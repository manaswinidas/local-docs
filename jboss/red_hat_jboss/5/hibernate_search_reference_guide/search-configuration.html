<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 3. Configuration</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="search-configuration">
      ⁠</a>Chapter 3. Configuration</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="search-configuration-directory">
      ⁠</a>3.1. Directory configuration</h1></div></div></div><div class="para">
			Apache Lucene has a notion of <code class="literal">Directory</code> to store the index files. The <code class="classname">Directory</code> implementation can be customized, but Lucene comes bundled with a file system (<code class="literal">FSDirectoryProvider</code>) and an in memory (<code class="literal">RAMDirectoryProvider</code>) implementation. <code class="literal">DirectoryProvider</code>s are the Hibernate Search abstraction around a Lucene <code class="classname">Directory</code> and handle the configuration and the initialization of the underlying Lucene resources. <a class="xref" href="search-configuration.html#directory-provider-table">Table 3.1, “List of built-in Directory Providers”</a> shows the list of the directory providers bundled with Hibernate Search.
		</div><div class="table"><a id="directory-provider-table">
      ⁠</a><p class="title"><strong>Table 3.1. List of built-in Directory Providers</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="List of built-in Directory Providers"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: center"> Class </th><th style="text-align: center"> Description </th><th style="text-align: center"> Properties </th></tr></thead><tbody><tr><td> org.hibernate.search.store.RAMDirectoryProvider </td><td> Memory based directory, the directory will be uniquely identified (in the same deployment unit) by the <code class="literal">@Indexed.index</code> element </td><td> none </td></tr><tr><td> org.hibernate.search.store.FSDirectoryProvider </td><td> File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt; </td><td> <div class="para">
							<code class="literal">indexBase</code> : Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr><tr><td> org.hibernate.search.store.FSMasterDirectoryProvider </td><td> <div class="para">
							File system based directory. Like FSDirectoryProvider. It also copies the index to a source directory (aka copy directory) on a regular basis.
						</div>
						 <div class="para">
							The recommended value for the refresh period is (at least) 50% higher than the time to copy the information (default 3600 seconds - 60 minutes).
						</div>
						 <div class="para">
							Note that the copy is based on an incremental copy mechanism reducing the average copy time.
						</div>
						 <div class="para">
							DirectoryProvider typically used on the master node in a JMS back end cluster.
						</div>
						 <div class="para">
							The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
						</div>
						 </td><td> <div class="para">
							<code class="literal">indexBase</code>: Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal">sourceBase</code>: Source (copy) base directory.
						</div>
						 <div class="para">
							<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
						</div>
						 <div class="para">
							<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
						</div>
						 <div class="para">
							<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr><tr><td> org.hibernate.search.store.FSSlaveDirectoryProvider </td><td> <div class="para">
							File system based directory. Like FSDirectoryProvider, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
						</div>
						 <div class="para">
							The recommended value for the refresh period is (at least) 50% higher than the time to copy the information (default 3600 seconds - 60 minutes).
						</div>
						 <div class="para">
							Note that the copy is based on an incremental copy mechanism reducing the average copy time.
						</div>
						 <div class="para">
							DirectoryProvider typically used on slave nodes using a JMS back end.
						</div>
						 <div class="para">
							The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
						</div>
						 </td><td> <div class="para">
							<code class="literal">indexBase</code>: Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal">sourceBase</code>: Source (copy) base directory.
						</div>
						 <div class="para">
							<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
						</div>
						 <div class="para">
							<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
						</div>
						 <div class="para">
							<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr></tbody></table></div></div><div class="para">
			If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <code class="classname">org.hibernate.store.DirectoryProvider</code> interface.
		</div><div class="para">
			Each indexed entity is associated to a Lucene index (an index can be shared by several entities but this is not usually the case). You can configure the index through properties prefixed by <code class="constant">hibernate.search.</code><em class="replaceable">indexname</em> . Default properties inherited to all indexes can be defined using the prefix <code class="constant">hibernate.search.default.</code>
		</div><div class="para">
			To define the directory provider of a given index, you use the <code class="constant">hibernate.search.<em class="replaceable">indexname</em>.directory_provider </code>
		</div><div class="example"><a id="idm140635535964368">
      ⁠</a><p class="title"><strong>Example 3.1. Configuring directory providers</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider org.hibernate.search.store.RAMDirectoryProvider</pre></div></div><div class="para">
			applied on
		</div><div class="example"><a id="idm140635535962256">
      ⁠</a><p class="title"><strong>Example 3.2. Specifying the index name using the <code class="literal">index</code> parameter of <code class="classname">@Indexed</code></strong></p><div class="example-contents"><pre class="programlisting">@Indexed(index="Status")
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }</pre></div></div><div class="para">
			will create a file system directory in <code class="filename">/usr/lucene/indexes/Status</code> where the Status entities will be indexed, and use an in memory directory named <code class="literal">Rules</code> where Rule entities will be indexed.
		</div><div class="para">
			You can easily define common rules like the directory provider and base directory, and override those defaults later on on a per index basis.
		</div><div class="para">
			Writing your own <code class="classname">DirectoryProvider</code>, you can utilize this configuration mechanism as well.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="search-configuration-directory-sharding">
      ⁠</a>3.2. Sharding indexes</h1></div></div></div><div class="para">
			In some extreme cases involving huge indexes (in size), it is necessary to split (shard) the indexing data of a given entity type into several Lucene indexes. This solution is not recommended until you reach significant index sizes and index update times are slowing the application down. The main drawback of index sharding is that searches will end up being slower since more files have to be opened for a single search. In other words do not do it until you have problems :)
		</div><div class="para">
			Despite this strong warning, Hibernate Search allows you to index a given entity type into several sub indexes. Data is sharded into the different sub indexes thanks to an <code class="classname">IndexShardingStrategy</code>. By default, no sharding strategy is enabled, unless the number of shards is configured. To configure the number of shards use the following property
		</div><div class="example"><a id="idm140635472418224">
      ⁠</a><p class="title"><strong>Example 3.3. Enabling index sharding by specifying nbr_of_shards for a specific index</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5</pre></div></div><div class="para">
			This will use 5 different shards.
		</div><div class="para">
			The default sharding strategy, when shards are set up, splits the data according to the hash value of the id string representation (generated by the Field Bridge). This ensures a fairly balanced sharding. You can replace the strategy by implementing <code class="literal">IndexShardingStrategy</code> and by setting the following property
		</div><div class="example"><a id="idm140635529674432">
      ⁠</a><p class="title"><strong>Example 3.4. Specifying a custom sharding strategy</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation</pre></div></div><div class="para">
			Each shard has an independent directory provider configuration as described in <a class="xref" href="search-configuration.html#search-configuration-directory">Section 3.1, “Directory configuration”</a>. The DirectoryProvider default name for the previous example are <code class="literal">&lt;indexName&gt;.0</code> to <code class="literal">&lt;indexName&gt;.4</code>. In other words, each shard has the name of it's owning index followed by <code class="constant">.</code> (dot) and its index number.
		</div><div class="example"><a id="idm140635529670784">
      ⁠</a><p class="title"><strong>Example 3.5. Configuring the sharding configuration for an example entity <code class="classname">Animal</code></strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase /usr/lucene/indexes

hibernate.search.Animal.sharding_strategy.nbr_of_shards 5
hibernate.search.Animal.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.Animal.0.indexName Animal00
hibernate.search.Animal.3.indexBase /usr/lucene/sharded
hibernate.search.Animal.3.indexName Animal03</pre></div></div><div class="para">
			This configuration uses the default id string hashing strategy and shards the Animal index into 5 subindexes. All subindexes are <code class="classname">FSDirectoryProvider</code> instances and the directory where each subindex is stored is as followed:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					for subindex 0: /usr/lucene/indexes/Animal00 (shared indexBase but overridden indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 1: /usr/lucene/indexes/Animal.1 (shared indexBase, default indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 2: /usr/lucene/indexes/Animal.2 (shared indexBase, default indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 3: /usr/lucene/shared/Animal03 (overridden indexBase, overridden indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 4: /usr/lucene/indexes/Animal.4 (shared indexBase, default indexName)
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635473726944">
      ⁠</a>3.3. Sharing indexes (two entities into the same directory)</h1></div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				This is only presented here so that you know the option is available. There is really not much benefit in sharing indexes.
			</div></div></div><div class="para">
			It is technically possible to store the information of more than one entity into a single Lucene index. There are two ways to accomplish this:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Configuring the underlying directory providers to point to the same physical index directory. In practice, you set the property <code class="literal">hibernate.search.[fully qualified entity name].indexName</code> to the same value. As an example let’s use the same index (directory) for the <code class="classname">Furniture</code> and <code class="classname">Animal</code> entity. We just set <code class="literal">indexName</code> for both entities to for example “Animal”. Both entities will then be stored in the Animal directory
				</div><div class="para">
					
<pre class="programlisting"><code class="code">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Aninal hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Aninal</code></pre>

				</div></li><li class="listitem"><div class="para">
					Setting the <code class="code">@Indexed</code> annotation’s <code class="methodname">index</code> attribute of the entities you want to merge to the same value. If we again wanted all <code class="classname">Furniture</code> instances to be indexed in the <code class="classname">Animal</code> index along with all instances of <code class="classname">Animal</code> we would specify <code class="code">@Indexed(index=”Animal”)</code> on both <code class="classname">Animal</code> and <code class="classname">Furniture</code> classes.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635530298432">
      ⁠</a>3.4. Worker configuration</h1></div></div></div><div class="para">
			It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. The work can be executed to the Lucene directory or sent to a JMS queue for later processing. When processed to the Lucene directory, the work can be processed synchronously or asynchronously to the transaction commit.
		</div><div class="para">
			You can define the worker configuration using the following properties
		</div><div class="table"><a id="idm140635530296400">
      ⁠</a><p class="title"><strong>Table 3.2. worker configuration</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="worker configuration"><colgroup><col style="text-align: center"/><col/></colgroup><tbody><tr><td style="text-align: center"> Property </td><td> Description </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.backend</code> </td><td> Out of the box support for the Apache Lucene back end and the JMS back end. Default to <code class="literal">lucene</code>. Supports also <code class="literal">jms</code>. </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.execution</code> </td><td> Supports synchronous and asynchronous execution. Default to <code class="literal"> <code class="literal">sync</code> </code>. Supports also <code class="literal">async</code>. </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.thread_pool.size</code> </td><td> Defines the number of threads in the pool. useful only for asynchronous execution. Default to 1. </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.buffer_queue.max</code> </td><td> Defines the maximal number of work queue if the thread poll is starved. Useful only for asynchronous execution. Default to infinite. If the limit is reached, the work is done by the main thread. </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.jndi.*</code> </td><td> Defines the JNDI properties to initiate the InitialContext (if needed). JNDI is only used by the JMS back end. </td></tr><tr><td style="text-align: center"> <code class="literal"> hibernate.search.worker.jms.connection_factory</code> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<code class="literal">/ConnectionFactory</code> by default in EAP) </td></tr><tr><td style="text-align: center"> <code class="literal">hibernate.search.worker.jms.queue</code> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages. </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jms-back_end">
      ⁠</a>3.5. JMS Master/Slave configuration</h1></div></div></div><div class="para">
			This section describes in greater detail how to configure the Master / Slaves Hibernate Search architecture.
		</div><div class="mediaobject" style="text-align: center"><img src="images/jms-backend.png" align="middle" width="250" alt="JMS Master/Slave configuration" style="text-align: middle"/><div class="caption"><div class="para">
				JMS Master/Slave architecture overview.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635502699872">
      ⁠</a>3.5.1. Slave nodes</h2></div></div></div><div class="para">
				Every index update operation is sent to a JMS queue. Index querying operations are executed on a local index copy.
			</div><div class="example"><a id="idm140635502698480">
      ⁠</a><p class="title"><strong>Example 3.6. JMS Slave configuration</strong></p><div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSSlaveDirectoryProvider

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.worker.execution = async
# hibernate.search.worker.thread_pool.size = 2
# hibernate.search.worker.buffer_queue.max = 50</pre></div></div><div class="para">
				A file system local copy is recommended for faster search results.
			</div><div class="para">
				The refresh period should be higher than the expected time copy.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635473584000">
      ⁠</a>3.5.2. Master node</h2></div></div></div><div class="para">
				Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis.
			</div><div class="example"><a id="idm140635473582608">
      ⁠</a><p class="title"><strong>Example 3.7. JMS Master configuration</strong></p><div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSMasterDirectoryProvider

## Backend configuration
#Backend is the default lucene one</pre></div></div><div class="para">
				The refresh period should be higher than the expected time copy.
			</div><div class="para">
				In addition to the Hibernate Search framework configuration, a Message Driven Bean should be written and set up to process the index works queue through JMS.
			</div><div class="example"><a id="idm140635473579616">
      ⁠</a><p class="title"><strong>Example 3.8. Message Driven Bean processing the indexing queue</strong></p><div class="example-contents"><pre class="programlisting">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController implements MessageListener {
    @PersistenceContext EntityManager em;
    
    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session) 
    }
}</pre></div></div><div class="para">
				This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a JavaEE 5 MDB. This implementation is given as an example and, while most likely be more complex, can be adjusted to make use of non Java EE Message Driven Beans. For more information about the <code class="methodname">getSession()</code> and <code class="methodname">cleanSessionIfNeeded()</code>, please check <code class="classname">AbstractJMSHibernateSearchController</code>'s javadoc.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuration-reader-strategy">
      ⁠</a>3.6. Reader strategy configuration</h1></div></div></div><div class="para">
			The different reader strategies are described in <a class="xref" href="search-architecture.html#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>. Out of the box strategies are:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">shared</code>: share index readers across several queries. This strategy is the most efficient.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">not-shared</code>: create an index reader for each individual query
				</div></li></ul></div><div class="para">
			The default reader strategy is <code class="literal">shared</code>. This can be adjusted:
		</div><pre class="programlisting">hibernate.search.reader.strategy = not-shared</pre><div class="para">
			Adding this property switches to the <code class="literal">not-shared</code> strategy.
		</div><div class="para">
			Or if you have a custom reader strategy:
		</div><pre class="programlisting">hibernate.search.reader.strategy = my.corp.myapp.CustomReaderProvider</pre><div class="para">
			where <code class="classname">my.corp.myapp.CustomReaderProvider</code> is the custom strategy implementation.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="search-configuration-event">
      ⁠</a>3.7. Enabling Hibernate Search and automatic indexing</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635511525200">
      ⁠</a>3.7.1. Enabling Hibernate Search</h2></div></div></div><div class="para">
				Hibernate Search is enabled out of the box when using Hibernate Annotations or Hibernate EntityManager. If, for some reason you need to disable it, set <code class="literal">hibernate.search.autoregister_listeners</code> to false. Note that there is no performance penalty when the listeners are enabled even though no entities are indexed.
			</div><div class="para">
				To enable Hibernate Search in Hibernate Core (ie. if you do not use Hibernate Annotations), add the <code class="literal">FullTextIndexEventListener</code> for the following six Hibernate events.
			</div><div class="example"><a id="idm140635525506864">
      ⁠</a><p class="title"><strong>Example 3.9. Explicitly enabling Hibernate Search by configuring the <code class="classname">FullTextIndexEventListener</code></strong></p><div class="example-contents"><pre class="programlisting">&lt;hibernate-configuration&gt;
     &lt;session-factory&gt;
        ...
        &lt;event type="post-update"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-insert"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-delete"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-recreate"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-remove"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-update"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635525504048">
      ⁠</a>3.7.2. Automatic indexing</h2></div></div></div><div class="para">
				By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search updates the according Lucene index. It is sometimes desirable to disable that features if either your index is read-only or if index updates are done in a batch way (see <a class="xref" href="search-batchindex.html">Chapter 6, <em>Manual indexing</em></a>).
			</div><div class="para">
				To disable event based indexing, set
			</div><pre class="programlisting">hibernate.search.indexing_strategy manual</pre><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					In most case, the JMS back end provides the best of both world, a lightweight event based system keeps track of all changes in the system, and the heavyweight indexing process is done by a separate process or machine.
				</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="lucene-indexing-performance">
      ⁠</a>3.8. Tuning Lucene indexing performance</h1></div></div></div><div class="para">
			Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code> and <code class="literal">maxBufferedDocs</code>. You can specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard.
		</div><div class="para">
			There are two sets of parameters allowing for different performance settings depending on the use case. During indexing operations triggered by database modifications, the parameters are grouped by the <code class="literal">transaction</code> keyword: 
<pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.transaction.&lt;parameter_name&gt;</pre>
			 When indexing occurs via <code class="literal">FullTextSession.index()</code> (see <a class="xref" href="search-batchindex.html">Chapter 6, <em>Manual indexing</em></a>), the used properties are those grouped under the <code class="literal">batch</code> keyword: 
<pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.&lt;parameter_name&gt;</pre>

		</div><div class="para">
			Unless the corresponding <code class="literal">.batch</code> property is explicitly set, the value will default to the <code class="literal">.transaction</code> property. If no value is set for a <code class="literal">.batch</code> value in a specific shard configuration, Hibernate Search will look at the index section, then at the default section and after that it will look for a <code class="literal">.transaction</code> in the same order: 
<pre class="programlisting">hibernate.search.Animals.2.indexwriter.transaction.max_merge_docs 10
hibernate.search.Animals.2.indexwriter.transaction.merge_factor 20
hibernate.search.default.indexwriter.batch.max_merge_docs 100</pre>
			 This configuration will result in these settings applied to the second shard of Animals index:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">transaction.max_merge_docs</code> = 10
				</div></li><li class="listitem"><div class="para">
					<code class="literal">batch.max_merge_docs</code> = 100
				</div></li><li class="listitem"><div class="para">
					<code class="literal">transaction.merge_factor</code> = 20
				</div></li><li class="listitem"><div class="para">
					<code class="literal">batch.merge_factor</code> = 20
				</div></li></ul></div><div class="para">
			All other values will use the defaults defined in Lucene.
		</div><div class="para">
			The default for all values is to leave them at Lucene's own default, so the listed values in the following table actually depend on the version of Lucene you are using; values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performances, please refer to the Lucene documentation.
		</div><div class="table"><a id="idm140635475064016">
      ⁠</a><p class="title"><strong>Table 3.3. List of indexing performance and behavior properties</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="List of indexing performance and behavior properties"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: center"> Property </th><th style="text-align: center"> Description </th><th style="text-align: center"> Default Value </th></tr></thead><tbody><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_delete_terms</code> </td><td> <div class="para">
							Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
						</div>
						 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_docs</code> </td><td> <div class="para">
							Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
						</div>
						 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_field_length</code> </td><td> <div class="para">
							The maximum number of terms that will be indexed for a single field. This limits the amount of memory required for indexing so that very large data will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.
						</div>
						 <div class="para">
							This silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accommodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.
						</div>
						 <div class="para">
							If setting this value in <code class="literal">batch</code> differently than in <code class="literal">transaction</code> you may get different data (and results) in your index depending on the indexing mode.
						</div>
						 </td><td> 10000 </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_merge_docs</code> </td><td> <div class="para">
							Defines the largest number of documents allowed in a segment. Larger values are best for batched indexing and speedier searches. Small values are best for transaction indexing.
						</div>
						 </td><td> Unlimited (Integer.MAX_VALUE) </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].merge_factor</code> </td><td> <div class="para">
							Controls segment merge frequency and size.
						</div>
						 <div class="para">
							Determines how often segment indices are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. The value must no be lower than 2.
						</div>
						 </td><td> 10 </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].ram_buffer_size</code> </td><td> <div class="para">
							Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
						</div>
						 <div class="para">
							Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
						</div>
						 </td><td> 16 MB </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].term_index_interval</code> </td><td> <div class="para">
							Expert: Set the interval between indexed terms.
						</div>
						 <div class="para">
							Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
						</div>
						 </td><td> 128 </td></tr><tr><td> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].use_compound_file</code> </td><td> The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large. 
						<div class="para">

						</div>
						 <div class="para">
							Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
						</div>
						 </td><td> true </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="search-configuration-directory-lockfactories">
      ⁠</a>3.9. LockFactory configuration</h1></div></div></div><div class="para">
			Lucene Directories have default locking strategies which work well for most cases, but it's possible to specify for each index managed by Hibernate Search which LockingFactory you want to use.
		</div><div class="para">
			Some of these locking strategies require a file system level lock and may be used even on RAM based indexes, but this is not recommended and of no practical use.
		</div><div class="para">
			To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to one of <code class="literal">simple</code>, <code class="literal">native</code>, <code class="literal">single</code> or <code class="literal">none</code>, or set it to the fully qualified name of an implementation of <code class="literal">org.hibernate.search.store.LockFactoryFactory</code>; Implementing this interface you can provide a custom <code class="literal">org.apache.lucene.store.LockFactory</code>.
		</div><div class="table"><a id="search-configuration-directory-lockfactories-table">
      ⁠</a><p class="title"><strong>Table 3.4. List of available LockFactory implementations</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="List of available LockFactory implementations"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: center"> name </th><th style="text-align: center"> Class </th><th style="text-align: center"> Description </th></tr></thead><tbody><tr><td> simple </td><td> org.apache.lucene.store.SimpleFSLockFactory </td><td> <div class="para">
							Safe implementation based on Java's File API, it marks the usage of the index by creating a marker file.
						</div>
						 <div class="para">
							If for some reason you had to kill your application, you will need to remove this file before restarting it.
						</div>
						 <div class="para">
							This is the default implementation for <code class="literal">FSDirectoryProvider</code>,<code class="literal">FSMasterDirectoryProvider</code> and <code class="literal">FSSlaveDirectoryProvider</code>.
						</div>
						 </td></tr><tr><td> native </td><td> org.apache.lucene.store.NativeFSLockFactory </td><td> <div class="para">
							As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if your application crashes the locks will be cleaned up.
						</div>
						 <div class="para">
							This implementation has known problems on NFS.
						</div>
						 </td></tr><tr><td> single </td><td> org.apache.lucene.store.SingleInstanceLockFactory </td><td> <div class="para">
							This LockFactory does not use a file marker but is a Java object lock held in memory; therefore it is possible to use it only when you are sure the index is not going to be shared by any other process.
						</div>
						 <div class="para">
							This is the default implementation for <code class="literal">RAMDirectoryProvider</code>.
						</div>
						 </td></tr><tr><td> none </td><td> org.apache.lucene.store.NoLockFactory </td><td> <div class="para">
							All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means.
						</div>
						 </td></tr></tbody></table></div></div><div class="para">
			Configuration example:
		</div><pre class="programlisting">hibernate.search.default.locking_strategy simple
hibernate.search.Animals.locking_strategy native
hibernate.search.Books.locking_strategy org.custom.components.MyLockingFactory</pre></div></div></body></html>