<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 14. JAX-RS Resource Locators and Sub Resources</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="JAX-RS_Resource_Locators_and_Sub_Resources">
      ⁠</a>Chapter 14. JAX-RS Resource Locators and Sub Resources</h1></div></div></div><div class="para">
		Resource classes can partially process a request and then provide another <span class="emphasis"><em>sub-resource</em></span> object to process the remainder of the request. For example:
	</div><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public Customer getCustomer(@PathParam("id") int id) {
      Customer cust = ...; // Find a customer object
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

</pre><div class="para">
		Resource methods with a <code class="literal">@Path</code> annotation and no HTTP method are considered <span class="emphasis"><em>sub-resource locators</em></span>. They provide an object that can process the request. In the previous example code, <code class="literal">ShoppingStore</code> is a root resource because its class is annotated with <code class="literal">@Path</code>. The <code class="literal">getCustomer()</code> is a sub-resource locator method.
	</div><div class="para">
		If the client invoked the following:
	</div><pre class="programlisting">GET /customer/123</pre><div class="para">
		Then the <code class="literal">ShoppingStore.getCustomer()</code> method would be invoked first. This method provides a <code class="literal">Customer</code> object that can service the request. The HTTP request will be dispatched to the <code class="literal">Customer.get()</code> method. Another example is:
	</div><pre class="programlisting">GET /customer/123/address</pre><div class="para">
		In this request, again, first the <code class="literal">ShoppingStore.getCustomer()</code> method is invoked. A <code class="literal">Customer</code> object is returned, and the rest of the request is dispatched to the <code class="literal">Customer.getAddress()</code> method.
	</div><div class="para">
		Another interesting feature of sub-resource locators is that the locator method result is dynamically processed at runtime in order to determine how the request should be dispatched. This means that the <code class="literal">ShoppingStore.getCustomer()</code> method does not have to declare any specific type.
	</div><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = ...; // Find a customer object
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

</pre><div class="para">
		In the previous example, <code class="literal">getCustomer()</code> returns a <code class="literal">java.lang.Object</code>. Per request, at runtime, the JAX-RS server will determine how to dispatch the request based on the object returned by <code class="literal">getCustomer()</code>. This can be useful in certain situations.
	</div><div class="para">
		For example, say you have a class hierarchy for your customers. <code class="literal">Customer</code> is the abstract base, and <code class="literal">CorporateCustomer</code> and <code class="literal">IndividualCustomer</code> are subclasses. In this case, your <code class="literal">getCustomer()</code> method might perform a Hibernate polymorphic query without requiring any understanding of the concrete class it queries, or the content returned.
	</div><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = entityManager.find(Customer.class, id);
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

public class CorporateCustomer extendsCustomer {
   
    @Path("/businessAddress")
    public String getAddress() {...}

}

</pre></div></body></html>