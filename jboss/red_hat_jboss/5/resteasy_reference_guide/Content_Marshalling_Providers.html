<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 16. Content Marshalling/Providers</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Content_Marshalling_Providers">
      ⁠</a>Chapter 16. Content Marshalling/Providers</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Default_Providers_and_default_JAX-RS_Content_Marshalling">
      ⁠</a>16.1. Default Providers and default JAX-RS Content Marshalling</h1></div></div></div><div class="para">
			RESTEasy can automatically marshal and unmarshal several different message body types.
		</div><div class="table"><a id="idm140379123011616">
      ⁠</a><p class="title"><strong>Table 16.1. Message Body Types</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Message Body Types"><colgroup><col/><col/></colgroup><thead><tr><th> Media Types </th><th> Java Type </th></tr></thead><tbody><tr><td> application/*+xml, text/*+xml, application/*+json, application/*+fastinfoset, application/atom+* </td><td> JaxB annotated classes </td></tr><tr><td> */* </td><td> java.lang.String </td></tr><tr><td> */* </td><td> java.io.InputStream </td></tr><tr><td> text/plain </td><td> primitives, java.lang.String, or any type that has a String constructor, or static valueOf(String) method for input, toString() for output </td></tr><tr><td> */* </td><td> javax.activation.DataSource </td></tr><tr><td> */* </td><td> java.io.File </td></tr><tr><td> */* </td><td> byte[] </td></tr><tr><td> application/x-www-form-urlencoded </td><td> javax.ws.rs.core.MultivaluedMap </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Content_Marshalling_with__Provider_classes">
      ⁠</a>16.2. Content Marshalling with @Provider classes</h1></div></div></div><div class="para">
			The JAX-RS specification lets you plug in your own readers and writers for request or response bodies. To do so, annotate a class with <code class="literal">@Provider</code> and specify the <code class="literal">@Produces</code> types for a reader. You must also implement a <code class="literal">MessageBodyReader</code> and a <code class="literal">MessageBodyWriter</code> interface. 
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="MessageBodyWorkers">
      ⁠</a>16.3. Providers Utility Class</h1></div></div></div><div class="para">
			<code class="literal">javax.ws.rs.ext.Providers</code> is a simple injectable interface that lets you locate <code class="literal">MessageBodyReader</code>s, <code class="literal">MessageBodyWriter</code>s, <code class="literal">ContextResolver</code>s and <code class="literal">ExceptionMapper</code>s. It also lets you implement multi-part providers (content types that embed other content types).
		</div><pre class="programlisting">
public interface Providers
{

   /**
    * Get a message body reader that matches a set of criteria. The set of
    * readers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each reader's
    * {@link javax.ws.rs.Consumes}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching readers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Consumes} (x/y &gt; x/* &gt; */*)
    * sorted first. Finally, the
    * {@link MessageBodyReader#isReadable}
    * method is called on each reader in order using the supplied criteria and
    * the first reader that returns {@code true} is selected and returned.
    *
    * @param type        the class of object that is to be written.
    * @param mediaType   the media type of the data that will be read.
    * @param genericType the type of object to be produced. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the formal type of the method parameter as returned by
    *                    &lt;code&gt;Class.getGenericParameterTypes&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be initialized with the produced instance. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the annotations on that parameter returned by
    *                    &lt;code&gt;Class.getParameterAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyReader&lt;T&gt; getMessageBodyReader(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get a message body writer that matches a set of criteria. The set of
    * writers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each writer's
    * {@link javax.ws.rs.Produces}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching writers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x/* &gt; */*)
    * sorted first. Finally, the
    * {@link MessageBodyWriter#isWriteable}
    * method is called on each writer in order using the supplied criteria and
    * the first writer that returns {@code true} is selected and returned.
    *
    * @param mediaType   the media type of the data that will be written.
    * @param type        the class of object that is to be written.
    * @param genericType the type of object to be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the declared type of the field as returned by
    *                    &lt;code&gt;Field.getGenericType&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the annotations on that field returned by
    *                    &lt;code&gt;Field.getDeclaredAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyWriter&lt;T&gt; getMessageBodyWriter(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get an exception mapping provider for a particular class of exception.
    * Returns the provider whose generic type is the nearest superclass of
    * {@code type}.
    *
    * @param type the class of exception
    * @return an {@link ExceptionMapper} for the supplied type or null if none
    *         is found.
    */
   &lt;T extends Throwable&gt; ExceptionMapper&lt;T&gt; getExceptionMapper(Class&lt;T&gt; type);

   /**
    * Get a context resolver for a particular type of context and media type.
    * The set of resolvers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each resolver's
    * {@link javax.ws.rs.Produces}, ensuring the generic type of the context
    * resolver is assignable to the supplied value of {@code contextType}, and
    * eliminating those that do not match. If only one resolver matches the
    * criteria then it is returned. If more than one resolver matches then the
    * list of matching resolvers is ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x/* &gt; */*)
    * sorted first. A proxy is returned that delegates calls to
    * {@link ContextResolver#getContext(java.lang.Class)} to each matching context
    * resolver in order and returns the first non-null value it obtains or null
    * if all matching context resolvers return null.
    *
    * @param contextType the class of context desired
    * @param mediaType   the media type of data for which a context is required.
    * @return a matching context resolver instance or null if no matching
    *         context providers are found.
    */
   &lt;T&gt; ContextResolver&lt;T&gt; getContextResolver(Class&lt;T&gt; contextType,
                                             MediaType mediaType);
}
</pre><div class="para">
			You can inject an instance of <code class="literal">Providers</code> into <code class="literal">MessageBodyReader</code> or <code class="literal">MessageBodyWriter</code> like so:
		</div><pre class="programlisting">
            @Provider
            @Consumes("multipart/fixed")
            public class MultipartProvider implements MessageBodyReader {

            private @Context Providers providers;

            ...

            }
</pre></div></div></body></html>