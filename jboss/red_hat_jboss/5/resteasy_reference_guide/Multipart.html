<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 20. Multipart Providers</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Multipart">
      ⁠</a>Chapter 20. Multipart Providers</h1></div></div></div><div class="para">
		RESTEasy has rich support for the <code class="literal">multipart/*</code> and <code class="literal">multipart/form-data</code> MIME (Multipurpose Internet Mail Extension) types. The <code class="literal">multipart</code> MIME format passes lists of content bodies. Multiple content bodies are embedded in the one message. <code class="literal">multipart/form-data</code> is often found in web application HTML Form documents, and is generally used to upload files. The <code class="literal">form-data</code> format works like other <code class="literal">multipart</code> formats, except that each inlined piece of content has a name associated with it.
	</div><div class="para">
		RESTEasy provides a custom API for reading and writing <code class="literal">multipart</code> types, as well as marshaling arbitrary List (for any <code class="literal">multipart</code> type) and Map (<code class="literal">multipart/form-data</code> only) objects.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="MultipartInput">
      ⁠</a>20.1. Input with multipart/mixed</h1></div></div></div><div class="para">
			When you write a JAX-RS service, RESTEasy provides an interface to let you read any <code class="literal">multipart</code> MIME type: <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartInput</code>.
		</div><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public interface MultipartInput
{
   List&lt;InputPart&gt; getParts();

   String getPreamble();
}

public interface InputPart
{
   MultivaluedMap&lt;String, String&gt; getHeaders();

   String getBodyAsString();

   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;

   &lt;T&gt; T getBody(org.jboss.resteasy.util.GenericType&lt;T&gt; type) throws IOException;

   MediaType getMediaType();
}
</pre><div class="para">
			<code class="literal">MultipartInput</code> is a simple interface that lets you access each part of the <code class="literal">multipart</code> message. Each part is represented by an <code class="literal">InputPart</code> interface, and is associated with a set of headers. You can unmarshal a part by calling one of the <code class="literal">getBody()</code> methods. The <code class="literal">Type genericType</code> parameter can be null, but the <code class="literal">Class type</code> parameter must be set. RESTEasy locates a <code class="literal">MessageBodyReader</code> based on the media type of the part, and the type information you pass in. The following piece of code unmarshals XML parts into a JAXB annotated class called <code class="literal">Customer</code>.
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         List&lt;Customer&gt; customers = new ArrayList...;
         for (InputPart part : input.getParts())
         {
            Customer cust = part.getBody(Customer.class, null);
            customers.add(cust);
         }
      }
   }
</pre><div class="para">
			If you want to unmarshal a body part that is sensitive to generic type metadata, you can use the <code class="literal">org.jboss.resteasy.util.GenericType</code> class, like so:
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         for (InputPart part : input.getParts())
         {
            List&lt;Customer&gt; cust = part.getBody(new GenericType&gt;List&gt;Customer&lt;&lt;() {});
         }
      }
   }

</pre><div class="para">
			<code class="literal">GenericType</code> is required here because it is the only way to obtain generic type information at runtime.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_list">
      ⁠</a>20.2. java.util.List with multipart data</h1></div></div></div><div class="para">
			If the body parts are uniform, you can provide a <code class="literal">java.util.List</code> as your input parameter and avoid unmarshaling each part manually. As you can see in the example code below, this must include the type being unmarshaled with the generic parameter of the List type declaration.
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(List&lt;Customer&gt; customers)
      {
         ...
      }
   }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="MultipartFormData">
      ⁠</a>20.3. Input with multipart/form-data</h1></div></div></div><div class="para">
			When you write a JAX-RS service, RESTEasy provides an interface that lets you read the <code class="literal">multipart/form-data</code> MIME type. <code class="literal">multipart/form-data</code> is often found in web application HTML Form documents, and is generally used to upload files. The <code class="literal">form-data</code> format is like other <code class="literal">multipart</code> formats except that each inlined piece of content is associated with a name. The interface for <code class="literal">form-data</code> input is <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartFormDataInput</code>.
		</div><pre class="programlisting">
public interface MultipartFormDataInput extends MultipartInput
{
   @Deprecated
   Map&lt;String, InputPart&gt; getFormData();

   Map&lt;String, List&lt;InputPart&gt;&gt; getFormDataMap();

   &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType) throws IOException;

   &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
}
</pre><div class="para">
			This works similarly to <code class="literal">MultipartInput</code>, as described earlier in this chapter.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_map">
      ⁠</a>20.4. java.util.Map with multipart/form-data</h1></div></div></div><div class="para">
			With <code class="literal">form-data</code>, if the body parts are uniform, you can provide a <code class="literal">java.util.Map</code> as your input parameter and avoid unmarshaling each part manually. As you can see in the example code below, this must include the type being unmarshaled with the generic parameter of the List type declaration.
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/form-data")
      public void put(Map&lt;String, Customer&gt; customers)
      {
         ...
      }
   }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="MultipartRelated">
      ⁠</a>20.5. Input with multipart/related</h1></div></div></div><div class="para">
			When you write a JAX-RS service, RESTEasy provides an interface that lets you read the <code class="literal">multipart/related</code> MIME type. <code class="literal">multipart/related</code> indicates that message parts should be considered as parts of a whole, and not individually. You can use <code class="literal">multipart/related</code> to perform tasks like sending a web page complete with images in a single message.
		</div><div class="para">
			Every <code class="literal">multipart/related</code> message has a <code class="literal">root/start</code> part that references other parts of the message. Parts are identified by their <code class="literal">Content-ID</code> headers. <code class="literal">multipart/related</code> is defined by RFC 2387. The interface for <code class="literal">related</code> input is <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartRelatedInput</code>.
		</div><pre class="programlisting">
public interface MultipartRelatedInput extends MultipartInput
{
   String getType();

   String getStart();

   String getStartInfo();

   InputPart getRootPart();

   Map&lt;String, InputPart&gt; getRelatedMap();
}
</pre><div class="para">
			It works similarly to <code class="literal">MultipartInput</code>, as described earlier in this chapter.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_output">
      ⁠</a>20.6. Output with multipart</h1></div></div></div><div class="para">
			RESTEasy provides a simple API to output multipart data.
		</div><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartOutput
{
   public OutputPart addPart(Object entity, MediaType mediaType)

   public OutputPart addPart(Object entity, GenericType type, MediaType mediaType)

   public OutputPart addPart(Object entity, Class type, Type genericType, MediaType mediaType)

   public List&lt;OutputPart&gt; getParts()

   public String getBoundary()

   public void setBoundary(String boundary)
}

public class OutputPart
{
   public MultivaluedMap&lt;String, Object&gt; getHeaders()

   public Object getEntity()

   public Class getType()

   public Type getGenericType()

   public MediaType getMediaType()
}

</pre><div class="para">
			To output <code class="literal">multipart</code> data, create a <code class="literal">MultipartOutput</code> object and call <code class="literal">addPart()</code> methods. RESTEasy automatically finds a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. As with <code class="literal">MultipartInput</code>, your marshaling may be sensitive to generic type metadata. In this case, use <code class="literal">GenericType</code>. The following example returns a <code class="literal">multipart/mixed</code> format to the calling client. The parts are JAXB-annotated <code class="literal">Customer</code> objects that will marshal into <code class="literal">application/xml</code>.
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      public MultipartOutput get()
      {
         MultipartOutput output = new MultipartOutput();
         output.addPart(new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart(new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_list_output">
      ⁠</a>20.7. Multipart Output with java.util.List</h1></div></div></div><div class="para">
			If the body parts are uniform, you can provide a <code class="literal">java.util.Map</code> as your input parameter and avoid unmarshaling each part manually or using a <code class="literal">MultipartOutput</code> object. As you can see in the example code below, this must include the type being unmarshaled with the generic parameter of the List type declaration. You must also annotate the method with <code class="literal">@PartType</code> to specify each part's media type. The following example returns a customer list to a client, where each customer is a JAXB object:
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      @PartType("application/xml")
      public List&lt;Customer&gt; get()
      {
         ...
      }
   }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_formdata_output">
      ⁠</a>20.8. Output with multipart/form-data</h1></div></div></div><div class="para">
			RESTEasy provides a simple API to output multipart/form-data.
		</div><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartFormDataOutput extends MultipartOutput
{
   public OutputPart addFormData(String key, Object entity, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, GenericType type, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, Class type, Type genericType, MediaType mediaType)

   public Map&lt;String, OutputPart&gt; getFormData()
}

</pre><div class="para">
			To output <code class="literal">multipart/form-data</code>, create a <code class="literal">MultipartFormDataOutput</code> object and call <code class="literal">addFormData()</code> methods. RESTEasy automatically locates a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. As with <code class="literal">MultipartInput</code>, your marshaling may be sensitive to generic type metadata. In this case, use <code class="literal">GenericType</code>. The example below returns a <code class="literal">multipart/form-data</code> format to a calling client. The parts are JAXB-annotated <code class="literal">Customer</code> objects, which will be marshaled into <code class="literal">application/xml</code>.
		</div><pre class="programlisting">
   @Path("/form")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      public MultipartFormDataOutput get()
      {
         MultipartFormDataOutput output = new MultipartFormDataOutput();
         output.addPart("bill", new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart("monica", new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_map_output">
      ⁠</a>20.9. Multipart FormData Output with java.util.Map</h1></div></div></div><div class="para">
			If the body parts are uniform, you can provide a <code class="literal">java.util.Map</code> as your input parameter and avoid unmarshaling each part manually or using a <code class="literal">MultipartFormDataOutput</code> object. As you can see in the example code below, this must include the type being unmarshaled with the generic parameter of the List type declaration. You must also annotate the method with <code class="literal">@PartType</code> to specify each part's media type. This example returns a customer list to a client, where each customer is a JAXB object.
		</div><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      @PartType("application/xml")
      public Map&lt;String, Customer&gt; get()
      {
         ...
      }
   }

</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipart_related_output">
      ⁠</a>20.10. Output with multipart/related</h1></div></div></div><div class="para">
			RESTEasy provides a simple API to output <code class="literal">multipart/related</code>.
		</div><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartRelatedOutput extends MultipartOutput
{
   public OutputPart getRootPart()

   public OutputPart addPart(Object entity, MediaType mediaType,
      String contentId, String contentTransferEncoding)

   public String getStartInfo()

   public void setStartInfo(String startInfo)
}
</pre><div class="para">
			To output <code class="literal">multipart/related</code>, create a <code class="literal">MultipartRelatedOutput</code> object and call <code class="literal">addPart()</code> methods. The first added part is used as the root part of the <code class="literal">multipart/related</code> message. RESTEasy automatically locates a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. As with <code class="literal">MultipartInput</code>, your marshaling may be sensitive to generic type metadata. In this case, use <code class="literal">GenericType</code>. The example below returns a <code class="literal">multipart/related</code> format to the calling client — a HTML file with two images.
		</div><pre class="programlisting">
@Path("/related")
public class MyService
{
   @GET
   @Produces("multipart/related")
   public MultipartRelatedOutput get()
   {
      MultipartRelatedOutput output = new MultipartRelatedOutput();
      output.setStartInfo("text/html");

      Map&lt;String, String&gt; mediaTypeParameters = new LinkedHashMap&lt;String, String&gt;();
      mediaTypeParameters.put("charset", "UTF-8");
      mediaTypeParameters.put("type", "text/html");
      output
         .addPart(
            "&lt;html&gt;&lt;body&gt;\n"
            + "This is me: &lt;img src='cid:http://example.org/me.png' /&gt;\n"
            + "&lt;br /&gt;This is you: &lt;img src='cid:http://example.org/you.png' /&gt;\n"
            + "&lt;/body&gt;&lt;/html&gt;",
            new MediaType("text", "html", mediaTypeParameters),
            "&lt;mymessage.xml@example.org&gt;", "8bit");
      output.addPart("// binary octets for me png",
            new MediaType("image", "png"), "&lt;http://example.org/me.png&gt;",
            "binary");
      output.addPart("// binary octets for you png", new MediaType(
            "image", "png"),
            "&lt;http://example.org/you.png&gt;", "binary");
      client.putRelated(output);
      return output;
   }
}
</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="multipartform_annotation">
      ⁠</a>20.11. @MultipartForm and POJOs</h1></div></div></div><div class="para">
			If you are familiar with your <code class="literal">multipart/form-data</code> packets, you can map them to and from a POJO class with the <code class="literal">@org.jboss.resteasy.annotations.providers.multipart.MultipartForm</code> annotation and the <code class="literal">@FormParam</code> JAX-RS annotation. To do so, define a POJO with a default constructor (at least), and annotate its fields, properties, or both, with <code class="literal">@FormParam</code>s. These <code class="literal">@FormParam</code>s must also be annotated with <code class="literal">@org.jboss.resteasy.annotations.providers.multipart.PartType</code> to be output. For example:
		</div><pre class="programlisting">
   public class CustomerProblemForm {
      @FormData("customer")
      @PartType("application/xml")
      private Customer customer;

      @FormData("problem")
      @PartType("text/plain")
      private String problem;

      public Customer getCustomer() { return customer; }
      public void setCustomer(Customer cust) { this.customer = cust; }
      public String getProblem() { return problem; }
      public void setProblem(String problem) { this.problem = problem; }
   }
</pre><div class="para">
			Once you have defined your POJO class, you can use it to represent <code class="literal">multipart/form-data</code>. The following code sends a <code class="literal">CustomerProblemForm</code> using the RESTEasy client framework:
		</div><pre class="programlisting">
   @Path("portal")
   public interface CustomerPortal {

      @Path("issues/{id}")
      @Consumes("multipart/form-data")
      @PUT
      public void putProblem(@MultipartForm CustomerProblemForm,
                             @PathParam("id") int id);
   }

   {
       CustomerPortal portal = ProxyFactory.create(CustomerPortal.class, "http://example.com");
       CustomerProblemForm form = new CustomerProblemForm();
       form.setCustomer(...);
       form.setProblem(...);

       portal.putProblem(form, 333);
   }
</pre><div class="para">
			Note that the <code class="literal">@MultipartForm</code> annotation tells RESTEasy that the object has <code class="literal">@FormParam</code>, and that it should be marshaled from that parameter. You can use the same object to receive <code class="literal">multipart</code> data. Here is an example of the server-side counterpart to the customer portal.
		</div><pre class="programlisting">
   @Path("portal")
   public class CustomerPortalServer {

      @Path("issues/{id})
      @Consumes("multipart/form-data")
      @PUT
      public void putIssue(@MultipartForm CustomerProblemForm,
                           @PathParam("id") int id) {
         ... write to database...
      }
   }
</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="xop_with_multipart_related">
      ⁠</a>20.12. XML-binary Optimized Packaging (Xop)</h1></div></div></div><div class="para">
			RESTEasy supports packaging XOP (XML-binary Optimized Packaging) messages as <code class="literal">multipart/related</code>. This means that if you have a JAXB-annotated POJO that also holds some binary content, you can send it without needing to encode the binary in any other way. This results in faster transport while retaining the convenience of the POJO. (You can read more about XOP at the <a href="http://www.w3.org/TR/xop10/">W3C web page</a>.)
		</div><div class="para">
			Take the following JAXB-annotated POJO as an example. <code class="literal">@XmlMimeType</code> tells JAXB the MIME type of the binary content. (This is not required, but it is recommended.)
		</div><pre class="programlisting">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Xop {
  private Customer bill;

  private Customer monica;

  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
  private byte[] myBinary;

  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
  private DataHandler myDataHandler;

  // methods, other fields ...
}
</pre><div class="para">
			Here, <code class="literal">myBinary</code> and <code class="literal">myDataHandler</code> are processed as binary attachments, while the XOP object will be sent as XML. <code class="literal">javax.activation.DataHandler</code> is the most common supported type, so if you need a <code class="literal">java.io.InputStream</code> or a <code class="literal">javax.activation.DataSource</code>, you must use the <code class="literal">DataHandler</code>. <code class="literal">java.awt.Image</code> and <code class="literal">javax.xml.transform.Source</code> are also supported. We assume, in the previous example, that <code class="literal">Customer</code> is a JAXB-friendly POJO. The following is an example Java client to send the previous example:
		</div><pre class="programlisting">
// our client interface:
@Path("mime")
public static interface MultipartClient {
  @Path("xop")
  @PUT
  @Consumes(MediaType.MULTIPART_RELATED)
  public void putXop(@XopWithMultipartRelated Xop bean);
}

// Somewhere using it:
{
  MultipartClient client = ProxyFactory.create(MultipartClient.class,
    "http://www.example.org");
  Xop xop = new Xop(new Customer("bill"), new Customer("monica"),
    "Hello Xop World!".getBytes("UTF-8"),
    new DataHandler(new ByteArrayDataSource("Hello Xop World!".getBytes("UTF-8"),
    MediaType.APPLICATION_OCTET_STREAM)));
  client.putXop(xop);
}
</pre><div class="para">
			<code class="literal">@Consumes(MediaType.MULTIPART_RELATED)</code> tells RESTEasy that we want to send <code class="literal">multipart/related</code> packages, a format that will hold our XOP message. <code class="literal">@XopWithMultipartRelated</code> tells RESTEasy that we want to create XOP messages. Now that we have a POJO and a client service capable of sending it, we need a server capable of reading it:
		</div><pre class="programlisting">
@Path("/mime")
public class XopService {
  @PUT
  @Path("xop")
  @Consumes(MediaType.MULTIPART_RELATED)
  public void putXopWithMultipartRelated(@XopWithMultipartRelated Xop xop) {
    // do very important things here
  }
}
</pre><div class="para">
			<code class="literal">@Consumes(MediaType.MULTIPART_RELATED)</code> tells RESTEasy that we want to read <code class="literal">multipart/related</code> packages. <code class="literal">@XopWithMultipartRelated</code> tells RESTEasy that we want to read XOP messages. We could also produce XOP return values by annotating them with <code class="literal">@Produce</code>.
		</div></div></div></body></html>