<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 17. JAXB Providers</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Built_in_JAXB_providers">
      ⁠</a>Chapter 17. JAXB Providers</h1></div></div></div><div class="para">
		RESTEasy includes support for marshaling and unmarshaling JAXB annotated classes. Multiple JAXB Providers are included with RESTEasy to address the subtle differences between classes generated by XJC and classes that are annotated with <code class="literal">@XmlRootElement</code>, or work with <code class="literal">JAXBElement</code> classes directly.
	</div><div class="para">
		When using the JAX-RS API in development, the provider to be invoked is selected transparently. This chapter describes the providers best-suited for a variety of configurations if you want to access the providers <span class="emphasis"><em>directly</em></span>.
	</div><div class="para">
		RESTEasy selects a JAXB Provider when a parameter type (return type) is an object annotated with JAXB annotations (for example, <code class="literal">@XmlRootEntity</code> or <code class="literal">@XmlType</code>), or a <code class="literal">JAXBElement</code>. The resource class (resource method) will be annotated with either <code class="literal">@Consumes</code> or <code class="literal">@Produces</code>, and contain one or more of the following values:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				<code class="literal">text/*+xml</code>
			</div></li><li class="listitem"><div class="para">
				<code class="literal">application/*+xml</code>
			</div></li><li class="listitem"><div class="para">
				<code class="literal">application/*+fastinfoset</code>
			</div></li><li class="listitem"><div class="para">
				<code class="literal">application/*+json</code>
			</div></li></ul></div><div class="para">
		RESTEasy selects different providers based on the return type used in the resource. This section describes the workings of the selection process.
	</div><div class="para">
		Classes annotated with <code class="literal">@XmlRootElement</code> are handled with the <code class="literal">JAXBXmlRootElementProvider</code>. This provider handles basic marshaling and unmarshaling of custom JAXB entities.
	</div><div class="para">
		Classes that are generated by XJC do not usually contain an <code class="literal">@XmlRootElement</code> annotation. To be marshaled, they must be wrapped in an instance of <code class="literal">JAXBElement</code>. This usually involves invoking a method named <code class="literal">ObjectFactory</code> on the class, which serves as the <code class="literal">XmlRegistry</code>.
	</div><div class="para">
		The <code class="literal">JAXBXmlTypeProvider</code> provider is selected when the class is annotated with an <code class="literal">XmlType</code> annotation and not an <code class="literal">XmlRootElement</code> annotation. The provider attempts to locate the <code class="literal">XmlRegistry</code> for the target class. By default, a JAXB implementation creates a class called <code class="literal">ObjectFactory</code> and is located in the same package as the target class. <code class="literal">ObjectFactory</code> contains a <code class="literal">create</code> method that takes the object instance as a parameter. For example, if the target type is called <code class="literal">Contact</code>, then the <code class="literal">ObjectFactory</code> class will have a method:
	</div><pre class="programlisting">
      public JAXBElement createContact(Contact value) {..
</pre><div class="para">
		If your resource works with the <code class="literal">JAXBElement</code> class directly, the RESTEasy runtime will select the <code class="literal">JAXBElementProvider</code>. This provider examines the <code class="literal">ParameterizedType</code> value of the <code class="literal">JAXBElement</code> in order to select the appropriate <code class="literal">JAXBContext</code>.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="decorators">
      ⁠</a>17.1. JAXB Decorators</h1></div></div></div><div class="para">
			RESTEasy's JAXB providers can decorate <code class="literal">marshaler</code> and <code class="literal">Unmarshaler</code> instances. Add an annotation that triggers the decoration <code class="literal">marshaler</code> or <code class="literal">Unmarshaler</code>. The decorators can perform tasks such as setting <code class="literal">marshaler</code> or <code class="literal">Unmarshaler</code> properties and setting up validation.
		</div><div class="para">
			As an example, say you want to create an annotation that will trigger <span class="emphasis"><em>pretty-printing</em></span> of an XML document. In raw JAXB, we would set a property on the <code class="literal">marshaler</code> of <code class="literal">marshaler.JAXB_FORMATTED_OUTPUT</code>. Instead, let us write a <span class="emphasis"><em>marshaler decorator</em></span>.
		</div><div class="para">
			First, define an annotation:
		</div><pre class="programlisting">
 import org.jboss.resteasy.annotations.Decorator;

 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
 @Retention(RetentionPolicy.RUNTIME)
 @Decorator(processor = PrettyProcessor.class, target = marshaler.class)
 public @interface Pretty {}
</pre><div class="para">
			For this to work, you must annotate the <code class="literal">@Pretty</code> annotation with a meta-annotation named <code class="literal">@Decorator</code>. The <code class="literal">target()</code> attribute must be the JAXB <code class="literal">marshaler</code> class. Next, we will write the <code class="literal">processor()</code> attribute class.
		</div><pre class="programlisting">
 import org.jboss.resteasy.core.interception.DecoratorProcessor;
 import org.jboss.resteasy.annotations.DecorateTypes;

 import javax.xml.bind.marshaler;
 import javax.xml.bind.PropertyException;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.Produces;
 import java.lang.annotation.Annotation;

 /**
  * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
  * @version $Revision: 1 $
  */
 @DecorateTypes({"text/*+xml", "application/*+xml"})
 public class PrettyProcessor implements DecoratorProcessor&lt;marshaler, Pretty&gt;
 {
    public marshaler decorate(marshaler target, Pretty annotation,
                  Class type, Annotation[] annotations, MediaType mediaType)
    {
       target.setProperty(marshaler.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
    }
 }
</pre><div class="para">
			The <code class="literal">processor</code> implementation must implement the <code class="literal">DecoratorProcessor</code> interface, and should also be annotated with <code class="literal">@DecorateTypes</code>. This annotation specifies the media types that the processor can work with.
		</div><div class="para">
			Now that we have defined our annotation and our <code class="literal">Processor</code>, we can use it on our JAX-RS resource methods or JAXB types like so:
		</div><pre class="programlisting">
   @GET
   @Pretty
   @Produces("application/xml")
   public SomeJAXBObject get() {...}
</pre><div class="para">
			If this is confusing, check the RESTEasy source code for information about implementing <code class="literal">@XmlHeader</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Pluggable_JAXBContext_s_with_ContextResolvers">
      ⁠</a>17.2. Pluggable <code class="literal">JAXBContext</code>s with <code class="literal">ContextResolvers</code></h1></div></div></div><div class="para">
			We do not recommend using this feature unless you are familiar with the principles involved.
		</div><div class="para">
			By default, RESTEasy creates and caches <code class="literal">JAXBContext</code> instances per class type depending on the class you are marshaling or unmarshaling. If you do not want RESTEasy to create <code class="literal">JAXBContext</code>s, you can plug in your own by implementing an instance of <code class="literal">javax.ws.rs.ext.ContextResolver</code>.
		</div><pre class="programlisting">
 public interface ContextResolver&lt;T&gt;
 {
T getContext(Class&lt;?&gt; type);
 }

 @Provider
 @Produces("application/xml")
 public class MyJAXBContextResolver implements ContextResolver&lt;JAXBContext&gt;
 {
JAXBContext getContext(Class&lt;?&gt; type)
{
   if (type.equals(WhateverClassIsOverridedFor.class)) return JAXBContext.newInstance()...;
}
 }
</pre><div class="para">
			You must provide a <code class="literal">@Produces</code> annotation to specify the types of media intended for the context. You must also implement <code class="literal">ContextResolver&lt;JAXBContext&gt;</code>. This helps the runtime match the correct context resolver. You must also annotate the <code class="literal">ContextResolver</code> class with <code class="literal">@Provider</code>.
		</div><div class="para">
			There are several ways to make this <code class="literal">ContextResolver</code> available.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
					return it as a class or instance from a <code class="literal">javax.ws.rs.core.Application</code> implementation.
				</div></li><li class="listitem"><div class="para">
					list it as a provider with <code class="literal">resteasy.providers</code>.
				</div></li><li class="listitem"><div class="para">
					let RESTEasy automatically scan for it within your <code class="filename">WAR</code> file. (See the Configuration Guide for more details.)
				</div></li><li class="listitem"><div class="para">
					add it manually via <code class="literal">ResteasyProviderFactory.getInstance().registerProvider(Class)</code> or <code class="literal">registerProviderInstance(Object)</code>.
				</div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_and_XML_provider">
      ⁠</a>17.3. JAXB and XML provider</h1></div></div></div><div class="para">
			RESTEasy provides the required JAXB provider support for XML. It has several additional annotations to make application coding simpler.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="XmlHeader">
      ⁠</a>17.3.1. <code class="literal">@XmlHeader</code> and <code class="literal">@Stylesheet</code></h2></div></div></div><div class="para">
				To set an XML header when you output XML documents, use the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.XmlHeader</code> annotation.
			</div><pre class="programlisting">
@XmlRootElement
public static class Thing
{
   private String name;

   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
}

@Path("/test")
public static class TestService
{

   @GET
   @Path("/header")
   @Produces("application/xml")
   @XmlHeader("&lt;?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?&gt;")
   public Thing get()
   {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}
</pre><div class="para">
				Here, the <code class="literal">@XmlHeader</code> forces an <code class="literal">xml-stylesheet</code> header on the XML output. The same result can be obtained by placing the header on the <code class="literal">Thing</code> class. Read the JavaDocs for further information regarding the substitution values provided by RESTEasy.
			</div><div class="para">
				RESTEasy also has a convenient annotation for stylesheet headers. For example:
			</div><pre class="programlisting">
@XmlRootElement
public static class Thing
{
   private String name;

   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
}

@Path("/test")
public static class TestService
{

   @GET
   @Path("/stylesheet")
   @Produces("application/xml")
   @Stylesheet(type="text/css", href="${basepath}foo.xsl")
   @Junk
   public Thing getStyle()
   {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}
</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_and_JSON_provider">
      ⁠</a>17.4. JAXB and JSON provider</h1></div></div></div><div class="para">
			RESTEasy lets you marshal JAXB annotated POJOs to and from JSON with the Jettison JSON library. You can find more information about Jettison at <a href="http://jettison.codehaus.org/">http://jettison.codehaus.org/</a>.
		</div><div class="para">
			Jettison has two mapping formats: the default <span class="emphasis"><em>Jettison Mapped Convention</em></span> format, and BadgerFish.
		</div><div class="para">
			For example, consider this JAXB class:
		</div><pre class="programlisting">@XmlRootElement(name = "book")
public class Book {

   private String author;
   private String ISBN;
   private String title;

   public Book() {
   }

   public Book(String author, String ISBN, String title) {
      this.author = author;
      this.ISBN = ISBN;
      this.title = title;
   }

   @XmlElement
   public String getAuthor() {
      return author;
   }

   public void setAuthor(String author) {
      this.author = author;
   }

   @XmlElement
   public String getISBN() {
      return ISBN;
   }

   public void setISBN(String ISBN) {
      this.ISBN = ISBN;
   }

   @XmlAttribute
   public String getTitle() {
      return title;
   }

   public void setTitle(String title) {
      this.title = title;
   }
}


</pre><div class="para">
			The JAXB <code class="literal">Book</code> class would be marshaled to JSON using the BadgerFish Convention:
		</div><pre class="programlisting">
 {"book":
    {
       "@title":"EJB 3.0",
       "author":{"$":"Bill Burke"},
       "ISBN":{"$":"596529260"}
    }
 }
</pre><div class="para">
			Element values are associated with a map. To find the value of the element, you must access the <code class="literal">$</code> variable. You could access the book like this, in JavaScript:
		</div><pre class="programlisting">
 var data = eval("(" + xhr.responseText + ")");
 document.getElementById("zone").innerHTML = data.book.@title;
 document.getElementById("zone").innerHTML += data.book.author.$;
</pre><div class="para">
			To use the BadgerFish Convention you must use the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.json.BadgerFish</code> annotation either on the JAXB class you are marshaling or unmarshaling, or on the JAX-RS resource method or parameter:
		</div><pre class="programlisting">
 @BadgerFish
 @XmlRootElement(name = "book")
 public class Book {...}
</pre><div class="para">
			To return a <code class="literal">book</code> on the JAX-RS method without polluting your JAXB classes with RESTEasy annotations, you can add the annotation to the JAX-RS method instead:
		</div><pre class="programlisting">
 @BadgerFish
 @GET
 public Book getBook(...) {...}
</pre><div class="para">
			If your input is a <code class="literal">Book</code>, place it on the parameter:
		</div><pre class="programlisting">
 @POST
 public void newBook(@BadgerFish Book book) {...}
</pre><div class="para">
			The default Jettison Mapped Convention returns the following JSON:
		</div><pre class="programlisting">
 { "book" :
      {
         "@title":"EJB 3.0",
         "author":"Bill Burke",
         "ISBN":596529260
       }
 }
</pre><div class="para">
			Note that <code class="literal">title</code> is prefixed with the <code class="literal">@</code> character. Unlike the BadgerFish convention, this does not represent the value of element text, which makes it simpler (and a sensible default). To access this in JavaScript:
		</div><pre class="programlisting">
 var data = eval("(" + xhr.responseText + ")");
 document.getElementById("zone").innerHTML = data.book.@title;
 document.getElementById("zone").innerHTML += data.book.author;
</pre><div class="para">
			The Mapped Convention lets you adjust the JAXB mapping with the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.json.Mapped</code> annotation. With this, you can provide an XML namespace to JSON namespace mapping. For example, if you define your JAXB namespace within your <code class="literal">package-info.java</code> class like so:
		</div><pre class="programlisting">
 @javax.xml.bind.annotation.XmlSchema(namespace="http://jboss.org/books")
 package org.jboss.resteasy.test.books;
</pre><div class="para">
			You must define a JSON-to-XML namespace mapping, or you will receive an exception:
		</div><pre class="programlisting">
java.lang.IllegalStateException: Invalid JSON namespace:
  http://jboss.org/books
at org.codehaus.jettison.mapped.MappedNamespaceConvention
  .getJSONNamespace(MappedNamespaceConvention.java:151)
at org.codehaus.jettison.mapped.MappedNamespaceConvention
  .createKey(MappedNamespaceConvention.java:158)
at org.codehaus.jettison.mapped.MappedXMLStreamWriter
  .writeStartElement(MappedXMLStreamWriter.java:241)
</pre><div class="para">
			The <code class="literal">@Mapped</code> annotation fixes this problem. Place the <code class="literal">@Mapped</code> annotation on your JAXB classes, your JAX-RS resource method, or on the parameter that you are unmarshaling.
		</div><pre class="programlisting">
 import org.jboss.resteasy.annotations.providers.jaxb.json.Mapped;
 import org.jboss.resteasy.annotations.providers.jaxb.json.XmlNsMap;

 ...

@GET
@Produces("application/json")
@Mapped(namespaceMap = {
        @XmlNsMap(namespace = "http://jboss.org/books", jsonName = "books")
})
public Book get() {...}

</pre><div class="para">
			You can also force <code class="literal">@XmlAttribute</code>s to be marshaled as <code class="literal">XMLElements</code>.
		</div><pre class="programlisting">
            @Mapped(attributeAsElements={"title"})
            @XmlRootElement(name = "book")
            public class Book {...}
</pre><div class="para">
			To return a <code class="literal">book</code> on the JAX-RS method without polluting your JAXB classes with RESTEasy annotations, add the annotation to the JAX-RS method:
		</div><pre class="programlisting">
            @Mapped(attributeAsElements={"title"})
            @GET
            public Book getBook(...) {...}
</pre><div class="para">
			If your input is a <code class="literal">Book</code>, place it on the parameter:
		</div><pre class="programlisting">
 @POST
 public void newBook(@Mapped(attributeAsElements={"title"}) Book book) {...}
</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_and_FastinfoSet_provider">
      ⁠</a>17.5. JAXB and FastinfoSet provider</h1></div></div></div><div class="para">
			RESTEasy supports the <code class="literal">Fastinfoset</code> MIME type through the use of JAXB annotated classes. <code class="literal">Fastinfoset</code> documents serialize and parse more quickly, and are smaller in size, than logically-equivalent XML documents, so they can be used where size and processing time of XML documents is problematic. It is configured in the same way as the XML JAXB provider.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_Collections">
      ⁠</a>17.6. Arrays and Collections of JAXB Objects</h1></div></div></div><div class="para">
			RESTEasy automatically marshals arrays, <code class="literal">java.util.Set</code>s, and <code class="literal">java.util.List</code>s of JAXB objects to and from XML, JSON, <code class="literal">Fastinfoset</code>, and other RESTEasy JAXB mappers.
		</div><pre class="programlisting">
 @XmlRootElement(name = "customer")
 @XmlAccessorType(XmlAccessType.FIELD)
 public class Customer
 {
@XmlElement
private String name;

public Customer()
{
}

public Customer(String name)
{
   this.name = name;
}

public String getName()
{
   return name;
}
 }

 @Path("/")
 public class MyResource
 {
   @PUT
   @Path("array")
   @Consumes("application/xml")
   public void putCustomers(Customer[] customers)
   {
      Assert.assertEquals("bill", customers[0].getName());
      Assert.assertEquals("monica", customers[1].getName());
   }

   @GET
   @Path("set")
   @Produces("application/xml")
   public Set&lt;Customer&gt; getCustomerSet()
   {
      HashSet&lt;Customer&gt; set = new HashSet&lt;Customer&gt;();
      set.add(new Customer("bill"));
      set.add(new Customer("monica"));

      return set;
   }


   @PUT
   @Path("list")
   @Consumes("application/xml")
   public void putCustomers(List&lt;Customer&gt; customers)
   {
      Assert.assertEquals("bill", customers.get(0).getName());
      Assert.assertEquals("monica", customers.get(1).getName());
   }
 }
</pre><div class="para">
			The resource above publishes and receives JAXB objects. We assume that these are wrapped in a collection element like the following:
		</div><pre class="programlisting">
 &lt;collection&gt;
&lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
&lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
 &lt;collection&gt;
</pre><div class="para">
			You can change the namespace URI, namespace tag, and collection element name by using the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.Wrapped</code> annotation on a parameter or method:
		</div><pre class="programlisting">
 @Target({ElementType.PARAMETER, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Wrapped
 {
String element() default "collection";

String namespace() default "http://jboss.org/resteasy";

String prefix() default "resteasy";
 }
</pre><div class="para">
			So, if we wanted to output the following XML:
		</div><pre class="programlisting">
 &lt;foo:list xmlns:foo="http://foo.org"&gt;
&lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
&lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
 &lt;/foo:list&gt;
</pre><div class="para">
			We would use the <code class="literal">@Wrapped</code> annotation as follows:
		</div><pre class="programlisting">
   @GET
   @Path("list")
   @Produces("application/xml")
   @Wrapped(element="list", namespace="http://foo.org", prefix="foo")
   public List&lt;Customer&gt; getCustomerSet()
   {
      List&lt;Customer&gt; list = new ArrayList&lt;Customer&gt;();
      list.add(new Customer("bill"));
      list.add(new Customer("monica"));

      return list;
   }

</pre><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="json_list">
      ⁠</a>17.6.1. JSON and JAXB Collections/Arrays</h2></div></div></div><div class="para">
				RESTEasy supports using collections with JSON. It encloses lists, sets, or arrays of returned JAXB objects in a simple JSON array. For example:
			</div><pre class="programlisting">
   @XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
   @XmlAttribute
   private String test;

   public Foo()
   {
   }

   public Foo(String test)
   {
      this.test = test;
   }

   public String getTest()
   {
      return test;
   }

   public void setTest(String test)
   {
      this.test = test;
   }
}
</pre><div class="para">
				A List or Array of the <code class="literal">Foo</code> class would be represented in JSON like so:
			</div><pre class="programlisting">
 [{"foo":{"@test":"bill"}},{"foo":{"@test":"monica}"}}]
</pre><div class="para">
				It would also expect this format when receiving input.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_Map">
      ⁠</a>17.7. Maps of JAXB Objects</h1></div></div></div><div class="para">
			RESTEasy automatically marshals maps of JAXB objects to and from XML, JSON, <code class="literal">Fastinfoset</code>, and other JAXB mappers. Your parameter or method return type must be generic, with a String as the key and the JAXB object's type.
		</div><pre class="programlisting">
@XmlRootElement(namespace = "http://foo.com")
public static class Foo
{
   @XmlAttribute
   private String name;

   public Foo()
   {
   }

   public Foo(String name)
   {
      this.name = name;
   }

   public String getName()
   {
      return name;
   }
}

@Path("/map")
public static class MyResource
{
   @POST
   @Produces("application/xml")
   @Consumes("application/xml")
   public Map&lt;String, Foo&gt; post(Map&lt;String, Foo&gt; map)
   {
      Assert.assertEquals(2, map.size());
      Assert.assertNotNull(map.get("bill"));
      Assert.assertNotNull(map.get("monica"));
      Assert.assertEquals(map.get("bill").getName(), "bill");
      Assert.assertEquals(map.get("monica").getName(), "monica");
      return map;
   }
 }
</pre><div class="para">
			This resource publishes and receives JAXB objects within a map. By default, they are wrapped in a <code class="literal">map</code> element in the default namespace. Each <code class="literal">map</code> element has zero or more <code class="literal">entry</code> elements with a <code class="literal">key</code> attribute.
		</div><pre class="programlisting">
 &lt;map&gt;
&lt;entry key="bill" xmlns="http://foo.com"&gt;
    &lt;foo name="bill"/&gt;
&lt;/entry&gt;
&lt;entry key="monica" xmlns="http://foo.com"&gt;
    &lt;foo name="monica"/&gt;
&lt;/entry&gt;
 &lt;/map&gt;
</pre><div class="para">
			You can change the namespace URI, namespace prefix and map, entry, and key element and attribute names by using the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.WrappedMap</code> annotation on a parameter or method.
		</div><pre class="programlisting">
 @Target({ElementType.PARAMETER, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface WrappedMap
 {
/**
 * map element name
 */
String map() default "map";

/**
 * entry element name *
 */
String entry() default "entry";

/**
 * entry's key attribute name
 */
String key() default "key";

String namespace() default "";

String prefix() default "";
 }
</pre><div class="para">
			So, to output the following XML:
		</div><pre class="programlisting">
 &lt;hashmap&gt;
&lt;hashentry hashkey="bill" xmlns:foo="http://foo.com"&gt;
    &lt;foo:foo name="bill"/&gt;
&lt;/hashentry&gt;
 &lt;/map&gt;
</pre><div class="para">
			We would use the @WrappedMap annotation as follows:
		</div><pre class="programlisting">
@Path("/map")
public static class MyResource
{
   @GET
   @Produces("application/xml")
   @WrappedMap(map="hashmap", entry="hashentry", key="hashkey")
   public Map&lt;String, Foo&gt; get()
   {
      ...
      return map;
   }
</pre><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="json_map">
      ⁠</a>17.7.1. JSON and JAXB maps</h2></div></div></div><div class="para">
				RESTEasy supports the use of maps with JSON. It encloses returned JAXB objects within simple JSON maps. For example:
			</div><pre class="programlisting">
   @XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
   @XmlAttribute
   private String test;

   public Foo()
   {
   }

   public Foo(String test)
   {
      this.test = test;
   }

   public String getTest()
   {
      return test;
   }

   public void setTest(String test)
   {
      this.test = test;
   }
}
</pre><div class="para">
				This a List or array of this Foo class would be represented in JSON like this:
			</div><pre class="programlisting">
 { "entry1" : {"foo":{"@test":"bill"}}, "entry2" : {"foo":{"@test":"monica}"}}}
</pre><div class="para">
				It also expects this format for input
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_JSON_problems">
      ⁠</a>17.7.2. Possible Problems with Jettison Provider</h2></div></div></div><div class="para">
				If you have the <code class="filename">resteasy-jackson-provider-xxx.jar</code> in your classpath, the Jackson JSON provider will be triggered. This is problematic for code that depends upon the Jettison JAXB or JSON provider. To correct this, you must either remove Jackson from your <code class="literal">WEB-INF/lib</code> or classpath, or use the <code class="literal">@NoJackson</code> annotation on your JAXB classes.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAXB_INTERFACES">
      ⁠</a>17.8. Interfaces, Abstract Classes, and JAXB</h1></div></div></div><div class="para">
			Some object models use abstract classes and interfaces heavily. JAXB does not work with interfaces that are root elements, and RESTEasy cannot unmarshal parameters that are interfaces or raw abstract classes because it lacks the information required to create a <code class="literal">JAXBContext</code>. For example:
		</div><pre class="programlisting">
 public interface IFoo {}

 @XmlRootElement
 public class RealFoo implements IFoo {}

 @Path("/jaxb")
 public class MyResource {

@PUT
@Consumes("application/xml")
public void put(IFoo foo) {...}
 }
</pre><div class="para">
			In this example, RESTEasy would display an error ("Cannot find MessageBodyReader for..." or similar) because RESTEasy does not know that implementations of <code class="literal">IFoo</code> are JAXB classes, so it cannot create a <code class="literal">JAXBContext</code> for <code class="literal">IFoo</code>. As a workaround, you can annotate the interface with <code class="literal">@XmlSeeAlso</code> to correct the issue.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				This will not work with manual, hand-coded JAXB.
			</div></div></div><pre class="programlisting">
 @XmlSeeAlso(RealFoo.class)
 public interface IFoo {}
</pre><div class="para">
			The extra <code class="literal">@XmlSeeAlso</code> on <code class="literal">IFoo</code> allows RESTEasy to create a <code class="literal">JAXBContext</code> that knows how to unmarshal <code class="literal">RealFoo</code> instances.
		</div></div></div></body></html>