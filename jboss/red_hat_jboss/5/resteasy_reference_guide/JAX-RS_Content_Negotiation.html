<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 15. JAX-RS Content Negotiation</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="JAX-RS_Content_Negotiation">
      ⁠</a>Chapter 15. JAX-RS Content Negotiation</h1></div></div></div><div class="para">
		The HTTP protocol has built-in content negotiation headers that allow the client and server to specify the type of content that they transfer, and the type of content they prefer to receive. The server declares content preferences via the <code class="literal">@Produces</code> and <code class="literal">@Consumes</code> headers.
	</div><div class="para">
		<code class="literal">@Consumes</code> is an array of media types that a particular resource or resource method consumes. For example:
	</div><div class="para">
		
<pre class="programlisting">
         @Consumes("text/*")
         @Path("/library")
         public class Library {

         @POST
         public String stringBook(String book) {...}


         @Consumes("text/xml")
         @POST
         public String jaxbBook(Book book) {...}
</pre>

	</div><div class="para">
		When a client makes a request, JAX-RS first locates all methods that match the path. It then sorts objects based on the content-type header sent by the client. If a client sends the following:
	</div><pre class="programlisting">
         POST /library
         content-type: text/plain

         this is a nice book
</pre><div class="para">
		The <code class="literal">stringBook()</code> method is invoked, because it matches the default <code class="literal">text/*</code> media type. If the client sends XML, like so:
	</div><pre class="programlisting">
         POST /library
         content-type: text/xml

         &lt;book name="EJB 3.0" author="Bill Burke"/&gt;
</pre><div class="para">
		Then the <code class="literal">jaxbBook()</code> method is invoked.
	</div><div class="para">
		<code class="literal">@Produces</code> is used to map a client request and match it with the client's <code class="literal">Accept</code> header. The <span class="emphasis"><em>Accept HTTP</em></span> header is sent by the client, and defines the media types that the client prefers to receive from the server.
	</div><pre class="programlisting">
         @Produces("text/*")
         @Path("/library")
         public class Library {

         @GET
         @Produces("application/json")
         public String getJSON() {...}


         @GET
         public String get() {...}
</pre><div class="para">
		So, if the client sends:
	</div><pre class="programlisting">
      
         GET /library
         Accept: application/json
</pre><div class="para">
		The <code class="literal">getJSON()</code> method would be invoked.
	</div><div class="para">
		<code class="literal">@Consumes</code> and <code class="literal">@Produces</code> can support multiple media types by presenting them in a list. The client's <code class="literal">Accept</code> header can also list multiple media types to receive. More specific media types are selected first. The <code class="literal">Accept</code> header (or <code class="literal">@Produces</code> or <code class="literal">@Consumes</code>) can also specify weighted preferences that will match requests with resource methods. (This is best explained in Section 14.1 of RFC 2616.) RESTEasy provides support for this more complex method of content negotiation.
	</div><div class="para">
		An alternative method used by JAX-RS is a combination of media-type, content-language, and content encoding, in addition to etags, last modified headers, and other pre-conditions. This is a more complex form of content negotiation, performed programmatically by the application developer via the <code class="literal">javax.ws.rs.Variant</code>, <code class="literal">VarianListBuilder</code>, and <code class="literal">Request</code> objects. <code class="literal">Request</code> is injected using the <code class="literal">@Context</code> annotation. (For more information, read the JavaDoc.)
	</div></div></body></html>