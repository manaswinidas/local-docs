<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 3. Working with objects</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="objectstate">
      ⁠</a>Chapter 3. Working with objects</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663879112080">
      ⁠</a>3.1. Entity states</h1></div></div></div><div class="para">
			Like in Hibernate (comparable terms in parentheses), an entity instance is in one of the following states:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					New (transient): an entity is new if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a persistence context. It has no persistent representation in the database and no identifier value has been assigned.
				</div></li><li class="listitem"><div class="para">
					Managed (persistent): a managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.
				</div></li><li class="listitem"><div class="para">
					Detached: the entity instance is an instance with a persistent identity that is no longer associated with a persistence context, usually because the persistence context was closed or the instance was evicted from the context.
				</div></li><li class="listitem"><div class="para">
					Removed: a removed entity instance is an instance with a persistent identity, associated with a persistence context, but scheduled for removal from the database.
				</div></li></ul></div><div class="para">
			The <code class="classname">EntityManager</code> API allows you to change the state of an entity, or in other words, to load and store objects. You will find persistence with EJB3 easier to understand if you think about object state management, not managing of SQL statements.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663934577152">
      ⁠</a>3.2. Making objects persistent</h1></div></div></div><div class="para">
			Once you've created a new entity instance (using the common <code class="literal">new</code> operator) it is in the <span class="emphasis"><em>new</em></span> state. You can make it persistent by associating it to an entity manager:
		</div><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
em.persist(fritz);</pre><div class="para">
			If the <code class="literal">DomesticCat</code> entity type has a generated identifier, the value is associated to the instance when <code class="code">persist()</code> is called. If the identifier is not automatically generated, the application-assigned (usually natural) key value has to be set on the instance before <code class="code">persist()</code> is called.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663919754592">
      ⁠</a>3.3. Loading an object</h1></div></div></div><div class="para">
			Load an entity instance by its identifier value with the entity manager's <code class="code">find()</code> method:
		</div><pre class="programlisting">cat = em.find(Cat.class, catId);

// You may need to wrap the primitive identifiers
long catId = 1234;
em.find( Cat.class, new Long(catId) );</pre><div class="para">
			In some cases, you do not really want to load the object state, but just having a reference to it (ie a proxy). You can get this reference using the <code class="literal">getReference()</code> method. This is especially useful to link a child to its parent without having to load the parent.
		</div><pre class="programlisting">child = new Child();
child.SetName("Henry");
Parent parent = em.getReference(Parent.class, parentId); //no query to the DB
child.setParent(parent);
em.persist(child);</pre><div class="para">
			You can reload an entity instance and its collections at any time using the <code class="code">em.refresh()</code> operation. This is useful when database triggers are used to initialize some of the properties of the entity. Note that only the entity instance and its collections are refreshed unless you specify <code class="literal">REFRESH</code> as a cascade style of any associations:
		</div><pre class="programlisting">em.persist(cat);
em.flush(); // force the SQL insert and triggers to run
em.refresh(cat); //re-read the state (after the trigger executes)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663916354928">
      ⁠</a>3.4. Querying objects</h1></div></div></div><div class="para">
			If you do not know the identifier values of the objects you are looking for, you need a query. The Hibernate EntityManager implementation supports an easy-to-use but powerful object-oriented query language (EJB3-QL) which has been inspired by HQL (and vice-versa). Both query languages are portable across databases, they use entity and property names as identifiers (instead of table and column names). You may also express your query in the native SQL of your database, with optional support from EJB3 for result set conversion into Java business objects.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140663916353104">
      ⁠</a>3.4.1. Executing queries</h2></div></div></div><div class="para">
				EJB3QL and SQL queries are represented by an instance of <code class="classname">javax.persistence.Query</code>. This interface offers methods for parameter binding, result set handling, and for execution of the query. Queries are always created using the current entity manager.
			</div><div class="para">
				A query is usually executed by invoking <code class="methodname">getResultList()</code>. This method loads the resulting instances of the query completely into memory. Entity instances retrieved by a query are in persistent state. The <code class="methodname">getSingleResult() </code>method offers a shortcut if you know your query will only return a single object.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663939358992">
      ⁠</a>3.4.1.1. Projection</h3></div></div></div><div class="para">
					An EJB3QL query queries can return tuples of objects if projection is used. Each result tuple is returned as an object array:
				</div><pre class="programlisting">Iterator&lt;Cat[]&gt; kittensAndMothers = 
  em.createQuery("select kitten, mother from Cat kitten join kitten.mother mother").getResultList().iterator();
  while (kittensAndMothers.hasNext()) {
     Cat[] tuple = kittensAndMothers.next();
     Cat kitten = tuple[0];
     Cat mother = tuple[1];
  } 
    ....
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663939356656">
      ⁠</a>3.4.1.2. Scalar results</h3></div></div></div><div class="para">
					Queries may specify a particular property of an entity in the select clause, instead of an entity alias. You may call SQL aggregate functions as well. Returned non-transactional objects or aggregation results are considered "scalar" results and are not entities in persistent state (in other words, they are considered "read only"):
				</div><pre class="programlisting">Iterator&lt;Object[]&gt; results = em.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .getResultList()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663939354048">
      ⁠</a>3.4.1.3. Bind parameters</h3></div></div></div><div class="para">
					Both named and positional query parameters are supported, the <code class="literal">Query</code> API offers several methods to bind arguments. The EJB3 specification numbers positional parameters from one. Named parameters are identifiers of the form <code class="literal">:paramname</code> in the query string. Named parameters should be preferred, they are more robust and easier to read and understand:
				</div><pre class="programlisting">// Named parameter (preferred)
Query q = em.createQuery("select cat from DomesticCat cat where cat.name = :name");
q.setParameter("name", "Fritz");
List cats = q.getResultList();

// Positional parameter
Query q = em.createQuery("select cat from DomesticCat cat where cat.name = ?1");
q.setParameter(1, "Izi");
List cats = q.getResultList();

// Named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = em.createQuery("select cat from DomesticCat cat where cat.name in (:namesList)");
q.setParameter("namesList", names);
List cats = q.getResultList();</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663926698576">
      ⁠</a>3.4.1.4. Pagination</h3></div></div></div><div class="para">
					If you need to specify bounds upon your result set (the maximum number of rows you want to retrieve and/or the first row you want to retrieve), use the following methods:
				</div><pre class="programlisting">Query q = em.createQuery("select cat from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.getResultList(); //return cats from the 20th position to 29th</pre><div class="para">
					Hibernate knows how to translate this limit query into the native SQL of your DBMS.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663926695888">
      ⁠</a>3.4.1.5. Externalizing named queries</h3></div></div></div><div class="para">
					You may also define named queries through annotations:
				</div><pre class="programlisting">@javax.persistence.NamedQuery(name="eg.DomesticCat.by.name.and.minimum.weight", 
  query="select cat from eg.DomesticCat as cat  where cat.name = ?1 and cat.weight &gt; ?2")</pre><div class="para">
					Parameters are bound programmatically to the named query, before it is executed:
				</div><pre class="programlisting">Query q = em.createNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setParameter(1, name);
q.setParameter(2, minWeight);
List cats = q.getResultList();</pre><div class="para">
					Note that the actual program code is independent of the query language that is used, you may also define native SQL queries in metadata, or use Hibernate's native facilities by placing them in XML mapping files.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663928237040">
      ⁠</a>3.4.1.6. Native queries</h3></div></div></div><div class="para">
					You may express a query in SQL, using <code class="methodname">createNativeQuery()</code> and let Hibernate take care mapping from JDBC result sets to business objects. Use the <code class="literal">@SqlResultSetMapping</code> (please see the Hibernate Annotations reference documentation on how to map a SQL resultset mapping) or the entity mapping (if the column names of the query result are the same as the names declared in the entity mapping; remember that all entity columns have to be returned for this mechanism to work):
				</div><pre class="programlisting">@SqlResultSetMapping(name="getItem", entities = 
        @EntityResult(entityClass=org.hibernate.ejb.test.Item.class, fields= {
            @FieldResult(name="name", column="itemname"),
            @FieldResult(name="descr", column="itemdescription")
        })
)

Query q = em.createNativeQuery("select name as itemname, descr as itemdescription from Item", "getItem");
item = (Item) q.getSingleResult(); //from a resultset

Query q = em.createNativeQuery("select * from Item", Item.class);
item = (Item) q.getSingleResult(); //from a class columns names match the mapping</pre><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						For more information about scalar support in named queries, please refers to the Hibernate Annotations documentation
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663928232304">
      ⁠</a>3.4.1.7. Query hints</h3></div></div></div><div class="para">
					Query hints (for performance optimization, usually) are implementation specific. Hints are declared using the <code class="methodname">query.setHint(String name, Object value)</code> method, or through the <code class="literal">@Named(Native)Query(hints)</code> annotation Note that these are not SQL query hints! The Hibernate EJB3 implementation offers the following query hints:
				</div><div class="table"><a id="idm140663925477840">
      ⁠</a><p class="title"><strong>Table 3.1. Hibernate query hints</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Hibernate query hints"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: center"> Hint </th><th style="text-align: center"> Description </th></tr></thead><tbody><tr><td> org.hibernate.timeout </td><td> Query timeout in seconds ( eg. new Integer(10) ) </td></tr><tr><td> org.hibernate.fetchSize </td><td> Number of rows fetched by the JDBC driver per roundtrip ( eg. new Integer(50) ) </td></tr><tr><td> org.hibernate.comment </td><td> Add a comment to the SQL query, useful for the DBA ( e.g. new String("fetch all orders in 1 statement") ) </td></tr><tr><td> org.hibernate.cacheable </td><td> Whether or not a query is cacheable ( eg. new Boolean(true) ), defaults to false </td></tr><tr><td> org.hibernate.cacheMode </td><td> Override the cache mode for this query ( eg. CacheMode.REFRESH ) </td></tr><tr><td> org.hibernate.cacheRegion </td><td> Cache region of this query ( eg. new String("regionName") ) </td></tr><tr><td> org.hibernate.readOnly </td><td> Entities retrieved by this query will be loaded in a read-only mode where Hibernate will never dirty-check them or make changes persistent ( eg. new Boolean(true) ), default to false </td></tr><tr><td> org.hibernate.flushMode </td><td> Flush mode used for this query </td></tr><tr><td> org.hibernate.cacheMode </td><td> Cache mode used for this query </td></tr></tbody></table></div></div><div class="para">
					The value object accept both the native type or its string equivalent (eg. <code class="literal">CaheMode.REFRESH</code> or <span class="quote">“<span class="quote"><code class="literal">REFRESH</code></span>”</span>). Please refer to the Hibernate reference documentation for more information.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663931019360">
      ⁠</a>3.5. Modifying persistent objects</h1></div></div></div><div class="para">
			Transactional managed instances (ie. objects loaded, saved, created or queried by the entity manager) may be manipulated by the application and any changes to persistent state will be persisted when the Entity manager is flushed (discussed later in this chapter). There is no need to call a particular method to make your modifications persistent. A straightforward way to update the state of an entity instance is to <code class="methodname">find()</code> it, and then manipulate it directly, while the persistence context is open:
		</div><pre class="programlisting">Cat cat = em.find( Cat.class, new Long(69) );
cat.setName("PK");
em.flush();  // changes to cat are automatically detected and persisted</pre><div class="para">
			Sometimes this programming model is inefficient since it would require both an SQL SELECT (to load an object) and an SQL UPDATE (to persist its updated state) in the same session. Therefore Hibernate offers an alternate approach, using detached instances.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663929493360">
      ⁠</a>3.6. Modifying detached objects</h1></div></div></div><div class="para">
			Many applications need to retrieve an object in one transaction, send it to the presentation layer for manipulation, and later save the changes in a new transaction. There can be significant user think and waiting time between both transactions. Applications that use this kind of approach in a high-concurrency environment usually use versioned data to ensure isolation for the "long" unit of work.
		</div><div class="para">
			The EJB3 specifications supports this development model by providing for persistence of modifications made to detached instances using the <code class="methodname">EntityManager.merge()</code> method:
		</div><pre class="programlisting">// in the first entity manager
Cat cat = firstEntityManager.find(Cat.class, catId);
Cat potentialMate = new Cat();
firstEntityManager.persist(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new entity manager
secondEntityManager.merge(cat);  // update cat
secondEntityManager.merge(mate); // update mate</pre><div class="para">
			The <code class="literal">merge()</code> method merges modifications made to the detached instance into the corresponding managed instance, if any, without consideration of the state of the persistence context. In other words, the merged objects state overrides the persistent entity state in the persistence context, if one is already present. The application should individually <code class="methodname">merge()</code> detached instances reachable from the given detached instance if and only if it wants their state also to be persistent. This can be cascaded to associated entities and collections, using transitive persistence, see <a class="xref" href="objectstate.html#objectstate-transitive">Section 3.10, “Transitive persistence”</a>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663931096896">
      ⁠</a>3.7. Automatic state detection</h1></div></div></div><div class="para">
			The merge operation is clever enough to automatically detect whether the merging of the detached instance has to result in an insert or update. In other words, you do not have to worry about passing a new instance (and not a detached instance) to <code class="literal">merge()</code>, the entity manager will figure this out for you:
		</div><pre class="programlisting">// In the first entity manager
Cat cat = firstEntityManager.find(Cat.class, catID);

// In a higher layer of the application, detached
Cat mate = new Cat();
cat.setMate(mate);

// Later, in a new entity manager
secondEntityManager.merge(cat);   // update existing state
secondEntityManager.merge(mate);  // save the new instance</pre><div class="para">
			The usage and semantics of <code class="literal">merge()</code> seems to be confusing for new users. Firstly, as long as you are not trying to use object state loaded in one entity manager in another new entity manager, you should not need to use <code class="methodname">merge()</code> at all. Some whole applications will never use this method.
		</div><div class="para">
			Usually <code class="methodname">merge()</code> is used in the following scenario:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					the application loads an object in the first entity manager
				</div></li><li class="listitem"><div class="para">
					the object is passed up to the presentation layer
				</div></li><li class="listitem"><div class="para">
					some modifications are made to the object
				</div></li><li class="listitem"><div class="para">
					the object is passed back down to the business logic layer
				</div></li><li class="listitem"><div class="para">
					the application persists these modifications by calling <code class="methodname">merge()</code> in a second entity manager
				</div></li></ul></div><div class="para">
			Here is the exact semantic of <code class="methodname">merge()</code>:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					if there is a managed instance with the same identifier currently associated with the persistence context, copy the state of the given object onto the managed instance
				</div></li><li class="listitem"><div class="para">
					if there is no managed instance currently associated with the persistence context, try to load it from the database, or create a new managed instance
				</div></li><li class="listitem"><div class="para">
					the managed instance is returned
				</div></li><li class="listitem"><div class="para">
					the given instance does not become associated with the persistence context, it remains detached and is usually discarded
				</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Merging vs. saveOrUpdate/saveOrUpdateCopy</strong></p></div><div class="admonition"><div class="para">
				Merging in EJB3 is similar to the <code class="literal">saveOrUpdateCopy()</code> method in native Hibernate. However, it is not the same as the <code class="literal">saveOrUpdate()</code> method, the given instance is not reattached with the persistence context, but a managed instance is returned by the <code class="methodname">merge()</code> method.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663926639408">
      ⁠</a>3.8. Deleting managed objects</h1></div></div></div><div class="para">
			<code class="methodname">EntityManager.remove()</code> will remove an objects state from the database. Of course, your application might still hold a reference to a deleted object. You can think of <code class="methodname">remove()</code> as making a persistent instance new (aka transient) again. It is not detached, and a merge would result in an insertion.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663917309040">
      ⁠</a>3.9. Flush the persistence context</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140663917308272">
      ⁠</a>3.9.1. In a transaction</h2></div></div></div><div class="para">
				From time to time the entity manager will execute the SQL DML statements needed to synchronize the data store with the state of objects held in memory. This process, flush, occurs by default (this is Hibernate specific and not defined by the specification) at the following points:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						before query execution*
					</div></li><li class="listitem"><div class="para">
						from <code class="methodname">javax.persistence.EntityTransaction.commit()*</code>
					</div></li><li class="listitem"><div class="para">
						when <code class="methodname">EntityManager.flush()</code> is called*
					</div></li></ul></div><div class="para">
				(*) if a transaction is active
			</div><div class="para">
				The SQL statements are issued in the following order
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						all entity insertions, in the same order the corresponding objects were saved using <code class="methodname">EntityManager.persist()</code>
					</div></li><li class="listitem"><div class="para">
						all entity updates
					</div></li><li class="listitem"><div class="para">
						all collection deletions
					</div></li><li class="listitem"><div class="para">
						all collection element deletions, updates and insertions
					</div></li><li class="listitem"><div class="para">
						all collection insertions
					</div></li><li class="listitem"><div class="para">
						all entity deletions, in the same order the corresponding objects were deleted using <code class="methodname">EntityManager.remove()</code>
					</div></li></ul></div><div class="para">
				(Exception: entity instances using application-assigned identifiers are inserted when they are saved.)
			</div><div class="para">
				Except when you explicitly <code class="methodname">flush()</code>, there are absolutely no guarantees about when the entity manager executes the JDBC calls, only the order in which they are executed. However, Hibernate does guarantee that the <code class="methodname">Query.getResultList()</code>/<code class="methodname">Query.getSingleResult()</code> will never return stale data; nor will they return wrong data if executed in an active transaction.
			</div><div class="para">
				It is possible to change the default behavior so that flush occurs less frequently. The <code class="classname">FlushModeType</code> for an entity manager defines two different modes: only flush at commit time or flush automatically using the explained routine unless <code class="methodname">flush()</code> is called explicitly.
			</div><pre class="programlisting">em = emf.createEntityManager();
em.getTransaction().begin();
em.setFlushMode(FlushModeType.COMMIT); // allow queries to return stale state

Cat izi = em.find(Cat.class, id);
izi.setName(iznizi);

// might return stale data
em.createQuery("from Cat as cat left outer join cat.kittens kitten").getResultList();

// change to izi is not flushed!
...
em.getTransaction().commit(); // flush occurs</pre><div class="para">
				During flush, an exception might happen (e.g. if a DML operation violates a constraint). 
			</div><div class="para">
				Hibernate provides more flush modes than the one described in the EJB3 specification. Please refer to the Hibernate core reference documentation for more information.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140663933946544">
      ⁠</a>3.9.2. Outside a transaction</h2></div></div></div><div class="para">
				In an <code class="literal">EXTENDED</code> persistence context, all read only operations of the entity manager can be executed outside a transaction (<code class="literal">find()</code>, <code class="literal">getReference()</code>, <code class="literal">refresh()</code>, and read queries). Some modifications operations can be executed outside a transaction, but they are queued until the persistence context join a transaction. This is the case of <code class="literal">persist()</code>, <code class="literal"><code class="literal">merge()</code></code>, <code class="literal">remove()</code>. Some operations cannot be called outside a transaction: <code class="literal">flush()</code>, <code class="literal">lock()</code>, and update/delete queries.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="objectstate-transitive">
      ⁠</a>3.10. Transitive persistence</h1></div></div></div><div class="para">
			It is quite cumbersome to save, delete, or reattach individual objects, especially if you deal with a graph of associated objects. A common case is a parent/child relationship. Consider the following example:
		</div><div class="para">
			If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is persisted, the value-typed child objects are persisted as well, when the parent is removed, the children will be removed, etc. This even works for operations such as the removal of a child from the collection; Hibernate will detect this and, since value-typed objects can not have shared references, remove the child from the database.
		</div><div class="para">
			Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle, support shared references (so removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. The EJB3 specification does not require persistence by reachability. It supports a more flexible model of transitive persistence, as first seen in Hibernate.
		</div><div class="para">
			For each basic operation of the entity manager - including <code class="methodname">persist()</code>, <code class="methodname">merge()</code>, <code class="methodname">remove()</code>, <code class="methodname">refresh()</code> - there is a corresponding cascade style. Respectively, the cascade styles are named PERSIST, MERGE, REMOVE, REFRESH. If you want an operation to be cascaded to associated entity (or collection of entities), you must indicate that in the association annotation:
		</div><pre class="programlisting">@OneToOne(cascade=CascadeType.PERSIST)</pre><div class="para">
			Cascading options can be combined:
		</div><pre class="programlisting">@OneToOne(cascade= { CascadeType.PERSIST, CascadeType.REMOVE, CascadeType.REFRESH } )</pre><div class="para">
			You may even use CascadeType.ALL to specify that all operations should be cascaded for a particular association. Remember that by default, no operation is cascaded.
		</div><div class="para">
			Hibernate offers more native cascading options, please refer to the Hibernate Annotations manual and the Hibernate reference guide for more information.
		</div><div class="para">
			Recommendations:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					It does not usually make sense to enable cascade on a <code class="literal">@ManyToOne</code> or <code class="literal">@ManyToMany</code> association. Cascade is often useful for <code class="literal">@OneToOne</code> and <code class="literal">@OneToMany</code> associations.
				</div></li><li class="listitem"><div class="para">
					If the child object's lifespan is bounded by the lifespan of the parent object, make the parent a full life-cycle object by specifying <code class="literal">CascadeType.ALL</code> and <code class="literal">org.hibernate.annotations.CascadeType.DELETE_ORPHAN</code> (please refer to the Hibernate reference guide for the semantics of orphan delete)
				</div></li><li class="listitem"><div class="para">
					Otherwise, you might not need cascade at all. But if you think that you will often be working with the parent and children together in the same transaction, and you want to save yourself some typing, consider using <code class="code">cascade={PERSIST, MERGE}</code>. These options can even make sense for a many-to-many association.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663926626992">
      ⁠</a>3.11. Locking</h1></div></div></div><div class="para">
			The default locking system in EJB3 is mostly based on optimistic locking (ie using a version column to check any concurrency issues). EJB3 has defined an additional mechanism to increase the concurrency guaranties. You can apply a lock on a given entity (and it's associated entities if <code class="literal">LOCK</code> is cascaded) through the <code class="methodname">lock(Object entity)</code> method. Depending on the concurrency guaranties you requires, you choose a lock mode:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">LockMode.READ</code> prevents dirty-reads and non repeatable read on a given entity.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">LockMode.WRITE</code> prevents dirty-reads and non repeatable read on a given entity and force an increase of the version number if any.
				</div></li></ul></div></div></div></body></html>