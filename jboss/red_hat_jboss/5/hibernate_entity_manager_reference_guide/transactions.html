<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 4. Transactions and Concurrency</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="transactions">
      ⁠</a>Chapter 4. Transactions and Concurrency</h1></div></div></div><div class="para">
		The most important point about Hibernate Entity Manager and concurrency control is that it is very easy to understand. Hibernate Entity Manager directly uses JDBC connections and JTA resources without adding any additional locking behavior. We highly recommend you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. Hibernate Entity Manager only adds automatic versioning but does not lock objects in memory or change the isolation level of your database transactions. Basically, use Hibernate Entity Manager like you would use direct JDBC (or JTA/CMT) with your database resources.
	</div><div class="para">
		We start the discussion of concurrency control in Hibernate with the granularity of <code class="literal">EntityManagerFactory</code>, and <code class="literal">EntityManager</code>, as well as database transactions and long units of work.
	</div><div class="para">
		In this chapter, and unless explicitly expressed, we will mix and match the concept of entity manager and persistence context. One is an API and programming object, the other a definition of scope. However, keep in mind the essential difference. A persistence context is usually bound to a JTA transaction in Java EE, and a persistence context starts and ends at transaction boundaries (transaction-scoped) unless you use an extended entity manager. Please refer to <a class="xref" href="architecture.html#architecture-ejb-persistctxscope">Section 1.2.3, “Persistence context scope”</a> for more information.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transactions-basics">
      ⁠</a>4.1. Entity manager and transaction scopes</h1></div></div></div><div class="para">
			A <code class="literal">EntityManagerFactory</code> is an expensive-to-create, threadsafe object intended to be shared by all application threads. It is created once, usually on application start.
		</div><div class="para">
			An <code class="literal">EntityManager</code> is an inexpensive, non-threadsafe object that should be used once, for a single business process, a single unit of work, and then discarded. An <code class="literal">EntityManager</code> will not obtain a JDBC <code class="literal">Connection</code> (or a <code class="literal">Datasource</code>) unless it is needed, so you may safely open and close an <code class="literal">EntityManager</code> even if you are not sure that data access will be needed to serve a particular request. (This becomes important as soon as you are implementing some of the following patterns using request interception.)
		</div><div class="para">
			To complete this picture you also have to think about database transactions. A database transaction has to be as short as possible, to reduce lock contention in the database. Long database transactions will prevent your application from scaling to highly concurrent load.
		</div><div class="para">
			What is the scope of a unit of work? Can a single Hibernate <code class="literal">EntityManager</code> span several database transactions or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries?
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics-uow">
      ⁠</a>4.1.1. Unit of work</h2></div></div></div><div class="para">
				First, do not use the <span class="emphasis"><em>entitymanager-per-operation</em></span> antipattern, that is, do not open and close an <code class="literal">EntityManager</code> for every simple database call in a single thread! Of course, the same is true for database transactions. Database calls in an application are made using a planned sequence, they are grouped into atomic units of work. (Note that this also means that auto-commit after every single SQL statement is useless in an application, this mode is intended for ad-hoc SQL console work.)
			</div><div class="para">
				The most common pattern in a multi-user client/server application is <span class="emphasis"><em>entitymanager-per-request</em></span>. In this model, a request from the client is send to the server (where the EJB3 persistence layer runs), a new <code class="literal">EntityManager</code> is opened, and all database operations are executed in this unit of work. Once the work has been completed (and the response for the client has been prepared), the persistence context is flushed and closed, as well as the entity manager object. You would also use a single database transaction to serve the clients request. The relationship between the two is one-to-one and this model is a perfect fit for many applications.
			</div><div class="para">
				This is the default EJB3 persistence model in a Java EE environment (JTA bounded, transaction-scoped persistence context); injected (or looked up) entity managers share the same persistence context for a particular JTA transaction. The beauty of EJB3 is that you do not have to care about that anymore and just see data access through entity manager and demaraction of transaction scope on session beans as completely orthogonal.
			</div><div class="para">
				The challenge is the implementation of this (and other) behavior outside an EJB3 container: not only has the <code class="literal">EntityManager</code> and resource-local transaction to be started and ended correctly, but they also have to be accessible for data access operations. The demarcation of a unit of work is ideally implemented using an interceptor that runs when a request hits the non-EJB3 container server and before the response will be send (i.e. a <code class="literal">ServletFilter</code> if you are using a standalone servlet container). We recommend to bind the <code class="literal">EntityManager</code> to the thread that serves the request, using a <code class="literal">ThreadLocal</code> variable. This allows easy access (like accessing a static variable) in all code that runs in this thread. Depending on the database transaction demarcation mechanism you chose, you might also keep the transaction context in a <code class="literal">ThreadLocal</code> variable. The implementation patterns for this are known as <span class="emphasis"><em>ThreadLocal Session</em></span> and <span class="emphasis"><em>Open Session in View</em></span> in the Hibernate community. You can easily extend the <code class="literal">HibernateUtil</code> shown in the Hibernate reference documentation to implement this pattern, you do not need any external software (it's in fact very trivial). Of course, you'd have to find a way to implement an interceptor and set it up in your environment. See the Hibernate website for tips and examples. Once again, remember that your first choice is naturally an EJB3 container - preferably a light and modular one such as JBoss application server.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics-apptx">
      ⁠</a>4.1.2. Long units of work</h2></div></div></div><div class="para">
				The entitymanager-per-request pattern is not the only useful concept you can use to design units of work. Many business processes require a whole series of interactions with the user interleaved with database accesses. In web and enterprise applications it is not acceptable for a database transaction to span a user interaction with possibly long waiting time between requests. Consider the following example:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						The first screen of a dialog opens, the data seen by the user has been loaded in a particular <code class="literal">EntityManager</code> and resource-local transaction. The user is free to modify the detached objects.
					</div></li><li class="listitem"><div class="para">
						The user clicks "Save" after 5 minutes and expects his modifications to be made persistent; he also expects that he was the only person editing this information and that no conflicting modification can occur.
					</div></li></ul></div><div class="para">
				We call this unit of work, from the point of view of the user, a long running <span class="emphasis"><em>application transaction</em></span>. There are many ways how you can implement this in your application.
			</div><div class="para">
				A first naive implementation might keep the <code class="literal">EntityManager</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification, and to guarantee isolation and atomicity. This is of course an anti-pattern, a pessimistic approach, since lock contention would not allow the application to scale with the number of concurrent users.
			</div><div class="para">
				Clearly, we have to use several database transactions to implement the application transaction. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single application transaction usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data, all others simply read data (e.g. in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you use EJB3 entity manager and persistence context features:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="emphasis"><em>Automatic Versioning</em></span> - An entity manager can do automatic optimistic concurrency control for you, it can automatically detect if a concurrent modification occurred during user think time (usually by comparing version numbers or timestamps when updating the data in the final resource-local transaction).
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>Detached Entities</em></span> - If you decide to use the already discussed <span class="emphasis"><em>entity-per-request</em></span> pattern, all loaded instances will be in detached state during user think time. The entity manager allows you to merge the detached (modified) state and persist the modifications, the pattern is called <span class="emphasis"><em>entitymanager-per-request-with-detached-entities</em></span>. Automatic versioning is used to isolate concurrent modifications.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>Extended Entity Manager</em></span> - The Hibernate Entity Manager may be disconnected from the underlying JDBC connection between two client calls and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> and makes even merging unnecessary. An extend persistence context is responsible to collect and retain any modification (persist, merge, remove) made outside a transaction. The next client call made inside an active transaction (typically the last operation of a user conversation) will execute all queued modifications. Automatic versioning is used to isolate concurrent modifications.
					</div></li></ul></div><div class="para">
				Both <span class="emphasis"><em>entitymanager-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> have advantages and disadvantages, we discuss them later in this chapter in the context of optimistic concurrency control.
			</div><div class="para">
				
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics-identity">
      ⁠</a>4.1.3. Considering object identity</h2></div></div></div><div class="para">
				An application may concurrently access the same persistent state in two different persistence contexts. However, an instance of a managed class is never shared between two persistence contexts. Hence there are two different notions of identity:
			</div><div class="variablelist"><dl class="variablelist compact"><dt><span class="term">Database Identity</span></dt><dd><div class="para">
							<code class="literal">foo.getId().equals( bar.getId() )</code>
						</div></dd><dt><span class="term">JVM Identity</span></dt><dd><div class="para">
							<code class="literal">foo==bar</code>
						</div></dd></dl></div><div class="para">
				Then for objects attached to a <span class="emphasis"><em>particular</em></span> persistence context (i.e. in the scope of an <code class="literal">EntityManager</code>) the two notions are equivalent, and JVM identity for database identity is guaranteed by the Hibernate Entity Manager. However, while the application might concurrently access the "same" (persistent identity) business object in two different persistence contexts, the two instances will actually be "different" (JVM identity). Conflicts are resolved using (automatic versioning) at flush/commit time, using an optimistic approach.
			</div><div class="para">
				This approach leaves Hibernate and the database to worry about concurrency; it also provides the best scalability, since guaranteeing identity in single-threaded units of work only does not need expensive locking or other means of synchronization. The application never needs to synchronize on any business object, as long as it sticks to a single thread per <code class="literal">EntityManager</code>. Within a persistence context, the application may safely use <code class="literal">==</code> to compare entities.
			</div><div class="para">
				However, an application that uses <code class="literal">==</code> outside of a persistence context might see unexpected results. This might occur even in some unexpected places, for example, if you put two detached instances into the same <code class="literal">Set</code>. Both might have the same database identity (i.e. they represent the same row), but JVM identity is by definition not guaranteed for instances in detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement his own notion of object equality. There is one caveat: Never use the database identifier to implement equality, use a business key, a combination of unique, usually immutable, attributes. The database identifier will change if a transient entity is made persistent (see the contract of the <code class="literal">persist()</code> operation). If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for good business keys do not have to be as stable as database primary keys, you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Also note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics-issues">
      ⁠</a>4.1.4. Common concurrency control issues</h2></div></div></div><div class="para">
				Never use the anti-patterns <span class="emphasis"><em>entitymanager-per-user-session</em></span> or <span class="emphasis"><em>entitymanager-per-application</em></span> (of course, there are rare exceptions to this rule, e.g. entitymanager-per-application might be acceptable in a desktop application, with manual flushing of the persistence context). Note that some of the following issues might also appear with the recommended patterns, make sure you understand the implications before making a design decision:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						An entity manager is not thread-safe. Things which are supposed to work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if an <code class="literal">EntityManager</code> instance would be shared. If you keep your Hibernate <code class="literal">EntityManager</code> in your <code class="literal">HttpSession</code> (discussed later), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough may use the same <code class="literal">EntityManager</code> in two concurrently running threads. You will very likely have provisions for this case already in place, for other non-threadsafe but session-scoped objects.
					</div></li><li class="listitem"><div class="para">
						An exception thrown by the Entity Manager means you have to rollback your database transaction and close the <code class="literal">EntityManager</code> immediately (discussed later in more detail). If your <code class="literal">EntityManager</code> is bound to the application, you have to stop the application. Rolling back the database transaction does not put your business objects back into the state they were at the start of the transaction. This means the database state and the business objects do get out of sync. Usually this is not a problem, because exceptions are not recoverable and you have to start over your unit of work after rollback anyway.
					</div></li><li class="listitem"><div class="para">
						The persistence context caches every object that is in managed state (watched and checked for dirty state by Hibernate). This means it grows endlessly until you get an <code class="classname">OutOfMemoryException</code>, if you keep it open for a long time or simply load too much data. One solution for this is some kind batch processing with regular flushing of the persistence context, but you should consider using a database stored procedure if you need mass data operations. Some solutions for this problem are shown in <a class="xref" href="batch.html">Chapter 6, <em>Batch processing</em></a>. Keeping a persistence context open for the duration of a user session also means a high probability of stale data, which you have to know about and control appropriately.
					</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transactions-demarcation">
      ⁠</a>4.2. Database transaction demarcation</h1></div></div></div><div class="para">
			Datatabase (or system) transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required but there is no downside if you always demarcate transactions explicitly. You'll have to do operations outside a transaction, though, when you'll need to retain modifications in an <code class="literal">EXTENDED</code> persistence context.
		</div><div class="para">
			An EJB3 application can run in non-managed (i.e. standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, an <code class="literal">EntityManagerFactory</code> is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries, in other words, begin, commit, or rollback database transactions itself. A managed environment usually provides container-managed transactions, with the transaction assembly defined declaratively through annotations of EJB session beans, for example. Programmatic transaction demarcation is then no longer necessary, even flushing the <code class="literal">EntityManager</code> is done automatically.
		</div><div class="para">
			Usually, ending a unit of work involves four distinct phases:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					commit the (resource-local or JTA) transaction (this automatically flushes the entity manager and persistence context)
				</div></li><li class="listitem"><div class="para">
					close the entity manager (if using an application-managed entity manager)
				</div></li><li class="listitem"><div class="para">
					handle exceptions
				</div></li></ul></div><div class="para">
			We will now have a closer look at transaction demarcation and exception handling in both managed- and non-managed environments.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation-nonmanaged">
      ⁠</a>4.2.1. Non-managed environment</h2></div></div></div><div class="para">
				If an EJB3 persistence layer runs in a non-managed environment, database connections are usually handled by Hibernate's pooling mechanism behind the scenes. The common entity manager and transaction handling idiom looks like this:
			</div><pre class="programlisting">// Non-managed environment idiom
EntityManager em = emf.createEntityManager();
EntityTransaction tx = null;
try {
    tx = em.getTransaction();
    tx.begin();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if ( tx != null &amp;&amp; tx.isActive() ) tx.rollback();
    throw e; // or display error message
}
finally {
    em.close();
}</pre><div class="para">
				You do not have to <code class="literal">flush()</code> the <code class="literal">EntityManager</code> explicitly - the call to <code class="literal">commit()</code> automatically triggers the synchronization.
			</div><div class="para">
				A call to <code class="literal">close()</code> marks the end of an <code class="literal">EntityManager</code>. The main implication of <code class="literal">close()</code> is the release of resources - make sure you always close and never outside of guaranteed finally block.
			</div><div class="para">
				You will very likely never see this idiom in business code in a normal application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes entity manager calls (in the persistence layer) and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit) are in different layers. This can be a challenge to design yourself and you should use J2EE/EJB container services whenever they are available. Exception handling is discussed later in this chapter.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140663885794368">
      ⁠</a>4.2.1.1. EntityTransaction</h3></div></div></div><div class="para">
					In a JTA environment, you do not need any extra API to interact with the transaction in your environment. Simply use transaction declaration or the JTA APIs.
				</div><div class="para">
					If you are using a <code class="literal">RESOURCE_LOCAL</code> entity manager, you need to demarcate your transaction boundaries through the <code class="literal">EntityTransaction</code> API. You can get an <code class="literal">EntityTransaction</code> through <code class="literal">entityManager.getTransaction()</code>. This <code class="literal">EntityTransaction</code> API provides the regular <code class="methodname">begin()</code>, <code class="methodname">commit()</code>, <code class="methodname">rollback()</code> and <code class="methodname">isActive()</code> methods. It also provide a way to mark a transaction as rollback only, ie force the transaction to rollback. This is very similar to the JTA operation <code class="methodname">setRollbackOnly()</code>. When a <code class="literal">commit()</code> operation fail and/or if the transaction is marked as <code class="literal">setRollbackOnly()</code>, the <code class="literal">commit()</code> method will try to rollback the transaction and raise a <code class="literal">javax.transaction.RollbackException</code>.
				</div><div class="para">
					In a <code class="literal">JTA</code> entity manager, <code class="literal">entityManager.getTransaction()</code> calls are not permitted.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation-jta">
      ⁠</a>4.2.2. Using JTA</h2></div></div></div><div class="para">
				If your persistence layer runs in an application server (e.g. behind EJB3 session beans), every datasource connection obtained internally by the entity manager will automatically be part of the global JTA transaction. Hibernate offers two strategies for this integration.
			</div><div class="para">
				If you use bean-managed transactions (BMT), the code will look like this:
			</div><pre class="programlisting">// BMT idiom
@Resource public UserTransaction utx;
@Resource public EntityManagerFactory factory;

public void doBusiness() {
    EntityManager em = factory.createEntityManager();
    try {

    // do some work
    ...

    utx.commit();
}
catch (RuntimeException e) {
    if (utx != null) utx.rollback();
    throw e; // or display error message
}
finally {
    em.close();
}</pre><div class="para">
				With Container Managed Transactions (CMT) in an EJB3 container, transaction demarcation is done in session bean annotations or deployment descriptors, not programmatically. The <code class="literal">EntityManager</code> will automatically be flushed on transaction completion (and if you have injected or lookup the <code class="literal">EntityManager</code>, it will be also closed automatically). If an exception occurs during the <code class="literal">EntityManager</code> use, transaction rollback occurs automatically if you do not catch the exception. Since <code class="literal">EntityManager</code> exceptions are <code class="literal">RuntimeException</code>s they will rollback the transaction as per the EJB specification (system exception vs. application exception).
			</div><div class="para">
				It is important to let Hibernate EntityManager define the <code class="literal">hibernate.transaction.factory_class</code> (ie not overriding this value). Remember to also set <code class="literal">org.hibernate.transaction.manager_lookup_class</code>.
			</div><div class="para">
				If you work in a CMT environment, you might also want to use the same entity manager in different parts of your code. Typically, in a non-managed environment you would use a <code class="literal">ThreadLocal</code> variable to hold the entity manager, but a single EJB request might execute in different threads (e.g. session bean calling another session bean). The EJB3 container takes care of the persistence context propagation for you. Either using injection or lookup, the EJB3 container will return an entity manager with the same persistence context bound to the JTA context if any, or create a new one and bind it (see <a class="xref" href="architecture.html#architecture-ejb-persistctxpropagation">Section 1.2.4, “Persistence context propagation”</a> .)
			</div><div class="para">
				Our entity manager/transaction management idiom for CMT and EJB3 container-use is reduced to this:
			</div><pre class="programlisting">//CMT idiom through injection
@PersistenceContext(name="sample") EntityManager em;</pre><div class="para">
				In other words, all you have to do in a managed environment is to inject the <code class="literal">EntityManager</code>, do your data access work, and leave the rest to the container. Transaction boundaries are set declaratively in the annotations or deployment descriptors of your session beans. The life cycle of the entity manager and persistence context is completely managed by the container.
			</div><div class="para">
				
			</div><div class="para">
				When using particular Hibernate native APIs, one caveat has to be remembered: <code class="literal">after_statement</code> connection release mode. Due to a silly limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicitly from a <code class="literal">finally</code> block. (Of course, most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> at all from the CMT code.)
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation-exceptions">
      ⁠</a>4.2.3. Exception handling</h2></div></div></div><div class="para">
				If the <code class="literal">EntityManager</code> throws an exception (including any <code class="literal">SQLException</code>), you should immediately rollback the database transaction, call <code class="literal">EntityManager.close()</code> (if <code class="methodname">createEntityManager()</code> has been called) and discard the <code class="literal">EntityManager</code> instance. Certain methods of <code class="literal">EntityManager</code> will <span class="emphasis"><em>not</em></span> leave the persistence context in a consistent state. No exception thrown by an entity manager can be treated as recoverable. Ensure that the <code class="literal">EntityManager</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. Note that a container managed entity manager will do that for you. You just have to let the RuntimeException propagate up to the container.
			</div><div class="para">
				The Hibernate entity manager generally raises exceptions which encapsulate the Hibernate core exception. Common exceptions raised by the <code class="literal">EntityManager</code> API are
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						IllegalArgumentException: an argument is not permitted, not recognized, or in an incorrect format (or similar).
					</div></li><li class="listitem"><div class="para">
						EntityNotFoundException: an entity was expected but none match the requirement
					</div></li><li class="listitem"><div class="para">
						TransactionRequiredException: this operation has to be in a transaction
					</div></li><li class="listitem"><div class="para">
						IllegalStateException: the entity manager is used in a wrong way
					</div></li></ul></div><div class="para">
				The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. Note that Hibernate might also throw other unchecked exceptions which are not a <code class="literal">HibernateException</code>. These are, again, not recoverable and appropriate action should be taken.
			</div><div class="para">
				Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meaningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect; however, it is also possible to plug in a custom implementation (see the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details). The standard <code class="literal">JDBCException</code> subtypes are:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">JDBCConnectionException</code> - indicates an error with the underlying JDBC communication.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">SQLGrammarException</code> - indicates a grammar or syntax problem with the issued SQL.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">ConstraintViolationException</code> - indicates some form of integrity constraint violation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">LockAcquisitionException</code> - indicates an error acquiring a lock level necessary to perform the requested operation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">GenericJDBCException</code> - a generic exception which did not fall into any of the other categories.
					</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663918990640">
      ⁠</a>4.3. EXTENDED Persistence Context</h1></div></div></div><div class="para">
			All application managed entity manager and container managed persistence contexts defined as such are <code class="literal">EXTENDED</code>. This means that the persistence context type goes beyond the transaction life cycle. We should then understand what happens to operations made outside the scope of a transaction.
		</div><div class="para">
			In an <code class="literal">EXTENDED</code> persistence context, all read only operations of the entity manager can be executed outside a transaction (<code class="literal">find()</code>, <code class="literal">getReference()</code>, <code class="literal">refresh()</code>, and read queries). Some modifications operations can be executed outside a transaction, but they are queued until the persistence context join a transaction: this is the case of <code class="literal">persist()</code>, <code class="literal"><code class="literal">merge()</code></code>, <code class="literal">remove()</code>. Some operations cannot be called outside a transaction: <code class="literal">flush()</code>, <code class="literal">lock()</code>, and update/delete queries.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140663936975184">
      ⁠</a>4.3.1. Container Managed Entity Manager</h2></div></div></div><div class="para">
				When using an EXTENDED persistence context with a container managed entity manager, the life cycle of the persistence context is binded to the life cycle of the Stateful Session Bean. Plus if the entity manager is created outside a transaction, modifications operations (persist, merge, remove) are queued in the persistence context and not executed to the database.
			</div><div class="para">
				When a method of the stateful session bean involved or starting a transaction is later called, the entity manager join the transaction. All queued operation will then be executed to synchronize the persistence context.
			</div><div class="para">
				This is perfect to implement the <code class="literal">entitymanager-per-conversation</code> pattern. A stateful session bean represents the conversation implementation. All intermediate conversation work will be processed in methods not involving transaction. The end of the conversation will be processed inside a <code class="literal">JTA</code> transaction. Hence all queued operations will be executed to the database and committed. If you are interested in the notion of conversation inside your application, have a look at JBoss Seam. Jboss Seam emphasizes the concept of conversation and entity manager life cycle and bind EJB3 and JSF together.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140663936970864">
      ⁠</a>4.3.2. Application Managed Entity Manager</h2></div></div></div><div class="para">
				Application-managed entity manager are always <code class="literal">EXTENDED</code>. When you create an entity manager inside a transaction, the entity manager automatically join the current transaction. If the entity manager is created outside a transaction, the entity manager will queue the modification operations. When
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="methodname">entityManager.joinTransaction()</code> is called when a JTA transaction is active for a <code class="literal">JTA</code> entity manager
					</div></li><li class="listitem"><div class="para">
						<code class="literal">entityManager.getTransaction().begin()</code> is called for a <code class="literal">RESOURCE_LOCAL</code> entity manager
					</div></li></ul></div><div class="para">
				the entity manager join the transaction and all the queued operations will then be executed to synchronize the persistence context.
			</div><div class="para">
				It is not legal to call <code class="methodname">entityManager.joinTransaction()</code> if no JTA transaction is involved.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transactions-optimistic">
      ⁠</a>4.4. Optimistic concurrency control</h1></div></div></div><div class="para">
			The only approach that is consistent with high concurrency and high scalability is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates (and to prevent lost updates). Hibernate provides for three possible approaches to writing application code that uses optimistic concurrency. The use cases we show are in the context of long application transactions but version checking also has the benefit of preventing lost updates in single database transactions.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic-manual">
      ⁠</a>4.4.1. Application version checking</h2></div></div></div><div class="para">
				In an implementation without much help from the persistence mechanism, each interaction with the database occurs in a new <code class="literal">EntityManager</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. This approach forces the application to carry out its own version checking to ensure application transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to EJB2 entities:
			</div><pre class="programlisting">// foo is an instance loaded by a previous entity manager
em = factory.createEntityManager();
EntityTransaction t = em.getTransaction();
t.begin();
int oldVersion = foo.getVersion();
Foo dbFoo = em.find( foo.getClass(), foo.getKey() ); // load the current state
if ( dbFoo.getVersion()!=foo.getVersion() ) 
    throw new StaleObjectStateException("Message", oldVersion); 
dbFoo.setProperty("bar");
t.commit();
em.close();</pre><div class="para">
				The <code class="literal">version</code> property is mapped using <code class="literal">@Version</code>, and the entity manager will automatically increment it during flush if the entity is dirty.
			</div><div class="para">
				Of course, if you are operating in a low-data-concurrency environment and do not require version checking, you may use this approach and just skip the version check. In that case, <span class="emphasis"><em>last commit wins</em></span> will be the default strategy for your long application transactions. Keep in mind that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes.
			</div><div class="para">
				Clearly, manual version checking is only feasible in very trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified objects have to be checked. Hibernate offers automatic version checking with either detached instances or an extended entity manager and persistence context as the design paradigm.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic-longsession">
      ⁠</a>4.4.2. Extended entity manager and automatic versioning</h2></div></div></div><div class="para">
				A single persistence context is used for the whole application transaction. The entity manager checks instance versions at flush time, throwing an exception if concurrent modification is detected. It's up to the developer to catch and handle this exception (common options are the opportunity for the user to merge his changes or to restart the business process with non-stale data).
			</div><div class="para">
				In an <code class="literal">EXTENDED</code> persistence context, all operations made outside an active transaction are queued. The <code class="literal">EXTENDED</code> persistence context is flushed when executed in an active transaction (at worse at commit time).
			</div><div class="para">
				The <code class="literal">Entity Manager</code> is disconnected from any underlying JDBC connection when waiting for user interaction. In an application-managed extended entity manager, this occurs automatically at transaction completion. In a stateful session bean holding a container-managed extended entity manager (i.e. a SFSB annotated with <code class="literal">@PersistenceContext(EXTENDED)</code>), this occurs transparently as well. This approach is the most efficient in terms of database access. The application need not concern itself with version checking or with merging detached instances, nor does it have to reload instances in every database transaction. For those who might be concerned by the number of connections opened and closed, remember that the connection provider should be a connection pool, so there is no performance impact. The following examples show the idiom in a non-managed environment:
			</div><pre class="programlisting">// foo is an instance loaded earlier by the extended entity manager
em.getTransaction().begin(); // new connection to data store is obtained and tx started
foo.setProperty("bar");
em.getTransaction().commit();  // End tx, flush and check version, disconnect</pre><div class="para">
				The <code class="literal">foo</code> object still knows which <code class="literal">persistence context</code> it was loaded in. With <code class="literal">getTransaction.begin();</code> the entity manager obtains a new connection and resumes the persistence context. The method <code class="literal">getTransaction().commit()</code> will not only flush and check versions, but also disconnects the entity manager from the JDBC connection and return the connection to the pool.
			</div><div class="para">
				This pattern is problematic if the persistence context is too big to be stored during user think time, and if you do not know where to store it. E.g. the <code class="literal">HttpSession</code> should be kept as small as possible. As the persistence context is also the (mandatory) first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. This is indeed recommended, as the persistence context will soon also have stale data.
			</div><div class="para">
				It is up to you where you store the extended entity manager during requests, inside an EJB3 container you simply use a stateful session bean as described above. Do not transfer it to the web layer (or even serialize it to a separate tier) to store it in the <code class="literal">HttpSession</code>. In a non-managed, two-tiered environment the <code class="literal">HttpSession</code> might indeed be the right place to store it.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic-detached">
      ⁠</a>4.4.3. Detached objects and automatic versioning</h2></div></div></div><div class="para">
				With this paradigm, each interaction with the data store occurs in a new persistence context. However, the same persistent instances are reused for each interaction with the database. The application manipulates the state of detached instances originally loaded in another persistence context and then merges the changes using <code class="literal">EntityManager.merge()</code>:
			</div><pre class="programlisting">// foo is an instance loaded by a non-extended entity manager
foo.setProperty("bar");
entityManager = factory.createEntityManager();
entityManager.getTransaction().begin();
managedFoo = entityManager.merge(foo);  // discard foo and from now on use managedFoo
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
				Again, the entity manager will check instance versions during flush, throwing an exception if conflicting updates occurred.
			</div></div></div></div></body></html>