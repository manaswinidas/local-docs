<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 6. Batch processing</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="batch">
      ⁠</a>Chapter 6. Batch processing</h1></div></div></div><div class="para">
		Batch processing has traditionally been difficult in full object/relational mapping. ORM is all about object state management, which implies that object state is available in memory. However, Hibernate has some features to optimize batch processing which are discussed in the Hibernate reference guide, however, EJB3 persistence differs slightly.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="batch-direct">
      ⁠</a>6.1. Bulk update/delete</h1></div></div></div><div class="para">
			As already discussed, automatic and transparent object/relational mapping is concerned with the management of object state. This implies that the object state is available in memory, hence updating or deleting (using SQL <code class="literal">UPDATE</code> and <code class="literal">DELETE</code>) data directly in the database will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statement execution which are performed through EJB-QL (<a class="xref" href="queryhql.html">Chapter 7, <em>EJB-QL: The Object Query Language</em></a>).
		</div><div class="para">
			The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? ClassName (WHERE WHERE_CONDITIONS)?</code>. Note that:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					In the from-clause, the FROM keyword is optional.
				</div></li><li class="listitem"><div class="para">
					There can only be a single class named in the from-clause, and it <span class="emphasis"><em>cannot</em></span> have an alias (this is a current Hibernate limitation and will be removed soon).
				</div></li><li class="listitem"><div class="para">
					No joins (either implicit or explicit) can be specified in a bulk EJB-QL query. Sub-queries may be used in the where-clause.
				</div></li><li class="listitem"><div class="para">
					The where-clause is also optional.
				</div></li></ul></div><div class="para">
			As an example, to execute an EJB-QL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method:
		</div><pre class="programlisting">EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();

String ejbqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = entityManager.createQuery( ejbqlUpdate )
                            .setParameter( "newName", newName )
                            .setParameter( "oldName", oldName )
                            .executeUpdate();
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
			To execute an EJB-QL <code class="literal">DELETE</code>, use the same <code class="literal">Query.executeUpdate()</code> method (the method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>):
		</div><pre class="programlisting">EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();

String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = entityManager.createQuery( hqlDelete )
                            .setParameter( "oldName", oldName )
                            .executeUpdate();
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
			The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicate the number of entities affected by the operation. This may or may not correlate with the number of rows affected in the database. An EJB-QL bulk operation might result in multiple actual SQL statements being executed, for joined-subclass, for example. The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritance hierarchy.
		</div></div></div></body></html>