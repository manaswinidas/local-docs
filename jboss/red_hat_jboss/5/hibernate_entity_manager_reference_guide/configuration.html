<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 2. Setup and configuration</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="configuration">
      ⁠</a>Chapter 2. Setup and configuration</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663929784544">
      ⁠</a>2.1. Setup</h1></div></div></div><div class="para">
			The EJB 3.0 / JPA compatible Hibernate EntityManager is built on top of Hibernate core and Hibernate Annotations. You have to use compatible versions of each module. Please consult the compatibility matrix in the hibernate.org download section. The following libraries have to be in your classpath: hibernate3.jar, hibernate-annotations.jar, hibernate-commons-annotations.jar, hibernate-entitymanager.jar and all needed third party libraries for each package (incl. ejb-persistence.jar).
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="setup-configuration">
      ⁠</a>2.2. Configuration and bootstrapping</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="setup-configuration-packaging">
      ⁠</a>2.2.1. Packaging</h2></div></div></div><div class="para">
				The configuration for entity managers both inside an application server and in a standalone application reside in a persistence archive. A persistence archive is a JAR file which must define a <code class="literal">persistence.xml</code> file that resides in the <code class="filename">META-INF</code> folder. All properly annotated classes included in the archive (ie having an <code class="literal">@Entity</code> annotation), all annotated packages and all Hibernate hbm.xml files included in the archive will be added to the persistence unit configuration, so by default, your persistence.xml will be quite minimalist:
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;
   &lt;persistence-unit name="sample"&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="para">
				Here's a more complete example of a <code class="filename"><code class="literal">persistence.xml</code></code> file
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;
   &lt;persistence-unit name="manager1" transaction-type="JTA"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;mapping-file&gt;ormap.xml&lt;/mapping-file&gt;
      &lt;jar-file&gt;MyApp.jar&lt;/jar-file&gt;
      &lt;class&gt;org.acme.Employee&lt;/class&gt;
      &lt;class&gt;org.acme.Person&lt;/class&gt;
      &lt;class&gt;org.acme.Address&lt;/class&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="variablelist"><dl class="variablelist compact"><dt><span class="term"><code class="code">name</code></span></dt><dd><div class="para">
							(attribute) Every entity manager must have a name.
						</div></dd><dt><span class="term"><code class="code">transaction-type</code></span></dt><dd><div class="para">
							(attribute) Transaction type used. Either JTA or RESOURCE_LOCAL (default to JTA in a JavaEE environment and to RESOURCE_LOCAL in a JavaSE environment). When a jta-datasource is used, the default is JTA, if non-jta-datasource is used, RESOURCE_LOCAL is used.
						</div></dd><dt><span class="term"><code class="code">provider</code></span></dt><dd><div class="para">
							The provider is a fully-qualified class name of the EJB Persistence provider. You do not have to define it if you do not work with several EJB3 implementations. This is needed when you are using multiple vendor implementations of EJB Persistence.
						</div></dd><dt><span class="term"><code class="code">jta-data-source</code>, <code class="code">non-jta-data-source</code></span></dt><dd><div class="para">
							This is the JNDI name of where the javax.sql.DataSource is located. When running without a JNDI available Datasource, you must specify JDBC connections with Hibernate specific properties (see below).
						</div></dd><dt><span class="term"><code class="code">mapping-file</code></span></dt><dd><div class="para">
							The class element specifies a EJB3 compliant XML mapping file that you will map. The file has to be in the classpath. As per the EJB3 specification, Hibernate EntityManager will try to load the mapping file located in the jar file at <code class="literal">META_INF/orm.xml</code>. Of course any explicit mapping file will be loaded too. As a matter of fact, you can provide any XML file in the mapping file element ie. either hbm files or EJB3 deployment descriptor.
						</div></dd><dt><span class="term"><code class="code">jar-file</code></span></dt><dd><div class="para">
							The jar-file elements specifies a jar to analyse. All properly annotated classes, annotated packages and all hbm.xml files part of this jar file will be added to the persistence unit configuration. This element is mainly used in Java EE environment. Use of this one in Java SE should be considered as non portable, in this case a absolute url is needed. You can alternatively point to a directory (This is especially useful when in your test environment, the persistence.xml file is not under the same root directory or jar than your domain model).
						</div><pre class="programlisting">        &lt;jar-file&gt;file:/home/turin/work/local/lab8/build/classes&lt;/jar-file&gt;</pre></dd><dt><span class="term"><code class="code">exclude-unlisted-classes</code></span></dt><dd><div class="para">
							Do not check the main jar file for annotated classes. Only explicit classes will be part of the persistence unit.
						</div></dd><dt><span class="term"><code class="code">class</code></span></dt><dd><div class="para">
							The class element specifies a fully qualified class name that you will map. By default all properly annotated classes and all hbm.xml files found inside the archive are added to the persistence unit configuration. You can add some external entity through the class element though. As an extension to the specification, you can add a package name in the <code class="literal">&lt;class&gt;</code> element (eg <code class="code">&lt;class&gt;org.hibernate.eg&lt;/class&gt;</code>). Specifying a package in the <code class="literal">&lt;class&gt;</code> element will include only the annotated classes.
						</div></dd><dt><span class="term"><code class="code">properties</code></span></dt><dd><div class="para">
							The properties element is used to specify vendor specific properties. This is where you will define your Hibernate specific configurations. This is also where you will have to specify JDBC connection information as well.
						</div></dd></dl></div><div class="para">
				Be sure to define the grammar definition in the <code class="literal">persistence</code> element since the EJB3 specification requires the schema validation. If the systemId ends with <code class="literal">persistence_1_0.xsd</code>, Hibernate entityManager will use the version embedded in the hibernate-entitymanager.jar. No internet access will be performed.
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="setup-configuration-bootstrapping">
      ⁠</a>2.2.2. Bootstrapping</h2></div></div></div><div class="para">
				The EJB3 specification defines a bootstrap procedure to access the <code class="classname">EntityManagerFactory</code> and the <code class="classname">EntityManager</code>. The bootstrap class is <code class="classname">javax.persistence.Persistence</code>, e.g.
			</div><pre class="programlisting">EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1");
//or
Map configOverrides = new HashMap();
configOverrides.put("hibernate.hbm2ddl.auto", "create-drop");
EntityManagerFactory programmaticEmf =
    Persistence.createEntityManagerFactory("manager1", configOverrides);</pre><div class="para">
				The first version is equivalent to the second with an empty map. The map version is a set of overrides that will take precedence over any properties defined in your persistence.xml files. There are a couple of EJB3 properties usable in the map:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						javax.persistence.provider to define the provider class used
					</div></li><li class="listitem"><div class="para">
						javax.persistence.transactionType to define the transaction type used (either JTA or RESOURCE_LOCAL)
					</div></li><li class="listitem"><div class="para">
						javax.persistence.jtaDataSource to define the JTA datasource name in JNDI
					</div></li><li class="listitem"><div class="para">
						javax.persistence.nonJtaDataSource to define the non JTA datasource name in JNDI
					</div></li></ul></div><div class="para">
				When <code class="code">Persistence.createEntityManagerFactory()</code> is called, the persistence implementation will search your classpath for any <code class="code">META-INF/persistence.xml</code> files using the <code class="code">ClassLoader.getResource("META-INF/persistence.xml")</code> method. Actually the <code class="classname">Persistence</code> class will look at all the Persistence Providers available in the classpath and ask each of them if they are responsible for the creation of the entity manager factory <code class="literal">manager1</code>. From the list of resources available from each provider, the persistence implementation will search for an entity manager that whose name in <code class="filename">persistence.xml</code> matches the name specified at the command line. (The provider <code class="literal">element</code> must match the current persistence provider.) If no persistence.xml with the correct name is found or if the expected persistence provider is not found, a <code class="classname">PersistenceException</code> is raised.
			</div><div class="para">
				Apart from Hibernate system-level settings, all the properties available in Hibernate can be set in <code class="code">properties</code> element of the persistence.xml file or as an override in the map you pass to <code class="code">createEntityManagerFactory()</code>. Please refer to the Hibernate reference documentation for a complete listing. There are however a couple of properties available in the EJB3 provider only.
			</div><div class="para">

			</div><div class="table"><a id="idm140663938399584">
      ⁠</a><p class="title"><strong>Table 2.1. Hibernate Entity Manager specific properties</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Hibernate Entity Manager specific properties"><colgroup><col style="text-align: left" class="c1" width="33%"/><col width="67%" class="c2"/></colgroup><thead><tr><th style="text-align: left"> Property name </th><th> Description </th></tr></thead><tbody><tr><td style="text-align: left"> hibernate.ejb.classcache. &lt;classname&gt; </td><td> class cache strategy [comma cache region] of the class Default to no cache, and default region cache to fully.qualified.classname (eg. hibernate.ejb.classcache.com.acme.Cat read-write or hibernate.ejb.classcache.com.acme.Cat read-write, MyRegion). </td></tr><tr><td style="text-align: left"> hibernate.ejb.collectioncache. &lt;collectionrole&gt; </td><td> collection cache strategy [comma cache region] of the class Default to no cache, and default region cache to fully.qualified.classname.role (eg. hibernate.ejb.classcache.com.acme.Cat read-write or hibernate.ejb.classcache.com.acme.Cat read-write, MyRegion). </td></tr><tr><td style="text-align: left"> hibernate.ejb.cfgfile </td><td> XML configuration file to use to configure Hibernate (eg. <code class="filename">/hibernate.cfg.xml</code>). </td></tr><tr><td style="text-align: left"> hibernate.archive. autodetection </td><td> Determine which element is auto discovered by Hibernate Entity Manager while parsing the .par archive. (default to <code class="literal">class,hbm</code>). </td></tr><tr><td style="text-align: left"> hibernate.ejb. interceptor </td><td> An optional Hibernate interceptor. The interceptor instance is shared by all <code class="classname">Session</code> instances. This interceptor has to implement <code class="classname">org.hibernate.Interceptor</code> and have a no-arg constructor. This property can not be combined with <code class="literal">hibernate.ejb.interceptor.session_scoped</code>. </td></tr><tr><td style="text-align: left"> hibernate.ejb.interceptor. session_scoped </td><td> An optional Hibernate interceptor. The interceptor instance is specific to a given <code class="classname">Session</code> instance (and hence can be non thread-safe). This interceptor has to implement <code class="classname">org.hibernate.Interceptor</code> and have a no-arg constructor. This property can not be combined with <code class="literal">hibernate.ejb.interceptor</code>. </td></tr><tr><td style="text-align: left"> hibernate.ejb.naming_strategy </td><td> An optional naming strategy. The default naming strategy used is <code class="classname">EJB3NamingStrategy</code>. You also might want to consider the <code class="classname">DefaultComponentSafeNamingStrategy</code>. </td></tr><tr><td style="text-align: left"> hibernate.ejb.event. &lt;eventtype&gt; </td><td> Event listener list for a given eventtype. The list of event listeners is a comma separated fully qualified class name list (eg. hibernate.ejb.event.pre-load com.acme.SecurityListener, com.acme.AuditListener) </td></tr><tr><td style="text-align: left"> hibernate.ejb. use_class_enhancer </td><td> Whether or not use Application server class enhancement at deployment time (default to false) </td></tr><tr><td style="text-align: left"> hibernate.ejb. discard_pc_on_close </td><td> If true, the persistence context will be discarded (think clear() when the method is called. Otherwise the persistence context will stay alive till the transaction completion: all objects will remain managed, and any change will be synchronized with the database (default to false, ie wait the transaction completion) </td></tr></tbody></table></div></div><div class="para">
				Note that you can mix XML <code class="literal">&lt;class&gt;</code> declaration and <code class="literal">hibernate.ejb.cfgfile</code> usage in the same configuration. Be aware of the potential clashes. The properties set in <code class="filename">persistence.xml</code> will override the one in the defined <code class="filename">hibernate.cfg.xml</code>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					It is important that you do not override <code class="literal">hibernate.transaction.factory_class</code>, Hibernate EntityManager automatically set the appropriate transaction factory depending on the EntityManager type (ie <code class="literal">JTA</code> versus <code class="literal">RESOURSE_LOCAL</code>). If you are working in a Java EE environment, you might want to set the <code class="literal">hibernate.transaction.manager_lookup_class</code> though.
				</div></div></div><div class="para">
				Here is a typical configuration in a J2SE environment
			</div><pre class="programlisting">&lt;persistence&gt;
   &lt;persistence-unit name="manager1" transaction-type="RESOURCE_LOCAL"&gt;
      &lt;class&gt;org.hibernate.ejb.test.Cat&lt;/class&gt;
      &lt;class&gt;org.hibernate.ejb.test.Distributor&lt;/class&gt;
      &lt;class&gt;org.hibernate.ejb.test.Item&lt;/class&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver"/&gt;
         &lt;property name="hibernate.connection.username" value="sa"/&gt;
         &lt;property name="hibernate.connection.password" value=""/&gt;
         &lt;property name="hibernate.connection.url" value="jdbc:hsqldb:."/&gt;
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
       
         &lt;!-- cache configuration --&gt;
         &lt;property name="hibernate.ejb.classcache.org.hibernate.ejb.test.Item" value="read-write"/&gt;
         &lt;property name="hibernate.ejb.collectioncache.org.hibernate.ejb.test.Item.distributors" value="read-write, RegionName"/&gt;

         &lt;!-- alternatively to &lt;class&gt; and &lt;property&gt; declarations, you can use a regular hibernate.cfg.xml file --&gt;
         &lt;!-- property name="hibernate.ejb.cfgfile" value="/org/hibernate/ejb/test/hibernate.cfg.xml"/ --&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="para">
				To ease the programmatic configuration, Hibernate Entity Manager provides a proprietary API. This API is very similar to the Configuration API and share the same concepts: <code class="literal">Ejb3Configuration</code>. Refer to the JavaDoc and the <code class="literal">Hibernate Core Reference Guide</code> for more detailed information on how to use it.
			</div><pre class="programlisting">Ejb3Configuration cfg = new Ejb3Configuration();
EntityManagerFactory emf = 
  cfg.addProperties( properties ) //add some properties
     .setInterceptor( myInterceptorImpl ) // set an interceptor
     .addAnnotatedClass( MyAnnotatedClass.class ) //add a class to be mapped
     .addClass( NonAnnotatedClass.class ) //add an hbm.xml file using the Hibernate convention
     .addResource( "mypath/MyOtherCLass.hbm.xml" ) //add an hbm.xml file
     .addResource( "mypath/orm.xml" ) //add an EJB3 deployment descriptor
     .configure("/mypath/hibernate.cfg.xml") //add a regular hibernate.cfg.xml
     .buildEntityManagerFactory(); //Create the entity manager factory</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663881354976">
      ⁠</a>2.3. Event listeners</h1></div></div></div><div class="para">
			Hibernate Entity Manager needs to enhance Hibernate core to implements all the EJB3 semantics. It does that through the event listener system of Hibernate. Be careful when you use the event system yourself, you might override some of the EJB3 semantics. A safe way is to add your event listeners to the list given below.
		</div><div class="table"><a id="idm140663881353392">
      ⁠</a><p class="title"><strong>Table 2.2. Hibernate Entity Manager default event listeners</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-14-rows" summary="Hibernate Entity Manager default event listeners"><colgroup><col style="text-align: left" class="c1" width="33%"/><col width="67%" class="c2"/></colgroup><thead><tr><th style="text-align: left"> Event </th><th> Listeners </th></tr></thead><tbody><tr><td style="text-align: left"> flush </td><td> org.hibernate.ejb.event.EJB3FlushEventListener </td></tr><tr><td style="text-align: left"> auto-flush </td><td> org.hibernate.ejb.event.EJB3AutoFlushEventListener </td></tr><tr><td style="text-align: left"> delete </td><td> org.hibernate.ejb.event.EJB3DeleteEventListener </td></tr><tr><td style="text-align: left"> flush-entity </td><td> org.hibernate.ejb.event.EJB3FlushEntityEventListener </td></tr><tr><td style="text-align: left"> merge </td><td> org.hibernate.ejb.event.EJB3MergeEventListener </td></tr><tr><td style="text-align: left"> create </td><td> org.hibernate.ejb.event.EJB3PersistEventListener </td></tr><tr><td style="text-align: left"> create-onflush </td><td> org.hibernate.ejb.event.EJB3PersistOnFlushEventListener </td></tr><tr><td style="text-align: left"> save </td><td> org.hibernate.ejb.event.EJB3SaveEventListener </td></tr><tr><td style="text-align: left"> save-update </td><td> org.hibernate.ejb.event.EJB3SaveOrUpdateEventListener </td></tr><tr><td style="text-align: left"> pre-insert </td><td> org.hibernate.secure.JACCPreInsertEventListener, org.hibernate.valitator.event.ValidateEventListener </td></tr><tr><td style="text-align: left"> pre-insert </td><td> org.hibernate.secure.JACCPreUpdateEventListener, org.hibernate.valitator.event.ValidateEventListener </td></tr><tr><td style="text-align: left"> pre-delete </td><td> org.hibernate.secure.JACCPreDeleteEventListener </td></tr><tr><td style="text-align: left"> pre-load </td><td> org.hibernate.secure.JACCPreLoadEventListener </td></tr><tr><td style="text-align: left"> post-delete </td><td> org.hibernate.ejb.event.EJB3PostDeleteEventListener </td></tr><tr><td style="text-align: left"> post-insert </td><td> org.hibernate.ejb.event.EJB3PostInsertEventListener </td></tr><tr><td style="text-align: left"> post-load </td><td> org.hibernate.ejb.event.EJB3PostLoadEventListener </td></tr><tr><td style="text-align: left"> post-update </td><td> org.hibernate.ejb.event.EJB3PostUpdateEventListener </td></tr></tbody></table></div></div><div class="para">
			Note that the JACC*EventListeners are removed if the security is not enabled.
		</div><div class="para">
			You can configure the event listeners either through the properties (see <a class="xref" href="configuration.html#setup-configuration">Section 2.2, “Configuration and bootstrapping”</a>) or through the <code class="methodname">Ejb3Configuration.getEventListeners()</code> API.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663942226144">
      ⁠</a>2.4. Obtaining an EntityManager in a Java SE environment</h1></div></div></div><div class="para">
			An entity manager factory should be considered as an immutable configuration holder, it is defined to point to a single datasource and to map a defined set of entities. This is the entry point to create and manage <code class="classname">EntityManager</code>s. The <code class="classname">Persistence</code> class is bootstrap class to create an entity manager factory.
		</div><pre class="programlisting">// Use persistence.xml configuration
EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1");
EntityManager em = emf.createEntityManager(); // Retrieve an application managed entity manager
// Work with the EM
em.close();
...
emf.close(); //close at application end</pre><div class="para">
			An entity manager factory is typically created at application initialization time and closed at application end. It's creation is an expensive process. For those who are familiar with Hibernate, an entity manager factory is very much like a session factory. Actually, an entity manager factory is a wrapper on top of a session factory. Calls to the entityManagerFactory are thread safe.
		</div><div class="para">
			Thanks to the EntityManagerFactory, you can retrieve an extended entity manager. The extended entity manager keep the same persistence context for the lifetime of the entity manager: in other words, the entities are still managed between two transactions (unless you call entityManager.clear() in between). You can see an entity manager as a small wrapper on top of an Hibernate session.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663932741680">
      ⁠</a>2.5. Various</h1></div></div></div><div class="para">
			Hibernate Entity Manager comes with Hibernate Validator configured out of the box. You do not have to override any event yourself. If you do not use Hibernate Validator annotations in your domain model, there will be no performance cost. For more information on Hibernate Validator, please refer to the Hibernate Annotations reference guide.
		</div></div></div></body></html>