<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 5. Entity listeners and Callback methods</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="listeners">
      ⁠</a>Chapter 5. Entity listeners and Callback methods</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663926276944">
      ⁠</a>5.1. Definition</h1></div></div></div><div class="para">
			It is often useful for the application to react to certain events that occur inside the persistence mechanism. This allows the implementation of certain kinds of generic functionality, and extension of built-in functionality. The EJB3 specification provides two related mechanisms for this purpose.
		</div><div class="para">
			A method of the entity may be designated as a callback method to receive notification of a particular entity life cycle event. Callbacks methods are annotated by a callback annotation. You can also define an entity listener class to be used instead of the callback methods defined directly inside the entity class. An entity listener is a stateless class with a no-arg constructor. An entity listener is defined by annotating the entity class with the <code class="literal">@EntityListeners</code> annotation:
		</div><pre class="programlisting">@Entity 
@EntityListeners(class=Audit.value)
public class Cat {
    @Id private Integer id;
    private String name;
    private Date dateOfBirth;
    @Transient private int age;
    private Date lastUpdate;
    //getters and setters

    /**
     * Set my transient property at load time based on a calculation,
     * note that a native Hibernate formula mapping is better for this purpose.
     */
    @PostLoad
    public void calculateAge() {
        Calendar birth = new GregorianCalendar();
        birth.setTime(dateOfBirth);
        Calendar now = new GregorianCalendar();
        now.setTime( new Date() );
        int adjust = 0;
        if ( now.get(Calendar.DAY_OF_YEAR) - birth.get(Calendar.DAY_OF_YEAR) &lt; 0) {
            adjust = -1;
        }
        age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR) + adjust;
    }
}

public class LastUpdateListener {
    /**
     * automatic property set before any database persistence
     */
    @PreUpdate
    @PrePersist
    public void setLastUpdate(Cat o) {
        o.setLastUpdate( new Date() );
    }
}</pre><div class="para">
			The same callback method or entity listener method can be annotated with more than one callback annotation. For a given entity, you cannot have two methods being annotated by the same callback annotation whether it is a callback method or an entity listener method. A callback method is a no-arg method with no return type and any arbitrary name. An entity listener has the signature <code class="code">void &lt;METHOD&gt;(Object)</code> where Object is of the actual entity type (note that Hibernate Entity Manager relaxed this constraint and allows <code class="literal">Object</code> of <code class="literal">java.lang.Object</code> type (allowing sharing of listeners across several entities.)
		</div><div class="para">
			A callback method can raise a <code class="classname">RuntimeException</code>. The current transaction, if any, must be rolled back. The following callbacks are defined:
		</div><div class="table"><a id="idm140663921777632">
      ⁠</a><p class="title"><strong>Table 5.1. Callbacks</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Callbacks"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: center"> Type </th><th style="text-align: center"> Description </th></tr></thead><tbody><tr><td> @PrePersist </td><td> Executed before the entity manager persist operation is actually executed or cascaded. This call is synchronous with the persist operation. </td></tr><tr><td> @PreRemove </td><td> Executed before the entity manager remove operation is actually executed or cascaded. This call is synchronous with the remove operation. </td></tr><tr><td> @PostPersist </td><td> Executed after the entity manager persist operation is actually executed or cascaded. This call is invoked after the database INSERT is executed. </td></tr><tr><td> @PostRemove </td><td> Executed after the entity manager remove operation is actually executed or cascaded. This call is synchronous with the remove operation. </td></tr><tr><td> @PreUpdate </td><td> Executed before the database UPDATE operation. </td></tr><tr><td> @PostUpdate </td><td> Executed after the database UPDATE operation. </td></tr><tr><td> @PostLoad </td><td> Executed after an entity has been loaded into the current persistence context or an entity has been refreshed. </td></tr></tbody></table></div></div><div class="para">
			A callback method must not invoke <code class="classname">EntityManager</code> or <code class="classname">Query</code> methods!
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="important"><div class="admonition_header"><p><strong>Exception When Flushing Lazy Connections or Proxies</strong></p></div><div class="admonition"><div class="para">
				You cannot initialize lazy collections or proxies during a flush as the method call causes an exception.
			</div><div class="para">
				When accessing a lazy collection with a Hibernate event, the corresponding CollectionEntry of the lazily-loaded collection is added to the PersistenceContext. On flush, Hibernate accesses the added collection values and crashes because the collection was neither processed nor set to be ignored.
			</div><div class="para">
				The following workaround creates another session, which initializes the lazy collections before the original session calls the flush method:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>SessionImplementor si = (SessionImplementor)(event.<span xmlns="" class="perl_Function">getSession</span>());
<span xmlns="" class="line">​</span>Session anotherSession = si.<span xmlns="" class="perl_Function">getFactory</span>().<span xmlns="" class="perl_Function">openSession</span>(si.<span xmlns="" class="perl_Function">getJDBCContext</span>().<span xmlns="" class="perl_Function">connection</span>());
<span xmlns="" class="line">​</span>Object obj = anotherSession.<span xmlns="" class="perl_Function">get</span>( event.<span xmlns="" class="perl_Function">getEntity</span>().<span xmlns="" class="perl_Function">getClass</span>(),event.<span xmlns="" class="perl_Function">getId</span>());
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">if</span>(obj <span xmlns="" class="perl_Keyword">instanceof</span> Parent){
<span xmlns="" class="line">​</span>   Parent parent = (Parent)obj;
<span xmlns="" class="line">​</span>   Iterator it = parent.<span xmlns="" class="perl_Function">getChildren</span>().<span xmlns="" class="perl_Function">iterator</span>();
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">while</span>(it.<span xmlns="" class="perl_Function">hasNext</span>()){
<span xmlns="" class="line">​</span>       Child child = (Child)it.<span xmlns="" class="perl_Function">next</span>();
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}
<span xmlns="" class="line">​</span>anotherSession.<span xmlns="" class="perl_Function">close</span>()
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663919838144">
      ⁠</a>5.2. Callbacks and listeners inheritance</h1></div></div></div><div class="para">
			You can define several entity listeners per entity at different level of the hierarchy.You can also define several callbacks at different level of the hierarchy. But you cannot define two listeners for the same event in the same entity or the same entity listener.
		</div><div class="para">
			When an event is raised, the listeners are executed in this order:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">@EntityListeners</code> for a given entity or superclass in the array order
				</div></li><li class="listitem"><div class="para">
					Entity listeners for the superclasses (highest first)
				</div></li><li class="listitem"><div class="para">
					Entity Listeners for the entity
				</div></li><li class="listitem"><div class="para">
					Callbacks of the superclasses (highest first)
				</div></li><li class="listitem"><div class="para">
					Callbacks of the entity
				</div></li></ul></div><div class="para">
			You can stop the entity listeners inheritance by using the <code class="literal">@ExcludeSuperclassListeners</code>, all superclasses <code class="literal">@EntityListeners</code> will then be ignored.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663932490944">
      ⁠</a>5.3. XML definition</h1></div></div></div><div class="para">
			The EJB3 specification allows annotation overriding through EJB3 deployment descriptor. There is also an additional feature that can be useful: default event listeners.
		</div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd"
                 version="1.0"
        &gt;
    &lt;persistence-unit-metadata&gt;
        &lt;persistence-unit-defaults&gt;
            &lt;entity-listeners&gt;
                &lt;entity-listener class="org.hibernate.ejb.test.pack.defaultpar.IncrementListener"&gt;
                    &lt;pre-persist method-name="increment"/&gt;
                &lt;/entity-listener&gt;
            &lt;/entity-listeners&gt;
        &lt;/persistence-unit-defaults&gt;
    &lt;/persistence-unit-metadata&gt;
    &lt;package&gt;org.hibernate.ejb.test.pack.defaultpar&lt;/package&gt;
    &lt;entity class="ApplicationServer"&gt;
        &lt;entity-listeners&gt;
            &lt;entity-listener class="OtherIncrementListener"&gt;
                &lt;pre-persist method-name="increment"/&gt;
            &lt;/entity-listener&gt;
        &lt;/entity-listeners&gt;


        &lt;pre-persist method-name="calculate"/&gt;
    &lt;/entity&gt;
&lt;/entity-mappings&gt;</pre><div class="para">
			You can override entity listeners on a given entity. An entity listener correspond to a given class and one or several event fire a given method call. You can also define event on the entity itself to describe the callbacks.
		</div><div class="para">
			Last but not least, you can define some default entity listeners that will apply first on the entity listener stack of all the mapped entities of a given persistence unit. If you do not want an entity to inherit the default listeners, you can use @ExcludeDefaultListeners (or &lt;exclude-default-listeners/&gt;).
		</div></div></div></body></html>