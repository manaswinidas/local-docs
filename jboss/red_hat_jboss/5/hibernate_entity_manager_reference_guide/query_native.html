<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 8. Native query</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="query_native">
      ⁠</a>Chapter 8. Native query</h1></div></div></div><div class="para">
		You may also express queries in the native SQL dialect of your database. This is useful if you want to utilize database specific features such as query hints or the CONNECT BY option in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate. Note that Hibernate allows you to specify handwritten SQL (including stored procedures) for all create, update, delete, and load operations (please refer to the reference guide for more information.)
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663921160496">
      ⁠</a>8.1. Expressing the resultset</h1></div></div></div><div class="para">
			To use a SQL query, you need to describe the SQL resultset. This description will help the <code class="literal">EntityManager</code> to map your columns onto entity properties. This is done using the <code class="literal">@SqlResultSetMapping</code> annotation. Each <code class="literal">@SqlResultSetMapping </code>has a name which is used when creating a SQL query on <code class="literal">EntityManager</code>.
		</div><pre class="programlisting">@SqlResultSetMapping(name="GetNightAndArea", 
    entities={
        @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class, fields
        = {
          @FieldResult(name="id", column="nid"),
          @FieldResult(name="duration", column="night_duration"),
          @FieldResult(name="date", column="night_date"),
          @FieldResult(name="area", column="area_id")
        }),
        @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields
        = {
          @FieldResult(name="id", column="aid"),
          @FieldResult(name="name", column="name")
        })
    }
)

@SqlResultSetMapping(name="defaultSpaceShip",
entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class))</pre><div class="para">
			You can also define scalar results and even mix entity results and scalar results
		</div><pre class="programlisting">@SqlResultSetMapping(name="ScalarAndEntities",
  entities={
      @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class,
      fields = {
          @FieldResult(name="id", column="nid"),
          @FieldResult(name="duration", column="night_duration"),
          @FieldResult(name="date", column="night_date"),
          @FieldResult(name="area", column="area_id")
      }),
      @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class,
      fields = {
          @FieldResult(name="id", column="aid"),
          @FieldResult(name="name", column="name")
      })
  },
  columns={
      @ColumnResult(name="durationInSec")
  }
)</pre><div class="para">
			The SQL query will then have to return a column alias <code class="literal">durationInSec</code>.
		</div><div class="para">
			Please refer to the Hibernate Annotations reference guide for more information about <code class="literal">@SqlResultSetMapping.</code>
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663929520688">
      ⁠</a>8.2. Using native SQL Queries</h1></div></div></div><div class="para">
			Now that the result set is described, we are capable of executing the native SQL query. <code class="literal">EntityManager</code> provides all the needed APIs. The first method is to use a SQL resultset name to do the binding, the second one uses the entity default mapping (the column returned has to have the same names as the one used in the mapping). A third one (not yet supported by Hibernate entity manager), returns pure scalar results.
		</div><pre class="programlisting">String sqlQuery = "select night.id nid, night.night_duration, night.night_date, area.id aid, "
    + "night.area_id, area.name from Night night, Area area where night.area_id = area.id "
    + "and night.night_duration &gt;= ?";
Query q = entityManager.createNativeQuery(sqlQuery, "GetNightAndArea");
q.setParameter( 1, expectedDuration );
q.getResultList();</pre><div class="para">
			This native query returns nights and area based on the <code class="literal">GetNightAndArea</code> result set.
		</div><pre class="programlisting">String sqlQuery = "select * from tbl_spaceship where owner = ?";
Query q = entityManager.createNativeQuery(sqlQuery, SpaceShip.class);
q.setParameter( 1, "Han" );
q.getResultList();</pre><div class="para">
			The second version is useful when your SQL query returns one entity reusing the same columns as the ones mapped in metadata.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140663928811600">
      ⁠</a>8.3. Named queries</h1></div></div></div><div class="para">
			Native named queries share the same calling API than EJB-QL named queries. Your code does not need to know the difference between the two. This is very useful for migration from SQL to EJB-QL:
		</div><pre class="programlisting">Query q = entityManager.createNamedQuery("getSeasonByNativeQuery");
q.setParameter( 1, name );
Season season = (Season) q.getSingleResult();</pre></div></div></body></html>