<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 5. Java Connector Architecture</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Performance_Tuning_Guide-Java_Connector_Architecture">
      ⁠</a>Chapter 5. Java Connector Architecture</h1></div></div></div><div class="para">
		Within the platform, Java Connector Architecture (JCA) is used in two main areas: integration with data sources, such as relational databases, and integration with JMS providers. In EAP 5.1.2 and above, two JMS providers are available: JBoss Messaging technology, and the newer HornetQ technology. External JMS providers can be integrated through their provided JCA resource adapters. This chapter will cover data sources and their respective parameters, also JMS integration and its relevant parameters.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-Data_Sources">
      ⁠</a>5.1. Data Sources</h1></div></div></div><div class="para">
			Data sources are the means of defining the properties of a relational database. This is done with a <code class="filename">*-ds.xml</code> file in the <code class="filename">deploy</code> directory of a specific configuration. The platform ships with examples for quite a few relational databases, and there is a complete list of certified relational databases on the JBoss Enterprise Application Platform product pages of the Red Hat website. A data source definition has many parameters but the focus here is on two specific parameters: min-pool-size and max-pool-size.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-Data_source_connection_pooling">
      ⁠</a>5.2. Data source connection pooling</h1></div></div></div><div class="para">
			When connecting to a data source, JBoss Enterprise Application Platform must allocate resources and de-allocate resources for every connection. This is quite expensive in terms of time and system resources. Connection pooling reduces the cost of data source connections by creating a number ("pool") of data source connections available to be shared by applications. Pooling data source connections is much more efficient than allocating and de-allocating resources on demand. There are third-party alternatives for data source pooling but the native method is already included and avoids an extra layer of complexity.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-Minimum_pool_size">
      ⁠</a>5.3. Minimum pool size</h1></div></div></div><div class="para">
			The <code class="filename">min-pool-size</code> data source parameter defines the minimum size of the connection pool. The default minimum is zero connections, so if a minimum pool size is not specified, no connections will be created in the connection pool when the platform starts. As data source transactions occur, connections will be requested but because the pool defaults to zero on start up, none will be available. The connection pool examines the minimum and maximum parameters, creates connections and places them in the pool. Users of any affected application will experience a delay while this occurs. During periods of inactivity the connection pool will shrink, possibly to the minimum value, and later when transactions later occur application performance will again suffer.
		</div><div class="figure"><a id="figu-Performance_Tuning_Guide-Minimum_pool_size-Data_Source_Metrics">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/img-admin_console_datasource_metrics_1.png" width="444" alt="Data Source Metrics"/></div></div><p class="title"><strong>Figure 5.1. Data Source Metrics</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-Maximum_pool_size">
      ⁠</a>5.4. Maximum pool size</h1></div></div></div><div class="para">
			The <code class="literal">max-pool-size parameter</code> data source parameter defines the maximum size of the connection pool. It's more important that the <code class="literal">min-pool-size</code> parameter because it limits the number of active connections to the data source and so the concurrent activity on the data source. If this value is set too low it's likely that the platform's hardware resources will be underutilized.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Setting the <code class="literal">max-pool-size</code> too low is a common configuration error.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-Balancing_pool_size_values">
      ⁠</a>5.5. Balancing pool size values</h1></div></div></div><div class="para">
			The aim of adjusting the min-pool-size and max-pool-size pool values is to allow all possible concurrent database activity to execute, and so maximize throughput. To do this requires an understanding of how much concurrent activity in the server is occurring. As a guide of concurrent activity, look at the platform's thread pools to see how many threads are active. This is available through the administration console, as in the following screenshot:
		</div><div class="figure"><a id="figu-Performance_Tuning_Guide-Balancing_pool_size_values-JMX_Console_Datasource_Metrics">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/img-admin_console_connectors_metrics_1.png" width="444" alt="JMX Console Datasource Metrics"/></div></div><p class="title"><strong>Figure 5.2. JMX Console Datasource Metrics</strong></p></div><div class="para">
			In this example there were 81 active threads in the JBoss Web HTTP connector, which is the primary thread pool in the test used for this illustration. That number is to be expected because there were 80 users, with no think times between requests, and response times were between 18 and 20 ms on average. Having 81 threads active accounts for the continued use of the 80 users, plus the one user for the administration console itself. Most of the time the actual number of active threads was actually only 80, but when the refresh button is clicked, the administration console consumed a thread during its collection of the data. In this example, you may presume that the maximum size of the connection pool should at least be 80 but it may not be as simple as it appears.
		</div><div class="figure"><a id="figu-Performance_Tuning_Guide-Balancing_pool_size_values-Admin_Console_Datasource_Metrics">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/img-admin_console_datasource_metrics_2.png" width="444" alt="Admin Console Datasource Metrics"/></div></div><p class="title"><strong>Figure 5.3. Admin Console Datasource Metrics</strong></p></div><div class="para">
			In looking at the data source metrics in the administration console, the “Max Connections In Use Count” is reported as 80. With 80 concurrent users and each transaction performing database transactions, a value of 80 seems obvious. In various situations, though, this figure may be misleading. If “Max Connections in Use Count” equals the max-pool-size parameter then this value is meaningless. It's also possible that the thread pools have many more active threads than threads that will eventually hit the database. Also there may be multiple thread pools in use within the platform, each with their own data access characteristics. Finally, it's possible for an EJB 3 application to skew the number of connections needed.
		</div><div class="para">
			It's a requirement of the EJB 3 specifications that each bean that has an entity manager injected into it also have a unique instance of the entity manager. This has an indirect influence on the database connection pool sizing. Since Hibernate is the JPA provider, a unique instance of an entity manager and a Hibernate session, this requires a database connection for the queries within that entity manager and Hibernate session. In the case of a simple application, where stateless session beans execute queries and never call other stateless session beans, a single database connection is consumed for that processing. In a more complex application, assume there's a stateless session bean that executes queries but also calls on other stateless sessions beans. Because that also execute queries, there are multiple entity managers, potentially consuming multiple database connections and all participating in the same transaction. In a more complex example again, assume there's a stateless session bean that puts a message on a JMS queue, then does some further processing that executes queries and asynchronously, a message driven bean de-queues that message and does some processing that executes queries. From these examples it's evident that the more complex the application structure, the harder it will be to determine just how many connections may be used. This is even further complicated by the speed at which connections can be returned to the pool for reuse, and how fast they can be enlisted in a transaction when reused from the pool. One technique you can use is to continue increasing the maximum pool size until the “Max Connections In Use Count” stays below the maximum size parameter of the pool. This may not be possible in a production environment so a test environment is recommended.
		</div><div class="para">
			There's one more check that can be made to determine if the connection pool is too small and so might be throttling throughput. During peak loads you can use the JMX console to take a thread dump of the running platform. If in the output you see the following the connection pool is too small:
		</div><pre class="screen">
Thread: http-192.168.1.22-8080-2 : priority:5, demon:true, threadId:145, threadState:TIMED_WAITING
- waiting on &lt;0x2222b715&gt; (a java.util.concurrent.Semaphore$FairSync)
sun.misc.Unsafe.park(Native Method)
java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:226)
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(AbstractQueuedSynchronizer.java:1037)
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1326)
java.util.concurrent.Semaphore.tryAcquire(Semaphore.java:410)
org.jboss.resource.connectionmanager.InternalManagedConnectionPool.getConnection(InternalManagedConnectionPool.java:193)
org.jboss.resource.connectionmanager.JBossManagedConnectionPool$BasePool.getConnection(JBossManagedConnectionPool.java:747)
org.jboss.resource.connectionmanager.BaseConnectionManager2.getManagedConnection(BaseConnectionManager2.java:404)
org.jboss.resource.connectionmanager.TxConnectionManager.getManagedConnection(TxConnectionManager.java:424)
org.jboss.resource.connectionmanager.BaseConnectionManager2.allocateConnection(BaseConnectionManager2.java:496)
org.jboss.resource.connectionmanager.BaseConnectionManager2$ConnectionManagerProxy.allocateConnection(BaseConnectionManager2.java:941)
org.jboss.resource.adapter.jdbc.WrapperDataSource.getConnection(WrapperDataSource.java:89)
org.hibernate.ejb.connection.InjectedDataSourceConnectionProvider.getConnection(InjectedDataSourceConnectionProvider.java:47)
org.hibernate.jdbc.ConnectionManager.openConnection(ConnectionManager.java:446)
org.hibernate.jdbc.ConnectionManager.getConnection(ConnectionManager.java:167)
</pre><div class="para">
			In this example thread dump from the ServerInfo section of the JMX Console's jboss.system category (where you can invoke a listThreadDump operation) you can see that the thread is in a TIMED_WAITING state and waiting on a semaphore. If you look closely at the stack trace you also see that the InternalManagedConnectionPool is executing its getConnection() method. In the connection pool, if no connection is available for use it waits on a semaphore, which has the same number of tickets available as the max-pool-size parameter. If a transaction is waiting for a connection to become available in the pool, it waits until one is returned to the pool. This has an advantage over continuing to increase the pool size because it's possible to see just how many threads are waiting on a connection from the pool. More accurate information means it takes fewer iterations to get the pool's size right.
		</div><div class="para">
			In closing discussion on the pool size, a rule of thumb is to set the minimum to the size which allows for maximum throughput and the maximum to 10% to 20% higher than the minimum. Setting the maximum higher than the minimum allows a buffer for situations in which load unexpectedly increases, a situation almost guaranteed to occur in real life.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Performance_Tuning_Guide-Java_Connector_Architecture-JMS_Integration_or_Provider">
      ⁠</a>5.6. JMS Integration or Provider</h1></div></div></div><div class="para">
			JMS integration in all Java EE servers is provided through JCA since it's a requirement of the specifications. As mentioned in Message Driven Beans section, there are two JMS providers: the original JBoss Messaging and the newer HornetQ technology. In either case, the focus in tuning each is the JCA thread pool.
		</div><div class="para">
			The JCA container has its own thread pool, and this pool needs to be sized appropriately to handle the messaging load. It's highly related to the maxSession parameter that was discussed with message driven beans. Besides message driven beans, you can use the JMS API directly within the container, and not be tied to message driven beans at all. The JCA thread pool's configuration is in the file <code class="filename">jca-jboss-beans.xml</code> in the directory <code class="filename">JBOSS_EAP_DIST/jboss-as/server/<em class="replaceable">PROFILE</em>/deploy</code>. Note that the <code class="literal">minimal</code> configuration does <span class="emphasis"><em>not</em></span> contain the JCA container.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Below is an example of this configuration file.
			</div></div></div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- THREAD POOL --&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"WorkManagerThreadPool"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.util.threadpool.BasicThreadPool"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- Expose via JMX --&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="jboss.jca:service=WorkManagerThreadPool", exposedInterface=org.jboss.util.threadpool.BasicThreadPoolMBean.class)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- The name that appears in thread names --&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"name"</span><span xmlns="" class="perl_Keyword">&gt;</span>WorkManager<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- The maximum amount of work in the queue --&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"maximumQueueSize"</span><span xmlns="" class="perl_Keyword">&gt;</span>1024<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- The maximum number of active threads --&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"maximumPoolSize"</span><span xmlns="" class="perl_Keyword">&gt;</span>100<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- How long to keep threads alive after their last work (default one minute) --&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"keepAliveTime"</span><span xmlns="" class="perl_Keyword">&gt;</span>60000<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
</pre><div class="para">
			In tuning the thread pool the focus is on just two parameters: maximumPoolSize and maximumQueueSize.
		</div><div class="para">
			The <code class="literal">maximumPoolSize</code> parameter specifies the number of threads in the thread pool for use by the JMS provider. The default size is 100, which may or may not be appropriate. If message driven beans are used in the application, make sure that there are enough threads in the thread pool to handle the maximum number of sessions. If only one message driven bean is used, ensure that the thread pool is at least the size of the number of sessions for that one bean. If there are many different message driven beans, the calculations are more complex.
		</div><div class="para">
			When you have many message-driven beans, each with their own maxSessions, start by adding all of the maxSession values together. This assumes that they all will hit those maximums at the same time, and different components are likely to have different usage patterns. If you understand the usage pattern, you may be able to reduce the thread pool accordingly, to just take into account the maximums that overlap each other. In fact, reducing it if you do not need 100 is a good step because it will save some memory.
		</div><div class="para">
			If you are not sure of the application's behavior, you can monitor the usage of the thread pool through the JMX console. Below is a screen shot from the JMX console that shows the attributes of the thread pool:
		</div><div class="figure"><a id="figu-Performance_Tuning_Guide-JMS_Integration_or_Provider-JMX_Console_Thread_Pool_Statistics">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/img-jmx_console_threadpool_metrics.png" width="444" alt="JMX Console Thread Pool Statistics"/></div></div><p class="title"><strong>Figure 5.4. JMX Console Thread Pool Statistics</strong></p></div><div class="para">
			On the second line of the table in the screenshot you see the attribute name called QueueSize, a read-only attribute which records any requests for threads from the thread pool that could not be satisfied because all the threads were currently in use. If this value is above zero, then the thread pool is too small to service all incoming requests. This value will not update automatically so it's necessary to refresh the page manually to see the value updated while the system is running.
		</div><div class="para">
			The <code class="literal">maximumQueueSize</code> parameter specifies how many requests will wait for a thread to become available before an exception is thrown and processing is aborted. The default value is 1024, which is a safe value. You may want to fail fast, versus wait for an extended period of time, or have more than 1024 requests backed up before failing. Setting this parameter to a lower value means you'll know earlier of exceptions but at the expense of application uptime. It's recommended to leave it at the default value as it provides greater reliability. If a request is waiting in the queue it's because there are none available in the pool. While sizing the pool, monitor the number of requests waiting in the queue to confirm whether or not the pool is too small.
		</div></div></div></body></html>