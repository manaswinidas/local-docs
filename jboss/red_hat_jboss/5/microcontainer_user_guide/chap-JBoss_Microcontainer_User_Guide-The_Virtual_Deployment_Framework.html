<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 10. The Virtual Deployment Framework</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework">
      ⁠</a>Chapter 10. The Virtual Deployment Framework</h1></div></div></div><div class="para">
		The new <em class="firstterm">Virtual Deployment Framework (VDF)</em> is an improved way to manage deployers in the Microcontainer. This chapter details some of its useful features.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Agnostic_Handling_of_Deployment_Types">
      ⁠</a>10.1. Agnostic Handling of Deployment Types</h1></div></div></div><div class="para">
			The traditional type of virtual deployment is based on classes which already exist in a shared class-space or domain. In this case, the end product is a new service installed onto the server from your main client. The traditional way to do this is to upload a descriptor file. The new VDF simplifies this process by passing over the bytes and serializing them into a <code class="classname">Deployment</code> instance.
		</div><div class="para">
			The other type of deployment, which extends the first one, is a plain file-system-based deployment, backed up by Microcontainer VFS. This approach is described in more detail in <a class="xref" href="chap-JBoss_Microcontainer_User_Guide-The_Virtual_File_System_Classloading_and_Deployers.html">Chapter 8, <em>The Virtual File System</em></a>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Separation_of_structure_recognition_from_deployment_life-cycle_logic">
      ⁠</a>10.2. Separation of Structure Recognition From Deployment life-cycle logic</h1></div></div></div><div class="para">
			In order to do any real work on top of a deployment, you must first understand its structure, including its classpaths and metadata locations.
		</div><div class="para">
			Metadata locations include the configuration files such as <code class="filename">my-jboss-beans.xml</code>, <code class="filename">web.xml</code>, <code class="filename">ejb-jar.xml</code>. Classpaths are classloader roots, such as <code class="filename">WEB-INF/classes</code> or <code class="filename">myapp.ear/lib</code>.
		</div><div class="para">
			Bearing the structure in mind, you can proceed to actual deployment handling.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><p class="title"><strong>A typical deployment life cycle</strong></p><ol><li class="listitem"><div class="para">
					The <code class="classname">MainDeployer</code> passes the deployment to the set of <code class="classname">StructuralDeployer</code>s for recognition, and receives back a Deployment context.
				</div></li><li class="listitem"><div class="para">
					Next, the <code class="classname">MainDeployer</code> passes the resulting Deployment context to the <code class="classname">Deployers</code> for handling by the appropriate <code class="classname">Deployer</code>.
				</div></li></ol></div><div class="para">
			In this way, the MainDeployer is a broker with the responsibility of deciding which Deployers to use.
		</div><div class="para">
			In the case of virtual or programmatic deployment, an existing predetermined StructureMetaData information reads the structure information and handles it in one of the ways explained in <a class="xref" href="chap-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework.html#StructuredMetadataInformation">Handling StructuredMetaData Information</a>.
		</div><div class="variablelist"><a id="StructuredMetadataInformation">
      ⁠</a><p class="title"><strong>Handling StructuredMetaData Information</strong></p><dl class="variablelist"><dt><span class="term">VFS-based deployments</span></dt><dd><div class="para">
						the structure recognition is forwarded to a set of StructureDeployers.
					</div></dd><dt><span class="term">JEE-specification-defined structures</span></dt><dd><div class="para">
						we have matching StructureDeployer implementations:
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								EarStructure
							</div></li><li class="listitem"><div class="para">
								WarStructure
							</div></li><li class="listitem"><div class="para">
								JarStructure
							</div></li></ul></div></dd><dt><span class="term">DeclarativeStructures</span></dt><dd><div class="para">
						looks for <code class="filename">META-INF/jboss-structure.xml</code> file inside your deployment, and parses it to construct a proper <code class="classname">StructureMetaData</code>.
					</div></dd><dt><span class="term">FileStructures</span></dt><dd><div class="para">
						only recognizes known configuration files, such as files like <code class="filename">-jboss-beans.xml</code> or <code class="filename">-service.xml</code>.
					</div><div class="example"><a id="exam-JBoss_Microcontainer_User_Guide-Separation_of_structure_recognition_from_deployment_life-cycle_logic-An_example_of_jboss_structure.xml">
      ⁠</a><p class="title"><strong>Example 10.1. An example of <code class="filename">jboss-structure.xml</code></strong></p><div class="example-contents"><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;structure&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;context</span><span xmlns="" class="perl_Others"> comparator=</span><span xmlns="" class="perl_String">"org.jboss.test.deployment.test.SomeDeploymentComparatorTop"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;path</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">""</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;metaDataPath&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;path</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"META-INF"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/metaDataPath&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;classpath&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;path</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"lib"</span><span xmlns="" class="perl_Others"> suffixes=</span><span xmlns="" class="perl_String">".jar"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/classpath&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/context&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/structure&gt;</span>
</pre></div></div></dd></dl></div><div class="para">
			In the case of EarStructure, first recognize a top level deployment, then recursively process sub-deployments.
		</div><div class="para">
			You can implement a custom <code class="classname">StructureDeployer</code> with the help of the generic <code class="classname">GroupingStructure</code> class provided by the generic <code class="interfacename">StructureDeployer</code> interface.
		</div><div class="para">
			After you have a recognized deployment structure, you can pass it to real deployers. The Deployers object knows how to deal with the real deployers, using a chain of deployers per <code class="classname">DeploymentStage</code>.
		</div><div class="example"><a id="idm139732982300128">
      ⁠</a><p class="title"><strong>Example 10.2. Deployment Stages</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">interface</span> DeploymentStages {
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The not installed stage - nothing is done here */</span>
<span xmlns="" class="line">​</span>   DeploymentStage NOT_INSTALLED = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"Not Installed"</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The pre parse stage - where pre parsing stuff can be prepared; altDD, ignore, ... */</span>
<span xmlns="" class="line">​</span>   DeploymentStage PRE_PARSE = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"PreParse"</span>, NOT_INSTALLED);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The parse stage - where metadata is read */</span>
<span xmlns="" class="line">​</span>   DeploymentStage PARSE = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"Parse"</span>, PRE_PARSE);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The post parse stage - where metadata can be fixed up */</span>
<span xmlns="" class="line">​</span>   DeploymentStage POST_PARSE = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"PostParse"</span>, PARSE);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The pre describe stage - where default dependencies metadata can be created */</span>
<span xmlns="" class="line">​</span>   DeploymentStage PRE_DESCRIBE = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"PreDescribe"</span>, POST_PARSE);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The describe stage - where dependencies are established */</span>
<span xmlns="" class="line">​</span>   DeploymentStage DESCRIBE = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"Describe"</span>, PRE_DESCRIBE);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The classloader stage - where classloaders are created */</span>
<span xmlns="" class="line">​</span>   DeploymentStage CLASSLOADER = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"ClassLoader"</span>, DESCRIBE);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The post classloader stage - e.g. aop */</span>
<span xmlns="" class="line">​</span>   DeploymentStage POST_CLASSLOADER = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"PostClassLoader"</span>, CLASSLOADER);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The pre real stage - where before real deployments are done */</span>
<span xmlns="" class="line">​</span>   DeploymentStage PRE_REAL = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"PreReal"</span>, POST_CLASSLOADER);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The real stage - where real deployment processing is done */</span>
<span xmlns="" class="line">​</span>   DeploymentStage REAL = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"Real"</span>, PRE_REAL);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Comment">/** The installed stage - could be used to provide valve in future? */</span>
<span xmlns="" class="line">​</span>   DeploymentStage INSTALLED = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">DeploymentStage</span>(<span xmlns="" class="perl_String">"Installed"</span>, REAL);
<span xmlns="" class="line">​</span>}
</pre></div></div><div class="para">
			Preexisting deployment stages are mapped to the Microcontainer's built-in controller states. They provide a deployment/life cycle focused view of generic controller states.
		</div><div class="para">
			Inside Deployers, the deployment is converted into the Microcontainer's component <code class="classname">DeploymentControllerContext</code>. The Microcontainer's state machine handles dependencies.
		</div><div class="para">
			Deployments are handled sequentially by deployment stage. For each deployer, the entire deployed hierarchy order is handled, using the deployer's <code class="varname">parent-first</code> property. This property is set to <code class="option">true</code> by default.
		</div><div class="para">
			You can also specify which hierarchy levels your deployer handles. You can choose <code class="option">all</code>, <code class="option">top level</code>, <code class="option">components only</code>, or <code class="option">no components</code>.
		</div><div class="para">
			The way the Microcontainer handles component models and dependency handling applies here as well. If there are unresolved dependencies, the deployment will wait in the current state, potentially reporting an error if the current state is not the required state.
		</div><div class="para">
			Adding a new deployer is accomplished by extending one of the many existing helper deployers.
		</div><div class="para">
			Some deployers actually need VFS backed deployment, while others can use a general deployment. In most cases the parsing deployers are the ones that need VFS backing.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				Also be aware that deployers run recursively through every deployment, sub-deployment, and component. Your code needs to determine, as early in the process as possible, whether the deployer should handle the current deployment or not.
			</div></div></div><div class="example"><a id="idm139732984252848">
      ⁠</a><p class="title"><strong>Example 10.3. Simple Deployer which Outputs Information About Its Deployment</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> StdioDeployer <span xmlns="" class="perl_Keyword">extends</span> AbstractDeployer {
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">deploy</span>(DeploymentUnit unit) <span xmlns="" class="perl_Keyword">throws</span> DeploymentException
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      System.<span xmlns="" class="perl_Function">out</span>.<span xmlns="" class="perl_Function">println</span>(<span xmlns="" class="perl_String">"Deploying unit: "</span> + unit);
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   @Override
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">undeploy</span>(DeploymentUnit unit)
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      System.<span xmlns="" class="perl_Function">out</span>.<span xmlns="" class="perl_Function">println</span>(<span xmlns="" class="perl_String">"Undeploying unit: "</span> + unit);
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}
</pre></div></div><div class="para">
			Add this description into one of the <code class="filename">-jboss-beans.xml</code> files in <code class="filename">deployers/</code> directory in JBoss Application Server, and <code class="classname">MainDeployerImpl</code> bean will pick up this deployer via the Microcontainer's IoC callback handling.
		</div><div class="example"><a id="idm139732982359152">
      ⁠</a><p class="title"><strong>Example 10.4. Simple Deployment Descriptor</strong></p><div class="example-contents"><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"StdioDeployer"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.acme.StdioDeployer"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Natural_flow_control_in_the_form_of_attachments">
      ⁠</a>10.3. Natural Flow Control in the form of Attachments</h1></div></div></div><div class="para">
			VDF includes a mechanism called <em class="firstterm">attachments</em>, which facilitates the passing of information from one deployer to the next. Attachments are implemented as a slightly-enhanced <code class="filename">java.util.Map</code>, whose entries each represent an attachment.
		</div><div class="para">
			Some deployers are producers, while others are consumers. The same deployer can also perform both functions. Some deployers create metadata or utility instances, putting them into the <em class="firstterm">attachments</em> map. Other deployers only declare their need for these attachments and pull the data from the attachments map, before doing additional work on that data.
		</div><div class="para">
			<em class="firstterm">Natural order</em> refers to the way that deployers are ordered. A common natural order uses the relative terms <em class="wordasword">before</em> and <em class="wordasword">after</em>. However, with the attachments mechanism already in place, you can order deployers by the way in which they produce and/or consume the attachments.
		</div><div class="para">
			Each attachment has a key, and deployers pass keys to the attachments they produce. If the deployer produces an attachment, then that key is called <em class="firstterm">output</em>. If the deployer consumes an attachment, then that key is called <em class="firstterm">input</em>.
		</div><div class="para">
			Deployers have <em class="firstterm">ordinary</em> inputs and <em class="firstterm">required</em> inputs. Ordinary inputs are only used to help determine the natural order. Required inputs also help determine order, but they have another function too. They help to determine if the deployer is actually relevant for the given deployment, by checking to see if an attachment corresponding to that required input exists in the attachments map.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				While relative ordering is still supported, it is considered bad practice, and could be deprecated in future releases.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Separate_client_user_and_server_usage_and_implementation_details">
      ⁠</a>10.4. Client, User, and Server Usage and Implementation Details</h1></div></div></div><div class="para">
			These features hide the implementation details, making the usage less error-prone, while at the same time streamlining the development process.
		</div><div class="para">
			The goal is for clients to only see a Deployment API, while developers see a DeploymentUnit, and server implementation details are contained in a DeploymentContext. Only the necessary information is exposed to a particular level of deployment's life cycle.
		</div><div class="para">
			Components have already been mentioned as part of deployers' hierarchy handling. While top level deployment and sub-deployments are a natural representation of the deployment's structure hierarchy, components are a new VDF concept. The idea of components is that they have a 1:1 mapping with the <code class="classname">ControllerContexts</code> inside the Microcontainer. See <a class="xref" href="chap-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework.html#reinforcements-for-1-to-1-mapping">Why Components Map 1:1 with the <code class="classname">ControllerContexts</code></a> for the reasons behind this assertion.
		</div><div class="variablelist"><a id="reinforcements-for-1-to-1-mapping">
      ⁠</a><p class="title"><strong>Why Components Map 1:1 with the <code class="classname">ControllerContexts</code></strong></p><dl class="variablelist"><dt><span class="term">Naming</span></dt><dd><div class="para">
						The component unit's name is the same as the <code class="classname">ControllerContext</code>'s name.
					</div></dd><dt><span class="term">get*Scope() and get*MetaData()</span></dt><dd><div class="para">
						return the same MDR context that will be used by the Microcontainer for that instance.
					</div></dd><dt><span class="term">IncompleteDeploymentException (IDE)</span></dt><dd><div class="para">
						In order for the IDE to print out what dependencies are missing for a deployment, it needs to know the ControllerContext names. It discovers the name by collecting the Component DeploymentUnit's names in Component Deployers that specify them, such as <code class="classname">BeanMetaDataDeployer</code> or the <code class="methodname">setUseUnitName()</code> method in <code class="classname">AbstractRealDeployer</code>.
					</div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Single_State_Machine">
      ⁠</a>10.5. Single State Machine</h1></div></div></div><div class="para">
			All Microcontainer components are handled by a single entry point, or single state machine. Deployments are no exception.
		</div><div class="para">
			You can take advantage of this feature by using the <code class="filename">jboss-dependency.xml</code> configuration file in your deployments.
		</div><div class="example"><a id="idm139732981080160">
      ⁠</a><p class="title"><strong>Example 10.5. <code class="filename">jboss-dependency.xml</code></strong></p><div class="example-contents"><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;dependency</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"urn:jboss:dependency:1.0"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;item</span><span xmlns="" class="perl_Others"> whenRequired=</span><span xmlns="" class="perl_String">"Real"</span><span xmlns="" class="perl_Others"> dependentState=</span><span xmlns="" class="perl_String">"Create"</span><span xmlns="" class="perl_Keyword">&gt;</span>TransactionManager<span xmlns="" class="perl_Keyword">&lt;/item&gt;</span> (1)
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;item&gt;</span>my-human-readable-deployment-alias<span xmlns="" class="perl_Keyword">&lt;/item&gt;</span> (2)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/dependency&gt;</span>
</pre><div class="para">
				Note the artificial call-outs in the XML: (1) and (2).
			</div><div class="para">
				(1) shows how to describe dependency on another service. This example requires <code class="classname">TransactionManager</code> to be created before the deployment is in the 'Real' stage.
			</div><div class="para">
				(2) is a bit more complex, since you are missing additional information. By default, deployment names inside the Microcontainer are URI names, which makes typing them by hand an error prone proposition. So, in order to be able to easily declare dependence on other deployments, you need an aliasing mechanism to avoid URI names. You can add a plain text file named <code class="filename">aliases.txt</code> into your deployment. Each line of the file contains an alias, giving a deployment archive one or more simple names used to refer to it.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-JBoss_Microcontainer_User_Guide-The_Virtual_Deployment_Framework-Scanning_Classes_for_Annotations">
      ⁠</a>10.6. Scanning Classes for Annotations</h1></div></div></div><div class="para">
			Current JEE specifications reduce the number of configuration files, but the container is now required to do most of the work using @annotations. In order to get @annotation info, containers must scan classes. This scanning creates a performance penalty.
		</div><div class="para">
			But to reduce the amount of scanning, the Microcontainer provides another descriptor hook, by means of <code class="filename">jboss-scanning.xml</code>.
		</div><div class="example"><a id="idm139732995369728">
      ⁠</a><p class="title"><strong>Example 10.6. <code class="filename">jboss-scanning.xml</code></strong></p><div class="example-contents"><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;scanning</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"urn:jboss:scanning:1.0"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;path</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"myejbs.jar"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;include</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"com.acme.foo"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;exclude</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"com.acme.foo.bar"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/path&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;path</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"my.war/WEB-INF/classes"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;include</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"com.acme.foo"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/path&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/scanning&gt;</span>
</pre><div class="para">
				This example shows a simple description of relative paths to include or exclude when scanning for Java Enterprise Edition version 5 and greater annotated metadata information. 
			</div></div></div></div></div></body></html>