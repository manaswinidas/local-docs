<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 18. Overview of Protocols Used by XTS</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019146820144">
      ⁠</a>Chapter 18. Overview of Protocols Used by XTS</h1></div></div></div><a id="idm140019156037712" class="indexterm"/><a id="idm140019114118112" class="indexterm"/><a id="idm140019150507152" class="indexterm"/><a id="idm140019146618624" class="indexterm"/><a id="idm140019158862704" class="indexterm"/><a id="idm140019180765584" class="indexterm"/><a id="idm140019173495088" class="indexterm"/><a id="idm140019178290736" class="indexterm"/><a id="idm140019174809904" class="indexterm"/><a id="idm140019169276160" class="indexterm"/><a id="idm140019164149520" class="indexterm"/><a id="idm140019117228368" class="indexterm"/><a id="idm140019147663408" class="indexterm"/><a id="idm140019178296128" class="indexterm"/><div class="para">
		This section discusses fundamental concepts associated with the WS-Coordination, WS-Atomic Transaction and WS-Business Activity protocols, as defined in each protocol's specification. Foundational information about these protocols is important to understanding the remaining material covered in this guide.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			If you are familiar with the WS-Coordination, WS-Atomic Transaction, and WS-Business Activity specifications you may only need to skim this chapter.
		</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019154287744">
      ⁠</a>18.1. WS-Coordination</h1></div></div></div><div class="para">
			In general terms, <em class="firstterm">coordination</em> is the act of one entity,known as the coordinator, disseminating information to a number of participants for some domain-specific reason. This reason could be to reach consensus on a decision by a distributed transaction protocol, or to guarantee that all participants obtain a specific message, such as in a reliable multicast environment. When parties are being coordinated, information, known as the <em class="firstterm">coordination context</em>, is propagated to tie together operations which are logically part of the same coordinated work or activity. This context information may flow with normal application messages, or may be an explicit part of a message exchange. It is specific to the type of coordination being performed.
		</div><div class="para">
			The fundamental idea underpinning <em class="firstterm">WS-Coordination (WS-C)</em> is that a coordination infrastructure is needed in a Web Services environment. The WS-C specification defines a framework that allows different coordination protocols to be plugged in to coordinate work between clients, services, and participants, as shown in <a class="xref" href="ch18.html#fig-ws-c-architecture">Figure 18.1, “WS-C Architecture”</a>.
		</div><div class="figure"><a id="fig-ws-c-architecture">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-ws-c-overview.png" alt="WS-C Architecture"/></div></div><p class="title"><strong>Figure 18.1. WS-C Architecture</strong></p></div><div class="para">
			Whatever coordination protocol is used, and in whatever domain it is deployed, the same generic requirements are present.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><a id="list-requirements-for-wsc">
      ⁠</a><p class="title"><strong>Generic Requirements for WS-C</strong></p><ul><li class="listitem"><div class="para">
					Instantiation, or activation, of a new coordinator for the specific coordination protocol, for a particular application instance.
				</div></li><li class="listitem"><div class="para">
					Registration of participants with the coordinator, such that they will receive that coordinator’s protocol messages during (some part of) the application’s lifetime.
				</div></li><li class="listitem"><div class="para">
					Propagation of contextual information between Web Services that comprise the application.
				</div></li><li class="listitem"><div class="para">
					An entity to drive the coordination protocol through to completion.
				</div></li></ul></div><div class="para">
			The first three of the points in <a class="xref" href="ch18.html#list-requirements-for-wsc">Generic Requirements for WS-C</a> are the direct responsibility of WS-C, while the fourth is the responsibility of a third-party entity. The third-party entity is usually the client component of the overall application. These four WS-C roles and their relationships are shown in <a class="xref" href="ch18.html#fig-wsc-four-roles">Figure 18.2, “Four Roles in WS-C”</a>.
		</div><div class="figure"><a id="fig-wsc-four-roles">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-wsc-four-roles.png" alt="Four Roles in WS-C"/></div></div><p class="title"><strong>Figure 18.2. Four Roles in WS-C</strong></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019149235472">
      ⁠</a>18.1.1. Activation</h2></div></div></div><div class="para">
				The WS-C framework exposes an Activation Service which supports the creation of coordinators for specific coordination protocols and retrieval of associated contexts. Activation services are invoked synchronously using an RPC style exchange. So, the service WSDL defines a single port declaring a <code class="methodname">CreateCoordinationContext</code> operation. This operation takes an input specifying the details of the transaction to be created, including the type of coordination required, timeout, and other relevant information. It returns an output containing the details of the newly-created transaction context: the transaction identifier, coordination type, and registration service URL.
			</div><div class="example"><a id="example-wsc-interfaces">
      ⁠</a><p class="title"><strong>Example 18.1. </strong></p><div class="example-contents"><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">&lt;!-- Activation Service portType Declaration --&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;wsdl:portType</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"ActivationCoordinatorPortType"</span><span xmlns="" class="perl_Keyword">&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;wsdl:operation</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"CreateCoordinationContext"</span><span xmlns="" class="perl_Keyword">&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;wsdl:input</span><span xmlns="" class="perl_Others"> message=</span><span xmlns="" class="perl_String">"wscoor:CreateCoordinationContext"</span><span xmlns="" class="perl_Keyword">/&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;wsdl:output</span><span xmlns="" class="perl_Others"> message=</span><span xmlns="" class="perl_String">"wscoor:CreateCoordinationContextResponse"</span><span xmlns="" class="perl_Keyword">/&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/wsdl:operation&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/wsdl:portType&gt;</span> </pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The 1.0 Activation Coordinator service employs an asynchronous message exchange comprised of two one-way messages, so an Activation Requester service is also necessary.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019167555440">
      ⁠</a>18.1.2. Registration</h2></div></div></div><div class="para">
				The context returned by the activation service includes the URL of a Registration Service. When a web service receives a service request accompanied by a transaction context, it contacts the Registration Service to enroll as a participant in the transaction. The registration request includes a participant protocol defining the role the web service wishes to take in the transaction. Depending upon the coordination protocol, more than one choice of participant protocol may be available.
			</div><div class="para">
				Like the activation service, the registration service assumes synchronous communication. Thus, the service WSDL exposes a single port declaring a <code class="methodname">Register</code> operation. This operation takes an input specifying the details of the participant which is to be registered, including the participant protocol type. It returns a corresponding output response.
			</div><div class="example"><a id="example-wsc-registration">
      ⁠</a><p class="title"><strong>Example 18.2. Registration ServiceWSDL Interface</strong></p><div class="example-contents"><pre class="programlisting">&lt;!-- Registration Service portType Declaration --&gt; 
&lt;wsdl:portType name="RegistrationCoordinatorPortType"&gt; 
  &lt;wsdl:operation name="Register"&gt; 
    &lt;wsdl:input message="wscoor:Register"/&gt; 
    &lt;wsdl:output message="wscoor:RegisterResponse"/&gt; 
  &lt;/wsdl:operation&gt; 
&lt;/wsdl:portType&gt; </pre></div></div><div class="para">
				Once a participant is registered with a coordinator through the registration service, it receives coordination messages from the coordinator. Typical messages include such things as “prepare to complete” and “complete” messages, if a two-phase protocol is used. Where the coordinator’s protocol supports it, participants can also send messages back to the coordinator.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The 1.0 Registration Coordinator service employs an asynchronous message exchange comprised of two one way messages, so a Registration Requester service is also necessary
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019150476672">
      ⁠</a>18.1.3. Completion</h2></div></div></div><div class="para">
				The role of terminator is generally filled by the client application. At an appropriate point, the client asks the coordinator to perform its particular coordination function with any registered participants, to drive the protocol through to its completion. After completion, the client application may be informed of an outcome for the activity. This outcome may take any form along the spectrum from simple success or failure notification, to complex structured data detailing the activity’s status.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019168512880">
      ⁠</a>18.2. WS-Transaction</h1></div></div></div><div class="para">
			<em class="firstterm">WS-Transaction (WS-T)</em> comprises the pair of transaction coordination protocols, <em class="firstterm">WS-Atomic Transaction (WS-AT)</em> and <em class="firstterm">WS-Business Activity (WS-BA)</em>, which utilize the coordination framework provided by <em class="firstterm">WS-Coordination (WS-C)</em>.
		</div><div class="para">
			<em class="firstterm">WS-Transactions</em> was developed to unify existing traditional transaction processing systems, allowing them to communicate reliably with one another without changes to the systems' own function.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019168508688">
      ⁠</a>18.2.1. WS-Transaction Foundations</h2></div></div></div><div class="para">
				WS-Transaction is layered upon the WS-Coordination protocol, as shown in as shown in <a class="xref" href="ch18.html#wsc-wst-interop">Figure 18.3, “WS-Coordination, WS-Transaction, and WS-Business Activity”</a>.
			</div><div class="figure"><a id="wsc-wst-interop">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-wsc-wst-interop.png" alt="WS-Coordination, WS-Transaction, and WS-Business Activity"/></div></div><p class="title"><strong>Figure 18.3. WS-Coordination, WS-Transaction, and WS-Business Activity</strong></p></div><div class="para">
				WS-C provides a generic framework for specific coordination protocols, like WS-Transaction, used in a modular fashion. WS-C provides only context management, allowing contexts to be created and activities to be registered with those contexts. WS-Transaction leverages the context management framework provided by WS-C in two ways.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
						It extends the WS-C context to create a transaction context.
					</div></li><li class="listitem"><div class="para">
						It augments the activation and registration services with a number of additional services (Completion, Volatile2PC, Durable2PC, BusinessAgreementWithParticipantCompletion, and BusinessAgreementWithCoordinatorCompletion) and two protocol message sets (one for each of the transaction models supported in WS-Transaction), to build a fully-fledged transaction coordinator on top of the WS-C protocol infrastructure.
					</div></li><li class="listitem"><div class="para">
						An important aspect of WS-Transaction that differs from traditional transaction protocols is that a synchronous request/response model is not assumed. Sequences of one way messages are used to implement communications between the client/participant and the coordination services appropriate to the transaction's coordination and participant protocols. This is significant because it means that the client and participant containers must deploy XTS service endpoints to receive messages from the coordinator service.
					</div><div class="para">
						This requirement is visible in the details of the <code class="methodname">Register</code> and <code class="methodname">RegisterResponse</code> messages declared in the Registration Service WSDL in <a class="xref" href="ch18.html#example-wsc-registration">Example 18.2, “Registration ServiceWSDL Interface”</a>. The <code class="methodname">Register</code> message contains the URL of an endpoint in the client or web service container. This URL is used when a WS-Transaction coordination service wishes to dispatch a message to the client or web service. Similarly, the <code class="methodname">RegisterResponse</code> message contains a URL identifying an endpoint for the protocol-specific WS-Transaction coordination service for which the client/web service is registered, allowing messages to be addressed to the transaction coordinator.
					</div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019172391312">
      ⁠</a>18.2.2. WS-Transaction Architecture</h2></div></div></div><div class="para">
				WS-Transaction distinguishes the transaction-aware web service in its role executing business-logic, from the web service acting as a participant in the transaction, communicating with and responding to its transaction coordinator. Transaction-aware web services deal with application clients using business-level protocols, while the participant handles the underlying WS-Transaction protocols, as shown in <a class="xref" href="ch18.html#ws-trans-global-view">Figure 18.4, “WS-Transaction Global View”</a>.
			</div><div class="figure"><a id="ws-trans-global-view">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/ws-trans-global-view.png" alt="WS-Transaction Global View"/></div></div><p class="title"><strong>Figure 18.4. WS-Transaction Global View</strong></p></div><div class="para">
				A transaction-aware web service encapsulates the business logic or work that needs to be conducted within the scope of a transaction. This work cannot be confirmed by the application unless the transaction also commits. Thus, control is ultimately removed from the application and given to the transaction.
			</div><div class="para">
				The participant is the entity that, under the dictates of the transaction coordinator, controls the outcome of the work performed by the transaction-aware Web service. In <a class="xref" href="ch18.html#ws-trans-global-view">Figure 18.4, “WS-Transaction Global View”</a>, each web service is shown with one associated participant that manages the transaction protocol messages on behalf of its web service. <a class="xref" href="ch18.html#ws-trans-services-participants">Figure 18.5, “WS-Transaction Web Services and Participants”</a>, however, shows a close-up view of a single web service, and a client application with their associated participants.
			</div><div class="figure"><a id="ws-trans-services-participants">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-ws-trans-services-participants.png" alt="WS-Transaction Web Services and Participants"/></div></div><p class="title"><strong>Figure 18.5. WS-Transaction Web Services and Participants</strong></p></div><div class="para">
				The transaction-aware web service employs a back end database accessed via a JDBC driver, which sends SQL statements to the database for processing. However, those statements should only commit if the enclosing web service transaction does. For this to work, the web service must employ transaction bridging. Transaction bridging registers a participant with the coordinator for the web service transaction and creates a matching XA transaction within which it can invoke the driver to make tentative changes to the database. The web service ensures that service requests associated with a specific web service transaction are executed in the scope of the corresponding XA transaction, grouping changes common to a given transaction while isolating changes belonging to different transactions. The participant responds to prepare, commit, or rollback requests associated from the web service transaction coordinator by forwarding the same operations to the underlying XA transaction coordinator, ensuring that the local outcome in the database corresponds with the global outcome of the web service transaction as a whole.
			</div><div class="para">
				Things are less complex for the client. Through its API, the client application registers a participant with the transaction, and uses this participant to control termination of the transaction.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019182480320">
      ⁠</a>18.2.3. WS_Transaction Models</h2></div></div></div><div class="para">
				It has been established that traditional transaction models are not appropriate for Web Services. No one specific protocol is likely to be sufficient, given the wide range of situations where Web service transactions are likely to be used. The WS-Transaction specification proposes two distinct models, where each supports the semantics of a particular kind of B2B interaction.
			</div><div class="para">
				The following discussion presents the interactions between the client, web service and the transaction coordinator in great detail for expository purposes only. Most of this activity happens automatically behind the scenes. The actual APIs used to initiate and complete a transaction and to register a participant and drive it through the commit or abort process are described in <a class="xref" href="sec-xts-api.html">Chapter 21, <em>The XTS API</em></a>.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140019117196704">
      ⁠</a>18.2.3.1. Atomic Transactions</h3></div></div></div><div class="para">
					An <em class="firstterm">atomic transaction (AT)</em> is similar to traditional ACID transactions, and is designed to support short-duration interactions where ACID semantics are appropriate. Within the scope of an AT, web services typically employ bridging to allow them to access XA resources, such as databases and message queues, under the control of the web service transaction. When the transaction terminates, the participant propagates the outcome decision of the AT to the XA resources, and the appropriate commit or rollback actions are taken by each.
				</div><div class="para">
					All services and associated participants are expected to provide ACID semantics, and it is expected that any use of atomic transactions occurs in environments and situations where ACID is appropriate. Usually, this environment is a trusted domain, over short durations.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="idm140019117192960">
      ⁠</a><p class="title"><strong>Procedure 18.1. Atomic Transaction Process</strong></p><ol class="1"><li class="step"><div class="para">
							To begin an atomic transaction, the client application first locates a WS-C Activation Coordinator web service that supports WS-Transaction.
						</div></li><li class="step"><div class="para">
							The client sends a WS-C <code class="systemitem">CreateCoordinationContext</code> message to the service, specifying <a href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a> as its coordination type.
						</div></li><li class="step"><div class="para">
							The client receives an appropriate WS-Transaction context from the activation service.
						</div></li><li class="step"><div class="para">
							The response to the <code class="systemitem">CreateCoordinationContext</code> message, the transaction context, has its <code class="systemitem">CoordinationType</code> element set to the WS-Atomic Transaction namespace, <a href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a>. It also contains a reference to the atomic transaction coordinator endpoint, the WS-C Registration Service, where participants can be enlisted.
						</div></li><li class="step"><div class="para">
							The client normally proceeds to invoke Web Services and complete the transaction, either committing all the changes made by the web services, or rolling them back. In order to be able to drive this completion activity, the client must register itself as a participant for the <code class="systemitem">Completion</code> protocol, by sending a <code class="systemitem">Register</code> message to the Registration Service whose endpoint was returned in the Coordination Context.
						</div></li><li class="step"><div class="para">
							Once registered for Completion, the client application then interacts with Web Services to accomplish its business-level work. With each invocation of a business Web service, the client inserts the transaction context into a SOAP header block, such that each invocation is implicitly scoped by the transaction. The toolkits that support WS-Atomic Transaction-aware Web Services provide facilities to correlate contexts found in SOAP header blocks with back-end operations. This ensures that modifications made by the Web service are done within the scope of the same transaction as the client and subject to commit or rollback by the transaction coordinator.
						</div></li><li class="step"><div class="para">
							Once all the necessary application-level work is complete, the client can terminate the transaction, with the intent of making any changes to the service state permanent. The completion participant instructs the coordinator to try to commit or roll back the transaction. When the commit or roll-back operation completes, a status is returned to the participant to indicate the outcome of the transaction.
						</div></li></ol></div><div class="para">
					Although this description of the completion protocol seems straightforward, it hides the fact that in order to resolve the transaction to an outcome, several other participant protocols need to be followed.
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Volatile2pc</span></dt><dd><div class="para">
								The first of these protocols is the optional <em class="firstterm">Volatile2PC</em> (2PC is an abbreviation referring to the two-phase commit). The Volatile2PC protocol is the WS-Atomic Transaction equivalent of the synchronization protocol discussed earlier. It is typically executed where a Web service needs to flush volatile (cached) state, which may be used to improve performance of an application, to a database prior to the transaction committing. Once flushed, the data is controlled by a two-phase aware participant.
							</div><div class="para">
								When the completion participant initiates a <code class="systemitem">commit</code> operation, all Volatile2PC participants are informed that the transaction is about to complete, via the <code class="systemitem">prepare</code> message. The participants can respond with one of three messages: <code class="systemitem">prepared</code>, <code class="systemitem">aborted</code>, or <code class="systemitem">readonly</code>. A failure at this stage causes the transaction to roll back.
							</div></dd><dt><span class="term">Durable2PC</span></dt><dd><div class="para">
								The next protocol in the WS-Atomic Transaction is <em class="firstterm">Durable2PC</em>. The Durable2PC protocol is at the core of WS-Atomic Transaction. It brings about the necessary consensus between participants in a transaction, so the transaction can safely be terminated.
							</div><div class="para">
								The Durable2PC protocol ensures atomicity between participants, and is based on the classic technique of <span class="phrase">two-phase commit with presumed abort</span>.
							</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="idm140019178007952">
      ⁠</a><p class="title"><strong>Procedure 18.2. Durable2PC Procedure</strong></p><ol class="1"><li class="step"><div class="para">
										During the first phase, when the coordinator sends the prepare message, a participant must make durable any state changes that occurred during the scope of the transaction, so these changes can either be rolled back or committed later. None of the original state information can be lost at this point, since the atomic transaction may still roll back. If the participant cannot <code class="systemitem">prepare</code>, it must inform the coordinator, by means of the <code class="systemitem">aborted</code> message. The transaction will ultimately roll back. If the participant is responsible for a service that did not change any of the transaction's data,, it can return the <code class="systemitem">readonly</code> message, causing it to be omitted from the second phase of the commit protocol. Otherwise, the <code class="systemitem">prepared</code> message is sent by the participant.
									</div></li><li class="step"><div class="para">
										If no failures occur during the first phase, Durable2PC proceeds to the second phase, in which the coordinator sends the <code class="systemitem">commit</code> message to participants. Participants then make permanent the tentative work done by their associated services, and send a <code class="systemitem">committed</code> message to the coordinator. If any failures occur, the coordinator sends the <code class="systemitem">rollback</code> message to all participants, causing them to discard tentative work done by their associated services, and delete any state information saved to persistent storage at <code class="systemitem">prepare</code>, if they have reached that stage. Participants respond to a rollback by sending an <code class="systemitem">aborted</code> message to the coordinator.
									</div></li></ol></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
									The semantics of the WS-Atomic Transaction protocol do not include the one-phase commit optimization. A full two-phase commit is always used, even where only a single participant is enlisted.
								</div></div></div></dd></dl></div><div class="para">
					<a class="xref" href="ch18.html#two-pc-participant-state-transitions">Figure 18.6, “WS-Atomic Two-Phase Participant State Transitions”</a> shows the state transitions of a WS-Atomic Transaction and the message exchanges between coordinator and participant. Messages generated by the coordinator are represented by solid lines, while the participants' messages use dashed lines.
				</div><div class="figure"><a id="two-pc-participant-state-transitions">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-2pc-participant-state-transitions.png" alt="WS-Atomic Two-Phase Participant State Transitions"/></div></div><p class="title"><strong>Figure 18.6. WS-Atomic Two-Phase Participant State Transitions</strong></p></div><div class="para">
					Once the Durable2PC protocol completes, the <code class="systemitem">Completion</code> protocol that originally began the termination of the transaction can complete, and inform the client application whether the transaction was committed or rolled back. Additionally, the Volatile2PC protocol may complete.
				</div><div class="para">
					Like the <code class="systemitem">prepare</code> phase of Volatile2PC, the final phase is optional and can be used to inform participants about the transaction's completion, so that they can release resources such as database connections.
				</div><div class="para">
					Any registered Volatile2PC participants are invoked after the transaction terminates, and are informed about the transaction's completion state by the coordinator. Since the transaction has terminated, any failures of participants at this stage are ignored, since they have no impact on outcomes.
				</div><div class="para">
					<a class="xref" href="ch18.html#fig-at-model">Figure 18.7, “AT protocol model”</a> illustrates the intricate interweaving of individual protocols comprising the AT as a whole.
				</div><div class="figure"><a id="fig-at-model">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-at-model.png" alt="AT protocol model"/></div></div><p class="title"><strong>Figure 18.7. AT protocol model</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140019173496720">
      ⁠</a>18.2.3.2. Business Activities</h3></div></div></div><div class="para">
					Most B2B applications require transactional support in order to guarantee consistent outcome and correct execution. These applications often involve long-running computations, loosely coupled systems, and components that do not share data, location, or administration. It is difficult to incorporate atomic transactions within such architectures.
				</div><div class="para">
					For example, an online bookshop may reserve books for an individual for a specific period of time. However, if the individual does not purchase the books within that period, they become available again for purchase by other customers. Because it is not possible to have an infinite supply of stock, some online shops may seem, from the user's perspective, to reserve items for them, while actually allow others to preempt the reservation. A user may discover, to his disappointment, that the item is no longer available.
				</div><div class="para">
					A <em class="firstterm">Business Activity (BA)</em> is designed specifically for these kinds of long-duration interactions, where it is impossible or impractical to exclusively lock resources.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="idm140019184094272">
      ⁠</a><p class="title"><strong>Procedure 18.3. BA Process Overview</strong></p><ol class="1"><li class="step"><div class="para">
							Services are requested to do work.
						</div></li><li class="step"><div class="para">
							Where those services have the ability to undo any work, they inform the BA, in case the BA later decides the cancel the work. If the BA suffers a failure. it can instruct the service to execute its <code class="systemitem">undo</code> behavior.
						</div></li></ol></div><div class="para">
					The key to BA is that how services do their work and provide compensation mechanisms is not the responsibility of the WS-BA specification. It is delegated to the service provider.
				</div><div class="para">
					The WS-BA defines a protocol for Web Services-based applications to enable existing business processing and work-flow systems to wrap their proprietary mechanisms and interoperate across implementations and business boundaries.
				</div><div class="para">
					Unlike the WS-AT protocol model, where participants inform the coordinator of their state only when asked, a child activity within a BA can specify its outcome to the coordinator directly, without waiting for a request. A participant may choose to exit the activity or may notify the coordinator of a failure at any point. This feature is useful when tasks fail, since the notification can be used to modify the goals and drive processing forward, without the need to wait until the end of the transaction to identify failures. A well-designed Business Activity should be proactive.
				</div><div class="para">
					The BA protocols employ a compensation-based transaction model. When a participant in a business activity completes its work, it may choose to exit the activity. This choice does not allow any subsequent rollback. Alternatively, the participant can complete its activity, signaling to the coordinator that the work it has done can be compensated if, at some later point, another participant notifies a failure to the coordinator. In this latter case, the coordinator asks each non-exited participant to compensate for the failure, giving them the opportunity to execute whatever compensating action they consider appropriate. For instance, participant might credit a bank account which it previously debited. If all participants exit or complete without failure, the coordinator notifies each completed participant that the activity has been closed.
				</div><div class="para">
					Underpinning all of this are three fundamental assumptions, detailed in <a class="xref" href="ch18.html#wsba-assumptions">Assumptions of WS-BA</a>.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><a id="wsba-assumptions">
      ⁠</a><p class="title"><strong>Assumptions of WS-BA</strong></p><ul><li class="listitem"><div class="para">
							All state transitions are reliably recorded, including application state and coordination metadata (the record of sent and received messages).
						</div></li><li class="listitem"><div class="para">
							All request messages are acknowledged, so that problems are detected as early as possible. This avoids executing unnecessary tasks and can also detect a problem earlier when rectifying it is simpler and less expensive.
						</div></li><li class="listitem"><div class="para">
							As with atomic transactions, a <em class="firstterm">response</em> is defined as a separate operation, not as the output of the request. Message I/O implementations typically have timeout requirements too short for BA responses. If the response is not received after a timeout, it is re-sent, repeatedly, until a response is received. The receiver discards all but one identical request received.
						</div></li></ul></div><div class="para">
					The BA model has two participant protocols: <code class="systemitem">BusinessAgreementWithParticipantCompletion</code> and <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code>. Unlike the AT protocols which are driven from the coordinator down to participants, this protocol takes the opposite approach.
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">BusinessAgreementWithParticipantCompletion</span></dt><dd><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><ol class="1"><li class="step"><div class="para">
										A participant is initially created in the Active state.
									</div></li><li class="step"><div class="para">
										If it finishes its work and it is no longer needed within the scope of the BA (such as when the activity operates on immutable data), the participant can unilaterally decide to exit, sending an <code class="systemitem">exited</code> message to the coordinator. However, if the participant finishes and wishes to continue in the BA, it must be able to compensate for the work it has performed. In this case, it sends a <code class="systemitem">completed</code> message to the coordinator and waits for the coordinator to notify it about the final outcome of the BA. This outcome is either a <code class="systemitem">close</code> message, meaning the BA has completed successfully, or a <code class="systemitem">compensate</code> message indicating that the participant needs to reverse its work.
									</div></li></ol></div></dd><dt><span class="term">BusinessAgreementWithCoordinatorCompletion</span></dt><dd><div class="para">
								The <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code> differs from the <code class="systemitem">BusinessAgreementWithParticipantCompletion</code> protocol in that the participant cannot autonomously decide to complete its participation in the BA, even if it can be compensated.
							</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><ol class="1"><li class="step"><div class="para">
										Instead, the completion stage is driven by the client which created the BA, which sends a <code class="systemitem">completed</code> message to the coordinator.
									</div></li><li class="step"><div class="para">
										The coordinator sends a <code class="systemitem">complete</code> message to each participant, indicating that no further requests will be sent to the service associated with the participant.
									</div></li><li class="step"><div class="para">
										The participant continues on in the same manner as in the BusinessAgreementWithParticipantCompletion protocol.
									</div></li></ol></div></dd></dl></div><div class="para">
					The advantage of the BA model, compared to the AT model, is that it allows the participation of services that cannot lock resources for extended periods.
				</div><div class="para">
					While the full ACID semantics are not maintained by a BA, consistency can still be maintained through compensation. The task of writing correct compensating actions to preserve overall system consistency is the responsibility of the developers of the individual services under control of the BA. Such compensations may use backward error recovery, but forward recovery is more common.
				</div><div class="para">
					<a class="xref" href="ch18.html#fig-bawpc-state-transitions">Figure 18.8, “The WS-BA participant state transitions when created with the BusinessAgreementWithParticipantCompletion protocol”</a> shows the state transitions of a WS-BA <code class="systemitem">BusinessAgreementWithParticipantCompletion</code> participant and the message exchanges between coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the participants' messages are illustrated with dashed lines.
				</div><div class="figure"><a id="fig-bawpc-state-transitions">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-bawpc-state-transitions.png" alt="The WS-BA participant state transitions when created with the BusinessAgreementWithParticipantCompletion protocol"/></div></div><p class="title"><strong>Figure 18.8. The WS-BA participant state transitions when created with the BusinessAgreementWithParticipantCompletion protocol</strong></p></div><div class="para">
					<a class="xref" href="ch18.html#fig-bawcc-state-transitions">Figure 18.9, “The WS-BA participant state transitions when created with the BusinessAgreementWithCoordinatorCompletion protocol”</a> shows the state transitions of a WS-BA <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code> participant and the message exchanges between coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the participants' messages are illustrated with dashed lines.
				</div><div class="figure"><a id="fig-bawcc-state-transitions">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-bawcc-state-transitions.png" alt="The WS-BA participant state transitions when created with the BusinessAgreementWithCoordinatorCompletion protocol"/></div></div><p class="title"><strong>Figure 18.9. The WS-BA participant state transitions when created with the BusinessAgreementWithCoordinatorCompletion protocol</strong></p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019169772144">
      ⁠</a>18.2.4. Application Messages</h2></div></div></div><div class="para">
				<em class="firstterm">Application messages</em> are the requests and responses sent between parties, that constitute the work of a business process. Any such messages are considered opaque by XTS, and there is no mandatory message format, protocol binding, or encoding style. This means that you are free to use any appropriate Web Services protocol. In XTS, the transaction context is propagated within the headers of SOAP messages.
			</div><div class="para">
				XTS ships with support for service developers building WS-Transactions-aware services on the JBoss Enterprise Application Platform. Interceptors are provided for automatic context handling at both client and service, which significantly simplifies development, allowing you to concentrate on writing the business logic without being sidetracked by the transactional infrastructure. The interceptors add and remove context elements to application messages, without altering the semantics of the messages themselves. Any service which understands what to do with a WS-C context can use it. Services which are not aware of WS-C, WS-Atomic Transaction and WS-Business Activity can ignore the context. XTS manages contexts without user intervention.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140019169768800">
      ⁠</a>18.2.4.1. WS-C, WS-Atomic Transaction, and WS-Business Activity Messages</h3></div></div></div><div class="para">
					Although the application or service developer is rarely interested in the messages exchanged by the transactional infrastructure, it is useful to understand what kinds of exchanges occur so that the underlying model can be fitted in to an overall architecture.
				</div><div class="para">
					WS-Coordination, WS-Atomic Transaction and WS-Business Activity-specific messages are transported using SOAP messaging over HTTP. The types of messages that are propagated include instructions to perform standard transaction operations like <code class="systemitem">begin</code> and <code class="systemitem">prepare</code>.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						XTS messages do not interfere with messages from the application, an application need not use the same transport as the transaction-specific messages. For example, a client application might deliver its application-specific messages using SOAP RPC over SMTP, even though the XTS messages are delivered using a different mechanism.
					</div></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019179309120">
      ⁠</a>18.3. Summary</h1></div></div></div><div class="para">
			XTS provides a coordination infrastructure which allows transactions to run between services owned by different business, across the Internet. That infrastructure is based on the WS-C, WS-Atomic Transaction and WS-Business Activity specifications. It supports two kinds of transactions: atomic transactions and business activities, which can be combined in arbitrary ways to map elegantly onto the transactional requirements of the underlying problem. The use of the whole infrastructure is simple, because its functionality is exposed through a simple transactioning API. XTS provides everything necessary to keep application and transactional aspects of an application separate, and to ensure that a system's use of transactions does not interfere with the functional aspects of the system itself.
		</div></div></div></body></html>