<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Appendix A. Object Store Implementations</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019169408320">
      ⁠</a>Appendix A. Object Store Implementations</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019176046320">
      ⁠</a>A.1. The ObjectStore</h1></div></div></div><div class="para">
			This chapter covers the various JBoss Transaction Service object store implementations and provides guidelines for creating new implementations and using them in an application.
		</div><div class="para">
			JBoss Transaction Service includes several different implementations of a basic object store. Each implementation is optimized for a particular purpose. All of the implementations are derived from the <span class="interface">ObjectStore</span> interface, which defines the minimum operations which is needed for an object store implementation to be used by JBoss Transaction Service. You can override the default object store implementation at runtime by setting the <span class="property">com.arjuna.ats.arjuna.objectstore.objectStoreType</span> property to one of the types described below in <a class="xref" href="apa.html#example-objectstoreType">Example A.1, “Object Store Type”</a>.
		</div><div class="example"><a id="example-objectstoreType">
      ⁠</a><p class="title"><strong>Example A.1. Object Store Type</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Comment">/*</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* This is the base class from which all object store types are derived.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* Note that because object store instances are stateless, to improve</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* efficiency we try to only create one instance of each type per process.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* Therefore, the create and destroy methods are used instead of new</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* and delete. If an object store is accessed via create it *must* be</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* deleted using destroy. Of course it is still possible to make use of</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	* new and delete directly and to create instances on the stack.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">	*/</span>
<span xmlns="" class="line">​</span>	
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> ObjectStore
<span xmlns="" class="line">​</span>	{
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_COMMITTED;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_COMMITTED_HIDDEN;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_HIDDEN;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_INVISIBLE;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_ORIGINAL;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_SHADOW;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_UNCOMMITTED;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_UNCOMMITTED_HIDDEN;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> <span xmlns="" class="perl_DataType">int</span> OS_UNKNOWN;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">ObjectStore</span> (ClassName type);
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">ObjectStore</span> (ClassName type, String osRoot);
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">ObjectStore</span> (String osRoot);
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">allObjUids</span> (String s, InputObjectState buff)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">allObjUids</span> (String s, InputObjectState buff,
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_DataType">int</span> m) <span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">allTypes</span> (InputObjectState buff)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">int</span> <span xmlns="" class="perl_Function">currentState</span>(Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">commit_state</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">hide_state</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">reveal_state</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> InputObjectState <span xmlns="" class="perl_Function">read_committed</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> InputObjectState <span xmlns="" class="perl_Function">read_uncommitted</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">remove_committed</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">remove_uncommitted</span> (Uid u, String tn)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">write_committed</span> (Uid u, String tn,
<span xmlns="" class="line">​</span>	OutputObjectState buff)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">synchronized</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">write_uncommitted</span> (Uid u, String tn,
<span xmlns="" class="line">​</span>	OutputObjectState buff)
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">throws</span> ObjectStoreException;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">printState</span> (PrintStream strm, <span xmlns="" class="perl_DataType">int</span> res);
<span xmlns="" class="line">​</span>	};
</pre></div></div><div class="para">
			You do not usually need to interact with any of the object store implementations directly, except for creating them if you are not using the default store type. All stores manipulate instances of the class <code class="classname">ObjectState</code>, which are named using a type derived via the object's <code class="methodname">type()</code> operation, and a Uid. Object states in the store are usually in one of two distinct states <code class="systemitem">OS_COMMITTED</code> or <code class="systemitem">OS_UNCOMMITTED</code>. An object state starts in the <code class="systemitem">OS_COMMITTED</code> state, but when modified under the control of an atomic action, a new second object state may be written that is in the <code class="systemitem">OS_UNCOMMITTED</code> state. If the action commits, this second object state replaces the original and becomes <code class="systemitem">OS_COMMITTED</code>. If the action aborts, this second object state is discarded. All of the implementations provided with this release use shadow copies to handle these state transitions. However, you are allowed to implement them in a different way. Object states may become hidden and inaccessible under the control of the crash recovery system.
		</div><div class="para">
			The <code class="methodname">allTypes</code> and <code class="methodname">allObjUids</code> methods provide the ability to browse the contents of a store. The <code class="methodname">allTypes</code> method returns an <span class="type">InputObjectState</span> containing all of the type names of all objects in a store, terminated by a null name. The <code class="methodname">allObjUids</code> method returns an <span class="type">InputObjectState</span> that contains all of the Uids of all objects of a given type terminated by the special <code class="methodname">Uid.nullUid()</code> type.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Persistent_object_stores">
      ⁠</a>A.2. Persistent Object Stores</h1></div></div></div><div class="para">
			This section briefly describes the characteristics and optimizations of each of the supplied implementations of the persistent object store. Persistent object states are mapped onto the structure of the file system supported by the host operating system.
		</div><div class="para"><div xmlns:d="http://docbook.org/ns/docbook" class="title">Common Functionality</div>
				In addition to the features mentioned earlier, all of the supplied persistent object stores obey the following rules:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Each object state is stored in its own file, which is named using the <code class="systemitem">Uid</code> of the object.
				</div></li><li class="listitem"><div class="para">
					The type of an object, provided by the <code class="methodname">type()</code> operation, determines the directory where the object is placed.
				</div></li><li class="listitem"><div class="para">
					All of the stores have a common root directory which is determined by the JBoss Transaction Service configuration. This directory name is automatically prepended to any store-specific root information.
				</div></li><li class="listitem"><div class="para">
					All stores can also use a localized root directory that is automatically prepended to the type of the object to determine the ultimate directory name. The localized root name is specified when the store is created. The default localized root name is <code class="systemitem">defaultStore</code>.
				</div></li></ul></div><div class="table"><a id="idm140019160891344">
      ⁠</a><p class="title"><strong>Table A.1. Example Object Store Information</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="Example Object Store Information"><colgroup><col/><col/></colgroup><thead><tr><th> <div class="para">
							Item
						</div>
						 </th><th> <div class="para">
							Example Value
						</div>
						 </th></tr></thead><tbody><tr><td> <div class="para">
							ObjectStore root Directory from configure
						</div>
						 </td><td> <div class="para">
							<code class="filename">/JBossTS/ObjectStore/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							ObjectStore Type 1
						</div>
						 </td><td> <div class="para">
							<code class="filename">FragmentedStore/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							Default root
						</div>
						 </td><td> <div class="para">
							<code class="filename">defaultStore/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							StateManager
						</div>
						 </td><td> <div class="para">
							<code class="filename">StateManager</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							LockManager
						</div>
						 </td><td> <div class="para">
							<code class="filename">LockManager/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							User Types
						</div>
						 </td><td> <div class="para">
							<code class="filename"/>
						</div>
						 </td></tr><tr><td> <div class="para">
							Localized root 2
						</div>
						 </td><td> <div class="para">
							<code class="filename">myStore/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							StateManager
						</div>
						 </td><td> <div class="para">
							<code class="filename">StateManager/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							ObjectStore Type2
						</div>
						 </td><td> <div class="para">
							<code class="filename">ActionStore/</code>
						</div>
						 </td></tr><tr><td> <div class="para">
							Default root
						</div>
						 </td><td> <div class="para">
							<code class="filename">defaultStore/</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019150637920">
      ⁠</a>A.2.1. The Shadowing Store</h2></div></div></div><div class="para">
				The shadowing store is the original version of the object store as provided in prior releases. It is implemented by the <code class="classname">ShadowingStore</code> class. It is simple but slow, using pairs of files to represent objects: the shadow version and the committed version. Files are opened, locked, operated upon, unlocked, and closed during every interaction with the object store. This can take more resources than strictly necessary just to open, close, and rename files.
			</div><div class="para">
				The type of this object store is <span class="type">ShadowingStore</span>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019150634656">
      ⁠</a>A.2.2. No file-level locking</h2></div></div></div><div class="para">
				Since transactional objects are concurrency-controlled through the <code class="methodname">LockManager</code> method, no additional locking is needed at the file level. Therefore, the default object store implementation for JBoss Transaction Service, <code class="methodname">ShadowNoFileLockStore</code>, relies upon user-level locking, enabling it to provide better performance than the <code class="methodname">ShadowingStore</code> implementation.
			</div><div class="para">
				The type of this object store is <span class="type">ShadowNoFileLockStore</span>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019182796000">
      ⁠</a>A.2.3. The Hashed Store</h2></div></div></div><div class="para">
				The <code class="classname">HashedStore</code> implementation uses the same structure for object states as the shadowing store, but uses an alternate directory structure that is designed to store large numbers of objects of the same type. Objects are scattered throughout a set of directories by means of a hashing function which uses the object's Uid. By default, 255 sub-directories are used, but you can override this by setting the <code class="varname">HASHED_DIRECTORIES</code> environment variable.
			</div><div class="para">
				The type of this object store is <span class="type">HashedStore</span>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019182792336">
      ⁠</a>A.2.4. The JDBC Store</h2></div></div></div><div class="para">
				The <code class="methodname">JDBCStore</code> implementation stores persistent object states in a JDBC database. Nested transaction support is available when the <code class="methodname">JBDCStore</code> is used in conjunction with the Transactional Objects for Java API. All object states are stored as <em class="firstterm">Binary Large Objects (BLOBs)</em> within a single table. Object state size is limited to 64k. If you try to store an object state which exceeds this limit, an exception is thrown and the state is not stored. The transaction is forced to roll back.
			</div><div class="para">
				When using the JDBC object store, the application needs to provide an implementation of the <code class="classname">JDBCAccess</code> interface, located in the <span class="package">com.arjuna.ats.arjuna.objectstore</span> package. See the <a class="xref" href="apa.html#example-JDBCAccess">Example A.2, “JDBCAccess Implementation Example”</a>.
			</div><div class="example"><a id="example-JDBCAccess">
      ⁠</a><p class="title"><strong>Example A.2. JDBCAccess Implementation Example</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>	  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">interface</span> JDBCAccess
<span xmlns="" class="line">​</span>	  {
<span xmlns="" class="line">​</span>	  <span xmlns="" class="perl_Keyword">public</span> Connection <span xmlns="" class="perl_Function">getConnection</span> () <span xmlns="" class="perl_Keyword">throws</span> SQLException;
<span xmlns="" class="line">​</span>	  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">putConnection</span> (Connection conn) <span xmlns="" class="perl_Keyword">throws</span> SQLException;
<span xmlns="" class="line">​</span>	  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">initialise</span> (ObjectName objName);
<span xmlns="" class="line">​</span>	  }
</pre></div></div><div class="para">
				The implementation of the <code class="classname">JDBCAccess</code> class provides the <code class="methodname">Connection</code> used by the JDBC ObjectStore to save and restore object states. Refer to <a class="xref" href="apa.html#list-Connection-methods"><code class="classname">JDBCAccess</code> <code class="methodname">Connection</code> Methods</a> for details.
			</div><div class="variablelist"><a id="list-Connection-methods">
      ⁠</a><p class="title"><strong><code class="classname">JDBCAccess</code> <code class="methodname">Connection</code> Methods</strong></p><dl class="variablelist"><dt><span class="term"><code class="methodname">getConnection</code></span></dt><dd><div class="para">
							Returns the Connection to use. This method will be called whenever a connection is required and the implementation should use whatever policy is necessary for determining what connection to return. This method need not return the same Connection instance more than once.
						</div></dd><dt><span class="term"><code class="methodname">putConnection</code></span></dt><dd><div class="para">
							Returns one of the Connections acquired from getConnection. Connections are returned if any errors occur when using them.
						</div></dd><dt><span class="term"><code class="methodname">initialise</code></span></dt><dd><div class="para">
							Passes additional arbitrary information to the implementation.
						</div></dd></dl></div><div class="para">
				The JDBC object store initially requests the number of <code class="methodname">Connections</code> defined in the <span class="property">com.arjuna.ats.arjuna.objectstore.jdbcPoolSizeInitial</span> property, and uses no more than defined in the <span class="property">com.arjuna.ats.arjuna.objectstore.jdbcPoolSizeMaximum</span> property.
			</div><div class="para">
				The implementation of the <code class="interfacename">JDBCAccess</code> interface to use should be set in the <span class="property">com.arjuna.ats.arjuna.objectstore.jdbcUserDbAccess</span> property variable.
			</div><div class="para">
				The type of this object store is <span class="type">JDBCStore</span>.
			</div><div class="para">
				A JDBC object store can manage the transaction log. The transaction log implementation should be set to <span class="property">JDBCActionStore</span>, and the <code class="methodname">JDBCAccess</code> method should be provided via the <span class="property">com.arjuna.ats.arjuna.objectstore.jdbcTxDbAccess</span> property. The default table name is <code class="systemitem">JBossTSTxTable</code>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					You can use the same <code class="classname">JDBCAccess</code> implementation for both the user object store and the transaction log.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019118317808">
      ⁠</a>A.2.5. The Cached Store</h2></div></div></div><div class="para">
				The cached store uses the hashed object store, but does not read or write states to the persistent backing store immediately. It maintains the states in a volatile memory cache, flushing the cache periodically or when it is full. The failure semantics associated with this object store are different from the semantics used with the normal persistent object stores, because data about states could be lost in the event of a failure.
			</div><div class="para">
				The type of this object store is <span class="type">CachedStore</span>.
			</div><div class="variablelist"><p class="title"><strong>Configuration Options for the Cached Store</strong></p><dl class="variablelist"><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.hash</span></span></dt><dd><div class="para">
							Sets the number of internal stores to hash the states over. The default value is <code class="literal">128</code>.
						</div></dd><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.size</span></span></dt><dd><div class="para">
							The maximum size the cache can reach before a flush is triggered. The default is value is <code class="literal">10240</code> bytes.
						</div></dd><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.removedItems</span></span></dt><dd><div class="para">
							The maximum number of removed items that the cache can contain before a flush is triggered. By default, calls to remove a state that is in the cache actually only remove the state from the cache, leaving a blank entry. This improves performance. The entries are removed when the cache is flushed. The default value is twice the size of the hash.
						</div></dd><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.workItems</span></span></dt><dd><div class="para">
							The maximum number of items the cache is able to contain before it is flushed. The default value is <code class="literal">100</code>.
						</div></dd><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.scanPeriod</span></span></dt><dd><div class="para">
							The length of time, in milliseconds, for periodically flushing the cache. The default is <code class="literal">120</code> seconds.
						</div></dd><dt><span class="term"><span class="property">com.arjuna.ats.internal.arjuna.objectstore.cacheStore.sync</span></span></dt><dd><div class="para">
							Determines whether flushes of the cache are synchronized to disk. The default is <code class="literal">OFF</code>, and the other possible value is <code class="literal">ON</code>.
						</div></dd></dl></div></div></div></div></body></html>