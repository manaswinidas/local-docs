<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 9. Overview</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019146590416">
      ⁠</a>Chapter 9. Overview</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019160525344">
      ⁠</a>9.1. Introduction</h1></div></div></div><div class="para">
			This chapter contains a description of the use of the JBoss Transaction Service and the <em class="firstterm">Transactional Objects for Java</em> toolkit. The classes mentioned in this chapter are the key to writing fault-tolerant applications using transactions. After describing them, their application in a simple application is illustrated. The classes discussed in this chapter can be found in the <code class="classname">com.arjuna.ats.txoj</code> and <code class="classname">com.arjuna.ats.arjuna</code> packages.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019146649648">
      ⁠</a>9.2. JBoss Transaction Service</h1></div></div></div><div class="para">
			In keeping with the object-oriented view, the mechanisms needed to construct reliable distributed applications are presented to programmers in an object-oriented manner. Some mechanisms, such as concurrency control and state management, need to be inherited. Others, such as object storage and transactions, are implemented as JBoss Transaction Service objects that are created and manipulated like any other object.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				When using persistence and concurrency control facilities, it is assumed that the Transactional Objects for Java (TXOJ) classes are being used. Other mechanisms are not discussed here.
			</div></div></div><div class="para">
			JBoss Transaction Service uses object-oriented techniques to present programmers with a toolkit of Java classes which application classes can inherit to obtain desired properties, such as persistence and concurrency control. These classes form a hierarchy, part of which is shown below and which will be described later in this document.
		</div><div class="figure"><a id="figure-txcore-class-hierarchy">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/JBoss_Transaction_Service-class_hierarchy.png" align="middle" alt="JBoss Transaction Service Class Hierarchy" style="text-align: middle"/></div></div><p class="title"><strong>Figure 9.1. JBoss Transaction Service Class Hierarchy</strong></p></div><div class="para">
			The programmer is only responsible for specifying the scopes of transactions and setting appropriate locks within objects. JBoss Transaction Service and <span class="emphasis"><em>Transactional Objects for Java</em></span> (TXOJ) ensure registration and function with the appropriate transactions, as well as crash recovery in the case of failure.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019178556000">
      ⁠</a>9.2.1. Saving Object States</h2></div></div></div><div class="para">
				JBoss Transaction Service remembers the state of an object. It needs this information for recovery , in which the state represents some past state of the object, and persistence, in which the state represents the final state of an object at application termination. All of these requirements are implemented using the same mechanism: the <code class="classname">InputObjectState</code> class and the <code class="classname">OutputObjectState</code> class. The classes maintain an internal array into which instances of the standard types can be contiguously packed and unpacked using <code class="methodname">pack</code> and <code class="methodname">unpack</code> operations. This buffer is automatically resized as required. The instances are all stored in the buffer in a standard machine-independent form called network byte order. Any other architecture-independent format, such as XDR or ASN.1), can be implemented by replacing the classes with the ones corresponding to the pack and unpack function in the required format.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019157118704">
      ⁠</a>9.2.2. The Object Store</h2></div></div></div><div class="para">
				The Java SecurityManager imposes some restrictions on the implementation of persistence. Therefore, the object store provided with JBoss Transaction Service uses the techniques of interface/implementation. The implementations in JBoss Transaction Service write object states to the local file system or a database, or use a client stub to implement an interface to remote services.
			</div><div class="para">
				When persistent objects are created, they are given unique identifiers, which are actually instances of the Uid class. They can be identified within the object store by using these UIDs. States are read using the <code class="methodname">read_committed</code> operation and written by the <code class="methodname">write_committed</code> and <code class="methodname">write_uncommitted</code> operations.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019111798784">
      ⁠</a>9.2.3. Recovery and persistence</h2></div></div></div><div class="para">
				The <code class="classname">StateManager</code> class is at the root of the class hierarchy, and is responsible for object activation and deactivation and object recovery. See <a class="xref" href="ch09.html#StateManager_Signature">Example 9.1, “<code class="classname">StateManager</code> Implementation”</a>.
			</div><div class="example"><a id="StateManager_Signature">
      ⁠</a><p class="title"><strong>Example 9.1. <code class="classname">StateManager</code> Implementation</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">abstract</span> <span xmlns="" class="perl_Keyword">class</span> StateManager
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">activate</span> ();
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">deactivate</span> (<span xmlns="" class="perl_DataType">boolean</span> commit);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> Uid <span xmlns="" class="perl_Function">get_uid</span> (); <span xmlns="" class="perl_Comment">// object’s identifier.</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">// methods to be provided by a derived class</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">restore_state</span> (InputObjectState os);
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">save_state</span> (OutputObjectState os);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">protected</span> <span xmlns="" class="perl_Function">StateManager</span> ();
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">protected</span> <span xmlns="" class="perl_Function">StateManager</span> (Uid id);
<span xmlns="" class="line">​</span>};</pre></div></div><div class="para">
				Objects can be classified as recoverable, recoverable and persistent, or neither recoverable nor persistent.
			</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Recoverable</span></dt><dd><div class="para">
							<code class="classname">StateManager</code> attempts to generate and maintain appropriate recovery information for the object. The lifetimes of such objects do not exceed the application that created them.
						</div></dd><dt><span class="term">Recoverable and Persistent</span></dt><dd><div class="para">
							The lifetime of the object is greater than that of the creating or accessing application. In addition to maintaining recovery information, <code class="classname">StateManager</code> attempts to automatically <code class="methodname">load</code> or <code class="methodname">unload</code> any existing persistent state for the object by calling the <code class="methodname">activate</code> or <code class="methodname">deactivate</code> operation at the appropriate times.
						</div></dd><dt><span class="term">Neither Recoverable Nor Persistent</span></dt><dd><div class="para">
							No recovery information is ever kept nor is object activation or deactivation ever automatically attempted.
						</div></dd></dl></div><div class="para">
				If an object is recoverable or recoverable and persistent, then <code class="classname">StateManager</code> invokes the <code class="methodname">save_state</code> method, as part of performing the <code class="methodname">deactivate</code> method, and the <code class="methodname">restore_state</code>, as part of performing the <code class="methodname">activate</code>, at various points during the execution of the application. The programmer must implement these methods, since <code class="classname">StateManager</code> cannot detect user-level state changes. The programmer decides which parts of an object’s state should be made persistent. For example, in the case of a spreadsheet, you may not need to save all entries if some values can be recomputed instead. The <a class="xref" href="ch09.html#example_save_state">Example 9.2, “<code class="methodname">save_state</code> Example”</a> example shows the <code class="methodname">save_state</code> implementation for a class <code class="classname">Example</code> that has integer member variables called A, B and C.
			</div><div class="example"><a id="example_save_state">
      ⁠</a><p class="title"><strong>Example 9.2. <code class="methodname">save_state</code> Example</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">save_state</span>(OutputObjectState o)
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">if</span> (!<span xmlns="" class="perl_Keyword">super</span>.<span xmlns="" class="perl_Function">save_state</span>(o))
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">false</span>;
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">try</span>
<span xmlns="" class="line">​</span>	{
<span xmlns="" class="line">​</span>	    o.<span xmlns="" class="perl_Function">packInt</span>(A);
<span xmlns="" class="line">​</span>	    o.<span xmlns="" class="perl_Function">packInt</span>(B);
<span xmlns="" class="line">​</span>	    o.<span xmlns="" class="perl_Function">packInt</span>(C));
<span xmlns="" class="line">​</span>}
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">catch</span> (Exception e)
<span xmlns="" class="line">​</span>    {
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">false</span>;
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">true</span>;
<span xmlns="" class="line">​</span>}                      
</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					All <code class="methodname">save_state</code> and <code class="methodname">restore_state</code> methods need to call <code class="classname">super.save_state </code>and <code class="classname">super.restore_state</code>, to take advantage of improvements in the crash recovery mechanisms.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019159917888">
      ⁠</a>9.2.4. The Life cycle of a Transactional Object for Java </h2></div></div></div><div class="para">
				A persistent object which is not in use is assumed to be in a passive state, with its state residing in an object store and activated on demand. See the <a class="xref" href="ch09.html#example-fundamental-lifecycle">Figure 9.2, “Fundamental Life cycle of a Persistent Object in TXOJ”</a>.
			</div><div class="figure"><a id="example-fundamental-lifecycle">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/Persistent_Object_Lifecycle.png" align="middle" alt="Fundamental Life cycle of a Persistent Object in TXOJ" style="text-align: middle"/></div></div><p class="title"><strong>Figure 9.2. Fundamental Life cycle of a Persistent Object in TXOJ</strong></p></div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						The object is initially passive, and is stored in the object store as an instance of the class <code class="classname">OutputObjectState</code>.
					</div></li><li class="listitem"><div class="para">
						When required by an application, the object is automatically activated by reading it from the store using a <code class="methodname">read_committed</code> operation and is then converted from an <code class="classname">InputObjectState</code> instance into a fully-fledged object by the <code class="methodname">restore_state</code> operation of the object.
					</div></li><li class="listitem"><div class="para">
						When the application finishes with the object, it is deactivated by converting it back into an <code class="classname">OutputObjectState</code> instance using the <code class="methodname">save_state</code> operation, and is then stored back into the object store as a shadow copy using the <code class="methodname">write_uncommitted</code> method. This shadow copy can be committed, overwriting the previous version, using the <code class="methodname">commit_state</code> operation. The existence of shadow copies is normally hidden from the programmer by the transaction system. Object de-activation normally only occurs when the top-level transaction within which the object was activated commits.
					</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					During its lifetime, a persistent object may change from passive to active and back again, many times.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019160928512">
      ⁠</a>9.2.5. The Concurrency Controller</h2></div></div></div><div class="para">
				The concurrency controller is implemented by the <code class="classname">LockManager</code> class, which provides sensible default behavior which the programmer can override if necessary, by the particular semantics of the class being programmed. As with the <code class="classname">StateManager</code> class and persistence, concurrency control implementations are accessed through interfaces. The current implementations of concurrency control available to interfaces include:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Access to remote services
					</div></li><li class="listitem"><div class="para">
						Both local disk and database implementations, where locks are written to the local file system or database to make them persistent.
					</div></li><li class="listitem"><div class="para">
						A purely local implementation, where locks are maintained within the memory of the virtual machine which created them. This implementation performs better than writing locks to the local disk, but objects cannot be shared between virtual machines. Importantly, it is a basic Java object with no requirements which can be affected by the SecurityManager
					</div></li></ul></div><div class="para">
				The primary API to the concurrency controller is via the <code class="methodname">setlock</code> operation. By default, the runtime system enforces strict two-phase locking following a multiple reader, single writer policy on a per object basis. However, as shown in <a class="xref" href="ch09.html#figure-txcore-class-hierarchy">Figure 9.1, “JBoss Transaction Service Class Hierarchy”</a>, by inheriting from the <code class="classname">Lock</code> class, programmers can provide their own lock implementations with different lock conflict rules to enable <em class="firstterm">type specific concurrency control</em>.
			</div><div class="para">
				Lock acquisition is, of necessity, under programmer control. Just as <code class="classname">StateManager</code> cannot determine if an operation modifies an object, <code class="classname">LockManager</code> cannot determine if an operation needs a read or write lock. Lock release, however, is under control of the system and requires no further intervention by the programmer. This ensures that the two-phase property can be correctly maintained.
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">abstract</span> <span xmlns="" class="perl_Keyword">class</span> LockManager <span xmlns="" class="perl_Keyword">extends</span> StateManager
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> LockResult <span xmlns="" class="perl_Function">setlock</span> (Lock toSet, <span xmlns="" class="perl_DataType">int</span> retry, <span xmlns="" class="perl_DataType">int</span> timeout);
<span xmlns="" class="line">​</span>};</pre><div class="para">
				The <code class="classname">LockManager</code> class manages requests to set or release a lock on an object as appropriate. Since it is derived from the <code class="classname">StateManager</code> class, it can also control when some of the inherited facilities are invoked. For example, <code class="classname">LockManager</code> assumes that the setting of a write lock implies that the invoking operation must be about to modify the object, and may trigger the saving of recovery information if the object is recoverable. In a similar fashion, successful lock acquisition causes activate to be invoked.
			</div><div class="example"><a id="idm140019181250288">
      ⁠</a><p class="title"><strong>Example 9.3. Trying to Obtain A Write Lock</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Example <span xmlns="" class="perl_Keyword">extends</span> LockManager
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">foobar</span> ()
<span xmlns="" class="line">​</span>    {
<span xmlns="" class="line">​</span>	AtomicAction A = <span xmlns="" class="perl_Keyword">new</span> AtomicAction;
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_DataType">boolean</span> result = <span xmlns="" class="perl_Keyword">false</span>;
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>	A.<span xmlns="" class="perl_Function">begin</span>();
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">if</span> (<span xmlns="" class="perl_Function">setlock</span>(<span xmlns="" class="perl_Keyword">new</span> Lock(LockMode.<span xmlns="" class="perl_Function">WRITE</span>), <span xmlns="" class="perl_Float">0</span>) == Lock.<span xmlns="" class="perl_Function">GRANTED</span>)
<span xmlns="" class="line">​</span>	    {
<span xmlns="" class="line">​</span>		<span xmlns="" class="perl_Comment">/*</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">		 * Do some work, and TXOJ will</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">		 * guarantee ACID properties.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">		 */</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>		<span xmlns="" class="perl_Comment">// automatically aborts if fails</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>		<span xmlns="" class="perl_Keyword">if</span> (A.<span xmlns="" class="perl_Function">commit</span>() == AtomicAction.<span xmlns="" class="perl_Function">COMMITTED</span>)
<span xmlns="" class="line">​</span>		    {
<span xmlns="" class="line">​</span>			result = <span xmlns="" class="perl_Keyword">true</span>;
<span xmlns="" class="line">​</span>		    }
<span xmlns="" class="line">​</span>	    }
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">else</span>
<span xmlns="" class="line">​</span>	    A.<span xmlns="" class="perl_Function">rollback</span>();
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>	<span xmlns="" class="perl_Keyword">return</span> result;
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019181247504">
      ⁠</a>9.2.6. The Transaction Protocol Engine</h2></div></div></div><div class="para">
				The transaction protocol engine is represented by the <code class="classname">AtomicAction</code> class, which uses <code class="classname">StateManager</code> to record sufficient information for crash recovery mechanisms to complete the transaction in the event of failures. It has methods for starting and terminating the transaction. For those situations where programmers need to implement their own resources, methods for registering them with the current transaction are also provided. Because JBoss Transaction Service supports subtransactions, if a transaction is begun within the scope of an already executing transaction, it is automatically nested.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					JBoss Transaction Service is multi-thread aware, allowing each thread within an application to share a transaction or execute within its own transaction. Therefore, all JBoss Transaction Service classes are also thread safe.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019173558576">
      ⁠</a>9.2.7. Example</h2></div></div></div><div class="para">
				The simple example below illustrates the relationships between activation, termination and commitment:
			</div><div class="example"><a id="idm140019173557200">
      ⁠</a><p class="title"><strong>Example 9.4. Relationships Between Activation, Termination, and Commitment</strong></p><div class="example-contents"><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>      . . .
<span xmlns="" class="line">​</span>      O1 objct1 = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">objct1</span>(Name-A);<span xmlns="" class="perl_Comment">/* (i) bind to "old" persistent object A */</span>
<span xmlns="" class="line">​</span>      O2 objct2 = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">objct2</span>();	 <span xmlns="" class="perl_Comment">/* create a "new" persistent object */</span>
<span xmlns="" class="line">​</span>      OTS.<span xmlns="" class="perl_Function">current</span>().<span xmlns="" class="perl_Function">begin</span>();		 <span xmlns="" class="perl_Comment">/* (ii) start of atomic action */</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      objct1.<span xmlns="" class="perl_Function">op</span>(...);		      <span xmlns="" class="perl_Comment">/* (iii) object activation and invocations */</span>
<span xmlns="" class="line">​</span>      objct2.<span xmlns="" class="perl_Function">op</span>(...);
<span xmlns="" class="line">​</span>      . . .
<span xmlns="" class="line">​</span>      OTS.<span xmlns="" class="perl_Function">current</span>().<span xmlns="" class="perl_Function">commit</span>(<span xmlns="" class="perl_Keyword">true</span>); 	<span xmlns="" class="perl_Comment">/* (iv) tx commits &amp;amp; objects deactivated */</span>
<span xmlns="" class="line">​</span>      } 					<span xmlns="" class="perl_Comment">/* (v) */</span></pre><div class="para">
					The execution of the above code involves the following sequence of activities:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
							Creation of bindings to persistent objects. This might involve the creation of stub objects and a call to remote objects. The above example re-binds to an existing persistent object identified by <code class="literal">Name-A</code>, and a new persistent object. A naming system for remote objects maintains the mapping between object names and locations and is described in a later chapter.
						</div></li><li class="listitem"><div class="para">
							Start of the atomic transaction.
						</div></li><li class="listitem"><div class="para">
							Operation invocations. As a part of a given invocation, the object implementation ensures that it is locked in read or write mode, assuming no lock conflict, and initialized, if necessary, with the latest committed state from the object store. The first time a lock is acquired on an object within a transaction, the object’s state is also acquired from the object store.
						</div></li><li class="listitem"><div class="para">
							Commit of the top-level action. This includes updating the state of any modified objects in the object store.
						</div></li><li class="listitem"><div class="para">
							Breaking of the previously created bindings.
						</div></li></ol></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019159962704">
      ⁠</a>9.2.8. The Class Hierarchy</h2></div></div></div><div class="para">
				The principal classes which make up the class hierarchy of JBoss Transaction Service are depicted in <a class="xref" href="ch09.html#txcore_class_hierarchy">Example 9.5, “JBoss Transaction Service Class Hierarchy”</a>.
			</div><div class="example"><a id="txcore_class_hierarchy">
      ⁠</a><p class="title"><strong>Example 9.5. JBoss Transaction Service Class Hierarchy</strong></p><div class="example-contents"><pre class="programlisting">StateManager		// Basic naming, persistence and recovery control
LockManager		// Basic two-phase locking concurrency control service
User-Defined Classes
Lock			// Standard lock type for multiple readers/single writer
User-Defined Lock Classes
AbstractRecord		// Important utility class, similar to Resource
RecoveryRecord	            // handles object recovery
LockRecord		// handles object locking
RecordList		// Intentions list
other management record types
AtomicAction		// Implements transaction control abstraction
TopLevelTransaction
Input/OutputBuffer // Architecture neutral representation of an objects’ state
Input/OutputObjectState	// Convenient interface to Buffer
ObjectStore			// Interface to the object storage services
      
</pre></div></div><div class="para">
				Programmers of fault-tolerant applications need the <code class="classname">LockManager</code>, <code class="classname">Lock</code> and <code class="classname">AtomicAction</code> classes. Other classes important to a programmer are <code class="classname">Uid</code>, and <code class="classname">ObjectState</code>. Most JBoss Transaction Service classes are derived from the base class <code class="classname">StateManager</code>, which provides primitive facilities necessary for managing persistent and recoverable objects. These facilities include support for the activation and deactivation of objects, and state-based object recovery. The class <code class="classname">LockManager</code> uses the facilities of <code class="classname">StateManager</code> and <code class="classname">Lock</code> to provide the concurrency control required for implementing the serializability property of atomic actions. The implementation of atomic action facilities is supported by <code class="classname">AtomicAction</code> and <code class="classname">TopLevelTransaction</code>.
			</div><div class="para">
				Consider a simple example. Assume that <code class="classname">Example</code> is a user-defined persistent class suitably derived from the <code class="classname">LockManager</code>. An application containing an atomic transaction Trans accesses an object (called O) of type <code class="classname">Example</code> by invoking the operation op1 which involves state changes to O. The serialisability property requires that a write lock must be acquired on O before it is modified; thus the body of op1 should contain a call to the <code class="literal">setlock</code> operation of the concurrency controller:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">op1</span> (...)
<span xmlns="" class="line">​</span>{	
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">if</span> (<span xmlns="" class="perl_Function">setlock</span> (<span xmlns="" class="perl_Keyword">new</span> Lock(LockMode.<span xmlns="" class="perl_Function">WRITE</span>) == LockResult.<span xmlns="" class="perl_Function">GRANTED</span>)
<span xmlns="" class="line">​</span>	{
<span xmlns="" class="line">​</span>	    <span xmlns="" class="perl_Comment">// actual state change operations follow </span>
<span xmlns="" class="line">​</span>	    ...
<span xmlns="" class="line">​</span>	}
<span xmlns="" class="line">​</span>	}
</pre><div class="para">
				The <code class="methodname">setlock</code> method, provided by the <code class="classname">LockManager</code> class, performs the following functions in this case:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Check write lock compatibility with the currently held locks, and if allowed:
					</div></li><li class="listitem"><div class="para">
						Call the <code class="classname">StateManager</code> operation <code class="methodname">activate</code>, which loads, if not done already, the latest persistent state of O from the object store. Then call the <code class="classname">StateManager</code> operation <code class="methodname">modified</code>, which creates an instance of either <code class="classname">RecoveryRecord</code> or <code class="classname">PersistenceRecord</code> for O, depending upon whether O is persistent or not, and inserts it into the <code class="classname">RecordList</code> of <code class="classname">Trans</code>.
					</div></li><li class="listitem"><div class="para">
						Create and insert a LockRecord instance in the RecordList of Trans.
					</div></li></ul></div><div class="para">
				If <code class="literal">Trans</code> is aborted some time after the lock has been acquired, the <code class="methodname">rollback</code> operation of <code class="classname">AtomicAction</code> processes the <code class="classname">RecordList</code> instance associated with <code class="literal">Trans</code> by invoking an appropriate <code class="methodname">Abort</code> operation on the various records. The implementation of this operation by the <code class="classname">LockRecord</code> class releases the <code class="literal">WRITE</code> lock while that of <code class="classname">RecoveryRecord</code>/<code class="classname">PersistenceRecord</code> restores the prior state of O.
			</div><div class="para">
				All of the above work is automatically being performed by JBoss Transaction Service on behalf of the application programmer. The programmer only starts the transaction and sets an appropriate lock. JBoss Transaction Service and Transactional Objects for Java take care of participant registration, persistence, concurrency control and recovery.
			</div></div></div></div></body></html>