<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 3. The Resource Manager</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Transactions_JTA_Programmers_Guide-Test">
      ⁠</a>Chapter 3. The Resource Manager</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-The_XAResource_Interface">
      ⁠</a>3.1. The XAResource Interface</h1></div></div></div><div class="para">
			Some transaction specifications and systems define a generic resource which can be used to register arbitrary resources with a transaction. The JTA is much more XA specific. The <code class="interfacename">javax.transaction.xa.XAResource</code> interface is a Java mapping of the <code class="interfacename">XA</code> interface, and defines the contract between a <em class="firstterm">Resource Manager</em> and a <em class="firstterm">Transaction Manager</em> in a distributed transaction processing environment. A <em class="firstterm">resource adapter</em> implements the <code class="interfacename">XAResource</code> interface to support association of a top-level transaction to a resource. A relational database is an example of such a resource.
		</div><div class="para">
			The <code class="interfacename">XAResource</code> interface can be supported by any transactional resource adapter that is intended to be used in an environment where transactions are controlled by an external transaction manager. An application can access data through multiple database connections. Each database connection is associated with an <code class="code">XAResource</code> object that serves as a proxy object to the underlying resource manager instance. The transaction manager obtains an <code class="interfacename">XAResource</code> for each resource manager participating in a top-level transaction. The <code class="methodname">start</code> and <code class="methodname">end</code> methods associates and dissociate the transaction from the resource.
		</div><div class="para">
			The resource manager associates the transaction with all work performed on its data between the <code class="methodname">start</code> and <code class="methodname">end</code> invocations. At transaction commit time, these transactional resource managers are instructed by the transaction manager to prepare, commit, or rollback the transaction according to the two-phase commit protocol.
		</div><div class="para">
			In order to be better integrated with Java, the <code class="interfacename">XAResource</code> differs from the standard <code class="interfacename">XA</code> interface in the following ways:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					The resource manager initialization is done implicitly by the resource adapter when the connection is acquired. There is no <code class="methodname">xa_open</code> equivalent.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">Rmid</code> is not passed as an argument. Each <code class="literal">Rmid</code> is represented by a separate <code class="interfacename">XAResource</code> object.
				</div></li><li class="listitem"><div class="para">
					Asynchronous operations are not supported because Java supports multi-threaded processing and most databases do not support asynchronous operations.
				</div></li><li class="listitem"><div class="para">
					Error return values caused by the improper handling of the <code class="interfacename">XAResource</code> object by the transaction manager are mapped to Java exceptions by the <code class="classname">XAException</code> class.
				</div></li><li class="listitem"><div class="para">
					The DTP concept of <em class="firstterm">Thread of Control</em> maps to all Java threads with access to the <code class="interfacename">XAResource</code> and <code class="interfacename">Connection</code> objects. For example, two different threads are able to perform the <code class="methodname">start</code> and <code class="methodname">end</code> operations on the same <code class="interfacename">XAResource</code> object.
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="form-Transactions_JTA_Programmers_Guide-The_XAResource_Interface-Extended_XAResource_control">
      ⁠</a>3.1.1. Extended XAResource Control</h2></div></div></div><div class="para">
				By default, whenever an <code class="interfacename">XAResource</code> object is registered with a JTA-compliant transaction service, you have no control over the order in which it will be invoked during the two-phase commit protocol, with respect to other <code class="interfacename">XAResource</code> objects. However, JBoss Transaction Service supports controlling the order with the two interfaces <code class="interfacename">com.arjuna.ats.jta.resources.StartXAResource</code> and <code class="interfacename">com.arjuna.ats.jta.resources.EndXAResource</code>. By inheriting your <code class="interfacename">XAResource</code> instance from either of these interfaces, you control whether an instance of your class will be invoked at the beginning or end of the commit protocol.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Only one instance of each interface type may be registered with a specific transaction.
				</div></div></div><div class="para">
				Last Resource Commit optimization (LRCO) allows a single resource that is only one-phase aware (does not support <code class="methodname">prepare</code>) to be enlisted with a transaction which manipulates two-phase aware participants. JBossJTA provides LRCO support.
			</div><div class="para">
				In order to use the LRCO feature, your <code class="interfacename">XAResource</code> implementation must extend the <code class="interfacename">com.arjuna.ats.jta.resources.LastResourceCommitOptimisation</code> marker interface. When enlisting the resource via <code class="methodname">Transaction.enlistResource</code>, JBoss Transaction Service allows only a single <code class="interfacename">LastResourceCommitOptimisation</code> participant to be used within each transaction. Your resource is driven last in the commit protocol, and the <code class="methodname">prepare</code> method is not invoked.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					By default, an attempt to enlist more than one instance of a <code class="classname">LastResourceCommitOptimisation</code> class will fail and <code class="literal">false</code> is returned from <code class="methodname">Transaction.enlistResource</code>. You can override this behavior by setting the <span class="property">com.arjuna.ats.jta.allowMultipleLastResources</span> property to <code class="literal">true</code>. Be sure to read the section on enlisting multiple one-phase aware resources fore more information. 

				</div></div></div><div class="para">
				To use the LRCO in a distributed environment, you must disable interposition support. You are still able to use implicit context propagation.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="form-Transactions_JTA_Programmers_Guide-The_XAResource_Interface-Enlisting_multiple_one_phase_aware_resources">
      ⁠</a>3.1.2. Enlisting Multiple One-Phase Aware Resources</h2></div></div></div><div class="para">
				In order to guarantee consistency (atomicity) of outcome between multiple participants (resources) within the same transaction, the two-phase commit protocol is used with a durable transaction log. When possessing a single one-phase aware resource, you can still achieve an atomic (all or nothing) outcome across resources by utilizing LRCO, as explained earlier.
			</div><div class="para">
				However, you may have enlisted multiple one-phase aware resources within the same transaction. For example, a legacy database running within the same transaction as a legacy JMS implementation. In these situations, you cannot achieve atomicity of transaction outcome across multiple resources, because none of them enter the <code class="methodname">prepare</code> state. They commit or rollback immediately when instructed by the transaction coordinator, without knowledge of other resource states and without any way of undoing their actions if subsequent resources make a different choice. This can cause data corruption or heuristic outcomes.
			</div><div class="para">
				In these situations, use either of the following approaches:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Wrap the resources in compensating transactions.
					</div></li><li class="listitem"><div class="para">
						Migrate the legacy implementations to two-phase aware equivalents.
					</div></li></ul></div><div class="para">
				If neither of these options are viable, JBoss Transaction Service supports the enlistment of multiple one-phase aware resources within the same transaction, using LRCO. LRCO is covered earlier in this chapter.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
					Even when LRCO support is enabled, JBoss Transaction Service issues warnings when it detects this support. The log message is <code class="literal">"You have chosen to enable multiple last resources in the transaction manager. This is transactionally unsafe and should not be relied upon.”</code> or, when multiple one-phase resources are enlisted within the transaction, <code class="literal">“This is transactionally unsafe and should not be relied on.”</code>.
				</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Opening_a_Resource_Manager">
      ⁠</a>3.2. Opening a Resource Manager</h1></div></div></div><div class="para">
			The X/Open <code class="interfacename">XA</code> interface requires the transaction manager to initialize a resource manager using the <code class="methodname">xa_open</code> prior to issuing any other <code class="literal">xa_</code> calls. JTA requires initialization of a resource manager to be embedded within the resource adapter representing the resource manager. The transaction manager does not need to know how to initialize a resource manager. It must only tell the resource manager when to start and end work associated with a transaction and when to complete the transaction. The resource adapter is responsible for opening (initializing) the resource manager when the connection to the resource manager is established.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Closing_a_Resource_Manager">
      ⁠</a>3.3. Closing a Resource Manager</h1></div></div></div><div class="para">
			A resource manager is closed by the resource adapter as a result of destroying the transactional resource. A transaction resource at the resource adapter level is comprised of two separate objects:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					An <code class="interfacename">XAResource</code> object that allows the transaction manager to <code class="methodname">start</code> and <code class="methodname">end</code> the transaction association with the resource in use, and to coordinate the transaction completion process.
				</div></li><li class="listitem"><div class="para">
					A connection object that allows the application to perform operations on the underlying resource (for example, JDBC operations on an RDBMS).
				</div></li></ul></div><div class="para">
			Once opened, the resource manager is kept open until the resource is explicitly released (closed). When the application invokes the connection’s <code class="methodname">close</code> method, the resource adapter invalidates the connection object reference that was held by the application, notifying the application server about the <code class="methodname">close</code>. The transaction manager needs to invoke the <code class="methodname">XAResource.end</code> method to dissociate the transaction from that connection.
		</div><div class="para">
			The <code class="methodname">close</code> notification allows the application server to perform any necessary garbage collection and mark the physical XA connection as free for reuse, in the case of connection pooling.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Threads_of_control">
      ⁠</a>3.4. Threads of Control</h1></div></div></div><div class="para">
			The X/Open <code class="interfacename">XA</code> interface specifies that the XA calls related to transaction associations must be invoked from the same thread context. This thread-of-control requirement is not applicable to the object-oriented component-based application run-time environment, in which application threads are dispatched dynamically at method invocation time. Different threads may use the same connection resource to access the resource manager if the connection spans multiple method invocations. Depending on the implementation of the application server, different threads may be involved with the same <code class="interfacename">XAResource</code> object. The resource context and the transaction context may operate independent of thread context. Therefore, different threads may invoke the <code class="methodname">start</code> and <code class="methodname">end</code> methods.
		</div><div class="para">
			If the application server allows multiple threads to use a single <code class="interfacename">XAResource</code> object and its associated connection to the resource manager, the application server must ensure that only one transaction context is associated with the resource at any point in time. Therefore, the <code class="interfacename">XAResource</code> interface requires the resource managers to be able to support the two-phase commit protocol from any thread context.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Transaction_association">
      ⁠</a>3.5. Transaction Association</h1></div></div></div><div class="para">
			Transactions are associated with a transactional resource via the <code class="methodname">start</code> method, and dissociated from the resource via the <code class="methodname">end</code> method. The resource adapter internally maintains an association between the resource connection object and the <code class="interfacename">XAResource</code> object. At any given time, a connection is associated with zero or one transactions. Because JTA does not support nested transactions, the <code class="methodname">start</code> method cannot be invoked on a connection that is currently associated with a different transaction.
		</div><div class="para">
			The transaction manager may interleave multiple transaction contexts with the same resource, as long as <code class="methodname">start</code> and <code class="methodname">end</code> are invoked properly for each transaction context switch. Each time the resource is used with a different transaction, the <code class="methodname">end</code> method must be invoked for the previous transaction that was associated with the resource, and the <code class="methodname">start</code> method must be invoked for the current transaction context.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Externally_controlled_connections">
      ⁠</a>3.6. Externally-Controlled Connections</h1></div></div></div><div class="para">
			If a transactional application's transaction states are managed by an application server, its resources must also be managed by the application server so that transaction association is performed properly. If an application is associated with a transaction, it is incorrect for the application to perform transactional work through the connection without having the connection’s resource object already associated with the global transaction. The application server must associate the <code class="interfacename">XAResource</code> object in use with the transaction by invoking the <code class="methodname">Transaction.enlistResource</code> method.
		</div><div class="para">
			If a server-side transactional application retains its database connection across multiple client requests, the application server must enlist the resource with the application's current transaction context. In this way, the application server manages the connection resource usage status across multiple method invocations.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Resource_sharing">
      ⁠</a>3.7. Resource Sharing</h1></div></div></div><div class="para">
			When the same transactional resource is used to interleave multiple transactions, the application server is responsible for ensuring that only one transaction is enlisted with the resource at any given time. To initiate the transaction <code class="methodname">commit</code> process, the transaction manager can use any of the resource objects connected to the same resource manager instance. The resource object used for the two-phase commit protocol does not need to be associated with the transaction being completed.
		</div><div class="para">
			The resource adapter must be able to handle multiple threads invoking the <code class="interfacename">XAResource</code> methods concurrently for transaction <code class="methodname">commit</code> processing. The code below declares a transactional resource <code class="code">r1</code>. Global transaction <code class="code">xid1</code> is started and ended with <code class="code">r1</code>. Then a different global transaction <code class="code">xid2</code> is associated with <code class="code">r1</code>. In the meantime, the transaction manager may start the two phase commit process for <code class="code">xid1</code> using <code class="code">r1</code> or any other transactional resource connected to the same resource manager. The resource adapter needs to allow the commit process to be executed while the resource is currently associated with a different global transaction.
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>XAResource xares = r1.<span xmlns="" class="perl_Function">getXAResource</span>();
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>xares.<span xmlns="" class="perl_Function">start</span>(xid1); <span xmlns="" class="perl_Comment">// associate xid1 to the connection</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>..
<span xmlns="" class="line">​</span>xares.<span xmlns="" class="perl_Function">end</span>(xid1); <span xmlns="" class="perl_Comment">// disassociate xid1 to the connection</span>
<span xmlns="" class="line">​</span>..
<span xmlns="" class="line">​</span>xares.<span xmlns="" class="perl_Function">start</span>(xid2); <span xmlns="" class="perl_Comment">// associate xid2 to the connection</span>
<span xmlns="" class="line">​</span>..
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">// While the connection is associated with xid2,</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">// the TM starts the commit process for xid1</span>
<span xmlns="" class="line">​</span>status = xares.<span xmlns="" class="perl_Function">prepare</span>(xid1);
<span xmlns="" class="line">​</span>..
<span xmlns="" class="line">​</span>xares.<span xmlns="" class="perl_Function">commit</span>(xid1, <span xmlns="" class="perl_Keyword">false</span>);
<span xmlns="" class="line">​</span>  </pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Local_and_global_transactions">
      ⁠</a>3.8. Local and Global Transactions</h1></div></div></div><div class="para">
			The resource adapter must support the usage of both local and global transactions within the same transactional connection. Local transactions are started and coordinated by the resource manager internally. The <code class="interfacename">XAResource</code> interface is not used for local transactions. When using the same connection to perform both local and global transactions, the following rules apply:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					The local transaction must be committed (or rolled back) before starting a global transaction in the connection.
				</div></li><li class="listitem"><div class="para">
					The global transaction must be dissociated from the connection before any local transaction is started.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Transaction_timeouts">
      ⁠</a>3.9. Transaction Timeouts</h1></div></div></div><div class="para">
			Timeout values can be associated with transactions for life cycle control. If a transaction has not terminated (committed or rolled back) before the timeout value elapses, the transaction system automatically rolls it back. The <code class="interfacename">XAResource</code> interface supports a operation allowing the timeout associated with the current transaction to be propagated to the resource manager and, if supported, overrides any default timeout associated with the resource manager. This is useful when long-running transactions have lifetimes that exceed the default. If the timeout is not altered, the resource manager will rollback before the transaction terminates and subsequently cause the transaction to roll back as well.
		</div><div class="para">
			If no timeout value is explicitly set for a transaction, or a value of 0 is specified, then an implementation-specific default value may be used. In the case of JBoss Transaction Service, how this default value is set depends upon which JTA implementation you are using.
		</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Local JTA</span></dt><dd><div class="para">
						Set the <span class="property">com.arjuna.ats.arjuna.coordinator.defaultTimeout</span> property to a value expressed in seconds. The default value is 60 seconds.
					</div></dd><dt><span class="term">JTS</span></dt><dd><div class="para">
						Set the <span class="property">com.arjuna.ats.jts.defaultTimeout</span> property to a value expressed in seconds. The default value is 0, meaning that transactions do not time out.
					</div></dd></dl></div><div class="para">
			Unfortunately there are situations where imposing the same timeout as the transaction on a resource manager may not be appropriate. For example, the system administrator may need control over the lifetimes of resource managers without allowing that control to be passed to some external entity. JBoss Transaction Service supports an all-or-nothing approach to whether <code class="methodname">setTransactionTimeout</code> is called on <code class="interfacename">XAResource</code> instances.
		</div><div class="para">
			If the <span class="property">com.arjuna.ats.jta.xaTransactionTimeoutEnabled</span> property is set to <code class="literal">true</code> (the default), it is called on all instances. Alternatively, the <code class="methodname">setXATransactionTimeoutEnabled</code> method of <code class="classname">com.arjuna.ats.jta.common.Configuration</code> can be used.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Transactions_JTA_Programmers_Guide-Test-Dynamic_Registration">
      ⁠</a>3.10. Dynamic Registration</h1></div></div></div><div class="para">
			Dynamic registration is not supported in <code class="interfacename">XAResource</code> for the following reasons:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					In the Java component-based application server environment, connections to the resource manager are acquired dynamically when the application explicitly requests a connection. These resources are enlisted with the transaction manager on an as-needed basis.
				</div></li><li class="listitem"><div class="para">
					If a resource manager needs to dynamically register its work to the global transaction, it can be done at the resource adapter level via a private interface between the resource adapter and the underlying resource manager.
				</div></li></ul></div></div></div></body></html>