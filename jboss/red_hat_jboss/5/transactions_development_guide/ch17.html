<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 17. Transactions Overview</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019174426032">
      ⁠</a>Chapter 17. Transactions Overview</h1></div></div></div><a id="idm140019118533840" class="indexterm"/><a id="idm140019112018336" class="indexterm"/><a id="idm140019176539344" class="indexterm"/><a id="idm140019161581360" class="indexterm"/><a id="idm140019110441392" class="indexterm"/><a id="idm140019110321120" class="indexterm"/><a id="idm140019180818176" class="indexterm"/><a id="idm140019173986560" class="indexterm"/><a id="idm140019181203520" class="indexterm"/><a id="idm140019159152592" class="indexterm"/><a id="idm140019170307360" class="indexterm"/><a id="idm140019172757088" class="indexterm"/><a id="idm140019173764848" class="indexterm"/><a id="idm140019152985680" class="indexterm"/><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			This chapter deals with the theory of transactional Web Services. If you are familiar with these principles, consider this chapter a reference.
		</div></div></div><div class="para">
		Transactions have emerged as the dominant paradigm for coordinating interactions between parties in a distributed system, and in particular to manage applications that require concurrent access to shared data. Much of the JBoss Transaction Service Web Service API is based on contemporary transaction APIs whose familiarity will enhance developer productivity and lessen the learning curve. While the following section provides the essential information that you should know before starting to use XTS for building transactional Web Services, it should not be treated as a definitive reference to all transactional technology.
	</div><div class="para">
		A classic transaction is a unit of work that either completely succeeds, or fails with all partially completed work being undone. When a transaction is committed, all changes made by the associated requests are made durable, normally by committing the results of the work to a database. If a transaction should fail and is rolled back, all changes made by the associated work are undone. Transactions in distributed systems typically require the use of a transaction manager that is responsible for coordinating all of the participants that are part of the transaction.
	</div><div class="para">
		The main components involved in using and defining transactional Web Services using XTS are illustrated in <a class="xref" href="ch17.html#fig-web-services-transaction">Figure 17.1, “Components Involved in an XTS Transaction”</a>.
	</div><div class="figure"><a id="fig-web-services-transaction">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-web-services-transaction.png" alt="Components Involved in an XTS Transaction"/></div></div><p class="title"><strong>Figure 17.1. Components Involved in an XTS Transaction</strong></p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019115068400">
      ⁠</a>17.1. The Coordinator</h1></div></div></div><div class="para">
			 Every transaction is associated with a coordinator, which is responsible for governing the outcome of the transaction. When a client begins a Web Service transaction it posts a <code class="systemitem">create</code> request to a coordination service, which creates the coordinator and returns its details to the client. This service may be located in its own container or may be colocated with the application client or with one of the transactional web services for improved performance. The coordination service is typically responsible for managing many transactions in parallel, so each coordinator is identified by a unique transaction identifier.
		</div><div class="para">
			 The coordinator is responsible for ensuring that the web services invoked by the client arrive at a consistent outcome. When the client asks the coordinator to complete the transaction, the coordinator ensures that each web service is ready to confirm any provisional changes it has made within the scope of the transaction. It then asks them all to make their changes permanent. If any of the web services indicates a problem at the confirmation stage, the coordinator ensures that all web services reject their provisional changes, reverting to the state before the transaction started. The coordinator also reverts all changes if the client asks it to cancel the transaction.
		</div><div class="para">
			The negotiation between the coordinator and the web services is organized to ensure that all services will make their changes permanent, or all of them will revert to the previous state, even if the coordinator or one of the web services crashes part of the way through the transaction."
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019168119808">
      ⁠</a>17.2. The Transaction Context</h1></div></div></div><div class="para">
			In order for a transaction to span a number of services, certain information has to be shared between those services, to propagate information about the transaction. This information is known as the <em class="firstterm">Context</em>. The coordination service hands a context back to the application client when it begins a transaction. This context is passed as an extra, hidden parameter whenever the client invokes a transactional web service. The XTS implementation saves and propagates this context automatically with only minimal involvement required on the part of the client.  However, it is still helpful to understand what information is captured in a context. This information is listed in <a class="xref" href="ch17.html#context-contents">Contents of a Context</a>.
		</div><div class="variablelist"><a id="context-contents">
      ⁠</a><p class="title"><strong>Contents of a Context</strong></p><dl class="variablelist"><dt><span class="term">Transaction Identifier</span></dt><dd><div class="para">
						Guarantees global uniqueness for an individual transaction.
					</div></dd><dt><span class="term">Transaction Coordinator Location</span></dt><dd><div class="para">
						The endpoint address participants contact to enroll.
					</div></dd></dl></div><div class="figure"><a id="idm140019158333648">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-web-services-context-flow.png" alt="Web Services and Context Flow"/></div></div><p class="title"><strong>Figure 17.2. Web Services and Context Flow</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019113973280">
      ⁠</a>17.3. Participants</h1></div></div></div><div class="para">
			The coordinator cannot know the details of how every transactional service is implemented. In fact this knowledge is not even necessary for it to negotiate a transactional outcome. It treats each service taking part in a transaction as a participant and communicates with it according to some predefined participant coordination models appropriate to the type of transaction.  When a web service receives its first service request in some given transaction, it enrolls with the coordinator as a participant, specifying the participant model it wishes to follow. The context contains a URL for the endpoint of the coordination service which handles enrollment requests. So, the term participant merely refers a transactional service enrolled in a specific transaction using a specific participant model.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019113970544">
      ⁠</a>17.4. ACID Transactions</h1></div></div></div><div class="para">
			Traditionally, transaction processing systems support <em class="firstterm">ACID</em> properties. ACID is an acronym for <span class="emphasis"><em>Atomic, Consistent, Isolated, and Durable</em></span>. A unit of work has traditionally been considered transactional only if the ACID properties are maintained, as describe in <a class="xref" href="ch17.html#acid-properties">ACID Properties</a>.
		</div><div class="variablelist"><a id="acid-properties">
      ⁠</a><p class="title"><strong>ACID Properties</strong></p><dl class="variablelist"><dt><span class="term">Atomicity</span></dt><dd><div class="para">
						The transaction executes completely, or not at all.
					</div></dd><dt><span class="term">Consistency</span></dt><dd><div class="para">
						The effects of the transaction preserve the internal consistency of an underlying data structure.
					</div></dd><dt><span class="term">Isolated</span></dt><dd><div class="para">
						The transaction runs as if it were running alone, with no other transactions running, and is not visible to other transactions.
					</div></dd><dt><span class="term">Durable</span></dt><dd><div class="para">
						The transaction's results are not lost in the event of a failure.
					</div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019108663152">
      ⁠</a>17.5. Two Phase Commit</h1></div></div></div><div class="para">
			The classical two-phase commit approach is the bedrock of JBoss Transaction Service, and more generally of Web Services transactions. Two-phase commit provides coordination of parties that are involved in a transaction. The general flow of a two-phase commit transaction is described in <a class="xref" href="ch17.html#two-phase-commit-overview">Figure 17.3, “Two-Phase Commit Overview”</a>.
		</div><div class="figure"><a id="two-phase-commit-overview">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-two-phase-commit-overview.png" alt="Two-Phase Commit Overview"/></div></div><p class="title"><strong>Figure 17.3. Two-Phase Commit Overview</strong></p></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				During two-phase commit transactions, coordinators and resources keep track of activity in non-volatile data stores so that they can recover in the case of a failure.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019159751184">
      ⁠</a>17.6. The Synchronization Protocol</h1></div></div></div><div class="para">
			Besides the two-phase commit protocol, traditional transaction processing systems employ an additional protocol, often referred to as the <em class="firstterm">synchronization protocol</em>. With the original ACID properties, Durability is important when state changes need to be available despite failures. Applications interact with a persistence store of some kind, such as a database, and this interaction can impose a significant overhead, because disk access is much slower to access than main computer memory.
		</div><div class="para">
			One solution to the problem disk access time is to cache the state in main memory and only operate on the cache for the duration of a transaction. Unfortunately, this solution needs a way to flush the state back to the persistent store before the transaction terminates, or risk losing the full ACID properties. This is what the synchronization protocol does, with <em class="firstterm">Synchronization Participants</em>.
		</div><div class="para">
			Synchronizations are informed that a transaction is about to commit. At that point, they can flush cached state, which might be used to improve performance of an application, to a durable representation prior to the transaction committing. The synchronizations are then informed about when the transaction completes and its completion state.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="procedure"><a id="idm140019171056304">
      ⁠</a><p class="title"><strong>Procedure 17.1. The "Four Phase Protocol" Created By Synchronizations</strong></p><div class="para">
				Synchronizations essentially turn the two-phase commit protocol into a four-phase protocol:
			</div><ol class="1"><li class="step"><p class="title"><strong>Step 1</strong></p><div class="para">
					Before the transaction starts the two-phase commit, all registered Synchronizations are informed. Any failure at this point will cause the transaction to roll back.
				</div></li><li class="step"><p class="title"><strong>Steps 2 and 3</strong></p><div class="para">
					The coordinator then conducts the normal two-phase commit protocol.
				</div></li><li class="step"><p class="title"><strong>Step 4</strong></p><div class="para">
					Once the transaction has terminated, all registered Synchronizations are informed. However, this is a courtesy invocation because any failures at this stage are ignored: the transaction has terminated so there’s nothing to affect.
				</div></li></ol></div><div class="para">
			The synchronization protocol does not have the same failure requirements as the traditional two-phase commit protocol. For example, Synchronization participants do not need the ability to recover in the event of failures, because any failure before the two-phase commit protocol completes cause the transaction to roll back, and failures after it completes have no effect on the data which the Synchronization participants are responsible for.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019162619648">
      ⁠</a>17.7. Optimizations to the Protocol</h1></div></div></div><div class="para">
			There are several variants to the standard two-phase commit protocol that are worth knowing about, because they can have an impact on performance and failure recovery. <a class="xref" href="ch17.html#two-phase-variants">Table 17.1, “Variants to the Two-Phase Commit Protocol”</a> gives more information about each one.
		</div><div class="table"><a id="two-phase-variants">
      ⁠</a><p class="title"><strong>Table 17.1. Variants to the Two-Phase Commit Protocol</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Variants to the Two-Phase Commit Protocol"><colgroup><col/><col/></colgroup><thead><tr><th> <div class="para">
							Variant
						</div>
						 </th><th> <div class="para">
							Description
						</div>
						 </th></tr></thead><tbody><tr><td> <div class="para">
							Presumed Abort
						</div>
						 </td><td> <div class="para">
							If a transaction is going to roll back, the coordinator may record this information locally and tell all enlisted participants. Failure to contact a participant has no effect on the transaction outcome. The coordinator is informing participants only as a courtesy. Once all participants have been contacted, the information about the transaction can be removed. If a subsequent request for the status of the transaction occurs, no information will be available and the requester can assume that the transaction has aborted. This optimization has the benefit that no information about participants need be made persistent until the transaction has progressed to the end of the <code class="systemitem">prepare</code> phase and decided to commit, since any failure prior to this point is assumed to be an abort of the transaction.
						</div>
						 </td></tr><tr><td> <div class="para">
							One-Phase
						</div>
						 </td><td> <div class="para">
							If only a single participant is involved in the transaction, the coordinator does not need to drive it through the <code class="systemitem">prepare</code> phase. Thus, the participant is told to commit, and the coordinator does not need to record information about the decision, since the outcome of the transaction is the responsibility of the participant.
						</div>
						 </td></tr><tr><td> <div class="para">
							Read-Only
						</div>
						 </td><td> <div class="para">
							When a participant is asked to prepare, it can indicate to the coordinator that no information or data that it controls has been modified during the transaction. Such a participant does not need to be informed about the outcome of the transaction since the fate of the participant has no affect on the transaction. Therefore, a read-only participant can be omitted from the second phase of the commit protocol.
						</div>
						 </td></tr></tbody></table></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The WS-Atomic Transaction protocol does not support the one-phase commit optimization.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019181411888">
      ⁠</a>17.8. Non-Atomic Transactions and Heuristic Outcomes</h1></div></div></div><div class="para">
			In order to guarantee atomicity, the two-phase commit protocol is <em class="firstterm">blocking</em>. As a result of failures, participants may remain blocked for an indefinite period of time, even if failure recovery mechanisms exist. Some applications and participants cannot tolerate this blocking.
		</div><div class="para">
			To break this blocking nature, participants that are past the <code class="systemitem">prepare</code> phase are allowed to make autonomous decisions about whether to commit or rollback. Such a participant must record its decision, so that it can complete the original transaction if it eventually gets a request to do so. If the coordinator eventually informs the participant of the transaction outcome, and it is the same as the choice the participant made, no conflict exists. If the decisions of the participant and coordinator are different, the situation is referred to as a non-atomic outcome, and more specifically as a <em class="firstterm">heuristic outcome</em>.
		</div><div class="para">
			Resolving and reporting heuristic outcomes to the application is usually the domain of complex, manually driven system administration tools, because attempting an automatic resolution requires semantic information about the nature of participants involved in the transactions.
		</div><div class="para">
			Precisely when a participant makes a heuristic decision depends on the specific implementation. Likewise, the choice the participant makes about whether to commit or to roll back depends upon the implementation, and possibly the application and the environment in which it finds itself. The possible heuristic outcomes are discussed in <a class="xref" href="ch17.html#tbl-heuristic-outcomes">Table 17.2, “Heuristic Outcomes”</a>.
		</div><div class="table"><a id="tbl-heuristic-outcomes">
      ⁠</a><p class="title"><strong>Table 17.2. Heuristic Outcomes</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Heuristic Outcomes"><colgroup><col/><col/></colgroup><thead><tr><th> <div class="para">
							Outcome
						</div>
						 </th><th> <div class="para">
							Description
						</div>
						 </th></tr></thead><tbody><tr><td> <div class="para">
							Heuristic Rollback
						</div>
						 </td><td> <div class="para">
							The commit operation failed because some or all of the participants unilaterally rolled back the transaction.
						</div>
						 </td></tr><tr><td> <div class="para">
							Heuristic Commit
						</div>
						 </td><td> <div class="para">
							An attempted rollback operation failed because all of the participants unilaterally committed. One situation where this might happen is if the coordinator is able to successfully <code class="systemitem">prepare</code> the transaction, but then decides to roll it back because its transaction log could not be updated. While the coordinator is making its decision, the participants decides to commit.
						</div>
						 </td></tr><tr><td> <div class="para">
							Heuristic Mixed
						</div>
						 </td><td> <div class="para">
							Some participants commit ed, while others were rolled back.
						</div>
						 </td></tr><tr><td> <div class="para">
							Heuristic Hazard
						</div>
						 </td><td> <div class="para">
							The disposition of some of the updates is unknown. For those which are known, they have either all been committed or all rolled back.
						</div>
						 </td></tr></tbody></table></div></div><div class="para">
			Heuristic decisions should be used with care and only in exceptional circumstances, since the decision may possibly differ from that determined by the transaction service. This type of difference can lead to a loss of integrity in the system. Try to avoid needing to perform resolution of heuristics, either by working with services and participants that do not cause heuristics, or by using a transaction service that provides assistance in the resolution process.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019175932288">
      ⁠</a>17.9. Interposition</h1></div></div></div><div class="para">
			<em class="firstterm">Interposition</em> is a scoping mechanism which allows coordination of a transaction to be delegated across a hierarchy of coordinators. See <a class="xref" href="ch17.html#fig-interpositions">Figure 17.4, “Interpositions”</a> for a graphical representation of this concept.
		</div><div class="figure"><a id="fig-interpositions">
      ⁠</a><div class="figure-contents"><div class="mediaobject"><img src="images/fig-interpositions.png" alt="Interpositions"/></div></div><p class="title"><strong>Figure 17.4. Interpositions</strong></p></div><div class="para">
			Interposition is particularly useful for Web Services transactions, as a way of limiting the amount of network traffic required for coordination. For example, if communications between the top-level coordinator and a web service are slow because of network traffic or distance, the web service might benefit from executing in a subordinate transaction which employs a local coordinator service. In <a class="xref" href="ch17.html#fig-interpositions">Figure 17.4, “Interpositions”</a>,to <code class="systemitem">prepare</code>, the top-level coordinator only needs to send one <code class="systemitem">prepare</code> message to the subordinate coordinator, and receive one <code class="systemitem">prepared</code> or <code class="systemitem">aborted</code> reply. The subordinate coordinator forwards a <code class="systemitem">prepare</code> locally to each participant and combines the results to decide whether to send a single <code class="systemitem">prepared</code> or <code class="systemitem">aborted</code> reply.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140019164356832">
      ⁠</a>17.10. A New Transaction Protocol</h1></div></div></div><div class="para">
			Many component technologies offer mechanisms for coordinating ACID transactions based on two-phase commit semantics. Some of these are CORBA/OTS, JTS/JTA, and MTS/MSDTC. ACID transactions are not suitable for all Web Services transactions, as explained in <a class="xref" href="ch17.html#acid-not-suitable">Reasons ACID is Not Suitable for Web Services</a>.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><a id="acid-not-suitable">
      ⁠</a><p class="title"><strong>Reasons ACID is Not Suitable for Web Services</strong></p><ul><li class="listitem"><div class="para">
					Classic ACID transactions assume that an organization that develops and deploys applications owns the entire infrastructure for the applications. This infrastructure has traditionally taken the form of an Intranet. Ownership implies that transactions operate in a trusted and predictable manner. To assure ACIDity, potentially long-lived locks can be kept on underlying data structures during two-phase commit. Resources can be used for any period of time and released when the transaction is complete.
				</div><div class="para">
					In Web Services, these assumptions are no longer valid. One obvious reason is that the owners of data exposed through a Web service refuse to allow their data to be locked for extended periods, since allowing such locks invites denial-of-service attacks.
				</div></li><li class="listitem"><div class="para">
					All application infrastructures are generally owned by a single party. Systems using classical ACID transactions normally assume that participants in a transaction will obey the directives of the transaction manager and only infrequently make unilateral decisions which harm other participants in a transaction.
				</div><div class="para">
					Web Services participating in a transaction can effectively decide to resign from the transaction at any time, and the consumer of the service generally has little in the way of quality of service guarantees to prevent this.
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140019118735552">
      ⁠</a>17.10.1. Transaction in Loosely Coupled Systems</h2></div></div></div><div class="para">
				Extended transaction models which relax the ACID properties have been proposed over the years. WS-T provides a new transaction protocol to implement these concepts for the Web Services architecture. XTS is designed to accommodate four underlying requirements inherent in any loosely coupled architecture like Web Services. These requirements are discussed in <a class="xref" href="ch17.html#web-services-requirements">Requirements of Web Services</a>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><a id="web-services-requirements">
      ⁠</a><p class="title"><strong>Requirements of Web Services</strong></p><ul><li class="listitem"><div class="para">
						Ability to handle multiple successful outcomes to a transaction, and to involve operations whose effects may not be isolated or durable.
					</div></li><li class="listitem"><div class="para">
						Coordination of autonomous parties whose relationships are governed by contracts, rather than the dictates of a central design authority.
					</div></li><li class="listitem"><div class="para">
						Discontinuous service, where parties are expected to suffer outages during their lifetimes, and coordinated work must be able to survive such outages.
					</div></li><li class="listitem"><div class="para">
						Interoperation using XML over multiple communication protocols. XTS uses SOAP encoding carried over HTTP.
					</div></li></ul></div></div></div></div></body></html>