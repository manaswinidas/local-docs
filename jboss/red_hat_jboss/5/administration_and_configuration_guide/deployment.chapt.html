<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 27. Clustered Deployment Options</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="deployment.chapt">
      ⁠</a>Chapter 27. Clustered Deployment Options</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139776741068928">
      ⁠</a>27.1. Clustered Singleton Services</h1></div></div></div><div class="para">
			A clustered singleton service (also known as a HA singleton) is a service that is deployed on multiple nodes in a cluster, but is providing its service on only one of the nodes. The node running the singleton service is typically called the master node.
		</div><div class="figure"><a id="master_node_before.fig">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/master_node_before.png" align="middle" alt="Topology before the Master Node fails" style="text-align: middle"/></div></div><p class="title"><strong>Figure 27.1. Topology before the Master Node fails</strong></p></div><div class="para">
			When the master fails or is shut down, another master is selected from the remaining nodes and the service is restarted on the new master. Thus, other than a brief interval when one master has stopped and another has yet to take over, the service is always being provided by one but only one node.
		</div><div class="figure"><a id="master_node_fail.fig">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/master_node_fail.png" align="middle" alt="Topology after the Master Node fails" style="text-align: middle"/></div></div><p class="title"><strong>Figure 27.2. Topology after the Master Node fails</strong></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776766358656">
      ⁠</a>27.1.1. HASingleton Deployment Options</h2></div></div></div><div class="para">
				The JBoss Enterprise Application Platform provides support for a number of strategies for helping you deploy clustered singleton services. In this section we will explore the different strategies. All of the strategies are built on top of the HAPartition service described in the introduction. They rely on the <code class="literal">HAPartition</code> to provide notifications when different nodes in the cluster start and stop; based on those notifications each node in the cluster can independently (but consistently) determine if it is now the master node and needs to begin providing a service.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776697580384">
      ⁠</a>27.1.1.1. HASingletonDeployer service</h3></div></div></div><div class="para">
					The simplest and most commonly used strategy for deploying an HA singleton is to take an ordinary deployment (war, ear, jar, whatever you would normally put in deploy) and deploy it in the <code class="literal"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy-hasingleton</code> directory instead of in <code class="filename">deploy</code>. The <code class="filename">deploy-hasingleton</code> directory does not lie under <code class="filename">deploy</code> nor <code class="filename">farm</code> directories, so its contents are not automatically deployed when an Enterprise Application Platform instance starts. Instead, deploying the contents of this directory is the responsibility of a special service, the <code class="literal">HASingletonDeployer</code> bean (which itself is deployed via the <code class="filename">deploy/deploy-hasingleton-jboss-beans.xml</code> file). The HASingletonDeployer service is itself an HA Singleton, one whose provided service, when it becomes master, is to deploy the contents of deploy-hasingleton; and whose service, when it stops being the master (typically at server shutdown), is to undeploy the contents of <code class="filename">deploy-hasingleton</code>.
				</div><div class="para">
					So, by placing your deployments in <code class="literal">deploy-hasingleton</code> you know that they will be deployed only on the master node in the cluster. If the master node cleanly shuts down, they will be cleanly undeployed as part of shutdown. If the master node fails or is shut down, they will be deployed on whatever node takes over as master.
				</div><div class="para">
					Using deploy-hasingleton is very simple, but it does have two drawbacks:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							There is no hot-deployment feature for services in <code class="literal">deploy-hasingleton</code>. Redeploying a service that has been deployed to <code class="literal">deploy-hasingleton</code> requires a server restart.
						</div></li><li class="listitem"><div class="para">
							If the master node fails and another node takes over as master, your singleton service needs to go through the entire deployment process before it will be providing services. Depending on the complexity of your service's deployment, and the extent of start up activity in which it engages, this could take a while, during which time the service is not being provided.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776698671440">
      ⁠</a>27.1.1.2. POJO deployments using HASingletonController</h3></div></div></div><div class="para">
					If your service is a POJO (i.e., not a J2EE deployment like an ear or war or jar), you can deploy it along with a service called an HASingletonController in order to turn it into an HA singleton. It is the job of the HASingletonController to work with the HAPartition service to monitor the cluster and determine if it is now the master node for its service. If it determines it has become the master node, it invokes a method on your service telling it to begin providing service. If it determines it is no longer the master node, it invokes a method on your service telling it to stop providing service. Let us walk through an illustration.
				</div><div class="para">
					First, we have a POJO that we want to make an HA singleton. The only thing special about it is it needs to expose a public method that can be called when it should begin providing service, and another that can be called when it should stop providing service:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">interface</span> HASingletonExampleMBean
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">isMasterNode</span>();
<span xmlns="" class="line">​</span>}</pre><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> HASingletonExample <span xmlns="" class="perl_Keyword">implements</span> HASingletonExampleMBean
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">private</span> <span xmlns="" class="perl_DataType">boolean</span> isMasterNode = <span xmlns="" class="perl_Keyword">false</span>; 
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">isMasterNode</span>()
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">return</span> isMasterNode; 
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">startSingleton</span>()
<span xmlns="" class="line">​</span>   { 
<span xmlns="" class="line">​</span>      isMasterNode = <span xmlns="" class="perl_Keyword">true</span>;
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">stopSingleton</span>()
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      isMasterNode = <span xmlns="" class="perl_Keyword">false</span>; 
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}
</pre><div class="para">
					We used <code class="literal">startSingleton</code> and <code class="literal">stopSingleton</code> in the above example, but you could name the methods anything.
				</div><div class="para">
					Next, we deploy our service, along with an HASingletonController to control it, most likely packaged in a .sar file, with the following <code class="literal">META-INF/jboss-beans.xml</code>:
				</div><div class="programlistingco"><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;deployment</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"urn:jboss:bean-deployer:2.0"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Comment">&lt;!-- This bean is an example of a clustered singleton --&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"HASingletonExample"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.examples.HASingletonExample"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX (name="jboss:service=HASingletonExample", exposedInterface=org.jboss.ha.examples.HASingletonExampleMBean.class)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>    <img class="callout" alt="1" src="Common_Content/images/1.png"/>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"ExampleHASingletonController"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.singleton.HASingletonController"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="jboss:service=ExampleHASingletonController", 
<span xmlns="" class="line">​</span>      exposedInterface=org.jboss.ha.singleton.HASingletonControllerMBean.class, registerDirectly=true)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"target"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"HASingletonExample"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"targetStartMethod"</span><span xmlns="" class="perl_Keyword">&gt;</span>startSingleton<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"targetStopMethod"</span><span xmlns="" class="perl_Keyword">&gt;</span>stopSingleton<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/deployment&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/1.png" alt="1"/></p></td><td valign="top" align="left"><div class="para">
								While the <span class="bold bold"><strong>&lt;annotation&gt;</strong></span> line in the code sample above has been broken across multiple lines for formatting, <span class="bold bold"><strong>ensure it is on a single line if you copy it into a configuration file</strong></span>. The configuration will not work if this line is broken.
							</div></td></tr></table></div></div><div class="para">
					The primary advantage of this approach over deploy-ha-singleton. is that the above example can be placed in <code class="literal">deploy</code> or <code class="literal">farm</code> and thus can be hot deployed and farmed deployed. Also, if our example service had complex, time-consuming start up requirements, those could potentially be implemented in create() or start() methods. JBoss will invoke create() and start() as soon as the service is deployed; it does not wait until the node becomes the master node. So, the service could be primed and ready to go, just waiting for the controller to implement startSingleton() at which point it can immediately provide service.
				</div><div class="para">
					Although not demonstrated in the example above, the <code class="literal">HASingletonController</code> can support an optional argument for either or both of the target start and stop methods. These are specified using the <code class="literal">targetStartMethodArgument</code> and <code class="literal">TargetStopMethodArgument</code> properties, respectively. Currently, only string values are supported.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776685320128">
      ⁠</a>27.1.1.3. HASingleton deployments using a Barrier</h3></div></div></div><div class="para">
					Services deployed normally inside deploy or farm that want to be started/stopped whenever the content of deploy-hasingleton gets deployed/undeployed, (i.e., whenever the current node becomes the master), need only specify a dependency on the Barrier service:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;depends&gt;</span>jboss.ha:service=HASingletonDeployer,type=Barrier<span xmlns="" class="perl_Keyword">&lt;/depends&gt;</span></pre><div class="para">
					The way it works is that a BarrierController is deployed along with the HASingletonDeployer and listens for JMX notifications from it. A BarrierController is a relatively simple MBean that can subscribe to receive any JMX notification in the system. It uses the received notifications to control the lifecycle of a dynamically created MBean called the Barrier. The Barrier is instantiated, registered and brought to the CREATE state when the BarrierController is deployed. After that, the BarrierController starts and stops the Barrier when matching JMX notifications are received. Thus, other services need only depend on the Barrier bean using the usual &lt;depends&gt; tag, and they will be started and stopped in tandem with the Barrier. When the BarrierController is undeployed the Barrier is also destroyed.
				</div><div class="para">
					This provides an alternative to the deploy-hasingleton approach in that we can use farming to distribute the service, while content in deploy-hasingleton must be copied manually on all nodes.
				</div><div class="para">
					On the other hand, the barrier-dependent service will be instantiated/created (i.e., any create() method invoked) on all nodes, but only started on the master node. This is different with the deploy-hasingleton approach that will only deploy (instantiate/create/start) the contents of the deploy-hasingleton directory on one of the nodes.
				</div><div class="para">
					So services depending on the barrier will need to make sure they do minimal or no work inside their create() step, rather they should use start() to do the work.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The Barrier controls the start/stop of dependent services, but not their destruction, which happens only when the <code class="literal">BarrierController</code> is itself destroyed/undeployed. Thus using the <code class="literal">Barrier</code> to control services that need to be "destroyed" as part of their normal “undeploy” operation (like, for example, an <code class="literal">EJBContainer</code>) will not have the desired effect.
					</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776686389248">
      ⁠</a>27.1.2. Determining the master node</h2></div></div></div><div class="para">
				The various clustered singleton management strategies all depend on the fact that each node in the cluster can independently react to changes in cluster membership and correctly decide whether it is now the “master node”. How is this done?
			</div><div class="para">
				For each member of the cluster, the HAPartition service maintains an attribute called the CurrentView, which is basically an ordered list of the current members of the cluster. As nodes join and leave the cluster, JGroups ensures that each surviving member of the cluster gets an updated view. You can see the current view by going into the JMX console, and looking at the CurrentView attribute in the <code class="literal">jboss:service=DefaultPartition</code> mbean. Every member of the cluster will have the same view, with the members in the same order.
			</div><div class="para">
				Let us say, for example, that we have a 4 node cluster, nodes A through D, and the current view can be expressed as {A, B, C, D}. Generally speaking, the order of nodes in the view will reflect the order in which they joined the cluster (although this is not always the case, and should not be assumed to be the case).
			</div><div class="para">
				To further our example, let us say there is a singleton service (i.e. an <code class="literal">HASingletonController</code>) named Foo that's deployed around the cluster, except, for whatever reason, on B. The <code class="literal">HAPartition</code> service maintains across the cluster a registry of what services are deployed where, in view order. So, on every node in the cluster, the <code class="literal">HAPartition</code> service knows that the view with respect to the Foo service is {A, C, D} (no B).
			</div><div class="para">
				Whenever there is a change in the cluster topology of the Foo service, the <code class="literal">HAPartition</code> service invokes a callback on Foo notifying it of the new topology. So, for example, when Foo started on D, the Foo service running on A, C and D all got callbacks telling them the new view for Foo was {A, C, D}. That callback gives each node enough information to independently decide if it is now the master. The Foo service on each node uses the <code class="literal">HAPartition</code>'s <code class="literal">HASingletonElectionPolicy</code> to determine if they are the master, as explained in the <a class="xref" href="deployment.chapt.html#ha-singleton-election-policy">Section 27.1.2.1, “HA singleton election policy”</a>.
			</div><div class="para">
				If A were to fail or shutdown, Foo on C and D would get a callback with a new view for Foo of {C, D}. C would then become the master. If A restarted, A, C and D would get a callback with a new view for Foo of {C, D, A}. C would remain the master – there's nothing magic about A that would cause it to become the master again just because it was before.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ha-singleton-election-policy">
      ⁠</a>27.1.2.1. HA singleton election policy</h3></div></div></div><div class="para">
					The <code class="literal">HASingletonElectionPolicy</code> object is responsible for electing a master node from a list of available nodes, on behalf of an HA singleton, following a change in cluster topology.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">interface</span> HASingletonElectionPolicy
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>   ClusterNode <span xmlns="" class="perl_Function">elect</span>(List&lt;ClusterNode&gt; nodes);
<span xmlns="" class="line">​</span>}
</pre><div class="para">
					JBoss Enterprise Application Platform ships with two election policies:
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">HASingletonElectionPolicySimple</code> </span></dt><dd><div class="para">
								This policy selects a master node based relative age. The desired age is configured via the <code class="literal">position</code> property, which corresponds to the index in the list of available nodes. <code class="literal">position = 0</code>, the default, refers to the oldest node; <code class="literal">position = 1</code>, refers to the 2nd oldest; etc. <code class="literal">position</code> can also be negative to indicate youngness; imagine the list of available nodes as a circular linked list. <code class="literal">position = -1</code>, refers to the youngest node; <code class="literal">position = -2</code>, refers to the 2nd youngest node; etc.
							</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.singleton.HASingletonElectionPolicySimple"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"position"</span><span xmlns="" class="perl_Keyword">&gt;</span>-1<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
</pre></dd><dt><span class="term"> <code class="literal">PreferredMasterElectionPolicy</code> </span></dt><dd><div class="para">
								This policy extends <code class="literal">HASingletonElectionPolicySimple</code>, allowing the configuration of a preferred node. The <code class="literal">preferredMaster</code> property, specified as <span class="emphasis"><em>host:port</em></span> or <span class="emphasis"><em>address:port</em></span>, identifies a specific node that should become master, if available. If the preferred node is not available, the election policy will behave as described above.
							</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.singleton.PreferredMasterElectionPolicy"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"preferredMaster"</span><span xmlns="" class="perl_Keyword">&gt;</span>server1:12345<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
</pre></dd></dl></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-intro-farm">
      ⁠</a>27.2. Farming Deployment</h1></div></div></div><div class="para">
			The easiest way to deploy an application into the cluster is to use the farming service. Using the farming service, you can deploy an application (e.g. EAR, WAR, or SAR; either an archive file or in exploded form) to the <code class="literal">all/farm/</code> directory of any cluster member and the application will be automatically duplicate across all nodes in the same cluster. If a node joins the cluster later, it will pull in all farm deployed applications in the cluster and deploy them locally at start-up time. If you delete the application from a running clustered server node's <code class="literal">farm/</code> directory, the application will be undeployed locally and then removed from all other clustered server nodes' <code class="literal">farm/</code> directories (triggering undeployment).
		</div><div class="para">
			Farming is enabled by default in the <code class="literal">all</code> configuration in JBoss Enterprise Application Platform and thus requires no manual setup. The required <code class="filename">farm-deployment-jboss-beans.xml</code> and <code class="filename">timestamps-jboss-beans.xml</code> configuration files are located in the <code class="literal">deploy/cluster</code> directory. If you want to enable farming in a custom configuration, simply copy these files to the corresponding JBoss deploy directory <code class="literal"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/cluster</code>. Make sure that your custom configuration has clustering enabled.
		</div><div class="para">
			While there is little need to customize the farming service, it can be customized via the <code class="literal">FarmProfileRepositoryClusteringHandler</code> bean, whose properties and default values are listed below:
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"FarmProfileRepositoryClusteringHandler"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">      class=</span><span xmlns="" class="perl_String">"org.jboss.profileservice.cluster.repository.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">      DefaultRepositoryClusteringHandler"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"partition"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"profileDomain"</span><span xmlns="" class="perl_Keyword">&gt;</span>default<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"profileServer"</span><span xmlns="" class="perl_Keyword">&gt;</span>default<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"profileName"</span><span xmlns="" class="perl_Keyword">&gt;</span>farm<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"immutable"</span><span xmlns="" class="perl_Keyword">&gt;</span>false<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"lockTimeout"</span><span xmlns="" class="perl_Keyword">&gt;</span>60000<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span><span xmlns="" class="perl_Comment">&lt;!-- 1 minute --&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"methodCallTimeout"</span><span xmlns="" class="perl_Keyword">&gt;</span>60000<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span><span xmlns="" class="perl_Comment">&lt;!-- 1 minute --&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"synchronizationPolicy"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"FarmProfileSynchronizationPolicy"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
</pre><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>partition</strong></span> is a required attribute to inject the HAPartition service that the farm service uses for intra-cluster communication.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>profile[Domain|Server|Name]</strong></span> are all used to identify the server profile for which this handler is intended.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>immutable</strong></span> indicates whether or not this handler allows a node to push content changes to the cluster. A value of <code class="literal">true</code> is equivalent to setting <code class="literal">synchronizationPolicy</code> to <code class="literal">org.jboss.system.server.profileservice.repository.clustered.sync.</code> <code class="literal">ImmutableSynchronizationPolicy</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>lockTimeout</strong></span> defines the number of milliseconds to wait for cluster-wide lock acquisition.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>methodCallTimeout</strong></span> defines the number of milliseconds to wait for invocations on remote cluster nodes.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>synchronizationPolicy</strong></span> decides how to handle content additions, reincarnations, updates, or removals from nodes attempting to join the cluster or from cluster merges. The policy is consulted on the "authoritative" node, i.e. the master node for the service on the cluster. <span class="emphasis"><em>Reincarnation</em></span> refers to the phenomenon where a newly started node may contain an application in its <code class="literal">farm/</code> directory that was previously removed by the farming service but might still exist on the starting node if it was not running when the removal took place. The default synchronization policy is defined as follows:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"FarmProfileSynchronizationPolicy"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">      class=</span><span xmlns="" class="perl_String">"org.jboss.profileservice.cluster.repository.</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">      DefaultSynchronizationPolicy"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowJoinAdditions"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowJoinReincarnations"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowJoinUpdates"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowJoinRemovals"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowMergeAdditions"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowMergeReincarnations"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowMergeUpdates"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"allowMergeRemovals"</span><span xmlns="" class="perl_Keyword">&gt;&lt;null/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"developerMode"</span><span xmlns="" class="perl_Keyword">&gt;</span>false<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"removalTrackingTime"</span><span xmlns="" class="perl_Keyword">&gt;</span>2592000000<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span><span xmlns="" class="perl_Comment">&lt;!-- 30 days --&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"timestampService"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"TimestampDiscrepancyService"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>allow[Join|Merge][Additions|Reincarnations|Updates|Removals]</strong></span> define fixed responses to requests to allow additions, reincarnations, updates, or removals from joined or merged nodes.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>developerMode</strong></span> enables a lenient synchronization policy that allows all changes. Enabling developer mode is equivalent to setting each of the above properties to <code class="literal">true</code> and is intended for development environments.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>removalTrackingTime</strong></span> defines the number of milliseconds for which this policy should remembered removed items, for use in detecting reincarnations.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timestampService</strong></span> estimates and tracks discrepancies in system clocks for current and past members of the cluster. Default implementation is defined in <code class="filename">timestamps-jboss-beans.xml</code>.
						</div></li></ul></div></li></ul></div></div></div></body></html>