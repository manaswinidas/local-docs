<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 19. Introduction and Quick Start</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-intro.chapt">
      ⁠</a>Chapter 19. Introduction and Quick Start</h1></div></div></div><div class="para">
		Clustering allows you to run an application on several parallel servers (a.k.a cluster nodes) while providing a single view to application clients. Load is distributed across different servers, and even if one or more of the servers fails, the application is still accessible via the surviving cluster nodes. Clustering is crucial for scalable enterprise applications, as you can improve performance by adding more nodes to the cluster. Clustering is crucial for highly available enterprise applications, as it is the clustering infrastructure that supports the redundancy needed for high availability.
	</div><div class="para">
		The JBoss Enterprise Application Platform comes with clustering support out of the box, as part of the <code class="literal">production</code> server profile. The <code class="literal">production</code> server profile includes support for the following: 
		<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					A scalable, fault-tolerant JNDI implementation (HA-JNDI).
				</div></li><li class="listitem"><div class="para">
					Web tier clustering, including:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							High availability for web session state via state replication.
						</div></li></ul></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Ability to integrate with hardware and software load balancers, including special integration with mod_jk and other JK-based software load balancers.
						</div></li></ul></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Single Sign-on support across a cluster.
						</div></li></ul></div></li><li class="listitem"><div class="para">
					EJB session bean clustering, for both stateful and stateless beans, and for both EJB3 and EJB2.
				</div></li><li class="listitem"><div class="para">
					A distributed cache for JPA/Hibernate entities.
				</div></li><li class="listitem"><div class="para">
					A framework for keeping local EJB2 entity caches consistent across a cluster by invalidating cache entries across the cluster when a bean is changed on any node.
				</div></li><li class="listitem"><div class="para">
					Distributed JMS queues and topics via JBoss Messaging.
				</div></li><li class="listitem"><div class="para">
					Deploying a service or application on multiple nodes in the cluster but having it active on only one (but at least one) node is called a <span class="emphasis"><em>HA Singleton</em></span>.
				</div></li><li class="listitem"><div class="para">
					Keeping deployed content in sync on all nodes in the cluster via the <code class="literal">Farm</code> service.
				</div></li></ul></div>

	</div><div class="para">
		In this <span class="emphasis"><em>Clustering Guide</em></span> we aim to provide you with an in depth understanding of how to use JBoss Enterprise Application Platform's clustering features. In this first part of the guide, the goal is to provide some basic "Quick Start" steps to encourage you to start experimenting with JBoss Enterprise Application Platform Clustering, and then to provide some background information that will allow you to understand how JBoss Enterprise Application Platform Clustering works. The next part of the guide then explains in detail how to use these features to cluster your JEE services. Finally, we provide some more details about advanced configuration of JGroups and JBoss Cache, the core technologies that underlie JBoss Enterprise Application Platform Clustering.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-quickstart">
      ⁠</a>19.1. Quick Start Guide</h1></div></div></div><div class="para">
			The goal of this section is to give you the minimum information needed to let you get started experimenting with JBoss Enterprise Application Platform Clustering. Most of the areas touched on in this section are covered in much greater detail later in this guide.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-quickstart-setup">
      ⁠</a>19.1.1. Initial Preparation</h2></div></div></div><div class="para">
				Preparing a set of servers to act as a JBoss Enterprise Application Platform cluster involves a few simple steps:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Install JBoss Enterprise Application Platform on all your servers.</strong></span> In its simplest form, this is just a matter of unzipping the JBoss download onto the file system on each server. 
					</div><div class="para">
						If you want to run multiple JBoss Enterprise Application Platform instances on a single server, you can either install the full JBoss distribution onto multiple locations on your file system, or you can simply make copies of the <code class="literal">production</code> server profile. For example, assuming the root of the JBoss distribution was unzipped to <code class="literal">/var/jboss</code>, you would:
					</div><pre class="programlisting">
$ cd /var/jboss/server
$ cp -r production node1
$ cp -r production node2</pre></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>For each node, determine the address to bind sockets to.</strong></span> When you start JBoss, whether clustered or not, you need to tell JBoss on what address its sockets should listen for traffic. (The default is <code class="literal">localhost</code> which is secure but is not very useful, particularly in a cluster.) So, you need to decide what those addresses will be.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Ensure multicast is working.</strong></span> By default JBoss Enterprise Application Platform uses UDP multicast for most intra-cluster communications. Make sure each server's networking configuration supports multicast and that multicast support is enabled for any switches or routers between your servers. If you are planning to run more than one node on a server, make sure the server's routing table includes a multicast route. See the JGroups documentation at <a href="http://www.jgroups.org">http://www.jgroups.org</a> for more on this general area, including information on how to use JGroups' diagnostic tools to confirm that multicast is working.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							JBoss Enterprise Application Platform clustering does not require the use of UDP multicast; the Enterprise Application Platform can also be reconfigured to use TCP unicast for intra-cluster communication.
						</div></div></div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Determine a unique integer "ServerPeerID" for each node.</strong></span> This is needed for JBoss Messaging clustering, and can be skipped if you will not be running JBoss Messaging (that is, you will remove JBM from the server profile's <code class="literal">deploy</code> directory). JBM requires that each node in a cluster has a unique integer ID, known as a "ServerPeerID", that should remain consistent across server restarts.
					</div><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
							A simple 1, 2, 3, ..., x naming scheme is acceptable, however the value must be between the range <code class="literal">0</code> to <code class="literal">1023</code>. Values outside this range will result in a <span class="errorcode">java.lang.IllegalArgumentException</span> with the ServerPeer start Service.
						</div></div></div><div class="para">
						We will cover how to use the ServerPeerID in <a class="xref" href="clustering-intro.chapt.html#clustering-quickstart-launching">Section 19.1.2, “Launching a JBoss Enterprise Application Platform Cluster”</a>.
					</div></li></ul></div><div class="para">
				Beyond the above required steps, the following two optional steps are recommended to help ensure that your cluster is properly isolated from other JBoss Enterprise Application Platform clusters that may be running on your network:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Pick a unique name for your cluster.</strong></span> The default name for a JBoss Enterprise Application Platform cluster is "DefaultPartition". Come up with a different name for each cluster in your environment, e.g. "QAPartition" or "BobsDevPartition". The use of "Partition" is not required; it's just a semi-convention. As a small aid to performance try to keep the name short, as it gets included in every message sent around the cluster. We will cover how to use the name you pick in the next section.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Pick a unique multicast address for your cluster.</strong></span> By default JBoss Enterprise Application Platform uses UDP multicast for most intra-cluster communication. Pick a different multicast address for each cluster you run. Generally a good multicast address is of the form <code class="literal">239.255.x.y</code>. We will cover how to use the address you pick in the next section.
					</div></li></ul></div><div class="para">
				See <a class="xref" href="jgroups.chapt.html#clustering-jgroups-isolation">Section 28.6.2, “Isolating JGroups Channels”</a> for more on isolating clusters.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-quickstart-launching">
      ⁠</a>19.1.2. Launching a JBoss Enterprise Application Platform Cluster</h2></div></div></div><div class="para">
				The simplest way to start a server cluster is to start several JBoss instances on the same local network, using the <code class="literal">-c production</code> command line option for each instance. Those server instances will detect each other and automatically form a cluster.
			</div><div class="para">
				Let us look at a few different scenarios for doing this. In each scenario we will be creating a two node cluster, where the ServerPeerID for the first node is <code class="literal">1</code> and for the second node is <code class="literal">2</code>. We've decided to call our cluster "DocsPartition" and to use <code class="literal">239.255.100.100</code> as our multicast address. These scenarios are meant to be illustrative; the use of a two node cluster should not be taken to mean that is the best size for a cluster; it's just that's the simplest way to do the examples.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 1: Nodes on Separate Machines</strong></span>
					</div><div class="para">
						This is the most common production scenario. Assume the machines are named "node1" and "node2", while node1 has an IP address of <code class="literal">192.168.0.101</code> and node2 has an address of <code class="literal">192.168.0.102</code>. Assume the "ServerPeerID" for node1 is <code class="literal">1</code> and for node2 it's <code class="literal">2</code>. Assume on each machine JBoss is installed in <code class="literal">/var/jboss</code>.
					</div><div class="para">
						On node1, to launch JBoss:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c production -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1</pre><div class="para">
						On node2, it's the same except for a different <code class="literal">-b</code> value and ServerPeerID:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c production -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.102 -Djboss.messaging.ServerPeerID=2</pre><div class="para">
						The <code class="literal">-c</code> switch says to use the <code class="literal">production</code> config, which includes clustering support. The <code class="literal">-g</code> switch sets the cluster name. The <code class="literal">-u</code> switch sets the multicast address that will be used for intra-cluster communication. The <code class="literal">-b</code> switch sets the address on which sockets will be bound. The <code class="literal">-D</code> switch sets system property <code class="literal">jboss.messaging.ServerPeerID</code>, from which JBoss Messaging gets its unique id.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 2: Two Nodes on a Single, Multihomed, Server</strong></span>
					</div><div class="para">
						Running multiple nodes on the same machine is a common scenario in a development environment, and is also used in production in combination with Scenario 1. (Running <span class="emphasis"><em>all</em></span> the nodes in a production cluster on a single machine is generally not recommended, since the machine itself becomes a single point of failure.) In this version of the scenario, the machine is multihomed, i.e. has more than one IP address. This allows the binding of each JBoss instance to a different address, preventing port conflicts when the nodes open sockets.
					</div><div class="para">
						Assume the single machine has the <code class="literal">192.168.0.101</code> and <code class="literal">192.168.0.102</code> addresses assigned, and that the two JBoss instances use the same addresses and ServerPeerIDs as in Scenario 1. The difference from Scenario 1 is we need to be sure each Enterprise Application Platform instance has its own work area. So, instead of using the <code class="literal">production</code> config, we are going to use the <code class="literal">node1</code> and <code class="literal">node2</code> configs we copied from <code class="literal">production</code> earlier in the previous section.
					</div><div class="para">
						To launch the first instance, open a console window and:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node1 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1</pre><div class="para">
						For the second instance, it's the same except for different <span class="emphasis"><em>-b</em></span> and <span class="emphasis"><em>-c</em></span> values and a different ServerPeerID:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node2 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.102 -Djboss.messaging.ServerPeerID=2</pre></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 3: Two Nodes on a Single, Non-Multihomed, Server</strong></span>
					</div><div class="para">
						This is similar to Scenario 2, but here the machine only has one IP address available. Two processes can not bind sockets to the same address and port, so we will have to tell JBoss to use different ports for the two instances. This can be done by configuring the ServiceBindingManager service by setting the <code class="literal">jboss.service.binding.set</code> system property.
					</div><div class="para">
						To launch the first instance, open a console window and:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node1 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1 \
    -Djboss.service.binding.set=ports-default</pre><div class="para">
						For the second instance:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node2 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=2 \
    -Djboss.service.binding.set=ports-01</pre><div class="para">
						This tells the ServiceBindingManager on the first node to use the standard set of ports (e.g. JNDI on 1099). The second node uses the "ports-01" binding set, which by default for each port has an offset of 100 from the standard port number (e.g. JNDI on 1199). See the <code class="literal">conf/bindingservice.beans/META-INF/bindings-jboss-beans.xml</code> file for the full ServiceBindingManager configuration.
					</div><div class="para">
						Note that this setup is not advised for production use, due to the increased management complexity that comes with using different ports. But it is a fairly common scenario in development environments where developers want to use clustering but cannot multihome their workstations.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Including <code class="literal">-Djboss.service.binding.set=ports-default</code> on the command line for node1 is not technically necessary, since <code class="literal">ports-default</code> is the default value. But using a consistent set of command line arguments across all servers is helpful to people less familiar with all the details.
						</div></div></div></li></ul></div><div class="para">
				That's it; that's all it takes to get a cluster of JBoss Enterprise Application Platform servers up and running.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-quickstart-http">
      ⁠</a>19.1.3. Web Application Clustering Quick Start</h2></div></div></div><div class="para">
				JBoss Enterprise Application Platform supports clustered web sessions, where a backup copy of each user's <code class="literal">HttpSession</code> state is stored on one or more nodes in the cluster. In case the primary node handling the session fails or is shut down, any other node in the cluster can handle subsequent requests for the session by accessing the backup copy. Web tier clustering is discussed in detail in the <em class="citetitle">HTTP Connectors Load Balancing Guide</em>.
			</div><div class="para">
				There are two aspects to setting up web tier clustering: 
				<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Configuring an External Load Balancer</strong></span>. Web applications require an external load balancer to balance HTTP requests across the cluster of JBoss Enterprise Application Platform instances (see <a class="xref" href="cluster.concepts.chapt.html#clustering-concepts-arch-balancer">Section 20.2.2, “External Load Balancer Architecture”</a> for more on why that is). JBoss Enterprise Application Platform itself does not act as an HTTP load balancer. So, you will need to set up a hardware or software load balancer. There are many possible load balancer choices, so how to configure one is really beyond the scope of a Quick Start. Refer to the <em class="citetitle">HTTP Connectors Load Balancing Guide</em> for details on how to set up the popular mod_jk software load balancer.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Configuring Your Web Application for Clustering</strong></span>. This aspect involves telling JBoss you want clustering behavior for a particular web app, and it could not be simpler. Just add an empty <code class="literal">distributable</code> element to your application's <code class="literal">web.xml</code> file:
						</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;?xml</span> version="1.0"<span xmlns="" class="perl_Keyword">?&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;web-app</span><span xmlns="" class="perl_Others">  xmlns=</span><span xmlns="" class="perl_String">"http://java.sun.com/xml/ns/javaee"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">          xmlns:xsi=</span><span xmlns="" class="perl_String">"http://www.w3.org/2001/XMLSchema-instance"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">          xsi:schemaLocation=</span><span xmlns="" class="perl_String">"http://java.sun.com/xml/ns/javaee </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">                              http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">          version=</span><span xmlns="" class="perl_String">"2.5"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>          
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;distributable/&gt;</span>
<span xmlns="" class="line">​</span>    
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/web-app&gt;</span></pre><div class="para">
							Simply doing that is enough to get the default JBoss Enterprise Application Platform web session clustering behavior, which is appropriate for most applications. Refer to the <em class="citetitle">HTTP Connectors Load Balancing Guide</em> for more advanced configuration options.
						</div></li></ul></div>

			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-quickstart-ejbsessions">
      ⁠</a>19.1.4. EJB Session Bean Clustering Quick Start</h2></div></div></div><div class="para">
				JBoss Enterprise Application Platform supports clustered EJB session beans, whereby requests for a bean are balanced across the cluster. For stateful beans a backup copy of bean state is maintained on one or more cluster nodes, providing high availability in case the node handling a particular session fails or is shut down. Clustering of both EJB2 and EJB3 beans is supported.
			</div><div class="para">
				For EJB3 session beans, simply add the <code class="literal">org.jboss.ejb3.annotation.Clustered</code> annotation to the bean class for your stateful or stateless bean:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>@javax.<span xmlns="" class="perl_Function">ejb</span>.<span xmlns="" class="perl_Function">Stateless</span>
<span xmlns="" class="line">​</span>@org.<span xmlns="" class="perl_Function">jboss</span>.<span xmlns="" class="perl_Function">ejb3</span>.<span xmlns="" class="perl_Function">annotation</span>.<span xmlns="" class="perl_Function">Clustered</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MyBean <span xmlns="" class="perl_Keyword">implements</span> MySessionInt {
<span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">test</span>() {
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">// Do something cool</span>
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}</pre><div class="para">
				For EJB2 session beans, or for EJB3 beans where you prefer XML configuration over annotations, simply add a <code class="literal">clustered</code> element to the bean's section in the JBoss-specific deployment descriptor, <code class="literal">jboss.xml</code>:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;jboss&gt;</span>    
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;enterprise-beans&gt;</span>      
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;session&gt;</span>        
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;ejb-name&gt;</span>example.StatelessSession<span xmlns="" class="perl_Keyword">&lt;/ejb-name&gt;</span>        
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;jndi-name&gt;</span>example.StatelessSession<span xmlns="" class="perl_Keyword">&lt;/jndi-name&gt;</span>        
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;clustered&gt;</span>true<span xmlns="" class="perl_Keyword">&lt;/clustered&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;/session&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/enterprise-beans&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/jboss&gt;</span></pre><div class="para">
				See <a class="xref" href="clustering-session.html">Chapter 23, <em>Clustered Session EJBs</em></a> for more advanced configuration options.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-quickstart-ejb3entities">
      ⁠</a>19.1.5. Entity Clustering Quick Start</h2></div></div></div><div class="para">
				One of the big improvements in the clustering area in JBoss Enterprise Application Platform 5 is the use of the new Hibernate/JBoss Cache integration for second level entity caching that was introduced in Hibernate 3.3. In the JPA/Hibernate context, a second level cache refers to a cache whose contents are retained beyond the scope of a transaction. A second level cache <span class="emphasis"><em>may</em></span> improve performance by reducing the number of database reads. You should always load test your application with second level caching enabled and disabled to see whether it has a beneficial impact on your particular application.
			</div><div class="para">
				If you use more than one JBoss Enterprise Application Platform instance to run your JPA/Hibernate application and you use second level caching, you must use a cluster-aware cache. Otherwise a cache on server A will still hold out-of-date data after activity on server B updates some entities.
			</div><div class="para">
				JBoss Enterprise Application Platform provides a cluster-aware second level cache based on JBoss Cache. To tell JBoss Enterprise Application Platform's standard Hibernate-based JPA provider to enable second level caching with JBoss Cache, configure your <code class="literal">persistence.xml</code> as follows:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;?xml</span> version="1.0" encoding="UTF-8"<span xmlns="" class="perl_Keyword">?&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;persistence</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"http://java.sun.com/xml/ns/persistence"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xmlns:xsi=</span><span xmlns="" class="perl_String">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xsi:schemaLocation=</span><span xmlns="" class="perl_String">"http://java.sun.com/xml/ns/persistence</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">   http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   version=</span><span xmlns="" class="perl_String">"1.0"</span><span xmlns="" class="perl_Keyword">&gt;</span> 
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;persistence-unit</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"somename"</span><span xmlns="" class="perl_Others"> transaction-type=</span><span xmlns="" class="perl_String">"JTA"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;jta-data-source&gt;</span>java:/SomeDS<span xmlns="" class="perl_Keyword">&lt;/jta-data-source&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;properties&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"hibernate.cache.use_second_level_cache"</span><span xmlns="" class="perl_Others"> value=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"hibernate.cache.region.factory_class"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   value=</span><span xmlns="" class="perl_String">"org.hibernate.cache.jbc2.JndiMultiplexedJBossCacheRegionFactory"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"hibernate.cache.region.jbc2.cachefactory"</span><span xmlns="" class="perl_Others"> value=</span><span xmlns="" class="perl_String">"java:CacheManager"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Comment">&lt;!-- Other configuration options ... --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/properties&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/persistence-unit&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/persistence&gt;</span></pre><div class="para">
				That tells Hibernate to use the JBoss Cache-based second level cache, but it does not tell it what entities to cache. That can be done by adding the <code class="literal">org.hibernate.annotations.Cache</code> annotation to your entity class:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>package org.example.entities;
<span xmlns="" class="line">​</span> 
<span xmlns="" class="line">​</span>import java.io.Serializable;
<span xmlns="" class="line">​</span>import javax.persistence.Entity;
<span xmlns="" class="line">​</span>import org.hibernate.annotations.Cache;
<span xmlns="" class="line">​</span>import org.hibernate.annotations.CacheConcurrencyStrategy;
<span xmlns="" class="line">​</span> 
<span xmlns="" class="line">​</span>@Entity
<span xmlns="" class="line">​</span>@Cache(usage=CacheConcurrencyStrategy.TRANSACTIONAL)
<span xmlns="" class="line">​</span>public class Account implements Serializable {</pre><div class="para">
				See <a class="xref" href="clustering-entity.html">Chapter 24, <em>Clustered Entity EJBs</em></a> for more advanced configuration options and details on how to configure the same thing for a non-JPA Hibernate application.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Clustering can add significant overhead to a JPA/Hibernate second level cache, so do not assume that just because second level caching adds a benefit to a non-clustered application that it will be beneficial to a clustered application. Even if clustered second level caching is beneficial overall, caching of more frequently modified entity types may be beneficial in a non-clustered scenario but not in a clustered one. <span class="emphasis"><em>Always</em></span> load test your application.
				</div></div></div></div></div></div></body></html>