<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 22. Clustered JNDI Services</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-jndi">
      ⁠</a>Chapter 22. Clustered JNDI Services</h1></div></div></div><div class="para">
		JNDI is one of the most important services provided by the application server. The JBoss HA-JNDI (High Availability JNDI) service brings the following features to JNDI:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				Transparent failover of naming operations. If an HA-JNDI naming Context is connected to the HA-JNDI service on a particular JBoss Enterprise Application Platform instance, and that service fails or is shut down, the HA-JNDI client can transparently fail over to another Enterprise Application Platform instance.
			</div></li><li class="listitem"><div class="para">
				Load balancing of naming operations. A HA-JNDI naming Context will automatically load balance its requests across all the HA-JNDI servers in the cluster.
			</div></li><li class="listitem"><div class="para">
				Automatic client discovery of HA-JNDI servers (using multicast).
			</div></li><li class="listitem"><div class="para">
				Unified view of JNDI trees cluster-wide. A client can connect to the HA-JNDI service running on any node in the cluster and find objects bound in JNDI on any other node. This is accomplished via two mechanisms: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Cross-cluster lookups. A client can perform a lookup and the server side HA-JNDI service has the ability to find things bound in regular JNDI on any node in the cluster.
						</div></li><li class="listitem"><div class="para">
							A replicated cluster-wide context tree. An object bound into the HA-JNDI service will be replicated around the cluster, and a copy of that object will be available in-VM on each node in the cluster.
						</div></li></ul></div>

			</div></li></ul></div><div class="para">
		JNDI is a key component for many other interceptor-based clustering services: those services register themselves with JNDI so the client can look up their proxies and make use of their services. HA-JNDI completes the picture by ensuring that clients have a highly-available means to look up those proxies. However, it is important to understand that using HA-JNDI (or not) has no effect whatsoever on the clustering behavior of the objects that are looked up. To illustrate:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				If an EJB is not configured as clustered, looking up the EJB via HA-JNDI does not somehow result in the addition of clustering capabilities (load balancing of EJB calls, transparent failover, state replication) to the EJB.
			</div></li><li class="listitem"><div class="para">
				If an EJB is configured as clustered, looking up the EJB via regular JNDI instead of HA-JNDI does not somehow result in the removal of the bean proxy's clustering capabilities.
			</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-jndi-how">
      ⁠</a>22.1. How it works</h1></div></div></div><div class="para">
			The JBoss client-side HA-JNDI naming Context is based on the client-side interceptor architecture (see  the Introduction and Quick Start chapter). The client obtains an HA-JNDI proxy object (via the <code class="literal">InitialContext</code> object) and invokes JNDI lookup services on the remote server through the proxy. The client specifies that it wants an HA-JNDI proxy by configuring the naming properties used by the <code class="literal">InitialContext</code> object. This is covered in detail in <a class="xref" href="clustering-jndi.html#clustering-jndi-client">Section 22.2, “Client configuration”</a>. Other than the need to ensure the appropriate naming properties are provided to the <code class="literal">InitialContext</code>, the fact that the naming Context is using HA-JNDI is completely transparent to the client.
		</div><div class="para">
			On the server side, the HA-JNDI service maintains a cluster-wide context tree. The cluster wide tree is always available as long as there is one node left in the cluster. Each node in the cluster also maintains its own local JNDI context tree. The HA-JNDI service on each node is able to find objects bound into the local JNDI context tree, and is also able to make a cluster-wide RPC to find objects bound in the local tree on any other node. An application can bind its objects to either tree, although in practice most objects are bound into the local JNDI context tree. The design rationale for this architecture is as follows:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					It avoids migration issues with applications that assume that their JNDI implementation is local. This allows clustering to work out-of-the-box with just a few tweaks of configuration files.
				</div></li><li class="listitem"><div class="para">
					In a homogeneous cluster, this configuration actually cuts down on the amount of network traffic. A homogeneous cluster is one where the same types of objects are bound under the same names on each node.
				</div></li><li class="listitem"><div class="para">
					Designing it in this way makes the HA-JNDI service an optional service since all underlying cluster code uses a straight new <code class="literal">InitialContext</code> to lookup or create bindings.
				</div></li></ul></div><div class="para">
			On the server side, a naming Context obtained via a call to <code class="literal">new InitialContext()</code> will be bound to the local-only, non-cluster-wide JNDI Context. So, all EJB homes and such will not be bound to the cluster-wide JNDI Context, but rather, each home will be bound into the local JNDI.
		</div><div class="para">
			When a remote client does a lookup through HA-JNDI, HA-JNDI will delegate to the local JNDI service when it cannot find the object within the global cluster-wide Context. The detailed lookup rule is as follows.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					If the binding is available in the cluster-wide JNDI tree, return it.
				</div></li><li class="listitem"><div class="para">
					If the binding is not in the cluster-wide tree, delegate the lookup query to the local JNDI service and return the received answer if available.
				</div></li><li class="listitem"><div class="para">
					If not available, the HA-JNDI service asks all other nodes in the cluster if their local JNDI service owns such a binding and returns the answer from the set it receives.
				</div></li><li class="listitem"><div class="para">
					If no local JNDI service owns such a binding, a <code class="literal">NameNotFoundException</code> is finally raised.
				</div></li></ul></div><div class="para">
			In practice, objects are rarely bound in the cluster-wide JNDI tree; rather they are bound in the local JNDI tree. For example, when EJBs are deployed, their proxies are always bound in local JNDI, not HA-JNDI. So, an EJB home lookup done through HA-JNDI will always be delegated to the local JNDI instance.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If different beans (even of the same type, but participating in different clusters) use the same JNDI name, this means that each JNDI server will have a logically different "target" bound under the same name (JNDI on node 1 will have a binding for bean A and JNDI on node 2 will have a binding, under the same name, for bean B). Consequently, if a client performs a HA-JNDI query for this name, the query will be invoked on any JNDI server of the cluster and will return the locally bound stub. Nevertheless, it may not be the correct stub that the client is expecting to receive! So, it is always best practice to ensure that across the cluster different names are used for logically different bindings.
			</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If a binding is only made available on a few nodes in the cluster (for example because a bean is only deployed on a small subset of nodes in the cluster), the probability is higher that a lookup will hit a HA-JNDI server that does not own this binding and thus the lookup will need to be forwarded to all nodes in the cluster. Consequently, the query time will be longer than if the binding would have been available locally. Moral of the story: as much as possible, cache the result of your JNDI queries in your client.
			</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				You cannot currently use a non-JNP JNDI implementation (i.e. LDAP) for your local JNDI implementation if you want to use HA-JNDI. However, you can use JNDI federation using the <code class="literal">ExternalContext</code> MBean to bind non-JBoss JNDI trees into the JBoss JNDI namespace. Furthermore, nothing prevents you using one centralized JNDI server for your whole cluster and scrapping HA-JNDI and JNP.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-jndi-client">
      ⁠</a>22.2. Client configuration</h1></div></div></div><div class="para">
			Configuring a client to use HA-JNDI is a matter of ensuring the correct set of naming environment properties are available when a new <code class="literal">InitialContext</code> is created. How this is done varies depending on whether the client is running inside JBoss Enterprise Application Platform itself or is in another VM.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776679436512">
      ⁠</a>22.2.1. For clients running inside the Enterprise Application Platform</h2></div></div></div><div class="para">
				If you want to access HA-JNDI from inside the Enterprise Application Platform, you must explicitly configure your <code class="literal">InitialContext</code> by passing in JNDI properties to the constructor. The following code shows how to create a naming Context bound to HA-JNDI:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>Properties p = <span xmlns="" class="perl_Keyword">new</span> Properties();  
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(Context.<span xmlns="" class="perl_Function">INITIAL_CONTEXT_FACTORY</span>, <span xmlns="" class="perl_String">"org.jnp.interfaces.NamingContextFactory"</span>);  
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(Context.<span xmlns="" class="perl_Function">URL_PKG_PREFIXES</span>, <span xmlns="" class="perl_String">"jboss.naming:org.jnp.interfaces"</span>);
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">// HA-JNDI is listening on the address passed to JBoss via -b  </span>
<span xmlns="" class="line">​</span>String bindAddress = System.<span xmlns="" class="perl_Function">getProperty</span>(<span xmlns="" class="perl_String">"jboss.bind.address"</span>, <span xmlns="" class="perl_String">"localhost"</span>);
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(Context.<span xmlns="" class="perl_Function">PROVIDER_URL</span>, bindAddress + <span xmlns="" class="perl_String">":1100"</span>); <span xmlns="" class="perl_Comment">// HA-JNDI address and port.  </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> InitialContext(p);</pre><div class="para">
				The Context.PROVIDER_URL property points to the HA-JNDI service configured in the <code class="literal">deploy/cluster/hajndi-jboss-beans.xml</code> file (see <a class="xref" href="clustering-jndi.html#clustering-jndi-jboss">Section 22.3, “JBoss configuration”</a>). By default this service listens on the interface named via the <code class="literal">jboss.bind.address</code> system property, which itself is set to whatever value you assign to the <code class="literal">-b</code> command line option when you start JBoss Enterprise Application Platform (or <code class="literal">localhost</code> if not specified). The above code shows an example of accessing this property.
			</div><div class="para">
				However, this does not work in all cases, especially when running several JBoss Enterprise Application Platform instances on the same machine and bound to the same IP address, but configured to use different ports. A safer method is to not specify the Context.PROVIDER_URL but instead allow the <code class="literal">InitialContext</code> to statically find the in-VM HA-JNDI by specifying the <code class="literal">jnp.partitionName</code> property:
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>Properties p = <span xmlns="" class="perl_Keyword">new</span> Properties();
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(Context.<span xmlns="" class="perl_Function">INITIAL_CONTEXT_FACTORY</span>, <span xmlns="" class="perl_String">"org.jnp.interfaces.NamingContextFactory"</span>);
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(Context.<span xmlns="" class="perl_Function">URL_PKG_PREFIXES</span>, <span xmlns="" class="perl_String">"jboss.naming:org.jnp.interfaces"</span>);
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">// HA-JNDI is registered under the partition name passed to JBoss via -g  </span>
<span xmlns="" class="line">​</span>String partitionName = System.<span xmlns="" class="perl_Function">getProperty</span>(<span xmlns="" class="perl_String">"jboss.partition.name"</span>, <span xmlns="" class="perl_String">"DefaultPartition"</span>);
<span xmlns="" class="line">​</span>p.<span xmlns="" class="perl_Function">put</span>(<span xmlns="" class="perl_String">"jnp.partitionName"</span>, partitionName);
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> InitialContext(p);</pre><div class="para">
				This example uses the <code class="literal">jboss.partition.name</code> system property to identify the partition with which the HA-JNDI service works. This system property is set to whatever value you assign to the <code class="literal">-g</code> command line option when you start JBoss Enterprise Application Platform (or <code class="literal">DefaultPartition</code> if not specified).
			</div><div class="para">
				Do not attempt to simplify things by placing a <code class="literal">jndi.properties</code> file in your deployment or by editing the Enterprise Application Platform's <code class="literal">conf/jndi.properties</code> file. Doing either will almost certainly break things for your application and quite possibly across the server. If you want to externalize your client configuration, one approach is to deploy a properties file not named <code class="literal">jndi.properties</code>, and then programatically create a <code class="literal">Properties</code> object that loads that file's contents.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776761502880">
      ⁠</a>22.2.1.1. Accessing HA-JNDI Resources from EJBs and WARs -- Environment Naming Context</h3></div></div></div><div class="para">
					If your HA-JNDI client is an EJB or servlet, the least intrusive way to configure the lookup of resources is to bind the resources to the environment naming context of the bean or webapp performing the lookup. The binding can then be configured to use HA-JNDI instead of a local mapping. Following is an example of doing this for a JMS connection factory and queue (the most common use case for this kind of thing).
				</div><div class="para">
					Within the bean definition in the ejb-jar.xml or in the war's web.xml you will need to define two resource-ref mappings, one for the connection factory and one for the destination.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resource-ref&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-ref-name&gt;</span>jms/ConnectionFactory<span xmlns="" class="perl_Keyword">&lt;/res-ref-name&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-type&gt;</span>javax.jms.QueueConnectionFactory<span xmlns="" class="perl_Keyword">&lt;/res-type&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-auth&gt;</span>Container<span xmlns="" class="perl_Keyword">&lt;/res-auth&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/resource-ref&gt;</span>
<span xmlns="" class="line">​</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resource-ref&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-ref-name&gt;</span>jms/Queue<span xmlns="" class="perl_Keyword">&lt;/res-ref-name&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-type&gt;</span>javax.jms.Queue<span xmlns="" class="perl_Keyword">&lt;/res-type&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-auth&gt;</span>Container<span xmlns="" class="perl_Keyword">&lt;/res-auth&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/resource-ref&gt;</span></pre><div class="para">
					Using these examples the bean performing the lookup can obtain the connection factory by looking up 'java:comp/env/jms/ConnectionFactory' and can obtain the queue by looking up 'java:comp/env/jms/Queue'.
				</div><div class="para">
					Within the JBoss-specific deployment descriptor (jboss.xml for EJBs, jboss-web.xml for a WAR) these references need to be mapped to a URL that makes use of HA-JNDI.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resource-ref&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-ref-name&gt;</span>jms/ConnectionFactory<span xmlns="" class="perl_Keyword">&lt;/res-ref-name&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;jndi-name&gt;</span>jnp://${jboss.bind.address}:1100/ConnectionFactory<span xmlns="" class="perl_Keyword">&lt;/jndi-name&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/resource-ref&gt;</span>
<span xmlns="" class="line">​</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resource-ref&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;res-ref-name&gt;</span>jms/Queue<span xmlns="" class="perl_Keyword">&lt;/res-ref-name&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;jndi-name&gt;</span>jnp://${jboss.bind.address}:1100/queue/A<span xmlns="" class="perl_Keyword">&lt;/jndi-name&gt;</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;/resource-ref&gt;</span></pre><div class="para">
					The URL should be the URL to the HA-JNDI server running on the same node as the bean; if the bean is available the local HA-JNDI server should also be available. The lookup will then automatically query all of the nodes in the cluster to identify which node has the JMS resources available.
				</div><div class="para">
					The <code class="literal">${jboss.bind.address}</code> syntax used above tells JBoss to use the value of the <code class="literal">jboss.bind.address</code> system property when determining the URL. That system property is itself set to whatever value you assign to the <code class="literal">-b</code> command line option when you start JBoss Enterprise Application Platform.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776755661824">
      ⁠</a>22.2.1.2. Why do this programmatically and not just put this in a jndi.properties file?</h3></div></div></div><div class="para">
					The JBoss Enterprise Application Platform's internal naming environment is controlled by the <code class="filename">conf/jndi.properties</code> file, which should not be edited.
				</div><div class="para">
					No other jndi.properties file should be deployed inside the Enterprise Application Platform because of the possibility of its being found on the classpath when it should not and thus disrupting the internal operation of the server. For example, if an EJB deployment included a jndi.properties configured for HA-JNDI, when the server binds the EJB proxies into JNDI it will likely bind them into the replicated HA-JNDI tree and not into the local JNDI tree where they belong.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776755659056">
      ⁠</a>22.2.1.3. How can I tell if things are being bound into HA-JNDI that should not be?</h3></div></div></div><div class="para">
					Go into the jmx-console and execute the <code class="literal">list</code> operation on the <code class="literal">jboss:service=JNDIView</code> mbean. Towards the bottom of the results, the contents of the "HA-JNDI Namespace" are listed. Typically this will be empty; if any of your own deployments are shown there and you did not explicitly bind them there, there's probably an improper jndi.properties file on the classpath. Please visit the following link for an example: <a href="http://www.jboss.com/index.html?module=bb&amp;op=viewtopic&amp;t=104715">Problem with removing a Node from Cluster</a>.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776680893168">
      ⁠</a>22.2.2. For clients running outside the Enterprise Application Platform</h2></div></div></div><div class="para">
				The JNDI client needs to be aware of the HA-JNDI cluster. You can pass a list of JNDI servers (i.e., the nodes in the HA-JNDI cluster) to the <code class="literal">java.naming.provider.url</code> JNDI setting in the <code class="literal">jndi.properties</code> file. Each server node is identified by its IP address and the JNDI port number. The server nodes are separated by commas (see <a class="xref" href="clustering-jndi.html#clustering-jndi-jboss">Section 22.3, “JBoss configuration”</a> for how to configure the servers and ports).
			</div><pre class="programlisting">java.naming.provider.url=server1:1100,server2:1100,server3:1100,server4:1100</pre><div class="para">
				When initializing, the JNP client code will try to get in touch with each server node from the list, one after the other, stopping as soon as one server has been reached. It will then download the HA-JNDI stub from this node.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					There is no load balancing behavior in the JNP client lookup process itself. It just goes through the provider lists and uses the first available server to obtain the stub. The HA-JNDI provider list only needs to contain a subset of HA-JNDI nodes in the cluster; once the HA-JNDI stub is downloaded, the stub will include information on all the available servers. A good practice is to include a set of servers such that you are certain that at least one of those in the list will be available.
				</div></div></div><div class="para">
				The downloaded smart proxy contains the list of currently running nodes and the logic to load balance naming requests and to fail-over to another node if necessary. Furthermore, each time a JNDI invocation is made to the server, the list of targets in the proxy interceptor is updated (only if the list has changed since the last call).
			</div><div class="para">
				If the property string <code class="literal">java.naming.provider.url</code> is empty or if all servers it mentions are not reachable, the JNP client will try to discover a HA-JNDI server through a multicast call on the network (auto-discovery). See <a class="xref" href="clustering-jndi.html#clustering-jndi-jboss">Section 22.3, “JBoss configuration”</a> for how to configure auto-discovery on the JNDI server nodes. Through auto-discovery, the client might be able to get a valid HA-JNDI server node without any configuration. Of course, for auto-discovery to work, the network segment(s) between the client and the server cluster must be configured to propagate such multicast datagrams.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					By default the auto-discovery feature uses multicast group address 230.0.0.4 and port 1102.
				</div></div></div><div class="para">
				In addition to the <code class="literal">java.naming.provider.url</code> property, you can specify a set of other properties. The following list shows all clustering-related client side properties you can specify when creating a new <code class="literal">InitialContext</code>. (All of the standard, non-clustering-related environment properties used with regular JNDI are also available.)
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">java.naming.provider.url</code>: Provides a list of IP addresses and port numbers for HA-JNDI provider nodes in the cluster. The client tries those providers one by one and uses the first one that responds.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.disableDiscovery</code>: When set to <code class="literal">true</code>, this property disables the automatic discovery feature. Default is <code class="literal">false</code>.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.partitionName</code>: In an environment where multiple HA-JNDI services bound to distinct clusters (a.k.a. partitions), are running, this property allows you to ensure that your client only accepts automatic-discovery responses from servers in the desired partition. If you do not use the automatic discovery feature (i.e. jnp.disableDiscovery is true), this property is not used. By default, this property is not set and the automatic discovery selects the first HA-JNDI server that responds, regardless of the cluster partition name.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryTimeout</code>: Determines how many milliseconds the context will wait for a response to its automatic discovery packet. Default is 5000 ms.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryGroup</code>: Determines which multicast group address is used for the automatic discovery. Default is 230.0.0.4. Must match the value of the AutoDiscoveryAddress configured on the server side HA-JNDI service. Note that the server side HA-JNDI service by default listens on the address specified via the <code class="literal">-u</code> switch, so if <code class="literal">-u</code> is used on the server side (as is recommended), jnp.discoveryGroup will need to be configured on the client side.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryPort</code>: Determines which multicast port is used for the automatic discovery. Default is 1102. Must match the value of the AutoDiscoveryPort configured on the server side HA-JNDI service.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryTTL</code>: specifies the TTL (time-to-live) for autodiscovery IP multicast packets. This value represents the number of network hops a multicast packet can be allowed to propagate before networking equipment should drop the packet. Despite its name, it does not represent a unit of time.
					</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-jndi-jboss">
      ⁠</a>22.3. JBoss configuration</h1></div></div></div><div class="para">
			The <code class="literal">hajndi-jboss-beans.xml</code> file in the <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/production/deploy/cluster</code> directory includes the following bean to enable HA-JNDI services.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"HAJNDI"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.jndi.HANamingService"</span><span xmlns="" class="perl_Keyword">&gt;</span>    
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX
<span xmlns="" class="line">​</span>      (name="jboss:service=HAJNDI", 
<span xmlns="" class="line">​</span>         exposedInterface=org.jboss.ha.jndi.HANamingServiceMBean.class)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>  
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- The partition used for group RPCs to find locally bound objects on other nodes --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Handler for the replicated tree --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"distributedTreeManager"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.jndi.impl.jbc.JBossCacheDistributedTreeManager"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"cacheHandler"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"HAPartitionCacheHandler"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"localNamingInstance"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"jboss:service=NamingBeanImpl"</span><span xmlns="" class="perl_Others"> property=</span><span xmlns="" class="perl_String">"namingInstance"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- The thread pool used to control the bootstrap and auto discovery lookups --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"lookupPool"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"jboss.system:service=ThreadPool"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Bind address of bootstrap endpoint --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"bindAddress"</span><span xmlns="" class="perl_Keyword">&gt;</span>${jboss.bind.address}<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Port on which the HA-JNDI stub is made available --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"port"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Comment">&lt;!-- Get the port from the ServiceBindingManager --&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;value-factory</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"ServiceBindingManager"</span><span xmlns="" class="perl_Others"> method=</span><span xmlns="" class="perl_String">"getIntBinding"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;parameter&gt;</span>jboss:service=HAJNDI<span xmlns="" class="perl_Keyword">&lt;/parameter&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;parameter&gt;</span>Port<span xmlns="" class="perl_Keyword">&lt;/parameter&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;/value-factory&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Bind address of the HA-JNDI RMI endpoint --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"rmiBindAddress"</span><span xmlns="" class="perl_Keyword">&gt;</span>${jboss.bind.address}<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- RmiPort to be used by the HA-JNDI service once bound. 0 = ephemeral. --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"rmiPort"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Comment">&lt;!-- Get the port from the ServiceBindingManager --&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;value-factory</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"ServiceBindingManager"</span><span xmlns="" class="perl_Others"> method=</span><span xmlns="" class="perl_String">"getIntBinding"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;parameter&gt;</span>jboss:service=HAJNDI<span xmlns="" class="perl_Keyword">&lt;/parameter&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;parameter&gt;</span>RmiPort<span xmlns="" class="perl_Keyword">&lt;/parameter&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;/value-factory&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Accept backlog of the bootstrap socket --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"backlog"</span><span xmlns="" class="perl_Keyword">&gt;</span>50<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- A flag to disable the auto discovery via multicast --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"discoveryDisabled"</span><span xmlns="" class="perl_Keyword">&gt;</span>false<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Set the auto-discovery bootstrap multicast bind address. If not </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">      specified and a BindAddress is specified, the BindAddress will be used. --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"autoDiscoveryBindAddress"</span><span xmlns="" class="perl_Keyword">&gt;</span>${jboss.bind.address}<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Multicast Address and group port used for auto-discovery --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"autoDiscoveryAddress"</span><span xmlns="" class="perl_Keyword">&gt;</span>${jboss.partition.udpGroup:230.0.0.4}<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"autoDiscoveryGroup"</span><span xmlns="" class="perl_Keyword">&gt;</span>1102<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- The TTL (time-to-live) for autodiscovery IP multicast packets --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"autoDiscoveryTTL"</span><span xmlns="" class="perl_Keyword">&gt;</span>16<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- The load balancing policy for HA-JNDI --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"loadBalancePolicy"</span><span xmlns="" class="perl_Keyword">&gt;</span>org.jboss.ha.framework.interfaces.RoundRobin<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Client socket factory to be used for client-server</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">           RMI invocations during JNDI queries</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">      &lt;property name="clientSocketFactory"&gt;custom&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">      --&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">&lt;!-- Server socket factory to be used for client-server</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">           RMI invocations during JNDI queries</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">      &lt;property name="serverSocketFactory"&gt;custom&lt;/property&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Comment">      --&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span></pre><div class="para">
			You can see that this bean has a number of other services injected into different properties: 
			<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>HAPartition</strong></span> accepts the core clustering service used manage HA-JNDI's clustered proxies and to make the group RPCs that find locally bound objects on other nodes. See <a class="xref" href="clustering-blocks.chapt.html#clustering-hapartition">Section 21.3, “The HAPartition Service”</a> for more.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>distributedTreeManager</strong></span> accepts a handler for the replicated tree. The standard handler uses JBoss Cache to manage the replicated tree. The JBoss Cache instance is retrieved using the injected <code class="literal">HAPartitionCacheHandler</code> bean. See <a class="xref" href="clustering-blocks.chapt.html#clustering-hapartition">Section 21.3, “The HAPartition Service”</a> for more details.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>localNamingInstance</strong></span> accepts the reference to the local JNDI service.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>lookupPool</strong></span> accepts the thread pool used to provide threads to handle the bootstrap and auto discovery lookups.
					</div></li></ul></div>

		</div><div class="para">
			Besides the above dependency injected services, the available configuration attributes for the HA-JNDI bean are as follows:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>bindAddress</strong></span> specifies the address to which the HA-JNDI server will bind to listen for naming proxy download requests from JNP clients. The default value is the value of the <code class="literal">jboss.bind.address</code> system property, or <code class="literal">localhost</code> if that property is not set. The <code class="literal">jboss.bind.address</code> system property is set if the <code class="literal">-b</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>port</strong></span> specifies the port to which the HA-JNDI server will bind to listen for naming proxy download requests from JNP clients. The value is obtained from the ServiceBindingManager bean configured in <code class="literal">conf/bootstrap/bindings.xml</code>. The default value is <code class="literal">1100</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>backlog</strong></span> specifies the maximum queue length for incoming connection indications for the TCP server socket on which the service listens for naming proxy download requests from JNP clients. The default value is <code class="literal">50</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>rmiBindAddress</strong></span> specifies the address to which the HA-JNDI server will bind to listen for RMI requests (e.g. for JNDI lookups) from naming proxies. The default value is the value of the <code class="literal">jboss.bind.address</code> system property, or <code class="literal">localhost</code> if that property is not set. The <code class="literal">jboss.bind.address</code> system property is set if the <code class="literal">-b</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>rmiPort</strong></span> specifies the port to which the server will bind to communicate with the downloaded stub. The value is obtained from the ServiceBindingManager bean configured in <code class="literal">conf/bootstrap/bindings.xml</code>. The default value is <code class="literal">1101</code>. If no value is set, the operating system automatically assigns a port.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>discoveryDisabled</strong></span> is a boolean flag that disables configuration of the auto discovery multicast listener. The default is <code class="literal">false</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryAddress</strong></span> specifies the multicast address to listen to for JNDI automatic discovery. The default value is the value of the <code class="literal">jboss.partition.udpGroup</code> system property, or 230.0.0.4 if that is not set. The <code class="literal">jboss.partition.udpGroup</code> system property is set if the <code class="literal">-u</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryGroup</strong></span> specifies the port to listen on for multicast JNDI automatic discovery packets. The default value is <code class="literal">1102</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryBindAddress</strong></span> sets the interface on which HA-JNDI should listen for auto-discovery request packets. If this attribute is not specified and a <code class="literal">bindAddress</code> is specified, the <code class="literal">bindAddress</code> will be used.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryTTL</strong></span> specifies the TTL (time-to-live) for autodiscovery IP multicast packets. This value represents the number of network hops a multicast packet can be allowed to propagate before networking equipment should drop the packet. Despite its name, it does not represent a unit of time.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>loadBalancePolicy</strong></span> specifies the class name of the LoadBalancePolicy implementation that should be included in the client proxy. See <a class="xref" href="clustering-intro.chapt.html">Chapter 19, <em>Introduction and Quick Start</em></a> the Introduction and Quick Start chapter for details.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>clientSocketFactory</strong></span> is an optional attribute that specifies the fully qualified classname of the <code class="literal">java.rmi.server.RMIClientSocketFactory</code> that should be used to create client sockets. The default is <code class="literal">null</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>serverSocketFactory</strong></span> is an optional attribute that specifies the fully qualified classname of the <code class="literal">java.rmi.server.RMIServerSocketFactory</code> that should be used to create server sockets. The default is <code class="literal">null</code>.
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776743154816">
      ⁠</a>22.3.1. Adding a Second HA-JNDI Service</h2></div></div></div><div class="para">
				It is possible to start several HA-JNDI services that use different HAPartitions. This can be used, for example, if a node is part of many logical clusters. In this case, make sure that you set a different port or IP address for each service. For instance, if you wanted to hook up HA-JNDI to the example cluster you set up and change the binding port, the bean descriptor would look as follows (properties that do not vary from the standard deployments are omitted):
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Error">&lt;</span>-- Cache Handler for secondary HAPartition --&gt;
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"SecondaryHAPartitionCacheHandler"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">         class=</span><span xmlns="" class="perl_String">"org.jboss.ha.framework.server.HAPartitionCacheHandlerImpl"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"cacheManager"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"CacheManager"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"cacheConfigName"</span><span xmlns="" class="perl_Keyword">&gt;</span>secondary-ha-partition<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Error">&lt;</span>-- The secondary HAPartition --&gt;
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"SecondaryHAPartition"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.framework.server.ClusterPartition"</span><span xmlns="" class="perl_Keyword">&gt;</span>     
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;depends&gt;</span>jboss:service=Naming<span xmlns="" class="perl_Keyword">&lt;/depends&gt;</span>
<span xmlns="" class="line">​</span>       
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX
<span xmlns="" class="line">​</span>      (name="jboss:service=HAPartition,partition=SecondaryPartition", 
<span xmlns="" class="line">​</span>      exposedInterface=org.jboss.ha.framework.server.ClusterPartitionMBean.class, registerDirectly=true)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>
<span xmlns="" class="line">​</span>       
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"cacheHandler"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"SecondaryHAPartitionCacheHandler"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>               
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"partitionName"</span><span xmlns="" class="perl_Keyword">&gt;</span>SecondaryPartition<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      ....      
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"MySpecialPartitionHAJNDI"</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.jndi.HANamingService"</span><span xmlns="" class="perl_Keyword">&gt;</span>    
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;annotation&gt;</span>@org.jboss.aop.microcontainer.aspects.jmx.JMX
<span xmlns="" class="line">​</span>      (name="jboss:service=HAJNDI,partitionName=SecondaryPartition", 
<span xmlns="" class="line">​</span>         exposedInterface=org.jboss.ha.jndi.HANamingServiceMBean.class)<span xmlns="" class="perl_Keyword">&lt;/annotation&gt;</span>  
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"HAPartition"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"SecondaryHAPartition"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"distributedTreeManager"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;bean</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"org.jboss.ha.jndi.impl.jbc.JBossCacheDistributedTreeManager"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"cacheHandler"</span><span xmlns="" class="perl_Keyword">&gt;&lt;inject</span><span xmlns="" class="perl_Others"> bean=</span><span xmlns="" class="perl_String">"SecondaryHAPartitionPartitionCacheHandler"</span><span xmlns="" class="perl_Keyword">/&gt;&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"port"</span><span xmlns="" class="perl_Keyword">&gt;</span>56789<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"rmiPort"</span><span xmlns="" class="perl_Keyword">&gt;</span>56790<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"autoDiscoveryGroup"</span><span xmlns="" class="perl_Keyword">&gt;</span>56791<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>      .....
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/bean&gt;</span></pre></div></div></div></body></html>