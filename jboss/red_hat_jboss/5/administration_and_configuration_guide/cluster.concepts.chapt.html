<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 20. Clustering Concepts</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="cluster.concepts.chapt">
      ⁠</a>Chapter 20. Clustering Concepts</h1></div></div></div><div class="para">
		In the next section, we discuss basic concepts behind JBoss' clustering services. It is helpful that you understand these concepts before reading the rest of the <span class="emphasis"><em>Clustering Guide</em></span>.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-concepts-def">
      ⁠</a>20.1. Cluster Definition</h1></div></div></div><div class="para">
			A cluster is a set of nodes that communicate with each other and work toward a common goal. In a JBoss Enterprise Application Platform cluster (also known as a “partition”), a node is an JBoss Enterprise Application Platform instance. Communication between the nodes is handled by the JGroups group communication library, with a JGroups <code class="literal">Channel</code> providing the core functionality of tracking who is in the cluster and reliably exchanging messages between the cluster members. JGroups channels with the same configuration and name have the ability to dynamically discover each other and form a group. This is why simply executing “run -c production” on two Enterprise Application Platform instances on the same network is enough for them to form a cluster – each Enterprise Application Platform starts a <code class="literal">Channel</code> (actually, several) with the same default configuration, so they dynamically discover each other and form a cluster. Nodes can be dynamically added to or removed from clusters at any time, simply by starting or stopping a <code class="literal">Channel</code> with a configuration and name that matches the other cluster members.
		</div><div class="para">
			On the same Enterprise Application Platform instance, different services can create their own <code class="literal">Channel</code>. In a standard start of the Enterprise Application Platform 5 <span class="emphasis"><em>production</em></span> server profile, two different services create a total of four different channels – JBoss Messaging creates two and a core general purpose clustering service known as HAPartition creates two more. If you deploy clustered web applications, clustered EJB3 SFSBs or a clustered JPA/Hibernate entity cache, additional channels will be created. The channels the Enterprise Application Platform connects can be divided into three broad categories: a general purpose channel used by the HAPartition service, channels created by JBoss Cache for special purpose caching and cluster wide state replication, and two channels used by JBoss Messaging.
		</div><div class="para">
			So, if you go to two Enterprise Application Platform 5.0.x instances and execute <code class="literal">run -c production</code>, the channels will discover each other and you'll have a conceptual <code class="literal">cluster</code>. It's easy to think of this as a two node cluster, but it's important to understand that you really have multiple channels, and hence multiple two node clusters.
		</div><div class="para">
			On the same network, you may have different sets of servers whose services wish to cluster. <a class="xref" href="cluster.concepts.chapt.html#clustering-Partition.fig">Figure 20.1, “Clusters and server nodes”</a> shows an example network of EAP instances divided into three sets, with the third set only having one node. This sort of topology can be set up simply by configuring the Enterprise Application Platform instances such that within a set of nodes meant to form a cluster the Channel configurations and names match while they differ from any other channel configurations and names match while they differ from any other channels on the same network. The Enterprise Application Platform tries to make this is easy as possible, such that servers that are meant to cluster only need to have the same values passed on the command line to the <code class="literal">-g</code> (partition name) and <code class="literal">-u</code> (multicast address) start up switches. For each set of servers, different values should be chosen. The sections on “JGroups Configuration” and “Isolating JGroups Channels” cover in detail how to configure the Enterprise Application Platform such that desired peers find each other and unwanted peers do not.
		</div><div class="figure"><a id="clustering-Partition.fig">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/clustering-Partition.png" align="middle" alt="Clusters and server nodes" style="text-align: middle"/></div></div><p class="title"><strong>Figure 20.1. Clusters and server nodes</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-concepts-arch">
      ⁠</a>20.2. Service Architectures</h1></div></div></div><div class="para">
			The clustering topography defined by the JGroups configuration on each node is of great importance to system administrators. But for most application developers, the greater concern is probably the cluster architecture from a client application's point of view. Two basic clustering architectures are used with JBoss Enterprise Application Platform: client-side interceptors (a.k.a. smart proxies or stubs) and external load balancers. Which architecture your application will use will depend on what type of client you have.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-concepts-arch-proxy">
      ⁠</a>20.2.1. Client-side interceptor architecture</h2></div></div></div><div class="para">
				Most remote services provided by the JBoss Enterprise Application Platform, including JNDI, EJB, JMS, RMI and JBoss Remoting, require the client to obtain (for example, to look up and download) a remote proxy object. The proxy object is generated by the server and it implements the business interface of the service. The client then makes local method calls against the proxy object. The proxy automatically routes the call across the network where it is invoked against service objects managed in the server. The proxy object figures out how to find the appropriate server node, marshal call parameters, unmarshal call results, and return the result to the caller client. In a clustered environment, the server-generated proxy object includes an interceptor that understands how to route calls to multiple nodes in the cluster.
			</div><div class="para">
				The proxy's clustering logic maintains up-to-date knowledge about the cluster. For instance, it knows the IP addresses of all available server nodes, the algorithm to distribute load across nodes (see next section), and how to failover the request if the target node not available. As part of handling each service request, if the cluster topology has changed the server node updates the proxy with the latest changes in the cluster. For instance, if a node drops out of the cluster, each proxy is updated with the new topology the next time it connects to any active node in the cluster. All the manipulations done by the proxy's clustering logic are transparent to the client application. The client-side interceptor clustering architecture is illustrated below:
			</div><div class="mediaobjectco" style="text-align: center"><img src="images/clustering-InterceptorArch.png" align="middle" width="594" alt="Client-side interceptor architecture" style="text-align: middle"/><div class="calloutlist"><table border="0" summary="Callout list"><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/1.png" alt="1"/></p></td><td valign="top" align="left"><div class="para">
						Client communicates with proxy
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/2.png" alt="2"/></p></td><td valign="top" align="left"><div class="para">
						Proxy sends request to Node 1
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/3.png" alt="3"/></p></td><td valign="top" align="left"><div class="para">
						Node 1 goes offline
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/4.png" alt="4"/></p></td><td valign="top" align="left"><div class="para">
						Proxy switches to Node 2
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/5.png" alt="5"/></p></td><td valign="top" align="left"><div class="para">
						Proxy sends request to Node 2
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/6.png" alt="6"/></p></td><td valign="top" align="left"><div class="para">
						Proxy downloads class dynamically from Node 2
					</div></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-concepts-arch-balancer">
      ⁠</a>20.2.2. External Load Balancer Architecture</h2></div></div></div><div class="para">
				The HTTP-based JBoss services do not require the client to download anything. The client (for example, a web browser) sends in requests and receives responses directly over the wire using the HTTP protocol). In this case, an external load balancer is required to process all requests and dispatch them to server nodes in the cluster. The client only needs to know how to contact the load balancer; it has no knowledge of the JBoss Enterprise Application Platform instances behind the load balancer. The load balancer is logically part of the cluster, but we refer to it as “external” because it is not running in the same process as either the client or any of the JBoss Enterprise Application Platform instances. It can be implemented either in software or hardware. There are many vendors of hardware load balancers; the mod_jk Apache module is an excellent example of a software load balancer. An external load balancer implements its own mechanism for understanding the cluster configuration and provides its own load balancing and failover policies. The external load balancer clustering architecture is illustrated below:
			</div><div class="mediaobjectco" style="text-align: center"><img src="images/clustering-BalancerArch.png" align="middle" width="594" alt="External Load Balancer Architecture" style="text-align: middle"/><div class="calloutlist"><table border="0" summary="Callout list"><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/1.png" alt="1"/></p></td><td valign="top" align="left"><div class="para">
						Browser sends a request.
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/2.png" alt="2"/></p></td><td valign="top" align="left"><div class="para">
						Load Balancer forwards request to Node 1.
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/3.png" alt="3"/></p></td><td valign="top" align="left"><div class="para">
						Node 1 goes offline.
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/4.png" alt="4"/></p></td><td valign="top" align="left"><div class="para">
						Load Balancer switches to using Node 2.
					</div></td></tr><tr><td valign="top" align="left"><p><img class="callout" src="Common_Content/images/5.png" alt="5"/></p></td><td valign="top" align="left"><div class="para">
						Load Balancer forwards to Node 2.
					</div></td></tr></table></div></div><div class="para">
				A potential problem with an external load balancer architecture is that the load balancer itself may be a single point of failure. It needs to be monitored closely to ensure high availability of the entire cluster's services.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="clustering-concepts-balancepolicy">
      ⁠</a>20.3. Load Balancing Policies</h1></div></div></div><div class="para">
			Both the JBoss client-side interceptor (stub) and load balancer use load balancing policies to determine to which server node a new request should be sent. In this section, let us go over the load balancing policies available in JBoss Enterprise Application Platform.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-concepts-balancepolicy-30">
      ⁠</a>20.3.1. Client-side interceptor architecture</h2></div></div></div><div class="para">
				In JBoss Enterprise Application Platform 5, the following load balancing options are available when the client-side interceptor architecture is used. The client-side stub maintains a list of all nodes providing the target service; the job of the load balance policy is to pick a node from this list for each request. Each policy has two implementation classes, one meant for use by legacy services like EJB2 that use the legacy detached invoker architecture, and the other meant for services like EJB3 that use AOP-based invocations.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Round-Robin: each call is dispatched to a new node, proceeding sequentially through the list of nodes. The first target node is randomly selected from the list. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.RoundRobin</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.RoundRobin</code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						Random-Robin: for each call the target node is randomly selected from the list. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.RandomRobin</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.RandomRobin </code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						First Available: one of the available target nodes is elected as the main target and is thereafter used for every call; this elected member is randomly chosen from the list of members in the cluster. When the list of target nodes changes (because a node starts or dies), the policy will choose a new target node unless the currently elected node is still available. Each client-side proxy elects its own target node independently of the other proxies, so if a particular client downloads two proxies for the same target service (for example, an EJB), each proxy will independently pick its target. This is an example of a policy that provides “session affinity” or “sticky sessions”, since the target node does not change once established. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.FirstAvailable</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailable</code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						First Available Identical All Proxies: has the same behavior as the "First Available" policy but the elected target node is shared by all proxies in the same client-side VM that are associated with the same target service. So if a particular client downloads two proxies for the same target service (e.g. an EJB), each proxy will use the same target. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.FirstAvailableIdenticalAllProxies</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailableIdenticalAllProxies</code> (EJB3).
					</div></li></ul></div><div class="para">
				Each of the above is an implementation of the <code class="classname">org.jboss.ha.framework.interfaces.LoadBalancePolicy</code> interface; users are free to write their own implementation of this simple interface if they need some special behavior. In later sections we will see how to configure the load balance policies used by different services.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776680649616">
      ⁠</a>20.3.2. External load balancer architecture</h2></div></div></div><div class="para">
				New in JBoss Enterprise Application Platform 5 are a set of "TransactionSticky" load balance policies. These extend the standard policies above to add behavior such that all invocations that occur within the scope of a transaction are routed to the same node (if that node still exists). These are based on the legacy detached invoker architecture, so they are not available for AOP-based services like EJB3.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Transaction-Sticky Round-Robin: Transaction-sticky variant of Round-Robin. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyRoundRobin</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky Random-Robin: Transaction-sticky variant of Random-Robin. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyRandomRobin</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky First Available: Transaction-sticky variant of First Available. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyFirstAvailable</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky First Available Identical All Proxies: Transaction-sticky variant of First Available Identical All Proxies. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyFirstAvailableIdenticalAllProxies</code>.
					</div></li></ul></div><div class="para">
				Each of the above is an implementation of a simple interface; users are free to write their own implementations if they need some special behavior. In later sections we will see how to configure the load balance policies used by different services.
			</div></div></div></div></body></html>