<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 28. JGroups Services</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups.chapt">
      ⁠</a>Chapter 28. JGroups Services</h1></div></div></div><div class="para">
		JGroups provides the underlying group communication support for JBoss Enterprise Application Platform clusters. The interaction of clustered services with JGroups was covered in <a class="xref" href="clustering-blocks.chapt.html#clustering-blocks-jgroups">Section 21.1, “Group Communication with JGroups”</a>. This chapter focuses on the details of this interaction, with particular attention to configuration details and troubleshooting tips.
	</div><div class="para">
		This chapter is not intended as complete JGroups documentation. If you want to know more about JGroups, you can consult:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				The JGroups project documentation at <a href="http://jgroups.org/ug.html">http://jgroups.org/ug.html</a>
			</div></li><li class="listitem"><div class="para">
				The JGroups wiki pages at jboss.org, rooted at <a href="https://www.jboss.org/community/wiki/JGroups">https://www.jboss.org/community/wiki/JGroups</a>
			</div></li></ul></div><div class="para">
		The first section of this chapter covers the many JGroups configuration options in detail. JBoss Enterprise Application Platform ships with a set of default JGroups configurations. Most applications will work with the default configurations out of the box. You will only need to edit these configurations when you deploy an application with special network or performance requirements.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups-configuration">
      ⁠</a>28.1. Configuring a JGroups Channel's Protocol Stack</h1></div></div></div><div class="para">
			The JGroups framework provides services to enable peer-to-peer communications between nodes in a cluster. Communication occurs over a communication channel. The channel built up from a stack of network communication <span class="emphasis"><em>protocols</em></span>, each of which is responsible for adding a particular capability to the overall behavior of the channel. Key capabilities provided by various protocols include transport, cluster discovery, message ordering, lossless message delivery, detection of failed peers, and cluster membership management services.
		</div><div class="para">
			<a class="xref" href="jgroups.chapt.html#JGroupsStack.fig">Figure 28.1, “Protocol stack in JGroups”</a> shows a conceptual cluster with each member's channel composed of a stack of JGroups protocols.
		</div><div class="figure"><a id="JGroupsStack.fig">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/jbosscache-JGroupsStack.png" align="middle" alt="Protocol stack in JGroups" style="text-align: middle"/></div></div><p class="title"><strong>Figure 28.1. Protocol stack in JGroups</strong></p></div><div class="para">
			This section of the chapter covers some of the most commonly used protocols, according to the type of behavior they add to the channel. We discuss a few key configuration attributes exposed by each protocol, but since these attributes should be altered only by experts, this chapter focuses on familiarizing users with the purpose of various protocols.
		</div><div class="para">
			The JGroups configurations used in JBoss Enterprise Application Platform appear as nested elements in the <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file. This file is parsed by the <code class="literal">ChannelFactory</code> service, which uses the contents to provide correctly configured channels to the clustered services that require them. See <a class="xref" href="clustering-blocks.chapt.html#clustering-blocks-jgroups-channelfactory">Section 21.1.1, “The Channel Factory Service”</a> for more on the <code class="literal">ChannelFactory</code> service.
		</div><div class="para">
			The following is an example protocol stack configuration from <code class="filename">jgroups-channelfactory-stacks.xml</code>:
		</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;stack</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"udp-async"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">           description=</span><span xmlns="" class="perl_String">"Same as the default 'udp' stack above, except message bundling</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">                        is enabled in the transport protocol (enable_bundling=true). </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">                        Useful for services that make high-volume asynchronous </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">                        RPCs (e.g. high volume JBoss Cache instances configured </span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">                        for REPL_ASYNC) where message bundling may improve performance."</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;config&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;UDP</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             singleton_name=</span><span xmlns="" class="perl_String">"udp-async"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_port=</span><span xmlns="" class="perl_String">"${jboss.jgroups.udp_async.mcast_port:45689}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_addr=</span><span xmlns="" class="perl_String">"${jboss.partition.udpGroup:228.11.11.11}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             tos=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ucast_recv_buf_size=</span><span xmlns="" class="perl_String">"20000000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ucast_send_buf_size=</span><span xmlns="" class="perl_String">"640000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_recv_buf_size=</span><span xmlns="" class="perl_String">"25000000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_send_buf_size=</span><span xmlns="" class="perl_String">"640000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             loopback=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             discard_incompatible_packets=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             enable_bundling=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             max_bundle_size=</span><span xmlns="" class="perl_String">"64000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             max_bundle_timeout=</span><span xmlns="" class="perl_String">"30"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ip_ttl=</span><span xmlns="" class="perl_String">"${jgroups.udp.ip_ttl:2}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_naming_pattern=</span><span xmlns="" class="perl_String">"cl"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             timer.num_threads=</span><span xmlns="" class="perl_String">"12"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             enable_diagnostics=</span><span xmlns="" class="perl_String">"${jboss.jgroups.enable_diagnostics:true}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             diagnostics_addr=</span><span xmlns="" class="perl_String">"${jboss.jgroups.diagnostics_addr:224.0.0.75}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             diagnostics_port=</span><span xmlns="" class="perl_String">"${jboss.jgroups.diagnostics_port:7500}"</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.min_threads=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.max_threads=</span><span xmlns="" class="perl_String">"200"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.keep_alive_time=</span><span xmlns="" class="perl_String">"5000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.queue_enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.queue_max_size=</span><span xmlns="" class="perl_String">"1000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.rejection_policy=</span><span xmlns="" class="perl_String">"discard"</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.min_threads=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.max_threads=</span><span xmlns="" class="perl_String">"200"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.keep_alive_time=</span><span xmlns="" class="perl_String">"1000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.queue_enabled=</span><span xmlns="" class="perl_String">"false"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.rejection_policy=</span><span xmlns="" class="perl_String">"discard"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;PING</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"2000"</span><span xmlns="" class="perl_Others"> num_initial_members=</span><span xmlns="" class="perl_String">"3"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;MERGE2</span><span xmlns="" class="perl_Others"> max_interval=</span><span xmlns="" class="perl_String">"100000"</span><span xmlns="" class="perl_Others"> min_interval=</span><span xmlns="" class="perl_String">"20000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;FD_SOCK/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;FD</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"6000"</span><span xmlns="" class="perl_Others"> max_tries=</span><span xmlns="" class="perl_String">"5"</span><span xmlns="" class="perl_Others"> shun=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;VERIFY_SUSPECT</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"1500"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;BARRIER/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;pbcast.NAKACK</span><span xmlns="" class="perl_Others"> use_mcast_xmit=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Others"> gc_lag=</span><span xmlns="" class="perl_String">"0"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   retransmit_timeout=</span><span xmlns="" class="perl_String">"300,600,1200,2400,4800"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   discard_delivered_msgs=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;UNICAST</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"300,600,1200,2400,3600"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;pbcast.STABLE</span><span xmlns="" class="perl_Others"> stability_delay=</span><span xmlns="" class="perl_String">"1000"</span><span xmlns="" class="perl_Others"> desired_avg_gossip=</span><span xmlns="" class="perl_String">"50000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   max_bytes=</span><span xmlns="" class="perl_String">"400000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>          
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;VIEW_SYNC</span><span xmlns="" class="perl_Others"> avg_send_interval=</span><span xmlns="" class="perl_String">"10000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;pbcast.GMS</span><span xmlns="" class="perl_Others"> print_local_addr=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Others"> join_timeout=</span><span xmlns="" class="perl_String">"3000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   shun=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   view_bundling=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   view_ack_collection_timeout=</span><span xmlns="" class="perl_String">"5000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">                   resume_task_timeout=</span><span xmlns="" class="perl_String">"7500"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;FC</span><span xmlns="" class="perl_Others"> max_credits=</span><span xmlns="" class="perl_String">"2000000"</span><span xmlns="" class="perl_Others"> min_threshold=</span><span xmlns="" class="perl_String">"0.10"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">              ignore_synchronous_response=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;FRAG2</span><span xmlns="" class="perl_Others"> frag_size=</span><span xmlns="" class="perl_String">"60000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Comment">&lt;!-- pbcast.STREAMING_STATE_TRANSFER/ --&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;pbcast.STATE_TRANSFER/&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;pbcast.FLUSH</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"0"</span><span xmlns="" class="perl_Others"> start_flush_timeout=</span><span xmlns="" class="perl_String">"10000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;/config&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/stack&gt;</span></pre><div class="para">
			The <code class="literal">&lt;config&gt;</code> element contains all the configuration data for JGroups. This information is used to configure a JGroups <span class="emphasis"><em>channel</em></span>, which is conceptually similar to a socket, and manages communication between peers in a cluster. Each element within the <code class="literal">&lt;config&gt;</code> element defines a particular JGroups <span class="emphasis"><em>protocol</em></span>. Each protocol performs one function. The combination of these functions defines the characteristics of the channel as a whole. The next few sections describe common protocols and explain the options available to each.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776704883968">
      ⁠</a>28.1.1. Common Configuration Properties</h2></div></div></div><div class="para">
				The following property is exposed by all of the JGroups protocols discussed below:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">stats</code> - indicates whether the protocol should gather runtime statistics on its operations. These statistics can be exposed via tools like the JMX Console or the JGroups Probe utility. What, if any, statistics are gathered depends on the protocol. Default is <code class="literal">true</code>.
					</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					All protocols in the versions of JGroups used in JBoss Enterprise Application Platform 4 and earlier exposed the <code class="literal">down_thread</code> and <code class="literal">up_thread</code> attributes. The JGroups version included in JBoss Enterprise Application Platform 5 and later no longer uses those attributes, and a <code class="literal">WARN</code> message will be written to the server log if they are configured for any protocol.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-transport">
      ⁠</a>28.1.2. Transport Protocols</h2></div></div></div><div class="para">
				The transport protocols send and receive messages to and from the network. They also manage the thread pools used to deliver incoming messages to addresses higher in the protocol stack. JGroups supports <code class="literal">UDP</code>, <code class="literal">TCP</code> and <code class="literal">TUNNEL</code> as transport protocols.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The <code class="literal">UDP</code>, <code class="literal">TCP</code>, and <code class="literal">TUNNEL</code> protocols are mutually exclusive. You can only have one transport protocol in each JGroups <code class="literal">Config</code> element
				</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-transport-udp">
      ⁠</a>28.1.2.1. UDP configuration</h3></div></div></div><div class="para">
					UDP is the preferred transport protocol for JGroups. UDP uses multicast (or, in an unusual configuration, multiple unicasts) to send and receive messages. If you choose UDP as the transport protocol for your cluster service, you need to configure it in the <code class="literal">UDP</code> sub-element in the JGroups <code class="literal">config</code> element. Here is an example.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;UDP</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             singleton_name=</span><span xmlns="" class="perl_String">"udp-async"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_port=</span><span xmlns="" class="perl_String">"${jboss.jgroups.udp_async.mcast_port:45689}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_addr=</span><span xmlns="" class="perl_String">"${jboss.partition.udpGroup:228.11.11.11}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             tos=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ucast_recv_buf_size=</span><span xmlns="" class="perl_String">"20000000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ucast_send_buf_size=</span><span xmlns="" class="perl_String">"640000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_recv_buf_size=</span><span xmlns="" class="perl_String">"25000000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             mcast_send_buf_size=</span><span xmlns="" class="perl_String">"640000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             loopback=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             discard_incompatible_packets=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             enable_bundling=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             max_bundle_size=</span><span xmlns="" class="perl_String">"64000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             max_bundle_timeout=</span><span xmlns="" class="perl_String">"30"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             ip_ttl=</span><span xmlns="" class="perl_String">"${jgroups.udp.ip_ttl:2}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_naming_pattern=</span><span xmlns="" class="perl_String">"cl"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             timer.num_threads=</span><span xmlns="" class="perl_String">"12"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             enable_diagnostics=</span><span xmlns="" class="perl_String">"${jboss.jgroups.enable_diagnostics:true}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             diagnostics_addr=</span><span xmlns="" class="perl_String">"${jboss.jgroups.diagnostics_addr:224.0.0.75}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             diagnostics_port=</span><span xmlns="" class="perl_String">"${jboss.jgroups.diagnostics_port:7500}"</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.min_threads=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.max_threads=</span><span xmlns="" class="perl_String">"200"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.keep_alive_time=</span><span xmlns="" class="perl_String">"5000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.queue_enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.queue_max_size=</span><span xmlns="" class="perl_String">"1000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             thread_pool.rejection_policy=</span><span xmlns="" class="perl_String">"discard"</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.enabled=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.min_threads=</span><span xmlns="" class="perl_String">"8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.max_threads=</span><span xmlns="" class="perl_String">"200"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.keep_alive_time=</span><span xmlns="" class="perl_String">"1000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.queue_enabled=</span><span xmlns="" class="perl_String">"false"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">             oob_thread_pool.rejection_policy=</span><span xmlns="" class="perl_String">"discard"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					JGroups transport configurations have a number of attributes available. First we look at the attributes available to the <code class="literal">UDP</code> protocol, followed by the attributes that are also used by the <code class="literal">TCP</code> and <code class="literal">TUNNEL</code> transport protocols.
				</div><div class="para">
					The attributes particular to the <code class="literal">UDP</code> protocol are:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ip_mcast</strong></span> specifies whether or not to use IP multicasting. The default is <code class="literal">true</code>. If set to <code class="literal">false</code>, multiple unicast packets will be sent instead of one multicast packet. Any packet sent via <code class="literal">UDP</code> protocol are UDP datagrams.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_addr</strong></span> specifies the multicast address (class D) for communicating with the group (i.e., the cluster). The standard protocol stack configurations in JBoss Enterprise Application Platform use the value of system property <code class="literal">jboss.partition.udpGroup</code>, if set, as the value for this attribute. Using the <code class="literal">-u</code> command line switch when starting JBoss Enterprise Application Platform sets that value. See <a class="xref" href="jgroups.chapt.html#clustering-jgroups-isolation">Section 28.6.2, “Isolating JGroups Channels”</a> for information about using this configuration attribute to ensure that JGroups channels are properly isolated from one another. If this attribute is omitted, the default value is <code class="literal">228.11.11.11</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_port</strong></span> specifies the port to use for multicast communication with the group. See <a class="xref" href="jgroups.chapt.html#clustering-jgroups-isolation">Section 28.6.2, “Isolating JGroups Channels”</a> for how to use this configuration attribute to ensure JGroups channels are properly isolated from one another. If this attribute is omitted, the default is <code class="literal">45688</code>.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">mcast_send_buf_size</code>, <code class="literal">mcast_recv_buf_size</code>, <code class="literal">ucast_send_buf_size</code> and <code class="literal">ucast_recv_buf_size</code> define the socket send and receive buffer sizes that JGroups will request from the operating system. A large buffer size helps to ensure that packets are not dropped due to buffer overflow. However, socket buffer sizes are limited at the operating system level, so obtaining the desired buffer may require configuration at the operating system level. See <a class="xref" href="jgroups.chapt.html#jgroups-perf-udpbuffer">Section 28.6.2.3, “Improving UDP Performance by Configuring OS UDP Buffer Limits”</a> for further details.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_port</strong></span> specifies the port to which the unicast receive socket should be bound. The default is <code class="literal">0</code>; i.e. use an ephemeral port.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>port_range</strong></span> specifies the number of ports to try if the port identified by <code class="literal">bind_port</code> is not available. The default is <code class="literal">1</code>, which specifies that only <code class="literal">bind_port</code> will be tried.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ip_ttl</strong></span> specifies time-to-live (TTL) for IP Multicast packets. TTL is the commonly used term in multicast networking, but is actually something of a misnomer, since the value here refers to how many network hops a packet will be allowed to travel before networking equipment will drop it.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tos</strong></span> specifies the traffic class for sending unicast and multicast datagrams.
						</div></li></ul></div><div class="para">
					The attributes that are common to all transport protocols, and thus have the same meanings when used with <code class="literal">TCP</code> or <code class="literal">TUNNEL</code>, are:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>singleton_name</strong></span> provides a unique name for this transport protocol configuration. Used by the application server's <code class="literal">ChannelFactory</code> to support sharing of a transport protocol instance by different channels that use the same transport protocol configuration. See <a class="xref" href="clustering-blocks.chapt.html#clustering-blocks-jgroups-sharedtransport">Section 21.1.2, “The JGroups Shared Transport”</a>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface on which to receive and send messages. By default, JGroups uses the value of system property <code class="literal">jgroups.bind_addr</code>. This can also be set with the <code class="literal">-b</code> command line switch. See <a class="xref" href="jgroups.chapt.html#jgroups-other">Section 28.6, “Other Configuration Issues”</a> for more on binding JGroups sockets.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>receive_on_all_interfaces</strong></span> specifies whether this node should listen on all interfaces for multicasts. The default is <code class="literal">false</code>. It overrides the <code class="literal">bind_addr</code> property for receiving multicasts. However, <code class="literal">bind_addr</code> (if set) is still used to send multicasts.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>send_on_all_interfaces</strong></span> specifies whether this node sends UDP packets via all available network interface controllers, if your machine has multiple network interface controllers available. This means that the same multicast message is sent N times, so use with care.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>receive_interfaces</strong></span> specifies a list of interfaces on which to receive multicasts. The multicast receive socket will listen on all of these interfaces. This is a comma-separated list of IP addresses or interface names, for example, <code class="literal">192.168.5.1,eth1,127.0.0.1</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>send_interfaces</strong></span> specifies a list of interfaces via which to send multicasts. The multicast sender socket will send on all of these interfaces. This is a comma-separated list of IP addresses or interface names, for example, <code class="literal">192.168.5.1,eth1,127.0.0.1</code>.This means that the same multicast message is sent N times, so use with care.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>enable_bundling</strong></span> specifies whether to enable message bundling. If <code class="literal">true</code>, the transport protocol queues outgoing messages until <code class="literal">max_bundle_size</code> bytes have accumulated, or <code class="literal">max_bundle_time</code> milliseconds have elapsed, whichever occurs first. Then the transport protocol bundles queued messages into one large message and sends it. The messages are un-bundled at the receiver. The default is <code class="literal">false</code>.
						</div><div class="para">
							Message bundling can have significant performance benefits for channels that are used for high volume sending of messages where the sender does not block waiting for a response from recipients (for example, a JBoss Cache instance configured for <code class="literal">REPL_ASYNC</code>.) It can add considerable latency to applications where senders need to block waiting for responses, so it is not recommended for certain situations, such as where a JBoss Cache instance is configured for <code class="literal">REPL_SYNC</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>loopback</strong></span> specifies whether the thread sending a message to the group should itself carry the message back up the stack for delivery. (Messages sent to the group are always delivered to the sending node as well.) If <code class="literal">false</code>, the sending thread does not carry the message; the transport protocol waits to read the message off the network and uses one of the message delivery pool threads for delivery. The default is <code class="literal">false</code>, but <code class="literal">true</code> is recommended to ensure that the channel receives its own messages, in case the network interface goes down.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>discard_incompatible_packets</strong></span> specifies whether to discard packets sent by peers that use a different version of JGroups. Each message in the cluster is tagged with a JGroups version. If <code class="literal">discard_incompatible_packets</code> is set to <code class="literal">true</code>, messages received from different versions of JGroups will be silently discarded. Otherwise, a warning will be logged. <span class="emphasis"><em>In no case will the message be delivered.</em></span> The default value is <code class="literal">false</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>enable_diagnostics</strong></span> specifies that the transport should open a multicast socket on address <code class="literal">diagnostics_addr</code> and port <code class="literal">diagnostics_port</code> to listen for diagnostic requests sent by the JGroups <a href="http://www.jboss.org/community/wiki/Probe"><span class="bold bold"><strong>Probe</strong></span> utility</a>.
						</div></li><li class="listitem"><div class="para">
							The various <span class="bold bold"><strong>thread_pool</strong></span> attributes configure the behavior of the pool of threads JGroups uses to carry ordinary incoming messages up the stack. The various attributes provide the constructor arguments for an instance of <code class="literal">java.util.concurrent.ThreadPoolExecutorService</code>. In the example above, the pool will have a minimum or <span class="emphasis"><em>core size</em></span> of 8 threads, and a maximum size of 200. If more than 8 pool threads have been created, a thread returning from carrying a message will wait for up to 5000 milliseconds to be assigned a new message to carry, after which it will terminate. If no threads are available to carry a message, the (separate) thread reading messages off the socket will place messages in a queue; the queue will hold up to 1000 messages. If the queue is full, the thread reading messages off the socket will discard the message.
						</div></li><li class="listitem"><div class="para">
							The various <span class="bold bold"><strong>oob_thread_pool</strong></span> attributes are similar to the <span class="bold bold"><strong>thread_pool</strong></span> attributes in that they configure a <code class="literal">java.util.concurrent.ThreadPoolExecutorService</code> used to carry incoming messages up the protocol stack. In this case, the pool is used to carry a special type of message known as an Out-Of-Band (OOB) message. OOB messages are exempt from the ordered-delivery requirements of protocols like NAKACK and UNICAST and thus can be delivered up the stack even if NAKACK or UNICAST are queuing up messages from a particular sender. OOB messages are often used internally by JGroups protocols and can be used by applications as well. For example, when JBoss Cache is in <code class="literal">REPL_SYNC</code> mode, it uses OOB messages for the second phase of its two-phase-commit protocol.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-transport-tcp">
      ⁠</a>28.1.2.2. TCP configuration</h3></div></div></div><div class="para">
					Alternatively, a JGroups-based cluster can also work over TCP connections. Compared with UDP, TCP generates more network traffic when the cluster size increases. TCP is fundamentally a unicast protocol. To send multicast messages, JGroups uses multiple TCP unicasts. To use TCP as a transport protocol, you should define a <code class="literal">TCP</code> element in the JGroups <code class="literal">config</code> element. Here is an example of the <code class="literal">TCP</code> element.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;TCP</span><span xmlns="" class="perl_Others"> singleton_name=</span><span xmlns="" class="perl_String">"tcp"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">        start_port=</span><span xmlns="" class="perl_String">"7800"</span><span xmlns="" class="perl_Others"> end_port=</span><span xmlns="" class="perl_String">"7800"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					The following attributes are specific to the <code class="literal">TCP</code> element:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">start_port</code> and <code class="literal">end_port</code> define the range of TCP ports to which the server should bind. The server socket is bound to the first available port beginning with <code class="literal">start_port</code>. If no available port is found (for example, because the ports are in use by other sockets) before the <code class="literal">end_port</code>, the server throws an exception. If no <code class="literal">end_port</code> is provided, or <code class="literal">end_port</code> is lower than <code class="literal">start_port</code>, no upper limit is applied to the port range. If <code class="literal">start_port</code> is equal to <code class="literal">end_port</code>, JGroups is forced to use the specified port, since <code class="literal">start_port</code> fails if the specified port in not available. The default value is <code class="literal">7800</code>. If set to <code class="literal">0</code>, the operating system will select a port. (This will only work for <code class="literal">MPING</code> or <code class="literal">TCPGOSSIP</code> discovery protocols. <code class="literal">TCCPING</code> requires that nodes and their required ports are listed.)
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_port</strong></span> in TCP acts as an alias for <code class="literal">start_port</code>. If configured internally, it sets <code class="literal">start_port</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>recv_buf_size, send_buf_size</strong></span> define receive and send buffer sizes. It is good to have a large receiver buffer size, so packets are less likely to get dropped due to buffer overflow.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>conn_expire_time</strong></span> specifies the time (in milliseconds) after which a connection can be closed by the reaper if no traffic has been received.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>reaper_interval</strong></span> specifies interval (in milliseconds) to run the reaper. If both values are 0, no reaping will be done. If either value is &gt; 0, reaping will be enabled. By default, reaper_interval is 0, which means no reaper.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>sock_conn_timeout</strong></span> specifies max time in milliseconds for a socket creation. When doing the initial discovery, and a peer hangs, do not wait forever but go on after the timeout to ping other members. Reduces chances of *not* finding any members at all. The default is 2000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>use_send_queues</strong></span> specifies whether to use separate send queues for each connection. This prevents blocking on write if the peer hangs. The default is true.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>external_addr</strong></span> specifies external IP address to broadcast to other group members (if different to local address). This is useful when you have use (Network Address Translation) NAT, e.g. a node on a private network, behind a firewall, but you can only route to it via an externally visible address, which is different from the local address it is bound to. Therefore, the node can be configured to broadcast its external address, while still able to bind to the local one. This avoids having to use the TUNNEL protocol, (and hence a requirement for a central gossip router) because nodes outside the firewall can still route to the node inside the firewall, but only on its external address. Without setting the external_addr, the node behind the firewall will broadcast its private address to the other nodes which will not be able to route to it.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>skip_suspected_members</strong></span> specifies whether unicast messages should not be sent to suspected members. The default is true.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tcp_nodelay</strong></span> specifies TCP_NODELAY. TCP by default nagles messages, that is, conceptually, smaller messages are bundled into larger ones. If we want to invoke synchronous cluster method calls, then we need to disable nagling in addition to disabling message bundling (by setting <code class="literal">enable_bundling</code> to false). Nagling is disabled by setting <code class="literal">tcp_nodelay</code> to true. The default is false.
						</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						All of the attributes common to all protocols discussed in the UDP protocol section also apply to TCP.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-transport-tunnel">
      ⁠</a>28.1.2.3. TUNNEL configuration</h3></div></div></div><div class="para">
					The <code class="literal">TUNNEL</code> protocol uses an external router process to send messages. The external router is a Java process that runs the <code class="literal">org.jgroups.stack.GossipRouter</code> main class. Each node has to register with the router. All messages are sent to the router and forwarded on to their destinations. The TUNNEL approach can be used to set up communication with nodes behind firewalls. A node can establish a TCP connection to the <code class="classname">GossipRouter</code> through the firewall (you can use port 80). This connection is also used by the router to send messages to nodes behind the firewall, as most firewalls do not permit outside hosts to initiate a TCP connection to a host inside the firewall. The <code class="literal">TUNNEL</code> configuration is defined in the <code class="literal">TUNNEL</code> element within the JGroups <code class="literal">&lt;config&gt;</code> element, like so:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;TUNNEL</span><span xmlns="" class="perl_Others">  singleton_name=</span><span xmlns="" class="perl_String">"tunnel"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">            router_port=</span><span xmlns="" class="perl_String">"12001"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">            router_host=</span><span xmlns="" class="perl_String">"192.168.5.1"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					The available attributes in the <code class="literal">TUNNEL</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>router_host</strong></span> specifies the host on which the GossipRouter is running.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>router_port</strong></span> specifies the port on which the GossipRouter is listening.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>reconnect_interval</strong></span> specifies the interval of time (in milliseconds) for which <code class="literal">TUNNEL</code> will attempt to connect to the <code class="classname">GossipRouter</code> if the connection is not established. The default value is <code class="literal">5000</code>.
						</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						All of the attributes common to all protocols discussed in the UDP protocol section also apply to <code class="literal">TUNNEL</code>.
					</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-discovery">
      ⁠</a>28.1.3. Discovery Protocols</h2></div></div></div><div class="para">
				When a channel on a node first connects, it must determine which other nodes are running compatible channels, and which of these nodes is currently acting as the <span class="emphasis"><em>coordinator</em></span> (the node responsible for letting new nodes join the group). Discovery protocols are used to find active nodes in the cluster and to determine which is the coordinator. This information is then provided to the group membership protocol (GMS), which communicates with the coordinator's GMS to add the newly-connecting node to the group. (For more information about group membership protocols, see <a class="xref" href="jgroups.chapt.html#jgroups-other-gms">Section 28.1.6, “Group Membership (GMS)”</a>.)
			</div><div class="para">
				Discovery protocols also assist merge protocols (see <a class="xref" href="jgroups.chapt.html#jgroups-other-merge">Section 28.5, “Merging (MERGE2)”</a>) to detect cluster-split situations.
			</div><div class="para">
				The discovery protocols sit on top of the transport protocol, so you can choose to use different discovery protocols depending on your transport protocol. These are also configured as sub-elements in the JGroups <code class="literal">&lt;config&gt;</code> element.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-discovery-ping">
      ⁠</a>28.1.3.1. PING</h3></div></div></div><div class="para">
					PING is a discovery protocol that works by either multicasting PING requests to an IP multicast address or connecting to a gossip router. As such, PING normally sits on top of the UDP or TUNNEL transport protocols. Each node responds with a packet {C, A}, where C=coordinator's address and A=own address. After timeout milliseconds or num_initial_members replies, the joiner determines the coordinator from the responses, and sends a JOIN request to it (handled by). If nobody responds, we assume we are the first member of a group.
				</div><div class="para">
					Here is an example PING configuration for IP multicast.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;PING</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"2000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    num_initial_members=</span><span xmlns="" class="perl_String">"3"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					Here is another example PING configuration for contacting a Gossip Router.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;PING</span><span xmlns="" class="perl_Others"> gossip_host=</span><span xmlns="" class="perl_String">"localhost"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">      gossip_port=</span><span xmlns="" class="perl_String">"1234"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">       timeout=</span><span xmlns="" class="perl_String">"2000"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">      num_initial_members=</span><span xmlns="" class="perl_String">"3"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					The available attributes in the <code class="literal">PING</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for num_initial_members responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the minimum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_host</strong></span> specifies the host on which the GossipRouter is running.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_port</strong></span> specifies the port on which the GossipRouter is listening on.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_refresh</strong></span> specifies the interval (in milliseconds) for the lease from the GossipRouter. The default is 20000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-separated list of addresses or ports (for example, <code class="literal">host1[12345],host2[23456]</code>) which are pinged for discovery. Default is <code class="literal">null</code>, meaning multicast discovery should be used. If <code class="literal">initial_hosts</code> is specified, you must list all possible cluster members, not just a few well-known hosts, or <code class="literal">MERGE2</code> cluster split discovery will not work reliably.
						</div></li></ul></div><div class="para">
					If both <code class="literal">gossip_host</code> and <code class="literal">gossip_port</code> are defined, the cluster uses the GossipRouter for the initial discovery. If the <code class="literal">initial_hosts</code> is specified, the cluster pings that static list of addresses for discovery. Otherwise, the cluster uses IP multicasting for discovery.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The discovery phase returns when the <code class="literal">timeout</code> ms have elapsed or the <code class="literal">num_initial_members</code> responses have been received.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-discovery-tcpgossip">
      ⁠</a>28.1.3.2. TCPGOSSIP</h3></div></div></div><div class="para">
					The TCPGOSSIP protocol only works with a GossipRouter. It works essentially the same way as the PING protocol configuration with valid <code class="literal">gossip_host</code> and <code class="literal">gossip_port</code> attributes. It works on top of both UDP and TCP transport protocols. Here is an example.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;TCPGOSSIP</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"2000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">       num_initial_members=</span><span xmlns="" class="perl_String">"3"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">       initial_hosts=</span><span xmlns="" class="perl_String">"192.168.5.1[12000],192.168.0.2[12000]"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					The available attributes in the <code class="literal">TCPGOSSIP</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for num_initial_members responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the minimum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-separated list of addresses/ports (for example, <code class="literal">host1[12345],host2[23456]</code>) of <code class="literal">GossipRouter</code>s to register
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-discovery-tcpping">
      ⁠</a>28.1.3.3. TCPPING</h3></div></div></div><div class="para">
					The TCPPING protocol takes a set of known members and pings them for discovery. The mechanism works on top of TCP.
				</div><div class="para">
					Here is an example of the <code class="literal">TCPPING</code> configuration element in the JGroups <code class="literal">config</code> element.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;TCPPING</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"2000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     num_initial_members=</span><span xmlns="" class="perl_String">"3"</span><span xmlns="" class="perl_Error">/</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     initial_hosts=</span><span xmlns="" class="perl_String">"hosta[2300],hostb[3400],hostc[4500]"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     max_dynamic_hosts=</span><span xmlns="" class="perl_String">"3"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     port_range=</span><span xmlns="" class="perl_String">"3"</span><span xmlns="" class="perl_Keyword">&gt;</span>
</pre><div class="para">
					The available attributes in the <code class="literal">TCPPING</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for num_initial_members responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the minimum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-separated list of addresses (for example, <code class="literal">host1[12345],host2[23456]</code>) for pinging.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max_dynamic_hosts</strong></span> specifies the maximum number of hosts that can be dynamically added to the cluster (defaults to <code class="literal">0</code>).
						</div><div class="para">
							If dynamic adding of hosts is not allowed, make sure you list all cluster members in the <span class="property">&lt;initial_hosts&gt;</span> attribute on all cluster members before adding the new node to the cluster, so that the nodes can be added on server start.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>port_range</strong></span> specifies the number of consecutive ports to be probed when getting the initial membership, starting with the port specified in the <code class="varname">initial_hosts</code> parameter. Given the current values of <code class="literal">port_range</code> and <code class="literal">initial_hosts</code> above, the <code class="literal">TCPPING</code> layer will try to connect to <code class="literal">hosta[2300]</code>, <code class="literal">hosta[2301]</code>, <code class="literal">hosta[2302]</code>, <code class="literal">hostb[3400]</code>, <code class="literal">hostb[3401]</code>, <code class="literal">hostb[3402]</code>, <code class="literal">hostc[4500]</code>, <code class="literal">hostc[4501]</code>, and <code class="literal">hostc[4502]</code>. This configuration option allows for multiple possible ports on the same host to be pinged without having to spell out all possible combinations. If in your TCP protocol configuration your <code class="literal">end_port</code> is greater than your <code class="literal">start_port</code>, we recommend using a TCPPING <code class="literal">port_range</code> equal to the difference, to ensure a node is pinged no matter which port it is bound to within the allowed range.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-discovery-mping">
      ⁠</a>28.1.3.4. MPING</h3></div></div></div><div class="para">
					<code class="literal">MPING</code> uses IP multicast to discover the initial membership. Unlike the other discovery protocols, which delegate the sending and receiving of discovery messages on the network to the transport protocol, <code class="literal">MPING</code> opens its own sockets to send and receive multicast discovery messages. As a result it can be used with all transports, but it is most often used with <code class="literal">TCP</code>. <code class="literal">TCP</code> usually requires <code class="literal">TCPPING</code>, which must explicitly list all possible group members. <code class="literal">MPING</code> does not have this requirement, and is typically used where <code class="literal">TCP</code> is required for regular message transport, and UDP multicasting is allowed for discovery.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;MPING</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"2000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    num_initial_members=</span><span xmlns="" class="perl_String">"3"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    bind_to_all_interfaces=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    mcast_addr=</span><span xmlns="" class="perl_String">"228.8.8.8"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    mcast_port=</span><span xmlns="" class="perl_String">"7500"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    ip_ttl=</span><span xmlns="" class="perl_String">"8"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					The available attributes in the <code class="literal">MPING</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for any responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the maximum number of responses to wait for unless timeout has expired. The default is 2..
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface on which to send and receive multicast packets. By default JGroups uses the value of the system property <code class="literal">jgroups.bind_addr</code>, which can be set with the <code class="code">-b</code> command line switch. See <a class="xref" href="jgroups.chapt.html#jgroups-other">Section 28.6, “Other Configuration Issues”</a> for more on binding JGroups sockets.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_to_all_interfaces</strong></span> overrides the <code class="literal">bind_addr</code> and uses all interfaces in multihome nodes.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_addr, mcast_port, ip_ttl</strong></span> attributes are the same as related attributes in the UDP protocol configuration.
						</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-fd">
      ⁠</a>28.1.4. Failure Detection Protocols</h2></div></div></div><div class="para">
				The failure detection protocols are used to detect failed nodes. Once a failed node is detected, a <span class="emphasis"><em>suspect verification</em></span> phase can occur. If the node is still considered dead after this phase is complete, the cluster updates its membership view so that further messages are not sent to the failed node. The service using JGroups is informed that the node is no longer part of the cluster. Failure detection protocols are configured as sub-elements in the JGroups <code class="literal">&lt;config&gt;</code> element.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-fd-fd">
      ⁠</a>28.1.4.1. FD</h3></div></div></div><div class="para">
					<code class="literal">FD</code> is a failure detection protocol based on 'heartbeat' messages. This protocol requires that each node periodically ping its neighbor. If the neighbor fails to respond, the calling node sends a <code class="literal">SUSPECT</code> message to the cluster. The current group coordinator can optionally verify that the suspected node is dead (<code class="literal">VERIFY_SUSPECT</code>). If the node is still considered dead after this verification step, the coordinator updates the cluster's membership view. The following is an example of <code class="literal">FD</code> configuration:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;FD</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"6000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    max_tries=</span><span xmlns="" class="perl_String">"5"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    shun=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					The available attributes in the <code class="literal">FD</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for the responses to the are-you-alive messages. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max_tries</strong></span> specifies the number of missed are-you-alive messages from a node before the node is suspected. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>shun</strong></span> specifies whether a failed node will be forbidden from sending messages to the group without formally rejoining. A shunned node would need to rejoin the cluster via the discovery process. JGroups allows applications to configure a channel such that, when a channel is shunned, the process of rejoining the cluster and transferring state takes place automatically. This is the default behavior of JBoss Enterprise Application Platform.
						</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Regular traffic from a node is proof of life, so heartbeat messages are only sent when no regular traffic is detected on the node for a long period of time.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-fd-fdsock">
      ⁠</a>28.1.4.2. FD_SOCK</h3></div></div></div><div class="para">
					<code class="literal">FD_SOCK</code> is a failure detection protocol based on a ring of TCP sockets created between group members. Each member in a group connects to its neighbor, with the final member connecting to the first, forming a ring. Node B becomes suspected when its neighbor, Node A, detects an abnormally closed TCP socket, presumably due to a crash in Node B. (When nodes intend to leave the group, they inform their neighbors so that they do not become suspected.)
				</div><div class="para">
					The simplest <code class="literal">FD_SOCK</code> configuration does not take any attribute. You can declare an empty <code class="literal">FD_SOCK</code> element in the JGroups <code class="literal">&lt;config&gt;</code> element.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;FD_SOCK/&gt;</span>
</pre><div class="para">
					The attributes available to the <code class="literal">FD_SOCK</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface to which the server socket should be bound. By default, JGroups uses the value of the system property <code class="literal">jgroups.bind_addr</code>. This system property can be set with the <code class="code">-b</code> command line switch. For more information about binding JGroups sockets, see <a class="xref" href="jgroups.chapt.html#jgroups-other">Section 28.6, “Other Configuration Issues”</a>.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776734033376">
      ⁠</a>28.1.4.3. VERIFY_SUSPECT</h3></div></div></div><div class="para">
					This protocol verifies whether a suspected member is really dead by pinging that member once again. This verification is performed by the coordinator of the cluster. The suspected member is dropped from the cluster group if confirmed to be dead. The aim of this protocol is to minimize false suspicions. Here's an example.
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;VERIFY_SUSPECT</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"1500"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					The available attributes in the <code class="literal">VERIFY_SUSPECT</code> element are listed below.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies how long to wait for a response from the suspected member before considering it dead.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776764331120">
      ⁠</a>28.1.4.4. FD versus FD_SOCK</h3></div></div></div><div class="para">
					FD and FD_SOCK, each taken individually, do not provide a solid failure detection layer. Let us look at the differences between these failure detection protocols to understand how they complement each other:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="emphasis"><em>FD</em></span>
						</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
									An overloaded machine might be slow in sending are-you-alive responses.
								</div></li><li class="listitem"><div class="para">
									A member will be suspected when suspended in a debugger/profiler.
								</div></li><li class="listitem"><div class="para">
									Low timeouts lead to higher probability of false suspicions and higher network traffic.
								</div></li><li class="listitem"><div class="para">
									High timeouts will not detect and remove crashed members for some time.
								</div></li></ul></div></li><li class="listitem"><div class="para">
							<span class="emphasis"><em>FD_SOCK</em></span>:
						</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
									Suspended in a debugger is no problem because the TCP connection is still open.
								</div></li><li class="listitem"><div class="para">
									High load no problem either for the same reason.
								</div></li><li class="listitem"><div class="para">
									Members will only be suspected when TCP connection breaks, so hung members will not be detected.
								</div></li><li class="listitem"><div class="para">
									Also, a crashed switch will not be detected until the connection runs into the TCP timeout (between 2-20 minutes, depending on TCP/IP stack implementation).
								</div></li></ul></div></li></ul></div><div class="para">
					A failure detection layer is intended to report real failures promptly, while avoiding false suspicions. There are two solutions:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
							By default, JGroups configures the FD_SOCK socket with KEEP_ALIVE, which means that TCP sends a heartbeat on socket on which no traffic has been received in 2 hours. If a host crashed (or an intermediate switch or router crashed) without closing the TCP connection properly, we would detect this after 2 hours (plus a few minutes). This is of course better than never closing the connection (if KEEP_ALIVE is off), but may not be of much help. So, the first solution would be to lower the timeout value for KEEP_ALIVE. This can only be done for the entire kernel in most operating systems, so if this is lowered to 15 minutes, this will affect all TCP sockets.
						</div></li><li class="listitem"><div class="para">
							The second solution is to combine FD_SOCK and FD; the timeout in FD can be set such that it is much lower than the TCP timeout, and this can be configured individually per process. FD_SOCK will already generate a suspect message if the socket was closed abnormally. However, in the case of a crashed switch or host, FD will make sure the socket is eventually closed and the suspect message generated. Example:
						</div></li></ol></div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;FD_SOCK/&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;FD</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"6000"</span><span xmlns="" class="perl_Others"> max_tries=</span><span xmlns="" class="perl_String">"5"</span><span xmlns="" class="perl_Others"> shun=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;VERIFY_SUSPECT</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"1500"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					In this example, a member becomes suspected when the neighboring socket has been closed abnormally, in a process crash, for instance, since the operating system closes all sockets. However, if a host or switch crashes, the sockets will not be closed. <code class="literal">FD</code> will suspect the neighbor after sixty seconds (<code class="literal">6000</code> milliseconds). Note that if this example system were stopped in a breakpoint in the debugger, the node being debugged will be suspected once the <code class="varname">timeout</code> has elapsed.
				</div><div class="para">
					A combination of <code class="literal">FD</code> and <code class="literal">FD_SOCK</code> provides a solid failure detection layer, which is why this technique is used across the JGroups configurations included with JBoss Enterprise Application Platform.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-reliable">
      ⁠</a>28.1.5. Reliable Delivery Protocols</h2></div></div></div><div class="para">
				Reliable delivery protocols within the JGroups stack ensure that messages are actually delivered, and delivered in the correct order (First In, First Out, or FIFO) to the destination node. The basis for reliable message delivery is positive and negative delivery acknowledgments (ACK and NAK). In <code class="literal">ACK</code> mode, the sender resends the message until acknowledgment is received from the receiver. In <code class="literal">NAK</code> mode, the receiver requests re-transmission when it discovers a gap.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-reliable-unicast">
      ⁠</a>28.1.5.1. UNICAST</h3></div></div></div><div class="para">
					The <code class="literal">UNICAST</code> protocol is used for unicast messages. It uses positive acknowledgements (<code class="literal">ACK</code>). It is configured as a sub-element under the JGroups <code class="literal">config</code> element. If the JGroups stack is configured with the TCP transport protocol, <code class="literal">UNICAST</code> is not necessary because TCP itself guarantees FIFO delivery of unicast messages. Here is an example configuration for the <code class="literal">UNICAST</code> protocol:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;UNICAST</span><span xmlns="" class="perl_Others"> timeout=</span><span xmlns="" class="perl_String">"300,600,1200,2400,3600"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					There is only one configurable attribute in the <code class="literal">UNICAST</code> element.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the re-transmission timeout (in milliseconds). For instance, if the timeout is <code class="literal">100,200,400,800</code>, the sender resends the message if it has not received an <code class="literal">ACK</code> after 100 milliseconds the first time, and the second time it waits for 200 milliseconds before re-sending, and so on. A low value for the first timeout allows for prompt re-transmission of dropped messages, but means that messages may be transmitted more than once if they have not actually been lost (that is, the message has been sent, but the <code class="literal">ACK</code> has not been received before the timeout). High values (<code class="literal">1000,2000,3000</code>) can improve performance if the network is tuned such that UDP datagram loss is infrequent. High values on networks with frequent losses will be harmful to performance, since later messages will not be delivered until lost messages have been re-transmitted.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-reliable-nakack">
      ⁠</a>28.1.5.2. NAKACK</h3></div></div></div><div class="para">
					The <code class="literal">NAKACK</code> protocol is used for multicast messages. It uses negative acknowledgements (<code class="literal">NAK</code>). Under this protocol, each message is tagged with a sequence number. The receiver keeps track of the received sequence numbers and delivers the messages in order. When a gap in the series of received sequence numbers is detected, the receiver schedules a task to periodically ask the sender to re-transmit the missing message. The task is canceled if the missing message is received. <code class="literal">NAKACK</code> protocol is configured as the <code class="literal">pbcast.NAKACK</code> sub-element under the JGroups <code class="literal">&lt;config&gt;</code> element. Here is an example configuration:
				</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;pbcast.NAKACK</span><span xmlns="" class="perl_Others"> max_xmit_size=</span><span xmlns="" class="perl_String">"60000"</span><span xmlns="" class="perl_Others"> use_mcast_xmit=</span><span xmlns="" class="perl_String">"false"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   retransmit_timeout=</span><span xmlns="" class="perl_String">"300,600,1200,2400,4800"</span><span xmlns="" class="perl_Others"> gc_lag=</span><span xmlns="" class="perl_String">"0"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   discard_delivered_msgs=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
					The configurable attributes in the <code class="literal">pbcast.NAKACK</code> element are as follows.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>re-transmit_timeout</strong></span> specifies the series of timeouts (in milliseconds) after which re-transmission is requested if a missing message has not yet been received.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>use_mcast_xmit</strong></span> determines whether the sender should send the re-transmission to the entire cluster rather than just to the node requesting it. This is useful when the <span class="emphasis"><em>sender</em></span>'s network layer tends to drop packets, avoiding the need to individually re-transmit to each node.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max_xmit_size</strong></span> specifies the maximum size (in bytes) for a bundled re-transmission, if multiple messages are reported missing.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>discard_delivered_msgs</strong></span> specifies whether to discard delivered messages on the receiver nodes. By default, nodes save delivered messages so any node can re-transmit a lost message in case the original sender has crashed or left the group. However, if we only ask the sender to resend its messages, we can enable this option and discard delivered messages.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gc_lag</strong></span> specifies the number of messages to keep in memory for re-transmission, even after the periodic cleanup protocol (see <a class="xref" href="jgroups.chapt.html#jgroups-other-gc">Section 28.4, “Distributed Garbage Collection (STABLE)”</a>) indicates all peers have received the message. The default value is <code class="literal">20</code>.
						</div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-other-gms">
      ⁠</a>28.1.6. Group Membership (GMS)</h2></div></div></div><div class="para">
				The group membership service (GMS) protocol in the JGroups stack maintains a list of active nodes. It handles the requests to join and leave the cluster. It also handles the SUSPECT messages sent by failure detection protocols. All nodes in the cluster, as well as any interested services like JBoss Cache or HAPartition, are notified if the group membership changes. The group membership service is configured in the <code class="literal">pbcast.GMS</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;pbcast.GMS</span><span xmlns="" class="perl_Others"> print_local_addr=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    join_timeout=</span><span xmlns="" class="perl_String">"3000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    join_retry_timeout=</span><span xmlns="" class="perl_String">"2000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    shun=</span><span xmlns="" class="perl_String">"true"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    view_bundling=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
				The configurable attributes in the <code class="literal">pbcast.GMS</code> element are as follows.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>join_timeout</strong></span> specifies the maximum number of milliseconds to wait for a new node JOIN request to succeed. Retry afterwards.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>join_retry_timeout</strong></span> specifies the number of milliseconds to wait after a failed JOIN before trying again.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>print_local_addr</strong></span> specifies whether to dump the node's own address to the standard output when started.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>shun</strong></span> specifies whether a node should shun (that is, disconnect) itself if it receives a cluster view in which it is not a member node.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>disable_initial_coord</strong></span> specifies whether to prevent this node from becoming the cluster coordinator during the initial connection of the channel. This flag does not prevent a node becoming the coordinator after the initial channel connection, if the current coordinator leaves the group.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>view_bundling</strong></span> specifies whether multiple JOIN or LEAVE requests arriving at the same time are bundled and handled together at the same time, resulting in only one new view that incorporates all changes. This is more efficient than handling each request separately.
					</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-other-fc">
      ⁠</a>28.1.7. Flow Control (FC)</h2></div></div></div><div class="para">
				The flow control (FC) protocol tries to adapt the data sending rate to the data receipt rate among nodes. If a sender node is too fast, it might overwhelm the receiver node and result in out-of-memory conditions or dropped packets that have to be re-transmitted. In JGroups, flow control is implemented via a credit-based system. The sender and receiver nodes have the same number of credits (bytes) to start with. The sender subtracts credits by the number of bytes in messages it sends. The receiver accumulates credits for the bytes in the messages it receives. When the sender's credit drops to a threshold, the receivers send some credit to the sender. If the sender's credit is used up, the sender blocks until it receives credits from the receiver. The flow control protocol is configured in the <code class="literal">FC</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;FC</span><span xmlns="" class="perl_Others"> max_credits=</span><span xmlns="" class="perl_String">"2000000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    min_threshold=</span><span xmlns="" class="perl_String">"0.10"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    ignore_synchronous_response=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
				The configurable attributes in the <code class="literal">FC</code> element are as follows.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>max_credits</strong></span> specifies the maximum number of credits (in bytes). This value should be smaller than the JVM heap size.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>min_credits</strong></span> specifies the minimum number of bytes that must be received before the receiver will send more credits to the sender.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>min_threshold</strong></span> specifies the percentage of the <code class="literal">max_credits</code> that should be used to calculate <code class="literal">min_credits</code>. Setting this overrides the <code class="literal">min_credits</code> attribute.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>ignore_synchronous_response</strong></span> specifies whether threads that have carried messages up to the application should be allowed to carry outgoing messages back down through FC without blocking for credits. <span class="emphasis"><em>Synchronous response</em></span> refers to the fact that these messages are generally responses to incoming RPC-type messages. Forbidding JGroups threads to carry messages up to block in FC can help prevent certain deadlock scenarios, so we recommend setting this to <code class="literal">true</code>.
					</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Why is FC needed on top of TCP ? TCP has its own flow control!</strong></p></div><div class="admonition"><div class="para">
					FC is required for group communication where group messages must be sent at the highest speed that the slowest receiver can handle. For example, say we have a cluster comprised of nodes A, B, C and D. D is slow (perhaps overloaded), while the rest are fast. When A sends a group message, it does so via TCP connections: A-A (theoretically), A-B, A-C and A-D.
				</div><div class="para">
					Say A sends 100 million messages to the cluster. TCP's flow control applies to A-B, A-C and A-D individually, but not to A-BCD as a group. Therefore, A, B and C will receive the 100 million messages, but D will receive only 1 million. (This is also why <code class="literal">NAKACK</code> is required, even though TCP handles its own re-transmission.)
				</div><div class="para">
					JGroups must buffer all messages in memory in case an original sender <span class="emphasis"><em>S</em></span> dies and a node requests re-transmission of a message sent by <span class="emphasis"><em>S</em></span>. Since all members buffer all messages that they receive, stable messages (messages seen by every node) must sometimes be purged. (The purging process is managed by the <code class="literal">STABLE</code> protocol. For more information, see <a class="xref" href="jgroups.chapt.html#jgroups-other-gc">Section 28.4, “Distributed Garbage Collection (STABLE)”</a>.)
				</div><div class="para">
					In the above case, the slow node D will prevent the group from purging messages above 1M, so every member will buffer 99M messages ! This in most cases leads to OOM exceptions. Note that - although the sliding window protocol in TCP will cause writes to block if the window is full - we assume in the above case that this is still much faster for A-B and A-C than for A-D.
				</div><div class="para">
					So, in summary, even with TCP we need to FC to ensure we send messages at a rate the slowest receiver (D) can handle.
				</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>So do I always need FC?</strong></p></div><div class="admonition"><div class="para">
					This depends on how the application uses the JGroups channel. Referring to the example above, if there was something about the application that would naturally cause A to slow down its rate of sending because D was not keeping up, then FC would not be needed.
				</div><div class="para">
					A good example of such an application is one that uses JGroups to make synchronous group RPC calls. By synchronous, we mean the thread that makes the call blocks waiting for responses from all the members of the group. In that kind of application, the threads on A that are making calls would block waiting for responses from D, thus naturally slowing the overall rate of calls.
				</div><div class="para">
					A JBoss Cache cluster configured for REPL_SYNC is a good example of an application that makes synchronous group RPC calls. If a channel is only used for a cache configured for REPL_SYNC, we recommend you remove FC from its protocol stack.
				</div><div class="para">
					And, of course, if your cluster only consists of two nodes, including FC in a TCP-based protocol stack is unnecessary. There is no group beyond the single peer-to-peer relationship, and TCP's internal flow control will handle that just fine.
				</div><div class="para">
					Another case where FC may not be needed is for a channel used by a JBoss Cache configured for buddy replication and a single buddy. Such a channel will in many respects act like a two node cluster, where messages are only exchanged with one other node, the buddy. (There may be other messages related to data gravitation that go to all members, but in a properly engineered buddy replication use case these should be infrequent. But if you remove FC be sure to load test your application.)
				</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139776724302960">
      ⁠</a>28.2. Fragmentation (FRAG2)</h1></div></div></div><div class="para">
			This protocol fragments messages that are larger than a certain size, and reassembles them at the receiver's side. It works for both unicast and multicast messages. It is configured with the <code class="literal">FRAG2</code> sub-element in the JGroups <code class="literal">config</code> element. Here is an example configuration:
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;FRAG2</span><span xmlns="" class="perl_Others"> frag_size=</span><span xmlns="" class="perl_String">"60000"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
			The configurable attributes in the FRAG2 element are as follows.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>frag_size</strong></span> specifies the maximum message size (in bytes) before fragmentation occurs. Messages larger than this size are fragmented. For stacks that use the UDP transport, this value must be lower than 64 kilobytes (the maximum UDP datagram size). For TCP-based stacks, it must be lower than the value of <code class="varname">max_credits</code> in the FC protocol.
				</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				TCP protocol already provides fragmentation, but a JGroups fragmentation protocol is still required if FC is used. The reason for this is that if you send a message larger than <code class="literal">FC.max_credits</code>, the FC protocol will block forever. So, <code class="literal">frag_size</code> within FRAG2 must always be set to a value lower than that of <code class="literal">FC.max_credits</code>.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups-other-st">
      ⁠</a>28.3. State Transfer</h1></div></div></div><div class="para">
			The state transfer service transfers the state from an existing node (i.e., the cluster coordinator) to a newly joining node. It is configured in the <code class="literal">pbcast.STATE_TRANSFER</code> sub-element under the JGroups <code class="literal">Config</code> element. It does not have any configurable attribute. Here is an example configuration.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;pbcast.STATE_TRANSFER/&gt;</span>
</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups-other-gc">
      ⁠</a>28.4. Distributed Garbage Collection (STABLE)</h1></div></div></div><div class="para">
			In a JGroups cluster, all nodes must store all messages received for potential re-transmission in case of a failure. However, if we store all messages forever, we will run out of memory. The distributed garbage collection service periodically purges messages that have been seen by all nodes, removing them from the memory in each node. The distributed garbage collection service is configured in the <code class="literal">pbcast.STABLE</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;pbcast.STABLE</span><span xmlns="" class="perl_Others"> stability_delay=</span><span xmlns="" class="perl_String">"1000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    desired_avg_gossip=</span><span xmlns="" class="perl_String">"5000"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    max_bytes=</span><span xmlns="" class="perl_String">"400000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
			The configurable attributes in the <code class="literal">pbcast.STABLE</code> element are as follows.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>desired_avg_gossip</strong></span> specifies intervals (in milliseconds) of garbage collection runs. Set this to <code class="literal">0</code> to disable interval-based garbage collection.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>max_bytes</strong></span> specifies the maximum number of bytes received before the cluster triggers a garbage collection run. Set to <code class="literal">0</code> to disable garbage collection based on the bytes received.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>stability_delay</strong></span> specifies the maximum time period (in milliseconds) of a random delay introduced before a node sends its <code class="literal">STABILITY</code> message at the end of a garbage collection run. The delay gives other nodes concurrently running a <code class="literal">STABLE</code> task a chance to send first. If used together with <code class="literal">max_bytes</code>, this attribute should be set to a small number.
				</div></li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Set the <code class="literal">max_bytes</code> attribute when you have a high traffic cluster.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups-other-merge">
      ⁠</a>28.5. Merging (MERGE2)</h1></div></div></div><div class="para">
			When a network error occurs, the cluster might be partitioned into several different partitions. JGroups has a MERGE service that allows the coordinators in partitions to communicate with each other and form a single cluster back again. The merging service is configured in the <code class="literal">MERGE2</code> sub-element under the JGroups <code class="literal">Config</code> element. Here is an example configuration.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;MERGE2</span><span xmlns="" class="perl_Others"> max_interval=</span><span xmlns="" class="perl_String">"10000"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">    min_interval=</span><span xmlns="" class="perl_String">"2000"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
			The configurable attributes in the <code class="literal">MERGE2</code> element are as follows.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>max_interval</strong></span> specifies the maximum number of milliseconds to wait before sending a MERGE message.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>min_interval</strong></span> specifies the minimum number of milliseconds to wait before sending a MERGE message.
				</div></li></ul></div><div class="para">
			JGroups chooses a random value between <code class="literal">min_interval</code> and <code class="literal">max_interval</code> to periodically send the MERGE message.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The application state maintained by the application using a channel is not merged by JGroups during a merge. This must be done by the application.
			</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If <code class="literal">MERGE2</code> is used in conjunction with <code class="literal">TCPPING</code>, the <code class="literal">initial_hosts</code> attribute must contain all the nodes that could potentially be merged back, in order for the merge process to work properly. Otherwise, the merge process may not detect all sub-groups, and may miss those comprised solely of unlisted members.
			</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jgroups-other">
      ⁠</a>28.6. Other Configuration Issues</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776746050544">
      ⁠</a>28.6.1. Binding JGroups Channels to a Particular Interface</h2></div></div></div><div class="para">
				In the Transport Protocols section above, we briefly touched on how the interface to which JGroups will bind sockets is configured. Let us get into this topic in more depth:
			</div><div class="para">
				First, it is important to understand that the value set in any <code class="literal">bind_addr</code> element in an XML configuration file will be ignored by JGroups if it finds that the system property <code class="literal">jgroups.bind_addr</code> (or a deprecated earlier name for the same thing, <code class="literal">bind.address</code>) has been set. The system property has a higher priority level than the XML property. If JBoss Enterprise Application Platform is started with the <code class="literal">-b</code> (or <code class="literal">--host</code>) switch, the application server will set <code class="literal">jgroups.bind_addr</code> to the specified value. If <code class="literal">-b</code> is not set, the application server will bind most services to <code class="literal">localhost</code> by default.
			</div><div class="para">
				So, what are <span class="emphasis"><em>best practices</em></span> for managing how JGroups binds to interfaces?
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Binding JGroups to the same interface as other services. Simple, just use <code class="literal">-b</code>:
					</div><pre class="screen">./run.sh -b 192.168.1.100 -c production</pre></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to one interface, but use a different one for JGroups:
					</div><pre class="screen">./run.sh -b 10.0.0.100 -Djgroups.bind_addr=192.168.1.100 -c production</pre><div class="para">
						Specifically setting the system property overrides the <code class="literal">-b</code> value. This is a common usage pattern; put client traffic on one network, with intra-cluster traffic on another.
					</div></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to all interfaces. This can be done like this: 
<pre class="screen">./run.sh -b 0.0.0.0 -c production</pre>
						 However, doing this will not cause JGroups to bind to all interfaces! Instead, JGroups will bind to the machine's default interface. See the Transport Protocols section for how to tell JGroups to receive or send on all interfaces, if that is what you really want.
					</div></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to all interfaces, but specify the JGroups interface:
					</div><pre class="screen">./run.sh -b 0.0.0.0 -Djgroups.bind_addr=192.168.1.100 -c production</pre><div class="para">
						Again, specifically setting the system property overrides the <code class="literal">-b</code> value.
					</div></li><li class="listitem"><div class="para">
						Using different interfaces for different channels:
					</div><pre class="screen">./run.sh -b 10.0.0.100 -Djgroups.ignore.bind_addr=true -c production</pre></li></ul></div><div class="para">
				This setting tells JGroups to ignore the <code class="literal">jgroups.bind_addr</code> system property, and instead use whatever is specified in XML. You would need to edit the various XML configuration files to set the various <code class="literal">bind_addr</code> attributes to the desired interfaces.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="clustering-jgroups-isolation">
      ⁠</a>28.6.2. Isolating JGroups Channels</h2></div></div></div><div class="para">
				Within JBoss Enterprise Application Platform, there are a number of services that independently create JGroups channels — possibly multiple different JBoss Cache services (used for <code class="literal">HttpSession</code> replication, EJB3 stateful session bean replication and EJB3 entity replication), two JBoss Messaging channels, and <span class="application"><strong>HAPartition</strong></span>, the general purpose clustering service that underlies most other JBossHA services.
			</div><div class="para">
				It is critical that these channels only communicate with their intended peers; not with the channels used by other services and not with channels for the same service opened on machines not meant to be part of the group. Nodes improperly communicating with each other is one of the most common issues users have with JBoss Enterprise Application Platform clustering.
			</div><div class="para">
				Whom a JGroups channel will communicate with is defined by its group name and, for UDP-based channels, its multicast address and port. Isolating a JGroups channel means ensuring that different channels use different values for the group name, the multicast address and, in some cases, the multicast port.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776734340848">
      ⁠</a>28.6.2.1. Isolating Sets of JBoss Enterprise Application Platform Instances from Each Other</h3></div></div></div><div class="para">
					This section addresses the issue of having multiple independent clusters running within the same environment. For example, you might have a production cluster, a staging cluster, and a QA cluster, or multiple clusters in a QA test lab or development team environment.
				</div><div class="para">
					To isolate JGroups clusters from other clusters on the network, you must:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							Make sure the channels in the various clusters use different group names. This can be controlled with the command line arguments used to start JBoss Enterprise Application Platform; see <a class="xref" href="jgroups.chapt.html#clustering-jgroups-isolation-group-name">Section 28.6.2.2.1, “Changing the Group Name”</a> for more information.
						</div></li><li class="listitem"><div class="para">
							Make sure the channels in the various clusters use different multicast addresses. This is also easy to control with the command line arguments used to start JBoss.
						</div></li><li class="listitem"><div class="para">
							If you are not running on Linux, Windows, Solaris or HP-UX, you may also need to ensure that the channels in each cluster use different multicast ports. This is more difficult than using different group names, although it can still be controlled from the command line. See <a class="xref" href="jgroups.chapt.html#clustering-jgroups-isolation-mcast_port">Section 28.6.2.2.3, “Changing the Multicast Port”</a>. Note that using different ports should not be necessary if your servers are running on Linux, Windows, Solaris or HP-UX.
						</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776756784688">
      ⁠</a>28.6.2.2. Isolating Channels for Different Services on the Same Set of JBoss Enterprise Application Platform Instances</h3></div></div></div><div class="para">
					This section addresses the usual case: a cluster of three machines, each of which has, for example, an HAPartition deployed alongside JBoss Cache for web session clustering. The HAPartition channels should not communicate with the JBoss Cache channels. Ensuring proper isolation of these channels is straightforward, and is usually handled by the application server without any alterations on the part of the user.
				</div><div class="para">
					To isolate channels for different services from each other on the same set of application server instances, each channel must have its own group name. The configurations that ship with JBoss Enterprise Application Platform ensure that this is the case. However, if you create a custom service that uses JGroups directly, you must use a unique group name. If you create a custom JBoss Cache configuration, ensure that you provide a unique value in the <code class="literal">clusterName</code> configuration property.
				</div><div class="para">
					In releases prior to JBoss Enterprise Application Platform 5, different channels running in the same application server also had to use unique multicast ports. With the JGroups shared transport introduced in JBoss Enterprise Application Platform 5 (see <a class="xref" href="clustering-blocks.chapt.html#clustering-blocks-jgroups-sharedtransport">Section 21.1.2, “The JGroups Shared Transport”</a>), it is now common for multiple channels to use the same transport protocol and its sockets. This makes configuration easier, which is one of the main benefits of the shared transport. However, if you decide to create your own custom JGroups protocol stack configuration, be sure to configure its transport protocols with a multicast port that is different from the ports used in other protocol stacks.
				</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="clustering-jgroups-isolation-group-name">
      ⁠</a>28.6.2.2.1. Changing the Group Name</h4></div></div></div><div class="para">
						The group name for a JGroups channel is configured via the service that starts the channel. For all the standard clustered services, we make it easy for you to create unique groups names by simply using the <code class="literal">-g</code> (or <code class="literal">--partition</code>) switch when starting JBoss:
					</div><pre class="screen">./run.sh -g QAPartition -b 192.168.1.100 -c production</pre><div class="para">
						This switch sets the <code class="literal">jboss.partition.name</code> system property, which is used as a component in the configuration of the group name in all the standard clustering configuration files. For example, 
<pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;property</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"clusterName"</span><span xmlns="" class="perl_Keyword">&gt;</span>${jboss.partition.name:DefaultPartition}-SFSBCache<span xmlns="" class="perl_Keyword">&lt;/property&gt;</span></pre>

					</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm139776736214896">
      ⁠</a>28.6.2.2.2. Changing the multicast address and port</h4></div></div></div><div class="para">
						The <code class="literal">-u</code> (or <code class="literal">--udp</code>) command line switch may be used to control the multicast address used by the JGroups channels opened by all standard JBoss Enterprise Application Platform services. 
<pre class="screen">/run.sh -u 230.1.2.3 -g QAPartition -b 192.168.1.100 -c production</pre>
						 This switch sets the <code class="literal">jboss.partition.udpGroup</code> system property, which is referenced in all of the standard protocol stack configurations in JBoss Enterprise Application Platform:
					</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;UDP</span><span xmlns="" class="perl_Others"> mcast_addr=</span><span xmlns="" class="perl_String">"${jboss.partition.udpGroup:228.1.2.3}"</span> <span xmlns="" class="perl_Error">....</span></pre><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Why is changing the group name insufficient?</strong></p></div><div class="admonition"><div class="para">
							If channels with different group names share the same multicast address and port, the lower level JGroups protocols in each channel will see, process and eventually discard messages intended for the other group. This will at a minimum hurt performance and can lead to anomalous behavior.
						</div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="clustering-jgroups-isolation-mcast_port">
      ⁠</a>28.6.2.2.3. Changing the Multicast Port</h4></div></div></div><div class="para">
						On some operating systems (Mac OS X for example), using different <code class="literal">-g</code> and <code class="literal">-u</code> values is not sufficient to isolate clusters; the channels running in the different clusters must also use different multicast ports. Unfortunately, setting the multicast ports is not as simple as <code class="literal">-g</code> and <code class="literal">-u</code>. By default, a JBoss Enterprise Application Platform instance running the <code class="literal">production</code> configuration will use up to two different instances of the JGroups UDP transport protocol, and will therefore open two multicast sockets. You can control the ports those sockets use by using system properties on the command line. For example,
					</div><pre class="programlisting">
/run.sh -u 230.1.2.3 -g QAPartition -b 192.168.1.100 -c production \\
        -Djboss.jgroups.udp.mcast_port=12345 -Djboss.messaging.datachanneludpport=23456
</pre><div class="para">
						The <code class="literal">jboss.messaging.datachanneludpport</code> property controls the multicast port used by the <code class="literal">MPING</code> protocol in JBoss Messaging's <code class="literal">DATA</code> channel. The <code class="literal">jboss.jgroups.udp.mcast_port</code> property controls the multicast port used by the UDP transport protocol shared by all other clustered services.
					</div><div class="para">
						The set of JGroups protocol stack configurations included in the <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/production/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file includes a number of other example protocol stack configurations that the standard JBoss Enterprise Application Platform distribution does not actually use. Those configurations also use system properties to set any multicast ports. So, if you reconfigure a JBoss Enterprise Application Platform service to use one of those protocol stack configurations, use the appropriate system property to control the port from the command line.
					</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Why do I need to change the multicast port if I change the address?</strong></p></div><div class="admonition"><div class="para">
							It should be sufficient to just change the address, but unfortunately the handling of multicast sockets is one area where the JVM fails to hide operating system behavior differences from the application. The <code class="literal">java.net.MulticastSocket</code> class provides different overloaded constructors. On some operating systems, if you use one constructor variant, packets addressed to a particular multicast port are delivered to all listeners on that port, regardless of the multicast address on which they are listening. We refer to this as the <span class="emphasis"><em>promiscuous traffic</em></span> problem. On most operating systems that exhibit the promiscuous traffic problem (Linux, Solaris and HP-UX) JGroups can use a different constructor variant that avoids the problem. However, on some operating systems with the promiscuous traffic problem (Mac OS X), multicast does not work properly if the other constructor variant is used. So, on these operating systems the recommendation is to configure different multicast ports for different clusters.
						</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-perf-udpbuffer">
      ⁠</a>28.6.2.3. Improving UDP Performance by Configuring OS UDP Buffer Limits</h3></div></div></div><div class="para">
					By default, the JGroups channels in JBoss Enterprise Application Platform use the UDP transport protocol to take advantage of IP multicast. However, one disadvantage of UDP is it does not come with the reliable delivery guarantees provided by TCP. The protocols discussed in <a class="xref" href="jgroups.chapt.html#jgroups-reliable">Section 28.1.5, “Reliable Delivery Protocols”</a> allow JGroups to guarantee delivery of UDP messages, but those protocols are implemented in Java, not at the operating system network layer. For peak performance from a UDP-based JGroups channel it is important to limit the need for JGroups to re-transmit messages by limiting UDP datagram loss.
				</div><div class="para">
					One of the most common causes of lost UDP datagrams is an undersized receive buffer on the socket. The UDP protocol's <code class="literal">mcast_recv_buf_size</code> and <code class="literal">ucast_recv_buf_size</code> configuration attributes are used to specify the amount of receive buffer JGroups <span class="emphasis"><em>requests</em></span> from the operating system, but the actual size of the buffer the operating system provides is limited by operating system-level maximums. These maximums are often very low:
				</div><div class="table"><a id="idm139776751179776">
      ⁠</a><p class="title"><strong>Table 28.1. Default Max UDP Buffer Sizes</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Default Max UDP Buffer Sizes"><colgroup><col/><col/></colgroup><thead><tr><th> Operating System </th><th> Default Max UDP Buffer (in bytes) </th></tr></thead><tbody><tr><td> Linux </td><td> 131071 </td></tr><tr><td> Windows </td><td> No known limit </td></tr><tr><td> Solaris </td><td> 262144 </td></tr><tr><td> FreeBSD, Darwin </td><td> 262144 </td></tr><tr><td> AIX </td><td> 1048576 </td></tr></tbody></table></div></div><div class="para">
					The command used to increase the above limits is operating system-specific. The table below shows the command required to increase the maximum buffer to 25 megabytes. In all cases, root privileges are required:
				</div><div class="table"><a id="idm139776752903360">
      ⁠</a><p class="title"><strong>Table 28.2. Commands to Change Max UDP Buffer Sizes</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Commands to Change Max UDP Buffer Sizes"><colgroup><col/><col/></colgroup><thead><tr><th> Operating System </th><th> Command </th></tr></thead><tbody><tr><td> Linux </td><td> <code class="literal">sysctl -w net.core.rmem_max=26214400</code> </td></tr><tr><td> Solaris </td><td> <code class="literal">ndd -set /dev/udp udp_max_buf 26214400</code> </td></tr><tr><td> FreeBSD, Darwin </td><td> <code class="literal">sysctl -w kern.ipc.maxsockbuf=26214400</code> </td></tr><tr><td> AIX </td><td> <code class="literal">no -o sb_max=8388608</code> (AIX will only allow 1 megabyte, 4 megabytes or 8 megabytes). </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139776736812352">
      ⁠</a>28.6.3. JGroups Troubleshooting</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776736811552">
      ⁠</a>28.6.3.1. Nodes do not form a cluster</h3></div></div></div><div class="para">
					Make sure your machine is set up correctly for IP multicast. There are 2 test programs that can be used to detect this: McastReceiverTest and McastSenderTest. Go to the <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/server/production/lib</code> directory and start McastReceiverTest, for example: 
<pre class="screen">[lib]$ java -cp jgroups.jar org.jgroups.tests.McastReceiverTest -mcast_addr 224.10.10.10 -port 5555</pre>

				</div><div class="para">
					Then in another window start <code class="literal">McastSenderTest</code>: 
<pre class="screen">[lib]$ java -cp jgroups.jar org.jgroups.tests.McastSenderTest -mcast_addr 224.10.10.10 -port 5555</pre>

				</div><div class="para">
					If you want to bind to a specific network interface card (NIC), use <code class="command">-bind_addr <em class="replaceable">192.168.0.2</em></code>, where <em class="replaceable">192.168.0.2</em> is the IP address of the NIC to which you want to bind. Use this parameter in both the sender and the receiver.
				</div><div class="para">
					You should be able to type in the <code class="literal">McastSenderTest</code> window and see the output in the <code class="literal">McastReceiverTest</code> window. If not, try to use <code class="command">-ttl 32</code> in the sender. If this still fails, consult a system administrator to help you setup IP multicast correctly, and ask the admin to make sure that multicast will work on the interface you have chosen or, if the machines have multiple interfaces, ask to be told the correct interface. Once you know multicast is working properly on each machine in your cluster, you can repeat the above test to test the network, putting the sender on one machine and the receiver on another.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139776733029168">
      ⁠</a>28.6.3.2. Causes of missing heartbeats in FD</h3></div></div></div><div class="para">
					Sometimes a member is suspected by FD because a heartbeat ack has not been received for some time T (defined by timeout and max_tries). This can have multiple reasons, e.g. in a cluster of A,B,C,D; C can be suspected if (note that A pings B, B pings C, C pings D and D pings A):
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							B or C are running at 100% CPU for more than T seconds. So even if C sends a heartbeat ack to B, B may not be able to process it because it is at 100%
						</div></li><li class="listitem"><div class="para">
							B or C are garbage collecting, same as above.
						</div></li><li class="listitem"><div class="para">
							A combination of the 2 cases above
						</div></li><li class="listitem"><div class="para">
							The network loses packets. This usually happens when there is a lot of traffic on the network, and the switch starts dropping packets (usually broadcasts first, then IP multicasts, TCP packets last).
						</div></li><li class="listitem"><div class="para">
							B or C are processing a callback. Let us say C received a remote method call over its channel and takes T+1 seconds to process it. During this time, C will not process any other messages, including heartbeats, and therefore B will not receive the heartbeat ack and will suspect C.
						</div></li></ul></div></div></div></div></div></body></html>