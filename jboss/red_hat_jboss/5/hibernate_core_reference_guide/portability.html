<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 25. Database Portability Considerations</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="portability">
      ⁠</a>Chapter 25. Database Portability Considerations</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portability-basics">
      ⁠</a>25.1. Portability Basics</h1></div></div></div><div class="para">
			One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is the notion of database portability. This could mean an internal IT user migrating from one database vendor to another, or it could mean a framework or deployable application consuming Hibernate to simultaneously target multiple database products by their users. Regardless of the exact scenario, the basic idea is that you want Hibernate to help you run against any number of databases without changes to your code, and ideally without any changes to the mapping metadata.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portability-dialect">
      ⁠</a>25.2. Dialect</h1></div></div></div><div class="para">
			The first line of portability for Hibernate is the dialect, which is a specialization of the <code class="classname">org.hibernate.dialect.Dialect</code> contract. A dialect encapsulates all the differences in how Hibernate must communicate with a particular database to accomplish some task like getting a sequence value or structuring a SELECT query. Hibernate bundles a wide range of dialects for many of the most popular databases. If you find that your particular database is not among them, it is not terribly difficult to write your own.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portability-dialectresolver">
      ⁠</a>25.3. Dialect resolution</h1></div></div></div><div class="para">
			Originally, Hibernate would always require that users specify which dialect to use. In the case of users looking to simultaneously target multiple databases with their build that was problematic. Generally this required their users to configure the Hibernate dialect or defining their own method of setting that value.
		</div><div class="para">
			Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a <code class="interfacename">java.sql.Connection</code> to that database. This was much better, expect that this resolution was limited to databases Hibernate know about ahead of time and was in no way configurable or overridable.
		</div><div class="para">
			Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method: 
<pre class="programlisting">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</pre>
			 . The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver.
		</div><div class="para">
			The cool part about these resolvers is that users can also register their own custom resolvers which will be processed ahead of the built-in Hibernate ones. This might be useful in a number of different situations: it allows easy integration for auto-detection of dialects beyond those shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular database is recognized; etc. To register one or more resolvers, simply specify them (separated by commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the <code class="constant">DIALECT_RESOLVERS</code> constant on <code class="classname">org.hibernate.cfg.Environment</code>).
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portability-idgen">
      ⁠</a>25.4. Identifier generation</h1></div></div></div><div class="para">
			When considering portability between databases, another important decision is selecting the identifier generation strategy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targeting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy because the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entity be associated with the session (like via save() e.g.) regardless of current transactional semantics. The underlying issue is that the semanctics of the application itself changes in these cases.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Hibernate has been improved so that the insert is delayed in cases where that is feasible.
			</div></div></div><div class="para">
			Starting with version 3.2.3, Hibernate comes with a set of <a href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targeting portability in a much different way.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code>
						</div></li><li class="listitem"><div class="para">
							<code class="classname">org.hibernate.id.enhanced.TableGenerator</code>
						</div></li></ul></div>

			</div></div></div><div class="para">
			The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portability-functions">
      ⁠</a>25.5. Database functions</h1></div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				This is a new area in Hibernate and as such it is not as mature as the overall Hibernate experience.
			</div></div></div><div class="para">
			SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. 
			<div xmlns:d="http://docbook.org/ns/docbook" class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
					Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet.
				</div><div class="para">
					It is sort of implemented such that users can programmatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL.
				</div></div></div>

		</div></div></div></body></html>