<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 2. Architecture</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="architecture">
      ⁠</a>Chapter 2. Architecture</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="architecture-overview">
      ⁠</a>2.1. Overview</h1></div></div></div><div class="para">
			The diagram below provides a high-level view of the Hibernate architecture:
		</div><div class="mediaobject" style="text-align: center"><img src="images/overview.png" align="middle" alt="Overview" style="text-align: middle"/></div><div class="para">
			We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture.
		</div><div class="para">
			This next diagram illustrates how Hibernate utilizes database and configuration data to provide persistence services, and persistent objects, to the application.
		</div><div class="para">
			The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs:
		</div><div class="mediaobject" style="text-align: center"><img src="images/lite.png" align="middle" alt="Overview" style="text-align: middle"/></div><div class="para">
			The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details.
		</div><div class="mediaobject" style="text-align: center"><img src="images/full_cream.png" align="middle" alt="Overview" style="text-align: middle"/></div><div class="para">
			Here are some definitions of the objects depicted in the diagrams: 
			<div class="variablelist"><dl class="variablelist compact"><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><div class="para">
							A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level.
						</div></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><div class="para">
							A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier.
						</div></dd><dt><span class="term">Persistent objects and collections</span></dt><dd><div class="para">
							Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="literal">Session</code>. Once the <code class="literal">Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation).
						</div></dd><dt><span class="term">Transient and detached objects and collections</span></dt><dd><div class="para">
							Instances of persistent classes that are not currently associated with a <code class="literal">Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="literal">Session</code>.
						</div></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><div class="para">
							(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="literal">Session</code> might span several <code class="literal">Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="literal">Transaction</code>, is never optional.
						</div></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><div class="para">
							(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="literal">Datasource</code> or <code class="literal">DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer.
						</div></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><div class="para">
							(Optional) A factory for <code class="literal">Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer.
						</div></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><div class="para">
							Hibernate offers a range of optional extension interfaces you can implement to customize the behavior of your persistence layer. See the API documentation for details.
						</div></dd></dl></div>

		</div><div class="para">
			Given a "minimal" architecture, the application bypasses the <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> and/or <code class="literal">ConnectionProvider</code> APIs to communicate with JTA or JDBC directly.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="architecture-states">
      ⁠</a>2.2. Instance states</h1></div></div></div><div class="para">
			An instance of a persistent class can be in one of three different states. These states are defined in relation to a <span class="emphasis"><em>persistence context</em></span>. The Hibernate <code class="literal">Session</code> object is the persistence context. The three different states are as follows:
		</div><div class="variablelist"><dl class="variablelist compact"><dt><span class="term">transient</span></dt><dd><div class="para">
						The instance is not associated with any persistence context. It has no persistent identity or primary key value.
					</div></dd><dt><span class="term">persistent</span></dt><dd><div class="para">
						The instance is currently associated with a persistence context. It has a persistent identity (primary key value) and can have a corresponding row in the database. For a particular persistence context, Hibernate <span class="emphasis"><em>guarantees</em></span> that persistent identity is equivalent to Java identity in relation to the in-memory location of the object.
					</div></dd><dt><span class="term">detached</span></dt><dd><div class="para">
						The instance was once associated with a persistence context, but that context was closed, or the instance was serialized to another process. It has a persistent identity and can have a corresponding row in the database. For detached instances, Hibernate does not guarantee the relationship between persistent identity and Java identity.
					</div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="architecture-jmx">
      ⁠</a>2.3. JMX Integration</h1></div></div></div><div class="para">
			JMX is the J2EE standard for the management of Java components. Hibernate can be managed via a JMX standard service. AN MBean implementation is provided in the distribution: <code class="literal">org.hibernate.jmx.HibernateService</code>.
		</div><div class="para">
			For an example of how to deploy Hibernate as a JMX service on the JBoss Enterprise Application Server, refer to <a class="xref" href="session-configuration.html#configuration-j2ee-jmx">Section 3.8.4, “JMX deployment”</a>.
		</div><div class="para">
			Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics">Section 3.4.6, “Hibernate statistics”</a> for more information.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="architecture-jca">
      ⁠</a>2.4. JCA Support</h1></div></div></div><div class="para">
			Hibernate can also be configured as a JCA connector. Please see the website for more information. Please note, however, that at this stage Hibernate JCA support is under development.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="architecture-current-session">
      ⁠</a>2.5. Contextual sessions</h1></div></div></div><div class="para">
			Most applications using Hibernate need some form of "contextual" session, where a given session is in effect throughout the scope of a given context. However, across applications the definition of what constitutes a context is typically different; different contexts define different scopes to the notion of current. Applications using Hibernate prior to version 3.0 tended to utilize either home-grown <code class="literal">ThreadLocal</code>-based contextual sessions, helper classes such as <code class="literal">HibernateUtil</code>, or utilized third-party frameworks, such as Spring or Pico, which provided proxy/interception-based contextual sessions.
		</div><div class="para">
			Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use.
		</div><div class="para">
			However, as of version 3.1, the processing behind <code class="literal">SessionFactory.getCurrentSession()</code> is now pluggable. To that end, a new extension interface, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, and a new configuration parameter, <code class="literal">hibernate.current_session_context_class</code>, have been added to allow pluggability of the scope and context of defining current sessions.
		</div><div class="para">
			See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">org.hibernate.context.JTASessionContext</code>: current sessions are tracked and scoped by a <code class="literal">JTA</code> transaction. The processing here is exactly the same as in the older JTA-only approach. See the Javadocs for details.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>:current sessions are tracked by thread of execution. See the Javadocs for details.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">org.hibernate.context.ManagedSessionContext</code>: current sessions are tracked by thread of execution. However, you are responsible to bind and unbind a <code class="literal">Session</code> instance with static methods on this class: it does not open, flush, or close a <code class="literal">Session</code>.
				</div></li></ul></div><div class="para">
			The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html">Chapter 11, <em>Transactions and Concurrency</em></a> for more information and code examples.
		</div><div class="para">
			The <code class="literal">hibernate.current_session_context_class</code> configuration parameter defines which <code class="literal">org.hibernate.context.CurrentSessionContext</code> implementation should be used. For backwards compatibility, if this configuration parameter is not set but a <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> is configured, Hibernate will use the <code class="literal">org.hibernate.context.JTASessionContext</code>. Typically, the value of this parameter would just name the implementation class to use. For the three out-of-the-box implementations, however, there are three corresponding short names: "jta", "thread", and "managed".
		</div></div></div></body></html>