<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 5. The contextual component model</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="concepts">
      ⁠</a>Chapter 5. The contextual component model</h1></div></div></div><div class="para">
		Seam's two core concepts are the notions of a <span class="emphasis"><em>context</em></span> and a <span class="emphasis"><em>component</em></span>. Components are stateful objects, usually Enterprise JavaBeans (EJBs). An instance of a component is associated with a context, and assigned a name within that context. <span class="emphasis"><em>Bijection</em></span> provides a mechanism for aliasing internal component names (instance variables) to contextual names, which allows component trees to be dynamically assembled and reassembled by Seam.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690498359088">
      ⁠</a>5.1. Seam contexts</h1></div></div></div><div class="para">
			Seam has several built-in contexts, which are created and destroyed by the framework. The application does not control context demarcation via explicit Java API calls. Contexts are usually implicit. In some cases, however, contexts are demarcated with annotations.
		</div><div class="para">
			There are a number of basic contexts:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Stateless context
				</div></li><li class="listitem"><div class="para">
					Event (for instance, a request) context
				</div></li><li class="listitem"><div class="para">
					Page context
				</div></li><li class="listitem"><div class="para">
					Conversation context
				</div></li><li class="listitem"><div class="para">
					Session context
				</div></li><li class="listitem"><div class="para">
					Business process context
				</div></li><li class="listitem"><div class="para">
					Application context
				</div></li></ul></div><div class="para">
			Some of these contexts serve similar purposes in Servlet and related specifications. Two you may not have encountered previously are the <span class="emphasis"><em>conversation context</em></span> and the <span class="emphasis"><em>business process context</em></span>. One reason that state management in web applications is so fragile and error-prone is that the three built-in contexts (request, session, and application) are not especially meaningful for business logic. A user login session, for example, is an arbitrary construct in terms of the application workflow. Therefore, most Seam components are scoped to the conversation or business process contexts, since these are the most meaningful contexts in terms of the application.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690508296752">
      ⁠</a>5.1.1. Stateless context</h2></div></div></div><div class="para">
				Components which are truly stateless (primarily stateless session beans) always operate in the stateless context — the absence of a context, since the instance Seam resolves is not stored. Stateless components are arguably object-oriented, but they are developed regularly and thus form an important part of any Seam application.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690516143168">
      ⁠</a>5.1.2. Event context</h2></div></div></div><div class="para">
				The event context is the "narrowest" stateful context, and expands the notion of the web request to cover other event types. The event context associated with the life cycle of a JSF request is the most important example of an event context, and the one you will work with most often. Components associated with the event context are destroyed at the end of the request, but their state is available and well- defined for at least the life cycle of the request.
			</div><div class="para">
				When you invoke a Seam component with RMI, or Seam Remoting, the event context is created and destroyed just for the invocation.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690450040768">
      ⁠</a>5.1.3. Page context</h2></div></div></div><div class="para">
				The page context allows you to associate state with a particular instance of a rendered page. You can initialize state in your event listener, or while rendering the page, and can then access it from any event that originates from that page. This is especially useful for functionality such as clickable lists, where the list is backed by changing data on the server side. The state is actually serialized to the client, so this construct is extremely robust with respect to multi-window operation and the back button.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690528469552">
      ⁠</a>5.1.4. Conversation context</h2></div></div></div><div class="para">
				The conversation context is a central concept to Seam. A <span class="emphasis"><em>conversation</em></span> is a single unit of work from the user's perspective. In reality, it may span several interactions with a user — several requests and several data transactions. But to the user, a conversation solves a single problem. For example, the processes of booking a hotel, approving a contract, and creating an order are all conversations. It may help to think of a conversation as implementing a single "use case", although the relationship is not necessarily this exact.
			</div><div class="para">
				A conversation holds state associated with the user's present task, in the current window. A single user may have multiple conversations in progress at any point in time, usually spanning multiple windows. The conversation context ensures that state from the different conversations does not collide and cause bugs.
			</div><div class="para">
				Some conversations last only for a single request. Conversations that span multiple requests must be demarcated with annotations provided by Seam.
			</div><div class="para">
				Some conversations are also <span class="emphasis"><em>tasks</em></span>. A task is a conversation that is significant to a long-running business process, and can trigger a business process state transition when completed successfully. Seam provides a special set of annotations for task demarcation.
			</div><div class="para">
				Conversations can be <span class="emphasis"><em>nested</em></span>, with one conversation taking place inside a broader conversation. This is an advanced feature.
			</div><div class="para">
				Between requests, conversation state is usually held in the Servlet session. Seam implements configurable <span class="emphasis"><em>conversation timeout</em></span> to automatically destroy inactive conversations, which ensures that the state held by a single user login session does not continue to grow if a user abandons a conversation. In the same process, Seam serializes the processing of concurrent requests in the same long-running conversation context.
			</div><div class="para">
				Alternatively, Seam can also be configured to store conversational state in the client browser.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690532327888">
      ⁠</a>5.1.5. Session context</h2></div></div></div><div class="para">
				A session context holds state associated with the user login session. There are some cases where it is useful for state to be shared between several conversations. However, session context should not usually hold components other than global information about the logged in user.
			</div><div class="para">
				In a JSR-168 portal environment, the session context represents the portlet session.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690532325728">
      ⁠</a>5.1.6. Business process context</h2></div></div></div><div class="para">
				The business process context holds state associated with long-running business processes. This state is managed and made persistent by the BPM engine (in this case, JBoss jBPM). The business process spans multiple interactions with multiple users. State is shared between multiple users in a well-defined manner. The current task determines the current business process instance, and the business process life cycle is defined externally with <span class="emphasis"><em>process definition language</em></span>, so there are no special annotations for business process demarcation.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690527621264">
      ⁠</a>5.1.7. Application context</h2></div></div></div><div class="para">
				The application context is the Servlet context from the Servlet specification. Application context is used primarily to hold static information such as configuration data, reference data or metamodels. For example, Seam stores its own configuration and metamodel in the application context.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690502263216">
      ⁠</a>5.1.8. Context variables</h2></div></div></div><div class="para">
				A context defines a namespace through a set of <span class="emphasis"><em>context variables</em></span>. These work similarly to session or request attributes in the Servlet specification. Any value may be bound to a context variable, but they are usually bound to Seam component instances.
			</div><div class="para">
				The context variable name identifies a component instance within a context. (The context variable name usually matches the component name.) You can programmatically access a named component instance in a particular scope with the <code class="literal">Contexts</code> class, which provides access to several thread-bound instances of the <code class="literal">Context</code> interface:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>User user = (User) Contexts.<span xmlns="" class="perl_Function">getSessionContext</span>().<span xmlns="" class="perl_Function">get</span>(<span xmlns="" class="perl_String">"user"</span>);</pre><div class="para">
				You may also set or change the value associated with a name:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>Contexts.<span xmlns="" class="perl_Function">getSessionContext</span>().<span xmlns="" class="perl_Function">set</span>(<span xmlns="" class="perl_String">"user"</span>, user);</pre><div class="para">
				However, components are usually obtained from a context via <span class="emphasis"><em>injection</em></span>. Component instances are subsequently given to contexts via <span class="emphasis"><em>outjection</em></span>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690538152224">
      ⁠</a>5.1.9. Context search priority</h2></div></div></div><div class="para">
				Sometimes, component instances are obtained from a particular known scope. At other times, all stateful scopes are searched, in the following order of priority:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Event context
					</div></li><li class="listitem"><div class="para">
						Page context
					</div></li><li class="listitem"><div class="para">
						Conversation context
					</div></li><li class="listitem"><div class="para">
						Session context
					</div></li><li class="listitem"><div class="para">
						Business process context
					</div></li><li class="listitem"><div class="para">
						Application context
					</div></li></ul></div><div class="para">
				You can perform a priority search by calling <code class="literal">Contexts.lookupInStatefulContexts()</code>. Whenever you access a component by name from a JSF page, a priority search occurs.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="concurrency">
      ⁠</a>5.1.10. Concurrency model</h2></div></div></div><div class="para">
				Neither the Servlet, nor EJB specifications, define facilities for managing concurrent requests from the same client. The Servlet container lets all threads run concurrently, without ensuring thread-safeness. The EJB container allows concurrent access of stateless components, and throws an exception when multiple threads access a stateful session bean. This is sufficient for web applications based around fine-grained, synchronous requests. However, for modern applications, which frequently use asynchronous (AJAX) requests, concurrency support is vital. Therefore, Seam adds a concurrency management layer to its context model.
			</div><div class="para">
				Session and application contexts are multi-threaded in Seam, allowing concurrent requests to be processed concurrently. Event and page contexts are single-threaded. Strictly, the business process context is multi-threaded, but concurrency here is rare, and can usually be disregarded. Seam serializes concurrent requests within a long-running conversation context in order to enforce a <span class="emphasis"><em>single thread per conversation per process</em></span> model for the conversation context.
			</div><div class="para">
				Because session context is multi-threaded and often contains volatile state, Seam always protects session-scoped components from concurrent access while Seam interceptors are enabled. If interceptors are disabled, any required thread safety must be implemented by the component itself. By default, Seam serializes requests to session-scoped session beans and JavaBeans, and detects and breaks any deadlocks that occur. However, this is not default behavior for application-scoped components, since they do not usually hold volatile state, and global synchronization is extremely expensive. Serialized threading models can be forced on any session bean or JavaBean component by adding the <code class="literal">@Synchronized</code> annotation.
			</div><div class="para">
				This concurrency model means that AJAX clients can safely use volatile session and conversational state, without the need for any special work on the part of the developer.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690531384240">
      ⁠</a>5.2. Seam components</h1></div></div></div><div class="para">
			Seam components are Plain Old Java Objects (POJOs). Specifically, they are JavaBeans, or Enterprise JavaBean 3.0 (EJB3) enterprise beans. While Seam does not require components to be EJBs, and can be used without an EJB3-compliant container, Seam was designed with EJB3 in mind, and includes deep integration with EJB3. Seam supports the following <span class="emphasis"><em>component types</em></span>:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					EJB3 stateless session beans
				</div></li><li class="listitem"><div class="para">
					EJB3 stateful session beans
				</div></li><li class="listitem"><div class="para">
					EJB3 entity beans (for instance, JPA entity classes)
				</div></li><li class="listitem"><div class="para">
					JavaBeans
				</div></li><li class="listitem"><div class="para">
					EJB3 message-driven beans
				</div></li><li class="listitem"><div class="para">
					Spring beans (see <a class="xref" href="spring.html">Chapter 26, <em>Spring Framework integration</em></a>)
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690528577856">
      ⁠</a>5.2.1. Stateless session beans</h2></div></div></div><div class="para">
				Stateless session bean components cannot hold state across multiple invocations, so they usually operate upon the state of other components in the various Seam contexts. They can be used as JSF action listeners, but cannot provide properties to JSF components for display.
			</div><div class="para">
				Stateless session beans always exist in the stateless context. They can be accessed concurrently as a new instance is used for each request. The EJB3 container assigns instances to requests. (Normally, instances are allocated from a reuseable pool, so instance variables can retain data from previous uses of the bean.)
			</div><div class="para">
				Seam stateless session bean components are instantiated with either <code class="literal">Component.getInstance()</code> or <code class="literal">@In(create=true)</code>. They should not be directly instantiated via JNDI look up or the <code class="literal">new</code> operator.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690525476736">
      ⁠</a>5.2.2. Stateful session beans</h2></div></div></div><div class="para">
				Stateful session bean components can not only hold state across multiple invocations of the bean, but also across multiple requests. Any application state that does not belong in the database should be held by stateful session beans. This is a major difference between Seam and many other web application frameworks. Current conversation data should be stored in the instance variables of a stateful session bean bound to the conversation context, rather than in the <code class="literal">HttpSession</code>. This lets Seam manage state life cycle, and ensures there are no collisions between state relating to different concurrent conversations.
			</div><div class="para">
				Stateful session beans are often used as JSF action listeners, and as backing beans to provide properties to JSF components for display or form submission.
			</div><div class="para">
				By default, stateful session beans are bound to the conversation context. They may never be bound to the page, or to stateless contexts.
			</div><div class="para">
				Seam serializes concurrent requests to session-scoped stateful session beans while Seam interceptors are enabled.
			</div><div class="para">
				Seam stateful session bean components are instantiated with either <code class="literal">Component.getInstance()</code> or <code class="literal">@In(create=true)</code>. They should not be directly instantiated via JNDI look up or the <code class="literal">new</code> operator.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690508396144">
      ⁠</a>5.2.3. Entity beans</h2></div></div></div><div class="para">
				Entity beans can function as a Seam component when bound to a context variable. Because entities have a persistent identity in addition to their contextual identity, entity instances are usually bound explicitly in Java code, rather than being instantiated implicitly by Seam.
			</div><div class="para">
				Entity bean components do not support bijection or context demarcation. Nor does invocation of an entity bean trigger validation.
			</div><div class="para">
				Entity beans are not usually used as JSF action listeners, but often function as backing beans to provide properties to JSF components for display or form submission. They are commonly used as a backing bean coupled with a stateless session bean action listener to implement create/update/delete-type functionality.
			</div><div class="para">
				By default, entity beans are bound to the conversation context, and can never be bound to the stateless context.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					In a clustered environment, it is less efficient to bind an entity bean directly to a conversation (or session-scoped Seam context variable) than it is to refer to the entity bean with a stateful session bean. Not all Seam applications define entity beans as Seam components for this reason.
				</div></div></div><div class="para">
				Seam entity bean components are instantiated with <code class="literal">Component.getInstance()</code> or <code class="literal">@In(create=true)</code>, or directly instantiated with the <code class="literal">new</code> operator.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690461828960">
      ⁠</a>5.2.4. JavaBeans</h2></div></div></div><div class="para">
				JavaBeans are used similarly to stateless or stateful session beans. However, they do not provide functions such as declarative transaction demarcation, declarative security, efficient clustered state replication, EJB3 persistence, timeout methods, etc.
			</div><div class="para">
				In a later chapter, we show you how to use Seam and Hibernate without an EJB container. In this case, components are JavaBeans rather than session beans.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					In a clustered environment, it is less efficient to cluster conversation- or session-scoped Seam JavaBean components than it is to cluster stateful session bean components.
				</div></div></div><div class="para">
				By default, JavaBeans are bound to the event context.
			</div><div class="para">
				Seam always serializes concurrent requests to session-scoped JavaBeans.
			</div><div class="para">
				Seam JavaBean components are instantiated with <code class="literal">Component.getInstance()</code> or <code class="literal">@In(create=true)</code>. They should not be directly instantiated using the <code class="literal">new</code> operator.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690493751168">
      ⁠</a>5.2.5. Message-driven beans</h2></div></div></div><div class="para">
				Message-driven beans can function as Seam components. However, their call method differs from that of other Seam components — rather than being invoked with the context variable, they listen for messages sent to JMS queues or topics.
			</div><div class="para">
				Message-driven beans cannot be bound to Seam contexts, nor can they access the session or conversation state of their <span class="emphasis"><em>caller</em></span>. However, they do support bijection and some other Seam functionality.
			</div><div class="para">
				Message-driven beans are never instantiated by the application; they are instantiated by the EJB container when a message is received.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690494410528">
      ⁠</a>5.2.6. Interception</h2></div></div></div><div class="para">
				To perform actions such as bijection, context demarcation, and validation, Seam must intercept component invocations. For JavaBeans, Seam controls component instantiation completely, and no special configuration is required. For entity beans, interception is not required, since bijection and context demarcation are not defined. For session beans, an EJB interceptor must be registered for the session bean component. This can be done with an annotation, as follows:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Interceptors</span>(SeamInterceptor.<span xmlns="" class="perl_Function">class</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { <span xmlns="" class="perl_Keyword">... </span>}</pre><div class="para">
				However, it is better to define the interceptor in <code class="filename">ejb-jar.xml</code>:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;interceptors&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;interceptor&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;interceptor-class&gt;</span>
<span xmlns="" class="line">​</span>      org.jboss.seam.ejb.SeamInterceptor
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/interceptor-class&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/interceptor&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/interceptors&gt;</span> 
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;assembly-descriptor&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;interceptor-binding&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;ejb-name&gt;</span>*<span xmlns="" class="perl_Keyword">&lt;/ejb-name&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;interceptor-class&gt;</span>
<span xmlns="" class="line">​</span>      org.jboss.seam.ejb.SeamInterceptor
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/interceptor-class&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/interceptor-binding&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/assembly-descriptor&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690453470256">
      ⁠</a>5.2.7. Component names</h2></div></div></div><div class="para">
				All Seam components require names. Assign a name with the <code class="literal">@Name</code> annotation:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { <span xmlns="" class="perl_Keyword">... </span>}</pre><div class="para">
				This is the <span class="emphasis"><em>Seam component name</em></span>, and does not relate to any other name defined by the EJB specification. However, Seam component names work like JSF managed bean names, and can be thought of in identical terms.
			</div><div class="para">
				<code class="literal">@Name</code> is not the only way to define a component name, but the name must always be specified. No other Seam annotation will function if a name is not defined.
			</div><div class="para">
				When Seam instantiates a component, it binds the new instance to a variable matching the component name in the component's configured scope. This is identical to JSF managed bean behavior, except that Seam lets you configure this mapping with annotations rather than XML. You can also programmatically bind a component to a context variable. This is useful if a particular component serves multiple roles within the system. For example, the current <code class="literal">User</code> might be bound to the <code class="literal">currentUser</code> session context variable, while a <code class="literal">User</code> that is the subject of some administration functionality might be bound to the <code class="literal">user</code> conversation context variable. Take care when binding programmatically, because it is possible to overwrite context variables that reference Seam components.
			</div><div class="para">
				For very large applications, and for built-in Seam components, qualified component names are often used to avoid naming conflicts.
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"com.jboss.myapp.loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { <span xmlns="" class="perl_Keyword">... </span>}</pre><div class="para">
				The qualified component name can be used both in Java code and in JSF's expression language:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;h:commandButton</span><span xmlns="" class="perl_Others"> type=</span><span xmlns="" class="perl_String">"submit"</span><span xmlns="" class="perl_Others"> value=</span><span xmlns="" class="perl_String">"Login"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   action=</span><span xmlns="" class="perl_String">"#{com.jboss.myapp.loginAction.login}"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
				Since this is noisy, Seam also provides a means of aliasing a qualified name to a simple name. Add a line like this to the <code class="filename">components.xml</code> file:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;factory</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"loginAction"</span><span xmlns="" class="perl_Others"> scope=</span><span xmlns="" class="perl_String">"STATELESS"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">         value=</span><span xmlns="" class="perl_String">"#{com.jboss.myapp.loginAction}"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
				All built-in Seam components have qualified names, but can be accessed through their unqualified names with Seam's <span class="emphasis"><em>namespace-import</em></span> feature. The <code class="filename">components.xml</code> file included in the Seam JAR defines the following namespaces:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;components</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"http://jboss.com/products/seam/components"</span><span xmlns="" class="perl_Keyword">&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.core<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.cache<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.transaction<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.framework<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.web<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.faces<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.international<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.theme<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.pageflow<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.bpm<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.jms<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.mail<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.security<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.security.management<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span>  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.security.permission<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.captcha<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;import&gt;</span>org.jboss.seam.excel.exporter<span xmlns="" class="perl_Keyword">&lt;/import&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Comment">&lt;!-- ... ---&gt;</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/components&gt;</span></pre><div class="para">
				When attempting to resolve an unqualified name, Seam will check each of these namespaces, in order. Additional application-specific namespaces can be included in your application's <code class="filename">components.xml</code> file.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690532568480">
      ⁠</a>5.2.8. Defining the component scope</h2></div></div></div><div class="para">
				The <code class="literal">@Scope</code> annotation lets us override the scope (context) of a component to define the context a component instance is bound to when instantiated by Seam.
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"user"</span>) 
<span xmlns="" class="line">​</span>@Entity 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(SESSION) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> User { <span xmlns="" class="perl_Keyword">... </span>}</pre><div class="para">
				<code class="literal">org.jboss.seam.ScopeType</code> defines an enumeration of possible scopes.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690495203440">
      ⁠</a>5.2.9. Components with multiple roles</h2></div></div></div><div class="para">
				Some Seam component classes can fulfill multiple roles in the system. For example, the <code class="literal">User</code> class is usually a session-scoped component representing the current user, but in user administration screens becomes a conversation-scoped component. The <code class="literal">@Role</code> annotation lets us define an additional named role for a component, with a different scope — it lets us bind the same component class to different context variables. (Any Seam component <span class="emphasis"><em>instance</em></span> can be bound to multiple context variables, but this lets us do it at the class level to take advantage of automatic instantiation.)
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"user"</span>) 
<span xmlns="" class="line">​</span>@Entity 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(CONVERSATION) 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Role</span>(name=<span xmlns="" class="perl_String">"currentUser"</span>, scope=SESSION)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> User { <span xmlns="" class="perl_Keyword">... </span>}</pre><div class="para">
				The <code class="literal">@Roles</code> annotation lets us specify additional roles as required.
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"user"</span>) 
<span xmlns="" class="line">​</span>@Entity 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(CONVERSATION) 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Roles</span>({ @<span xmlns="" class="perl_Function">Role</span>(name=<span xmlns="" class="perl_String">"currentUser"</span>, scope=SESSION), 
<span xmlns="" class="line">​</span>         @<span xmlns="" class="perl_Function">Role</span>(name=<span xmlns="" class="perl_String">"tempUser"</span>, scope=EVENT)}) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> User { <span xmlns="" class="perl_Keyword">... </span>}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690516133888">
      ⁠</a>5.2.10. Built-in components</h2></div></div></div><div class="para">
				Seam is implemented as a set of built-in interceptors and components. This makes it easy for applications to interact with built-in components at runtime, or to customize basic Seam functionality by replacing the built-in components with custom implementations. The built-in components are defined in the Seam namespace <code class="literal">org.jboss.seam.core</code>, and in the Java package of the same name.
			</div><div class="para">
				The built-in components may be injected like any other Seam component, but they also provide convenient static <code class="literal">instance()</code> methods:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>FacesMessages.<span xmlns="" class="perl_Function">instance</span>().<span xmlns="" class="perl_Function">add</span>(<span xmlns="" class="perl_String">"Welcome back, #{user.name}!"</span>);</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690524700800">
      ⁠</a>5.3. Bijection</h1></div></div></div><div class="para">
			<span class="emphasis"><em>Dependency injection</em></span> or <span class="emphasis"><em>inversion of control</em></span> (IoC) allows one component to reference another by having the container "inject" the component into a setter method or instance variable. In previous dependency injection implementations, injection occurred at component construction, and the reference did not change for the lifetime of the component instance. This is reasonable for stateless components — from the client's perspective, all instances of a particular stateless component are interchangeable. However, Seam emphasizes the use of stateful components, so traditional dependency injection as a construct is less useful. Seam introduces the notion of <span class="emphasis"><em>bijection</em></span> as a generalization of injection. In contrast to injection, bijection is:
		</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">contextual</span></dt><dd><div class="para">
						Bijection is used to assemble stateful components from various different contexts. A component from a <span class="emphasis"><em>wider</em></span> context can even refer to a component from a <span class="emphasis"><em>narrower</em></span> context.
					</div></dd><dt><span class="term">bidirectional</span></dt><dd><div class="para">
						Values are injected from context variables into attributes of the invoked component, and returned (via outjection) to the context, allowing the invoked component to manipulate contextual variable values simply by setting its own instance variables.
					</div></dd><dt><span class="term">dynamic</span></dt><dd><div class="para">
						Since the value of contextual variables changes over time, and since Seam components are stateful, bijection takes place every time a component is invoked.
					</div></dd></dl></div><div class="para">
			In essence, bijection lets you alias a context variable to a component instance variable, by specifying that the value of the instance variable is injected, outjected, or both. Annotations are used to enable bijection.
		</div><div class="para">
			The <code class="literal">@In</code> annotation specifies that a value should be injected, either into an instance variable:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  @In User user; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			or into a setter method:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  User user; 
<span xmlns="" class="line">​</span>  @In 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">setUser</span>(User user) { <span xmlns="" class="perl_Keyword">this</span>.<span xmlns="" class="perl_Function">user</span>=user; } 
<span xmlns="" class="line">​</span>  ...
<span xmlns="" class="line">​</span>  }</pre><div class="para">
			By default, Seam performs a priority search of all contexts, using the name of the property or instance variable being injected. You may wish to specify the context variable name explicitly, using, for example, <code class="literal">@In("currentUser")</code>.
		</div><div class="para">
			If you want Seam to create an instance of the component, where there is no existing component instance bound to the named context variable, you should specify <code class="literal">@In(create=true)</code>. If the value is optional (it can be null), specify <code class="literal">@In(required=false)</code>.
		</div><div class="para">
			For some components, specifying <code class="literal">@In(create=true)</code> each time it is used can be repetitive. In such cases, annotate the component <code class="literal">@AutoCreate</code>. This way, it will always be created whenever required, even without the explicit use of <code class="literal">create=true</code>.
		</div><div class="para">
			You can even inject the value of an expression:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  @<span xmlns="" class="perl_Function">In</span>(<span xmlns="" class="perl_String">"#{user.username}"</span>) String username; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Injected values are disinjected (that is, set to <code class="literal">null</code>) immediately after method completion and outjection.
		</div><div class="para">
			(More information about component life cycle and injection can be found in the next chapter.)
		</div><div class="para">
			The <code class="literal">@Out</code> annotation specifies that an attribute should be outjected, either from an instance variable:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  @Out User user; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			or from a getter method:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  User user; 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @Out 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> User <span xmlns="" class="perl_Function">getUser</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> user; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			An attribute may be both injected and outjected:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  @In 
<span xmlns="" class="line">​</span>  @Out User user; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			or:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"loginAction"</span>) 
<span xmlns="" class="line">​</span>@Stateless 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> LoginAction <span xmlns="" class="perl_Keyword">implements</span> Login { 
<span xmlns="" class="line">​</span>  User user;
<span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span>  @In 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">setUser</span>(User user) { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">this</span>.<span xmlns="" class="perl_Function">user</span>=user; 
<span xmlns="" class="line">​</span>  }
<span xmlns="" class="line">​</span>   
<span xmlns="" class="line">​</span>  @Out 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> User <span xmlns="" class="perl_Function">getUser</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> user; } 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690505315248">
      ⁠</a>5.4. Life cycle methods</h1></div></div></div><div class="para">
			Session bean and entity bean Seam components support all common EJB3 life cycle callbacks (<code class="literal">@PostConstruct</code>, <code class="literal">@PreDestroy</code>, etc.), but Seam also supports the use of any of these callbacks with JavaBean components. However, since these annotations are not available in a J2EE environment, Seam defines two additional component life cycle callbacks, equivalent to <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code>.
		</div><div class="para">
			The <code class="literal">@Create</code> method is called after Seam instantiates a component. Components may define only one <code class="literal">@Create</code> method.
		</div><div class="para">
			The <code class="literal">@Destroy</code> method is called when the context that the Seam component is bound to ends. Components may define only one <code class="literal">@Destroy</code> method.
		</div><div class="para">
			In addition, stateful session bean components <span class="emphasis"><em>must</em></span> define a method with no parameters, annotated <code class="literal">@Remove</code>. This method is called by Seam when the context ends.
		</div><div class="para">
			Finally, the <code class="literal">@Startup</code> annotation can be applied to any application- or session-scoped component. The <code class="literal">@Startup</code> annotation tells Seam to instantiate the component immediately, when the context begins, instead of waiting until it is first referenced by a client. It is possible to control the order of instantiation of start up components by specifying <code class="literal">@Startup(depends={....})</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690530579696">
      ⁠</a>5.5. Conditional installation</h1></div></div></div><div class="para">
			The <code class="literal">@Install</code> annotation controls conditional installation of components that are required in some deployment scenarios and not in others. This is useful when you want to:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					mock out an infrastructural component in a test,
				</div></li><li class="listitem"><div class="para">
					change a component's implementation in certain deployment scenarios, or
				</div></li><li class="listitem"><div class="para">
					install some components only if their dependencies are available. (This is useful for framework authors.)
				</div></li></ul></div><div class="para">
			<code class="literal">@Install</code> lets you specify <span class="emphasis"><em>precedence</em></span> and <span class="emphasis"><em>dependencies</em></span>.
		</div><div class="para">
			The precedence of a component is a number that Seam uses to decide which component to install when there are multiple classes with the same component name in the classpath. Seam will choose the component with the higher precedence. Some predefined precedence values are (in ascending order):
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
					<code class="literal">BUILT_IN</code> — the lowest precedence components are the components built in to Seam.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">FRAMEWORK</code> — components defined by third-party frameworks may override built-in components, but are overridden by application components.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">APPLICATION</code> — the default precedence. This is appropriate for most application components.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">DEPLOYMENT</code> — for application components which are deployment-specific.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">MOCK</code> — for mock objects used in testing.
				</div></li></ol></div><div class="para">
			Suppose we have a component named <code class="literal">messageSender</code> that talks to a JMS queue.
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"messageSender"</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MessageSender { 
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">sendMessage</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Comment">//do something with JMS </span>
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			In our unit tests, there is no available JMS queue, so we would like to stub out this method. We'll create a <span class="emphasis"><em>mock</em></span> component that exists in the classpath when unit tests are running, but is never deployed with the application:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"messageSender"</span>) 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Install</span>(precedence=MOCK) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MockMessageSender <span xmlns="" class="perl_Keyword">extends</span> MessageSender { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">sendMessage</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Comment">//do nothing! </span>
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			The <code class="literal">precedence</code> helps Seam decide which version to use when it finds both components in the classpath.
		</div><div class="para">
			If we are able to control precisely which classes are in the classpath, this works well. But if we are writing a reuseable framework with many dependencies, we do not want to have to break that framework across multiple <code class="filename">jar</code>s. We want to be able to decide which components to install based on other installed components, and classes available in the classpath. The <code class="literal">@Install</code> annotation also controls this functionality. Seam uses this mechanism internally to enable the conditional installation of many built-in components.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690453367296">
      ⁠</a>5.6. Logging</h1></div></div></div><div class="para">
			Before Seam, even the simplest log message required verbose code:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">private</span> <span xmlns="" class="perl_DataType">static</span> <span xmlns="" class="perl_DataType">final</span> Log log = LogFactory.<span xmlns="" class="perl_Function">getLog</span>(CreateOrderAction.<span xmlns="" class="perl_Function">class</span>);
<span xmlns="" class="line">​</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> Order <span xmlns="" class="perl_Function">createOrder</span>(User user, Product product, <span xmlns="" class="perl_DataType">int</span> quantity) { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">if</span> ( log.<span xmlns="" class="perl_Function">isDebugEnabled</span>() ) { 
<span xmlns="" class="line">​</span>    log.<span xmlns="" class="perl_Function">debug</span>(<span xmlns="" class="perl_String">"Creating new order for user: "</span> + user.<span xmlns="" class="perl_Function">username</span>() + 
<span xmlns="" class="line">​</span>              <span xmlns="" class="perl_String">" product: "</span> + product.<span xmlns="" class="perl_Function">name</span>() + <span xmlns="" class="perl_String">" quantity: "</span> + quantity);
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">Order</span>(user, product, quantity); 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Seam provides a logging API that simplifies this code significantly:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Logger <span xmlns="" class="perl_Keyword">private</span> Log log; 
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> Order <span xmlns="" class="perl_Function">createOrder</span>(User user, Product product, <span xmlns="" class="perl_DataType">int</span> quantity) { 
<span xmlns="" class="line">​</span>  log.<span xmlns="" class="perl_Function">debug</span>(<span xmlns="" class="perl_String">"Creating new order for user: #0 product: #1 quantity: #2"</span>, 
<span xmlns="" class="line">​</span>             user.<span xmlns="" class="perl_Function">username</span>(), product.<span xmlns="" class="perl_Function">name</span>(), quantity); 
<span xmlns="" class="line">​</span>          
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">Order</span>(user, product, quantity); 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Except for entity bean components (which require the <code class="literal">log</code> variable to be static), this will work regardless of whether the <code class="literal">log</code> variable is declared static.
		</div><div class="para">
			String concatenation occurs inside the <code class="literal">debug()</code> method, so the verbose <code class="literal">if ( log.isDebugEnabled() )</code> guard is unnecessary. Usually, we would not even need to explicitly specify the log category, since Seam knows where it is injecting the <code class="literal">log</code>.
		</div><div class="para">
			If <code class="literal">User</code> and <code class="literal">Product</code> are Seam components available in the current contexts, the code is even more concise:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Logger <span xmlns="" class="perl_Keyword">private</span> Log log; 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> Order <span xmlns="" class="perl_Function">createOrder</span>(User user, Product product, <span xmlns="" class="perl_DataType">int</span> quantity) { 
<span xmlns="" class="line">​</span>  log.<span xmlns="" class="perl_Function">debug</span>(<span xmlns="" class="perl_String">"Creating new order for user: #{user.username} </span>
<span xmlns="" class="line">​</span>             product: #{product.<span xmlns="" class="perl_Function">name</span>} quantity: #0<span xmlns="" class="perl_String">", quantity); </span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">Order</span>(user, product, quantity); 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Seam logging automatically chooses whether to send output to log4j or JDK logging — if log4j is in the classpath, it will be used; if not, Seam uses JDK logging.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690507834352">
      ⁠</a>5.7. The <code class="literal">Mutable</code> interface and <code class="literal">@ReadOnly</code></h1></div></div></div><div class="para">
			Many application servers feature <code class="literal">HttpSession</code> clustering where changes to the state of mutable objects bound to the session are replicated only when <code class="literal">setAttribute</code> is called explicitly. This can lead to bugs that manifest only upon failover, which cannot be effectively tested during development. Further, the replication messages themselves are inefficient, since they contain the entire serialized object graph, bound to the session attribute.
		</div><div class="para">
			EJB stateful session beans must perform automatic dirty checking (that is, they must automatically detect object state changes to synchronize updated states with the database) and replicate mutable state. A sophisticated EJB container can introduce optimizations such as attribute-level replication. Unfortunately, not all Seam users will be working in an environment that supports EJB3. Therefore, Seam provides an extra layer of cluster-safe state management for session- and conversation-scoped JavaBean and entity bean components.
		</div><div class="para">
			For session- or conversation-scoped JavaBean components, Seam automatically forces replication by calling <code class="literal">setAttribute()</code> once in every request where the component was invoked by the application. However, this strategy is inefficient for read-mostly components. Control this behavior by implementing the <code class="literal">org.jboss.seam.core.Mutable</code> interface, or by extending <code class="literal">org.jboss.seam.core.AbstractMutable</code> and writing your own dirty-checking logic inside the component. For example,
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"account"</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Account <span xmlns="" class="perl_Keyword">extends</span> AbstractMutable { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">private</span> BigDecimal balance; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">setBalance</span>(BigDecimal balance) { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Function">setDirty</span>(<span xmlns="" class="perl_Keyword">this</span>.<span xmlns="" class="perl_Function">balance</span>, balance); 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">this</span>.<span xmlns="" class="perl_Function">balance</span> = balance; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> BigDecimal <span xmlns="" class="perl_Function">getBalance</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> balance; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Or, you can use the <code class="literal">@ReadOnly</code> annotation to achieve a similar effect:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"account"</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Account { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">private</span> BigDecimal balance; 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">setBalance</span>(BigDecimal balance) { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">this</span>.<span xmlns="" class="perl_Function">balance</span> = balance; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @ReadOnly 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> BigDecimal <span xmlns="" class="perl_Function">getBalance</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> balance; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			For session- or conversation-scoped entity bean components, Seam automatically forces replication by calling <code class="literal">setAttribute()</code> once in every request, unless the (conversation-scoped) entity is currently associated with a Seam-managed persistence context, in which case replication is unnecessary. This strategy is not necessarily efficient, so session or conversation scope entity beans should be used with care. You can always write a stateful session bean or JavaBean component to "manage" the entity bean instance. For example:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Stateful @<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"account"</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> AccountManager <span xmlns="" class="perl_Keyword">extends</span> AbstractMutable { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">private</span> Account account; <span xmlns="" class="perl_Comment">// an entity bean </span>
<span xmlns="" class="line">​</span>  @Unwrap 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> Account <span xmlns="" class="perl_Function">getAccount</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> account; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Note that the <code class="literal">EntityHome</code> class in the Seam Application Framework is an excellent example of managing an entity bean instance using a Seam component.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690515280832">
      ⁠</a>5.8. Factory and manager components</h1></div></div></div><div class="para">
			It is often necessary to work with objects that are not Seam components, but we still prefer to be able to inject them into our components with <code class="literal">@In</code>, use them in value- and method-binding expressions, and tie them into the Seam context life cycle (<code class="literal">@Destroy</code>, for example). Therefore, Seam contexts can hold objects that are not Seam components, and Seam provides several features that simplify working with non-component objects bound to contexts.
		</div><div class="para">
			The <span class="emphasis"><em>factory component pattern</em></span> lets a Seam component act as the instantiator for a non-component object. A <span class="emphasis"><em>factory method</em></span> will be called when a context variable is referenced but has no value bound to it. Factory methods are defined with the <code class="literal">@Factory</code> annotation. The factory method binds a value to the context variable, and determines the scope of the bound value. There are two styles of factory method. The first style returns a value, which is bound to the context by Seam:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Factory</span>(scope=CONVERSATION) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> List&lt;Customer&gt; <span xmlns="" class="perl_Function">getCustomerList</span>() { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">... </span>; 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			The second style is a method of type <code class="literal">void</code>, which binds the value to the context variable itself:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@DataModel List&lt;Customer&gt; customerList; 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Factory</span>(<span xmlns="" class="perl_String">"customerList"</span>) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">initCustomerList</span>() { 
<span xmlns="" class="line">​</span>  customerList = <span xmlns="" class="perl_Keyword">...  </span>; 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			In either case, the factory method is called when the <code class="literal">customerList</code> context variable is referenced, and its value is null. The factory method then has no further part in the life cycle of the value. The <span class="emphasis"><em>manager component pattern</em></span> is an even more powerful pattern. In this case, a Seam component bound to a context variable manages the value of the context variable while remaining invisible to clients.
		</div><div class="para">
			A manager component is any component with an <code class="literal">@Unwrap</code> method. This method returns the value that will be visible to clients, and is called every time a context variable is referenced.
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"customerList"</span>) 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(CONVERSATION) 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> CustomerListManager { 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>  @Unwrap 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> List&lt;Customer&gt; <span xmlns="" class="perl_Function">getCustomerList</span>() { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">... </span>; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>}</pre><div class="para">
			The manager component pattern is especially useful where more control is required over component life cycle. For example, if you have a heavyweight object that needs a cleanup operation when the context ends, you could <code class="literal">@Unwrap</code> the object, and perform cleanup in the <code class="literal">@Destroy</code> method of the manager component.
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"hens"</span>) 
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(APPLICATION)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> HenHouse { 
<span xmlns="" class="line">​</span>  Set&lt;Hen&gt; hens;
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @<span xmlns="" class="perl_Function">In</span>(required=<span xmlns="" class="perl_Keyword">false</span>) Hen hen; 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @Unwrap 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> List&lt;Hen&gt; <span xmlns="" class="perl_Function">getHens</span>() 
<span xmlns="" class="line">​</span>  { 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">if</span> (hens == <span xmlns="" class="perl_Keyword">null</span>) { 
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">// Setup our hens } </span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> hens; 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @<span xmlns="" class="perl_Function">Observer</span>({<span xmlns="" class="perl_String">"chickBorn"</span>, <span xmlns="" class="perl_String">"chickenBoughtAtMarket"</span>}) 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">addHen</span>() { 
<span xmlns="" class="line">​</span>    hens.<span xmlns="" class="perl_Function">add</span>(hen); 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @<span xmlns="" class="perl_Function">Observer</span>(<span xmlns="" class="perl_String">"chickenSoldAtMarket"</span>) 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">removeHen</span>() { 
<span xmlns="" class="line">​</span>    hens.<span xmlns="" class="perl_Function">remove</span>(hen); 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  @<span xmlns="" class="perl_Function">Observer</span>(<span xmlns="" class="perl_String">"foxGetsIn"</span>) 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Function">removeAllHens</span>() { 
<span xmlns="" class="line">​</span>    hens.<span xmlns="" class="perl_Function">clear</span>(); 
<span xmlns="" class="line">​</span>  } 
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">... </span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
			Here, the managed component observes many events that change the underlying object. The component manages these actions itself, and because the object is unwrapped each time it is accessed, a consistent view is provided.
		</div></div></div></body></html>