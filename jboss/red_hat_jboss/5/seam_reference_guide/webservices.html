<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 23. Web Services</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="webservices">
      ⁠</a>Chapter 23. Web Services</h1></div></div></div><div class="para">
		Seam integrates with JBossWS (JWS) to allow standard Java EE web services to take full advantage of Seam's contextual framework, including conversational web service support. This chapter guides you through web service configuration for a Seam environment.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690512444624">
      ⁠</a>23.1. Configuration and Packaging</h1></div></div></div><div class="para">
			For Seam to create contexts for web service requests, it must first have access to those requests. <code class="literal">org.jboss.seam.webservice.SOAPRequestHandler</code> is a <code class="literal">SOAPHandler</code> implementation that manages the Seam component life cycle during the scope of a web service request.
		</div><div class="para">
			<code class="filename">standard-jaxws-endpoint-config.xml</code> (a configuration file) should be placed in the <code class="literal">META-INF</code> directory of the <code class="filename">JAR</code> file that contains the web service classes. This file contains the following SOAP handler configuration:
		</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;jaxws-config</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"urn:jboss:jaxws-config:2.0"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">              xmlns:xsi=</span><span xmlns="" class="perl_String">"http://www.w3.org/2001/XMLSchema-instance"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">              xmlns:javaee=</span><span xmlns="" class="perl_String">"http://java.sun.com/xml/ns/javaee"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">              xsi:schemaLocation=</span>
<span xmlns="" class="line">​</span>                <span xmlns="" class="perl_String">"urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>                
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;endpoint-config&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;config-name&gt;</span>Seam WebService Endpoint<span xmlns="" class="perl_Keyword">&lt;/config-name&gt;</span>
<span xmlns="" class="line">​</span>    
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;pre-handler-chains&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;javaee:handler-chain&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;javaee:protocol-bindings&gt;</span>
<span xmlns="" class="line">​</span>          ##SOAP11_HTTP
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;/javaee:protocol-bindings&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;javaee:handler&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;javaee:handler-name&gt;</span>
<span xmlns="" class="line">​</span>            SOAP Request Handler
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;/javaee:handler-name&gt;</span>
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;javaee:handler-class&gt;</span>
<span xmlns="" class="line">​</span>            org.jboss.seam.webservice.SOAPRequestHandler
<span xmlns="" class="line">​</span>          <span xmlns="" class="perl_Keyword">&lt;/javaee:handler-class&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;/javaee:handler&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;/javaee:handler-chain&gt;</span>
<span xmlns="" class="line">​</span>      
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/pre-handler-chains&gt;</span>
<span xmlns="" class="line">​</span>    
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/endpoint-config&gt;</span>
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/jaxws-config&gt;</span>
</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690529703552">
      ⁠</a>23.2. Conversational Web Services</h1></div></div></div><div class="para">
			Seam uses a SOAP header element in both SOAP request and response messages to carry the conversation ID between the consumer and the service. One example of a web service request containing a conversation ID is:
		</div><pre class="programlisting XML"><span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;soapenv:Envelope</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">         xmlns:soapenv=</span><span xmlns="" class="perl_String">"http://schemas.xmlsoap.org/soap/envelope/"</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">         xmlns:seam=</span><span xmlns="" class="perl_String">"http://seambay.example.seam.jboss.org/"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>                  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;soapenv:Header&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;seam:conversationId</span><span xmlns="" class="perl_Others"> xmlns:seam=</span><span xmlns="" class="perl_String">'http://www.jboss.org/seam/webservice'</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>      2
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/seam:conversationId&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/soapenv:Header&gt;</span>
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;soapenv:Body&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;seam:confirmAuction/&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/soapenv:Body&gt;</span>
<span xmlns="" class="line">​</span>  
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/soapenv:Envelope&gt;</span>    
<span xmlns="" class="line">​</span>
</pre><div class="para">
			The above SOAP message contains a <code class="literal">conversationId</code> element, which contains the conversation ID for the request — in this case, <code class="literal">2</code>. Because web services can be consumed by a variety of web service clients written in a variety of languages, the developer is responsible for implementing conversation ID propagation between individual web services to be used in a single conversation's scope.
		</div><div class="para">
			The <code class="literal">conversationId</code> header element must be qualified with a namespace of <code class="literal">http://www.jboss.org/seam/webservice</code>, or Seam will be unable to read the conversation ID from the request. An example response to the above request message is:
		</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;env:Envelope</span><span xmlns="" class="perl_Others"> xmlns:env=</span><span xmlns="" class="perl_String">'http://schemas.xmlsoap.org/soap/envelope/'</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;env:Header&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;seam:conversationId</span><span xmlns="" class="perl_Others"> xmlns:seam=</span><span xmlns="" class="perl_String">'http://www.jboss.org/seam/webservice'</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>      2
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/seam:conversationId&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/env:Header&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;env:Body&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;confirmAuctionResponse</span> 
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">       xmlns=</span><span xmlns="" class="perl_String">"http://seambay.example.seam.jboss.org/"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/env:Body&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/env:Envelope&gt;</span>
</pre><div class="para">
			Note that the response message contains the same <code class="literal">conversationId</code> element as the request.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690510552368">
      ⁠</a>23.2.1. A Recommended Strategy</h2></div></div></div><div class="para">
				Since web services must be implemented as either stateless session beans or POJOs, we recommend that conversational web services implement the web service as a facade for a conversational Seam component.
			</div><div class="mediaobject" style="text-align: center"><img src="images/ws-strategy.png" align="middle" alt="A Recommended Strategy" style="text-align: middle"/></div><div class="para">
				If the web service is written as a stateless session bean, it can be transformed into a Seam component by annotating it with <code class="literal">@Name</code>. This allows Seam bijection, and other features, to be used in the web service class itself.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690493766576">
      ⁠</a>23.3. An example web service</h1></div></div></div><div class="para">
			The example code that follows is from the seamBay example application, which can be found in Seam's <code class="literal">/examples</code> directory, and follows the recommended strategy outlined in the previous section. First, we will look at the web service class and one of its web service methods:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Stateless
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">WebService</span>(name = <span xmlns="" class="perl_String">"AuctionService"</span>, serviceName = <span xmlns="" class="perl_String">"AuctionService"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> AuctionService <span xmlns="" class="perl_Keyword">implements</span> AuctionServiceRemote
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>  @WebMethod
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">boolean</span> <span xmlns="" class="perl_Function">login</span>(String username, String password)
<span xmlns="" class="line">​</span>  {
<span xmlns="" class="line">​</span>    Identity.<span xmlns="" class="perl_Function">instance</span>().<span xmlns="" class="perl_Function">setUsername</span>(username);
<span xmlns="" class="line">​</span>    Identity.<span xmlns="" class="perl_Function">instance</span>().<span xmlns="" class="perl_Function">setPassword</span>(password);
<span xmlns="" class="line">​</span>    Identity.<span xmlns="" class="perl_Function">instance</span>().<span xmlns="" class="perl_Function">login</span>();
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">return</span> Identity.<span xmlns="" class="perl_Function">instance</span>().<span xmlns="" class="perl_Function">isLoggedIn</span>();
<span xmlns="" class="line">​</span>  }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Comment">// snip</span>
<span xmlns="" class="line">​</span>}
</pre><div class="para">
			Here, the web service is a stateless session bean annotated with the JWS annotations from the <code class="literal">javax.jws</code> package, as defined by JSR-181. The <code class="literal">@WebService</code> annotation tells the container that this class implements a web service. The <code class="literal">@WebMethod</code> annotation on the <code class="literal">login()</code> method identifies the method as a web service method. The <code class="literal">name</code> and <code class="literal">serviceName</code> attributes in the <code class="literal">@WebService</code> annotation are optional.
		</div><div class="para">
			When the web service is a stateless session bean, each method that will be exposed as a web service method must also be declared in the remote interface of the web service class. In the previous example, since the <code class="literal">AuctionServiceRemote</code> interface is annotated as a <code class="literal">@WebService</code>, it must declare the <code class="literal">login()</code> method.
		</div><div class="para">
			In the previous example, the web service implements a <code class="literal">login()</code> method that delegates to Seam's built-in <code class="literal">Identity</code> component. As our recommended strategy suggests, the web service is written as a simple facade. The real work takes place in a Seam component. This means that business logic is reused efficiently between web services and other clients.
		</div><div class="para">
			In the following example, the web service method begins a new conversation by delegating to the <code class="literal">AuctionAction.createAuction()</code> method:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@WebMethod
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">createAuction</span>(String title, String description, <span xmlns="" class="perl_DataType">int</span> categoryId)
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>  AuctionAction action = 
<span xmlns="" class="line">​</span>    (AuctionAction) Component.<span xmlns="" class="perl_Function">getInstance</span>(AuctionAction.<span xmlns="" class="perl_Function">class</span>, <span xmlns="" class="perl_Keyword">true</span>);
<span xmlns="" class="line">​</span>  action.<span xmlns="" class="perl_Function">createAuction</span>();
<span xmlns="" class="line">​</span>  action.<span xmlns="" class="perl_Function">setDetails</span>(title, description, categoryId);
<span xmlns="" class="line">​</span>}
</pre><div class="para">
			The code from <code class="literal">AuctionAction</code> is as follows:
		</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@Begin
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">createAuction</span>()
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>  auction = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">Auction</span>();
<span xmlns="" class="line">​</span>  auction.<span xmlns="" class="perl_Function">setAccount</span>(authenticatedAccount);
<span xmlns="" class="line">​</span>  auction.<span xmlns="" class="perl_Function">setStatus</span>(Auction.<span xmlns="" class="perl_Function">STATUS_UNLISTED</span>);        
<span xmlns="" class="line">​</span>  durationDays = DEFAULT_AUCTION_DURATION;
<span xmlns="" class="line">​</span>}
</pre><div class="para">
			Here, we see how web services can participate in long-running conversations by acting as a facade and delegating the real work to a conversational Seam component.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139690529720144">
      ⁠</a>23.4. RESTful HTTP web services with RESTEasy</h1></div></div></div><div class="para">
			Seam integrates the RESTEasy implementation of the JAX-RS specification (JSR 311). You can decide which of the following features are integrated with your Seam application:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					RESTEasy bootstrap and configuration, with automatic resource detection. and providers.
				</div></li><li class="listitem"><div class="para">
					SeamResourceServlet-served HTTP/REST requests, without the need for an external servlet or configuration in <code class="filename">web.xml</code>.
				</div></li><li class="listitem"><div class="para">
					Resources written as Seam components with full Seam life cycle management and bijection.
				</div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690462474000">
      ⁠</a>23.4.1. RESTEasy configuration and request serving</h2></div></div></div><div class="para">
				First, download the RESTEasy libraries and the <code class="filename">jaxrs-api.jar</code>, and deploy them alongside the integration library (<code class="filename">jboss-seam-resteasy.jar</code>) and any other libraries your application requires.
			</div><div class="para">
				In seam-gen based projects, this can be done by appending <code class="literal">jaxrs-api.jar</code>, <code class="literal">resteasy-jaxrs.jar</code> and <code class="literal">jboss-seam-resteasy.jar</code> to the <code class="literal">deployed-jars.list</code> (war deployment) or <code class="literal">deployed-jars-ear.list</code> (ear deployment) file. For a JBDS based project, copy the libraries mentioned above to the <code class="literal">EarContent/lib</code> (ear deployment) or <code class="literal">WebContent/WEB-INF/lib</code> (war deployment) folder and reload the project in the IDE.
			</div><div class="para">
				All classes annotated with <code class="literal">@javax.ws.rs.Path</code> will automatically be discovered and registered as HTTP resources at start up. Seam automatically accepts and serves HTTP requests with its built-in <code class="literal">SeamResourceServlet</code>. The URI of a resource is built like so:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						The URI begins with the pattern mapped in <code class="filename">web.xml</code> for the <code class="literal">SeamResourceServlet</code> — in the examples provided, <code class="literal">/seam/resource</code>. Change this setting to expose your RESTful resources under a different base. Remember that this is a <span class="emphasis"><em>global</em></span> change, and other Seam resources (<code class="literal">s:graphicImage</code>) will also be served under this base path.
					</div></li><li class="listitem"><div class="para">
						Seam's RESTEasy integration then appends a configurable string to the base path (<code class="literal">/rest</code> by default). So, in the example, the full base path of your resources would be <code class="literal">/seam/resource/rest</code>. We recommend changing this string in your application to something more descriptive — add a version number to prepare for future REST API upgrades. This allows old clients to keep the old URI base.
					</div></li><li class="listitem"><div class="para">
						Finally, the resource is made available under the defined <code class="literal">@Path</code>. For example, a resource mapped with <code class="literal">@Path("/customer")</code> would be available under <code class="literal">/seam/resource/rest/customer</code>.
					</div></li></ul></div><div class="para">
				The following resource definition would return a plain text representation for any GET request using the URI <code class="literal">http://your.hostname/seam/resource/rest/customer/123</code>:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/customer"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MyCustomerResource {
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    @GET
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/{customerId}"</span>)
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Produces</span>(<span xmlns="" class="perl_String">"text/plain"</span>)
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> String <span xmlns="" class="perl_Function">getCustomer</span>(@<span xmlns="" class="perl_Function">PathParam</span>(<span xmlns="" class="perl_String">"customerId"</span>) <span xmlns="" class="perl_DataType">int</span> id) {
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">return</span> ...;
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
				If these defaults are acceptable, there is no need for additional configuration. However, if required, you can configure RESTEasy in your Seam application. First, import the <code class="literal">resteasy</code> namespace into your XML configuration file header:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;components</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xmlns=</span><span xmlns="" class="perl_String">"http://jboss.com/products/seam/components"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xmlns:resteasy=</span><span xmlns="" class="perl_String">"http://jboss.com/products/seam/resteasy"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xmlns:xsi=</span><span xmlns="" class="perl_String">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   xsi:schemaLocation=</span>
<span xmlns="" class="line">​</span>     <span xmlns="" class="perl_String">"http://jboss.com/products/seam/resteasy</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">      http://jboss.com/products/seam/resteasy-2.2.xsd</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">      http://jboss.com/products/seam/components</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_String">      http://jboss.com/products/seam/components-2.2.xsd"</span><span xmlns="" class="perl_Keyword">&gt;</span></pre><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:application</span><span xmlns="" class="perl_Others"> resource-path-prefix=</span><span xmlns="" class="perl_String">"/restv1"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
				The full base path to your resources is now <code class="literal">/seam/resource/restv1/{resource}</code>. Note that your <code class="literal">@Path</code> definitions and mappings do not change. This is an application-wide switch, usually used for versioning of the HTTP API.
			</div><div class="para">
				If you want to map the full path in your resources, you can disable base path stripping:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:application</span><span xmlns="" class="perl_Others"> strip-seam-resource-path=</span><span xmlns="" class="perl_String">"false"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
</pre><div class="para">
				Here, the path of a resource is now mapped with <code class="literal">@Path("/seam/resource/rest/customer")</code>. Disabling this feature binds your resource class mappings to a particular deployment scenario. This is <span class="emphasis"><em>not</em></span> recommended.
			</div><div class="para">
				Seam scans your classpath for any deployed <code class="literal">@javax.ws.rs.Path</code> resources or <code class="literal">@javax.ws.rs.ext.Provider</code> classes. You can disable scanning and configure these classes manually like so:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:application</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     scan-providers=</span><span xmlns="" class="perl_String">"false"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     scan-resources=</span><span xmlns="" class="perl_String">"false"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">     use-builtin-providers=</span><span xmlns="" class="perl_String">"true"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;resteasy:resource-class-names&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;value&gt;</span>org.foo.MyCustomerResource<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;value&gt;</span>org.foo.MyOrderResource<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span>
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">&lt;value&gt;</span>org.foo.MyStatelessEJBImplementation<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/resteasy:resource-class-names&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;resteasy:provider-class-names&gt;</span> 
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;value&gt;</span>org.foo.MyFancyProvider<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Keyword">&lt;/resteasy:provider-class-names&gt;</span> 
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span> <span xmlns="" class="perl_Keyword">&lt;/resteasy:application&gt;</span></pre><div class="para">
				The <code class="literal">use-built-in-providers</code> switch enables (default) or disables the RESTEasy built-in providers. Since these provide plain text, JSON and JAXB marshaling, we recommend that these are left enabled.
			</div><div class="para">
				RESTEasy supports plain EJBs (EJBs that are not Seam components) as resources. Instead of configuring the JNDI names in a non-portable fashion in <code class="filename">web.xml</code> (see RESTEasy documentation), you can simply list the EJB implementation classes, not the business interfaces, in <code class="filename">components.xml</code> as shown above. Note that you have to annotate the <code class="literal">@Local</code> interface of the EJB with <code class="literal">@Path</code>, <code class="literal">@GET</code>, and so on - not the bean implementation class. This allows you to keep your application deployment-portable with the global Seam <code class="literal">jndi-pattern</code> switch on <code class="literal">&lt;core:init/&gt;</code>. Note that plain (non-Seam component) EJB resources will not be found even if scanning of resources is enabled, you always have to list them manually. Again, this whole paragraph is only relevant for EJB resources that are not also Seam components and that do not have an <code class="literal">@Name</code> annotation.
			</div><div class="para">
				Finally, you can configure media type and language URI extensions:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:application&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;resteasy:media-type-mappings&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;key&gt;</span>txt<span xmlns="" class="perl_Keyword">&lt;/key&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;value&gt;</span>text/plain<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/resteasy:media-type-mappings&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;resteasy:language-mappings&gt;</span>
<span xmlns="" class="line">​</span>       <span xmlns="" class="perl_Keyword">&lt;key&gt;</span>deutsch<span xmlns="" class="perl_Keyword">&lt;/key&gt;&lt;value&gt;</span>de-DE<span xmlns="" class="perl_Keyword">&lt;/value&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/resteasy:language-mappings&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/resteasy:application&gt;</span></pre><div class="para">
				This definition would map the URI suffix of <code class="literal">.txt.deutsch</code> to the additional <code class="literal">Accept</code> and <code class="literal">Accept-Language</code> header values, <code class="literal">text/plain</code> and <code class="literal">de-DE</code>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690514951312">
      ⁠</a>23.4.2. Resources and providers as Seam components</h2></div></div></div><div class="para">
				Resource and provider instances are, by default, managed by RESTEasy. A resource class will be instantiated by RESTEasy and serve a single request, after which it will be destroyed. This is the default JAX-RS life cycle. Providers are instantiated once for the entire application. These are stateless singletons.
			</div><div class="para">
				Resources and providers can also be written as Seam components to take advantage of Seam's richer life cycle management, and bijection and security abilities. Make your resource class into a Seam component like so:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"customerResource"</span>)
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/customer"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MyCustomerResource {
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    @In
<span xmlns="" class="line">​</span>    CustomerDAO customerDAO;
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    @GET
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/{customerId}"</span>)
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Produces</span>(<span xmlns="" class="perl_String">"text/plain"</span>)
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> String <span xmlns="" class="perl_Function">getCustomer</span>(@<span xmlns="" class="perl_Function">PathParam</span>(<span xmlns="" class="perl_String">"customerId"</span>) <span xmlns="" class="perl_DataType">int</span> id) {
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">return</span> customerDAO.<span xmlns="" class="perl_Function">find</span>(id).<span xmlns="" class="perl_Function">getName</span>();
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
				A <code class="literal">customerResource</code> instance is now handled by Seam when a request hits the server. This component is event-scoped, so its life cycle is identical to that of the JAX-RS. However, the Seam JavaBean component gives you full injection support, and full access to all other components and contexts. Session, application, and stateless resource components are also supported. These three scopes allow you to create an effectively stateless Seam middle-tier HTTP request-processing application. 
			</div><div class="para">
				You can annotate an interface and keep the implementation free from JAX-RS annotations:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/customer"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">interface</span> MyCustomerResource {
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    @GET
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"/{customerId}"</span>)
<span xmlns="" class="line">​</span>    @<span xmlns="" class="perl_Function">Produces</span>(<span xmlns="" class="perl_String">"text/plain"</span>)
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> String <span xmlns="" class="perl_Function">getCustomer</span>(@<span xmlns="" class="perl_Function">PathParam</span>(<span xmlns="" class="perl_String">"customerId"</span>) <span xmlns="" class="perl_DataType">int</span> id);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>}</pre><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"customerResource"</span>)
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Scope</span>(ScopeType.<span xmlns="" class="perl_Function">STATELESS</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MyCustomerResourceBean <span xmlns="" class="perl_Keyword">implements</span> MyCustomerResource {
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    @In
<span xmlns="" class="line">​</span>    CustomerDAO customerDAO;
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">public</span> String <span xmlns="" class="perl_Function">getCustomer</span>(<span xmlns="" class="perl_DataType">int</span> id) {
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">return</span> customerDAO.<span xmlns="" class="perl_Function">find</span>(id).<span xmlns="" class="perl_Function">getName</span>();
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>}</pre><div class="para">
				You can use <code class="literal">SESSION</code>-scoped Seam components. By default, the session will however be shortened to a single request. In other words, when an HTTP request is being processed by the RESTEasy integration code, an HTTP session will be created so that Seam components can utilize that context. When the request has been processed, Seam will look at the session and decide if the session was created only to serve that single request (no session identifier has been provided with the request, or no session existed for the request). If the session has been created only to serve this request, the session will be destroyed after the request!
			</div><div class="para">
				Assuming that your Seam application only uses event, application, or stateless components, this procedure prevents exhaustion of available HTTP sessions on the server. The RESTEasy integration with Seam assumes by default that sessions are not used, hence anemic sessions would add up as every REST request would start a session that will only be removed when timed out.
			</div><div class="para">
				If your RESTful Seam application has to preserve session state across REST HTTP requests, disable this behavior in your configuration file:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:application</span><span xmlns="" class="perl_Others"> destroy-session-after-request=</span><span xmlns="" class="perl_String">"false"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
				Every REST HTTP request will now create a new session that will only be removed by timeout or explicit invalidation in your code through <code class="literal">Session.instance().invalidate()</code>. It is your responsibility to pass a valid session identifier along with your HTTP requests, if you want to utilize the session context across requests.
			</div><div class="para">
				Conversation-scoped resource components and conversation mapping are not currently supported, but are planned for future versions of Seam.
			</div><div class="para">
				Provider classes can also be Seam components. They must be either application-scoped or stateless.
			</div><div class="para">
				Resources and providers can be EJBs or JavaBeans, like any other Seam component.
			</div><div class="para">
				EJB Seam components are supported as REST resources. Always annotate the local business interface, not the EJB implementation class, with JAX-RS annotations. The EJB has to be <code class="literal">STATELESS</code>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					RESTEasy components do not support hot redeployment. As a result, the components should never be placed in the <code class="literal">src/hot</code> folder. The <code class="literal">src/main</code> folder should be used instead.
				</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Sub-resources as defined in the JAX RS specification, section 3.4.1, can not be Seam component instances at this time. Only root resource classes can be registered as Seam components. In other words, do not return a Seam component instance from a root resource method.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690447394416">
      ⁠</a>23.4.3. Securing resources</h2></div></div></div><div class="para">
				You can enable the Seam authentication filter for HTTP Basic and Digest authentication in <code class="filename">components.xml</code>:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;web:authentication-filter</span><span xmlns="" class="perl_Others"> url-pattern=</span><span xmlns="" class="perl_String">"/seam/resource/rest/*"</span><span xmlns="" class="perl_Others"> auth-type=</span><span xmlns="" class="perl_String">"basic"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
				See the Seam security chapter on how to write an authentication routine.
			</div><div class="para">
				After successful authentication, authorization rules with the common <code class="literal">@Restrict</code> and <code class="literal">@PermissionCheck</code> annotations are in effect. You can also access the client <code class="literal">Identity</code>, work with permission mapping, and so on. All regular Seam security features for authorization are available.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690492872544">
      ⁠</a>23.4.4. Mapping exceptions to HTTP responses</h2></div></div></div><div class="para">
				Section 3.3.4 of the JAX-RS specification defines how JAX RS handles checked and unchecked exceptions. Integrating RESTEasy with Seam allows you to map exceptions to HTTP response codes within Seam's <code class="filename">pages.xml</code>. If you use <code class="filename">pages.xml</code> already, this is easier to maintain than many JAX RS exception mapper classes.
			</div><div class="para">
				For exceptions to be handled within Seam, the Seam filter must be executed for your HTTP request. You must filter all requests in your <code class="filename">web.xml</code>, <span class="emphasis"><em>not</em></span> as a request URI pattern that does not cover your REST requests. The following example intercepts all HTTP requests and enables Seam exception handling:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;filter&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;filter-name&gt;</span>Seam Filter<span xmlns="" class="perl_Keyword">&lt;/filter-name&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;filter-class&gt;</span>org.jboss.seam.servlet.SeamFilter<span xmlns="" class="perl_Keyword">&lt;/filter-class&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/filter&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;filter-mapping&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;filter-name&gt;</span>Seam Filter<span xmlns="" class="perl_Keyword">&lt;/filter-name&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;url-pattern&gt;</span>/*<span xmlns="" class="perl_Keyword">&lt;/url-pattern&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/filter-mapping&gt;</span></pre><div class="para">
				To convert the unchecked <code class="literal">UnsupportedOperationException</code> thrown by your resource methods to a <code class="literal">501 Not Implemented</code> HTTP status response, add the following to your <code class="filename">pages.xml</code> descriptor:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;exception</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"java.lang.UnsupportedOperationException"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;http-error</span><span xmlns="" class="perl_Others"> error-code=</span><span xmlns="" class="perl_String">"501"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;message&gt;</span>The requested operation is not supported<span xmlns="" class="perl_Keyword">&lt;/message&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/http-error&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/exception&gt;</span></pre><div class="para">
				Custom or checked exceptions are handled in the same way:
			</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;exception</span><span xmlns="" class="perl_Others"> class=</span><span xmlns="" class="perl_String">"my.CustomException"</span><span xmlns="" class="perl_Others"> log=</span><span xmlns="" class="perl_String">"false"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;http-error</span><span xmlns="" class="perl_Others"> error-code=</span><span xmlns="" class="perl_String">"503"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">&lt;message&gt;</span>Service not available: #{org.jboss.seam.handledException.message}<span xmlns="" class="perl_Keyword">&lt;/message&gt;</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">&lt;/http-error&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/exception&gt;</span></pre><div class="para">
				You do not have to send a HTTP error to the client if an exception occurs. Seam lets you map the exception as a redirect to a view of your Seam application. Since this feature is typically used for human clients (web browsers) and not for REST API remote clients, you should pay attention to conflicting exception mappings in <code class="filename">pages.xml</code>.
			</div><div class="para">
				The HTTP response does pass through the servlet container, so an additional mapping may apply if you have <code class="literal">&lt;error-page&gt;</code> mappings in your <code class="literal">web.xml</code> configuration. The HTTP status code would then be mapped to a rendered HTML error page with status <code class="literal">200 OK</code>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690496155872">
      ⁠</a>23.4.5. Exposing entities via RESTful API</h2></div></div></div><div class="para">
				Seam makes it really easy to use a RESTful approach for accessing application data. One of the improvements that Seam introduces is the ability to expose parts of your SQL database for remote access via plain HTTP calls. For this purpose, the Seam/RESTEasy integration module provides two components: <code class="literal">ResourceHome</code> and <code class="literal">ResourceQuery</code>, which benefit from the API provided by the Seam Application Framework (<a class="xref" href="framework.html">Chapter 13, <em>The Seam Application Framework</em></a>). These components allow you to bind domain model entity classes to an HTTP API.
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139690509688752">
      ⁠</a>23.4.5.1. ResourceQuery</h3></div></div></div><div class="para">
					ResourceQuery exposes entity querying capabilities as a RESTful web service. By default, a simple underlying Query component, which returns a list of instances of a given entity class, is created automatically. Alternatively, the ResourceQuery component can be attached to an existing Query component in more sophisticated cases. The following example demonstrates how easily ResourceQuery can be configured:
				</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:resource-query</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   path=</span><span xmlns="" class="perl_String">"/user"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   name=</span><span xmlns="" class="perl_String">"userResourceQuery"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   entity-class=</span><span xmlns="" class="perl_String">"com.example.User"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					With this single XML element, a ResourceQuery component is set up. The configuration is straightforward:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							The component will return a list of <code class="literal">com.example.User</code> instances.
						</div></li><li class="listitem"><div class="para">
							The component will handle HTTP requests on the URI path <code class="filename">/user</code>.
						</div></li><li class="listitem"><div class="para">
							The component will by default transform the data into XML or JSON (based on client's preference). The set of supported mime types can be altered by using the <code class="varname">media-types</code> attribute, for example:
						</div></li></ul></div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:resource-query</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   path=</span><span xmlns="" class="perl_String">"/user"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   name=</span><span xmlns="" class="perl_String">"userResourceQuery"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   entity-class=</span><span xmlns="" class="perl_String">"com.example.User"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   media-types=</span><span xmlns="" class="perl_String">"application/fastinfoset"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					Alternatively, if you do not like configuring components using XML, you can set up the component by extension:
				</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"userResourceQuery"</span>)
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"user"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> UserResourceQuery <span xmlns="" class="perl_Keyword">extends</span> ResourceQuery&lt;User&gt;
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>}</pre><div class="para">
					Queries are read-only operations, the resource only responds to GET requests. Furthermore, ResourceQuery allows clients of a web service to manipulate the resultset of a query using the following path parameters:
				</div><div class="informaltable"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows"><colgroup><col/><col/><col/></colgroup><thead><tr><th> Parameter name </th><th> Example </th><th> Description </th></tr></thead><tbody><tr><td> start </td><td> /user?start=20 </td><td> Returns a subset of a database query result starting with the 20th entry. </td></tr><tr><td> show </td><td> /user?show=10 </td><td> Returns a subset of the database query result limited to 10 entries. </td></tr></tbody></table></div><div class="para">
					For example, you can send an HTTP GET request to <code class="literal">/user?start=30&amp;show=10</code> to get a list of entries representing 10 rows starting with row 30.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						RESTEasy uses JAXB to marshall entities. Thus, in order to be able to transfer them over the wire, you need to annotate entity classes with <code class="literal">@XMLRootElement</code>. Consult the JAXB and RESTEasy documentation for more information.
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm139690506973792">
      ⁠</a>23.4.5.2. ResourceHome</h3></div></div></div><div class="para">
					Just as ResourceQuery makes Query's API available for remote access, so does ResourceHome for the Home component. The following table describes how the two APIs (HTTP and Home) are bound together.
				</div><div class="table"><a id="idm139690515153584">
      ⁠</a><p class="title"><strong>Table 23.1. Bindings in ResourceHome</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="gt-4-cols lt-7-rows" summary="Bindings in ResourceHome"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th> HTTP method </th><th> Path </th><th> Function </th><th> ResourceHome method </th></tr></thead><tbody><tr><td> GET </td><td> {path}/{id} </td><td> Read </td><td> getResource() </td></tr><tr><td> POST </td><td> {path} </td><td> Create </td><td> postResource() </td></tr><tr><td> PUT </td><td> {path}/{id} </td><td> Update </td><td> putResource() </td></tr><tr><td> DELETE </td><td> {path}/{id} </td><td> Delete </td><td> deleteResource() </td></tr></tbody></table></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							You can GET, PUT, and DELETE a particular user instance by sending HTTP requests to /user/{userId}
						</div></li><li class="listitem"><div class="para">
							Sending a POST request to <code class="filename">/user</code> creates a new user entity instance and persists it. Usually, you leave it up to the persistence layer to provide the entity instance with an identifier value and thus an URI. Therefore, the URI is sent back to the client in the <code class="literal">Location</code> header of the HTTP response.
						</div></li></ul></div><div class="para">
					The configuration of ResourceHome is very similar to ResourceQuery except that you need to explicitly specify the underlying Home component and the Java type of the entity identifier property.
				</div><pre class="programlisting XML"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;resteasy:resource-home</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   path=</span><span xmlns="" class="perl_String">"/user"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   name=</span><span xmlns="" class="perl_String">"userResourceHome"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   entity-home=</span><span xmlns="" class="perl_String">"#{userHome}"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">   entity-id-class=</span><span xmlns="" class="perl_String">"java.lang.Integer"</span><span xmlns="" class="perl_Keyword">/&gt;</span></pre><div class="para">
					Again, you can write a subclass of ResourceHome instead of XML:
				</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Name</span>(<span xmlns="" class="perl_String">"userResourceHome"</span>)
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Path</span>(<span xmlns="" class="perl_String">"user"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> UserResourceHome <span xmlns="" class="perl_Keyword">extends</span> ResourceHome&lt;User, Integer&gt;
<span xmlns="" class="line">​</span>{
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   @In
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">private</span> EntityHome&lt;User&gt; userHome;
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   @Override
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> Home&lt;?, User&gt; <span xmlns="" class="perl_Function">getEntityHome</span>()
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">return</span> userHome;
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}</pre><div class="para">
					For more examples of ResourceHome and ResourceQuery components, take a look at the <span class="emphasis"><em>Seam Tasks</em></span> example application, which demonstrates how Seam/RESTEasy integration can be used together with a jQuery web client. In addition, you can find more code example in the <span class="emphasis"><em>Restbay</em></span> example, which is used mainly for testing purposes.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139690519342352">
      ⁠</a>23.4.6. Testing resources and providers</h2></div></div></div><div class="para">
				Seam includes a unit testing utility class that helps you create unit tests for a RESTful architecture. Extend the <code class="literal">SeamTest</code> class as usual and use the <code class="literal">ResourceRequestEnvironment.ResourceRequest</code> to emulate HTTP requests/response cycles:
			</div><pre class="programlisting JAVA"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">import org.jboss.seam.mock.ResourceRequestEnvironment;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">import org.jboss.seam.mock.EnhancedMockHttpServletRequest;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">import org.jboss.seam.mock.EnhancedMockHttpServletResponse;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">import static org.jboss.seam.mock.ResourceRequestEnvironment.ResourceRequest;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">import static org.jboss.seam.mock.ResourceRequestEnvironment.Method;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MyTest <span xmlns="" class="perl_Keyword">extends</span> SeamTest {
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   ResourceRequestEnvironment sharedEnvironment;
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   @BeforeClass
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">prepareSharedEnvironment</span>() <span xmlns="" class="perl_Keyword">throws</span> Exception {
<span xmlns="" class="line">​</span>       sharedEnvironment = <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">ResourceRequestEnvironment</span>(<span xmlns="" class="perl_Keyword">this</span>) {
<span xmlns="" class="line">​</span>            @Override
<span xmlns="" class="line">​</span>            <span xmlns="" class="perl_Keyword">public</span> Map&lt;String, Object&gt; <span xmlns="" class="perl_Function">getDefaultHeaders</span>() {
<span xmlns="" class="line">​</span>               <span xmlns="" class="perl_Keyword">return</span> <span xmlns="" class="perl_Keyword">new</span> HashMap&lt;String, Object&gt;() {{
<span xmlns="" class="line">​</span>                   <span xmlns="" class="perl_Function">put</span>(<span xmlns="" class="perl_String">"Accept"</span>, <span xmlns="" class="perl_String">"text/plain"</span>);
<span xmlns="" class="line">​</span>               }};
<span xmlns="" class="line">​</span>            }
<span xmlns="" class="line">​</span>         };
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   @Test
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">test</span>() <span xmlns="" class="perl_Keyword">throws</span> Exception
<span xmlns="" class="line">​</span>   {
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Comment">//Not shared: new ResourceRequest(new ResourceRequestEnvironment(this), Method.GET, "/my/relative/uri)</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">ResourceRequest</span>(sharedEnvironment, Method.<span xmlns="" class="perl_Function">GET</span>, <span xmlns="" class="perl_String">"/my/relative/uri)</span>
<span xmlns="" class="line">​</span>      {
<span xmlns="" class="line">​</span>         @Override
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">protected</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">prepareRequest</span>(EnhancedMockHttpServletRequest request)
<span xmlns="" class="line">​</span>         {
<span xmlns="" class="line">​</span>            request.<span xmlns="" class="perl_Function">addQueryParameter</span>(<span xmlns="" class="perl_String">"foo"</span>, <span xmlns="" class="perl_String">"123"</span>);
<span xmlns="" class="line">​</span>            request.<span xmlns="" class="perl_Function">addHeader</span>(<span xmlns="" class="perl_String">"Accept-Language"</span>, <span xmlns="" class="perl_String">"en_US, de"</span>);
<span xmlns="" class="line">​</span>         }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>         @Override
<span xmlns="" class="line">​</span>         <span xmlns="" class="perl_Keyword">protected</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">onResponse</span>(EnhancedMockHttpServletResponse response)
<span xmlns="" class="line">​</span>         {
<span xmlns="" class="line">​</span>            assert response.<span xmlns="" class="perl_Function">getStatus</span>() == <span xmlns="" class="perl_Float">200</span>;
<span xmlns="" class="line">​</span>            assert response.<span xmlns="" class="perl_Function">getContentAsString</span>().<span xmlns="" class="perl_Function">equals</span>(<span xmlns="" class="perl_String">"foobar"</span>);
<span xmlns="" class="line">​</span>         }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>      }.<span xmlns="" class="perl_Function">run</span>();
<span xmlns="" class="line">​</span>   }
<span xmlns="" class="line">​</span>}</pre><div class="para">
				This test only executes local calls, it does not communicate with the <code class="literal">SeamResourceServlet</code> through TCP. The mock request is passed through the Seam servlet and filters and the response is then available for test assertions. Overriding the <code class="methodname">getDefaultHeaders()</code> method in a shared instance of <code class="literal">ResourceRequestEnvironment</code> allows you to set request headers for every test method in the test class.
			</div><div class="para">
				Note that a <code class="literal">ResourceRequest</code> has to be executed in a <code class="literal">@Test</code> method or in a <code class="literal">@BeforeMethod</code> callback. You can not execute it in any other callback, such as <code class="literal">@BeforeClass</code>.
			</div></div></div></div></body></html>