<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 23. Hibernate Search</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Hibernate_Search">
      ⁠</a>Chapter 23. Hibernate Search</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Getting_Started_with_Hibernate_Search">
      ⁠</a>23.1. Getting Started with Hibernate Search</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="About_Hibernate_Search">
      ⁠</a>23.1.1. About Hibernate Search</h2></div></div></div><div class="para">
		Hibernate Search provides full-text search capability to Hibernate applications. It is especially suited to search applications for which SQL-based solutions are not suited, including: full-text, fuzzy and geolocation searches. Hibernate Search uses Apache Lucene as its full-text search engine, but is designed to minimize the maintenance overhead. Once it is configured, indexing, clustering and data synchronization is maintained transparently, allowing you to focus on meeting your business requirements.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+42279-743936+%5BLatest%5D&amp;comment=Title%3A+About+Hibernate+Search%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=42279-743936+18+Feb+2015+23%3A18+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Overview7">
      ⁠</a>23.1.2. Overview</h2></div></div></div><div class="para">
		Hibernate Search consists of an indexing component as well as an index search component, both are backed by Apache Lucene. Each time an entity is inserted, updated or removed in/from the database, Hibernate Search keeps track of this event (through the Hibernate event system) and schedules an index update. All these updates are handled without you having to interact with the Apache Lucene APIs directly. Instead, interaction with the underlying Lucene indexes is handled via an <code class="classname">IndexManager</code>.
	</div><div class="para">
		Once the index is created, you can search for entities and return lists of managed entities instead of dealing with the underlying Lucene infrastructure. The same persistence context is shared between Hibernate and Hibernate Search. The <code class="classname">FullTextSession</code> class is built on top of the Hibernate <code class="classname">Session</code> class so that the application code can use the unified <code class="classname">org.hibernate.Query</code> or <code class="classname">javax.persistence.Query</code> APIs exactly the same way an HQL, JPA-QL, or native query would do.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			It is recommended - for both your database and Hibernate Search - to execute your operations in a transaction, be it JDBC or JTA.
		</div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			Hibernate Search works perfectly fine in the Hibernate / EntityManager long conversation pattern, known as atomic conversation.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14269-749072+%5BLatest%5D&amp;comment=Title%3A+Overview%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14269-749072+29+Mar+2015+23%3A13+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="About_the_Index_Manager">
      ⁠</a>23.1.3. About the Index Manager</h2></div></div></div><div class="para">
		Each time an entity is inserted, updated or removed from the database, Hibernate Search keeps track of this event through the Hibernate event system and schedules an index update. Interaction with the underlying Lucene indexes is handled by an <em class="firstterm">IndexManager</em>, each of which is uniquely identified by name. By default there is a one-to-one relationship between IndexManager and Lucene index. The IndexManager abstracts the specific index configuration, including the selected <em class="firstterm">backend</em>, <em class="firstterm">reader strategy</em> and the chosen <em class="firstterm">DirectoryProvider</em>.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+43126-749081+%5BLatest%5D&amp;comment=Title%3A+About+the+Index+Manager%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=43126-749081+30+Mar+2015+00%3A21+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="About_the_Directory_Provider">
      ⁠</a>23.1.4. About the Directory Provider</h2></div></div></div><div class="para">
		Apache Lucene, which is part of the Hibernate Search infrastructure, has the concept of a Directory for storage of indexes. Hibernate Search handles the initialization and configuration of a Lucene Directory instance via a <em class="firstterm">Directory Provider</em>.
	</div><div class="para">
		The <code class="literal">directory_provider</code> property specifies the directory provider to be used to store the indexes. The default filesystem directory provider is <code class="literal">filesystem</code>, which uses the local filesystem to store indexes.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+43127-748295+%5BLatest%5D&amp;comment=Title%3A+About+the+Directory+Provider%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=43127-748295+23+Mar+2015+19%3A02+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="About_the_Worker">
      ⁠</a>23.1.5. About the Worker</h2></div></div></div><div class="para">
		Updates to Lucene indexes are handled by the Hibernate Search <em class="firstterm">Worker</em>, which receives all entity changes, queues them by context and applies them once a context ends. The most common context is the transaction, but may be dependent on the number of entity changes or some other application (life cycle) events.
	</div><div class="para">
		For better efficiency, interactions are batched and generally applied once the context ends. Outside a transaction, the index update operation is executed right after the actual database operation. In the case of an ongoing transaction, the index update operation is scheduled for the transaction commit phase and discarded in case of transaction rollback. A worker may be configured with a specific batch size limit, after which indexing occurs regardless of the context.
	</div><div class="para">
		For details of Worker configuration options see <a class="xref" href="chap-Hibernate_Search.html#sect-Worker_Configuration">Section 23.2.5, “Worker Configuration”</a>.
	</div><div class="para">
		There are two immediate benefits to this method of handling index updates: 
		<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Performance: Lucene indexing works better when operation are executed in batch.
				</div></li><li class="listitem"><div class="para">
					ACIDity: The work executed has the same scoping as the one executed by the database transaction and is executed if and only if the transaction is committed. This is not ACID in the strict sense, but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the source at any time.
				</div></li></ul></div>

	</div><div class="para">
		The two batch modes - no scope vs transactional - are the equivalent of autocommit versus transactional behavior. From a performance perspective, the <span class="emphasis"><em>transactional</em></span> mode is recommended. The scoping choice is made transparently. Hibernate Search detects the presence of a transaction and adjust the scoping (see <a class="xref" href="chap-Hibernate_Search.html#sect-Worker_Configuration">Section 23.2.5, “Worker Configuration”</a>).
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+43148-748314+%5BLatest%5D&amp;comment=Title%3A+About+the+Worker%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=43148-748314+23+Mar+2015+20%3A06+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Back_End_Setup_and_Operations">
      ⁠</a>23.1.6. Back End Setup and Operations</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Back_End">
      ⁠</a>23.1.6.1. Back End</h3></div></div></div><div class="para">
		<span class="phrase">Hibernate Search</span> uses various back ends to process batches of work. The back end is not limited to the configuration option <code class="literal">default.worker.backend</code>. This property specifies a implementation of the <code class="classname">BackendQueueProcessor</code> interface which is a part of a back end configuration. Additional settings are required to set up a back end, for example the <span class="phrase">JMS</span> back end.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14264-592108+%5BLatest%5D&amp;comment=Title%3A+Back+End%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14264-592108+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Lucene1">
      ⁠</a>23.1.6.2. Lucene</h3></div></div></div><div class="para">
		In the Lucene mode, all index updates for a node (JVM) are executed by the same node to the Lucene directories using the directory providers. Use this mode in a non-clustered environment or in clustered environments with a shared directory store.
	</div><div class="figure"><a id="idm139978530120512">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/1603.png" align="middle" alt="Lucene Back End Configuration" style="text-align: middle"/></div></div><p class="title"><strong>Figure 23.1. Lucene Back End Configuration</strong></p></div><div class="para">
		Lucene mode targets non-clustered or clustered applications where the <code class="classname">Directory</code> manages the locking strategy. The primary advantage of Lucene mode is simplicity and immediate visibility of changes in Lucene queries. The Near Real Time (NRT) back end is an alternate back end for non-clustered and non-shared index configurations.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14270-592110+%5BLatest%5D&amp;comment=Title%3A+Lucene%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14270-592110+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="JMS1">
      ⁠</a>23.1.6.3. JMS</h3></div></div></div><div class="para">
		Index updates for a node are sent to the JMS queue. A unique reader processes the queue and updates the master index. The master index is subsequently replicated regularly to slave copies to establish the master/slave pattern. The master is responsible for Lucene index updates. The slaves accept read and write operations but process read operations on local index copies. The master is the sole responsible for updating the Lucene index. Only the master applies the local changes in an update operation.
	</div><div class="figure"><a id="idm139978514700112">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/1602.png" align="middle" alt="JMS Backend Configuration" style="text-align: middle"/></div></div><p class="title"><strong>Figure 23.2. JMS Backend Configuration</strong></p></div><div class="para">
		This mode targets clustered environments where throughput is critical and index update delays are affordable. The JMS provider ensures reliability and uses the slaves to change the local index copies.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14261-592108+%5BLatest%5D&amp;comment=Title%3A+JMS%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14261-592108+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Reader_Strategies">
      ⁠</a>23.1.7. Reader Strategies</h2></div></div></div><div class="para">
				When executing a query, <span class="phrase">Hibernate Search</span> uses a reader strategy to interact with the Apache Lucene indexes. Choose a reader strategy based on the profile of the application (frequent updates, read mostly, asynchronous index update, etc).
			</div><div class="para RoleCreateBugPara">
				<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+IDs%3A%0A14195-747783+%5BLatest%5D&amp;comment=Title%3A+Reader+Strategies%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Shared">
      ⁠</a>23.1.7.1. The Shared Strategy</h3></div></div></div><div class="para">
		Using the <code class="literal">shared</code> strategy, <span class="phrase">Hibernate Search</span> shares the same <code class="classname">IndexReader</code> for a given Lucene index across multiple queries and threads provided that the <code class="classname">IndexReader</code> remains updated. If the <code class="classname">IndexReader</code> is not updated, a new one is opened and provided. Each <code class="classname">IndexReader</code> is made of several <code class="classname">SegmentReader</code>s. The shared strategy reopens segments that have been modified or created after the last opening and shares the already loaded segments from the previous instance. This is the default strategy.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14197-592106+%5BLatest%5D&amp;comment=Title%3A+The+Shared+Strategy%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14197-592106+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Not-shared">
      ⁠</a>23.1.7.2. The Not-shared Strategy</h3></div></div></div><div class="para">
		Using the <code class="literal">not-shared</code> strategy, a Lucene <code class="classname">IndexReader</code> opens every time a query executes. Opening and starting up a <code class="classname">IndexReader</code> is an expensive operation. As a result, opening an <code class="classname">IndexReader</code> for each query execution is not an efficient strategy.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14201-592106+%5BLatest%5D&amp;comment=Title%3A+The+Not-shared+Strategy%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14201-592106+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Custom1">
      ⁠</a>23.1.7.3. Custom Reader Strategies</h3></div></div></div><div class="para">
		You can write a custom reader strategy using an implementation of <span class="phrase"><code class="classname">org.hibernate.search.reader.ReaderProvider</code></span>. The implementation must be thread safe.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14221-592105+%5BLatest%5D&amp;comment=Title%3A+Custom+Reader+Strategies%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14221-592105+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Reader_Strategy_Configuration">
      ⁠</a>23.1.7.4. Reader Strategy Configuration</h3></div></div></div><div class="para">
		Change the strategy from the default (<code class="literal">shared</code>) to <code class="literal">not-shared</code> as follows:
	</div><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = not-shared</pre><div class="para">
		Alternately, customize the reader strategy by replacing <code class="classname">my.corp.myapp.CustomReaderProvider</code> with the custom strategy implementation:
	</div><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider</pre><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14279-592110+%5BLatest%5D&amp;comment=Title%3A+Reader+Strategy+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14279-592110+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Configuration">
      ⁠</a>23.2. Configuration</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Minimum_Configuration">
      ⁠</a>23.2.1. Minimum Configuration</h2></div></div></div><div class="para">
		Hibernate Search has been designed to provide flexibility in its configuration and operation, with default values carefully chosen to suit the majority of use cases. At a minimum a <code class="literal">Directory Provider</code> must be configured, along with its properties. The default Directory Provider is <code class="literal">filesystem</code>, which uses the local filesystem for index storage. For details of available Directory Providers and their configuration, see <a class="xref" href="chap-Hibernate_Search.html#Directory_Configuration">Section 23.2.3, “DirectoryProvider Configuration”</a>.
	</div><div class="para">
		If you are using Hibernate directly, settings such as the DirectoryProvider must be set in the configuration file, either <code class="filename">hibernate.properties</code> or <code class="filename">hibernate.cfg.xml</code>. If you are using Hibernate via JPA the configuration file is <code class="filename">persistence.xml</code>.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+42280-747997+%5BLatest%5D&amp;comment=Title%3A+Minimum+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=42280-747997+20+Mar+2015+00%3A07+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Configuring_the_IndexManager">
      ⁠</a>23.2.2. Configuring the IndexManager</h2></div></div></div><div class="para">
				Hibernate Search offers several implementations for this interface:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">directory-based</code>: the default implementation which uses the Lucene <code class="classname">Directory</code> abstraction to manage index files.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">near-real-time</code>: avoids flushing writes to disk at each commit. This index manager is also <code class="classname">Directory</code> based, but uses Lucene's near real-time (NRT) functionality.
					</div></li></ul></div><div class="para">
				To specify an IndexManager other than the default, specify the following property:
			</div><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</pre><div class="para RoleCreateBugPara">
				<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+IDs%3A%0A14194-748105+%5BLatest%5D&amp;comment=Title%3A+Configuring+the+IndexManager%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Directory-based">
      ⁠</a>23.2.2.1. Directory-based</h3></div></div></div><div class="para">
		The <code class="literal">Directory-based</code> implementation is the default <code class="classname">IndexManager</code> implementation. It is highly configurable and allows separate configurations for the reader strategy, back ends, and directory providers.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14205-749752+%5BLatest%5D&amp;comment=Title%3A+Directory-based%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14205-749752+02+Apr+2015+08%3A13+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Near-real-time">
      ⁠</a>23.2.2.2. Near Real Time</h3></div></div></div><div class="para">
		The <code class="classname">NRTIndexManager</code> is an extension of the default <code class="classname">IndexManager</code> and leverages the Lucene NRT (Near Real Time) feature for low latency index writes. However, it ignores configuration settings for alternative back ends other than <code class="literal">lucene</code> and acquires exclusive write locks on the <code class="classname">Directory</code>.
	</div><div class="para">
		The <code class="classname">IndexWriter</code> does not flush every change to the disk to provide low latency. Queries can read the updated states from the unflushed index writer buffers. However, this means that if the <code class="classname">IndexWriter</code> is killed or the application crashes, updates can be lost so the indexes must be rebuilt.
	</div><div class="para">
		The Near Real Time configuration is recommended for non-clustered websites with limited data due to the mentioned disadvantages and because a master node can be individually configured for improved performance as well.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14216-592105+%5BLatest%5D&amp;comment=Title%3A+Near+Real+Time%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14216-592105+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Custom">
      ⁠</a>23.2.2.3. Custom</h3></div></div></div><div class="para">
		Specify a fully qualified class name for the custom implementation to set up a customized <code class="classname">IndexManager</code>. Set up a no-argument constructor for the implementation as follows: 
<pre class="programlisting">[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre>

	</div><div class="para">
		The custom index manager implementation does not require the same components as the default implementations. For example, delegate to a remote indexing service which does not expose a <code class="classname">Directory</code> interface.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14211-592105+%5BLatest%5D&amp;comment=Title%3A+Custom%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14211-592105+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Directory_Configuration">
      ⁠</a>23.2.3. DirectoryProvider Configuration</h2></div></div></div><div class="para">
		A <code class="classname">DirectoryProvider</code> is the Hibernate Search abstraction around a Lucene <code class="classname">Directory</code> and handles the configuration and the initialization of the underlying Lucene resources. <a class="xref" href="chap-Hibernate_Search.html#directory-provider-properties"> Directory Providers and their Properties </a> shows the list of the directory providers available in Hibernate Search together with their corresponding options.
	</div><div class="para">
		Each indexed entity is associated with a Lucene index (except of the case where multiple entities share the same index). The name of the index is given by the <code class="constant">index</code> property of the <code class="classname">@Indexed</code> annotation. If the <code class="constant">index</code> property is not specified the fully qualified name of the indexed class will be used as name (recommended).
	</div><div class="para">
		The DirectoryProvider and any additional options can be configured by using the prefix <code class="constant">hibernate.search.</code><em class="replaceable">&lt;indexname&gt;</em>. The name <code class="constant">default</code> (<code class="constant">hibernate.search.default</code>) is reserved and can be used to define properties which apply to all indexes. <a class="xref" href="chap-Hibernate_Search.html#example-configuring-directory-providers">Example 23.2, “Configuring Directory Providers”</a> shows how <code class="constant">hibernate.search.default.directory_provider</code> is used to set the default directory provider to be the filesystem one. <code class="constant">hibernate.search.default.indexBase</code> sets then the default base directory for the indexes. As a result the index for the entity <code class="classname">Status</code> is created in <code class="filename">/usr/lucene/indexes/org.hibernate.example.Status</code>.
	</div><div class="para">
		The index for the <code class="classname">Rule</code> entity, however, is using an in-memory directory, because the default directory provider for this entity is overridden by the property <code class="constant">hibernate.search.Rules.directory_provider</code>.
	</div><div class="para">
		Finally the <code class="classname">Action</code> entity uses a custom directory provider <code class="classname">CustomDirectoryProvider</code> specified via <code class="constant">hibernate.search.Actions.directory_provider</code>.
	</div><div class="example"><a id="idm139978468212176">
      ⁠</a><p class="title"><strong>Example 23.1. Specifying the Index Name</strong></p><div class="example-contents"><pre class="programlisting Java"><span xmlns="" class="line">​</span>package org.<span xmlns="" class="perl_Function">hibernate</span>.<span xmlns="" class="perl_Function">example</span>;
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>@Indexed
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Status { <span xmlns="" class="perl_Keyword">... </span>}
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Indexed</span>(index=<span xmlns="" class="perl_String">"Rules"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Rule { <span xmlns="" class="perl_Keyword">... </span>}
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">Indexed</span>(index=<span xmlns="" class="perl_String">"Actions"</span>)
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> Action { <span xmlns="" class="perl_Keyword">... </span>}</pre></div></div><div class="example"><a id="example-configuring-directory-providers">
      ⁠</a><p class="title"><strong>Example 23.2. Configuring Directory Providers</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider = ram
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			Using the described configuration scheme you can easily define common rules like the directory provider and base directory, and override those defaults later on a per index basis.
		</div></div></div><div class="variablelist"><a id="directory-provider-properties">
      ⁠</a><p class="title"><strong> Directory Providers and their Properties </strong></p><dl class="variablelist"><dt><span class="term"> ram </span></dt><dd><div class="para">
					None
				</div></dd><dt><span class="term"> filesystem </span></dt><dd><div class="para">
					File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt;
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">indexBase</code> : base directory
						</div></li><li class="listitem"><div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div></li><li class="listitem"><div class="para">
							<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="chap-Hibernate_Search.html#LockFactory_Configuration">Section 23.2.7, “LockFactory Configuration”</a>
						</div></li><li class="listitem"><div class="para">
							<code class="literal">filesystem_access_type</code>: allows to determine the exact type of <code class="classname">FSDirectory</code> implementation used by this <code class="classname">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="classname">NIOFSDirectory</code> on non Windows systems, <code class="classname">SimpleFSDirectory</code> on Windows), <code class="literal">simple</code> (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code> (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code> (<code class="classname">MMapDirectory</code>). Refer to Javadocs of these <code class="classname">Directory</code> implementations before changing this setting. Even though <code class="classname">NIOFSDirectory</code> or <code class="classname">MMapDirectory</code> can bring substantial performance boosts they also have their issues.
						</div></li></ul></div></dd><dt><span class="term"><span class="property">filesystem-master</span></span></dt><dd><div class="para">
					File system based directory. Like <code class="literal">filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular basis.
				</div><div class="para">
					The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
				</div><div class="para">
					Note that the copy is based on an incremental copy mechanism reducing the average copy time.
				</div><div class="para">
					DirectoryProvider typically used on the master node in a JMS back end cluster.
				</div><div class="para">
					The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">indexBase</code>: base directory
						</div></li><li class="listitem"><div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div></li><li class="listitem"><div class="para">
							<code class="literal">sourceBase</code>: source (copy) base directory.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">source</code>: source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
						</div></li><li class="listitem"><div class="para">
							<code class="literal">refresh</code>: refresh period in seconds (the copy will take place every <code class="constant">refresh</code> seconds). If a copy is still in progress when the following <code class="constant">refresh</code> period elapses, the second copy operation will be skipped.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="chap-Hibernate_Search.html#LockFactory_Configuration">Section 23.2.7, “LockFactory Configuration”</a>
						</div></li><li class="listitem"><div class="para">
							<code class="literal">filesystem_access_type</code>: allows to determine the exact type of <code class="classname">FSDirectory</code> implementation used by this <code class="classname">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="classname">NIOFSDirectory</code> on non Windows systems, <code class="classname">SimpleFSDirectory</code> on Windows), <code class="literal">simple</code> (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code> (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code> (<code class="classname">MMapDirectory</code>). Refer to Javadocs of these <code class="classname">Directory</code> implementations before changing this setting. Even though <code class="classname">NIOFSDirectory</code> or <code class="classname">MMapDirectory</code> can bring substantial performance boosts, there are also issues of which you need to be aware.
						</div></li></ul></div></dd><dt><span class="term"><span class="property">filesystem-slave</span></span></dt><dd><div class="para">
					File system based directory. Like <code class="literal">filesystem</code>, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
				</div><div class="para">
					The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
				</div><div class="para">
					Note that the copy is based on an incremental copy mechanism reducing the average copy time. If a copy is still in progress when <code class="constant">refresh</code> period elapses, the second copy operation will be skipped.
				</div><div class="para">
					DirectoryProvider typically used on slave nodes using a JMS back end.
				</div><div class="para">
					The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
				</div><div class="para">
					<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
								<code class="literal">indexBase</code>: Base directory
							</div></li><li class="listitem"><div class="para">
								<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
							</div></li><li class="listitem"><div class="para">
								<code class="literal">sourceBase</code>: Source (copy) base directory.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
							</div></li><li class="listitem"><div class="para">
								<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="chap-Hibernate_Search.html#LockFactory_Configuration">Section 23.2.7, “LockFactory Configuration”</a>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">retry_marker_lookup</code> : optional, default to 0. Defines how many times Hibernate Search checks for the marker files in the source directory before failing. Waiting 5 seconds between each try.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">retry_initialize_period</code> : optional, set an integer value in seconds to enable the retry initialize feature: if the slave can't find the master index it will try again until it's found in background, without preventing the application to start: fullText queries performed before the index is initialized are not blocked but will return empty results. When not enabling the option or explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer. To prevent the application from starting without an invalid index but still control an initialization timeout, see <code class="literal">retry_marker_lookup</code> instead.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">filesystem_access_type</code>: allows to determine the exact type of <code class="classname">FSDirectory</code> implementation used by this <code class="classname">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="classname">NIOFSDirectory</code> on non Windows systems, <code class="classname">SimpleFSDirectory</code> on Windows), <code class="literal">simple</code> (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code> (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code> (<code class="classname">MMapDirectory</code>). Refer to Javadocs of these <code class="classname">Directory</code> implementations before changing this setting. Even though <code class="classname">NIOFSDirectory</code> or <code class="classname">MMapDirectory</code> can bring substantial performance boosts you need also to be aware of the issues.
							</div></li></ul></div>

				</div></dd></dl></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <code class="classname">org.hibernate.store.DirectoryProvider</code> interface. In this case, pass the fully qualified class name of your provider into the <code class="literal">directory_provider</code> property. You can pass any additional properties using the prefix <code class="constant">hibernate.search.</code><em class="replaceable">&lt;indexname&gt;</em>.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14230-748896+%5BLatest%5D&amp;comment=Title%3A+DirectoryProvider+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14230-748896+26+Mar+2015+20%3A32+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Sharding_Indexes">
      ⁠</a>23.2.4. Sharding Indexes</h2></div></div></div><div class="para">
		In some cases it can be useful to split (shard) the indexed data of a given entity into several Lucene indexes.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
			Sharding should only be implemented if the advantages outweigh the disadvantages. Searching sharded indexes will typically be slower as all shards have to be opened for a single search.
		</div></div></div><div class="para">
		Possible use cases for sharding are:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				A single index is so large that index update times are slowing the application down.
			</div></li><li class="listitem"><div class="para">
				A typical search will only hit a subset of the index, such as when data is naturally segmented by customer, region or application.
			</div></li></ul></div><div class="para">
		By default sharding is not enabled unless the number of shards is configured. To do this use the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards</code> property.
	</div><div class="example"><a id="example-index-sharding">
      ⁠</a><p class="title"><strong>Example 23.3. Enabling Index Sharding</strong></p><div class="example-contents"><div class="para">
			In this example 5 shards are enabled.
		</div><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards = 5</pre></div></div><div class="para">
		Responsible for splitting the data into sub-indexes is the <code class="classname">IndexShardingStrategy</code>. The default sharding strategy splits the data according to the hash value of the ID string representation (generated by the <code class="classname">FieldBridge</code>). This ensures a fairly balanced sharding. You can replace the default strategy by implementing a custom <code class="classname">IndexShardingStrategy</code>. To use your custom strategy you have to set the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy</code> property.
	</div><div class="example"><a id="idm139978453565440">
      ⁠</a><p class="title"><strong>Example 23.4. Specifying a Custom Sharding Strategy</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy = my.shardingstrategy.Implementation</pre></div></div><div class="para">
		The <code class="classname">IndexShardingStrategy</code> property also allows for optimizing searches by selecting which shard to run the query against. By activating a filter a sharding strategy can select a subset of the shards used to answer a query (<code class="classname">IndexShardingStrategy.getIndexManagersForQuery</code>) and thus speed up the query execution.
	</div><div class="para">
		Each shard has an independent <code class="classname">IndexManager</code> and so can be configured to use a different directory provider and back end configuration. The <code class="classname">IndexManager</code> index names for the Animal entity in <a class="xref" href="chap-Hibernate_Search.html#example-sharding-configuration">Example 23.5, “Sharding Configuration for Entity Animal”</a> are <code class="literal">Animal.0</code> to <code class="literal">Animal.4</code>. In other words, each shard has the name of its owning index followed by <code class="constant">.</code> (dot) and its index number.
	</div><div class="example"><a id="example-sharding-configuration">
      ⁠</a><p class="title"><strong>Example 23.5. Sharding Configuration for Entity Animal</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Animal.sharding_strategy.nbr_of_shards = 5
hibernate.search.Animal.directory_provider = filesystem
hibernate.search.Animal.0.indexName = Animal00 
hibernate.search.Animal.3.indexBase = /usr/lucene/sharded
hibernate.search.Animal.3.indexName = Animal03</pre></div></div><div class="para">
		In <a class="xref" href="chap-Hibernate_Search.html#example-sharding-configuration">Example 23.5, “Sharding Configuration for Entity Animal”</a>, the configuration uses the default id string hashing strategy and shards the <code class="classname">Animal</code> index into 5 sub-indexes. All sub-indexes are filesystem instances and the directory where each sub-index is stored is as followed:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				for sub-index 0: <code class="filename">/usr/lucene/indexes/Animal00</code> (shared indexBase but overridden indexName)
			</div></li><li class="listitem"><div class="para">
				for sub-index 1: <code class="filename">/usr/lucene/indexes/Animal.1</code> (shared indexBase, default indexName)
			</div></li><li class="listitem"><div class="para">
				for sub-index 2: <code class="filename">/usr/lucene/indexes/Animal.2</code> (shared indexBase, default indexName)
			</div></li><li class="listitem"><div class="para">
				for sub-index 3: <code class="filename">/usr/lucene/shared/Animal03</code> (overridden indexBase, overridden indexName)
			</div></li><li class="listitem"><div class="para">
				for sub-index 4: <code class="filename">/usr/lucene/indexes/Animal.4</code> (shared indexBase, default indexName)
			</div></li></ul></div><div class="para">
		When implementing a <code class="classname">IndexShardingStrategy</code> any field can be used to determine the sharding selection. Consider that to handle deletions, <code class="literal">purge</code> and <code class="literal">purgeAll</code> operations, the implementation might need to return one or more indexes without being able to read all the field values or the primary identifier. In that case the information is not enough to pick a single index, all indexes should be returned, so that the delete operation will be propagated to all indexes potentially containing the documents to be deleted.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14190-748889+%5BLatest%5D&amp;comment=Title%3A+Sharding+Indexes%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14190-748889+26+Mar+2015+18%3A37+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Worker_Configuration">
      ⁠</a>23.2.5. Worker Configuration</h2></div></div></div><div class="para">
				It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. There exist several architectural components and possible extension points. Let's have a closer look.
			</div><div class="para">
				First there is a <code class="classname">Worker</code>. An implementation of the <code class="classname">Worker</code> interface is responsible for receiving all entity changes, queuing them by context and applying them once a context ends. The most intuitive context, especially in connection with ORM, is the transaction. For this reason Hibernate Search will per default use the <code class="classname">TransactionalWorker</code> to scope all changes per transaction. One can, however, imagine a scenario where the context depends for example on the number of entity changes or some other application (lifecycle) events. For this reason the <code class="classname">Worker</code> implementation is configurable as shown in <a class="xref" href="chap-Hibernate_Search.html#table-worker-configuration">Table 23.1, “Scope configuration”</a>.
			</div><div class="table"><a id="table-worker-configuration">
      ⁠</a><p class="title"><strong>Table 23.1. Scope configuration</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Scope configuration"><colgroup><col/><col/></colgroup><tbody><tr><td> <span class="bold bold"><strong>Property</strong></span> </td><td> <span class="bold bold"><strong>Description</strong></span> </td></tr><tr><td> <span class="property">hibernate.search.worker.scope</span> </td><td> The fully qualified class name of the <code class="classname">Worker</code> implementation to use. If this property is not set, empty or <code class="literal">transaction</code> the default <code class="classname">TransactionalWorker</code> is used. </td></tr><tr><td> <span class="property">hibernate.search.worker.*</span> </td><td> All configuration properties prefixed with <code class="literal">hibernate.search.worker</code> are passed to the Worker during initialization. This allows adding custom, worker specific parameters. </td></tr><tr><td> <span class="property">hibernate.search.worker.batch_size</span> </td><td> Defines the maximum number of indexing operation batched per context. Once the limit is reached indexing will be triggered even though the context has not ended yet. This property only works if the <code class="classname">Worker</code> implementation delegates the queued work to BatchedQueueingProcessor (which is what the <code class="classname">TransactionalWorker</code> does) </td></tr></tbody></table></div></div><div class="para">
				Once a context ends it is time to prepare and apply the index changes. This can be done synchronously or asynchronously from within a new thread. Synchronous updates have the advantage that the index is at all times in sync with the databases. Asynchronous updates, on the other hand, can help to minimize the user response time. The drawback is potential discrepancies between database and index states. Lets look at the configuration options shown in <a class="xref" href="chap-Hibernate_Search.html#table-work-execution-configuration">Table 23.2, “Execution configuration”</a>.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The following options can be different on each index; in fact they need the indexName prefix or use <code class="literal">default</code> to set the default value for all indexes.
				</div></div></div><div class="table"><a id="table-work-execution-configuration">
      ⁠</a><p class="title"><strong>Table 23.2. Execution configuration</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Execution configuration"><colgroup><col/><col/></colgroup><tbody><tr><td> <span class="bold bold"><strong>Property</strong></span> </td><td> <span class="bold bold"><strong>Description</strong></span> </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.execution</span> </td><td> <div class="para">
								<code class="literal">sync</code>: synchronous execution (default)
							</div>
							 <div class="para">
								<code class="literal">async</code>: asynchronous execution
							</div>
							 </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.thread_pool.size</span> </td><td> The backend can apply updates from the same transaction context (or batch) in parallel, using a threadpool. The default value is 1. You can experiment with larger values if you have many operations per transaction. </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.buffer_queue.max</span> </td><td> Defines the maximal number of work queue if the thread poll is starved. Useful only for asynchronous execution. Default to infinite. If the limit is reached, the work is done by the main thread. </td></tr></tbody></table></div></div><div class="para">
				So far all work is done within the same Virtual Machine (VM), no matter which execution mode. The total amount of work has not changed for the single VM. Luckily there is a better approach, namely delegation. It is possible to send the indexing work to a different server by configuring hibernate.search.default.worker.backend - see <a class="xref" href="chap-Hibernate_Search.html#table-backend-configuration">Table 23.3, “Backend configuration”</a>. Again this option can be configured differently for each index.
			</div><div class="table"><a id="table-backend-configuration">
      ⁠</a><p class="title"><strong>Table 23.3. Backend configuration</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="Backend configuration"><colgroup><col/><col/></colgroup><tbody><tr><td> <span class="bold bold"><strong>Property</strong></span> </td><td> <span class="bold bold"><strong>Description</strong></span> </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.backend</span> </td><td> <div class="para">
								<code class="literal">lucene</code>: The default backend which runs index updates in the same VM. Also used when the property is undefined or empty.
							</div>
							 <div class="para">
								<code class="literal">jms</code>: JMS backend. Index updates are send to a JMS queue to be processed by an indexing master. See <a class="xref" href="chap-Hibernate_Search.html#table-jms-backend-configuration">Table 23.4, “JMS backend configuration”</a> for additional configuration options and <a class="xref" href="chap-Hibernate_Search.html#JMS_MasterSlave_Back_End">Section 23.2.5.1, “JMS Master/Slave Back End”</a> for a more detailed description of this setup.  
							</div>
							 <div class="para">
								<code class="literal">blackhole</code>: Mainly a test/developer setting which ignores all indexing work
							</div>
							 <div class="para">
								You can also specify the fully qualified name of a class implementing <code class="classname">BackendQueueProcessor</code>. This way you can implement your own communication layer. The implementation is responsible for returning a <code class="classname">Runnable</code> instance which on execution will process the index work.
							</div>
							 </td></tr></tbody></table></div></div><div class="table"><a id="table-jms-backend-configuration">
      ⁠</a><p class="title"><strong>Table 23.4. JMS backend configuration</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="JMS backend configuration"><colgroup><col/><col/></colgroup><thead><tr><th> <span class="bold bold"><strong>Property</strong></span> </th><th> <span class="bold bold"><strong>Description</strong></span> </th></tr></thead><tbody><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.jndi.*</span> </td><td> Defines the JNDI properties to initiate the InitialContext (if needed). JNDI is only used by the JMS back end. </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.jms.connection_factory</span> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<code class="literal">/ConnectionFactory</code> by default in Red Hat JBoss Enterprise Application Platform) </td></tr><tr><td> <span class="property">hibernate.search.&lt;indexName&gt;.​worker.jms.queue</span> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages. </td></tr></tbody></table></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
					As you probably noticed, some of the shown properties are correlated which means that not all combinations of property values make sense. In fact you can end up with a non-functional configuration. This is especially true for the case that you provide your own implementations of some of the shown interfaces. Make sure to study the existing code before you write your own <code class="classname">Worker</code> or <code class="classname">BackendQueueProcessor</code> implementation.
				</div></div></div><div class="para RoleCreateBugPara">
				<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+IDs%3A%0A14229-749068+%5BLatest%5D&amp;comment=Title%3A+Worker+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="JMS_MasterSlave_Back_End">
      ⁠</a>23.2.5.1. JMS Master/Slave Back End</h3></div></div></div><div class="para">
		This section describes in greater detail how to configure the Master/Slave Hibernate Search architecture.
	</div><div class="figure"><a id="idm139978528542816">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/1602.png" align="middle" alt="JMS Backend Configuration" style="text-align: middle"/></div></div><p class="title"><strong>Figure 23.3. JMS Backend Configuration</strong></p></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14234-592107+%5BLatest%5D&amp;comment=Title%3A+JMS+Master%2FSlave+Back+End%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14234-592107+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Slave_Nodes">
      ⁠</a>23.2.5.2. Slave Nodes</h3></div></div></div><div class="para">
		Every index update operation is sent to a JMS queue. Index querying operations are executed on a local index copy.
	</div><div class="example"><a id="idm139978499350560">
      ⁠</a><p class="title"><strong>Example 23.6. JMS Slave configuration</strong></p><div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.default.worker.execution = async
# hibernate.search.default.worker.thread_pool.size = 2
# hibernate.search.default.worker.buffer_queue.max = 50</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			A file system local copy is recommended for faster search results.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14289-592111+%5BLatest%5D&amp;comment=Title%3A+Slave+Nodes%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14289-592111+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Master_Node">
      ⁠</a>23.2.5.3. Master Node</h3></div></div></div><div class="para">
		Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis.
	</div><div class="example"><a id="idm139978516863840">
      ⁠</a><p class="title"><strong>Example 23.7. JMS Master configuration</strong></p><div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#Backend is the default lucene one</pre></div></div><div class="para">
		In addition to the Hibernate Search framework configuration, a Message Driven Bean has to be written and set up to process the index works queue through JMS.
	</div><div class="example"><a id="idm139978446263056">
      ⁠</a><p class="title"><strong>Example 23.8. Message Driven Bean processing the indexing queue</strong></p><div class="example-contents"><pre class="programlisting Java"><span xmlns="" class="line">​</span>@<span xmlns="" class="perl_Function">MessageDriven</span>(activationConfig = {
<span xmlns="" class="line">​</span>      @<span xmlns="" class="perl_Function">ActivationConfigProperty</span>(propertyName=<span xmlns="" class="perl_String">"destinationType"</span>, 
<span xmlns="" class="line">​</span>                                propertyValue=<span xmlns="" class="perl_String">"javax.jms.Queue"</span>),
<span xmlns="" class="line">​</span>      @<span xmlns="" class="perl_Function">ActivationConfigProperty</span>(propertyName=<span xmlns="" class="perl_String">"destination"</span>, 
<span xmlns="" class="line">​</span>                                propertyValue=<span xmlns="" class="perl_String">"queue/hibernatesearch"</span>),
<span xmlns="" class="line">​</span>      @<span xmlns="" class="perl_Function">ActivationConfigProperty</span>(propertyName=<span xmlns="" class="perl_String">"DLQMaxResent"</span>, propertyValue=<span xmlns="" class="perl_String">"1"</span>)
<span xmlns="" class="line">​</span>   } )
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">public</span> <span xmlns="" class="perl_Keyword">class</span> MDBSearchController <span xmlns="" class="perl_Keyword">extends</span> AbstractJMSHibernateSearchController 
<span xmlns="" class="line">​</span>                                 <span xmlns="" class="perl_Keyword">implements</span> MessageListener {
<span xmlns="" class="line">​</span>    @PersistenceContext EntityManager em;
<span xmlns="" class="line">​</span>    
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Comment">//method retrieving the appropriate session</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">protected</span> Session <span xmlns="" class="perl_Function">getSession</span>() {
<span xmlns="" class="line">​</span>        <span xmlns="" class="perl_Keyword">return</span> (Session) em.<span xmlns="" class="perl_Function">getDelegate</span>();
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Comment">//potentially close the session opened in #getSession(), not needed here</span>
<span xmlns="" class="line">​</span>    <span xmlns="" class="perl_Keyword">protected</span> <span xmlns="" class="perl_DataType">void</span> <span xmlns="" class="perl_Function">cleanSessionIfNeeded</span>(Session session) 
<span xmlns="" class="line">​</span>    }
<span xmlns="" class="line">​</span>}</pre></div></div><div class="para">
		This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a JavaEE MDB. This implementation is given as an example and can be adjusted to make use of non Java EE Message Driven Beans. For more information about the <code class="methodname">getSession()</code> and <code class="methodname">cleanSessionIfNeeded()</code>, see <code class="classname">AbstractJMSHibernateSearchController</code>'s javadoc.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14288-592111+%5BLatest%5D&amp;comment=Title%3A+Master+Node%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14288-592111+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Tuning_Lucene_Indexing">
      ⁠</a>23.2.6. Tuning Lucene Indexing</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Tuning_Lucene_Indexing_performance">
      ⁠</a>23.2.6.1. Tuning Lucene Indexing Performance</h3></div></div></div><div class="para">
		<span class="phrase">Hibernate Search</span> is used to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code>, and <code class="literal">maxBufferedDocs</code>. Specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard.
	</div><div class="para">
		There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword: 
<pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre>

	</div><div class="para">
		If no value is set for an <code class="literal">indexwriter</code> value in a specific shard configuration, Hibernate Search checks the index section, then at the default section.
	</div><div class="para">
		The configuration in the following table will result in these settings applied on the second shard of the <code class="classname">Animal</code> index:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				<code class="literal">max_merge_docs</code> = 10
			</div></li><li class="listitem"><div class="para">
				<code class="literal">merge_factor</code> = 20
			</div></li><li class="listitem"><div class="para">
				<code class="literal">ram_buffer_size</code> = 64MB
			</div></li><li class="listitem"><div class="para">
				<code class="literal">term_index_interval</code> = Lucene default
			</div></li></ul></div><div class="para">
		All other values will use the defaults defined in Lucene.
	</div><div class="para">
		The default for all values is to leave them at Lucene's own default. The values listed in <a class="xref" href="chap-Hibernate_Search.html#table-performance-parameters-678">Table 23.5, “List of indexing performance and behavior properties”</a> depend for this reason on the version of Lucene you are using. The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance, see the Lucene documentation.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			Previous versions of Hibernate Search had the notion of <code class="literal">batch</code> and <code class="literal">transaction</code> properties. This is no longer the case as the backend will always perform work using the same settings.
		</div></div></div><div class="table"><a id="table-performance-parameters-678">
      ⁠</a><p class="title"><strong>Table 23.5. List of indexing performance and behavior properties</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="List of indexing performance and behavior properties"><colgroup><col width="40%"/><col width="40%"/><col width="20%"/></colgroup><thead><tr><th style="text-align: center"> Property </th><th style="text-align: center"> Description </th><th style="text-align: center"> Default Value </th></tr></thead><tbody><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​exclusive_index_use</span>
					</div>
					 </td><td>   <div class="para">
						Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables <span class="phrase">Hibernate Search</span> to work in exclusive mode on the index and improve performance when writing changes to the index.
					</div>
					 </td><td> <code class="literal">true</code> (improved performance, releases locks only at shutdown) </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​max_queue_length</span>
					</div>
					 </td><td> <div class="para">
						Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting doesn't make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
					</div>
					 </td><td> <code class="literal">1000</code> </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.max_buffered_delete_terms</span>
					</div>
					 </td><td> <div class="para">
						Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
					</div>
					 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.max_buffered_docs</span>
					</div>
					 </td><td> <div class="para">
						Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
					</div>
					 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.max_merge_docs</span>
					</div>
					 </td><td> <div class="para">
						Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
					</div>
					 </td><td> Unlimited (Integer.MAX_VALUE) </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_factor</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
					</div>
					 </td><td> 10 </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_min_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments smaller than this size (in MB) are always considered for the next segment merge operation.
					</div>
					 <div class="para">
						Setting this too large might result in expensive merge operations, even tough they are less frequent.
					</div>
					 <div class="para">
						See also <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">minMergeSize</code>.
					</div>
					 </td><td> 0 MB (actually ~1K) </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_max_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments larger than this size (in MB) are never merged in bigger segments.
					</div>
					 <div class="para">
						This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
					</div>
					 <div class="para">
						See also <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">maxMergeSize</code>.
					</div>
					 </td><td> Unlimited </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_max_optimize_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
					</div>
					 <div class="para">
						Applied to <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">maxMergeSizeForOptimize</code>.
					</div>
					 </td><td> Unlimited </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_calibrate_by_deletes</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
					</div>
					 <div class="para">
						Applied to <code class="classname">org.apache.lucene.index.LogMergePolicy</code>. <code class="literal">calibrateSizeByDeletes</code>.
					</div>
					 </td><td> <code class="literal">true</code> </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.ram_buffer_size</span>
					</div>
					 </td><td> <div class="para">
						Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
					</div>
					 <div class="para">
						Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
					</div>
					 </td><td> 16 MB </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.term_index_interval</span>
					</div>
					 </td><td> <div class="para">
						Expert: Set the interval between indexed terms.
					</div>
					 <div class="para">
						Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
					</div>
					 </td><td> 128 </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.use_compound_file</span>
					</div>
					 </td><td> The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large. 
					<div class="para">
						Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
					</div>
					 </td><td> true </td></tr><tr><td> <div class="para">
						<span class="property">hibernate.search.​enable_dirty_check</span>
					</div>
					 </td><td>   <div class="para">
						Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, <span class="phrase">Hibernate Search</span> skips the re-indexing process.
					</div>
					 <div class="para">
						Disable this option if you use custom <code class="literal">FieldBridge</code>s which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
					</div>
					 <div class="para">
						This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
					</div>
					 <div class="para">
						Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
					</div>
					 </td><td> true </td></tr></tbody></table></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
			The <code class="literal">blackhole</code> backend is not meant to be used in production, only as a tool to identify indexing bottlenecks.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14263-749963+%5BLatest%5D&amp;comment=Title%3A+Tuning+Lucene+Indexing+Performance%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14263-749963+07+Apr+2015+07%3A50+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="The_Lucene_IndexWriter">
      ⁠</a>23.2.6.2. The Lucene IndexWriter</h3></div></div></div><div class="para">
		There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword: 
<pre class="programlisting">default.&lt;indexname&gt;.indexwriter.&lt;parameter_name&gt;</pre>

	</div><div class="para">
		If no value is set for <code class="literal">indexwriter</code> in a shard configuration, <span class="phrase">Hibernate Search</span> looks at the index section and then at the default section.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+21158-592399+%5BLatest%5D&amp;comment=Title%3A+The+Lucene+IndexWriter%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=21158-592399+23+Feb+2014+16%3A58+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Performance_Option_Configuration">
      ⁠</a>23.2.6.3. Performance Option Configuration</h3></div></div></div><div class="para">
		The following configuration will result in these settings being applied on the second shard of the <code class="classname">Animal</code> index:
	</div><div class="example"><a id="example-performamce-option-configuration">
      ⁠</a><p class="title"><strong>Example 23.9. Example performance option configuration</strong></p><div class="example-contents"><pre class="programlisting">default.Animals.2.indexwriter.max_merge_docs = 10
default.Animals.2.indexwriter.merge_factor = 20
default.Animals.2.indexwriter.term_index_interval = default
default.indexwriter.max_merge_docs = 100
default.indexwriter.ram_buffer_size = 64</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				<code class="literal">max_merge_docs</code> = 10
			</div></li><li class="listitem"><div class="para">
				<code class="literal">merge_factor</code> = 20
			</div></li><li class="listitem"><div class="para">
				<code class="literal">ram_buffer_size</code> = 64MB
			</div></li><li class="listitem"><div class="para">
				<code class="literal">term_index_interval</code> = Lucene default
			</div></li></ul></div><div class="para">
		All other values will use the defaults defined in Lucene.
	</div><div class="para">
		The Lucene default values are the default setting for <span class="phrase">Hibernate Search</span>. Therefore, the values listed in the following table depend on the version of Lucene being used. The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance, see the Lucene documentation.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			The back end will always perform work using the same settings.
		</div></div></div><div class="table"><a id="table-performance-parameters-680">
      ⁠</a><p class="title"><strong>Table 23.6. List of indexing performance and behavior properties</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols gt-7-rows" summary="List of indexing performance and behavior properties"><colgroup><col width="40%"/><col width="40%"/><col width="20%"/></colgroup><thead><tr><th style="text-align: center"> Property </th><th style="text-align: center"> Description </th><th style="text-align: center"> Default Value </th></tr></thead><tbody><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.exclusive_index_use</span>
					</div>
					 </td><td> <div class="para">
						Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables <span class="phrase">Hibernate Search</span> to work in exclusive mode on the index and improve performance when writing changes to the index.
					</div>
					 </td><td> <code class="literal">true</code> (improved performance, releases locks only at shutdown) </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.max_queue_length</span>
					</div>
					 </td><td> <div class="para">
						Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting doesn't make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
					</div>
					 </td><td> <code class="literal">1000</code> </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.max_buffered_delete_terms</span>
					</div>
					 </td><td> <div class="para">
						Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
					</div>
					 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.max_buffered_docs</span>
					</div>
					 </td><td> <div class="para">
						Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
					</div>
					 </td><td> Disabled (flushes by RAM usage) </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.max_merge_docs</span>
					</div>
					 </td><td> <div class="para">
						Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
					</div>
					 </td><td> Unlimited (Integer.MAX_VALUE) </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.merge_factor</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
					</div>
					 </td><td> 10 </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.merge_min_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments smaller than this size (in MB) are always considered for the next segment merge operation.
					</div>
					 <div class="para">
						Setting this too large might result in expensive merge operations, even tough they are less frequent.
					</div>
					 <div class="para">
						See also <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">minMergeSize</code>.
					</div>
					 </td><td> 0 MB (actually ~1K) </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.merge_max_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments larger than this size (in MB) are never merged in bigger segments.
					</div>
					 <div class="para">
						This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
					</div>
					 <div class="para">
						See also <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">maxMergeSize</code>.
					</div>
					 </td><td> Unlimited </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.merge_max_optimize_size</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
					</div>
					 <div class="para">
						Applied to <code class="classname">org.apache.lucene.index.LogDocMergePolicy</code>. <code class="literal">maxMergeSizeForOptimize</code>.
					</div>
					 </td><td> Unlimited </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.merge_calibrate_by_deletes</span>
					</div>
					 </td><td> <div class="para">
						Controls segment merge frequency and size.
					</div>
					 <div class="para">
						Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
					</div>
					 <div class="para">
						Applied to <code class="classname">org.apache.lucene.index.LogMergePolicy</code>. <code class="literal">calibrateSizeByDeletes</code>.
					</div>
					 </td><td> <code class="literal">true</code> </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.ram_buffer_size</span>
					</div>
					 </td><td> <div class="para">
						Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
					</div>
					 <div class="para">
						Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
					</div>
					 </td><td> 16 MB </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.term_index_interval</span>
					</div>
					 </td><td> <div class="para">
						Expert: Set the interval between indexed terms.
					</div>
					 <div class="para">
						Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
					</div>
					 </td><td> 128 </td></tr><tr><td> <div class="para">
						<span class="property">default.&lt;indexname&gt;.indexwriter.use_compound_file</span>
					</div>
					 </td><td> The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large. 
					<div class="para">
						Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
					</div>
					 </td><td> true </td></tr><tr><td> <div class="para">
						<span class="property">default.enable_dirty_check</span>
					</div>
					 </td><td> <div class="para">
						Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, <span class="phrase">Hibernate Search</span> skips the re-indexing process.
					</div>
					 <div class="para">
						Disable this option if you use custom <code class="literal">FieldBridge</code>s which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
					</div>
					 <div class="para">
						This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
					</div>
					 <div class="para">
						Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
					</div>
					 </td><td> true </td></tr></tbody></table></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+21159-748899+%5BLatest%5D&amp;comment=Title%3A+Performance+Option+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=21159-748899+26+Mar+2015+21%3A23+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Tuning_the_Indexing_Speed">
      ⁠</a>23.2.6.4. Tuning the Indexing Speed</h3></div></div></div><div class="para">
		When the architecture permits it, keep <code class="literal">default.exclusive_index_use=true</code> for improved index writing efficiency.
	</div><div class="para">
		When tuning indexing speed the recommended approach is to focus first on optimizing the object loading, and then use the timings you achieve as a baseline to tune the indexing process. Set the <code class="literal">blackhole</code> as worker back end and start your indexing routines. This back end does not disable <span class="phrase">Hibernate Search</span>: it generates the required change sets to the index, but discards them instead of flushing them to the index. In contrast to setting the <span class="phrase"><code class="literal">hibernate.search.indexing_strategy</code></span> to <code class="literal">manual</code>, using <code class="literal">blackhole</code> will possibly load more data from the database because associated entities are re-indexed as well.
	</div><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
			The <code class="literal">blackhole</code> back end is not to be used in production, only as a diagnostic tool to identify indexing bottlenecks.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+21161-748891+%5BLatest%5D&amp;comment=Title%3A+Tuning+the+Indexing+Speed%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=21161-748891+26+Mar+2015+19%3A19+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Control_Segment_Size">
      ⁠</a>23.2.6.5. Control Segment Size</h3></div></div></div><div class="para">
		The following options configure the maximum size of segments created: 
		<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<em class="parameter"><code>merge_max_size</code></em>
				</div></li><li class="listitem"><div class="para">
					<em class="parameter"><code>merge_max_optimize_size</code></em>
				</div></li><li class="listitem"><div class="para">
					<em class="parameter"><code>merge_calibrate_by_deletes</code></em>
				</div></li></ul></div>

	</div><div class="example"><a id="idm139978514863888">
      ⁠</a><p class="title"><strong>Example 23.10. Control Segment Size</strong></p><div class="example-contents"><pre class="programlisting">//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre></div></div><div class="para">
		Set the <em class="parameter"><code>max_size</code></em> for merge operations to less than half of the hard limit segment size, as merging segments combines two segments into one larger segment.
	</div><div class="para">
		A new segment may initially be a larger size than expected, however a segment is never created significantly larger than the <em class="parameter"><code>ram_buffer_size</code></em>. This threshold is checked as an estimate.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14219-763409+%5BLatest%5D&amp;comment=Title%3A+Control+Segment+Size%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14219-763409+29+Jun+2015+23%3A49+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="LockFactory_Configuration">
      ⁠</a>23.2.7. LockFactory Configuration</h2></div></div></div><div class="para">
		The Lucene Directory can be configured with a custom locking strategy via <code class="classname">LockingFactory</code> for each index managed by <span class="phrase">Hibernate Search</span>.
	</div><div class="para">
		Some locking strategies require a filesystem level lock, and may be used on RAM-based indexes. When using this strategy the <code class="classname">IndexBase</code> configuration option must be specified to point to a filesystem location in which to store the lock marker files.
	</div><div class="para">
		To select a locking factory, set the <span class="phrase"><code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code></span> option to one the following options: 
		<div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					<em class="parameter"><code>simple</code></em>
				</div></li><li class="listitem"><div class="para">
					<em class="parameter"><code>native</code></em>
				</div></li><li class="listitem"><div class="para">
					<em class="parameter"><code>single</code></em>
				</div></li><li class="listitem"><div class="para">
					<em class="parameter"><code>none</code></em>
				</div></li></ul></div>

	</div><div class="table"><a id="search-configuration-directory-lockfactories-table">
      ⁠</a><p class="title"><strong>Table 23.7. List of available LockFactory implementations</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="List of available LockFactory implementations"><colgroup><col width="20%"/><col width="20%"/><col width="60%"/></colgroup><thead><tr><th style="text-align: center"> name </th><th style="text-align: center"> Class </th><th style="text-align: center"> Description </th></tr></thead><tbody><tr><td> <span class="property">simple</span> </td><td> org.apache.lucene.store.​SimpleFSLockFactory </td><td> <div class="para">
						Safe implementation based on Java's File API, it marks the usage of the index by creating a marker file.
					</div>
					 <div class="para">
						If for some reason you had to kill your application, you will need to remove this file before restarting it.
					</div>
					 </td></tr><tr><td> <span class="property">native</span> </td><td> org.apache.lucene.store.​NativeFSLockFactory </td><td> <div class="para">
						As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
					</div>
					 <div class="para">
						This implementation has known problems on NFS, avoid it on network shares.
					</div>
					 <div class="para">
						<code class="literal">native</code> is the default implementation for the <code class="literal">filesystem</code>, <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code> directory providers.
					</div>
					 </td></tr><tr><td> <span class="property">single</span> </td><td> org.apache.lucene.store.​SingleInstanceLockFactory </td><td> <div class="para">
						This LockFactory doesn't use a file marker but is a Java object lock held in memory; therefore it's possible to use it only when you are sure the index is not going to be shared by any other process.
					</div>
					 <div class="para">
						This is the default implementation for the <code class="literal">ram</code> directory provider.
					</div>
					 </td></tr><tr><td> <span class="property">none</span> </td><td> org.apache.lucene.store.​NoLockFactory </td><td>   <div class="para">
						Changes to this index are not coordinated by a lock.
					</div>
					 </td></tr></tbody></table></div></div><div class="para">
		The following is an example of locking strategy configuration:
	</div><pre class="programlisting">hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14212-748911+%5BLatest%5D&amp;comment=Title%3A+LockFactory+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14212-748911+26+Mar+2015+23%3A03+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Exception_Handling_Configuration1">
      ⁠</a>23.2.8. Exception Handling Configuration</h2></div></div></div><div class="para">
		<span class="phrase">Hibernate Search</span> allows you to configure how exceptions are handled during the indexing process. If no configuration is provided then exceptions are logged to the log output by default. It is possible to explicitly declare the exception logging mechanism as follows:
	</div><pre class="programlisting">hibernate.search.error_handler = log</pre><div class="para">
		The default exception handling occurs for both synchronous and asynchronous indexing. <span class="phrase">Hibernate Search</span> provides an easy mechanism to override the default error handling implementation.
	</div><div class="para">
		In order to provide your own implementation you must implement the <code class="classname">ErrorHandler</code> interface, which provides the <code class="code">handle(ErrorContext context)</code> method. <code class="code">ErrorContext</code> provides a reference to the primary <code class="code">LuceneWork</code> instance, the underlying exception and any subsequent <code class="code">LuceneWork</code> instances that could not be processed due to the primary exception.
	</div><div class="para">
		
<pre class="programlisting">public interface ErrorContext  {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</pre>

	</div><div class="para">
		To register this error handler with <span class="phrase">Hibernate Search</span> you must declare the fully qualified classname of your <code class="classname">ErrorHandler</code> implementation in the configuration properties:
	</div><div class="para">
		
<pre class="programlisting">hibernate.search.error_handler = CustomerErrorHandler</pre>

	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14222-592105+%5BLatest%5D&amp;comment=Title%3A+Exception+Handling+Configuration%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14222-592105+23+Feb+2014+16%3A57+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Index_Format_Compatibility">
      ⁠</a>23.2.9. Index Format Compatibility</h2></div></div></div><div class="para">
		<span class="phrase">Hibernate Search</span> does not currently offer a backwards compatible API or tool to facilitate porting applications to newer versions. The API uses Apache Lucene for index writing and searching. Occasionally an update to the index format may be required. In this case, there is a possibility that data will need to be re-indexed if Lucene is unable to read the old format.
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
			Back up indexes before attempting to update the index format.
		</div></div></div><div class="para">
		<span class="phrase">Hibernate Search</span> exposes the <span class="phrase"><code class="literal">hibernate.search.lucene_version</code></span> configuration property. This property instructs Analyzers and other Lucene classes to conform to their behaviour as defined in an older version of Lucene. See also <code class="classname">org.apache.lucene.util.Version</code> contained in the <code class="filename">lucene-core.jar</code>. If the option is not specified, <span class="phrase">Hibernate Search</span> instructs Lucene to use the version default. It is recommended that the version used is explicitly defined in the configuration to prevent automatic changes when an upgrade occurs. After an upgrade, the configuration values can be updated explicitly if required.
	</div><div class="example"><a id="idm139978499622160">
      ⁠</a><p class="title"><strong>Example 23.11. Force Analyzers to be compatible with a Lucene 3.0 created index</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.lucene_version = LUCENE_30</pre></div></div><div class="para">
		The configured <code class="classname">SearchFactory</code> is global and affects all Lucene APIs that contain the relevant parameter. If Lucene is used and <span class="phrase">Hibernate Search</span> is bypassed, apply the same value to it for consistent results.
	</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14223-749070+%5BLatest%5D&amp;comment=Title%3A+Index+Format+Compatibility%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14223-749070+29+Mar+2015+23%3A09+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Disable_Hibernate_Search">
      ⁠</a>23.2.10. Disable Hibernate Search</h2></div></div></div><div class="para">
		Hibernate Search can be partially or completely disabled as required. Hibernate Search's indexing can be disabled, for example, if the index is read-only, or you prefer to perform indexing manually, rather than automatically. It is also possible to completely disable Hibernate Search, preventing indexing and searching.
	</div><div class="para"><div xmlns:d="http://docbook.org/ns/docbook" class="title"> Disable Indexing </div>
			To disable Hibernate Search indexing, change the <code class="literal">indexing_strategy</code> configuration option to <code class="literal">manual</code>, then restart JBoss EAP. 
<pre class="screen">hibernate.search.indexing_strategy = manual</pre>

		</div><div class="para"><div xmlns:d="http://docbook.org/ns/docbook" class="title"> Disable Hibernate Search Completely </div>
			To disable Hibernate Search completely, disable all listeners by changing the <code class="literal">autoregister_listeners</code> configuration option to <code class="literal">false</code>, then restart JBoss EAP. 
<pre class="screen">hibernate.search.autoregister_listeners = false</pre>

		</div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+43111-747741+%5BLatest%5D&amp;comment=Title%3A+Disable+Hibernate+Search%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=43111-747741+18+Mar+2015+21%3A46+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sect-Monitoring">
      ⁠</a>23.3. Monitoring</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Monitoring1">
      ⁠</a>23.3.1. Monitoring</h2></div></div></div><div class="para">
		Hibernate Search offers access to a <code class="classname">Statistics</code> object via <code class="methodname">SearchFactory.getStatistics()</code>. It allows you, for example, to determine which classes are indexed and how many entities are in the index. This information is always available. However, by specifying the <code class="literal">hibernate.search.generate_statistics</code> property in your configuration you can also collect total and average Lucene query and object loading timings.
	</div><div class="para">
		Hibernate Search provides several methods of monitoring its operations. The list of indexed classes and number of entities per index are always available from the <code class="classname">Statistics</code> object via the <code class="methodname">SearchFactory.getStatistics()</code> method. To obtain total and average Lucene query and object loading timings, specify the <code class="literal">hibernate.search.generate_statistics</code> property in your configuration.
	</div><div class="para"><div xmlns:d="http://docbook.org/ns/docbook" class="title"> Access to Statistics via JMX </div>
			To enable access to statistics via JMX, set the property <code class="literal">hibernate.search.jmx_enabled</code> to <code class="literal">true</code>. This will automatically register the <code class="classname">StatisticsInfoMBean</code> bean, providing access to statistics via the <code class="classname">Statistics</code> object. Depending on your configuration the <code class="classname">IndexingProgressMonitorMBean</code> bean may also be registered.
		</div><div class="para"><div xmlns:d="http://docbook.org/ns/docbook" class="title"> Monitoring Indexing </div>
			If the mass indexer API is used, you can monitor indexing progress via the <code class="classname">IndexingProgressMonitorMBean</code> bean. The bean is only bound to JMX while indexing is in progress.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			JMX beans can be accessed remotely via JConsole by setting the system property <code class="varname">com.sun.management.jmxremote</code> to <code class="constant">true</code>.
		</div></div></div><div class="para RoleCreateBugPara">
		<a href="https://bugzilla.redhat.com/enter_bug.cgi?cf_environment=Build+Name%3A+23087%2C+Red+Hat+Administration+and+Configuration+Guide-6.4%0ABuild+Date%3A+16-11-2017+09%3A12%3A46%0ATopic+ID%3A+14217-748322+%5BLatest%5D&amp;comment=Title%3A+Monitoring%0A%0ADescribe+the+issue%3A%0A%0A%0ASuggestions+for+improvement%3A%0A%0A%0AAdditional+information%3A&amp;cf_build_id=14217-748322+23+Mar+2015+21%3A14+en-US+%5BLatest%5D&amp;product=JBoss+Enterprise+Application+Platform+6&amp;component=Documentation&amp;version=6.4.0">Report a bug</a>
	</div></div></div></div></body></html>