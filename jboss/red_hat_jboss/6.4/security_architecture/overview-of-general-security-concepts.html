<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. Overview of General Security Concepts</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="overview-of-general-security-concepts"/>Chapter 1. Overview of General Security Concepts</h1></div></div></div><p>
			Before digging into how JBoss EAP 6 handles security, it is important to understand a few basic security concepts.
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authentication"/>Authentication</h1></div></div></div><p>
				Authentication refers to identifying a subject and verifying the authenticity of the identification. The most common authentication mechanism is a username and password combination, but other mechanisms, such as shared keys, smart cards, or fingerprints are also used for Authentication. When in the context of Java Enterprise Edition declarative security, the result of a successful authentication is called a <span class="emphasis"><em>principal</em></span>.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authorization"/>Authorization</h1></div></div></div><p>
				Authorization refers to a way of specifying access rights or defining access policies. A system can then implement a mechanism to utilize those policies to permit or deny access to resources for the requestor. In many cases, this is implemented by matching a principal with a set of actions or places they are or are not allowed to access, sometimes referred to as a role.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authentication_and_authorization_in_practice"/>Authentication and Authorization in Practice</h1></div></div></div><p>
				Though Authentication and Authorization are distinct concepts, they are very often linked. Many modules written to handle authentication also handle authorization and vice-versa.
			</p><div class="title"><strong>Example</strong></div><p>
					The application <span class="emphasis"><em>MyPersonalSoapbox</em></span> provides the ability to post and view messages. Principals with the <span class="emphasis"><em>Talk</em></span> role are allowed to post messages and view other posted messages. Users who have not logged in have the <span class="emphasis"><em>Listen</em></span> role and are allowed to view posted messages. <span class="emphasis"><em>Suzy</em></span>, <span class="emphasis"><em>Adam</em></span>, and <span class="emphasis"><em>Bob</em></span> use the application. <span class="emphasis"><em>Suzy</em></span> and <span class="emphasis"><em>Bob</em></span> can authenticate with their username and password, but <span class="emphasis"><em>Adam</em></span> does not have a username and password yet. <span class="emphasis"><em>Suzy</em></span> has the <span class="emphasis"><em>Talk</em></span> role, but <span class="emphasis"><em>Bob</em></span> has no roles (neither <span class="emphasis"><em>Talk</em></span> nor <span class="emphasis"><em>Listen</em></span>). When <span class="emphasis"><em>Suzy</em></span> authenticates, she may post and view messages. When <span class="emphasis"><em>Adam</em></span> uses <span class="emphasis"><em>MyPersonalSoapbox</em></span>, he cannot log in, but he can still see posted messages. When <span class="emphasis"><em>Bob</em></span> logs in, he cannot post any messages nor can he view any other posted messages.
				</p><p>
				<span class="emphasis"><em>Suzy</em></span> is both authenticated and authorized. <span class="emphasis"><em>Adam</em></span> has not authenticated, but he is authorized (with the <span class="emphasis"><em>Listen</em></span> role) to view messages. <span class="emphasis"><em>Bob</em></span> is authenticated, but has no authorization (no roles).
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="encryption"/>Encryption</h1></div></div></div><p>
				Encryption refers to encoding sensitive information by applying mathematical algorithms to it. Data is secured by converting (or encrypting) it to an encoded format. In order to read the data again, the encoded format must be converted back (or decrypted) to the original format. Encryption can be applied to simple string data in files or databases, or even on data sent across communications streams.
			</p><p>
				Examples of encryption include:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						LUKS can be used to encrypt Linux filesystem disks.
					</li><li class="listitem">
						The blowfish or AES algorithms can be used to encrypt data stored in Postgres databases.
					</li><li class="listitem">
						The HTTPS protocol encrypts all data via SSL/TLS before transferring it from one party to another.
					</li><li class="listitem">
						When a users connects from one server to another using the Secure Shell (SSH) protocol, all of the communication is sent in an encrypted tunnel.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ssl_tls_and_certificates"/>SSL/TLS and Certificates</h1></div></div></div><p>
				Secure Sockets Layer (SSL)/Transport Layer Security(TLS) encrypts network traffic between two systems. This occurs by using a symmetric key which is exchanged between and only known by those two systems. To ensure a secure exchange of the symmetric key, SSL/TLS makes use of Public Key Infrastructure (PKI), a method of encryption that utilizes a key pair. A key pair consists of two separate but matching cryptographic keys - a public key and a private key. The public key is shared with any party and is used to encrypt data, and the private key is kept secret and is used to decrypt data that has been encrypted using the public key.
			</p><p>
				When a client requests a secure connection to exchange symmetric keys, a handshake phase takes place before secure communication can begin. During the SSL/TLS handshake, the server passes its public key to the client in the form of a certificate. The certificate contains the identity of the server (its URL), the public key of the server, and a digital signature that validates the certificate. The client then validates the certificate and makes a decision about whether the certificate is trusted or not. If the certificate is trusted, the client generates the symmetric key for the SSL/TLS connection, encrypts it using the public key of the server, and sends it back to the server. The server decrypts the symmetric key, using its private key, and further communication between the two machines over this connection is encrypted using the symmetric key.
			</p><p>
				There are two basic kinds of certificates: <span class="strong"><strong>Self-Signed Certificates</strong></span> and <span class="strong"><strong>Authority-Signed Certificates</strong></span>. A self-signed certificate uses its own private key to sign itself, and that signature is unverified (not connected to any chain of trust). An authority-signed certificate is a certificate that is issued to a party by a certificate authority and is signed by that certificate authority (e.g. Verisign, CAcert, RSA and many others). The certificate authority is essentially verifying the authenticity of the holder of the certificate.
			</p><p>
				Self-Signed certificates can be faster and easier to generate and require less infrastructure to manage, but they can be difficult for clients to verify their authenticity since no third party has confirmed their authenticity. This inherently makes the less secure. Authority-signed certificates can take more effort to setup initially, but are far easier for clients to verify their authenticity (i.e. a chain of trust has been created since a third party has confirmed the authenticity of the holder of the certificate).
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="single_sign_on_sso"/>Single Sign On (SSO)</h1></div></div></div><p>
				Single Sign On (SSO) allows principals authenticated to one resource to implicitly authorize access to other resources. If a set of distinct resources are secured by SSO, a user is only required to authenticate the first time they access any of the secured resources. Upon successful authentication, the roles associated with the user are stored and used for authorization of all other associated resources. This allows the user to access any additional authorized resources without re-authenticating.
			</p><p>
				If the user logs out of a resource, or a resource invalidates the session programmatically, all persisted authorization data is removed, and the process starts over. In the case of a resource session timeout, the SSO session is not invalidated if there are other valid resource sessions associated with that user. SSO may be used for authentication and authorization on both web applications as well as on desktop applications. In some cases, an single SSO implementation can integrate with both.
			</p><p>
				Within SSO, there are a few common terms used to describe different concepts and parts of the system:
			</p><div class="title"><strong>Identity Management</strong></div><p>
					<span class="emphasis"><em>Identity Management (IDM)</em></span> refers to the idea of managing principals and their associated authentication, authorization, and privileges across one or more systems or domains. The term <span class="emphasis"><em>Indentity and Access Management (IAM)</em></span> is sometimes used to describe this same concept.
				</p><div class="title"><strong>Identity Provider</strong></div><p>
					An <span class="emphasis"><em>identity provider (IDP)</em></span> is the authoritative entity responsible for authenticating an end user and asserting the identity for that user in a trusted fashion to trusted partners.
				</p><div class="title"><strong>Identity Store</strong></div><p>
					An identity provider needs an <span class="emphasis"><em>identity store</em></span> to retrieve users' information. This information will be used during the authentication and authorization process. Identity stores can be any type of repository: a database, LDAP, properties file, etc.
				</p><div class="title"><strong>Service Provider</strong></div><p>
					A <span class="emphasis"><em>service provider</em></span> relies on an identity provider to assert information about a user via an electronic user credential, leaving the service provider to manage access control and dissemination based on a trusted set of user credential assertions.
				</p><div class="title"><strong>Clustered and Non-Clustered SSO</strong></div><p>
					<span class="emphasis"><em>Non-clustered SSO</em></span> limits the sharing of authorization information to applications on the same virtual host. In addition, there is no resiliency in the event of a host failure. In a <span class="emphasis"><em>clustered SSO</em></span> scenario, data can be shared between applications in multiple virtual hosts, and is therefore resilient to failover. In addition, clustered SSO is able to receive requests from a load balancer.
				</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="third_party_sso_implementations"/>Third-Party SSO Implementations</h2></div></div></div><div class="title"><strong>Kerberos</strong></div><p>
						<span class="emphasis"><em>Kerberos</em></span> is a network authentication protocol for client/server applications. It allows authentication across a non-secure network in a secure way, using secret-key symmetric cryptography.
					</p><p>
					Kerberos uses security tokens called tickets. To use a secured service, users need to obtain a ticket from the Ticket Granting Service (TGS), which is a service running on a server on their network. After obtaining the ticket, users request a Service Ticket (ST) from an Authentication Service (AS), which is another service running on the same network. Users then use the ST to authenticate to the desired service. The TGS and the AS both run inside an enclosing service called the Key Distribution Center (KDC).
				</p><p>
					Kerberos is designed to be used in a client-server desktop environment, and is not usually used in web applications or thin client environments. However, many organizations already use a Kerberos system for desktop authentication, and prefer to reuse their existing system rather than create a second one for their web applications. Kerberos is an integral part of Microsoft Active Directory, and is also used in many Red Hat Enterprise Linux environments.
				</p><div class="title"><strong>SPNEGO</strong></div><p>
						<span class="emphasis"><em>Simple and Protected GSS_API Negotiation Mechanism (SPNEGO)</em></span> provides a mechanism for extending a Kerberos-based SSO environment for use in web applications.
					</p><p>
					When an application on a client computer, such as a web browser, attempts to access a protected page on a web server, the server responds that authorization is required. The application then requests a service ticket from the Kerberos Key Distribution Center (KDC). After the ticket is obtained, the application wraps it in a request formatted for SPNEGO, and sends it back to the web application, via the browser. The web container running the deployed web application unpacks the request and authenticates the ticket. Upon successful authentication, access is granted.
				</p><p>
					SPNEGO works with all types of Kerberos providers, including the Kerberos service included in Red Hat Enterprise Linux and the Kerberos server which is an integral part of Microsoft Active Directory.
				</p><div class="title"><strong>Microsoft Active Directory</strong></div><p>
						<span class="emphasis"><em>Microsoft Active Directory (AD)</em></span> is a directory service developed by Microsoft to authenticate users and computers in a Microsoft Windows domain. It is included as part of Microsoft Windows Server. The computer running Microsoft Windows Server controlling the domain is referred to as the domain controller. Red Hat Enterprise Linux can integrate with Active Directory domains as can Red Hat Identity Management, Red Hat JBoss Enterprise Application Platform, and other Red Hat Products.
					</p><p>
					Active Directory relies on three core technologies which work together:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							Lightweight Directory Access Protocol (LDAP), for storing information about users, computers, passwords, and other resources.
						</li><li class="listitem">
							Kerberos, for providing secure authentication over the network.
						</li><li class="listitem">
							Domain Name Service (DNS) for providing mappings between IP addresses and host names of computers and other devices on the network.
						</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="claims_based_identity"/>Claims-Based Identity</h2></div></div></div><p>
					One way of implementing SSO is by using a <span class="emphasis"><em>claims-based identity</em></span> system. A claims-based identity system allows systems to pass around identity information, but abstracts that information into two components: a <span class="emphasis"><em>claim</em></span> and an <span class="emphasis"><em>issuer</em></span> (or authority). A claim is statement that one subject (e.g. user, group, application, organization) makes about another. That claim (or set of claims) is then packaged into a token (or set of tokens) and issued by a provider. Claims-based identity allows individual secured resources to implement SSO without having to know everything about a user.
				</p><div class="title"><strong>Security Token Service (STS)</strong></div><p>
						A <span class="emphasis"><em>Security Token Service (STS)</em></span> is an authentication service that issues security tokens to clients for use in authenticating and authorizing users for secured applications (web services or EJBs). A client attempting to authenticate against an application (service provider) secured with STS will be redirect to a centralized STS authenticate and issued a token. If successful, that client will reattempt to access the service provider, providing their token in along with the original request. That service provider will validate the token from the client with the STS and proceed accordingly. This same token may be reused by the client against other web services or EJBs that are connected to the STS. The concept of a centralized STS that can issue, cancel, renew and validate security tokens, and specifies the format of security token request and response messages is known as <span class="emphasis"><em>WS-Trust</em></span>.
					</p><div class="title"><strong>Browser-Based SSO</strong></div><p>
						In <span class="emphasis"><em>browser-based SSO</em></span>, one or more web applications, known as service providers, are connected to a centralized identity provider in a hub and spoke architecture. The identity provider (IDP) acts as the central source (hub) for identity and role information by issuing claim statements (via SAML) to service providers (spokes). Requests may be issued when a user attempts to access a service provider or if a user attempt to authenticate directly with the identity provider. These are known as SP-initiated and IDP-initiated flows respectively, and will both issue the same claim statements.
					</p><div class="title"><strong>SAML</strong></div><p>
						<span class="emphasis"><em>Security Assertion Markup Language (SAML)</em></span> is a data format that allows two parties, usually an identity provider and a service provider, to exchange authentication and authorization information. A SAML token is a type of token issued by a STS or IDP and can be used to enable SSO. A resource secured by SAML (SAML service provider) will redirect users to the SAML identity provider (a type of STS or IDP) to obtain a valid SAML token before authenticating and authorizing that user.
					</p><div class="title"><strong>Desktop-Based SSO</strong></div><p>
						<span class="emphasis"><em>Desktop-Based SSO</em></span> enables service providers and desktop domains (e.g. Active Directory or Kerberos) to share a principal. In practice, this allows users to login on their computer using their domain credentials and then have service providers re-use that principal during authentication (without having to re-authenticate), thus providing SSO.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ldap"/>LDAP</h1></div></div></div><p>
				<span class="emphasis"><em>Lightweight Directory Access Protocol (LDAP)</em></span> is a protocol for storing and distributing directory information across a network. This directory information includes information about users, hardware devices, access roles and restrictions, and other information.
			</p><p>
				In Lightweight Directory Access Protocol (LDAP), the Distinguished Name (DN) uniquely identifies an object in a directory. Each distinguished name must have a unique name and location from all other objects, which is achieved using a number of attribute-value pairs (AVPs). The AVPs define information such as common names, organization unit, among others. The combination of these values results in a unique string required by the LDAP.
			</p><p>
				Some common implementations of LDAP include Red Hat Directory Server, OpenLDAP, Microsoft Active Directory, IBM Tivoli Directory Server, Oracle Internet Directory, 389 Directory Server, and others.
			</p></div></div></body></html>