<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools Expert User Guide</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p></div><hr/></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e7">1. The Rule Engine</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10">1.1. What is a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13">1.1.1. Introduction and Background</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e103">1.2. Why use a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e124">1.2.1. Advantages of a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e167">1.2.2. When should you use a Rule Engine?</a></span></dt><dt><span class="section"><a href="#d0e204">1.2.3. When not to use a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e216">1.2.4. Scripting or Process Engines</a></span></dt><dt><span class="section"><a href="#d0e229">1.2.5. Strong and Loose Coupling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e237">2. Quick Start</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e240">2.1. The Basics</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e243">2.1.1. Stateless Knowledge Session</a></span></dt><dt><span class="section"><a href="#d0e390">2.1.2. Stateful Knowledge Session</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">2.2. A Little Theory</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e565">2.2.1. Methods versus Rules</a></span></dt><dt><span class="section"><a href="#d0e597">2.2.2. Cross Products</a></span></dt><dt><span class="section"><a href="#d0e622">2.2.3. Activations, Agenda and Conflict Sets.</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e788">2.3. More on building and deploying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e791">2.3.1. Knowledge Base by Configuration Using Changesets</a></span></dt><dt><span class="section"><a href="#d0e819">2.3.2. Knowledge Agent</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e840">3. User Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e843">3.1. Building</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e852">3.1.1. Building using Code</a></span></dt><dt><span class="section"><a href="#d0e933">3.1.2. Building using Configuration and the ChangeSet XML</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e989">3.2. Deploying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e992">3.2.1. KnowledgePackage and Knowledge Definitions</a></span></dt><dt><span class="section"><a href="#d0e1005">3.2.2. KnowledgeBase</a></span></dt><dt><span class="section"><a href="#d0e1055">3.2.3. In-Process Building and Deployment</a></span></dt><dt><span class="section"><a href="#d0e1070">3.2.4. Building and Deployment in Separate Processes</a></span></dt><dt><span class="section"><a href="#d0e1109">3.2.5. StatefulknowledgeSessions and KnowledgeBase Modifications</a></span></dt><dt><span class="section"><a href="#d0e1123">3.2.6. KnowledgeAgent</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1248">3.3. Running</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1252">3.3.1. KnowledgeBase</a></span></dt><dt><span class="section"><a href="#d0e1271">3.3.2. StatefulKnowledgeSession</a></span></dt><dt><span class="section"><a href="#d0e1293">3.3.3. KnowledgeRuntime</a></span></dt><dt><span class="section"><a href="#d0e1560">3.3.4. Agenda</a></span></dt><dt><span class="section"><a href="#d0e1666">3.3.5. Event Model</a></span></dt><dt><span class="section"><a href="#d0e1781">3.3.6. KnowledgeRuntimeLogger</a></span></dt><dt><span class="section"><a href="#d0e1797">3.3.7. StatelessKnowledgeSession</a></span></dt><dt><span class="section"><a href="#d0e1992">3.3.8. Pipeline</a></span></dt><dt><span class="section"><a href="#d0e2250">3.3.9. Commands and the CommandExecutor</a></span></dt><dt><span class="section"><a href="#d0e2593">3.3.10. Marshalling</a></span></dt><dt><span class="section"><a href="#d0e2668">3.3.11. Persistence and Transactions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2712">4. The Rule Language</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2715">4.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2723">4.1.1. A rule file</a></span></dt><dt><span class="section"><a href="#d0e2756">4.1.2. What makes a rule</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2792">4.2. Keywords</a></span></dt><dt><span class="section"><a href="#d0e3005">4.3. Comments</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3010">4.3.1. Single line comment</a></span></dt><dt><span class="section"><a href="#d0e3023">4.3.2. Multi-line comment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3036">4.4. Error Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3045">4.4.1. Message format</a></span></dt><dt><span class="section"><a href="#d0e3076">4.4.2. Error Messages Description</a></span></dt><dt><span class="section"><a href="#d0e3231">4.4.3. Other Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3236">4.5. Package</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3259">4.5.1. import</a></span></dt><dt><span class="section"><a href="#d0e3273">4.5.2. global</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3316">4.6. Function</a></span></dt><dt><span class="section"><a href="#d0e3350">4.7. Type Declaration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3378">4.7.1. Declaring New Types</a></span></dt><dt><span class="section"><a href="#d0e3500">4.7.2. Declaring Metadata</a></span></dt><dt><span class="section"><a href="#d0e3571">4.7.3. Declaring Metadata for Existing Types</a></span></dt><dt><span class="section"><a href="#d0e3614">4.7.4. Accessing Declared Types from the Application Code</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3663">4.8. Rule</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3705">4.8.1. Rule Attributes</a></span></dt><dt><span class="section"><a href="#RuleLanguage-ConditionalElements">4.8.2. Left Hand Side (when) Conditional Elements</a></span></dt><dt><span class="section"><a href="#d0e5216">4.8.3. The Right Hand Side (then)</a></span></dt><dt><span class="section"><a href="#d0e5455">4.8.4. A Note on Auto-boxing and Primitive Types</a></span></dt></dl></dd><dt><span class="section"><a href="#sec.query">4.9. Query</a></span></dt><dt><span class="section"><a href="#d0e5495">4.10. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5506">4.10.1. When to use a DSL</a></span></dt><dt><span class="section"><a href="#d0e5515">4.10.2. Editing and managing a DSL</a></span></dt><dt><span class="section"><a href="#d0e5569">4.10.3. Using a DSL in your rules</a></span></dt><dt><span class="section"><a href="#d0e5595">4.10.4. Adding constraints to facts</a></span></dt><dt><span class="section"><a href="#d0e5628">4.10.5. How it works</a></span></dt><dt><span class="section"><a href="#d0e5637">4.10.6. Creating a DSL from scratch</a></span></dt><dt><span class="section"><a href="#d0e5665">4.10.7. Scope and keywords</a></span></dt><dt><span class="section"><a href="#d0e5670">4.10.8. DSLs in the BRMS and IDE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5679">4.11. XML Rule Language</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5688">4.11.1. When to use XML</a></span></dt><dt><span class="section"><a href="#d0e5699">4.11.2. The XML format</a></span></dt><dt><span class="section"><a href="#d0e5745">4.11.3. Legacy Drools 2.x XML rule format</a></span></dt><dt><span class="section"><a href="#d0e5750">4.11.4. Automatic transforming between formats (XML and DRL)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e5762">5. Authoring</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5765">5.1. Decision Tables in Spreadsheets</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5777">5.1.1. When to use Decision tables</a></span></dt><dt><span class="section"><a href="#d0e5789">5.1.2. Overview</a></span></dt><dt><span class="section"><a href="#d0e5827">5.1.3. How decision tables work</a></span></dt><dt><span class="section"><a href="#d0e5900">5.1.4. Keywords and Syntax</a></span></dt><dt><span class="section"><a href="#d0e6103">5.1.5. Creating and integrating Spreadsheet based Decision
      Tables</a></span></dt><dt><span class="section"><a href="#d0e6116">5.1.6. Managing business rules in decision tables.</a></span></dt><dt><span class="section"><a href="#d0e6161">5.1.7. Rule Templates</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6212">5.2. Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6225">5.2.1. The Rule Template File</a></span></dt><dt><span class="section"><a href="#d0e6322">5.2.2. Expanding a Template</a></span></dt><dt><span class="section"><a href="#d0e6376">5.2.3. Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e6447">6. The Java Rule Engine API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6450">6.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6465">6.2. How To Use</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6470">6.2.1. Building and Registering RuleExecutionSets</a></span></dt><dt><span class="section"><a href="#d0e6503">6.2.2. Using Stateful and Stateless RuleSessions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6538">6.3. References</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e6584">7. The Rule IDE (Eclipse)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6602">7.1. Features Outline</a></span></dt><dt><span class="section"><a href="#d0e6658">7.2. Creating a Rule Project</a></span></dt><dt><span class="section"><a href="#d0e6681">7.3. Creating a New Rule and Wizards</a></span></dt><dt><span class="section"><a href="#d0e6702">7.4. Textual Rule Editor</a></span></dt><dt><span class="section"><a href="#d0e6725">7.5. The Guided Editor (Rule GUI)</a></span></dt><dt><span class="section"><a href="#d0e6742">7.6. Drools Views</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6759">7.6.1. The Working Memory View</a></span></dt><dt><span class="section"><a href="#d0e6773">7.6.2. The Agenda View</a></span></dt><dt><span class="section"><a href="#d0e6787">7.6.3. The Global Data View</a></span></dt><dt><span class="section"><a href="#d0e6801">7.6.4. The Audit View</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6885">7.7. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6892">7.7.1. Editing languages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6915">7.8. The Rete View</a></span></dt><dt><span class="section"><a href="#d0e6931">7.9. Large DRL Files</a></span></dt><dt><span class="section"><a href="#d0e6947">7.10. Debugging Rules</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6958">7.10.1. Creating Breakpoints</a></span></dt><dt><span class="section"><a href="#d0e6972">7.10.2. Debugging Rules</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e7010">8. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7013">8.1. Getting the Examples</a></span></dt><dt><span class="section"><a href="#d0e7018">8.2. Hello World</a></span></dt><dt><span class="section"><a href="#d0e7283">8.3. State Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7288">8.3.1. Understanding the State Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7566">8.4. Fibonacci Example</a></span></dt><dt><span class="section"><a href="#d0e7769">8.5. Banking Tutorial</a></span></dt><dt><span class="section"><a href="#d0e8093">8.6. Pricing Rule Decision Table Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8114">8.6.1. Executing the example</a></span></dt><dt><span class="section"><a href="#d0e8156">8.6.2. The decision table</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8221">8.7. Pet Store Example</a></span></dt><dt><span class="section"><a href="#d0e8780">8.8. Honest Politician Example</a></span></dt><dt><span class="section"><a href="#d0e8905">8.9. Sudoku Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8926">8.9.1. Sudoku Overview</a></span></dt><dt><span class="section"><a href="#d0e8940">8.9.2. Running the Example</a></span></dt><dt><span class="section"><a href="#d0e9026">8.9.3. Java Source and Rules Overview</a></span></dt><dt><span class="section"><a href="#d0e9144">8.9.4. Sudoku Validator Rules (validatorSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e9174">8.9.5. Sudoku Solving Rules (solverSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e9282">8.9.6. Suggestions for Future Developments</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9337">8.10. Number Guess</a></span></dt><dt><span class="section"><a href="#d0e9627">8.11. Miss Manners and Benchmarking</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9646">8.11.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e9732">8.11.2. Indepth Discussion</a></span></dt><dt><span class="section"><a href="#d0e9942">8.11.3. Output Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9997">8.12. Conway's Game Of Life</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7"/>Chapter 1. The Rule Engine</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e10">1.1. What is a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13">1.1.1. Introduction and Background</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e103">1.2. Why use a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e124">1.2.1. Advantages of a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e167">1.2.2. When should you use a Rule Engine?</a></span></dt><dt><span class="section"><a href="#d0e204">1.2.3. When not to use a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e216">1.2.4. Scripting or Process Engines</a></span></dt><dt><span class="section"><a href="#d0e229">1.2.5. Strong and Loose Coupling</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10"/>1.1. What is a Rule Engine?</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13"/>1.1.1. Introduction and Background</h3></div></div></div><p>Artificial Intelligence (A.I.) is a very broad research area that
    focuses on "Making computers think like people" and includes disciplines
    such as Neural Networks, Genetic Algorithms, Decision Trees, Frame Systems
    and Expert Systems. Knowledge representation is the area of A.I. concerned
    with how knowledge is represented and manipulated. Expert Systems use
    Knowledge representation to facilitate the codification of knowledge into
    a knowledge base which can be used for reasoning, i.e., we can process
    data with this knowledge base to infer conclusions. Expert Systems are
    also known as Knowledge-based Systems and Knowledge-based Expert Systems
    and are considered to be "applied artificial intelligence". The process of
    developing with an Expert System is Knowledge Engineering. EMYCIN was one
    of the first "shells" for an Expert System, which was created from the
    MYCIN medical diagnosis Expert System. Whereas early Expert Systems had
    their logic hard-coded, "shells" separated the logic from the system,
    providing an easy to use environment for user input. Drools is a Rule
    Engine that uses the rule-based approach to implement an Expert System and
    is more correctly classified as a Production Rule System.</p><p>The term "Production Rule" originates from formal grammars where it
    is described as "an abstract structure that describes a formal language
    precisely, i.e., a set of rules that mathematically delineates a (usually
    infinite) set of finite-length strings over a (usually finite) alphabet"
    (<a class="ulink" href="http://en.wikipedia.org/wiki/Formal_grammar">
        <em class="citetitle">wikipedia</em>
      </a>).</p><p>Business Rule Management Systems build additional value on top of a
    general purpose Rule Engine by providing business user focused systems for
    rule creation, management, deployment, collaboration, analysis and end
    user tools. Further adding to this value is the fast evolving and popular
    methodology "Business Rules Approach", which is a helping to formalize the
    role of Rule Engines in the enterprise.</p><p>The term Rule Engine is quite ambiguous in that it can be any system
    that uses rules, in any form, that can be applied to data to produce
    outcomes. This includes simple systems like form validation and dynamic
    expression engines. The book "How to Build a Business Rules Engine (2004)"
    by Malcolm Chisholm exemplifies this ambiguity. The book is actually about
    how to build and alter a database schema to hold validation rules. The
    book then shows how to generate VB code from those validation rules to
    validate data entry. This, while a very valid and useful topic for some,
    caused quite a surprise to this author, unaware at the time in the
    subtleties of Rules Engines' differences, who was hoping to find some
    hidden secrets to help improve the Drools engine. JBoss jBPM uses
    expressions and delegates in its Decision nodes which control the
    transitions in a Workflow. At each node it evaluates ther is a rule set
    that dictates the transition to undertake, and so this is also a Rule
    Engine. While a Production Rule System is a kind of Rule Engine and also
    an Expert System, the validation and expression evaluation Rule Engines
    mentioned previously are not Expert Systems.</p><p>A Production Rule System is Turing complete, with a focus on
    knowledge representation to express propositional and first order logic in
    a concise, non-ambiguous and declarative manner. The brain of a Production
    Rules System is an Inference Engine that is able to scale to a large
    number of rules and facts. The Inference Engine matches facts and data
    against Production Rules - also called Productions or just Rules - to
    infer conclusions which result in actions. A Production Rule is a two-part
    structure using First Order Logic for reasoning over knowledge
    representation.</p><pre class="programlisting">when
    &lt;conditions&gt;
then
    &lt;actions&gt;;</pre><p>The process of matching the new or existing facts against Production
    Rules is called <a id="d0e36" class="indexterm"/> Pattern Matching, which is performed by the <a id="d0e40" class="indexterm"/> Inference Engine. There are a number of algorithms used for
    Pattern Matching by Inference Engines including:</p><div class="itemizedlist"><ul><li><p>Linear</p></li><li><p>Rete</p></li><li><p>Treat</p></li><li><p>Leaps</p></li></ul></div><p>Drools implements and extends the <a id="d0e59" class="indexterm"/> Rete algorithm;<a id="d0e63" class="indexterm"/> Leaps used to be provided but was retired as it became
    unmaintained. The Drools <a id="d0e67" class="indexterm"/> Rete implementation is called ReteOO, signifying that
    Drools has an enhanced and optimized implementation of the Rete algorithm
    for object oriented systems. Other Rete based engines also have marketing
    terms for their proprietary enhancements to Rete, like RetePlus and Rete
    III. The most common enhancements are covered in "Production Matching for
    Large Learning Systems (Rete/UL)" (1995) by Robert B. Doorenbos.</p><p>The Rules are stored in the <a id="d0e73" class="indexterm"/> Production Memory and the facts that the Inference Engine
    matches against are kept in the <a id="d0e77" class="indexterm"/> Working Memory. Facts are asserted into the Working Memory
    where they may then be modified or retracted. A system with a large number
    of rules and facts may result in many rules being true for the same fact
    assertion; these rules are said to be in conflict. The Agenda manages the
    execution order of these conflicting rules using a Conflict Resolution
    strategy.</p><div class="figure"><a id="d0e81"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/rule-engine-inkscape.png" align="middle" width="540" height="300" alt="High-level View of a Rule Engine"/></div></div><p class="title"><b>Figure 1.1. High-level View of a Rule Engine</b></p></div><br class="figure-break"/><p>There are two methods of execution for a rule system: Forward
    Chaining and Backward Chaining; systems that implement both are called
    Hybrid Rule Systems. Understanding these two modes of operation is the key
    to understanding why a Production Rule System is different and how to get
    the best from it. Forward chaining is "data-driven" and thus reactionary,
    with facts being asserted into working memory, which results in one or
    more rules being concurrently true and scheduled for execution by the
    Agenda. In short, we start with a fact, it propagates and we end in a
    conclusion. Drools is a forward chaining engine.</p><div class="figure"><a id="d0e89"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Forward_Chaining.png" align="middle" alt="Forward Chaining"/></div></div><p class="title"><b>Figure 1.2. Forward Chaining</b></p></div><br class="figure-break"/><p>Backward chaining is "goal-driven", meaning that we start with a
    conclusion which the engine tries to satisfy. If it can't it then searches
    for conclusions that it can satisfy; these are known as subgoals, that
    will help satisfy some unknown part of the current goal. It continues this
    process until either the initial conclusion is proven or there are no more
    subgoals. Prolog is an example of a Backward Chaining engine; Drools plans
    to provide support for Backward Chaining in a future release.</p><div class="figure"><a id="d0e97"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Backward_Chaining.png" align="middle" alt="Backward Chaining"/></div></div><p class="title"><b>Figure 1.3. Backward Chaining</b></p></div><br class="figure-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e103"/>1.2. Why use a Rule Engine?</h2></div></div></div><p>Some frequently asked questions:</p><div class="orderedlist"><ol type="1"><li><p>When should you use a rule engine?</p></li><li><p>What advantage does a rule engine have over hand coded
      "if...then" approaches?</p></li><li><p>Why should you use a rule engine instead of a scripting framework,
      like <a id="d0e118" class="indexterm"/> BeanShell?</p></li></ol></div><p>We will attempt to address these questions below.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e124"/>1.2.1. Advantages of a Rule Engine</h3></div></div></div><div class="itemizedlist"><ul><li><p>Declarative Programming</p><p>Rule engines allow you to say "What to do", not "How to do
        it".</p><p>The key advantage of this point is that using rules can make it
        easy to express solutions to difficult problems and consequently have
        those solutions verified. Rules are much easier to read than
        code.</p><p>Rule systems are capable of solving very, very hard problems,
        providing an explanation of how the solution was arrived at and why
        each "decision" along the way was made (not so easy with other of AI
        systems like neural networks or the human brain - I have no idea why I
        scratched the side of the car).</p></li><li><p>Logic and Data Separation</p><p>Your data is in your domain objects, the logic is in the rules.
        This is fundamentally breaking the OO coupling of data and logic,
        which can be an advantage or a disadvantage depending on your point of
        view. The upshot is that the logic can be much easier to maintain as
        there are changes in the future, as the logic is all laid out in
        rules. This can be especially true if the logic is cross-domain or
        multi-domain logic. Instead of the logic being spread across many
        domain objects or controllers, it can all be organized in one or more
        very distinct rules files.</p></li><li><p>Speed and Scalability</p><p>The Rete algorithm,the Leaps algorithm, and their descendants such as
        Drools' ReteOO, provide very efficient ways of matching
        rule patterns to your domain object data. These are especially
        efficient when you have datasets that change in small portions as the
        rule engine can remember past matches. These algorithms are battle
        proven.</p></li><li><p>Centralization of Knowledge</p><p>By using rules, you create a repository of knowledge (a
        knowledge base) which is executable. This means it's a single point of
        truth, for business policy, for instance. Ideally rules are so
        readable that they can also serve as documentation.</p></li><li><p>Tool Integration</p><p>Tools such as Eclipse (and in future, Web based user interfaces)
        provide
        ways to edit and manage rules and get immediate feedback, validation
        and content assistance. Auditing and debugging tools are also
        available.</p></li><li><p>Explanation Facility</p><p>Rule systems effectively provide an "explanation facility" by
        being able to log the decisions made by the rule engine along with why
        the decisions were made.</p></li><li><p>Understandable Rules</p><p>By creating object models and, optionally, Domain Specific
        Languages that model your problem domain you can set yourself up to
        write rules that are very close to natural language. They lend
        themselves to logic that is understandable to, possibly nontechnical,
        domain experts as they are expressed in their language, with all the
        program plumbing, the technical know-how being hidden
        away in the usual code.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e167"/>1.2.2. When should you use a Rule Engine?</h3></div></div></div><p>The shortest answer to this is "when there is no satisfactory
    traditional programming approach to solve the problem.". Given that short
    answer, some more explanation is required. The reason why there is no
    "traditional" approach is possibly one of the following: </p><div class="itemizedlist"><ul><li><p>The problem is just too fiddle for traditional code.</p><p>The problem may not be complex, but you can't see a
          non-fragile way of building a solution for it.</p></li><li><p>The problem is beyond any obvious algorithmic
          solution.</p><p>It is a complex problem to solve, there are no obvious
          traditional solutions, or basically the problem isn't fully
          understood.</p></li><li><p>The logic changes often</p><p>The logic itself may even be simple but
          the rules change quite often. In many organizations software
          releases are few and far between and pluggable rules can help provide the
          "agility" that is needed and expected in a reasonably safe
          way.</p></li><li><p>Domain experts (or business analysts) are readily available,
          but are nontechnical.</p><p>Domain experts often possess a wealth of knowledge about business
          rules and processes. They typically are nontechnical, but can be
          very logical. Rules can allow them to express the logic in their own
          terms. Of course, they still have to think critically and be capable
          of logical thinking. Many people in nontechnical positions do
          not have training in formal logic, so be careful and work with them,
          as by codifying business knowledge in rules, you will often expose
          holes in the way the business rules and processes are currently
          understood.</p></li></ul></div><p>If rules are a new technology for your project teams, the overhead
    in getting going must be factored in. It is not a trivial technology, but
    this document tries to make it easier to understand.</p><p>Typically in a modern OO application you would use a rule engine to
    contain key parts of your business logic, 
    <span class="emphasis"><em>especially the really messy parts</em></span>. This is
    an inversion of the OO concept of encapsulating all the logic inside your
    objects. This is not to say that you throw out OO practices, on the
    contrary in any real world application, business logic is just one part of
    the application. If you ever notice lots of conditional statements
    such as "if" and "switch", an
    overabundance of strategy patterns and other messy logic in your code
    that just doesn't feel right: that would be a place for rules.
    If there is some such logic and you keep coming back to fix it, either
    because you got it wrong, or the logic or your understanding changes: think
    about using rules. If you are faced with tough problems for which there are
    no algorithms or patterns: consider using rules.</p><p>Rules could be used embedded in your application or perhaps as a
    service. Often a rule engine works best as "stateful" component, being
    an integral part of an application. However, there have been
    successful cases of creating reusable rule services which are
    stateless.</p><p>For your organization it is important to decide about the process you
    will use for updating rules in systems that are in production. The options
    are many, but different organizations have different requirements.
    Frequently, rules maintenance is out of the control of the application
    vendors or project developers.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e204"/>1.2.3. When not to use a Rule Engine</h3></div></div></div><p>To quote a Drools mailing list regular: </p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>It seems to me
    that in the excitement of working with rules engines, that people forget
    that a rules engine is only one piece of a complex application or
    solution. Rules engines are not really intended to handle workflow or
    process executions nor are workflow engines or process management tools
    designed to do rules. Use the right tool for the job. Sure, a pair of
    pliers can be used as a hammering tool in a pinch, but that's not what
    it's designed for.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">Dave Hamu</span></td></tr></table></div><p>As rule engines are dynamic (dynamic in the sense that the rules can
    be stored and managed and updated as data), they are often looked at as a
    solution to the problem of deploying software. (Most IT departments seem to
    exist for the purpose of preventing software being rolled out.) If this is
    the reason you wish to use a rule engine, be aware that rule engines work
    best when you are able to write declarative rules. As an alternative, you
    can consider data-driven designs (lookup tables), or script processing
    engines where the scripts are managed in a database and are able to be
    updated on the fly.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e216"/>1.2.4. Scripting or Process Engines</h3></div></div></div><p>Hopefully the preceding sections have explained when you may want to
    use a rule engine.</p><p>Alternatives are script-based engines that provide the drive
    for "changes on the fly", and there are many such solutions.</p><p>Alternatively Process Engines (also capable of workflow) such as
    jBPM allow you to graphically (or programmatically) describe steps in a
    process. Those steps can also involve decision points which are in
    themselves a simple rule. Process engines and rules often can work nicely
    together, so they are not mutually exclusive.</p><p>One key point to note with rule engines is that some rule engines
    are really scripting engines. The downside of scripting engines is that
    you are tightly coupling your application to the scripts. If they are
    rules, you are effectively calling rules directly and this may cause more
    difficulty in future maintenance, as they tend to grow in complexity over
    time. The upside of scripting engines is that they can be easier to
    implement initially, producing results quickly, and are conceptually
    simpler for imperative programmers.</p><p>Many people have also implemented data-driven systems successfully
    in the past (where there are control tables that store meta-data that
    changes your applications behavior) - these can work well when the
    control can remain very limited. However, they can quickly grow out of
    control if extended too much (such that only the original creators can
    change the applications behavior) or they cause the application to
    stagnate as they are too inflexible.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e229"/>1.2.5. Strong and Loose Coupling</h3></div></div></div><p>No doubt you have heard terms like "tight coupling" and "loose
    coupling" in systems design. Generally people assert that "loose" or
    "weak" coupling is preferable in design terms, due to the added
    flexibility it affords. Similarly, you can have "strongly coupled" and
    "weakly coupled" rules. Strongly coupled in this sense means that one rule
    "firing" will clearly result in another rule firing, and so on; in other
    words,
    there is a clear (probably obvious) chain of logic. If your rules are all
    strongly coupled, the chances are that the will turn out to be inflexible,
    and, more significantly, that a rule engine is an overkill. A clear chain
    can be hard coded, or implemented using a Decision Tree. This is not to
    say that strong
    coupling is inherently bad, but it is a point to keep in mind when
    considering a rule engine and the way you capture the rules. "Loosely"
    coupled rules should result in a system that allows rules to be changed,
    removed and added without requiring changes to other, unrelated
    rules.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e237"/>Chapter 2. Quick Start</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e240">2.1. The Basics</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e243">2.1.1. Stateless Knowledge Session</a></span></dt><dt><span class="section"><a href="#d0e390">2.1.2. Stateful Knowledge Session</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">2.2. A Little Theory</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e565">2.2.1. Methods versus Rules</a></span></dt><dt><span class="section"><a href="#d0e597">2.2.2. Cross Products</a></span></dt><dt><span class="section"><a href="#d0e622">2.2.3. Activations, Agenda and Conflict Sets.</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e788">2.3. More on building and deploying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e791">2.3.1. Knowledge Base by Configuration Using Changesets</a></span></dt><dt><span class="section"><a href="#d0e819">2.3.2. Knowledge Agent</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e240"/>2.1. The Basics</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e243"/>2.1.1. Stateless Knowledge Session</h3></div></div></div><p>So where do we get started, there are so many use cases and so
      much functionality in a rule engine such as Drools that it becomes
      beguiling. Have no fear my intrepid adventurer, the complexity is
      layered and you can ease yourself into with simple use cases.</p><p>Stateless session, not utilising inference, forms the simplest
      use case. A stateless session can be called like a function passing it
      some data and then receiving some results back. Some common use cases
      for stateless sessions are, but not limited to:</p><div class="itemizedlist"><ul><li><p>Validation</p><div class="itemizedlist"><ul><li><p>Is this person eligible for a mortgage?</p></li></ul></div></li><li><p>Calculation</p><div class="itemizedlist"><ul><li><p>Compute a mortgage premium.</p></li></ul></div></li><li><p>Routing and Filtering</p><div class="itemizedlist"><ul><li><p>Filter incoming messages, such as emails, into
              folders.</p></li><li><p>Send incoming messages to a destination.</p></li></ul></div></li></ul></div><p>So let's start with a very simple example using a driving license
      application.</p><pre class="programlisting">public class Applicant {
    private String name;
    private int age;
    private boolean valid;
    // getter and setter methods here
}
</pre><p>Now that we have our data model we can write our first rule. We
      assume that the application uses rules to refute invalid applications.
      As this is a simple validation use case we will add a
      single rule to disqualify any applicant younger than 18.</p><pre class="programlisting">package com.company.license

rule "Is of valid age"
when
    $a : Applicant( age &lt; 18 )
then
    $a.setValid( false );
end</pre><p>To make the engine aware of data, so it can be processed against
      the rules, we have to <span class="emphasis"><em>insert</em></span> the data, much like 
      with a database. When
      the Applicant instance is inserted into the engine it is evaluated
      against the constraints of the rules, in this case just two constraints
      for one rule. We say <span class="emphasis"><em>two</em></span> because the type Applicant
      is the first object
      type constraint, and <code class="code">age &lt; 18</code> is the second field constraint.
      An object type constraint plus its zero or more field constraints is
      referred to as a pattern. When an inserted instance satisfies both the
      object type constraint and all the field constraints, it is said to be
      matched. The <code class="code">$a</code> is a binding variable which permits us to reference
      the matched object in the consequence. There its properties can be
      updated. The dollar character ('$') is optional, but it helps to
      differentiate variable names from field names. The process of
      matching patterns against the inserted data is, not surprisingly,
      often referred to as <span class="emphasis"><em>pattern matching</em></span>.</p><p>Let's assume that the rules are in the same folder as the classes,
      so we can use the classpath resource loader to build our first
      <code class="code">KnowledgeBase</code>. A Knowledge Base is what we call our collection of
      compiled rules, which are compiled using the <code class="code">KnowledgeBuilder</code>.</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "licenseApplication.drl", getClass() ),
              ResourceType.DRL );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );</pre><p>The above code snippet looks on the classpath for the 
      <code class="filename">licenseApplication.drl</code>
      file, using the method <code class="code">newClassPathResource()</code>. The resource type
      is DRL, short for "Drools Rule Language". Once the DRL file has been added
      we can check the Knowledge Builder object for any errors. If there are no
      errors, we can add the resulting packages to our Knowledge Base.
      Now we are ready to build our session and execute against some
      data:</p><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
assertTrue( applicant.isValid() );
ksession.execute( applicant );
assertFalse( applicant.isValid() );
</pre><p>The preceding code executes the data against the rules. Since the applicant is
      under the age of 18, the application is marked as invalid.</p><p>So far we've only used a single instance, but what if we want to use
      more than one? We can execute against any object implementing Iterable, such as
      a collection. Let's add another class called <code class="code">Application</code>, which has the
      date of the application, and we'll also move the boolean valid field to the
      <code class="code">Application</code> class.</p><pre class="programlisting">public class Applicant {
    private String name;
    private int age;
    // getter and setter methods here
}

public class Application {
    private Date dateApplied;
    private boolean valid;
    // getter and setter methods here
}</pre><p>We can also add another rule to validate that the application
      was made within a period of time.</p><pre class="programlisting">package com.company.license

rule "Is of valid age"
when
    Applicant( age &lt; 18 )
    $a : Application()     
then
    $a.setValid( false );
end

rule "Application was made this year"
when
    $a : Application( dateApplied &gt; "01-jan-2009" )     
then
    $a.setValid( false );
end
</pre><p>Unfortunately a Java array does not implement the
      <code class="code">Iterable</code>
      interface, so we have to use the JDK converter method
      <code class="code">Arrays.asList(...)</code>. The code
      shown below executes against an iterable list, where all collection
      elements are inserted before any matched rules are fired.</p><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
Application application = new Application();
assertTrue( application() );
ksession.execute( Arrays.asList( new Object[] { application, applicant } ) );
assertFalse( application() );
</pre><p>The two execute methods <code class="code">execute(Object object)</code> and
      <code class="code">execute(Iterable objects)</code> are actually convenience methods for the
      interface <code class="code">BatchExecutor</code>'s method <code class="code">execute(Command command)</code>.</p><p>A <code class="code">CommandFactory</code> is used to create commands, so that the following is
      equivalent to <code class="code">execute(Iterable it)</code>:</p><pre class="programlisting">ksession.execute( CommandFactory.newInsertIterable( new Object[] { application, applicant } ) );
</pre><p>Batch Executor and Command Factory are particularly useful when working
      with multiple Commands and with output identifiers for obtaining results.</p><pre class="programlisting">List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();
cmds.add( CommandFactory.newInsert( new Person( "Mr John Smith" ), "mrSmith" );
cmds.add( CommandFactory.newInsert( new Person( "Mr John Doe" ), "mrDoe" );
BatchExecutionResults results = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
assertEquals( new Person( "Mr John Smith" ), results.getValue( "mrSmith" ) );
</pre><p><code class="code">CommandFactory</code> supports many other Commands that can be used in
      the <code class="code">BatchExecutor</code> like <code class="code">StartProcess</code>, <code class="code">Query</code>, and
      <code class="code">SetGlobal</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e390"/>2.1.2. Stateful Knowledge Session</h3></div></div></div><p>Stateful Sessions are longer lived and allow iterative changes
      over time. Some common use cases for Stateful Sessions are, but not
      limited to:</p><div class="itemizedlist"><ul><li><p>Monitoring</p><div class="itemizedlist"><ul><li><p>Stock market monitoring and analysis for semi-automatic
              buying.</p></li></ul></div></li><li><p>Diagnostics</p><div class="itemizedlist"><ul><li><p>Fault finding, medical diagnostics</p></li></ul></div></li><li><p>Logistics</p><div class="itemizedlist"><ul><li><p>Parcel tracking and delivery provisioning</p></li></ul></div></li><li><p>Compliance</p><div class="itemizedlist"><ul><li><p>Validation of legality for market trades.</p></li></ul></div></li></ul></div><p>In contrast to a Stateless Session, the <code class="code">dispose()</code>
      method must be called
      afterwards to ensure there are no memory leaks, as the Knowledge Base
      contains references to Stateful Knowledge Sessions when they are created.
      <code class="code">StatefulKnowledgeSession</code> also supports the <code class="code">BatchExecutor</code>
      interface, like <code class="code">StatelessKnowledgeSession</code>, the only difference
      being that the <code class="code">FireAllRules</code> command is not automatically called at the
      end for a Stateful Session.</p><p>We illustrate the monitoring use case with an example for raising a
      fire alarm. Using just four classes, we represent rooms in a house, each of which
      has one sprinkler. If a fire starts in a room, we
      represent that with a single <code class="code">Fire</code> instance.</p><pre class="programlisting">public class Room {
    private String name
    // getter and setter methods here
}
public classs Sprinkler {
    private Room room;
    private boolean on;
    // getter and setter methods here
}
public class Fire {
    private Room room;
    // getter and setter methods here
}
public class Alarm {
}
</pre><p>In the previous section on Stateless Sessions the concepts of
      inserting and matching against data was introduced. That example assumed
      that only a single instance of each object type was ever inserted and thus
      only used literal constraints. However, a house has many rooms, so rules
      must express relationships between objects, such as a sprinkler being in
      a certain room. This is best done by using a binding variable as a constraint
      in a pattern. This "join" process results in what is called cross products, which are
      covered in the next section.</p><p>When a fire occurs an instance of the <code class="code">Fire</code> class is created, for
      that room, and inserted into the session. The rule uses a binding on the 
      <code class="code">room</code>
      field of the <code class="code">Fire</code> object to constrain matching to the sprinkler for that room,
      which is currently  off. When this rule fires and the consequence is executed
      the sprinkler is turned on.</p><pre class="programlisting">rule "When there is a fire turn on the sprinkler"
when
    Fire($room : room)
    $sprinkler : Sprinkler( room == $room, on == false )
then
    modify( $sprinkler ) { setOn( true ) };
    System.out.println( "Turn on the sprinkler for room " + $room.getName() );
end</pre><p>Whereas the Stateless Session uses standard Java syntax to modify
      a field, in the above rule we use the <strong class="kw"><code>modify</code></strong> statement, which acts as a
      sort of "with" statement. It may contain a series of comma separated Java
      expressions, i.e., calls to setters of the object selected by the <strong class="kw"><code>modify</code></strong>
      statement's control
      expression. This modifies the data, and makes the engine aware of those changes
      so it can reason over them once more. This process is called inference, and
      it's essential for the working of a Stateful Session. Stateless Sessions 
      typically do not use inference, so the engine does not need to be aware of 
      changes to data. Inference can also be turned off explicitly by using the
      <span class="emphasis"><em>sequential mode</em></span>.</p><p>So far we have rules that tell us when matching data exists, but
      what about when it does <span class="emphasis"><em>not</em></span> exist? How do we determine
      that a fire has been extinguished, i.e., that there isn't a <code class="code">Fire</code>
      object any more? Previously the constraints have been sentences according
      to Propositional Logic,
      where the engine is constraining against individual intances. Drools also has
      support for First Order Logic that allows you to look at sets of data.
      A pattern under the keyword <strong class="kw"><code>not</code></strong> matches when something does not exist.
      The rule given below turns the sprinkler off as soon as the fire in that
      room has disappeared.</p><pre class="programlisting">rule "When the fire is gone turn off the sprinkler"
when
    $room : Room( )
    $sprinkler : Sprinkler( room == $room, on == true )
    not Fire( room == $room )
then
    modify( $sprinkler ) { setOn( false ) };
    System.out.println( "Turn off the sprinkler for room " + $room.getName() );
end</pre><p>While there is one sprinkler per room, there is just a single alarm
      for the building. An <code class="code">Alarm</code> object is created when a fire occurs,
      but only one <code class="code">Alarm</code> is needed for the entire building, no matter
      how many fires occur. Previously <strong class="kw"><code>not</code></strong> was introduced to match the absence of
      a fact; now we use its complement <strong class="kw"><code>exists</code></strong> which matches for one or more
      instances of some category.</p><pre class="programlisting">rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert( new Alarm() );
    System.out.println( "Raise the alarm" );
end</pre><p>Likewise, when there are no fires we want to remove the alarm, so
      the <strong class="kw"><code>not</code></strong> keyword can be used again.</p><pre class="programlisting">rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    retract( $alarm );
    System.out.println( "Cancel the alarm" );
end

</pre><p>Finally there is a general health status message that is printed
      when the application first starts and after the alarm is removed and all
      sprinklers have been turned off.</p><pre class="programlisting">rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler( on === true ) 
then
    System.out.println( "Everything is ok" );
end</pre><p>The above rules should be placed in a single DRL file and saved to
      some directory on the classpath and using the file name
      <code class="filename">fireAlarm.drl</code>,
      as in the Stateless Session example. We can then build a Knowledge Base,
      as before, just using the new name <code class="filename">fireAlarm.drl</code>.
      The difference is that
      this time we create a Stateful Session from the Knowledge Base, whereas
      before we created a Stateless Session.</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "fireAlarm.drl", getClass() ),
              ResourceType.DRL );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();</pre><p>With the session created it is now possible to iteratvely work
      with it over time. Four <code class="code">Room</code> objects are created and 
      inserted, as well as one <code class="code">Sprinkler</code> object for
      each room. At this point the engine has done all of its
      matching, but no rules have fired yet. Calling <code class="code">ksession.fireAllRules()</code>
      allows the matched rules to fire, but without a fire that will
      just produce the health message.</p><pre class="programlisting">String[] names = new String[]{"kitchen", "bedroom", "office", "livingroom"};
Map&lt;String,Room&gt; name2room = new HashMap&lt;String,Room&gt;();
for( String name: names ){
    Room room = new Room( name );
    name2room.put( name, room );
    ksession.insert( room );
    Sprinkler sprinkler = new Sprinkler( room );
    ksession.insert( sprinkler );
}

ksession.fireAllRules()
</pre><pre class="programlisting">&gt; Everything is ok</pre><p>We now create two fires and insert them; this time a reference is
      kept for the returned <code class="code">FactHandle</code>. A Fact Handle is an 
      internal engine reference to the inserted instance and allows instances to be
      retracted or modified at a later point in time. With the fires now in
      the engine, once <code class="code">fireAllRules()</code> is called, the alarm is raised and the
      respective sprinklers are turned on.</p><pre class="programlisting">Fire kitchenFire = new Fire( name2room.get( "kitchen" ) );
Fire officeFire = new Fire( name2room.get( "office" ) );

FactHandle kitchenFireHandle = ksession.insert( kitchenFire );
FactHandle officeFireHandle = ksession.insert( officeFire );

ksession.fireAllRules();</pre><pre class="programlisting">&gt; Raise the alarm
&gt; Turn on the sprinkler for room kitchen
&gt; Turn on the sprinkler for room office</pre><p>After a while the fires will be put out and the <code class="code">Fire</code>
      instances are retracted. This results in the sprinklers being turned off, the alarm
      being cancelled, and eventually the health message is printed again.</p><pre class="programlisting">ksession.retract( kitchenFireHandle );
ksession.retract( officeFireHandle );

ksession.fireAllRules();</pre><pre class="programlisting">&gt; Turn on the sprinkler for room office
&gt; Turn on the sprinkler for room kitchen
&gt; Cancel the alarm
&gt; Everything is ok</pre><p>Everyone still with me? That wasn't so hard and already I'm
      hoping you can start to see the value and power of a declarative rule
      system.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e562"/>2.2. A Little Theory</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e565"/>2.2.1. Methods versus Rules</h3></div></div></div><p>People often confuse methods and rules, and new rule users regular
      ask, "How do I call a rule?" After the last section, you are now
      feeling like a rule expert and the answer to that is obvious, but let's
      summarize the differences nonetheless.</p><pre class="programlisting">public void helloWorld(Person person) {
    if ( person.getName().equals( "Chuck" ) ) {
        System.out.println( "Hello Chuck" );
    }
}</pre><div class="itemizedlist"><ul><li><p>Methods are called directly.</p></li><li><p>Specific instances are passed.</p></li><li><p>One call results in a single execution.</p></li></ul></div><pre class="programlisting">rule "Hello World"
    when
        Person( name == "Chuck" )
    then
        System.out.println( "Hello Chuck" );
        end</pre><div class="itemizedlist"><ul><li><p>Rules execute by matching against any data as long it is
          inserted into the engine.</p></li><li><p>Rules can never be called directly.</p></li><li><p>Specific instances cannot be passed to a rule.</p></li><li><p>Depending on the matches, a rule may fire once or several
          times, or not at all.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e597"/>2.2.2. Cross Products</h3></div></div></div><p>Earlier the term "cross product" was mentioned, which is the
      result of a join. Imagine for a moment that the data from the
      fire alarm example were used in combination with the following
      rule where there ar no field constraints:</p><pre class="programlisting">rule
when
    $room : Room()
    $sprinkler : Sprinkler()
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</pre><p>In SQL terms this would be like doing <code class="code">select * from Room,
      Sprinkler</code> and every row in the Room table would be joined with every
      row in the Sprinkler table resulting in the following output:</p><pre class="programlisting">room:office sprinker:office
room:office sprinkler:kitchen
room:office sprinkler:livingroom
room:office sprinkler:bedroom
room:kitchen sprinkler:office
room:kitchen sprinkler:kitchen
room:kitchen sprinkler:livingroom
room:kitchen sprinkler:bedroom
room:livingroom sprinkler:office
room:livingroom sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:livingroom sprinkler:bedroom
room:bedroom sprinkler:office
room:bedroom sprinkler:kitchen
room:bedroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</pre><p>These cross products can obviously become huge, and they may
      very well contain spurious data. The size of cross products is
      often the source of performance problems for new rule authors.
      From this it can be seen that it's always desirable to constrain
      the cross products, which is done with the variable constraint.</p><pre class="programlisting">rule
when
    $room : Room()
    $sprinkler : Sprinkler( room == $room )
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</pre><p>This results in just four rows of data, with the correct Sprinkler
      for each Room. In SQL (actually HQL) the corresponding query would be
      <code class="code">select * from Room, Sprinkler where Room == Sprinkler.room</code>.</p><pre class="programlisting">room:office sprinkler:office
room:kitchen sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e622"/>2.2.3. Activations, Agenda and Conflict Sets.</h3></div></div></div><p>So far the data and the matching process has been simple and small. To
      mix things up a bit a new example will be explored that handles cashflow
      calculations over date periods. The state of the engine will be
      illustratively shown at key stages to help get a better understanding
      of what is actually going on under the hood. Three classes will be used,
      as shown below.</p><pre class="programlisting">public class CashFlow {
    private Date   date;
    private double amount;
    private int    type;
    long           accountNo;
    // getter and setter methods here
}

public class Account {
    private long   accountNo;
    private double balance;
    // getter and setter methods here
}

public AccountPeriod {
    private Date start;
    private Date end;
    // getter and setter methods here
}</pre><p>By now you already know how to create Knowledge Bases and how to
      instantiate facts to populate the <code class="code">StatefulKnowledgeSession</code>, so tables
      will be used to show the state of the inserted data, as it makes things
      clearer for illustration purposes. The tables below show that a single fact
      was inserted for the <code class="code">Account</code>. Also inserted are a series of debits
      and credits as <code class="code">CashFlow</code> objects for that account, extending over two
      quarters.</p><div class="figure"><a id="d0e640"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Quick_Start/tables1.png" width="100%" alt="CashFlows and Account"/></td></tr></table></div></div><p class="title"><b>Figure 2.1. CashFlows and Account</b></p></div><br class="figure-break"/><p>Two rules can be used to determine the debit and credit for that
      quarter and update the Account balance. The two rules below constrain
      the cashflows for an account for a given time period. Notice the
      "&amp;&amp;" which use short cut syntax to avoid repeating the field
      name twice.</p><table frame="void"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">rule "increase balance for credits"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end,
    $amount : amount )
then
  acc.balance  += $amount;
end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">rule "decrease balance for debits" 
when 
  ap : AccountPeriod() 
  acc : Account( $accountNo : accountNo ) 
  CashFlow( type == DEBIT, 
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end, 
    $amount : amount ) 
then 
  acc.balance -= $amount; 
end</pre>
            </td>
          </tr></tbody></table><p>If the <code class="code">AccountPeriod</code> is set to the first quarter we constrain the
      rule "increase balance for credits" to fire on two rows of data and
      "decrease balance for debits" to act on one row of data.</p><div class="figure"><a id="d0e669"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables2.png" alt="AccountingPeriod, CashFlows and Account"/></div></div><p class="title"><b>Figure 2.2. AccountingPeriod, CashFlows and Account</b></p></div><br class="figure-break"/><p>The two cashflow tables above represent the matched data for the
      two rules. The data is matched during the insertion stage and, as you
      discovered in the previous chapter, does not fire straight away, but only
      after <code class="code">fireAllRules()</code> is called. Meanwhile, the rule plus its 
      matched data is
      placed on the Agenda and referred to as an Activation. The Agenda is a
      table of Activations that are able to fire and have their consequences
      executed, as soon as fireAllRules() is called. Activations on the
      Agenda are executed in turn. Notice that the order of execution 
      so far is considered arbitrary.</p><div class="figure"><a id="d0e680"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables7.png" alt="CashFlows and Account"/></div></div><p class="title"><b>Figure 2.3. CashFlows and Account</b></p></div><br class="figure-break"/><p>After all of the above activations are fired, the account has a
      balance of -25.</p><div class="figure"><a id="d0e688"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables3.png" alt="CashFlows and Account"/></div></div><p class="title"><b>Figure 2.4. CashFlows and Account</b></p></div><br class="figure-break"/><p>If the <code class="code">AccountPeriod</code> is updated to the second quarter, we have just
      a single matched row of data, and thus just a single Activation on the
      Agenda.</p><div class="figure"><a id="d0e699"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables4.png" alt="CashFlows and Account"/></div></div><p class="title"><b>Figure 2.5. CashFlows and Account</b></p></div><br class="figure-break"/><p>The firing of that Activation results in a balance of 25.</p><div class="figure"><a id="d0e707"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables5.png" alt="CashFlows and Account"/></div></div><p class="title"><b>Figure 2.6. CashFlows and Account</b></p></div><br class="figure-break"/><p>What if you don't want the order of Activation
      execution to be arbitrary? When there is one or more Activations on the
      Agenda they are said to be in conflict, and a conflict resolver strategy
      is used to determine the order of execution. At the simplest level the
      default strategy uses salience to determine rule priority. Each rule has
      a default value of 0, the higher the value the higher the priority. To
      illustrate this we add a rule to print the account balance, where we
      want this rule to be executed after all the debits and credits have
      been applied for all accounts. We achieve this by assigning a negative
      salience to this rule so that it fires after all rules with the default
      salience 0.</p><table border="0" id="d0e715"><tbody><tr>
            <td>
              <pre class="programlisting">rule "Print balance for AccountPeriod"
        salience -50
    when
        ap : AccountPeriod()
        acc : Account()        
    then
        System.out.println( acc.accountNo + " : " + acc.balance );    
end</pre>
            </td>
          </tr></tbody></table><p>The table below depicts the resulting Agenda. The three debit and credit
      rules are shown to be in arbitrary order, while the print rule is ranked
      last, to execute afterwards.</p><div class="figure"><a id="d0e727"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables6.png" alt="CashFlows and Account"/></div></div><p class="title"><b>Figure 2.7. CashFlows and Account</b></p></div><br class="figure-break"/><p>Earlier we showed how rules would equate to SQL, which can often
      help people with an SQL background to understand rules.
      The two rules above can be represented with two views and a trigger for
      each view, as below:</p><table border="0" id="d0e735"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">select * from Account acc,
              Cashflow cf,
              AccountPeriod ap      
where acc.accountNo == cf.accountNo and 
      cf.type == CREDIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">select * from Account acc, 
              Cashflow cf,
              AccountPeriod ap 
where acc.accountNo == cf.accountNo and 
      cf.type == DEBIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</pre>
            </td>
          </tr><tr>
            <td align="left" valign="top">
              <pre class="programlisting">trigger : acc.balance += cf.amount</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">trigger : acc.balance -= cf.amount</pre>
            </td>
          </tr></tbody></table><p>Drools also features ruleflow-group attributes which allows
      workflow diagrams to declaratively specify when rules are allowed to
      fire. The screenshot below is taken from Eclipse using the Drools
      plugin. It has two ruleflow-group nodes which ensures that the calculation
      rules are executed before the reporting rules.</p><div class="mediaobject"><img src="images/Chapter-Quick_Start/ruleflow.png"/></div><p>The use of the ruleflow-group attribute in a rule is shown
      below.</p><table border="0" id="d0e772"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">rule "increase balance for credits"
  ruleflow-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">rule "Print balance for AccountPeriod"
  ruleflow-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</pre>
            </td>
          </tr></tbody></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e788"/>2.3. More on building and deploying</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e791"/>2.3.1. Knowledge Base by Configuration Using Changesets</h3></div></div></div><p>So far, the programmatic API has been used to build a
      Knowledge Base. Quite often it's more desirable to do this via
      configuration. To facilitate this, Drools supports the "Changeset"
      feature. The file <code class="filename">changeset.xml</code> contains a
      list of resources, and it
      may also point recursively to another changeset XML file. Currently the 
      changeset has only a single "add" element, but support for remove 
      and modify will be added in the future, for more powerful incremental
      changes over time. Currently there is no XML schema for the changeset
      XML, but we hope to add one soon. A few examples will be
      shown to give you the gist of things. A resource approach is employed
      that uses a prefix to indicate the protocol. All the protocols provided
      by <code class="code">java.net.URL</code>, such as "file" and "http", are supported, as well as an
      additional "classpath". Currently the type attribute must always be
      specified for a resource, as it is not inferred from the file name extension.
      Here is a simple example that points to a http location for some rules.</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre><p>To use the above XML, the code is almost identical as before,
      except we change the resource type to <code class="code">CHANGE_SET</code>.</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClasspathResource( "myChangeSet.xml", getClass() ),
              ResourceType.CHANGE_SET );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}</pre><p>Changesets can include any number of resources, and they even support
      additional configuration information, which currently is only needed for
      decision tables. The example below is expanded to load the rules from a
      http URL location, and an Excel decision table from the classpath.</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
       &lt;resource source='classpath:data/IntegrationExampleTest.xls' type="DTABLE"&gt;
           &lt;decisiontable-conf input-type="XLS" worksheet-name="Tables_2" /&gt;
       &lt;/resource&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre><p>It is also possible to specify a directory, to add the contents of
      that directory. It is expected that all the files are
      of the specified type, since type is not yet inferred from the file name
      extensions.</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='file://myfolder/' type='DRL' /&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e819"/>2.3.2. Knowledge Agent</h3></div></div></div><p>The Knowlege Agent provides automatic loading, caching and
      re-loading of resources and is configured from a properties files. The
      Knowledge Agent can update or rebuild this Knowlege Base as the resources
      it uses are changed. The strategy for this is determined by the
      configuration given to the factory, but it is typically pull-based using
      regular polling. We hope to add push-based updates and rebuilds in
      future versions.</p><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
kagent.applyChangeSet( ResourceFactory.newUrlResource( url ) );
KnowledgeBase kbase = kagent.getKnowledgeBase();</pre><p>A <code class="code">KnowledgeAgent</code> object will continuously scan all the
      added resources, using a default polling interval of 60 seconds and, when
      some last modification date is updated, it will rebuild the cached
      Knowledge Base using the new  resources. Note that the previous
      <code class="code">KnowledgeBase</code> reference will still exist
      and you'll have to call <code class="code">getKnowledgeBase()</code> to access the newly built
      <code class="code">KnowledgeBase</code>. If a directory is specified as part of the change set,
      the entire contents of that directory will be scanned for
      changes.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e840"/>Chapter 3. User Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e843">3.1. Building</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e852">3.1.1. Building using Code</a></span></dt><dt><span class="section"><a href="#d0e933">3.1.2. Building using Configuration and the ChangeSet XML</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e989">3.2. Deploying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e992">3.2.1. KnowledgePackage and Knowledge Definitions</a></span></dt><dt><span class="section"><a href="#d0e1005">3.2.2. KnowledgeBase</a></span></dt><dt><span class="section"><a href="#d0e1055">3.2.3. In-Process Building and Deployment</a></span></dt><dt><span class="section"><a href="#d0e1070">3.2.4. Building and Deployment in Separate Processes</a></span></dt><dt><span class="section"><a href="#d0e1109">3.2.5. StatefulknowledgeSessions and KnowledgeBase Modifications</a></span></dt><dt><span class="section"><a href="#d0e1123">3.2.6. KnowledgeAgent</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1248">3.3. Running</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1252">3.3.1. KnowledgeBase</a></span></dt><dt><span class="section"><a href="#d0e1271">3.3.2. StatefulKnowledgeSession</a></span></dt><dt><span class="section"><a href="#d0e1293">3.3.3. KnowledgeRuntime</a></span></dt><dt><span class="section"><a href="#d0e1560">3.3.4. Agenda</a></span></dt><dt><span class="section"><a href="#d0e1666">3.3.5. Event Model</a></span></dt><dt><span class="section"><a href="#d0e1781">3.3.6. KnowledgeRuntimeLogger</a></span></dt><dt><span class="section"><a href="#d0e1797">3.3.7. StatelessKnowledgeSession</a></span></dt><dt><span class="section"><a href="#d0e1992">3.3.8. Pipeline</a></span></dt><dt><span class="section"><a href="#d0e2250">3.3.9. Commands and the CommandExecutor</a></span></dt><dt><span class="section"><a href="#d0e2593">3.3.10. Marshalling</a></span></dt><dt><span class="section"><a href="#d0e2668">3.3.11. Persistence and Transactions</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e843"/>3.1. Building</h2></div></div></div><div class="figure"><a id="d0e846"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/builder.png" alt="org.drools.builder"/></div></div><p class="title"><b>Figure 3.1. org.drools.builder</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e852"/>3.1.1. Building using Code</h3></div></div></div><p>The KnowledgeBuilder is responsible for taking source files, such as
    a DRL file or an Excel file, and turning them into a Knowledge Package of
    rule and process definitions which a Knowledge Base can consume. An object
    of the class <code class="code">ResourceType</code> indicates the type of resource it is being
    asked to build.</p><p>The <code class="code">ResourceFactory</code> provides capabilities to load resources from a
    number of sources, such as Reader, ClassPath, URL, File, or ByteArray.
    Binaries, such as decision tables (Excel .xls files), should not use a Reader based
    resource handler, which is only suitable for text based resources.</p><div class="figure"><a id="d0e865"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeBuilder.png" width="100%" alt="KnowledgeBuilder"/></td></tr></table></div></div><p class="title"><b>Figure 3.2. KnowledgeBuilder</b></p></div><br class="figure-break"/><p>The KnowlegeBuilder is created using the
    KnowledgeBuilderFactory.</p><div class="figure"><a id="d0e873"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeBuilderFactory.png" width="100%" alt="KnowledgeBuilderFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.3. KnowledgeBuilderFactory</b></p></div><br class="figure-break"/><p>A KnowledgeBuilder can be created using the default
    configuration.</p><div class="example"><a id="d0e881"/><p class="title"><b>Example 3.1. Creating a new KnowledgeBuilder</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();</pre></div></div><br class="example-break"/><p>A configuration can be created using the <code class="code">KnowledgeBuilderFactory</code>.
    This allows the behavior of the Knowledge Builder to be modified. The most
    common usage is to provide a custom class loader so that the <code class="code">KnowledgeBuilder</code>
    object can resolve classes that are not in the default classpath. The first parameter
    is for properties and is optional, i.e., it may be left null, in which case the
    default options will be used. The options parameter can be used for things
    like changing the dialect or registering new accumulator functions.</p><div class="example"><a id="d0e894"/><p class="title"><b>Example 3.2. Creating a new KnowledgeBuilder with a custom ClassLoader</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilderConfiguration kbuilderConf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null, classLoader );
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(kbuilderConf);
</pre></div></div><br class="example-break"/><p>Resources of any type can be added iteratively. Below, a DRL file is
    added. Unlike Drools 4.0 Package Builder, the Knowledge Builder can now
    handle multiple namespaces, so you can just keep adding resources
    regardless of namespace.</p><div class="example"><a id="d0e901"/><p class="title"><b>Example 3.3. Adding DRL Resources</b></p><div class="example-contents"><pre class="programlisting">kbuilder.add( ResourceFactory.newFileResource( "/project/myrules.drl" ),
              ResourceType.DRL);
</pre></div></div><br class="example-break"/><p>It is best practice to always check the <code class="code">hasErrors()</code> method after an
    addition. You should not add more resources or retrieve the Knowledge Packages
    if there are errors. <code class="code">getKnowledgePackages()</code> returns an empty list if
    there are errors.</p><div class="example"><a id="d0e914"/><p class="title"><b>Example 3.4. Validating</b></p><div class="example-contents"><pre class="programlisting">if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}
</pre></div></div><br class="example-break"/><p>When all the resources have been added and there are no errors the
    collection of Knowledge Packages can be retrieved. It is a Collection because
    there is one Knowledge Package per package namespace. These
    Knowledge Packages are serializable and often used as a unit of
    deployment.</p><div class="example"><a id="d0e921"/><p class="title"><b>Example 3.5. Getting the KnowledgePackages</b></p><div class="example-contents"><pre class="programlisting">Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();
</pre></div></div><br class="example-break"/><p>The final example puts it all together.</p><div class="example"><a id="d0e928"/><p class="title"><b>Example 3.6. Putting it all together</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}

KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newFileResource( "/project/myrules1.drl" ),
              ResourceType.DRL);
kbuilder.add( ResourceFactory.newFileResource( "/project/myrules2.drl" ),
              ResourceType.DRL);

if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}

Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e933"/>3.1.2. Building using Configuration and the ChangeSet XML</h3></div></div></div><p>Instead of adding the resources to create definitions
    programmatically it is also possible to do it by configuration, via the
    ChangeSet XML. The simple XML file supports
    three elements: add, remove, and modify, each of which has a sequence
    of &lt;resource&gt; subelements defining a configuration entity. The
    following XML schema is <span class="emphasis"><em>not</em></span> normative and
    intended for illustration only.</p><div class="example"><a id="d0e941"/><p class="title"><b>Example 3.7. XML Schema for ChangeSet XML (not normative)</b></p><div class="example-contents"><pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://drools.org/drools-5.0/change-set"
           targetNamespace="http://drools.org/drools-5.0/change-set"&gt;

  &lt;xs:element name="change-set" type="ChangeSet"/&gt;

  &lt;xs:complexType name="ChangeSet"&gt;
    &lt;xs:choice maxOccurs="unbounded"&gt;
      &lt;xs:element name="add"    type="Operation"/&gt;
      &lt;xs:element name="remove" type="Operation"/&gt;
      &lt;xs:element name="modify" type="Operation"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Operation"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="resource" type="Resource"
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Resource"&gt;
    &lt;xs:sequence&gt;
      
      &lt;xs:element name="decisiontable-conf" type="DecTabConf"
                  minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    
    &lt;xs:attribute name="source" type="xs:string"/&gt;
    &lt;xs:attribute name="type"   type="ResourceType"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="DecTabConf"&gt;
    &lt;xs:attribute name="input-type"     type="DecTabInpType"/&gt;
    &lt;xs:attribute name="worksheet-name" type="xs:string"
                  use="optional"/&gt;
  &lt;/xs:complexType&gt;

  
  &lt;xs:simpleType name="ResourceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DRL"/&gt;
      &lt;xs:enumeration value="XDRL"/&gt;
      &lt;xs:enumeration value="DSL"/&gt;
      &lt;xs:enumeration value="DSLR"/&gt;
      &lt;xs:enumeration value="DRF"/&gt;
      &lt;xs:enumeration value="DTABLE"/&gt;
      &lt;xs:enumeration value="PKG"/&gt;
      &lt;xs:enumeration value="BRL"/&gt;
      &lt;xs:enumeration value="CHANGE_SET"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  
  &lt;xs:simpleType name="DecTabInpType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="XLS"/&gt;
      &lt;xs:enumeration value="CSV"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre></div></div><br class="example-break"/><p>Currently only the add element is supported, but the others will be implemented to
    support iterative changes. The following example loads a single DRL file.</p><div class="example"><a id="d0e956"/><p class="title"><b>Example 3.8. Simple ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/project/myrules.drl' type='DRL' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"/><p>Notice the <code class="code">file:</code> prefix, which signifies the protocol for the
    resource. The Change Set supports all the protocols provided by
    java.net.URL, such as "file" and "http", as well as an additional
    "classpath". Currently the type attribute must always be specified for a
    resource, as it is not inferred from the file name extension. Using the
    ClassPath resource loader in Java allows you to specify the Class Loader to
    be used to locate the resource but this is not possible from XML. Instead,
    the Class Loader will default to the one used by the Knowledge Builder
    unless the ChangeSet XML is itself loaded by the ClassPath resource, in
    which case it will use the Class Loader specified for that resource.</p><p>Currently you still need to use the API to load that ChangeSet, but
    we will add support for containers such as Spring in the future, so that the
    process of creating a Knowledge Base can be done completely by XML configuration.
    Loading resources using an XML file couldn't be simpler, as it's just another
    resource type.</p><div class="example"><a id="d0e968"/><p class="title"><b>Example 3.9. Loading the ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting">kbuilder.add( ResourceFactory.newUrlResource( url ), ResourceType.CHANGE_SET );
</pre></div></div><br class="example-break"/><p>ChangeSets can include any number of resources, and they even support
    additional configuration information, which currently is only needed for
    decision tables. Below, the example is expanded to load rules from a
    http URL location, and an Excel decision table from the classpath.</p><div class="example"><a id="d0e975"/><p class="title"><b>Example 3.10. ChangeSet XML with resource configuration</b></p><div class="example-contents"><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
  &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
       &lt;resource source='classpath:data/IntegrationExampleTest.xls' type="DTABLE"&gt;
           &lt;decisiontable-conf input-type="XLS" worksheet-name="Tables_2" /&gt;
       &lt;/resource&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre></div></div><br class="example-break"/><p>The ChangeSet is especially useful when working with a Knowledge Agent,
    as it allows for change notification and automatic rebuilding of the
    Knowledge Base, which is covered in more detail in the section on the
    Knowledge Agent, under Deploying.</p><p>Directories can also be specified, to add all resources
    in that folder. Currently it is expected that all resources in
    that folder are of the same type. If you use the Knowledge Agent it will
    provide a continous scanning for added, modified or removed resources and
    rebuild the cached Knowledge Base. The KnowledgeAgent provides more
    information on this.</p><div class="example"><a id="d0e984"/><p class="title"><b>Example 3.11. ChangeSet XML which adds a directory's contents</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/projects/myproject/myrules' type='DRL' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e989"/>3.2. Deploying</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e992"/>3.2.1. KnowledgePackage and Knowledge Definitions</h3></div></div></div><p>A Knowledge Package is a collection of Knowledge Definitions, such
    as rules and processes. It is created by the Knowledge Builder, as
    described in the chapter "Building". Knowledge Packages are self-contained and
    serializable, and they currently form the basic deployment unit.</p><div class="figure"><a id="d0e997"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgePackage.png" alt="KnowledgePackage"/></div></div><p class="title"><b>Figure 3.4. KnowledgePackage</b></p></div><br class="figure-break"/><p>Knowledge Packages are added to the Knowledge Base. However, a
    Knowledge Package instance cannot be reused once it's added to the
    Knowledge Base. If you need to add it to another Knowledge Base, try
    serializing it first and using the "cloned" result. We hope to fix this
    limitation in future versions of Drools.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1005"/>3.2.2. KnowledgeBase</h3></div></div></div><p>The Knowlege Base is a repository of all the application's knowledge
    definitions. It may contain rules, processes, functions, and type models.
    The Knowledge Base itself does not contain instance data, known as facts;
    instead, sessions are created from the Knowledge Base into which data can be
    inserted and where process instances may be started. Creating the
    Knowlege Base can be
    heavy, whereas session creation is very light, so it is recommended that
    Knowledge Bases be cached where possible to allow for repeated session
    creation.</p><div class="figure"><a id="d0e1010"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeBase.png" width="100%" alt="KnowledgeBase"/></td></tr></table></div></div><p class="title"><b>Figure 3.5. KnowledgeBase</b></p></div><br class="figure-break"/><p>A <code class="code">KnowledgeBase</code> object is also serializable, and some people
    may prefer to build and then store a <code class="code">KnowledgeBase</code>, treating it also 
    as a unit of deployment, instead of the Knowledge Packages.</p><p>The KnowlegeBase is created using the KnowledgeBaseFactory.</p><div class="figure"><a id="d0e1026"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeBaseFactory.png" width="100%" alt="KnowledgeBaseFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.6. KnowledgeBaseFactory</b></p></div><br class="figure-break"/><p>A KnowledgeBase can be created using the default
    configuration.</p><div class="example"><a id="d0e1034"/><p class="title"><b>Example 3.12. Creating a new KnowledgeBase</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();</pre></div></div><br class="example-break"/><p>If a custom class loader was used with the <code class="code">KnowledgeBuilder</code> to
    resolve types not in the default class loader, then that must also be set
    on the <code class="code">KnowledgeBase</code>. The technique for this is the same as with the
    <code class="code">KnowledgeBuilder</code>.</p><div class="example"><a id="d0e1050"/><p class="title"><b>Example 3.13. Creating a new KnowledgeBase with a custom ClassLoader</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration kbaseConf =
    KnowledgeBaseFactory.createKnowledgeBaseConfiguration( null, cl );
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1055"/>3.2.3. In-Process Building and Deployment</h3></div></div></div><p>This is the simplest form of deployment. It compiles the
    knowledge definitions and adds them to the Knowledge Base in the same JVM.
    This approach requires drools-core.jar and drools-compiler.jar to be on
    the classpath.</p><div class="example"><a id="d0e1060"/><p class="title"><b>Example 3.14. Add KnowledgePackages to a KnowledgeBase</b></p><div class="example-contents"><pre class="programlisting">Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kpkgs );</pre></div></div><br class="example-break"/><p>Note that the <code class="code">addKnowledgePackages(kpkgs)</code> method can be called
    iteratively to add additional knowledge.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1070"/>3.2.4. Building and Deployment in Separate Processes</h3></div></div></div><p>Both the <code class="code">KnowledgeBase</code> and the <code class="code">KnowledgePackage</code>
    are units of
    deployment and serializable. This means you can have one machine do any
    necessary building, requiring <code class="filename">drools-compiler.jar</code>, and
    have another machine deploy and execute everything, needing only
    <code class="filename">drools-core.jar</code>.</p><p>Although serialization is standard Java, we present an example of
    how one  machine might write out the deployment unit and how another 
    machine might read in and use that deployment unit.</p><div class="example"><a id="d0e1089"/><p class="title"><b>Example 3.15. Writing the KnowledgePackage to an OutputStream</b></p><div class="example-contents"><pre class="programlisting">ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream( fileName ) );
out.writeObject( kpkgs );
out.close();
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e1094"/><p class="title"><b>Example 3.16. Reading the KnowledgePackage from an InputStream</b></p><div class="example-contents"><pre class="programlisting">ObjectInputStream in = new ObjectInputStream( new FileInputStream( fileName ) );
// The input stream might contain an individual
// package or a collection.
@SuppressWarnings( "unchecked" )
Collection&lt;KnowledgePackage&gt; kpkgs =
    ()in.readObject( Collection&lt;KnowledgePackage&gt; );
in.close();

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kpkgs );
</pre></div></div><br class="example-break"/><p>The <code class="code">KnowledgeBase</code> is also serializable and some people may prefer
      to build and then store the <code class="code">KnowledgeBase</code> itself, instead of the
      Knowledge Packages.</p><p>Drools Guvnor, our server side management system, uses this
      deployment approach. After Guvnor has compiled and published serialized
      Knowledge Packages on a URL, Drools can use the URL resource type
      to load them.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1109"/>3.2.5. StatefulknowledgeSessions and KnowledgeBase Modifications</h3></div></div></div><p>Stateful Knowledge Sessions will be discussed in more detail in
    section "Running". The <code class="code">KnowledgeBase</code> creates and returns
    <code class="code">StatefulKnowledgeSession</code> objects, and it may optionally
    keep references to those.
    When <code class="code">KnowledgeBase</code> modifications occur those modifications are applied
    against the data in the sessions. This reference is a weak reference and it
    is also optional, which is controlled by a boolean flag.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1123"/>3.2.6. KnowledgeAgent</h3></div></div></div><p>The <code class="code">KnowlegeAgent</code> provides automatic loading, caching and
    re-loading of resources and is configured from a properties files. The
    Knowledge Agent can update or rebuild this Knowlege Base as the
    resources it uses are changed. The strategy for this is determined by the configuration
    given to the factory, but it is typically pull-based using regular
    polling. We hope to add push-based updates and rebuilds in future
    versions. The Knowledge Agent will continuously scan all the added
    resources, using a default polling interval of 60 seconds. If their 
    date of the last modification is updated it will rebuild the cached
    Knowledge Base using the new resources.</p><div class="figure"><a id="d0e1131"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeAgent.png" width="100%" alt="KnowledgeAgent"/></td></tr></table></div></div><p class="title"><b>Figure 3.7. KnowledgeAgent</b></p></div><br class="figure-break"/><p>The <code class="code">KnowlegeBuilder</code> is created using a
    <code class="code">KnowledgeBuilderFactory</code> object.
    The agent must specify a name, which is used in the log files to associate
    a log entry with the corresponding agent.</p><div class="example"><a id="d0e1145"/><p class="title"><b>Example 3.17. Creating the KnowledgeAgent</b></p><div class="example-contents"><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
</pre></div></div><br class="example-break"/><div class="figure"><a id="d0e1150"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeAgentFactory.png" width="100%" alt="KnowledgeAgentFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.8. KnowledgeAgentFactory</b></p></div><br class="figure-break"/><p>The following example constructs an agent that will build a new
    KnowledgeBase from the specified ChangeSet. (See section "Building" for
    more details on the ChangeSet format.) Note that the method can be called
    iteratively to add new resources over time. At the moment the remove and
    modify elements of the ChangeSet XML are not implemented, but future
    versions will provide this as well, giving you more control over those
    incremental changes.
    The Knowledge Agent polls the resources added from the ChangeSet 
    every 60 seconds, the default interval, to see if they are updated.
    Whenever changes are found it will construct a new Knowledge Base.
    If the change set specifies a resource that
    is a directory its contents will be scanned for changes, too.</p><div class="example"><a id="d0e1158"/><p class="title"><b>Example 3.18. Writing the KnowledgePackage to an OutputStream</b></p><div class="example-contents"><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
kagent.applyChangeSet( ResourceFactory.newUrlResource( url ) );
KnowledgeBase kbase = kagent.getKnowledgeBase();
</pre></div></div><br class="example-break"/><p>Resource scanning is not on by default, it's a service and must be
    started, and the same is true for notification. Both can be done via the
    ResourceFactory.</p><div class="example"><a id="d0e1165"/><p class="title"><b>Example 3.19. Starting the Scanning and Notification Services</b></p><div class="example-contents"><pre class="programlisting">ResourceFactory.getResourceChangeNotifierService().start();
ResourceFactory.getResourceChangeScannerService().start();
</pre></div></div><br class="example-break"/><p>The default resource scanning period may be changed via the
    <code class="code">ResourceChangeScannerService</code>. A suitably updated 
    <code class="code">ResourceChangeScannerConfiguration</code> object is passed to the service's
    <code class="code">configure()</code> method, which allows for the service to be reconfigured on
    demand.</p><div class="example"><a id="d0e1181"/><p class="title"><b>Example 3.20. Changing the Scanning Intervals</b></p><div class="example-contents"><pre class="programlisting">ResourceChangeScannerConfiguration sconf =
    ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();
// Set the disk scanning interval to 30s, default is 60s.
sconf.setProperty( "drools.resource.scanner.interval", "30" ); 
ResourceFactory.getResourceChangeScannerService().configure( sconf );
</pre></div></div><br class="example-break"/><p>Knowledge Agents can take an empty Knowledge Base or a populated one.
    If a populated Knowledge Base is provided, the Knowledge Agent will
    run an iterator from Knowledge Base and subscribe to the resources that
    it finds. While it is
    possible for the Knowledge Builder to build all resources found in a
    directory, that information is lost by the Knowledge Builder so that those
    directories will not be continuously scanned. Only directories specified
    as part of the <code class="code">applyChangeSet(Resource)</code> method are monitored.</p><p>One of the advantages of providing <code class="code">KnowledgeBase</code> as the starting
    point is that you can provide it with a <code class="code">KnowledgeBaseConfiguration</code>. When
    resource changes are detected and a new <code class="code">KnowledgeBase</code> object is
    instantiated, it will use the <code class="code">KnowledgeBaseConfiguration</code> of the previous
    <code class="code">KnowledgeBase</code> object.</p><div class="example"><a id="d0e1208"/><p class="title"><b>Example 3.21. Using an existing KnowledgeBase</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration kbaseConf =
    KnowledgeBaseFactory.createKnowledgeBaseConfiguration( null, cl );
KnowledgeBase kbase KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );
// Populate kbase with resources here.

KnowledgeAgent kagent =
    KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent", kbase );
KnowledgeBase kbase = kagent.getKnowledgeBase();
</pre></div></div><br class="example-break"/><p>In the above example <code class="code">getKnowledgeBase()</code> will return the same
    provided kbase instance until resource changes are detected and a new
    Knowledge Base is built. When the new Knowledge Base is built, it will be
    done with the <code class="code">KnowledgeBaseConfiguration</code> that was provided to 
    the previous <code class="code">KnowledgeBase</code>.</p><p>As mentioned previously, a ChangeSet XML can specify a directory and
    all of its contents will be added. If this ChangeSet XML is used with the
    <code class="code">applyChangeSet()</code> method it will also add any directories to the scanning
    process. When the directory scan detects an additional file, it will be 
    added to the Knowledge Base; any removed file is removed from the
    Knowledge Base, and modified files will, as usual, force the build of a
    new Knowledge Base using the latest version.</p><div class="example"><a id="d0e1229"/><p class="title"><b>Example 3.22. ChangeSet XML which adds a directories contents</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/projects/myproject/myrules' type='PKG' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"/><p>Note that for the resource type PKG the drools-compiler dependency is
    not needed as the Knowledge Agent is able to handle those with just
    drools-core.</p><p>The <code class="code">KnowledgeAgentConfiguration</code> can be used to modify a
    Knowledge Agent's default behavior. You could use this to load
    the resources from a directory, while inhibiting the continuous scan
    for changes of that directory.</p><div class="example"><a id="d0e1241"/><p class="title"><b>Example 3.23. Change the Scanning Behavior</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();

KnowledgeAgentConfiguration kaconf =
    KnowledgeAgentFactory.newKnowledgeAgentConfiguation();
// Do not scan directories, just files.
kaconf.setProperty( "drools.agent.scanDirectories", "false" );
KnowledgeAgent kagent =
    KnowledgeAgentFactory.newKnowledgeAgent( "test agent", kaconf );
</pre></div></div><br class="example-break"/><p>Previously we mentioned Drools Guvnor and how it can build and
    publish serialized Knowledge Packages on a URL, and that the
    ChangeSet XML can handle URLs and Packages. Taken together, this forms
    an importanty deployment scenario for the Knowledge Agent.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1248"/>3.3. Running</h2></div></div></div><p/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1252"/>3.3.1. KnowledgeBase</h3></div></div></div><p>The <code class="code">KnowlegeBase</code> is a repository of all the
    application's knowledge definitions. It will contain rules, processes,
    functions, and type models. The Knowledge Base itself does not contain
    data; instead, sessions are created from the <code class="code">KnowledgeBase</code>
    into which data can be inserted and from which process instances may be
    started. Creating the <code class="code">KnowlegeBase</code> can be heavy, whereas
    session creation is very light, so it is recommended that Knowle Bases be
    cached where possible to allow for repeated session creation.</p><div class="example"><a id="d0e1266"/><p class="title"><b>Example 3.24. Creating a new KnowledgeBase</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1271"/>3.3.2. StatefulKnowledgeSession</h3></div></div></div><p>The <code class="code">StatefulKnowledgeSession</code> stores and executes on the
    runtime data. It is created from the <code class="code">KnowledgeBase</code>.</p><div class="figure"><a id="d0e1282"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/StatefulKnowledgeSession.png" width="100%" alt="StatefulKnowledgeSession"/></td></tr></table></div></div><p class="title"><b>Figure 3.9. StatefulKnowledgeSession</b></p></div><br class="figure-break"/><div class="example"><a id="d0e1288"/><p class="title"><b>Example 3.25. Create a StatefulKnowledgeSession from a KnowledgeBase</b></p><div class="example-contents"><pre class="programlisting">StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1293"/>3.3.3. KnowledgeRuntime</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1296"/>3.3.3.1. WorkingMemoryEntryPoint</h4></div></div></div><p>The <code class="code">WorkingMemoryEntryPoint</code> provides the methods
      around inserting, updating and retrieving facts. The term "entry point"
      is related to the fact that we have multiple partitions in a Working
      Memory and you can choose which one you are inserting into, although
      this use case is aimed at event processing and covered in more detail in
      the Fusion manual. Most rule based applications will work with the
      default entry point alone.</p><p>The <code class="code">KnowledgeRuntime</code> interface provides the main
      interaction with the engine. It is available in rule consequences and
      process actions. In this manual the focus is on the methods and
      interfaces related to rules, and the methods pertaining to processes
      will be ignored for now. But you'll notice that the
      <code class="code">KnowledgeRuntime</code> inherits methods from both the
      <code class="code">WorkingMemory</code> and the <code class="code">ProcessRuntime</code>, thereby
      providing a unified API to work with processes and rules. When working
      with rules, three interfaces form the <code class="code">KnowledgeRuntime</code>:
      <code class="code">WorkingMemoryEntryPoint</code>, <code class="code">WorkingMemory</code> and the
      <code class="code">KnowledgeRuntime</code> itself.</p><div class="figure"><a id="d0e1330"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/WorkingMemoryEntryPoint.png" alt="WorkingMemoryEntryPoint"/></div></div><p class="title"><b>Figure 3.10. WorkingMemoryEntryPoint</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1336"/>3.3.3.1.1. Insertion</h5></div></div></div><p>Insertion is the act of telling the <code class="code">WorkingMemory</code>
        about a fact, which you do by
        <code class="code">ksession.insert(yourObject)</code>, for example. When you insert
        a fact, it is examined for matches against the rules. This means
        <span class="emphasis"><em>all</em></span> of the work for deciding about firing or not
        firing a rule is done during insertion; no rule, however, is executed
        until you call <code class="code">fireAllRules()</code>, which you call after you
        have finished inserting your facts. It is a common misunderstanding
        for people to think the condition evaluation happens when you call
        <code class="code">fireAllRules()</code>. Expert systems typically use the term
        <span class="emphasis"><em>assert</em></span> or <span class="emphasis"><em>assertion</em></span> to refer
        to facts made available to the system. However, due to "assert" being
        a keyword in most languages, we have decided to use the
        <strong class="kw"><code>insert</code></strong> keyword; so expect to hear the two used
        interchangeably.</p><p>When an Object is inserted it returns a <code class="code">FactHandle</code>.
        This <code class="code">FactHandle</code> is the token used to represent your
        inserted object within the <code class="code">WorkingMemory</code>. It is also used
        for interactions with the <code class="code">WorkingMemory</code> when you wish to
        retract or modify an object.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );      </pre><p>As mentioned in the Knowledge Base section, a Working Memory may
        operate in two assertion modes, i.e., equality or identity, with
        identity being the default.</p><p><span class="emphasis"><em>Identity</em></span> means that the Working Memory uses
        an <code class="code">IdentityHashMap</code> to store all asserted objects. New
        instance assertions always result in the return of a new
        <code class="code">FactHandle</code>, but if an instance is asserted again then it
        returns the original fact handle, i.e., it ignores repeated insertions
        for the same fact.</p><p><span class="emphasis"><em>Equality</em></span> means that the Working Memory uses
        a <code class="code">HashMap</code> to store all asserted Objects. New instance
        assertions will only return a new <code class="code">FactHandle</code> if no equal
        objects have been asserted.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1404"/>3.3.3.1.2. Retraction</h5></div></div></div><p>Retraction is the removal of a fact from Working Memory, which
        means that it will no longer track and match that fact, and any rules
        that are activated and dependent on that fact will be cancelled. Note
        that it is possible to have rules that depend on the nonexistence of a
        fact, in which case retracting a fact may cause a rule to activate.
        (See the <code class="code">not</code> and <code class="code">exist</code> keywords.) Retraction
        is done using the <code class="code">FactHandle</code> that was returned by the
        insert call.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );
....
ksession.retract( stiltonHandle );            </pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1420"/>3.3.3.1.3. Update</h5></div></div></div><p>The Rule Engine must be notified of modified facts, so that they
        can be reprocessed. Internally, modification is actually a retract
        followed by an insert; the Rule Engine removes the fact from the
        <code class="code">WorkingMemory</code> and inserts it again. You must use the
        <code class="code">update()</code> method to notify the <code class="code">WorkingMemory</code>
        of changed objects for those objects that are not able to notify the
        <code class="code">WorkingMemory</code> themselves. Notice that
        <code class="code">update()</code> always takes the modified object as a second
        parameter, which allows you to specify new instances for immutable
        objects. The <code class="code">update()</code> method can only be used with
        objects that have shadow proxies turned on. The update method is only
        available within Java code. On the right hand side of a rule, also the
        <strong class="kw"><code>modify</code></strong> statement is supported, providing simplified calls to
        the object's setters.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1448"/>3.3.3.2. WorkingMemory</h4></div></div></div><p>The WorkingMemory provides access to the Agenda, permits query
      executions, and lets you access named Enty Points.</p><div class="figure"><a id="d0e1453"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/WorkingMemory.png" width="100%" alt="WorkingMemory"/></td></tr></table></div></div><p class="title"><b>Figure 3.11. WorkingMemory</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1459"/>3.3.3.2.1. Query</h5></div></div></div><p>Queries are used to retrieve fact sets based on patterns, as
        they are used in rules. Patterns may make use of optional parameters.
        Queries can be defined in the Knowlege Base, from where they are
        called up to return the matching results. While iterating over the
        result collection, any bound identifier in the query can be accessed
        using the get(String identifier) method and any FactHandle for that
        identifier can be retrieved using getFactHandle(String
        identifier).</p><div class="figure"><a id="d0e1464"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/QueryResults.png" alt="QueryResults"/></div></div><p class="title"><b>Figure 3.12. QueryResults</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e1470"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/QueryResultsRow.png" alt="QueryResultsRow"/></div></div><p class="title"><b>Figure 3.13. QueryResultsRow</b></p></div><br class="figure-break"/><div class="example"><a id="d0e1476"/><p class="title"><b>Example 3.26. Simple Query Example</b></p><div class="example-contents"><pre class="programlisting">QueryResults results =
    ksession.getQueryResults( "my query", new Object[] { "string" } );
for ( QueryResultsRow row : results ) {
    System.out.println( row.get( "varName" ) );
}</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1481"/>3.3.3.3. KnowledgeRuntime</h4></div></div></div><p>The <code class="code">KnowledgeRuntime</code> provides further methods that
      are applicable to both rules and processes, such as setting globals and
      registering <code class="code">ExitPoints</code>.</p><div class="figure"><a id="d0e1492"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntime.png" alt="KnowledgeRuntime"/></div></div><p class="title"><b>Figure 3.14. KnowledgeRuntime</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1498"/>3.3.3.3.1. Globals</h5></div></div></div><p>Globals are named objects that can be passed to the rule engine,
        without needing to insert them. Most often these are used for static
        information, or for services that are used in the RHS of a rule, or
        perhaps as a means to return objects from the rule engine. If you use
        a global on the LHS of a rule, make sure it is immutable. A global
        must first be declared in a rules file before it can be set on the
        session.</p><pre class="programlisting">global java.util.List list</pre><p>With the Knowledge Base now aware of the global identifier and
        its type, it is now possible to call <code class="code">ksession.setGlobal()</code>
        for any session. Failure to declare the global type and identifier
        first will result in an exception being thrown. To set the global on
        the session use <code class="code">ksession.setGlobal(identifier,
        value)</code>:</p><pre class="programlisting">List list = new ArrayList();
ksession.setGlobal("list", list);           </pre><p>If a rule evaluates on a global before you set it you will get a
        <code class="code">NullPointerException</code>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1520"/>3.3.3.4. StatefulRuleSession</h4></div></div></div><p>The <code class="code">StatefulRuleSession</code> is inherited by the
      <code class="code">StatefulKnowledgeSession</code> and provides the rule related
      methods that are relevant from outside of the engine.</p><div class="figure"><a id="d0e1531"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/StatefulRuleSession.png" alt="StatefulRuleSession"/></div></div><p class="title"><b>Figure 3.15. StatefulRuleSession</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1537"/>3.3.3.4.1. Agenda Filters</h5></div></div></div><div class="figure"><a id="d0e1540"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-User_Guide/AgendaFilter.png" align="middle" alt="AgendaFilters"/></div></div><p class="title"><b>Figure 3.16. AgendaFilters</b></p></div><br class="figure-break"/><p><code class="code">AgendaFilter</code> objects are optional implementations
        of the filter interface which are used to allow or deny the firing of
        an activation. What you filter on is entirely up to the
        implementation. Drools 4.0 used to supply some out of the box filters,
        which have not be exposed in drools 5.0 drools-api, but they are
        simple to implement and the Drools 4.0 code base can be referred
        to.</p><p>To use a filter specify it while calling
        <code class="code">fireAllRules()</code>. The following example permits only rules
        ending in the string <code class="code">"Test"</code>. All others will be filtered
        out. </p><pre class="programlisting">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1560"/>3.3.4. Agenda</h3></div></div></div><p>The Agenda is a <span class="emphasis"><em>Rete</em></span> feature. During actions on
    the <code class="code">WorkingMemory</code>, rules may become fully matched and
    eligible for execution; a single Working Memory Action can result in
    multiple eligible rules. When a rule is fully matched an Activation is
    created, referencing the rule and the matched facts, and placed onto the
    Agenda. The Agenda controls the execution order of these Activations using
    a Conflict Resolution strategy.</p><p>The engine cycles repeatedly through two phases:</p><div class="orderedlist"><ol type="1"><li><p>Working Memory Actions. This is where most of the work takes
        place, either in the Consequence (the RHS itself) or the main Java
        application process. Once the Consequence has finished or the main
        Java application process calls <code class="code">fireAllRules()</code> the engine
        switches to the Agenda Evaluation phase.</p></li><li><p>Agenda Evaluation. This attempts to select a rule to fire. If no
        rule is found it exits, otherwise it fires the found rule, switching
        the phase back to Working Memory Actions.</p></li></ol></div><div class="figure"><a id="d0e1583"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-Rule_Engine/Two_Phase.png" align="middle" width="100%" alt="Two Phase Execution"/></td></tr></table></div></div><p class="title"><b>Figure 3.17. Two Phase Execution</b></p></div><br class="figure-break"/><p>The process repeats until the agenda is clear, in which case control
    returns to the calling application. When Working Memory Actions are taking
    place, no rules are being fired.</p><div class="figure"><a id="d0e1591"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/Agenda.png" alt="Agenda"/></div></div><p class="title"><b>Figure 3.18. Agenda</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1597"/>3.3.4.1. Conflict Resolution</h4></div></div></div><p>Conflict resolution is required when there are multiple rules on
      the agenda. (The basics to this are covered in chapter "Quick Start".)
      As firing a rule may have side effects on the working memory, the rule
      engine needs to know in what order the rules should fire (for instance,
      firing ruleA may cause ruleB to be removed from the agenda).</p><p>The default conflict resolution strategies employed by Drools are:
      Salience and LIFO (last in, first out).</p><p>The most visible one is <span class="emphasis"><em>salience</em></span> (or
      priority), in which case a user can specify that a certain rule has a
      higher priority (by giving it a higher number) than other rules. In that
      case, the rule with higher salience will be preferred. LIFO priorities
      are based on the assigned Working Memory Action counter value, with all
      rules created during the same action receiving the same value. The
      execution order of a set of firings with the same priority value is
      arbitrary.</p><p>As a general rule, it is a good idea not to count on rules firing
      in any particular order, and to author the rules without worrying about
      a "flow".</p><p>Drools 4.0 supported custom conflict resolution strategies; while
      this capability still exists in Drools it has not yet been exposed to
      the end user via drools-api in Drools 5.0.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1613"/>3.3.4.2. AgendaGroup</h4></div></div></div><div class="figure"><a id="d0e1616"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/AgendaGroup.png" alt="AgendaGroup"/></div></div><p class="title"><b>Figure 3.19. AgendaGroup</b></p></div><br class="figure-break"/><p>Agenda groups are a way to partition rules (activations, actually)
      on the agenda. At any one time, only one group has "focus" which means
      that activations for rules in that group only will take effect. You can
      also have rules with "auto focus" which means that the focus is taken
      for its agenda group when that rule's conditions are true.</p><p>Agenda groups are known as "modules" in CLIPS terminology. They
      provide a handy way to create a "flow" between grouped rules. You can
      switch the group which has focus either from within the rule engine, or
      via the API. If your rules have a clear need for multiple "phases" or
      "sequences" of processing, consider using agenda-groups for this
      purpose.</p><p>Each time <code class="code">setFocus()</code> is called it pushes that Agenda
      Group onto a stack. When the focus group is empty it is popped from the
      stack and the focus group that is now on top evaluates. An Agenda Group
      can appear in multiple locations on the stack. The default Agenda Group
      is "MAIN", with all rules which do not specify an Agenda Group being in
      this group. It is also always the first group on the stack, given focus
      initially, by default.</p><pre class="programlisting">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1634"/>3.3.4.3. ActivationGroup</h4></div></div></div><div class="figure"><a id="d0e1637"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ActivationGroup.png" alt="ActivationGroup"/></div></div><p class="title"><b>Figure 3.20. ActivationGroup</b></p></div><br class="figure-break"/><p>An activation group is a set of rules bound together by the same
      "activation-group" rule attribute. In this group only one rule can fire,
      and after that rule has fired all the other rules are cancelled from the
      agenda. The <code class="code">clear()</code> method can be called at any time, which
      cancels all of the activations before one has had a chance to fire.
      </p><pre class="programlisting">ksession.getAgenda().getActivationGroup( "Group B" ).clear();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1650"/>3.3.4.4. RuleFlowGroup</h4></div></div></div><div class="figure"><a id="d0e1653"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/RuleFlowGroup.png" alt="RuleFlowGroup"/></div></div><p class="title"><b>Figure 3.21. RuleFlowGroup</b></p></div><br class="figure-break"/><p>A rule flow group is a group of rules associated by the
      "ruleflow-group" rule attribute. These rules can only fire when the
      group is activate. The group itself can only become active when the
      elaboration of the ruleflow diagram reaches the node representing the
      group. Here too, the <code class="code">clear()</code> method can be called at any
      time to cancels all activations still remaining on the Agenda.
      </p><pre class="programlisting">ksession.getAgenda().getRuleFlowGroup( "Group C" ).clear();</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1666"/>3.3.5. Event Model</h3></div></div></div><p>The event package provides means to be notified of rule engine
    events, including rules firing, objects being asserted, etc. This allows
    you, for instance, to separate logging and auditing activities from the
    main part of your application (and the rules).</p><p>The <code class="code">KnowlegeRuntimeEventManager</code> interface is
    implemented by the <code class="code">KnowledgeRuntime</code> which provides two
    interfaces, <code class="code">WorkingMemoryEventManager</code> and
    <code class="code">ProcessEventManager</code>. We will only cover the
    <code class="code">WorkingMemoryEventManager</code> here.</p><div class="figure"><a id="d0e1688"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntimeEventManager.png" alt="KnowledgeRuntimeEventManager"/></div></div><p class="title"><b>Figure 3.22. KnowledgeRuntimeEventManager</b></p></div><br class="figure-break"/><p>The <code class="code">WorkingMemoryEventManager</code> allows for listeners to
    be added and removed, so that events for the working memory and the agenda
    can be listened to.</p><div class="figure"><a id="d0e1699"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/WorkingMemoryEventManager.png" width="100%" alt="WorkingMemoryEventManager"/></td></tr></table></div></div><p class="title"><b>Figure 3.23. WorkingMemoryEventManager</b></p></div><br class="figure-break"/><p>The following code snippet shows how a simple agenda listener is
    declared and attached to a session. It will print activations after they
    have fired.</p><div class="example"><a id="d0e1707"/><p class="title"><b>Example 3.27. Adding an AgendaEventListener</b></p><div class="example-contents"><pre class="programlisting">ksession.addEventListener( new DefaultAgendaEventListener() {                            
   public void afterActivationFired(AfterActivationFiredEvent event) {
       super.afterActivationFired( event );
       System.out.println( event );
   }
});     </pre></div></div><br class="example-break"/><p>Drools also provides <code class="code">DebugWorkingMemoryEventListener</code>
    and <code class="code">DebugAgendaEventListener</code> which implement each method with
    a debug print statement. To print all Working Memory events, you add a
    listener like this:</p><div class="example"><a id="d0e1720"/><p class="title"><b>Example 3.28. Creating a new KnowledgeBuilder</b></p><div class="example-contents"><pre class="programlisting">ksession.addEventListener( new DebugWorkingMemoryEventListener() );     </pre></div></div><br class="example-break"/><p>All emitted events implement the <code class="code">KnowlegeRuntimeEvent</code>
    interface which can be used to retrieve the actual
    <code class="code">KnowlegeRuntime</code> the event originated from.</p><div class="figure"><a id="d0e1733"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntimeEvent.png" alt="KnowlegeRuntimeEvent"/></div></div><p class="title"><b>Figure 3.24. KnowlegeRuntimeEvent</b></p></div><br class="figure-break"/><p>The events currently supported are:</p><div class="itemizedlist"><ul><li><p>ActivationCreatedEvent</p></li><li><p>ActivationCancelledEvent</p></li><li><p>BeforeActivationFiredEvent</p></li><li><p>AfterActivationFiredEvent</p></li><li><p>AgendaGroupPushedEvent</p></li><li><p>AgendaGroupPoppedEvent</p></li><li><p>ObjectInsertEvent</p></li><li><p>ObjectRetractedEvent</p></li><li><p>ObjectUpdatedEvent</p></li><li><p>ProcessCompletedEvent</p></li><li><p>ProcessNodeLeftEvent</p></li><li><p>ProcessNodeTriggeredEvent</p></li><li><p>ProcessStartEvent</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1781"/>3.3.6. KnowledgeRuntimeLogger</h3></div></div></div><p>The KnowledgeRuntimeLogger uses the comprehensive event system in
    Drools to create an audit log that can be used to log the execution of an
    application for later inspection, using tools such as the Eclipse audit
    viewer.</p><div class="figure"><a id="d0e1786"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/KnowledgeRuntimeLoggerFactory.png" width="100%" alt="KnowledgeRuntimeLoggerFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.25. KnowledgeRuntimeLoggerFactory</b></p></div><br class="figure-break"/><div class="example"><a id="d0e1792"/><p class="title"><b>Example 3.29. FileLogger</b></p><div class="example-contents"><pre class="programlisting">KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "logdir/mylogfile");
...
logger.close();</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1797"/>3.3.7. StatelessKnowledgeSession</h3></div></div></div><p>The <code class="code">StatelessKnowledgeSession</code> wraps the
    <code class="code">StatefulKnowledgeSession</code>, instead of extending it. Its main
    focus is on decision service type scenarios. It avoids the need to call
    <code class="code">dispose()</code>. Stateless sessions do not support iterative
    insertions and the method call <code class="code">fireAllRules()</code> from Java code;
    the act of calling <code class="code">execute()</code> is a single-shot method that
    will internally instantiate a <code class="code">StatefulKnowledgeSession</code>, add
    all the user data and execute user commands, call
    <code class="code">fireAllRules()</code>, and then call <code class="code">dispose()</code>. While
    the main way to work with this class is via the
    <code class="code">BatchExecution</code> (a subinterface of <code class="code">Command</code>) as
    supported by the <code class="code">CommandExecutor</code> interface, two convenience
    methods are provided for when simple object insertion is all that's
    required. The <code class="code">CommandExecutor</code> and <code class="code">BatchExecution</code>
    are talked about in detail in their own section.</p><div class="figure"><a id="d0e1841"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/StatelessKnowledgeSession.png" width="100%" alt="StatelessKnowledgeSession"/></td></tr></table></div></div><p class="title"><b>Figure 3.26. StatelessKnowledgeSession</b></p></div><br class="figure-break"/><p>Our simple example shows a stateless session executing a given
    collection of Java objects using the convenience API. It will iterate the
    collection, inserting each element in turn.</p><div class="example"><a id="d0e1849"/><p class="title"><b>Example 3.30. Simple StatelessKnowledgeSession execution with a
      Collection</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newFileSystemResource( fileName ), ResourceType.DRL );
if (kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
} else {
    KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
    kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
    StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
    ksession.execute( collection );
}</pre></div></div><br class="example-break"/><p>If this was done as a single Command it would be as follows:</p><div class="example"><a id="d0e1856"/><p class="title"><b>Example 3.31. Simple StatelessKnowledgeSession execution with InsertElements
      Command</b></p><div class="example-contents"><pre class="programlisting">ksession.execute( CommandFactory.newInsertElements( collection ) );  </pre></div></div><br class="example-break"/><p>If you wanted to insert the collection itself, and the collection's
    individual elements, then
    <code class="code">CommandFactory.newInsert(collection)</code> would do the job.</p><p>Methods of the <code class="code">CommandFactory</code> create the supported
    commands, all of which can be marshalled using XStream and the
    <code class="code">BatchExecutionHelper</code>. <code class="code">BatchExecutionHelper</code>
    provides details on the XML format as well as how to use Drools Pipeline
    to automate the marshalling of <code class="code">BatchExecution</code> and
    <code class="code">ExecutionResults</code>.</p><p><code class="code">StatelessKnowledgeSession</code> supports globals, scoped in a
    number of ways. I'll cover the non-command way first, as commands are
    scoped to a specific execution call. Globals can be resolved in three
    ways.</p><div class="itemizedlist"><ul><li><p>The Stateless Knowledge Session method <code class="code">getGlobals()</code>
        returns a Globals instance which provides access to the session's
        globals. These are shared for <span class="emphasis"><em>all</em></span> execution
        calls. Exercise caution regarding mutable globals because execution
        calls can be executing simultaneously in different threads.</p><div class="example"><a id="d0e1897"/><p class="title"><b>Example 3.32. Session scoped global</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.  
ksession.execute( collection ); </pre></div></div><br class="example-break"/></li><li><p>Using a delegate is another way of global resolution. Assigning
        a value to a global (with <code class="code">setGlobal(String, Object)</code>)
        results in the value being stored in an internal collection mapping
        identifiers to values. Identifiers in this internal collection will
        have priority over any supplied delegate. Only if an identifier cannot
        be found in this internal collection, the delegate global (if any)
        will be used.</p></li><li><p>The third way of resolving globals is to have execution scoped
        globals. Here, a <code class="code">Command</code> to set a global is passed to the
        <code class="code">CommandExecutor</code>.</p></li></ul></div><p>The <code class="code">CommandExecutor</code> interface also offers the ability
    to export data via "out" parameters. Inserted facts, globals and query
    results can all be returned.</p><div class="example"><a id="d0e1922"/><p class="title"><b>Example 3.33. Out identifiers</b></p><div class="example-contents"><pre class="programlisting">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1927"/>3.3.7.1. Sequential Mode</h4></div></div></div><p>With Rete you have a stateful session where objects can be
      asserted and modified over time, and where rules can also be added and
      removed. Now what happens if we assume a stateless session, where after
      the initial data set no more data can be asserted or modified and rules
      cannot be added or removed? Certainly it won't be necessary to
      re-evaluate rules, and the engine will be able to operate in a
      simplified way.</p><div class="orderedlist"><ol type="1"><li><p>Order the Rules by salience and position in the ruleset (by
          setting a sequence attribute on the rule terminal node).</p></li><li><p>Create an array, one element for each possible rule
          activation; element position indicates firing order.</p></li><li><p>Turn off all node memories, except the right-input Object
          memory.</p></li><li><p>Disconnect the Left Input Adapter Node propagation, and let
          the Object plus the Node be referenced in a Command object, which is
          added to a list on the Working Memory for later execution.</p></li><li><p>Assert all objects, and, when all assertions are finished and
          thus right-input node memories are populated, check the Command list
          and execute each in turn.</p></li><li><p>All resulting Activations should be placed in the array, based
          upon the determined sequence number of the Rule. Record the first
          and last populated elements, to reduce the iteration range.</p></li><li><p>Iterate the array of Activations, executing populated element
          in turn.</p></li><li><p>If we have a maximum number of allowed rule executions, we can
          exit our network evaluations early to fire all the rules in the
          array.</p></li></ol></div><p>The <code class="code">LeftInputAdapterNode</code> no longer creates a Tuple,
      adding the Object, and then propagate the Tuple – instead a Command
      object is created and added to a list in the Working Memory. This
      Command object holds a reference to the
      <code class="code">LeftInputAdapterNode</code> and the propagated object. This stops
      any left-input propagations at insertion time, so that we know that a
      right-input propagation will never need to attempt a join with the
      left-inputs (removing the need for left-input memory). All nodes have
      their memory turned off, including the left-input Tuple memory but
      excluding the right-input object memory, which means that the only node
      remembering an insertion propagation is the right-input object memory.
      Once all the assertions are finished and all right-input memories
      populated, we can then iterate the list of
      <code class="code">LeftInputAdatperNode</code> Command objects calling each in turn.
      They will propagate down the network attempting to join with the
      right-input objects, but they won't be remembered in the left input as
      we know there will be no further object assertions and thus propagations
      into the right-input memory.</p><p>There is no longer an Agenda, with a priority queue to schedule
      the Tuples; instead, there is simply an array for the number of rules.
      The sequence number of the <code class="code">RuleTerminalNode</code> indicates the
      element within the array where to place the Activation. Once all Command
      objects have finished we can iterate our array, checking each element in
      turn, and firing the Activations if they exist. To improve performance,
      we remember the first and the last populated cell in the array. The
      network is constructed, with each <code class="code">RuleTerminalNode</code> being
      given a sequence number based on a salience number and its order of
      being added to the network.</p><p>Typically the right-input node memories are Hash Maps, for fast
      object retraction; here, as we know there will be no object retractions,
      we can use a list when the values of the object are not indexed. For
      larger numbers of objects indexed Hash Maps provide a performance
      increase; if we know an object type has only a few instances, indexing
      is probably not advantageous, and a list can be used.</p><p>Sequential mode can only be used with a Stateless Session and is
      off by default. To turn it on, either call
      <code class="code">RuleBaseConfiguration.setSequential(true)</code>, or set the
      rulebase configuration property <code class="code">drools.sequential</code> to true.
      Sequential mode can fall back to a dynamic agenda by calling
      <code class="code">setSequentialAgenda</code> with
      <code class="code">SequentialAgenda.DYNAMIC</code>. You may also set the
      "drools.sequential.agenda" property to "sequential" or "dynamic".</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1992"/>3.3.8. Pipeline</h3></div></div></div><p>The <code class="code">PipelineFactory</code> and associated classes are there to
    help with the automation of getting information into and out of Drools,
    especially when using services such as Java Message Service (JMS), and
    other data sources that aren't Java objects. Transformers for Smooks,
    JAXB, XStream and jXLS are povided. Smooks is an ETL (extract, transform,
    load) tool and can work with a variety of data sources. JAXB is a Java
    standard for XML binding capable of working with XML schemas. XStream is a
    simple and fast XML serialisation framework. jXLS finally allows for
    loading of Java objects from an Excel spreadsheet. Minimal information on
    these technologies will be provided here; beyond this, you should consult
    the relevant user guide for each of these tools.</p><div class="figure"><a id="d0e2000"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/PipelineFactory.png" width="100%" alt="PipelineFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.27. PipelineFactory</b></p></div><br class="figure-break"/><p>Pipeline is not meant as a replacement for products like the more
    powerful Apache Camel. It is a simple framework aimed at the specific
    Drools use cases.</p><p>In Drools, a pipeline is a series of stages that operate on and
    propagate a given payload. Typically this starts with a
    <code class="code">Pipeline</code> instance which is responsible for taking the
    payload, creating a <code class="code">PipelineContext</code> for it and propagating
    that to the first receiver stage. Two subtypes of <code class="code">Pipeline</code>
    are provided, both requiring a different <code class="code">PipelineContext</code>:
    <code class="code">StatefulKnowledgeSessionPipeline</code> and
    <code class="code">StatelessKnowledgeSessionPipeline</code>.
    <code class="code">PipelineFactory</code> provides methods to create both of the two
    <code class="code">Pipeline</code> subtypes. Notice that both factory methods take the
    relevant session as an argument. The construction of a
    <code class="code">StatefulKnowledgeSessionPipeline</code> is shown below, where also
    its receiver is set.</p><div class="example"><a id="d0e2037"/><p class="title"><b>Example 3.34. StatefulKnowledgeSessionPipeline</b></p><div class="example-contents"><pre class="programlisting">Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( receiver );</pre></div></div><br class="example-break"/><p>A pipeline is then made up of a chain of <code class="code">Stage</code>s that
    implement both the <code class="code">Emitter</code> and the <code class="code">Receiver</code>
    interfaces. The <code class="code">Emitter</code> interface enables the
    <code class="code">Stage</code> to propagate a payload, and the <code class="code">Receiver</code>
    interface lets it receive a payload. This is why the <code class="code">Pipeline</code>
    interface only implements <code class="code">Emitter</code> and <code class="code">Stage</code> and
    not <code class="code">Receiver</code>, as it is the first instance in the chain. The
    <code class="code">Stage</code> interface allows a custom exception handler to be set
    on the <code class="code">Stage</code> object.</p><div class="example"><a id="d0e2080"/><p class="title"><b>Example 3.35. StageExceptionHandler</b></p><div class="example-contents"><pre class="programlisting">Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setStageExceptionHandler( new StageExceptionHandler() { .... } );
</pre></div></div><br class="example-break"/><p>The <code class="code">Transformer</code> interface extends <code class="code">Stage</code>,
    <code class="code">Emitter</code> and <code class="code">Receiver</code>, providing those interface
    methods as a single type. Its other purpose is that of a marker interface
    indicating this particulare role of the implementing class. (We have
    several other marker interfaces such as <code class="code">Expression</code> and
    <code class="code">Action</code>, both of which also extend <code class="code">Stage</code>,
    <code class="code">Emitter</code> and <code class="code">Receiver</code>.) One of the stages should
    be responsible for setting a result value on the
    <code class="code">PipelineContext</code>. It's the responsibility of the
    <code class="code">ResultHandler</code> interface, to be implemented by the user, to
    process on these results. It may do so by inserting them into some
    suitable object, whence the user's code may retrieve them.</p><div class="example"><a id="d0e2120"/><p class="title"><b>Example 3.36. StageExceptionHandler</b></p><div class="example-contents"><pre class="programlisting">ResultHandler resultHandler = new ResultHandlerImpl();
pipeline.insert( factHandle, resultHandler );  
System.out.println( resultHandler );
...
public class ResultHandlerImpl implements ResultHandler {
    Object result;

    public void handleResult(Object result) {
        this.result = result;
    }

    public Object getResult() {
        return this.result;
    }
}
</pre></div></div><br class="example-break"/><p>While the above example shows a simple handler that merely assigns
    the result to a field that the user can access, it could do more complex
    work like sending the object as a message.</p><p>Pipeline provides an adapter to insert the payload and to create the
    correct Pipeline Context internally.</p><p>In general it is easier to construct the pipelines in reverse. In
    the following example XML data is loaded from disk, transformed with
    XStream and finally inserted into the session.</p><div class="example"><a id="d0e2131"/><p class="title"><b>Example 3.37. Constructing a pipeline</b></p><div class="example-contents"><pre class="programlisting">// Make the results (here: FactHandles) available to the user 
Action executeResultHandler = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session
// associated with the PipelineContext
KnowledgeRuntimeCommand insertStage =
  PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( executeResultHandler );
       
// Create the transformer instance and the Transformer Stage,
// to transform from Xml to a Java object.
XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setReceiver( insertStage );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( transformer );

// Instantiate a simple result handler and load and insert the XML
ResultHandlerImpl resultHandler = new ResultHandlerImpl();
pipeline.insert( ResourceFactory.newClassPathResource( "path/facts.xml", getClass() ),
                 resultHandler );
</pre></div></div><br class="example-break"/><p>While the above example is for loading a resource from disk, it is
    also possible to work from a running messaging service. Drools currently
    provides a single service for JMS, called <code class="code">JmsMessenger</code>.
    Support for other services will be added later. The code below shows part
    of a unit test which illustrates part of the <code class="code">JmsMessenger</code> in
    action:</p><div class="example"><a id="d0e2144"/><p class="title"><b>Example 3.38. Using JMS with Pipeline</b></p><div class="example-contents"><pre class="programlisting">// As this is a service, it's more likely that
// the results will be logged or sent as a return message.
Action resultHandlerStage = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session associated with the PipelineContext
KnowledgeRuntimeCommand insertStage = PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( resultHandlerStage );

// Create the transformer instance and create the Transformer stage where we are
// going from XML to Pojo. JAXB needs an array of the available classes.
JAXBContext jaxbCtx = KnowledgeBuilderHelper.newJAXBContext( classNames,
                                                              kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( insertStage );

// Payloads for JMS arrive in a Message wrapper: we need to unwrap this object.
Action unwrapObjectStage = PipelineFactory.newJmsUnwrapMessageObject();
unwrapObjectStage.setReceiver( transformer );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( unwrapObjectStage );

// Services, like JmsMessenger take a ResultHandlerFactory implementation.
// This is because a result handler must be created for each incoming message.
ResultHandlerFactory factory = new ResultHandlerFactoryImpl();
Service messenger = PipelineFactory.newJmsMessenger( pipeline,
                                                     props,
                                                     destinationName,
                                                     factory );
messenger.start();
</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2149"/>3.3.8.1. Xstream Transformer</h4></div></div></div><div class="example"><a id="d0e2153"/><p class="title"><b>Example 3.39. XStream FromXML transformer stage</b></p><div class="example-contents"><pre class="programlisting">XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setReceiver( nextStage );</pre></div></div><p><br class="example-break"/> </p><div class="example"><a id="d0e2159"/><p class="title"><b>Example 3.40. XStream ToXML transformer stage</b></p><div class="example-contents"><pre class="programlisting">XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamToXmlTransformer( xstream );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2164"/>3.3.8.2. JAXB Transformer</h4></div></div></div><p>The Transformer objects are <code class="code">JaxbFromXmlTransformer</code>
      and <code class="code">JaxbToXmlTransformer</code>. The former uses an
      <code class="code">javax.xml.bind.Unmarshaller</code> for converting an XML document
      into a content tree; the latter serializes a content tree to XML by
      passing it to a <code class="code">javax.xml.bind.Marshaller</code>. Both of these
      objects can be obtained from a <code class="code">JAXBContext</code> object.</p><p>A JAXBContext maintains the set of Java classes that are bound to
      XML elements. Such classes may be generated from an XML schema, by
      compiling it with JAXB's schema compiler <span class="command"><strong>xjc</strong></span>.
      Alternatively, handwritten classes can be augmented with annotations
      from <code class="code">jaxb.xml.bind.annotation</code>.</p><p>Unmarshalling an XML document results in an object tree. Inserting
      objects from this tree as facts into a session can be done by walking
      the tree and inserting nodes as appropriate. This could be done in the
      context of a pipeline by a custom Transformer that emits the nodes one
      by one to its receiver.</p><div class="example"><a id="d0e2195"/><p class="title"><b>Example 3.41. JAXB XSD Generation into the KnowlegeBuilder</b></p><div class="example-contents"><pre class="programlisting">Options xjcOpts = new Options();
xjcOpts.setSchemaLanguage( Language.XMLSCHEMA );
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
 
String[] classNames =
  KnowledgeBuilderHelper.addXsdModel(
    ResourceFactory.newClassPathResource( "order.xsd", getClass() ),
    kbuilder,
    xjcOpts,
    "xsd" );</pre></div></div><p><br class="example-break"/> </p><div class="example"><a id="d0e2201"/><p class="title"><b>Example 3.42. JAXB From XML transformer stage</b></p><div class="example-contents"><pre class="programlisting">JAXBContext jaxbCtx =
  KnowledgeBuilderHelper.newJAXBContext( classNames, kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( receiver );
 </pre></div></div><p><br class="example-break"/> </p><div class="example"><a id="d0e2207"/><p class="title"><b>Example 3.43. JAXB to XML transformer stage</b></p><div class="example-contents"><pre class="programlisting">Marshaller marshaller = jaxbCtx.createMarshaller();
Transformer transformer = PipelineFactory.newJaxbToXmlTransformer( marshaller );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2212"/>3.3.8.3. Smooks Transformer</h4></div></div></div><div class="example"><a id="d0e2216"/><p class="title"><b>Example 3.44. Smooks FromSource transformer stage</b></p><div class="example-contents"><pre class="programlisting">Smooks smooks = new Smooks( getClass().getResourceAsStream( "smooks-config.xml" ) );
Transformer transformer =
  PipelineFactory.newSmooksFromSourceTransformer( smooks, "orderItem" );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"/> </p><div class="example"><a id="d0e2222"/><p class="title"><b>Example 3.45. Smooks ToSource transformer stage</b></p><div class="example-contents"><pre class="programlisting">Smooks smooks = new Smooks( getClass().getResourceAsStream( "smooks-config.xml" ) );
Transformer transformer = PipelineFactory.newSmooksToSourceTransformer( smooks );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2227"/>3.3.8.4. jXLS (Excel/Calc/CSV) Transformer</h4></div></div></div><p>This transformer transforms from an Excel spreadsheet to a map of
      Java objects, using jXLS, and the resulting map is set as the
      propagating object. You may need to use splitters and MVEL expressions
      to split up the transformation to insert individual Java objects. Note
      that you must provde an XLSReader, which references the mapping file and
      also an MVEL string which will instantiate the map. The MVEL expression
      is pre-compiled but executed on each usage of the transformation.</p><div class="example"><a id="d0e2232"/><p class="title"><b>Example 3.46. JXLS transformer stage</b></p><div class="example-contents"><pre class="programlisting">XLSReader mainReader =
  ReaderBuilder.buildFromXML( ResourceFactory.newClassPathResource( "departments.xml", getClass() ).getInputStream() );
String expr = "[ 'departments' : new java.util.ArrayList()," +
              "  'company' : new org.drools.runtime.pipeline.impl.Company() ]";
Transformer transformer = PipelineFactory.newJxlsTransformer(mainReader, expr );</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2237"/>3.3.8.5. JMS Messenger</h4></div></div></div><p>This transformer creates a new <code class="code">JmsMessenger</code> which
      runs as a service in its own thread. It expects an existing JNDI entry
      for "ConnectionFactory", used to create the MessageConsumer which will
      feed into the specified pipeline.</p><div class="example"><a id="d0e2245"/><p class="title"><b>Example 3.47. JMS Messenger stage</b></p><div class="example-contents"><pre class="programlisting">// As this is a service, it's more likely the results will be logged
// or sent as a return message.
Action resultHandlerStage = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session associated with the PipelineContext
KnowledgeRuntimeCommand insertStage = PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( resultHandlerStage );

// Create the transformer instance and create the Transformer stage,
// where we are going from XML to Java object.
// JAXB needs an array of the available classes
JAXBContext jaxbCtx = KnowledgeBuilderHelper.newJAXBContext( classNames, kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( insertStage );

// Payloads for JMS arrive in a Message wrapper, we need to unwrap this object.
Action unwrapObjectStage = PipelineFactory.newJmsUnwrapMessageObject();
unwrapObjectStage.setReceiver( transformer );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( unwrapObjectStage );

// Services like JmsMessenger take a ResultHandlerFactory implementation.
// This is so because a result handler must be created for each incoming message.
ResultHandleFactoryImpl factory = new ResultHandleFactoryImpl();
Service messenger = PipelineFactory.newJmsMessenger( pipeline,
                                                     props,
                                                     destinationName,
                                                     factory );
</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2250"/>3.3.9. Commands and the CommandExecutor</h3></div></div></div><p>Drools has the concept of stateful or stateless sessions. We've
    already covered stateful sessions, which use the standard working memory
    that can be worked with iteratively over time. Stateless is a one-off
    execution of a working memory with a provided data set. It may return some
    results, with the session being disposed at the end, prohibiting further
    iterative interactions. You can think of stateless as treating a rule
    engine like a function call with optional return results.</p><p>In Drools 4 we supported these two paradigms but the way the user
    interacted with them was different. StatelessSession used an execute(...)
    method which would insert a collection of objects as facts.
    StatefulSession didn't have this method, and insert used the more
    traditional <code class="code">insert(...)</code> method. The other issue was that the
    StatelessSession did not return any results, so that users themselves had
    to map globals to get results, and it wasn't possible to do anything
    besides inserting objects; users could not start processes or execute
    queries.</p><p>Drools 5.0 addresses all of these issues and more. The foundation
    for this is the <code class="code">CommandExecutor</code> interface, which both the
    stateful and stateless interfaces extend, creating consistency and
    <code class="code">ExecutionResults</code>:</p><div class="figure"><a id="d0e2268"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/CommandExecutor.png" alt="CommandExecutor"/></div></div><p class="title"><b>Figure 3.28. CommandExecutor</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e2274"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ExecutionResults.png" alt="ExecutionResults"/></div></div><p class="title"><b>Figure 3.29. ExecutionResults</b></p></div><br class="figure-break"/><p>The <code class="code">CommandFactory</code> allows for commands to be executed
    on those sessions, the only difference being that the Stateless Knowledge
    Session executes <code class="code">fireAllRules()</code> at the end before disposing
    the session. The currently supported commands are:</p><div class="itemizedlist"><ul><li><p>FireAllRules</p></li><li><p>GetGlobal</p></li><li><p>SetGlobal</p></li><li><p>InsertObject</p></li><li><p>InsertElements</p></li><li><p>Query</p></li><li><p>StartProcess</p></li><li><p>BatchExecution</p></li></ul></div><p><code class="code">InsertObject</code> will insert a single object, with an
    optional "out" identifier. <code class="code">InsertElements</code> will iterate an
    Iterable, inserting each of the elements. What this means is that a
    Stateless Knowledge Session is no longer limited to just inserting
    objects, it can now start processes or execute queries, and do this in any
    order.</p><div class="example"><a id="d0e2320"/><p class="title"><b>Example 3.48. Insert Command</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
ExecutionResults bresults =
  ksession.execute( CommandFactory.newInsert( new Cheese( "stilton" ), "stilton_id" ) );
Stilton stilton = bresults.getValue( "stilton_id" );
</pre></div></div><br class="example-break"/><p>The execute method always returns an <code class="code">ExecutionResults</code>
    instance, which allows access to any command results if they specify an
    out identifier such as the "stilton_id" above.</p><div class="example"><a id="d0e2330"/><p class="title"><b>Example 3.49. InsertElements Command</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Command cmd = CommandFactory.newInsertElements( Arrays.asList( Object[] { 
                  new Cheese( "stilton" ),
                  new Cheese( "brie" ),
                  new Cheese( "cheddar" ),
              });
ExecutionResults bresults = ksession.execute( cmd );
</pre></div></div><br class="example-break"/><p>The execute method only allows for a single command. That's where
    <code class="code">BatchExecution</code> comes in, which represents a composite
    command, created from a list of commands. Now, execute will iterate over
    the list and execute each command in turn. This means you can insert some
    objects, start a process, call fireAllRules and execute a query, all in a
    single <code class="code">execute(...)</code> call, which is quite powerful.</p><p>As mentioned previosly, the Stateless Knowledge Session will execute
    <code class="code">fireAllRules()</code> automatically at the end. However the
    keen-eyed reader probably has already noticed the
    <code class="code">FireAllRules</code> command and wondered how that works with a
    StatelessKnowledgeSession. The <code class="code">FireAllRules</code> command is
    allowed, and using it will disable the automatic execution at the end;
    think of using it as a sort of manual override function.</p><p>Commands support out identifiers. Any command that has an out
    identifier set on it will add its results to the returned ExecutionResults
    instance. Let's look at a simple example to see how this works.</p><div class="example"><a id="d0e2356"/><p class="title"><b>Example 3.50. BatchExecution Command</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();

List cmds = new ArrayList();        
cmds.add( CommandFactory.newInsertObject( new Cheese( "stilton", 1), "stilton") );
cmds.add( CommandFactory.newStartProcess( "process cheeses" ) );
cmds.add( CommandFactory.newQuery( "cheeses" ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( "stilton" );
QueryResults qresults = ( QueryResults ) bresults.getValue( "cheeses" );
</pre></div></div><br class="example-break"/><p>In the above example multiple commands are executed, two of which
    populate the <code class="code">ExecutionResults</code>. The query command defaults to
    use the same identifier as the query name, but it can also be mapped to a
    different identifier.</p><p>A custom XStream marshaller can be used with the Drools Pipeline to
    achieve XML scripting, which is perfect for services. Here are two simple
    XML samples, one for the BatchExecution and one for the
    <code class="code">ExecutionResults</code>.</p><div class="example"><a id="d0e2371"/><p class="title"><b>Example 3.51. Simple BatchExecution XML</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert out-identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;price&gt;25&lt;/price&gt;
         &lt;oldPrice&gt;0&lt;/oldPrice&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2376"/><p class="title"><b>Example 3.52. Simple ExecutionResults XML</b></p><div class="example-contents"><pre class="programlisting">&lt;execution-results&gt;
   &lt;result identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;oldPrice&gt;25&lt;/oldPrice&gt;        
         &lt;price&gt;30&lt;/price&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/result&gt;
&lt;/execution-results&gt;
</pre></div></div><br class="example-break"/><p>The previously mentioned pipeline allows for a series of Stage
    objects, combined to help with getting data into and out of sessions.
    There is a Stage implementing the <code class="code">CommandExecutor</code> interface
    that allows the pipeline to script either a stateful or stateless session.
    The pipeline setup is trivial:</p><div class="example"><a id="d0e2386"/><p class="title"><b>Example 3.53. Pipeline for CommandExecutor</b></p><div class="example-contents"><pre class="programlisting">Action executeResultHandler = PipelineFactory.newExecuteResultHandler();

Action assignResult = PipelineFactory.newAssignObjectAsResult();
assignResult.setReceiver( executeResultHandler );

Transformer outTransformer =
  PipelineFactory.newXStreamToXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
outTransformer.setReceiver( assignResult );

KnowledgeRuntimeCommand cmdExecution = PipelineFactory.newCommandExecutor();
batchExecution.setReceiver( cmdExecution );

Transformer inTransformer =
  PipelineFactory.newXStreamFromXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
inTransformer.setReceiver( batchExecution );

Pipeline pipeline = PipelineFactory.newStatelessKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( inTransformer );
</pre></div></div><br class="example-break"/><p>The key thing here to note is the use of the
    <code class="code">BatchExecutionHelper</code> to provide a specially configured
    XStream with custom converters for our Command objects and the new
    <code class="code">BatchExecutor</code> stage.</p><p>Using the pipeline is very simple. You must provide your own
    implementation of the <code class="code">ResultHandler</code> which is called when the
    pipeline executes the <code class="code">ExecuteResultHandler</code> stage.</p><div class="figure"><a id="d0e2407"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ResultHandler.png" alt="Pipeline ResultHandler"/></div></div><p class="title"><b>Figure 3.30. Pipeline ResultHandler</b></p></div><br class="figure-break"/><div class="example"><a id="d0e2413"/><p class="title"><b>Example 3.54. Simple Pipeline ResultHandler</b></p><div class="example-contents"><pre class="programlisting">public static class ResultHandlerImpl implements ResultHandler {
    Object object;

    public void handleResult(Object object) {
       this.object = object;
    }

    public Object getObject() {
        return this.object;
    }
}
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2418"/><p class="title"><b>Example 3.55. Using a Pipeline</b></p><div class="example-contents"><pre class="programlisting">
InputStream inXml = ...;
ResultHandler resultHandler = new ResultHandlerImpl();
pipeline.insert( inXml, resultHandler );
</pre></div></div><br class="example-break"/><p>Earlier a <code class="code">BatchExecution</code> was created with Java to
    insert some objects and execute a query. The XML representation to be used
    with the pipeline for that example is shown below, with parameters added
    to the query.</p><div class="example"><a id="d0e2428"/><p class="title"><b>Example 3.56. BatchExecution Marshalled to XML</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
  &lt;insert out-identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;1&lt;/price&gt;
      &lt;oldPrice&gt;0&lt;/oldPrice&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/insert&gt;
  &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
    &lt;string&gt;stilton&lt;/string&gt;
    &lt;string&gt;cheddar&lt;/string&gt;
  &lt;/query&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>The <code class="code">CommandExecutor</code> returns an
    <code class="code">ExecutionResults</code>, and this is handled by the pipeline code
    snippet as well. A similar output for the &lt;batch-execution&gt; XML
    sample above would be:</p><div class="example"><a id="d0e2441"/><p class="title"><b>Example 3.57. ExecutionResults Marshalled to XML</b></p><div class="example-contents"><pre class="programlisting">&lt;execution-results&gt;
  &lt;result identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;2&lt;/price&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/result&gt;        
  &lt;result identifier='cheeses2'&gt;
    &lt;query-results&gt;
      &lt;identifiers&gt;
        &lt;identifier&gt;cheese&lt;/identifier&gt;
      &lt;/identifiers&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;2&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;1&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
    &lt;/query-results&gt;
  &lt;/result&gt;
&lt;/execution-results&gt;
</pre></div></div><br class="example-break"/><p>The <code class="code">BatchExecutionHelper</code> provides a configured XStream
    instance to support the marshalling of Batch Executions, where the
    resulting XML can be used as a message format, as shown above. Configured
    converters only exist for the commands supported via the Command Factory.
    The user may add other converters for their user objects. This is very
    useful for scripting stateless or stateful knowledge sessions, especially
    when services are involved.</p><p>There is currently no XML schema to support schema validation. The
    basic format is outlined here, and the drools-transformer-xstream module
    has an illustrative unit test in the
    <code class="code">XStreamBatchExecutionTest</code> unit test. The root element is
    &lt;batch-execution&gt; and it can contain zero or more commands
    elements.</p><div class="example"><a id="d0e2456"/><p class="title"><b>Example 3.58. Root XML element</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
...
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>This contains a list of elements that represent commands, the
    supported commands is limited to those Commands provided by the Command
    Factory. The most basic of these is the &lt;insert&gt; element, which
    inserts objects. The contents of the insert element is the user object, as
    dictated by XStream.</p><div class="example"><a id="d0e2463"/><p class="title"><b>Example 3.59. Insert</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert&gt;
      ...&lt;!-- any user object --&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>The insert element features an "out-identifier" attribute, demanding
    that the inserted object will also be returned as part of the result
    payload.</p><div class="example"><a id="d0e2470"/><p class="title"><b>Example 3.60. Insert with Out Identifier Command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert out-identifier='userVar'&gt;
      ...
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>It's also possible to insert a collection of objects using the
    &lt;insert-elements&gt; element. This command does not support an
    out-identifier. The <code class="code">org.domain.UserClass</code> is just an
    illustrative user object that XStream would serialize.</p><div class="example"><a id="d0e2480"/><p class="title"><b>Example 3.61. Insert Elements command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert-elements&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/insert-elements&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>Next, there is the <code class="code">&lt;set-global&gt;</code> element, which
    sets a global for the session.</p><div class="example"><a id="d0e2490"/><p class="title"><b>Example 3.62. Insert Elements command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p><code class="code">&lt;set-global&gt;</code> also supports two other optional
    attributes, <strong class="kw"><code>out</code></strong> and <strong class="kw"><code>out-identifier</code></strong>. A true value for the
    boolean <strong class="kw"><code>out</code></strong> will add the global to the
    <code class="code">&lt;batch-execution-results&gt;</code> payload, using the name from
    the <strong class="kw"><code>identifier</code></strong> attribute. <strong class="kw"><code>out-identifier</code></strong> works like
    <strong class="kw"><code>out</code></strong> but additionally allows you to override the identifier used
    in the <code class="code">&lt;batch-execution-results&gt;</code> payload.</p><div class="example"><a id="d0e2523"/><p class="title"><b>Example 3.63. Set Global Command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar1' out='true'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
   &lt;set-global identifier='userVar2' out-identifier='alternativeUserVar2'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>There is also a <code class="code">&lt;get-global&gt;</code> element, without
    contents, with just an <strong class="kw"><code>out-identifier</code></strong> attribute. (There is no
    need for an <strong class="kw"><code>out</code></strong> attribute because retrieving the value is the
    sole purpose of a <code class="code">&lt;get-global&gt;</code> element.</p><div class="example"><a id="d0e2542"/><p class="title"><b>Example 3.64. Get Global Command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;get-global identifier='userVar1' /&gt;
   &lt;get-global identifier='userVar2' out-identifier='alternativeUserVar2'/&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>While the <strong class="kw"><code>out</code></strong> attribute is useful in returning specific
    instances as a result payload, we often wish to run actual queries. Both
    parameter and parameterless queries are supported. The <strong class="kw"><code>name</code></strong>
    attribute is the name of the query to be called, and the
    <strong class="kw"><code>out-identifier</code></strong> is the identifier to be used for the query results
    in the <code class="code">&lt;execution-results&gt;</code> payload.</p><div class="example"><a id="d0e2561"/><p class="title"><b>Example 3.65. Query Command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;query out-identifier='cheeses' name='cheeses'/&gt;
   &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
      &lt;string&gt;stilton&lt;/string&gt;
      &lt;string&gt;cheddar&lt;/string&gt;
   &lt;/query&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"/><p>The <code class="code">&lt;start-process&gt;</code> command accepts optional
    parameters. Other process related methods will be added later, like
    interacting with work items.</p><div class="example"><a id="d0e2571"/><p class="title"><b>Example 3.66. Start Process Command</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;startProcess processId='org.drools.actions'&gt;
      &lt;parameter identifier='person'&gt;
         &lt;org.drools.TestVariable&gt;
            &lt;name&gt;John Doe&lt;/name&gt;
         &lt;/org.drools.TestVariable&gt;
      &lt;/parameter&gt;
   &lt;/startProcess&gt;
&lt;/batch-execution
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2576"/><p class="title"><b>Example 3.67. Signal Event Command</b></p><div class="example-contents"><pre class="programlisting">&lt;signal-event process-instance-id='1' event-type='MyEvent'&gt;
   &lt;string&gt;MyValue&lt;/string&gt;
&lt;/signal-event&gt;
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2581"/><p class="title"><b>Example 3.68. Complete Work Item Command</b></p><div class="example-contents"><pre class="programlisting">&lt;complete-work-item id='" + workItem.getId() + "' &gt;
   &lt;result identifier='Result'&gt;
      &lt;string&gt;SomeOtherString&lt;/string&gt;
   &lt;/result&gt;
&lt;/complete-work-item&gt;
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2586"/><p class="title"><b>Example 3.69. Abort Work Item Command</b></p><div class="example-contents"><pre class="programlisting">&lt;abort-work-item id='21' /&gt;
</pre></div></div><br class="example-break"/><p>Support for more commands will be added over time.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2593"/>3.3.10. Marshalling</h3></div></div></div><p>The <code class="code">MarshallerFactory</code> is used to marshal and unmarshal
    Stateful Knowledge Sessions.</p><div class="figure"><a id="d0e2601"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-User_Guide/MarshallerFactory.png" width="100%" alt="MarshallerFactory"/></td></tr></table></div></div><p class="title"><b>Figure 3.31. MarshallerFactory</b></p></div><br class="figure-break"/><p>At the simplest the <code class="code">MarshallerFactory</code> can be used as
    follows:</p><div class="example"><a id="d0e2612"/><p class="title"><b>Example 3.70. Simple Marshaller Example</b></p><div class="example-contents"><pre class="programlisting">// ksession is the StatefulKnowledgeSession
// kbase is the KnowledgeBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"/><p>However, with marshalling you need more flexibility when dealing
    with referenced user data. To achieve this we have the
    <code class="code">ObjectMarshallingStrategy</code> interface. Two implementations are
    provided, but users can implement their own. The two supplied strategies
    are <code class="code">IdentityMarshallingStrategy</code> and
    <code class="code">SerializeMarshallingStrategy</code>.
    <code class="code">SerializeMarshallingStrategy</code> is the default, as used in the
    example above, and it just calls the <code class="code">Serializable</code> or
    <code class="code">Externalizable</code> methods on a user instance.
    <code class="code">IdentityMarshallingStrategy</code> instead creates an integer id for
    each user object and stores them in a Map, while the id is written to the
    stream. When unmarshalling it accesses the
    <code class="code">IdentityMarshallingStrategy</code> map to retrieve the instance.
    This means that if you use the <code class="code">IdentityMarshallingStrategy</code>,
    it is stateful for the life of the Marshaller instance and will create ids
    and keep references to all objects that it attempts to marshal. Below is
    he code to use an Identity Marshalling Strategy.</p><div class="example"><a id="d0e2646"/><p class="title"><b>Example 3.71. IdentityMarshallingStrategy</b></p><div class="example-contents"><pre class="programlisting">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategy oms = MarshallerFactory.newIdentityMarshallingStrategy()
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"/><p>For added flexability we can't assume that a single strategy is
    suitable. Therefore we have added the
    <code class="code">ObjectMarshallingStrategyAcceptor</code> interface that each Object
    Marshalling Strategy contains. The Marshaller has a chain of strategies,
    and when it attempts to read or write a user object it iterates the
    strategies asking if they accept responsability for marshalling the user
    object. One of the provided implementations is
    <code class="code">ClassFilterAcceptor</code>. This allows strings and wild cards to be
    used to match class names. The default is "*.*", so in the above example
    the Identity Marshalling Strategy is used which has a default "*.*"
    acceptor.</p><p>Assuming that we want to serialize all classes except for one given
    package, where we will use identity lookup, we could do the
    following:</p><div class="example"><a id="d0e2661"/><p class="title"><b>Example 3.72. IdentityMarshallingStrategy with Acceptor</b></p><div class="example-contents"><pre class="programlisting">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategyAcceptor identityAcceptor =
  MarshallerFactory.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStrategy =
  MarshallerFactory.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = MarshallerFactory.newSerializeMarshallingStrategy();
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase,
                                   new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"/><p>Note that the acceptance checking order is in the natural order of
    the supplied array.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2668"/>3.3.11. Persistence and Transactions</h3></div></div></div><p>Longterm out of the box persistence with Java Persistence API (JPA)
    is possible with Drools. You will need to have some implementation of the
    Java Transaction API (JTA) installed. For development purposes we
    recommend the Bitronix Transaction Manager, as it's simple to set up and
    works embedded, but for production use JBoss Transactions is
    recommended.</p><div class="example"><a id="d0e2673"/><p class="title"><b>Example 3.73. Simple example using transactions</b></p><div class="example-contents"><pre class="programlisting">Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
         Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );
          
// KnowledgeSessionConfiguration may be null, and a default will be used
StatefulKnowledgeSession ksession =
  JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );
int sessionId = ksession.getId();
 
UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( "process1" );
ut.commit();
</pre></div></div><br class="example-break"/><p>To use a JPA, the Environment must be set with both the
    <code class="code">EntityManagerFactory</code> and the <code class="code">TransactionManager</code>.
    If rollback occurs the ksession state is also rolled back, so you can
    continue to use it after a rollback. To load a previously persisted
    Stateful Knowledge Session you'll need the id, as shown below:</p><div class="example"><a id="d0e2686"/><p class="title"><b>Example 3.74. Loading a StatefulKnowledgeSession</b></p><div class="example-contents"><pre class="programlisting">StatefulKnowledgeSession ksession =
  JPAKnowledgeService.loadStatefulKnowledgeSession( sessionId, kbase, null, env );
</pre></div></div><br class="example-break"/><p>To enable persistence several classes must be added to your
    persistence.xml, as in the example below:</p><div class="example"><a id="d0e2693"/><p class="title"><b>Example 3.75. Configuring JPA</b></p><div class="example-contents"><pre class="programlisting">&lt;persistence-unit name="org.drools.persistence.jpa" transaction-type="JTA"&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;       
   &lt;class&gt;org.drools.persistence.session.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceEventInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;            
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
         &lt;property name="hibernate.show_sql" value="true" /&gt;
         &lt;property name="hibernate.transaction.manager_lookup_class"
                      value="org.hibernate.transaction.BTMTransactionManagerLookup" /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</pre></div></div><br class="example-break"/><p>The jdbc JTA data source would have to be configured first. Bitronix
    provides a number of ways of doing this, and its documentation should be
    contsulted for details. For a quick start, here is the programmatic
    approach:</p><div class="example"><a id="d0e2700"/><p class="title"><b>Example 3.76. Configuring JTA DataSource</b></p><div class="example-contents"><pre class="programlisting">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( "jdbc/BitronixJTADataSource" );
ds.setClassName( "org.h2.jdbcx.JdbcDataSource" );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( "user", "sa" );
ds.getDriverProperties().put( "password", "sasa" );
ds.getDriverProperties().put( "URL", "jdbc:h2:mem:mydb" );
ds.init();
</pre></div></div><br class="example-break"/><p>Bitronix also provides a simple embedded JNDI service, ideal for
    testing. To use it add a jndi.properties file to your META-INF and add the
    following line to it:</p><div class="example"><a id="d0e2707"/><p class="title"><b>Example 3.77. JNDI properties</b></p><div class="example-contents"><pre class="programlisting">java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</pre></div></div><br class="example-break"/></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2712"/>Chapter 4. The Rule Language</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2715">4.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2723">4.1.1. A rule file</a></span></dt><dt><span class="section"><a href="#d0e2756">4.1.2. What makes a rule</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2792">4.2. Keywords</a></span></dt><dt><span class="section"><a href="#d0e3005">4.3. Comments</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3010">4.3.1. Single line comment</a></span></dt><dt><span class="section"><a href="#d0e3023">4.3.2. Multi-line comment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3036">4.4. Error Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3045">4.4.1. Message format</a></span></dt><dt><span class="section"><a href="#d0e3076">4.4.2. Error Messages Description</a></span></dt><dt><span class="section"><a href="#d0e3231">4.4.3. Other Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3236">4.5. Package</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3259">4.5.1. import</a></span></dt><dt><span class="section"><a href="#d0e3273">4.5.2. global</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3316">4.6. Function</a></span></dt><dt><span class="section"><a href="#d0e3350">4.7. Type Declaration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3378">4.7.1. Declaring New Types</a></span></dt><dt><span class="section"><a href="#d0e3500">4.7.2. Declaring Metadata</a></span></dt><dt><span class="section"><a href="#d0e3571">4.7.3. Declaring Metadata for Existing Types</a></span></dt><dt><span class="section"><a href="#d0e3614">4.7.4. Accessing Declared Types from the Application Code</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3663">4.8. Rule</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3705">4.8.1. Rule Attributes</a></span></dt><dt><span class="section"><a href="#RuleLanguage-ConditionalElements">4.8.2. Left Hand Side (when) Conditional Elements</a></span></dt><dt><span class="section"><a href="#d0e5216">4.8.3. The Right Hand Side (then)</a></span></dt><dt><span class="section"><a href="#d0e5455">4.8.4. A Note on Auto-boxing and Primitive Types</a></span></dt></dl></dd><dt><span class="section"><a href="#sec.query">4.9. Query</a></span></dt><dt><span class="section"><a href="#d0e5495">4.10. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5506">4.10.1. When to use a DSL</a></span></dt><dt><span class="section"><a href="#d0e5515">4.10.2. Editing and managing a DSL</a></span></dt><dt><span class="section"><a href="#d0e5569">4.10.3. Using a DSL in your rules</a></span></dt><dt><span class="section"><a href="#d0e5595">4.10.4. Adding constraints to facts</a></span></dt><dt><span class="section"><a href="#d0e5628">4.10.5. How it works</a></span></dt><dt><span class="section"><a href="#d0e5637">4.10.6. Creating a DSL from scratch</a></span></dt><dt><span class="section"><a href="#d0e5665">4.10.7. Scope and keywords</a></span></dt><dt><span class="section"><a href="#d0e5670">4.10.8. DSLs in the BRMS and IDE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5679">4.11. XML Rule Language</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5688">4.11.1. When to use XML</a></span></dt><dt><span class="section"><a href="#d0e5699">4.11.2. The XML format</a></span></dt><dt><span class="section"><a href="#d0e5745">4.11.3. Legacy Drools 2.x XML rule format</a></span></dt><dt><span class="section"><a href="#d0e5750">4.11.4. Automatic transforming between formats (XML and DRL)</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2715"/>4.1. Overview</h2></div></div></div><p>Drools has a "native" rule language. 
  This format is very light in terms of punctuation, and supports
  natural and domain specific languages via "expanders" that allow the
  language to morph to your problem domain. This chapter is mostly concerted
  with this native rule format. The diagrams used to present the syntax are
  known as "railroad" diagrams, and they are basically flow charts for the
  language terms. The
  technically very keen may also refer to <code class="filename">DRL.g</code> which is 
  the Antlr3
  grammar for the rule language. If you use the Rule Workbench, a lot of the
  rule structure is done for you with content assistance, for example, type
  "ru" and press ctrl+space, and it will build the rule structure for
  you.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2723"/>4.1.1. A rule file</h3></div></div></div><p>A rule file is typically a file with a .drl extension. In a DRL file
    you can have multiple rules, queries and functions, as well as some
    resource declarations like imports, globals and attributes that are
    assigned and used by your rules and queries. However, you are also able to
    spread your rules across multiple rule files (in that case, the extension
    .rule is suggested, but not required) - spreading rules across files can
    help with managing large numbers of rules. A DRL file is simply a text
    file.</p><p>The overall structure of a rule file is:</p><div class="example"><a id="d0e2730"/><p class="title"><b>Example 4.1. Rules file</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>package </strong></span><em class="replaceable"><code>package-name</code></em>

<em class="replaceable"><code>imports</code></em>

<em class="replaceable"><code>globals</code></em>

<em class="replaceable"><code>functions</code></em>

<em class="replaceable"><code>queries</code></em>

<em class="replaceable"><code>rules</code></em>
</pre></div></div><br class="example-break"/><p>The order in which the elements are declared is not important,
    except for the package name that, if declared, must be the first element
    in the rules file. All elements are optional, so you will use only those
    you need. We will discuss each of them in the following sections.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2756"/>4.1.2. What makes a rule</h3></div></div></div><p>For the inpatients, just as an early view, a rule has the following
    rough structure:</p><pre class="programlisting"><span class="bold"><strong>rule</strong></span> <em class="replaceable"><code>"name"</code></em>
    <em class="replaceable"><code>attributes</code></em>
    <span class="bold"><strong>when</strong></span>
        <em class="replaceable"><code>LHS</code></em>
    <span class="bold"><strong>then</strong></span>
        <em class="replaceable"><code>RHS</code></em>
<span class="bold"><strong>end</strong></span>
</pre><p>It's really that simple. Mostly punctuation is not needed,
    even the double quotes for "name" are optional, as are newlines.
    Attributes are simple (always optional) hints to how the rule should
    behave. LHS is the conditional parts of the rule, which follows a certain
    syntax which is covered below. RHS is basically a block that allows
    dialect specific semantic code to be executed.</p><p>It is important to note that white space is not important,
      <span class="emphasis"><em>except</em></span> in
    the case of domain specific languages, where lines are processed
    one by one and spaces may be significant to the domain language.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2792"/>4.2. Keywords</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
        <em class="replaceable"><code>(updated to Drools 5.0)</code></em>
      </p></div><p>Drools 5 introduces the concept of <span class="emphasis"><em>hard</em></span> and
    <span class="emphasis"><em>soft</em></span> keywords.</p><p>Hard keywords are reserved, you cannot use any hard keyword when
    naming your domain objects, properties, methods, functions and other
    elements that are used in the rule text.</p><p>Here is the list of hard keywords that must be avoided as identifiers
    when writing rules:</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>true</code></strong></p></li><li><p><strong class="kw"><code>false</code></strong></p></li><li><p><strong class="kw"><code>accumulate</code></strong></p></li><li><p><strong class="kw"><code>collect</code></strong></p></li><li><p><strong class="kw"><code>from</code></strong></p></li><li><p><strong class="kw"><code>null</code></strong></p></li><li><p><strong class="kw"><code>over</code></strong></p></li><li><p><strong class="kw"><code>then</code></strong></p></li><li><p><strong class="kw"><code>when</code></strong></p></li></ul></div><p>Soft keywords are just recognized in their context, enabling you to
    use these words in any other place you wish. Here is a list of the soft
    keywords:</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>lock-on-active</code></strong></p></li><li><p><strong class="kw"><code>date-effective</code></strong></p></li><li><p><strong class="kw"><code>date-expires</code></strong></p></li><li><p><strong class="kw"><code>no-loop</code></strong></p></li><li><p><strong class="kw"><code>auto-focus</code></strong></p></li><li><p><strong class="kw"><code>activation-group</code></strong></p></li><li><p><strong class="kw"><code>agenda-group</code></strong></p></li><li><p><strong class="kw"><code>ruleflow-group</code></strong></p></li><li><p><strong class="kw"><code>entry-point</code></strong></p></li><li><p><strong class="kw"><code>duration</code></strong></p></li><li><p><strong class="kw"><code>package</code></strong></p></li><li><p><strong class="kw"><code>import</code></strong></p></li><li><p><strong class="kw"><code>dialect</code></strong></p></li><li><p><strong class="kw"><code>salience</code></strong></p></li><li><p><strong class="kw"><code>enabled</code></strong></p></li><li><p><strong class="kw"><code>attributes</code></strong></p></li><li><p><strong class="kw"><code>rule</code></strong></p></li><li><p><strong class="kw"><code>extend</code></strong></p></li><li><p><strong class="kw"><code>template</code></strong></p></li><li><p><strong class="kw"><code>query</code></strong></p></li><li><p><strong class="kw"><code>declare</code></strong></p></li><li><p><strong class="kw"><code>function</code></strong></p></li><li><p><strong class="kw"><code>global</code></strong></p></li><li><p><strong class="kw"><code>eval</code></strong></p></li><li><p><strong class="kw"><code>not</code></strong></p></li><li><p><strong class="kw"><code>in</code></strong></p></li><li><p><strong class="kw"><code>or</code></strong></p></li><li><p><strong class="kw"><code>and</code></strong></p></li><li><p><strong class="kw"><code>exists</code></strong></p></li><li><p><strong class="kw"><code>forall</code></strong></p></li><li><p><strong class="kw"><code>action</code></strong></p></li><li><p><strong class="kw"><code>reverse</code></strong></p></li><li><p><strong class="kw"><code>result</code></strong></p></li><li><p><strong class="kw"><code>end</code></strong></p></li><li><p><strong class="kw"><code>init</code></strong></p></li></ul></div><p>Of course, you can have these (hard and soft) words as part of a
    method name in camel case, like notSomething() or accumulateSomething() -
    there are no issues with that scenario.</p><p>Another improvement of the DRL language is the ability to escape hard
    keywords on rule text. This feature enables you to use your existing
    domain objects without worrying about keyword collision. To escape a word,
    simply enclose it in grave accents, like this:</p><pre class="programlisting">Holiday( `when` == "july" )</pre><p>The escape should be used everywehere in rule text, except within code
    expressions in the LHS or RHS code block. Here are examples of proper
    usage:</p><pre class="programlisting">rule "validate holiday by eval" 
dialect "mvel"
when
    h1 : Holiday( )
    eval( h1.when == "july" )
then
    System.out.println(h1.name + ":" + h1.when);
end
</pre><pre class="programlisting">rule "validate holiday" 
dialect "mvel"
when
    h1 : Holiday( `when` == "july" )
then
    System.out.println(h1.name + ":" + h1.when);
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3005"/>4.3. Comments</h2></div></div></div><p>Comments are sections of text that are ignored by the rule engine.
  They are stripped out when they are encountered, except inside semantic code
  blocks, like the RHS of a rule.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3010"/>4.3.1. Single line comment</h3></div></div></div><div class="figure"><a id="d0e3013"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/single_line_comment.png" align="middle" alt="Single line comment"/></div></div><p class="title"><b>Figure 4.1. Single line comment</b></p></div><br class="figure-break"/><p>To create single line comments, you can use either '#' or '//'. The
    parser will ignore anything in the line after the comment symbol.
    Example:</p><pre class="programlisting">rule "Testing Comments"
when
    # this is a single line comment
    // this is also a single line comment
    eval( true ) # this is a comment in the same line of a pattern
then
    // this is a comment inside a semantic code block
    # this is another comment in a semantic code block
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3023"/>4.3.2. Multi-line comment</h3></div></div></div><div class="figure"><a id="d0e3026"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/multi_line_comment.png" align="middle" alt="Multi-line comment"/></div></div><p class="title"><b>Figure 4.2. Multi-line comment</b></p></div><br class="figure-break"/><p>Multi-line comments are used to comment blocks of text, both in and
    outside semantic code blocks. Example:</p><pre class="programlisting">rule "Test Multi-line Comments"
when
    /* this is a multi-line comment
       in the left hand side of a rule */
    eval( true )
then
    /* and this is a multi-line comment
       in the right hand side of a rule */
end </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3036"/>4.4. Error Messages</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><em class="replaceable"><code>(updated to Drools 5.0)</code></em></p></div><p>Drools 5 introduces standardized error messages. This standardization
  aims to help users to find and resolve problems in a easier and faster way.
  In this section you will learn how to identify and interpret those error
  messages, and you will also receive some tips on how to solve the problems
  associated with them.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3045"/>4.4.1. Message format</h3></div></div></div><p>The standardization includes the error message format and to better
    explain this format, let's use the following example:</p><div class="figure"><a id="d0e3050"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/error_message.png" align="middle" alt="Error Message Format"/></div></div><p class="title"><b>Figure 4.3. Error Message Format</b></p></div><br class="figure-break"/><p><span class="bold"><strong>1st Block:</strong></span> This area identifies the
    error code.</p><p><span class="bold"><strong>2nd Block:</strong></span> Line and column
    information.</p><p><span class="bold"><strong>3rd Block:</strong></span> Some text describing the
    problem.</p><p><span class="bold"><strong>4th Block:</strong></span> This is the first
    context. Usually indicates the rule, function, template or query where the
    error occurred. This block is not mandatory.</p><p><span class="bold"><strong>5th Block:</strong></span> Identifies the pattern
    where the error occurred. This block is not mandatory.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3076"/>4.4.2. Error Messages Description</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3079"/>4.4.2.1. 101: No viable alternative</h4></div></div></div><p>Indicates the most common errors, where the parser came to a
      decision point but  couldn't identify an alternative. Here are some
      examples:</p><div class="example"><a id="d0e3084"/><p class="title"><b>Example 4.2. </b></p><div class="example-contents"><pre class="programlisting">1: rule one
2:   when
3:     exists Foo()
4:     <span class="bold"><strong>exits</strong></span> Bar()
5:   then
6: end
</pre></div></div><br class="example-break"/><p>The above example generates this message:</p><div class="itemizedlist"><ul><li><p>[ERR 101] Line 4:4 no viable alternative at input 'exits' in
          rule one</p></li></ul></div><p>At first glance this seems to be valid syntax, but it is not (exits
      != exists). Let's take a look at next example:</p><div class="example"><a id="d0e3098"/><p class="title"><b>Example 4.3. </b></p><div class="example-contents"><pre class="programlisting">1: package org.drools;
2: rule
3:   when
4:     Object()
5:   then
6:     System.out.println("A RHS");
7: end
</pre></div></div><br class="example-break"/><p>Now the above code generates this message:</p><div class="itemizedlist"><ul><li><p>[ERR 101] Line 3:2 no viable alternative at input
          'WHEN'</p></li></ul></div><p>This message means that the parser encountered the token
      <span class="bold"><strong>WHEN</strong></span>, actually a hard keyword, but
      it's in the wrong place since the the rule name is missing.</p><p>The error "no viable alternative" also occurs when you make
      a simple lexical mistake. Here is a sample of a lexical problem:</p><div class="example"><a id="d0e3114"/><p class="title"><b>Example 4.4. </b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     Student( name == "Andy )
4:   then
5: end
</pre></div></div><br class="example-break"/><p>The above code misses to close the quotes and because of this the
      parser generates this error message:</p><div class="itemizedlist"><ul><li><p>[ERR 101] Line 0:-1 no viable alternative at input
          '&lt;eof&gt;' in rule simple_rule in pattern Student</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Usually the Line and Column information are accurate, but in
        some cases (like unclosed quotes), the parser generates a 0:-1
        position. In this case you should check whether you didn't forget to close
        quotes, apostrophes or parentheses.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3127"/>4.4.2.2. 102: Mismatched input</h4></div></div></div><p>This error indicates that the parser was looking for a particular
      symbol that it didn’t ﬁnd at the current input position. Here are some
      samples:</p><div class="example"><a id="d0e3132"/><p class="title"><b>Example 4.5. </b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     foo3 : Bar(
</pre></div></div><br class="example-break"/><p>The above example generates this message:</p><div class="itemizedlist"><ul><li><p>[ERR 102] Line 0:-1 mismatched input '&lt;eof&gt;' expecting
          ')' in rule simple_rule in pattern Bar</p></li></ul></div><p>To fix this problem, it is necessary to complete the rule
      statement.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Usually when you get a 0:-1 position, it means that parser
        reached the end of source.</p></div><p>The following code generates more than one error message:</p><div class="example"><a id="d0e3148"/><p class="title"><b>Example 4.6. </b></p><div class="example-contents"><pre class="programlisting">1: package org.drools;
2:
3: rule "Avoid NPE on wrong syntax"
4:   when
5:     not( Cheese( ( type == "stilton", price == 10 ) || ( type == "brie", price == 15 ) ) from $cheeseList )
6:   then
7:     System.out.println("OK");
8: end
</pre></div></div><br class="example-break"/><p>These are the errors associated with this source:</p><div class="itemizedlist"><ul><li><p>[ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule
          "Avoid NPE on wrong syntax" in pattern Cheese</p></li><li><p>[ERR 101] Line 5:57 no viable alternative at input 'type' in
          rule "Avoid NPE on wrong syntax"</p></li><li><p>[ERR 102] Line 5:106 mismatched input ')' expecting 'then' in
          rule "Avoid NPE on wrong syntax"</p></li></ul></div><p>Note that the second problem is related to the first. To fix it,
      just replace the commas (',') by AND operator ('&amp;&amp;').</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>In some situations you can get more than one error message. Try to
        fix one by one, starting at the first one. Some error messages are
        generated merely as consequences of other errors.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3168"/>4.4.2.3. 103: Failed predicate</h4></div></div></div><p>A validating semantic predicate evaluated to false. Usually these
      semantic predicates are used to identify soft keywords. This sample
      shows exactly this situation:</p><div class="example"><a id="d0e3173"/><p class="title"><b>Example 4.7. </b></p><div class="example-contents"><pre class="programlisting"> 1: package nesting;
 2: dialect "mvel"
 3:
 4: import org.drools.Person
 5: import org.drools.Address
 6: 
 7: <span class="bold"><strong>fdsfdsfds</strong></span>
 8: 
 9: rule "test something"
10:   when
11:     p: Person( name=="Michael" )
12:   then
13:     p.name = "other";
14:     System.out.println(p.name);
15: end
</pre></div></div><br class="example-break"/><p>With this sample, we get this error message:</p><div class="itemizedlist"><ul><li><p>[ERR 103] Line 7:0 rule 'rule_key' failed predicate:
          {(validateIdentifierKey(DroolsSoftKeywords.RULE))}? in rule</p></li></ul></div><p>The <span class="bold"><strong>fdsfdsfds</strong></span> text is invalid and
      the parser couldn’t identify it as the soft keyword <strong class="kw"><code>rule</code></strong>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>This error is very similar to 102: Mismatched input, but usually
        involves soft keywords.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3196"/>4.4.2.4. 104: Trailing semi-colon not allowed</h4></div></div></div><p>This error is associated with the <strong class="kw"><code>eval</code></strong> clause, where its
      expression may not be terminated with a semicolon. Check this
	example:</p><div class="example"><a id="d0e3204"/><p class="title"><b>Example 4.8. </b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     eval(abc();)
4:   then
5: end
</pre></div></div><br class="example-break"/><p>Due to the trailing semicolon within eval, we get this error
      message:</p><div class="itemizedlist"><ul><li><p>[ERR 104] Line 3:4 trailing semi-colon not allowed in rule
          simple_rule</p></li></ul></div><p>This problem is simple to fix: just remove the
      semi-colon.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3215"/>4.4.2.5. 105: Early Exit</h4></div></div></div><p>The recognizer came to a subrule in the grammar that must match an
      alternative at least once, but the subrule did not match anything.
      Simply put: the parser has entered a branch from where there is no
      way out. This example illustrates it:</p><div class="example"><a id="d0e3220"/><p class="title"><b>Example 4.9. </b></p><div class="example-contents"><pre class="programlisting">1: template test_error
2:   aa s  11;
3: end
</pre></div></div><br class="example-break"/><p>This is the message associated to the above sample:</p><div class="itemizedlist"><ul><li><p>[ERR 105] Line 2:2 required (...)+ loop did not match anything
          at input 'aa' in template test_error</p></li></ul></div><p>To fix this problem it is necessary to remove the numeric value
      as it is neither a valid data type which might begin a new template
      slot nor a possible start for any other rule file construct.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3231"/>4.4.3. Other Messages</h3></div></div></div><p>Any other message means that something bad has happened, so
    please contact the development team.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3236"/>4.5. Package</h2></div></div></div><p>A package is a collection of rules and other related constructs, such
  as imports and globals. The package members are typically related to each
  other - perhaps HR rules, for instance. A package represents a namespace,
  which ideally is kept unique for a given grouping of rules. The package name
  itself is the namespace, and is not related to files or folders in any
  way.</p><p>It is possible to assemble rules from multiple rule sources, and have
  one top level package configuration that all the rules are kept under (when
  the rules are assembled). Although, it is not possible to merge into the
  same package resources declared under different names. A single Rulebase
  may, however, contain multiple packages built on it. A common structure is to
  have all the rules for a package in the same file as the package declaration
  (so that is it entirely self-contained).</p><p>The following railroad diagram shows all the components that may make
  up a package. Note that a package <span class="emphasis"><em>must</em></span> have a namespace and be declared
  using standard Java conventions for package names; i.e., no spaces, unlike
  rule names which allow spaces. In terms of the order of elements, they can
  appear in any order in the rule file, with the exception of the <strong class="kw"><code>package</code></strong>
  statement, which must be at the top of the file. In all cases, the semicolons are
  optional.</p><div class="figure"><a id="d0e3251"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/package.png" align="middle" alt="package"/></div></div><p class="title"><b>Figure 4.4. package</b></p></div><br class="figure-break"/><p>Notice that any rule atttribute (as described the section Rule Attributes)
  may also be written at package level, superseding the attribute's default value.
  The modified default may still be replaced by an attribute setting within
  a rule.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3259"/>4.5.1. import</h3></div></div></div><div class="figure"><a id="d0e3262"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Rule_Language/import.png" alt="import"/></div></div><p class="title"><b>Figure 4.5. import</b></p></div><br class="figure-break"/><p>Import statements work like import statements in Java. You need to
    specify the fully qualified paths and type names for any objects you want
    to use in the rules. Drools automatically imports classes from the
    Java package of the same name, and also from the package
    <code class="code">java.lang</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3273"/>4.5.2. global</h3></div></div></div><div class="figure"><a id="d0e3276"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Rule_Language/global.png" alt="global"/></div></div><p class="title"><b>Figure 4.6. global</b></p></div><br class="figure-break"/><p>With <strong class="kw"><code>global</code></strong> you define global variables. They are used to make
    application objects available to the rules. Typically, they are used
    to provide data or services that the rules use, especially application
    services used in rule consequences, and to return data from the rules,
    like logs or values added in rule consequences, or for the rules to
    interact with the application, doing callbacks. Globals are not 
    inserted into the Working Memory, and therefore a global should never be
    used to establish conditions in rules except when it has a
    constant immutable value. The engine cannot be notified about value
    changes of globals and does not track their changes. Incorrect use
    of globals in constraints may yield surprising results - surprising
    in a bad way.</p><p>If multiple packages declare globals with the same identifier they
    must be of the same type and all of them will reference the same global
    value.</p><p>In order to use globals you must:</p><div class="orderedlist"><ol type="1"><li><p>Declare your global variable in your rules file and use it in
        rules. Example:</p><pre class="programlisting">global java.util.List myGlobalList;

rule "Using a global"
when
    eval( true )
then
    myGlobalList.add( "Hello World" );
end
</pre></li><li><p>Set the global value on your working memory. It is a best
        practice to set all global values before asserting any fact to the
        working memory. Example:</p><pre class="programlisting">List list = new ArrayList();
WorkingMemory wm = rulebase.newStatefulSession();
wm.setGlobal( "myGlobalList", list );
</pre></li></ol></div><p>Note that these are just named instances of objects that you pass in
    from your application to the working memory. This means you can pass in
    any object you want: you could pass in a service locator, or perhaps a
    service itself. With the new <strong class="kw"><code>from</code></strong> element it is now common to pass a
    Hibernate session as a global, to allow <strong class="kw"><code>from</code></strong> to pull data from a named
    Hibernate query.</p><p>One example may be an instance of a Email service. In your
    integration code that is calling the rule engine, you obtain your
    emailService object, and then set it in the working memory. In the DRL,
    you declare that you have a global of type EmailService, and give it the
    name "email". Then in your rule consequences, you can use things like
    email.sendSMS(number, message).</p><p>Globals are not designed to share data between rules and they should
    never be used for that purpose. Rules always reason and react to the
    working memory state, so if you want to pass data from rule to rule, assert
    the data as facts into the working memory.</p><p>It is strongly discouraged to set or change a global value from
    inside your rules. We recommend to you always set the value from your
    application using the working memory interface.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3316"/>4.6. Function</h2></div></div></div><div class="figure"><a id="d0e3319"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/function.png" align="middle" alt="function"/></div></div><p class="title"><b>Figure 4.7. function</b></p></div><br class="figure-break"/><p>Functions are a way to put semantic code in your rule source file, as
  opposed to in normal Java classes. They can't do anything more than what you
  can do with helper classes. (In fact, the compiler generates the helper class
  for you behind the scenes.) The main advantage of using functions in a rule
  is that you can keep the logic all in one place, and you can change the
  functions as needed (which can be a good or a bad thing). Functions are most
  useful for invoking actions on the consequence (<strong class="kw"><code>then</code></strong>) part of a rule,
  especially if that particular action is used over and over again, perhaps
  with only differing parameters for each rule.</p><p>A typical function declaration looks like:</p><pre class="programlisting">function String hello(String name) {
    return "Hello "+name+"!";
}
</pre><p>Note that the <strong class="kw"><code>function</code></strong> keyword is used, even though its not really
  part of Java. Parameters to the function are defined as for a method, and
  you don't have to have parameters if they are not needed. The return type
  is defined just like in a regular method.</p><p>Alternatively, you could use a static method in a helper class,
  e.g., <code class="code">Foo.hello()</code>. Drools supports the use of
  function imports, so all you would need to do is:</p><pre class="programlisting">import function my.package.Foo.hello</pre><p>Irrespective of the way the function is defined or imported, you
  use a function by calling it by its name, in the consequence or inside
  a semantic code block. Example:</p><pre class="programlisting">rule "using a static function"
when 
    eval( true )
then
    System.out.println( hello( "Bob" ) );
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3350"/>4.7. Type Declaration</h2></div></div></div><div class="figure"><a id="d0e3353"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/meta_data.png" align="middle" alt="meta_data"/></div></div><p class="title"><b>Figure 4.8. meta_data</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e3359"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/type_declaration.png" align="middle" alt="type_declaration"/></div></div><p class="title"><b>Figure 4.9. type_declaration</b></p></div><br class="figure-break"/><p>Type declarations have two main goals in the rules engine: to allow
  the declaration of new types, and to allow the declaration of metadata for
  types.</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Declaring new types:</strong></span> Drools works
      out of the box with plain Java objects as facts. Sometimes, however, users
      may want to define the model directly to the rules engine, without
      worrying about creating models in a lower level language like Java. At
      other times, there is a domain model already built, but eventually the
      user wants or needs to complement this model with additional entities
      that are used mainly during the reasoning process.</p></li><li><p><span class="bold"><strong>Declaring metadata:</strong></span> facts may
      have meta information associated to them. Examples of meta information
      include any kind of data that is not represented by the fact attributes
      and is consistent among all instances of that fact type. This meta
      information may be queried at runtime by the engine and used in the
      reasoning process.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3378"/>4.7.1. Declaring New Types</h3></div></div></div><p>To declare a new type, all you need to do is use the keyword
    <strong class="kw"><code>declare</code></strong>, followed by the list of fields,  and the keyword
    <strong class="kw"><code>end</code></strong>.</p><div class="example"><a id="d0e3389"/><p class="title"><b>Example 4.10. Declaring a new fact type: Address</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> Address
   number : int
   streetName : String
   city : String
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"/><p>The previous example declares a new fact type called
    <code class="code">Address</code>. This fact type will have three attributes:
    <code class="code">number</code>, <code class="code">streetName</code> and <code class="code">city</code>.
    Each attribute has a type that can be any valid
    Java type, including any other class created by the user or even other
    fact types previously declared.</p><p>For instance, we may want to declare another fact type
    <code class="code">Person</code>:</p><div class="example"><a id="d0e3419"/><p class="title"><b>Example 4.11. declaring a new fact type: Person</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : java.util.Date
    address : Address
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"/>As we can see on the previous example,
    <code class="code">dateOfBirth</code> is of type <code class="code">java.util.Date</code>,
    from the Java API, while <code class="code">address</code> is of the previously
    defined fact type Address.</p><p>You may avoid having to write the fully qualified name of a class
    every time you write it by using the <strong class="kw"><code>import</code></strong> clause, as previously
    discussed.</p><div class="example"><a id="d0e3445"/><p class="title"><b>Example 4.12. Avoiding the need to use fully qualified class names by using
        import</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><p><br class="example-break"/></p><p>When you declare a new fact type, Drools will, at compile time,
    generate bytecode that implements a Java class representing the fact
    type. The
    generated Java class will be a one-to-one Java Bean mapping of the type
    definition. So, for the previous example, the generated Java class would
    be:</p><div class="example"><a id="d0e3460"/><p class="title"><b>Example 4.13. generated Java class for the previous Person fact type
        declaration</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>public</strong></span> <span class="bold"><strong>class</strong></span> Person implements Serializable {
    <span class="bold"><strong>private</strong></span> String name;
    <span class="bold"><strong>private</strong></span> java.util.Date dateOfBirth;
    <span class="bold"><strong>private</strong></span> Address address;

    // getters and setters
    // equals/hashCode
    // toString
}
</pre></div></div><p><br class="example-break"/>Since the generated class is a simple Java class, it can
      be used transparently in the rules, like any other fact.</p><div class="example"><a id="d0e3481"/><p class="title"><b>Example 4.14. Using the declared types in rules</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>rule</strong></span> "Using a declared Type"
<span class="bold"><strong>when</strong></span> 
    $p : Person( name == "Bob" )
<span class="bold"><strong>then</strong></span>
    <span class="emphasis"><em>// Insert Mark, who is Bob's mate.</em></span>
    Person mark = new Person();
    mark.setName("Mark");
    insert( mark );
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3500"/>4.7.2. Declaring Metadata</h3></div></div></div><p>Metadata may be assigned to several different constructions in
    Drools: fact types, fact attributes and rules. Drools uses the
    at sign ('@') to introduce metadata, and it always uses the form:</p><pre class="programlisting">@<span class="emphasis"><em>metadata_key</em></span>( <span class="emphasis"><em>metadata_value</em></span> )</pre><p>The
    parenthesized <span class="emphasis"><em>metadata_value</em></span> is optional.</p><p>For instance, if you want to declare a metadata attribute like
    <code class="code">author</code>, whose value is <span class="emphasis"><em>Bob</em></span>, you
    could simply write:</p><div class="example"><a id="d0e3526"/><p class="title"><b>Example 4.15. Declaring a metadata attribute</b></p><div class="example-contents"><pre class="programlisting">@author( Bob )</pre></div></div><br class="example-break"/><p>Drools allows the declaration of any arbitrary metadata attribute,
    but some will have special meaning to the engine, while others are simply
    available for querying at runtime. Drools allows the declaration of
    metadata both for fact types and for fact attributes. Any metadata that is
    declared before the fields of a fact type are assigned to the fact type,
    while metadata declared after an attribute are assigned to that
    particular attribute.</p><div class="example"><a id="d0e3533"/><p class="title"><b>Example 4.16. Declaring metadata attributes for fact types and
      attributes</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )

    name : String <span class="emphasis"><em>@key @maxLength</em></span>( 30 )
    dateOfBirth : Date 
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"/><p>In the previous example, there are two metadata items declared for the
    fact type (<code class="code">@author</code> and <code class="code">@dateOfCreation</code>) and two 
    more defined for the name attribute (<code class="code">@key</code> and
    <code class="code">@maxLength</code>). Please note that the <code class="code">@key</code> metadata
    has no value, and so the parentheses and the value were omitted.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3571"/>4.7.3. Declaring Metadata for Existing Types</h3></div></div></div><p>Drools allows the declaration of metadata attributes for existing
    types in the same way as when declaring metadata attributes for new fact
    types. The only difference is that there are no fields in that
    declaration.</p><p>For instance, if there is a class org.drools.examples.Person, and
    one wants to declare metadata for it, it's possible to write the following
    code:</p><div class="example"><a id="d0e3578"/><p class="title"><b>Example 4.17. Declaring metadata for an existing type</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> org.drools.examples.Person

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"/><p>Instead of using the import, it is also possible to reference the
    class by its fully qualified name, but since the class will also be
    referenced in the rules, it is usually shorter to add the import and use
    the short class name everywhere.</p><div class="example"><a id="d0e3599"/><p class="title"><b>Example 4.18. Declaring metadata using the fully qualified class name</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> org.drools.examples.Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3614"/>4.7.4. Accessing Declared Types from the Application Code</h3></div></div></div><p>Declared types are usually used inside rules files, while Java
    models are used when sharing the model between rules and applications.
    Although, sometimes, the application may need to access and handle facts
    from the declared types, especially when the application is wrapping the
    rules engine and providing higher level, domain specific user interfaces
    for rules management.</p><p>In such cases, the generated classes can be handled as usual with
    the Java Reflection API, but, as we know, that usually requires a lot of
    work for small results. Therefore, Drools provides a simplified API for the
    most common fact handling the application may want to do.</p><p>The first important thing to realize is that a declared fact will
    belong to the package where it was declared. So, for instance, in the
    example below, <code class="code">Person</code> will belong to the
    <code class="code">org.drools.examples</code> package, and so the
    fully qualified name of the generated class will be
    <code class="code">org.drools.examples.Person</code>.</p><div class="example"><a id="d0e3632"/><p class="title"><b>Example 4.19. Declaring a type in the org.drools.examples package</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>package</strong></span> org.drools.examples

<span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"/><p>Declared types, as discussed previously, are generated at knowledge
    base compilation time, i.e., the application will only have access to them
    at application run time. Therefore, these classes are not available for
    direct reference from the application.</p><p>Drools then provides an interface through which users can handle
    declared types from the application code:
    <code class="code">org.drools.definition.type.FactType</code>. Through this interface, the user can
    instantiate, read and write fields in the declared fact types.</p><div class="example"><a id="d0e3654"/><p class="title"><b>Example 4.20. Handling declared fact types through the API</b></p><div class="example-contents"><pre class="programlisting">// get a reference to a knowledge base with a declared type:
KnowledgeBase kbase = ...

// get the declared FactType
FactType personType = kbase.getFactType( "org.drools.examples",
                                         "Person" );

// handle the type as necessary:
// create instances:
Object bob = personType.newInstance();

// set attributes values
personType.set( bob,
                "name",
                "Bob" );
personType.set( bob,
                "age",
                42 );

// insert fact into a session
StatefulKnowledgeSession ksession = ...
ksession.insert( bob );
ksession.fireAllRules();

// read attributes
String name = personType.get( bob, "name" );
int age = personType.get( bob, "age" );

</pre></div></div><br class="example-break"/><p>The API also includes other helpful methods, like setting all the
    attributes at once, reading values from a Map, or reading all attributes at
    once, into a Map.</p><p>Although the API is similar to Java reflection (yet much simpler to
    use), it does not use reflection underneath, relying on much more
    performant accessors implemented in generated bytecode.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3663"/>4.8. Rule</h2></div></div></div><div class="figure"><a id="d0e3666"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/rule.png" align="middle" alt="rule"/></div></div><p class="title"><b>Figure 4.10. rule</b></p></div><br class="figure-break"/><p>A rule specifies that <span class="emphasis"><em>when</em></span> a particular set
  of conditions occur, specified in the Left Hand Side (LHS), 
  <span class="emphasis"><em>then</em></span> do what is specified as a list of actions in
  the Right Hand Side (RHS). A common question from users
  is "Why use when instead of if?" "When" was chosen over "if" because "if" is
  normally part of a procedural execution flow, where, at a specific point in
  time, a condition is to be checked. In contrast, "when" indicates that
  the condition evaluation is not tied to a specific evaluation sequence
  or point in time, but that it happens continually, at any time during
  the life time of the engine; whenever the condition is met, the
  actions are executed.</p><p>A rule must have a name, unique within its rule package. If
  you define a rule twice in the same DRL it produces an error while loading.
  If you add a DRL that includes a rule name already in the package, it
  replaces the previous rule. If a rule name is to have spaces, then it
  will need to be enclosd in double quotes (it is best to always use double
  quotes).</p><p>Attributes - described below - are optional. They are best written
  one per line.</p><p>The LHS of the rule follows the <strong class="kw"><code>when</code></strong> keyword (ideally on a new
  line), similarly the RHS follows the <strong class="kw"><code>then</code></strong> keyword (again, ideally on
  a newline). The rule is terminated by the keyword <strong class="kw"><code>end</code></strong>. Rules cannot
  be nested.</p><div class="example"><a id="d0e3695"/><p class="title"><b>Example 4.21. Rule Syntax Overview</b></p><div class="example-contents"><pre class="programlisting">rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"/><div class="example"><a id="d0e3700"/><p class="title"><b>Example 4.22. A simple rule</b></p><div class="example-contents"><pre class="programlisting">rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3705"/>4.8.1. Rule Attributes</h3></div></div></div><p>Rule attributes provide a declarative way to influence the behavior
    of the rule. Some are quite simple, while others are part of complex
    subsystems such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</p><div class="figure"><a id="d0e3710"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/rule_attributes.png" align="middle" alt="rule attributes"/></div></div><p class="title"><b>Figure 4.11. rule attributes</b></p></div><br class="figure-break"/><div class="variablelist"><dl><dt><span class="term"><strong class="kw"><code>no-loop</code></strong></span></dt><dd><p>default value: false</p><p>type: Boolean</p><p>When the rule's consequence modifies a fact it may cause
	    the Rule to activate again, causing recursion. Setting no-loop
	    to true means the attempt to create the Activation for the
	    current set of data will be ignored.</p></dd><dt><span class="term"><strong class="kw"><code>ruleflow-group</code></strong></span></dt><dd><p>default value: N/A</p><p>type: String</p><p>Ruleflow is a Drools feature that lets you exercise
          control over the firing of rules. Rules that are assembled
          by the same ruleflow-group identifier fire only when 
          their group is active.</p></dd><dt><span class="term"><strong class="kw"><code>lock-on-active</code></strong></span></dt><dd><p>default value: false</p><p>type: Boolean</p><p>Whenever a ruleflow-group becomes active or an
	    agenda-group receives the focus, any rule within that
	    group that has lock-on-active set to true will not be
	    activated any more; irrespective of the origin of the
	    update, the activation of a matching rule is discarded.
	    This is a stronger version of no-loop, because the change
	    could now be caused not only by the rule itself. It's
	    ideal for calculation rules where you have a number of
	    rules that modify a fact and you don't want any rule
	    re-matching and firing again. Only when the ruleflow-group
	    is no longer active or the agenda-group loses the focus
	    those rules with lock-on-active set to true become
	    eligible again for their activations to be placed onto
	    the agenda.</p></dd><dt><span class="term"><strong class="kw"><code>salience</code></strong></span></dt><dd><p>default value : 0</p><p>type : integer</p><p>Each rule has a salience attribute that can be assigned
	    an integer number, which defaults to zero and can be
	    negative or positive. Salience is a form of priority where
	    rules with higher salience values are given higher priority
	    when ordered in the Activation queue.</p></dd><dt><span class="term"><strong class="kw"><code>agenda-group</code></strong></span></dt><dd><p>default value: MAIN</p><p>type: String</p><p>Agenda groups allow the user to partition the Agenda
          providing more execution control. Only rules in the agenda
          group that has acquired the focus are allowed to fire.</p></dd><dt><span class="term"><strong class="kw"><code>auto-focus</code></strong></span></dt><dd><p>default value: false</p><p>type: Boolean</p><p>When a rule is activated where the <code class="code">auto-focus</code>
          value is true and the rule's agenda group does
          not have focus yet, then it is given focus, allowing the rule to
          potentially fire.</p></dd><dt><span class="term"><strong class="kw"><code>activation-group</code></strong></span></dt><dd><p>default value: N/A</p><p>type: String</p><p>Rules that belong to the same activation-group, identified
          by this attribute's string value, will only fire exclusively. In
          other words, the first rule in an activation-group to fire will
          cancel the other rules' activations, i.e., stop them from firing.</p><p>Note: This used to be called Xor group, but technically it's
          not quite an Xor. You may still hear people mention Xor group;
          just swap that term in your mind with activation-group.</p></dd><dt><span class="term"><strong class="kw"><code>dialect</code></strong></span></dt><dd><p>default value: as specified by the package</p><p>type: String</p><p>possible values: "java" or "mvel"</p><p>The dialect species the language to be used for any code
	  expressions in the LHS or the RHS code block. Currently two 
          dialects are available, Java and MVEL. While the dialect can
          be specified at the package level, this attribute allows the 
          package definition to be overridden for a rule.</p></dd><dt><span class="term"><strong class="kw"><code>date-effective</code></strong></span></dt><dd><p>default value: N/A</p><p>type: String, containing a date and time definition</p><p>A rule can only activate if the current date and time is
          after date-effective attribute.</p></dd><dt><span class="term"><strong class="kw"><code>date-expires</code></strong></span></dt><dd><p>default value: N/A</p><p>type: String, containing a date and time definition</p><p>A rule cannot activate if the current date and time is 
          after the date-expires attribute.</p></dd><dt><span class="term"><strong class="kw"><code>duration</code></strong></span></dt><dd><p>default value: no default value</p><p>type: long</p><p>The duration dictates that the rule will fire after a
          specified duration, if it is still true.</p></dd></dl></div><div class="example"><a id="d0e3845"/><p class="title"><b>Example 4.23. Some attribute examples</b></p><div class="example-contents"><pre class="programlisting">rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="RuleLanguage-ConditionalElements"/>4.8.2. Left Hand Side (when) Conditional Elements</h3></div></div></div><p>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty, it is re-written as <code class="code">eval(true)</code>, which means 
    that the rule's condition is always true. It will be activated, once,
    when a new Working Memory session is created.</p><div class="figure"><a id="d0e3858"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/lhs.png" align="middle" alt="Left Hand Side"/></div></div><p class="title"><b>Figure 4.12. Left Hand Side</b></p></div><br class="figure-break"/><div class="example"><a id="d0e3864"/><p class="title"><b>Example 4.24. Rule without a Conditional Element</b></p><div class="example-contents"><pre class="programlisting">rule "no CEs"
when
then
    &lt;action&gt;*
end

# The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"/><p>Conditional elements work on one or more <span class="emphasis"><em>patterns</em></span> (which are
    described below). The most common one is <strong class="kw"><code>and</code></strong>, which is implicit when you
    have multiple patterns in the LHS of a rule that are not connected in
    any way. Note that an <strong class="kw"><code>and</code></strong> cannot have a leading declaration binding like
    <strong class="kw"><code>or</code></strong>. This is obvious, since a declaration can only
    reference a single fact, and when the <strong class="kw"><code>and</code></strong> is satisfied it matches more
    than one fact - so which fact would the declaration bind to?</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3886"/>4.8.2.1. Pattern</h4></div></div></div><p>The pattern element is the most important Conditional Element. The
      entity relationship diagram below provides an overview of the various
      parts that make up the pattern's constraints and how they work together;
      each is then covered in more detail with railroad diagrams and
      examples.</p><div class="figure"><a id="d0e3891"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/patternER.png" align="middle" alt="Pattern Entity Relationship Diagram"/></div></div><p class="title"><b>Figure 4.13. Pattern Entity Relationship Diagram</b></p></div><br class="figure-break"/><p>At the top of the ER diagram you can see that the pattern consists
      of zero or more constraints and has an optional pattern binding. The
      railroad diagram below shows the syntax for this.</p><div class="figure"><a id="d0e3899"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/pattern.png" align="middle" alt="Pattern"/></div></div><p class="title"><b>Figure 4.14. Pattern</b></p></div><br class="figure-break"/><p>In its simplest form, with no constraints, a pattern matches
      against a fact of the given type. In the following case the type
      is <code class="code">Cheese</code>, which means that the pattern will match
      against all <code class="code">Cheese</code> objects in the Working Memory.</p><p>Notice that the type need not be the actual class of some
      fact object. Patterns may refer to superclasses or even interfaces,
      thereby potentially matching facts from many different
      classes.</p><div class="example"><a id="d0e3915"/><p class="title"><b>Example 4.25. Simple Pattern</b></p><div class="example-contents"><pre class="programlisting">Cheese()</pre></div></div><br class="example-break"/><p>For referring to the matched object, use a pattern binding
      variable such as <code class="code">$c</code>. The prefixed dollar symbol ('$')
      is optional; it can
      be useful in complex rules where it helps to more easily
      differentiate between variables and fields.</p><div class="example"><a id="d0e3925"/><p class="title"><b>Example 4.26. Pattern with a binding variable</b></p><div class="example-contents"><pre class="programlisting">$c : Cheese()</pre></div></div><br class="example-break"/><p>Inside of the pattern parenthesis is where all the action happens.
      A constraint can be either a Field Constraint, Inline Eval,
      or a Constraint Group. Constraints can be separated by
      the following symbols: ',', '&amp;&amp;' or '||'.</p><div class="figure"><a id="d0e3932"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraints.png" align="middle" alt="Constraints"/></div></div><p class="title"><b>Figure 4.15. Constraints</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e3938"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraint.png" align="middle" alt="Constraint"/></div></div><p class="title"><b>Figure 4.16. Constraint</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e3944"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraintGroup.png" align="middle" alt="constraintGroup"/></div></div><p class="title"><b>Figure 4.17. constraintGroup</b></p></div><br class="figure-break"/><p>The comma character (',') is used to separate constraint groups.
      It has implicit and connective semantics.</p><div class="example"><a id="d0e3952"/><p class="title"><b>Example 4.27. Constraint Group connective ','</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</pre></div></div><p><br class="example-break"/>The above example has three constraint groups, each with a
      single constraint:</p><div class="itemizedlist"><ul><li><p>Group 1 - <code class="code">type == "stilton"</code> requires that the
          type is stilton.</p></li><li><p>Group 2 - <code class="code">price &lt; 10</code> demands a price less
          than 10.</p></li><li><p>Group 3 - <code class="code">age == "mature"</code> accepts only mature
          cheese.</p></li></ul></div><p>The '&amp;&amp;' (and) and '||' (or) constraint connectives allow
      constraint groups to have multiple constraints. Example:</p><div class="example"><a id="d0e3979"/><p class="title"><b>Example 4.28. &amp;&amp; and || Constraint Connectives</b></p><div class="example-contents"><pre class="programlisting">// Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" )
// Cheese type is "stilton" or price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" )</pre></div></div><br class="example-break"/><p>The above example has two constraint groups. The first has two
      constraints and the second has one constraint.</p><p>The connectives are evaluated in the following order, from first
      to last:</p><div class="orderedlist"><ol type="1"><li><p>&amp;&amp;</p></li><li><p>||</p></li><li><p>,</p></li></ol></div><p>It is possible to change the evaluation priority by using
      parentheses, as in any logic or mathematical expression. Example:</p><div class="example"><a id="d0e4001"/><p class="title"><b>Example 4.29. Using parentheses to change evaluation priority</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </pre></div></div><p><br class="example-break"/>In the above example, the use of parentheses evaluates the
      connective '||' before the connective '&amp;&amp;'.</p><p>Also, it is important to note that besides having the same
      semantics, the connectives '&amp;&amp;' and ',' are resolved with
      different priorities, and ',' cannot be embedded in a composite
      constraint expression.</p><div class="example"><a id="d0e4009"/><p class="title"><b>Example 4.30. Not Equivalent connectives</b></p><div class="example-contents"><pre class="programlisting">// invalid as ',' cannot be embedded in an expression:
Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" )
// valid as '&amp;&amp;' can be embedded in an expression:
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature")</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4014"/>4.8.2.1.1. Field Constraints</h5></div></div></div><p>A Field constraint specifies a restriction to be used on a
        named field; the field name can have an optional variable
        binding.</p><div class="figure"><a id="d0e4019"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/fieldConstraint.png" align="middle" alt="fieldConstraint"/></div></div><p class="title"><b>Figure 4.18. fieldConstraint</b></p></div><br class="figure-break"/><p>There are three types of restrictions: Single Value Restriction,
        Compound Value Restriction, and Multi Restriction.</p><div class="figure"><a id="d0e4027"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/restriction.png" align="middle" alt="restriction"/></div></div><p class="title"><b>Figure 4.19. restriction</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4033"/>4.8.2.1.1.1. JavaBeans as facts</h6></div></div></div><p>A field is derived from an accessible method of the object.
          If your model
          objects follow the Java Bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods, where these methods take no
          arguments, and return something. Within patterns, fields can be
          accessed using the bean naming convention, so that "getType" would
          be accessed as "type". Drools uses the standard JDK Introspector
          class to do this mapping.</p><p>For example, referring to our Cheese class, the pattern
          <code class="code">Cheese(type == "brie")</code> applies the getType() method
          to a Cheese instance. If a field name cannot be found, the
          compiler will resort to using the name as a method without
          arguments. Thus, the method <code class="code">toString()</code> is called due to a
          constraint <code class="code">Cheese(toString == "cheddar")</code>. In this
          case, you use the full name of the method with correct
          capitalization, but still without parentheses. Do
          please make sure that you are accessing methods that take no
          parameters, and that are in fact <span class="emphasis"><em>accessors</em></span>
          which don't change the state of the object in a way that may effect the rules.
          Remember that the rule engine effectively caches the results of its
          matching in between invocations to make it faster.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4052"/>4.8.2.1.1.2. Values</h6></div></div></div><p>The field constraints can take a number of values; including
          literal, qualifiedIdentifier (enum), variable and
          returnValue.</p><div class="figure"><a id="d0e4057"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/literal.png" align="middle" alt="literal"/></div></div><p class="title"><b>Figure 4.20. literal</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e4063"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/qualifiedIdentifier.png" align="middle" alt="qualifiedIdentifier"/></div></div><p class="title"><b>Figure 4.21. qualifiedIdentifier</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e4069"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/identifier.png" align="middle" alt="variable"/></div></div><p class="title"><b>Figure 4.22. variable</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e4075"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/returnValue.png" align="middle" alt="returnValue"/></div></div><p class="title"><b>Figure 4.23. returnValue</b></p></div><br class="figure-break"/><p>You can do checks against fields that are or may be null, using
          '==' and '!=' as you would expect, and the literal <strong class="kw"><code>null</code></strong> keyword, as
          in <code class="code">Cheese(type != null)</code>, where the evaluator will not
          throw an exception and return true if the value is null.
          Type coercion is always attempted if the field and the value are
          of different types; exceptions will be thrown if a bad coercion is
          attempted. For instance, if "ten" is provided as a string in a numeric
          evaluator, an exception is thrown, whereas "10" would coerce to a
	  numeric 10. Coercion is
          always in favor of the field type and not the value type.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4089"/>4.8.2.1.1.3. Single Value Restriction</h6></div></div></div><div class="figure"><a id="d0e4092"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/singleValueRestriction.png" align="middle" alt="singleValueRestriction"/></div></div><p class="title"><b>Figure 4.24. singleValueRestriction</b></p></div><br class="figure-break"/><p>A Single Value Restriction is a binary relation, applying a binary
          operator to the field value and another value, which may be a literal,
          a variable, a parenthesized expression ("return value"), or a qualified
          identifier, i.e., an enum constant.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4100"/>4.8.2.1.1.3.1. Operators</h6></div></div></div><div class="figure"><a id="d0e4103"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/operator.png" align="middle" alt="Operators"/></div></div><p class="title"><b>Figure 4.25. Operators</b></p></div><br class="figure-break"/><p>The operators '==' and '!=' are valid for all types. Other
            relational operatory may be used whenever the type values are
            ordered; for date fields, '&lt;' means "before". The pair <strong class="kw"><code>matches</code></strong> and
            <strong class="kw"><code>not matches</code></strong> is only applicable to string fields, <strong class="kw"><code>contains</code></strong> and
            <strong class="kw"><code>not contains</code></strong> require the field to be of some  Collection type.
            Coercion to the correct value for the evaluator and the field will be 
            attempted, as mentioned in the "Values" section.</p><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4123"/>The Operator <strong class="kw"><code>matches</code></strong></h6></div></div></div><p>Matches a field against any valid Java <a id="d0e4130" class="indexterm"/>Regular Expression. Typically that regexp is a
              string literal, but variables that resolve to a valid regexp are also
              allowed. It is important to note that, <span class="emphasis"><em>different from
              Java</em></span>, within regular expressions written as string literals
              <span class="emphasis"><em>you don't need to escape '\'</em></span>. Example:</p><div class="example"><a id="d0e4140"/><p class="title"><b>Example 4.31. Regular Expression Constraint</b></p><div class="example-contents"><pre class="programlisting">Cheese( type matches "(Buffalo)?\S*Mozarella" )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4145"/>The Operator <strong class="kw"><code>not matches</code></strong></h6></div></div></div><p>The operator returns true if the string does not match the
              regular expression. The same rules apply as for the <strong class="kw"><code>matches</code></strong> operator.
              Example:</p><div class="example"><a id="d0e4155"/><p class="title"><b>Example 4.32. Regular Expression Constraint</b></p><div class="example-contents"><pre class="programlisting">Cheese( type not matches "(Buffulo)?\S*Mozarella" )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4160"/>The Operator <strong class="kw"><code>contains</code></strong></h6></div></div></div><p>The operator <strong class="kw"><code>contains</code></strong> is used to check whether a
              field that is a <a id="d0e4170" class="indexterm"/>Collection or array contains the specified
              value.</p><div class="example"><a id="d0e4174"/><p class="title"><b>Example 4.33. Contains with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4179"/>The Operator <strong class="kw"><code>not contains</code></strong></h6></div></div></div><p>The operator <strong class="kw"><code>not contains</code></strong> is used to check whether a
              field that is a <a id="d0e4189" class="indexterm"/>Collection or array does <span class="emphasis"><em>not</em></span> contain the
              specified value.</p><div class="example"><a id="d0e4196"/><p class="title"><b>Example 4.34. Literal Constraint with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</pre></div></div><br class="example-break"/><div class="blockquote"><blockquote class="blockquote"><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For backward compatibility, the <strong class="kw"><code>excludes</code></strong>
                  operator is supported as a synonym for <strong class="kw"><code>not contains</code></strong>.</p></div></blockquote></div></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4211"/>The Operator <strong class="kw"><code>memberOf</code></strong></h6></div></div></div><p>The operator <strong class="kw"><code>memberOf</code></strong> is used to check whether a field is a
              member of a collection or array; that collection must be a variable.</p><div class="example"><a id="d0e4221"/><p class="title"><b>Example 4.35. Literal Constraint with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese memberOf $matureCheeses )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4226"/>The Operator <strong class="kw"><code>not memberOf</code></strong></h6></div></div></div><p>The operator <strong class="kw"><code>not memberOf</code></strong> is used to check whether a
              field is not a
              member of a collection or array; that collection must be a variable.</p><div class="example"><a id="d0e4236"/><p class="title"><b>Example 4.36. Literal Constraint with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese not memberOf $matureCheeses )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4241"/>The Operator <strong class="kw"><code>soundslike</code></strong></h6></div></div></div><p>This operator is similar to <strong class="kw"><code>matches</code></strong>, but it checks
              whether a word has almost the same sound (using English pronounciation)
              as the given value. This is based on the Soundex algorithm
              (see <code class="code">http://en.wikipedia.org/wiki/Soundex</code>).</p><div class="example"><a id="d0e4254"/><p class="title"><b>Example 4.37. Test with soundslike</b></p><div class="example-contents"><pre class="programlisting">// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4259"/>4.8.2.1.1.3.2. Literal Restrictions</h6></div></div></div><p>Literal restrictions are the simplest form of restrictions
            and evaluate a field against a specified literal, which may be
            numeric or a date, a string or a boolean.</p><div class="figure"><a id="d0e4264"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/literalRestriction.png" align="middle" alt="literalRestriction"/></div></div><p class="title"><b>Figure 4.26. literalRestriction</b></p></div><br class="figure-break"/><p>Literal Restrictions using the operator '==' provide for
            faster execution as we can index using hashing to improve performance.</p><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4272"/>Numeric</h6></div></div></div><p>All standard Java numeric primitives are supported.</p><div class="example"><a id="d0e4277"/><p class="title"><b>Example 4.38. Numeric Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( quantity == 5 )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4282"/>Date</h6></div></div></div><p>The date format "dd-mmm-yyyy" is supported by default. You
              can customize this by providing an alternative date format mask
              as the System property named <code class="code">drools.dateformat</code>. If more control
              is required, use the inline-eval constraint.</p><div class="example"><a id="d0e4290"/><p class="title"><b>Example 4.39. Date Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( bestBefore &lt; "27-Oct-2009" )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4295"/>String</h6></div></div></div><p>Any valid Java String is allowed.</p><div class="example"><a id="d0e4300"/><p class="title"><b>Example 4.40. String Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( type == "stilton" )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4305"/>Boolean</h6></div></div></div><p>Only <code class="code">true</code> or <code class="code">false</code> can be used; 0 and 1 are not
              acceptable. A boolean field alone (as in <code class="code">Cheese( smelly )</code> is
              not permitted; you must compare this to a boolean literal.</p><div class="example"><a id="d0e4319"/><p class="title"><b>Example 4.41. Boolean Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == true )</pre></div></div><br class="example-break"/></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4324"/>Qualified Identifier</h6></div></div></div><p>Enums can be used as well, both JDK 1.4 and 5 style
              enums are supported. For the latter you must be executing on a
              JDK 5 environment.</p><div class="example"><a id="d0e4329"/><p class="title"><b>Example 4.42. Boolean Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == SomeClass.TRUE )</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4334"/>4.8.2.1.1.3.3. Bound Variable Restriction</h6></div></div></div><div class="figure"><a id="d0e4337"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/variableRestriction.png" align="middle" alt="variableRestriction"/></div></div><p class="title"><b>Figure 4.27. variableRestriction</b></p></div><br class="figure-break"/><p>Variables can be bound to facts and their fields and then
            used in subsequent Field Constraints. A bound variable is called a
            <a id="d0e4345" class="indexterm"/>Declaration. Valid operators are determined by the
            type of the field being constrained; coercion will be attempted
            where possible. Bound Variable Restrictions using the operator '=='
            provide for very fast execution as we can use hashing to
            improve performance.</p><div class="example"><a id="d0e4349"/><p class="title"><b>Example 4.43. Bound Field using the operator '=='</b></p><div class="example-contents"><pre class="programlisting">Person( likes : favouriteCheese )
Cheese( type == likes )</pre></div></div><br class="example-break"/><p>Here, <code class="code">likes</code> is the variable that is bound in
              its declaration to the field <code class="code">favouriteCheese</code> of any
              matching Person instance. It is then used to constrain the type of 
              Cheese in the following pattern. Any valid Java variable name can 
              be used, and it may be prefixed with a '$', which you will often
              see used to help differentiate declarations from fields. The example
              below shows a declaration for <code class="code">$stilton</code>, bound to the
              object matching the first pattern and used with a <code class="code">contains</code>
              operator. - Note the optional use of '$'.</p><div class="example"><a id="d0e4368"/><p class="title"><b>Example 4.44. Bound Fact using 'contains' operator</b></p><div class="example-contents"><pre class="programlisting">$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4373"/>4.8.2.1.1.3.4. Return Value Restriction</h6></div></div></div><div class="figure"><a id="d0e4376"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/returnValueRestriction.png" align="middle" alt="returnValueRestriction"/></div></div><p class="title"><b>Figure 4.28. returnValueRestriction</b></p></div><br class="figure-break"/><p>A <a id="d0e4384" class="indexterm"/>Return Value restriction is a parenthesized expression
            composed from literals, any valid Java primitive or object, previously
            bound variables, function calls, and operators. Functions used in a
            Return Value must return results that do not depend on time.</p><div class="example"><a id="d0e4388"/><p class="title"><b>Example 4.45. Return Value Restriction</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4393"/>4.8.2.1.1.4. Compound Value Restriction</h6></div></div></div><p>The compound value restriction is used where there is more
          than one possible value to match. Currently only the <strong class="kw"><code>in</code></strong> and
          <strong class="kw"><code>not in</code></strong> evaluators support this. The second operand of this operator must be
          a comma-separated list of values, enclosed in parentheses. Values may
          be given as variables, literals, return values or qualified identifiers.
          Both evaluators are actually "syntactic sugar", internally rewritten as
          a list of multiple restrictions using the operators '!=' and '=='.</p><div class="figure"><a id="d0e4404"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/compoundValueRestriction.png" align="middle" alt="compoundValueRestriction"/></div></div><p class="title"><b>Figure 4.29. compoundValueRestriction</b></p></div><br class="figure-break"/><p/><div class="example"><a id="d0e4411"/><p class="title"><b>Example 4.46. Compound Restriction using "in"</b></p><div class="example-contents"><pre class="programlisting">Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4416"/>4.8.2.1.1.5. Multi Restriction</h6></div></div></div><p>Multi restriction allows you to place more than one
          restriction on a field using the restriction connectives
          '&amp;&amp;' or '||'. Grouping via parentheses is permitted,
          resulting in a recursive syntax pattern.</p><div class="figure"><a id="d0e4421"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/multiRestriction.png" align="middle" alt="multiRestriction"/></div></div><p class="title"><b>Figure 4.30. multiRestriction</b></p></div><br class="figure-break"/><div class="figure"><a id="d0e4427"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/restrictionGroup.png" align="middle" alt="restrictionGroup"/></div></div><p class="title"><b>Figure 4.31. restrictionGroup</b></p></div><br class="figure-break"/><p/><div class="example"><a id="d0e4434"/><p class="title"><b>Example 4.47. Multi Restriction</b></p><div class="example-contents"><pre class="programlisting">// Simple multi restriction using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )
// Complex multi restriction using groupings of multi restrictions
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )
// Mixing muti restrictions with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4439"/>4.8.2.1.2. Inline Eval Constraints</h5></div></div></div><div class="figure"><a id="d0e4442"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/inlineEvalConstraint.png" align="middle" alt="Inline Eval Expression"/></div></div><p class="title"><b>Figure 4.32. Inline Eval Expression</b></p></div><br class="figure-break"/><p>An <a id="d0e4450" class="indexterm"/>inline eval constraint can use any valid dialect
        expression as long as it results to a primitive boolean. The expression
        must be constant over time. Any previously bound variable, from the current
        or previous pattern, can be used; autovivification is also used to
        auto-create field binding variables. When an identifier is found that
        is not a current variable, the builder looks to see if the identifier
        is a field on the current object type, if it is, the field binding
	is auto-created as a variable of the same name. This is called
	autovivification of field variables inside of inline evals.</p><p>This example will find all male-female pairs where the
        male is 2 years older than the female; the variable <code class="code">age</code>
        is auto-created in the second pattern by the autovivification process.</p><div class="example"><a id="d0e4459"/><p class="title"><b>Example 4.48. Return Value operator</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' )
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4464"/>4.8.2.1.3. Nested Accessors</h5></div></div></div><p>Drools permits <span class="emphasis"><em>nested accessors</em></span> in in the field
        constraints using the MVEL accessor graph notation. Field constraints
        involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the
        Working Memory is not aware of any of the nested values, and does not
        know when they change; they should be considered immutable while any
        of their parent references are inserted into the Working Memory. If
        you wish to modify a nested value you should remove the parent objects
        first and re-assert afterwards. If you only have a single parent at
        the root of the graph, when in the MVEL dialect, you can use the
        <strong class="kw"><code>modify</code></strong> construct and its block setters to write the nested accessor
        assignments while retracting and inserting the the root parent object
        as required. Nested accessors can be used on either side of the operator
        symbol.</p><div class="example"><a id="d0e4475"/><p class="title"><b>Example 4.49. Nested Accessors</b></p><div class="example-contents"><pre class="programlisting">// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age )</pre><p>This is internally rewriten as an MVEL inline eval:</p><pre class="programlisting">// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) </pre></div></div><br class="example-break"/><p class="remark"><i><span class="remark"><span class="bold"><strong>Note: </strong></span>Nested accessors have a much
        greater performance cost than direct field accesses, so use them carefully.</span></i></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4488"/>4.8.2.2. Conditional Element <strong class="kw"><code>and</code></strong></h4></div></div></div><p>The Conditional Element <strong class="kw"><code>and</code></strong> is used to group other Conditional
      Elements into a logical conjunction. The root element of the LHS is an
      implicit prefix <strong class="kw"><code>and</code></strong> and doesn't need to be specified. Drools supports
      both prefix <strong class="kw"><code>and</code></strong> and infix <strong class="kw"><code>and</code></strong>, but prefix is the preferred option
      as its implicit grouping avoids confusion.</p><div class="figure"><a id="d0e4507"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/prefixAnd.png" align="middle" alt="prefixAnd"/></div></div><p class="title"><b>Figure 4.33. prefixAnd</b></p></div><br class="figure-break"/><p/><div class="example"><a id="d0e4514"/><p class="title"><b>Example 4.50. prefixAnd</b></p><div class="example-contents"><pre class="programlisting">(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e4519"/><p class="title"><b>Example 4.51. implicit root prefixAnd</b></p><div class="example-contents"><pre class="programlisting">when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</pre></div></div><br class="example-break"/><p>Infix <strong class="kw"><code>and</code></strong> is supported along with explicit grouping with
      parentheses, should it be needed. The symbol '&amp;&amp;', as an
      alternative to <strong class="kw"><code>and</code></strong>, is deprecated although it is still supported in
      the syntax for legacy support reasons.</p><div class="figure"><a id="d0e4532"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/infixAnd.png" align="middle" alt="infixAnd"/></div></div><p class="title"><b>Figure 4.34. infixAnd</b></p></div><br class="figure-break"/><div class="example"><a id="d0e4538"/><p class="title"><b>Example 4.52. infixAnd</b></p><div class="example-contents"><pre class="programlisting">//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )
//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4543"/>4.8.2.3. Conditional Element <strong class="kw"><code>or</code></strong></h4></div></div></div><p>The Conditional Element <strong class="kw"><code>or</code></strong> is used to group other Conditional
      Elements into a logical disjunction. Drools supports both prefix <strong class="kw"><code>or</code></strong> and
      infix <strong class="kw"><code>or</code></strong>, but prefix is the preferred option as its implicit grouping
      avoids confusion. The behavior of the Conditional Element <strong class="kw"><code>or</code></strong> is different
      from the connective '||' for constraints and restrictions in field
      constraints. The engine actually has no understanding of the Conditional
      Element <strong class="kw"><code>or</code></strong>; instead, via a number of different logic transformations,
      a rule with <strong class="kw"><code>or</code></strong> is rewritten as a number of subrules. This process ultimately
      results in a rule that has a single <strong class="kw"><code>or</code></strong> as the root node and one subrule
      for each of its CEs. Each subrule can activate and fire like any normal rule;
      there is no special behavior or interaction between these subrules. - This can
      be most confusing to new rule authors.</p><div class="figure"><a id="d0e4571"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/prefixOr.png" align="middle" alt="prefixOr"/></div></div><p class="title"><b>Figure 4.35. prefixOr</b></p></div><br class="figure-break"/><div class="example"><a id="d0e4577"/><p class="title"><b>Example 4.53. prefixOr</b></p><div class="example-contents"><pre class="programlisting">(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</pre></div></div><br class="example-break"/><p>Infix <strong class="kw"><code>or</code></strong> is supported along with explicit grouping with
      parentheses, should it be needed. The symbol '||', as an alternative to
      <strong class="kw"><code>or</code></strong>, is deprecated although it is still supported in the syntax for
      legacy support reasons.</p><div class="figure"><a id="d0e4590"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/infixOr.png" align="middle" alt="infixOr"/></div></div><p class="title"><b>Figure 4.36. infixOr</b></p></div><br class="figure-break"/><div class="example"><a id="d0e4596"/><p class="title"><b>Example 4.54. infixOr</b></p><div class="example-contents"><pre class="programlisting">//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )
//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</pre></div></div><br class="example-break"/><p>The Conditional Element <strong class="kw"><code>or</code></strong> also allows for optional pattern
      binding. This means that each resulting subrule will bind its pattern to
      the pattern binding. Each pattern must be bound separately,
      using eponymous variables:</p><div class="example"><a id="d0e4606"/><p class="title"><b>Example 4.55. or with binding</b></p><div class="example-contents"><pre class="programlisting">(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</pre></div></div><br class="example-break"/><p>Since the conditional element <strong class="kw"><code>or</code></strong> results in multiple subrule
      generation, one for each possible logically outcome, the example above
      would result in the internal generation of two rules. These two rules
      work independently within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting.</p><p>The best way to think of the conditional element <strong class="kw"><code>or</code></strong> is as a
      shortcut for generating two or more similar rules. When you think
      of it that
      way, it's clear that for a single rule there could be multiple
      activations if two or more terms of the disjunction are true.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4621"/>4.8.2.4. Conditional Element <strong class="kw"><code>eval</code></strong></h4></div></div></div><div class="figure"><a id="d0e4626"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/eval.png" align="middle" alt="eval"/></div></div><p class="title"><b>Figure 4.37. eval</b></p></div><br class="figure-break"/><p>The CE <strong class="kw"><code>eval</code></strong> is essentially a catch-all which allows any semantic code
      (that returns a primitive boolean) to be executed. This code can refer to
      variables that were bound in the LHS of the rule, and functions in the
      rule package. Overuse of eval reduces the declarativeness of your rules
      and can result in a poorly performing engine. While <strong class="kw"><code>eval</code></strong> can be used
      anywhere in the patterns, the best practice is to add it as the last
      conditional element in the LHS of a rule.</p><p>Evals cannot be indexed and thus are not as efficient as  Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</p><p>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</p><div class="example"><a id="d0e4644"/><p class="title"><b>Example 4.56. eval</b></p><div class="example-contents"><pre class="programlisting">p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
// call function isValid in the LHS
eval( isValid(p1, p2) )</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4649"/>4.8.2.5. Conditional Element <strong class="kw"><code>not</code></strong></h4></div></div></div><div class="figure"><a id="d0e4654"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/not.png" align="middle" alt="not"/></div></div><p class="title"><b>Figure 4.38. not</b></p></div><br class="figure-break"/><p>The CE <strong class="kw"><code>not</code></strong> is first order logic's non-existential quantifier and checks
      for the non-existence of something in the Working Memory. Think of "not"
      as meaning "there must be none of...".</p><p>The keyword <strong class="kw"><code>not</code></strong> be followed by parentheses around the CEs
      that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</p><div class="example"><a id="d0e4670"/><p class="title"><b>Example 4.57. No Busses</b></p><div class="example-contents"><pre class="programlisting">not Bus()</pre></div></div><br class="example-break"/><div class="example"><a id="d0e4675"/><p class="title"><b>Example 4.58. No red Busses</b></p><div class="example-contents"><pre class="programlisting">// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <strong class="kw"><code>and</code></strong> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4683"/>4.8.2.6. Conditional Element <strong class="kw"><code>exists</code></strong></h4></div></div></div><div class="figure"><a id="d0e4688"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/exists.png" align="middle" alt="exists"/></div></div><p class="title"><b>Figure 4.39. exists</b></p></div><br class="figure-break"/><p>The CE <strong class="kw"><code>exists</code></strong> is first order logic's existential quantifier and checks
      for the existence of something in the Working Memory. Think of "exists" as
      meaning "there is at least one..". It is different from just having the pattern
      on its own, which is more like saying "for each one of...". If you use
      <strong class="kw"><code>exists</code></strong> with a pattern, the rule will only activate at most once, regardless
      of how much data there is in working memory that matches the
      condition inside of the <strong class="kw"><code>exists</code></strong> pattern. Since only the existence matters, 
      no bindings will be established.</p><p>The keyword <strong class="kw"><code>exists</code></strong> must be followed by parentheses around the
      CEs that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</p><div class="example"><a id="d0e4710"/><p class="title"><b>Example 4.59. At least one Bus</b></p><div class="example-contents"><pre class="programlisting">exists Bus()</pre></div></div><br class="example-break"/><div class="example"><a id="d0e4715"/><p class="title"><b>Example 4.60. At least one red Bus</b></p><div class="example-contents"><pre class="programlisting">exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <strong class="kw"><code>and</code></strong>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4723"/>4.8.2.7. Conditional Element <strong class="kw"><code>forall</code></strong></h4></div></div></div><div class="figure"><a id="d0e4728"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/forall.png" align="middle" alt="forall"/></div></div><p class="title"><b>Figure 4.40. forall</b></p></div><br class="figure-break"/><p>The Conditional Element <strong class="kw"><code>forall</code></strong> completes the First Order Logic
      support in Drools. The Conditional Element <strong class="kw"><code>forall</code></strong> evaluates to true
      when all facts that match the first pattern match all the remaining
      patterns. Example:</p><pre class="programlisting">rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</pre><p>In the above rule, we "select" all Bus objects whose type is
      "english". Then, for each fact that matches this pattern we evaluate the
      following patterns and if they match, the forall CE will evaluate to
      true.</p><p>To state that all facts of a given type in the working memory must
      match a set of constraints, <strong class="kw"><code>forall</code></strong> can be written with a single pattern
      for simplicity. Example:</p><div class="example"><a id="d0e4752"/><p class="title"><b>Example 4.61. Single Pattern Forall</b></p><div class="example-contents"><pre class="programlisting">rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</pre></div></div><p><br class="example-break"/></p><p>Another example shows multiple patterns inside the <strong class="kw"><code>forall</code></strong>:</p><div class="example"><a id="d0e4762"/><p class="title"><b>Example 4.62. Multi-Pattern Forall</b></p><div class="example-contents"><pre class="programlisting">rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</pre></div></div><p><br class="example-break"/></p><p>Forall can be nested inside other CEs for complete expressiveness.
      For instance, <strong class="kw"><code>forall</code></strong> can be used inside a <strong class="kw"><code>not</code></strong> CE. Note that only single
      patterns have optional parentheses, so that with a nested forall parentheses
      must be used :</p><div class="example"><a id="d0e4775"/><p class="title"><b>Example 4.63. Combining Forall with Not CE</b></p><div class="example-contents"><pre class="programlisting">rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</pre></div></div><p><br class="example-break"/></p><p>As a side note, <code class="code">not( forall( p1 p2 p3...))</code> is
	equivalent to writing:</p><pre class="programlisting">not(p1 and not(and p2 p3...))</pre><p>Also, it is important to note that <strong class="kw"><code>forall</code></strong> is a <span class="emphasis"><em>scope
      delimiter</em></span>. Therefore, it can use any previously bound
      variable, but no variable bound inside it will be available for use
      outside of it.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4795"/>4.8.2.8. Conditional Element <strong class="kw"><code>from</code></strong></h4></div></div></div><div class="figure"><a id="d0e4800"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/from.png" align="middle" alt="from"/></div></div><p class="title"><b>Figure 4.41. from</b></p></div><br class="figure-break"/><p>The Conditional Element <strong class="kw"><code>from</code></strong> enables users to specify an arbitrary
      source for data to be matched by LHS patterns. This
      allows the engine to reason over data not in the Working Memory. The data
      source could be a sub-field on a bound variable or the results of a method
      call. It is a powerful construction that allows out of the box
      integration with other application components and frameworks. One common
      example is the integration with data retrieved on-demand from databases
      using hibernate named queries.</p><p>The expression used to define the object source is any expression
      that follows regular MVEL syntax. Therefore, it allows you to easily use
      object property navigation, execute method calls and access maps and
      collections elements.</p><p>Here is a simple example of reasoning and binding on another
      pattern sub-field:</p><pre class="programlisting">rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</pre><p>With all the flexibility from the new expressiveness in the Drools
      engine you can slice and dice this problem many ways. This is the same
      but shows how you can use a graph notation with the 'from':</p><pre class="programlisting">rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</pre><p>Previous examples were evaluations using a single pattern. The
      CE <strong class="kw"><code>from</code></strong> also support object sources that return a collection of objects.
      In that case, <strong class="kw"><code>from</code></strong> will iterate  over all objects in the
      collection and try to match each of them individually. For instance, if
      we want a rule that applies 10% discount to each item in an order, we
      could do:</p><pre class="programlisting">rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</pre><p>The above example will cause the rule to fire once for each item
      whose value is greater than 100 for each given order.</p><p>You must take caution, however, when using <strong class="kw"><code>from</code></strong>, 
      especially in conjunction with the
      <strong class="kw"><code>lock-on-active</code></strong> rule attribute 
      as it may produce unexpected results. Consider the example provided earlier, but
      now slightly modified as follows:</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>
	  In the above example, persons in Raleigh, NC should be assigned to sales region 1 and 
	  receive a discount; i.e., you would expect both rules to activate and fire. Instead you
	  will find that only the second rule fires.</p><p>If you were to turn on the audit log, you would also see that when the second rule fires,
	  it deactivates the first rule. Since the rule attribute <strong class="kw"><code>lock-on-active</code></strong>
	  prevents a rule from creating new activations when a set of facts change, the first rule fails to
	  reactivate. Though the set of facts have not changed, the use of
	  <strong class="kw"><code>from</code></strong> returns a new fact for all intents and purposes each time
	  it is evaluated. 
	  </p><p>First, it's important to review why you would use the above pattern. You may have
	  many rules across different rule-flow groups. When rules modify working memory and other rules
	  downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated,
          the use of <strong class="kw"><code>modify</code></strong> is critical. You don't, however, want other rules in the
          same rule-flow group to place activations on one another recursively. In this case,
          the <strong class="kw"><code>no-loop</code></strong> attribute is ineffective, as it would only prevent a rule from
          activating itself recursively. Hence, you resort to <strong class="kw"><code>lock-on-active</code></strong>.</p><p>
	  There are several ways to address this issue:</p><div class="itemizedlist"><ul><li><p>Avoid the use of <strong class="kw"><code>from</code></strong> when you can assert all facts into working memory 
          or use nested object references in your constraint expressions (shown below).</p></li><li><p>Place the variable assigned used in the modify block as the last sentence
          in your condition (LHS).</p></li><li><p>Avoid the use of <strong class="kw"><code>lock-on-active</code></strong> when you
          can explicitly manage how rules within the same rule-flow group place
          activations on one another (explained below).</p></li></ul></div><p>The preferred solution is to minimize use of <strong class="kw"><code>from</code></strong> when you can assert
        all your facts into working memory directly. In the example above, both the 
        Person and Address instance can be asserted into working memory. In this case,
        because the graph is fairly simple, an even easier solution is to modify your
        rules as follows:</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>Now, you will find that both rules fire as expected. However, it is not 
	  always possible to access nested facts as above. Consider an example where a Person
	  holds one or more Addresses and you wish to use an existential quantifier to
	  match people with at least one address that meets certain conditions. 
	  In this case, you would have to resort to 
	  the use of <strong class="kw"><code>from</code></strong> to reason over the collection.</p><p>
	  There are several ways to use <strong class="kw"><code>from</code></strong> to achieve this and not all of them
          exhibit an issue with the use of <strong class="kw"><code>lock-on-active</code></strong>.
          For example, the following use of <strong class="kw"><code>from</code></strong> causes both rules to fire as
          expected:</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>However, the following slightly different approach does exhibit the problem:</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} #Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} #Modify assessment in a modify block
end</pre><p>In the above example, the $addresses variable is returned from the
	  use of <strong class="kw"><code>from</code></strong>. The example also introduces
	  a new object, assessment, to highlight one possible solution in this case.
	  If the $assessment variable assigned in the condition (LHS) is moved to the last condition
	  in each rule, both rules fire as expected.
	  </p><p>
	  Though the above examples demonstrate how to combine the use of <strong class="kw"><code>from</code></strong>
	  with <strong class="kw"><code>lock-on-active</code></strong> where no loss of rule activations occurs, they
          carry the drawback of placing a dependency
          on the order of conditions on the LHS. In addition, the solutions present
          greater complexity for the rule author in terms of keeping track of
	  which conditions may create issues.</p><p>A better alternative is to 
	  assert more facts into working memory. In this case, a person's addresses
	  may be asserted into working memory and the use of <strong class="kw"><code>from</code></strong>
	  would not be necessary.</p><p>There are cases, however, where asserting all data into working memory is not
	  practical and we need to find other solutions. Another option is to reevaluate the
	  need for <strong class="kw"><code>lock-on-active</code></strong>. An alternative to <strong class="kw"><code>lock-on-active</code></strong> is to 
	  directly manage how rules within the same rule-flow group activate one another
	  by including conditions in each rule that prevent rules from activating
          each other recursively when working memory is modified. For example, in the 
          case above where a discount is applied to citizens of Raleigh, a condition may
          be added to the rule that checks whether the discount has already been applied.
          If so, the rule does not activate.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4943"/>4.8.2.9. Conditional Element <strong class="kw"><code>collect</code></strong></h4></div></div></div><div class="figure"><a id="d0e4948"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/collect.png" align="middle" alt="collect"/></div></div><p class="title"><b>Figure 4.42. collect</b></p></div><br class="figure-break"/><p>The Conditional Element <strong class="kw"><code>collect</code></strong> allows rules to reason over a collection
      of objects obtained from the given source or from the working memory. In First 
      Oder Logic terms this is the cardinality quantifier. A simple example:</p><pre class="programlisting">import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</pre><p>In the above example, the rule will look for all pending alarms in
      the working memory for each given system and group them in ArrayLists.
      If 3 or more alarms are found for a given system, the rule will
      fire.</p><p>The result pattern of <strong class="kw"><code>collect</code></strong> can
      be any concrete class that implements the <code class="code">java.util.Collection</code>
      interface
      and provides a default no-arg public constructor. This means that you can use
      Java collections like ArrayList, LinkedList, HashSet, etc., or
      your own class, as long as it implements the <code class="code">java.util.Collection</code>
      interface and provide a default no-arg public constructor.</p><p>Both source and result patterns can be constrained as any other
      pattern.</p><p>Variables bound before the <strong class="kw"><code>collect</code></strong> CE are in the scope of both source and
      result patterns and therefore you can use them to constrain both your
      source and result patterns. But note that <strong class="kw"><code>collect</code></strong> is a scope delimiter for
      bindings, so that any binding made inside of it is not available for use
      outside of it.</p><p>Collect accepts nested <strong class="kw"><code>from</code></strong> CEs. The following example is a valid
      use of "collect":</p><pre class="programlisting">import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4991"/>4.8.2.10. Conditional Element <strong class="kw"><code>accumulate</code></strong></h4></div></div></div><div class="figure"><a id="d0e4996"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/accumulate.png" align="middle" alt="accumulate"/></div></div><p class="title"><b>Figure 4.43. accumulate</b></p></div><br class="figure-break"/><p>The Conditional Element <strong class="kw"><code>accumulate</code></strong> is a more flexible and powerful
      form of <strong class="kw"><code>collect</code></strong>, the sense that it can be used to do what <strong class="kw"><code>collect</code></strong> does
      and also achieve things that the CE <strong class="kw"><code>collect</code></strong> is not capable of doing.
      Basically, what it does is that it allows a rule to iterate
      over a collection of objects, executing custom actions for each of the
      elements, and at the end it returns a result object.</p><p>The general syntax of the <strong class="kw"><code>accumulate</code></strong> CE is:</p><pre class="programlisting"><em class="replaceable"><code>&lt;result pattern&gt;</code></em> <strong class="kw"><code>from accumulate(</code></strong> <em class="replaceable"><code>&lt;source pattern&gt;</code></em><strong class="kw"><code>,</code></strong>
                                  <strong class="kw"><code>init(</code></strong> <em class="replaceable"><code>&lt;init code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>action(</code></strong> <em class="replaceable"><code>&lt;action code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>reverse(</code></strong> <em class="replaceable"><code>&lt;reverse code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>result(</code></strong> <em class="replaceable"><code>&lt;result expression&gt;</code></em> <strong class="kw"><code>) )</code></strong>
</pre><p>The meaning of each of the elements is the following:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>&lt;source pattern&gt;</em></span>: the
          source pattern is a regular pattern that the engine will try to
          match against each of the source objects.</p></li><li><p><span class="emphasis"><em>&lt;init code&gt;</em></span>: this is a
          semantic block of code in the selected dialect that will be executed
          once for each tuple, before iterating over the source
          objects.</p></li><li><p><span class="emphasis"><em>&lt;action code&gt;</em></span>: this is
          a semantic block of code in the selected dialect that will be
          executed for each of the source objects.</p></li><li><p><span class="emphasis"><em>&lt;reverse code&gt;</em></span>: this is
          an optional semantic block of code in the selected dialect that if
          present will be executed for each source object that no longer
          matches the source pattern. The objective of this code block is to
          undo any calculation done in the <span class="emphasis"><em>&lt;action code&gt;</em></span> block, so
          that the engine can do decremental calculation when a source object
          is modified or retracted, hugely improving performance of these
          operations.</p></li><li><p><span class="emphasis"><em>&lt;result expression&gt;</em></span>:
          this is a semantic expression in the selected dialect that is
          executed after all source objects are iterated.</p></li><li><p><span class="emphasis"><em>&lt;result pattern&gt;</em></span>: this
          is a regular pattern that the engine tries to match against the
          object returned from the <span class="emphasis"><em>&lt;result expression&gt;</em></span>.
          If it matches, the <strong class="kw"><code>accumulate</code></strong> conditional element
          evaluates to <span class="emphasis"><em>true</em></span> and the engine
          proceeds with the evaluation of the next CE in the rule. If it does
          not matches, the <strong class="kw"><code>accumulate</code></strong> CE
          evaluates to <span class="emphasis"><em>false</em></span> and the engine
          stops evaluating CEs for that rule.</p></li></ul></div><p>It is easier to understand if we look at an example:</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</pre><p>In the above example, for each <code class="code">Order</code> in the 
      Working Memory, the  engine will execute the <span class="emphasis"><em>init code</em></span>
      initializing the total variable to zero. Then it will iterate over all
      <code class="code">OrderItem</code> objects for that order, executing the
      <span class="emphasis"><em>action</em></span> for each one (in the example, it will sum
      the value of all items into the total variable). After iterating over
      all <code class="code">OrderItem</code> objects, it will return the value corresponding
      to the <span class="emphasis"><em>result expression</em></span> (in the above example, the
      value of variable <code class="code">total</code>). Finally, the engine will try to match the
      result with the <code class="code">Number</code> pattern, and if the double value is greater
      than 100, the rule will fire.</p><p>The example used Java as the semantic dialect, and as such, note
      that the usage of the semicolon as statement delimiter is mandatory in the
      init, action and reverse code
      blocks. The result is an expression and, as such, it does not admit ';'.
      If the user uses any other dialect, he must comply to that dialect's
      specific syntax.</p><p>As mentioned before, the <span class="emphasis"><em>reverse code</em></span> is optional,
      but it is strongly recommended that the user writes it in order to benefit
      from the <span class="emphasis"><em>improved performance on update and retract</em></span>.</p><p>The <strong class="kw"><code>accumulate</code></strong> CE can be used to
      execute any action on source objects. The following example instantiates
      and populates a custom object:</p><pre class="programlisting">rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e5167"/>4.8.2.10.1. Accumulate Functions</h5></div></div></div><p>The accumulate CE is a very powerful CE, but it gets real
        declarative and easy to use when using predefined functions that are
        known as Accumulate Functions. They work exactly like accumulate, but
        instead of explicitly writing custom code in every accumulate CE, the
        user can use predefined code for common operations.</p><p>For instance, the rule to apply discount on orders written in
        the previous section, could be written in the following way, using
        Accumulate Functions:</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</pre><p>In the above example, sum is an Accumulate Function and will sum
        the $value of all OrderItems and return the result.</p><p>Drools ships with the following built-in accumulate
        functions:</p><div class="itemizedlist"><ul><li><p>average</p></li><li><p>min</p></li><li><p>max</p></li><li><p>count</p></li><li><p>sum</p></li></ul></div><p>These common functions accept any expression as input. For
        instance, if someone wants to calculate the average profit on all
        items of an order, a rule could be written using the average
        function:</p><pre class="programlisting">rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</pre><p>Accumulate Functions are all pluggable. That means that if
        needed, custom, domain specific functions can easily be added to the
        engine and rules can start to use them without any restrictions. To
        implement a new Accumulate Functions all one needs to do is to create
        a Java class that implements the
        <code class="code">org.drools.base.acumulators.AccumulateFunction</code> interface and add a
        line to the configuration file or set a system property to let the
        engine know about the new function. As an example of an Accumulate
        Function implementation, the following is the implementation of the
        <strong class="kw"><code>average</code></strong> function:</p><pre class="programlisting">/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 * 
 * @author etirelli
 *
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object,
     * java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object,
     * java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</pre><p>The code for the function is very simple, as we could expect, as
        all the "dirty" integration work is done by the engine. Finally, to
        plug the function into the engine, we added it to the configuration
        file:</p><pre class="programlisting">drools.accumulate.function.average =
   org.drools.base.accumulators.AverageAccumulateFunction
</pre><p>Here, "drools.accumulate.function." is a prefix that must always
        be used, "average" is how the function will be used in the rule file,
        and "org.drools.base.accumulators.AverageAccumulateFunction" is the
        fully qualified name of the class that implements the function
        behavior.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5216"/>4.8.3. The Right Hand Side (then)</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5219"/>4.8.3.1. Usage</h4></div></div></div><p>The Right Hand Side (RHS) is a common name for the consequence or
      action part of the rule; this part should contain a list of actions to be
      executed. It is bad practice to use imperative or conditional code in the
      RHS of a rule; as a rule should be atomic in nature - "when this, then do
      this", not "when this, maybe do this". The RHS part of a rule should also
      be kept small, thus keeping it declarative and readable. If you find you
      need imperative and/or conditional code in the RHS, then maybe you should
      be breaking that rule down into multiple rules. The main purpose of the
      RHS is to insert, retractor modify working memory data. To assist with
      that there are a few convenience methods you can use to modify working
      memory; without having to first reference a working memory
      instance.</p><p><strong class="kw"><code>update(</code></strong><span class="emphasis"><em>object, handle</em></span><strong class="kw"><code>);</code></strong>
      will tell the engine that an object has
      changed (one that has been bound to something on the LHS) and rules may
      need to be reconsidered.</p><p><strong class="kw"><code>update(</code></strong><span class="emphasis"><em>object</em></span><strong class="kw"><code>);</code></strong>  can
      also be used; here the Knowledge Helper will look up the facthandle for you,
      via an identity check, for the passed object. (Note that if you  provide
      Property Change Listeners to your Java beans that you are inserting into
      the engine, you can avoid the need to call  <code class="code">update()</code> when the
      object changes.)</p><p><strong class="kw"><code>insert(new</code></strong> <span class="emphasis"><em>Something</em></span><strong class="kw"><code>());</code></strong>
      will place a new object of your creation into the Working Memory.</p><p><strong class="kw"><code>insertLogical(new</code></strong> <span class="emphasis"><em>Something</em></span><strong class="kw"><code>());</code></strong>
      is similar to insert, but the object will be automatically retracted when there are
      no more facts to support the truth of the currently firing rule.</p><p><strong class="kw"><code>retract(</code></strong><span class="emphasis"><em>handle</em></span><strong class="kw"><code>);</code></strong>
      removes an object from Working Memory.</p><p>These convenience methods are basically macros that provide short
      cuts to the <code class="code">KnowledgeHelper</code> instance that lets you access your
      Working Memory from rules files. The predefined variable <code class="code">drools</code>
      of type  <code class="code">KnowledgeHelper</code> lets you call several other useful
      methods. (Refer to the <code class="code">KnowledgeHelper</code> interface documentation for
      more advanced operations).</p><div class="itemizedlist"><ul><li><p>The call <code class="code">drools.halt()</code> terminates rule execution
          immediately. This is required for returning control to the point
          whence the current session was put to work with
          <code class="code">fireUntilHalt()</code>.</p></li><li><p>Methods <code class="code">insert(Object o)</code>,
          <code class="code">update(Object o)</code> and <code class="code">retract(Object o)</code>
          can be called on <code class="code">drools</code> as well, but due to their
          frequent use they can be called without the object reference.</p></li><li><p><code class="code">drools.getWorkingMemory()</code> returns the
          <code class="code">WorkingMemory</code> object.</p></li><li><p><code class="code">drools.setFocus( String s)</code> sets the focus
          to the specified agenda group.</p></li><li><p><code class="code">drools.getRule().getName()</code>, called from a 
          rule's RHS, returns the name of the rule.</p></li><li><p><code class="code">drools.getTuple()</code> returns the Tuple that
          matches the currently executing rule, and
          <code class="code">drools.getActivation()</code> delivers the corresponding
          Activation. (These calls are useful for logging and debugging
          purposes.)</p></li></ul></div><p>The full Knowlege Runtime API is exposed through another predefined
      variable, <code class="code">kcontext</code>, of type <code class="code">KnowledgeContext</code>. Its
      method <code class="code">getKnowledgeRuntime()</code> delivers an object of type
      <code class="code">KnowledgeRuntime</code>, which, in turn, provides access to a wealth
      of methods, many of which are quite useful for coding RHS logic.

      </p><div class="itemizedlist"><ul><li><p>The call <code class="code">kcontext.getKnowledgeRuntime().halt()</code>
          terminates rule execution immediately.</p></li><li><p>The accessor <code class="code">getAgenda()</code> returns a reference
          to this session's <code class="code">Agenda</code>, which in turn provides access
          to the various rule groups: activation groups, agenda groups, and
          rule flow groups. A fairly common paradigm is the activation of some
          agenda group, which could be done with the lengthy call:
          </p><pre class="programlisting">
// give focus to the agenda group CleanUp
kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</pre><p>
          (You can achieve the same using <code class="code">drools.setFocus( "CleanUp" )</code>.)
          </p></li><li><p>To run a query, you call <code class="code">getQueryResults(String query)</code>,
          whereupon you may process the results, as explained in section
          “<span class="quote"><a class="link" href="#sec.query" title="4.9. Query">Query</a></span>”.
          </p></li><li><p>A set of methods dealing with event management lets you, among
          other things, add and remove event listeners for the Working Memory
          and the Agenda.</p></li><li><p>Method<code class="code">getKnowledgeBase()</code> returns the
          <code class="code">KnowledgeBase</code> object, the backbone of all the
          Knowledge in your system, and the originator of the current
          session.</p></li><li><p>You can manage globals with <code class="code">setGlobal(...)</code>,
          <code class="code">getGlobal(...)</code> and <code class="code">getGlobals()</code>.</p></li><li><p>Method <code class="code">getEnvironment()</code> returns the runtime's
          <code class="code">Environment</code> which works much like what you know as
          your operating system's environment.</p></li></ul></div><p>
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5413"/>4.8.3.2. The <strong class="kw"><code>modify</code></strong> Statement</h4></div></div></div><p>This language extension provides a structured approach to
      fact updates. It combines the update operation with a number of
      setter calls to change the object's fields. This is the syntax
      schema for the <strong class="kw"><code>modify</code></strong> statement:</p><pre class="programlisting"><strong class="kw"><code>modify ( </code></strong><em class="replaceable"><code>&lt;fact-expression&gt;</code></em><strong class="kw"><code> ) {</code></strong>
    <em class="replaceable"><code>&lt;expression&gt;</code></em> [ <strong class="kw"><code>,</code></strong> <em class="replaceable"><code>&lt;expression&gt;</code></em> ]*
<strong class="kw"><code>}</code></strong></pre><p>The parenthesized <span class="emphasis"><em>&lt;fact-expression&gt;</em></span> must yield
      a fact object reference.  The expression list in the block should consist of
      setter calls for the given  object, to be written without the usual object reference,
      which is automatically prepended by the compiler.</p><p>The example illustrates a simple fact modification.</p><div class="example"><a id="d0e5450"/><p class="title"><b>Example 4.64. A modify statement</b></p><div class="example-contents"><pre class="programlisting">rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5455"/>4.8.4. A Note on Auto-boxing and Primitive Types</h3></div></div></div><p>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives were autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing JDK 1.5
    and JDK 5 rules to handle auto-boxing and unboxing apply in this case. When
    evaluating field constraints, the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec.query"/>4.9. Query</h2></div></div></div><div class="figure"><a id="d0e5463"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/query.png" align="middle" alt="query"/></div></div><p class="title"><b>Figure 4.44. query</b></p></div><br class="figure-break"/><p>A query is a simple way to search the working memory for facts that
  match the stated conditions. Therefore, it contains only the structure of
  the LHS of a rule, so that you specify neither "when" nor "then". A query
  has an optional set of parameters, each of which can be optionally typed. If
  the type is not given, the type Object is assumed. The engine will attempt
  to coerce the values as needed. Query names are global to the KnowledgeBase;
  so do not add queries of the same name to different packages for the same
  RuleBase.</p><p>To return the results use
  <code class="code">ksession.getQueryResults("name")</code>, where "name" is the query's
  name. This returns a list of query results, which allow you to retrieve the
  objects that matched the query.</p><p>The first example presents a simple query for all the people over the
  age of 30. The second one, using parameters, combines the age limit with a
  location.</p><div class="example"><a id="d0e5478"/><p class="title"><b>Example 4.65. Query People over the age of 30</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of 30" 
    person : Person( age &gt; 30 )
end</pre></div></div><br class="example-break"/><div class="example"><a id="d0e5483"/><p class="title"><b>Example 4.66. Query People over the age of x, and who live in y</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of x"  (int x, String y)
    person : Person( age &gt; x, location == y )
end</pre></div></div><br class="example-break"/><p>We iterate over the returned QueryResults using a standard "for" loop.
  Each element is a QueryResultsRow which we can use to access each of the
  columns in the tuple. These columns can be accessed by bound declaration
  name or index position.</p><div class="example"><a id="d0e5490"/><p class="title"><b>Example 4.67. Query People over the age of 30</b></p><div class="example-contents"><pre class="programlisting">QueryResults results = ksession.getQueryResults( "people over the age of 30" );
System.out.println( "we have " + results.size() + " people over the age  of 30" );

System.out.println( "These people are are over 30:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5495"/>4.10. Domain Specific Languages</h2></div></div></div><p>As mentioned previously, <a id="d0e5500" class="indexterm"/>(or DSLs) are a way of extending the rule language to your
  problem domain. They are wired in to the rule language for you, and can make
  use of all the underlying rule language and engine features.</p><p>DSLs are used both in the IDE, as well as the web based BRMS. Of
  course as rules are text, you can use them even without this tooling.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5506"/>4.10.1. When to use a DSL</h3></div></div></div><p>DSLs can serve as a layer of separation between rule authoring (and
    rule authors) and the domain objects that the engine operates on. DSLs can
    also act as "templates" of conditions or actions that are used over and
    over in your rules, perhaps only with parameters changing each time. If
    your rules need to be read and validated by less technical folk, (such as
    Business Analysts) the DSLs are definitely for you. If the conditions or
    consequences of your rules follow similar patterns which you can express
    in a template. You wish to hide away your implementation details, and
    focus on the business rule. You want to provide a controlled means of
    editing rules based on pre-defined templates.</p><p>DSLs have no impact on the rules at runtime, they are just a
    parse/compile time feature.</p><p>Note that Drools 4 DSLs are quite different from Drools 2 XML based
    DSLs. It is still possible to do Drools 2 style XML languages - if you
    require this, then take a look at the Drools 4 XML rule language, and
    consider using XSLT to map from your XML language to the Drools 4 XML
    language.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5515"/>4.10.2. Editing and managing a DSL</h3></div></div></div><p>A DSL's configuration like most things is stored in plain text. If
    you use the IDE, you get a nice graphical editor (with some validation),
    but the format of the file is quite simple, and is basically a properties
    file.</p><p>Note that since Drools 4.0, DSLs have become more powerful in
    allowing you to customise almost any part of the language, including
    keywords. Regular expressions can also be used to match words/sentences if
    needed (this is provided for enhanced localisation). However, not all
    features are supported by all the tools (although you can use them, the
    content assistance just may not be 100% accurate in certain cases).</p><div class="example"><a id="d0e5522"/><p class="title"><b>Example 4.68. Example <a id="d0e5525" class="indexterm"/> mapping</b></p><div class="example-contents"><pre class="programlisting">[when]This is {something}=Something(something=={something})</pre></div></div><br class="example-break"/><p>Referring to the above example, the [when] refers to the scope of
    the expression: ie does it belong on the LHS or the RHS of a rule. The
    part after the [scope] is the expression that you use in the rule
    (typically a natural language expression, but it doesn't have to be). The
    part on the right of the "=" is the mapping into the rule language (of
    course the form of this depends on if you are talking about the RHS or the
    LHS - if its the LHS, then its the normal LHS syntax, if its the RHS then
    its fragments of Java code for instance).</p><p>The parser will take the expression you specify, and extract the
    values that match where the {something} (named Tokens) appear in the
    input. The values that match the tokens are then interpolated with the
    corresponding {something} (named Tokens) on the right hand side of the
    mapping (the target expression that the rule engine actually uses).</p><p>Note also that the "sentences" above can be regular expressions.
    This means the parser will match the sentence fragements that match the
    expressions. This means you can use (for instance) the '?' to indicate the
    character before it is optional (think of each sentence as a regular
    expression pattern - this means if you want to use regex characters - you
    will need to escape them with a '\' of course.</p><p>It is important to note that the DSL expressions are processed one
    line at a time. This means that in the above example, all the text after
    "This is " to the end of the line will be included as the value for
    "{something}" when it is interpolated into the target string. This may not
    be exactly what you want, as you may want to "chain" together different
    DSL expressions to generate a target expression. The best way around this
    is to make sure that the {tokens} are enclosed with characters or words.
    This means that the parser will scan along the sentence, and pluck out the
    value BETWEEN the characters (in the example below they are
    double-quotes). Note that the characters that surround the token are not
    included in when interpolating, just the contents between them (rather
    then all the way to the end of the line, as would otherwise be the
    case).</p><p>As a rule of thumb, use quotes for textual data that a rule editor
    may want to enter. You can also wrap words around the {tokens} to make
    sure you enclose the data you want to capture (see other example).</p><div class="example"><a id="d0e5541"/><p class="title"><b>Example 4.69. Example with quotes</b></p><div class="example-contents"><pre class="programlisting">[when]This is "{something}" and "{another}"=Something(something=="{something}", another=="{another}")
[when]This is {also} valid=Another(something=="{also}")</pre></div></div><br class="example-break"/><p>It is a good idea to try and avoid punctuation in your DSL
    expressions where possible, other then quotes and the like - keep it
    simple and things will be easier. Using a DSL can make debugging slightly
    harder when you are first building rules, but it can make the maintenance
    easier (and of course the readability of the rules).</p><p>The "{" and "}" characters should only be used on the left hand side
    of the mapping (the expression) to mark tokens. On the right hand side you
    can use "{" and "}" on their own if needed - such as </p><pre class="programlisting">if (foo) \{
    doSomething();\ }</pre><p> as well as with the token names as shown
    above.</p><p>PLEASE NOTE that if you want curly braces to appear literally as curly braces, then escape them with a backslack (\). Otherwise it may think it is a token to be replaced.
  </p><p>Don't forget that if you are capturing strings from users, you will
    also need the quotes on the right hand side of the mapping, just like a
    normal rule, as the result of the mapping must be a valid expression in
    the rule language.</p><div class="example"><a id="d0e5557"/><p class="title"><b>Example 4.70. Some more examples</b></p><div class="example-contents"><pre class="programlisting">#This is a comment to be ignored.
[when]There is a Person with name of "{name}"=Person(name=="{name}")
[when]Person is at least {age} years old and lives in "{location}"=Person(age &gt; {age}, location=="{location}")
[then]Log "{message}"=System.out.println("{message}");
[when]And = and</pre></div></div><br class="example-break"/><p>Referring to the above examples, this would render the following
    input as shown below: </p><div class="example"><a id="d0e5564"/><p class="title"><b>Example 4.71. Some examples as processed</b></p><div class="example-contents"><pre class="programlisting">There is a Person with name of "kitty" ---&gt; Person(name="kitty")
Person is at least 42 years old and lives in "atlanta" ---&gt; Person(age &gt; 42, location="atlanta")
Log "boo" ---&gt; System.out.println("boo");
There is a Person with name of "bob" and Person is at least 30 years old and lives in "atlanta" 
          ---&gt; Person(name="kitty") and Person(age &gt; 30, location="atlanta")</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5569"/>4.10.3. Using a DSL in your rules</h3></div></div></div><p>A good way to get started if you are new to Rules (and DSLs) is just
    write the rules as you normally would against your object model. You can
    unit test as you go (like a good agile citizen!). Once you feel
    comfortable, you can look at extracting a domain language to express what
    you are doing in the rules. Note that once you have started using the
    "expander" keyword, you will get errors if the parser does not recognize
    expressions you have in there - you need to move everything to the DSL. As
    a way around this, you can prefix each line with "&gt;" and it will tell
    the parser to take that line literally, and not try and expand it (this is
    handy also if you are debugging why something isn't working).</p><p>Also, it is better to rename the extension of your rules file from
    ".drl" to ".dslr" when you start using DSLs, as that will allow the IDE to
    correctly recognize and work with your rules file.</p><p>As you work through building up your DSL, you will find that the DSL
    configuration stabilizes pretty quickly, and that as you add new rules and
    edit rules you are reusing the same DSL expressions over and over. The aim
    is to make things as fluent as possible.</p><p>To use the DSL when you want to compile and run the rules, you will
    need to pass the DSL configuration source along with the rule source.
    </p><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( source, dsl );
//source is a reader for the rule source, dsl is a reader for the DSL configuration
</pre><p> You will also need to specify the expander by name in the
    rule source file: </p><pre class="programlisting">expander your-expander.dsl
</pre><p>Typically you keep the DSL in the same directory as the rule,
    but this is not required if you are using the above API (you only need to
    pass a reader). Otherwise everything is just the same.</p><p>You can chain DSL expressions together on one line, as long as it is
    clear to the parser what the {tokens} are (otherwise you risk reading in
    too much text until the end of the line). The DSL expressions are
    processed according to the mapping file, top to bottom in order. You can
    also have the resulting rule expressions span lines - this means that you
    can do things like:</p><div class="example"><a id="d0e5588"/><p class="title"><b>Example 4.72. Chaining DSL Expressions</b></p><div class="example-contents"><pre class="programlisting">There is a person called Bob who is happy
  Or
There is a person called Mike who is sad
</pre></div></div><br class="example-break"/><p>Of course this assumes that "Or" is mapped to the "or" conditional
    element (which is a sensible thing to do).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5595"/>4.10.4. Adding constraints to facts</h3></div></div></div><p>A common requirement when writing rule conditions is to be able to
    add many constraints to fact declarations. A fact may have many (dozens)
    of fields, all of which could be used or not used at various times. To
    come up with every combination as separate DSL statements would in many
    cases not be feasible.</p><p>The DSL facility allows you to achieve this however, with a simple
    convention. If your DSL expression starts with a "-", then it will be
    assumed to be a field constraint, which will be added to the declaration
    that is above it (one per line).</p><p>This is easier to explain with an example. Lets take look at Cheese
    class, with the following fields: type, price, age, country. We can
    express some LHS condition in normal DRL like the following
    </p><pre class="programlisting">Cheese(age &lt; 5, price == 20, type=="stilton", country=="ch")</pre><p>
    If you know ahead of time that you will use all the fields, all the time,
    it is easy to do a mapping using the above techniques. However, chances
    are that you will have many fields, and many combinations. If this is the
    case, you can setup your mappings like so: </p><pre class="programlisting">[when]There is a Cheese with=Cheese()
[when]- age is less than {age}=age&lt;{age}
[when]- type is '{type}'=type=='{type}'
[when]- country equal to '{country}'=country=='{country}'</pre><p><span class="bold"><strong>IMPORTANT:</strong></span> It is NOT possible to
    use the "-" feature after an <span class="bold"><strong>accumulate</strong></span>
    statement to add constraints to the accumulate pattern. This limitation
    will be removed in the future.</p><p>You can then write rules with conditions like the following:
    </p><pre class="programlisting">There is a Cheese with
        - age is less than 42
        - type is 'stilton'</pre><p> The parser will pick up the "-"
    lines (they have to be on their own line) and add them as constraints to
    the declaration above. So in this specific case, using the above mappings,
    is the equivalent to doing (in DRL): </p><pre class="programlisting">Cheese(age&lt;42, type=='stilton')</pre><p>
    The parser will do all the work for you, meaning you just define mappings
    for individual constraints, and can combine them how you like (if you are
    using context assistant, if you press "-" followed by CTRL+space it will
    conveniently provide you with a filtered list of field constraints to
    choose from.</p><p>To take this further, after alter the DSL to have
    [when][org.drools.Cheese]- age is less than {age} ... (and similar to all
    the items in the example above).</p><p>The extra [org.drools.Cheese] indicates that the sentence only
    applies for the main constraint sentence above it (in this case "There is
    a Cheese with"). For example, if you have a class called "Cheese" - then
    if you are adding contraints to the rule (by typing "-" and waiting for
    content assistance) then it will know that only items marked as having an
    object-scope of "com.yourcompany.Something" are valid, and suggest only
    them. This is entirely optional (you can leave out that section if needed
    - OR it can be left blank).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5628"/>4.10.5. How it works</h3></div></div></div><p>DSLs kick in when the rule is parsed. The DSL configuration is read
    and supplied to the parser, so the parser can "expand" the DSL expressions
    into the real rule language expressions.</p><p>When the parser is processing the rules, it will check if an
    "expander" representing a DSL is enabled, if it is, it will try to expand
    the expression based on the context of where it is the rule. If an
    expression can not be expanded, then an error will be added to the
    results, and the line number recorded (this insures against typos when
    editing the rules with a DSL). At present, the DSL expander is fairly
    space sensitive, but this will be made more tolerant in future releases
    (including tolerance for a wide range of punctuation).</p><p>The expansion itself works by trying to match a line against the
    expression in the DSL configuration. The values that correspond to the
    token place holders are stored in a map based on the name of the token,
    and then interpolated to the target mapping. The values that match the
    token placeholders are extracted by either searching until the end of the
    line, or until a character or word after the token place holder is
    matched. The "{" and "}" are not included in the values that are
    extracted, they are only used to demarcate the tokens - you should not use
    these characters in the DSL expression (but you can in the target).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5637"/>4.10.6. Creating a DSL from scratch</h3></div></div></div><p>DSLs can be aid with capturing rules if the rules are well known,
    just not in any technically usable format (ie. sitting around in people
    brains). Until we are able to have those little sockets in our necks like
    in the Matrix, our means of getting stuff into computers is still the old
    fashioned way.</p><p>Rules engines require an object or a data model to operate on - in many
    cases you may know this up front. In other cases the model will be
    discovered with the rules. In any case, rules generally work better with
    simpler flatter object models. In some cases, this may mean having a rule
    object model which is a subset of the main applications model (perhaps
    mapped from it). Object models can often have complex relationships and
    hierarchies in them - for rules you will want to simplify and flatten the
    model where possible, and let the rule engine infer relationships (as it
    provides future flexibility). As stated previously, DSLs can have an
    advantage of providing some insulation between the object model and the
    rule language.</p><p>Coming up with a DSL is a collaborative approach for both technical
    and domain experts. Historically there was a role called "knowledge
    engineer" which is someone skilled in both the rule technology, and in
    capturing rules. Over a short period of time, your DSL should stabilize,
    which means that changes to rules are done entirely using the DSL. A
    suggested approach if you are starting from scratch is the following
    workflow: </p><div class="itemizedlist"><ul><li><p>Capture rules as loose "if then" statements - this is really
          to get an idea of size and complexity (possibly in a text
          document).</p></li><li><p>Look for recurring statements in the rules captured. Also look
          for the rule objects/fields (and match them up with what may already
          be known of the object model).</p></li><li><p>Create a new DSL, and start adding statements from the above
          steps. Provide the "holes" for data to be edited (as many statements
          will be similar, with only some data changing).</p></li><li><p>Use the above DSL, and try to write the rules just like that
          appear in the "if then" statements from the first and second steps.
          Iterate this process until patterns appear and things stabilize. At
          this stage, you are not so worried about the rule language
          underneath, just the DSL.</p></li><li><p>At this stage you will need to look at the Objects, and the
          Fields that are needed for the rules, reconcile this with the
          datamodel so far.</p></li><li><p>Map the DSL statements to the rule language, based on the
          object model. Then repeat the process. Obviously this is best done
          in small steps, to make sure that things are on the right
          track.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5665"/>4.10.7. Scope and keywords</h3></div></div></div><p>If you are editing the DSL with the GUI, or as text, you will notice
    there is a [scope] item at the start of each mapping line. This indicates
    if the sentence/word applies to the LHS, RHS or is a keyword. Valid values
    for this are [condition], [consequence] and [keyword] (with [when] and
    [then] being the same as [condition] and [consequence] respectively). When
    [keyword] is used, it means you can map any keyword of the language like
    "rule" or "end" to something else. Generally this is only used when you
    want to have a non English rule language (and you would ideally map it to
    a single word).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5670"/>4.10.8. DSLs in the BRMS and IDE</h3></div></div></div><p>You can use DSLs in the BRMS in both guided editor rules, and
    textual rules that use a dsl. (In fact, the same applies to the
    IDE).</p><p>In the guided editor - the DSLs generally have to be simpler - what
    you are doing is defining little "forms" to capture data from users in
    text fields (ie as you pick a DSL expression - it will add an item to the
    GUI which only allows you enter data in the {token} parts of a DSL
    expression). You can not use sophisticated regular expressions to match
    text. However, in textual rules (which have a .dslr extension in the IDE)
    you are free to use the full power as needed.</p><p>In the BRMS - when you build a package the DSLs are already included
    and all the work is done for you. In the IDE (or in any IDE) - you will
    either need to use the drools-ant task, or otherwise use the code shown in
    sections above.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5679"/>4.11. XML Rule Language</h2></div></div></div><p>As an option, Drools also supports a "native" <a id="d0e5684" class="indexterm"/> rule language as an alternative to DRL. This allows you to
  capture and manage your rules as XML data. Just like the non-XML DRL format,
  the XML format is parsed into the internal "AST" representation - as fast as
  possible (using a SAX parser). There is no external transformation step
  required. All the features are available with XML that are available to
  DRL.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5688"/>4.11.1. When to use XML</h3></div></div></div><p>There are several scenarios that XML is desirable. However, we
    recommend that it is not a default choice, as XML is not readily human
    readable (unless you like headaches) and can create visually bloated
    rules.</p><p>If you do want to edit XML by hand, use a good schema aware editor
    that provides nice hierarchical views of the XML, ideally visually
    (commercial tools like XMLSpy, Oxygen etc are good, but cost money, but
    then so do headache tablets).</p><p>Other scenarios where you may want to use the XML format are if you
    have a tool that generates rules from some input (programmatically
    generated rules), or perhaps interchange from another rule language, or
    from another tool that emits XML (using XSLT you can easily transform
    between XML formats). Note you can always generate normal DRL as
    well.</p><p>Alternatively you may be embedding Drools in a product that already
    uses XML for configuration, so you would like the rules to be in an XML
    format. You may be creating your own rule language on XML - note that you
    can always use the AST objects directly to create your own rule language
    as well (the options are many, due to the open architecture).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5699"/>4.11.2. The XML format</h3></div></div></div><p>A full W3C standards (XMLSchema) compliant XSD is provided that
    describes the XML language, which will not be repeated here verbatim. A
    summary of the language follows.</p><div class="example"><a id="d0e5704"/><p class="title"><b>Example 4.73. A rule in XML<a id="d0e5707" class="indexterm"/></b></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;package name="com.sample"
         xmlns="http://drools.org/drools-4.0"
         xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         xs:schemaLocation="http://drools.org/drools-4.0 drools-4.0.xsd"&gt;

&lt;import name="java.util.HashMap" /&gt;
&lt;import name="org.drools.*" /&gt;

&lt;global identifier="x" type="com.sample.X" /&gt;
&lt;global identifier="yada" type="com.sample.Yada" /&gt;

&lt;function return-type="void" name="myFunc"&gt;
    &lt;parameter identifier="foo" type="Bar" /&gt;
    &lt;parameter identifier="bada" type="Bing" /&gt;

    &lt;body&gt;
     System.out.println("hello world");
    &lt;/body&gt;
&lt;/function&gt;

&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
		&lt;pattern identifier="foo2" object-type="Bar" &gt;
            &lt;or-constraint-connective&gt;
                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&gt;" value="60" /&gt;
                                &lt;literal-restriction evaluator="&lt;" value="70" /&gt;
                            &lt;/and-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&lt;" value="50" /&gt;
                                &lt;literal-restriction evaluator="&gt;" value="55" /&gt;
                            &lt;/and-restriction-connective&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="black" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="40" /&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="pink" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="12"/&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;literal-restriction evaluator="==" value="yellow"/&gt;
                            &lt;literal-restriction evaluator="==" value="blue" /&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;
            &lt;/or-constraint-connective&gt;
        &lt;/pattern&gt;

        &lt;not&gt;
            &lt;pattern object-type="Person"&gt;
                &lt;field-constraint field-name="likes"&gt;
                    &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;exists&gt;
                &lt;pattern object-type="Person"&gt;
                    &lt;field-constraint field-name="likes"&gt;
                        &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                    &lt;/field-constraint&gt;
                &lt;/pattern&gt;                
            &lt;/exists&gt;
        &lt;/not&gt;

        &lt;or-conditional-element&gt;
            &lt;pattern identifier="foo3" object-type="Bar" &gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;or-restriction-connective&gt;
                        &lt;literal-restriction evaluator="==" value="3" /&gt;
                        &lt;literal-restriction evaluator="==" value="4" /&gt;
                    &lt;/or-restriction-connective&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a3"&gt;
                    &lt;literal-restriction evaluator="==" value="hello" /&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a4"&gt;
                    &lt;literal-restriction evaluator="==" value="null" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;pattern identifier="foo4" object-type="Bar" &gt;
                &lt;field-binding field-name="a" identifier="a4" /&gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;literal-restriction evaluator="!=" value="4" /&gt;
                    &lt;literal-restriction evaluator="!=" value="5" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;
        &lt;/or-conditional-element&gt;

        &lt;pattern identifier="foo5" object-type="Bar" &gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;or-restriction-connective&gt;
                    &lt;return-value-restriction evaluator="==" &gt;a4 + 1&lt;/return-value-restriction&gt;
                    &lt;variable-restriction evaluator="&gt;" identifier="a4" /&gt;
                    &lt;qualified-identifier-restriction evaluator="=="&gt;
                        org.drools.Bar.BAR_ENUM_VALUE
                    &lt;/qualified-identifier-restriction&gt;
                &lt;/or-restriction-connective&gt;
            &lt;/field-constraint&gt;            
        &lt;/pattern&gt;

        &lt;pattern identifier="foo6" object-type="Bar" &gt;
            &lt;field-binding field-name="a" identifier="a4" /&gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;literal-restriction evaluator="==" value="6" /&gt;
            &lt;/field-constraint&gt;
        &lt;/pattern&gt;
  &lt;/lhs&gt;
 &lt;rhs&gt;
    if ( a == b ) {
      assert( foo3 );
    } else {
      retract( foo4 );
    }
    System.out.println( a4 );
   &lt;/rhs&gt;
&lt;/rule&gt;

&lt;/package&gt;
	
</pre></div></div><br class="example-break"/><p>In the preceding XML text you will see the typical XML
      element, the package declaration, imports, globals, functions,
      and the rule itself. Most of the elements are self explanatory
      if you have some  understanding of the Drools features.</p><p>The <code class="code">import</code> elements import the types you wish to
      use in the rule.</p><p>The <code class="code">global</code> elements define global objects that can
      be referred to in the rules.</p><p>The <code class="code">function</code> contains a function declaration, for
      a function to be used in the rules. You have to specify a return type,
      a unique name and parameters, in the body goes a snippet of code.</p><p>The rule is discussed below.</p><div class="example"><a id="d0e5731"/><p class="title"><b>Example 4.74. Detail of rule element</b></p><div class="example-contents"><pre class="programlisting">&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
    &lt;pattern identifier="cheese" object-type="Cheese"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern object-type="Person"&gt;&lt;/pattern&gt;
                &lt;init&gt;
                    int total = 0;
                &lt;/init&gt;
                &lt;action&gt;
                    total += $cheese.getPrice();
                &lt;/action&gt;
                &lt;result&gt;
                    new Integer( total ) );
                &lt;/result&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;

    &lt;pattern identifier="max" object-type="Number"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern identifier="cheese" object-type="Cheese"&gt;&lt;/pattern&gt;
                &lt;external-function evaluator="max" expression="$price"/&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;
&lt;/lhs&gt;
&lt;rhs&gt;
    list1.add( $cheese );
&lt;/rhs&gt;
&lt;/rule&gt;
	</pre></div></div><br class="example-break"/><p>In the above detail of the rule we see that the rule has LHS
      and RHS (conditions and consequence) sections.
    The RHS is simple, it is just a block of semantic code that will be
    executed when the rule is activated. The LHS is slightly more
    complicated as it contains nested elements for conditional elements,
    constraints and restrictions.</p><p>A key element of the LHS is the Pattern element. This allows you to
    specify a type (class) and perhaps bind a variable to an instance of that
    class. Nested under the pattern object are constraints and restrictions
	that have to be met. The Predicate and Return Value constraints 
	allow Java expressions to be embedded.</p><p>That leaves the conditional elements, not, exists, and, or etc. They
    work like their DRL counterparts. Elements that are nested under and an
    "and" element are logically "anded" together. Likewise with "or" (and you
    can nest things further). "Exists" and "Not" work around patterns, to check
    for the existence or nonexistence of a fact meeting the pattern's
    constraints.</p><p>The Eval element allows the execution of a valid snippet of Java
    code - as long as it evaluates to a boolean (do not end it with a
    semi-colon, as it is just a fragment) - this can include calling a
    function. The Eval is less efficient than the columns, as the rule engine
    has to evaluate it each time, but it is a "catch all" feature for when you
    can express what you need to do with Column constraints.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5745"/>4.11.3. Legacy Drools 2.x XML rule format</h3></div></div></div><p>The Drools 2.x legacy XML format is no longer supported by Drools XML parser</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5750"/>4.11.4. Automatic transforming between formats (XML and DRL)</h3></div></div></div><p>Drools comes with some utility classes to transform between formats.
    This works by parsing the rules from the source format into the AST, and
    then "dumping" out to the appropriate target format. This allows you, for
    example, to write rules in DRL, and when needed, export to XML if
    necessary at some point in the future.</p><p>The classes to look at if you need to do this are: </p><pre class="programlisting">XmlDumper - for exporting XML.
DrlDumper - for exporting DRL.
DrlParser - reading DRL.
XmlPackageReader - reading XML.
</pre><p> Using combinations of the above, you can convert between any
    format (including round trip). Note that DSLs will not be preserved (from
    DRLs that are using a DSL) - but they will be able to be converted.</p><p>Feel free to make use of XSLT to provide all sorts of possibilities
  for XML, XSLT and its ilk are what make XML powerful.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5762"/>Chapter 5. Authoring</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5765">5.1. Decision Tables in Spreadsheets</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5777">5.1.1. When to use Decision tables</a></span></dt><dt><span class="section"><a href="#d0e5789">5.1.2. Overview</a></span></dt><dt><span class="section"><a href="#d0e5827">5.1.3. How decision tables work</a></span></dt><dt><span class="section"><a href="#d0e5900">5.1.4. Keywords and Syntax</a></span></dt><dt><span class="section"><a href="#d0e6103">5.1.5. Creating and integrating Spreadsheet based Decision
      Tables</a></span></dt><dt><span class="section"><a href="#d0e6116">5.1.6. Managing business rules in decision tables.</a></span></dt><dt><span class="section"><a href="#d0e6161">5.1.7. Rule Templates</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6212">5.2. Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6225">5.2.1. The Rule Template File</a></span></dt><dt><span class="section"><a href="#d0e6322">5.2.2. Expanding a Template</a></span></dt><dt><span class="section"><a href="#d0e6376">5.2.3. Example</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5765"/>5.1. Decision Tables in Spreadsheets</h2></div></div></div><p>Decision tables are a "precise yet compact" (ref. Wikipedia) way of
    representing conditional logic, and are well suited to
    <span class="emphasis"><em>business</em></span> level rules.</p><p>Drools supports managing rules in a spreadsheet format. Supported
    formats are Excel (XLS), and CSV, which means that a variety of spreadsheet
    programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can
    be utilized. It is expected that web based decision table editors will be
    included in a near future release.</p><p>Decision tables are an old concept (in software terms) but have
    proven useful over the years. Very briefly speaking, in Drools decision
    tables are a way to generate rules driven from the data entered into a
    spreadsheet. All the usual features of a spreadsheet for data capture and
    manipulation can be taken advantage of.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5777"/>5.1.1. When to use Decision tables</h3></div></div></div><p>Decision tables may want to be considered as a course of action if
      rules exist that can be expressed as rule templates and data. In each row
      of a decision table, data is collected that is combined with the
      templates to generate a rule.</p><p>Many businesses already use spreadsheets for managing data,
      calculating, etc. If you are happy to continue this way, you can also
      manage your business rules this way. This also assumes you are happy to
      manage packages of rules in .xls or .csv files. Decision tables are not
      recommended for rules that do not follow a set of templates, or where
      there are a small number of rules (or if there is a dislike towards
      software like Excel or Open Office). They are ideal in the sense that
      there can be control over what <span class="emphasis"><em>parameters</em></span> of rules
      can be edited, without exposing the rules directly.</p><p>Decision tables also provide a degree of insulation from the
      underlying object model.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5789"/>5.1.2. Overview</h3></div></div></div><p>Here are some examples of real world decision tables (slightly
      edited to protect the innocent).</p><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/excel.png" width="100%"/></td></tr></table></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/actions.png"/></div></div><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/open_office.png" width="100%"/></td></tr></table></div></div><p>In the above examples, the technical aspects of the decision table
      have been collapsed away (using a standard spreadsheet feature).</p><p>The rules start from row 17, with each row resulting in a rule. The
      conditions are in columns C, D, E, etc., the actions being off-screen. The
      values in the cells are quite simple, and their meaning is indicated by
      the headers in Row 16. Column B is just a description. It is
      customary to use color to make it obvious what the different areas of
      the table mean.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Note that although the decision tables look like they process
        top down, this is not necessarily the case. Ideally, rules are
        authored without regard for the order of rows, simply because
        this makes maintenance easier, as rows will not need to be shifted
        around all the time.</p></div><p>As each row is a rule, the same principles apply. As the rule
      engine processes the facts, any rules that match may fire. (Some people
      are confused by this. It is possible to clear the agenda when a rule
      fires and simulate a very simple decision table where the first match
      exists.) Also note that you can have multiple tables on one
      spreadsheet. This way, rules can be grouped where they share common
      templates, yet at the end of the day they are all combined into one rule
      package. Decision tables are essentially a tool to generate DRL rules
      automatically.</p><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/multi_table.png" width="100%"/></td></tr></table></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5827"/>5.1.3. How decision tables work</h3></div></div></div><p>The key point to keep in mind is that in a decision table each
      row is a rule, and each column in that row is either a condition or
      action for that rule.</p><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/row_col.png" width="100%"/></td></tr></table></div></div><p>The spreadsheet looks for the <em class="firstterm">RuleTable</em>
      keyword to indicate the start of a rule table (both the starting row and
      column). Other keywords are also used to define other package level
      attributes (covered later). It is important to keep the keywords in the
      one column. By convention the second column ("B") is used for this, but
      it can be any column (convention is to leave a margin on the left for
      notes). In the following diagram, C is actually the column where it
      starts. Everything to the left of this is ignored.</p><p>If we expand the hidden sections, it starts to make more sense how
      it works; note the keywords in column C.</p><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/expanded.png" width="100%"/></td></tr></table></div></div><p>Now the hidden magic which makes it work can be seen. The RuleSet
      keyword indicates the name to be used in the <span class="emphasis"><em>rule
      package</em></span> that will encompass all the rules. This name is
      optional, using a default, but it <span class="emphasis"><em>must</em></span> have the
      <span class="emphasis"><em>RuleSet</em></span> keyword in the cell immediately to the
      right.</p><p>The other keywords visible in Column C are Import and Sequential
      which will be covered later. The RuleTable keyword is important as it
      indicates that a chunk of rules will follow, based on some rule
      templates. After the RuleTable keyword there is a name,
      used to prefix the names of the generated rules. The row numbers are
      appended to guarantee unique rule names. The column of RuleTable
      indicates the column in which the rules start; columns to the left are
      ignored.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In general the keywords make up name-value pairs.</p></div><p>Referring to row 14 (the row immediately after RuleTable), the
      keywords CONDITION and ACTION indicate that the data in the columns
      below are for either the LHS or the RHS parts of a rule. There are other
      attributes on the rule which can also be optionally set this way.</p><p>Row 15 contains declarations of <em class="firstterm">ObjectTypes</em>.
      The content in this row is optional, but if this option is not in use,
      the row must be left blank; however this option is usually found to be
      quite useful. When using this row, the values in the cells below (row 16)
      become constraints on that object type. In the above case, it will
      generate <code class="code">Person(age=="42")</code> and
      <code class="code">Cheese(type=="stilton")</code>,
      where 42 and "stilton" come from row 18. In the
      above example, the "==" is implicit; if just a field name is given it
      will assume that it is to look for exact matches.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>An ObjectType declaration can span columns (via merged cells),
        meaning that all columns below the merged range will be combined into
        the one set of constraints.</p></div><p>Row 16 contains the rule templates themselves. They can use the
      "$para" place holder to indicate where data from the cells below will be
      populated ($param can be sued or $1, $2 etc to indicate parameters from
      a comma separated list in a cell below). Row 17 is ignored as it is
      textual descriptions of the rule template.</p><p>Rows 18 and 19 show data, which will be combined (interpolated)
      with the templates in row 15, to generate rules. If a cell contains no
      data, then its template is ignored. (This would mean that some condition
      or action does not apply for that rule row.) Rule rows are read until
      there is a blank row. Multiple RuleTables can exsist in a sheet. Row 20
      contains another keyword, and a value. The row positions of keywords
      like this do not matter (most people put them at the top) but their
      column should be the same one where the RuleTable or RuleSet keywords
      should appear. In our case column C has been chosen to be significant,
      but column A could be used instead.</p><p>In the above example, rules would be rendered like the following
      (as it uses the "ObjectType" row):</p><pre class="screen">//row 18
			rule "Cheese_fans_18"
			when
			Person(age=="42")
			Cheese(type=="stilton")
			then
			list.add("Old man stilton");
			end
</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The contraints <code class="code">age=="42"</code> and <code class="code">type=="stilton"</code>
        are interpreted as single constraints, to be added to the respective
        ObjectType in the cell above. If the cells above were spanned, then there
        could be multiple constraints on one "column".</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5900"/>5.1.4. Keywords and Syntax</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5903"/>5.1.4.1. Syntax of templates</h4></div></div></div><p>The syntax of what goes in the templates is dependent on if it
        is a CONDITION column or ACTION column. In most cases, it is identical
        to "vanilla" DRL for the LHS or RHS respectively.
        This means in the LHS, the constraint language must be used, and in
        the RHS it is a snippet of code to be executed.</p><p>The <code class="code">$param</code> place holder is used in templates to
        indicate where data form the cell will be interpolated. You can also
        use <code class="code">$1</code> to the same effect. If the cell contains a comma
        separated list of values. Symbols $1, $2, etc. may be used to indicate which
        positional parameter from the list of values in the cell will be
        used.</p><div class="example"><a id="d0e5916"/><p class="title"><b>Example 5.1. Interpolating cell data</b></p><div class="example-contents"><p>If the template is [Foo(bar == $param)] and the cell is [ 42
          ] then the result will be [Foo(bar == 42)].</p><p>If the template is
          [Foo(bar &lt; $1, baz == $2)] and the cell is [42,42] then the
          result will be [Foo(bar &gt; 42, baz ==42)]</p></div></div><br class="example-break"/><p>For conditions: How snippets are rendered depends on the presence
        of an entry in the row above, where ObjectType declarations may appear.
        If there is such an entry, the snippets are rendered as individual constraints
        on that ObjectType. If there isn't, then they are just rendered as is
        (with values substituted). If just a plain field is entered (as in the
        example above) then it will assume that this means equality. If another
        operator is placed at the end of the snippet, then the values will be
        interpolated at the end of the constraint, otherwise it will look for
        <code class="code">$param</code> as outlined previously.</p><p>For consequences: How snippets are rendered also depends on the presence
        of an entry in the row immediately above it. If there is no entry,
        the output is simply the interpolated snippets. If there is
        something there (which would typically be a bound variable or a global
        like in the example above) then it will append it as a method call on
        that object (refer to the above example).</p><p>This may be easiest to understand with some examples, given below.
        </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/spanned_column.png"/></div></div><p> The above shows how the Person ObjectType declaration
        spans 2 columns in the spreadsheet, thus both constraints will appear
        as Person(age == ... , type == ...). As before, since only the field
        names are present in the snippet, they imply an equality test.
        </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/with_param.png"/></div></div><p> The above condition example shows how you use
        interpolation to place the values in the snippet (in this case it
        would result in Person(age == "42")).</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/operator_completion.png"/></div></div><p> The above condition example shows that if you put an
        operator on the end by itself, the values will be placed after the
        operator automatically. </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/with_binding.png"/></div></div><p> A binding can be put in before the column (the
        constraints will be added from the cells below). Anything can be
        placed in the ObjectType row. (For instance, this could be a
        precondition for the columns in the spreadsheet columns that follow).</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/consequence.png"/></div></div><p> This shows how the consequence could be done by
        simple interpolation: just leave the cell above blank. (The same
        applies to condition columns.) With this style anything can be placed
        in the consequence, not just one method call.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5957"/>5.1.4.2. Keywords</h4></div></div></div><p>The following table describes the keywords that are pertinent to
        the rule table structure.</p><div class="table"><a id="d0e5962"/><p class="title"><b>Table 5.1. Keywords</b></p><div class="table-contents"><table summary="Keywords" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Keyword</th><th>Description</th><th>Inclusion Status</th></tr></thead><tbody><tr><td>RuleSet</td><td>The cell to the right of this contains the ruleset
                name.</td><td>One only; if left out, it will default.</td></tr><tr><td>Sequential</td><td>The cell to the right of this can be true or false. If
                true, then salience is used to ensure that rules fire from the
                top down.</td><td>Optional</td></tr><tr><td>Import</td><td>The cell to the right contains a comma separated list
                of Java classes to import.</td><td>Optional</td></tr><tr><td>RuleTable</td><td>A cell starting with RuleTable indicates the start of a
                definition of a rule table. The actual rule table starts the
                next row down. The rule table is read left-to-right, and
                top-down, until the next blank row.</td><td>At least one; if there are more, then they are all
                added to the one ruleset.</td></tr><tr><td>CONDITION</td><td>Indicates that this column will be for rule
                conditions.</td><td>At least one per rule table</td></tr><tr><td>ACTION</td><td>Indicates that this column will be for rule
                consequences.</td><td>At least one per rule table</td></tr><tr><td>PRIORITY</td><td>Indicates that this column's values will set the
                'salience' values for the rule row. Over-rides the
                'Sequential' flag.</td><td>Optional</td></tr><tr><td>DURATION</td><td>Indicates that this column's values will set the
                duration values for the rule row.</td><td>Optional</td></tr><tr><td>NAME</td><td>Indicates that this column's values will set the name
                for the rule generated from that row.</td><td>Optional</td></tr><tr><td>Functions</td><td>The cell immediately to the right can contain functions
                which can be used in the rule snippets. Drools supports
                functions defined in the DRL, allowing logic to be embedded in
                the rule, and changed without hard coding, use with care. Same
                syntax as regular DRL.</td><td>Optional</td></tr><tr><td>Variables</td><td>The cell immediately to the right can contain global
                declarations which Drools supports. This is a type, followed
                by a variable name. (If multiple variables are needed, separate
                them with commas.)</td><td>Optional</td></tr><tr><td>No-loop or Unloop</td><td>Placed in the header of a table, no-loop or unloop will
                both complete the same function of not allowing a rule (row)
                to loop. For this option to function correctly, there must be
                a value (true or false) in the cell for the option to take
                effect. If the cell is left blank then this option will not be
                set for the row.</td><td>Optional</td></tr><tr><td>XOR-GROUP</td><td>Cell values in this column mean that the rule row
                belongs to the given Activation group . An Activation
                group means that only one rule in the named group will fire
                (i.e., the first one to fire cancels the other rules'
                activations).</td><td>Optional</td></tr><tr><td>AGENDA-GROUP</td><td>Cell values in this column mean that the rule row
                belongs to the given Agenda group. (This is one way of
                controlling flow between groups of rules - see also "rule
                flow").</td><td>Optional</td></tr><tr><td>RULEFLOW-GROUP</td><td>Cell values in this column mean that the rule row
                belongs to the given rule-flow group.</td><td>Optional</td></tr><tr><td>Worksheet</td><td>By default, the first worksheet is only looked at for
                decision tables.</td><td>N/A</td></tr></tbody></table></div></div><br class="table-break"/><p>Below you will find examples of using the HEADER keyword, which
        affects the rules generated for each row. Note that the header name is
        what is important in most cases. If no value appears in the cells
        below it, then the attribute will not apply (it will be ignored) for
        that specific row.</p><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Decision_Tables/Key.png" width="100%"/></td></tr></table></div></div><p>The following is an example of Import (comma delimited),
        Variables (gloabls) - also comma delimited, and a function block (can
        be multiple functions - just the usual drl syntax). This can appear in
        the same column as the "RuleSet" keyword, and can be below all the
        rule rows if you desire.</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/keywords.png"/></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6103"/>5.1.5. Creating and integrating Spreadsheet based Decision
      Tables</h3></div></div></div><p>The API to use spreadsheet based decision tables is in the
      drools-decisiontables module. There is really only one class to look at:
      SpreadsheetCompiler. This class will take spreadsheets in various
      formats, and generate rules in DRL (which you can then use in the normal
      way). The SpreadsheetComiler can just be used to generate partial rule
      files if it is wished, and assemble it into a complete rule package
      after the fact (this allows the seperation of technical and
      non-technical aspects of the rules if needed).</p><p>To get started, a sample spreadsheet can be used as base.
      Alternatively, if the plug-in is being used (Rule Workbench IDE), the
      wizard can generate a spreadsheet from a template (to edit it an xls
      compatible spreadsheet editor will need to be used). </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/wizard.png"/></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6116"/>5.1.6. Managing business rules in decision tables.</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6119"/>5.1.6.1. Workflow and collaboration.</h4></div></div></div><p>Spreadsheets are well established business tools (in use for
        over 25 years). Decision tables lend themselves to close collaboration
        between IT and domain experts, while making the business rules clear
        to business analysts, it is an ideal separation of concerns.</p><p>Typically, the whole process of authoring rules (coming up with
        a new decision table) would be something like:</p><div class="orderedlist"><ol type="1"><li><p>Business analyst takes a template decision table (from a
            repository, or from IT)</p></li><li><p>Decision table business language descriptions are entered in
            the table(s)</p></li><li><p>Decision table rules (rows) are entered (roughly)</p></li><li><p>Decision table is handed to a technical resource, who maps
            the business language (descriptions) to scripts (this may involve
            software development of course, if it is a new application or data
            model)</p></li><li><p>Technical person hands back and reviews the modifications
            with the business analyst.</p></li><li><p>The business analyst can continue editing the rule rows as
            needed (moving columns around is also fine etc).</p></li><li><p>In parallel, the technical person can develop test cases for
            the rules (liaising with business analysts) as these test cases
            can be used to verify rules and rule changes once the system is
            running.</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6148"/>5.1.6.2. Using spreadsheet features</h4></div></div></div><p>Features of applications like Excel can be used to provide
        assistance in entering data into spreadsheets, such as validating
        fields. Lists that are stored in other worksheets can bse used to
        provide valid lists of values for cells, like in the following
        diagram. </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/lists.png"/></div></div><p>Some applications provide a limited ability to keep a history of
        changes, but it is recommended that an alternative means of revision
        control is also used. When changes are being made to rules over time,
        older versions are archived (many solutions exist for this which are
        also open source, such as Subversion).
        http://www.drools.org/Business+rules+in+decision+tables+explained</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6161"/>5.1.7. Rule Templates</h3></div></div></div><p>Related to decision tables (but not necessarily requiring a
      spreadsheet) are "Rule Templates" (in the drools-templates module).
      These use any tablular data source as a source of rule data - populating
      a template to generate many rules. This can allow both for more flexible
      spreadsheets, but also rules in existing databases, for instance (at the
      cost of developing the template up front to generate the rules).</p><p>With Rule Templates the data is separated from the rule, and there
      are no restrictions on which part of the rule is data-driven. So whilst
      you can do everything you could do in decision tables you can also do
      the following:</p><div class="itemizedlist"><ul><li><p>store your data in a database (or any other format)</p></li><li><p>conditionally generate rules based on the values in the
          data</p></li><li><p>use data for any part of your rules (e.g. condition operator,
          class name, property name)</p></li><li><p>run different templates over the same data</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6181"/>5.1.7.1. A decision table-like example</h4></div></div></div><p>As an example, a more classic decision table is shown, but
        without any hidden rows for the rule meta data (so the spreadsheet
        only contains the raw data to generate the rules).</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/template1.png"/></div></div><p>See the "ExampleCheese.xls" in the examples download for the
        above spreadsheet.</p><p>If this was a regular decision table there would be hidden rows
        before row 1 and between rows 1 and 2 containing rule metadata. With
        rule templates the data is completely separate from the rules. This
        has two handy consequences - you can apply multiple rule templates to
        the same data and your data is not tied to your rules at all. So what
        does the template look like?</p><pre class="programlisting">
1  template header
2  age
3  type
4  log
5
6  package org.drools.examples.templates;
7
8  global java.util.List list;
9
10 template "cheesefans"
11
12 rule "Cheese fans_@{row.rowNumber}"
13 when
14    Person(age == @{age})
15    Cheese(type == "@{type}")
16 then
17    list.add("@{log}");
18 end
19
20 end template
	</pre><p>Referring to the above:</p><pre class="programlisting">
Line 1: all rule templates start with "template header"
Lines 2-4: following the header is the list of columns in the order they appear in the data. In this case we are calling the first column "age", the second "type" and the third "log".
Lines 5: empty line signifying the end of the column definitions
Lines 6-9: standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global definitions
Line 10: The "template" keyword signals the start of a rule template. There can be more than one template in a template file. The template should have a unique name.
Lines 11-18: The rule template - see below
Line 20: "end template" signifies the end of the template.
</pre><p>The rule templates rely on MVEL to do substitution using the
        syntax @{token_name}. There is currently one built-in expression,
        @{row.rowNumber} which gives a unique number for each row of data and
        enables you to generate unique rule names. For each row of data a rule
        will be generated with the values in the data substituted for the
        tokens in the template. With the example data above the following rule
        file would be generated:</p><pre class="programlisting">
package org.drools.examples.templates;

global java.util.List list;

rule "Cheese fans_1"
when
  Person(age == 42)
  Cheese(type == "stilton")
then
  list.add("Old man stilton");
end

rule "Cheese fans_2"
when
  Person(age == 21)
  Cheese(type == "cheddar")
then
  list.add("Young man cheddar");
end
</pre><p>The code to run this is simple:</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
DecisionTableConfiguration dtconf = KnowledgeBuilderFactory.newDecisionTableConfiguration();
dtconf.setInputType( DecisionTableInputType.XLS );
dtconf.setWorksheetName( "Tables_2" );
kbuilder.add( ResourceFactory.newInputStreamResource( getSpreadsheetStream() ),
              ResourceType.DTABLE,
              dtconf );

Collection&lt;KnowlegePackage&gt; kpkg = kbuilder.getKnowlegePackages();
</pre><p>We create an ExternalSpreadsheetCompiler object and use it to
        merge the spreadsheet with the rules. The two integer parameters
        indicate the column and row where the data actually starts - in our
        case column 2, row 2 (i.e. B2)</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6212"/>5.2. Templates</h2></div></div></div><p>If you discover that you have a group of rules following
    the same arrangement of patterns, constraints and actions on
    the RHS, differing only in constants or names for objects or
    fields, you might think of employing Drool's rule template feature
    for generating the actual rules. You would write a 
    <span class="emphasis"><em>rule template</em></span> file, containing the
    textual skeleton of your rule and use the Drools template
    compiler in combination with a collection of objects providing
    the actual values for the "flesh" of the rules for their
    instantiation.</p><p>The mechanism is very similar to what a macro processor
    does. The major advantage proffered by template expansion is
    that it's nicely integrated in the overall handling of
    Knowledge Resources.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>This is an experimental feature. In particular,
    the API is subject to change.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6225"/>5.2.1. The Rule Template File</h3></div></div></div><p>A rule template file begins with a header defining the
      placeholders, or <span class="emphasis"><em>formal template parameters</em></span> 
      for the strings that are to be inserted during instantiation. 
      After the first line, which invariably contains <strong class="kw"><code>template header</code></strong>,
      you should write a number of lines, each of which contains a single
      parameter name.</p><div class="example"><a id="d0e6236"/><p class="title"><b>Example 5.2. Rule template file: template header</b></p><div class="example-contents"><pre class="programlisting">
<span class="bold"><strong>template header</strong></span>
<span class="emphasis"><em>parameter-name-1</em></span>
...
<span class="emphasis"><em>parameter-name-n</em></span>
...</pre></div></div><br class="example-break"/><p>The template header is followed by the text that is to
      be replicated and interpolated with the actual parameters. It
      may begin with a <strong class="kw"><code>package</code></strong> statement, followed by some
      additional lines. These 
      may be sectioned into one or more templates, each of them
      between a pair of matching <strong class="kw"><code>template</code></strong> and
      <strong class="kw"><code>end template</code></strong> statements. The <strong class="kw"><code>template</code></strong> takes
      an argument, which puts a name to the template. The name
      can be a simple unquoted name or an arbitrary string enclosed
      in double quotes. The template text between these lines may
      contain one or more rules, constituting the "raw material"
      for the expansion.</p><div class="example"><a id="d0e6264"/><p class="title"><b>Example 5.3. Rule template file: templates</b></p><div class="example-contents"><pre class="programlisting">
<span class="bold"><strong>template header</strong></span>
<span class="bold"><strong><span class="emphasis"><em>parameter-name-1</em></span></strong></span>
...
<span class="emphasis"><em>parameter-name-n</em></span>
<span class="bold"><strong>package ...</strong></span>     # optional
<span class="emphasis"><em>header text</em></span>    # optional
<span class="bold"><strong>template</strong></span> <span class="emphasis"><em>template-name</em></span>
...
// template text
...
<span class="bold"><strong>end template</strong></span>
...</pre></div></div><br class="example-break"/><p>The resulting text will begin with the package line and the
      header text following it, if present. Then, each template text
      will be expanded individually, yielding one set of rules for each
      of the actual parameter sets. Therefore, the structure of the
      template sections affect the order of the generated rules, since
      the generator iterates over the sections and then over the
      set of actual parameters.</p><p>Any interpolation takes place between a pair of <strong class="kw"><code>template</code></strong>
      and <strong class="kw"><code>end template</code></strong> statements, when this template is
      expanded. The template text is scanned for occurrences of
      <span class="emphasis"><em>parameter expansions</em></span> written according to:
      </p><pre class="programlisting">
<span class="bold"><strong>@{<span class="emphasis"><em>parameter-name</em></span>}</strong></span></pre><p>
      The name between '@{' and '}' should be one of the parameter names
      defined in the template header. The substitution is effected anywhere,
      even within string literals.</p><p>An important parameter is available without having to be
      included in the data source providing the actual values. The
      parameter substitution
      </p><pre class="programlisting">
<span class="bold"><strong>@{row.rowNumber}</strong></span></pre><p>
      expands to the integers 0, 1, 2, etc., providing a unique distinction
      for the instantiation derived from a parameter set. You would use this
      as part of each rule name, because, without this precaution, there
      would be duplicate rule names. (You are, of course, free to use your
      own identification included as an extra parameter.)</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6322"/>5.2.2. Expanding a Template</h3></div></div></div><p>To expand a template, you must prepare a data source. This can
      be a spreadsheet, as explained in the previous section. Here, we'll
      concentrate on expansion driven by Java objects. There are two
      straightforward ways of supplying values for a fixed set of names:
      Java objects, in the JavaBeans style, and Maps. Both of them can
      be arranged in a <code class="code">Collection</code>, whose elements will be
      processed during the expansion, resulting in an instantiation
      for each element.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6330"/>5.2.2.1. Instantiation from Java Objects</h4></div></div></div><p>You may use a Java object that provides getter methods
        corresponding to all of the parameter names of your template
        file. If, for instance, you have defined a header
        </p><pre class="programlisting">
template header
type
limit
word</pre><p>
        the following Java class could be used:
        </p><pre class="programlisting">
public class ParamSet {
    //...
    public ParamSet( String t, int l, boolean w ) {
        //...
    }
    public String  getType(){...}
    public int     getLimit(){...}
    public boolean isWord(){...}
}</pre><p>
        Although interpolation is pure text manipulation, the actual values
        supplied may be of any type, just as long as this type provides a
        reasonable <code class="code">toString()</code> method. (For simple types, the
        eponymous static method of the related class from <code class="code">java.lang</code>
        is used.)</p><p>Assuming that we have created a <code class="code">Collection&lt;ParamSet&gt;</code>
        for a template file <code class="code">template.drl</code>, we can now proceed to
        request its expansion.</p><pre class="programlisting">
Collection&lt;ParamSet&gt; paramSets = new ArrayList&lt;ParamSet&gt;();
// populate paramSets
paramSets.add( new ParamSet( "Foo", 42, true ) );
paramSets.add( new ParamSet( "Bar", 13, false ) );
ObjectDataCompiler converter = new ObjectDataCompiler();
InputStream templateStream =
    this.getClass().getResourceAsStream( "template.drl" );
String drl = converter.compile( objs, templateStream );</pre>

        The resulting string contains the expanded rules text. You could
        write it to a file and proceed as usual, but it's also possible to
        feed this to a <code class="code">KnowledgeBuilder</code> and continue with the
        resulting Knowledge Packages.

        <pre class="programlisting">
KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();
KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
Reader rdr = new StringReader( drl );
kBuilder.add( ResourceFactory.newReaderResource( rdr ), ResourceType.DRL );
if( kBuilder.hasErrors() ){
    // ...
    throw new IllegalStateException( "DRL errors" );
}
kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6363"/>5.2.2.2. Instantiation from Maps</h4></div></div></div><p>A <code class="code">Map</code> that provides the values for substituting
        template parameters should have a (string) key set matching all of
        the parameter names. Again, values could be from any class, as long
        as they provide a good <code class="code">toString()</code> method. The expansion
        would use the same approach, just differing in the way the
        map collection is composed.</p><pre class="programlisting">
Collection&lt;Map&lt;String,Object&gt;&gt; paramMaps = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();
// populate paramMaps
ObjectDataCompiler converter = new ObjectDataCompiler();
InputStream templateStream =
    this.getClass().getResourceAsStream( "template.drl" );
String drl = converter.compile( objs, templateStream );</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6376"/>5.2.3. Example</h3></div></div></div><p>The following example illustrates template expansion. It is based on simple
       objects of class <code class="code">Item</code> containing a couple of integer fields and an
       <code class="code">enum</code> field of type <code class="code">ItemCode</code>.</p><pre class="programlisting">
public class Item {
    // ...
    public Item( String n, int p, int w, ItemCode c ){...}

    public String   getName() {...}
    public int      getWeight() {...}
    public int      getPrice() {...}
    public ItemCode getCode() {...}
}

public enum ItemCode {
    LOCK,
    STOCK,
    BARREL;
}</pre><p>The rule template contains a single rule. Notice that the field
         name for the range test is a parameter, which enables us to instantiate
         the template for different fields.</p><pre class="programlisting">
template header
field
lower
upper
codes

package range;
template "inRange"
rule "is in range @{row.rowNumber}"
when
    Item( $name : name, $v : @{field} &gt;= @{lower} &amp;&amp; &lt;= @{upper}, $code : code @{codes} )
then
    System.out.println( "Item " + $name + " @{field} in range: " + $v + " code: " + $code );
end
end template</pre><p>The next code snippet is from the application, where several
         parameter sets have to be set up. First, there is class
         <code class="code">ParamSet</code>, for storing a set of actual parameters.</p><pre class="programlisting">
public class ParamSet {
    //...
    private EnumSet&lt;ItemCode&gt; codeSet;
	
    public ParamSet( String f, int l, int u, EnumSet&lt;ItemCode&gt; cs ){...}

    public String getField() { return field; }
    public int getLower() { return lower; }
    public int getUpper() { return upper; }

    public String getCodes(){
        StringBuilder sb = new StringBuilder();
        String conn = "";
        for( ItemCode ic: codeSet ){
             sb.append( conn ).append( " == ItemCode." ).append( ic );
             conn = " ||";
        }
        return sb.toString();
    }	
}</pre><p>Note that the method <code class="code">getCodes()</code> does returns the
        <code class="code">EnumSet&lt;ItemCode&gt;</code> field value as a <code class="code">String</code>
        value representing a multiple restriction, i.e., a test for one out
        of a list of values.</p><p>The task of expanding a template, passing the resulting DRL text
        to a Knowledge Builder and adding the resulting Knowledge Packages
        to a Knowledge Base is generic. The utility class <code class="code">Expander</code>
        takes care of this, using a Knowledge Base, the <code class="code">InputStream</code>
        with the rule template and the collection of parameter sets.</p><pre class="programlisting">
public class Expander {
	
    public void expand( KnowledgeBase kBase, InputStream is, Collection&lt;?&gt; act )
        throws Exception {
        ObjectDataCompiler converter = new ObjectDataCompiler();		
        String drl = converter.compile( act, is );
        
        KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
        Reader rdr = new StringReader( drl );
        kBuilder.add( ResourceFactory.newReaderResource( rdr ), ResourceType.DRL );
        if( kBuilder.hasErrors() ){
            for( KnowledgeBuilderError err: kBuilder.getErrors() ){
                System.err.println( err.toString() );
            }
            throw new IllegalStateException( "DRL errors" );
        }
        kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );
    }
}</pre><p>We are now all set to prepare the Knowledge Base with some
        generated rules. First, we define several parameter sets,
        constructed as <code class="code">ParamSet</code> objects, and add them to a
        <code class="code">List</code>, which is passed to the <code class="code">expand</code>
        method shown above. Then we launch a stateful session, insert a
        few <code class="code">Item</code>, and watch what happens.</p><pre class="programlisting">
Collection&lt;ParamSet&gt; cfl = new ArrayList&lt;ParamSet&gt;();
cfl.add( new ParamSet( "weight",  10,  99, EnumSet.of( ItemCode.LOCK, ItemCode.STOCK ) ) );
cfl.add( new ParamSet( "price",   10,  50, EnumSet.of( ItemCode.BARREL ) ) );

KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();
Expander ex = new Expander();
InputStream dis = new FileInputStream( new File( "rangeTemp.drl" ) );
ex.expand( kBase, dis, cfl );
        
StatefulKnowledgeSession session = kBase.newStatefulKnowledgeSession();
session.insert( new Item( "A", 130,  42, ItemCode.LOCK ) );
session.insert( new Item( "B",  44, 100, ItemCode.STOCK ) );
session.insert( new Item( "C", 123, 180, ItemCode.BARREL ) );
session.insert( new Item( "D",  85,   9, ItemCode.LOCK ) );
        
session.fireAllRules();</pre><p>Notice that the two resulting rules deal with
         <span class="emphasis"><em>different</em></span> fields, one with an item's weight,
         the other one with its price. - Below is the output.</p><pre class="programlisting">
Item E price in range: 25 code: BARREL
Item A weight in range: 42 code: LOCK</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6447"/>Chapter 6. The Java Rule Engine API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e6450">6.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6465">6.2. How To Use</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6470">6.2.1. Building and Registering RuleExecutionSets</a></span></dt><dt><span class="section"><a href="#d0e6503">6.2.2. Using Stateful and Stateless RuleSessions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6538">6.3. References</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6450"/>6.1. Introduction</h2></div></div></div><p>
		Drools provides an implementation of the Java Rule Engine API (known
		as JSR94), which allows for support of multiple rule engines from a
		single API. JSR94 does not deal in any way with the rule language
                itself. W3C is working on the
		<a class="ulink" href="http://www.w3.org/TR/2006/WD-rif-ucr-20060323/">Rule Interchange Format (RIF)</a>
		and the OMG has started to work on a standard based on
		<a class="ulink" href="http://ruleml.org/">RuleML</a>.
		Recently Haley Systems has also proposed a rule language standard
                called RML.
	</p><p>It should be remembered that the JSR94 standard represents the "least
		common denominator" in features across rule engines. This means that
                there is less functionality in the JSR94 API than in the standard
                Drools API. So, by using JSR94, you forfeit the advantage of using the
		full capabilities of the Drools Rule Engine. It is necessary to expose
		further functionality, like globals and support for DRL, DSL and XML,
		via property maps due to the very basic feature set of JSR94; this
                introduces non-portable functionality. Furthermore, as JSR94 does not
                provide a rule language, you are only solving a small fraction of the
                complexity of switching rule engines with very little gain. So, while
                we support JSR94, for those that insist on using it, we strongly
                recommend you program against the Drools API.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6465"/>6.2. How To Use</h2></div></div></div><p>There are two parts to working with JSR94. The first part is the
  administrative API that deals with building and registering RuleExecutionSet objects,
  the second part is runtime session execution of these RuleExecutionSets.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6470"/>6.2.1. Building and Registering RuleExecutionSets</h3></div></div></div><p>The RuleServiceProviderManager manages the registration and
    retrieval of RuleServiceProviders. The Drools RuleServiceProvider
    implementation is automatically registered via a static block when the
    class is loaded using Class.forNamem, in much the same way as JDBC
    drivers.</p><div class="example"><a id="d0e6476"/><p class="title"><b>Example 6.1. Automatic RuleServiceProvider Registration</b></p><div class="example-contents"><pre class="programlisting">// RuleServiceProviderImpl is registered to "http://drools.org/"
// via a static initialization block
Class.forName("org.drools.jsr94.rules.RuleServiceProviderImpl");

// Get the rule service provider from the provider manager.
RuleServiceProvider ruleServiceProvider =
  RuleServiceProviderManager.getRuleServiceProvider("http://drools.org/");</pre></div></div><p><br class="example-break"/>The RuleServiceProvider provides access to the RuleRuntime and
    RuleAdministrator APIs. The RuleAdministrator provides an administration
    API for the management of RuleExecutionSet objects, making it possible to
    register a RuleExecutionSet that can then be retrieved via the
    RuleRuntime.</p><p>First, you need to create a RuleExecutionSet before it can be
    registered; RuleAdministrator provides factory methods to return an empty
    LocalRuleExecutionSetProvider or RuleExecutionSetProvider. The
    LocalRuleExecutionSetProvider should be used to load a RuleExecutionSets
    from local sources that are not serializable, like Streams. The
    RuleExecutionSetProvider can be used to load RuleExecutionSets from
    serializable sources, like DOM Elements or Packages. Both the
    "ruleAdministrator.getLocalRuleExecutionSetProvider( null );" and the
    "ruleAdministrator.getRuleExecutionSetProvider( null );" take null as a
    parameter, as the properties map for these methods is not currently
    used.</p><div class="example"><a id="d0e6484"/><p class="title"><b>Example 6.2. Registering a LocalRuleExecutionSet with the RuleAdministrator
      API</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministrator ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider =
  ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create the RuleExecutionSet for the drl
RuleExecutionSet ruleExecutionSet =
  ruleExecutionSetProvider.createRuleExecutionSet( drlReader, null );
</pre></div></div><br class="example-break"/><p>"ruleExecutionSetProvider.createRuleExecutionSet( reader, null )" in
    the above example takes a null parameter for the properties map; however
    it can actually be used to provide configuration for the incoming source.
    When null is passed the default is used to load the input as a drl.
    Allowed keys for a map are "source" and "dsl". The key "source" takes "drl" or
    "xml" as its value; you set "source" to "drl" to load a DRL, or to "xml" to
    load an XML source; "xml" will ignore any "dsl" key/value settings. The
    "dsl" key can take a Reader or a String (the contents of the dsl) as a
    value.</p><div class="example"><a id="d0e6491"/><p class="title"><b>Example 6.3. Specifying a DSL when registering a LocalRuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministration ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider =
  ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create a Reader for the dsl and a put in the properties map
URL dslUrl = new URL("http://mydomain.org/sources/myrules.dsl");
Reader dslReader = new InputStreamReader( dslUrl.openStream()  );
Map properties = new HashMap();
properties.put( "source", "drl" );
properties.put( "dsl", dslReader );

// Create the RuleExecutionSet for the drl and dsl
RuleExecutionSet ruleExecutionSet =
  ruleExecutionSetProvider.createRuleExecutionSet( reader, properties );
</pre></div></div><br class="example-break"/><p>When registering a RuleExecutionSet you must specify the name to be
    used for its retrieval. There is also a field to pass properties, which is
    currently unused - so just pass null.</p><div class="example"><a id="d0e6498"/><p class="title"><b>Example 6.4. Register the RuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Register the RuleExecutionSet with the RuleAdministrator
String uri = ruleExecutionSet.getName();
ruleAdministrator.registerRuleExecutionSet(uri, ruleExecutionSet, null);</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6503"/>6.2.2. Using Stateful and Stateless RuleSessions</h3></div></div></div><p>The Runtime, obtained from the RuleServiceProvider, is used to
    create stateful and stateless rule engine sessions.</p><div class="example"><a id="d0e6508"/><p class="title"><b>Example 6.5. Getting the RuleRuntime</b></p><div class="example-contents"><pre class="programlisting">RuleRuntime ruleRuntime = ruleServiceProvider.getRuleRuntime();</pre></div></div><br class="example-break"/><p>To create a rule session you must use one of the two RuleRuntime
    public constants. These are "RuleRuntime.STATEFUL_SESSION_TYPE" and
    "RuleRuntime.STATELESS_SESSION_TYPE", accompanying the URI to the
    RuleExecutionSet you wish to instantiate a RuleSession for. The properties
    map can be null, or it can be used to specify globals, as shown in the
    next section. The createRuleSession(...) method returns a RuleSession
    instance which must then be cast to StatefulRuleSession or
    StatelessRuleSession.</p><div class="example"><a id="d0e6515"/><p class="title"><b>Example 6.6. Stateful Rule</b></p><div class="example-contents"><pre class="programlisting">(StatefulRuleSession) session =
  ruleRuntime.createRuleSession( uri,
                                 null,
                                 RuleRuntime.STATEFUL_SESSION_TYPE );
session.addObject( new PurchaseOrder( "lots of cheese" ) );
session.executeRules();</pre></div></div><br class="example-break"/><p>The StatelessRuleSession has a very simple API; you can only call
    executeRules(List list) passing a list of objects, and an optional filter,
    the resulting objects are then returned.</p><div class="example"><a id="d0e6522"/><p class="title"><b>Example 6.7. Stateless</b></p><div class="example-contents"><pre class="programlisting">(StatelessRuleSession) session =
  ruleRuntime.createRuleSession( uri,
                                 null,
                                 RuleRuntime.STATELESS_SESSION_TYPE );
List list = new ArrayList();
list.add( new PurchaseOrder( "even more cheese" ) );

List results = new ArrayList();
results = session.executeRules( list );</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6527"/>6.2.2.1. Globals</h4></div></div></div><p>It is possible to support globals with JSR94, in a manner that is
      not portable, by using the properties map passed to the RuleSession factory
      method. Globals must be defined in the DRL or XML file first, otherwise
      an exception will be thrown. The key represents the identifier declared
      in the DRL or XML, and the value is the instance you wish to be used in
      the execution. In the following example the results are collected in a
      java.util.List which is used as global:</p><pre class="programlisting">java.util.List globalList = new java.util.ArrayList( );
java.util.Map map = new java.util.HashMap( );
map.put( "list", globalList ); 
//Open a stateless Session
StatelessRuleSession srs =
  (StatelessRuleSession) runtime.createRuleSession( "SistersRules",
                                                    map,
                                                    RuleRuntime.STATELESS_SESSION_TYPE );
...
// Persons added to List
// call executeRules( ) giving a List of Objects as parameter
// There are rules which will put Objects in the List
// fetch the list from the map
List list = (java.util.List) map.get("list");</pre><p>Do not forget to declare the global "list" in your DRL:</p><pre class="programlisting">package SistersRules; 
import org.drools.jsr94.rules.Person; 
global java.util.List list
rule FindSisters 
when 
    $person1 : Person ( $name1:name ) 
    $person2 : Person ( $name2:name ) 
    eval( $person1.hasSister($person2) ) 
then 
    list.add($person1.getName() + " and " + $person2.getName() +" are sisters"); 
    assert( $person1.getName() + " and " + $person2.getName() +" are sisters"); 
end</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6538"/>6.3. References</h2></div></div></div><p>If you need more information on JSR 94, please refer to the following
  references </p><div class="orderedlist"><ol type="1"><li><p>Official JCP Specification for Java Rule Engine API (JSR
        94)</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.jcp.org/en/jsr/detail?id=94">http://www.jcp.org/en/jsr/detail?id=94</a></p></li></ul></div></li><li><p>The Java Rule Engine API documentation</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.javarules.org/api_doc/api/index.html">http://www.javarules.org/api_doc/api/index.html</a></p></li></ul></div></li><li><p>The Logic From The Bottom Line: An Introduction to The Drools
        Project. By N. Alex Rupp, published on TheServiceSide.com in
        2004</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Drools">http://www.theserverside.com/articles/article.tss?l=Drools</a></p></li></ul></div></li><li><p>Getting Started With the Java Rule Engine API (JSR 94): Toward
        Rule-Based Applications. By Dr. Qusay H. Mahmoud, published on Sun
        Developer Network in 2005</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html">http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html</a></p></li></ul></div></li><li><p>Jess and the javax.rules API. By Ernest Friedman-Hill, published
        on TheServerSide.com in 2003</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Jess">http://www.theserverside.com/articles/article.tss?l=Jess</a></p></li></ul></div></li></ol></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6584"/>Chapter 7. The Rule IDE (Eclipse)</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e6602">7.1. Features Outline</a></span></dt><dt><span class="section"><a href="#d0e6658">7.2. Creating a Rule Project</a></span></dt><dt><span class="section"><a href="#d0e6681">7.3. Creating a New Rule and Wizards</a></span></dt><dt><span class="section"><a href="#d0e6702">7.4. Textual Rule Editor</a></span></dt><dt><span class="section"><a href="#d0e6725">7.5. The Guided Editor (Rule GUI)</a></span></dt><dt><span class="section"><a href="#d0e6742">7.6. Drools Views</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6759">7.6.1. The Working Memory View</a></span></dt><dt><span class="section"><a href="#d0e6773">7.6.2. The Agenda View</a></span></dt><dt><span class="section"><a href="#d0e6787">7.6.3. The Global Data View</a></span></dt><dt><span class="section"><a href="#d0e6801">7.6.4. The Audit View</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6885">7.7. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6892">7.7.1. Editing languages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6915">7.8. The Rete View</a></span></dt><dt><span class="section"><a href="#d0e6931">7.9. Large DRL Files</a></span></dt><dt><span class="section"><a href="#d0e6947">7.10. Debugging Rules</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6958">7.10.1. Creating Breakpoints</a></span></dt><dt><span class="section"><a href="#d0e6972">7.10.2. Debugging Rules</a></span></dt></dl></dd></dl></div><p>
    The Eclipse based IDE provides developers (and very technical users) with
    an environment to edit and test rules in various formats, and integrate it
    deeply with their applications. In cases where you prefer business rules and
    web tooling, you will want to look at the BRMS (but using the BRMS and the
    IDE together is not uncommon).</p><p>The Drools IDE is delivered as an Eclipse plug-in, which
  allows you to author and manage rules from within Eclipse, as well as
  integrate rules with your application. This is an optional tool, and not all
  components are required to be used, you can use what components are relevant
  to you. The Drools IDE is also a part of the Red Hat Developer Studio
  (formerly known as JBoss IDE).</p><p>This guide will cover some of the features of JBoss Drools, in as far
  as the IDE touches on them (it is assumed that the reader has some
  familiarity with rule engines, and Drools in particular. It is important to
  note that none of the underlying features of the rule engine are dependent
  on Eclipse, and integrators are free to use their tools of choice, as always
  ! Plenty of people use IntelliJ with rules, for instance.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You can get the plug-in either as a zip to download, or from an
  update site. Refer to the chapter on installation.</p></div><div class="figure"><a id="d0e6596"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-IDE/all.jpg" width="100%" alt="Overview"/></td></tr></table></div></div><p class="title"><b>Figure 7.1. Overview</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6602"/>7.1. Features Outline</h2></div></div></div><p>The rules IDE has the following features</p><div class="orderedlist"><ol type="1"><li><p>Textual/graphical rule editor</p><div class="orderedlist"><ol type="a"><li><p>An editor that is aware of DRL syntax, and provides content
            assistance (including an outline view)</p></li><li><p>An editor that is aware of DSL (domain specific langauge) extensions, and provides content assistance.</p></li></ol></div></li><li><p>RuleFlow graphical editor</p><p>You can edit visual graphs which represent a process (a rule flow). The RuleFlow can then be applied to your rule package to have imperative control.</p></li><li><p>Wizards for fast creation of</p><div class="orderedlist"><ol type="a"><li><p>a "rules" project</p></li><li><p>a rule resource, either as a DRL file or a "guided rule editor" file (.brl)</p></li><li><p>a Domain Specific language</p></li><li><p>a decision table</p></li><li><p>a ruleflow</p></li></ol></div></li><li><p>A domain specific language editor</p><div class="orderedlist"><ol type="a"><li><p>Create and manage mappings from your user's language to the
            rule language</p></li></ol></div></li><li><p>Rule validation</p><div class="orderedlist"><ol type="a"><li><p>As rules are entered, the rule is "built" in the background
            and errors reported via the problem view where possible</p></li></ol></div></li></ol></div><p>The above features make use of Eclipse infrastructure
    and features, with all of the power of Eclipse being available.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6658"/>7.2. Creating a Rule Project</h2></div></div></div><p>The aim of the new project wizard is to set up an executable scaffold
    project to start using rules immediately. This will set up a basic
    structure, the classpath, sample rules and a test case to get you
    started.</p><div class="figure"><a id="d0e6663"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_project1.jpg" align="middle" alt="New rule project scaffolding"/></div></div><p class="title"><b>Figure 7.2. New rule project scaffolding</b></p></div><br class="figure-break"/><p>When you choose to create a new "rule project" you will get a choice to
      add some default artifacts to it, like rules, decision tables, ruleflows, etc.
      These can serve as a starting point, and will give you something executable
      almost immediately, which you can then modify and mould to your needs. The
      simplest case (a hello world rule) is shown below. Feel free to experiment
      with the plug-in at this point.</p><div class="figure"><a id="d0e6671"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_project2.png" align="middle" alt="New rule project result"/></div></div><p class="title"><b>Figure 7.3. New rule project result</b></p></div><br class="figure-break"/><p>The newly created project contains an example rule file (Sample.drl)
    in the src/rules directory and an example Java file (DroolsTest.java) that can
    be used to execute the rules in a Drools engine. You'll find this in the
    folder src/java, in the com.sample package. All the other jars that are
    necessary during
    execution are also added to the classpath in a custom classpath container
    called Drools Library. Rules do not have to be kept in "Java"
    projects at all, this is just a convenience for people who are already
    using Eclipse as their Java IDE.</p><p>Important note: The Drools plug-in adds a "Drools Builder"
    capability to your Eclipse instance. This means you can enable a builder
    on any project that will build and validate your rules when resources
    change. This happens automatically with the Rule Project Wizard, but you
    can also enable it manually on any project. One downside of this is that
    if you have rule files with a large number of rules (more than 500 rules
    per file), it means that the background builder may be doing a lot of work to
    build the rules on each change. An option here is to turn off the builder,
    or put the large rules into .rule files, where you can still use the rule
    editor, but it won't build them in the background. To fully validate the
    rules you will need to run them in a unit test of course.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6681"/>7.3. Creating a New Rule and Wizards</h2></div></div></div><p>You can create a rule simple as an empty text ".drl" file, or use
    the wizard to do so. The wizard menu can be invoked with Control+N, or by
    choosing it from the toolbar, where there is a menu with the JBoss Drools
    icon.</p><div class="figure"><a id="d0e6686"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/wizards.jpg" align="middle" alt="The wizard menu"/></div></div><p class="title"><b>Figure 7.4. The wizard menu</b></p></div><br class="figure-break"/><p>The wizard will ask for some basic options for generating a rule
    resource. These are just hints - you can change your mind later. For
    storing rule files you would typically create a directory src/rules and
    create suitably named subdirectories. The package name is mandatory, and
    is similar to a package name in Java; i.e., it establishes a namespace for
    grouping related rules.</p><div class="figure"><a id="d0e6694"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_rule.jpg" align="middle" alt="New rule wizard"/></div></div><p class="title"><b>Figure 7.5. New rule wizard</b></p></div><br class="figure-break"/><p>The result of this wizard is a rule skeleton, for you to expand.
    As with all wizards, they are an optional help - you don't have to use
    them if you don't want to.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6702"/>7.4. Textual Rule Editor</h2></div></div></div><p>The rule editor is where rule managers and developers will be
    spending most of their time. The rule editor follows the pattern of a
    normal text editor in Eclipse, with all the customary features of a text
    editor. On top of this, the rule editor provides pop-up content
    assistance. You invoke pop-up content assistance the "normal" way by
    pressing Control+Space.</p><div class="figure"><a id="d0e6707"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/editor1.jpg" align="middle" alt="The rule editor in action"/></div></div><p class="title"><b>Figure 7.6. The rule editor in action</b></p></div><br class="figure-break"/><p>The rule editor works on files that have a .drl (or .rule)
    extension. Usually these contain related rules, but it would also be 
    possible to have rules in individual files, grouped by being in the
    same package "namespace", if you so prefer. These DRL files are plain
    text files.</p><p>You can see from the example above that the rule group is using a
    domain specific language. Note the expander keyword, which tells the rule
    compiler to look for a dsl file of that name, to resolve the rule
    language. Even with the domain specific language (DSL) the rules are
    still stored as plain text as you see it onscreen, which allows simpler
    management of rules and versions, e.g., comparing versions of rules.</p><p>The editor has an outline view that is kept in sync with the
    structure of the rules; it is updated on save. This provides a quick way of
    navigating around rules by name, even in a file which may have hundreds of
    rules. The items are sorted alphabetically by default.</p><div class="figure"><a id="d0e6719"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/outline.jpg" align="middle" alt="The rule outline view"/></div></div><p class="title"><b>Figure 7.7. The rule outline view</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6725"/>7.5. The Guided Editor (Rule GUI)</h2></div></div></div><p>
    A new feature of the Drools IDE (since version 4) is the guided editor for rules.
    This is similar to the web based editor that is available in the BRMS. It
    allows you to build rules in a GUI-driven fashion, based on your object
    model.</p><div class="figure"><a id="d0e6730"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/guidededitor1.png" align="middle" alt="The guided editor"/></div></div><p class="title"><b>Figure 7.8. The guided editor</b></p></div><br class="figure-break"/><p>
      To create a rule this way, use the wizard menu. It will create an instance
      of a .brl file and open it in the guided editor. This editor works 
      based on a .package file in the same directory as the .brl file. In 
      this "package" file you have the package name and import statements - just 
      like you would at the top of a normal DRL file. First time you create
      a brl rule you will need to populate the package file with the fact
      classes you are interested in. Once you have this, the guided editor
      will be able to prompt you with facts and their fields so that you can
      build rules graphically.</p><p>
      The guided editor works off the model classes (or fact classes) that you
      configure. It then is able to "render" to DRL the rule that you have
      entered graphically. You can do this visually - and use it as a basis
      for learning DRL, or you can use it and build rules of the brl directly.
      One way to do this is by using the drools-ant module, which is an ant task 
      that creates all the rule assets in a folder, as a rule package, so that
      you can then deploy it as a binary file. Alternatively, you can use the
      following snippet of code to convert the brl to a drl rule.</p><pre class="programlisting">BRXMLPersitence read = BRXMLPersitence.getInstance();
BRDRLPersistence write = BRDRLPersistence.getInstance();
String brl = ... // read from the .brl file as needed...
String outputDRL = write.marshall(read.unmarshal(brl));
// Pass the outputDRL to the PackageBuilder, as usual</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6742"/>7.6. Drools Views</h2></div></div></div><p>When debugging an application using a Drools engine, these views
    can be used to check the state of the Drools engine itself: the Working
    Memory View, the Agenda View, and the Global Data View. To be able to use
    these views, create breakpoints in your code invoking the working memory.
    For example, the line where you call workingMemory.fireAllRules() is a
    good candidate. If the debugger halts at that joinpoint, you should select
    the working memory variable in the debug variables view. The available
    views can then be used to show the details of the selected working
    memory:</p><div class="orderedlist"><ol type="1"><li><p>The Working Memory View shows all elements of the Drools 
        working memory.</p></li><li><p>The Agenda View shows all elements on the agenda. For each rule
        on the agenda, the rule name and bound variables are shown.</p></li><li><p>The Global Data View shows all global data currently defined in
        the Drools working memory.</p></li></ol></div><p>The Audit view can be used to display audit logs containing events
    that were logged during the execution of a rules engine, in tree form.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6759"/>7.6.1. The Working Memory View</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/workingMemory.png"/></div><p>The Working Memory View shows all elements in the working memory of the
      Drools engine.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for visualizing sets of
          elements in a more obvious way.</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6773"/>7.6.2. The Agenda View</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/agenda.png"/></div><p>The Agenda View shows all elements on the agenda. For each rule on
      the agenda, the rule name and bound variables are shown.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the agenda item, or all their details. Logical
          structures allow for example visualizing sets of elements in a more
          obvious way. The logical structure of AgendaItems shows the rule
          that is represented by the AgendaItem, and the values of all the
          parameters used in the rule.</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6787"/>7.6.3. The Global Data View</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/globals.png"/></div><p>The Global Data View shows all global data currently defined in
      the Drools engine.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for example visualizing sets of
          elements in a more obvious way.</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6801"/>7.6.4. The Audit View</h3></div></div></div><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-IDE/audit.jpg" width="100%"/></td></tr></table></div><p>The audit view visualizes an audit log, that is optionally
      created when executing the rules engine. To create an audit log, use the
      following code:</p><pre class="programlisting">WorkingMemory workingMemory = ruleBase.newWorkingMemory();
// Create a new Working Memory Logger, that logs to file.
WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger(workingMemory);
// An event.log file is created in the subdirectory log (which must exist)
// of the working directory.
logger.setFileName( "log/event" );

workingMemory.assertObject(...);
workingMemory.fireAllRules();

// stop logging
logger.writeToDisk();</pre><p>Open the log by clicking the Open Log action, the first icon in the
      Audit View, and select the file. The Audit View now shows all events
      that where logged during the executing of the rules. There are different
      types of events, each with a different icon:</p><div class="orderedlist"><ol type="1"><li><p>Object inserted, a green square: <span class="inlinemediaobject"><img src="images/Chapter-IDE/greensquare.GIF"/></span></p></li><li><p>Object updated, a yellow square: <span class="inlinemediaobject"><img src="images/Chapter-IDE/yellowsquare.GIF"/></span></p></li><li><p>Object removed, a red square: <span class="inlinemediaobject"><img src="images/Chapter-IDE/redsquare.GIF"/></span></p></li><li><p>Activation created, a right arrow: <span class="inlinemediaobject"><img src="images/Chapter-IDE/arrowright.GIF"/></span></p></li><li><p>Activation cancelled, a left arrow: <span class="inlinemediaobject"><img src="images/Chapter-IDE/arrowleft.GIF"/></span></p></li><li><p>Activation executed, a blue diamond: <span class="inlinemediaobject"><img src="images/Chapter-IDE/bluediamond.GIF"/></span></p></li><li><p>Ruleflow start or end, the "process" icon: <span class="inlinemediaobject"><img src="images/Chapter-IDE/process.gif"/></span></p></li><li><p>Ruleflow-group activation or deactivation, the "activity" icon: <span class="inlinemediaobject"><img src="images/Chapter-IDE/activity.gif"/></span></p></li><li><p>Rule package addition or removal, the Drools icon: <span class="inlinemediaobject"><img src="images/Chapter-IDE/drools.gif"/></span></p></li><li><p>Rule addition or removal, the Drools icon: <span class="inlinemediaobject"><img src="images/Chapter-IDE/drools.gif"/></span></p></li></ol></div><p>All these events show extra information concerning the event, like
      the id and toString representation of the object in case of working
      memory events (insert, modify and retract), the name of the rule and all
      the variables bound in the activation in case of an activation event
      (created, cancelled or executed). If an event occurs when executing an
      activation, it is shown as a child of the activation's execution event. For
      some events, you can retrieve the "cause":</p><div class="orderedlist"><ol type="1"><li><p>The cause of an object modified or retracted event is the last
          object event for that object. This is either the object asserted
          event, or the last object modified event for that object.</p></li><li><p>The cause of an activation cancelled or executed event is the
          corresponding activation created event.</p></li></ol></div><p>When selecting an event, the cause of that event is shown in green
      in the audit view (if visible of course). You can also right click the
      action and select the "Show Cause" menu item. This will scroll you to
      the cause of the selected event.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6885"/>7.7. Domain Specific Languages</h2></div></div></div><p>Domain Specific Languages (DSL) enable you to create a language that
    allows your rules to look like - rules! Most often the domain specific
    language reads like natural language. Typically you would look at how a
    business analyst would describe the rule, in their own words, and then map
    this to your object model, via rule constructs. A side benefit of this is
    that it can provide an insulation layer between your domain objects and
    the rules themselves (as we know you like to refactor). A domain
    specific language will grow as the rules grow, and works best when there
    are common terms used over an over, with different parameters.</p><p>To aid with this, the rule workbench provides an editor for Domain
    Specific Languages. They are stored in a plain text format, so you can
    use any editor of your choice; this format is simply a slightly enhanced
    version of the "Properties" file format. The editor will be invoked on 
    any files with a .dsl extension. There is also a wizard to create a sample
    DSL.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6892"/>7.7.1. Editing languages</h3></div></div></div><div class="figure"><a id="d0e6895"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-IDE/dsl_editor.jpg" align="middle" width="100%" alt="The Domain Specific Language editor"/></td></tr></table></div></div><p class="title"><b>Figure 7.9. The Domain Specific Language editor</b></p></div><br class="figure-break"/><p>The DSL editor provides a tabular view of the mapping of
      Language to Rule Expressions. The Language Expression is what is used in the
      rules. This also feeds the content assistance for the rule editor, so
      that it can suggest Language Expressions from the DSL configuration. (The
      rule editor loads the DSL configuration when the rule resource is
      loaded for editing.) The Rule language mapping defines the "code" for the
      rules into which the language expression will be compiled by the rule
      engine compiler. The form of this Rule language expression depends on it
      being intended for the condition or the action part of a rule. (For the
      RHS it may be a snippet of Java, for instance). The "scope" item indicates
      where the expression belongs, "when" indicating the LHS, "then" the RHS,
      and "*" meaning anywhere. It's also possible to create aliases for
      keywords.</p><p>By selecting a mapping item (a row in the table) you can see the
      expression and mapping in the text fields below the table. Double clicking
      or pressing the edit button will open the edit dialog. Other buttons let you
      remove and add mappings. Don't remove mappings while they are still in
      use.</p><div class="figure"><a id="d0e6905"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/mapping_editor.jpg" align="middle" alt="Language Mapping editor dialog"/></div></div><p class="title"><b>Figure 7.10. Language Mapping editor dialog</b></p></div><br class="figure-break"/><p>Here is a short description of the DSL translation process.
      The parser reads the rule text in a DSL, line by line, and tries to
      match some "Language Expression", depending on the scope. After a
      match, the values that correspond to a placeholder between curly
      braces (e.g., {age}) are extracted from the rule source. The 
      placeholders in the corresponding "Rule Expression" are replaced by
      their corresponding value. In the example above, the natural
      language expression maps to two constraints on a fact of type
      Person, based on the fields age and location, and the {age} and {location}
      values are extracted from the original rule text.</p><p>If you do not wish to use a language mapping for a
      particular rule in a drl, prefix the expression with &gt; and the
      compiler will not try to translate it according to the language
      definition. Also note that Domain Specific Languages are optional. When
      the rule is compiled, the .dsl file will also need to be
      available.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6915"/>7.8. The Rete View</h2></div></div></div><p>The Rete Tree View shows you the current Rete Network for your DRL
    file. You display it by clicking on the tab "Rete Tree" at the bottom
    of the DRL Editor window. With the Rete Network visualization being open,
    you can use drag-and-drop on individual nodes to arrange optimal network
    overview. You may also select multiple nodes by dragging a rectangle
    over them; then the entire group can be moved around. The Eclips toolbar
    icons for zooming in and out can be used in the customary manner.</p><p>In the current release there is no export function to creates a gif
    or jpeg file. Meanwhile, please use ctrl + alt + print to create a copy of
    your current Eclipse window, and cut it off.</p><div class="mediaobject"><img src="images/Chapter-IDE/thereteview.jpg"/></div><p>The Rete View is an advanced feature which takes full advantage of
    the Eclipse Graphical Editing Framework (GEF).</p><p>The Rete view works only in Drools Rule Projects, where the Drools
    Builder is set in the project´s properties.</p><p>If you are using Drools in another type of project where you are
    not having a Drools Rule Project with the appropriate Drools Builder, you
    can use a workaround: Set up a little Drools Rule Project next 
    to it, putting needed libraries into it, and the DRLs you want to inspect
    with the Rete View.
    Just click on the right tab below in the DRL Editor, followed by a click
    on "Generate Rete View".</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6931"/>7.9. Large DRL Files</h2></div></div></div><p>Depending on the JDK you use, it may be necessary to increase the
    permanent generation max size. Both the SUN and the IBM JDK have a permanent
    generation, whereas BEA JRockit does not.</p><p>To increase the permanent generation, start Eclipse with
    -XX:MaxPermSize=###m</p><p>Example: c:\Eclipse\Eclipse.exe -XX:MaxPermSize=128m</p><p>Rulesets of 4,000 rules or greater should set the permanent
    generation to at least 128Mb.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>This may also apply to compiling large numbers of rules
    in general, as there is generally one or more classes per rule.</p></div><p>As an alternative to the above, you may put rules in a file with the
    ".rule" extension, and the background builder will not try to compile them
    with each change, which may provide performance improvements if your IDE
    becomes sluggish with very large numbers of rules.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6947"/>7.10. Debugging Rules</h2></div></div></div><div class="figure"><a id="d0e6950"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-IDE/debug-overview.png" align="middle" width="100%" alt="Debugging"/></td></tr></table></div></div><p class="title"><b>Figure 7.11. Debugging</b></p></div><br class="figure-break"/><p>You can debug rules during the execution of your Drools application.
      You can add breakpoints in the consequences of your rules, and whenever
      such a breakpoint is encountered during the execution of the rules,
      execution is halted.  You can then inspect the variables known at that
      point and use any
      of the default debugging actions to decide what should happen next: step over,
      continue, etc.  You can also use the debug views to inspect the content of the
      working memory and the Agenda.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6958"/>7.10.1. Creating Breakpoints</h3></div></div></div><p>You can add and remove rule breakpoints in DRL files in two ways,
     similar to adding breakpoints to Java files:</p><div class="orderedlist"><ol type="1"><li><p>Double-click the ruler of the DRL editor at the line where you want to
          add a breakpoint.  Note that rule breakpoints can only be created in the
          consequence of a rule.  Double-clicking on a line where no breakpoint is allowed
          will do nothing.  A breakpoint can be removed by double-clicking the ruler once more.
          </p></li><li><p>If you right-click the ruler, a popup menu will show up, containing the
          "Toggle breakpoint" action.  Note that rule breakpoints can only be created in the
          consequence of a rule.  The action is automatically disabled if no rule
          breakpoint is allowed at that line.  Clicking the action will add a breakpoint at the
          selected line, or remove it if there was one already.</p></li></ol></div><p>The Debug Perspective contains a Breakpoints view which can be used to see
     all defined breakpoints, get their properties, enable/disable or remove them, etc.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6972"/>7.10.2. Debugging Rules</h3></div></div></div><p>Drools breakpoints are only enabled if you debug your application as
      a Drools Application.  You can do this like this:</p><div class="figure"><a id="d0e6977"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-IDE/debugAsDrools.png" align="middle" width="100%" alt="Debug as Drools Application"/></td></tr></table></div></div><p class="title"><b>Figure 7.12. Debug as Drools Application</b></p></div><br class="figure-break"/><div class="orderedlist"><ol type="1"><li><p>Select the main class of your application. Right click it and select
          the "Debug As &gt;" sub-menu and select Drools Application. Alternatively,
          you can also select   the "Debug ..." menu item to open a new dialog
          for creating, managing and running debug configurations (see the
          screenshot below).</p></li><li><p>Select the "Drools Application" item in the left tree and click
          the "New launch configuration" button (leftmost icon in the toolbar
          above the tree).  This will create a new configuration with some of
          the properties (like project and main class)already filled in,
          based on the main class you selected in the beginning. All properties
          shown here are the same as for any standard Java program.</p></li><li><p>Change the name of your debug configuration to something meaningful.
          You can just accept the defaults for all other properties. For more
          information about these properties, please check the Eclipse JDT 
          documentation.</p></li><li><p>Click the "Debug" button on the bottom to start debugging your
          application. You only have to define your debug configuration once.
          The next time you run your Drools application, you don't have
          to create a new one but select the previously defined one
          in the tree on the left, as a sub-element of the "Drools Application"
          tree node, and then click the Debug button. The Eclipse toolbar also
          contains shortcut buttons to quickly re-execute one of your
          previous configurations (at least when one of the Java, Java Debug,
          or Drools perspectives has been selected).</p></li></ol></div><div class="figure"><a id="d0e6996"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-IDE/debug_rules_configuration.png" align="middle" width="100%" alt="Debug as Drools Application Configuration"/></td></tr></table></div></div><p class="title"><b>Figure 7.13. Debug as Drools Application Configuration</b></p></div><br class="figure-break"/><p>After clicking the "Debug" button, the application starts executing
     and will halt if any breakpoint is encountered.  This can be a Drools rule 
     breakpoint, or any other standard Java breakpoint.  Whenever a Drools rule
     breakpoint is encountered, the corresponding DRL file is opened and the
     active line is highlighted.  The Variables view also contains all rule
     parameters and their value. You can then use the default Java debug actions
     to decide what to do next: resume, terminate, step over, etc.  The debug
     view can also be used to inspect the contents of the Working Memory and the
     Agenda at that time as well. You don't have to select a Working Memory now,
     as the current executing working memory is automatically shown.</p><div class="figure"><a id="d0e7004"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-IDE/debug.png" align="middle" width="100%" alt="Debugging"/></td></tr></table></div></div><p class="title"><b>Figure 7.14. Debugging</b></p></div><br class="figure-break"/></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7010"/>Chapter 8. Examples</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e7013">8.1. Getting the Examples</a></span></dt><dt><span class="section"><a href="#d0e7018">8.2. Hello World</a></span></dt><dt><span class="section"><a href="#d0e7283">8.3. State Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7288">8.3.1. Understanding the State Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7566">8.4. Fibonacci Example</a></span></dt><dt><span class="section"><a href="#d0e7769">8.5. Banking Tutorial</a></span></dt><dt><span class="section"><a href="#d0e8093">8.6. Pricing Rule Decision Table Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8114">8.6.1. Executing the example</a></span></dt><dt><span class="section"><a href="#d0e8156">8.6.2. The decision table</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8221">8.7. Pet Store Example</a></span></dt><dt><span class="section"><a href="#d0e8780">8.8. Honest Politician Example</a></span></dt><dt><span class="section"><a href="#d0e8905">8.9. Sudoku Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8926">8.9.1. Sudoku Overview</a></span></dt><dt><span class="section"><a href="#d0e8940">8.9.2. Running the Example</a></span></dt><dt><span class="section"><a href="#d0e9026">8.9.3. Java Source and Rules Overview</a></span></dt><dt><span class="section"><a href="#d0e9144">8.9.4. Sudoku Validator Rules (validatorSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e9174">8.9.5. Sudoku Solving Rules (solverSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e9282">8.9.6. Suggestions for Future Developments</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9337">8.10. Number Guess</a></span></dt><dt><span class="section"><a href="#d0e9627">8.11. Miss Manners and Benchmarking</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9646">8.11.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e9732">8.11.2. Indepth Discussion</a></span></dt><dt><span class="section"><a href="#d0e9942">8.11.3. Output Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9997">8.12. Conway's Game Of Life</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7013"/>8.1. Getting the Examples</h2></div></div></div><p>Make sure the Drools Eclipse plugin is installed, which
			needs the Graphical Editing Framework (GEF) dependency installed
                        first. Then download and extract the
			drools-examples zip file, which includes an already created Eclipse
			project. Import that project into a new Eclipse workspace. The rules
			all have example classes that execute the rules. If you want to try
			the examples in another project (or another IDE) then you will need
			to set up the dependencies by hand, of course. Many, but not all of the
			examples are documented below, enjoy!</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7018"/>8.2. Hello World</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Hello World
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HelloWorldExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HelloWorld.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate basic rules in use</pre><p>The "Hello World" example shows a simple example of rules usage, and
  both the MVEL and Java dialects.</p><p>This example demonstrates how to build Knowledge Bases and Sessions.
  Also, audit logging and debug outputs are shown, which is ommitted
  from other examples as it's all very similar. A <code class="code">KnowledgeBuilder</code>
  is used to turn a DRL source file into <code class="code">Package</code> objects which
  the Knowledge Base can consume. The add method takes a <code class="code">Resource</code>
  interface and a Resource Type as parameters. The <code class="code">Resource</code> can be 
  used to retrieve a DRL source file from various locations; in this case the
  DRL file is being retrieved from the classpath using a
  <code class="code">ResourceFactory</code>, but it could come from a disk file or a URL.
  Here, we only add a single DRL source file, but multiple DRL files can be 
  added. Also, DRL files with different namespaces can be added, where
  the Knowledge Builder creates a package for each namespace. Multiple
  packages of different namespaces can be added to the same Knowledge Base.
  When all the DRL files have been added, we should check the builder for 
  errors. While the Knowledge Base will validate the package, it will only
  have access to the error information as a String, so if you wish to debug
  the error information you should do it on the <code class="code">KnowledgeBuilder</code>
  instance. Once you know the builder is error free, get the
  <code class="code">Package</code> collection, instantiate a <code class="code">KnowledgeBase</code>
  from the <code class="code">KnowledgeBaseFactory</code> and add the package
  collection.</p><div class="example"><a id="d0e7068"/><p class="title"><b>Example 8.1. HelloWorld: Creating the KnowledgeBase and Session</b></p><div class="example-contents"><pre class="programlisting">final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

// this will parse and compile in one step
kbuilder.add(ResourceFactory.newClassPathResource("HelloWorld.drl",
				HelloWorldExample.class), ResourceType.DRL);

// Check the builder for errors
if (kbuilder.hasErrors()) {
    System.out.println(kbuilder.getErrors().toString());
    throw new RuntimeException("Unable to compile \"HelloWorld.drl\".");
}

// get the compiled packages (which are serializable)
final Collection&lt;KnowledgePackage&gt; pkgs = kbuilder.getKnowledgePackages();

// add the packages to a knowledgebase (deploy the knowledge packages).
final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages(pkgs);

final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();</pre></div></div><br class="example-break"/><p>Drools has an event model that exposes much of what's happening
  internally. Two default debug listeners are supplied,
  <code class="code">DebugAgendaEventListener</code> and 
  <code class="code">DebugWorkingMemoryEventListener</code> which print out
  debug event information to the <code class="code">System.err</code> stream displayed
  in the Console window. Adding listeners to a
  Session is trivial, as shown below. The <code class="code">KnowledgeRuntimeLogger</code>
  provides execution auditing, the result of which can be viewed in a
  graphical viewer. The logger is actually a specialised implementation
  built on the Agenda and Working Memory listeners. When the engine has
  finished executing, <code class="code">logger.close()</code> must be called.</p><p>Most of the examples use the Audit logging features of Drools to
  record execution flow for later inspection.</p><div class="example"><a id="d0e7092"/><p class="title"><b>Example 8.2. HelloWorld: Event logging and Auditing</b></p><div class="example-contents"><pre class="programlisting">// setup the debug listeners
ksession.addEventListener( new DebugAgendaEventListener() );
ksession.addEventListener( new DebugWorkingMemoryEventListener() );
        
// setup the audit logging
KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "log/helloworld");</pre></div></div><br class="example-break"/><p>The single class used in this example is very simple. It has two
  fields: the message, which is a String and the status which can be one
  of the two integers <code class="code">HELLO</code> or <code class="code">GOODBYE</code>.</p><div class="example"><a id="d0e7105"/><p class="title"><b>Example 8.3. HelloWorld example: Message Class</b></p><div class="example-contents"><pre class="programlisting">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status; 
    ...
}</pre></div></div><br class="example-break"/><p>A single <code class="code">Message</code> object is created with the
  message text "Hello World" and the status <code class="code">HELLO</code> and then
  inserted into the engine, at which point <code class="code">fireAllRules()</code>
  is executed. Remember that all the network evaluation is done
  during the insert time, so that by the time the program execution reaches the
  <code class="code">fireAllRules()</code> method call the engine already knows which rules
  are fully matches and able to fire.</p><div class="example"><a id="d0e7124"/><p class="title"><b>Example 8.4. HelloWorld: Execution</b></p><div class="example-contents"><pre class="programlisting">final Message message = new Message();
message.setMessage("Hello World");
message.setStatus(Message.HELLO);
ksession.insert(message);

ksession.fireAllRules();

logger.close();

ksession.dispose();    </pre></div></div><br class="example-break"/><p>To execute the example as a Java application:</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.HelloWorldExample in your
      Eclipse IDE</p></li><li><p>Right-click the class and select "Run as..." and then "Java
      application"</p></li></ol></div><p>If we put a breakpoint on the <code class="code">fireAllRules()</code> method
  and select the <code class="code">ksession</code> variable, we can see that the
  "Hello World" rule is already activated and on the Agenda, confirming
  that all the pattern matching work was already done during the insert.</p><div class="figure"><a id="d0e7146"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/HelloWorldExample/helloworld_agenda1.png" width="100%" alt="Hello World: fireAllRules Agenda View"/></td></tr></table></div></div><p class="title"><b>Figure 8.1. Hello World: fireAllRules Agenda View</b></p></div><br class="figure-break"/><p>The may application print outs go to to System.out while the debug
  listener print outs go to System.err.</p><div class="example"><a id="d0e7154"/><p class="title"><b>Example 8.5. HelloWorld: System.out in the Console window</b></p><div class="example-contents"><pre class="programlisting">Hello World
Goodbye cruel world</pre></div></div><br class="example-break"/><div class="example"><a id="d0e7159"/><p class="title"><b>Example 8.6. HelloWorld: System.err in the Console window</b></p><div class="example-contents"><pre class="programlisting">==&gt;[ActivationCreated(0): rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                 object=org.drools.examples.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                old_object=org.drools.examples.HelloWorldExample$Message@17cec96; 
                new_object=org.drools.examples.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]  </pre></div></div><br class="example-break"/><p>The LHS (after <strong class="kw"><code>when</code></strong>) section of the rule states that it will be
  activated for each <code class="code">Message</code> object inserted into the Working
  Memory whose status is <code class="code">Message.HELLO</code>. Besides that, two 
  variable bindings are created: the variable <code class="code">message</code> is bound
  to the <code class="code">message</code> attribute and the variable <code class="code">m</code>
  is bound to the matched <code class="code">Message</code> object itself.</p><p>The RHS (after <strong class="kw"><code>then</code></strong>) or consequence part of the rule is
  written using the MVEL expression language, as declared by
  the rule's attribute <code class="code">dialect</code>. After printing the content of
  the bound variable <code class="code">message</code> to <code class="code">System.out</code>,
  the rule changes the values of the <code class="code">message</code> and
  <code class="code">status</code> attributes of the <code class="code">Message</code> object
  bound to <code class="code">m</code>. This is done MVEL's <strong class="kw"><code>modify</code></strong> statement,
  which allows you to apply a block of assignments in one statement, with the
  engine being automatically notified of the changes at the end of the 
  block.</p><div class="example"><a id="d0e7216"/><p class="title"><b>Example 8.7. HelloWorld: rule "Hello World"</b></p><div class="example-contents"><pre class="programlisting">rule "Hello World"
      dialect "mvel"
  when
      m : Message( status == Message.HELLO, message : message )
  then
      System.out.println( message ); 
      modify ( m ) { message = "Goodbyte cruel world",
                     status = Message.GOODBYE };
end</pre></div></div><br class="example-break"/><p>We can set a breakpoint into the DRL, on the <strong class="kw"><code>modify</code></strong>
  call, and inspect the Agenda view again during the execution of the
  rule's consequence. This time we start the execution via "Debug As"
  and "Drools application" and not by running a "Java application":</p><div class="orderedlist"><ol type="1"><li><p>Open the class <code class="code">org.drools.examples.HelloWorld</code> in your
      Eclipse IDE.</p></li><li><p>Right-click the class and select "Debug as..." and then "Drools
      application".</p></li></ol></div><p>Now we can see that the other rule <code class="code">"Good Bye"</code>, which
  uses the Java dialect, is activated and placed on the Agenda.</p><div class="figure"><a id="d0e7241"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/HelloWorldExample/helloworld_agenda2.png" alt="Hello World: rule &#34;Hello World&#34; Agenda View"/></div></div><p class="title"><b>Figure 8.2. Hello World: rule "Hello World" Agenda View</b></p></div><br class="figure-break"/><p>The "Good Bye" rule, which specifies the "java" dialect, is similar
  to the "Hello World" rule except that it matches <code class="code">Message</code>
  objects whose  status is <code class="code">Message.GOODBYE</code>.</p><div class="example"><a id="d0e7255"/><p class="title"><b>Example 8.8. HelloWorld: rule "Good Bye"</b></p><div class="example-contents"><pre class="programlisting">rule "Good Bye"
      dialect "java"
  when
      Message( status == Message.GOODBYE, message : message )
  then
      System.out.println( message ); 
end</pre></div></div><br class="example-break"/><p>Remember the Java code where we used the
  <code class="code">KnowledgeRuntimeLoggerFactory</code> method <code class="code">newFileLogger</code>
  to create a <code class="code">KnowledgeRuntimeLogger</code> and called
  <code class="code">logger.close()</code> at the end. This created an audit log file that
  can be shown in the Audit view. We use the Audit view in many of the
  examples to demostrate the example execution flow. In the view screen shot
  below we can see that the object is inserted, which creates an activation
  for the "Hello World" rule; the activation is then executed which updates
  the <code class="code">Message</code> object causing the "Good Bye" rule to
  activate; finally the "Good Bye" rule also executes. Selecting an event in
  the Audit view highlights the origin event in green; therefore the
  "Activation created" event is highlighted in green as the origin of the
  "Activation executed" event.</p><div class="figure"><a id="d0e7277"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/HelloWorldExample/helloworld_auditview1.png" width="100%" alt="Hello World: Audit View"/></td></tr></table></div></div><p class="title"><b>Figure 8.3. Hello World: Audit View</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7283"/>8.3. State Example</h2></div></div></div><p>This example is implemented in three different versions to
    demonstrate different ways of implementing the same basic behavior:
    forward chaining, i.e., the ability the engine has to  evaluate,
    activate and fire rules in sequence, based on changes on the facts
    in the Working Memory.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7288"/>8.3.1. Understanding the State Example</h3></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> State Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.StateExampleUsingSalience
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> StateExampleUsingSalience.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates basic rule use
  and Conflict Resolution for rule firing priority.</pre><p>Each <code class="code">State</code> class has fields for its name and its
      current state (see the class <code class="code">org.drools.examples.State</code>).
      The two possible states for each objects are:</p><div class="itemizedlist"><ul><li><p><code class="code">NOTRUN</code></p></li><li><p><code class="code">FINISHED</code></p></li></ul></div><div class="example"><a id="d0e7324"/><p class="title"><b>Example 8.9. State Class</b></p><div class="example-contents"><pre class="programlisting">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"/><p>Ignoring the <code class="code">PropertyChangeSupport</code>, which will
      be explained later, we see the creation of four <code class="code">State</code>
      objects named A, B, C and D. Initially their states are set to
      <code class="code">NOTRUN</code>, which is default for the used constructor.
      Each instance is asserted in turn into the Session and then
      <code class="code">fireAllRules()</code> is called.</p><div class="example"><a id="d0e7343"/><p class="title"><b>Example 8.10. Salience State: Execution</b></p><div class="example-contents"><pre class="programlisting">State a = new State( "A" );
State b = new State( "B" );
State c = new State( "C" );
final State d = new State( "D" );

// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
boolean dynamic = true;

session.insert( a, dynamic );
session.insert( b, dynamic );
session.insert( c, dynamic );
session.insert( d, dynamic );

session.fireAllRules();
session.dispose(); // Stateful rule session must always be disposed when finished</pre></div></div><br class="example-break"/><p>To execute the application:</p><div class="orderedlist"><ol type="1"><li><p>Open the class <code class="code">org.drools.examples.StateExampleUsingSalience</code> in your Eclipse IDE.</p></li><li><p>Right-click the class and select "Run as..." and then
          "Java application"</p></li></ol></div><p>You will see the following output in the Eclipse console
      window:</p><div class="example"><a id="d0e7362"/><p class="title"><b>Example 8.11. Salience State: Console Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
</pre></div></div><br class="example-break"/><p>There are four rules in total. First, the <code class="code">Bootstrap</code>
      rule fires, setting A to state <code class="code">FINISHED</code>, which then
      causes B to change its state to <code class="code">FINISHED</code>. C and D are
      both dependent on B, causing a conflict which is resolved by the
      salience values. Let's look at the way this was executed.</p><p>The best way to understand what is happening is to use the
      Audit Logging feature to graphically see the results of each
      operation. To view the Audit log generated by a run of this
      example:</p><div class="orderedlist"><ol type="1"><li><p>If the Audit View is not visible, click on "Window" and
          then select "Show View", then "Other..." and "Drools" and
          finally "Audit View".</p></li><li><p>In the "Audit View" click the "Open Log" button and select
          the file "&lt;drools-examples-drl-dir&gt;/log/state.log".</p></li></ol></div><p>After that, the "Audit view" will look like the following
      screenshot:</p><div class="figure"><a id="d0e7389"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/StateExample/state_example_audit1.png" width="100%" alt="Salience State Example Audit View"/></td></tr></table></div></div><p class="title"><b>Figure 8.4. Salience State Example Audit View</b></p></div><br class="figure-break"/><p>Reading the log in the "Audit View", top to bottom, we see every
      action and the corresponding changes in the Working Memory. This way
      we observe that the assertion of the State object A in the state
      <code class="code">NOTRUN</code> activates the <code class="code">Bootstrap</code> rule, while
      the assertions of the other <code class="code">State</code> objects have no
      immediate effect.</p><div class="example"><a id="d0e7406"/><p class="title"><b>Example 8.12. Salience State: Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</pre></div></div><br class="example-break"/><p>The execution of rule Bootstrap changes the state of A to
      <code class="code">FINISHED</code>, which, in turn, activates rule "A to B".</p><div class="example"><a id="d0e7416"/><p class="title"><b>Example 8.13. Salience State: Rule "A to B"</b></p><div class="example-contents"><pre class="programlisting">rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"/><p>The execution of rule "A to B" changes the state of B to
      <code class="code">FINISHED</code>, which activates both, rules "B to C" and
      "B to D", placing their Activations onto the Agenda. From this moment
      on, both rules may fire and, therefore, they are said to be
      "in conflict". The conflict resolution strategy allows the engine's
      Agenda to decide which rule to fire. As rule "B to C"  has the
      <span class="bold"><strong>higher salience value</strong></span> (10 versus
      the default salience value of 0), it fires first, modifying object C
      to state <code class="code">FINISHED</code>. The Audit view shown above reflects
      the  modification of the <code class="code">State</code> object in the rule "A to B",
      which results in two activations being in conflict. The Agenda view
      can also be used to investigate the state of the Agenda, with debug
      points being placed in the rules themselves and the Agenda view opened.
      The screen shot below shows the breakpoint in the rule "A to B" and
      the state of the Agenda with the two conflicting rules.</p><div class="figure"><a id="d0e7435"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/StateExample/state_example_agenda1.png" alt="State Example Agenda View"/></div></div><p class="title"><b>Figure 8.5. State Example Agenda View</b></p></div><br class="figure-break"/><div class="example"><a id="d0e7441"/><p class="title"><b>Example 8.14. Salience State: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"/><p>Rule "B to D"  fires last, modifying object D to state
      <code class="code">FINISHED</code>.</p><div class="example"><a id="d0e7451"/><p class="title"><b>Example 8.15. Salience State: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"/><p>There are no more rules to execute and so the engine stops.</p><p>Another notable concept in this example is the use of
      <span class="emphasis"><em>dynamic facts</em></span>, based on
      <code class="code">PropertyChangeListener</code> objects. As described in the
      documentation, in order for the engine to see and react to changes of
      fact properties, the application must tell the engine that changes
      occurred. This can be done explicitly in the rules by using the
      <strong class="kw"><code>modify</code></strong> statement, or implicitly by letting the engine know
      that the facts implement <code class="code">PropertyChangeSupport</code> as defined
      by the <span class="emphasis"><em>JavaBeans specification</em></span>. This example
      demonstrates how to use <code class="code">PropertyChangeSupport</code> to avoid
      the need for explicit <strong class="kw"><code>modify</code></strong> statements in the rules. To
      make use of this feature, ensure that your facts implement
      <code class="code">PropertyChangeSupport</code>, the same way the class
      <code class="code">org.drools.example.State</code> does, and use the following
      code to insert the facts into the Working Memory:</p><div class="example"><a id="d0e7487"/><p class="title"><b>Example 8.16. Inserting a Dynamic Fact</b></p><div class="example-contents"><pre class="programlisting">// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
final boolean dynamic = true;

session.insert( fact, dynamic );
</pre></div></div><br class="example-break"/><p>When using <code class="code">PropertyChangeListener</code> objects, each
      setter must implement a little extra code for the notification. Here
      is the setter for <code class="code">state</code> in the class
      <code class="code">org.drools.examples</code>:</p>:
  
      <div class="example"><a id="d0e7504"/><p class="title"><b>Example 8.17. Setter Example with PropertyChangeSupport</b></p><div class="example-contents"><pre class="programlisting">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</pre></div></div><br class="example-break"/><p>There are two other classes in this example:
      <code class="code">StateExampleUsingAgendGroup</code> and
      <code class="code">StateExampleWithDynamicRules</code>. Both execute from A to B
      to C to D, as just shown. The <code class="code">StateExampleUsingAgendGroup</code>
      uses agenda-groups to control the rule conflict and which one fires
      first. <code class="code">StateExampleWithDynamicRules</code> shows how an
      additional rule can be added to an already running Working Memory
      with all the existing data applying to it at runtime.</p><p>Agenda groups are a way to partition the Agenda into groups
      and to control which groups can execute. By default, all rules are
      in the agenda group "MAIN". The "agenda-group" attribute lets
      you specify a different agenda group for the rule. Initially,
      a Working Memory has its focus on the Agenda group "MAIN". A group's
      rules will only fire when the group receives the focus. This can be
      achieved either ny using the method by <code class="code">setFocus()</code> or the
      rule attribute <strong class="kw"><code>auto-focus</code></strong>. "auto-focus" means that the rule
      automatically sets the focus to its agenda group when the rule is
      matched and activated. It is this "auto-focus" that enables rule
      "B to C" to fire before "B to D".</p><div class="example"><a id="d0e7531"/><p class="title"><b>Example 8.18. Agenda Group State Example: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</pre></div></div><br class="example-break"/><p>The rule "B to C" calls <code class="code">setFocus()</code> on the
      agenda group "B to D", allowing its active rules
      to fire, which allows the rule "B to D" to fire.</p><div class="example"><a id="d0e7541"/><p class="title"><b>Example 8.19. Agenda Group State Example: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"/><p>The example <code class="code">StateExampleWithDynamicRules</code> adds
      another rule to the Rule Base after <code class="code">fireAllRules()</code>.
      The added rule is just another state transition.</p><div class="example"><a id="d0e7554"/><p class="title"><b>Example 8.20. Dynamic State Example: Rule "D to E"</b></p><div class="example-contents"><pre class="programlisting">rule "D to E"
  when
      State(name == "D", state == State.FINISHED )      
      e : State(name == "E", state == State.NOTRUN )
  then
      System.out.println(e.getName() + " finished" );
      e.setState( State.FINISHED );
end</pre></div></div><br class="example-break"/><p>This produces the following expected output:</p><div class="example"><a id="d0e7561"/><p class="title"><b>Example 8.21. Dynamic Sate Example Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
E finished
</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7566"/>8.4. Fibonacci Example</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Fibonacci 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.FibonacciExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> Fibonacci.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates Recursion,
  the CE <strong class="kw"><code>not</code></strong> and cross product matching</pre><p>The Fibonacci Numbers (see <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a>)
    discovered by Leonardo of Pisa (see <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci">http://en.wikipedia.org/wiki/Fibonacci</a>) is a sequence 
    that starts with 0 and 1. The next Fibonacci number is obtained by adding
    the two preceding Fibonacci numbers. The Fibonacci sequence begins with
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946,... The Fibonacci Example demonstrates recursion
    and conflict resolution with salience values.</p><p>The single fact class <code class="code">Fibonacci</code> is used in this
    example. It has two fields, sequence and value. The sequence field
    is used to indicate the position of the object in the Fibonacci
    number sequence. The value field shows the value of that
    Fibonacci object for that sequence position, using -1 to indicate
    a value that still needs to be computed.</p><div class="example"><a id="d0e7601"/><p class="title"><b>Example 8.22. Fibonacci Class</b></p><div class="example-contents"><pre class="programlisting">public static class Fibonacci {
    private int  sequence;
    private long value;

    public Fibonacci( final int sequence ) {
        this.sequence = sequence;
        this.value = -1;
    }

    ... setters and getters go here...
}</pre></div></div><br class="example-break"/><p>Execute the example:</p><div class="orderedlist"><ol type="1"><li><p>Open the class <code class="classname">org.drools.examples.FibonacciExample</code> in your Eclipse IDE.</p></li><li><p>Right-click the class and select "Run as..." and then
        "Java application"</p></li></ol></div><p>Eclipse shows the following output in its console window (with
    "...snip..." indicating lines that were removed to save space):</p><div class="example"><a id="d0e7620"/><p class="title"><b>Example 8.23. Fibonacci Example: Console Output</b></p><div class="example-contents"><pre class="programlisting">recurse for 50
recurse for 49
recurse for 48
recurse for 47
...snip...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...snip...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025
</pre></div></div><br class="example-break"/><p>To kick this off from Java we only insert a single Fibonacci
    object, with a sequence field of 50. A recursive rule is then used
    to insert the other 49 <code class="code">Fibonacci</code> objects. This example
    doesn't use
    <code class="code">PropertyChangeSupport</code>. It uses the MVEL dialect, which
    means we can use the <strong class="kw"><code>modify</code></strong> keyword, which allows a block
    setter action which also notifies the engine of changes.</p><div class="example"><a id="d0e7636"/><p class="title"><b>Example 8.24. Fibonacci Example: Execution</b></p><div class="example-contents"><pre class="programlisting">ksession.insert( new Fibonacci( 50 ) );
ksession.fireAllRules();</pre></div></div><br class="example-break"/><p>The rule Recurse is very simple. It matches each asserted
    <code class="code">Fibonacci</code> object with a value of -1, creating and 
    asserting a new <code class="code">Fibonacci</code> object with a sequence of
    one less than the currently matched object. Each time a Fibonacci
    object is added while the one with a sequence field equal to 1
    does not exist, the rule re-matches and fires again. The
    <strong class="kw"><code>not</code></strong> conditional element is used to stop the rule's matching
    once we have all 50 Fibonacci objects in memory. The rule also has a
    salience value, because we need to have all 50 <code class="code">Fibonacci</code>
    objects asserted before we execute the Bootstrap rule.</p><div class="example"><a id="d0e7655"/><p class="title"><b>Example 8.25. Fibonacci Example: Rule "Recurse"</b></p><div class="example-contents"><pre class="programlisting">rule Recurse
    salience 10
    when
        f : Fibonacci ( value == -1 )
        not ( Fibonacci ( sequence == 1 ) )
    then
        insert( new Fibonacci( f.sequence - 1 ) );
        System.out.println( "recurse for " + f.sequence );
end</pre></div></div><br class="example-break"/><p>The Audit view shows the original assertion of the
    <code class="code">Fibonacci</code> object with a sequence field of 50, done from
    Java code. From there on, the Audit view shows the continual
    recursion of the rule, where each asserted <code class="code">Fibonacci</code>
    object causes the Recurse rule to become activated and to fire again.</p><div class="figure"><a id="d0e7668"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/FibonacciExample/fibonacci1.png" width="100%" alt="Fibonacci Example: &#34;Recurse&#34; Audit View 1"/></td></tr></table></div></div><p class="title"><b>Figure 8.6. Fibonacci Example: "Recurse" Audit View 1</b></p></div><br class="figure-break"/><p>When a <code class="code">Fibonacci</code> object with a sequence field of 2 is
    asserted the "Bootstrap" rule is matched and activated along with the
    "Recurse" rule. Note the multi-restriction on field
    <code class="code">sequence</code>, testing for equality with 1 or 2.</p><div class="example"><a id="d0e7682"/><p class="title"><b>Example 8.26. Fibonacci Example: Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction
    then 
        modify ( f ){ value = 1 };
        System.out.println( f.sequence + " == " + f.value );
end</pre></div></div><br class="example-break"/><p>At this point the Agenda looks as shown below. However,
    the "Bootstrap" rule does not fire because the "Recurse" rule has a higher
    salience.</p><div class="figure"><a id="d0e7689"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci_agenda1.png" alt="Fibonacci Example: &#34;Recurse&#34; Agenda View 1"/></div></div><p class="title"><b>Figure 8.7. Fibonacci Example: "Recurse" Agenda View 1</b></p></div><br class="figure-break"/><p>When a <code class="code">Fibonacci</code> object with a sequence of 1 is
    asserted the Bootstrap rule is matched again, causing two activations
    for this rule. Note that the "Recurse" rule does not match and activate
    because the <strong class="kw"><code>not</code></strong> conditional element stops the rule's matching
    as soon as a <code class="code">Fibonacci</code> object with a sequence of 1
    exists.</p><div class="figure"><a id="d0e7706"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci_agenda2.png" alt="Fibonacci Example: &#34;Recurse&#34; Agenda View 2"/></div></div><p class="title"><b>Figure 8.8. Fibonacci Example: "Recurse" Agenda View 2</b></p></div><br class="figure-break"/><p>Once we have two <code class="code">Fibonacci</code> objects with values
    not equal to -1 the "Calculate" rule is able to match. It was
    the "Bootstrap" rule that set the objects with sequence 1 and 2 to
    values of 1. At this point we have 50 Fibonacci objects in the Working
    Memory. Now we need to select a suitable triple to calculate each
    of their values in turn. Using three Fibonacci patterns in a rule without
    field constraints to confine the possible cross products would result
    in 50x49x48 possible combinations, leading to about 125,000 possible rule
    firings, most of them incorrect. The "Calculate" rule uses field
    constraints to correctly constraint the thee Fibonacci patterns in the
    correct order; this
    technique is called <span class="emphasis"><em>cross product matching</em></span>. The
    first pattern finds any Fibonacci with a value != -1 and binds both
    the pattern and the field.  The second Fibonacci does this, too, but
    it adds an additional field constraint to ensure that its sequence is
    greater by one than the Fibonacci bound to <code class="code">f1</code>. When this
    rule fires for the first time, we know that only sequences 1 and 2
    have values of 1, and the two constraints ensure that <code class="code">f1</code>
    references sequence 1 and <code class="code">f2</code> references sequence 2. The
    final pattern finds the Fibonacci with a value equal to -1 and with a
    sequence one greater than <code class="code">f2</code>. At this point, we have
    three <code class="code">Fibonacci</code> objects correctly selected from the
    available cross products, and we can calculate the value for the
    third <code class="code">Fibonacci</code> object that's bound to <code class="code">f3</code>.</p><div class="example"><a id="d0e7741"/><p class="title"><b>Example 8.27. Fibonacci Example: Rule "Calculate"</b></p><div class="example-contents"><pre class="programlisting">rule Calculate
    when
        // Bind f1 and s1
        f1 : Fibonacci( s1 : sequence, value != -1 )
        // Bind f2 and v2; refer to bound variable s1
        f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 )
        // Bind f3 and s3; alternative reference of f2.sequence
        f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )      
    then
        // Note the various referencing rechniques.
        modify ( f3 ) { value = f1.value + v2 };
        System.out.println( s3 + " == " + f3.value );
end 
</pre></div></div><br class="example-break"/><p>The <strong class="kw"><code>modify</code></strong> statement updated the value of the
    <code class="code">Fibonacci</code> object bound to <code class="code">f3</code>. This means
    we now have another new Fibonacci object with a value not equal to -1,
    which allows the "Calculate" rule to rematch and calculate the next
    Fibonacci number. The Audit view below shows how the firing of the
    last "Bootstrap" modifies the <code class="code">Fibonacci</code> object,
    enabling the "Calculate" rule to match, which then modifies
    another Fibonacci object allowing the "Calculate" rule to match again.
    This continues till the value is set for all <code class="code">Fibonacci</code>
    objects.</p><div class="figure"><a id="d0e7763"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci4.png" alt="Fibonacci Example: &#34;Bootstrap&#34; Audit View"/></div></div><p class="title"><b>Figure 8.9. Fibonacci Example: "Bootstrap" Audit View</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7769"/>8.5. Banking Tutorial</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> BankingTutorial
<span class="bold"><strong>Main class:</strong></span> org.drools.tutorials.banking.Example*.java
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> org.drools.tutorials.banking.*.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate pattern matching, basic sorting and calculation rules.</pre><p>This tutorial demonstrates the process of developing a
    complete personal banking application to handle credits and debits on
    multiple accounts. It uses a set of design patterns that have
    been created for the process.</p><p>The class <code class="code">RuleRunner</code> is a simple harness to execute
    one or more DRL files against a set of data. It compiles the Packages 
    and creates the Knowledge Base for each execution, allowing us to
    easily execute each scenario and inspect the outputs. In reality this
    is not a good solution for a production system, where the Knowledge Base
    should be built just once and cached, but for the purposes of this
    tutorial it shall suffice.</p><div class="example"><a id="d0e7795"/><p class="title"><b>Example 8.28. Banking Tutorial: RuleRunner</b></p><div class="example-contents"><pre class="programlisting">public class RuleRunner {

    public RuleRunner() {
    }

    public void runRules(String[] rules,
                         Object[] facts) throws Exception {

        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        for ( int i = 0; i &lt; rules.length; i++ ) {
            String ruleFile = rules[i];
            System.out.println( "Loading file: " + ruleFile );
            kbuilder.add( ResourceFactory.newClassPathResource( ruleFile,
                                                                RuleRunner.class ),
                          ResourceType.DRL );
        }

        Collection&lt;KnowledgePackage&gt; pkgs = kbuilder.getKnowledgePackages();
        kbase.addKnowledgePackages( pkgs );
        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

        for ( int i = 0; i &lt; facts.length; i++ ) {
            Object fact = facts[i];
            System.out.println( "Inserting fact: " + fact );
            ksession.insert( fact );
        }

        ksession.fireAllRules();
    }
}</pre></div></div><br class="example-break"/><p>The first of our sample Java classes loads and executes a single
    DRL file, <code class="filename">Example.drl</code>, but without inserting any
    data.</p><div class="example"><a id="d0e7805"/><p class="title"><b>Example 8.29. Banking Tutorial : Java Example1</b></p><div class="example-contents"><pre class="programlisting">public class Example1 {
    public static void main(String[] args) throws Exception {
        new RuleRunner().runRules( new String[] { "Example1.drl" },
                                   new Object[0] );
    }
}</pre></div></div><br class="example-break"/><p>The first simple rule to execute has a single <strong class="kw"><code>eval</code></strong>
    condition that will alway be true, so that this rule will match and
    fire, once, after the start.</p><div class="example"><a id="d0e7815"/><p class="title"><b>Example 8.30. Banking Tutorial: Rule in Example1.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 01"   
    when
        eval( 1==1 )
    then
        System.out.println( "Rule 01 Works" );
endh</pre></div></div><br class="example-break"/><p>The output for the rule is below, showing that the rule matches
    and executes the single print statement.</p><div class="example"><a id="d0e7822"/><p class="title"><b>Example 8.31. Banking Tutorial: Output of Example1.java</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example1.drl
Rule 01 Works</pre></div></div><br class="example-break"/><p>The next step is to assert some simple facts and print them
    out.</p><div class="example"><a id="d0e7829"/><p class="title"><b>Example 8.32. Banking Tutorial: Java Example2</b></p><div class="example-contents"><pre class="programlisting">public class Example2 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example2.drl" },
                                   numbers );
    }
    
    private static Integer wrap( int i ) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"/><p>This doesn’t use any specific facts but instead asserts a set
    of <code class="code">java.lang.Integer</code> objects. This is not considered
    "best practice" as a number is not a useful fact, but we use it here
    to demonstrate basic techniques before more complexity is added.</p><p>Now we will create a simple rule to print out these numbers.</p><div class="example"><a id="d0e7841"/><p class="title"><b>Example 8.33. Banking Tutorial: Rule in Example2.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 02"   
    when
        Number( $intValue : intValue )
    then
        System.out.println( "Number found with value: " + $intValue ); 
end</pre></div></div><br class="example-break"/><p>Once again, this rule does nothing special. It identifies any
    facts that are <code class="code">Number</code> objects and prints out the values.
    Notice the use of the abstract class <code class="code">Number</code>: we inserted
    <code class="code">Integer</code> objects but we now look for any kind of number.
    The pattern matching engine is able to match interfaces and
    superclasses of asserted objects.</p><p>The output shows the DRL being loaded, the facts inserted and
    then the matched and fired rules. We can see that each inserted number
    is matched and fired and thus printed.</p><div class="example"><a id="d0e7859"/><p class="title"><b>Example 8.34. Banking Tutorial: Output of Example2.java</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example2.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 5
Number found with value: 1
Number found with value: 4
Number found with value: 1
Number found with value: 3
</pre></div></div><br class="example-break"/><p>There are certainly many better ways to sort numbers than using
    rules, but since we will need to apply some cashflows in date order
    when we start looking at banking rules we'll develop simple rule
    based sorting technique.</p><div class="example"><a id="d0e7866"/><p class="title"><b>Example 8.35. Banking Tutorial: Example3.java</b></p><div class="example-contents"><pre class="programlisting">public class Example3 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example3.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"/><p>Again we insert our <code class="code">Integer</code> objects, but this time the
    rule is slightly different:</p><div class="example"><a id="d0e7876"/><p class="title"><b>Example 8.36. Banking Tutorial: Rule in Example3.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 03"
    when
        $number : Number( )
        not Number( intValue &lt; $number.intValue )
    then
        System.out.println("Number found with value: " + $number.intValue() ); 
        retract( $number );
end</pre></div></div><br class="example-break"/><p>The first line of the rule identifies a <code class="code">Number</code> and
    extracts the value. The second line ensures that there does not exist
    a smaller number than the one found by the first pattern. We might
    expect to match only one number - the smallest in the set. However,
    the retraction of the number after it has been printed means that the
    smallest number has been removed, revealing the next smallest number,
    and so on. </p><p>The resulting output shows that the numbers are now
    sorted numerically.</p><div class="example"><a id="d0e7888"/><p class="title"><b>Example 8.37. Banking Tutorial: Output of Example3.java</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example3.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 1
Number found with value: 1
Number found with value: 3
Number found with value: 4
Number found with value: 5
</pre></div></div><br class="example-break"/><p>We are ready to start moving towards our personal accounting
    rules. The first step is to create a <code class="code">Cashflow</code> object.</p><div class="example"><a id="d0e7898"/><p class="title"><b>Example 8.38. Banking Tutorial: Class Cashflow</b></p><div class="example-contents"><pre class="programlisting">public class Cashflow {
    private Date   date;
    private double amount;

    public Cashflow() {
    }

    public Cashflow(Date date, double amount) {
        this.date = date;
        this.amount = amount;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String toString() {
        return "Cashflow[date=" + date + ",amount=" + amount + "]";
    }
}</pre></div></div><br class="example-break"/><p>Class <code class="code">Cashflow</code> has two simple attributes, a date
    and an amount. (Note that using the type <code class="code">double</code> for
    monetary units is generally <span class="emphasis"><em>not</em></span> a good idea
    because floating point numbers cannot represent most numbers accurately.)
    There is also an overloaded constructor to set the values, and a
    method <code class="code">toString</code> to print a cashflow. The Java code of
    <code class="filename">Example4.java</code> inserts five Cashflow objects,
    with varying dates and amounts.</p><div class="example"><a id="d0e7920"/><p class="title"><b>Example 8.39. Banking Tutorial: Example4.java</b></p><div class="example-contents"><pre class="programlisting">public class Example4 {    
    public static void main(String[] args) throws Exception {
        Object[] cashflows = {
            new Cashflow(new SimpleDate("01/01/2007"), 300.00),
            new Cashflow(new SimpleDate("05/01/2007"), 100.00),
            new Cashflow(new SimpleDate("11/01/2007"), 500.00),
            new Cashflow(new SimpleDate("07/01/2007"), 800.00),
            new Cashflow(new SimpleDate("02/01/2007"), 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example4.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"/><p>The convenience class <code class="code">SimpleDate</code> extends
    <code class="code">java.util.Date</code>, providing a constructor taking
    a String as input and defining a date format. The code is
    listed below</p><div class="example"><a id="d0e7933"/><p class="title"><b>Example 8.40. Banking Tutorial: Class SimpleDate</b></p><div class="example-contents"><pre class="programlisting">public class SimpleDate extends Date {
    private static final SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
    
    public SimpleDate(String datestr) throws Exception {             
        setTime(format.parse(datestr).getTime());
    }
}</pre></div></div><br class="example-break"/><p>Now, let’s look at <code class="filename">Example4.drl</code> to see how
    we print the sorted <code class="code">Cashflow</code> objects:</p><div class="example"><a id="d0e7946"/><p class="title"><b>Example 8.41. Banking Tutorial: Rule in Example4.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 04"   
    when
        $cashflow : Cashflow( $date : date, $amount : amount )
        not Cashflow( date &lt; $date)
    then
        System.out.println("Cashflow: "+$date+" :: "+$amount);  
        retract($cashflow);
end</pre></div></div><br class="example-break"/><p>Here, we identify a <code class="code">Cashflow</code> and extract the date
    and the amount. In the second line of the rule we ensure that there
    is no Cashflow with an earlier date than the one found. In the
    consequence, we print the <code class="code">Cashflow</code> that satisfies the
    rule and then retract it, making way for the next earliest
    <code class="code">Cashflow</code>. So, the output we generate is:</p><div class="example"><a id="d0e7962"/><p class="title"><b>Example 8.42. Banking Tutorial: Output of Example4.java</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example4.drl
Inserting fact: Cashflow[date=Mon Jan 01 00:00:00 GMT 2007,amount=300.0]
Inserting fact: Cashflow[date=Fri Jan 05 00:00:00 GMT 2007,amount=100.0]
Inserting fact: Cashflow[date=Thu Jan 11 00:00:00 GMT 2007,amount=500.0]
Inserting fact: Cashflow[date=Sun Jan 07 00:00:00 GMT 2007,amount=800.0]
Inserting fact: Cashflow[date=Tue Jan 02 00:00:00 GMT 2007,amount=400.0]
Cashflow: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Cashflow: Tue Jan 02 00:00:00 GMT 2007 :: 400.0
Cashflow: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Cashflow: Sun Jan 07 00:00:00 GMT 2007 :: 800.0
Cashflow: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"/><p>Next, we extend our <code class="code">Cashflow</code>, resulting in a
    <code class="code">TypedCashflow</code> which can be a credit or a debit operation.
    (Normally, we would just add this to the <code class="code">Cashflow</code> type, but
    we use extension to keep the previous version of the class intact.)</p><div class="example"><a id="d0e7978"/><p class="title"><b>Example 8.43. Banking Tutorial: Class TypedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class TypedCashflow extends Cashflow {
    public static final int CREDIT = 0;
    public static final int DEBIT  = 1;

    private int             type;

    public TypedCashflow() {
    }

    public TypedCashflow(Date date, int type, double amount) {
        super( date, amount );
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String toString() {
        return "TypedCashflow[date=" + getDate() +
               ",type=" + (type == CREDIT ? "Credit" : "Debit") +
               ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"/><p>There are lots of ways to improve this code, but for the sake
    of the example this will do.</p><p>Now let's create Example5, a class for running our code.</p><div class="example"><a id="d0e7987"/><p class="title"><b>Example 8.44. Banking Tutorial: Example5.java</b></p><div class="example-contents"><pre class="programlisting">public class Example5 {    
    public static void main(String[] args) throws Exception {      
        Object[] cashflows = {
            new TypedCashflow(new SimpleDate("01/01/2007"),    
                              TypedCashflow.CREDIT, 300.00),
            new TypedCashflow(new SimpleDate("05/01/2007"),
                              TypedCashflow.CREDIT, 100.00),
            new TypedCashflow(new SimpleDate("11/01/2007"),
                              TypedCashflow.CREDIT, 500.00),
            new TypedCashflow(new SimpleDate("07/01/2007"),
                              TypedCashflow.DEBIT, 800.00),
            new TypedCashflow(new SimpleDate("02/01/2007"),
                              TypedCashflow.DEBIT, 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example5.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"/><p>Here, we simply create a set of <code class="code">Cashflow</code> objects
    which are either credit or debit operations. We supply them and
    <code class="filename">Example5.drl</code> to the RuleEngine. </p><p>Now, let’s look at a rule printing the sorted
    <code class="code">Cashflow</code> objects.</p><div class="example"><a id="d0e8005"/><p class="title"><b>Example 8.45. Banking Tutorial: Rule in Example5.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 05"  
    when
        $cashflow : TypedCashflow( $date : date,
                                   $amount : amount,
                                   type == TypedCashflow.CREDIT )
        not TypedCashflow( date &lt; $date,
                           type == TypedCashflow.CREDIT )
    then
        System.out.println("Credit: "+$date+" :: "+$amount);   
        retract($cashflow);
end</pre></div></div><br class="example-break"/><p>Here, we identify a <code class="code">Cashflow</code> fact with a type
    of <code class="code">CREDIT</code> and extract the date and the amount. In the
    second line of the rule we ensure that there is no <code class="code">Cashflow</code>
    of the same type with an earlier date than the one found. In the
    consequence, we print the cashflow satisfying the patterns and then
    retract it, making way for the next earliest cashflow of type
    <code class="code">CREDIT</code>.</p><p>So, the output we generate is</p><div class="example"><a id="d0e8026"/><p class="title"><b>Example 8.46. Banking Tutorial: Output of Example5.java</b></p><div class="example-contents"><pre class="screen">Loading file: Example5.drl
Inserting fact: TypedCashflow[date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: TypedCashflow[date=Fri Jan 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: TypedCashflow[date=Thu Jan 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: TypedCashflow[date=Sun Jan 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: TypedCashflow[date=Tue Jan 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Credit: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Credit: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"/><p>Continuing our banking exercise, we are now going to process both
    credits and debits on two bank accounts, calculating the account balance.
    In order to do this, we create two separate <code class="code">Account</code> objects
    and inject them into the <code class="code">Cashflows</code> objects before passing
    them to the Rule Engine. The reason for this is to provide easy access
    to the correct account without having to resort to helper classes. Let’s
    take a look at the <code class="code">Account</code> class first. This is a simple
    Java object with an account number and balance:</p><div class="example"><a id="d0e8042"/><p class="title"><b>Example 8.47. Banking Tutorial: Class Account</b></p><div class="example-contents"><pre class="programlisting">public class Account {
    private long   accountNo;
    private double balance = 0;

    public Account() {
    }

    public Account(long accountNo) {
        this.accountNo = accountNo;
    }

    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account[" + "accountNo=" + accountNo + ",balance=" + balance + "]";
    }
}</pre></div></div><br class="example-break"/><p>Now let’s extend our <code class="code">TypedCashflow</code>, resulting in
    <code class="code">AllocatedCashflow</code>, to include an <code class="code">Account</code>
    reference.</p><div class="example"><a id="d0e8058"/><p class="title"><b>Example 8.48. Banking Tutorial: Class AllocatedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class AllocatedCashflow extends TypedCashflow {
    private Account account;

    public AllocatedCashflow() {
    }

    public AllocatedCashflow(Account account, Date date, int type, double amount) {
        super( date, type, amount );
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public String toString() {
        return "AllocatedCashflow[" +
               "account=" + account +
               ",date=" + getDate() + 
               ",type=" + (getType() == CREDIT ? "Credit" : "Debit") + 
               ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"/><p>The Java code of <code class="filename">Example5.java</code> creates 
    two <code class="code">Account</code> objects and passes one of them into each
    cashflow, in the constructor call.</p><div class="example"><a id="d0e8071"/><p class="title"><b>Example 8.49. Banking Tutorial: Example5.java</b></p><div class="example-contents"><pre class="programlisting">public class Example6 {    
    public static void main(String[] args) throws Exception {      
        Account acc1 = new Account(1);
        Account acc2 = new Account(2);
           
        Object[] cashflows = {
            new AllocatedCashflow(acc1,new SimpleDate("01/01/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/02/2007"),
                                  TypedCashflow.CREDIT, 100.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/03/2007"),
                                  TypedCashflow.CREDIT, 500.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/02/2007"),
                                  TypedCashflow.DEBIT,  800.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/03/2007"),
                                  TypedCashflow.DEBIT,  400.00),
            new AllocatedCashflow(acc1,new SimpleDate("01/04/2007"),    
                                  TypedCashflow.CREDIT, 200.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/04/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/05/2007"),
                                  TypedCashflow.CREDIT, 700.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/05/2007"),
                                  TypedCashflow.DEBIT,  900.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/05/2007"),
                                  TypedCashflow.DEBIT,  100.00)           
        };
        
        new RuleRunner().runRules( new String[] { "Example6.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"/><p>Now, let’s look at the rule in <code class="filename">Example6.drl</code>
    to see how we apply each cashflow in date order and calculate and print
    the balance. </p><div class="example"><a id="d0e8081"/><p class="title"><b>Example 8.50. Banking Tutorial: Rule in Example6.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 06 - Credit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                                       $date : date,
                                       $amount : amount,
                                       type == TypedCashflow.CREDIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Credit: " + $date + " :: " + $amount);     
        $account.setBalance($account.getBalance()+$amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());          
        retract($cashflow);
end

rule "Rule 06 - Debit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                            $date : date,
                            $amount : amount,
                            type == TypedCashflow.DEBIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Debit: " + $date + " :: " + $amount);      
        $account.setBalance($account.getBalance() - $amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());           
        retract($cashflow);
end</pre></div></div><br class="example-break"/><p>Although we have separate rules for credits and debits, but we do
    not specify a type when checking for earlier cashflows. This is so that
    all cashflows are applied in date order, regardless of the cashflow type.
    In the conditions we identify the account to work with, and in the
    consequences we update it with the cashflow amount.</p><div class="example"><a id="d0e8088"/><p class="title"><b>Example 8.51. Banking Tutorial: Output of Example6.java</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example6.drl
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0]
Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0
Account: 2 - new balance: -400.0
Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0
Account: 2 - new balance: 100.0
Debit: Wed May 02 00:00:00 BST 2007 :: 100.0
Account: 2 - new balance: 0.0
Credit: Fri May 11 00:00:00 BST 2007 :: 700.0
Account: 2 - new balance: 700.0
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Account: 1 - new balance: 300.0
Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0
Account: 1 - new balance: 400.0
Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0
Account: 1 - new balance: -400.0
Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0
Account: 1 - new balance: -200.0
Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0
Account: 1 - new balance: 100.0
Debit: Mon May 07 00:00:00 BST 2007 :: 900.0
Account: 1 - new balance: -800.0
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8093"/>8.6. Pricing Rule Decision Table Example</h2></div></div></div><p>The Pricing Rule decision table demonstrates the use of a 
    decision table in a spreadsheet, in Excel's XLS format, in calculating
    the retail cost of an insurance policy. The purpose of the provide set
    of rules is to calculate a base price and a discount for a
    car driver applying for a specific policy. The driver's age, history and
    the policy type all contribute to what the basic premium is, and an
    additional chunk of rules deals with refining this with a discount
    percentage.</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Example Policy Pricing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PricingRuleDTExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> ExamplePolicyPricing.xls
<span class="bold"><strong>Objective:</strong></span> demonstrate spreadsheet-based decision tables.</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8114"/>8.6.1. Executing the example</h3></div></div></div><p>Open the file <code class="filename">PricingRuleDTExample.java</code> and 
      execute it as a Java application. It should produce the following
      output in the Console window:</p><pre class="programlisting">Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20     </pre><p>The code to execute the example follows the usual pattern.
      The rules are loaded, the facts inserted and a Stateless Session is
      created. What is different is how the rules are added.</p><pre class="programlisting">DecisionTableConfiguration dtableconfiguration =
    KnowledgeBuilderFactory.newDecisionTableConfiguration();
        dtableconfiguration.setInputType( DecisionTableInputType.XLS );

        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        Resource xlsRes = ResourceFactory.newClassPathResource( "ExamplePolicyPricing.xls",
                                                                getClass() );
        kbuilder.add( xlsRes,
                      ResourceType.DTABLE,
                      dtableconfiguration );
</pre><p>Note the use of the <code class="code">DecisionTableConfiguration</code> object.
      Its input type is set to <code class="code">DecisionTableInputType.XLS</code>.
      If you use the BRMS, all this is of course taken care of for you.</p><p>There are two fact types used in this example, <code class="code">Driver</code>
      and <code class="code">Policy</code>. Both are used with their default values. The
      <code class="code">Driver</code> is 30 years old, has had no prior claims and
      currently has a risk profile of <code class="code">LOW</code>. The <code class="code">Policy</code>
      being applied for is <code class="code">COMPREHENSIVE</code>, and it has not yet been
      approved.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8156"/>8.6.2. The decision table</h3></div></div></div><p>In this decision table, each row is a rule, and each column is
      a condition or an action.</p><div class="figure"><a id="d0e8161"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Config.png" width="100%" alt="Decision table configuration"/></td></tr></table></div></div><p class="title"><b>Figure 8.10. Decision table configuration</b></p></div><br class="figure-break"/><p>Referring to the spreadsheet show above, we have the
      <code class="code">RuleSet</code> declaration, which provides the package name.
      There are also other optional items you can have here, such as
      <code class="code">Variables</code> for global variables, and <code class="code">Imports</code>
      for importing classes. In this case, the namespace of the rules is
      the same as the fact classes we are using, so we can omit it.</p><p>Moving further down, we can see the <code class="code">RuleTable</code>
      declaration. The name after this (Pricing bracket) is used as the
      prefix for all the generated rules. Below that, we have
      "CONDITION or ACTION", indicating the purpose of the column, i.e.,
      whether it forms part of the condition or the consequence of the rule
      that will be generated.</p><p>You can see that there is a driver, his data spanned across three
      cells, which means that the template expressions below it apply to that
      fact. We observe the driver's age range (which uses <code class="code">$1</code> and
      <code class="code">$2</code> with comma-separated values), 
      <code class="code">locationRiskProfile</code>, and <code class="code">priorClaims</code> in the
      respective columns. In the action columns, we are set the policy
      base price and log a message.</p><div class="figure"><a id="d0e8197"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Table1.png" width="100%" alt="Base price calculation"/></td></tr></table></div></div><p class="title"><b>Figure 8.11. Base price calculation</b></p></div><br class="figure-break"/><p>In the preceding spreadsheet section, there are broad category
      brackets, indicated by the comment in the leftmost column. As we know
      the details of our drivers and their policies, we can tell (with a bit
      of thought) that they should match row number 18, as they have no
      prior accidents, and are 30 years old. This gives us a base price
      of 120.</p><div class="figure"><a id="d0e8205"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Table2.png" width="100%" alt="Discount calculation"/></td></tr></table></div></div><p class="title"><b>Figure 8.12. Discount calculation</b></p></div><br class="figure-break"/><p>The above section contains the conditions for the discount we
      might grant our driver. The discount results from the <code class="code">Age</code>
      bracket, the number of prior claims, and the policy type. In our case,
      the driver is 30, with no prior claims, and is applying for a
      <code class="code">COMPREHENSIVE</code> policy, which means we can give a discount
      of 20%. Note that this is actually a separate table, but in the same
      worksheet, so that different templates apply.</p><p>It is important to note that decision tables generate rules.
      This means they aren't simply top-down logic, but more a means to
      capture data resulting in rules. This is a subtle difference that
      confuses some people. The evaluation of the rules is not necessarily
      in the given order, since all the normal mechanics of the rule engine
      still apply.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8221"/>8.7. Pet Store Example</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Pet Store 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PetStore
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> PetStore.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Agenda Groups, Global Variables and integration with a GUI,
including callbacks from within the rules
</pre><p>The Pet Store example shows how to integrate Rules with a GUI,
      in this case a Swing based desktop application. Within the rules file,
      it demonstrates how to use Agenda groups and auto-focus to control
      which of a set of rules is allowed to fire at any given time. It also
      illustrates the mixing of the Java and MVEL dialects within the rules,
      the use of accumulate functions and the way of calling Java functions
      from within the ruleset.</p><p>All of the Java code is contained in one file,
      <code class="filename">PetStore.java</code>, defining the following principal
      classes (in addition to several classes to handle Swing Events):</p><div class="itemizedlist"><ul><li><p><code class="code">Petstore</code> contains the <code class="code">main()</code>
          method that we will look at shortly.</p></li><li><p><code class="code">PetStoreUI</code> is responsible for creating and
          displaying the Swing based GUI. It contains several smaller
          classes, mainly for responding to various GUI events such as
          mouse button clicks.</p></li><li><p><code class="code">TableModel</code> holds the table data. Think of it
          as a JavaBean that extends the Swing class
          <code class="code">AbstractTableModel</code>.</p></li><li><p><code class="code">CheckoutCallback</code> allows the GUI to interact
          with the Rules.</p></li><li><p><code class="code">Ordershow</code> keeps the items that we wish to
          buy.</p></li><li><p><code class="code">Purchase</code> stores details of the order and
          the products we are buying.</p></li><li><p><code class="code">Product</code> is a JavaBean holding details of
          the product available for purchase, and its price.</p></li></ul></div><p>Much of the Java code is either plain JavaBeans or Swing-based.
      Only a few Swing-related points will be discussed in this section,
      but a good tutorial about Swing components can be found at Sun's
      Swing website, in
      <a class="ulink" href="???">
      <code class="uri">http://java.sun.com/docs/books/tutorial/uiswing/</code>
      </a>.</p><p>The pieces of Java code in <code class="filename">Petstore.java</code>
      that relate to rules and facts are shown below.</p><div class="example"><a id="d0e8302"/><p class="title"><b>Example 8.52. Creating the PetStore RuleBase in PetStore.main</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

kbuilder.add( ResourceFactory.newClassPathResource( "PetStore.drl",
                                                    PetStore.class ),
              ResourceType.DRL );
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );

// Create the stock.
Vector&lt;Product&gt; stock = new Vector&lt;Product&gt;();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the
// Working Memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kbase ) );
ui.createAndShowGUI();
</pre></div></div><br class="example-break"/><p>The code shown above loads the rules from a DRL file on the
      classpath. Unlike other examples where the facts are asserted and
      fired straight away, this example defers this step to later. The
      way it does this is via the second last line where a
      <code class="code">PetStoreUI</code> object is created using a constructor 
      accepting the <code class="code">Vector</code> object <code class="code">stock</code>
      collecting our products, and an instance of
      the <code class="code">CheckoutCallback</code> class containing the Rule Base
      that we have just loaded.</p><p>The Java code that fires the rules is within the 
      <code class="code">CheckoutCallBack.checkout()</code> method. This is triggered
      (eventually) when the Checkout button is pressed by the user.</p><div class="example"><a id="d0e8326"/><p class="title"><b>Example 8.53. Firing the Rules - extract from CheckoutCallBack.checkout()</b></p><div class="example-contents"><pre class="programlisting">public String checkout(JFrame frame, List&lt;Product&gt; items) {
    Order order = new Order();

    // Iterate through list and add to cart
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction

    StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );
    ksession.fireAllRules();

    // Return the state of the cart
    return order.toString();
}
</pre></div></div><br class="example-break"/><p>Two items get passed into this method. One is the handle to the
      <code class="code">JFrame</code> Swing component surrounding the output text
      frame, at the bottom of the GUI. The second is a list of order items;
      this comes from the <code class="code">TableModel</code> storing the information
      from the "Table" area at the top right section of the GUI.</p><p>The for loop transforms the list of order items coming from the
      GUI into the <code class="code">Order</code> JavaBean, also contained in the
      file <code class="filename">PetStore.java</code>. Note that it would be 
      possible to refer to the Swing dataset directly within the rules,
      but it is better coding practice to do it this way, using simple
      Java objects. It means that we are not tied to Swing if we wanted
      to transform the sample into a Web application.</p><p>It is important to note that <span class="emphasis"><em>all state in this
      example is stored in the Swing components, and that the rules are
      effectively stateless.</em></span> Each time the "Checkout" button is
      pressed, this code copies the contents of the Swing
      <code class="code">TableModel</code> into the Session's Working Memory.</p><p>Within this code, there are nine calls to the Working Memory.
      The first of these creates a new Working Memory, as a Stateful
      Knowledge Session from the Knowledge Base. Remember that we passed
      in this Knowledge Base when we created the <code class="code">CheckoutCallBack</code>
      class in the <code class="code">main()</code> method. The next two calls pass in
      two objects that we will hold as global variables in the rules: the
      Swing text area and the Swing frame used for writing messages.</p><p>More inserts put information on products into the Working Memory,
      as well as the order list. The final call is the standard
      <code class="code">fireAllRules()</code>. Next, we look at what this method causes
      to happen within the rules file.</p><div class="example"><a id="d0e8368"/><p class="title"><b>Example 8.54. Package, Imports, Globals and Dialect: extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">package org.drools.examples

import org.drools.WorkingMemory
import org.drools.examples.PetStore.Order
import org.drools.examples.PetStore.Purchase
import org.drools.examples.PetStore.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame 
global javax.swing.JTextArea textArea</pre></div></div><br class="example-break"/><p>The first part of file <code class="filename">PetStore.drl</code>
      contains the standard package and import statements to make various
      Java classes available to the rules. New to us are the two globals
      <code class="code">frame</code> and <code class="code">textArea</code>. They hold references
      to the Swing components <code class="code">JFrame</code> and <code class="code">JTextArea</code>
      components that were previously passed on by the Java code calling
      the <code class="code">setGlobal()</code> method. Unlike  variables in rules,
      which expire as soon as the rule has fired, global variables retain
      their value for the lifetime of the Session.</p><p>The next extract from the file <code class="filename">PetStore.drl</code>
      contains two functions that are referenced by the rules that we will
      look at shortly.</p><div class="example"><a id="d0e8398"/><p class="title"><b>Example 8.55. Java Functions in the Rules: extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">function void doCheckout(JFrame frame, WorkingMemory workingMemory) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
        "Would you like to checkout?",
        "",
        JOptionPane.YES_NO_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null,
        options,
        options[0]);

    if (n == 0) {
        workingMemory.setFocus( "checkout" );
    }   
}

function boolean requireTank(JFrame frame, WorkingMemory workingMemory, Order order, Product fishTank, int total) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
        "Would you like to buy a tank for your " + total + " fish?",
        "Purchase Suggestion",
        JOptionPane.YES_NO_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null,
        options,
        options[0]);
                                             
    System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                      + total + " fish? - " );

    if (n == 0) {
        Purchase purchase = new Purchase( order, fishTank );
        workingMemory.insert( purchase );
        order.addItem( purchase );
        System.out.println( "Yes" );
    } else {
        System.out.println( "No" );
    }      
    return true;
}
</pre></div></div><br class="example-break"/><p>Having these functions in the rules file just makes the Pet Store
      example more compact. In real life you probably have the functions
      in a file of their own, within the same rules package, or as a
      static method on a standard Java class, and import them, using
      <code class="code">import function my.package.Foo.hello</code>.</p><p>The purpose of these two functions is:</p><div class="itemizedlist"><ul><li><p><code class="code">doCheckout()</code> displays a dialog asking users
          whether they wish to checkout. If they do, focus is set to the
          <code class="code">checkOut</code> agenda-group, allowing rules in that group
          to (potentially) fire.</p></li><li><p><code class="code">requireTank()</code> displays a dialog asking
          users whether they wish to buy a tank. If so, a new fish tank
          <code class="code">Product</code> is added to the order list in Working
          Memory.</p></li></ul></div><p>We'll see the rules that call these functions later on. The
      next set of examples are from the Pet Store rules themselves. The
      first extract is the one that happens to fire first, partly because
      it has the <strong class="kw"><code>auto-focus</code></strong> attribute set to true.</p><div class="example"><a id="d0e8432"/><p class="title"><b>Example 8.56. Putting items into working memory: extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// Insert each item in the shopping cart into the Working Memory 
// Insert each item in the shopping cart into the Working Memory
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end</pre></div></div><br class="example-break"/><p>This rule matches against all orders that do not yet have their
      <code class="code">grossTotal</code> calculated . It loops for each purchase item
      in that order. Some parts of the "Explode Cart" rule should be familiar:
      the rule name, the salience (suggesting the order for the rules being
      fired) and the dialect set to <code class="code">"java"</code>. There are three
      new features:</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>agenda-group</code></strong> <code class="code">"init"</code> defines the name
           of the agenda group. In this case, there is only one rule in the
           group. However, neither the Java code nor a rule consequence sets
           the focus to this group, and therefore it relies on the next
           attibute for its chance to fire.</p></li><li><p><strong class="kw"><code>auto-focus</code></strong> <code class="code">true</code> ensures that this rule,
          while being the only rule in the agenda group, gets a chance to fire
          when <code class="code">fireAllRules()</code> is called from the Java code.</p></li><li><p><code class="code">kcontext....setFocus()</code> sets the focus to the
          <code class="code">"show items"</code> and <code class="code">"evaluate"</code> agenda groups
          in turn, permitting their rules to fire. In practice, we loop
          through all items on the order, inserting them into memory, then
          firing the other rules after each insert.</p></li></ul></div><p>The next two listings show the rules within the
      <code class="code">"show items"</code> and <code class="code">evaluate</code> agenda groups.
      We look at them in the order that they are called.</p><div class="example"><a id="d0e8484"/><p class="title"><b>Example 8.57. Show Items in the GUI - extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
</pre></div></div><br class="example-break"/><p>The <code class="code">"show items"</code> agenda-group has only one rule,
      called "Show Items" (note the difference in case). For each purchase
      on the order currently in the Working Memory (or Session), it logs
      details to the text area at the bottom of the GUI. The
      <code class="code">textArea</code> variable used to do this is one of the global
      variables we looked at earlier.</p><p>The <code class="code">evaluate</code> Agenda group also gains focus from
      the <code class="code">"Explode Cart"</code> rule listed previously. This
      Agenda group has two rules, <code class="code">"Free Fish Food Sample"</code> and
      <code class="code">"Suggest Tank"</code>, shown below.</p><div class="example"><a id="d0e8511"/><p class="title"><b>Example 8.58. Evaluate Agenda Group: extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// Free Fish Food sample when we buy a Gold Fish if we haven't already bought 
// Fish Food and don't already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate"
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;amp;&amp;amp; Purchase( product == $p ) )
    not ( $p : Product( name == "Fish Food Sample") &amp;amp;&amp;amp; Purchase( product == $p ) )
    exists ( $p : Product( name == "Gold Fish") &amp;amp;&amp;amp; Purchase( product == $p ) )
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

// Suggest a tank if we have bought more than 5 gold fish and don't already have one
rule "Suggest Tank"
    agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;amp;&amp;amp; Purchase( product == $p ) )
    ArrayList( $total : size &amp;gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) )
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, drools.getWorkingMemory(), $order, $fishTank, $total); 
end
</pre></div></div><br class="example-break"/><p>The rule <code class="code">"Free Fish Food Sample"</code> will only fire if</p><div class="itemizedlist"><ul><li><p>we <span class="emphasis"><em>don't </em></span>already have any fish food, <span class="emphasis"><em>and</em></span></p></li><li><p>we <span class="emphasis"><em>don't</em></span> already have a free fish food sample,
          <span class="emphasis"><em>and</em></span></p></li><li><p>we <span class="emphasis"><em>do</em></span> have a Gold Fish in our order.</p></li></ul></div><p>If the rule does fire, it creates a new product (Fish Food Sample), and adds it to the
      order in Working Memory.</p><p>The rule <code class="code">"Suggest Tank"</code> will only fire if</p><div class="itemizedlist"><ul><li><p>we <span class="emphasis"><em>don't </em></span>already have a Fish Tank in our order,
          <span class="emphasis"><em>and</em></span></p></li><li><p>we <span class="emphasis"><em>do</em></span> have more than 5 Gold Fish Products
          in our order.</p></li></ul></div><p>If the rule does fire, it calls the <code class="code">requireTank()</code> function
      that we looked at earlier (showing a Dialog to the user, and adding a Tank to
      the order / working memory if confirmed). When calling the
      <span class="italic">requireTank</span>() function the rule passes
      the global <span class="italic">frame</span> variable so that the
      function has a handle to the Swing GUI.</p><p>The next rule we look at is <code class="code">"do checkout"</code>.</p><div class="example"><a id="d0e8582"/><p class="title"><b>Example 8.59. Doing the Checkout - extract (6) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, drools.getWorkingMemory());
end</pre></div></div><br class="example-break"/><p>The rule <code class="code">"do checkout"</code> has <span class="bold"><strong>no
      agenda group set and no auto-focus attribute</strong></span>. As such, is is
      deemed part of the default (MAIN) agenda group. This group gets focus by
      default when all the rules in agenda-groups that explicity had focus set
      to them have run their course.</p><p>There is no LHS to the rule, so the RHS will always call the
      <code class="code">doCheckout()</code> function. When calling the
      <code class="code">doCheckout()</code> function, the rule passes the global
      <code class="code">frame</code> variable to give the function a handle to the Swing GUI.
      As we saw earlier, the <code class="code">doCheckout()</code> function shows a
      confirmation dialog to the user. If confirmed, the function sets the focus
      to the <span class="italic">checkout</span> agenda-group, allowing
      the next lot of rules to fire.</p><div class="example"><a id="d0e8612"/><p class="title"><b>Example 8.60. Checkout Rules: extract from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue )
       from accumulate( Purchase( $price : product.price ), sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 10 &amp;amp;&amp;amp; &amp;lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
</pre></div></div><br class="example-break"/><p>There are three rules in the <span class="italic">checkout</span> agenda-group:</p><div class="itemizedlist"><ul><li><p>If we haven't already calculated the gross total,
          <code class="code">Gross Total</code> accumulates the product prices into a total,
          puts this total into Working Memory, and displays it via the Swing
          <code class="code">JTextArea</code>, using the <code class="code">textArea</code> global
          variable yet again.</p></li><li><p>If our gross total is between 10 and 20, 
          <code class="code">"Apply 5% Discount"</code> calculates the discounted total and
          adds it to the Working Memory and displays it in the text area.</p></li><li><p>If our gross total is not less than 20, 
          <code class="code">"Apply 10% Discount"</code> calculates the discounted total and
          adds it to the Working Memory and displays it in the text area.</p></li></ul></div><p>Now that we've run through what happens in the code, let's have a
      look at what happens when we actually run the code. The file
      <code class="filename">PetStore.java</code> contains a <code class="code">main()</code> method,
      so that it can be run as a standard Java application, either from the
      command line or via the IDE. This assumes you have your classpath set
      correctly. (See the start of the examples section for more information.)</p><p>The first screen that we see is the Pet Store Demo. It has a list
      of available products (top left), an empty list of selected products
      (top right), checkout and reset buttons (middle) and an empty system
      messages area (bottom).</p><div class="figure"><a id="d0e8657"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/1-PetStore-Start-Screen.png" alt="PetStore Demo just after Launch"/></div></div><p class="title"><b>Figure 8.13. PetStore Demo just after Launch</b></p></div><br class="figure-break"/><p>To get to this point, the following things have happened:</p><div class="orderedlist"><ol type="1"><li><p>The <code class="code">main()</code> method has run and loaded the Rule Base
          <span class="emphasis"><em>but not yet fired the rules</em></span>. So far, this is the
          only code in connection with rules that has been run.</p></li><li><p>A new <code class="code">PetStoreUI</code> object has been created and given a
          handle to the Rule Base, for later use.</p></li><li><p>Various Swing components do their stuff, and the above screen
          is shown and <span class="emphasis"><em>waits for user input</em></span>.</p></li></ol></div><p>Clicking on various products from the list might give you a
      screen similar to the one below.</p><div class="figure"><a id="d0e8689"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/2-stock-added-to-order-list.png" alt="PetStore Demo with Products Selected"/></div></div><p class="title"><b>Figure 8.14. PetStore Demo with Products Selected</b></p></div><br class="figure-break"/><p>Note that <span class="emphasis"><em>no rules code has been fired here</em></span>. This
      is only Swing code, listening for mouse click events, and adding some
      selected product to the <code class="code">TableModel</code> object for display in the
      top right hand section. (As an aside, note that this is a classic use of
      the Model View Controller design pattern).</p><p>It is only when we press the "Checkout" button that we fire our
      business rules, in roughly the same order that we walked through the
      code earlier.</p><div class="orderedlist"><ol type="1"><li><p>Method <code class="code">CheckOutCallBack.checkout()</code> is called
          (eventually) by the Swing class waiting for the click on the
          "Checkout" button. This inserts the data from the
          <code class="code">TableModel</code> object (top right hand side of the GUI),
          and inserts it into the Session's Working Memory. It then fires
          the rules.</p></li><li><p>The <code class="code">"Explode Cart"</code> rule is the first to fire,
          given that it has <strong class="kw"><code>auto-focus</code></strong> set to true. It loops through
          all the products in the cart, ensures that the products are in the
          Working Memory, and then gives the <code class="code">"Show Items"</code> and
          <code class="code">Evaluation</code> agenda groups a chance to fire. The rules
          in these groups add the contents of the cart to the text area
          (at the bottom of the window), decide whether or not to give us free
          fish food, and to ask us whether we want to buy a fish tank. This
          is shown in the figure below.</p></li></ol></div><div class="figure"><a id="d0e8730"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/3-purchase-suggestion.png" alt="Do we want to buy a fish tank?"/></div></div><p class="title"><b>Figure 8.15. Do we want to buy a fish tank?</b></p></div><br class="figure-break"/><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">Do Checkout</span> rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the<span class="italic"> doCheckout() function </span>which displays a 'Would you like to Checkout?' Dialog Box.</p></li><li><p>The <code class="code">doCheckout()</code> function sets the focus to the
          <code class="code">checkout</code> agenda-group, giving the rules in that group
          the option to fire.</p></li><li><p>The rules in the the <code class="code">checkout</code> agenda-group display
          the contents of the cart and apply the appropriate discount.</p></li><li><p><span class="emphasis"><em>Swing then waits for user input</em></span> to either
          checkout more products (and to cause the rules to fire again), or to
          close the GUI - see the figure below.</p></li></ol></div><div class="figure"><a id="d0e8766"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/4-Petstore-final-screen.png" alt="Petstore Demo after all rules have fired."/></div></div><p class="title"><b>Figure 8.16. Petstore Demo after all rules have fired.</b></p></div><br class="figure-break"/><p>We could add more System.out calls to demonstrate this flow of
      events. The output, as it currently appears in the Console window, is
      given in the listing below.</p><div class="example"><a id="d0e8774"/><p class="title"><b>Example 8.61. Console (System.out) from running the PetStore GUI</b></p><div class="example-contents"><pre class="programlisting">Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8780"/>8.8. Honest Politician Example</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Honest Politician
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HonestPoliticianExample 
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HonestPoliticianExample.drl
<span class="bold"><strong>Objective:</strong></span> Illustrate the concept of "truth maintenance" based on the logical insertion of facts
</pre><p>The Honest Politician example demonstrates truth maintenance with
  logical assertions. The basic premise is that an object can only exist
  while a statement is true. A rule's consequence can logically insert an 
  object with the <code class="code">insertLogical()</code> method. This means the object
  will only remain in the Working Memory as long as the rule that logically
  inserted  it remains true. When the rule is no longer true the object is
  automatically retracted.</p><p>In this example there is the class <code class="code">Politician</code>, with a
  name and a boolean value for being honest. Four politicians with honest
  state set to true are inserted.</p><div class="example"><a id="d0e8810"/><p class="title"><b>Example 8.62. Class Politician</b></p><div class="example-contents"><pre class="programlisting">public class Politician {
    private String name;
    private boolean honest;
    ...
}</pre></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e8815"/><p class="title"><b>Example 8.63. Honest Politician: Execution</b></p><div class="example-contents"><pre class="programlisting">Politician blair = new Politician("blair", true);
Politician bush = new Politician("bush", true);
Politician chirac = new Politician("chirac", true);
Politician schroder = new Politician("schroder", true);
    
ksession.insert( blair );
ksession.insert( bush );
ksession.insert( chirac );
ksession.insert( schroder );

ksession.fireAllRules();</pre></div></div><p><br class="example-break"/>The Console window output shows that, while there is at
    least one honest politician, democracy lives. However, as each
    politician is in turn corrupted by an evil corporation, so that
    all politicians become dishonest, democracy is dead.</p><div class="example"><a id="d0e8821"/><p class="title"><b>Example 8.64. Honest Politician: Console Output</b></p><div class="example-contents"><pre class="programlisting">Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted schroder
I'm an evil corporation and I have corrupted chirac
I'm an evil corporation and I have corrupted bush
I'm an evil corporation and I have corrupted blair
We are all Doomed!!! Democracy is Dead
</pre></div></div><p><br class="example-break"/>As soon as there is at least one honest politician in the
    Working Memory a new <code class="code">Hope</code> object is logically asserted.
    This object will only exist while there is at least one honest
    politician. As soon as all politicians are dishonest, the
    <code class="code">Hope</code> object will be automatically retracted. This rule
    is given a salience of 10 to ensure that it fires before any other
    rule, as at this stage the "Hope is Dead" rule is actually true.</p><div class="example"><a id="d0e8833"/><p class="title"><b>Example 8.65. Honest Politician: Rule "We have an honest politician"</b></p><div class="example-contents"><pre class="programlisting">rule "We have an honest Politician"
    salience 10
    when
        exists( Politician( honest == true ) )
    then
        insertLogical( new Hope() );
end</pre></div></div><br class="example-break"/><p>As soon as a <code class="code">Hope</code> object exists the "Hope Lives" rule
  matches and fires. It has a salience of 10 so that it takes priority
  over "Corrupt the Honest".</p><div class="example"><a id="d0e8843"/><p class="title"><b>Example 8.66. Honest Politician: Rule "Hope Lives"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope Lives"
    salience 10
        when
            exists( Hope() )
        then
            System.out.println("Hurrah!!! Democracy Lives");
end</pre></div></div><br class="example-break"/><p>Now that there is hope and we have, at the start, four honest
    politicians, we have four activations for this rule, all in conflict.
    They will fire in turn, corrupting each politician so that they are
    no longer honest. When all four politicians have been corrupted we
    have no politicians with the property <code class="code">honest == true</code>.
    Thus, the rule "We have an honest Politician" is no longer true and
    the object it logical inserted (due to the last execution of
    <code class="code">new Hope()</code>) is automatically retracted.</p><div class="example"><a id="d0e8856"/><p class="title"><b>Example 8.67. Honest Politician: Rule "Corrupt the Honest"</b></p><div class="example-contents"><pre class="programlisting">rule "Corrupt the Honest"
    when
        politician : Politician( honest == true )   
        exists( Hope() )
    then
        System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
        modify ( politician ) { honest = false };
end</pre></div></div><br class="example-break"/><p>With the <code class="code">Hope</code> object being automatically retracted,
    via the truth maintenance system, the conditional element <strong class="kw"><code>not</code></strong>
    applied to <code class="code">Hope</code> is no longer true so that the following
    rule will match and fire.</p><div class="example"><a id="d0e8872"/><p class="title"><b>Example 8.68. Honest Politician: Rule "Hope is Dead"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope is Dead"
    when
        not( Hope() )
    then
        System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</pre></div></div><br class="example-break"/><p>Let's take a look at the Audit trail for this application:</p><div class="figure"><a id="d0e8879"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/HonestPoliticianExample/honest_politician_audit.png" width="100%" alt="Honest Politician Example Audit View"/></td></tr></table></div></div><p class="title"><b>Figure 8.17. Honest Politician Example Audit View</b></p></div><br class="figure-break"/><p>The moment we insert the first politician we have two activations.
    The rule "We have an honest Politician" is activated only once for the first
    inserted politician because it uses an <strong class="kw"><code>exists</code></strong> conditional
    element, which matches once for any number. The rule "Hope is Dead" is
    also activated at this stage, because we have not yet inserted the
    <code class="code">Hope</code> object. Rule "We have an honest Politician" fires first,
    as it has a higher salience than "Hope is Dead", which inserts the
    <code class="code">Hope</code> object. (That action is highlighted green.) The
    insertion of the <code class="code">Hope</code> object activates "Hope Lives" and
    de-activates "Hope is Dead"; it also activates "Corrupt the Honest"
    for each inserted honested politician. Rule "Hope Lives" executes,
    printing  "Hurrah!!! Democracy Lives". Then, for each politician, rule
    "Corrupt the Honest" fires, printing "I'm an evil corporation and I
    have corrupted X", where X is the name of the politician, and modifies
    the politician's honest value to false. When the last honest politician
    is corrupted, <code class="code">Hope</code> is automatically retracted, by the truth
    maintenance system, as shown by the blue highlighted area. The green
    highlighted area shows the origin of the currently selected blue
    highlighted area. Once the <code class="code">Hope</code> fact is retracted, "Hope is
    dead" activates and fires printing "We are all Doomed!!! Democracy is
    Dead".</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8905"/>8.9. Sudoku Example</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Sudoku
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.sudoku.Main
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> sudokuSolver.drl, sudokuValidator.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates the solving of logic problems, and complex pattern matching.
</pre><p>This example demonstrates how Drools can be used to find a solution
    in a large potential solution space based on a number of constraints. We
    use the popular puzzle of Sudoku. This example also shows how Drools can
    be integrated into a graphical interface and how callbacks can be used to
    interact with a running Drools rules engine in order to update the
    graphical interface based on changes in the Working Memory at
    runtime.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8926"/>8.9.1. Sudoku Overview</h3></div></div></div><p>Sudoku is a logic-based number placement puzzle. The objective is
      to fill a 9x9 grid so that each column, each row, and each of the nine
      3x3 zones contains the digits from 1 to 9, once, and only once.</p><p>The puzzle setter provides a partially completed grid and the
      puzzle solver's task is to complete the grid with these
      constraints.</p><p>The general strategy to solve the problem is to ensure that when
      you insert a new number it should be unique in its particular
      3x3 zone, row and column.</p><p>See </p><pre class="programlisting">URL: http://en.wikipedia.org/wiki/Sudoku</pre><p>
      for a more detailed description.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8940"/>8.9.2. Running the Example</h3></div></div></div><p>Download and install drools-examples as described above and then
      execute <code class="filename">java org.drools.examples.sudoku.Main</code>. This
      example requires Java 5.</p><p>A window will be displayed with a relatively simple partially
      filled grid. </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku1.png"/></div></div><p>Click on the "Solve" button and the Drools-based engine will fill
      out the remaining values. The Console window will display detailed
      information about the rules which are executing to solve the puzzle
      in a human readable form.</p><pre class="screen">Rule #3 determined the value at (4,1) could not be 4 as this value already exists in the same column at (8,1)
Rule #3 determined the value at (5,5) could not be 2 as this value already exists in the same row at (5,6)
Rule #7 determined (3,5) is 2 as this is the only possible cell in the column that can have this value
Rule #1 cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of 2 exists for this cell.
Rule #1 cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of 2 exists for this cell.
... 
Rule #3 determined the value at (1,1) could not be 1 as this value already  exists in the same zone at (2,1)
Rule #6 determined (1,7) is 1 as this is the only possible cell in the row that can have this value
Rule #1 cleared the other PossibleCellValues for (1,7) as a ResolvedCellValue of 1 exists for this cell.
Rule #6 determined (1,1) is 8 as this is the only possible cell in the row that can have this value</pre><p>Once all of the activated rules for the solving logic have
      executed, the engine executes a second rule base to check that the
      solution is complete and valid. In this case it is, and the "Solve"
      button is disabled and displays a text like
      <code class="code">"Solved (1052ms)"</code>.</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku2.png"/></div></div><p>The example comes with a number of grids which can be loaded and
      solved. Click on "File", then "Samples" and "Medium" to load a more
      challenging grid. Note that the solve button is enabled when the new
      grid is loaded.
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku3.png"/></div></div><p>Click on the "Solve" button again to solve this new grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku4.png"/></div></div><p>Now, let us load a Sudoku grid that is deliberately invalid. Click
      on "File", "Samples" and "!DELIBERATELY BROKEN!". Note that this grid
      starts with some issues, for example the value 5 appears twice in the
      first row.</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku5.png"/></div></div><p>Nevertheless, click on the "Solve" button to apply the solving
      rules to this invalid grid. Note that the "Solve" button is relabelled
      to indicate that the resulting solution is invalid. </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku6.png"/></div></div><p>In addition, the validation rule set outputs all of the issues
      which are discovered to the console. </p><pre class="programlisting">
There are two cells on the same column with the same value at (6,0) and (4,0)
There are two cells on the same column with the same value at (4,0) and (6,0)
There are two cells on the same row with the same value at (2,4) and (2,2)
There are two cells on the same row with the same value at (2,2) and (2,4)
There are two cells on the same row with the same value at (6,3) and (6,8)
There are two cells on the same row with the same value at (6,8) and (6,3)
There are two cells on the same column with the same value at (7,4) and (0,4)
There are two cells on the same column with the same value at (0,4) and (7,4)
There are two cells on the same row with the same value at (0,8) and (0,0)
There are two cells on the same row with the same value at (0,0) and (0,8)
There are two cells on the same column with the same value at (1,2) and (3,2)
There are two cells on the same column with the same value at (3,2) and (1,2)
There are two cells in the same zone with the same value at (6,3) and (7,3)
There are two cells in the same zone with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (6,3) and (7,3)</pre><p>We will look at the solving rule set later in this section, but
      for the moment we should note that some theoretically solvable solutions
      can not be solved by the engine as it stands. Click on
      "File", "Samples" and then "Hard 3" to load a sparsely populated grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku7.png"/></div></div><p>Now click on the "Solve" button and note that the current rules
      are unable to complete the grid, even though (if you are a Sudoku
      aficionado) you may be able to see a way forward with the solution.
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku8.png"/></div></div><p>At the present time, the solving functionality has been achieved
      by the use of ten rules. This rule set could be extended to enable the
      engine to tackle more complex logic for filling grids such as
      this.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9026"/>8.9.3. Java Source and Rules Overview</h3></div></div></div><p>The Java source code can be found in the
      /src/main/java/org/drools/examples/sudoku directory, with the two DRL
      files defining the rules located in the
      /src/main/rules/org/drools/examples/sudoku directory.</p><p>The package <code class="code">org.drools.examples.sudoku.swing</code>
      contains a set of classes which implement a framework for Sudoku
      puzzles. Note that this package does not have any dependencies on
      the Drools libraries. <code class="code">SudokuGridModel</code>
      defines an interface which can be implemented to store a Sudoku puzzle
      as a 9x9 grid of <code class="code">Integer</code> values, some of which may be null,
      indicating that the value for the cell has not yet been resolved.
      <code class="code">SudokuGridView</code> is
      a Swing component which can visualize any implementation of
      <code class="code">SudokuGridModel</code>. <code class="code">SudokuGridEvent</code> and
      <code class="code">SudokuGridListener</code> are used to
      communicate state changes between the model and the view: events are
      fired when a cell's value is resolved or changed. If you are familiar
      with the model-view-controller patterns in other Swing components such
      as <code class="code">JTable</code> then this pattern should be familiar.
      <code class="code">SudokuGridSamples</code> provides a number of partially filled
      Sudoku puzzles for demonstration purposes.</p><p>Package <code class="code">org.drools.examples.sudoku.rules</code> contains an
      implementation of <code class="code">SudokuGridModel</code> which is based on Drools.
      Two Java objects are used, both of which extend
      <code class="code">AbstractCellValue</code> and represent a value for a specific cell
      in the grid, including the row and column location of the cell, an index
      of the 3x3 zone the cell is contained in, and the value of the cell.
      <code class="code">PossibleCellValue</code> indicates that we do not currently know
      for sure what the value in a cell is. There can be from 2 to 9 possible
      cell values for a given cell. <code class="code">ResolvedCellValue</code> indicates 
      that we have determined what the value
      for a cell must be. There can only be one resolved cell value for a
      given cell. <code class="code">DroolsSudokuGridModel</code> implements
      <code class="code">SudokuGridModel</code> and is responsible for converting an
      initial two dimensional array of partially specified cells into a set
      of <code class="code">CellValue</code> Java object, creating a Working Memory
      based on <code class="filename">solverSudoku.drl</code> and inserting the
      <code class="code">CellValue</code> objects into the Working Memory. When the 
      <code class="code">solve()</code> method is called it calls in turn
      <code class="code">fireAllRules()</code> on this Working Memory to try to solve
      the puzzle. <code class="code">DroolsSudokuGridModel</code> attaches a 
      <code class="code">WorkingMemoryListener</code> to the Working Memory, which
      allows it to be called back on insert and retract events as the
      puzzle is solved. When a new <code class="code">ResolvedCellValue</code> is inserted
      into the Working Memory, this callback allows the implementation to
      fire a <code class="code">SudokuGridEvent</code> to its
      <code class="code">SudokuGridListener</code> clientele, which can then update
      themselves in realtime. Once all the rules fired by the solver Working
      Memory have executed, <code class="code">DroolsSudokuGridModel</code> runs a
      second set of rules, based on <code class="filename">validatorSudoku.drl</code>
      which works with the same set of Java objects to determine whether the
      resulting grid is a valid and a full solution.</p><p>The class <code class="code">org.drools.examples.sudoku.Main</code> implements
      a Java application combining the components desribed.</p><p>The packae <code class="code">org.drools.examples.sudoku</code> contains two
      DRL files. <code class="filename">solverSudoku.drl</code> defines the rules
      which attempt to solve a Sudoku puzzle, and
      <code class="filename">validator.drl</code> defines the rules which determin
      whether the current state of the Working Memory represents a valid
      solution. Both use <code class="code">PossibleCellValue</code> and
      <code class="code">ResolvedCellValue</code> objects as their facts and
      both output information to the Console window as their rules fire. In a
      real-world situation we would insert logging information and use the
      <code class="code">WorkingMemoryListener</code> to display this information to a
      user, rather than use the console in this fashion.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9144"/>8.9.4. Sudoku Validator Rules (validatorSudoku.drl)</h3></div></div></div><p>We start with the validator rules as this rule set is shorter and
      simpler than the solver rule set.</p><p>The first rule simply checks that no <code class="code">PossibleCellValue</code>
      objects remain in the Working Memory. Once the puzzle is solved, only
      <code class="code">ResolvedCellValue</code> objects should be present, one for
      each cell.</p><p>The other three rules each match all of the
      <code class="code">ResolvedCellValue</code> objects and bind them to the
      variable <code class="code">$resolved1</code>. They then look for
      <code class="code">ResolvedCellValues</code> that
      contain the same value and are located, respectively, in the same row,
      column, or 3x3 zone. If these rules are fired they add a message to a
      global list of strings describing the reason the solution is invalid.
      <code class="code">DroolsSudokoGridModel</code> injects this list before it runs
      the rule set and checks whether it is empty or not after having called
      <code class="code">fireAllRules()</code>. If it is not empty then it prints all the
      strings in the list and sets a flag to indicate that the grid is not
      solved.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9174"/>8.9.5. Sudoku Solving Rules (solverSudoku.drl)</h3></div></div></div><p>Now let us look at the more complex rule set used to solve Sudoku
      puzzles.</p><p>Rule #1 is basically a book-keeping rule. Several of the other
      rules insert <code class="code">ResolvedCellValues</code> into the working memory
      at specific rows and columns after they have determined that a given
      cell must have a
      certain value. At this point, it is important to clear the Working
      Memory of any inserted <code class="code">PossibleCellValues</code> at the same
      row and column
      with invalid values. This rule is therefore given a higher salience than
      the remaining rules to ensure that as soon as the LHS is true,
      activations for the rule move to the top of the Agenda and are fired. In
      turn, this prevents the spurious firing of other rules due to the
      combination of a <code class="code">ResolvedCellValue</code> and one or more
      <code class="code">PossibleCellValues</code> being present in the same cell.
      This rule also calls <code class="code">update()</code> on the
      <code class="code">ResolvedCellValue</code>, even though its value has not in
      fact been modified to ensure that Drools fires an event to any
      <code class="code">WorkingMemoryListeners</code>  attached to the Working Memory
      so that they can update themselves - in
      this case so that the GUI can display the new state of the grid.</p><p>Rule #2 identifies cells in the grid which have only one possible
      value. The first line of the <strong class="kw"><code>when</code></strong> clause matches all of the
      <code class="code">PossibleCellValue</code> objects in the Working Memory. The
      second line demonstrates a use of the <strong class="kw"><code>not</code></strong> keyword. This rule
      will only fire if no other <code class="code">PossibleCellValue</code> objects
      exist in the Working Memory at the same
      row and column but with a different value. When the rule fires, the
      single <code class="code">PossibleCellValue</code> at the row and column is
      retracted from the Working Memory and is replaced by a new
      <code class="code">ResolvedCellValue</code> at the same
      row and column with the same value.</p><p>Rule #3 removes <code class="code">PossibleCellValues</code> with a given
      value from a row when they have the same value as a
      <code class="code">ResolvedCellValue</code>. In other words, when a cell is filled
      with a resolved value, we need to remove the
      possibility of any other cell on the same row having this value. The
      first line of the when clause matches all <code class="code">ResolvedCellValue</code>
      objects in the Working Memory. The second line matches
      <code class="code">PossibleCellValues</code> which have both the same row and the
      same value as these <code class="code">ResolvedCellValue</code>
      objects. If any are found, the rule activates and, when fired retracts
      the <code class="code">PossibleCellValue</code> which can no longer be a solution
      for that cell.</p><p>Rules #4 and #5 act in the same way as Rule #3 but check for
      redundant <code class="code">PossibleCellValues</code> in a given column and a 
      given zone of the grid as a <code class="code">ResolvedCellValue</code>
      respectively.</p><p>Rule #6 checks for the scenario where a possible cell value only
      appears once in a given row. The first line of the LHS matches against
      all <code class="code">PossibleCellValue</code> facts in the Working Memory, storing
      the result in a number of local variables. The second line checks that
      no other <code class="code">PossibleCellValue</code> objects with the same value
      exist on this row. The third to fifth lines check that there is not
      a <code class="code">ResolvedCellValue</code> with the same value in the same zone,
      row or column so that this rule does not fire prematurely.
      It is interesting to note that we could remove lines 3 to 5 and give
      rules #3, #4 and #5 a higher salience to make sure they always fire
      before rules #6,#7 and #8. When the rule fires, we know that
      <code class="code">$possible</code> must represent the value for the cell;
      so, as in Rule #2, we retract <code class="code">$possible</code> and replace it
      with the equivalent, new <code class="code">ResolvedCellValue</code>.</p><p>Rules #7 and #8 act in the same way as Rule #2 but check for
      single <code class="code">PossibleCellValues</code> in a given column and a given
      zone of the grid, respectively.</p><p>Rule #9 represents the most complex currently implemented rule.
      This rule implements the logic that, if we know that a pair of given
      values can only occur in two cells on a specific row, (for example we
      have determined the values of 4 and 6 can only appear in the first row
      in cells [0,3] and [0,5]) and this pair of cells can not hold other 
      values, then, although we do not know which of the pair contains a 
      four and which contains a six, we do know that these two values must be
      in these two cells, and hence we can remove the possibility of them
      occuring anywhere else in the same row.</p><p>Rules #10 and #11 act in the same way as rule #9 but check for the
      existance of only two possible values in a given column and zone,
      respectively.</p><p>To solve harder grids, the rule set would need to be extended
      further with more complex rules that encapsulate more complex
      reasoning.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9282"/>8.9.6. Suggestions for Future Developments</h3></div></div></div><p>There are a number of ways in which this example could be
      developed. The reader is encouraged to consider these as
      excercises.</p><div class="itemizedlist"><ul><li><p>Agenda groups are a great declarative tool for
          phased execution. In this example, it is easy to see we have two
          phases: "resolution" and "validation". Right now, they are executed
          by creating two separate rule bases, each for one "job".
          Presumably it would be better to define agenda groups for all the
          rules, spliting them in "resolution" rules and "validation" rules,
          all loaded in a single rule base. The engine executes resolution and
          right after that, executes validation.</p></li><li><p>Auto-focus is a great way of handling exceptions
          to the regular rules execution. In our case, if we detect an
          inconsistency, either in the input data or in the resolution rules,
          why should we spend time continuing the execution if it will be
          invalid anyway? It is better to simply (and immediately)
          report the inconsistency as soon as it is found. To do that, since
          we now have a single rulebase with all rules, we simply need to
          define the auto-focus attribute for all rules validating puzzle
          consistency.</p></li><li><p>Logical insert: an inconsistency only exists while wrong data
          is in the working memory. As so, we could state that the
          validation rules logically insert inconsistencies and as soon as the
          offending data is retracted, the inconsistency no longer
          exists.</p></li><li><p><code class="code">session.iterateObjects()</code>: although a valid
          use case having a global list to add the found problems, I think
          it would be more
          interesting to ask the Stateful Session by the desired list of
          problems, using <code class="code">session.iterateObjects( new ClassObjectFilter(
          Inconsistency.class ) ).</code> Having the inconsistency class
          can also allow us to paint in red the offending cells in the
          GUI.</p></li><li><p><code class="code">kcontext.getKnowledgeRuntime().halt()</code>: even
          reporting the error as soon as it is found, we need a way to tell
          the engine to stop   evaluating rules. We
          can do that creating a rule that, in the presence of inconsistencies,
          calls <code class="code">halt()</code> to stop evaluation.</p></li><li><p>Queries: looking at the method
          <code class="code">getPossibleCellValues(int row, int col)</code> in
          <code class="code">DroolsSudokuGridModel</code>, we see it iterating over all
          <code class="code">CellValue</code> objects, looking for the few it wants. That
          is a great opportunity to demonstrate Drools queries. We just
          define a query to
          return the objects we want and iterate over it, cleanly and nicely.
          Other queries may be defined as needed.</p></li><li><p>Globals as services: the main objective of this change is to
          attend the next proposed change , but it is nice by its own.
          In order to teach the use of globals as services, it
          would be nice to set up a callback, so that each rule that finds the
          <code class="code">ResolvedCellValue</code> for a given cell can call, to
          notify and update the corresponding cell in the GUI, providing
          immediate feedback for
          the user. Also, the last found cell could have its number painted in
          a different color to facilitate the identification of the rules'
          conclusions.</p></li><li><p>Step by step execution: now that we have immediate user
          feedback, we can make use of the restricted run feature in Drools,
          i.e., we could add a button in the GUI, that, when activated,
          causes the execution of a single rule, by calling
          <code class="code">fireAllRules( 1 )</code>. This way, the user would see,
          step by step, what the engine is doing.</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9337"/>8.10. Number Guess</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Number Guess 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.NumberGuessExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> NumberGuess.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Rule Flow to organise Rules
</pre><p>The "Number Guess" example shows the use of Rule Flow, a way of
  controlling the order in which rules are fired. It uses widely
  understood workflow diagrams for defining the order in which groups
  of rules will be executed.</p><div class="example"><a id="d0e9358"/><p class="title"><b>Example 8.69. Creating the Number Guess RuleBase: NumberGuessExample.main() - part 1</b></p><div class="example-contents"><pre class="programlisting">final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.drl",
                                                    ShoppingExample.class ),
              ResourceType.DRL );
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.rf",
                                                    ShoppingExample.class ),
              ResourceType.DRF );

final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );</pre></div></div><br class="example-break"/><p>The creation of the package and the loading of the rules (using
  the <code class="code">add()</code> method) is the same as the previous examples.
  There is an additional line to add the Rule Flow
  (<code class="filename">NumberGuess.rf</code>), which provides the option of
  specifying different rule flows for the same Knowledge Base.
  Otherwise, the Knowledge Base is created in the same manner as before.</p><div class="example"><a id="d0e9371"/><p class="title"><b>Example 8.70. Starting the RuleFlow: NumberGuessExample.main() - part 2</b></p><div class="example-contents"><pre class="programlisting">final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "log/numberguess");

ksession.insert( new GameRules( 100, 5 ) );
ksession.insert( new RandomNumber() );
ksession.insert( new Game() );

ksession.startProcess( "Number Guess" );
ksession.fireAllRules();

logger.close();

ksession.dispose();</pre></div></div><br class="example-break"/><p>Once we have a Knowledge Base, we can use it to obtain a Stateful
  Session. Into our session we insert our facts, i.e., standard Java objects.
  (For simplicity, in this sample, these classes are all contained within
  our <code class="filename">NumberGuessExample.java</code> file. Class
  <code class="code">GameRules</code> provides the maximum range and the number of guesses
  allowed. Class <code class="code">RandomNumber</code> automatically generates a number
  between 0 and 100 and makes it available to our rules, by insertion via
  the <code class="code">getValue()</code> method. Class <code class="code">Game</code> keeps track
  of the guesses we have made before, and their number.</p><p>Note that before we call the standard <code class="code">fireAllRules()</code>
  method, we also start the process that we loaded earlier, via the
  <code class="code">startProcess()</code> method. We'll learn where to obtain the
  parameter we pass ("Number Guess", i.e., the identifier of the rule flow)
  when we talk about the rule flow file and the graphical Rule Flow Editor
  below.</p><p>Before we finish the discussion of our Java code, we note that in
  some real-life application we would examine the final state of the objects.
  (Here, we could retrieve the number of guesses, to add it to a high score
  table.) For this example we are content to ensure that the Working Memory
  session is cleared by calling the <code class="code">dispose()</code> method.</p><div class="figure"><a id="d0e9406"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/NumberGuessExample/numberguess-ruleflow.png" width="100%" alt="RuleFlow for the NumberGuess Example"/></td></tr></table></div></div><p class="title"><b>Figure 8.18. RuleFlow for the NumberGuess Example</b></p></div><br class="figure-break"/><p>If you open the <code class="filename">NumberGuess.rf</code> file in the
  Drools IDE (provided you have the JBoss Rules extensions installed
  correctly in Eclipse) you should see the above diagram, similar to a
  standard flowchart. Its icons are similar (but not exactly the same)
  as in the JBoss jBPM workflow product. Should you wish to edit the
  diagram, a menu of available components should be available to the
  left of the diagram in the IDE, which is called the
  <span class="emphasis"><em>palette</em></span>. This diagram is saved in XML, an
  (almost) human readable format, using XStream.</p><p>If it is not already open, ensure that the Properties View is
  visible in the IDE. It can be opened by clicking "Window", then
  "Show View" and "Other", where you can select the "Properties" view.
  If you do this <span class="emphasis"><em>before</em></span> you select any item on
  the rule flow (or click on the blank space in the rule flow) you
  should be presented with the following set of properties.</p><div class="figure"><a id="d0e9425"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/NumberGuessExample/numberguess-ruleflow-properties.png" width="100%" alt="Properties for the Number Guess Rule Flow"/></td></tr></table></div></div><p class="title"><b>Figure 8.19. Properties for the Number Guess Rule Flow</b></p></div><br class="figure-break"/><p>Keep an eye on the Properties View as we progress through the
  example's rule flow, as it presents valuable information. In this case, it
  provides us with the identification of the Rule Flow Process that
  we used in our earlier code snippet, when we called
  <code class="code">session.startProcess()</code>.</p><p>In the "Number Guess" Rule Flow we encounter several node
  types, many of them identified by an icon.</p><p>
    </p><div class="itemizedlist"><ul><li><p>The Start node (white arrow in a green circle) and the End
        node (red box) mark beginning and end of the rule flow.</p></li><li><p>A Rule Flow Group box (yellow, without an icon) represents
        a Rule Flow Groups defined in our rules (DRL) file that we will
        look at later. For example, when the flow reaches the Rule Flow Group
        "Too High", only those rules marked with an attribute of
        <strong class="kw"><code>ruleflow-group</code></strong> <code class="code">"Too High"</code> can potentially fire.</p></li><li><p>Action nodes (yellow, cog-shaped icon) perform standard Java
        method calls. Most action nodes in this example call
        <code class="code">System.out.println()</code>, indicating the program's progress
        to the user.</p></li><li><p>Split and Join Nodes (blue ovals, no icon) such as "Guess Correct?"
        and "More guesses Join" mark places where the flow of control can
        split, according to various conditions, and rejoin, respectively</p></li><li><p>Arrows indicate the flow between the various nodes.</p></li></ul></div><p>
  </p><p>The various nodes in combination with the rules make the
  Number Guess game work. For example, the "Guess" Rule Flow Group
  allows only the rule "Get user Guess" to fire, because only that rule
  has a matching attribute of <strong class="kw"><code>ruleflow-group</code></strong> <code class="code">"Guess"</code>.</p><div class="example"><a id="d0e9474"/><p class="title"><b>Example 8.71. A Rule firing only at a specific point in the Rule Flow:
    NumberGuess.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Get user Guess"
    ruleflow-group "Guess"
    no-loop
    when
        $r : RandomNumber()
        rules : GameRules( allowed : allowedGuesses )
        game : Game( guessCount &lt; allowed )
        not ( Guess() )
    then
        System.out.println( "You have " + ( rules.allowedGuesses - game.guessCount )
                            + " out of " + rules.allowedGuesses
                            + " guesses left.\nPlease enter your guess from 0 to "
                            + rules.maxRange );
        br = new BufferedReader( new InputStreamReader( System.in ) );
        i = br.readLine();        
        modify ( game ) { guessCount = game.guessCount + 1 }
        insert( new Guess( i ) );
end</pre></div></div><br class="example-break"/><p>The rest of this rule is fairly standard. The LHS section
      (after <strong class="kw"><code>when</code></strong>) of the rule states that it will be activated
      for each <code class="code">RandomNumber</code> object inserted into the Working
      Memory where <code class="code">guessCount</code> is less than
      <code class="code">allowedGuesses</code> from the <code class="code">GameRules</code> object
      and where the user has not guessed the correct number.</p><p>The RHS section (or consequence, after <strong class="kw"><code>then</code></strong>) prints a
      message to the user and then awaits user input from
      <code class="code">System.in</code>. After obtaining this input (the
      <code class="code">readLine()</code> method call blocks until the return key is
      pressed) it modifies the guess count and inserts the new
      guess, making both available to the Working Memory.</p><p>The rest of the rules file is fairly standard: the package
      declares the dialect as MVEL, and various Java classes are imported.
      In total, there are five rules in this file:</p><div class="orderedlist"><ol type="1"><li><p>Get User Guess, the Rule we examined above.</p></li><li><p>A Rule to record the highest guess.</p></li><li><p>A Rule to record the lowest guess.</p></li><li><p>A Rule to inspect the guess and retract it from memory if
            incorrect.</p></li><li><p>A Rule that notifies the user that all guesses have been
            used up.</p></li></ol></div><p>One point of integration between the standard Rules and
      the RuleFlow is via the <strong class="kw"><code>ruleflow-group</code></strong> attribute on the
      rules, as dicussed above. A
      <span class="emphasis"><em>second point of integration between the rules (.drl) file
      and the Rules Flow .rf files</em></span> is
      that the Split Nodes (the blue ovals) can use values in the Working Memory
      (as updated by the rules) to decide which flow of action to take. To see
      how this works, click on the "Guess Correct Node"; then within the
      Properties View, open the Constraints Editor by clicking the button at
      the right that appears once you click on the "Constraints" property line.
      You should see something similar to the diagram below.</p><div class="figure"><a id="d0e9533"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/NumberGuessExample/numberguess-editconstraints.png" alt="Edit Constraints for the &#34;Guess Correct&#34; Node"/></div></div><p class="title"><b>Figure 8.20. Edit Constraints for the "Guess Correct" Node</b></p></div><br class="figure-break"/><p>Click on the "Edit" button beside "To node Too High" and you'll
      see a dialog  like the one below. The values in the "Textual Editor"
      window follow the standard rule format for the LHS and can refer to
      objects in Working Memory.
      The consequence (RHS) is that the flow of control follows this node
      (i.e., "To node Too High") if the LHS expression evaluates to true.</p><div class="figure"><a id="d0e9541"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/NumberGuessExample/numberguess-constraint-toohigh.png" alt="Constraint Editor for the &#34;Guess Correct&#34; Node: value too high"/></div></div><p class="title"><b>Figure 8.21. Constraint Editor for the "Guess Correct" Node: value too high</b></p></div><br class="figure-break"/><p>Since the file <code class="filename">NumberGuess.java</code> contains a
      <code class="code">main()</code> method, it
      can be run as a standard Java application, either from the command line
      or via the IDE. A typical game might result in the interaction below.
      The numbers in bold are typed in by the user.</p><div class="example"><a id="d0e9555"/><p class="title"><b>Example 8.72. Example Console output where the Number Guess Example beat the
        human!</b></p><div class="example-contents"><pre class="programlisting">You have 5 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>50</strong></span>
Your guess was too high
You have 4 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>25</strong></span>
Your guess was too low
You have 3 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>37</strong></span>
Your guess was too low
You have 2 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>44</strong></span>
Your guess was too low
You have 1 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>47</strong></span>
Your guess was too low
You have no more guesses
The correct guess was 48 

</pre></div></div><br class="example-break"/><p>A summary of what is happening in this sample is:</p><div class="orderedlist"><ol type="1"><li><p>The <code class="code">main()</code> method of
            <code class="filename">NumberGuessExample.java</code> loads a Rule Base,
            creates a Stateful Session and inserts <code class="code">Game</code>,
            <code class="code">GameRules</code> and <code class="code">RandomNumber</code>
            (containing the target number) objects into it. The
            method also sets the process flow we are going to use, and fires all
            rules. Control passes to the Rule Flow.</p></li><li><p>File <code class="filename">NumberGuess.rf</code>, the Rule Flow,
            begins at the "Start" node.</p></li><li><p>Control passes (via the "More guesses" join node) to the
            Guess node.</p></li><li><p>At the Guess node, the appropriate Rule Flow Group
            ("Get user Guess") is enabled. In this case the Rule "Guess" (in the
            <code class="filename">NumberGuess.drl</code> file) is triggered. This rule 
            displays a message to the user, takes the response, and puts it into
            Working Memory. Flow passes to the next Rule Flow Node.</p></li><li><p>At the next node, "Guess Correct", constraints inspect the
            current session and decide which path to take.</p><p>If the guess in step 4 was too high or too low, flow proceeds
            along a path which has an action node with normal Java code
            printing a suitable message and a Rule Flow Group causing a
            highest guess or lowest guess rule to be triggered. Flow passes
            from these nodes to step 6.</p><p>If the guess in step 4 was right, we proceed along the path
            towards the end of the Rule Flow. Before we get there, an action
            node with normal Java code prints a statement "you guessed
            correctly". There is a join node here (just before the Rule Flow
            end) so that our no-more-guesses path (step 7) can also terminate
            the Rule Flow.</p></li><li><p>Control passes as per the Rule Flow via a join node, a guess
            incorrect Rule Flow Group (triggering a rule to retract a guess from
            Working Memory) onto the "More guesses" decision node.</p></li><li><p>The "More guesses" decision node (on the right hand side of the
            rule flow) uses constraints, again looking at values that the rules
            have put into the working memory, to decide if we have more
            guesses and if so, goto step 3. If not, we proceed to the end of
            the rule flow, via a Rule Flow Group that triggers a rule stating
            "you have no more guesses".</p></li><li><p>The loop over steps 3 to 7 continues until the number is guessed
            correctly, or we run out of guesses.</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9627"/>8.11. Miss Manners and Benchmarking</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Miss Manners
<span class="bold"><strong>Main class:</strong></span> org.drools.benchmark.manners.MannersBenchmark
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> manners.drl
<span class="bold"><strong>Objective:</strong></span> Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth.</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9646"/>8.11.1. Introduction</h3></div></div></div><p>Miss Manners is throwing a party and, being a good host, she wants
      to arrange good seating. Her initial design arranges everyone in 
      male-female pairs, but then she worries about people have things to talk
      about. What is a good host to do? She decides to note the hobby of
      each guest so she can then arrange guests not only pairing them according
      to alternating sex but also ensuring that a guest has someone with a
      common hobby, at least on one side.</p><div class="figure"><a id="d0e9651"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-Examples/MannersExample/guests_at_table.png" align="middle" width="100%" alt="Miss Manners' Guests"/></td></tr></table></div></div><p class="title"><b>Figure 8.22. Miss Manners' Guests</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9657"/>8.11.1.1. BenchMarking</h4></div></div></div><p>Five benchmarks were established in the 1991 paper "Effects of
        Database Size on Rule System Performance: Five Case Studies" by 
        David Brant, Timothy Grose, Bernie Lofaso and Daniel P. Miranker:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Manners</strong></span> uses a 
            depth-first search approach to determine the
            seating arrangements alternating women and men and ensuring
            one common hobby for neighbors.</p></li><li><p><span class="bold"><strong>Waltz</strong></span> establishes
            a three-dimensional interpretation of a line drawing by
            line labeling by constraint propagation.</p></li><li><p><span class="bold"><strong>WaltzDB</strong></span> is a more
            general version of Waltz, supporting junctions of more
            than three lines and using a database.</p></li><li><p><span class="bold"><strong>ARP</strong></span> is a 
            route planner for a robotic air vehicle using the A*
            search algorithm to achieve minimal cost.</p></li><li><p><span class="bold"><strong>Weaver</strong></span> 
            VLSI router for channels and boxes using a black-board
            technique.</p></li></ul></div><p>Manners has become the de facto rule engine benchmark.
        Its behavior, however, is now well known and many engines
        optimize for this, thus negating its usefulness as a benchmark 
        which is why Waltz is becoming more favorable. These five
        benchmarks are also published at the University of Texas <a class="ulink" href="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9693"/>8.11.1.2. Miss Manners Execution Flow</h4></div></div></div><p>After the first seating arrangement has been assigned, a
        depth-first recursion occurs which repeatedly assigns correct
        seating arrangements until the last seat is assigned. Manners
        uses a <code class="code">Context</code> instance to control execution flow.
        The activity diagram is partitioned to show the relation of the
        rule execution to the current <code class="code">Context</code> state.</p><div class="figure"><a id="d0e9704"/><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/Chapter-Examples/MannersExample/manners_activity_diagram.png" align="middle" width="100%" alt="Manners Activity Diagram"/></td></tr></table></div></div><p class="title"><b>Figure 8.23. Manners Activity Diagram</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9710"/>8.11.1.3. The Data and Results</h4></div></div></div><p>Before going deeper into the rules, let's first take a look
        at the asserted data and the resulting seating arrangement. The
        data is a simple set of five guests who should be arranged so
        that sexes alternate and neighbors have a common hobby.</p><p><span class="bold"><strong>The Data</strong></span></p><p>The data is given in OPS5 syntax, with a parenthesized
        list of name and value pairs for each attribute. Each
        person has only one hobby.</p><div class="literallayout"><p>(guest (name n1) (sex m) (hobby  h1)  )<br/>
(guest (name n2) (sex f) (hobby  h1)  )<br/>
(guest (name n2) (sex f) (hobby  h3)  )<br/>
(guest (name n3) (sex m) (hobby  h3)  )<br/>
(guest (name n4) (sex m) (hobby  h1)  )<br/>
(guest (name n4) (sex f) (hobby  h2)  )<br/>
(guest (name n4) (sex f) (hobby  h3)  )<br/>
(guest (name n5) (sex f) (hobby  h2)  )<br/>
(guest (name n5) (sex f) (hobby  h1)  )<br/>
(last_seat (seat 5)  )</p></div><p><span class="bold"><strong>The Results</strong></span></p><p>Each line of the results list is printed per execution of the
        "Assign Seat" rule. They key bit to notice is that each line has
        a "pid" value one greater than the last. (The significance of this
        will be explained in the discussion of the rule "Assign Seating".)
        The "ls", "rs", "ln" and "rn" refer to the left and right
        seat and neighbor's name, respectively. The actual implementation
        uses longer attribute names (e.g., <code class="code">leftGuestName</code>,
        but here we'll stick to the notation from the original
        implementation.</p><div class="literallayout"><p>[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] <br/>
[Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] <br/>
[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] <br/>
[Seating id=4, pid=3, done=false, ls=3, rn=n3, rs=4, rn=n2] <br/>
[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1]</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9732"/>8.11.2. Indepth Discussion</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9735"/>8.11.2.1. Cheating</h4></div></div></div><p>Manners has been designed to exercise cross product
        joins and Agenda activities. Many people not understanding this
        tweak the example to achieve better performance, making their
        port of the Manners benchmark pointless. Known cheats or
        porting errors for Miss Manners are:</p><div class="itemizedlist"><ul><li><p>Using arrays for a guests hobbies, instead of asserting each
            one as a single fact massively reduces the cross products.</p></li><li><p>Altering the sequence of data can also reduce the
            amount of matching, increasing execution speed.</p></li><li><p>It's possible to change the <strong class="kw"><code>not</code></strong> Conditional
            Element so that the test algorithm only uses the
            "first-best-match", which is, basically, transforming
            the test algorithm to backward chaining. The results are only
            comparable to other backward chaining rule engines or ports of
            Manners.</p></li><li><p>Removing the context so the rule engine matches the guests
            and seats prematurely. A proper port will prevent facts from
            matching using the context start.</p></li><li><p>It's possible to prevent the rule engine from performing
            combinatorial pattern matching.</p></li><li><p>If no facts are retracted in the reasoning cycle, as a
            result of the <strong class="kw"><code>not</code></strong> CE, the port is incorrect.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9765"/>8.11.2.2. Conflict Resolution</h4></div></div></div><p>The Manners benchmark was written for OPS5 which has two conflict
        resolution strategies, LEX and MEA. LEX is a chain of several
        strategies including salience, recency and complexity. The recency
        part of the strategy drives the depth first (LIFO) firing order.
        The CLIPS  manual documents the Recency strategy as follows:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Every fact and instance is marked internally with a "time tag"
          to indicate its relative recency with respect to every other fact
          and instance in the system. The pattern entities associated with
          each rule activation are sorted in descending order for determining
          placement. An activation with a more recent pattern entity is
          placed before activations with less recent pattern entities. To
          determine the placement order of two activations, compare the sorted
          time tags of the two activations one by one starting with the
          largest time tags. The comparison should continue until one
          activation’s time tag is greater than the other activation’s
          corresponding time tag. The activation with the greater time tag is
          placed before the other activation on the agenda. If one activation
          has more pattern entities than the other activation and the compared
          time tags are all identical, then the activation with more time tags
          is placed before the other activation on the agenda.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">CLIPS Reference Manual</span></td></tr></table></div><p>However Jess and CLIPS both use the Depth strategy, which is
        simpler and lighter, which Drools also adopted. The CLIPS manual
        documents the Depth strategy as:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Newly activated rules are placed above all rules of the same
          salience. For example, given that fact-a activates rule-1 and rule-2
          and fact-b activates rule-3 and rule-4, then if fact-a is asserted
          before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on
          the agenda. However, the position of rule-1 relative to rule-2 and
          rule-3 relative to rule-4 will be arbitrary.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">CLIPS Reference Manual</span></td></tr></table></div><p>The initial Drools implementation for the Depth strategy would
        not work for Manners without the use of salience on the "make_path"
        rule. The CLIPS support team had this to say:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>The default conflict resolution strategy for CLIPS, Depth, is
          different than the default conflict resolution strategy used by
          OPS5. Therefore if you directly translate an OPS5 program to CLIPS,
          but use the default depth conflict resolution strategy, you're only
          likely to get the correct behavior by coincidence. The LEX and MEA
          conflict resolution strategies are provided in CLIPS to allow you to
          quickly convert and correctly run an OPS5 program in CLIPS.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Support Forum</span></td></tr></table></div><p>Investigation into the CLIPS code reveals there is undocumented
        functionality in the Depth strategy. There is an accumulated time tag
        used in this strategy; it's not an extensively fact by fact comparison
        as in the recency strategy, it simply adds the total of all the time
        tags for each activation and compares.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9791"/>8.11.2.3. Rule "assignFirstSeat"</h4></div></div></div><p>Once the context is changed to <code class="code">START_UP</code>,
        activations are created for all asserted guest. Because all
        activations are created as the result of a single Working Memory
        action, they all have the same Activation time tag. The last
        asserted <code class="code">Guest</code> object would have a higher fact
        time tag, and its Activation would fire because it has the highest
        accumulated fact time tag. The execution order in this rule has little
        importance, but has a big impact in the rule "Assign Seat". The
        activation fires and asserts the first <code class="code">Seating</code>
        arrangement and a <code class="code">Path</code>, and then sets the
        <code class="code">Context</code> attribute <code class="code">state</code> to create 
        an activation for rule <code class="code">findSeating</code>.</p><pre class="programlisting">rule assignFirstSeat
    when
        context : Context( state == Context.START_UP )
        guest : Guest()
        count : Count()
    then
        String guestName = guest.getName();
        
        Seating seating =
          new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName);
        insert( seating );
        
        Path path = new Path( count.getValue(), 1, guestName );
        insert( path );
        
        modify( count ) { setValue ( count.getValue() + 1 )  }

    System.out.println( "assign first seat :  " + seating + " : " + path );

        modify( context ) {
            setState( Context.ASSIGN_SEATS )
        } 
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9819"/>8.11.2.4. Rule "findSeating"</h4></div></div></div><p>This rule determines each of the <code class="code">Seating</code>
        arrangements. The rule creates cross product solutions for
        <span class="emphasis"><em>all</em></span> asserted <code class="code">Seating</code> arrangements
        against <span class="emphasis"><em>all</em></span> the asserted guests except 
        against itself or any already assigned chosen solutions.</p><pre class="programlisting">rule findSeating
   when 
       context : Context( state == Context.ASSIGN_SEATS )
       $s      : Seating( pathDone == true )
       $g1     : Guest( name == $s.rightGuestName )
       $g2     : Guest( sex != $g1.sex, hobby == $g1.hobby )

       count   : Count()

       not ( Path( id == $s.id, guestName == $g2.name) )
       not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) )
   then
       int rightSeat = $s.getRightSeat();
       int seatId = $s.getId();
       int countValue = count.getValue();
       
       Seating seating =
         new Seating( countValue, seatId, false, rightSeat,
                      $s.getRightGuestName(), rightSeat + 1, $g2.getName() );
       insert( seating );
                            
       Path path = new Path( countValue, rightSeat + 1, $g2.getName()  );
       insert( path );
       
       Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() );
       insert( chosen  );

       System.err.println( "find seating : " + seating + " : " + path +
                           " : " + chosen);

       modify( count ) {setValue(  countValue + 1 )}
       modify( context ) {setState( Context.MAKE_PATH )}
end</pre><p>However, as can be seen from the printed results shown earlier,
        it is essential that only the <code class="code">Seating</code> with the highest
        <code class="code">pid</code> cross product be chosen. How can this be possible
        if we have activations, of the same time tag, for nearly all
        existing <code class="code">Seating</code> and <code class="code">Guest</code> objects? For
        example, on the third iteration of <code class="code">findDeating</code> the
        produced activations will be as shown below. Remember, this is from
        a very small data set, and with larger data sets there would be many
        more possible activated <code class="code">Seating</code> solutions, with multiple
        solutions per <code class="code">pid</code>:</p><div class="literallayout"><p>=&gt;[ActivationCreated(35): rule=findSeating <br/>
[fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] <br/>
[fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] <br/>
[fid:3:3]:[Guest name=n2, sex=f, hobbies=h3]<br/>
<br/>
=&gt;[ActivationCreated(35): rule=findSeating <br/>
[fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] <br/>
[fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] <br/>
[fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] <br/>
<br/>
=&gt;[ActivationCreated(35): rule=findSeating <br/>
[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] <br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] <br/>
[fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]</p></div><p>The creation of all these redundant activations might seem
        pointless, but it must be remembered that Manners is not about good
        rule design; it's purposefully designed as a bad ruleset to fully
        stress-test the cross product matching process and the Agenda, which
        this clearly does. Notice that each activation has the same time tag
        of 35, as they were all activated by the change in the
        <code class="code">Context</code> object to <code class="code">ASSIGN_SEATS</code>. With OPS5
        and LEX it would correctly fire the activation with the
        <code class="code">Seating</code> asserted last. With Depth, the accumulated fact
        time tag ensures that the activation with the last asserted
        <code class="code">Seating</code> fires.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9877"/>8.11.2.5. Rules "makePath" and "pathDone"</h4></div></div></div><p>Rule <code class="code">makePath</code> must always fire before
        <code class="code">pathDone</code>. A <code class="code">Path</code> object is asserted for
        each <code class="code">Seating</code> arrangement, up to the last asserted 
        <code class="code">Seating</code>. Notice that the conditions in
        <code class="code">pathDone</code> are a subset of those in
        <code class="code">makePath</code> - so how do we ensure that <code class="code">makePath</code>
        fires first?</p><pre class="programlisting">rule makePath
    when 
        Context( state == Context.MAKE_PATH )
        Seating( seatingId:id, seatingPid:pid, pathDone == false )
        Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat )
        not Path( id == seatingId, guestName == pathGuestName )
    then
        insert( new Path( seatingId, pathSeat, pathGuestName ) );
end</pre><pre class="programlisting">rule pathDone
    when
        context : Context( state == Context.MAKE_PATH ) 
        seating : Seating( pathDone == false ) 
    then
        modify( seating ) {setPathDone( true )} 
        
    modify( context ) {setState( Context.CHECK_DONE)}
end</pre><div class="figure"><a id="d0e9910"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Examples/MannersExample/make_path.png" align="middle" alt="Rete Diagram"/></div></div><p class="title"><b>Figure 8.24. Rete Diagram</b></p></div><br class="figure-break"/><p>Both rules end up on the Agenda in conflict and with identical
        activation time tags. However, the accumulate fact time tag is greater
        for "Make Path" so it gets priority.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9918"/>8.11.2.6. Rules "continue" and "areWeDone"</h4></div></div></div><p>Rule <code class="code">areWeDone</code> only activates when the last seat
        is assigned, at which point both rules will be activated. For the
        same reason that <code class="code">makePath</code> always wins over
        <code class="code">path Done</code>, <code class="code">areWeDone</code> will take
        priority over rule <code class="code">continue</code>.</p><pre class="programlisting">rule areWeDone
    when
        context : Context( state == Context.CHECK_DONE ) 
        LastSeat( lastSeat: seat )
        Seating( rightSeat == lastSeat ) 
    then
        modify( context ) {setState(Context.PRINT_RESULTS )}
end
</pre><pre class="programlisting">rule continue
    when
        context : Context( state == Context.CHECK_DONE ) 
    then
        modify( context ) {setState( Context.ASSIGN_SEATS )}
end
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9942"/>8.11.3. Output Summary</h3></div></div></div><div class="literallayout"><p><span class="bold"><strong>Assign First seat</strong></span><br/>
=&gt;[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]<br/>
=&gt;[fid:14:14]:[Path id=1, seat=1, guest=n5]<br/>
<br/>
==&gt;[ActivationCreated(16): rule=findSeating<br/>
[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]<br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1]<br/>
[fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]<br/>
<br/>
==&gt;[ActivationCreated(16): rule=findSeating<br/>
[fid:13:13]:[Seating id=1 , pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]<br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1]<br/>
[fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]*<br/>
<br/>
<span class="bold"><strong>Assign Seating</strong></span><br/>
=&gt;[fid:15:17] :[Seating id=2 , pid=1 , done=false, ls=1, lg=n5, rs=2, rn=n4]<br/>
=&gt;[fid:16:18]:[Path id=2, seat=2, guest=n4]<br/>
=&gt;[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1]<br/>
<br/>
=&gt;[ActivationCreated(21): rule=makePath <br/>
[fid:15:17] : [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]<br/>
[fid:14:14] : [Path id=1, seat=1, guest=n5]*<br/>
<br/>
==&gt;[ActivationCreated(21): rule=pathDone<br/>
[Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]*<br/>
<br/>
<span class="bold"><strong>Make Path</strong></span><br/>
=&gt;[fid:18:22:[Path id=2, seat=1, guest=n5]]<br/>
<br/>
<span class="bold"><strong>Path Done</strong></span><br/>
<br/>
<span class="bold"><strong>Continue Process</strong></span><br/>
=&gt;[ActivationCreated(25): rule=findSeating<br/>
[fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4]<br/>
[fid:7:7]:[Guest name=n4, sex=f, hobbies=h3]<br/>
[fid:4:4] : [Guest name=n3, sex=m, hobbies=h3]*<br/>
<br/>
=&gt;[ActivationCreated(25): rule=findSeating<br/>
[fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4]<br/>
[fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]<br/>
[fid:2:2]:[Guest name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3]<br/>
<br/>
=&gt;[ActivationCreated(25): rule=findSeating<br/>
[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]<br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1]<br/>
[fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]<br/>
<br/>
<span class="bold"><strong>Assign Seating</strong></span><br/>
=&gt;[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]]<br/>
=&gt;[fid:20:27]:[Path id=3, seat=3, guest=n3]]<br/>
=&gt;[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}]<br/>
<br/>
=&gt;[ActivationCreated(30): rule=makePath<br/>
[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]<br/>
[fid:18:22]:[Path id=2, seat=1, guest=n5]*<br/>
<br/>
=&gt;[ActivationCreated(30): rule=makePath <br/>
[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]<br/>
[fid:16:18]:[Path id=2, seat=2, guest=n4]*<br/>
<br/>
=&gt;[ActivationCreated(30): rule=done <br/>
[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]*<br/>
<br/>
<span class="bold"><strong>Make Path</strong></span><br/>
=&gt;[fid:22:31]:[Path id=3, seat=1, guest=n5]<br/>
<br/>
<span class="bold"><strong>Make Path </strong></span><br/>
=&gt;[fid:23:32] [Path id=3, seat=2, guest=n4]<br/>
<br/>
<span class="bold"><strong>Path Done</strong></span><br/>
<br/>
<span class="bold"><strong>Continue Processing</strong></span><br/>
=&gt;[ActivationCreated(35): rule=findSeating<br/>
[fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3]<br/>
[fid:4:4]:[Guest name=n3, sex=m, hobbies=h3]<br/>
[fid:3:3]:[Guest name=n2, sex=f, hobbies=h3], [fid:12:29]*<br/>
<br/>
=&gt;[ActivationCreated(35): rule=findSeating <br/>
[fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] <br/>
[fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]<br/>
[fid:2:2]:[Guest name=n2, sex=f, hobbies=h1]<br/>
<br/>
=&gt;[ActivationCreated(35): rule=findSeating <br/>
[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] <br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1, sex=m, hobbies=h1]<br/>
<br/>
<span class="bold"><strong>Assign Seating</strong></span><br/>
=&gt;[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]]<br/>
=&gt;[fid:25:37]:[Path id=4, seat=4, guest=n2]]<br/>
=&gt;[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3]<br/>
<br/>
==&gt;[ActivationCreated(40): rule=makePath <br/>
[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]<br/>
[fid:23:32]:[Path id=3, seat=2, guest=n4]*<br/>
<br/>
==&gt;[ActivationCreated(40): rule=makePath <br/>
[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] <br/>
[fid:20:27]:[Path id=3, seat=3, guest=n3]*<br/>
<br/>
=&gt;[ActivationCreated(40): rule=makePath <br/>
[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]<br/>
[fid:22:31]:[Path id=3, seat=1, guest=n5]*<br/>
<br/>
=&gt;[ActivationCreated(40): rule=done <br/>
[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]*<br/>
<br/>
<span class="bold"><strong>Make Path </strong></span><br/>
=&gt;fid:27:41:[Path id=4, seat=2, guest=n4]<br/>
<br/>
<span class="bold"><strong>Make Path</strong></span><br/>
=&gt;fid:28:42]:[Path id=4, seat=1, guest=n5]]<br/>
<br/>
<span class="bold"><strong>Make Path</strong></span><br/>
=&gt;fid:29:43]:[Path id=4, seat=3, guest=n3]]<br/>
<br/>
<span class="bold"><strong>Path Done</strong></span><br/>
<br/>
<span class="bold"><strong>Continue  Processing</strong></span><br/>
=&gt;[ActivationCreated(46): rule=findSeating <br/>
[fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] <br/>
[fid:5:5]:[Guest name=n4, sex=m, hobbies=h1], [fid:2:2]<br/>
[Guest name=n2, sex=f, hobbies=h1]<br/>
<br/>
=&gt;[ActivationCreated(46): rule=findSeating <br/>
[fid:24:44]:[Seating id=4, pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2]<br/>
[fid:2:2]:[Guest name=n2, sex=f, hobbies=h1]<br/>
[fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]*<br/>
<br/>
=&gt;[ActivationCreated(46): rule=findSeating <br/>
[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]<br/>
[fid:9:9]:[Guest name=n5, sex=f, hobbies=h1]<br/>
[fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]<br/>
<br/>
<span class="bold"><strong>Assign Seating</strong></span><br/>
=&gt;[fid:30:47]:[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1]<br/>
=&gt;[fid:31:48]:[Path id=5, seat=5, guest=n1]<br/>
=&gt;[fid:32:49]:[Chosen id=4, name=n1, hobbies=h1]<br/>
</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9997"/>8.12. Conway's Game Of Life</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Conway's Game Of Life
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.conway.ConwayAgendaGroupRun
            org.drools.examples.conway.ConwayRuleFlowGroupRun
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> conway-ruleflow.drl conway-agendagroup.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates 'accumulate', 'collect' and 'from'</pre><p>Conway's Game Of Life, described in <a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a> and in
    <a class="ulink" href="http://www.math.com/students/wonders/life/life.html">http://www.math.com/students/wonders/life/life.html</a>,
    is a famous cellular automaton conceived in the early 1970's by the
    mathematician John Conway. While the system is well known as "Conway's
    Game Of Life", it really isn't a game at all. Conway's system is more like
    a simulation of a form of life. Don't be intimidated. The system
    is terribly simple and terribly interesting. Math and Computer Science
    students alike have marvelled over Conway's system for more than 30 years
    now. The application
    presented here is a Swing-based implementation of Conway's Game of Life.
    The rules that govern the system are implemented as business rules using
    Drools. This document will explain the rules that drive the simulation and
    discuss the Drools parts of the implementation.</p><p>We'll first introduce the grid view, shown below, designed for the
    visualisation of the game, showing the "arena" where the life simuation
    takes place. Initially the grid is empty, meaning that there are no live
    cells in the system. Each cell is either alive or dead, with live cells
    showing a green ball. Preselected patterns of live cells can be
    chosen from the "Pattern" drop-down list. Alternatively, individual
    cells can be doubled-clicked to toggle them between live and dead. It's
    important to understand that each cell is related to its neighboring cells,
    which is fundamental for the game's rules. Neighbors include not only
    cells to the left, right, top and bottom but also cells that are connected
    diagonally, so that each cell has a total of 8 neighbors. Exceptions
    are the four corner cells which have only three neighbors, and the cells
    along the four border, with five neighbors each.</p><div class="figure"><a id="d0e10026"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway1.png" width="100%" alt="Conway's Game of Life: Starting a new game"/></td></tr></table></div></div><p class="title"><b>Figure 8.25. Conway's Game of Life: Starting a new game</b></p></div><br class="figure-break"/><p>So what are the basic rules that govern this game? Its goal is to
    show the development of a population, generation by generation. Each
    generation results from the preceding one, based on the simultaneous
    evaluation of all cells. This is the simple set of rules that
    govern what the next generation will look like:</p><div class="itemizedlist"><ul><li><p>If a live cell has fewer than 2 live neighbors, it dies of
        loneliness.</p></li><li><p>If a live cell has more than 3 live neighbors, it dies from
        overcrowding.</p></li><li><p>If a dead cell has exactly 3 live neighbors, it comes to
        life.</p></li></ul></div><p>That is all there is to it. Any cell that doesn't meet any of those
    criteria is left as is for the next generation. With those simple rules in
    mind, go back and play with the system a little bit more and step through
    some generations, one at a time, and notice these rules taking their
    effect.</p><p>The screenshot below shows an example generation, with a number of
    live cells. Don't worry about matching the exact patterns represented in
    the screen shot. Just get some groups of cells added to the grid. Once you
    have groups of live cells in the grid, or select a pre-designed pattern,
    click the "Next Generation" button and notice what happens. Some of the
    live cells are killed (the green ball disappears) and some dead cells come
    to life (a green ball appears). Step through several generations and see
    if you notice any patterns. If you click on the "Start" button, the system
    will evolve itself so you don't need to click the "Next Generation" button
    over and over. Play with the system a little and then come back here for
    more details of how the application works.</p><div class="figure"><a id="d0e10048"/><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway2.png" width="100%" alt="Conway's Game of Life: A running game"/></td></tr></table></div></div><p class="title"><b>Figure 8.26. Conway's Game of Life: A running game</b></p></div><br class="figure-break"/><p>Now lets delve into the code. As this is an advanced example we'll
    assume that by now you know your way around the Drools framework and are
    able to connect the presented highlight, so that we'll just focus at a
    high level overview. The example has two ways to execute, one way 
    uses Agenda Groups to manage execution flow, and the other one uses
    Rule Flow Groups to manage execution flow. These two versions are
    implemented in <code class="code">ConwayAgendaGroupRun</code> and
    <code class="code">ConwayRuleFlowGroupRun</code>, respectively. Here,
    we'll discuss the Rule Flow version, as it's what most people will
    use.</p><p>All the <code class="code">Cell</code> objects are inserted into the Session
    and the rules in the <strong class="kw"><code>ruleflow-group</code></strong> "register neighbor" are
    allowed to execute by the Rule Flow process. This group of four rules
    creates <code class="code">Neighbor</code> relations between some cell and its
    northeastern, northern, northwestern and western neighbors. This
    relation is bidirectional, which takes care of the other four directions.
    Border cells don't need any special treatment - they simply won't be
    paired with neighboring cells where there isn't any. By
    the time all activations have fired for these rules, all cells are related
    to all their neighboring cells.</p><div class="example"><a id="d0e10073"/><p class="title"><b>Example 8.73. Conway's Game of Life: Register Cell Neighbour relations</b></p><div class="example-contents"><pre class="programlisting">rule "register north east"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )            
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )    
then                    
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );        
end

rule "register north"
    ruleflow-group "register neighbor"  
when
    $cell: Cell( $row : row, $col : col )   
    $north : Cell( row  == ($row - 1), col == $col )    
then        
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );        
end

rule "register north west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )           
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )                        
then        
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );        
end

rule "register west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )          
    $west : Cell( row  == $row, col == ( $col - 1 ) )                       
then        
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );         
end</pre></div></div><br class="example-break"/><p>Once all the cells are inserted, some Java code applies the pattern
    to the grid, setting certain cells to Live. Then, when the user clicks
    "Start" or "Next Generation", it executes the "Generation" ruleflow. This
    ruleflow is responsible for the management of all changes of cells in each
    generation cycle.</p><div class="figure"><a id="d0e10080"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway_ruleflow_generation.png" alt="Conway's Game of Life: rule flow &#34;Generation&#34;"/></div></div><p class="title"><b>Figure 8.27. Conway's Game of Life: rule flow "Generation"</b></p></div><br class="figure-break"/><p>The rule flow process first enters the "evaluate" group, which means
    that any active rule in the group can fire. The rules in this group apply
    the Game-of-Life rules discussed in the beginning of the example,
    determining the cells to be killed and the ones to be given life. We use
    the "phase" attribute to drive the reasoning of the Cell by specific
    groups of rules; typically the phase is tied to a Rule Flow Group in the
    Rule Flow process definition. Notice that it doesn't actually change the
    state of any <code class="code">Cell</code> objectss at this point; this is because 
    it's evaluating the grid in turn and it must complete the full evaluation
    until those changes can be applied. To achieve this, it sets the cell to
    a "phase" which is either <code class="code">Phase.KILL</code> or
    <code class="code">Phase.BIRTH</code>, used later to control actions applied
    to the <code class="code">Cell</code> object.</p><div class="example"><a id="d0e10100"/><p class="title"><b>Example 8.74. Conway's Game of Life: Evaluate Cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has fewer than 2 live neighbors
    theCell: Cell( liveNeighbors &lt; 2, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has more than 3 live neighbors
    theCell: Cell( liveNeighbors &gt; 3, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
when
#   A dead cell has 3 live neighbors
    theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        theCell.setPhase( Phase.BIRTH );
    }
end
</pre></div></div><br class="example-break"/><p>Once all <code class="code">Cell</code> objects in the grid have been evaluated,
    we first clear any calculation activations that occured from any previous
    data changes. This is done via the "reset calculate" rule, which clears
    any activations in the "calculate" group. We then enter a split in the
    rule flow which allows any activations in both the "kill" and the "birth"
    group to fire. These rules are responsible for applying the state
    change.</p><div class="example"><a id="d0e10110"/><p class="title"><b>Example 8.75. Conway's Game of Life: Apply the state changes</b></p><div class="example-contents"><pre class="programlisting">rule "reset calculate"
    ruleflow-group "reset calculate"
when
then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
when
    theCell: Cell( phase == Phase.KILL )
then
    modify( theCell ){
        setCellState( CellState.DEAD ),
        setPhase( Phase.DONE );   
    }
end 
 
rule "birth"
    ruleflow-group "birth"
    no-loop
when
    theCell: Cell( phase == Phase.BIRTH )
then
    modify( theCell ){
        setCellState( CellState.LIVE ),
        setPhase( Phase.DONE );
    }
end </pre></div></div><br class="example-break"/><p>At this stage, a number of <code class="code">Cell</code> objects have been
    modified with the state changed to either <code class="code">LIVE</code> or
    <code class="code">DEAD</code>. Now we get to see the power of the
    <code class="code">Neighbor</code> facts defining the cell relations. When a cell
    becomes live or dead, we use the <code class="code">Neighbor</code> relation to
    iterate over all surrounding cells, increasing or decreasing the
    <code class="code">liveNeighbor</code> count. Any cell that has its count changed
    is also set to to the <code class="code">EVALUATE</code> phase, to make sure
    it is included in the reasoning during the evaluation stage of the
    Rule Flow Process. Notice that we don't have to do any iteration
    ourselves; simply by applying the relations in the rules we make
    the rule engine do all the hard work for us, with a minimal amount of
    code. Once the live count has been determined and set for all cells,
    the Rule Flow Process comes to and end. If the user has initially
    clicked the "Start" button, the engine will restart the rule flow;
    otherwise the user may request another generation.</p><div class="example"><a id="d0e10138"/><p class="title"><b>Example 8.76. Conway's Game of Life: Evaluate cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.LIVE )
    Neighbor( cell == theCell, $neighbor : neighbor ) 
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ),
        setPhase( Phase.EVALUATE );   
    }
end 

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.DEAD )
    Neighbor( cell == theCell, $neighbor : neighbor )
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ),
        setPhase( Phase.EVALUATE );
    }
end </pre></div></div><br class="example-break"/></div></div></div></body></html>