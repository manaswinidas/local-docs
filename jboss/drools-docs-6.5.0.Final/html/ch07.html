<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. Running</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt03.html" title="Part III. Drools Runtime and Language"/><link rel="prev" href="ch06.html" title="Chapter 6. User Guide"/><link rel="next" href="ch08.html" title="Chapter 8. Rule Language Reference"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch06.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch08.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 7. Running"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6607"/>Chapter 7. Running</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch07.html#d0e6612">7.1. KieRuntime</a></span></dt><dd><dl><dt><span class="section"><a href="ch07.html#d0e6615">7.1.1. EntryPoint</a></span></dt><dt><span class="section"><a href="ch07.html#d0e6790">7.1.2. RuleRuntime</a></span></dt><dt><span class="section"><a href="ch07.html#d0e6849">7.1.3. StatefulRuleSession</a></span></dt></dl></dd><dt><span class="section"><a href="ch07.html#d0e6889">7.2. Agenda</a></span></dt><dd><dl><dt><span class="section"><a href="ch07.html#d0e6926">7.2.1. Conflict Resolution</a></span></dt><dt><span class="section"><a href="ch07.html#d0e6942">7.2.2. AgendaGroup</a></span></dt><dt><span class="section"><a href="ch07.html#d0e6974">7.2.3. ActivationGroup</a></span></dt><dt><span class="section"><a href="ch07.html#d0e6990">7.2.4. RuleFlowGroup</a></span></dt></dl></dd><dt><span class="section"><a href="ch07.html#d0e7006">7.3. Event Model</a></span></dt><dt><span class="section"><a href="ch07.html#d0e7084">7.4. StatelessKieSession</a></span></dt><dd><dl><dt><span class="section"><a href="ch07.html#d0e7214">7.4.1. Sequential Mode</a></span></dt></dl></dd><dt><span class="section"><a href="ch07.html#d0e7279">7.5. Rule Execution Modes</a></span></dt><dd><dl><dt><span class="section"><a href="ch07.html#d0e7286">7.5.1. Passive Mode</a></span></dt><dt><span class="section"><a href="ch07.html#d0e7301">7.5.2. Active Mode</a></span></dt></dl></dd><dt><span class="section"><a href="ch07.html#d0e7377">7.6. Propagation modes</a></span></dt><dt><span class="section"><a href="ch07.html#d0e7429">7.7. Commands and the CommandExecutor</a></span></dt></dl></div><p>Ths sections extends the KIE Running section, which should be read first, with specifics for the Drools runtime.</p><div class="section" title="7.1. KieRuntime"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6612"/>7.1. KieRuntime</h2></div></div></div><div class="section" title="7.1.1. EntryPoint"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6615"/>7.1.1. EntryPoint</h3></div></div></div><p>The <code class="code">EntryPoint</code> provides the methods around inserting, updating and deleting
        facts. The term "entry point" is related to the fact that we have multiple partitions in a
        Working Memory and you can choose which one you are inserting into. The use of multiple
        entry points is more common in event processing use cases, but they can be used by pure rule
        applications as well. </p><p>The <code class="code">KieRuntime</code> interface provides the main
      interaction with the engine. It is available in rule consequences and
      process actions. In this manual the focus is on the methods and
      interfaces related to rules, and the methods pertaining to processes
      will be ignored for now. But you'll notice that the
      <code class="code">KieRuntime</code> inherits methods from both the
      <code class="code">WorkingMemory</code> and the <code class="code">ProcessRuntime</code>, thereby
      providing a unified API to work with processes and rules. When working
      with rules, three interfaces form the <code class="code">KieRuntime</code>:
      <code class="code">EntryPoint</code>, <code class="code">WorkingMemory</code> and the
      <code class="code">KieRuntime</code> itself.</p><div class="figure"><a id="d0e6649"/><p class="title"><strong>Figure 7.1. EntryPoint</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/EntryPoint.png" alt="EntryPoint"/></div></div></div><br class="figure-break"/><div class="section" title="7.1.1.1. Insert"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6655"/>7.1.1.1. Insert</h4></div></div></div><p>In order for a fact to be evaluated against the rules in a <code class="code">KieBase</code>, it
          has to be inserted into the session. This is done by calling the method
            <code class="code">insert(yourObject)</code>. When a fact is inserted into the session, some of its
          properties might be immediately evaluated (eager evaluation) and some might be deferred
          for later evaluation (lazy evaluation). The exact behaviour depends on the rules engine
          algorithm being used. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Expert systems typically use the term <span class="emphasis"><em>assert</em></span> or
              <span class="emphasis"><em>assertion</em></span> to refer to facts made available to the system.
            However, due to "assert" being a keyword in most languages, we have decided to use the
              <code class="literal">insert</code> keyword; In this manual, the two terms are used
            interchangeably.</p></div><p>When an Object is inserted it returns a <code class="code">FactHandle</code>.
        This <code class="code">FactHandle</code> is the token used to represent your
        inserted object within the <code class="code">WorkingMemory</code>. It is also used
        for interactions with the <code class="code">WorkingMemory</code> when you wish to
        delete or modify an object.</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );      </code></pre><p>As mentioned in the KieBase section, a Working Memory may operate in two assertion
          modes: either equality or identity. Identity is the default.</p><p><span class="emphasis"><em>Identity</em></span> means that the Working Memory uses
        an <code class="code">IdentityHashMap</code> to store all asserted objects. New
        instance assertions always result in the return of new
        <code class="code">FactHandle</code>, but if an instance is asserted again then it
        returns the original fact handle, i.e., it ignores repeated insertions
        for the same object.</p><p><span class="emphasis"><em>Equality</em></span> means that the Working Memory uses a
            <code class="code">HashMap</code> to store all asserted objects. An object instance assertion will
          only return a new <code class="code">FactHandle</code> if the inserted object is not equal (according
          to its <code class="code">equal()/hashcode()</code> methods) to an already existing fact.</p></div><div class="section" title="7.1.1.2. Delete"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6720"/>7.1.1.2. Delete</h4></div></div></div><p>In order to remove a fact from the session, the method <code class="code">delete()</code> is used.
          When a fact is deleted,  any matches that are active and depend on that fact will be
          cancelled. Note that it is possible to have rules that depend on the nonexistence of a
          fact, in which case deleting a fact may cause a rule to activate. (See the
            <code class="code">not</code> and <code class="code">exists</code> keywords). </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Expert systems typically use the term <span class="emphasis"><em>retract</em></span> or
              <span class="emphasis"><em>retraction</em></span> to refer to the operation of removing facts from the
            Working Memory. Drools prefers the keyword <code class="literal">delete</code> for symmetry with
            the keyword <code class="code">insert</code>; Drools also supports the keyword <code class="code">retract</code>,
            but it was deprecated in favor of <code class="code">delete</code>. In this manual, the two terms are
            used interchangeably.</p></div><p>Retraction may be done using the <code class="code">FactHandle</code> that was returned by the
          insert call. On the right hand side of a rule the <code class="literal">delete</code> statement is
          used, which works with a simple object reference.</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );
....
ksession.delete( stiltonHandle );            </code></pre></div><div class="section" title="7.1.1.3. Update"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6765"/>7.1.1.3. Update</h4></div></div></div><p>The Rule Engine must be notified of modified facts, so that they
        can be reprocessed. You must use the <code class="code">update()</code> method to
        notify the <code class="code">WorkingMemory</code> of changed objects for those
        objects that are not able to notify the <code class="code">WorkingMemory</code>
        themselves. Notice that <code class="code">update()</code> always takes the
        modified object as a second parameter, which allows you to specify new
        instances for immutable objects. On the right hand side of a rule the
        <code class="code">modify</code> statement is recommended, as it makes the
        changes and notifies the engine in a single statement. Alternatively,
        after changing a fact object's field values through calls of setter
        methods you must invoke <code class="code">update</code> immediately, event
        before changing another fact, or you will cause problems with the
        indexing within the rule engine. The modify statement avoids this
        problem.</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </code></pre></div></div><div class="section" title="7.1.2. RuleRuntime"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6790"/>7.1.2. RuleRuntime</h3></div></div></div><p>The RuleRuntime provides access to the Agenda, permits query
      executions, and lets you access named Entry Points.</p><div class="figure"><a id="d0e6795"/><p class="title"><strong>Figure 7.2. RuleRuntime</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/RuleRuntime.png" alt="RuleRuntime"/></div></div></div><br class="figure-break"/><div class="section" title="7.1.2.1. Query"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6801"/>7.1.2.1. Query</h4></div></div></div><p>Queries are used to retrieve fact sets based on patterns, as
        they are used in rules. Patterns may make use of optional parameters.
        Queries can be defined in the Knowledge Base, from where they are
        called up to return the matching results. While iterating over the
        result collection, any identifier bound in the query can be used to
        access the corresponding fact or fact field by calling the
        <code class="code">get</code> method with the binding variable's name as its
        argument. If the binding refers to a fact object, its FactHandle can
        be retrieved by calling <code class="code">getFactHandle</code>, again with the
        variable's name as the parameter.</p><div class="figure"><a id="d0e6812"/><p class="title"><strong>Figure 7.3. QueryResults</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/QueryResults.png" alt="QueryResults"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e6818"/><p class="title"><strong>Figure 7.4. QueryResultsRow</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/QueryResultsRow.png" alt="QueryResultsRow"/></div></div></div><br class="figure-break"/><div class="example"><a id="d0e6824"/><p class="title"><strong>Example 7.1. Simple Query Example</strong></p><div class="example-contents"><pre><code class="language-java">QueryResults results =
    ksession.getQueryResults( "my query", new Object[] { "string" } );
for ( QueryResultsRow row : results ) {
    System.out.println( row.get( "varName" ) );
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="7.1.2.2. Live Queries"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6829"/>7.1.2.2. Live Queries</h4></div></div></div><p>Invoking queries and processing the results by iterating over
        the returned set is not a good way to monitor changes over
        time.</p><p>To alleviate this, Drools provides Live Queries, which have a
        listener attached instead of returning an iterable result set. These
        live queries stay open by creating a view and publishing change events for
        the contents of this view. To activate, you start your query with
        parameters and listen to changes in the resulting view. The
        <code class="code">dispose</code> method terminates the query and discontinues this
        reactive scenario.</p><div class="example"><a id="d0e6839"/><p class="title"><strong>Example 7.2. Implementing ViewChangedEventListener</strong></p><div class="example-contents"><pre><code class="language-java">final List updated = new ArrayList();
final List removed = new ArrayList();
final List added = new ArrayList();

ViewChangedEventListener listener = new ViewChangedEventListener() {
 public void rowUpdated(Row row) {
  updated.add( row.get( "$price" ) );
 }

 public void rowRemoved(Row row) {
  removed.add( row.get( "$price" ) );
 }

 public void rowAdded(Row row) {
  added.add( row.get( "$price" ) );
 }
};

// Open the LiveQuery
LiveQuery query = ksession.openLiveQuery( "cheeses",
                                          new Object[] { "cheddar", "stilton" },
                                          listener );
...
...
query.dispose() // calling dispose to terminate the live query</code></pre></div></div><br class="example-break"/><p>A Drools blog article contains an example of Glazed Lists
        integration for live queries:</p><p><a class="link" href="http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html">http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html</a></p></div></div><div class="section" title="7.1.3. StatefulRuleSession"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6849"/>7.1.3. StatefulRuleSession</h3></div></div></div><p>The <code class="code">StatefulRuleSession</code> is inherited by the
      <code class="code">KieSession</code> and provides the rule related
      methods that are relevant from outside of the engine.</p><div class="figure"><a id="d0e6860"/><p class="title"><strong>Figure 7.5. StatefulRuleSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/StatefulRuleSession.png" alt="StatefulRuleSession"/></div></div></div><br class="figure-break"/><div class="section" title="7.1.3.1. Agenda Filters"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6866"/>7.1.3.1. Agenda Filters</h4></div></div></div><div class="figure"><a id="d0e6869"/><p class="title"><strong>Figure 7.6. AgendaFilters</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/ApiReference/AgendaFilter.png" align="middle" alt="AgendaFilters"/></div></div></div><br class="figure-break"/><p><code class="code">AgendaFilter</code> objects are optional implementations
        of the filter interface which are used to allow or deny the firing of
        a match. What you filter on is entirely up to the
        implementation. Drools 4.0 used to supply some out of the box filters,
        which have not be exposed in drools 5.0 knowledge-api, but they are
        simple to implement and the Drools 4.0 code base can be referred
        to.</p><p>To use a filter specify it while calling
        <code class="code">fireAllRules()</code>. The following example permits only rules
        ending in the string <code class="code">"Test"</code>. All others will be filtered
        out.</p><pre><code class="language-java">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</code></pre></div></div></div><div class="section" title="7.2. Agenda"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6889"/>7.2. Agenda</h2></div></div></div><p>The Agenda is a <span class="emphasis"><em>Rete</em></span> feature. During actions on
    the <code class="code">WorkingMemory</code>, rules may become fully matched and
    eligible for execution; a single Working Memory Action can result in
    multiple eligible rules. When a rule is fully matched a Match is
    created, referencing the rule and the matched facts, and placed onto the
    Agenda. The Agenda controls the execution order of these Matches using
    a Conflict Resolution strategy.</p><p>The engine cycles repeatedly through two phases:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Working Memory Actions. This is where most of the work takes
        place, either in the Consequence (the RHS itself) or the main Java
        application process. Once the Consequence has finished or the main
        Java application process calls <code class="code">fireAllRules()</code> the engine
        switches to the Agenda Evaluation phase.</p></li><li class="listitem"><p>Agenda Evaluation. This attempts to select a rule to fire. If no
        rule is found it exits, otherwise it fires the found rule, switching
        the phase back to Working Memory Actions.</p></li></ol></div><div class="figure"><a id="d0e6912"/><p class="title"><strong>Figure 7.7. Two Phase Execution</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Two_Phase.png" align="middle" alt="Two Phase Execution"/></div></div></div><br class="figure-break"/><p>The process repeats until the agenda is clear, in which case control
    returns to the calling application. When Working Memory Actions are taking
    place, no rules are being fired.</p><div class="figure"><a id="d0e6920"/><p class="title"><strong>Figure 7.8. Agenda</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/Agenda.png" alt="Agenda"/></div></div></div><br class="figure-break"/><div class="section" title="7.2.1. Conflict Resolution"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6926"/>7.2.1. Conflict Resolution</h3></div></div></div><p>Conflict resolution is required when there are multiple rules on
      the agenda. (The basics to this are covered in chapter "Quick Start".)
      As firing a rule may have side effects on the working memory, the rule
      engine needs to know in what order the rules should fire (for instance,
      firing ruleA may cause ruleB to be removed from the agenda).</p><p>The default conflict resolution strategies employed by Drools are:
      Salience and LIFO (last in, first out).</p><p>The most visible one is <span class="emphasis"><em>salience</em></span> (or
      priority), in which case a user can specify that a certain rule has a
      higher priority (by giving it a higher number) than other rules. In that
      case, the rule with higher salience will be preferred. LIFO priorities
      are based on the assigned Working Memory Action counter value, with all
      rules created during the same action receiving the same value. The
      execution order of a set of firings with the same priority value is
      arbitrary.</p><p>As a general rule, it is a good idea not to count on rules firing
      in any particular order, and to author the rules without worrying about
      a "flow". However when a flow is needed a number of possibilities exist,
      including but not limited to: agenda groups, rule flow groups,
      activation groups, control/semaphore facts. These are discussed in later
      sections.</p><p>Drools 4.0 supported custom conflict resolution strategies; while
      this capability still exists in Drools it has not yet been exposed to
      the end user via knowledge-api in Drools 5.0.</p></div><div class="section" title="7.2.2. AgendaGroup"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6942"/>7.2.2. AgendaGroup</h3></div></div></div><div class="figure"><a id="d0e6945"/><p class="title"><strong>Figure 7.9. AgendaGroup</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/AgendaGroup.png" alt="AgendaGroup"/></div></div></div><br class="figure-break"/><p>Agenda groups are a way to partition rules (matches, actually)
      on the agenda. At any one time, only one group has "focus" which means
      that matches for rules in that group only will take effect. You can
      also have rules with "auto focus" which means that the focus is taken
      for its agenda group when that rule's conditions are true.</p><p>Agenda groups are known as "modules" in CLIPS terminology. While
      it best to design rules that do not need control flow, this is not
      always possible. Agenda groups provide a handy way to create a "flow"
      between grouped rules. You can switch the group which has focus either
      from within the rule engine, or via the API. If your rules have a clear
      need for multiple "phases" or "sequences" of processing, consider using
      agenda-groups for this purpose.</p><p>Each time <code class="code">setFocus()</code> is called it pushes that Agenda
      Group onto a stack. When the focus group is empty it is popped from the
      stack and the focus group that is now on top evaluates. An Agenda Group
      can appear in multiple locations on the stack. The default Agenda Group
      is "MAIN", with all rules which do not specify an Agenda Group being in
      this group. It is also always the first group on the stack, given focus
      initially, by default.</p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</code></pre><p>The <code class="code">clear()</code> method can be used to cancel all the activations
      generated by the rules belonging to a given Agenda Group before one has had a chance
      to fire.</p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).clear();</code></pre><p>Note that, due to the lazy nature of the phreak algorithm used by Drools,
      the activations are by default materialized only at firing time, but it is possible
      to anticipate the evaluation and then the activation of a given rule at the
      moment when a fact is inserted into the session by annotating it with
      <code class="code">@Propagation(IMMEDIATE)</code> as explained in the Propagation modes section.</p></div><div class="section" title="7.2.3. ActivationGroup"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6974"/>7.2.3. ActivationGroup</h3></div></div></div><div class="figure"><a id="d0e6977"/><p class="title"><strong>Figure 7.10. ActivationGroup</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/ActivationGroup.png" alt="ActivationGroup"/></div></div></div><br class="figure-break"/><p>An activation group is a set of rules bound together by the same
      "activation-group" rule attribute. In this group only one rule can fire,
      and after that rule has fired all the other rules are cancelled from the
      agenda. The <code class="code">clear()</code> method can be called at any time, which
      cancels all of the activations before one has had a chance to
      fire.</p><pre><code class="language-java">ksession.getAgenda().getActivationGroup( "Group B" ).clear();</code></pre></div><div class="section" title="7.2.4. RuleFlowGroup"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6990"/>7.2.4. RuleFlowGroup</h3></div></div></div><div class="figure"><a id="d0e6993"/><p class="title"><strong>Figure 7.11. RuleFlowGroup</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/RuleFlowGroup.png" alt="RuleFlowGroup"/></div></div></div><br class="figure-break"/><p>A rule flow group is a group of rules associated by the
      "ruleflow-group" rule attribute. These rules can only fire when the
      group is activate. The group itself can only become active when the
      elaboration of the ruleflow diagram reaches the node representing the
      group. Here too, the <code class="code">clear()</code> method can be called at any
      time to cancels all matches still remaining on the Agenda.</p><pre><code class="language-java">ksession.getAgenda().getRuleFlowGroup( "Group C" ).clear();</code></pre></div></div><div class="section" title="7.3. Event Model"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7006"/>7.3. Event Model</h2></div></div></div><p>The event package provides means to be notified of rule engine
    events, including rules firing, objects being asserted, etc. This allows
    you, for instance, to separate logging and auditing activities from the
    main part of your application (and the rules).</p><p>The <code class="code">WorkingMemoryEventManager</code> allows for listeners to be added and removed,
      so that events for the working memory and the agenda can be listened to.</p><div class="figure"><a id="d0e7016"/><p class="title"><strong>Figure 7.12. WorkingMemoryEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/WorkingMemoryEventManager.png" alt="WorkingMemoryEventManager"/></div></div></div><br class="figure-break"/><p>The following code snippet shows how a simple agenda listener is
    declared and attached to a session. It will print matches after they
    have fired.</p><div class="example"><a id="d0e7024"/><p class="title"><strong>Example 7.3. Adding an AgendaEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DefaultAgendaEventListener() {
   public void afterMatchFired(AfterMatchFiredEvent event) {
       super.afterMatchFired( event );
       System.out.println( event );
   }
});     </code></pre></div></div><br class="example-break"/><p>Drools also provides <code class="code">DebugRuleRuntimeEventListener</code>
    and <code class="code">DebugAgendaEventListener</code> which implement each method with
    a debug print statement. To print all Working Memory events, you add a
    listener like this:</p><div class="example"><a id="d0e7037"/><p class="title"><strong>Example 7.4. Adding a DebugRuleRuntimeEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DebugRuleRuntimeEventListener() );     </code></pre></div></div><br class="example-break"/><p>The events currently supported are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>MatchCreatedEvent</p></li><li class="listitem"><p>MatchCancelledEvent</p></li><li class="listitem"><p>BeforeMatchFiredEvent</p></li><li class="listitem"><p>AfterMatchFiredEvent</p></li><li class="listitem"><p>AgendaGroupPushedEvent</p></li><li class="listitem"><p>AgendaGroupPoppedEvent</p></li><li class="listitem"><p>ObjectInsertEvent</p></li><li class="listitem"><p>ObjectDeletedEvent</p></li><li class="listitem"><p>ObjectUpdatedEvent</p></li><li class="listitem"><p>ProcessCompletedEvent</p></li><li class="listitem"><p>ProcessNodeLeftEvent</p></li><li class="listitem"><p>ProcessNodeTriggeredEvent</p></li><li class="listitem"><p>ProcessStartEvent</p></li></ul></div></div><div class="section" title="7.4. StatelessKieSession"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7084"/>7.4. StatelessKieSession</h2></div></div></div><p>The <code class="code">StatelessKieSession</code> wraps the
    <code class="code">KieSession</code>, instead of extending it. Its main
    focus is on decision service type scenarios. It avoids the need to call
    <code class="code">dispose()</code>. Stateless sessions do not support iterative
    insertions and the method call <code class="code">fireAllRules()</code> from Java code;
    the act of calling <code class="code">execute()</code> is a single-shot method that
    will internally instantiate a <code class="code">KieSession</code>, add
    all the user data and execute user commands, call
    <code class="code">fireAllRules()</code>, and then call <code class="code">dispose()</code>. While
    the main way to work with this class is via the
    <code class="code">BatchExecution</code> (a subinterface of <code class="code">Command</code>) as
    supported by the <code class="code">CommandExecutor</code> interface, two convenience
    methods are provided for when simple object insertion is all that's
    required. The <code class="code">CommandExecutor</code> and <code class="code">BatchExecution</code>
    are talked about in detail in their own section.</p><div class="figure"><a id="d0e7128"/><p class="title"><strong>Figure 7.13. StatelessKieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/StatelessKieSession.png" alt="StatelessKieSession"/></div></div></div><br class="figure-break"/><p>Our simple example shows a stateless session executing a given
    collection of Java objects using the convenience API. It will iterate the
    collection, inserting each element in turn.</p><div class="example"><a id="d0e7136"/><p class="title"><strong>Example 7.5. Simple StatelessKieSession execution with a Collection</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute( collection );</code></pre></div></div><br class="example-break"/><p>If this was done as a single Command it would be as follows:</p><div class="example"><a id="d0e7143"/><p class="title"><strong>Example 7.6. Simple StatelessKieSession execution with InsertElements Command</strong></p><div class="example-contents"><pre><code class="language-java">ksession.execute( CommandFactory.newInsertElements( collection ) );  </code></pre></div></div><br class="example-break"/><p>If you wanted to insert the collection itself, and the collection's
    individual elements, then
    <code class="code">CommandFactory.newInsert(collection)</code> would do the job.</p><p>Methods of the <code class="code">CommandFactory</code> create the supported
    commands, all of which can be marshalled using XStream and the
    <code class="code">BatchExecutionHelper</code>. <code class="code">BatchExecutionHelper</code>
    provides details on the XML format as well as how to use Drools Pipeline
    to automate the marshalling of <code class="code">BatchExecution</code> and
    <code class="code">ExecutionResults</code>.</p><p><code class="code">StatelessKieSession</code> supports globals, scoped in a
    number of ways. I'll cover the non-command way first, as commands are
    scoped to a specific execution call. Globals can be resolved in three
    ways.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The StatelessKieSession method <code class="code">getGlobals()</code>
        returns a Globals instance which provides access to the session's
        globals. These are shared for <span class="emphasis"><em>all</em></span> execution
        calls. Exercise caution regarding mutable globals because execution
        calls can be executing simultaneously in different threads.</p><div class="example"><a id="d0e7184"/><p class="title"><strong>Example 7.7. Session scoped global</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.
ksession.execute( collection ); </code></pre></div></div><br class="example-break"/></li><li class="listitem"><p>Using a delegate is another way of global resolution. Assigning
        a value to a global (with <code class="code">setGlobal(String, Object)</code>)
        results in the value being stored in an internal collection mapping
        identifiers to values. Identifiers in this internal collection will
        have priority over any supplied delegate. Only if an identifier cannot
        be found in this internal collection, the delegate global (if any)
        will be used.</p></li><li class="listitem"><p>The third way of resolving globals is to have execution scoped
        globals. Here, a <code class="code">Command</code> to set a global is passed to the
        <code class="code">CommandExecutor</code>.</p></li></ul></div><p>The <code class="code">CommandExecutor</code> interface also offers the ability
    to export data via "out" parameters. Inserted facts, globals and query
    results can all be returned.</p><div class="example"><a id="d0e7209"/><p class="title"><strong>Example 7.8. Out identifiers</strong></p><div class="example-contents"><pre><code class="language-java">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</code></pre></div></div><br class="example-break"/><div class="section" title="7.4.1. Sequential Mode"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7214"/>7.4.1. Sequential Mode</h3></div></div></div><p>With Rete you have a stateful session where objects can be
      asserted and modified over time, and where rules can also be added and
      removed. Now what happens if we assume a stateless session, where after
      the initial data set no more data can be asserted or modified and rules
      cannot be added or removed? Certainly it won't be necessary to
      re-evaluate rules, and the engine will be able to operate in a
      simplified way.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Order the Rules by salience and position in the ruleset (by
          setting a sequence attribute on the rule terminal node).</p></li><li class="listitem"><p>Create an elements, one element for each possible rule
          match; element position indicates firing order.</p></li><li class="listitem"><p>Turn off all node memories, except the right-input Object
          memory.</p></li><li class="listitem"><p>Disconnect the Left Input Adapter Node propagation, and let
          the Object plus the Node be referenced in a Command object, which is
          added to a list on the Working Memory for later execution.</p></li><li class="listitem"><p>Assert all objects, and, when all assertions are finished and
          thus right-input node memories are populated, check the Command list
          and execute each in turn.</p></li><li class="listitem"><p>All resulting Matches should be placed in the elements, based
          upon the determined sequence number of the Rule. Record the first
          and last populated elements, to reduce the iteration range.</p></li><li class="listitem"><p>Iterate the elements of Matches, executing populated element
          in turn.</p></li><li class="listitem"><p>If we have a maximum number of allowed rule executions, we can
          exit our network evaluations early to fire all the rules in the
          elements.</p></li></ol></div><p>The <code class="code">LeftInputAdapterNode</code> no longer creates a Tuple,
      adding the Object, and then propagate the Tuple – instead a Command
      object is created and added to a list in the Working Memory. This
      Command object holds a reference to the
      <code class="code">LeftInputAdapterNode</code> and the propagated object. This stops
      any left-input propagations at insertion time, so that we know that a
      right-input propagation will never need to attempt a join with the
      left-inputs (removing the need for left-input memory). All nodes have
      their memory turned off, including the left-input Tuple memory but
      excluding the right-input object memory, which means that the only node
      remembering an insertion propagation is the right-input object memory.
      Once all the assertions are finished and all right-input memories
      populated, we can then iterate the list of
      <code class="code">LeftInputAdatperNode</code> Command objects calling each in turn.
      They will propagate down the network attempting to join with the
      right-input objects, but they won't be remembered in the left input as
      we know there will be no further object assertions and thus propagations
      into the right-input memory.</p><p>There is no longer an Agenda, with a priority queue to schedule
      the Tuples; instead, there is simply an elements for the number of rules.
      The sequence number of the <code class="code">RuleTerminalNode</code> indicates the
      element within the elements where to place the Match. Once all Command
      objects have finished we can iterate our elements, checking each element in
      turn, and firing the Matches if they exist. To improve performance,
      we remember the first and the last populated cell in the elements. The
      network is constructed, with each <code class="code">RuleTerminalNode</code> being
      given a sequence number based on a salience number and its order of
      being added to the network.</p><p>Typically the right-input node memories are Hash Maps, for fast
      object deletion; here, as we know there will be no object deletions,
      we can use a list when the values of the object are not indexed. For
      larger numbers of objects indexed Hash Maps provide a performance
      increase; if we know an object type has only a few instances, indexing
      is probably not advantageous, and a list can be used.</p><p>Sequential mode can only be used with a Stateless Session and is
      off by default. To turn it on, either call
      <code class="code">RuleBaseConfiguration.setSequential(true)</code>, or set the
      rulebase configuration property <code class="code">drools.sequential</code> to true.
      Sequential mode can fall back to a dynamic agenda by calling
      <code class="code">setSequentialAgenda</code> with
      <code class="code">SequentialAgenda.DYNAMIC</code>. You may also set the
      "drools.sequential.agenda" property to "sequential" or "dynamic".</p></div></div><div class="section" title="7.5. Rule Execution Modes"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7279"/>7.5. Rule Execution Modes</h2></div></div></div><p>Drools provides two modes for rule execution - passive and active.</p><p>As a general guideline, Passive Mode is most suitable for Rule Engine applications which need to
    explicitly control when the engine shall evaluate and fire the rules, or for CEP applications making use
    of the Pseudo Clock. Active Mode is most effective for Rule Engine applications which delegate control
    of when rules are evaluated and fired to the engine, or for typical CEP application making use of the
    Real Time Clock.</p><div class="section" title="7.5.1. Passive Mode"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7286"/>7.5.1. Passive Mode</h3></div></div></div><p>With Passive mode not only is the user responsible for working memory operations, such as <code class="code">insert()</code>,
      but also for when the rules are to evaluate the data and fire the resulting rule instantiations -
      using <code class="code">fireAllRules()</code></p><p>An example outline of Drools code for a CEP application making use of Passive Mode:</p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );
KieSession session = kbase.newKieSession( conf, null );
SessionPseudoClock clock = session.getSessionClock();

session.insert( tick1 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick2 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick3 );
session.fireAllRules();

session.dispose();</code></pre></div><div class="section" title="7.5.2. Active Mode"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7301"/>7.5.2. Active Mode</h3></div></div></div><p>Drools offers a <code class="code">fireUntilHalt()</code> method, that starts the engine in Active Mode, which is
      asynchronous in behavior, where rules will be continually evaluated and fired, until a
      <code class="code">halt()</code> call is made. </p><p>This is specially useful for CEP scenarios that require what is commonly known as "active queries".</p><p>Please note calling <code class="code">fireUntilHalt()</code> blocks the current thread, while the engine will
      start and continue running asynchronously until the <code class="code">halt()</code> is called on the KieSession. It is
      suggested therefore to call <code class="code">fireUntilHalt()</code> from a dedicated thread, so the current thread does
      not get blocked indefinitely; this also enable the current thread to call <code class="code">halt()</code> at a later
      stage, ref. examples below.</p><p>An example outline of Drools code for a CEP application making use of Active Mode:</p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
KieSession session = kbase.newKieSession( conf, null );

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

session.insert( tick1 );

... Thread.sleep( 1000L ); ...

session.insert( tick2 );

... Thread.sleep( 1000L ); ...

session.insert( tick3 );

session.halt();
session.dispose();</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Generally, it is not recommended mixing <code class="code">fireAllRules()</code> and
        <code class="code">fireUntilHalt()</code> , especially from different threads. However the engine is able to handle
        such situations safely, thanks to the internal state machine. If <code class="code">fireAllRules()</code> is
        running and a call <code class="code">fireUntilHalt()</code> is made, the engine will wait until the
        <code class="code">fireAllRules()</code> is finished and then start <code class="code">fireUntilHalt()</code> . However if
        <code class="code">fireUntilHalt()</code> is running and <code class="code">fireAllRules()</code> is called, the later is
        ignored and will just return directly. For more details about thread-safety and the internal state
        machine, reference section "Improved multi-threading behaviour".</p></div><div class="section" title="7.5.2.1. Performing KieSession operations atomically when in Active Mode"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7359"/>7.5.2.1. Performing KieSession operations atomically when in Active Mode</h4></div></div></div><p>When in Active Mode, the Drools engine is in control of when the rule shall be evaluated and
          fired; therefore it is important that operations on the KieSession are performed in a thread-safe manner.
          Additionally, from a client-side perspective, there might be the need for more than one operations to be
          called on the KieSession in between rule evaluations, but for engine to consider these as an atomic
          operation: for example, inserting more than one Fact at a given time, but for the engine to await until
          all the inserts are done, before evaluating the rules again.</p><p>Drools offers a submit() method to group and perform operations on the KieSession as a thread-safe
          atomic action, while in Active Mode.</p><p>An example outline of Drools code to perform KieSession operations atomically when in Active Mode:</p><pre><code class="language-java">KieSession session = ...;

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

final FactHandle fh = session.insert( fact_a );

... Thread.sleep( 1000L ); ...

session.submit( new KieSession.AtomicAction() {
  @Override
  public void execute( KieSession kieSession ) {
    fact_a.setField("value");
    kieSession.update( fh, fact_a );
    kieSession.insert( fact_1 );
    kieSession.insert( fact_2 );
    kieSession.insert( fact_3 );
  }
} );

... Thread.sleep( 1000L ); ...

session.insert( fact_z );

session.halt();
session.dispose();</code></pre><p>As a reminder example, the fact handle could also be retrieved from the KieSession:</p><pre><code class="language-java">...
session.insert( fact_a );

... Thread.sleep( 1000L ); ...

session.submit( new KieSession.AtomicAction() {
  @Override
  public void execute( KieSession kieSession ) {
    final FactHandle fh = kieSession.getFactHandle( fact_a );
    fact_a.setField("value");
    kieSession.update( fh, fact_a );
    kieSession.insert( fact_1 );
    kieSession.insert( fact_2 );
    kieSession.insert( fact_3 );
  }
} );

...</code></pre></div></div></div><div class="section" title="7.6. Propagation modes"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7377"/>7.6. Propagation modes</h2></div></div></div><p>The introduction of PHREAK as default algorithm for the Drools engine made the rules' evaluation
    lazy. This new Drools lazy behavior allowed a relevant performance boost but, in some very specific cases,
    breaks the semantic of a few Drools features.</p><p>More precisely in some circumstances it is necessary to propagate the insertion of new fact into th
    session immediately. For instance Drools allows a query to be executed in pull only (or passive) mode by
    prepending a '?' symbol to its invocation as in the following example:</p><div class="example"><a id="d0e7384"/><p class="title"><strong>Example 7.9. A passive query</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></div><br class="example-break"/><p>In this case, since the query is passive, it shouldn't react to the insertion of a String
    matching the join condition in the query itself. In other words this sequence of commands</p><pre><code class="language-java">KieSession ksession = ...
ksession.insert(1);
ksession.insert("1");
ksession.fireAllRules();</code></pre><p>shouldn't cause the rule R to fire because the String satisfying the query condition has
    been inserted after the Integer and the passive query shouldn't react to this insertion.
    Conversely the rule should fire if the insertion sequence is inverted because the insertion
    of the Integer, when the passive query can be satisfied by the presence of an already existing
    String, will trigger it.</p><p>Unfortunately the lazy nature of PHREAK doesn't allow the engine to make any
    distinction regarding the insertion sequence of the two facts, so the rule will fire
    in both cases. In circumstances like this it is necessary to evaluate the rule eagerly as
    done by the old RETEOO-based engine.</p><p>In other cases it is required that the propagation is eager, meaning that it is not immedate,
    but anyway has to happen before the engine/agenda starts scheduled evaluations. For instance this
    is necessary when a rule has the no-loop or the lock-on-active attribute and in fact when this
    happens this propagation mode is automatically enforced by the engine.</p><p>To cover these use cases, and in all other situations where an immediate or eager rule
    evaluation is required, it is possible to declaratively specify so by annotating the rule
    itself with <span class="bold"><strong>@Propagation(Propagation.Type)</strong></span>, where
    Propagation.Type is an enumeration with 3 possible values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>IMMEDIATE</strong></span> means that the propagation is performed immediately.</p></li><li class="listitem"><p><span class="bold"><strong>EAGER</strong></span> means that the propagation is performed lazily but
          eagerly evaluated before scheduled evaluations.</p></li><li class="listitem"><p><span class="bold"><strong>LAZY</strong></span> means that the propagation is totally lazy and this is
          default PHREAK behaviour</p></li></ul></div><p>This means that the following drl:</p><div class="example"><a id="d0e7422"/><p class="title"><strong>Example 7.10. A data-driven rule using a passive query</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R @Propagation(IMMEDIATE) when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></div><br class="example-break"/><p>will make the rule R to fire if and only if the Integer is inserted after the String, thus
    behaving in accordance with the semantic of the passive query.</p></div><div class="section" title="7.7. Commands and the CommandExecutor"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7429"/>7.7. Commands and the CommandExecutor</h2></div></div></div><p>The <code class="code">CommandFactory</code> allows for commands to be executed
    on those sessions, the only difference being that the Stateless Knowledge
    Session executes <code class="code">fireAllRules()</code> at the end before disposing
    the session. The currently supported commands are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>FireAllRules</p></li><li class="listitem"><p>GetGlobal</p></li><li class="listitem"><p>SetGlobal</p></li><li class="listitem"><p>InsertObject</p></li><li class="listitem"><p>InsertElements</p></li><li class="listitem"><p>Query</p></li><li class="listitem"><p>StartProcess</p></li><li class="listitem"><p>BatchExecution</p></li></ul></div><p><code class="code">InsertObject</code> will insert a single object, with an
    optional "out" identifier. <code class="code">InsertElements</code> will iterate an
    Iterable, inserting each of the elements. What this means is that a
    Stateless Knowledge Session is no longer limited to just inserting
    objects, it can now start processes or execute queries, and do this in any
    order.</p><div class="example"><a id="d0e7472"/><p class="title"><strong>Example 7.11. Insert Command</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
  ksession.execute( CommandFactory.newInsert( new Cheese( "stilton" ), "stilton_id" ) );
Stilton stilton = bresults.getValue( "stilton_id" );
</code></pre></div></div><br class="example-break"/><p>The execute method always returns an <code class="code">ExecutionResults</code>
    instance, which allows access to any command results if they specify an
    out identifier such as the "stilton_id" above.</p><div class="example"><a id="d0e7482"/><p class="title"><strong>Example 7.12. InsertElements Command</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
Command cmd = CommandFactory.newInsertElements( Arrays.asList( Object[] {
                  new Cheese( "stilton" ),
                  new Cheese( "brie" ),
                  new Cheese( "cheddar" ),
              });
ExecutionResults bresults = ksession.execute( cmd );
</code></pre></div></div><br class="example-break"/><p>The execute method only allows for a single command. That's where
    <code class="code">BatchExecution</code> comes in, which represents a composite
    command, created from a list of commands. Now, execute will iterate over
    the list and execute each command in turn. This means you can insert some
    objects, start a process, call fireAllRules and execute a query, all in a
    single <code class="code">execute(...)</code> call, which is quite powerful.</p><p>As mentioned previosly, the StatelessKieSession will execute
    <code class="code">fireAllRules()</code> automatically at the end. However the
    keen-eyed reader probably has already noticed the
    <code class="code">FireAllRules</code> command and wondered how that works with a
    StatelessKieSession. The <code class="code">FireAllRules</code> command is
    allowed, and using it will disable the automatic execution at the end;
    think of using it as a sort of manual override function.</p><p>A custom XStream marshaller can be used with the Drools Pipeline to
    achieve XML scripting, which is perfect for services. Here are two simple
    XML samples, one for the BatchExecution and one for the
    <code class="code">ExecutionResults</code>.</p><div class="example"><a id="d0e7511"/><p class="title"><strong>Example 7.13. Simple BatchExecution XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='outStilton'&gt;
      &lt;org.drools.compiler.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;price&gt;25&lt;/price&gt;
         &lt;oldPrice&gt;0&lt;/oldPrice&gt;
      &lt;/org.drools.compiler.Cheese&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e7516"/><p class="title"><strong>Example 7.14. Simple ExecutionResults XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;execution-results&gt;
   &lt;result identifier='outStilton'&gt;
      &lt;org.drools.compiler.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;oldPrice&gt;25&lt;/oldPrice&gt;
         &lt;price&gt;30&lt;/price&gt;
      &lt;/org.drools.compiler.Cheese&gt;
   &lt;/result&gt;
&lt;/execution-results&gt;
</code></pre></div></div><br class="example-break"/><p>Spring and Camel, covered in the integrations book, facilitate
    declarative services.</p><div class="example"><a id="d0e7523"/><p class="title"><strong>Example 7.15. BatchExecution Marshalled to XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
  &lt;insert out-identifier="stilton"&gt;
    &lt;org.drools.compiler.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;1&lt;/price&gt;
      &lt;oldPrice&gt;0&lt;/oldPrice&gt;
    &lt;/org.drools.compiler.Cheese&gt;
  &lt;/insert&gt;
  &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
    &lt;string&gt;stilton&lt;/string&gt;
    &lt;string&gt;cheddar&lt;/string&gt;
  &lt;/query&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><p>The <code class="code">CommandExecutor</code> returns an
    <code class="code">ExecutionResults</code>, and this is handled by the pipeline code
    snippet as well. A similar output for the &lt;batch-execution&gt; XML
    sample above would be:</p><div class="example"><a id="d0e7536"/><p class="title"><strong>Example 7.16. ExecutionResults Marshalled to XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;execution-results&gt;
  &lt;result identifier="stilton"&gt;
    &lt;org.drools.compiler.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;2&lt;/price&gt;
    &lt;/org.drools.compiler.Cheese&gt;
  &lt;/result&gt;
  &lt;result identifier='cheeses2'&gt;
    &lt;query-results&gt;
      &lt;identifiers&gt;
        &lt;identifier&gt;cheese&lt;/identifier&gt;
      &lt;/identifiers&gt;
      &lt;row&gt;
        &lt;org.drools.compiler.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;2&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.compiler.Cheese&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;org.drools.compiler.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;1&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.compiler.Cheese&gt;
      &lt;/row&gt;
    &lt;/query-results&gt;
  &lt;/result&gt;
&lt;/execution-results&gt;
</code></pre></div></div><br class="example-break"/><p>The <code class="code">BatchExecutionHelper</code> provides a configured XStream
    instance to support the marshalling of Batch Executions, where the
    resulting XML can be used as a message format, as shown above. Configured
    converters only exist for the commands supported via the Command Factory.
    The user may add other converters for their user objects. This is very
    useful for scripting stateless or stateful knowledge sessions, especially
    when services are involved.</p><p>There is currently no XML schema to support schema validation. The
    basic format is outlined here, and the drools-pipeline module has an
    illustrative unit test in the <code class="code">XStreamBatchExecutionTest</code> unit
    test. The root element is &lt;batch-execution&gt; and it can contain zero
    or more commands elements.</p><div class="example"><a id="d0e7551"/><p class="title"><strong>Example 7.17. Root XML element</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
...
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><p>This contains a list of elements that represent commands, the
    supported commands is limited to those Commands provided by the Command
    Factory. The most basic of these is the &lt;insert&gt; element, which
    inserts objects. The contents of the insert element is the user object, as
    dictated by XStream.</p><div class="example"><a id="d0e7558"/><p class="title"><strong>Example 7.18. Insert</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert&gt;
      ...&lt;!-- any user object --&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><p>The insert element features an "out-identifier" attribute, demanding
    that the inserted object will also be returned as part of the result
    payload.</p><div class="example"><a id="d0e7565"/><p class="title"><strong>Example 7.19. Insert with Out Identifier Command</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='userVar'&gt;
      ...
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><p>It's also possible to insert a collection of objects using the
    &lt;insert-elements&gt; element. This command does not support an
    out-identifier. The <code class="code">org.domain.UserClass</code> is just an
    illustrative user object that XStream would serialize.</p><div class="example"><a id="d0e7575"/><p class="title"><strong>Example 7.20. Insert Elements command</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert-elements&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/insert-elements&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/><p>While the <code class="literal">out</code> attribute is useful in returning
    specific instances as a result payload, we often wish to run actual
    queries. Both parameter and parameterless queries are supported. The
    <code class="literal">name</code> attribute is the name of the query to be called,
    and the <code class="literal">out-identifier</code> is the identifier to be used for
    the query results in the <code class="code">&lt;execution-results&gt;</code>
    payload.</p><div class="example"><a id="d0e7594"/><p class="title"><strong>Example 7.21. Query Command</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;query out-identifier='cheeses' name='cheeses'/&gt;
   &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
      &lt;string&gt;stilton&lt;/string&gt;
      &lt;string&gt;cheddar&lt;/string&gt;
   &lt;/query&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"/></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch06.html"><strong>Prev</strong>Chapter 6. User Guide</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch08.html"><strong>Next</strong>Chapter 8. Rule Language Reference</a></li></ul></body></html>