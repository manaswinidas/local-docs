<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. KIE</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt02.html" title="Part II. KIE"/><link rel="prev" href="pt02.html" title="Part II. KIE"/><link rel="next" href="pt03.html" title="Part III. Drools Runtime and Language"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="pt02.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="pt03.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 4. KIE"><div class="titlepage"><div><div><h2 class="title"><a id="KIEChapter"/>Chapter 4. KIE</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch04.html#KIEOverviewSection">4.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#KIEAnatomySection">4.1.1. Anatomy of Projects</a></span></dt><dt><span class="section"><a href="ch04.html#KIELifeCyclesSection">4.1.2. Lifecycles</a></span></dt></dl></dd><dt><span class="section"><a href="ch04.html#BuildDeployUtilizeAndRunSection">4.2. Build, Deploy, Utilize and Run</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#KIEModuleIntroductionBuildingIntroductionSection">4.2.1. Introduction</a></span></dt><dt><span class="section"><a href="ch04.html#KIEBuildingSection">4.2.2. Building</a></span></dt><dt><span class="section"><a href="ch04.html#KIEDeployingSection">4.2.3. Deploying</a></span></dt><dt><span class="section"><a href="ch04.html#KIERunningSection">4.2.4. Running</a></span></dt><dt><span class="section"><a href="ch04.html#KIEDeployCheatSheets">4.2.5. Installation and Deployment Cheat Sheets</a></span></dt><dt><span class="section"><a href="ch04.html#KIEExamplesSection">4.2.6. Build,  Deploy and Utilize Examples</a></span></dt></dl></dd><dt><span class="section"><a href="ch04.html#KIESecuritySection">4.3. Security</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#SecurityManager">4.3.1. Security Manager</a></span></dt></dl></dd></dl></div><div class="section" title="4.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="KIEOverviewSection"/>4.1. Overview</h2></div></div></div><div class="section" title="4.1.1. Anatomy of Projects"><div class="titlepage"><div><div><h3 class="title"><a id="KIEAnatomySection"/>4.1.1. Anatomy of Projects</h3></div></div></div><p>The process of researching an integration knowledge solution for Drools and jBPM has simply
    used the "droolsjbpm" group name. This name permeates GitHub accounts and Maven POMs. As
    scopes broadened and new projects were spun KIE, an acronym for Knowledge Is Everything, was
    chosen as the new group name.  The KIE name is also used for the shared aspects of the system;
    such as the unified build, deploy and utilization.</p><p>KIE currently consists of the following subprojects:</p><div class="figure"><a id="d0e2215"/><p class="title"><strong>Figure 4.1. KIE Anatomy</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/Overview/kie.png" alt="KIE Anatomy"/></div></div></div><br class="figure-break"/><p>OptaPlanner, a local search and optimization tool, has been spun off from Drools Planner and
    is now a top level project with Drools and jBPM. This was a natural evolution as Optaplanner,
    while having strong Drools integration, has long been independant of Drools. </p><p>From the Polymita acquisition, along with other things, comes the powerful Dashboard Builder
    which provides powerful reporting capabilities. Dashboard Builder is currently a temporary name
    and after the 6.0 release a new name will be chosen. Dashboard Builder is completely
    independant of Drools and jBPM and will be used by many projects at JBoss, and hopefully
    outside of JBoss :)</p><p>UberFire is the new base workbench project, spun off from the ground up rewrite. UberFire
    provides Eclipse-like workbench capabilities, with panels and perspectives from plugins. The
    project is independant of Drools and jBPM and anyone can use it as a basis of building
    flexible and powerful workbenches. UberFire will be used for console and workbench development
    throughout JBoss.</p><p>It was determined that the Guvnor brand leaked too much from its intended role; such as the authoring
    metaphors, like Decision Tables, being considered Guvnor components instead of Drools components. This wasn't
    helped by the monolithic projects structure used in 5.x for Guvnor. In 6.0 Guvnor's focus has been narrowed to
    encapsulate the set of UberFire plugins that provide the basis for building a web based IDE. Such as Maven
    integration for building and deploying, management of Maven repositories and activity notifications via inboxes.
    Drools and jBPM build workbench distributions using Uberfire as the base and including a set of plugins, such as
    Guvnor, along with their own plugins for things like decision tables, guided editors, BPMN2 designer, human tasks.
    The Drools workbench is called Drools-WB. KIE-WB is the uber workbench that combined all the Guvnor, Drools and jBPM
    plugins. The jBPM-WB is ghosted out, as it doesn't actually exist, being made redundant by KIE-WB.</p><p/></div><div class="section" title="4.1.2. Lifecycles"><div class="titlepage"><div><div><h3 class="title"><a id="KIELifeCyclesSection"/>4.1.2. Lifecycles</h3></div></div></div><p>The different aspects, or life cycles, of working with KIE system, whether it's Drools or
    jBPM, can typically be broken down into the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>Author</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Authoring of knowledge using a UI metaphor, such as: DRL, BPMN2, decision table,
              class models.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Build</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Builds the authored knowledge into deployable units. </p></li><li class="listitem"><p>For KIE this unit is a JAR.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Test</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Test KIE knowedge before it's deployed to the application.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Deploy</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Deploys the unit to a location where applications may utilize (consume)
            them.</p></li><li class="listitem"><p>KIE uses Maven style repository.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Utilize</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The loading of a JAR to provide a KIE session (KieSession), for which the
            application can interact with.</p></li><li class="listitem"><p>KIE exposes the JAR at runtime via a KIE container (KieContainer).</p></li><li class="listitem"><p>KieSessions, for the runtime's to interact with, are created from the
            KieContainer.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Run</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>System interaction with the KieSession, via API.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Work</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>User interaction with the KieSession, via command line or UI.</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Manage</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Manage any KieSession or KieContainer.</p></li></ul></div></li></ul></div></div></div><div class="section" title="4.2. Build, Deploy, Utilize and Run"><div class="titlepage"><div><div><h2 class="title"><a id="BuildDeployUtilizeAndRunSection"/>4.2. Build, Deploy, Utilize and Run</h2></div></div></div><div class="section" title="4.2.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="KIEModuleIntroductionBuildingIntroductionSection"/>4.2.1. Introduction</h3></div></div></div><p>6.0 introduces a new configuration and convention approach to building knowledge bases,
    instead of using the programmatic builder approach in 5.x. The builder is still
    available to fall back on, as it's used for the tooling integration.</p><p>Building now uses Maven, and aligns with Maven practices. A KIE project or module is simply
    a Maven Java project or module; with an additional metadata file META-INF/kmodule.xml. The
    kmodule.xml file is the descriptor that selects resources to knowledge bases and configures
    those knowledge bases and sessions. There is also alternative XML support via Spring and OSGi
    BluePrints.</p><p>While standard Maven can build and package KIE resources, it will not provide validation at
    build time. There is a Maven plugin which is recommended to use to get build time validation. The
    plugin also generates many classes, making the runtime loading faster too.</p><p>The example project layout and Maven POM descriptor is illustrated in the screenshot</p><div class="figure"><a id="d0e2327"/><p class="title"><strong>Figure 4.2. Example project layout and Maven POM</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/defaultkiesession.png" alt="Example project layout and Maven POM"/></div></div></div></div><br class="figure-break"/><p>KIE uses defaults to minimise the amount of configuration. With an empty kmodule.xml being
    the simplest configuration. There must always be a kmodule.xml file, even if empty, as it's used
    for discovery of the JAR and its contents.</p><p>Maven can either 'mvn install' to deploy a KieModule to the local machine, where all other
    applications on the local machine use it. Or it can 'mvn deploy' to push the KieModule to a
    remote Maven repository. Building the Application will pull in the KieModule and populate the
    local Maven repository in the process.</p><div class="figure"><a id="d0e2338"/><p class="title"><strong>Figure 4.3. Example project layout and Maven POM</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/maven.png" alt="Example project layout and Maven POM"/></div></div></div></div><br class="figure-break"/><p>JARs can be deployed in one of two ways. Either added to the classpath, like any other JAR
    in a Maven dependency listing, or they can be dynamically loaded at runtime. KIE will scan the
    classpath to find all the JARs with a kmodule.xml in it. Each found JAR is represented by the
    KieModule interface. The terms classpath KieModule and dynamic KieModule are used to refer to the
    two loading approaches. While dynamic modules supports side by side versioning, classpath
    modules do not. Further once a module is on the classpath, no other version may be loaded
    dynamically.</p><p>Detailed references for the API are included in the next sections, the impatient can jump
    straight to the examples section, which is fairly self-explanatory on the different use cases.</p></div><div class="section" title="4.2.2. Building"><div class="titlepage"><div><div><h3 class="title"><a id="KIEBuildingSection"/>4.2.2. Building</h3></div></div></div><div class="figure"><a id="d0e2352"/><p class="title"><strong>Figure 4.4. org.kie.api.core.builder</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/builder.png" alt="org.kie.api.core.builder"/></div></div></div><br class="figure-break"/><div class="section" title="4.2.2.1. Creating and building a Kie Project"><div class="titlepage"><div><div><h4 class="title"><a id="creatingAndBuildingAKieProject"/>4.2.2.1. Creating and building a Kie Project</h4></div></div></div><p>A Kie Project has the structure of a normal Maven project with the only peculiarity
    of including a kmodule.xml file defining in a declaratively way the <code class="code">KieBase</code>s
    and <code class="code">KieSession</code>s that can be created from it. This file has to be placed in the
    resources/META-INF folder of the Maven project while all the other Kie artifacts, such as
    DRL or a Excel files, must be stored in the resources folder or in any other subfolder under it.</p><p>Since meaningful defaults have been provided for all configuration aspects, the simplest
    kmodule.xml file can contain just an empty kmodule tag like the following:</p><div class="example"><a id="d0e2372"/><p class="title"><strong>Example 4.1. An empty kmodule.xml file</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"/&gt;</code></pre></div></div><br class="example-break"/><p>In this way the kmodule will contain one single default <code class="code">KieBase</code>. All Kie
      assets stored under the resources folder, or any of its subfolders, will be compiled and added
      to it. To trigger the building of these artifacts it is enough to create a
        <code class="code">KieContainer</code> for them.</p><div class="figure"><a id="d0e2385"/><p class="title"><strong>Figure 4.5. KieContainer</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieContainer.png" alt="KieContainer"/></div></div></div><br class="figure-break"/><p>For this simple case it is enough to create a <code class="code">KieContainer</code> that reads the
      files to be built from the classpath:</p><div class="example"><a id="d0e2396"/><p class="title"><strong>Example 4.2. Creating a KieContainer from the classpath</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();</code></pre></div></div><br class="example-break"/><p><code class="code">KieServices</code> is the interface from where it possible to access all the Kie
      building and runtime facilities:</p><div class="figure"><a id="d0e2405"/><p class="title"><strong>Figure 4.6. KieServices</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieServices.png" alt="KieServices"/></div></div></div><br class="figure-break"/><p>In this way all the Java sources and the Kie resources are compiled and deployed into
    the KieContainer which makes its contents available for use at runtime.</p></div><div class="section" title="4.2.2.2. The kmodule.xml file"><div class="titlepage"><div><div><h4 class="title"><a id="theKmoduleXmlFile"/>4.2.2.2. The kmodule.xml file</h4></div></div></div><p>As explained in the former section, the kmodule.xml file is the place where it is possible
    to declaratively configure the <code class="code">KieBase</code>(s) and <code class="code">KieSession</code>(s) that can be
    created from a KIE project.</p><p>In particular a <code class="code">KieBase</code> is a repository of all the application's knowledge definitions.
    It will contain rules, processes, functions, and type models. The <code class="code">KieBase</code> itself does not contain
    data; instead, sessions are created from the <code class="code">KieBase</code> into which data can be inserted and from
    which process instances may be started. Creating the <code class="code">KieBase</code> can be heavy, whereas session
    creation is very light, so it is recommended that <code class="code">KieBase</code> be cached where possible to allow
    for repeated session creation. However end-users usually shouldn't worry about it, because this caching
    mechanism is already automatically provided by the <code class="code">KieContainer</code>.</p><div class="figure"><a id="d0e2444"/><p class="title"><strong>Figure 4.7. KieBase</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBase.png" alt="KieBase"/></div></div></div><br class="figure-break"/><p>Conversely the <code class="code">KieSession</code> stores and executes on the runtime data.
    It is created from the <code class="code">KieBase</code> or more easily can be created directly from the
    <code class="code">KieContainer</code> if it has been defined in the kmodule.xml file</p><div class="figure"><a id="d0e2461"/><p class="title"><strong>Figure 4.8. KieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieSession.png" alt="KieSession"/></div></div></div><br class="figure-break"/><p>The kmodule.xml allows to define and configure one or more <code class="code">KieBase</code>s and for each
    <code class="code">KieBase</code> all the different <code class="code">KieSession</code>s that can be created from it,
    as showed by the follwing example:</p><div class="example"><a id="d0e2478"/><p class="title"><strong>Example 4.3. A sample kmodule.xml file</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;configuration&gt;
    &lt;property key="drools.evaluator.supersetOf" value="org.mycompany.SupersetOfEvaluatorDefinition"/&gt;
  &lt;/configuration&gt;
  &lt;kbase name="KBase1" default="true" eventProcessingMode="cloud" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg1"&gt;
    &lt;ksession name="KSession2_1" type="stateful" default="true"/&gt;
    &lt;ksession name="KSession2_2" type="stateless" default="false" beliefSystem="jtms"/&gt;
  &lt;/kbase&gt;
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    &lt;ksession name="KSession3_1" type="stateful" default="false" clockType="realtime"&gt;
      &lt;fileLogger file="drools.log" threaded="true" interval="10"/&gt;
      &lt;workItemHandlers&gt;
        &lt;workItemHandler name="name" type="org.domain.WorkItemHandler"/&gt;
      &lt;/workItemHandlers&gt;
      &lt;listeners&gt;
        &lt;ruleRuntimeEventListener type="org.domain.RuleRuntimeListener"/&gt;
        &lt;agendaEventListener type="org.domain.FirstAgendaListener"/&gt;
        &lt;agendaEventListener type="org.domain.SecondAgendaListener"/&gt;
        &lt;processEventListener type="org.domain.ProcessListener"/&gt;
      &lt;/listeners&gt;
    &lt;/ksession&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></div><br class="example-break"/><p>Here the &lt;configuration&gt; tag contains a list of key-value pairs that are the optional properties
    used to configure the <code class="code">KieBase</code>s building process. For instance this sample kmodule.xml file defines
    an additional custom operator named <code class="code">supersetOf</code> and implemented by the
    <code class="code">org.mycompany.SupersetOfEvaluatorDefinition</code> class.</p><p>After this 2 <code class="code">KieBase</code>s have been defined and it is possible to instance 2 different types of
    <code class="code">KieSession</code>s from the first one, while only one from the second. A list of the attributes that
    can be defined on the kbase tag, together with their meaning and default values follows:</p><div class="table"><a id="d0e2502"/><p class="title"><strong>Table 4.1. kbase Attributes</strong></p><div class="table-contents"><table summary="kbase Attributes" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th align="center">Attribute name</th><th align="center">Default value</th><th align="center">Admitted values</th><th align="center">Meaning</th></tr></thead><tbody><tr><td>name</td><td>none</td><td>any</td><td>The name with which retrieve this KieBase from the KieContainer.
            This is the only mandatory attribute.</td></tr><tr><td>includes</td><td>none</td><td>any comma separated list</td><td>A comma separated list of other KieBases contained in this kmodule.
            The artifacts of all these KieBases will be also included in this one.</td></tr><tr><td>packages</td><td>all</td><td>any comma separated list</td><td>By default all the Drools artifacts under the resources folder,
            at any level, are included into the KieBase. This attribute allows to limit
            the artifacts that will be compiled in this KieBase to only the ones
            belonging to the list of packages.</td></tr><tr><td>default</td><td>false</td><td>true, false</td><td>Defines if this KieBase is the default one for this module, so
            it can be created from the KieContainer without passing any name to it.
            There can be at most one default KieBase in each module.</td></tr><tr><td>equalsBehavior</td><td>identity</td><td>identity, equality</td><td>Defines the behavior of Drools when a new fact is inserted into the
            Working Memory. With identity it always create a new FactHandle unless the same
            object isn't already present in the Working Memory, while with equality only if
            the newly inserted object is not equal (according to its equal method) to an already
            existing fact.</td></tr><tr><td>eventProcessingMode</td><td>cloud</td><td>cloud, stream</td><td>When compiled in cloud mode the KieBase treats events as normal facts, while
            in stream mode allow temporal reasoning on them.</td></tr><tr><td>declarativeAgenda</td><td>disabled</td><td>disabled, enabled</td><td>Defines if the Declarative Agenda is enabled or not.</td></tr></tbody></table></div></div><br class="table-break"/><p>Similarly all attributes of the ksession tag (except of course the name)
    have meaningful default. They are listed and described in the following table:</p><div class="table"><a id="d0e2582"/><p class="title"><strong>Table 4.2. ksession Attributes</strong></p><div class="table-contents"><table summary="ksession Attributes" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th align="center">Attribute name</th><th align="center">Default value</th><th align="center">Admitted values</th><th align="center">Meaning</th></tr></thead><tbody><tr><td>name</td><td>none</td><td>any</td><td>Unique name of this KieSession. Used to fetch the KieSession from the KieContainer.
            This is the only mandatory attribute.</td></tr><tr><td>type</td><td>stateful</td><td>stateful, stateless</td><td>A stateful session allows to iteratively work with the Working Memory,
            while a stateless one is a one-off execution of a Working Memory with a provided data set.</td></tr><tr><td>default</td><td>false</td><td>true, false</td><td>Defines if this KieSession is the default one for this module, so
            it can be created from the KieContainer without passing any name to it.
            In each module there can be at most one default KieSession for each type.</td></tr><tr><td>clockType</td><td>realtime</td><td>realtime, pseudo</td><td>Defines if events timestamps are determined by the system clock or by
            a psuedo clock controlled by the application. This clock is specially useful for
            unit testing temporal rules.</td></tr><tr><td>beliefSystem</td><td>simple</td><td>simple, jtms, defeasible</td><td>Defines the type of belief system used by the KieSession.</td></tr></tbody></table></div></div><br class="table-break"/><p>As outlined in the former kmodule.xml sample, it is also possible to declaratively
    create on each <code class="code">KieSession</code> a file (or a console) logger, one or more
    <code class="code">WorkItemHandler</code>s and some listeners that can be of 3 different types:
    ruleRuntimeEventListener, agendaEventListener and processEventListener</p><p>Having defined a kmodule.xml like the one in the former sample, it is now possible
    to simply retrieve the KieBases and KieSessions from the KieContainer using their names.</p><div class="example"><a id="d0e2652"/><p class="title"><strong>Example 4.4. Retriving KieBases and KieSessions from the KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();

KieBase kBase1 = kContainer.getKieBase("KBase1");
KieSession kieSession1 = kContainer.newKieSession("KSession2_1");
StatelessKieSession kieSession2 = kContainer.newStatelessKieSession("KSession2_2");</code></pre></div></div><br class="example-break"/><p>It has to be noted that since KSession2_1 and KSession2_2 are of 2 different types
    (the first is stateful, while the second is stateless) it is necessary to invoke 2 different methods on the
    <code class="code">KieContainer</code> according to their declared type. If the type of the <code class="code">KieSession</code>
    requested to the <code class="code">KieContainer</code> doesn't correspond with the one declared in the
    kmodule.xml file the <code class="code">KieContainer</code> will throw a <code class="code">RuntimeException</code>.
    Also since a <code class="code">KieBase</code> and a <code class="code">KieSession</code> have been flagged as default
    is it possible to get them from the <code class="code">KieContainer</code> without passing any name.</p><div class="example"><a id="d0e2683"/><p class="title"><strong>Example 4.5. Retriving default KieBases and KieSessions from the KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieContainer kContainer = ...

KieBase kBase1 = kContainer.getKieBase(); // returns KBase1
KieSession kieSession1 = kContainer.newKieSession(); // returns KSession2_1</code></pre></div></div><br class="example-break"/><p>Since a Kie project is also a Maven project the groupId, artifactId and version declared
    in the pom.xml file are used to generate a <code class="code">ReleaseId</code> that uniquely identifies
    this project inside your application. This allows creation of a new KieContainer from the
    project by simply passing its <code class="code">ReleaseId</code> to the <code class="code">KieServices</code>.</p><div class="example"><a id="d0e2699"/><p class="title"><strong>Example 4.6. Creating a KieContainer of an existing project by ReleaseId</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "myartifact", "1.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.2.3. Building with Maven"><div class="titlepage"><div><div><h4 class="title"><a id="buildingWithMaven"/>4.2.2.3. Building with Maven</h4></div></div></div><p>
      The KIE plugin for Maven ensures that artifact resources are validated and pre-compiled, it is recommended
      that this is used at all times. To use the plugin simply add it to the build
      section of the Maven pom.xml and activate it by using packaging <code class="code">kjar</code>.
     </p><div class="example"><a id="d0e2712"/><p class="title"><strong>Example 4.7. Adding the KIE plugin to a Maven pom.xml and activating it</strong></p><div class="example-contents"><pre><code class="language-xml">
  &lt;packaging&gt;kjar&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.kie&lt;/groupId&gt;
        &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;6.5.0.Final&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;        
      </code></pre></div></div><br class="example-break"/><p>The plugin comes with support for all the Drools/jBPM knowledge resources.
      However, in case you are using specific KIE annotations in your Java classes, like for example <code class="code">@kie.api.Position</code>, you will
      need to add compile time dependency on <code class="code">kie-api</code> into your project. We recommend to use the provided scope
      for all the additional KIE dependencies. That way the kjar stays as lightweight as possible, and not dependant
      on any particular KIE version.
    </p><p>Building a KIE module without the Maven plugin will copy all the resources, as is, into the resulting JAR.
      When that JAR is loaded by the runtime, it will attempt to build all the resources then. If there are compilation
      issues it will return a null KieContainer. It also pushes the compilation overhead to the runtime. In general this
      is not recommended, and the Maven plugin should always be used. </p></div><div class="section" title="4.2.2.4. Defining a KieModule programmatically"><div class="titlepage"><div><div><h4 class="title"><a id="definingAKieModuleProgrammatically"/>4.2.2.4. Defining a KieModule programmatically</h4></div></div></div><p>It is also possible to define the <code class="code">KieBase</code>s and <code class="code">KieSession</code>s
    belonging to a KieModule programmatically instead of the declarative definition in the
    kmodule.xml file. The same programmatic API also allows in explicitly adding the file containing the
    Kie artifacts instead of automatically read them from the resources folder of your project.
    To do that it is necessary to create a <code class="code">KieFileSystem</code>, a sort of virtual file
    system, and add all the resources contained in your project to it.</p><div class="figure"><a id="d0e2741"/><p class="title"><strong>Figure 4.9. KieFileSystem</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieFileSystem.png" alt="KieFileSystem"/></div></div></div><br class="figure-break"/><p>Like all other Kie core components you can obtain an instance of the <code class="code">KieFileSystem</code> from
    the <code class="code">KieServices</code>. The kmodule.xml configuration file must be added to the filesystem. This is a
    mandatory step. Kie also provides a convenient fluent API, implemented by the <code class="code">KieModuleModel</code>,
      to programmatically create this file.</p><div class="figure"><a id="d0e2758"/><p class="title"><strong>Figure 4.10. KieModuleModel</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieModuleModel.png" alt="KieModuleModel"/></div></div></div><br class="figure-break"/><p>To do this in practice it is necessary to create a <code class="code">KieModuleModel</code> from the
    <code class="code">KieServices</code>, configure it with the desired <code class="code">KieBase</code>s and
    <code class="code">KieSession</code>s, convert it in XML and add the XML to the <code class="code">KieFileSystem</code>.
    This process is shown by the following example:</p><div class="example"><a id="d0e2781"/><p class="title"><strong>Example 4.8. Creating a kmodule.xml programmatically and adding it to a KieFileSystem</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieModuleModel kieModuleModel = kieServices.newKieModuleModel();

KieBaseModel kieBaseModel1 = kieModuleModel.newKieBaseModel( "KBase1 ")
        .setDefault( true )
        .setEqualsBehavior( EqualityBehaviorOption.EQUALITY )
        .setEventProcessingMode( EventProcessingOption.STREAM );

KieSessionModel ksessionModel1 = kieBaseModel1.newKieSessionModel( "KSession1" )
        .setDefault( true )
        .setType( KieSessionModel.KieSessionType.STATEFUL )
        .setClockType( ClockTypeOption.get("realtime") );

KieFileSystem kfs = kieServices.newKieFileSystem();
kfs.writeKModuleXML(kieModuleModel.toXML());</code></pre></div></div><br class="example-break"/><p>At this point it is also necessary to add to the <code class="code">KieFileSystem</code>, through its
    fluent API, all others Kie artifacts composing your project. These artifacts have to be added
    in the same position of a corresponding usual Maven project.</p><div class="example"><a id="d0e2791"/><p class="title"><strong>Example 4.9. Adding Kie artifacts to a KieFileSystem</strong></p><div class="example-contents"><pre><code class="language-java">KieFileSystem kfs = ...
kfs.write( "src/main/resources/KBase1/ruleSet1.drl", stringContainingAValidDRL )
        .write( "src/main/resources/dtable.xls",
                kieServices.getResources().newInputStreamResource( dtableFileStream ) );</code></pre></div></div><br class="example-break"/><p>This example shows that it is possible to add the Kie artifacts both as plain Strings and
    as <code class="code">Resource</code>s. In the latter case the <code class="code">Resource</code>s can be created by the
    <code class="code">KieResources</code> factory, also provided by the <code class="code">KieServices</code>. The
    <code class="code">KieResources</code> provides many convenient factory methods to convert an <code class="code">InputStream</code>,
    a <code class="code">URL</code>, a <code class="code">File</code>, or a <code class="code">String</code> representing a path of your file
    system to a <code class="code">Resource</code> that can be managed by the <code class="code">KieFileSystem</code>.</p><div class="figure"><a id="d0e2831"/><p class="title"><strong>Figure 4.11. KieResources</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieResources.png" alt="KieResources"/></div></div></div><br class="figure-break"/><p>Normally the type of a <code class="code">Resource</code> can be inferred from the extension of the name
    used to add it to the <code class="code">KieFileSystem</code>. However it also possible to not follow the Kie
    conventions about file extensions and explicitly assign a specific <code class="code">ResourceType</code>
    to a <code class="code">Resource</code> as shown below:</p><div class="example"><a id="d0e2851"/><p class="title"><strong>Example 4.10. Creating and adding a Resource with an explicit type</strong></p><div class="example-contents"><pre><code class="language-java">KieFileSystem kfs = ...
kfs.write( "src/main/resources/myDrl.txt",
           kieServices.getResources().newInputStreamResource( drlStream )
                      .setResourceType(ResourceType.DRL) );</code></pre></div></div><br class="example-break"/><p>Add all the resources to the <code class="code">KieFileSystem</code> and build it by passing the <code class="code">KieFileSystem</code>
    to a <code class="code">KieBuilder</code></p><div class="figure"><a id="d0e2866"/><p class="title"><strong>Figure 4.12. KieBuilder</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBuilder.png" alt="KieBuilder"/></div></div></div><br class="figure-break"/><p>When the contents of a <code class="code">KieFileSystem</code> are successfully built, the resulting <code class="code">KieModule</code>
    is automatically added to the <code class="code">KieRepository</code>.
    The <code class="code">KieRepository</code> is a singleton acting as a repository for all the available <code class="code">KieModule</code>s.</p><div class="figure"><a id="d0e2889"/><p class="title"><strong>Figure 4.13. KieRepository</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRepository.png" alt="KieRepository"/></div></div></div><br class="figure-break"/><p>After this it is possible to create through the <code class="code">KieServices</code> a new
    <code class="code">KieContainer</code> for that <code class="code">KieModule</code> using its <code class="code">ReleaseId</code>. However,
    since in this case the <code class="code">KieFileSystem</code> doesn't contain any pom.xml file (it is possible to
    add one using the <code class="code">KieFileSystem.writePomXML</code> method), Kie cannot determine the
    <code class="code">ReleaseId</code> of the <code class="code">KieModule</code> and assign to it a default one. This
    default <code class="code">ReleaseId</code> can be obtained from the <code class="code">KieRepository</code> and used
    to identify the <code class="code">KieModule</code> inside the <code class="code">KieRepository</code> itself.
    The following example shows this whole process.</p><div class="example"><a id="d0e2933"/><p class="title"><strong>Example 4.11. Building the contents of a KieFileSystem and creating a KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieFileSystem kfs = ...
kieServices.newKieBuilder( kfs ).buildAll();
KieContainer kieContainer = kieServices.newKieContainer(kieServices.getRepository().getDefaultReleaseId());</code></pre></div></div><br class="example-break"/><p>At this point it is possible to get <code class="code">KieBase</code>s and create new <code class="code">KieSession</code>s
    from this <code class="code">KieContainer</code> exactly in the same way as in the case of a <code class="code">KieContainer</code>
    created directly from the classpath.</p><p>It is a best practice to check the compilation results. The <code class="code">KieBuilder</code>
    reports compilation results of 3 different severities: ERROR, WARNING and INFO. An ERROR
    indicates that the compilation of the project failed and in the case no <code class="code">KieModule</code> is
    produced and nothing is added to the <code class="code">KieRepository</code>. WARNING and INFO results
    can be ignored, but are available for inspection.</p><div class="example"><a id="d0e2963"/><p class="title"><strong>Example 4.12. Checking that a compilation didn't produce any error</strong></p><div class="example-contents"><pre><code class="language-java">KieBuilder kieBuilder = kieServices.newKieBuilder( kfs ).buildAll();
assertEquals( 0, kieBuilder.getResults().getMessages( Message.Level.ERROR ).size() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.2.5. Changing the Default Build Result Severity"><div class="titlepage"><div><div><h4 class="title"><a id="changingTheDefaultBuildResultSeverity"/>4.2.2.5. Changing the Default Build Result Severity</h4></div></div></div><p>In some cases, it is possible to change the default severity of a
    type of build result. For instance, when a new rule with the same name
    of an existing rule is added to a package, the default behavior is to
    replace the old rule by the new rule and report it as an INFO. This is
    probably ideal for most use cases, but in some deployments the user
    might want to prevent the rule update and report it as an error.</p><p>Changing the default severity for a result type, configured
    like any other option in Drools, can be done by API
    calls, system properties or configuration files. As of this version,
    Drools supports configurable result severity for rule updates and function
    updates. To configure it using system properties or configuration files,
    the user has to use the following properties:</p><div class="example"><a id="d0e2975"/><p class="title"><strong>Example 4.13. Setting the severity using properties</strong></p><div class="example-contents"><pre><code class="no-highlight">// sets the severity of rule updates
drools.kbuilder.severity.duplicateRule = &lt;INFO|WARNING|ERROR&gt;
// sets the severity of function updates
drools.kbuilder.severity.duplicateFunction = &lt;INFO|WARNING|ERROR&gt;</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="4.2.3. Deploying"><div class="titlepage"><div><div><h3 class="title"><a id="KIEDeployingSection"/>4.2.3. Deploying</h3></div></div></div><div class="section" title="4.2.3.1. KieBase"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2984"/>4.2.3.1. KieBase</h4></div></div></div><p>The <code class="code">KieBase</code> is a repository of all the application's knowledge definitions. It will contain
      rules, processes, functions, and type models. The <code class="code">KieBase</code> itself does not contain data; instead,
      sessions are created from the <code class="code">KieBase</code> into which data can be inserted and from which process
      instances may be started. The <code class="code">KieBase</code> can be obtained from the <code class="code">KieContainer</code> containing
      the <code class="code">KieModule</code> where the <code class="code">KieBase</code> has been defined.</p><div class="figure"><a id="d0e3010"/><p class="title"><strong>Figure 4.14. KieBase</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBase.png" alt="KieBase"/></div></div></div><br class="figure-break"/><p>Sometimes, for instance in a OSGi environment, the <code class="code">KieBase</code> needs to resolve types that are not in
      the default class loader. In this case it will be necessary to create a <code class="code">KieBaseConfiguration</code> with an
      additional class loader and pass it to <code class="code">KieContainer</code> when creating a new <code class="code">KieBase</code> from
      it.</p><div class="example"><a id="d0e3030"/><p class="title"><strong>Example 4.14. Creating a new KieBase with a custom ClassLoader</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieBaseConfiguration kbaseConf = kieServices.newKieBaseConfiguration( null, MyType.class.getClassLoader() );
KieBase kbase = kieContainer.newKieBase( kbaseConf );</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.3.2. KieSessions and KieBase Modifications"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3035"/>4.2.3.2. KieSessions and KieBase Modifications</h4></div></div></div><p>KieSessions will be discussed in more detail in
    section "Running". The <code class="code">KieBase</code> creates and returns
    <code class="code">KieSession</code> objects, and it may optionally keep
    references to those. When <code class="code">KieBase</code> modifications occur
    those modifications are applied against the data in the sessions. This
    reference is a weak reference and it is also optional, which is controlled
    by a boolean flag.</p></div><div class="section" title="4.2.3.3. KieScanner"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3049"/>4.2.3.3. KieScanner</h4></div></div></div><p>The <code class="code">KieScanner</code> allows continuous monitoring of your Maven repository
    to check whether a new release of a Kie project has been installed. A new release is deployed in
    the <code class="code">KieContainer</code> wrapping that project. The use of the <code class="code">KieScanner</code>
    requires kie-ci.jar to be on the classpath.</p><div class="figure"><a id="d0e3063"/><p class="title"><strong>Figure 4.15. KieScanner</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieScanner.png" alt="KieScanner"/></div></div></div><br class="figure-break"/><p>A <code class="code">KieScanner</code> can be registered on a <code class="code">KieContainer</code>
    as in the following example.</p><div class="example"><a id="d0e3077"/><p class="title"><strong>Example 4.15. Registering and starting a KieScanner on a KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "myartifact", "1.0-SNAPSHOT" );
KieContainer kContainer = kieServices.newKieContainer( releaseId );
KieScanner kScanner = kieServices.newKieScanner( kContainer );

// Start the KieScanner polling the Maven repository every 10 seconds
kScanner.start( 10000L );</code></pre></div></div><br class="example-break"/><p>In this example the <code class="code">KieScanner</code> is configured to run with a fixed
    time interval, but it is also possible to run it on demand by invoking the
    <code class="code">scanNow()</code> method on it. If the <code class="code">KieScanner</code> finds, in the
    Maven repository, an updated version of the Kie project used by that <code class="code">KieContainer</code>
    it automatically downloads the new version and triggers an incremental build of the new
    project.
    At this point, existing <code class="code">KieBase</code>s and <code class="code">KieSession</code>s under the control of <code class="code">KieContainer</code>
    will get automatically upgraded with it - specifically, those <code class="code">KieBase</code>s obtained with <code class="code">getKieBase()</code>
    along with their related <code class="code">KieSession</code>s, and any <code class="code">KieSession</code> obtained directly with
    <code class="code">KieContainer.newKieSession()</code> thus referencing the default <code class="code">KieBase</code>.
    Additionally, from this moment on, all the new <code class="code">KieBase</code>s and <code class="code">KieSession</code>s
    created from that <code class="code">KieContainer</code> will use the new project version.
    Please notice however any existing <code class="code">KieBase</code> which was obtained via <code class="code">newKieBase()</code> before the
    KieScanner upgrade, and any of its related <code class="code">KieSession</code>s, will not get automatically upgraded; this is because
    <code class="code">KieBase</code>s obtained via <code class="code">newKieBase()</code> are not under the direct control of the <code class="code">KieContainer</code>.
    </p><p>The <code class="code">KieScanner</code> will only pickup changes to deployed jars if it is using a SNAPSHOT, version range,
    the LATEST, or the RELEASE setting. Fixed versions will not automatically update at runtime.</p></div><div class="section" title="4.2.3.4. Maven Versions and Dependencies"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3155"/>4.2.3.4. Maven Versions and Dependencies</h4></div></div></div><p>Maven supports a number of mechanisms to manage versioning and dependencies within applications. Modules can
      be published with specific version numbers, or they can use the SNAPSHOT suffix. Dependencies can specify version
      ranges to consume, or take avantage of SNAPSHOT mechanism.</p><p>StackOverflow provides a very good description for this, which is reproduced below.</p><p><a class="link" href="http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency"> http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency
      </a></p><p>If you always want to use the newest version, Maven has two keywords you can use as an alternative to version
      ranges. You should use these options with care as you are no longer in control of the plugins/dependencies you are
      using. </p><p>When you depend on a plugin or a dependency, you can use the a version value of LATEST or RELEASE. LATEST
      refers to the latest released or snapshot version of a particular artifact, the most recently deployed artifact in
      a particular repository. RELEASE refers to the last non-snapshot release in the repository. In general, it is not
      a best practice to design software which depends on a non-specific version of an artifact. If you are developing
      software, you might want to use RELEASE or LATEST as a convenience so that you don't have to update version
      numbers when a new release of a third-party library is released. When you release software, you should always make
      sure that your project depends on specific versions to reduce the chances of your build or your project being
      affected by a software release not under your control. Use LATEST and RELEASE with caution, if at all. </p><p>See the POM Syntax section of the Maven book for more details. </p><p><a class="link" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html </a></p><p><a class="link" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html</a></p><p>Here's an example illustrating the various options. In the Maven repository, com.foo:my-foo has the following
      metadata:</p><pre><code class="language-xml">&lt;metadata&gt;
  &lt;groupId&gt;com.foo&lt;/groupId&gt;
  &lt;artifactId&gt;my-foo&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;versioning&gt;
    &lt;release&gt;1.1.1&lt;/release&gt;
    &lt;versions&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;version&gt;1.0.1&lt;/version&gt;
      &lt;version&gt;1.1&lt;/version&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
      &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/versions&gt;
    &lt;lastUpdated&gt;20090722140000&lt;/lastUpdated&gt;
  &lt;/versioning&gt;
&lt;/metadata&gt;</code></pre><p>If a dependency on that artifact is required, you have the following options (other version ranges can be
      specified of course, just showing the relevant ones here): Declare an exact version (will always resolve to
      1.0.1): </p><pre><code class="no-highlight">&lt;version&gt;[1.0.1]&lt;/version&gt;</code></pre><p> Declare an explicit version (will
      always resolve to 1.0.1 unless a collision occurs, when Maven will select a matching version):
      </p><pre><code class="no-highlight">&lt;version&gt;1.0.1&lt;/version&gt;</code></pre><p> Declare a version range for all 1.x (will
      currently resolve to 1.1.1): </p><pre><code class="no-highlight">&lt;version&gt;[1.0.0,2.0.0)&lt;/version&gt;</code></pre><p> Declare
      an open-ended version range (will resolve to 2.0.0):
      </p><pre><code class="no-highlight">&lt;version&gt;[1.0.0,)&lt;/version&gt;</code></pre><p> Declare the version as LATEST (will
      resolve to 2.0.0): </p><pre><code class="no-highlight">&lt;version&gt;LATEST&lt;/version&gt;</code></pre><p> Declare the version as
      RELEASE (will resolve to 1.1.1): </p><pre><code class="no-highlight">&lt;version&gt;RELEASE&lt;/version&gt;</code></pre><p>Note that
      by default your own deployments will update the "latest" entry in the Maven metadata, but to update the "release"
      entry, you need to activate the "release-profile" from the Maven super POM. You can do this with either
      "-Prelease-profile" or "-DperformRelease=true" </p></div><div class="section" title="4.2.3.5. Settings.xml and Remote Repository Setup"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3201"/>4.2.3.5. Settings.xml and Remote Repository Setup</h4></div></div></div><p>The maven settings.xml is used to configure Maven execution. Detailed instructions can be found at the Maven
      website:</p><p><a class="link" href="http://maven.apache.org/settings.html">http://maven.apache.org/settings.html</a></p><p>The settings.xml file can be located in 3 locations, the actual settings used is a merge of those 3
      locations.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Maven install: <code class="literal">$M2_HOME/conf/settings.xml</code></p></li><li class="listitem"><p>A user's install: <code class="literal">${user.home}/.m2/settings.xml</code></p></li><li class="listitem"><p>Folder location specified by the system property <code class="literal">kie.maven.settings.custom</code></p></li></ul></div><p>The settings.xml is used to specify the location of remote repositories. It is important that you activate the
      profile that specifies the remote repository, typically this can be done using "activeByDefault":</p><pre><code class="language-xml">&lt;profiles&gt;
  &lt;profile&gt;
    &lt;id&gt;profile-1&lt;/id&gt;
    &lt;activation&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;
    ...
  &lt;/profile&gt;
&lt;/profiles&gt;
    </code></pre><p>Maven provides detailed documentation on using multiple remote repositories:</p><p><a class="link" href="http://maven.apache.org/guides/mini/guide-multiple-repositories.html">http://maven.apache.org/guides/mini/guide-multiple-repositories.html</a></p></div></div><div class="section" title="4.2.4. Running"><div class="titlepage"><div><div><h3 class="title"><a id="KIERunningSection"/>4.2.4. Running</h3></div></div></div><p/><div class="section" title="4.2.4.1. KieBase"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3240"/>4.2.4.1. KieBase</h4></div></div></div><p>The <code class="code">KieBase</code> is a repository of all the
    application's knowledge definitions. It will contain rules, processes,
    functions, and type models. The <code class="code">KieBase</code> itself does not contain
    data; instead, sessions are created from the <code class="code">KieBase</code>
    into which data can be inserted and from which process instances may be
    started. The <code class="code">KieBase</code> can be obtained from the <code class="code">KieContainer</code>
    containing the <code class="code">KieModule</code> where the <code class="code">KieBase</code> has been defined.</p><div class="example"><a id="d0e3266"/><p class="title"><strong>Example 4.16. Getting a KieBase from a KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieBase kBase = kContainer.getKieBase();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.4.2. KieSession"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3271"/>4.2.4.2. KieSession</h4></div></div></div><p>The <code class="code">KieSession</code> stores and executes on the
    runtime data. It is created from the <code class="code">KieBase</code>.</p><div class="figure"><a id="d0e3282"/><p class="title"><strong>Figure 4.16. KieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieSession.png" alt="KieSession"/></div></div></div><br class="figure-break"/><div class="example"><a id="d0e3288"/><p class="title"><strong>Example 4.17. Create a KieSession from a KieBase</strong></p><div class="example-contents"><pre><code class="language-java">KieSession ksession = kbase.newKieSession();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.4.3. KieRuntime"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3293"/>4.2.4.3. KieRuntime</h4></div></div></div><div class="section" title="4.2.4.3.1. KieRuntime"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3296"/>4.2.4.3.1. KieRuntime</h5></div></div></div><p>The <code class="code">KieRuntime</code> provides methods that
      are applicable to both rules and processes, such as setting globals and
      registering channels. ("Exit point" is an obsolete synonym for "channel".)</p><div class="figure"><a id="d0e3304"/><p class="title"><strong>Figure 4.17. KieRuntime</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntime.png" alt="KieRuntime"/></div></div></div><br class="figure-break"/><div class="section" title="4.2.4.3.1.1. Globals"><div class="titlepage"><div><div><h6 class="title"><a id="d0e3310"/>4.2.4.3.1.1. Globals</h6></div></div></div><p>Globals are named objects that are made visible to the rule engine,
        but in a way that is fundamentally different from the one for facts:
        changes in the object backing a global do not trigger reevaluation of
        rules. Still, globals are useful for providing static information,
        as an object offering services that are used in the RHS of a rule, or
        as a means to return objects from the rule engine. When you use
        a global on the LHS of a rule, make sure it is immutable, or, at least,
        don't expect changes to have any effect on the behavior of your rules.</p><p>A global must be declared in a rules file, and then it needs to be
        backed up with a Java object.</p><pre><code class="no-highlight">global java.util.List list</code></pre><p>With the Knowledge Base now aware of the global identifier and
        its type, it is now possible to call <code class="code">ksession.setGlobal()</code>
        with the global's name and an object, for any session, to associate
        the object with the global. Failure to declare the global type and
        identifier in DRL code will result in an exception being thrown from
        this call.</p><pre><code class="language-java">List list = new ArrayList();
ksession.setGlobal("list", list);           </code></pre><p>Make sure to set any global before it is used in the evaluation
        of a rule. Failure to do so results in a <code class="code">NullPointerException</code>.</p></div></div></div><div class="section" title="4.2.4.4. Event Model"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3331"/>4.2.4.4. Event Model</h4></div></div></div><p>The event package provides means to be notified of rule engine
      events, including rules firing, objects being asserted, etc. This allows
      separation of logging and auditing activities from the
      main part of your application (and the rules).</p><p>The <code class="code">KieRuntimeEventManager</code> interface is
      implemented by the <code class="code">KieRuntime</code> which provides two
      interfaces, <code class="code">RuleRuntimeEventManager</code> and
      <code class="code">ProcessEventManager</code>. We will only cover the
      <code class="code">RuleRuntimeEventManager</code> here.</p><div class="figure"><a id="d0e3353"/><p class="title"><strong>Figure 4.18. KieRuntimeEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntimeEventManager.png" alt="KieRuntimeEventManager"/></div></div></div><br class="figure-break"/><p>The <code class="code">RuleRuntimeEventManager</code> allows for listeners to
      be added and removed, so that events for the working memory and the agenda
      can be listened to.</p><div class="figure"><a id="d0e3364"/><p class="title"><strong>Figure 4.19. RuleRuntimeEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/RuleRuntimeEventManager.png" alt="RuleRuntimeEventManager"/></div></div></div><br class="figure-break"/><p>The following code snippet shows how a simple agenda listener is
      declared and attached to a session. It will print matches after they
      have fired.</p><div class="example"><a id="d0e3372"/><p class="title"><strong>Example 4.18. Adding an AgendaEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DefaultAgendaEventListener() {
    public void afterMatchFired(AfterMatchFiredEvent event) {
        super.afterMatchFired( event );
        System.out.println( event );
    }
});</code></pre></div></div><br class="example-break"/><p>Drools also provides <code class="code">DebugRuleRuntimeEventListener</code>
      and <code class="code">DebugAgendaEventListener</code> which implement each method with
      a debug print statement. To print all Working Memory events, you add a
      listener like this:</p><div class="example"><a id="d0e3385"/><p class="title"><strong>Example 4.19. Adding a DebugRuleRuntimeEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DebugRuleRuntimeEventListener() );</code></pre></div></div><br class="example-break"/><p>All emitted events implement the <code class="code">KieRuntimeEvent</code>
    interface which can be used to retrieve the actual
    <code class="code">KnowlegeRuntime</code> the event originated from.</p><div class="figure"><a id="d0e3398"/><p class="title"><strong>Figure 4.20. KieRuntimeEvent</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntimeEvent.png" alt="KieRuntimeEvent"/></div></div></div><br class="figure-break"/><p>The events currently supported are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>MatchCreatedEvent</p></li><li class="listitem"><p>MatchCancelledEvent</p></li><li class="listitem"><p>BeforeMatchFiredEvent</p></li><li class="listitem"><p>AfterMatchFiredEvent</p></li><li class="listitem"><p>AgendaGroupPushedEvent</p></li><li class="listitem"><p>AgendaGroupPoppedEvent</p></li><li class="listitem"><p>ObjectInsertEvent</p></li><li class="listitem"><p>ObjectDeletedEvent</p></li><li class="listitem"><p>ObjectUpdatedEvent</p></li><li class="listitem"><p>ProcessCompletedEvent</p></li><li class="listitem"><p>ProcessNodeLeftEvent</p></li><li class="listitem"><p>ProcessNodeTriggeredEvent</p></li><li class="listitem"><p>ProcessStartEvent</p></li></ul></div></div><div class="section" title="4.2.4.5. KieRuntimeLogger"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3446"/>4.2.4.5. KieRuntimeLogger</h4></div></div></div><p>The KieRuntimeLogger uses the comprehensive event system in
    Drools to create an audit log that can be used to log the execution of an
    application for later inspection, using tools such as the Eclipse audit
    viewer.</p><div class="figure"><a id="d0e3451"/><p class="title"><strong>Figure 4.21. KieLoggers</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieLoggers.png" alt="KieLoggers"/></div></div></div><br class="figure-break"/><div class="example"><a id="d0e3457"/><p class="title"><strong>Example 4.20. FileLogger</strong></p><div class="example-contents"><pre><code class="language-java">KieRuntimeLogger logger =
  KieServices.Factory.get().getLoggers().newFileLogger(ksession, "logdir/mylogfile");
...
logger.close();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.4.6. Commands and the CommandExecutor"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3462"/>4.2.4.6. Commands and the CommandExecutor</h4></div></div></div><p>KIE has the concept of stateful or stateless sessions. Stateful sessions have already been
      covered, which use the standard KieRuntime, and can be worked with iteratively over time.
      Stateless is a one-off execution of a KieRuntime with a provided data set. It may return some
      results, with the session being disposed at the end, prohibiting further iterative
      interactions. You can think of stateless as treating an engine like a function call with
      optional return results.</p><p>The foundation for this is the <code class="code">CommandExecutor</code> interface, which both the
      stateful and stateless interfaces extend. This returns an
      <code class="code">ExecutionResults</code>:</p><div class="figure"><a id="d0e3475"/><p class="title"><strong>Figure 4.22. CommandExecutor</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/CommandExecutor.png" alt="CommandExecutor"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e3481"/><p class="title"><strong>Figure 4.23. ExecutionResults</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/ExecutionResults.png" alt="ExecutionResults"/></div></div></div><br class="figure-break"/><p>The <code class="code">CommandExecutor</code> allows for commands to be executed on those sessions, the
      only difference being that the StatelessKieSession executes <code class="code">fireAllRules()</code> at the
      end before disposing the session.  The commands can be created using the
        <code class="code">CommandExecutor</code> .The Javadocs provide the full list of the allowed comands
      using the <code class="code">CommandExecutor</code>.</p><p>setGlobal and getGlobal are two commands relevant to both Drools and jBPM. </p><p>Set Global calls setGlobal underneath. The optional boolean indicates whether the
      command should return the global's value as part of the <code class="code">ExecutionResults</code>. If true it uses the
      same name as the global name. A String can be used instead of the boolean, if an alternative
      name is desired.</p><p>
      </p><div class="example"><a id="d0e3510"/><p class="title"><strong>Example 4.21. Set Global Command</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
    ksession.execute( CommandFactory.newSetGlobal( "stilton", new Cheese( "stilton" ), true);
Cheese stilton = bresults.getValue( "stilton" );
</code></pre></div></div><p><br class="example-break"/>
    </p><p>Allows an existing global to be returned. The second optional String argument allows for
      an alternative return name.</p><div class="example"><a id="d0e3518"/><p class="title"><strong>Example 4.22. Get Global Command</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
    ksession.execute( CommandFactory.getGlobal( "stilton" );
Cheese stilton = bresults.getValue( "stilton" );
</code></pre></div></div><br class="example-break"/><p>All the above examples execute single commands.  The <code class="code">BatchExecution</code>
      represents a composite command, created from a list of commands. It will iterate over the list
      and execute each command in turn. This means you can insert some objects, start a process,
      call fireAllRules and execute a query, all in a single <code class="code">execute(...)</code> call, which
      is quite powerful.</p><p>The StatelessKieSession will execute <code class="code">fireAllRules()</code> automatically at the end.
      However the keen-eyed reader probably has already noticed the <code class="code">FireAllRules</code>
      command and wondered how that works with a StatelessKieSession. The <code class="code">FireAllRules</code>
      command is allowed, and using it will disable the automatic execution at the end; think of
      using it as a sort of manual override function.</p><p>Any command, in the batch, that has an out identifier set will add its results to the
      returned <code class="code">ExecutionResults</code> instance. Let's look at a simple example to see how
      this works. The example presented includes command from the Drools and jBPM, for the sake of
      illustration. They are covered in more detail in the Drool and jBPM specific sections.</p><div class="example"><a id="d0e3547"/><p class="title"><strong>Example 4.23. BatchExecution Command</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();

List cmds = new ArrayList();
cmds.add( CommandFactory.newInsertObject( new Cheese( "stilton", 1), "stilton") );
cmds.add( CommandFactory.newStartProcess( "process cheeses" ) );
cmds.add( CommandFactory.newQuery( "cheeses" ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( "stilton" );
QueryResults qresults = ( QueryResults ) bresults.getValue( "cheeses" );
</code></pre></div></div><br class="example-break"/><p>In the above example multiple commands are executed, two of which populate the
        <code class="code">ExecutionResults</code>. The query command defaults to use the same identifier as the
      query name, but it can also be mapped to a different identifier.</p><p>All commands support XML and jSON marshalling using XStream, as well as JAXB marshalling.
      This is covered in section <a class="link" href="ch11.html#CommandsAPISection" title="11.1. API">Commands API</a>.
    </p></div><div class="section" title="4.2.4.7. StatelessKieSession"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3562"/>4.2.4.7. StatelessKieSession</h4></div></div></div><p>The <code class="code">StatelessKieSession</code> wraps the
    <code class="code">KieSession</code>, instead of extending it. Its main
    focus is on the decision service type scenarios. It avoids the need to call
    <code class="code">dispose()</code>. Stateless sessions do not support iterative
    insertions and the method call <code class="code">fireAllRules()</code> from Java code;
    the act of calling <code class="code">execute()</code> is a single-shot method that
    will internally instantiate a <code class="code">KieSession</code>, add
    all the user data and execute user commands, call
    <code class="code">fireAllRules()</code>, and then call <code class="code">dispose()</code>. While
    the main way to work with this class is via the
    <code class="code">BatchExecution</code> (a subinterface of <code class="code">Command</code>) as
    supported by the <code class="code">CommandExecutor</code> interface, two convenience
    methods are provided for when simple object insertion is all that's
    required. The <code class="code">CommandExecutor</code> and <code class="code">BatchExecution</code>
    are talked about in detail in their own section.</p><div class="figure"><a id="d0e3606"/><p class="title"><strong>Figure 4.24. StatelessKieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/StatelessKieSession.png" alt="StatelessKieSession"/></div></div></div><br class="figure-break"/><p>Our simple example shows a stateless session executing a given
    collection of Java objects using the convenience API. It will iterate the
    collection, inserting each element in turn.</p><div class="example"><a id="d0e3614"/><p class="title"><strong>Example 4.24. Simple StatelessKieSession execution with a Collection</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute( collection );</code></pre></div></div><br class="example-break"/><p>If this was done as a single Command it would be as follows:</p><div class="example"><a id="d0e3621"/><p class="title"><strong>Example 4.25. Simple StatelessKieSession execution with InsertElements Command</strong></p><div class="example-contents"><pre><code class="language-java">ksession.execute( CommandFactory.newInsertElements( collection ) );  </code></pre></div></div><br class="example-break"/><p>If you wanted to insert the collection itself, and the collection's
    individual elements, then
    <code class="code">CommandFactory.newInsert(collection)</code> would do the job.</p><p>Methods of the <code class="code">CommandFactory</code> create the supported
    commands, all of which can be marshalled using XStream and the
    <code class="code">BatchExecutionHelper</code>. <code class="code">BatchExecutionHelper</code>
    provides details on the XML format as well as how to use Drools Pipeline
    to automate the marshalling of <code class="code">BatchExecution</code> and
    <code class="code">ExecutionResults</code>.</p><p><code class="code">StatelessKieSession</code> supports globals, scoped in a
    number of ways. We cover the non-command way first, as commands are
    scoped to a specific execution call. Globals can be resolved in three
    ways.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The StatelessKieSession method <code class="code">getGlobals()</code>
        returns a Globals instance which provides access to the session's
        globals. These are shared for <span class="emphasis"><em>all</em></span> execution
        calls. Exercise caution regarding mutable globals because execution
        calls can be executing simultaneously in different threads.</p><div class="example"><a id="d0e3662"/><p class="title"><strong>Example 4.26. Session scoped global</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.
ksession.execute( collection ); </code></pre></div></div><br class="example-break"/></li><li class="listitem"><p>Using a delegate is another way of global resolution. Assigning
        a value to a global (with <code class="code">setGlobal(String, Object)</code>)
        results in the value being stored in an internal collection mapping
        identifiers to values. Identifiers in this internal collection will
        have priority over any supplied delegate. Only if an identifier cannot
        be found in this internal collection, the delegate global (if any)
        will be used.</p></li><li class="listitem"><p>The third way of resolving globals is to have execution scoped
        globals. Here, a <code class="code">Command</code> to set a global is passed to the
        <code class="code">CommandExecutor</code>.</p></li></ul></div><p>The <code class="code">CommandExecutor</code> interface also offers the ability
    to export data via "out" parameters. Inserted facts, globals and query
    results can all be returned.</p><div class="example"><a id="d0e3687"/><p class="title"><strong>Example 4.27. Out identifiers</strong></p><div class="example-contents"><pre><code class="language-java">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.4.8. Marshalling"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3692"/>4.2.4.8. Marshalling</h4></div></div></div><p>The <code class="code">KieMarshallers</code> are used to marshal and unmarshal
    KieSessions.</p><div class="figure"><a id="d0e3700"/><p class="title"><strong>Figure 4.25. KieMarshallers</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieMarshallers.png" alt="KieMarshallers"/></div></div></div><br class="figure-break"/><p>An instance of the <code class="code">KieMarshallers</code> can be retrieved from the <code class="code">KieServices</code>.
    A simple example is shown below:</p><div class="example"><a id="d0e3714"/><p class="title"><strong>Example 4.28. Simple Marshaller Example</strong></p><div class="example-contents"><pre><code class="language-java">// ksession is the KieSession
// kbase is the KieBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = KieServices.Factory.get().getMarshallers().newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"/><p>However, with marshalling, you will need more flexibility when dealing
    with referenced user data. To achieve this use the
    <code class="code">ObjectMarshallingStrategy</code> interface. Two implementations are
    provided, but users can implement their own. The two supplied strategies
    are <code class="code">IdentityMarshallingStrategy</code> and
    <code class="code">SerializeMarshallingStrategy</code>.
    <code class="code">SerializeMarshallingStrategy</code> is the default, as shown in the
    example above, and it just calls the <code class="code">Serializable</code> or
    <code class="code">Externalizable</code> methods on a user instance.
    <code class="code">IdentityMarshallingStrategy</code> creates an integer id for
    each user object and stores them in a Map, while the id is written to the
    stream. When unmarshalling it accesses the
    <code class="code">IdentityMarshallingStrategy</code> map to retrieve the instance.
    This means that if you use the <code class="code">IdentityMarshallingStrategy</code>,
    it is stateful for the life of the Marshaller instance and will create ids
    and keep references to all objects that it attempts to marshal. Below is
    the code to use an Identity Marshalling Strategy.</p><div class="example"><a id="d0e3748"/><p class="title"><strong>Example 4.29. IdentityMarshallingStrategy</strong></p><div class="example-contents"><pre><code class="language-java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers()
ObjectMarshallingStrategy oms = kMarshallers.newIdentityMarshallingStrategy()
Marshaller marshaller =
        kMarshallers.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"/><p>Im most cases, a single strategy is insufficient. For added flexibility, the
    <code class="code">ObjectMarshallingStrategyAcceptor</code> interface can be used.
    This Marshaller has a chain of strategies,
    and while reading or writing a user object it iterates the
    strategies asking if they accept responsibility for marshalling the user
    object. One of the provided implementations is
    <code class="code">ClassFilterAcceptor</code>. This allows strings and wild cards to be
    used to match class names. The default is "*.*", so in the above example
    the Identity Marshalling Strategy is used which has a default "*.*"
    acceptor.</p><p>Assuming that we want to serialize all classes except for one given
    package, where we will use identity lookup, we could do the
    following:</p><div class="example"><a id="d0e3763"/><p class="title"><strong>Example 4.30. IdentityMarshallingStrategy with Acceptor</strong></p><div class="example-contents"><pre><code class="language-java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers()
ObjectMarshallingStrategyAcceptor identityAcceptor =
        kMarshallers.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStrategy =
        kMarshallers.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = kMarshallers.newSerializeMarshallingStrategy();
Marshaller marshaller =
        kMarshallers.newMarshaller( kbase,
                                    new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"/><p>Note that the acceptance checking order is in the natural order of
    the supplied elements.</p><p>Also note that if you are using scheduled matches (i.e. some
    of your rules use timers or calendars) they are marshallable only if,
    before you use it, you configure your KieSession to use a
    trackable timer job factory manager as follows:</p><div class="example"><a id="d0e3772"/><p class="title"><strong>Example 4.31. Configuring a trackable timer job factory manager</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption(TimerJobFactoryOption.get("trackable"));
KSession ksession = kbase.newKieSession(ksconf, null);</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.4.9. Persistence and Transactions"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3777"/>4.2.4.9. Persistence and Transactions</h4></div></div></div><p>Longterm out of the box persistence with Java Persistence API (JPA)
    is possible with Drools. It is necessary to have some implementation of the
    Java Transaction API (JTA) installed. For development purposes
    the Bitronix Transaction Manager is suggested, as it's simple to set up and
    works embedded, but for production use JBoss Transactions is
    recommended.</p><div class="example"><a id="d0e3782"/><p class="title"><strong>Example 4.32. Simple example using transactions</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
Environment env = kieServices.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
         Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );

// KieSessionConfiguration may be null, and a default will be used
KieSession ksession =
        kieServices.getStoreServices().newKieSession( kbase, null, env );
int sessionId = ksession.getId();

UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( "process1" );
ut.commit();</code></pre></div></div><br class="example-break"/><p>To use a JPA, the Environment must be set with both the
    <code class="code">EntityManagerFactory</code> and the <code class="code">TransactionManager</code>.
    If rollback occurs the ksession state is also rolled back, hence it is possible
    to continue to use it after a rollback. To load a previously persisted
    KieSession you'll need the id, as shown below:</p><div class="example"><a id="d0e3795"/><p class="title"><strong>Example 4.33. Loading a KieSession</strong></p><div class="example-contents"><pre><code class="language-java">KieSession ksession =
        kieServices.getStoreServices().loadKieSession( sessionId, kbase, null, env );</code></pre></div></div><br class="example-break"/><p>To enable persistence several classes must be added to your
    persistence.xml, as in the example below:</p><div class="example"><a id="d0e3802"/><p class="title"><strong>Example 4.34. Configuring JPA</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;persistence-unit name="org.drools.persistence.jpa" transaction-type="JTA"&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;
   &lt;class&gt;org.drools.persistence.info.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.info.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
         &lt;property name="hibernate.show_sql" value="true" /&gt;
         &lt;property name="hibernate.transaction.manager_lookup_class"
                      value="org.hibernate.transaction.BTMTransactionManagerLookup" /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre></div></div><br class="example-break"/><p>The jdbc JTA data source would have to be configured first. Bitronix
    provides a number of ways of doing this, and its documentation should be
    consulted for details. For a quick start, here is the programmatic
    approach:</p><div class="example"><a id="d0e3809"/><p class="title"><strong>Example 4.35. Configuring JTA DataSource</strong></p><div class="example-contents"><pre><code class="language-java">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( "jdbc/BitronixJTADataSource" );
ds.setClassName( "org.h2.jdbcx.JdbcDataSource" );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( "user", "sa" );
ds.getDriverProperties().put( "password", "sasa" );
ds.getDriverProperties().put( "URL", "jdbc:h2:mem:mydb" );
ds.init();
</code></pre></div></div><br class="example-break"/><p>Bitronix also provides a simple embedded JNDI service, ideal for
    testing. To use it, add a jndi.properties file to your META-INF folder and add the
    following line to it:</p><div class="example"><a id="d0e3816"/><p class="title"><strong>Example 4.36. JNDI properties</strong></p><div class="example-contents"><pre><code class="no-highlight">java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="4.2.5. Installation and Deployment Cheat Sheets"><div class="titlepage"><div><div><h3 class="title"><a id="KIEDeployCheatSheets"/>4.2.5. Installation and Deployment Cheat Sheets</h3></div></div></div><div class="figure"><a id="d0e3824"/><p class="title"><strong>Figure 4.26. Installation Overview</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/cheatsheet1.png" alt="Installation Overview"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e3830"/><p class="title"><strong>Figure 4.27. Deployment Overview</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/cheatsheet2.png" alt="Deployment Overview"/></div></div></div><br class="figure-break"/></div><div class="section" title="4.2.6. Build, Deploy and Utilize Examples"><div class="titlepage"><div><div><h3 class="title"><a id="KIEExamplesSection"/>4.2.6. Build,  Deploy and Utilize Examples</h3></div></div></div><p>The best way to learn the new build system is by example. The source project
    "drools-examples-api" contains a number of examples, and can be found at GitHub:</p><p><a class="link" href="https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api">https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api</a></p><p>Each example is described below, the order starts with the simplest (most of the options are defaulted) and working
    its way up to more complex use cases.</p><p>The Deploy use cases shown below all involve <code class="code">mvn install</code>. Remote deployment of JARs in
    Maven is well covered in Maven literature. Utilize refers to the initial act of loading the
    resources and providing access to the KIE runtimes. Where as Run refers to the act of
    interacting with those runtimes.</p><div class="section" title="4.2.6.1. Default KieSession"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3851"/>4.2.6.1. Default KieSession</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: default-kesession.</p></li><li class="listitem"><p>Summary: Empty kmodule.xml KieModule on the classpath that includes all resources in a
          single default KieBase. The example shows the retrieval of the default KieSession from
          the classpath.</p></li></ul></div><p>An empty kmodule.xml will produce a single KieBase that includes all files found under
      resources path, be it DRL, BPMN2, XLS etc. That single KieBase is the default and also
      includes a single default KieSession. Default means they can be created without knowing their
      names.</p><div class="example"><a id="d0e3863"/><p class="title"><strong>Example 4.37. Author - kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt; &lt;/kmodule&gt;
  </code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e3868"/><p class="title"><strong>Example 4.38. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>ks.getKieClasspathContainer() returns the KieContainer that contains the KieBases deployed
      onto the environment classpath. kContainer.newKieSession() creates the default KieSession.
      Notice that you no longer need to look up the KieBase, in order to create the KieSession. The
      KieSession knows which KieBase it's associated with, and use that, which in this case is the
      default KieBase.</p><div class="example"><a id="d0e3875"/><p class="title"><strong>Example 4.39. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">
KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();                
      </code></pre></div></div><br class="example-break"/><p/><p/></div><div class="section" title="4.2.6.2. Named KieSession"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3882"/>4.2.6.2. Named KieSession</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: named-kiesession.</p></li><li class="listitem"><p>Summary: kmodule.xml that has one named KieBase and one named KieSession. The examples
          shows the retrieval of the named KieSession from the classpath.</p></li></ul></div><p/><p>kmodule.xml will produce a single named KieBase, 'kbase1' that includes all files found
      under resources path, be it DRL, BPMN2, XLS etc. KieSession 'ksession1' is associated with
      that KieBase and can be created by name.</p><div class="example"><a id="d0e3895"/><p class="title"><strong>Example 4.40. Author - kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
    &lt;kbase name="kbase1"&gt;
        &lt;ksession name="ksession1"/&gt;
    &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e3900"/><p class="title"><strong>Example 4.41. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>ks.getKieClasspathContainer() returns the KieContainer that contains the KieBases deployed
      onto the environment classpath. This time the KieSession uses the name 'ksession1'. You do not
      need to lookup the KieBase first, as it knows which KieBase 'ksession1' is assocaited
      with.</p><div class="example"><a id="d0e3907"/><p class="title"><strong>Example 4.42. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.3. KieBase Inheritence"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3912"/>4.2.6.3. KieBase Inheritence</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: kiebase-inclusion.</p></li><li class="listitem"><p>Summary: 'kmodule.xml' demonstrates that one KieBase can include the resources from
          another KieBase, from another KieModule. In this case it inherits the named KieBase from
          the 'name-kiesession' example. The included KieBase can be from the current KieModule or
          any other KieModule that is in the pom.xml dependency list.</p></li></ul></div><p/><p>kmodule.xml will produce a single named KieBase, 'kbase2' that includes all files found
      under resources path, be it DRL, BPMN2, XLS etc. Further it will include all the resources
      found from the KieBase 'kbase1', due to the use of the 'includes' attribute. KieSession
      'ksession2' is associated with that KieBase and can be created by name.</p><div class="example"><a id="d0e3925"/><p class="title"><strong>Example 4.43. Author - kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kbase name="kbase2" includes="kbase1"&gt;
    &lt;ksession name="ksession2"/&gt;
&lt;/kbase&gt;</code></pre></div></div><br class="example-break"/><p>This example requires that the previous example, 'named-kiesession', is built and installed
      to the local Maven repository first. Once installed it can be included as a dependency, using
      the standard Maven &lt;dependencies&gt; element.</p><div class="example"><a id="d0e3932"/><p class="title"><strong>Example 4.44. Author - pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;kiebase-inclusion&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieBase Inclusion&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;named-kiesession&lt;/artifactId&gt;
      &lt;version&gt;6.0.0&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

&lt;/project&gt;</code></pre></div></div><br class="example-break"/><p>Once 'named-kiesession' is built and installed this example can be built and installed as
      normal. Again the act of installing, will force the unit tests to run, demonstrating the use
      case.</p><div class="example"><a id="d0e3939"/><p class="title"><strong>Example 4.45. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>ks.getKieClasspathContainer() returns the KieContainer that contains the KieBases deployed
      onto the environment classpath. This time the KieSession uses the name 'ksession2'. You do not
      need to lookup the KieBase first, as it knows which KieBase 'ksession1' is assocaited with.
      Notice two rules fire this time, showing that KieBase 'kbase2' has included the resources from
      the dependency KieBase 'kbase1'.</p><div class="example"><a id="d0e3946"/><p class="title"><strong>Example 4.46. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();
KieSession kSession = kContainer.newKieSession("ksession2");
kSession.setGlobal("out", out);

kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();

kSession.insert(new Message("Dave", "Open the pod bay doors, HAL."));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.4. Multiple KieBases"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3951"/>4.2.6.4. Multiple KieBases</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: 'multiple-kbases.</p></li><li class="listitem"><p>Summary: Demonstrates that the 'kmodule.xml'  can contain any number of KieBase or
          KieSession declarations. Introduces the 'packages' attribute to select the folders for the
          resources to be included in the KieBase.</p></li></ul></div><p>kmodule.xml produces 6 different named KieBases. 'kbase1' includes all resources from the
      KieModule. The other KieBases include resources from other selected folders, via the
      'packages' attribute. Note the use of wildcard '*', to select this package and all packages
      below it. </p><div class="example"><a id="d0e3963"/><p class="title"><strong>Example 4.47. Author - kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;

  &lt;kbase name="kbase1"&gt;
    &lt;ksession name="ksession1"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase2" packages="org.some.pkg"&gt;
    &lt;ksession name="ksession2"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase3" includes="kbase2" packages="org.some.pkg2"&gt;
    &lt;ksession name="ksession3"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase4" packages="org.some.pkg, org.other.pkg"&gt;
    &lt;ksession name="ksession4"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase5" packages="org.*"&gt;
    &lt;ksession name="ksession5"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase6" packages="org.some.*"&gt;
    &lt;ksession name="ksession6"/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e3968"/><p class="title"><strong>Example 4.48. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>Only part of the example is included below, as there is a test method per KieSession, but
      each one is a repetition of the other, with different list expectations.</p><div class="example"><a id="d0e3975"/><p class="title"><strong>Example 4.49. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">@Test
public void testSimpleKieBase() {
    List&lt;Integer&gt; list = useKieSession("ksession1");
    // no packages imported means import everything
    assertEquals(4, list.size());
    assertTrue( list.containsAll( asList(0, 1, 2, 3) ) );
}

//.. other tests for ksession2 to ksession6 here

private List&lt;Integer&gt; useKieSession(String name) {
    KieServices ks = KieServices.Factory.get();
    KieContainer kContainer = ks.getKieClasspathContainer();
    KieSession kSession = kContainer.newKieSession(name);

    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    kSession.setGlobal("list", list);
    kSession.insert(1);
    kSession.fireAllRules();

    return list;
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.5. KieContainer from KieRepository"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3980"/>4.2.6.5. KieContainer from KieRepository</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: kcontainer-from-repository</p></li><li class="listitem"><p>Summary: The project does not contain a kmodule.xml, nor does the pom.xml have any
          dependencies for other KieModules. Instead the Java code demonstrates the loading of a
          dynamic KieModule from a Maven repository. </p></li></ul></div><p>The pom.xml must include kie-ci as a depdency, to ensure Maven is available at runtime.
      As this uses Maven under the hood you can also use the standard Maven settings.xml
      file.</p><div class="example"><a id="d0e3992"/><p class="title"><strong>Example 4.50. Author - pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;kiecontainer-from-kierepo&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieContainer from KieRepo&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.kie&lt;/groupId&gt;
      &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

&lt;/project&gt;</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e3997"/><p class="title"><strong>Example 4.51. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>In the previous examples the classpath KieContainer used. This example creates a dynamic
      KieContainer as specified by the  ReleaseId. The ReleaseId uses Maven conventions for group
      id, artifact id and version. It also obeys LATEST and SNAPSHOT for versions.</p><div class="example"><a id="d0e4004"/><p class="title"><strong>Example 4.52. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();

// Install example1 in the local Maven repo before to do this
KieContainer kContainer = ks.newKieContainer(ks.newReleaseId("org.drools", "named-kiesession", "6.0.0-SNAPSHOT"));

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.6. Default KieSession from File"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4009"/>4.2.6.6. Default KieSession from File</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: default-kiesession-from-file</p></li><li class="listitem"><p>Summary: Dynamic KieModules can also be loaded from any Resource location. The loaded
          KieModule provides default KieBase and KieSession definitions.</p></li></ul></div><p>No kmodue.xml file exists. The project 'default-kiesession' must be built first, so that
      the resulting JAR, in the target folder, can be referenced as a File.</p><div class="example"><a id="d0e4021"/><p class="title"><strong>Example 4.53. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>Any KieModule can be loaded from a Resource location and added to the KieRepository. Once
      deployed in the KieRepository it can be resolved via its ReleaseId. Note neither Maven or kie-ci are
      needed here. It will not set up a transitive dependency parent classloader.</p><div class="example"><a id="d0e4028"/><p class="title"><strong>Example 4.54. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile("default-kiesession")));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.7. Named KieSession from File"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4033"/>4.2.6.7. Named KieSession from File</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: named-kiesession-from-file</p></li><li class="listitem"><p>Summary: Dynamic KieModules can also be loaded from any Resource location. The loaded
          KieModule provides named KieBase and KieSession definitions.</p></li></ul></div><p>No kmodue.xml file exists. The project 'named-kiesession' must be built first, so that the
      resulting JAR, in the target folder, can be referenced as a File.</p><div class="example"><a id="d0e4045"/><p class="title"><strong>Example 4.55. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>Any KieModule can be loaded from a Resource location and added to the KieRepository. Once
      in the KieRepository it can be resolved via its ReleaseId. Note neither Maven or kie-ci are
      needed here. It will not setup a transitive dependency parent classloader.</p><div class="example"><a id="d0e4052"/><p class="title"><strong>Example 4.56. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile("named-kiesession")));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.8. KieModule with Dependent KieModule"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4057"/>4.2.6.8. KieModule with Dependent KieModule</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: kie-module-form-multiple-files</p></li><li class="listitem"><p>Summary: Programmatically provide the list of dependant KieModules, without using Maven
          to resolve anything.</p></li></ul></div><p>No kmodue.xml file exists. The projects 'named-kiesession' and 'kiebase-include' must be
      built first, so that the resulting JARs, in the target folders, can be referenced as
      Files.</p><div class="example"><a id="d0e4069"/><p class="title"><strong>Example 4.57. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>Creates two resources. One is for the main KieModule 'exRes1' the other is for the
      dependency 'exRes2'. Even though kie-ci is not present and thus Maven is not available to resolve
      the dependencies, this shows how you can manually specify the dependent KieModules, for the
      vararg.</p><div class="example"><a id="d0e4076"/><p class="title"><strong>Example 4.58. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile("kiebase-inclusion"));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile("named-kiesession"));

KieModule kModule = kr.addKieModule(ex1Res, ex2Res);
KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession("ksession2");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, "Dave", "Open the pod bay doors, HAL.");
kSession.insert(msg2);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.9. Programmaticaly build a Simple KieModule with Defaults"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4081"/>4.2.6.9. Programmaticaly build a Simple KieModule with Defaults</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: kiemoduelmodel-example</p></li><li class="listitem"><p>Summary: Programmaticaly buid a KieModule from just a single file. The POM and models
          are all defaulted. This is the quickest out of the box approach, but should not be added
          to a Maven repository.</p></li></ul></div><div class="example"><a id="d0e4091"/><p class="title"><strong>Example 4.59. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>This programmatically builds a KieModule. It populates the model that represents the
      ReleaseId and  kmodule.xml, and it adds the relevant resources. A pom.xml is generated from
      the ReleaseId.</p><div class="example"><a id="d0e4098"/><p class="title"><strong>Example 4.60. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();
KieFileSystem kfs = ks.newKieFileSystem();

kfs.write("src/main/resources/org/kie/example5/HAL5.drl", getRule());

KieBuilder kb = ks.newKieBuilder(kfs);

kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
    throw new RuntimeException("Build Errors:\n" + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(kr.getDefaultReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);

kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div><div class="section" title="4.2.6.10. Programmaticaly build a KieModule using Meta Models"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4103"/>4.2.6.10. Programmaticaly build a KieModule using Meta Models</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Project: kiemoduelmodel-example</p></li><li class="listitem"><p>Summary: Programmaticaly build a KieModule, by creating its kmodule.xml meta model
          resources. </p></li></ul></div><div class="example"><a id="d0e4113"/><p class="title"><strong>Example 4.61. Build and Install - Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"/><p>This programmatically builds a KieModule. It populates the model that represents the
      ReleaseId and  kmodule.xml, as well as add the relevant resources. A pom.xml is generated from
      the ReleaseId.</p><div class="example"><a id="d0e4120"/><p class="title"><strong>Example 4.62. Utilize and Run - Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieFileSystem kfs = ks.newKieFileSystem();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile("named-kiesession"));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile("kiebase-inclusion"));

ReleaseId rid = ks.newReleaseId("org.drools", "kiemodulemodel-example", "6.0.0-SNAPSHOT");
kfs.generateAndWritePomXML(rid);

KieModuleModel kModuleModel = ks.newKieModuleModel();
kModuleModel.newKieBaseModel("kiemodulemodel")
            .addInclude("kiebase1")
            .addInclude("kiebase2")
            .newKieSessionModel("ksession6");

kfs.writeKModuleXML(kModuleModel.toXML());
kfs.write("src/main/resources/kiemodulemodel/HAL6.drl", getRule());

KieBuilder kb = ks.newKieBuilder(kfs);
kb.setDependencies(ex1Res, ex2Res);
kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
    throw new RuntimeException("Build Errors:\n" + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(rid);

KieSession kSession = kContainer.newKieSession("ksession6");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, "Dave", "Open the pod bay doors, HAL.");
kSession.insert(msg2);
kSession.fireAllRules();

Object msg3 = createMessage(kContainer, "Dave", "What's the problem?");
kSession.insert(msg3);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="4.3. Security"><div class="titlepage"><div><div><h2 class="title"><a id="KIESecuritySection"/>4.3. Security</h2></div></div></div><div class="section" title="4.3.1. Security Manager"><div class="titlepage"><div><div><h3 class="title"><a id="SecurityManager"/>4.3.1. Security Manager</h3></div></div></div><p>The KIE engine is a platform for the modelling and execution of business behavior, using a multitude of
    declarative abstractions and metaphores, like rules, processes, decision tables and etc.</p><p>Many times, the authoring of these metaphores is done by third party groups, be it a different group inside the
    same company, a group from a partner company, or even anonymous third parties on the internet. </p><p>Rules and Processes are designed to execute arbitrary code in order to do their job, but in such cases it might
    be necessary to constrain what they can do. For instance, it is unlikely a rule should be allowed to create a
    classloader (what could open the system to an attack) and certainly it should not be allowed to make a call to
      <code class="code">System.exit()</code>.</p><p>The Java Platform provides a very comprehensive and well defined security framework that allows users to define
    policies for what a system can do. The KIE platform leverages that framework and allow application developers to
    define a specific policy to be applied to any execution of user provided code, be it in rules, processes, work item
    handlers and etc.</p><div class="section" title="4.3.1.1. How to define a KIE Policy"><div class="titlepage"><div><div><h4 class="title"><a id="HowToDefineKiePolicy"/>4.3.1.1. How to define a KIE Policy</h4></div></div></div><p>Rules and processes can run with very restrict permissions, but the engine itself needs to perform many
      complex operations in order to work. Examples are: it needs to create classloaders, read system properties, access
      the file system, etc. </p><p>Once a security manager is installed, though, it will apply restrictions to all the code executing in the JVM
      according to the defined policy. For that reason, KIE allows the user to define two different policy files: one
      for the engine itself and one for the assets deployed into and executed by the engine.</p><p>One easy way to setup the enviroment is to give the engine itself a very permissive policy, while providing a
      constrained policy for rules and processes. </p><p>Policy files follow the standard policy file syntax as described in the Java documentation. For more details,
      see:</p><p>http://docs.oracle.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax</p><p>A permissive policy file for the engine can look like the following:</p><div class="example"><a id="d0e4158"/><p class="title"><strong>Example 4.63. A sample engine.policy file</strong></p><div class="example-contents"><pre><code class="no-highlight">grant { 
    permission java.security.AllPermission;
}</code></pre></div></div><br class="example-break"/><p>An example security policy for rules could be:</p><div class="example"><a id="d0e4165"/><p class="title"><strong>Example 4.64. A sample rules.policy file</strong></p><div class="example-contents"><pre><code class="no-highlight">grant { 
    permission java.util.PropertyPermission "*", "read"; 
    permission java.lang.RuntimePermission "accessDeclaredMembers"; 
}</code></pre></div></div><br class="example-break"/><p>Please note that depending on what the rules and processes are supposed to do, many more permissions might
      need to be granted, like accessing files in the filesystem, databases, etc.</p><p>In order to use these policy files, all that is necessary is to execute the application with these files as
      parameters to the JVM. Three parameters are required:</p><p>
      </p><div class="table"><a id="d0e4176"/><p class="title"><strong>Table 4.3. Parameters</strong></p><div class="table-contents"><table summary="Parameters" border="1"><colgroup><col width="1.0*" class="c1"/><col width="1.0*" class="c2"/></colgroup><thead><tr><th>Parameter</th><th>Meaning</th></tr></thead><tbody><tr><td>
                <p>-Djava.security.manager</p>
              </td><td>Enables the security manager</td></tr><tr><td>
                <p>-Djava.security.policy=&lt;jvm_policy_file&gt;</p>
              </td><td>Defines the global policy file to be applied to the whole application, including the engine</td></tr><tr><td>
                <p>-Dkie.security.policy=&lt;kie_policy_file&gt;</p>
              </td><td>Defines the policy file to be applied to rules and processes</td></tr></tbody></table></div></div><p><br class="table-break"/>
    </p><p>For instance:</p><p><code class="code">java -Djava.security.manager -Djava.security.policy=global.policy -Dkie.security.policy=rules.policy
        foo.bar.MyApp</code></p><p/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>When executing the engine inside a container, use your container's documentation to find out how to
        configure the Security Manager and how to define the global security policy. Define the kie security policy as
        described above and set the <code class="code">kie.security.policy</code> system property in order to configure the engine to
        use it.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Please note that unless a Security Manager is configured, the <code class="code">kie.security.policy</code> will be
        ignored.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A Security Manager has a high performance impact in the JVM. Applications with strict performance
        requirements are strongly discouraged of using a Security Manager. An alternative is the use of other security
        procedures like the auditing of rules/processes before testing and deployment to prevent malicious code from
        being deployed to the environment.</p></div></div></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="pt02.html"><strong>Prev</strong>Part II. KIE</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="pt03.html"><strong>Next</strong>Part III. Drools Runtime and Language</a></li></ul></body></html>