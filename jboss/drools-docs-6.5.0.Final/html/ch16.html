<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 16. Drools Camel Server</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt04.html" title="Part IV. Drools Integration"/><link rel="prev" href="ch15.html" title="Chapter 15. Apache Camel Integration"/><link rel="next" href="ch17.html" title="Chapter 17. JMX monitoring with RHQ/JON"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch15.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch17.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 16. Drools Camel Server"><div class="titlepage"><div><div><h2 class="title"><a id="ch.server"/>Chapter 16. Drools Camel Server</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch16.html#d0e16423">16.1. Introduction</a></span></dt><dt><span class="section"><a href="ch16.html#d0e16428">16.2. Deployment</a></span></dt><dt><span class="section"><a href="ch16.html#d0e16433">16.3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="ch16.html#d0e16473">16.3.1. REST/Camel Services configuration</a></span></dt></dl></dd></dl></div><div class="section" title="16.1. Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16423"/>16.1. Introduction</h2></div></div></div><p>The drools camel server (drools-camel-server) module is a war which you
  can deploy to execute KnowledgeBases remotely for any sort of client
  application. This is not limited to JVM application clients, but any
  technology that can use HTTP, through a REST interface. This version of the
  execution server supports stateless and stateful sessions in a native
  way.</p></div><div class="section" title="16.2. Deployment"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16428"/>16.2. Deployment</h2></div></div></div><p>Drools Camel Server is a war file, which can be deployed in a application
  server (such as JBoss AS). As the service is stateless, it is possible to
  have have as many of these services deployed as you need to serve the client
  load. Deploy on JBoss AS 4.x / Tomcat 6.x works out-of-the-box, instead some
  external dependencies must be added and the configuration must be changed to
  be deployed in JBoss AS 5</p></div><div class="section" title="16.3. Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16433"/>16.3. Configuration</h2></div></div></div><p>Inside the war file you will find a few XML configuration
  files.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>beans.xml</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Skeleton XML that imports knowledge-services.xml and
          camel-server.xml</p></li></ul></div></li><li class="listitem"><p>camel-server.xml</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Configures CXF endpoints with Camel Routes</p></li><li class="listitem"><p>Came Routes pipeline messages to various configured knowledge
          services</p></li></ul></div></li><li class="listitem"><p>knowledge-services.xml</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Various Knowledge Bases and Sessions</p></li></ul></div></li><li class="listitem"><p>camel-client.xml</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Sample camel client showing how to send and receive a
          message</p></li><li class="listitem"><p>Used by "out of the box" test.jsp</p></li></ul></div></li></ul></div><div class="section" title="16.3.1. REST/Camel Services configuration"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16473"/>16.3.1. REST/Camel Services configuration</h3></div></div></div><p>The next step is configure the services that are going to be exposed
    through drools-server. You can modify this configuration in
    camel-server.xml file.</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cxf="http://camel.apache.org/schema/cxf"
  xmlns:jaxrs="http://cxf.apache.org/jaxrs"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
  http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd
  http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

&lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt;
&lt;import resource="classpath:META-INF/cxf/cxf-extension-jaxrs-binding.xml"/&gt; 
&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt;

  &lt;!--
   !   If you are running on JBoss you will need to copy a camel-jboss.jar into the lib and set this ClassLoader configuration
   !  http://camel.apache.org/camel-jboss.html
   !   &lt;bean id="jbossResolver" class="org.apache.camel.jboss.JBossPackageScanClassResolver"/&gt;
   --&gt;

  &lt;!--
   !   Define the server end point.
   !   Copy and paste this element, changing id and the address, to expose services on different urls.
   !   Different Camel routes can handle different end point paths.
   --&gt;
  &lt;cxf:rsServer id="rsServer"  
                address="/rest"
                serviceClass="org.kie.jax.rs.CommandExecutorImpl"&gt;
       &lt;cxf:providers&gt;
           &lt;bean class="org.kie.jax.rs.CommandMessageBodyReader"/&gt;
       &lt;/cxf:providers&gt;
  &lt;/cxf:rsServer&gt;  
  
  &lt;cxf:cxfEndpoint id="soapServer"
            address="/soap"
             serviceName="ns:CommandExecutor"
             endpointName="ns:CommandExecutorPort"
          wsdlURL="soap.wsdl"
          xmlns:ns="http://soap.jax.drools.org/" &gt;
    &lt;cxf:properties&gt;
      &lt;entry key="dataFormat" value="MESSAGE"/&gt;
      &lt;entry key="defaultOperationName" value="execute"/&gt;
    &lt;/cxf:properties&gt;
  &lt;/cxf:cxfEndpoint&gt;

  &lt;!-- Leave this, as it's needed to make Camel "drools" aware --&gt;
  &lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;

  &lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;    
    &lt;!-- 
     ! Routes incoming messages from end point id="rsServer".
     ! Example route unmarshals the messages with xstream and executes against ksession1.
     ! Copy and paste this element, changing marshallers and the 'to' uri, to target different sessions, as needed.
     !--&gt;
     
    &lt;route&gt;
       &lt;from uri="cxfrs://bean://rsServer"/&gt;
       &lt;policy ref="kiePolicy"&gt;
         &lt;unmarshal ref="xstream" /&gt;
         &lt;to uri="kie:ksession1" /&gt;
         &lt;marshal ref="xstream" /&gt;
       &lt;/policy&gt;
    &lt;/route&gt;    

    &lt;route&gt;
      &lt;from uri="cxf://bean://soapServer"/&gt;
      &lt;policy ref="kiePolicy"&gt;
        &lt;unmarshal ref="xstream" /&gt;       
        &lt;to uri="kie:ksession1" /&gt;
        &lt;marshal ref="xstream" /&gt;
      &lt;/policy&gt;
    &lt;/route&gt;
        
  &lt;/camelContext&gt;
  
&lt;/beans&gt; </code></pre><div class="section" title="16.3.1.1. RESTful service endpoint creation"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16480"/>16.3.1.1. RESTful service endpoint creation</h4></div></div></div><p>In the next XML snippet code we are creating a RESTful (JAX-RS)
      endpoint bound to /kservice/rest address and using
      org.drools.jax.rs.CommandExecutorImpl as the service implementer. This
      class is only used to instantiate the service endpoint because all the
      internal implementation is managed by Camel, and you can see in the
      source file that the exposed execute service must be never
      called.</p><p>Also a JAX-RS Provider is provided to determine if the message
      transported can be processed in this service endpoint.</p><pre><code class="language-xml">&lt;cxf:rsServer id="rsServer"  
              address="/rest"
              serviceClass="org.kie.jax.rs.CommandExecutorImpl"&gt;
     &lt;cxf:providers&gt;
         &lt;bean class="org.kie.jax.rs.CommandMessageBodyReader"/&gt;
     &lt;/cxf:providers&gt;
&lt;/cxf:rsServer&gt;  </code></pre><p>Ideally this configuration doesn't need to be modified, at least
      the Service Class and the JAX-RS Provider, but you can add more
      endpoints associated to different addresses to use them in other Camel
      Routes.</p><p>After all this initial configuration, you can start config your
      own Knowledge Services.</p></div><div class="section" title="16.3.1.2. Camel Kie Policy &amp; Context creation"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16493"/>16.3.1.2. Camel Kie Policy &amp; Context creation</h4></div></div></div><p>KiePolicy is used to add Drools support in Camel, basically what
      it does is to add interceptors into the camel route to create Camel
      Processors on the fly and modify the internal navigation route. If you
      want to have SOAP support you need to create your custom Drools Policy,
      but it's going to be added in the next release.</p><p>But you don’t need to know more internal details, only instantiate
      this bean:</p><pre><code class="language-xml">&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;</code></pre><p>The next is create the camel route that will have the
      responsibility to execute the commands sent through JAX-RS. Basically we
      create a route definition associated with the JAX-RS definition as the
      data input, the camel policy to be used and inside the “execution route”
      or ProcessorDefinitions. As you can see, we set XStream as the
      marshaller/unmarshaller and the drools execution route definition</p><pre><code class="language-xml">&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;    
   &lt;route&gt;
      &lt;from uri="cxfrs://bean://rsServer"/&gt;
      &lt;policy ref="kiePolicy"&gt;
        &lt;unmarshal ref="xstream" /&gt;
        &lt;to uri="kie:ksession1" /&gt;
        &lt;marshal ref="xstream" /&gt;
      &lt;/policy&gt;
   &lt;/route&gt;    
   &lt;route&gt;
     &lt;from uri="cxf://bean://soapServer"/&gt;
     &lt;policy ref="kiePolicy"&gt;
       &lt;unmarshal ref="xstream" /&gt;       
       &lt;to uri="kie:ksession1" /&gt;
       &lt;marshal ref="xstream" /&gt;
     &lt;/policy&gt;
   &lt;/route&gt;
&lt;/camelContext&gt;</code></pre><p>The drools endpoint creation has the next arguments</p><pre><code class="language-xml">&lt;to uri="kie:{1}/{2}" /&gt;</code></pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Execution Node identifier that is registered in the
          CamelContext</p></li><li class="listitem"><p>Knowledge Session identifier that was registered in the
          Execution Node with identifier {1}</p></li></ol></div><p>Both parameters are configured in knowledge-services.xml
      file.</p></div><div class="section" title="16.3.1.3. Knowledge Services configuration"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16520"/>16.3.1.3. Knowledge Services configuration</h4></div></div></div><p>The next step is create the Knowledge Sessions that you are going
      to use.</p><pre><code class="language-xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:kie="http://drools.org/schema/kie-spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                          http://drools.org/schema/kie-spring http://drools.org/schema/kie-spring.xsd"&gt;

  &lt;kie:kmodule id="drools-camel-server"&gt;
    &lt;kie:kbase name="kbase1" packages="org.drools.server"&gt;
      &lt;kie:ksession name="ksession1" type="stateless"/&gt;
    &lt;/kie:kbase&gt;
  &lt;/kie:kmodule&gt;

  &lt;bean id="kiePostProcessor" 
            class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;

&lt;/beans&gt;</code></pre><p>The execution-node is a context or registered kbases and
      ksessions, here kbase1 and ksession1 are planed in the node1 context.
      The kbase itself consists of two knowledge definitions, a DRL and an XSD.
      The Spring documentation contains a lot more information on configuring
      these knowledge services.</p></div><div class="section" title="16.3.1.4. Test"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16529"/>16.3.1.4. Test</h4></div></div></div><p>With drools-server war unzipped you should be able to see a
      test.jsp and run it. This example just executes a simple "echo" type
      application. It sends a message to the rule server that pre-appends the
      word "echo" to the front and sends it back. By default the message is
      "Hello World", different messages can be passed using the url parameter
      msg - test.jsp?msg="My Custom Message".</p><p>Under the hood the jsp invokes the Test.java class, this then
      calls out to Camel which is where the meet happens. The camel-client.xml
      defines the client with just a few lines of XML:</p><pre><code class="language-xml">&lt;!-- Leave this, as it's needed to make Camel "drools" aware --&gt;
&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;
  
&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;route&gt;
     &lt;from uri="direct://kservice/rest"/&gt;
     &lt;policy ref="kiePolicy"&gt;
       &lt;to uri="cxfrs://http://localhost:8080/drools-server/kservice/rest"/&gt;
     &lt;/policy&gt;
  &lt;/route&gt;
  &lt;route&gt;
    &lt;from uri="direct://kservice/soap"/&gt;
    &lt;policy ref="kiePolicy"&gt;
      &lt;to uri="cxfrs://http://localhost:8080/drools-server/kservice/soap"/&gt;
    &lt;/policy&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre><p>"direct://kservice" is just a named hook, allowing Java to grab a
      reference and push data into it. In this example the data is already in
      XML, so we don't need to add any <code class="code">DataFormat</code>s to do the marshalling. The
      KiePolicy adds some smarts to the route and you'll see it used on the
      server side too. If JAXB or XStream were used, it would inject custom
      paths and converters, it can also set the ClassLoader too on the server
      side, on the client side it automatically unwraps the Response
      object.</p><p>The rule itself can be found here: test.drl. Notice the type
      Message is declared part of the DRL and is thus not present on the
      Classpath.</p><pre><code class="no-highlight">declare Message
   text : String
end
    
  
rule "echo" dialect "mvel"
when
   $m : Message();
then
   $m.text = "echo:" + $m.text;
end
</code></pre></div></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch15.html"><strong>Prev</strong>Chapter 15. Apache Camel Integration</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch17.html"><strong>Next</strong>Chapter 17. JMX monitoring with RHQ/JON</a></li></ul></body></html>