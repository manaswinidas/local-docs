<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 8. Rule Language Reference</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt03.html" title="Part III. Drools Runtime and Language"/><link rel="prev" href="ch07.html" title="Chapter 7. Running"/><link rel="next" href="ch09.html" title="Chapter 9. Complex Event Processing"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch07.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch09.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 8. Rule Language Reference"><div class="titlepage"><div><div><h2 class="title"><a id="DroolsLanguageReferenceChapter"/>Chapter 8. Rule Language Reference</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch08.html#d0e7602">8.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e7610">8.1.1. A rule file</a></span></dt><dt><span class="section"><a href="ch08.html#d0e7643">8.1.2. What makes a rule</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#d0e7679">8.2. Keywords</a></span></dt><dt><span class="section"><a href="ch08.html#d0e7874">8.3. Comments</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e7879">8.3.1. Single line comment</a></span></dt><dt><span class="section"><a href="ch08.html#d0e7889">8.3.2. Multi-line comment</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#d0e7902">8.4. Error Messages</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e7907">8.4.1. Message format</a></span></dt><dt><span class="section"><a href="ch08.html#d0e7938">8.4.2. Error Messages Description</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8093">8.4.3. Other Messages</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#d0e8098">8.5. Package</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e8121">8.5.1. import</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8135">8.5.2. global</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#d0e8178">8.6. Function</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8212">8.7. Type Declaration</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e8240">8.7.1. Declaring New Types</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8397">8.7.2. Declaring Metadata</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8758">8.7.3. Declaring Metadata for Existing Types</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8801">8.7.4. Parametrized constructors for declared types</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8825">8.7.5. Non Typesafe Classes</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8830">8.7.6. Accessing Declared Types from the Application Code</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8879">8.7.7. Type Declaration 'extends'</a></span></dt><dt><span class="section"><a href="ch08.html#d0e8911">8.7.8. Traits</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#d0e9154">8.8. Rule</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e9196">8.8.1. Rule Attributes</a></span></dt><dt><span class="section"><a href="ch08.html#d0e9356">8.8.2. Timers and Calendars</a></span></dt><dt><span class="section"><a href="ch08.html#d0e9456">8.8.3. Left Hand Side (when) syntax</a></span></dt><dt><span class="section"><a href="ch08.html#d0e11687">8.8.4. The Right Hand Side (then)</a></span></dt><dt><span class="section"><a href="ch08.html#d0e11934">8.8.5. Conditional named consequences</a></span></dt><dt><span class="section"><a href="ch08.html#d0e11959">8.8.6. A Note on Auto-boxing and Primitive Types</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#QuerySection">8.9. Query</a></span></dt><dt><span class="section"><a href="ch08.html#d0e12041">8.10. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#d0e12051">8.10.1. When to Use a DSL</a></span></dt><dt><span class="section"><a href="ch08.html#d0e12058">8.10.2. DSL Basics</a></span></dt><dt><span class="section"><a href="ch08.html#d0e12127">8.10.3. Adding Constraints to Facts</a></span></dt><dt><span class="section"><a href="ch08.html#d0e12171">8.10.4. Developing a DSL</a></span></dt><dt><span class="section"><a href="ch08.html#d0e12184">8.10.5. DSL and DSLR Reference</a></span></dt></dl></dd></dl></div><div class="section" title="8.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7602"/>8.1. Overview</h2></div></div></div><p>Drools has a "native" rule language. 
  This format is very light in terms of punctuation, and supports
  natural and domain specific languages via "expanders" that allow the
  language to morph to your problem domain. This chapter is mostly concerted
  with this native rule format. The diagrams used to present the syntax are
  known as "railroad" diagrams, and they are basically flow charts for the
  language terms. The
  technically very keen may also refer to <code class="filename">DRL.g</code> which is 
  the Antlr3
  grammar for the rule language. If you use the Rule Workbench, a lot of the
  rule structure is done for you with content assistance, for example, type
  "ru" and press ctrl+space, and it will build the rule structure for
  you.</p><div class="section" title="8.1.1. A rule file"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7610"/>8.1.1. A rule file</h3></div></div></div><p>A rule file is typically a file with a .drl extension. In a DRL file
    you can have multiple rules, queries and functions, as well as some
    resource declarations like imports, globals and attributes that are
    assigned and used by your rules and queries. However, you are also able to
    spread your rules across multiple rule files (in that case, the extension
    .rule is suggested, but not required) - spreading rules across files can
    help with managing large numbers of rules. A DRL file is simply a text
    file.</p><p>The overall structure of a rule file is:</p><div class="example"><a id="d0e7617"/><p class="title"><strong>Example 8.1. Rules file</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>package </strong></span><em class="replaceable"><code>package-name</code></em>

<em class="replaceable"><code>imports</code></em>

<em class="replaceable"><code>globals</code></em>

<em class="replaceable"><code>functions</code></em>

<em class="replaceable"><code>queries</code></em>

<em class="replaceable"><code>rules</code></em>
</code></pre></div></div><br class="example-break"/><p>The order in which the elements are declared is not important,
    except for the package name that, if declared, must be the first element
    in the rules file. All elements are optional, so you will use only those
    you need. We will discuss each of them in the following sections.</p></div><div class="section" title="8.1.2. What makes a rule"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7643"/>8.1.2. What makes a rule</h3></div></div></div><p>For the impatient, just as an early view, a rule has the following
    rough structure:</p><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> <em class="replaceable"><code>"name"</code></em>
    <em class="replaceable"><code>attributes</code></em>
    <span class="bold"><strong>when</strong></span>
        <em class="replaceable"><code>LHS</code></em>
    <span class="bold"><strong>then</strong></span>
        <em class="replaceable"><code>RHS</code></em>
<span class="bold"><strong>end</strong></span>
</code></pre><p>It's really that simple. Mostly punctuation is not needed,
    even the double quotes for "name" are optional, as are newlines.
    Attributes are simple (always optional) hints to how the rule should
    behave. LHS is the conditional parts of the rule, which follows a certain
    syntax which is covered below. RHS is basically a block that allows
    dialect specific semantic code to be executed.</p><p>It is important to note that white space is not important,
      <span class="emphasis"><em>except</em></span> in
    the case of domain specific languages, where lines are processed
    one by one and spaces may be significant to the domain language.</p></div></div><div class="section" title="8.2. Keywords"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7679"/>8.2. Keywords</h2></div></div></div><p>Drools 5 introduces the concept of <span class="emphasis"><em>hard</em></span> and
  <span class="emphasis"><em>soft</em></span> keywords.</p><p>Hard keywords are reserved, you cannot use any hard keyword when
  naming your domain objects, properties, methods, functions and other
  elements that are used in the rule text.</p><p>Here is the list of hard keywords that must be avoided as identifiers
  when writing rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">true</code></p></li><li class="listitem"><p><code class="literal">false</code></p></li><li class="listitem"><p><code class="literal">null</code></p></li></ul></div><p>Soft keywords are just recognized in their context, enabling you to
  use these words in any other place if you wish, although, it is still
  recommended to avoid them, to avoid confusions, if possible. Here is a list
  of the soft keywords:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">lock-on-active</code></p></li><li class="listitem"><p><code class="literal">date-effective</code></p></li><li class="listitem"><p><code class="literal">date-expires</code></p></li><li class="listitem"><p><code class="literal">no-loop</code></p></li><li class="listitem"><p><code class="literal">auto-focus</code></p></li><li class="listitem"><p><code class="literal">activation-group</code></p></li><li class="listitem"><p><code class="literal">agenda-group</code></p></li><li class="listitem"><p><code class="literal">ruleflow-group</code></p></li><li class="listitem"><p><code class="literal">entry-point</code></p></li><li class="listitem"><p><code class="literal">duration</code></p></li><li class="listitem"><p><code class="literal">package</code></p></li><li class="listitem"><p><code class="literal">import</code></p></li><li class="listitem"><p><code class="literal">dialect</code></p></li><li class="listitem"><p><code class="literal">salience</code></p></li><li class="listitem"><p><code class="literal">enabled</code></p></li><li class="listitem"><p><code class="literal">attributes</code></p></li><li class="listitem"><p><code class="literal">rule</code></p></li><li class="listitem"><p><code class="literal">extend</code></p></li><li class="listitem"><p>when</p></li><li class="listitem"><p>then</p></li><li class="listitem"><p><code class="literal">template</code></p></li><li class="listitem"><p><code class="literal">query</code></p></li><li class="listitem"><p><code class="literal">declare</code></p></li><li class="listitem"><p><code class="literal">function</code></p></li><li class="listitem"><p><code class="literal">global</code></p></li><li class="listitem"><p><code class="literal">eval</code></p></li><li class="listitem"><p><code class="literal">not</code></p></li><li class="listitem"><p><code class="literal">in</code></p></li><li class="listitem"><p><code class="literal">or</code></p></li><li class="listitem"><p><code class="literal">and</code></p></li><li class="listitem"><p><code class="literal">exists</code></p></li><li class="listitem"><p><code class="literal">forall</code></p></li><li class="listitem"><p>accumulate</p></li><li class="listitem"><p>collect</p></li><li class="listitem"><p>from</p></li><li class="listitem"><p><code class="literal">action</code></p></li><li class="listitem"><p><code class="literal">reverse</code></p></li><li class="listitem"><p><code class="literal">result</code></p></li><li class="listitem"><p><code class="literal">end</code></p></li><li class="listitem"><p>over</p></li><li class="listitem"><p><code class="literal">init</code></p></li></ul></div><p>Of course, you can have these (hard and soft) words as part of a
  method name in camel case, like notSomething() or accumulateSomething() -
  there are no issues with that scenario.</p><p>Although the 3 hard keywords above are unlikely to be used in your
  existing domain models, if you absolutely need to use them as identifiers
  instead of keywords, the DRL language provides the ability to escape hard
  keywords on rule text. To escape a word, simply enclose it in grave accents,
  like this:</p><pre><code class="no-highlight">Holiday( `true` == "yes" ) // please note that Drools will resolve that reference to the method Holiday.isTrue()</code></pre></div><div class="section" title="8.3. Comments"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7874"/>8.3. Comments</h2></div></div></div><p>Comments are sections of text that are ignored by the rule engine.
  They are stripped out when they are encountered, except inside semantic code
  blocks, like the RHS of a rule.</p><div class="section" title="8.3.1. Single line comment"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7879"/>8.3.1. Single line comment</h3></div></div></div><p>To create single line comments, you can use '//'. The parser will
    ignore anything in the line after the comment symbol. Example:</p><pre><code class="no-highlight">rule "Testing Comments"
when
    // this is a single line comment
    eval( true ) // this is a comment in the same line of a pattern
then
    // this is a comment inside a semantic code block
end
</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p> '#' for comments has been removed.</p></div></div><div class="section" title="8.3.2. Multi-line comment"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7889"/>8.3.2. Multi-line comment</h3></div></div></div><div class="figure"><a id="d0e7892"/><p class="title"><strong>Figure 8.1. Multi-line comment</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/multi_line_comment.png" align="middle" alt="Multi-line comment"/></div></div></div><br class="figure-break"/><p>Multi-line comments are used to comment blocks of text, both in and
    outside semantic code blocks. Example:</p><pre><code class="no-highlight">rule "Test Multi-line Comments"
when
    /* this is a multi-line comment
       in the left hand side of a rule */
    eval( true )
then
    /* and this is a multi-line comment
       in the right hand side of a rule */
end </code></pre></div></div><div class="section" title="8.4. Error Messages"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7902"/>8.4. Error Messages</h2></div></div></div><p>Drools 5 introduces standardized error messages. This standardization
  aims to help users to find and resolve problems in a easier and faster way.
  In this section you will learn how to identify and interpret those error
  messages, and you will also receive some tips on how to solve the problems
  associated with them.</p><div class="section" title="8.4.1. Message format"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7907"/>8.4.1. Message format</h3></div></div></div><p>The standardization includes the error message format and to better
    explain this format, let's use the following example:</p><div class="figure"><a id="d0e7912"/><p class="title"><strong>Figure 8.2. Error Message Format</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/error_message.png" align="middle" alt="Error Message Format"/></div></div></div><br class="figure-break"/><p><span class="bold"><strong>1st Block:</strong></span> This area identifies the
    error code.</p><p><span class="bold"><strong>2nd Block:</strong></span> Line and column
    information.</p><p><span class="bold"><strong>3rd Block:</strong></span> Some text describing the
    problem.</p><p><span class="bold"><strong>4th Block:</strong></span> This is the first
    context. Usually indicates the rule, function, template or query where the
    error occurred. This block is not mandatory.</p><p><span class="bold"><strong>5th Block:</strong></span> Identifies the pattern
    where the error occurred. This block is not mandatory.</p></div><div class="section" title="8.4.2. Error Messages Description"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7938"/>8.4.2. Error Messages Description</h3></div></div></div><div class="section" title="8.4.2.1. 101: No viable alternative"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7941"/>8.4.2.1. 101: No viable alternative</h4></div></div></div><p>Indicates the most common errors, where the parser came to a
      decision point but couldn't identify an alternative. Here are some
      examples:</p><div class="example"><a id="d0e7946"/><p class="title"><strong>Example 8.2. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule one
2:   when
3:     exists Foo()
4:     <span class="bold"><strong>exits</strong></span> Bar()
5:   then
6: end
</code></pre></div></div><br class="example-break"/><p>The above example generates this message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101] Line 4:4 no viable alternative at input 'exits' in
          rule one</p></li></ul></div><p>At first glance this seems to be valid syntax, but it is not
      (exits != exists). Let's take a look at next example:</p><div class="example"><a id="d0e7960"/><p class="title"><strong>Example 8.3. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: package org.drools.examples;
2: rule
3:   when
4:     Object()
5:   then
6:     System.out.println("A RHS");
7: end
</code></pre></div></div><br class="example-break"/><p>Now the above code generates this message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101] Line 3:2 no viable alternative at input
          'WHEN'</p></li></ul></div><p>This message means that the parser encountered the token <span class="bold"><strong>WHEN</strong></span>, actually a hard keyword, but it's in the
      wrong place since the the rule name is missing.</p><p>The error "no viable alternative" also occurs when you make a
      simple lexical mistake. Here is a sample of a lexical problem:</p><div class="example"><a id="d0e7976"/><p class="title"><strong>Example 8.4. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     Student( name == "Andy )
4:   then
5: end
</code></pre></div></div><br class="example-break"/><p>The above code misses to close the quotes and because of this the
      parser generates this error message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101] Line 0:-1 no viable alternative at input
          '&lt;eof&gt;' in rule simple_rule in pattern Student</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Usually the Line and Column information are accurate, but in
        some cases (like unclosed quotes), the parser generates a 0:-1
        position. In this case you should check whether you didn't forget to
        close quotes, apostrophes or parentheses.</p></div></div><div class="section" title="8.4.2.2. 102: Mismatched input"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7989"/>8.4.2.2. 102: Mismatched input</h4></div></div></div><p>This error indicates that the parser was looking for a particular
      symbol that it didn't ﬁnd at the current input position. Here are some
      samples:</p><div class="example"><a id="d0e7994"/><p class="title"><strong>Example 8.5. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     foo3 : Bar(
</code></pre></div></div><br class="example-break"/><p>The above example generates this message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 102] Line 0:-1 mismatched input '&lt;eof&gt;' expecting
          ')' in rule simple_rule in pattern Bar</p></li></ul></div><p>To fix this problem, it is necessary to complete the rule
      statement.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Usually when you get a 0:-1 position, it means that parser
        reached the end of source.</p></div><p>The following code generates more than one error message:</p><div class="example"><a id="d0e8010"/><p class="title"><strong>Example 8.6. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: package org.drools.examples;
2:
3: rule "Avoid NPE on wrong syntax"
4:   when
5:     not( Cheese( ( type == "stilton", price == 10 ) || ( type == "brie", price == 15 ) ) from $cheeseList )
6:   then
7:     System.out.println("OK");
8: end
</code></pre></div></div><br class="example-break"/><p>These are the errors associated with this source:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule
          "Avoid NPE on wrong syntax" in pattern Cheese</p></li><li class="listitem"><p>[ERR 101] Line 5:57 no viable alternative at input 'type' in
          rule "Avoid NPE on wrong syntax"</p></li><li class="listitem"><p>[ERR 102] Line 5:106 mismatched input ')' expecting 'then' in
          rule "Avoid NPE on wrong syntax"</p></li></ul></div><p>Note that the second problem is related to the first. To fix it,
      just replace the commas (',') by AND operator ('&amp;&amp;').</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In some situations you can get more than one error message. Try
        to fix one by one, starting at the first one. Some error messages are
        generated merely as consequences of other errors.</p></div></div><div class="section" title="8.4.2.3. 103: Failed predicate"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8030"/>8.4.2.3. 103: Failed predicate</h4></div></div></div><p>A validating semantic predicate evaluated to false. Usually these
      semantic predicates are used to identify soft keywords. This sample
      shows exactly this situation:</p><div class="example"><a id="d0e8035"/><p class="title"><strong>Example 8.7. </strong></p><div class="example-contents"><pre><code class="no-highlight"> 1: package nesting;
 2: dialect "mvel"
 3:
 4: import org.drools.compiler.Person
 5: import org.drools.compiler.Address
 6: 
 7: <span class="bold"><strong>fdsfdsfds</strong></span>
 8: 
 9: rule "test something"
10:   when
11:     p: Person( name=="Michael" )
12:   then
13:     p.name = "other";
14:     System.out.println(p.name);
15: end
</code></pre></div></div><br class="example-break"/><p>With this sample, we get this error message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 103] Line 7:0 rule 'rule_key' failed predicate:
          {(validateIdentifierKey(DroolsSoftKeywords.RULE))}? in rule</p></li></ul></div><p>The <span class="bold"><strong>fdsfdsfds</strong></span> text is invalid and
      the parser couldn't identify it as the soft keyword
      <code class="literal">rule</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>This error is very similar to 102: Mismatched input, but usually
        involves soft keywords.</p></div></div><div class="section" title="8.4.2.4. 104: Trailing semi-colon not allowed"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8058"/>8.4.2.4. 104: Trailing semi-colon not allowed</h4></div></div></div><p>This error is associated with the <code class="literal">eval</code> clause,
      where its expression may not be terminated with a semicolon. Check this
      example:</p><div class="example"><a id="d0e8066"/><p class="title"><strong>Example 8.8. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     eval(abc();)
4:   then
5: end
</code></pre></div></div><br class="example-break"/><p>Due to the trailing semicolon within eval, we get this error
      message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 104] Line 3:4 trailing semi-colon not allowed in rule
          simple_rule</p></li></ul></div><p>This problem is simple to fix: just remove the semi-colon.</p></div><div class="section" title="8.4.2.5. 105: Early Exit"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8077"/>8.4.2.5. 105: Early Exit</h4></div></div></div><p>The recognizer came to a subrule in the grammar that must match an
      alternative at least once, but the subrule did not match anything.
      Simply put: the parser has entered a branch from where there is no way
      out. This example illustrates it:</p><div class="example"><a id="d0e8082"/><p class="title"><strong>Example 8.9. </strong></p><div class="example-contents"><pre><code class="no-highlight">1: template test_error
2:   aa s  11;
3: end
</code></pre></div></div><br class="example-break"/><p>This is the message associated to the above sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 105] Line 2:2 required (...)+ loop did not match anything
          at input 'aa' in template test_error</p></li></ul></div><p>To fix this problem it is necessary to remove the numeric value as
      it is neither a valid data type which might begin a new template slot
      nor a possible start for any other rule file construct.</p></div></div><div class="section" title="8.4.3. Other Messages"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8093"/>8.4.3. Other Messages</h3></div></div></div><p>Any other message means that something bad has happened, so please
    contact the development team.</p></div></div><div class="section" title="8.5. Package"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8098"/>8.5. Package</h2></div></div></div><p>A package is a collection of rules and other related constructs, such
  as imports and globals. The package members are typically related to each
  other - perhaps HR rules, for instance. A package represents a namespace,
  which ideally is kept unique for a given grouping of rules. The package name
  itself is the namespace, and is not related to files or folders in any
  way.</p><p>It is possible to assemble rules from multiple rule sources, and have
  one top level package configuration that all the rules are kept under (when
  the rules are assembled). Although, it is not possible to merge into the
  same package resources declared under different names. A single Rulebase
  may, however, contain multiple packages built on it. A common structure is to
  have all the rules for a package in the same file as the package declaration
  (so that is it entirely self-contained).</p><p>The following railroad diagram shows all the components that may make
  up a package. Note that a package <span class="emphasis"><em>must</em></span> have a namespace and be declared
  using standard Java conventions for package names; i.e., no spaces, unlike
  rule names which allow spaces. In terms of the order of elements, they can
  appear in any order in the rule file, with the exception of the <code class="literal">package</code>
  statement, which must be at the top of the file. In all cases, the semicolons are
  optional.</p><div class="figure"><a id="d0e8113"/><p class="title"><strong>Figure 8.3. package</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/package.png" align="middle" alt="package"/></div></div></div><br class="figure-break"/><p>Notice that any rule attribute (as described the section Rule Attributes)
  may also be written at package level, superseding the attribute's default value.
  The modified default may still be replaced by an attribute setting within
  a rule.</p><div class="section" title="8.5.1. import"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8121"/>8.5.1. import</h3></div></div></div><div class="figure"><a id="d0e8124"/><p class="title"><strong>Figure 8.4. import</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/LanguageReference/import.png" alt="import"/></div></div></div><br class="figure-break"/><p>Import statements work like import statements in Java. You need to
    specify the fully qualified paths and type names for any objects you want
    to use in the rules. Drools automatically imports classes from the
    Java package of the same name, and also from the package
    <code class="code">java.lang</code>.</p></div><div class="section" title="8.5.2. global"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8135"/>8.5.2. global</h3></div></div></div><div class="figure"><a id="d0e8138"/><p class="title"><strong>Figure 8.5. global</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/LanguageReference/global.png" alt="global"/></div></div></div><br class="figure-break"/><p>With <code class="literal">global</code> you define global variables. They are used to make
    application objects available to the rules. Typically, they are used
    to provide data or services that the rules use, especially application
    services used in rule consequences, and to return data from the rules,
    like logs or values added in rule consequences, or for the rules to
    interact with the application, doing callbacks. Globals are not 
    inserted into the Working Memory, and therefore a global should never be
    used to establish conditions in rules except when it has a
    constant immutable value. The engine cannot be notified about value
    changes of globals and does not track their changes. Incorrect use
    of globals in constraints may yield surprising results - surprising
    in a bad way.</p><p>If multiple packages declare globals with the same identifier they
    must be of the same type and all of them will reference the same global
    value.</p><p>In order to use globals you must:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Declare your global variable in your rules file and use it in
        rules. Example:</p><pre><code class="no-highlight">global java.util.List myGlobalList;

rule "Using a global"
when
    eval( true )
then
    myGlobalList.add( "Hello World" );
end
</code></pre></li><li class="listitem"><p>Set the global value on your working memory. It is a best
        practice to set all global values before asserting any fact to the
        working memory. Example:</p><pre><code class="language-java">List list = new ArrayList();
KieSession kieSession = kiebase.newKieSession();
kieSession.setGlobal( "myGlobalList", list );
</code></pre></li></ol></div><p>Note that these are just named instances of objects that you pass in
    from your application to the working memory. This means you can pass in
    any object you want: you could pass in a service locator, or perhaps a
    service itself. With the new <code class="literal">from</code> element it is now common to pass a
    Hibernate session as a global, to allow <code class="literal">from</code> to pull data from a named
    Hibernate query.</p><p>One example may be an instance of a Email service. In your
    integration code that is calling the rule engine, you obtain your
    emailService object, and then set it in the working memory. In the DRL,
    you declare that you have a global of type EmailService, and give it the
    name "email". Then in your rule consequences, you can use things like
    email.sendSMS(number, message).</p><p>Globals are not designed to share data between rules and they should
    never be used for that purpose. Rules always reason and react to the
    working memory state, so if you want to pass data from rule to rule, assert
    the data as facts into the working memory.</p><p>Care must be taken when changing data held by globals because
    the rule engine is not aware of those changes, hence cannot react to them.</p></div></div><div class="section" title="8.6. Function"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8178"/>8.6. Function</h2></div></div></div><div class="figure"><a id="d0e8181"/><p class="title"><strong>Figure 8.6. function</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/function.png" align="middle" alt="function"/></div></div></div><br class="figure-break"/><p>Functions are a way to put semantic code in your rule source file, as
  opposed to in normal Java classes. They can't do anything more than what you
  can do with helper classes. (In fact, the compiler generates the helper class
  for you behind the scenes.) The main advantage of using functions in a rule
  is that you can keep the logic all in one place, and you can change the
  functions as needed (which can be a good or a bad thing). Functions are most
  useful for invoking actions on the consequence (<code class="literal">then</code>) part of a rule,
  especially if that particular action is used over and over again, perhaps
  with only differing parameters for each rule.</p><p>A typical function declaration looks like:</p><pre><code class="no-highlight">function String hello(String name) {
    return "Hello "+name+"!";
}
</code></pre><p>Note that the <code class="literal">function</code> keyword is used, even though its not really
  part of Java. Parameters to the function are defined as for a method, and
  you don't have to have parameters if they are not needed. The return type
  is defined just like in a regular method.</p><p>Alternatively, you could use a static method in a helper class,
  e.g., <code class="code">Foo.hello()</code>. Drools supports the use of
  function imports, so all you would need to do is:</p><pre><code class="no-highlight">import function my.package.Foo.hello</code></pre><p>Irrespective of the way the function is defined or imported, you
  use a function by calling it by its name, in the consequence or inside
  a semantic code block. Example:</p><pre><code class="no-highlight">rule "using a static function"
when 
    eval( true )
then
    System.out.println( hello( "Bob" ) );
end
</code></pre></div><div class="section" title="8.7. Type Declaration"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8212"/>8.7. Type Declaration</h2></div></div></div><div class="figure"><a id="d0e8215"/><p class="title"><strong>Figure 8.7. meta_data</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/meta_data.png" align="middle" alt="meta_data"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e8221"/><p class="title"><strong>Figure 8.8. type_declaration</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/type_declaration.png" align="middle" alt="type_declaration"/></div></div></div><br class="figure-break"/><p>Type declarations have two main goals in the rules engine: to allow
  the declaration of new types, and to allow the declaration of metadata for
  types.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>Declaring new types:</strong></span> Drools works
      out of the box with plain Java objects as facts. Sometimes, however,
      users may want to define the model directly to the rules engine, without
      worrying about creating models in a lower level language like Java. At
      other times, there is a domain model already built, but eventually the
      user wants or needs to complement this model with additional entities
      that are used mainly during the reasoning process.</p></li><li class="listitem"><p><span class="bold"><strong>Declaring metadata:</strong></span> facts may
      have meta information associated to them. Examples of meta information
      include any kind of data that is not represented by the fact attributes
      and is consistent among all instances of that fact type. This meta
      information may be queried at runtime by the engine and used in the
      reasoning process.</p></li></ul></div><div class="section" title="8.7.1. Declaring New Types"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8240"/>8.7.1. Declaring New Types</h3></div></div></div><p>To declare a new type, all you need to do is use the keyword
    <code class="literal">declare</code>, followed by the list of fields, and the
    keyword <code class="literal">end</code>. A new fact must have a list of fields,
    otherwise the engine will look for an existing fact class in the classpath
    and raise an error if not found.</p><div class="example"><a id="d0e8251"/><p class="title"><strong>Example 8.10. Declaring a new fact type: Address</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Address
   number : int
   streetName : String
   city : String
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>The previous example declares a new fact type called
    <code class="code">Address</code>. This fact type will have three attributes:
    <code class="code">number</code>, <code class="code">streetName</code> and <code class="code">city</code>. Each
    attribute has a type that can be any valid Java type, including any other
    class created by the user or even other fact types previously
    declared.</p><p>For instance, we may want to declare another fact type
    <code class="code">Person</code>:</p><div class="example"><a id="d0e8280"/><p class="title"><strong>Example 8.11. declaring a new fact type: Person</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : java.util.Date
    address : Address
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>As we can see on the previous example, <code class="code">dateOfBirth</code> is
    of type <code class="code">java.util.Date</code>, from the Java API, while
    <code class="code">address</code> is of the previously defined fact type
    Address.</p><p>You may avoid having to write the fully qualified name of a class
    every time you write it by using the <code class="literal">import</code> clause, as
    previously discussed.</p><div class="example"><a id="d0e8306"/><p class="title"><strong>Example 8.12. Avoiding the need to use fully qualified class names by using
      import</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>When you declare a new fact type, Drools will, at compile time,
    generate bytecode that implements a Java class representing the fact type.
    The generated Java class will be a one-to-one Java Bean mapping of the
    type definition. So, for the previous example, the generated Java class
    would be:</p><div class="example"><a id="d0e8320"/><p class="title"><strong>Example 8.13. generated Java class for the previous Person fact type
      declaration</strong></p><div class="example-contents"><pre><code class="language-java">public class Person implements Serializable {
    private String name;
    private java.util.Date dateOfBirth;
    private Address address;

    // empty constructor
    public Person() {...}

    // constructor with all fields 
    public Person( String name, Date dateOfBirth, Address address ) {...}

    // if keys are defined, constructor with keys
    public Person( ...keys... ) {...}

    // getters and setters
    // equals/hashCode
    // toString
}
</code></pre></div></div><br class="example-break"/><p>Since the generated class is a simple Java class, it can be used
    transparently in the rules, like any other fact.</p><div class="example"><a id="d0e8327"/><p class="title"><strong>Example 8.14. Using the declared types in rules</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> "Using a declared Type"
<span class="bold"><strong>when</strong></span> 
    $p : Person( name == "Bob" )
<span class="bold"><strong>then</strong></span>
    <span class="emphasis"><em>// Insert Mark, who is Bob's mate.</em></span>
    Person mark = new Person();
    mark.setName("Mark");
    insert( mark );
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><div class="section" title="8.7.1.1. Declaring enumerative types"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8346"/>8.7.1.1. Declaring enumerative types</h4></div></div></div><p>DRL also supports the declaration of enumerative types. Such type declarations require the additional keyword
			  <span class="emphasis"><em>enum</em></span>, followed by a comma separated list of admissible values terminated by a semicolon.
		  </p><div class="example"><a id="d0e8354"/><p class="title"><strong>Example 8.15. </strong></p><div class="example-contents"><pre><code class="no-highlight">
<span class="bold"><strong>declare enum</strong></span> DaysOfWeek
   SUN,MON,TUE,WED,THU,FRI,SAT;
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>The compiler will generate a valid Java enum, with static methods valueOf() and values(), as well as instance methods
			  ordinal(), compareTo() and name().</p><p>Complex enums are also partially supported, declaring the internal fields similarly to a regular type declaration.
			  Notice that as of version 6.x, enum fields do <span class="emphasis"><em>NOT</em></span> support other declared types or enums</p><div class="example"><a id="d0e8370"/><p class="title"><strong>Example 8.16. </strong></p><div class="example-contents"><pre><code class="no-highlight">
<span class="bold"><strong>declare enum</strong></span> DaysOfWeek
   SUN("Sunday"),MON("Monday"),TUE("Tuesday"),WED("Wednesday"),THU("Thursday"),FRI("Friday"),SAT("Saturday");

   fullName : String
<span class="bold"><strong>end</strong></span>
			  </code></pre></div></div><br class="example-break"/><p>Enumeratives can then be used in rules</p><div class="example"><a id="d0e8381"/><p class="title"><strong>Example 8.17. Using declarative enumerations in rules</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> "Using a declared Enum"
<span class="bold"><strong>when</strong></span>
   $p : Employee( dayOff == DaysOfWeek.MONDAY )
<span class="bold"><strong>then</strong></span>
   ...
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="8.7.2. Declaring Metadata"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8397"/>8.7.2. Declaring Metadata</h3></div></div></div><p>Metadata may be assigned to several different constructions in
    Drools: fact types, fact attributes and rules. Drools uses the at sign
    ('@') to introduce metadata, and it always uses the form:</p><pre><code class="no-highlight">@<span class="emphasis"><em>metadata_key</em></span>( <span class="emphasis"><em>metadata_value</em></span> )</code></pre><p>The parenthesized <span class="emphasis"><em>metadata_value</em></span> is
    optional.</p><p>For instance, if you want to declare a metadata attribute like
    <code class="code">author</code>, whose value is <span class="emphasis"><em>Bob</em></span>, you could
    simply write:</p><div class="example"><a id="d0e8423"/><p class="title"><strong>Example 8.18. Declaring a metadata attribute</strong></p><div class="example-contents"><pre><code class="no-highlight">@author( Bob )</code></pre></div></div><br class="example-break"/><p>Drools allows the declaration of any arbitrary metadata attribute,
    but some will have special meaning to the engine, while others are simply
    available for querying at runtime. Drools allows the declaration of
    metadata both for fact types and for fact attributes. Any metadata that is
    declared before the attributes of a fact type are assigned to the fact
    type, while metadata declared after an attribute are assigned to that
    particular attribute.</p><div class="example"><a id="d0e8430"/><p class="title"><strong>Example 8.19. Declaring metadata attributes for fact types and
      attributes</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )

    name : String <span class="emphasis"><em>@key @maxLength</em></span>( 30 )
    dateOfBirth : Date 
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>In the previous example, there are two metadata items declared for
    the fact type (<code class="code">@author</code> and <code class="code">@dateOfCreation</code>) and
    two more defined for the name attribute (<code class="code">@key</code> and
    <code class="code">@maxLength</code>). Please note that the <code class="code">@key</code> metadata
    has no required value, and so the parentheses and the value were
    omitted.:</p><div class="section" title="8.7.2.1. Predefined class level annotations"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8468"/>8.7.2.1. Predefined class level annotations</h4></div></div></div><p>Some annotations have predefined semantics that are interpreted by
      the engine. The following is a list of some of these predefined
      annotations and their meaning.</p><div class="section" title="8.7.2.1.1. @role( &lt;fact | event&gt; )"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8473"/>8.7.2.1.1. @role( &lt;fact | event&gt; )</h5></div></div></div><p>The @role annotation defines how the engine should handle instances of that type:
          either as regular facts or as events. It accepts two possible values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>fact : this is the default, declares that the type is to be
              handled as a regular fact.</p></li><li class="listitem"><p>event : declares that the type is to be handled as an
              event.</p></li></ul></div><p>The following example declares that the fact type StockTick in a stock broker
          application is to be handled as an event.</p><div class="example"><a id="d0e8487"/><p class="title"><strong>Example 8.20. declaring a fact type as an event</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> some.package.StockTick

<span class="bold"><strong>declare</strong></span> StockTick
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>The same applies to facts declared inline. If StockTick was a fact type declared in
          the DRL itself, instead of a previously existing class, the code would be:</p><div class="example"><a id="d0e8505"/><p class="title"><strong>Example 8.21. declaring a fact type and assigning it the event role</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> StockTick 
    <span class="emphasis"><em>@role</em></span>( event )

    datetime : java.util.Date
    symbol : String
    price : double
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.2.1.2. @typesafe( &lt;boolean&gt; )"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8518"/>8.7.2.1.2. @typesafe( &lt;boolean&gt; )</h5></div></div></div><p>By default all type declarations are compiled with type safety
        enabled; @typesafe( false ) provides a means to override this
        behaviour by permitting a fall-back, to type unsafe evaluation where
        all constraints are generated as MVEL constraints and executed
        dynamically. This can be important when dealing with collections that
        do not have any generics or mixed type collections.</p></div><div class="section" title="8.7.2.1.3. @timestamp( &lt;attribute name&gt; )"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8523"/>8.7.2.1.3. @timestamp( &lt;attribute name&gt; )</h5></div></div></div><p>Every event has an associated timestamp assigned to it. By default,
          the timestamp for a given event is read from the Session Clock and
          assigned to the event at the time the event is inserted into the working
          memory. Although, sometimes, the event has the timestamp as one of its
          own attributes. In this case, the user may tell the engine to use the
          timestamp from the event's attribute instead of reading it from the
          Session Clock.</p><pre><code class="no-highlight"><span class="emphasis"><em>@timestamp</em></span>( &lt;attributeName&gt; )</code></pre><p>To tell the engine what attribute to use as the source of the
          event's timestamp, just list the attribute name as a parameter to the
          @timestamp tag.</p><div class="example"><a id="d0e8534"/><p class="title"><strong>Example 8.22. declaring the VoiceCall timestamp attribute</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.2.1.4. @duration( &lt;attribute name&gt; )"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8550"/>8.7.2.1.4. @duration( &lt;attribute name&gt; )</h5></div></div></div><p>Drools supports both event semantics: point-in-time events and
          interval-based events. A point-in-time event is represented as an
          interval-based event whose duration is zero. By default, all events have
          duration zero. The user may attribute a different duration for an event by
          declaring which attribute in the event type contains the duration of the
          event.</p><pre><code class="no-highlight"><span class="emphasis"><em>@duration</em></span>( &lt;attributeName&gt; )</code></pre><p>So, for our VoiceCall fact type, the declaration would be:</p><div class="example"><a id="d0e8561"/><p class="title"><strong>Example 8.23. declaring the VoiceCall duration attribute</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.2.1.5. @expires( &lt;time interval&gt; )"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8579"/>8.7.2.1.5. @expires( &lt;time interval&gt; )</h5></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>This tag is only considered when running the engine in STREAM
            mode. Also, additional discussion on the effects of using this tag is
            made on the Memory Management section. It is included here for
            completeness.</p></div><p>Events may be automatically expired after some time in the working
          memory. Typically this happens when, based on the existing rules in the
          knowledge base, the event can no longer match and activate any rules.
          Although, it is possible to explicitly define when an event should
          expire.</p><pre><code class="no-highlight"><span class="emphasis"><em>@expires</em></span>( &lt;timeOffset&gt; )</code></pre><p>The value of <span class="emphasis"><em>timeOffset</em></span> is a temporal interval
          in the form:</p><pre><code class="no-highlight">[#d][#h][#m][#s][#[ms]]</code></pre><p>Where <span class="emphasis"><em>[ ]</em></span> means an optional parameter and
          <span class="emphasis"><em>#</em></span> means a numeric value.</p><p>So, to declare that the VoiceCall facts should be expired after 1
          hour and 35 minutes after they are inserted into the working memory, the
          user would write:</p><div class="example"><a id="d0e8608"/><p class="title"><strong>Example 8.24. declaring the expiration offset for the VoiceCall events</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
    <span class="emphasis"><em>@expires</em></span>( 1h35m )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>The @expires policy will take precedence and override the implicit
          expiration offset calculated from temporal constraints and sliding windows
          in the knowledge base.</p></div><div class="section" title="8.7.2.1.6. @propertyChangeSupport"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8631"/>8.7.2.1.6. @propertyChangeSupport</h5></div></div></div><p>Facts that implement support for property changes as defined in
        the Javabean(tm) spec, now can be annotated so that the engine
        register itself to listen for changes on fact properties. The boolean
        parameter that was used in the insert() method in the Drools 4 API is
        deprecated and does not exist in the drools-api module.</p><div class="example"><a id="d0e8636"/><p class="title"><strong>Example 8.25. @propertyChangeSupport</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  <span class="italic">@propertyChangeSupport</span>
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.2.1.7. @propertyReactive"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8648"/>8.7.2.1.7. @propertyReactive</h5></div></div></div><p>Make this type property reactive. See Fine grained property
        change listeners section for details.</p></div></div><div class="section" title="8.7.2.2. Predefined attribute level annotations"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8653"/>8.7.2.2. Predefined attribute level annotations</h4></div></div></div><p>As noted before, Drools also supports annotations in type
      attributes. Here is a list of predefined attribute annotations.</p><div class="section" title="8.7.2.2.1. @key"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8658"/>8.7.2.2.1. @key</h5></div></div></div><p>Declaring an attribute as a key attribute has 2 major effects on
        generated types:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The attribute will be used as a key identifier for the
              type, and as so, the generated class will implement the equals()
              and hashCode() methods taking the attribute into account when
              comparing instances of this type.</p></li><li class="listitem"><p>Drools will generate a constructor using all the key
              attributes as parameters.</p></li></ol></div><p>For instance:</p><div class="example"><a id="d0e8672"/><p class="title"><strong>Example 8.26. example of @key declarations for a type</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    firstName : String @key
    lastName : String @key
    age : int
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>For the previous example, Drools will generate equals() and
        hashCode() methods that will check the firstName and lastName
        attributes to determine if two instances of Person are equal to each
        other, but will not check the age attribute. It will also generate a
        constructor taking firstName and lastName as parameters, allowing one
        to create instances with a code like this:</p><div class="example"><a id="d0e8684"/><p class="title"><strong>Example 8.27. creating an instance using the key constructor</strong></p><div class="example-contents"><pre><code class="no-highlight">Person person = new Person( "John", "Doe" );</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.2.2.2. @position"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8689"/>8.7.2.2.2. @position</h5></div></div></div><p>Patterns support positional arguments on type declarations.</p><p>Positional arguments are ones where you don't need to specify the field name, as the
          position maps to a known named field. i.e. Person( name == "mark" ) can be rewritten as
          Person( "mark"; ). The semicolon ';' is important so that the engine knows that everything
          before it is a positional argument. Otherwise we might assume it was a boolean expression,
          which is how it could be interpreted after the semicolon. You can mix positional and named
          arguments on a pattern by using the semicolon ';' to separate them. Any variables used in
          a positional that have not yet been bound will be bound to the field that maps to that
          position.</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String
    shop : String
    price : int
<span class="bold"><strong>end</strong></span>
</code></pre><p>The default order is the declared order, but this can be overridden using
          @position</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String <span class="italic">@position(1)</span>
    shop : String <span class="italic">@position(2)</span>
    price : int <span class="italic">@position(0)</span>
<span class="bold"><strong>end</strong></span>
</code></pre><p>The @Position annotation, in the org.drools.definition.type package, can be used to
          annotate original pojos on the classpath. Currently only fields on classes can be
          annotated. Inheritance of classes is supported, but not interfaces of methods yet.</p><p>Example patterns, with two constraints and a binding. Remember semicolon ';' is used
          to differentiate the positional section from the named argument section. Variables and
          literals and expressions using just literals are supported in positional arguments, but
          not variables.</p><pre><code class="no-highlight">
Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
</code></pre><p>@Position is inherited when beans extend each other; while not recommended, two fields
          may have the same @position value, and not all consecutive values need be declared. If a
          @position is repeated, the conflict is solved using inheritance (fields in the superclass
          have the precedence) and the declaration order. If a @position value is missing, the first
          field without an explicit @position (if any) is selected to fill the gap. As always,
          conflicts are resolved by inheritance and declaration order.</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String 
    shop : String <span class="italic">@position(2)</span>
    price : int <span class="italic">@position(0)</span>
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> SeasonedCheese <span class="bold"><strong>extends</strong></span> Cheese
    year : Date <span class="italic">@position(0)</span>
    origin : String <span class="italic">@position(6)</span>
    country : String    
<span class="bold"><strong>end</strong></span></code></pre><p>In the example, the field order would be : price (@position 0 in the superclass),
            year (@position 0 in the subclass), name (first field with no @position), shop
            (@position 2), country (second field without @position), origin.</p></div></div></div><div class="section" title="8.7.3. Declaring Metadata for Existing Types"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8758"/>8.7.3. Declaring Metadata for Existing Types</h3></div></div></div><p>Drools allows the declaration of metadata attributes for existing
    types in the same way as when declaring metadata attributes for new fact
    types. The only difference is that there are no fields in that
    declaration.</p><p>For instance, if there is a class org.drools.examples.Person, and
    one wants to declare metadata for it, it's possible to write the following
    code:</p><div class="example"><a id="d0e8765"/><p class="title"><strong>Example 8.28. Declaring metadata for an existing type</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.examples.Person

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"/><p>Instead of using the import, it is also possible to reference the
    class by its fully qualified name, but since the class will also be
    referenced in the rules, it is usually shorter to add the import and use
    the short class name everywhere.</p><div class="example"><a id="d0e8786"/><p class="title"><strong>Example 8.29. Declaring metadata using the fully qualified class name</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> org.drools.examples.Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/></div><div class="section" title="8.7.4. Parametrized constructors for declared types"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8801"/>8.7.4. Parametrized constructors for declared types</h3></div></div></div><p>Generate constructors with parameters for declared types.</p><p>Example: for a declared type like the following:</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    firstName : String <span class="italic">@key</span>
    lastName : String <span class="italic">@key</span>
    age : int
<span class="bold"><strong>end</strong></span>
</code></pre><p>The compiler will implicitly generate 3 constructors: one without
    parameters, one with the @key fields, and one with all fields.</p><pre><code class="no-highlight">Person() // parameterless constructor
Person( String firstName, String lastName )
Person( String firstName, String lastName, int age )</code></pre></div><div class="section" title="8.7.5. Non Typesafe Classes"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8825"/>8.7.5. Non Typesafe Classes</h3></div></div></div><p>@typesafe( &lt;boolean&gt;) has been added to type declarations. By
    default all type declarations are compiled with type safety enabled;
    @typesafe( false ) provides a means to override this behaviour by
    permitting a fall-back, to type unsafe evaluation where all constraints
    are generated as MVEL constraints and executed dynamically. This can be
    important when dealing with collections that do not have any generics or
    mixed type collections.</p></div><div class="section" title="8.7.6. Accessing Declared Types from the Application Code"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8830"/>8.7.6. Accessing Declared Types from the Application Code</h3></div></div></div><p>Declared types are usually used inside rules files, while Java
    models are used when sharing the model between rules and applications.
    Although, sometimes, the application may need to access and handle facts
    from the declared types, especially when the application is wrapping the
    rules engine and providing higher level, domain specific user interfaces
    for rules management.</p><p>In such cases, the generated classes can be handled as usual with
    the Java Reflection API, but, as we know, that usually requires a lot of
    work for small results. Therefore, Drools provides a simplified API for
    the most common fact handling the application may want to do.</p><p>The first important thing to realize is that a declared fact will
    belong to the package where it was declared. So, for instance, in the
    example below, <code class="code">Person</code> will belong to the
    <code class="code">org.drools.examples</code> package, and so the fully qualified name
    of the generated class will be
    <code class="code">org.drools.examples.Person</code>.</p><div class="example"><a id="d0e8848"/><p class="title"><strong>Example 8.30. Declaring a type in the org.drools.examples package</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>package</strong></span> org.drools.examples

<span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>Declared types, as discussed previously, are generated at knowledge
    base compilation time, i.e., the application will only have access to them
    at application run time. Therefore, these classes are not available for
    direct reference from the application.</p><p>Drools then provides an interface through which users can handle
    declared types from the application code:
    <code class="code">org.drools.definition.type.FactType</code>. Through this interface,
    the user can instantiate, read and write fields in the declared fact
    types.</p><div class="example"><a id="d0e8870"/><p class="title"><strong>Example 8.31. Handling declared fact types through the API</strong></p><div class="example-contents"><pre><code class="no-highlight">// get a reference to a knowledge base with a declared type:
KieBase kbase = ...

// get the declared FactType
FactType personType = kbase.getFactType( "org.drools.examples",
                                         "Person" );

// handle the type as necessary:
// create instances:
Object bob = personType.newInstance();

// set attributes values
personType.set( bob,
                "name",
                "Bob" );
personType.set( bob,
                "age",
                42 );

// insert fact into a session
KieSession ksession = ...
ksession.insert( bob );
ksession.fireAllRules();

// read attributes
String name = personType.get( bob, "name" );
int age = personType.get( bob, "age" );

</code></pre></div></div><br class="example-break"/><p>The API also includes other helpful methods, like setting all the
    attributes at once, reading values from a Map, or reading all attributes
    at once, into a Map.</p><p>Although the API is similar to Java reflection (yet much simpler to
    use), it does not use reflection underneath, relying on much more
    performant accessors implemented with generated bytecode.</p></div><div class="section" title="8.7.7. Type Declaration 'extends'"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8879"/>8.7.7. Type Declaration 'extends'</h3></div></div></div><p>Type declarations now support 'extends' keyword for
    inheritance</p><p>In order to extend a type declared in Java by a DRL declared
    subtype, repeat the supertype in a declare statement without any
    fields.</p><pre><code class="no-highlight">b org.people.Person

<span class="bold"><strong>declare</strong></span> Person <span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> Student <span class="bold"><strong>extends</strong></span> Person
    school : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> LongTermStudent <span class="bold"><strong>extends</strong></span> Student
    years : int
    course : String
<span class="bold"><strong>end</strong></span></code></pre></div><div class="section" title="8.7.8. Traits"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8911"/>8.7.8. Traits</h3></div></div></div><p>WARNING : this feature is still experimental and subject to changes</p><p>The same fact may have multiple dynamic types which do not fit naturally in a class
      hierarchy. Traits allow to model this very common scenario. A trait is an interface that can
      be applied (and eventually removed) to an individual object at runtime. To create a trait
      rather than a traditional bean, one has to declare them explicitly as in the following
      example:</p><div class="example"><a id="d0e8918"/><p class="title"><strong>Example 8.32. </strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer
    // fields will map to getters/setters
    code     : String
    balance  : long
    discount : int
    maxExpense : long
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>At runtime, this declaration results in an interface, which can be used to write patterns,
      but can not be instantiated directly. In order to apply a trait to an object, we provide the
      new don keyword, which can be used as simply as this:</p><div class="example"><a id="d0e8930"/><p class="title"><strong>Example 8.33. </strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $c : Customer()
then
    GoldenCustomer gc = don( $c, GoldenCustomer.class );
end</code></pre></div></div><br class="example-break"/><p>when a core object dons a trait, a proxy class is created on the fly (one such class will
      be generated lazily for each core/trait class combination). The proxy instance, which wraps
      the core object and implements the trait interface, is inserted automatically and will
      possibly activate other rules. An immediate advantage of declaring and using interfaces,
      getting the implementation proxy for free from the engine, is that multiple inheritance
      hierarchies can be exploited when writing rules. The core classes, however, need not implement
      any of those interfaces statically, also facilitating the use of legacy classes as cores. In
      fact, any object can don a trait, provided that they are declared as @Traitable. Notice that
      this annotation used to be optional, but now is mandatory.</p><div class="example"><a id="d0e8935"/><p class="title"><strong>Example 8.34. </strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.core.factmodel.traits.Traitable;
<span class="bold"><strong>declare</strong></span> Customer
    <span class="italic">@Traitable</span>
    code    : String
    balance : long
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>The only connection between core classes and trait interfaces is at the proxy level: a
      trait is not specifically tied to a core class. This means that the same trait can be applied
      to totally different objects. For this reason, the trait does not transparently expose the
      fields of its core object. So, when writing a rule using a trait interface, only the fields of
      the interface will be available, as usual. However, any field in the interface that
      corresponds to a core object field, will be mapped by the proxy class:</p><div class="example"><a id="d0e8950"/><p class="title"><strong>Example 8.35. </strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $o: OrderItem( $p : price, $code : custCode )
    $c: GoldenCustomer( code == $code, $a : balance, $d: discount )
then
    $c.setBalance( $a - $p*$d );
end</code></pre></div></div><br class="example-break"/><p>In this case, the code and balance would be read from the underlying Customer object.
      Likewise, the setAccount will modify the underlying object, preserving a strongly typed access
      to the data structures. A hard field must have the same name and type both in the core class
      and all donned interfaces. The name is used to establish the mapping: if two fields have the
      same name, then they must also have the same declared type. The annotation
      @org.drools.core.factmodel.traits.Alias allows to relax this restriction. If an @Alias is
      provided, its value string will be used to resolve mappings instead of the original field
      name. @Alias can be applied both to traits and core beans. </p><div class="example"><a id="d0e8955"/><p class="title"><strong>Example 8.36. </strong></p><div class="example-contents"><pre><code class="no-highlight">import org.drools.core.factmodel.traits.*;
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer
    balance : long <span class="italic">@Alias( "org.acme.foo.accountBalance" )</span>
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> Person
    <span class="italic">@Traitable</span>
    name : String
    savings : long <span class="italic">@Alias( "org.acme.foo.accountBalance" )</span>
<span class="bold"><strong>end</strong></span>

when
    GoldenCustomer( balance &gt; 1000 ) // will react to new Person( 2000 )
then
end
</code></pre></div></div><br class="example-break"/><p>More work is being done on reaxing this constraint (see the experimental section on
      "logical" traits later). Now, one might wonder what happens when a core class does NOT provide
      the implementation for a field defined in an interface. We call hard fields those trait fields
      which are also core fields and thus readily available, while we define soft those fields which
      are NOT provided by the core class. Hidden fields, instead, are fields in the core class not
      exposed by the interface.</p><p>So, while hard field management is intuitive, there remains the problem of soft and hidden
      fields. Hidden fields are normally only accessible using the core class directly. However, the
      "fields" Map can be used on a trait interface to access a hidden field. If the field can't be
      resolved, null will be returned. Notice that this feature is likely to change in the
      future.</p><div class="example"><a id="d0e8986"/><p class="title"><strong>Example 8.37. </strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $sc : GoldenCustomer( fields[ "age" ] &gt; 18 )  // age is declared by the underlying core class, but not by GoldenCustomer
then</code></pre></div></div><br class="example-break"/><p>Soft fields, instead, are stored in a Map-like data structure that is specific to each
      core object and referenced by the proxy(es), so that they are effectively shared even when an
      object dons multiple traits.</p><div class="example"><a id="d0e8991"/><p class="title"><strong>Example 8.38. </strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $sc : GoldenCustomer( $c : code, // hard getter
                          $maxExpense : maxExpense &gt; 1000 // soft getter
    )
then
    $sc.setDiscount( ... ); // soft setter
end</code></pre></div></div><br class="example-break"/><p>A core object also holds a reference to all its proxies, so that it is possible to track
      which type(s) have been added to an object, using a sort of dynamic "instanceof" operator,
      which we called isA. The operator can accept a String, a class literal or a list of class
      literals. In the latter case, the constraint is satisfied only if all the traits have been
      donned. </p><div class="example"><a id="d0e8996"/><p class="title"><strong>Example 8.39. </strong></p><div class="example-contents"><pre><code class="no-highlight">$sc : GoldenCustomer( $maxExpense : maxExpense &gt; 1000,
                      this isA "SeniorCustomer", this isA [ NationalCustomer.class, OnlineCustomer.class ]
)</code></pre></div></div><br class="example-break"/><p>Eventually, the business logic may require that a trait is removed from a wrapped object.
      To this end, we provide two options. The first is a "logical don", which will result in a
      logical insertion of the proxy resulting from the traiting operation. The TMS will ensure that
      the trait is removed when its logical support is removed in the first place.</p><div class="example"><a id="d0e9001"/><p class="title"><strong>Example 8.40. </strong></p><div class="example-contents"><pre><code class="no-highlight">then
    <span class="bold"><strong>don</strong></span>( $x, // core object
         Customer.class, // trait class
         true // optional flag for logical insertion
    )
    </code></pre></div></div><br class="example-break"/><p>The second is the use of the "shed" keyword, which causes the removal of any type that is
      a subtype (or equivalent) of the one passed as an argument. Notice that, as of version 5.5,
      shed would only allow to remove a single specific trait.</p><div class="example"><a id="d0e9009"/><p class="title"><strong>Example 8.41. </strong></p><div class="example-contents"><pre><code class="no-highlight">then
    Thing t = <span class="bold"><strong>shed</strong></span>( $x, GoldenCustomer.class ) // also removes any trait that</code></pre></div></div><br class="example-break"/><p>This operation returns another proxy implementing the org.drools.core.factmodel.traits.Thing interface, where
      the getFields() and getCore()
      methods are defined. Internally, in fact, all declared traits are generated to extend this interface (in addition
      to any others specified).      This allows to preserve the wrapper with the soft fields which would otherwise be lost.</p><p>A trait and its proxies are also correlated in another way. Starting from version 5.6,
      whenever a core object is "modified", its proxies are "modified" automatically as well, to
      allow trait-based patterns to react to potential changes in hard fields. Likewise, whenever a
      trait proxy (mached by a trait pattern) is modified, the modification is propagated to the
      core class and the other traits. Morover, whenever a don operation is performed, the core
      object is also modified automatically, to reevaluate any "isA" operation which may be
      triggered.</p><p>Potentially, this may result in a high number of modifications, impacting performance (and
      correctness) heavily. So two solutions are currently implemented. First, whenever a core
      object is modified, only the most specific traits (in the sense of inheritance between trait
      interfaces) are updated and an internal blocking mechanism is in place to ensure that each
      potentially matching pattern is evaluated once and only once. So, in the following
      situation:</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span>
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> NationalGoldenustomer <span class="bold"><strong>extends</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span>
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> SeniorGoldenCustomer <span class="bold"><strong>extends</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span></code></pre><p>a modification of an object that is both a GoldenCustomer, a NationalGoldenCustomer and a
      SeniorGoldenCustomer wold cause only the latter two proxies to be actually modified. The
      first would match any pattern for GoldenCustomer and NationalGoldenCustomer; the latter would
      instead be prevented from rematching GoldenCustomer, but would be allowed to match
      SeniorGoldenCustomer patterns. It is not necessary, instead, to modify the GoldenCustomer
      proxy since it is already covered by at least one other more specific trait.</p><p>The second method, up to the usr, is to mark traits as @PropertyReactive. Property
      reactivity is trait-enabled and takes into account the trait field mappings, so to block
      unnecessary propagations. </p><div class="section" title="8.7.8.1. Cascading traits"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9058"/>8.7.8.1. Cascading traits</h4></div></div></div><p><span class="bold"><strong>WARNING</strong></span> : This feature is extremely experimental and
        subject to changes</p><p>Normally, a hard field must be exposed with its original type by all traits donned by an
        object, to prevent situations such as</p><div class="example"><a id="d0e9067"/><p class="title"><strong>Example 8.42. </strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  @Traitable
  name : String
  id : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer
  id : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Patient
  id : long  // Person can't don Patient, or an exception will be thrown
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><p>Should a Person don both Customer and Patient, the type of the hard field id would be
        ambiguous. However, consider the following example, where GoldenCustomers refer their best
        friends so that they become Customers as well:</p><div class="example"><a id="d0e9094"/><p class="title"><strong>Example 8.43. </strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  @Traitable( logical=true )
  bestFriend : Person
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer <span class="bold"><strong>end</strong></span>
        
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer <span class="bold"><strong>extends</strong></span> Customer
  refers : Customer <span class="italic">@Alias( "bestFriend" )</span>
<span class="bold"><strong>end</strong></span>          </code></pre></div></div><br class="example-break"/><p>Aside from the @Alias, a Person-as-GoldenCustomer's best friend might be compatible with
        the requirements of the trait GoldenCustomer, provided that they are some kind of Customer
        themselves. Marking a Person as "logically traitable" - i.e. adding the annotation
        @Traitable( logical = true ) - will instruct the engine to try and preserve the logical
        consistency rather than throwing an exception due to a hard field with different type
        declarations (Person vs Customer). The following operations would then work:</p><div class="example"><a id="d0e9128"/><p class="title"><strong>Example 8.44. </strong></p><div class="example-contents"><pre><code class="no-highlight">Person p1 = new Person();
Person p2 = new Person();
p1.setBestFriend( p2 );
...
Customer c2 = don( p2, Customer.class );
...
GoldenCustomer gc1 = don( p1, GoldenCustomer.class );
...
p1.getBestFriend(); // returns p2
gc1.getRefers(); // returns c2, a Customer proxy wrapping p2</code></pre></div></div><br class="example-break"/><p>Notice that, by the time p1 becomes GoldenCustomer, p2 must have already become a
        Customer themselves, otherwise a runtime exception will be thrown since the very definition
        of GoldenCustomer would have been violated.</p><p>In some cases, however, one might want to infer, rather than verify, that p2 is a
        Customer by virtue that p1 is a GoldenCustomer. This modality can be enabled by marking
        Customer as "logical", using the annotation @org.drools.core.factmodel.traits.Trait( logical
        = true ). In this case, should p2 not be a Customer by the time that p1 becomes a
        GoldenCustomer, it will be automatically don the trait Customer to preserve the logical
        integrity of the system.</p><p>Notice that the annotation on the core class enables the dynamic type management for its
        fields, whereas the annotation on the traits determines whether they will be enforced as
        integrity constraints or cascaded dynamically.</p><div class="example"><a id="d0e9137"/><p class="title"><strong>Example 8.45. </strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.factmodel.traits.*;

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer
    <span class="italic">@Trait( logical = true )</span>
<span class="bold"><strong>end</strong></span>        </code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="8.8. Rule"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9154"/>8.8. Rule</h2></div></div></div><div class="figure"><a id="d0e9157"/><p class="title"><strong>Figure 8.9. rule</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/rule.png" align="middle" alt="rule"/></div></div></div><br class="figure-break"/><p>A rule specifies that <span class="emphasis"><em>when</em></span> a particular set of
  conditions occur, specified in the Left Hand Side (LHS),
  <span class="emphasis"><em>then</em></span> do what queryis specified as a list of actions in
  the Right Hand Side (RHS). A common question from users is "Why use when
  instead of if?" "When" was chosen over "if" because "if" is normally part of
  a procedural execution flow, where, at a specific point in time, a condition
  is to be checked. In contrast, "when" indicates that the condition
  evaluation is not tied to a specific evaluation sequence or point in time,
  but that it happens continually, at any time during the life time of the
  engine; whenever the condition is met, the actions are executed.</p><p>A rule must have a name, unique within its rule package. If you define
  a rule twice in the same DRL it produces an error while loading. If you add
  a DRL that includes a rule name already in the package, it replaces the
  previous rule. If a rule name is to have spaces, then it will need to be
  enclosed in double quotes (it is best to always use double quotes).</p><p>Attributes - described below - are optional. They are best written one
  per line.</p><p>The LHS of the rule follows the <code class="literal">when</code> keyword
  (ideally on a new line), similarly the RHS follows the
  <code class="literal">then</code> keyword (again, ideally on a newline). The rule is
  terminated by the keyword <code class="literal">end</code>. Rules cannot be
  nested.</p><div class="example"><a id="d0e9186"/><p class="title"><strong>Example 8.46. Rule Syntax Overview</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e9191"/><p class="title"><strong>Example 8.47. A simple rule</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</code></pre></div></div><br class="example-break"/><div class="section" title="8.8.1. Rule Attributes"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9196"/>8.8.1. Rule Attributes</h3></div></div></div><p>Rule attributes provide a declarative way to influence the behavior
    of the rule. Some are quite simple, while others are part of complex
    subsystems such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</p><div class="figure"><a id="d0e9201"/><p class="title"><strong>Figure 8.10. rule attributes</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/rule_attributes.png" align="middle" alt="rule attributes"/></div></div></div><br class="figure-break"/><div class="variablelist"><dl><dt><span class="term"><code class="literal">no-loop</code></span></dt><dd><p>default value: <code class="literal">false</code></p><p>type: Boolean</p><p>When a rule's consequence modifies a fact it may cause the
          rule to activate again, causing an infinite loop. Setting no-loop to
          true will skip the creation of another Activation for the rule with
          the current set of facts.</p></dd><dt><span class="term"><code class="literal">ruleflow-group</code></span></dt><dd><p>default value: N/A</p><p>type: String</p><p>Ruleflow is a Drools feature that lets you exercise control
          over the firing of rules. Rules that are assembled by the same
          ruleflow-group identifier fire only when their group is
          active.</p></dd><dt><span class="term"><code class="literal">lock-on-active</code></span></dt><dd><p>default value: <code class="literal">false</code></p><p>type: Boolean</p><p>Whenever a ruleflow-group becomes active or an agenda-group
          receives the focus, any rule within that group that has
          lock-on-active set to true will not be activated any more;
          irrespective of the origin of the update, the activation of a
          matching rule is discarded. This is a stronger version of no-loop,
          because the change could now be caused not only by the rule itself.
          It's ideal for calculation rules where you have a number of rules
          that modify a fact and you don't want any rule re-matching and
          firing again. Only when the ruleflow-group is no longer active or
          the agenda-group loses the focus those rules with lock-on-active set
          to true become eligible again for their activations to be placed
          onto the agenda.</p></dd><dt><span class="term"><code class="literal">salience</code></span></dt><dd><p>default value: <code class="literal">0</code></p><p>type: integer</p><p>Each rule has an integer salience attribute which defaults to
          zero and can be negative or positive. Salience is a form of priority
          where rules with higher salience values are given higher priority
          when ordered in the Activation queue.</p><p>Drools also supports dynamic salience where you can use an
          expression involving bound variables.</p><div class="example"><a id="d0e9260"/><p class="title"><strong>Example 8.48. Dynamic Salience</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Fire in rank order 1,2,.."
        salience( -$rank )
    when
        Element( $rank : rank,... )
    then
        ...
end</code></pre></div></div><br class="example-break"/></dd><dt><span class="term"><code class="literal">agenda-group</code></span></dt><dd><p>default value: MAIN</p><p>type: String</p><p>Agenda groups allow the user to partition the Agenda providing
          more execution control. Only rules in the agenda group that has
          acquired the focus are allowed to fire.</p></dd><dt><span class="term"><code class="literal">auto-focus</code></span></dt><dd><p>default value: <code class="literal">false</code></p><p>type: Boolean</p><p>When a rule is activated where the <code class="code">auto-focus</code>
          value is true and the rule's agenda group does not have focus yet,
          then it is given focus, allowing the rule to potentially
          fire.</p></dd><dt><span class="term"><code class="literal">activation-group</code></span></dt><dd><p>default value: N/A</p><p>type: String</p><p>Rules that belong to the same activation-group, identified by
          this attribute's string value, will only fire exclusively. More
          precisely, the first rule in an activation-group to fire will
          cancel all pending activations of all rules in the group, i.e., stop
          them from firing.</p><p>Note: This used to be called Xor group, but technically it's
          not quite an Xor. You may still hear people mention Xor group; just
          swap that term in your mind with activation-group.</p></dd><dt><span class="term"><code class="literal">dialect</code></span></dt><dd><p>default value: as specified by the package</p><p>type: String</p><p>possible values: "java" or "mvel"</p><p>The dialect species the language to be used for any code
          expressions in the LHS or the RHS code block. Currently two dialects
          are available, Java and MVEL. While the dialect can be specified at
          the package level, this attribute allows the package definition to
          be overridden for a rule.</p></dd><dt><span class="term"><code class="literal">date-effective</code></span></dt><dd><p>default value: N/A</p><p>type: String, containing a date and time definition</p><p>A rule can only activate if the current date and time is after
          date-effective attribute.</p></dd><dt><span class="term"><code class="literal">date-expires</code></span></dt><dd><p>default value: N/A</p><p>type: String, containing a date and time definition</p><p>A rule cannot activate if the current date and time is after
          the date-expires attribute.</p></dd><dt><span class="term"><code class="literal">duration</code></span></dt><dd><p>default value: no default value</p><p>type: long</p><p>The duration dictates that the rule will fire after a
          specified duration, if it is still true.</p></dd></dl></div><div class="example"><a id="d0e9351"/><p class="title"><strong>Example 8.49. Some attribute examples</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.2. Timers and Calendars"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9356"/>8.8.2. Timers and Calendars</h3></div></div></div><p>Rules now support both interval and cron based timers, which replace
    the now deprecated duration attribute.</p><div class="example"><a id="d0e9361"/><p class="title"><strong>Example 8.50. Sample timer attribute uses</strong></p><div class="example-contents"><pre><code class="language-java">timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt;? )
timer ( int: 30s )
timer ( int: 30s 5m )

timer ( cron: &lt;cron expression&gt; )
timer ( cron:* 0/15 * * * ? )</code></pre></div></div><br class="example-break"/><p>Interval (indicated by "int:") timers follow the semantics of
    java.util.Timer objects, with an initial delay and an optional repeat
    interval. Cron (indicated by "cron:") timers follow standard Unix cron
    expressions:</p><div class="example"><a id="d0e9368"/><p class="title"><strong>Example 8.51. A Cron Example</strong></p><div class="example-contents"><pre><code class="language-java">rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end</code></pre></div></div><br class="example-break"/><p>A rule controlled by a timer becomes active when it matches, and
    once for each individual match. Its consequence is executed
    repeatedly, according to the timer's settings. This stops as soon
    as the condition doesn't match any more.</p><p>Consequences are executed even after control returns from a call
    to fireUntilHalt. Moreover, the Engine remains reactive to any
    changes made to the Working Memory. For instance, removing a fact
    that was involved in triggering the timer rule's execution causes
    the repeated execution to terminate, or inserting a fact so that
    some rule matches will cause that rule to fire. But the Engine is
    not continually active, only after a rule fires, for whatever
    reason. Thus, reactions to an insertion done asynchronously will
    not happen until the next execution of a timer-controlled rule.
    Disposing a session puts an end to all timer activity.</p><p>Conversely when the rule engine runs in passive mode (i.e.: using fireAllRules
    instead of fireUntilHalt) by default it doesn't fire consequences of timed rules
    unless fireAllRules isn't invoked again. However it is possible to change this
    default behavior by configuring the KieSession with a <code class="code">TimedRuleExectionOption</code>
    as shown in the following example.</p><div class="example"><a id="d0e9382"/><p class="title"><strong>Example 8.52. Configuring a KieSession to automatically execute timed rules</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExectionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, null);</code></pre></div></div><br class="example-break"/><p>It is also possible to have a finer grained control on the timed rules that have to be
    automatically executed. To do this it is necessary to set a <code class="code">FILTERED</code>
    <code class="code">TimedRuleExectionOption</code> that allows to define a callback to filter those
    rules, as done in the next example.</p><div class="example"><a id="d0e9395"/><p class="title"><strong>Example 8.53. Configuring a filter to choose which timed rules should be automatically executed</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( new TimedRuleExectionOption.FILTERED(new TimedRuleExecutionFilter() {
    public boolean accept(Rule[] rules) {
        return rules[0].getName().equals("MyRule");
    }
}) );</code></pre></div></div><br class="example-break"/><p>For what regards interval timers it is also possible to define both the delay
    and interval as an expression instead of a fixed value. To do that it is necessary to
    use an expression timer (indicated by "expr:") as in the following example:</p><div class="example"><a id="d0e9402"/><p class="title"><strong>Example 8.54. An Expression Timer Example</strong></p><div class="example-contents"><pre><code class="language-java">declare Bean
    delay   : String = "30s"
    period  : long = 60000
end

rule "Expression timer"
    timer( expr: $d, $p )
when
    Bean( $d : delay, $p : period )
then
end</code></pre></div></div><br class="example-break"/><p>The expressions, $d and $p in this case, can use any variable defined in the
    pattern matching part of the rule and can be any String that can be parsed in a time
    duration or any numeric value that will be internally converted in a long representing
    a duration expressed in milliseconds.</p><p>Both interval and expression timers can have 3 optional parameters named
    "start", "end" and "repeat-limit". When one or more of these parameters are used the first
    part of the timer definition must be followed by a semicolon ';' and the parameters have
    to be separated by a comma ',' as in the following example:</p><div class="example"><a id="d0e9411"/><p class="title"><strong>Example 8.55. An Interval Timer with a start and an end</strong></p><div class="example-contents"><pre><code class="language-java">timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)</code></pre></div></div><br class="example-break"/><p>The value for start and end parameters can be a Date, a String representing
    a Date or a long, or more in general any Number, that will be transformed in a Java Date
    applying the following conversion:</p><pre><code class="language-java">new Date( ((Number) n).longValue() )</code></pre><p>Conversely the repeat-limit can be only an integer and it defines the maximum
    number of repetitions allowed by the timer. If both the end and the repeat-limit parameters
    are set the timer will stop when the first of the two will be matched.</p><p>The using of the start parameter implies the definition of a phase for the timer,
    where the beginning of the phase is given by the start itself plus the eventual delay.
    In other words in this case the timed rule will then be scheduled at times:</p><pre><code class="language-java">start + delay + n*period</code></pre><p>for up to repeat-limit times and no later than the end timestamp (whichever first).
    For instance the rule having the following interval timer</p><pre><code class="language-java">timer ( int: 30s 1m; start="3-JAN-2010" )</code></pre><p>will be scheduled at the 30th second of every minute after the midnight of the
    3-JAN-2010. This also means that if for example you turn the system on at midnight of
    the 3-FEB-2010 it won't be scheduled immediately but will preserve the phase defined by
    the timer and so it will be scheduled for the first time 30 seconds after the midnight.
    If for some reason the system is paused (e.g. the session is serialized and then deserialized
    after a while) the rule will be scheduled only once to recover from missing activations
    (regardless of how many activations we missed) and subsequently it will be scheduled
    again in phase with the timer.</p><p>Calendars are used to control when rules can fire. The Calendar API
    is modelled on <a class="link" href="http://www.quartz-scheduler.org/">Quartz</a>:</p><div class="example"><a id="d0e9437"/><p class="title"><strong>Example 8.56. Adapting a Quartz Calendar</strong></p><div class="example-contents"><pre><code class="language-java">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</code></pre></div></div><br class="example-break"/><p>Calendars are registered with the KieSession:</p><div class="example"><a id="d0e9444"/><p class="title"><strong>Example 8.57. Registering a Calendar</strong></p><div class="example-contents"><pre><code class="language-java">ksession.getCalendars().set( "weekday", weekDayCal );</code></pre></div></div><br class="example-break"/><p>They can be used in conjunction with normal rules and rules
    including timers. The rule attribute "calendars" may contain one or more
    comma-separated calendar names written as string literals.</p><div class="example"><a id="d0e9451"/><p class="title"><strong>Example 8.58. Using Calendars and Timers together</strong></p><div class="example-contents"><pre><code class="language-java">rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm" );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm" );
end</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3. Left Hand Side (when) syntax"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9456"/>8.8.3. Left Hand Side (when) syntax</h3></div></div></div><div class="section" title="8.8.3.1. What is the Left Hand Side?"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9459"/>8.8.3.1. What is the Left Hand Side?</h4></div></div></div><p>The Left Hand Side (LHS) is a common name for the conditional part
      of the rule. It consists of zero or more Conditional Elements. If the
      LHS is empty, it will be considered as a condition element that is
      always true and it will be activated once, when a new WorkingMemory
      session is created.</p><div class="figure"><a id="d0e9464"/><p class="title"><strong>Figure 8.11. Left Hand Side</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/lhs.png" align="middle" alt="Left Hand Side"/></div></div></div><br class="figure-break"/><div class="example"><a id="d0e9470"/><p class="title"><strong>Example 8.59. Rule without a Conditional Element</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "no CEs"
when
    // empty
then
    ... // actions (executed once)
end

// The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    ... // actions (executed once)
end</code></pre></div></div><br class="example-break"/><p>Conditional elements work on one or more
      <span class="emphasis"><em>patterns</em></span> (which are described below). The most
      common conditional element is "<code class="literal">and"</code>. Therefore it is
      implicit when you have multiple patterns in the LHS of a rule that are
      not connected in any way:</p><div class="example"><a id="d0e9483"/><p class="title"><strong>Example 8.60. Implicit and</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "2 unconnected patterns"
when
    Pattern1()
    Pattern2()
then
    ... // actions
end

// The above rule is internally rewritten as:

rule "2 and connected patterns"
when
    Pattern1()
    and Pattern2()
then
    ... // actions
end</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>An "<code class="literal">and"</code> cannot have a leading declaration
        binding (unlike for example <code class="literal">or</code>). This is obvious,
        since a declaration can only reference a single fact at a time, and
        when the "<code class="literal">and"</code> is satisfied it matches both facts -
        so which fact would the declaration bind to?</p><pre><code class="no-highlight">// Compile error
$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))</code></pre></div></div><div class="section" title="8.8.3.2. Pattern (conditional element)"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9502"/>8.8.3.2. Pattern (conditional element)</h4></div></div></div><div class="section" title="8.8.3.2.1. What is a pattern?"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9505"/>8.8.3.2.1. What is a pattern?</h5></div></div></div><p>A pattern element is the most important Conditional Element. It
        can potentially match on each fact that is inserted in the working
        memory.</p><p>A pattern contains of zero or more constraints and has an
        optional pattern binding. The railroad diagram below shows the syntax
        for this.</p><div class="figure"><a id="d0e9512"/><p class="title"><strong>Figure 8.12. Pattern</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/pattern.png" align="middle" alt="Pattern"/></div></div></div><br class="figure-break"/><p>In its simplest form, with no constraints, a pattern matches
        against a fact of the given type. In the following case the type is
        <code class="code">Cheese</code>, which means that the pattern will match against
        all <code class="code">Person</code> objects in the Working Memory:</p><pre><code class="no-highlight">Person()</code></pre><p>The type need not be the actual class of some fact object.
        Patterns may refer to superclasses or even interfaces, thereby
        potentially matching facts from many different classes.</p><pre><code class="no-highlight">Object() // matches all objects in the working memory</code></pre><p>Inside of the pattern parenthesis is where all the action
        happens: it defines the constraints for that pattern. For example,
        with a age related constraint:</p><pre><code class="no-highlight">Person( age == 100 )</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For backwards compatibility reasons it's allowed to suffix
          patterns with the <code class="literal">;</code> character. But it is not
          recommended to do that.</p></div></div><div class="section" title="8.8.3.2.2. Pattern binding"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9542"/>8.8.3.2.2. Pattern binding</h5></div></div></div><p>For referring to the matched object, use a pattern binding
        variable such as <code class="code">$p</code>.</p><div class="example"><a id="d0e9550"/><p class="title"><strong>Example 8.61. Pattern with a binding variable</strong></p><div class="example-contents"><pre><code class="no-highlight">rule ...
when
    $p : Person()
then
    System.out.println( "Person " + $p );
end</code></pre></div></div><br class="example-break"/><p>The prefixed dollar symbol (<code class="literal">$</code>) is just a
        convention; it can be useful in complex rules where it helps to easily
        differentiate between variables and fields, but it is not
        mandatory.</p></div></div><div class="section" title="8.8.3.3. Constraint (part of a pattern)"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9560"/>8.8.3.3. Constraint (part of a pattern)</h4></div></div></div><div class="section" title="8.8.3.3.1. What is a constraint?"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9563"/>8.8.3.3.1. What is a constraint?</h5></div></div></div><p>A constraint is an expression that returns
        <code class="literal">true</code> or <code class="literal">false</code>. This example has
        a constraint that states <span class="emphasis"><em>5 is smaller than
        6</em></span>:</p><pre><code class="no-highlight">Person( 5 &lt; 6 )  // just an example, as constraints like this would be useless in a real pattern</code></pre><p>In essence, it's a Java expression with some enhancements (such
        as property access) and a few differences (such as
        <code class="literal">equals()</code> semantics for <code class="literal">==</code>).
        Let's take a deeper look.</p></div><div class="section" title="8.8.3.3.2. Property access on Java Beans (POJO's)"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9587"/>8.8.3.3.2. Property access on Java Beans (POJO's)</h5></div></div></div><p>Any bean property can be used directly. A bean property is
        exposed using a standard Java bean getter: a method
        <code class="literal">getMyProperty()</code> (or
        <code class="literal">isMyProperty()</code> for a primitive boolean) which takes
        no arguments and return something. For example: the age property is
        written as <code class="literal">age</code> in DRL instead of the getter
        <code class="literal">getAge()</code>:</p><pre><code class="no-highlight">Person( age == 50 )

// this is the same as:
Person( getAge() == 50 )</code></pre><p>Drools uses the standard JDK <code class="literal">Introspector</code>
        class to do this mapping, so it follows the standard Java bean
        specification.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>We recommend using property access (<code class="literal">age</code>)
          over using getters explicitly (<code class="literal">getAge()</code>) because
          of performance enhancements through field indexing.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Property accessors must not change the state of the object in
          a way that may effect the rules. Remember that the rule engine
          effectively caches the results of its matching in between
          invocations to make it faster.</p><pre><code class="no-highlight">public int getAge() {
    age++; // Do NOT do this
    return age;
}</code></pre><pre><code class="no-highlight">public int getAge() {
    Date now = DateUtil.now(); // Do NOT do this
    return DateUtil.differenceInYears(now, birthday);
}</code></pre><p>To solve this latter case, insert a fact that wraps the
          current date into working memory and update that fact between
          <code class="literal">fireAllRules</code> as needed.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The following fallback applies: if the getter of a property
          cannot be found, the compiler will resort to using the property name
          as a method name and without arguments:</p><pre><code class="no-highlight">Person( age == 50 )

// If Person.getAge() does not exists, this falls back to:
Person( age() == 50 )</code></pre></div><p>Nested property access is also supported:</p><pre><code class="no-highlight">Person( address.houseNumber == 50 )

// this is the same as:
Person( getAddress().getHouseNumber() == 50 )</code></pre><p>Nested properties are also indexed.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>In a stateful session, care should be taken when using nested
          accessors as the Working Memory is not aware of any of the nested
          values, and does not know when they change. Either consider them
          immutable while any of their parent references are inserted into the
          Working Memory. Or, instead, if you wish to modify a nested value
          you should mark all of the outer facts as updated. In the above
          example, when the <code class="literal">houseNumber</code> changes, any
          <code class="literal">Person</code> with that <code class="literal">Address</code> must
          be marked as updated.</p></div></div><div class="section" title="8.8.3.3.3. Java expression"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9655"/>8.8.3.3.3. Java expression</h5></div></div></div><p>You can use any Java expression that returns a
        <code class="literal">boolean</code> as a constraint inside the parentheses of a
        pattern. Java expressions can be mixed with other expression
        enhancements, such as property access:</p><pre><code class="no-highlight">Person( age == 50 )</code></pre><p>It is possible to change the evaluation priority by using
        parentheses, as in any logic or mathematical expression:</p><pre><code class="no-highlight">Person( age &gt; 100 &amp;&amp; ( age % 10 == 0 ) )</code></pre><p>It is possible to reuse Java methods:</p><pre><code class="no-highlight">Person( Math.round( weight / ( height * height ) ) &lt; 25.0 )</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>As for property accessors, methods must not change the state
          of the object in a way that may affect the rules. Any method
          executed on a fact in the LHS should be a <span class="emphasis"><em>read
          only</em></span> method.</p><pre><code class="no-highlight">Person( incrementAndGetAge() == 10 ) // Do NOT do this</code></pre></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>The state of a fact should not change between rule invocations
          (unless those facts are marked as updated to the working memory on
          every change):</p><pre><code class="no-highlight">Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this</code></pre></div><p>Normal Java operator precedence applies, see the operator
        precedence list below.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>All operators have normal Java semantics except for
          <code class="literal">==</code> and <code class="literal">!=</code>.</p><p>The <code class="literal">==</code> operator has null-safe
          <code class="literal">equals()</code> semantics:</p><pre><code class="no-highlight">// Similar to: java.util.Objects.equals(person.getFirstName(), "John")
// so (because "John" is not null) similar to:
// "John".equals(person.getFirstName())
Person( firstName == "John" )</code></pre><p>The <code class="literal">!=</code> operator has null-safe
          <code class="literal">!equals()</code> semantics:</p><pre><code class="no-highlight">// Similar to: !java.util.Objects.equals(person.getFirstName(), "John")
Person( firstName != "John" )</code></pre></div><p>Type coercion is always attempted if the field and the value are
        of different types; exceptions will be thrown if a bad coercion is
        attempted. For instance, if "ten" is provided as a string in a numeric
        evaluator, an exception is thrown, whereas "10" would coerce to a
        numeric 10. Coercion is always in favor of the field type and not the
        value type:</p><pre><code class="no-highlight">Person( age == "10" ) // "10" is coerced to 10</code></pre></div><div class="section" title="8.8.3.3.4. Comma separated AND"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9721"/>8.8.3.3.4. Comma separated AND</h5></div></div></div><p>The comma character ('<code class="literal">,</code>') is used to separate
        constraint groups. It has implicit <span class="emphasis"><em>AND</em></span> connective
        semantics.</p><pre><code class="no-highlight">// Person is at least 50 and weighs at least 80 kg
Person( age &gt; 50, weight &gt; 80 )</code></pre><pre><code class="no-highlight">// Person is at least 50, weighs at least 80 kg and is taller than 2 meter.
Person( age &gt; 50, weight &gt; 80, height &gt; 2 )</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Although the <code class="literal">&amp;&amp;</code> and
          <code class="literal">,</code> operators have the same semantics, they are
          resolved with different priorities: The
          <code class="literal">&amp;&amp;</code> operator precedes the
          <code class="literal">||</code> operator. Both the
          <code class="literal">&amp;&amp;</code> and <code class="literal">||</code> operator
          precede the <code class="literal">,</code> operator. See the operator
          precedence list below.</p><p>The comma operator should be preferred at the top level
          constraint, as it makes constraints easier to read and the engine
          will often be able to optimize them better.</p></div><p>The comma (<code class="literal">,</code>) operator cannot be embedded in
        a composite constraint expression, such as parentheses:</p><pre><code class="no-highlight">Person( ( age &gt; 50, weight &gt; 80 ) || height &gt; 2 ) // Do NOT do this: compile error

// Use this instead
Person( ( age &gt; 50 &amp;&amp; weight &gt; 80 ) || height &gt; 2 )</code></pre></div><div class="section" title="8.8.3.3.5. Binding variables"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9769"/>8.8.3.3.5. Binding variables</h5></div></div></div><p>A property can be bound to a variable:</p><pre><code class="no-highlight">// 2 persons of the same age
Person( $firstAge : age ) // binding
Person( age == $firstAge ) // constraint expression</code></pre><p>The prefixed dollar symbol (<code class="literal">$</code>) is just a
        convention; it can be useful in complex rules where it helps to easily
        differentiate between variables and fields.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For backwards compatibility reasons, It's allowed (but not
          recommended) to mix a constraint binding and constraint expressions
          as such:</p><pre><code class="no-highlight">// Not recommended
Person( $age : age * 2 &lt; 100 )</code></pre><pre><code class="no-highlight">// Recommended (separates bindings and constraint expressions)
Person( age * 2 &lt; 100, $age : age )</code></pre></div><p>Bound variable restrictions using the operator
        <code class="literal">==</code> provide for very fast execution as it use hash
        indexing to improve performance.</p></div><div class="section" title="8.8.3.3.6. Unification"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9793"/>8.8.3.3.6. Unification</h5></div></div></div><p>Drools does not allow bindings to the same declaration. However
        this is an important aspect to derivation query unification. While
        positional arguments are always processed with unification a special
        unification symbol, ':=', was introduced for named arguments named
        arguments. The following "unifies" the age argument across two
        people.</p><pre><code class="no-highlight">Person( $age := age ) 
Person( $age := age) </code></pre><p>In essence unification will declare a binding for the first
        occurrence and constrain to the same value of the bound field for
        sequence occurrences.</p></div><div class="section" title="8.8.3.3.7. Grouped accessors for nested objects"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9802"/>8.8.3.3.7. Grouped accessors for nested objects</h5></div></div></div><p>Often it happens that it is necessary to access multiple properties
        of a nested object as in the following example</p><pre><code class="no-highlight">Person( name == "mark", address.city == "london", address.country == "uk" )</code></pre><p>These accessors to nested objects can be grouped with a '.(...)'
        syntax providing more readable rules as in</p><pre><code class="no-highlight">Person( name == "mark", address.( city == "london", country == "uk") )</code></pre><p>Note the '.' prefix, this is necessary to differentiate the nested
        object constraints from a method call.</p></div><div class="section" title="8.8.3.3.8. Inline casts and coercion"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9815"/>8.8.3.3.8. Inline casts and coercion</h5></div></div></div><p>When dealing with nested objects, it also quite common the need to
        cast to a subtype. It is possible to do that via the # symbol as in:</p><pre><code class="no-highlight">Person( name == "mark", address#LongAddress.country == "uk" )</code></pre><p>This example casts Address to LongAddress, making its getters available.
        If the cast is not possible (instanceof returns false), the evaluation will
        be considered false. Also fully qualified names are supported:</p><pre><code class="no-highlight">Person( name == "mark", address#org.domain.LongAddress.country == "uk" )</code></pre><p>It is possible to use multiple inline casts in the same expression:</p><pre><code class="no-highlight">Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</code></pre><p>moreover, since we also support the instanceof operator, if that is used
        we will infer its results for further uses of that field, within that pattern:</p><pre><code class="no-highlight">Person( name == "mark", address instanceof LongAddress, address.country == "uk" )</code></pre></div><div class="section" title="8.8.3.3.9. Special literal support"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9834"/>8.8.3.3.9. Special literal support</h5></div></div></div><p>Besides normal Java literals (including Java 5 enums), this
        literal is also supported:</p><div class="section" title="8.8.3.3.9.1. Date literal"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9839"/>8.8.3.3.9.1. Date literal</h6></div></div></div><p>The date format <code class="literal">dd-mmm-yyyy</code> is supported by
          default. You can customize this by providing an alternative date
          format mask as the System property named
          <code class="code">drools.dateformat</code>. If more control is required, use a
          restriction.</p><div class="example"><a id="d0e9850"/><p class="title"><strong>Example 8.62. Date Literal Restriction</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( bestBefore &lt; "27-Oct-2009" )</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="8.8.3.3.10. List and Map access"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9855"/>8.8.3.3.10. List and Map access</h5></div></div></div><p>It's possible to directly access a <code class="literal">List</code> value
        by index:</p><pre><code class="no-highlight">// Same as childList(0).getAge() == 18
Person( childList[0].age == 18 )</code></pre><p>It's also possible to directly access a <code class="literal">Map</code>
        value by key:</p><pre><code class="no-highlight">// Same as credentialMap.get("jsmith").isValid()
Person( credentialMap["jsmith"].valid )</code></pre></div><div class="section" title="8.8.3.3.11. Abbreviated combined relation condition"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9872"/>8.8.3.3.11. Abbreviated combined relation condition</h5></div></div></div><p>This allows you to place more than one restriction on a field
        using the restriction connectives <code class="literal">&amp;&amp;</code> or
        <code class="literal">||</code>. Grouping via parentheses is permitted,
        resulting in a recursive syntax pattern.</p><div class="figure"><a id="d0e9883"/><p class="title"><strong>Figure 8.13. Abbreviated combined relation condition</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/abbreviatedCombinedRelationCondition.png" align="middle" alt="Abbreviated combined relation condition"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e9889"/><p class="title"><strong>Figure 8.14. Abbreviated combined relation condition with
          parentheses</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/abbreviatedCombinedRelationConditionGroup.png" align="middle" alt="Abbreviated combined relation condition with parentheses"/></div></div></div><br class="figure-break"/><pre><code class="no-highlight">// Simple abbreviated combined relation condition using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )</code></pre><pre><code class="no-highlight">// Complex abbreviated combined relation using groupings
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )</code></pre><pre><code class="no-highlight">// Mixing abbreviated combined relation with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</code></pre></div><div class="section" title="8.8.3.3.12. Special DRL operators"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9901"/>8.8.3.3.12. Special DRL operators</h5></div></div></div><div class="figure"><a id="d0e9904"/><p class="title"><strong>Figure 8.15. Operators</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/operator.png" align="middle" alt="Operators"/></div></div></div><br class="figure-break"/><p>Coercion to the correct value for the evaluator and the field
        will be attempted.</p><div class="section" title="8.8.3.3.12.1. The operators &lt; &lt;= &gt; &gt;="><div class="titlepage"><div><div><h6 class="title"><a id="d0e9912"/>8.8.3.3.12.1. The operators <code class="literal">&lt;</code>
          <code class="literal">&lt;=</code> <code class="literal">&gt;</code>
          <code class="literal">&gt;=</code></h6></div></div></div><p>These operators can be used on properties with natural
          ordering. For example, for Date fields, <code class="literal">&lt;</code>
          means <span class="emphasis"><em>before</em></span>, for <code class="literal">String</code>
          fields, it means alphabetically lower.</p><pre><code class="no-highlight">Person( firstName &lt; $otherFirstName )</code></pre><pre><code class="no-highlight">Person( birthDate &lt; $otherBirthDate )</code></pre><p>Only applies on <code class="literal">Comparable</code>
          properties.</p></div><div class="section" title="8.8.3.3.12.2. Null-safe dereferencing operator"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9946"/>8.8.3.3.12.2. Null-safe dereferencing operator</h6></div></div></div><p>The !. operator allows to derefencing in a null-safe way.
          More in details the matching algorithm requires the value to the left
          of the !. operator to be not null in order to give a positive result
          for pattern matching itself. In other words the pattern:</p><pre><code class="no-highlight">Person( $streetName : address!.street )</code></pre><p>will be internally translated in:</p><pre><code class="no-highlight">Person( address != null, $streetName : address.street )</code></pre></div><div class="section" title="8.8.3.3.12.3. The operator matches"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9957"/>8.8.3.3.12.3. The operator <code class="literal">matches</code></h6></div></div></div><p>Matches a field against any valid Java <a id="d0e9964" class="indexterm"/>Regular Expression. Typically that regexp is a string
          literal, but variables that resolve to a valid regexp are also
          allowed.</p><div class="example"><a id="d0e9968"/><p class="title"><strong>Example 8.63. Regular Expression Constraint</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( type matches "(Buffalo)?\\S*Mozarella" )</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Like in Java, regular expressions written as string literals
            <span class="emphasis"><em>need to escape '<code class="literal">\</code></em></span>'.</p></div><p>Only applies on <code class="literal">String</code> properties.
          Using <code class="literal">matches</code> against a <code class="literal">null</code> value
          always evaluates to false.</p></div><div class="section" title="8.8.3.3.12.4. The operator not matches"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9992"/>8.8.3.3.12.4. The operator <code class="literal">not matches</code></h6></div></div></div><p>The operator returns true if the String does not match the
          regular expression. The same rules apply as for the
          <code class="literal">matches</code> operator. Example:</p><div class="example"><a id="d0e10002"/><p class="title"><strong>Example 8.64. Regular Expression Constraint</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( type not matches "(Buffulo)?\\S*Mozarella" )</code></pre></div></div><br class="example-break"/><p>Only applies on <code class="literal">String</code> properties.
          Using <code class="literal">not matches</code> against a <code class="literal">null</code> value
          always evaluates to true.</p></div><div class="section" title="8.8.3.3.12.5. The operator contains"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10018"/>8.8.3.3.12.5. The operator <code class="literal">contains</code></h6></div></div></div><p>The operator <code class="literal">contains</code> is used to check
          whether a field that is a <a id="d0e10028" class="indexterm"/>Collection or elements contains the specified
          value.</p><div class="example"><a id="d0e10032"/><p class="title"><strong>Example 8.65. Contains with Collections</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</code></pre></div></div><br class="example-break"/><p>Only applies on <code class="literal">Collection</code>
          properties.</p><p>The operator <code class="literal">contains</code> can also be used in place of <code class="literal">String.contains()</code>
          constraints checks.</p><div class="example"><a id="d0e10050"/><p class="title"><strong>Example 8.66. Contains with String literals</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( name contains "tilto" )
Person( fullName contains "Jr" )
String( this contains "foo" )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.3.12.6. The operator not contains"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10055"/>8.8.3.3.12.6. The operator <code class="literal">not contains</code></h6></div></div></div><p>The operator <code class="literal">not contains</code> is used to check
          whether a field that is a <a id="d0e10065" class="indexterm"/>Collection or elements does <span class="emphasis"><em>not</em></span>
          contain the specified value.</p><div class="example"><a id="d0e10072"/><p class="title"><strong>Example 8.67. Literal Constraint with Collections</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</code></pre></div></div><br class="example-break"/><p>Only applies on <code class="literal">Collection</code>
          properties.</p><div class="blockquote"><blockquote class="blockquote"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For backward compatibility, the
              <code class="literal">excludes</code> operator is supported as a synonym
              for <code class="literal">not contains</code>.</p></div></blockquote></div><p>The operator <code class="literal">not contains</code> can also be used in place of the logical negation of <code class="literal">String.contains()</code>
          for constraints checks - i.e.: <code class="literal">! String.contains()</code></p><div class="example"><a id="d0e10102"/><p class="title"><strong>Example 8.68. Contains with String literals</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( name not contains "tilto" )
Person( fullName not contains "Jr" )
String( this not contains "foo" )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.3.12.7. The operator memberOf"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10107"/>8.8.3.3.12.7. The operator <code class="literal">memberOf</code></h6></div></div></div><p>The operator <code class="literal">memberOf</code> is used to check
          whether a field is a member of a collection or elements; that
          collection must be a variable.</p><div class="example"><a id="d0e10117"/><p class="title"><strong>Example 8.69. Literal Constraint with Collections</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheese memberOf $matureCheeses )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.3.12.8. The operator not memberOf"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10122"/>8.8.3.3.12.8. The operator <code class="literal">not memberOf</code></h6></div></div></div><p>The operator <code class="literal">not memberOf</code> is used to check
          whether a field is not a member of a collection or elements; that
          collection must be a variable.</p><div class="example"><a id="d0e10132"/><p class="title"><strong>Example 8.70. Literal Constraint with Collections</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheese not memberOf $matureCheeses )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.3.12.9. The operator soundslike"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10137"/>8.8.3.3.12.9. The operator <code class="literal">soundslike</code></h6></div></div></div><p>This operator is similar to <code class="literal">matches</code>, but it
          checks whether a word has almost the same sound (using English
          pronunciation) as the given value. This is based on the Soundex
          algorithm (see
          <code class="code">http://en.wikipedia.org/wiki/Soundex</code>).</p><div class="example"><a id="d0e10150"/><p class="title"><strong>Example 8.71. Test with soundslike</strong></p><div class="example-contents"><pre><code class="no-highlight">// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.3.12.10. The operator str"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10155"/>8.8.3.3.12.10. The operator <code class="literal">str</code></h6></div></div></div><p>This operator <code class="literal">str</code> is used to check whether
          a field that is a <code class="literal">String</code> starts with or ends with
          a certain value. It can also be used to check the length of the
          String.</p><pre><code class="no-highlight">Message( routingValue str[startsWith] "R1" )</code></pre><pre><code class="no-highlight">Message( routingValue str[endsWith] "R2" )</code></pre><pre><code class="no-highlight">Message( routingValue str[length] 17 )</code></pre></div><div class="section" title="8.8.3.3.12.11. The operators in and not in (compound value restriction)"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10174"/>8.8.3.3.12.11. The operators <code class="literal">in</code> and <code class="literal">not
          in</code> (compound value restriction)</h6></div></div></div><p>The compound value restriction is used where there is more
          than one possible value to match. Currently only the
          <code class="literal">in</code> and <code class="literal">not in</code> evaluators
          support this. The second operand of this operator must be a
          comma-separated list of values, enclosed in parentheses. Values may
          be given as variables, literals, return values or qualified
          identifiers. Both evaluators are actually <span class="emphasis"><em>syntactic
          sugar</em></span>, internally rewritten as a list of multiple
          restrictions using the operators <code class="literal">!=</code> and
          <code class="literal">==</code>.</p><div class="figure"><a id="d0e10200"/><p class="title"><strong>Figure 8.16. compoundValueRestriction</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/compoundValueRestriction.png" align="middle" alt="compoundValueRestriction"/></div></div></div><br class="figure-break"/><div class="example"><a id="d0e10206"/><p class="title"><strong>Example 8.72. Compound Restriction using "in"</strong></p><div class="example-contents"><pre><code class="no-highlight">Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese ) )</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="8.8.3.3.13. Inline eval operator (deprecated)"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10211"/>8.8.3.3.13. Inline eval operator (deprecated)</h5></div></div></div><div class="figure"><a id="d0e10214"/><p class="title"><strong>Figure 8.17. Inline Eval Expression</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/inlineEvalConstraint.png" align="middle" alt="Inline Eval Expression"/></div></div></div><br class="figure-break"/><p>An <a id="d0e10222" class="indexterm"/>inline eval constraint can use any valid dialect
        expression as long as it results to a primitive boolean. The
        expression must be constant over time. Any previously bound variable,
        from the current or previous pattern, can be used; autovivification is
        also used to auto-create field binding variables. When an identifier
        is found that is not a current variable, the builder looks to see if
        the identifier is a field on the current object type, if it is, the
        field binding is auto-created as a variable of the same name. This is
        called autovivification of field variables inside of inline
        eval's.</p><p>This example will find all male-female pairs where the male is 2
        years older than the female; the variable <code class="code">age</code> is
        auto-created in the second pattern by the autovivification
        process.</p><div class="example"><a id="d0e10231"/><p class="title"><strong>Example 8.73. Return Value operator</strong></p><div class="example-contents"><pre><code class="no-highlight">Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' ) // eval() is actually obsolete in this example</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Inline eval's are effectively obsolete as their inner syntax
          is now directly supported. It's recommended not to use them. Simply
          write the expression without wrapping eval() around it.</p></div></div><div class="section" title="8.8.3.3.14. Operator precedence"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10239"/>8.8.3.3.14. Operator precedence</h5></div></div></div><p>The operators are evaluated in this precedence:</p><div class="table"><a id="d0e10244"/><p class="title"><strong>Table 8.1. Operator precedence</strong></p><div class="table-contents"><table summary="Operator precedence" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Operator type</th><th align="center">Operators</th><th align="center">Notes</th></tr></thead><tbody><tr><td>(nested / null safe) property access</td><td><code class="literal">.</code> <code class="literal">!.</code></td><td>Not normal Java semantics</td></tr><tr><td>List/Map access</td><td><code class="literal">[ ]</code></td><td>Not normal Java semantics</td></tr><tr><td>constraint binding</td><td><code class="literal">:</code></td><td>Not normal Java semantics</td></tr><tr><td>multiplicative</td><td><code class="literal">*</code> <code class="literal">/</code>
                <code class="literal">%</code></td><td> </td></tr><tr><td>additive</td><td><code class="literal">+</code> <code class="literal">-</code></td><td> </td></tr><tr><td>shift</td><td><code class="literal">&lt;&lt;</code> <code class="literal">&gt;&gt;</code>
                <code class="literal">&gt;&gt;&gt;</code></td><td> </td></tr><tr><td>relational</td><td><code class="literal">&lt;</code> <code class="literal">&gt;</code>
                <code class="literal">&lt;=</code> <code class="literal">&gt;=</code>
                <code class="literal">instanceof</code></td><td> </td></tr><tr><td>equality</td><td><code class="literal">==</code> <code class="literal">!=</code></td><td>Does not use normal Java (<span class="emphasis"><em>not</em></span>)
                <span class="emphasis"><em>same</em></span> semantics: uses
                (<span class="emphasis"><em>not</em></span>) <span class="emphasis"><em>equals</em></span>
                semantics instead.</td></tr><tr><td>non-short circuiting AND</td><td><code class="literal">&amp;</code></td><td> </td></tr><tr><td>non-short circuiting exclusive OR</td><td><code class="literal">^</code></td><td> </td></tr><tr><td>non-short circuiting inclusive OR</td><td><code class="literal">|</code></td><td> </td></tr><tr><td>logical AND</td><td><code class="literal">&amp;&amp;</code></td><td> </td></tr><tr><td>logical OR</td><td><code class="literal">||</code></td><td> </td></tr><tr><td>ternary</td><td><code class="literal">? :</code></td><td> </td></tr><tr><td>Comma separated AND</td><td><code class="literal">,</code></td><td>Not normal Java semantics</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" title="8.8.3.4. Positional Arguments"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10412"/>8.8.3.4. Positional Arguments</h4></div></div></div><p>Patterns now support positional arguments on type
      declarations.</p><p>Positional arguments are ones where you don't need to specify the
      field name, as the position maps to a known named field. i.e. Person(
      name == "mark" ) can be rewritten as Person( "mark"; ). The semicolon
      ';' is important so that the engine knows that everything before it is a
      positional argument. Otherwise we might assume it was a boolean
      expression, which is how it could be interpreted after the semicolon.
      You can mix positional and named arguments on a pattern by using the
      semicolon ';' to separate them. Any variables used in a positional that
      have not yet been bound will be bound to the field that maps to that
      position.</p><pre><code class="no-highlight">declare Cheese
    name : String
    shop : String
    price : int
end
</code></pre><p>Example patterns, with two constraints and a binding. Remember
      semicolon ';' is used to differentiate the positional section from the
      named argument section. Variables and literals and expressions using
      just literals are supported in positional arguments, but not variables.
      Positional arguments are always resolved using unification.</p><pre><code class="no-highlight">Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
</code></pre><p>Positional arguments that are given a previously declared binding
      will constrain against that using unification; these are referred to as
      input arguments. If the binding does not yet exist, it will create the
      declaration binding it to the field represented by the position
      argument; these are referred to as output arguments.</p></div><div class="section" title="8.8.3.5. Fine grained property change listeners"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10427"/>8.8.3.5. Fine grained property change listeners</h4></div></div></div><p>When you call modify() (see the modify statement section) on a given object it will trigger a revaluation of all
      patterns of the matching object type in the knowledge base. This can can lead to unwanted and useless evaluations
      and in the worst cases to infinite recursions. The only workaround to avoid it was to split up your objects into
      smaller ones having a 1 to 1 relationship with the original object.</p><p>This feature allows the pattern matching to only react to modification of properties actually
      constrained or bound inside of a given pattern. That will help with performance and recursion and avoid artificial
      object splitting.</p><p>By default this feature is off in order to make the behavior of the rule engine backward compatible with the
      former releases. When you want to activate it on a specific bean you have to annotate it with @propertyReactive.
      This annotation works both on DRL type declarations:</p><pre><code class="no-highlight">declare Person
@propertyReactive
    firstName : String
    lastName : String
end</code></pre><p>and on Java classes:</p><pre><code class="no-highlight">@PropertyReactive
    public static class Person {
    private String firstName;
    private String lastName;
}</code></pre><p>In this way, for instance, if you have a rule like the following:</p><pre><code class="no-highlight">rule "Every person named Mario is a male" when
    $person : Person( firstName == "Mario" )
then
    modify ( $person )  { setMale( true ) }
end</code></pre><p>you won't have to add the no-loop attribute to it in order to avoid an infinite recursion because the engine
      recognizes that the pattern matching is done on the 'firstName' property while the RHS of the rule modifies the
      'male' one. Note that this feature does not work for update(), and this is one of the reasons why we promote
      modify() since it encapsulates the field changes within the statement. Moreover, on Java classes, you can also
      annotate any method to say that its invocation actually modifies other properties. For instance in the former
      Person class you could have a method like:</p><pre><code class="no-highlight">@Modifies( { "firstName", "lastName" } )
public void setName(String name) {
    String[] names = name.split("\\s");
    this.firstName = names[0];
    this.lastName = names[1];
}</code></pre><p>That means that if a rule has a RHS like the following:</p><pre><code class="no-highlight">modify($person) { setName("Mario Fusco") }</code></pre><p>it will correctly recognize that the values of both properties 'firstName' and 'lastName' could have
      potentially been modified and act accordingly, not missing of reevaluating the patterns constrained on them. At
      the moment the usage of @Modifies is not allowed on fields but only on methods. This is coherent with the most
      common scenario where the @Modifies will be used for methods that are not related with a class field as in the
      Person.setName() in the former example. Also note that @Modifies is not transitive, meaning that if another method
      internally invokes the Person.setName() one it won't be enough to annotate it with @Modifies( { "name" } ), but it
      is necessary to use @Modifies( { "firstName", "lastName" } ) even on it. Very likely @Modifies transitivity will
      be implemented in the next release.</p><p>For what regards nested accessors, the engine will be notified only for top level fields. In other words a
      pattern matching like:</p><pre><code class="no-highlight">Person ( address.city.name == "London ) </code></pre><p>will be revaluated only for modification of the 'address' property of a Person object. In the same way the
      constraints analysis is currently strictly limited to what there is inside a pattern. Another example could help
      to clarify this. An LHS like the following:</p><pre><code class="no-highlight">$p : Person( )
Car( owner = $p.name )</code></pre><p>will not listen on modifications of the person's name, while this one will do:</p><pre><code class="no-highlight">Person( $name : name )
Car( owner = $name )</code></pre><p>To overcome this problem it is possible to annotate a pattern with @watch as it follows:</p><pre><code class="no-highlight">$p : Person( ) @watch ( name )
Car( owner = $p.name )</code></pre><p>Indeed, annotating a pattern with @watch allows you to modify the inferred set of properties for which that
      pattern will react. Note that the properties named in the @watch annotation are actually added to the ones
      automatically inferred, but it is also possible to explicitly exclude one or more of them prepending their name
      with a ! and to make the pattern to listen for all or none of the properties of the type used in the pattern
      respectively with the wildcrds * and !*. So, for example, you can annotate a pattern in the LHS of a rule
      like:</p><pre><code class="no-highlight">// listens for changes on both firstName (inferred) and lastName
Person( firstName == $expectedFirstName ) @watch( lastName )

// listens for all the properties of the Person bean
Person( firstName == $expectedFirstName ) @watch( * )

// listens for changes on lastName and explicitly exclude firstName
Person( firstName == $expectedFirstName ) @watch( lastName, !firstName )

// listens for changes on all the properties except the age one
Person( firstName == $expectedFirstName ) @watch( *, !age )</code></pre><p>Since doesn't make sense to use this annotation on a pattern using a type not annotated with
      @PropertyReactive the rule compiler will raise a compilation error if you try to do so. Also the duplicated usage
      of the same property in @watch (for example like in: @watch( firstName, ! firstName ) ) will end up in a
      compilation error. In a next release we will make the automatic detection of the properties to be listened smarter
      by doing analysis even outside of the pattern.</p><p>It also possible to enable this feature by default on all the types of your model or to completely disallow
      it by using on option of the KnowledgeBuilderConfiguration. In particular this new PropertySpecificOption can have
      one of the following 3 values:</p><pre><code class="no-highlight">- DISABLED =&gt; the feature is turned off and all the other related annotations are just ignored
- ALLOWED =&gt; this is the default behavior: types are not property reactive unless they are not annotated with @PropertySpecific
- ALWAYS =&gt; all types are property reactive by default</code></pre><p>So, for example, to have a KnowledgeBuilder generating property reactive types by default you could
      do:</p><pre><code class="no-highlight">KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
config.setOption(PropertySpecificOption.ALWAYS);
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);</code></pre><p>In this last case it will be possible to disable the property reactivity feature on a specific type by
      annotating it with @ClassReactive.</p></div><div class="section" title="8.8.3.6. Basic conditional elements"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10488"/>8.8.3.6. Basic conditional elements</h4></div></div></div><div class="section" title="8.8.3.6.1. Conditional Element and"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10491"/>8.8.3.6.1. Conditional Element <code class="literal">and</code></h5></div></div></div><p>The Conditional Element <code class="literal">"and"</code> is used to
        group other Conditional Elements into a logical conjunction. Drools
        supports both prefix <code class="literal">and</code> and infix
        <code class="literal">and</code>.</p><div class="figure"><a id="d0e10507"/><p class="title"><strong>Figure 8.18. infixAnd</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/infixAnd.png" align="middle" alt="infixAnd"/></div></div></div><br class="figure-break"/><p>Traditional infix <code class="literal">and</code> is supported:</p><pre><code class="no-highlight">//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</code></pre><p>Explicit grouping with parentheses is also supported:</p><pre><code class="no-highlight">//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The symbol <code class="literal">&amp;&amp;</code> (as an alternative to
          <code class="literal">and</code>) is deprecated. But it is still supported in
          the syntax for backwards compatibility.</p></div><div class="figure"><a id="d0e10533"/><p class="title"><strong>Figure 8.19. prefixAnd</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/prefixAnd.png" align="middle" alt="prefixAnd"/></div></div></div><br class="figure-break"/><p>Prefix <code class="literal">and</code> is also supported:</p><pre><code class="no-highlight">(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )</code></pre><p>The root element of the LHS is an implicit prefix
        <code class="literal">and</code> and doesn't need to be specified:</p><div class="example"><a id="d0e10551"/><p class="title"><strong>Example 8.74. implicit root prefixAnd</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    Cheese( cheeseType : type )
    Person( favouriteCheese == cheeseType )
then
    ...</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.6.2. Conditional Element or"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10556"/>8.8.3.6.2. Conditional Element <code class="literal">or</code></h5></div></div></div><p>The Conditional Element <code class="literal">or</code> is used to group
        other Conditional Elements into a logical disjunction. Drools supports
        both prefix <code class="literal">or</code> and infix
        <code class="literal">or</code>.</p><div class="figure"><a id="d0e10572"/><p class="title"><strong>Figure 8.20. infixOr</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/infixOr.png" align="middle" alt="infixOr"/></div></div></div><br class="figure-break"/><p>Traditional infix <code class="literal">or</code> is supported:</p><pre><code class="no-highlight">//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )</code></pre><p>Explicit grouping with parentheses is also supported:</p><pre><code class="no-highlight">//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The symbol <code class="literal">||</code> (as an alternative to
          <code class="literal">or</code>) is deprecated. But it is still supported in
          the syntax for backwards compatibility.</p></div><div class="figure"><a id="d0e10598"/><p class="title"><strong>Figure 8.21. prefixOr</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/prefixOr.png" align="middle" alt="prefixOr"/></div></div></div><br class="figure-break"/><p>Prefix <code class="literal">or</code> is also supported:</p><pre><code class="no-highlight">(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The behavior of the Conditional Element <code class="literal">or</code>
          is different from the connective <code class="literal">||</code> for
          constraints and restrictions in field constraints. The engine
          actually has no understanding of the Conditional Element
          <code class="literal">or</code>. Instead, via a number of different logic
          transformations, a rule with <code class="literal">or</code> is rewritten as a
          number of subrules. This process ultimately results in a rule that
          has a single <code class="literal">or</code> as the root node and one subrule
          for each of its CEs. Each subrule can activate and fire like any
          normal rule; there is no special behavior or interaction between
          these subrules. - This can be most confusing to new rule
          authors.</p></div><p>The Conditional Element <code class="literal">or</code> also allows for
        optional pattern binding. This means that each resulting subrule will
        bind its pattern to the pattern binding. Each pattern must be bound
        separately, using eponymous variables:</p><pre><code class="no-highlight">pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</code></pre><pre><code class="no-highlight">(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</code></pre><p>Since the conditional element <code class="literal">or</code> results in
        multiple subrule generation, one for each possible logically outcome,
        the example above would result in the internal generation of two
        rules. These two rules work independently within the Working Memory,
        which means both can match, activate and fire - there is no
        shortcutting.</p><p>The best way to think of the conditional element
        <code class="literal">or</code> is as a shortcut for generating two or more
        similar rules. When you think of it that way, it's clear that for a
        single rule there could be multiple activations if two or more terms
        of the disjunction are true.</p></div><div class="section" title="8.8.3.6.3. Conditional Element not"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10648"/>8.8.3.6.3. Conditional Element <code class="literal">not</code></h5></div></div></div><div class="figure"><a id="d0e10653"/><p class="title"><strong>Figure 8.22. not</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/not.png" align="middle" alt="not"/></div></div></div><br class="figure-break"/><p>The CE <code class="literal">not</code> is first order logic's
        non-existential quantifier and checks for the non-existence of
        something in the Working Memory. Think of "not" as meaning "there must
        be none of...".</p><p>The keyword <code class="literal">not</code> may be followed by
        parentheses around the CEs that it applies to. In the simplest case of
        a single pattern (like below) you may optionally omit the
        parentheses.</p><div class="example"><a id="d0e10669"/><p class="title"><strong>Example 8.75. No Busses</strong></p><div class="example-contents"><pre><code class="no-highlight">not Bus()</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e10674"/><p class="title"><strong>Example 8.76. No red Busses</strong></p><div class="example-contents"><pre><code class="no-highlight">// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <code class="literal">and</code> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.8.3.6.4. Conditional Element exists"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10682"/>8.8.3.6.4. Conditional Element <code class="literal">exists</code></h5></div></div></div><div class="figure"><a id="d0e10687"/><p class="title"><strong>Figure 8.23. exists</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/exists.png" align="middle" alt="exists"/></div></div></div><br class="figure-break"/><p>The CE <code class="literal">exists</code> is first order logic's
        existential quantifier and checks for the existence of something in
        the Working Memory. Think of "exists" as meaning "there is at least
        one..". It is different from just having the pattern on its own, which
        is more like saying "for each one of...". If you use
        <code class="literal">exists</code> with a pattern, the rule will only activate
        at most once, regardless of how much data there is in working memory
        that matches the condition inside of the <code class="literal">exists</code>
        pattern. Since only the existence matters, no bindings will be
        established.</p><p>The keyword <code class="literal">exists</code> must be followed by
        parentheses around the CEs that it applies to. In the simplest case of
        a single pattern (like below) you may omit the parentheses.</p><div class="example"><a id="d0e10709"/><p class="title"><strong>Example 8.77. At least one Bus</strong></p><div class="example-contents"><pre><code class="no-highlight">exists Bus()</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e10714"/><p class="title"><strong>Example 8.78. At least one red Bus</strong></p><div class="example-contents"><pre><code class="no-highlight">exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <code class="literal">and</code>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="8.8.3.7. Advanced conditional elements"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10722"/>8.8.3.7. Advanced conditional elements</h4></div></div></div><div class="section" title="8.8.3.7.1. Conditional Element forall"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10725"/>8.8.3.7.1. Conditional Element <code class="literal">forall</code></h5></div></div></div><div class="figure"><a id="d0e10730"/><p class="title"><strong>Figure 8.24. forall</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/forall.png" align="middle" alt="forall"/></div></div></div><br class="figure-break"/><p>The Conditional Element <code class="literal">forall</code> completes the
        First Order Logic support in Drools. The Conditional Element
        <code class="literal">forall</code> evaluates to true when all facts that match
        the first pattern match all the remaining patterns. Example:</p><pre><code class="no-highlight">rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    // all English buses are red
end</code></pre><p>In the above rule, we "select" all Bus objects whose type is
        "english". Then, for each fact that matches this pattern we evaluate
        the following patterns and if they match, the forall CE will evaluate
        to true.</p><p>To state that all facts of a given type in the working memory
        must match a set of constraints, <code class="literal">forall</code> can be
        written with a single pattern for simplicity. Example:</p><div class="example"><a id="d0e10753"/><p class="title"><strong>Example 8.79. Single Pattern Forall</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    // all Bus facts are red
end</code></pre></div></div><br class="example-break"/><p>Another example shows multiple patterns inside the
        <code class="literal">forall</code>:</p><div class="example"><a id="d0e10763"/><p class="title"><strong>Example 8.80. Multi-Pattern Forall</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    // all employees have health and dental care
end</code></pre></div></div><br class="example-break"/><p>Forall can be nested inside other CEs. For instance,
        <code class="literal">forall</code> can be used inside a <code class="literal">not</code>
        CE. Note that only single patterns have optional parentheses, so that
        with a nested <code class="literal">forall</code> parentheses must be
        used:</p><div class="example"><a id="d0e10779"/><p class="title"><strong>Example 8.81. Combining Forall with Not CE</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    // not all employees have health and dental care
end</code></pre></div></div><br class="example-break"/><p>As a side note, <code class="code">forall( p1 p2 p3...)</code> is equivalent
        to writing:</p><pre><code class="no-highlight">not(p1 and not(and p2 p3...))</code></pre><p>Also, it is important to note that <code class="literal">forall</code> is
        a <span class="emphasis"><em>scope delimiter</em></span>. Therefore, it can use any
        previously bound variable, but no variable bound inside it will be
        available for use outside of it.</p></div><div class="section" title="8.8.3.7.2. Conditional Element from"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10799"/>8.8.3.7.2. Conditional Element <code class="literal">from</code></h5></div></div></div><div class="figure"><a id="d0e10804"/><p class="title"><strong>Figure 8.25. from</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/from.png" align="middle" alt="from"/></div></div></div><br class="figure-break"/><p>The Conditional Element <code class="literal">from</code> enables users to
        specify an arbitrary source for data to be matched by LHS patterns.
        This allows the engine to reason over data not in the Working Memory.
        The data source could be a sub-field on a bound variable or the
        results of a method call. It is a powerful construction that allows
        out of the box integration with other application components and
        frameworks. One common example is the integration with data retrieved
        on-demand from databases using hibernate named queries.</p><p>The expression used to define the object source is any
        expression that follows regular MVEL syntax. Therefore, it allows you
        to easily use object property navigation, execute method calls and
        access maps and collections elements.</p><p>Here is a simple example of reasoning and binding on another
        pattern sub-field:</p><pre><code class="no-highlight">rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    // zip code is ok
end</code></pre><p>With all the flexibility from the new expressiveness in the
        Drools engine you can slice and dice this problem many ways. This is
        the same but shows how you can use a graph notation with the
        'from':</p><pre><code class="no-highlight">rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    // zip code is ok
end</code></pre><p>Previous examples were evaluations using a single pattern. The
        CE <code class="literal">from</code> also support object sources that return a
        collection of objects. In that case, <code class="literal">from</code> will
        iterate over all objects in the collection and try to match each of
        them individually. For instance, if we want a rule that applies 10%
        discount to each item in an order, we could do:</p><pre><code class="no-highlight">rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    // apply discount to $item
end</code></pre><p>The above example will cause the rule to fire once for each item
        whose value is greater than 100 for each given order.</p><p>You must take caution, however, when using
        <code class="literal">from</code>, especially in conjunction with the
        <code class="literal">lock-on-active</code> rule attribute as it may produce
        unexpected results. Consider the example provided earlier, but now
        slightly modified as follows:</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} // Apply discount to person in a modify block
end</code></pre><p>In the above example, persons in Raleigh, NC should be assigned
        to sales region 1 and receive a discount; i.e., you would expect both
        rules to activate and fire. Instead you will find that only the second
        rule fires.</p><p>If you were to turn on the audit log, you would also see that
        when the second rule fires, it deactivates the first rule. Since the
        rule attribute <code class="literal">lock-on-active</code> prevents a rule from
        creating new activations when a set of facts change, the first rule
        fails to reactivate. Though the set of facts have not changed, the use
        of <code class="literal">from</code> returns a new fact for all intents and
        purposes each time it is evaluated.</p><p>First, it's important to review why you would use the above
        pattern. You may have many rules across different rule-flow groups.
        When rules modify working memory and other rules downstream of your
        RuleFlow (in different rule-flow groups) need to be reevaluated, the
        use of <code class="literal">modify</code> is critical. You don't, however, want
        other rules in the same rule-flow group to place activations on one
        another recursively. In this case, the <code class="literal">no-loop</code>
        attribute is ineffective, as it would only prevent a rule from
        activating itself recursively. Hence, you resort to
        <code class="literal">lock-on-active</code>.</p><p>There are several ways to address this issue:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid the use of <code class="literal">from</code> when you can assert
            all facts into working memory or use nested object references in
            your constraint expressions (shown below).</p></li><li class="listitem"><p>Place the variable assigned used in the modify block as the
            last sentence in your condition (LHS).</p></li><li class="listitem"><p>Avoid the use of <code class="literal">lock-on-active</code> when you
            can explicitly manage how rules within the same rule-flow group
            place activations on one another (explained below).</p></li></ul></div><p>The preferred solution is to minimize use of
        <code class="literal">from</code> when you can assert all your facts into
        working memory directly. In the example above, both the Person and
        Address instance can be asserted into working memory. In this case,
        because the graph is fairly simple, an even easier solution is to
        modify your rules as follows:</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} //Apply discount to person in a modify block
end</code></pre><p>Now, you will find that both rules fire as expected. However, it
        is not always possible to access nested facts as above. Consider an
        example where a Person holds one or more Addresses and you wish to use
        an existential quantifier to match people with at least one address
        that meets certain conditions. In this case, you would have to resort
        to the use of <code class="literal">from</code> to reason over the
        collection.</p><p>There are several ways to use <code class="literal">from</code> to achieve
        this and not all of them exhibit an issue with the use of
        <code class="literal">lock-on-active</code>. For example, the following use of
        <code class="literal">from</code> causes both rules to fire as expected:</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} // Apply discount to person in a modify block
end</code></pre><p>However, the following slightly different approach does exhibit
        the problem:</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} // Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} // Modify assessment in a modify block
end</code></pre><p>In the above example, the $addresses variable is returned from
        the use of <code class="literal">from</code>. The example also introduces a new
        object, assessment, to highlight one possible solution in this case.
        If the $assessment variable assigned in the condition (LHS) is moved
        to the last condition in each rule, both rules fire as
        expected.</p><p>Though the above examples demonstrate how to combine the use of
        <code class="literal">from</code> with <code class="literal">lock-on-active</code> where
        no loss of rule activations occurs, they carry the drawback of placing
        a dependency on the order of conditions on the LHS. In addition, the
        solutions present greater complexity for the rule author in terms of
        keeping track of which conditions may create issues.</p><p>A better alternative is to assert more facts into working
        memory. In this case, a person's addresses may be asserted into
        working memory and the use of <code class="literal">from</code> would not be
        necessary.</p><p>There are cases, however, where asserting all data into working
        memory is not practical and we need to find other solutions. Another
        option is to reevaluate the need for
        <code class="literal">lock-on-active</code>. An alternative to
        <code class="literal">lock-on-active</code> is to directly manage how rules
        within the same rule-flow group activate one another by including
        conditions in each rule that prevent rules from activating each other
        recursively when working memory is modified. For example, in the case
        above where a discount is applied to citizens of Raleigh, a condition
        may be added to the rule that checks whether the discount has already
        been applied. If so, the rule does not activate.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The pattern containing a from clause cannot be followed by another
          pattern starting with a parenthesis as in the following example</p><pre><code class="no-highlight">rule R when
    $l : List( )
    String() from $l
    (String() or Number())
then end</code></pre><p>This is because in that case the DRL parser reads the from expression
          as <code class="literal">from $l (String() or Number())</code> and it is impossible to
          disambiguate this expression from a function call. The straightforward fix
          to this is wrapping also the from clause in parenthesis as it follows:</p><pre><code class="no-highlight">rule R when
    $l : List( )
    (String() from $l)
    (String() or Number())
then end</code></pre></div></div><div class="section" title="8.8.3.7.3. Conditional Element collect"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10953"/>8.8.3.7.3. Conditional Element <code class="literal">collect</code></h5></div></div></div><div class="figure"><a id="d0e10958"/><p class="title"><strong>Figure 8.26. collect</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/collect.png" align="middle" alt="collect"/></div></div></div><br class="figure-break"/><p>The Conditional Element <code class="literal">collect</code> allows rules
        to reason over a collection of objects obtained from the given source
        or from the working memory. In First Oder Logic terms this is the
        cardinality quantifier. A simple example:</p><pre><code class="no-highlight">import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    // Raise priority, because system $system has
    // 3 or more alarms pending. The pending alarms
    // are $alarms.
end</code></pre><p>In the above example, the rule will look for all pending alarms
        in the working memory for each given system and group them in
        ArrayLists. If 3 or more alarms are found for a given system, the rule
        will fire.</p><p>The result pattern of <code class="literal">collect</code> can be any
        concrete class that implements the <code class="code">java.util.Collection</code>
        interface and provides a default no-arg public constructor. This means
        that you can use Java collections like ArrayList, LinkedList, HashSet,
        etc., or your own class, as long as it implements the
        <code class="code">java.util.Collection</code> interface and provide a default
        no-arg public constructor.</p><p>Both source and result patterns can be constrained as any other
        pattern.</p><p>Variables bound before the <code class="literal">collect</code> CE are in
        the scope of both source and result patterns and therefore you can use
        them to constrain both your source and result patterns. But note that
        <code class="literal">collect</code> is a scope delimiter for bindings, so that
        any binding made inside of it is not available for use outside of
        it.</p><p>Collect accepts nested <code class="literal">from</code> CEs. The
        following example is a valid use of "collect":</p><pre><code class="no-highlight">import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    // send a message to all mothers
end</code></pre></div><div class="section" title="8.8.3.7.4. Conditional Element accumulate"><div class="titlepage"><div><div><h5 class="title"><a id="d0e11001"/>8.8.3.7.4. Conditional Element <code class="literal">accumulate</code></h5></div></div></div><div class="figure"><a id="d0e11006"/><p class="title"><strong>Figure 8.27. accumulate</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/accumulate.png" align="middle" alt="accumulate"/></div></div></div><br class="figure-break"/><p>The Conditional Element <code class="literal">accumulate</code> is a more flexible and powerful form of
            <code class="literal">collect</code>, in the sense that it can be used to do what <code class="literal">collect</code> does and
          also achieve results that the CE <code class="literal">collect</code> is not capable of achieving. Accumulate allows a
          rule to iterate over a collection of objects, executing custom actions for each of the elements, and at the
          end, it returns a result object.</p><p>Accumulate supports both the use of pre-defined accumulate
        functions, or the use of inline custom code. Inline custom code should
        be avoided though, as it is harder for rule authors to maintain, and
        frequently leads to code duplication. Accumulate functions are easier
        to test and reuse.</p><p>The Accumulate CE also supports multiple different syntaxes. The
        preferred syntax is the top level accumulate, as noted bellow, but all
        other syntaxes are supported for backward compatibility.</p><div class="section" title="8.8.3.7.4.1. Accumulate CE (preferred syntax)"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11030"/>8.8.3.7.4.1. Accumulate CE (preferred syntax)</h6></div></div></div><p>The top level accumulate syntax is the most compact and
          flexible syntax. The simplified syntax is as follows:</p><pre><code class="no-highlight"><code class="literal">accumulate( </code><em class="replaceable"><code>&lt;source pattern&gt;</code></em><code class="literal">; </code><em class="replaceable"><code>&lt;functions&gt;</code></em><code class="literal"> [;</code><em class="replaceable"><code>&lt;constraints&gt;</code></em><code class="literal">] )</code>
</code></pre><p>For instance, a rule to calculate the minimum, maximum and
          average temperature reading for a given sensor and that raises an
          alarm if the minimum temperature is under 20C degrees and the
          average is over 70C degrees could be written in the following way,
          using Accumulate:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The DRL language defines "<code class="code">acc</code>" as a synonym of "<code class="code">accumulate</code>". The author
              might prefer to use "<code class="code">acc</code>" as a less verbose keyword or the full keyword
                "<code class="code">accumulate</code>" for legibility.</p></div><pre><code class="no-highlight">rule "Raise alarm"
when
    $s : Sensor()
    accumulate( Reading( sensor == $s, $temp : temperature );
                $min : min( $temp ),
                $max : max( $temp ),
                $avg : average( $temp );
                $min &lt; 20, $avg &gt; 70 )
then
    // raise the alarm
end</code></pre><p>In the above example, min, max and average are Accumulate
          Functions and will calculate the minimum, maximum and average
          temperature values over all the readings for each sensor.</p><p>Drools ships with several built-in accumulate functions,
          including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>average</p></li><li class="listitem"><p>min</p></li><li class="listitem"><p>max</p></li><li class="listitem"><p>count</p></li><li class="listitem"><p>sum</p></li><li class="listitem"><p>collectList</p></li><li class="listitem"><p>collectSet</p></li></ul></div><p>These common functions accept any expression as input. For
          instance, if someone wants to calculate the average profit on all
          items of an order, a rule could be written using the average
          function:</p><pre><code class="no-highlight">rule "Average profit"
when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
then
    // average profit for $order is $avgProfit
end</code></pre><p>Accumulate Functions are all pluggable. That means that if needed, custom, domain specific functions can
            easily be added to the engine and rules can start to use them without any restrictions. To implement a new
            Accumulate Function all one needs to do is to create a Java class that implements the
              <code class="code">org.drools.core.runtime.rule.TypedAccumulateFunction</code> interface. As an example of an
            Accumulate Function implementation, the following is the implementation of the <code class="literal">average</code>
            function:</p><pre><code class="language-java">/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements org.drools.core.runtime.rule.TypedAccumulateFunction {

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public static class AverageData implements Externalizable {
        public int    count = 0;
        public double total = 0;

        public AverageData() {}

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            count   = in.readInt();
            total   = in.readDouble();
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(count);
            out.writeDouble(total);
        }

    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Serializable createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object)
     */
    public void accumulate(Serializable context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object)
     */
    public void reverse(Serializable context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

    /**
     * {@inheritDoc}
     */
    public Class&lt; ? &gt; getResultType() {
        return Number.class;
    }

}
</code></pre><p>The code for the function is very simple, as we could expect, as all the "dirty" integration work is
            done by the engine. Finally, to use the function in the rules, the author can import it using the "import
            accumulate" statement:</p><pre><code class="no-highlight">import accumulate &lt;class_name&gt; &lt;function_name&gt;</code></pre><p>For instance, if one implements the class <code class="code">some.package.VarianceFunction</code> function that
            implements the <code class="code">variance</code> function and wants to use it in the rules, he would do the
            following:</p><div class="example"><a id="d0e11122"/><p class="title"><strong>Example 8.82. Example of importing and using the custom "<code class="code">variance</code>" accumulate function</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import accumulate</strong></span> some.package.VarianceFunction variance

<span class="bold"><strong>rule</strong></span> "Calculate Variance"
<span class="bold"><strong>when</strong></span>
    <span class="bold"><strong>accumulate</strong></span>( Test( $s : score ), $v : variance( $s ) )
<span class="bold"><strong>then</strong></span>
    <span class="italic">// the variance of the test scores is $v</span>
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The built in functions (sum, average, etc) are imported automatically by the engine. Only user-defined
              custom accumulate functions need to be explicitly imported.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For backward compatibility, Drools still supports the configuration of accumulate functions through
              configuration files and system properties, but this is a deprecated method. In order to configure the
              variance function from the previous example using the configuration file or system property, the user
              would set a property like this:</p><pre><code class="no-highlight">drools.accumulate.function.variance = some.package.VarianceFunction</code></pre><p>Please note that "<code class="code">drools.accumulate.function.</code>" is a prefix that must always be used,
                "<code class="code">variance</code>" is how the function will be used in the drl files, and
                "<code class="code">some.package.VarianceFunction</code>" is the fully qualified name of the class that implements
              the function behavior.</p></div></div><div class="section" title="8.8.3.7.4.2. Alternate Syntax: single function with return type"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11168"/>8.8.3.7.4.2. Alternate Syntax: single function with return type</h6></div></div></div><p>The accumulate syntax evolved over time with the goal of
          becoming more compact and expressive. Nevertheless, Drools still
          supports previous syntaxes for backward compatibility
          purposes.</p><p>In case the rule is using a single accumulate function on a
          given accumulate, the author may add a pattern for the result object
          and use the "from" keyword to link it to the accumulate result.
          Example: a rule to apply a 10% discount on orders over $100 could be
          written in the following way:</p><pre><code class="no-highlight">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    // apply discount to $order
end</code></pre><p>In the above example, the accumulate element is using only one
          function (sum), and so, the rules author opted to explicitly write a
          pattern for the result type of the accumulate function (Number) and
          write the constraints inside it. There are no problems in using this
          syntax over the compact syntax presented before, except that is is a
          bit more verbose. Also note that it is not allowed to use both the
          return type and the functions binding in the same accumulate statement.</p><p>Compile-time checks are performed in order to ensure the pattern
          used with the "from" keyword is assignable from the result of the
          accumulate function used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>With this syntax, the "<code class="code">from</code>" binds to the single
           result returned by the accumulate function, and it does not iterate.
           </p></div><p>In the above example, "<code class="code">$total</code>" is bound to the
           result returned by the accumulate <code class="code">sum()</code> function.</p><p>As another example however, if the result of the accumulate 
           function is a collection, "<code class="code">from</code>" still binds to the
           single result and it does not iterate:
           </p><pre><code class="no-highlight">rule "Person names"
when
  $x : Object() from accumulate(MyPerson( $val : name ); 
                                collectList( $val ) )
then
  // $x is a List
end</code></pre><p>
           The binded "<code class="code">$x : Object()</code>" is the List itself,
           returned by the <code class="code">collectList</code> accumulate function used.
           </p><p>This is an important distinction to highlight, as the<code class="code">from</code>
           keyword can also be used separately of <code class="code">accumulate</code>, to 
           iterate over the elements of a collection:
           </p><pre><code class="no-highlight">rule "Iterate the numbers"
when
    $xs : List()
    $x : Integer() from $xs
then
  // $x matches and binds to each Integer in the collection
end</code></pre><p>
           </p><p>While this syntax is still supported for backward compatibility purposes,
           for this and other reasons we encourage rule authors to make use instead of the
           Accumulate CE preferred syntax (described in the previous chapter),
           so to avoid any potential pitfalls, as described by these examples.
           </p></div><div class="section" title="8.8.3.7.4.3. Accumulate with inline custom code"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11222"/>8.8.3.7.4.3. Accumulate with inline custom code</h6></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>The use of accumulate with inline custom code is not a good
            practice for several reasons, including difficulties on maintaining
            and testing rules that use them, as well as the inability of
            reusing that code. Implementing your own accumulate functions is
            very simple and straightforward, they are easy to unit test and to
            use. This form of accumulate is supported for backward
            compatibility only.</p></div><p>Another possible syntax for the accumulate is to define inline
          custom code, instead of using accumulate functions. As noted on the
          previous warned, this is discouraged though for the stated
          reasons.</p><p>The general syntax of the <code class="literal">accumulate</code> CE
          with inline custom code is:</p><pre><code class="no-highlight"><em class="replaceable"><code>&lt;result pattern&gt;</code></em> <code class="literal">from accumulate(</code> <em class="replaceable"><code>&lt;source pattern&gt;</code></em><code class="literal">,</code>
                                  <code class="literal">init(</code> <em class="replaceable"><code>&lt;init code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">action(</code> <em class="replaceable"><code>&lt;action code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">reverse(</code> <em class="replaceable"><code>&lt;reverse code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">result(</code> <em class="replaceable"><code>&lt;result expression&gt;</code></em> <code class="literal">) )</code>
</code></pre><p>The meaning of each of the elements is the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>&lt;source pattern&gt;</em></span>: the source
              pattern is a regular pattern that the engine will try to match
              against each of the source objects.</p></li><li class="listitem"><p><span class="emphasis"><em>&lt;init code&gt;</em></span>: this is a semantic
              block of code in the selected dialect that will be executed once
              for each tuple, before iterating over the source objects.</p></li><li class="listitem"><p><span class="emphasis"><em>&lt;action code&gt;</em></span>: this is a
              semantic block of code in the selected dialect that will be
              executed for each of the source objects.</p></li><li class="listitem"><p><span class="emphasis"><em>&lt;reverse code&gt;</em></span>: this is an
              optional semantic block of code in the selected dialect that if
              present will be executed for each source object that no longer
              matches the source pattern. The objective of this code block is
              to undo any calculation done in the <span class="emphasis"><em>&lt;action
              code&gt;</em></span> block, so that the engine can do decremental
              calculation when a source object is modified or deleted,
              hugely improving performance of these operations.</p></li><li class="listitem"><p><span class="emphasis"><em>&lt;result expression&gt;</em></span>: this is a
              semantic expression in the selected dialect that is executed
              after all source objects are iterated.</p></li><li class="listitem"><p><span class="emphasis"><em>&lt;result pattern&gt;</em></span>: this is a
              regular pattern that the engine tries to match against the
              object returned from the <span class="emphasis"><em>&lt;result
              expression&gt;</em></span>. If it matches, the
              <code class="literal">accumulate</code> conditional element evaluates to
              <span class="emphasis"><em>true</em></span> and the engine proceeds with the
              evaluation of the next CE in the rule. If it does not matches,
              the <code class="literal">accumulate</code> CE evaluates to
              <span class="emphasis"><em>false</em></span> and the engine stops evaluating CEs
              for that rule.</p></li></ul></div><p>It is easier to understand if we look at an example:</p><pre><code class="no-highlight">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    // apply discount to $order
end</code></pre><p>In the above example, for each <code class="code">Order</code> in the
          Working Memory, the engine will execute the <span class="emphasis"><em>init
          code</em></span> initializing the total variable to zero. Then it
          will iterate over all <code class="code">OrderItem</code> objects for that order,
          executing the <span class="emphasis"><em>action</em></span> for each one (in the
          example, it will sum the value of all items into the total
          variable). After iterating over all <code class="code">OrderItem</code> objects,
          it will return the value corresponding to the <span class="emphasis"><em>result
          expression</em></span> (in the above example, the value of variable
          <code class="code">total</code>). Finally, the engine will try to match the
          result with the <code class="code">Number</code> pattern, and if the double value
          is greater than 100, the rule will fire.</p><p>The example used Java as the semantic dialect, and as such,
          note that the usage of the semicolon as statement delimiter is
          mandatory in the init, action and reverse code blocks. The result is
          an expression and, as such, it does not admit ';'. If the user uses
          any other dialect, he must comply to that dialect's specific
          syntax.</p><p>As mentioned before, the <span class="emphasis"><em>reverse code</em></span> is
          optional, but it is strongly recommended that the user writes it in
          order to benefit from the <span class="emphasis"><em>improved performance on update
          and delete</em></span>.</p><p>The <code class="literal">accumulate</code> CE can be used to execute
          any action on source objects. The following example instantiates and
          populates a custom object:</p><pre><code class="no-highlight">rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</code></pre></div></div></div><div class="section" title="8.8.3.8. Conditional Element eval"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11381"/>8.8.3.8. Conditional Element <code class="literal">eval</code></h4></div></div></div><div class="figure"><a id="d0e11386"/><p class="title"><strong>Figure 8.28. eval</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/eval.png" align="middle" alt="eval"/></div></div></div><br class="figure-break"/><p>The conditional element <code class="literal">eval</code> is essentially a
      catch-all which allows any semantic code (that returns a primitive
      boolean) to be executed. This code can refer to variables that were
      bound in the LHS of the rule, and functions in the rule package. Overuse
      of eval reduces the declarativeness of your rules and can result in a
      poorly performing engine. While <code class="literal">eval</code> can be used
      anywhere in the patterns, the best practice is to add it as the last
      conditional element in the LHS of a rule.</p><p>Evals cannot be indexed and thus are not as efficient as Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</p><p>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</p><pre><code class="no-highlight">p1 : Parameter()
p2 : Parameter()
eval( p1.getList().containsKey( p2.getItem() ) )</code></pre><pre><code class="no-highlight">p1 : Parameter()
p2 : Parameter()
// call function isValid in the LHS
eval( isValid( p1, p2 ) )</code></pre></div><div class="section" title="8.8.3.9. Railroad diagrams"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11408"/>8.8.3.9. Railroad diagrams</h4></div></div></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateAction.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateClause.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateFunction.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateInit.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateResult.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateReverse.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateSteps.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Accumulations.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AdditiveExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Annotation.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Arguments.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ArrayCreatorRest.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ArrayInitializer.png"/></div><div class="mediaobject"><img src="images/LanguageReference/AssignmentOperator.png"/></div><div class="mediaobject"><img src="images/LanguageReference/BindingPattern.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Block.png"/></div><div class="mediaobject"><img src="images/LanguageReference/BooleanLiteral.png"/></div><div class="mediaobject"><img src="images/LanguageReference/CompilationUnit.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalAnd.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementAccumulate.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementEval.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementExists.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementForall.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementNot.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElement.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalOrExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalOr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Constraints.png"/></div><div class="mediaobject"><img src="images/LanguageReference/CreatedName.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Creator.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Definition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Digit.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ExplicitGenericInvocationSuffix.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ExplicitGenericInvocation.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Exponent.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ExpressionList.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Expression.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Field.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Fraction.png"/></div><div class="mediaobject"><img src="images/LanguageReference/FromAccumulateClause.png"/></div><div class="mediaobject"><img src="images/LanguageReference/FromClause.png"/></div><div class="mediaobject"><img src="images/LanguageReference/FromCollectClause.png"/></div><div class="mediaobject"><img src="images/LanguageReference/FunctionDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/GlobalDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/IdentifierSuffix.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ImportDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/InExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/InlineListExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/InlineMapExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/InnerCreator.png"/></div><div class="mediaobject"><img src="images/LanguageReference/InstanceOfExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/IntLiteral.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Literal.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ModifyStatement.png"/></div><div class="mediaobject"><img src="images/LanguageReference/NonWildcardTypeArguments.png"/></div><div class="mediaobject"><img src="images/LanguageReference/OrRestriction.png"/></div><div class="mediaobject"><img src="images/LanguageReference/OverClause.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Parameters.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Pattern.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Placeholders.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Primary.png"/></div><div class="mediaobject"><img src="images/LanguageReference/PrimitiveType.png"/></div><div class="mediaobject"><img src="images/LanguageReference/QualifiedName.png"/></div><div class="mediaobject"><img src="images/LanguageReference/QueryDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/QueryOptions.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RealLiteral.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RealTypeSuffix.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RelationalExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RelationalOperator.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RhsStatement.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RuleAttributes.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RuleAttribute.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RuleDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/RuleOptions.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Selector.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ShiftExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/SingleRestriction.png"/></div><div class="mediaobject"><img src="images/LanguageReference/SourcePattern.png"/></div><div class="mediaobject"><img src="images/LanguageReference/StringId.png"/></div><div class="mediaobject"><img src="images/LanguageReference/SuperSuffix.png"/></div><div class="mediaobject"><img src="images/LanguageReference/ThenPart.png"/></div><div class="mediaobject"><img src="images/LanguageReference/TypeArguments.png"/></div><div class="mediaobject"><img src="images/LanguageReference/TypeArgument.png"/></div><div class="mediaobject"><img src="images/LanguageReference/TypeDefinition.png"/></div><div class="mediaobject"><img src="images/LanguageReference/TypeOptions.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Type.png"/></div><div class="mediaobject"><img src="images/LanguageReference/UnaryExprNotPlusMinus.png"/></div><div class="mediaobject"><img src="images/LanguageReference/UnaryExpr.png"/></div><div class="mediaobject"><img src="images/LanguageReference/Value.png"/></div><div class="mediaobject"><img src="images/LanguageReference/VariableInitializer.png"/></div><div class="mediaobject"><img src="images/LanguageReference/WhenPart.png"/></div></div></div><div class="section" title="8.8.4. The Right Hand Side (then)"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11687"/>8.8.4. The Right Hand Side (then)</h3></div></div></div><div class="section" title="8.8.4.1. Usage"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11690"/>8.8.4.1. Usage</h4></div></div></div><p>The Right Hand Side (RHS) is a common name for the consequence or
      action part of the rule; this part should contain a list of actions to
      be executed. It is bad practice to use imperative or conditional code in
      the RHS of a rule; as a rule should be atomic in nature - "when this,
      then do this", not "when this, maybe do this". The RHS part of a rule
      should also be kept small, thus keeping it declarative and readable. If
      you find you need imperative and/or conditional code in the RHS, then
      maybe you should be breaking that rule down into multiple rules. The
      main purpose of the RHS is to insert, delete or modify working memory
      data. To assist with that there are a few convenience methods you can
      use to modify working memory; without having to first reference a
      working memory instance.</p><p><code class="literal">update(</code><span class="emphasis"><em>object,
      handle</em></span><code class="literal">);</code> will tell the engine that an
      object has changed (one that has been bound to something on the LHS) and
      rules may need to be reconsidered.</p><p><code class="literal">update(</code><span class="emphasis"><em>object</em></span><code class="literal">);</code>
      can also be used; here the Knowledge Helper will look up the facthandle
      for you, via an identity check, for the passed object. (Note that if you
      provide Property Change Listeners to your Java beans that you are
      inserting into the engine, you can avoid the need to call
      <code class="code">update()</code> when the object changes.). After a fact's field
      values have changed you must call update before changing another fact,
      or you will cause problems with the indexing within the rule engine. The
      modify keyword avoids this problem.</p><p><code class="literal">insert(new</code>
      <span class="emphasis"><em>Something</em></span><code class="literal">());</code> will place a new
      object of your creation into the Working Memory.</p><p><code class="literal">insertLogical(new</code>
      <span class="emphasis"><em>Something</em></span><code class="literal">());</code> is similar to
      insert, but the object will be automatically deleted when there are no
      more facts to support the truth of the currently firing rule.</p><p><code class="literal">delete(</code><span class="emphasis"><em>handle</em></span><code class="literal">);</code>
      removes an object from Working Memory.</p><p>These convenience methods are basically macros that provide short
      cuts to the <code class="code">KnowledgeHelper</code> instance that lets you access
      your Working Memory from rules files. The predefined variable
      <code class="code">drools</code> of type <code class="code">KnowledgeHelper</code> lets you call
      several other useful methods. (Refer to the <code class="code">KnowledgeHelper</code>
      interface documentation for more advanced operations).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The call <code class="code">drools.halt()</code> terminates rule execution
          immediately. This is required for returning control to the point
          whence the current session was put to work with
          <code class="code">fireUntilHalt()</code>.</p></li><li class="listitem"><p>Methods <code class="code">insert(Object o)</code>, <code class="code">update(Object
          o)</code> and <code class="code">delete(Object o)</code> can be called on
          <code class="code">drools</code> as well, but due to their frequent use they can
          be called without the object reference.</p></li><li class="listitem"><p><code class="code">drools.getWorkingMemory()</code> returns the
          <code class="code">WorkingMemory</code> object.</p></li><li class="listitem"><p><code class="code">drools.setFocus( String s)</code> sets the focus to the
          specified agenda group.</p></li><li class="listitem"><p><code class="code">drools.getRule().getName()</code>, called from a rule's
          RHS, returns the name of the rule.</p></li><li class="listitem"><p><code class="code">drools.getTuple()</code> returns the Tuple that matches
          the currently executing rule, and
          <code class="code">drools.getActivation()</code> delivers the corresponding
          Activation. (These calls are useful for logging and debugging
          purposes.)</p></li></ul></div><p>The full Knowledge Runtime API is exposed through another
      predefined variable, <code class="code">kcontext</code>, of type
      <code class="code">KieContext</code>. Its method <code class="code">getKieRuntime()</code> delivers
      an object of type <code class="code">KieRuntime</code>, which, in turn, provides access to a
      wealth of methods, many of which are quite useful for coding RHS
      logic.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The call <code class="code">kcontext.getKieRuntime().halt()</code>
          terminates rule execution immediately.</p></li><li class="listitem"><p>The accessor <code class="code">getAgenda()</code> returns a reference to
          this session's <code class="code">Agenda</code>, which in turn provides access to
          the various rule groups: activation groups, agenda groups, and rule
          flow groups. A fairly common paradigm is the activation of some
          agenda group, which could be done with the lengthy call:</p><pre><code class="language-java">// give focus to the agenda group CleanUp
kcontext.getKieRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</code></pre><p>(You can achieve the same using <code class="code">drools.setFocus(
          "CleanUp" )</code>.)</p></li><li class="listitem"><p>To run a query, you call <code class="code">getQueryResults(String
          query)</code>, whereupon you may process the results, as explained
          in section <a class="link" href="ch08.html#QuerySection" title="8.9. Query">Query</a>. Using <code class="code">kcontext.getKieRuntime().getQueryResults(...)</code>
          or using <code class="code">drools.getKieRuntime().getQueryResults(...)</code> is the
          proper method of running a query from a rule's RHS, and the only supported way.
          </p></li><li class="listitem"><p>A set of methods dealing with event management lets you, among
          other things, add and remove event listeners for the Working Memory
          and the Agenda.</p></li><li class="listitem"><p>Method <code class="code">getKieBase()</code> returns the
          <code class="code">KieBase</code> object, the backbone of all the Knowledge
          in your system, and the originator of the current session.</p></li><li class="listitem"><p>You can manage globals with <code class="code">setGlobal(...)</code>,
          <code class="code">getGlobal(...)</code> and <code class="code">getGlobals()</code>.</p></li><li class="listitem"><p>Method <code class="code">getEnvironment()</code> returns the runtime's
          <code class="code">Environment</code> which works much like what you know as your
          operating system's environment.</p></li></ul></div></div><div class="section" title="8.8.4.2. The modify Statement"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11890"/>8.8.4.2. The <code class="literal">modify</code> Statement</h4></div></div></div><p>This language extension provides a structured approach to fact
      updates. It combines the update operation with a number of setter calls
      to change the object's fields. This is the syntax schema for the
      <code class="literal">modify</code> statement:</p><pre><code class="no-highlight"><code class="literal">modify ( </code><em class="replaceable"><code>&lt;fact-expression&gt;</code></em><code class="literal"> ) {</code>
    <em class="replaceable"><code>&lt;expression&gt;</code></em> [ <code class="literal">,</code> <em class="replaceable"><code>&lt;expression&gt;</code></em> ]*
<code class="literal">}</code></code></pre><p>The parenthesized <span class="emphasis"><em>&lt;fact-expression&gt;</em></span>
      must yield a fact object reference. The expression list in the block
      should consist of setter calls for the given object, to be written
      without the usual object reference, which is automatically prepended by
      the compiler.</p><p>The example illustrates a simple fact modification.</p><div class="example"><a id="d0e11927"/><p class="title"><strong>Example 8.83. A modify statement</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</code></pre></div></div><br class="example-break"/><p>The advantages in using the modify statment are particularly clear when
      used in conjuction with fine grained property change listeners.
      See the corresponding section for more details.</p></div></div><div class="section" title="8.8.5. Conditional named consequences"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11934"/>8.8.5. Conditional named consequences</h3></div></div></div><p>Sometimes the constraint of having one single consequence for each rule can
    be somewhat limiting and leads to verbose and difficult to be maintained repetitions
    like in the following example:</p><pre><code class="no-highlight">rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</code></pre><p>It is already possible to partially overcome this problem by making the
    second rule extending the first one like in:</p><pre><code class="no-highlight">rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
    extends "Give 10% discount to customers older than 60"
when
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</code></pre><p>Anyway this feature makes it possible to define more labelled consequences
    other than the default one in a single rule, so, for example, the 2 former rules
    can be compacted in only one like it follows:</p><pre><code class="no-highlight">rule "Give 10% discount and free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</code></pre><p>This last rule has 2 consequences, the usual default one, plus another one
    named "giveDiscount" that is activated, using the keyword do, as soon as a customer
    older than 60 is found in the knowledge base, regardless of the fact that he owns a
    car or not. The activation of a named consequence can be also guarded by an additional
    condition like in this further example:</p><pre><code class="no-highlight">rule "Give free parking to customers older than 60 and 10% discount to golden ones among them"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</code></pre><p>The condition in the if statement is always evaluated on the pattern immediately
    preceding it. In the end this last, a bit more complicated, example shows how it is
    possible to switch over different conditions using a nested if/else statement:</p><pre><code class="no-highlight">rule "Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount10]
    else if ( type == "Silver" ) break[giveDiscount5]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount10]
    modify($customer) { setDiscount( 0.1 ) };
then[giveDiscount5]
    modify($customer) { setDiscount( 0.05 ) };
end</code></pre><p>Here the purpose is to give a 10% discount AND a free parking to Golden customers
    over 60, but only a 5% discount (without free parking) to the Silver ones. This result
    is achieved by activating the consequence named "giveDiscount5" using the keyword break
    instead of do. In fact do just schedules a consequence in the agenda, allowing the
    remaining part of the LHS to continue of being evaluated as per normal, while break also
    blocks any further pattern matching evaluation. Note, of course, that the activation of
    a named consequence not guarded by any condition with break doesn't make sense (and
    generates a compile time error) since otherwise the LHS part following it would be never
    reachable.</p></div><div class="section" title="8.8.6. A Note on Auto-boxing and Primitive Types"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11959"/>8.8.6. A Note on Auto-boxing and Primitive Types</h3></div></div></div><p>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives were autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing JDK 1.5
    and JDK 5 rules to handle auto-boxing and unboxing apply in this case.
    When evaluating field constraints, the system attempts to coerce one of
    the values into a comparable format; so a primitive is comparable to an
    object wrapper.</p></div></div><div class="section" title="8.9. Query"><div class="titlepage"><div><div><h2 class="title"><a id="QuerySection"/>8.9. Query</h2></div></div></div><div class="figure"><a id="d0e11967"/><p class="title"><strong>Figure 8.29. query</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/query.png" align="middle" alt="query"/></div></div></div><br class="figure-break"/><p>A query is a simple way to search the working memory for facts that
  match the stated conditions. Therefore, it contains only the structure of
  the LHS of a rule, so that you specify neither "when" nor "then". A query
  has an optional set of parameters, each of which can be optionally typed. If
  the type is not given, the type Object is assumed. The engine will attempt
  to coerce the values as needed. Query names are global to the KieBase;
  so do not add queries of the same name to different packages for the same
  RuleBase.</p><p>To return the results use
  <code class="code">ksession.getQueryResults("name")</code>, where "name" is the query's
  name. This returns a list of query results, which allow you to retrieve the
  objects that matched the query.</p><p>The first example presents a simple query for all the people over the
  age of 30. The second one, using parameters, combines the age limit with a
  location.</p><div class="example"><a id="d0e11982"/><p class="title"><strong>Example 8.84. Query People over the age of 30</strong></p><div class="example-contents"><pre><code class="no-highlight">query "people over the age of 30" 
    person : Person( age &gt; 30 )
end</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e11987"/><p class="title"><strong>Example 8.85. Query People over the age of x, and who live in y</strong></p><div class="example-contents"><pre><code class="no-highlight">query "people over the age of x"  (int x, String y)
    person : Person( age &gt; x, location == y )
end</code></pre></div></div><br class="example-break"/><p>We iterate over the returned QueryResults using a standard "for" loop.
  Each element is a QueryResultsRow which we can use to access each of the
  columns in the tuple. These columns can be accessed by bound declaration
  name or index position.</p><div class="example"><a id="d0e11994"/><p class="title"><strong>Example 8.86. Query People over the age of 30</strong></p><div class="example-contents"><pre><code class="no-highlight">QueryResults results = ksession.getQueryResults( "people over the age of 30" );
System.out.println( "we have " + results.size() + " people over the age  of 30" );

System.out.println( "These people are are over 30:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</code></pre></div></div><br class="example-break"/><p>Support for positional syntax has been added for more compact code. By
  default the declared type order in the type declaration matches the argument
  position. But it possible to override these using the @position annotation.
  This allows patterns to be used with positional arguments, instead of the
  more verbose named arguments.</p><pre><code class="no-highlight">declare Cheese
    name : String @position(1)
    shop : String @position(2)
    price : int @position(0)
end
</code></pre><p>The @Position annotation, in the org.drools.definition.type package,
  can be used to annotate original pojos on the classpath. Currently only
  fields on classes can be annotated. Inheritance of classes is supported, but
  not interfaces or methods. The isContainedIn query below demonstrates the
  use of positional arguments in a pattern; <code class="literal">Location(x, y;)</code>
  instead of <code class="literal">Location( thing == x, location == y).</code></p><p>Queries can now call other queries, this combined with optional query
  arguments provides derivation query style backward chaining. Positional and
  named syntax is supported for arguments. It is also possible to mix both
  positional and named, but positional must come first, separated by a semi
  colon. Literal expressions can be passed as query arguments, but at this
  stage you cannot mix expressions with variables. Here is an example of a
  query that calls another query. Note that 'z' here will always be an 'out'
  variable. The '?' symbol means the query is pull only, once the results are
  returned you will not receive further results as the underlying data
  changes.</p><pre><code class="no-highlight">declare Location
    thing : String 
    location : String 
end

query isContainedIn( String x, String y ) 
    Location(x, y;)
    or 
    ( Location(z, y;) and ?isContainedIn(x, z;) )
end</code></pre><p>As previously mentioned you can use live "open" queries to reactively
  receive changes over time from the query results, as the underlying data it
  queries against changes. Notice the "look" rule calls the query without
  using '?'.</p><pre><code class="no-highlight">query isContainedIn( String x, String y ) 
    Location(x, y;)
    or 
    ( Location(z, y;) and isContainedIn(x, z;) )
end

rule look when 
    Person( $l : likes ) 
    isContainedIn( $l, 'office'; )
then
   insertLogical( $l 'is in the office' );
end 
</code></pre><p>Drools supports unification for derivation queries, in short this
    means that arguments are optional. It is possible to call queries from Java
    leaving arguments unspecified using the static field
    org.drools.core.runtime.rule.Variable.v - note you must use 'v' and not an
    alternative instance of Variable. These are referred to as 'out' arguments.
    Note that the query itself does not declare at compile time whether an
    argument is in or an out, this can be defined purely at runtime on each use.
    The following example will return all objects contained in the
    office.</p><pre><code class="no-highlight">results = ksession.getQueryResults( "isContainedIn", new Object[] {  Variable.v, "office" } );
l = new ArrayList&lt;List&lt;String&gt;&gt;();
for ( QueryResultsRow r : results ) {
    l.add( Arrays.asList( new String[] { (String) r.get( "x" ), (String) r.get( "y" ) } ) );
}  
</code></pre><p>The algorithm uses stacks to handle recursion, so the method stack
  will not blow up.</p><p>It is also possible to use as input argument for a query both the field of a fact as in:</p><pre><code class="no-highlight">query contains(String $s, String $c)
    $s := String( this.contains( $c ) )
end

rule PersonNamesWithA when
    $p : Person()
    contains( $p.name, "a"; )
then
end</code></pre><p>and more in general any kind of valid expression like in:</p><pre><code class="no-highlight">query checkLength(String $s, int $l)
    $s := String( length == $l )
end

rule CheckPersonNameLength when
    $i : Integer()
    $p : Person()
    checkLength( $p.name, 1 + $i + $p.age; )
then
end</code></pre><p>The following is not yet supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>List and Map unification</p></li><li class="listitem"><p>Expression unification - pred( X, X + 1, X * Y / 7 )</p></li></ul></div></div><div class="section" title="8.10. Domain Specific Languages"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12041"/>8.10. Domain Specific Languages</h2></div></div></div><p><a id="d0e12045" class="indexterm"/>Domain Specific Languages (or DSLs) are a way of creating a rule
  language that is dedicated to your problem domain. A set of DSL definitions
  consists of transformations from DSL "sentences" to DRL constructs, which lets
  you use of all the underlying rule language and engine features. Given a
  DSL, you write rules in DSL rule (or DSLR) files, which will be translated
  into DRL files.</p><p>DSL and DSLR files are plain text files, and you can use any text
  editor to create and modify them. But there are also DSL and DSLR editors,
  both in the IDE as well as in the web based BRMS, and you can use those
  as well, although they may not provide you with the full DSL functionality.
  </p><div class="section" title="8.10.1. When to Use a DSL"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12051"/>8.10.1. When to Use a DSL</h3></div></div></div><p>DSLs can serve as a layer of separation between rule authoring (and
    rule authors) and the technical intricacies resulting from the modelling
    of domain object and the rule engine's native language and methods. If your
    rules need to be read and validated by domain experts (such as business
    analysts, for instance) who are not programmers, you should consider 
    using a DSL; it hides implementation details and focuses on the rule logic
    proper. DSL sentences can also act as "templates" for conditional elements and
    consequence actions that are used repeatedly in your rules, possibly with
    minor variations. You may define DSL sentences as being mapped to these
    repeated phrases, with parameters providing a means for accommodating those
    variations.</p><p>DSLs have no impact on the rule engine at runtime, they are just a
    compile time feature, requiring a special parser and transformer.</p></div><div class="section" title="8.10.2. DSL Basics"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12058"/>8.10.2. DSL Basics</h3></div></div></div><p>The Drools DSL mechanism allows you to customise conditional
    expressions and consequence actions. A global substitution mechanism
    ("keyword") is also available.</p><div class="example"><a id="d0e12063"/><p class="title"><strong>Example 8.87. Example <a id="d0e12066" class="indexterm"/>DSL mapping</strong></p><div class="example-contents"><pre><code class="no-highlight">[when]Something is {colour}=Something(colour=="{colour}")</code></pre></div></div><br class="example-break"/><p>In the preceding example, <code class="code">[when]</code> indicates the scope of
    the expression, i.e., whether it is valid for the LHS or the RHS of a rule. The
    part after the bracketed keyword is the expression that you use in the rule;
    typically a natural language expression, but it doesn't have to be. The
    part to the right of the equal sign ("=") is the mapping of the expression into
    the rule language. The form of this string depends on its destination, RHS or 
    LHS. If it is for the LHS, then it ought to be a term according to the regular
    LHS syntax; if it is for the RHS then it might be a Java statement.</p><p>Whenever the DSL parser matches a line from the rule file written in the
    DSL with an expression in the DSL definition, it performs three steps of
    string manipulation. First, it extracts the string values appearing where the
    expression contains variable names in braces (here: <code class="code">{colour}</code>). Then,
    the values obtained from these captures are then interpolated wherever that name,
    again enclosed in braces, occurs on the right hand side of the mapping. Finally, the
    interpolated string replaces whatever was matched by the entire expression
    in the line of the DSL rule file.</p><p>Note that the expressions (i.e., the strings on the left hand side of the
    equal sign) are used as regular expressions in a pattern matching operation
    against a line of the DSL rule file, matching all or part of a line. This means
    you can use (for instance) a '?' to indicate that the preceding character is
    optional. One good reason to use this is to overcome variations in natural language
    phrases of your DSL. But, given that these expressions are regular
    expression patterns, this also means that all "magic" characters of Java's
    pattern syntax have to be escaped with a preceding backslash ('\').</p><p>It is important to note that the compiler transforms DSL rule files
    line by line. In the above example, all the text after "Something is " to
    the end of the line is captured as the replacement value for "{colour}",
    and this is used for interpolating the target string. This may not be exactly
    what you want. For instance, when you intend to merge different DSL
    expressions to generate a composite DRL pattern, you need to transform a DSLR
    line in several independent operations. The best way to achieve this is to
    ensure that the captures are surrounded by characteristic text - words or 
    even single characters. As a result,
    the matching operation done by the parser plucks out a substring from 
    somewhere within the line. In the example below, quotes are used as 
    distinctive characters. Note that the characters that surround the capture
    are not included during interpolation, just the contents between them.</p><p>As a rule of thumb, use quotes for textual data that a rule editor
    may want to enter. You can also enclose the capture with words to ensure
    that the text is correctly matched. Both is illustrated by the following
    example. Note that a single line such as <code class="code">Something is "green" and
    another solid thing</code> is now correctly expanded.</p><div class="example"><a id="d0e12091"/><p class="title"><strong>Example 8.88. Example with quotes</strong></p><div class="example-contents"><pre><code class="no-highlight">[when]something is "{colour}"=Something(colour=="{colour}")
[when]another {state} thing=OtherThing(state=="{state})"</code></pre></div></div><br class="example-break"/><p>It is a good idea to avoid punctuation (other than quotes or
    apostrophes) in your DSL expressions as much as possible. The main reason
    is that punctuation is easy to forget for rule authors using your DSL.
    Another reason is that parentheses, the period and the question mark are magic
    characters, requiring escaping in the DSL definition.</p><p>In a DSL mapping, the braces "{" and "}" should only be used to
    enclose a variable definition or reference, resulting in a capture. If they
    should occur literally, either in the expression or within the replacement
    text on the right hand side, they must be escaped with a preceding backslash
    ("\"):</p><pre><code class="no-highlight">[then]do something= if (foo) \{ doSomething(); \}
    </code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If braces "{" and "}" should appear in the replacement string of a
    DSL definition, escape them with a backslash ('\').</p></div><div class="example"><a id="d0e12105"/><p class="title"><strong>Example 8.89. Examples of DSL mapping entries</strong></p><div class="example-contents"><pre><code class="no-highlight"># This is a comment to be ignored.
[when]There is a person with name of "{name}"=Person(name=="{name}")
[when]Person is at least {age} years old and lives in "{location}"=
      Person(age &gt;= {age}, location=="{location}")
[then]Log "{message}"=System.out.println("{message}");
[when]And = and</code></pre></div></div><br class="example-break"/><p>Given the above DSL examples, the following examples show the expansion of various
    DSLR snippets:</p><div class="example"><a id="d0e12112"/><p class="title"><strong>Example 8.90. Examples of DSL expansions </strong></p><div class="example-contents"><pre><code class="no-highlight">There is a person with name of "Kitty"
   ==&gt; Person(name="Kitty")
Person is at least 42 years old and lives in "Atlanta"
   ==&gt; Person(age &gt;= 42, location="Atlanta")
Log "boo"
   ==&gt; System.out.println("boo");
There is a person with name of "Bob" and Person is at least 30 years old and lives in "Utah"
   ==&gt; Person(name="Bob") and Person(age &gt;= 30, location="Utah")</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Don't forget that if you are capturing plain text from a DSL rule line
    and want to use it as a string literal in the expansion, you must provide
    the quotes on the right hand side of the mapping.</p></div><p>You can chain DSL expressions together on one line, as long as it is
    clear to the parser where one ends and the next one begins and where the
    text representing a parameter ends. (Otherwise you risk getting all the
    text until the end of the line as a parameter value.) The DSL expressions are
    tried, one after the other, according to their order in the DSL definition
    file. After any match, all remaining DSL expressions are investigated,
    too.</p><p>The resulting DRL text may consist of more than one line. Line ends
    are in the replacement text are written as <code class="code">\n</code>.</p></div><div class="section" title="8.10.3. Adding Constraints to Facts"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12127"/>8.10.3. Adding Constraints to Facts</h3></div></div></div><p>A common requirement when writing rule conditions is to be able to
    add an arbitrary combination of constraints to a pattern. Given that a
    fact type may have many fields, having to provide an individual DSL
    statement for each combination would be plain folly.</p><p>The DSL facility allows you to add constraints to a pattern by a
    simple convention: if your DSL expression starts with a hyphen
    (minus character, "-") it is assumed to be a field constraint and,
    consequently, is is added to the last pattern line preceding it.</p><p>For an example, lets take look at class <code class="code">Cheese</code>,
    with the following fields: type, price, age and country. We can
    express some LHS condition in normal DRL like the following</p><pre><code class="no-highlight">Cheese(age &lt; 5, price == 20, type=="stilton", country=="ch")</code></pre><p>The DSL definitions given below result in three DSL phrases which
    may be used to create any combination of constraint involving these fields.</p><pre><code class="no-highlight">[when]There is a Cheese with=Cheese()
[when]- age is less than {age}=age&lt;{age}
[when]- type is '{type}'=type=='{type}'
[when]- country equal to '{country}'=country=='{country}'</code></pre><p>You can then write rules with conditions like the following:
    </p><pre><code class="no-highlight">There is a Cheese with
        - age is less than 42
        - type is 'stilton'</code></pre><p> The parser will pick up a line
    beginning with "-" and add it as a constraint to  the preceding pattern,
    inserting a comma when it is required. For the preceding example, the
    resulting DRL is: </p><pre><code class="no-highlight">Cheese(age&lt;42, type=='stilton')</code></pre><p>
    </p><p>Combining all all numeric fields with all relational operators
    (according to the DSL expression "age is less than..." in the preceding
    example) produces an unwieldy amount of DSL entries. But you can define
    DSL phrases for the various operators and even a generic expression
    that handles any field constraint, as shown below. (Notice that
    the expression definition contains a regular expression in addition
    to the variable name.)</p><pre><code class="no-highlight">[when][]is less than or equal to=&lt;=
[when][]is less than=&lt;
[when][]is greater than or equal to=&gt;=
[when][]is greater than=&gt;
[when][]is equal to===
[when][]equals===
[when][]There is a Cheese with=Cheese()
[when][]- {field:\w*} {operator} {value:\d*}={field} {operator} {value} </code></pre><p>Given these DSL definitions, you can write rules with conditions
    such as:</p><pre><code class="no-highlight">There is a Cheese with
   - age is less than 42
   - rating is greater than 50
   - type equals 'stilton'</code></pre><p>In this specific case, a phrase such as "is less than" is replaced by
    <code class="code">&lt;</code>, and then the line matches the last DSL entry. This
    removes the hyphen, but the final result is still added as a constraint
    to the preceding pattern. After processing all of the lines, the resulting
    DRL text is:</p><pre><code class="no-highlight">Cheese(age&lt;42, rating &gt; 50, type=='stilton')</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The order of the entries in the DSL is important if separate DSL
    expressions are intended to match the same line, one after the other.</p></div></div><div class="section" title="8.10.4. Developing a DSL"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12171"/>8.10.4. Developing a DSL</h3></div></div></div><p>A good way to get started is to write representative samples of the
    rules your application requires, and to test them as you develop. This will
    provide you with a stable framework of conditional elements and their
    constraints. Rules, both in DRL and in DSLR, refer to entities according
    to the data model representing the application data that should be subject
    to the reasoning process defined in rules. Notice that writing rules
    is generally easier if most of the data model's types are facts.</p><p>Given an initial set of rules, it should be possible to identify
    recurring or similar code snippets and to mark variable parts as
    parameters. This provides reliable leads as to what might be a handy
    DSL entry. Also, make sure you have a full grasp of the jargon the 
    domain experts are using, and base your DSL phrases on this vocabulary.</p><p>You may postpone implementation decisions concerning conditions
    and actions during this first design phase by leaving certain conditional
    elements and actions in their DRL form by prefixing a line with a
    greater sign ("&gt;"). (This is also handy for inserting debugging
    statements.)</p><p>During the next development phase, you should find that the DSL
    configuration stabilizes pretty quickly. New rules can be written by
    reusing the existing DSL definitions, or by adding a parameter to an
    existing condition or consequence entry.</p><p>Try to keep the number of DSL entries small. Using parameters
    lets you apply the same DSL sentence for similar rule patterns or
    constraints. But do not exaggerate: authors using the DSL should still
    be able to identify DSL phrases by some fixed text.</p></div><div class="section" title="8.10.5. DSL and DSLR Reference"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12184"/>8.10.5. DSL and DSLR Reference</h3></div></div></div><p>A DSL file is a text file in a line-oriented format. Its
    entries are used for transforming a DSLR file into a file according
    to DRL syntax.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A line starting with "#" or "//"
        (with or without preceding white space) is treated as a comment.
        A comment line starting with "#/" is scanned for
        words requesting a debug option, see below.</p></li><li class="listitem"><p>Any line starting with an opening bracket ("[") is assumed to
        be the first line of a DSL entry definition.</p></li><li class="listitem"><p>Any other line is appended to the preceding DSL entry
        definition, with the line end replaced by a space.</p></li></ul></div><p>A DSL entry consists of the following four parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A scope definition, written as one of the keywords
        "when" or "condition", "then" or "consequence", "*"
        and "keyword", enclosed in brackets ("[" and "]"). This indicates
        whether the DSL entry is valid for the condition or the
        consequence of a rule, or both. A scope indication of "keyword"
        means that the entry has global significance, i.e., it is
        recognized anywhere in a DSLR file.</p></li><li class="listitem"><p>A type definition, written as a Java class name,
        enclosed in brackets. This part is optional unless the
        the next part begins with an opening bracket. An empty
        pair of brackets is valid, too.</p></li><li class="listitem"><p>A DSL expression consists of a (Java) regular expression,
        with any number of embedded <span class="emphasis"><em>variable definitions,</em></span>
        terminated by an equal sign ("="). A variable definition is enclosed
        in braces ("{" and "}"). It
        consists of a variable name and two optional attachments, separated
        by colons (":"). If there is one attachment, it is a regular expression
        for matching text that is to be assigned to the variable; if there
        are two attachments, the first one is a hint for the GUI
        editor and the second one the regular expression.</p><p>Note that all characters that are "magic" in regular
        expressions must be escaped with a preceding backslash ("\")
        if they should occur literally within the expression.</p></li><li class="listitem"><p>The remaining part of the line after the delimiting equal
        sign is the replacement text for any DSLR text matching the
        regular expression. It may contain variable references, i.e.,
        a variable name enclosed in braces. Optionally, the variable name
        may be followed by an exclamation mark ("!") and a transformation
        function, see below.</p><p>Note that braces ("{" and "}") must be escaped with a
        preceding backslash ("\") if they should occur literally
        within the replacement string.</p></li></ul></div><p>Debugging of DSL expansion can be turned on, selectively,
    by using a comment line starting with "#/" which
    may contain one or more words from the table presented below.
    The resulting output is written to standard output.</p><div class="table"><a id="d0e12223"/><p class="title"><strong>Table 8.2. Debug options for DSL expansion</strong></p><div class="table-contents"><table summary="Debug options for DSL expansion" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Word</th><th>Description</th></tr></thead><tbody><tr><td>result</td><td>Prints the resulting DRL text, with line numbers.</td></tr><tr><td>steps</td><td>Prints each expansion step of condition and consequence
            lines.</td></tr><tr><td>keyword</td><td>Dumps the internal representation of all DSL entries with
            scope "keyword".</td></tr><tr><td>when</td><td>Dumps the internal representation of all DSL entries with
            scope "when" or "*".</td></tr><tr><td>then</td><td>Dumps the internal representation of all DSL entries with
            scope "then" or "*".</td></tr><tr><td>usage</td><td>Displays a usage statistic of all DSL entries.</td></tr></tbody></table></div></div><br class="table-break"/><p>Below are some sample DSL definitions, with comments describing the
    language features they illustrate.</p><pre><code class="no-highlight"># Comment: DSL examples

#/ debug: display result and usage

# keyword definition: replaces "regula" by "rule"
[keyword][]regula=rule

# conditional element: "T" or "t", "a" or "an", convert matched word
[when][][Tt]here is an? {entity:\w+}=
        ${entity!lc}: {entity!ucfirst} ()

# consequence statement: convert matched word, literal braces
[then][]update {entity:\w+}=modify( ${entity!lc} )\{ \}
</code></pre><p>The transformation of a DSLR file proceeds as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The text is read into memory.</p></li><li class="listitem"><p>Each of the "keyword" entries is applied to the entire text.
        First, the regular expression from the keyword definition is modified
        by replacing white space sequences with a pattern matching any number
        of white space characters, and by replacing variable definitions with
        a capture made from the regular expression provided with the definition,
        or with the default (".*?"). Then, the DSLR text is searched exhaustively
        for occurrences of strings matching the modified regular expression.
        Substrings of a matching string corresponding to variable captures are
        extracted and replace variable references in the corresponding
        replacement text, and this text replaces the matching string in the
        DSLR text.</p></li><li class="listitem"><p>Sections of the DSLR text between "when" and "then", and
        "then" and "end", respectively, are located and processed in a
        uniform manner, line by line, as described below.</p><p>For a line, each DSL entry pertaining to the line's section
        is taken in turn, in the order it appears in the DSL file. Its
        regular expression part is modified: white space is replaced by
        a pattern matching any number of white space characters; variable
        definitions with a regular expression are replaced by a capture
        with this regular expression, its default being ".*?".
        If the resulting regular expression matches all or part of the
        line, the matched part is replaced by the suitably modified
        replacement text.</p><p>Modification of the replacement text is done by replacing
        variable references with the text corresponding to the regular
        expression capture. This text may be modified according to the
        string transformation function given in the variable reference;
        see below for details.</p><p>If there is a variable reference naming a variable that is not
        defined in the same entry, the expander substitutes a value bound to
        a variable of that name, provided it was defined in one of the
        preceding lines of the current rule.</p></li><li class="listitem"><p>If a DSLR line in a condition is written with a leading
        hyphen, the expanded result is inserted into the last line, which
        should contain a pattern CE, i.e., a type name followed by a pair
        of parentheses. if this pair is empty, the expanded line (which
        should contain a valid constraint) is simply inserted, otherwise
        a comma (",") is inserted beforehand.  </p><p>If a DSLR line in a consequence is written with a leading
        hyphen, the expanded result is inserted into the last line, which
        should contain a "modify" statement, ending in a pair of braces
        ("{" and "}"). If this pair is empty, the expanded line (which
        should contain a valid method call) is simply inserted, otherwise
        a comma (",") is inserted beforehand.
        </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It is currently <span class="emphasis"><em>not</em></span> possible to use a line
    with a leading hyphen to insert text into other conditional element
    forms (e.g., "accumulate") or it may only work for the first insertion
    (e.g., "eval").</p></div><p>All string transformation functions are described in the following
    table.</p><div class="table"><a id="d0e12299"/><p class="title"><strong>Table 8.3. String transformation functions</strong></p><div class="table-contents"><table summary="String transformation functions" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>uc</td><td>Converts all letters to upper case.</td></tr><tr><td>lc</td><td>Converts all letters to lower case.</td></tr><tr><td>ucfirst</td><td>Converts the first letter to upper case, and
            all other letters to lower case.</td></tr><tr><td>num</td><td>Extracts all digits and "-" from the string. If the
            last two digits in the original string are preceded by "." or
            ",", a decimal period is inserted in the corresponding position.</td></tr><tr><td><span class="emphasis"><em>a</em></span>?<span class="emphasis"><em>b</em></span>/<span class="emphasis"><em>c</em></span></td><td>Compares the string with string <span class="emphasis"><em>a</em></span>, and if they
            are equal, replaces it with <span class="emphasis"><em>b</em></span>, otherwise with
            <span class="emphasis"><em>c</em></span>. But <span class="emphasis"><em>c</em></span> can be another triplet
            <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>c</em></span>, so
            that the entire structure is, in fact, a translation table.</td></tr></tbody></table></div></div><br class="table-break"/><p>The following DSL examples show how to use string transformation functions.</p><pre><code class="no-highlight"># definitions for conditions
[when][]There is an? {entity}=${entity!lc}: {entity!ucfirst}()
[when][]- with an? {attr} greater than {amount}={attr} &lt;= {amount!num}
[when][]- with a {what} {attr}={attr} {what!positive?&gt;0/negative?%lt;0/zero?==0/ERROR}</code></pre><p>A file containing a DSL definition has to be put under the resources folder
    or any of its subfolders like any other drools artifact. It must have the extension
    <code class="code">.dsl</code>, or alternatively be marked with type <code class="code">ResourceType.DSL</code>.
    when programmatically added to a <code class="code">KieFileSystem</code>. For a file using DSL
    definition, the extension <code class="code">.dslr</code> should be used, while it can be
    added to a <code class="code">KieFileSystem</code> with type <code class="code">ResourceType.DSLR</code>.</p><p>For parsing and expanding a DSLR file the DSL configuration is read
    and supplied to the parser. Thus, the parser can "recognize" the DSL
    expressions and transform them into native rule language expressions.</p></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch07.html"><strong>Prev</strong>Chapter 7. Running</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch09.html"><strong>Next</strong>Chapter 9. Complex Event Processing</a></li></ul></body></html>