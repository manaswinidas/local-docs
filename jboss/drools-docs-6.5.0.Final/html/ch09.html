<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. Complex Event Processing</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt03.html" title="Part III. Drools Runtime and Language"/><link rel="prev" href="ch08.html" title="Chapter 8. Rule Language Reference"/><link rel="next" href="ch10.html" title="Chapter 10. Experimental Features"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch08.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch10.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 9. Complex Event Processing"><div class="titlepage"><div><div><h2 class="title"><a id="DroolsComplexEventProcessingChapter"/>Chapter 9. Complex Event Processing</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch09.html#d0e12392">9.1. Complex Event Processing</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12443">9.2. Drools Fusion</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12545">9.3. Event Semantics</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12597">9.4. Event Processing Modes</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e12604">9.4.1. Cloud Mode</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12635">9.4.2. Stream Mode</a></span></dt></dl></dd><dt><span class="section"><a href="ch09.html#d0e12715">9.5. Session Clock</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e12746">9.5.1. Available Clock Implementations</a></span></dt></dl></dd><dt><span class="section"><a href="ch09.html#d0e12773">9.6. Sliding Windows</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e12786">9.6.1. Sliding Time Windows</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12809">9.6.2. Sliding Length Windows</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12845">9.6.3. Window Declaration</a></span></dt></dl></dd><dt><span class="section"><a href="ch09.html#d0e12866">9.7. Streams Support</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e12888">9.7.1. Declaring and Using Entry Points</a></span></dt></dl></dd><dt><span class="section"><a href="ch09.html#d0e12922">9.8. Memory Management for Events</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e12940">9.8.1. Explicit expiration offset</a></span></dt><dt><span class="section"><a href="ch09.html#d0e12958">9.8.2. Inferred expiration offset</a></span></dt></dl></dd><dt><span class="section"><a href="ch09.html#d0e12978">9.9. Temporal Reasoning</a></span></dt><dd><dl><dt><span class="section"><a href="ch09.html#d0e13050">9.9.1. Temporal Operators</a></span></dt></dl></dd></dl></div><div class="section" title="9.1. Complex Event Processing"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12392"/>9.1. Complex Event Processing</h2></div></div></div><p>There is no broadly accepted definition on the term Complex Event Processing. The term Event
    by itself is frequently overloaded and used to refer to several different things, depending on
    the context it is used. Defining terms is not the goal of this guide and as so, lets adopt a
    loose definition that, although not formal, will allow us to proceed with a common
    understanding.</p><p>So, in the scope of this guide:</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p><a id="d0e12401" class="indexterm"/>
      <span class="bold"><strong>Event</strong></span>, is a record of a significant change of state in the
      application domain at a given point in time.</p></div><p>For instance, on a Stock Broker application, when a sale operation is executed, it causes a
    change of state in the domain. This change of state can be observed on several entities in the
    domain, like the price of the securities that changed to match the value of the operation, the
    ownership of the traded assets that changed from the seller to the buyer, the balance of the
    accounts from both seller and buyer that are credited and debited, etc. Depending on how the
    domain is modelled, this change of state may be represented by a single event, multiple atomic
    events or even hierarchies of correlated events. In any case, in the context of this guide,
    Event is the record of the change of a particular piece of data in the domain.</p><p>Events are processed by computer systems since they were invented, and
  throughout the history, systems responsible for that were given different
  names and different methodologies were employed. It wasn't until the 90's
  though, that a more focused work started on EDA (Event Driven Architecture)
  with a more formal definition on the requirements and goals for event
  processing. Old messaging systems started to change to address such
  requirements and new systems started to be developed with the single purpose
  of event processing. Two trends were born under the names of Event Stream
  Processing and Complex Event Processing.</p><p>In the very beginnings, Event Stream Processing was focused on the capabilities of
    processing streams of events in (near) real time, while the main focus of Complex Event
    Processing was on the correlation and composition of atomic events into complex (compound)
    events. An important (maybe the most important) milestone was the publishing of Dr. David
    Luckham's book "The Power of Events" in 2002. In the book, Dr Luckham introduces the concept of
    Complex Event Processing and how it can be used to enhance systems that deal with events. Over
    the years, both trends converged to a common understanding and today these systems are all
    referred to as CEP systems.</p><p>This is a very simplistic explanation to a really complex and fertile field of research, but
    sets a high level and common understanding of the concepts that this guide will
    introduce.</p><p>The current understanding of what Complex Event Processing is may be
  briefly described as the following quote from Wikipedia:</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>"<a id="d0e12426" class="indexterm"/><span class="bold"><strong>Complex Event
      Processing</strong></span>, or CEP, is primarily an event processing concept
      that deals with the task of processing multiple events with the goal of
      identifying the meaningful events within the event cloud. CEP employs
      techniques such as detection of complex patterns of many events, event
      correlation and abstraction, event hierarchies, and relationships
      between events such as causality, membership, and timing, and
      event-driven processes."</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution"><em class="citetitle"><a class="link" href="http://en.wikipedia.org/wiki/Complex_event_processing">Wikipedia</a></em></span></td></tr></table></div></div><p>In other words, CEP is about detecting and selecting the interesting
  events (and only them) from an event cloud, finding their relationships and
  inferring new data from them and their relationships.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For the remaining of this guide, we will use the terms 
   <span class="bold"><strong>Complex Event Processing</strong></span>
  and <span class="bold"><strong>CEP</strong></span> as a broad reference for any of 
  the related technologies
  and techniques, including but not limited to, CEP, Complex Event Processing,
  ESP, Event Stream Processing and Event Processing in general.</p></div></div><div class="section" title="9.2. Drools Fusion"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12443"/>9.2. Drools Fusion</h2></div></div></div><p>Event Processing use cases, in general, share several requirements and
  goals with Business Rules use cases. These overlaps happen both on the
  business side and on the technical side.</p><p>On the Business side:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Business rules are frequently defined based on the occurrence of
      scenarios triggered by events. Examples could be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On an algorithmic trading application: take an action if the
          security price increases X% compared to the day opening price, where
          the price increases are usually denoted by events on a Stock Trade
          application.</p></li><li class="listitem"><p>On a monitoring application: take an action if the temperature
          on the server room increases X degrees in Y minutes, where sensor
          readings are usually denoted by events.</p></li></ul></div></li><li class="listitem"><p>Both business rules and event processing queries change frequently
      and require immediate response for the business to adapt itself to new
      market conditions, new regulations and new enterprise policies.</p></li></ul></div><p>From a technical perspective:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Both require seamless integration with the enterprise
      infrastructure and applications, specially on autonomous governance,
      including, but not limited to, lifecycle management, auditing, security,
      etc.</p></li><li class="listitem"><p>Both have functional requirements like pattern matching and
      non-functional requirements like response time and query/rule
      explanation.</p></li></ul></div><p>Even sharing requirements and goals, historically, both fields were
  born appart and although the industry evolved and one can find good products
  on the market, they either focus on event processing or on business rules
  management. That is due not only because of historical reasons but also
  because, even overlapping in part, use cases do have some different
  requirements.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Drools was also born as a rules engine several years ago, but
    following the vision of becoming a single platform for behavioral
    modelling, it soon realized that it could only achieve this goal by
    crediting the same importance to the three complementary business
    modelling techniques:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Business Rules Management</p></li><li class="listitem"><p>Business Processes Management</p></li><li class="listitem"><p>Complex Event Processing</p></li></ul></div></div><p>In this context, Drools Fusion is the module responsible for adding
  event processing capabilities into the platform. </p><p>Supporting Complex Event Processing, though, is much more than simply
  understanding what an event is. CEP scenarios share several common and
  distinguishing characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Usually required to process huge volumes of events, but only a
      small percentage of the events are of real interest.</p></li><li class="listitem"><p>Events are usually immutable, since they are a record of state
      change.</p></li><li class="listitem"><p>Usually the rules and queries on events must run in reactive
      modes, i.e., react to the detection of event patterns.</p></li><li class="listitem"><p>Usually there are strong temporal relationships between related
      events.</p></li><li class="listitem"><p>Individual events are usually not important. The system is
      concerned about patterns of related events and their
      relationships.</p></li><li class="listitem"><p>Usually, the system is required to perform composition and
      aggregation of events.</p></li></ul></div><p>Based on this general common characteristics, Drools Fusion defined a
  set of goals to be achieved in order to support Complex Event Processing
  appropriately:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Support Events, with their proper semantics, as first class
      citizens.</p></li><li class="listitem"><p>Allow detection, correlation, aggregation and composition of
      events.</p></li><li class="listitem"><p>Support processing of Streams of events.</p></li><li class="listitem"><p>Support temporal constraints in order to model the temporal
      relationships between events.</p></li><li class="listitem"><p>Support sliding windows of interesting events.</p></li><li class="listitem"><p>Support a session scoped unified clock.</p></li><li class="listitem"><p>Support the required volumes of events for CEP use cases.</p></li><li class="listitem"><p>Support to (re)active rules.</p></li><li class="listitem"><p>Support adapters for event input into the engine
      (pipeline).</p></li></ul></div><p>The above list of goals are based on the requirements not covered by
  Drools Expert itself, since in a unified platform, all features of one
  module are leveraged by the other modules. This way, Drools Fusion is born
  with enterprise grade features like Pattern Matching, that is paramount to a
  CEP product, but that is already provided by Drools Expert. In the same way,
  all features provided by Drools Fusion are leveraged by Drools Flow (and
  vice-versa) making process management aware of event processing and
  vice-versa.</p><p>For the remaining of this guide, we will go through each of the
  features Drools Fusion adds to the platform. All these features are
  available to support different use cases in the CEP world, and the user is
  free to select and use the ones that will help him model his business use
  case.</p></div><div class="section" title="9.3. Event Semantics"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12545"/>9.3. Event Semantics</h2></div></div></div><p>An <span class="emphasis"><em>event</em></span> is a fact that present a few
  distinguishing characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>Usually immutables:</strong></span> since, by the
      previously discussed definition, events are a record of a state change
      in the application domain, i.e., a record of something that already
      happened, and the past can not be "changed", events are immutables. This
      constraint is an important requirement for the development of several
      optimizations and for the specification of the event lifecycle. This
      does not mean that the Java object representing the object must be
      immutable. Quite the contrary, the engine does not enforce immutability
      of the object model, because one of the most common use cases for rules
      is event data enrichment.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>As a best practice, the application is allowed to populate
        un-populated event attributes (to enrich the event with inferred data),
        but already populated attributes should never be changed.</p></div></li><li class="listitem"><p><span class="bold"><strong>Strong temporal constraints:</strong></span>
      rules involving events usually require the correlation of multiple
      events, specially temporal correlations where events are said to happen
      at some point in time relative to other events.</p></li><li class="listitem"><p><span class="bold"><strong>Managed lifecycle:</strong></span> due to their
      immutable nature and the temporal constraints, events usually will only
      match other events and facts during a limited window of time, making it
      possible for the engine to manage the lifecycle of the events
      automatically. In other words, one an event is inserted into the working
      memory, it is possible for the engine to find out when an event can no
      longer match other facts and automatically delete it, releasing its
      associated resources.</p></li><li class="listitem"><p><span class="bold"><strong>Use of sliding windows:</strong></span> since all
      events have timestamps associated to them, it is possible to define and
      use sliding windows over them, allowing the creation of rules on
      aggregations of values over a period of time. Example: average of an
      event value over 60 minutes.</p></li></ul></div><p>Drools supports the declaration and usage of events with both
  semantics: <span class="bold"><strong>point-in-time</strong></span> events and
  <span class="bold"><strong>interval-based</strong></span> events. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A simplistic way to understand the unitification of the semantics is
    to consider a <span class="emphasis"><em>point-in-time</em></span> event as an
    <span class="emphasis"><em>interval-based</em></span> event whose <span class="emphasis"><em>duration is
    zero</em></span>.</p></div></div><div class="section" title="9.4. Event Processing Modes"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12597"/>9.4. Event Processing Modes</h2></div></div></div><p>Rules engines in general have a well known way of processing data and
  rules and provide the application with the results. Also, there is not many
  requirements on how facts should be presented to the rules engine, specially
  because in general, the processing itself is time independent. That is a
  good assumption for most scenarios, but not for all of them. When the
  requirements include the processing of real time or near real time events,
  time becomes and important variable of the reasoning process.</p><p>The following sections will explain the impact of time on rules
  reasoning and the two modes provided by Drools for the reasoning process.
  </p><div class="section" title="9.4.1. Cloud Mode"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12604"/>9.4.1. Cloud Mode</h3></div></div></div><p>The CLOUD processing mode is the default processing mode. Users of
  rules engine are familiar with this mode because it behaves in exactly the
  same way as any pure forward chaining rules engine, including previous
  versions of Drools.</p><p>When running in CLOUD mode, the engine sees all facts in the working
  memory, does not matter if they are regular facts or events, as a whole.
  There is no notion of flow of time, although events have a timestamp as
  usual. In other words, although the engine knows that a given event was
  created, for instance, on January 1st 2009, at 09:35:40.767, it is not
  possible for the engine to determine how "old" the event is, because there
  is no concept of "now".</p><p>In this mode, the engine will apply its usual many-to-many pattern
  matching algorithm, using the rules constraints to find the matching tuples,
  activate and fire rules as usual.</p><p>This mode does not impose any kind of additional requirements on
  facts. So for instance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is no notion of time. No requirements clock synchronization.
      </p></li><li class="listitem"><p>There is no requirement on event ordering. The engine looks at the
      events as an unordered cloud against which the engine tries to match
      rules.</p></li></ul></div><p>On the other hand, since there is no requirements, some benefits are
  not available either. For instance, in CLOUD mode, it is not possible to use
  sliding windows, because sliding windows are based on the concept of "now"
  and there is no concept of "now" in CLOUD mode. </p><p>Since there is no ordering requirement on events, it is not possible
  for the engine to determine when events can no longer match and as so, there
  is no automatic life-cycle management for events. I.e., the application must
  explicitly delete events when they are no longer necessary, in the same way
  the application does with regular facts.</p><p>Cloud mode is the default execution mode for Drools, but in any case,
  as any other configuration in Drools, it is possible to change this behavior
  either by setting a system property, using configuration property files or
  using the API. The corresponding property is:</p><pre><code class="language-java">KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();
config.setOption( EventProcessingOption.CLOUD );</code></pre><p>The equivalent property is:</p><pre><code class="no-highlight">drools.eventProcessingMode = cloud</code></pre><p/></div><div class="section" title="9.4.2. Stream Mode"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12635"/>9.4.2. Stream Mode</h3></div></div></div><p>The STREAM processing mode is the mode of choice when the application
  needs to process streams of events. It adds a few common requirements to the
  regular processing, but enables a whole lot of features that make stream
  event processing a lot simpler.</p><p>The main requirements to use STREAM mode are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Events in each stream must be time-ordered. I.e., inside a given
      stream, events that happened first must be inserted first into the
      engine.</p></li><li class="listitem"><p>The engine will force synchronization between streams through the
      use of the session clock, so, although the application does not need to
      enforce time ordering between streams, the use of non-time-synchronized
      streams may result in some unexpected results.</p></li></ul></div><p>Given that the above requirements are met, the application may enable
  the STREAM mode using the following API:</p><pre><code class="language-java">KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();
config.setOption( EventProcessingOption.STREAM );</code></pre><p>Or, the equivalent property: </p><pre><code class="no-highlight">drools.eventProcessingMode = stream</code></pre><p>When using the STREAM, the engine knows the concept of flow of time
  and the concept of "now", i.e., the engine understands how old events are
  based on the current timestamp read from the Session Clock. This
  characteristic allows the engine to provide the following additional
  features to the application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Sliding Window support</p></li><li class="listitem"><p>Automatic Event Lifecycle Management</p></li><li class="listitem"><p>Automatic Rule Delaying when using Negative Patterns</p></li></ul></div><p>All these features are explained in the following sections.</p><div class="section" title="9.4.2.1. Role of Session Clock in Stream mode"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12671"/>9.4.2.1. Role of Session Clock in Stream mode</h4></div></div></div><p>When running the engine in CLOUD mode, the session clock is used
    only to time stamp the arriving events that don't have a previously
    defined timestamp attribute. Although, in STREAM mode, the Session Clock
    assumes an even more important role.</p><p>In STREAM mode, the session clock is responsible for keeping the
    current timestamp, and based on it, the engine does all the temporal
    calculations on event's aging, synchronizes streams from multiple sources,
    schedules future tasks and so on.</p><p>Check the documentation on the Session Clock section to know how to
    configure and use different session clock implementations.</p></div><div class="section" title="9.4.2.2. Negative Patterns in Stream Mode"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12680"/>9.4.2.2. Negative Patterns in Stream Mode</h4></div></div></div><p>Negative patterns behave different in STREAM mode when compared to
    CLOUD mode. In CLOUD mode, the engine assumes that all facts and events
    are known in advance (there is no concept of flow of time) and so,
    negative patterns are evaluated immediately.</p><p>When running in STREAM mode, negative patterns with temporal
    constraints may require the engine to wait for a time period before
    activating a rule. The time period is automatically calculated by the
    engine in a way that the user does not need to use any tricks to achieve
    the desired result.</p><p>For instance:</p><div class="example"><a id="d0e12689"/><p class="title"><strong>Example 9.1. a rule that activates immediately upon matching</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( ) )
then
    // sound the alarm
end
</code></pre></div></div><br class="example-break"/><p>The above rule has no temporal constraints that would require
    delaying the rule, and so, the rule activates immediately. The following
    rule on the other hand, must wait for 10 seconds before activating, since
    it may take up to 10 seconds for the sprinklers to activate:</p><div class="example"><a id="d0e12696"/><p class="title"><strong>Example 9.2. a rule that automatically delays activation due to temporal
        constraints</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</code></pre></div></div><br class="example-break"/><p>This behaviour allows the engine to keep consistency when
    dealing with negative patterns and temporal constraints at the same time.
    The above would be the same as writing the rule as below, but does not
    burden the user to calculate and explicitly write the appropriate duration
    parameter:</p><div class="example"><a id="d0e12703"/><p class="title"><strong>Example 9.3. same rule with explicit duration parameter</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
    duration( 10s )
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</code></pre></div></div><br class="example-break"/><p>The following rule expects every 10 seconds at least one
	  “Heartbeat” event, if not the rule fires. The special case in this rule
	  is that we use the same type of the object in the first pattern and in
	  the negative pattern. The negative pattern has the temporal constraint to
	  wait between 0 to 10 seconds before firing and it excludes the Heartbeat
	  bound to $h. Excluding the bound Heartbeat is important since the
	  temporal constraint [0s, ...] does not exclude by itself the bound event
	  $h from being matched again, thus preventing the rule to fire.</p><div class="example"><a id="d0e12710"/><p class="title"><strong>Example 9.4. excluding bound events in negative patterns</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $h: Heartbeat( ) from entry-point "MonitoringStream"
    not( Heartbeat( this != $h, this after[0s,10s] $h ) from entry-point "MonitoringStream" )
then
    // Sound the alarm
end</code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="9.5. Session Clock"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12715"/>9.5. Session Clock</h2></div></div></div><p>Reasoning over time requires a reference clock. Just to mention one
  example, if a rule reasons over the average price of a given stock over the
  last 60 minutes, how the engine knows what stock price changes happened over
  the last 60 minutes in order to calculate the average? The obvious response
  is: by comparing the timestamp of the events with the "current time". How
  the engine knows what <span class="bold"><strong>time is now</strong></span>? Again,
  obviously, by querying the Session Clock.</p><p>The session clock implements a strategy pattern, allowing different
  types of clocks to be plugged and used by the engine. This is very important
  because the engine may be running in an elements of different scenarios that
  may require different clock implementations. Just to mention a few:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>Rules testing:</strong></span> testing always
      requires a controlled environment, and when the tests include rules with
      temporal constraints, it is necessary to not only control the input
      rules and facts, but also the flow of time.</p></li><li class="listitem"><p><span class="bold"><strong>Regular execution:</strong></span> usually, when
      running rules in production, the application will require a real time
      clock that allows the rules engine to react immediately to the time
      progression.</p></li><li class="listitem"><p><span class="bold"><strong>Special environments:</strong></span> specific
      environments may have specific requirements on time control. Cluster
      environments may require clock synchronization through heart beats, or
      JEE environments may require the use of an AppServer provided clock,
      etc.</p></li><li class="listitem"><p><span class="bold"><strong>Rules replay or simulation: </strong></span>to
      replay scenarios or simulate scenarios it is necessary that the
      application also controls the flow of time.</p></li></ul></div><div class="section" title="9.5.1. Available Clock Implementations"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12746"/>9.5.1. Available Clock Implementations</h3></div></div></div><p>Drools 5 provides 2 clock implementations out of the box. The default
  real time clock, based on the system clock, and an optional pseudo clock,
  controlled by the application.</p><div class="section" title="9.5.1.1. Real Time Clock"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12751"/>9.5.1.1. Real Time Clock</h4></div></div></div><p>By default, Drools uses a real time clock implementation that
    internally uses the system clock to determine the current
    timestamp.</p><p>To explicitly configure the engine to use the real time clock, just
    set the session configuration parameter to real time:</p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
</code></pre></div><div class="section" title="9.5.1.2. Pseudo Clock"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12760"/>9.5.1.2. Pseudo Clock</h4></div></div></div><p>Drools also offers out of the box an implementation of a clock that
    is controlled by the application that is called Pseudo Clock. This clock
    is specially useful for unit testing temporal rules since it can be
    controlled by the application and so the results become
    deterministic.</p><p>To configure the pseudo session clock, do:</p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );</code></pre><p>As an example of how to control the pseudo session clock:</p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( ClockTypeOption.get( "pseudo" ) );
KieSession session = kbase.newKieSession( conf, null );
        
SessionPseudoClock clock = session.getSessionClock();

// then, while inserting facts, advance the clock as necessary:
FactHandle handle1 = session.insert( tick1 );
clock.advanceTime( 10, TimeUnit.SECONDS );
FactHandle handle2 = session.insert( tick2 );
clock.advanceTime( 30, TimeUnit.SECONDS );
FactHandle handle3 = session.insert( tick3 );

</code></pre></div></div></div><div class="section" title="9.6. Sliding Windows"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12773"/>9.6. Sliding Windows</h2></div></div></div><p>Sliding Windows are a way to scope the events of interest by defining
  a window that is constantly moving. The two most common types of sliding
  window implementations are time based windows and length based
  windows.</p><p>The next sections will detail each of them.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Sliding Windows are only available when running the engine in STREAM
    mode. Check the Event Processing Mode section for details on how the
    STREAM mode works.</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Sliding windows start to match immediately and defining a sliding
    window does not imply that the rule has to wait for the sliding window to
    be "full" in order to match. For instance, a rule that calculates the
    average of an event property on a window:length(10) will start calculating
    the average immediately, and it will start at 0 (zero) for no-events, and
    will update the average as events arrive one by one.</p></div><div class="section" title="9.6.1. Sliding Time Windows"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12786"/>9.6.1. Sliding Time Windows</h3></div></div></div><p>Sliding Time Windows allow the user to write rules that will only
  match events occurring in the last X time units.</p><p>For instance, if the user wants to consider only the Stock Ticks that
  happened in the last 2 minutes, the pattern would look like this:</p><pre><code class="no-highlight">StockTick() over window:time( 2m )</code></pre><p>Drools uses the "over" keyword to associate windows to
  patterns.</p><p>On a more elaborate example, if the user wants to sound an alarm in
  case the average temperature over the last 10 minutes read from a sensor is
  above the threshold value, the rule would look like:</p><div class="example"><a id="d0e12799"/><p class="title"><strong>Example 9.5. aggregating values over time windows</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:time( 10m ),
        average( $temp ) )
then
    // sound the alarm
end
</code></pre></div></div><br class="example-break"/><p>The engine will automatically disregard any SensorReading older than
  10 minutes and keep the calculated average consistent.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Please note that time based windows are considered when calculating
    the interval an event remains in the working memory before being expired,
    but an event falling off a sliding window does not mean by itself that the
    event will be discarded from the working memory, as there might be other
    rules that depend on that event. The engine will discard events only when
    no other rules depend on that event and the expiration policy for that
    event type is fulfilled. </p></div></div><div class="section" title="9.6.2. Sliding Length Windows"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12809"/>9.6.2. Sliding Length Windows</h3></div></div></div><p>Sliding Length Windows work the same way as Time Windows, but consider
  events based on order of their insertion into the session instead of flow of
  time.</p><p>For instance, if the user wants to consider only the last 10 RHT Stock
  Ticks, independent of how old they are, the pattern would look like
  this:</p><pre><code class="no-highlight">StockTick( company == "RHT" ) over window:length( 10 )</code></pre><p>As you can see, the pattern is similar to the one presented in the
  previous section, but instead of using window:time to define the sliding
  window, it uses window:length.</p><p>Using a similar example to the one in the previous section, if the
  user wants to sound an alarm in case the average temperature over the last
  100 readings from a sensor is above the threshold value, the rule would look
  like:</p><div class="example"><a id="d0e12822"/><p class="title"><strong>Example 9.6. aggregating values over length windows</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:length( 100 ),
        average( $temp ) )
then
    // sound the alarm
end</code></pre></div></div><br class="example-break"/><p>The engine will keep only consider the last 100 readings to calculate
  the average temperature.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Please note that falling off a length based window is not criteria
    for event expiration in the session. The engine disregards events that
    fall off a window when calculating that window, but does not remove the
    event from the session based on that condition alone as there might be
    other rules that depend on that event.</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Please note that length based windows do not define temporal
    constraints for event expiration from the session, and the engine will not
    consider them. If events have no other rules defining temporal constraints
    and no explicit expiration policy, the engine will keep them in the
    session indefinitely. </p></div><p>When using a sliding window, alpha constraints are evaluated before
  the window is considered, but beta (join) constraints are evaluated afterwards.
  This usually doesn't make a difference when time windows are concerned, but
  it's important when using a length window. For example this pattern:</p><pre><code class="no-highlight">StockTick( company == "RHT" ) over window:length( 10 )</code></pre><p>defines a window of (at most) 10 StockTicks all having company equal to "RHT",
  while the following one:</p><pre><code class="no-highlight">$s : String()
StockTick( company == $s ) over window:length( 10 )</code></pre><p>first creates a window of (at most) 10 StockTicks regardless of the value of
  their company attribute and then filters among them only the ones having the company
  equal to the String selected from the working memory.</p></div><div class="section" title="9.6.3. Window Declaration"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12845"/>9.6.3. Window Declaration</h3></div></div></div><p>The engine also supports the declaration of Windows. This promotes a clear
  separation between what are the filters applied to the window and what are the
  constraints applied to the result of window. It also allows easy reuse of windows
  among multiple rules.</p><p>Another benefit is a new implementation of the basic window support in the
  engine, increasing the overall performance of the rules that use sliding windows.</p><p>The simplified EBNF to declare a window is:</p><pre><code class="no-highlight">windowDeclaration := DECLARE WINDOW ID annotation* lhsPatternBind END</code></pre><p>For example a window containing only the last 10 stock ticks from a given source
  can be defined like:</p><pre><code class="no-highlight">declare window Ticks
    StockTick( source == "NYSE" )
        over window:length( 10 )
        from entry-point STStream
end</code></pre><p>Rules can then use this declared window by using it as a source for a FROM as in:</p><pre><code class="no-highlight">rule "RHT ticks in the window"
    when
        accumulate( StockTick( company == "RHT" ) from window Ticks,
                    $cnt : count(1) )
    then
        // there has been $cnt RHT ticks over the last 10 ticks
end</code></pre><p>Note that this example also demonstrates how the window declaration allows
  to separate the constraints applied to the window (only the StockTicks having
  "NYSE" as source are among the 10 events included into window) and the constraints
  applied to the window result (among the last 10 events having "NYSE" as source
  only the ones with company equal to "RHT" are selected).</p></div></div><div class="section" title="9.7. Streams Support"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12866"/>9.7. Streams Support</h2></div></div></div><p>Most CEP use cases have to deal with streams of events. The streams
  can be provided to the application in various forms, from JMS queues to flat
  text files, from database tables to raw sockets or even through web service
  calls. In any case, the streams share a common set of
  characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>events in the stream are ordered by a timestamp. The timestamp may
      have different semantics for different streams but they are always
      ordered internally.</p></li><li class="listitem"><p>volumes of events are usually high.</p></li><li class="listitem"><p>atomic events are rarely useful by themselves. Usually meaning is
      extracted from the correlation between multiple events from the stream
      and also from other sources.</p></li><li class="listitem"><p>streams may be homogeneous, i.e. contain a single type of events,
      or heterogeneous, i.e. contain multiple types of events.</p></li></ul></div><p>Drools generalized the concept of a stream as an "entry point" into
  the engine. An entry point is for drools a gate from which facts come. The
  facts may be regular facts or special facts like events.</p><p>In Drools, facts from one entry point (stream) may join with facts
  from any other entry point or event with facts from the working memory.
  Although, they never mix, i.e., they never lose the reference to the entry
  point through which they entered the engine. This is important because one
  may have the same type of facts coming into the engine through several entry
  points, but one fact that is inserted into the engine through entry point A
  will never match a pattern from a entry point B, for example.</p><div class="section" title="9.7.1. Declaring and Using Entry Points"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12888"/>9.7.1. Declaring and Using Entry Points</h3></div></div></div><p>Entry points are declared implicitly in Drools by directly making use
  of them in rules. I.e. referencing an entry point in a rule will make the
  engine, at compile time, to identify and create the proper internal
  structures to support that entry point. </p><p>So, for instance, lets imagine a banking application, where
  transactions are fed into the system coming from streams. One of the streams
  contains all the transactions executed in ATM machines. So, if one of the
  rules says: a withdraw is authorized if and only if the account balance is
  over the requested withdraw amount, the rule would look like:</p><div class="example"><a id="d0e12895"/><p class="title"><strong>Example 9.7. Example of Stream Usage</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "authorize withdraw"
when
    WithdrawRequest( $ai : accountId, $am : amount ) from entry-point "ATM Stream"
    CheckingAccount( accountId == $ai, balance &gt; $am )
then
    // authorize withdraw
end
</code></pre></div></div><br class="example-break"/><p>In the previous example, the engine compiler will identify that
  the pattern is tied to the entry point "ATM Stream" and will both create all
  the necessary structures for the rulebase to support the "ATM Stream" and
  will only match WithdrawRequests coming from the "ATM Stream". In the
  previous example, the rule is also joining the event from the stream with a
  fact from the main working memory (CheckingAccount).</p><p>Now, lets imagine a second rule that states that a fee of $2 must be
  applied to any account for which a withdraw request is placed at a bank
  branch:</p><div class="example"><a id="d0e12904"/><p class="title"><strong>Example 9.8. Using a different Stream</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "apply fee on withdraws on branches"
when
    WithdrawRequest( $ai : accountId, processed == true ) from entry-point "Branch Stream"
    CheckingAccount( accountId == $ai )
then
    // apply a $2 fee on the account
end
</code></pre></div></div><br class="example-break"/><p>The previous rule will match events of the exact same type as
  the first rule (WithdrawRequest), but from two different streams, so an
  event inserted into "ATM Stream" will never be evaluated against the pattern
  on the second rule, because the rule states that it is only interested in
  patterns coming from the "Branch Stream".</p><p>So, entry points, besides being a proper abstraction for streams, are
  also a way to scope facts in the working memory, and a valuable tool for
  reducing cross products explosions. But that is a subject for another
  time.</p><p>Inserting events into an entry point is equally simple. Instead of
  inserting events directly into the working memory, insert them into the
  entry point as shown in the example below:</p><div class="example"><a id="d0e12915"/><p class="title"><strong>Example 9.9. Inserting facts into an entry point</strong></p><div class="example-contents"><pre><code class="language-java">// create your rulebase and your session as usual
KieSession session = ...

// get a reference to the entry point
EntryPoint atmStream = session.getEntryPoint( "ATM Stream" );

// and start inserting your facts into the entry point
atmStream.insert( aWithdrawRequest );
</code></pre></div></div><br class="example-break"/><p>The previous example shows how to manually insert facts into a given
  entry point. Although, usually, the application will use one of the many
  adapters to plug a stream end point, like a JMS queue, directly into the
  engine entry point, without coding the inserts manually. The Drools pipeline
  API has several adapters and helpers to do that as well as examples on how
  to do it.</p></div></div><div class="section" title="9.8. Memory Management for Events"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12922"/>9.8. Memory Management for Events</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>The automatic memory management for events is only performed when
    running the engine in STREAM mode. Check the Event Processing Mode section
    for details on how the STREAM mode works.</p></div><p>One of the benefits of running the engine in STREAM mode is that the
  engine can detect when an event can no longer match any rule due to its
  temporal constraints. When that happens, the engine can safely delete the
  event from the session without side effects and release any resources used
  by that event.</p><p>There are basically 2 ways for the engine to calculate the matching
  window for a given event:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>explicitly, using the expiration policy</p></li><li class="listitem"><p>implicitly, analyzing the temporal constraints on events</p></li></ul></div><p/><div class="section" title="9.8.1. Explicit expiration offset"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12940"/>9.8.1. Explicit expiration offset</h3></div></div></div><p>The first way of allowing the engine to calculate the window of
  interest for a given event type is by explicitly setting it. To do that,
  just use the declare statement and define an expiration for the fact
  type:</p><div class="example"><a id="d0e12945"/><p class="title"><strong>Example 9.10. explicitly defining an expiration offset of 30 minutes for
      StockTick events</strong></p><div class="example-contents"><pre><code class="no-highlight">declare StockTick
    @expires( 30m )
end
</code></pre></div></div><br class="example-break"/><p>The above example declares an expiration offset of 30 minutes
  for StockTick events. After that time, assuming no rule still needs the
  event, the engine will expire and remove the event from the session
  automatically.</p><p>
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>An explicit expiration policy for a given event type overrides any inferred expiration offset
      for that same type.</p></div><p>
  </p></div><div class="section" title="9.8.2. Inferred expiration offset"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12958"/>9.8.2. Inferred expiration offset</h3></div></div></div><p>Another way for the engine to calculate the expiration offset for a
  given event is implicitly, by analyzing the temporal constraints in the
  rules. For instance, given the following rule:</p><div class="example"><a id="d0e12963"/><p class="title"><strong>Example 9.11. example rule with temporal constraints</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "correlate orders"
when
    $bo : BuyOrderEvent( $id : id ) 
    $ae : AckEvent( id == $id, this after[0,10s] $bo )
then
    // do something
end
</code></pre></div></div><br class="example-break"/><p>Analyzing the above rule, the engine automatically calculates
  that whenever a BuyOrderEvent matches, it needs to store it for up to 10
  seconds to wait for matching AckEvent's. So, the implicit expiration offset
  for BuyOrderEvent will be 10 seconds. AckEvent, on the other hand, can only
  match existing BuyOrderEvent's, and so its expiration offset will be zero
  seconds.</p><p>The engine will make this analysis for the whole rulebase and find the offset for every
        event type. </p><p>
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>An explicit expiration policy for a given event type overrides any inferred expiration offset
                for that same type.</p></div><p>
    </p></div></div><div class="section" title="9.9. Temporal Reasoning"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12978"/>9.9. Temporal Reasoning</h2></div></div></div><p>Temporal reasoning is another requirement of any CEP system. As
  discussed previously, one of the distinguishing characteristics of events is
  their strong temporal relationships.</p><p>Temporal reasoning is an extensive field of research, from its roots
  on Temporal Modal Logic to its more practical applications in business
  systems. There are hundreds of papers and thesis written and approaches are
  described for several applications. Drools once more takes a pragmatic and
  simple approach based on several sources, but specially worth noting the
  following papers:</p><div class="bibliolist"><div class="biblioentry" title="An Interval-based Representation of Temporal Knowledge"><a id="d0e12987"/><p>[<abbr class="abbrev">ALLEN81</abbr>] <span class="author">Allen, J.F.. </span><span class="title"><em>An Interval-based Representation of Temporal Knowledge</em>. </span><span class="pubdate">1981. </span></p></div><div class="biblioentry" title="Maintaining knowledge about temporal intervals"><a id="d0e12998"/><p>[<abbr class="abbrev">ALLEN83</abbr>] <span class="author">Allen, J.F.. </span><span class="title"><em>Maintaining knowledge about temporal intervals</em>. </span><span class="pubdate">1983. </span></p></div><div class="biblioentry" title="A Unifying Semantics for Time and Events"><a id="d0e13009"/><p>[<abbr class="abbrev">BENNE00</abbr>] <span class="authorgroup">Bennet, Brandon and Galton, Antony P.. </span><span class="title"><em>A Unifying Semantics for Time and Events</em>. </span><span class="pubdate">2005. </span></p></div><div class="biblioentry" title="Unified Semantics for Event Correlation Over Time and Space in Hybrid Network Environments"><a id="d0e13024"/><p>[<abbr class="abbrev">YONEK05</abbr>] <span class="authorgroup">Yoneki, Eiko and Bacon, Jean. </span><span class="title"><em>Unified Semantics for Event Correlation Over Time and Space in
      Hybrid Network Environments</em>. </span><span class="pubdate">2005. </span></p></div></div><p>Drools implements the Interval-based Time Event Semantics described by
  Allen, and represents Point-in-Time Events as Interval-based evens with
  duration 0 (zero).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For all temporal operator intervals, the "*" (star) symbol is used
    to indicate <span class="emphasis"><em>positive infinity</em></span> and the "-*" (minus
    star) is used to indicate <span class="emphasis"><em>negative infinity</em></span>.</p></div><div class="section" title="9.9.1. Temporal Operators"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13050"/>9.9.1. Temporal Operators</h3></div></div></div><p>Drools implements all 13 operators defined by Allen and also their
  logical complement (negation). This section details each of the operators
  and their parameters.</p><div class="section" title="9.9.1.1. After"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13055"/>9.9.1.1. After</h4></div></div></div><p>The after evaluator correlates two events and matches when the
    temporal distance from the current event to the event being correlated
    belongs to the distance range declared for the operator.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this after[ 3m30s, 4m ] $eventB ) </code></pre><p>The previous pattern will match if and only if the temporal distance
    between the time when $eventB finished and the time when $eventA started
    is between ( 3 minutes and 30 seconds ) and ( 4 minutes ). In other
    words:</p><pre><code class="no-highlight"> 3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m </code></pre><p>The temporal distance interval for the after operator is
    optional:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined (like in the example below), the
        interval starts on the first value and finishes on the second.</p></li><li class="listitem"><p>If only one value is defined, the interval starts on the value
        and finishes on the positive infinity.</p></li><li class="listitem"><p>If no value is defined, it is assumed that the initial value is
        1ms and the final value is the positive infinity.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It is possible to define negative distances for this operator.
      Example:</p><pre><code class="no-highlight">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) </code></pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If the first value is greater than the second value, the engine
      automatically reverses them, as there is no reason to have the first
      value greater than the second value. Example: the following two patterns
      are considered to have the same semantics:</p><pre><code class="no-highlight">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this after[ -2m, -3m30s ] $eventB ) </code></pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The <span class="emphasis"><em>after</em></span>, <span class="emphasis"><em>before</em></span> and
      <span class="emphasis"><em>coincides</em></span> operators can be used to define
      constraints between events, java.util.Date attributes, and long
      attributes (interpreted as timestamps since epoch) in any combination.
      Example:</p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.2. Before"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13104"/>9.9.1.2. Before</h4></div></div></div><p>The before evaluator correlates two events and matches when the
    temporal distance from the event being correlated to the current
    correlated belongs to the distance range declared for the operator.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this before[ 3m30s, 4m ] $eventB ) </code></pre><p>The previous pattern will match if and only if the temporal distance
    between the time when $eventA finished and the time when $eventB started
    is between ( 3 minutes and 30 seconds ) and ( 4 minutes ). In other
    words:</p><pre><code class="no-highlight"> 3m30s &lt;= $eventB.startTimestamp - $eventA.endTimeStamp &lt;= 4m </code></pre><p>The temporal distance interval for the before operator is
    optional:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined (like in the example below), the
        interval starts on the first value and finishes on the second.</p></li><li class="listitem"><p>If only one value is defined, then the interval starts on the
        value and finishes on the positive infinity.</p></li><li class="listitem"><p>If no value is defined, it is assumed that the initial value is
        1ms and the final value is the positive infinity.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It is possible to define negative distances for this operator.
      Example:</p><pre><code class="no-highlight">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) </code></pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If the first value is greater than the second value, the engine
      automatically reverses them, as there is no reason to have the first
      value greater than the second value. Example: the following two patterns
      are considered to have the same semantics:</p><pre><code class="no-highlight">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this before[ -2m, -3m30s ] $eventB ) </code></pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The <span class="emphasis"><em>after</em></span>, <span class="emphasis"><em>before</em></span> and
      <span class="emphasis"><em>coincides</em></span> operators can be used to define
      constraints between events, java.util.Date attributes, and long
      attributes (interpreted as timestamps since epoch) in any combination.
      Example:</p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.3. Coincides"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13153"/>9.9.1.3. Coincides</h4></div></div></div><p>The coincides evaluator correlates two events and matches when both
    happen at the same time. Optionally, the evaluator accept thresholds for
    the distance between events' start and finish timestamps.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this coincides $eventB ) </code></pre><p>The previous pattern will match if and only if the start timestamps
    of both $eventA and $eventB are the same AND the end timestamp of both
    $eventA and $eventB also are the same.</p><p>Optionally, this operator accepts one or two parameters. These
    parameters are the thresholds for the distance between matching
    timestamps.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If only one parameter is given, it is used for both start and
        end timestamps.</p></li><li class="listitem"><p>If two parameters are given, then the first is used as a
        threshold for the start timestamp and the second one is used as a
        threshold for the end timestamp.</p></li></ul></div><p>In other words:</p><pre><code class="no-highlight">$eventA : EventA( this coincides[15s, 10s] $eventB ) </code></pre><p>Above pattern will match if and only if:</p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 15s &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 10s </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use negative interval values for the
      parameters and the engine will raise an error if that happens.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The <span class="emphasis"><em>after</em></span>, <span class="emphasis"><em>before</em></span> and
      <span class="emphasis"><em>coincides</em></span> operators can be used to define
      constraints between events, java.util.Date attributes, and long
      attributes (interpreted as timestamps since epoch) in any combination.
      Example:</p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.4. During"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13198"/>9.9.1.4. During</h4></div></div></div><p>The during evaluator correlates two events and matches when the
    current event happens during the occurrence of the event being
    correlated.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this during $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA starts
    after $eventB starts and finishes before $eventB finishes.</p><p>In other words:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt;= $eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p>The during operator accepts 1, 2 or 4 optional parameters as
    follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If one value is defined, this will be the maximum distance
        between the start timestamp of both event and the maximum distance
        between the end timestamp of both events in order to operator match.
        Example:</p><pre><code class="no-highlight">$eventA : EventA( this during[ 5s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">0 &lt; $eventA.startTimestamp - $eventB.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventB.endTimestamp - $eventA.endTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined, the first value will be the minimum
        distance between the timestamps of both events, while the second value
        will be the maximum distance between the timestamps of both events.
        Example:</p><pre><code class="no-highlight">$eventA : EventA( this during[ 5s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">5s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If four values are defined, the first two values will be the
        minimum and maximum distances between the start timestamp of both
        events, while the last two values will be the minimum and maximum
        distances between the end timestamp of both events. Example:</p><pre><code class="no-highlight">$eventA : EventA( this during[ 2s, 6s, 4s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">2s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</code></pre></li></ul></div></div><div class="section" title="9.9.1.5. Finishes"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13245"/>9.9.1.5. Finishes</h4></div></div></div><p>The finishes evaluator correlates two events and matches when the
    current event's start timestamp happens after the correlated event's start
    timestamp, but both end timestamps occur at the same time.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this finishes $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA starts
    after $eventB starts and finishes at the same time $eventB
    finishes.</p><p>In other words:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </code></pre><p>The finishes evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    both events in order for the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this finishes[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" title="9.9.1.6. Finished By"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13271"/>9.9.1.6. Finished By</h4></div></div></div><p>The finishedby evaluator correlates two events and matches when the
    current event start timestamp happens before the correlated event start
    timestamp, but both end timestamps occur at the same time. This is the
    symmetrical opposite of finishes evaluator.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this finishedby $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA starts
    before $eventB starts and finishes at the same time $eventB
    finishes.</p><p>In other words:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </code></pre><p>The finishedby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    both events in order for the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this finishedby[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" title="9.9.1.7. Includes"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13297"/>9.9.1.7. Includes</h4></div></div></div><p>The includes evaluator correlates two events and matches when the
    event being correlated happens during the current event. It is the
    symmetrical opposite of during evaluator.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this includes $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventB starts
    after $eventA starts and finishes before $eventA finishes.</p><p>In other words:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt;= $eventB.endTimestamp &lt; $eventA.endTimestamp </code></pre><p>The includes operator accepts 1, 2 or 4 optional parameters as
    follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If one value is defined, this will be the maximum distance
        between the start timestamp of both event and the maximum distance
        between the end timestamp of both events in order to operator match.
        Example:</p><pre><code class="no-highlight">$eventA : EventA( this includes[ 5s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">0 &lt; $eventB.startTimestamp - $eventA.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventA.endTimestamp - $eventB.endTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined, the first value will be the minimum
        distance between the timestamps of both events, while the second value
        will be the maximum distance between the timestamps of both events.
        Example:</p><pre><code class="no-highlight">$eventA : EventA( this includes[ 5s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">5s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If four values are defined, the first two values will be the
        minimum and maximum distances between the start timestamp of both
        events, while the last two values will be the minimum and maximum
        distances between the end timestamp of both events. Example:</p><pre><code class="no-highlight">$eventA : EventA( this includes[ 2s, 6s, 4s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">2s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s </code></pre></li></ul></div></div><div class="section" title="9.9.1.8. Meets"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13344"/>9.9.1.8. Meets</h4></div></div></div><p>The meets evaluator correlates two events and matches when the
    current event's end timestamp happens at the same time as the correlated
    event's start timestamp.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this meets $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA finishes
    at the same time $eventB starts.</p><p>In other words:</p><pre><code class="no-highlight">abs( $eventB.startTimestamp - $eventA.endTimestamp ) == 0 </code></pre><p>The meets evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    current event and the start timestamp of the correlated event in order for
    the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this meets[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">abs( $eventB.startTimestamp - $eventA.endTimestamp) &lt;= 5s </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" title="9.9.1.9. Met By"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13370"/>9.9.1.9. Met By</h4></div></div></div><p>The metby evaluator correlates two events and matches when the
    current event's start timestamp happens at the same time as the correlated
    event's end timestamp.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this metby $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA starts at
    the same time $eventB finishes.</p><p>In other words:</p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.endTimestamp ) == 0 </code></pre><p>The metby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    the correlated event and the start timestamp of the current event in order
    for the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this metby[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.endTimestamp) &lt;= 5s </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" title="9.9.1.10. Overlaps"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13396"/>9.9.1.10. Overlaps</h4></div></div></div><p>The overlaps evaluator correlates two events and matches when the
    current event starts before the correlated event starts and finishes after
    the correlated event starts, but before the correlated event finishes. In
    other words, both events have an overlapping period.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this overlaps $eventB ) </code></pre><p>The previous pattern will match if and only if:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p>The overlaps operator accepts 1 or 2 optional parameters as
    follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If one parameter is defined, this will be the maximum distance
        between the start timestamp of the correlated event and the end
        timestamp of the current event. Example:</p><pre><code class="no-highlight">$eventA : EventA( this overlaps[ 5s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
0 &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined, the first value will be the minimum
        distance and the second value will be the maximum distance between the
        start timestamp of the correlated event and the end timestamp of the
        current event. Example:</p><pre><code class="no-highlight">$eventA : EventA( this overlaps[ 5s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 10s </code></pre></li></ul></div></div><div class="section" title="9.9.1.11. Overlapped By"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13431"/>9.9.1.11. Overlapped By</h4></div></div></div><p>The overlappedby evaluator correlates two events and matches when
    the correlated event starts before the current event starts and finishes
    after the current event starts, but before the current event finishes. In
    other words, both events have an overlapping period.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this overlappedby $eventB ) </code></pre><p>The previous pattern will match if and only if:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp </code></pre><p>The overlappedby operator accepts 1 or 2 optional parameters as
    follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If one parameter is defined, this will be the maximum distance
        between the start timestamp of the current event and the end timestamp
        of the correlated event. Example:</p><pre><code class="no-highlight">$eventA : EventA( this overlappedby[ 5s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
0 &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If two values are defined, the first value will be the minimum
        distance and the second value will be the maximum distance between the
        start timestamp of the current event and the end timestamp of the
        correlated event. Example:</p><pre><code class="no-highlight">$eventA : EventA( this overlappedby[ 5s, 10s ] $eventB )</code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 10s</code></pre></li></ul></div><p/></div><div class="section" title="9.9.1.12. Starts"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13467"/>9.9.1.12. Starts</h4></div></div></div><p>The starts evaluator correlates two events and matches when the
    current event's end timestamp happens before the correlated event's end
    timestamp, but both start timestamps occur at the same time.</p><p>Lets look at an example:</p><pre><code class="no-highlight">$eventA : EventA( this starts $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventA finishes
    before $eventB finishes and starts at the same time $eventB starts.</p><p>In other words:</p><pre><code class="no-highlight">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p>The starts evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the start timestamp of
    both events in order for the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this starts[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" title="9.9.1.13. Started By"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13493"/>9.9.1.13. Started By</h4></div></div></div><p>The startedby evaluator correlates two events and matches when the
    correlating event's end timestamp happens before the current event's end
    timestamp, but both start timestamps occur at the same time. Lets look at
    an example:</p><pre><code class="no-highlight">$eventA : EventA( this startedby $eventB ) </code></pre><p>The previous pattern will match if and only if the $eventB finishes
    before $eventA finishes and starts at the same time $eventB starts.</p><p>In other words:</p><pre><code class="no-highlight">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </code></pre><p>The startedby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the start timestamp of
    both events in order for the operator to match. Example:</p><pre><code class="no-highlight">$eventA : EventA( this starts[ 5s ] $eventB ) </code></pre><p>Will match if and only if:</p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch08.html"><strong>Prev</strong>Chapter 8. Rule Language Reference</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch10.html"><strong>Next</strong>Chapter 10. Experimental Features</a></li></ul></body></html>