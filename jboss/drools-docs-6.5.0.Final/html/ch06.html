<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. User Guide</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Drools Documentation"/><link rel="up" href="pt03.html" title="Part III. Drools Runtime and Language"/><link rel="prev" href="ch05.html" title="Chapter 5. Hybrid Reasoning"/><link rel="next" href="ch07.html" title="Chapter 7. Running"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch05.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch07.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 6. User Guide"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4870"/>Chapter 6. User Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch06.html#d0e4873">6.1. The Basics</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#d0e4876">6.1.1. Stateless Knowledge Session</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5038">6.1.2. Stateful Knowledge Session</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5213">6.1.3. Methods versus Rules</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5245">6.1.4. Cross Products</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#d0e5270">6.2. Execution Control</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#d0e5273">6.2.1. Agenda</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5306">6.2.2. Rule Matches and Conflict Sets.</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#d0e5518">6.3. Inference</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#d0e5521">6.3.1. Bus Pass Example</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#d0e5589">6.4. Truth Maintenance with  Logical Objects</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#d0e5596">6.4.1. Overview</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#d0e5713">6.5. Decision Tables in Spreadsheets</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#d0e5725">6.5.1. When to Use Decision Tables</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5743">6.5.2. Overview</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5785">6.5.3. How Decision Tables Work</a></span></dt><dt><span class="section"><a href="ch06.html#d0e5871">6.5.4. Spreadsheet Syntax</a></span></dt><dt><span class="section"><a href="ch06.html#d0e6396">6.5.5. Creating and integrating Spreadsheet based Decision Tables</a></span></dt><dt><span class="section"><a href="ch06.html#d0e6417">6.5.6. Managing Business Rules in Decision Tables</a></span></dt><dt><span class="section"><a href="ch06.html#d0e6464">6.5.7. Rule Templates</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#d0e6567">6.6. Logging</a></span></dt></dl></div><div class="section" title="6.1. The Basics"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4873"/>6.1. The Basics</h2></div></div></div><div class="section" title="6.1.1. Stateless Knowledge Session"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4876"/>6.1.1. Stateless Knowledge Session</h3></div></div></div><p>So where do we get started? There are so many use cases and so much functionality in a rule engine such as
      Drools that it becomes beguiling. Have no fear my intrepid adventurer, the complexity is layered and you can ease
      yourself in with simple use cases.</p><p>Stateless session, not utilising inference, forms the simplest use
    case. A stateless session can be called like a function passing it some
    data and then receiving some results back. Some common use cases for
    stateless sessions are, but not limited to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Validation</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Is this person eligible for a mortgage?</p></li></ul></div></li><li class="listitem"><p>Calculation</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Compute a mortgage premium.</p></li></ul></div></li><li class="listitem"><p>Routing and Filtering</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Filter incoming messages, such as emails, into
            folders.</p></li><li class="listitem"><p>Send incoming messages to a destination.</p></li></ul></div></li></ul></div><p>So let's start with a very simple example using a driving license
    application.</p><pre><code class="language-java">public class Applicant {
    private String name;
    private int age;
    private boolean valid;
    // getter and setter methods here
}
</code></pre><p>Now that we have our data model we can write our first rule. We
    assume that the application uses rules to reject invalid applications. As
    this is a simple validation use case we will add a single rule to
    disqualify any applicant younger than 18.</p><pre><code class="no-highlight">package com.company.license

rule "Is of valid age"
when
    $a : Applicant( age &lt; 18 )
then
    $a.setValid( false );
end</code></pre><p>To make the engine aware of data, so it can be processed against the
    rules, we have to <span class="emphasis"><em>insert</em></span> the data, much like with a
    database. When the Applicant instance is inserted into the engine it is
    evaluated against the constraints of the rules, in this case just two
    constraints for one rule. We say <span class="emphasis"><em>two</em></span> because the type
    Applicant is the first object type constraint, and <code class="code">age &lt;
    18</code> is the second field constraint. An object type constraint plus
    its zero or more field constraints is referred to as a pattern. When an
    inserted instance satisfies both the object type constraint and all the
    field constraints, it is said to be matched. The <code class="code">$a</code> is a
    binding variable which permits us to reference the matched object in the
    consequence. There its properties can be updated. The dollar character
    ('$') is optional, but it helps to differentiate variable names from field
    names. The process of matching patterns against the inserted data is, not
    surprisingly, often referred to as <span class="emphasis"><em>pattern matching</em></span>.</p><p>To use this rule it is necessary to put it a Drools file, just a plain
    text file with .drl extension , short for "Drools Rule Language". Let's call
    this file licenseApplication.drl, and store it in a Kie Project. A Kie Project
    has the structure of a normal Maven project with an additional file (kmodule.xml)
    defining the <code class="code">KieBase</code>s and <code class="code">KieSession</code>s that can be created.
    This file has to be placed in the resources/META-INF folder of the Maven project
    while all the other Drools artifacts, such as the licenseApplication.drl
    containing the former rule, must be stored in the resources folder or in any
    other subfolder under it.</p><p>Since meaningful defaults have been provided for all configuration aspects, the simplest
    kmodule.xml file can contain just an empty kmodule tag like the following:</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"/&gt;</code></pre><p>At this point it is possible to create a <code class="code">KieContainer</code> that reads
    the files to be built, from the classpath.</p><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();</code></pre><p>The above code snippet compiles all the DRL files found on the classpath
    and put the result of this compilation, a <code class="code">KieModule</code>, in the <code class="code">KieContainer</code>.
    If there are no errors, we are now ready to create our session from the <code class="code">KieContainer</code>
    and execute against some data:</p><pre><code class="language-java">StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
assertTrue( applicant.isValid() );
ksession.execute( applicant );
assertFalse( applicant.isValid() );
</code></pre><p>The preceding code executes the data against the rules. Since the
    applicant is under the age of 18, the application is marked as
    invalid.</p><p>So far we've only used a single instance, but what if we want to use
    more than one? We can execute against any object implementing Iterable,
    such as a collection. Let's add another class called
    <code class="code">Application</code>, which has the date of the application, and we'll
    also move the boolean valid field to the <code class="code">Application</code>
    class.</p><pre><code class="language-java">public class Applicant {
    private String name;
    private int age;
    // getter and setter methods here
}

public class Application {
    private Date dateApplied;
    private boolean valid;
    // getter and setter methods here
}</code></pre><p>We will also add another rule to validate that the application was
    made within a period of time.</p><pre><code class="no-highlight">package com.company.license

rule "Is of valid age"
when
    Applicant( age &lt; 18 )
    $a : Application()     
then
    $a.setValid( false );
end

rule "Application was made this year"
when
    $a : Application( dateApplied &gt; "01-jan-2009" )     
then
    $a.setValid( false );
end
</code></pre><p>Unfortunately a Java array does not implement the
    <code class="code">Iterable</code> interface, so we have to use the JDK converter
    method <code class="code">Arrays.asList(...)</code>. The code shown below executes
    against an iterable list, where all collection elements are inserted
    before any matched rules are fired.</p><pre><code class="language-java">StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
Application application = new Application();
assertTrue( application.isValid() );
ksession.execute( Arrays.asList( new Object[] { application, applicant } ) );
assertFalse( application.isValid() );
</code></pre><p>The two execute methods <code class="code">execute(Object object)</code> and
    <code class="code">execute(Iterable objects)</code> are actually convenience methods
    for the interface <code class="code">BatchExecutor</code>'s method
    <code class="code">execute(Command command)</code>.</p><p>The <code class="code">KieCommands</code> commands factory, obtainable from the <code class="code">KieServices</code>
    like all other factories of the KIE API, is used to create commands, so that
    the following is equivalent to <code class="code">execute(Iterable it)</code>:</p><pre><code class="language-java">ksession.execute( kieServices.getCommands().newInsertElements( Arrays.asList( new Object[] { application, applicant } ) );
</code></pre><p>Batch Executor and Command Factory are particularly useful when
    working with multiple Commands and with output identifiers for obtaining
    results.</p><pre><code class="language-java">KieCommands kieCommands = kieServices.getCommands();
List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();
cmds.add( kieCommands.newInsert( new Person( "Mr John Smith" ), "mrSmith", true, null ) );
cmds.add( kieCommands.newInsert( new Person( "Mr John Doe" ), "mrDoe", true, null ) );
BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) );
assertEquals( new Person( "Mr John Smith" ), results.getValue( "mrSmith" ) );
</code></pre><p><code class="code">CommandFactory</code> supports many other Commands that can be
    used in the <code class="code">BatchExecutor</code> like <code class="code">StartProcess</code>,
    <code class="code">Query</code>, and <code class="code">SetGlobal</code>.</p></div><div class="section" title="6.1.2. Stateful Knowledge Session"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5038"/>6.1.2. Stateful Knowledge Session</h3></div></div></div><p>Stateful Sessions are long lived and allow iterative changes over
    time. Some common use cases for Stateful Sessions are, but not limited
    to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Monitoring</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Stock market monitoring and analysis for semi-automatic
            buying.</p></li></ul></div></li><li class="listitem"><p>Diagnostics</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Fault finding, medical diagnostics</p></li></ul></div></li><li class="listitem"><p>Logistics</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Parcel tracking and delivery provisioning</p></li></ul></div></li><li class="listitem"><p>Compliance</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Validation of legality for market trades.</p></li></ul></div></li></ul></div><p>In contrast to a Stateless Session, the <code class="code">dispose()</code>
    method must be called afterwards to ensure there are no memory leaks, as
    the KieBase contains references to Stateful Knowledge Sessions when
    they are created. Since Stateful Knowledge Session is the most commonly used session type
    it is just named <code class="code">KieSession</code> in the KIE API. <code class="code">KieSession</code> also
    supports the <code class="code">BatchExecutor</code> interface, like
    <code class="code">StatelessKieSession</code>, the only difference being that the
    <code class="code">FireAllRules</code> command is not automatically called at the end
    for a Stateful Session.</p><p>We illustrate the monitoring use case with an example for raising a
    fire alarm. Using just four classes, we represent rooms in a house, each
    of which has one sprinkler. If a fire starts in a room, we represent that
    with a single <code class="code">Fire</code> instance.</p><pre><code class="language-java">public class Room {
    private String name
    // getter and setter methods here
}
public class Sprinkler {
    private Room room;
    private boolean on;
    // getter and setter methods here
}
public class Fire {
    private Room room;
    // getter and setter methods here
}
public class Alarm {
}
</code></pre><p>In the previous section on Stateless Sessions the concepts of
    inserting and matching against data were introduced. That example assumed
    that only a single instance of each object type was ever inserted and thus
    only used literal constraints. However, a house has many rooms, so rules
    must express relationships between objects, such as a sprinkler being in a
    certain room. This is best done by using a binding variable as a
    constraint in a pattern. This "join" process results in what is called
    cross products, which are covered in the next section.</p><p>When a fire occurs an instance of the <code class="code">Fire</code> class is
    created, for that room, and inserted into the session. The rule uses a
    binding on the <code class="code">room</code> field of the <code class="code">Fire</code> object to
    constrain matching to the sprinkler for that room, which is currently off.
    When this rule fires and the consequence is executed the sprinkler is
    turned on.</p><pre><code class="no-highlight">rule "When there is a fire turn on the sprinkler"
when
    Fire($room : room)
    $sprinkler : Sprinkler( room == $room, on == false )
then
    modify( $sprinkler ) { setOn( true ) };
    System.out.println( "Turn on the sprinkler for room " + $room.getName() );
end</code></pre><p>Whereas the Stateless Session uses standard Java syntax to modify a
    field, in the above rule we use the <code class="literal">modify</code> statement,
    which acts as a sort of "with" statement. It may contain a series of comma
    separated Java expressions, i.e., calls to setters of the object selected
    by the <code class="literal">modify</code> statement's control expression. This
    modifies the data, and makes the engine aware of those changes so it can
    reason over them once more. This process is called inference, and it's
    essential for the working of a Stateful Session. Stateless Sessions
    typically do not use inference, so the engine does not need to be aware of
    changes to data. Inference can also be turned off explicitly by using the
    <span class="emphasis"><em>sequential mode</em></span>.</p><p>So far we have rules that tell us when matching data exists, but
    what about when it does <span class="emphasis"><em>not</em></span> exist? How do we
    determine that a fire has been extinguished, i.e., that there isn't a
    <code class="code">Fire</code> object any more? Previously the constraints have been
    sentences according to Propositional Logic, where the engine is
    constraining against individual instances. Drools also has support for
    First Order Logic that allows you to look at sets of data. A pattern under
    the keyword <code class="literal">not</code> matches when something does not exist.
    The rule given below turns the sprinkler off as soon as the fire in that
    room has disappeared.</p><pre><code class="no-highlight">rule "When the fire is gone turn off the sprinkler"
when
    $room : Room( )
    $sprinkler : Sprinkler( room == $room, on == true )
    not Fire( room == $room )
then
    modify( $sprinkler ) { setOn( false ) };
    System.out.println( "Turn off the sprinkler for room " + $room.getName() );
end</code></pre><p>While there is one sprinkler per room, there is just a single alarm
    for the building. An <code class="code">Alarm</code> object is created when a fire
    occurs, but only one <code class="code">Alarm</code> is needed for the entire building,
    no matter how many fires occur. Previously <code class="literal">not</code> was
    introduced to match the absence of a fact; now we use its complement
    <code class="literal">exists</code> which matches for one or more instances of some
    category.</p><pre><code class="no-highlight">rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert( new Alarm() );
    System.out.println( "Raise the alarm" );
end</code></pre><p>Likewise, when there are no fires we want to remove the alarm, so
    the <code class="literal">not</code> keyword can be used again.</p><pre><code class="no-highlight">rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    delete( $alarm );
    System.out.println( "Cancel the alarm" );
end

</code></pre><p>Finally there is a general health status message that is printed
    when the application first starts and after the alarm is removed and all
    sprinklers have been turned off.</p><pre><code class="no-highlight">rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler( on == true ) 
then
    System.out.println( "Everything is ok" );
end</code></pre><p>As we did in the Stateless Session example, the above rules should be placed
    in a single DRL file and saved into the resouces folder of your Maven project
    or any of its subfolder. As before, we can then obtain a <code class="code">KieSession</code> from
    the <code class="code">KieContainer</code>. The only difference is that this time we
    create a Stateful Session, whereas before we created a Stateless Session.</p><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
KieSession ksession = kContainer.newKieSession();</code></pre><p>With the session created it is now possible to iteratively work with
    it over time. Four <code class="code">Room</code> objects are created and inserted, as
    well as one <code class="code">Sprinkler</code> object for each room. At this point the
    engine has done all of its matching, but no rules have fired yet. Calling
    <code class="code">ksession.fireAllRules()</code> allows the matched rules to fire, but
    without a fire that will just produce the health message.</p><pre><code class="language-java">String[] names = new String[]{"kitchen", "bedroom", "office", "livingroom"};
Map&lt;String,Room&gt; name2room = new HashMap&lt;String,Room&gt;();
for( String name: names ){
    Room room = new Room( name );
    name2room.put( name, room );
    ksession.insert( room );
    Sprinkler sprinkler = new Sprinkler( room );
    ksession.insert( sprinkler );
}

ksession.fireAllRules();
</code></pre><pre><code class="no-highlight">&gt; Everything is ok</code></pre><p>We now create two fires and insert them; this time a reference is
    kept for the returned <code class="code">FactHandle</code>. A Fact Handle is an
    internal engine reference to the inserted instance and allows instances to
    be retracted or modified at a later point in time. With the fires now in
    the engine, once <code class="code">fireAllRules()</code> is called, the alarm is
    raised and the respective sprinklers are turned on.</p><pre><code class="language-java">Fire kitchenFire = new Fire( name2room.get( "kitchen" ) );
Fire officeFire = new Fire( name2room.get( "office" ) );

FactHandle kitchenFireHandle = ksession.insert( kitchenFire );
FactHandle officeFireHandle = ksession.insert( officeFire );

ksession.fireAllRules();</code></pre><pre><code class="no-highlight">&gt; Raise the alarm
&gt; Turn on the sprinkler for room kitchen
&gt; Turn on the sprinkler for room office</code></pre><p>After a while the fires will be put out and the <code class="code">Fire</code>
    instances are retracted. This results in the sprinklers being turned off,
    the alarm being cancelled, and eventually the health message is printed
    again.</p><pre><code class="language-java">ksession.delete( kitchenFireHandle );
ksession.delete( officeFireHandle );

ksession.fireAllRules();</code></pre><pre><code class="no-highlight">&gt; Cancel the alarm
&gt; Turn off the sprinkler for room office
&gt; Turn off the sprinkler for room kitchen
&gt; Everything is ok</code></pre><p>Everyone still with me? That wasn't so hard and already I'm hoping
    you can start to see the value and power of a declarative rule
    system.</p></div><div class="section" title="6.1.3. Methods versus Rules"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5213"/>6.1.3. Methods versus Rules</h3></div></div></div><p>People often confuse methods and rules, and new rule users often ask, "How do I call a rule?" After the last
      section, you are now feeling like a rule expert and the answer to that is obvious, but let's summarize the
      differences nonetheless.</p><pre><code class="language-java">public void helloWorld(Person person) {
    if ( person.getName().equals( "Chuck" ) ) {
        System.out.println( "Hello Chuck" );
    }
}</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Methods are called directly.</p></li><li class="listitem"><p>Specific instances are passed.</p></li><li class="listitem"><p>One call results in a single execution.</p></li></ul></div><pre><code class="no-highlight">rule "Hello World" when
    Person( name == "Chuck" )
then
    System.out.println( "Hello Chuck" );
end</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Rules execute by matching against any data as long it is
        inserted into the engine.</p></li><li class="listitem"><p>Rules can never be called directly.</p></li><li class="listitem"><p>Specific instances cannot be passed to a rule.</p></li><li class="listitem"><p>Depending on the matches, a rule may fire once or several times,
        or not at all.</p></li></ul></div></div><div class="section" title="6.1.4. Cross Products"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5245"/>6.1.4. Cross Products</h3></div></div></div><p>Earlier the term "cross product" was mentioned, which is the result of a join. Imagine for a moment that the
      data from the fire alarm example were used in combination with the following rule where there are no field
      constraints:</p><pre><code class="no-highlight">rule "Show Sprinklers" when
    $room : Room()
    $sprinkler : Sprinkler()
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</code></pre><p>In SQL terms this would be like doing <code class="code">select * from Room,
    Sprinkler</code> and every row in the Room table would be joined with
    every row in the Sprinkler table resulting in the following output:</p><pre><code class="no-highlight">room:office sprinkler:office
room:office sprinkler:kitchen
room:office sprinkler:livingroom
room:office sprinkler:bedroom
room:kitchen sprinkler:office
room:kitchen sprinkler:kitchen
room:kitchen sprinkler:livingroom
room:kitchen sprinkler:bedroom
room:livingroom sprinkler:office
room:livingroom sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:livingroom sprinkler:bedroom
room:bedroom sprinkler:office
room:bedroom sprinkler:kitchen
room:bedroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</code></pre><p>These cross products can obviously become huge, and they may very
    well contain spurious data. The size of cross products is often the source
    of performance problems for new rule authors. From this it can be seen
    that it's always desirable to constrain the cross products, which is done
    with the variable constraint.</p><pre><code class="no-highlight">rule
when
    $room : Room()
    $sprinkler : Sprinkler( room == $room )
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</code></pre><p>This results in just four rows of data, with the correct Sprinkler
    for each Room. In SQL (actually HQL) the corresponding query would be
    <code class="code">select * from Room, Sprinkler where Room ==
    Sprinkler.room</code>.</p><pre><code class="no-highlight">room:office sprinkler:office
room:kitchen sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</code></pre></div></div><div class="section" title="6.2. Execution Control"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5270"/>6.2. Execution Control</h2></div></div></div><div class="section" title="6.2.1. Agenda"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5273"/>6.2.1. Agenda</h3></div></div></div><p>The Agenda is a <span class="emphasis"><em>Rete</em></span> feature. It maintains set
    of rules that are able to execute, its job is to schedule that execution
    in a deterministic order.</p><p>During actions on the <code class="code">RuleRuntime</code>, rules may become fully matched and eligible for execution; a
      single Rule Runtime Action can result in multiple eligible rules. When a rule is fully matched a Rule Match is
      created, referencing the rule and the matched facts, and placed onto the Agenda. The Agenda controls the execution
      order of these Matches using a Conflict Resolution strategy.</p><p>The engine cycles repeatedly through two phases:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Rule Runtime Actions. This is where most of the work takes place, either in the Consequence (the RHS
          itself) or the main Java application process. Once the Consequence has finished or the main Java application
          process calls <code class="code">fireAllRules()</code> the engine switches to the Agenda Evaluation phase.</p></li><li class="listitem"><p>Agenda Evaluation. This attempts to select a rule to fire. If no rule is found it exits, otherwise it
          fires the found rule, switching the phase back to Rule Runtime Actions.</p></li></ol></div><div class="figure"><a id="d0e5298"/><p class="title"><strong>Figure 6.1. Two Phase Execution</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/UserGuide/Two_Phase.png" align="middle" alt="Two Phase Execution"/></div></div></div><br class="figure-break"/><p>The process repeats until the agenda is clear, in which case control returns to the calling application. When
      Rule Runtime Actions are taking place, no rules are being fired.</p></div><div class="section" title="6.2.2. Rule Matches and Conflict Sets."><div class="titlepage"><div><div><h3 class="title"><a id="d0e5306"/>6.2.2. Rule Matches and Conflict Sets.</h3></div></div></div><div class="section" title="6.2.2.1. Cashflow Example"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5309"/>6.2.2.1. Cashflow Example</h4></div></div></div><p>So far the data and the matching process has been simple and
      small. To mix things up a bit a new example will be explored that
      handles cashflow calculations over date periods. The state of the engine
      will be illustratively shown at key stages to help get a better
      understanding of what is actually going on under the hood. Three classes
      will be used, as shown below. This will help us grow our understanding
      of pattern matching and joins further. We will then use this to
      illustrate different techniques for execution control.</p><pre><code class="language-java">public class CashFlow {
    private Date   date;
    private double amount;
    private int    type;
    long           accountNo;
    // getter and setter methods here
}

public class Account {
    private long   accountNo;
    private double balance;
    // getter and setter methods here
}

public AccountPeriod {
    private Date start;
    private Date end;
    // getter and setter methods here
}</code></pre><p>By now you already know how to create KieBases and how to instantiate facts to populate the
          <code class="code">KieSession</code>, so tables will be used to show the state of the inserted data, as it makes things
        clearer for illustration purposes. The tables below show that a single fact was inserted for the
          <code class="code">Account</code>. Also inserted are a series of debits and credits as <code class="code">CashFlow</code> objects for
        that account, extending over two quarters.</p><div class="figure"><a id="d0e5327"/><p class="title"><strong>Figure 6.2. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables1.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/><p>Two rules can be used to determine the debit and credit for that
      quarter and update the Account balance. The two rules below constrain
      the cashflows for an account for a given time period. Notice the
      "&amp;&amp;" which use short cut syntax to avoid repeating the field
      name twice.</p><table frame="void" id="d0e5335"><tbody><tr>
            <td align="left" valign="top"><pre><code class="no-highlight">rule "increase balance for credits"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre></td>

            <td align="left" valign="top"><pre><code class="no-highlight">rule "decrease balance for debits" 
when 
  ap : AccountPeriod() 
  acc : Account( $accountNo : accountNo ) 
  CashFlow( type == DEBIT, 
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end, 
            $amount : amount ) 
then 
  acc.balance -= $amount; 
end</code></pre></td>
          </tr></tbody></table><p>Earlier we showed how rules would equate to SQL, which can often
      help people with an SQL background to understand rules. The two rules
      above can be represented with two views and a trigger for each view, as
      below:</p><table border="0" id="d0e5349"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">select * from Account acc,
              Cashflow cf,
              AccountPeriod ap      
where acc.accountNo == cf.accountNo and 
      cf.type == CREDIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">select * from Account acc, 
              Cashflow cf,
              AccountPeriod ap 
where acc.accountNo == cf.accountNo and 
      cf.type == DEBIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</code></pre>
            </td>
          </tr><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">trigger : acc.balance += cf.amount</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">trigger : acc.balance -= cf.amount</code></pre>
            </td>
          </tr></tbody></table><p>If the <code class="code">AccountPeriod</code> is set to the first quarter we
      constrain the rule "increase balance for credits" to fire on two rows of
      data and "decrease balance for debits" to act on one row of data.</p><div class="figure"><a id="d0e5384"/><p class="title"><strong>Figure 6.3. AccountingPeriod, CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables2.png" alt="AccountingPeriod, CashFlows and Account"/></div></div></div><br class="figure-break"/><p>The two cashflow tables above represent the matched data for the two rules. The data is matched during the
        insertion stage and, as you discovered in the previous chapter, does not fire straight away, but only after
          <code class="code">fireAllRules()</code> is called. Meanwhile, the rule plus its matched data is placed on the Agenda and
        referred to as an RuIe Match or Rule Instance. The Agenda is a table of Rule Matches that are able to fire and
        have their consequences executed, as soon as fireAllRules() is called. Rule Matches on the Agenda are referred
        to as a <em class="firstterm">conflict set</em> and their execution is determine by a conflict resolution strategy.
        Notice that the order of execution so far is considered arbitrary.</p><div class="figure"><a id="d0e5398"/><p class="title"><strong>Figure 6.4. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables7.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/><p>After all of the above activations are fired, the account has a
      balance of -25.</p><div class="figure"><a id="d0e5406"/><p class="title"><strong>Figure 6.5. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables3.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/><p>If the <code class="code">AccountPeriod</code> is updated to the second quarter, we have just a single matched row of
        data, and thus just a single Rule Match on the Agenda.</p><p>The firing of that Activation results in a balance of 25.</p><div class="figure"><a id="d0e5419"/><p class="title"><strong>Figure 6.6. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables4.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e5425"/><p class="title"><strong>Figure 6.7. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables5.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/></div><div class="section" title="6.2.2.2. Conflict Resolution"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5431"/>6.2.2.2. Conflict Resolution</h4></div></div></div><p>What if you don't want the order of rule execution to be arbitrary? When there is one or more Rule Match on
        the Agenda they are said to be in conflict, and a conflict resolution strategy is used to determine the order of
        execution. The Drools strategy is very simple and based around a salience value, which assigns a priority to a
        rule. Each rule has a default value of 0, the higher the value the higher the priority. </p><p>As a general rule, it is a good idea not to count on rules firing
      in any particular order, and to author the rules without worrying about
      a "flow". However when a flow is needed a number of possibilities exist
      beyond salience: agenda groups, rule flow groups, activation groups and
      control/semaphore facts. </p><p>As of Drools 6.0 rule definition order in the source file is used to set priority after salience.</p></div><div class="section" title="6.2.2.3. Salience"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5440"/>6.2.2.3. Salience</h4></div></div></div><p>To illustrate Salience we add a rule to print the account balance,
      where we want this rule to be executed after all the debits and credits
      have been applied for all accounts. We achieve this by assigning a
      negative salience to this rule so that it fires after all rules with the
      default salience 0.</p><table border="0" id="d0e5445"><tbody><tr>
            <td>
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
        salience -50
    when
        ap : AccountPeriod()
        acc : Account()        
    then
        System.out.println( acc.accountNo + " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table><p>The table below depicts the resulting Agenda. The three debit and
      credit rules are shown to be in arbitrary order, while the print rule is
      ranked last, to execute afterwards.</p><div class="figure"><a id="d0e5457"/><p class="title"><strong>Figure 6.8. CashFlows and Account</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables6.png" alt="CashFlows and Account"/></div></div></div><br class="figure-break"/></div><div class="section" title="6.2.2.4. Agenda Groups"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5463"/>6.2.2.4. Agenda Groups</h4></div></div></div><p>Agenda groups allow you to place rules into groups, and to place
      those groups onto a stack. The stack has push/pop bevaviour. Calling
      "setFocus" places the group onto the stack:</p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</code></pre><p>The agenda always evaluates the top of the stack. When all the
      rules have fired for a group, it is poped from the stack and the next
      group is evaluated.</p><table border="0" id="d0e5472"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "increase balance for credits"
  agenda-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
  agenda-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table><p>First set the focus to the "report" group and then by placing the
      focus on "calculation" we ensure that group is evaluated first.</p><pre><code class="language-java">Agenda agenda = ksession.getAgenda();
agenda.getAgendaGroup( "report" ).setFocus();
agenda.getAgendaGroup( "calculation" ).setFocus();
ksession.fireAllRules();</code></pre></div><div class="section" title="6.2.2.5. Rule Flow"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5492"/>6.2.2.5. Rule Flow</h4></div></div></div><p>Drools also features ruleflow-group attributes which allows
      workflow diagrams to declaratively specify when rules are allowed to
      fire. The screenshot below is taken from Eclipse using the Drools
      plugin. It has two ruleflow-group nodes which ensures that the
      calculation rules are executed before the reporting rules.</p><div class="mediaobject"><img src="images/UserGuide/ruleflow.png"/></div><p>The use of the ruleflow-group attribute in a rule is shown
      below.</p><table border="0" id="d0e5502"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "increase balance for credits"
  ruleflow-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
  ruleflow-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table></div></div></div><div class="section" title="6.3. Inference"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5518"/>6.3. Inference</h2></div></div></div><div class="section" title="6.3.1. Bus Pass Example"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5521"/>6.3.1. Bus Pass Example</h3></div></div></div><p>Inference has a bad name these days, as something not relevant to business use cases and just too complicated
      to be useful. It is true that contrived and complicated examples occur with inference, but that should not detract
      from the fact that simple and useful ones exist too. But more than this, correct use of inference can crate more
      agile and less error prone business rules, which are easier to maintain.</p><p>So what is inference? Something is inferred when we gain knowledge
    of something from using previous knowledge. For example, given a Person
    fact with an age field and a rule that provides age policy control, we can
    infer whether a Person is an adult or a child and act on this.</p><pre><code class="no-highlight">rule "Infer Adult"
when
  $p : Person( age &gt;= 18 )
then
  insert( new IsAdult( $p ) )
end</code></pre><p>Due to the preceding rule, every Person who is 18 or over will have an
    instance of IsAdult inserted for them. This fact is special in that it is known
    as a relation. We can use this inferred relation in any rule:</p><pre><code class="no-highlight">$p : Person()
IsAdult( person == $p )</code></pre><p>So now we know what inference is, and have a basic example, how does
    this facilitate good rule design and maintenance?</p><p>Let's take a government department that are responsible for issuing
    ID cards when children become adults, henceforth referred to as ID
    department. They might have a decision table that includes logic like
    this, which says when an adult living in London is 18 or over, issue the
    card:</p><div class="mediaobject"><img src="images/UserGuide/monolithic.png"/></div><p>However the ID department does not set the policy on who an adult
    is. That's done at a central government level. If the central government
    were to change that age to 21, this would initiate a change management process.
    Someone would have to liaise with the ID department and make sure their systems
    are updated, in time for the law going live.</p><p>This change management process and communication between departments
    is not ideal for an agile environment, and change becomes costly and error
    prone. Also the card department is managing more information than it needs
    to be aware of with its "monolithic" approach to rules management which is
    "leaking" information better placed elsewhere. By this I mean that it
    doesn't care what explicit "age &gt;= 18" information determines whether
    someone is an adult, only that they are an adult.</p><p>In contrast to this, let's pursue an approach where we split (de-couple)
    the authoring responsibilities, so that both the central government and the ID
    department maintain their own rules.</p><p>It's the central government's job to determine who is an adult.
    If they change the law they just update their central repository with the
    new rules, which others use:</p><div class="mediaobject"><img src="images/UserGuide/InferIsAdult.png"/></div><p>The IsAdult fact, as discussed previously, is inferred from the
    policy rules. It encapsulates the seemingly arbitrary piece of logic "age
    &gt;= 18" and provides semantic abstractions for its meaning. Now if
    anyone uses the above rules, they no longer need to be aware of explicit
    information that determines whether someone is an adult or not. They can
    just use the inferred fact:</p><div class="mediaobject"><img src="images/UserGuide/IssueIdCard.png"/></div><p>While the example is very minimal and trivial it illustrates some
    important points. We started with a monolithic and leaky approach to our
    knowledge engineering. We created a single decision table that had all
    possible information in it and that leaks information from central government
    that the ID department did not care about and did not want to
    manage.</p><p>We first de-coupled the knowledge process so each department was
    responsible for only what it needed to know. We then encapsulated this
    leaky knowledge using an inferred fact IsAdult. The use of the term
    IsAdult also gave a semantic abstraction to the previously arbitrary logic
    "age &gt;= 18".</p><p>So a general rule of thumb when doing your knowledge engineering
    is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>Bad</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Monolithic</p></li><li class="listitem"><p>Leaky</p></li></ul></div></li><li class="listitem"><p><span class="bold"><strong>Good</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>De-couple knowledge responsibilities</p></li><li class="listitem"><p>Encapsulate knowledge</p></li><li class="listitem"><p>Provide semantic abstractions for those
            encapsulations</p></li></ul></div></li></ul></div></div></div><div class="section" title="6.4. Truth Maintenance with Logical Objects"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5589"/>6.4. Truth Maintenance with <a id="d0e5592" class="indexterm"/> Logical Objects</h2></div></div></div><div class="section" title="6.4.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5596"/>6.4.1. Overview</h3></div></div></div><p>After regular inserts you have to retract facts explicitly. With
    <span class="emphasis"><em>logical</em></span> assertions, the fact that was asserted will
    be automatically retracted when the conditions that asserted it in the
    first place are no longer true. Actually, it's even cleverer then that,
    because it will be retracted only if there isn't any single condition that
    supports the logical assertion.</p><p>Normal insertions are said to be <span class="emphasis"><em>stated</em></span>, i.e.,
    just like the intuitive meaning of "stating a fact" implies. Using a
    <code class="code">HashMap</code> and a counter, we track how many times a particular
    equality is <span class="emphasis"><em>stated</em></span>; this means we count how many
    different instances are equal.</p><p>When we <span class="emphasis"><em>logically</em></span> insert an object during a RHS
    execution we are said to <span class="emphasis"><em>justify</em></span> it, and it is
    considered to be justified by the firing rule. For each logical insertion
    there can only be one equal object, and each subsequent equal logical
    insertion increases the justification counter for this logical assertion.
    A justification is removed by the LHS of the creating rule becoming
    untrue, and the counter is decreased accordingly. As soon as we have no
    more justifications the logical object is automatically retracted.</p><p>If we try to <span class="emphasis"><em>logically</em></span> insert an object when
    there is an equal <span class="emphasis"><em>stated</em></span> object, this will fail and
    return null. If we <span class="emphasis"><em>state</em></span> an object that has an
    existing equal object that is <span class="emphasis"><em>justified</em></span> we override
    the Fact; how this override works depends on the configuration setting
    <code class="code">WM_BEHAVIOR_PRESERVE</code>. When the property is set to discard we
    use the existing handle and replace the existing instance with the new
    Object, which is the default behavior; otherwise we override it to
    <span class="emphasis"><em>stated</em></span> but we create an new
    <code class="code">FactHandle</code>.</p><p>This can be confusing on a first read, so hopefully the flow charts
    below help. When it says that it returns a new <code class="code">FactHandle</code>,
    this also indicates the <code class="code">Object</code> was propagated through the
    network.</p><div class="figure"><a id="d0e5654"/><p class="title"><strong>Figure 6.9. Stated Insertion</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Stated_Assertion.png" align="middle" alt="Stated Insertion"/></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e5660"/><p class="title"><strong>Figure 6.10. Logical Insertion</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Logical_Assertion.png" align="middle" alt="Logical Insertion"/></div></div></div><br class="figure-break"/><div class="section" title="6.4.1.1. Bus Pass Example With Inference and TMS"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5666"/>6.4.1.1. Bus Pass Example With Inference and TMS</h4></div></div></div><p>The previous example was issuing ID cards to over 18s, in this
      example we now issue bus passes, either a child or adult pass.</p><pre><code class="no-highlight">rule "Issue Child Bus Pass" when
    $p : Person( age &lt; 16 )
then
    insert(new ChildBusPass( $p ) );
end
 
rule "Issue Adult Bus Pass" when
    $p : Person( age &gt;= 16 )
then
    insert(new AdultBusPass( $p ) );
end</code></pre><p>As before the above example is considered monolithic, leaky and
      providing poor separation of concerns.</p><p>As before we can provide a more robust application with a
      separation of concerns using inference. Notice this time we don't just
      insert the inferred object, we use "insertLogical":</p><pre><code class="no-highlight">rule "Infer Child" when
    $p : Person( age &lt; 16 )
then
    insertLogical( new IsChild( $p ) )
end
rule "Infer Adult" when
    $p : Person( age &gt;= 16 )
then
    insertLogical( new IsAdult( $p ) )
end</code></pre><p>A "insertLogical" is part of the Drools Truth Maintenance System (TMS). When a fact is logically inserted,
        this fact is dependant on the truth of the "when" clause. It means that when the rule becomes false the fact is
        automatically retracted. This works particularly well as the two rules are mutually exclusive. So in the above
        rules if the person is under 16 it inserts an IsChild fact, once the person is 16 or over the IsChild fact is
        automatically retracted and the IsAdult fact inserted.</p><p>Returning to the code to issue bus passes, these two rules can + logically insert the ChildBusPass and
        AdultBusPass facts, as the TMS + supports chaining of logical insertions for a cascading set of retracts.</p><pre><code class="no-highlight">rule "Issue Child Bus Pass" when
    $p : Person( )
         IsChild( person == $p )
then
    insertLogical(new ChildBusPass( $p ) );
end
 
rule "Issue Adult Bus Pass" when
    $p : Person( age &gt;= 16 )
         IsAdult( person =$p )
then
    insertLogical(new AdultBusPass( $p ) );
end</code></pre><p>Now when a person changes from being 15 to 16, not only is the IsChild fact automatically retracted, so is
        the person's ChildBusPass fact. For bonus points we can combine this with the 'not' conditional element to
        handle notifications, in this situation, a request for the returning of the pass. So when the TMS automatically
        retracts the ChildBusPass object, this rule triggers and sends a request to the person:</p><pre><code class="no-highlight">rule "Return ChildBusPass Request "when
    $p : Person( )
         not( ChildBusPass( person == $p ) )
then
    requestChildBusPass( $p );
end</code></pre></div><div class="section" title="6.4.1.2. Important note: Equality for Java objects"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5689"/>6.4.1.2. Important note: Equality for Java objects</h4></div></div></div><p>It is important to note that for Truth Maintenance (and logical
      assertions) to work at all, your Fact objects (which may be JavaBeans)
      must override equals and hashCode methods (from java.lang.Object)
      correctly. As the truth maintenance system needs to know when two
      different physical objects are equal in value, <span class="emphasis"><em>both</em></span>
      equals and hashCode must be overridden correctly, as per the Java
      standard.</p><p>Two objects are equal if and only if their equals methods return
      true for each other and if their hashCode methods return the same
      values. See the Java API for more details (but do keep in mind you
      <span class="emphasis"><em>MUST</em></span> override both equals and hashCode).</p><p>TMS behaviour is not affected by theruntime configuration of
      Identity vs Equality, TMS is always equality.</p></div><div class="section" title="6.4.1.3. Deleting stated or logically asserted facts from the working memory"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5704"/>6.4.1.3. Deleting stated or logically asserted facts from the working memory</h4></div></div></div><p>By default when a fact is deleted from the working memory Drools attempts to remove
      it both from the set of stated facts and also from the Truth Maintenance System in case it has
      been logically asserted. However, using an overload of the delete method, it is also
      possible to remove it only from one of the 2. For instance invoking:</p><pre><code class="no-highlight">ksession.delete( factHandle, FactHandle.State.LOGICAL );</code></pre><p>the fact is removed only if it has been logically asserted, but not if it is a
      stated fact. In this case, if the fact has been stated its deletion fails silently
      and it is ignored.</p></div></div></div><div class="section" title="6.5. Decision Tables in Spreadsheets"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5713"/>6.5. Decision Tables in Spreadsheets</h2></div></div></div><p>Decision tables are a "precise yet compact" (ref. Wikipedia) way of representing conditional logic, and are well
  suited to <span class="emphasis"><em>business</em></span> level rules.</p><p>Drools supports managing rules in a spreadsheet format. Supported formats are Excel (XLS), and CSV, which means
  that a variety of spreadsheet programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can be utilized.
  It is expected that web based decision table editors will be included in a near future release.</p><p>Decision tables are an old concept (in software terms) but have proven useful over the years. Very briefly
  speaking, in Drools decision tables are a way to generate rules driven from the data entered into a spreadsheet. All
  the usual features of a spreadsheet for data capture and manipulation can be taken advantage of.</p><div class="section" title="6.5.1. When to Use Decision Tables"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5725"/>6.5.1. When to Use Decision Tables</h3></div></div></div><p>Consider decision tables as a course of action if rules exist that can be expressed as rule templates and
    data: each row of a decision table provides data that is combined with a template to generate a rule.</p><p>Many businesses already use spreadsheets for managing data, calculations, etc. If you are happy to continue
    this way, you can also manage your business rules this way. This also assumes you are happy to manage packages of
    rules in <code class="filename">.xls</code> or <code class="filename">.csv</code> files. Decision tables are not recommended for rules
    that do not follow a set of templates, or where there are a small number of rules (or if there is a dislike towards
    software like Excel or OpenOffice.org). They are ideal in the sense that there can be control over what
    <span class="emphasis"><em>parameters</em></span> of rules can be edited, without exposing the rules directly.</p><p>Decision tables also provide a degree of insulation from the underlying object model.</p></div><div class="section" title="6.5.2. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5743"/>6.5.2. Overview</h3></div></div></div><p>Here are some examples of real world decision tables (slightly edited to protect the
      innocent).</p><div class="figure"><a id="d0e5748"/><p class="title"><strong>Figure 6.11.  Using Excel to edit a decision table </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/excel.png" alt="Using Excel to edit a decision table"/></div></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e5755"/><p class="title"><strong>Figure 6.12.  Multiple actions for a rule row </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/actions.png" alt="Multiple actions for a rule row"/></div></div></div></div><br class="figure-break"/><div class="figure"><a id="d0e5762"/><p class="title"><strong>Figure 6.13.  Using OpenOffice.org </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/open_office.png" alt="Using OpenOffice.org"/></div></div></div></div><br class="figure-break"/><p>In the above examples, the technical aspects of the decision table have been collapsed
      away (using a standard spreadsheet feature).</p><p>The rules start from row 17, with each row resulting in a rule. The conditions are in
      columns C, D, E, etc., the actions being off-screen. The values in the cells are quite simple,
      and their meaning is indicated by the headers in Row 16. Column B is just a description. It is
      customary to use color to make it obvious what the different areas of the table mean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Note that although the decision tables look like they process top down, this is not
        necessarily the case. Ideally, rules are authored without regard for the order of rows,
        simply because this makes maintenance easier, as rows will not need to be shifted around all
        the time.</p></div><p>As each row is a rule, the same principles apply. As the rule engine processes the facts,
      any rules that match may fire. (Some people are confused by this. It is possible to clear the
      agenda when a rule fires and simulate a very simple decision table where only the first match
      effects an action.) Also note that you can have multiple tables on one spreadsheet. This way,
      rules can be grouped where they share common templates, yet at the end of the day they are all
      combined into one rule package. Decision tables are essentially a tool to generate DRL rules
      automatically.</p><div class="figure"><a id="d0e5778"/><p class="title"><strong>Figure 6.14.  A real world example using multiple tables for grouping like rules </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/multi_table.png" alt="A real world example using multiple tables for grouping like rules"/></div></div></div></div><br class="figure-break"/></div><div class="section" title="6.5.3. How Decision Tables Work"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5785"/>6.5.3. How Decision Tables Work</h3></div></div></div><p>The key point to keep in mind is that in a decision table each row is a rule, and each
      column in that row is either a condition or action for that rule.</p><div class="figure"><a id="d0e5790"/><p class="title"><strong>Figure 6.15.  Rows and columns </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/row_col.png" alt="Rows and columns"/></div></div></div></div><br class="figure-break"/><p>The spreadsheet looks for the <em class="firstterm">RuleTable</em> keyword to indicate the
      start of a rule table (both the starting row and column). Other keywords are also used to
      define other package level attributes (covered later). It is important to keep the keywords in
      one column. By convention the second column ("B") is used for this, but it can be any column
      (convention is to leave a margin on the left for notes). In the following diagram, C is
      actually the column where it starts. Everything to the left of this is ignored.</p><p>If we expand the hidden sections, it starts to make more sense how it works; note the
      keywords in column C.</p><div class="figure"><a id="d0e5804"/><p class="title"><strong>Figure 6.16.  Expanded for rule templates </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/expanded.png" alt="Expanded for rule templates"/></div></div></div></div><br class="figure-break"/><p>Now the hidden magic which makes it work can be seen. The RuleSet keyword indicates the
      name to be used in the <span class="emphasis"><em>rule package</em></span> that will encompass all the rules.
      This name is optional, using a default, but it <span class="emphasis"><em>must</em></span> have the
        <span class="emphasis"><em>RuleSet</em></span> keyword in the cell immediately to the right.</p><p>The other keywords visible in Column C are Import and Sequential which will be covered
      later. The RuleTable keyword is important as it indicates that a chunk of rules will follow,
      based on some rule templates. After the RuleTable keyword there is a name, used to prefix the
      names of the generated rules. The sheet name and row numbers are appended to guarantee unique
      rule names.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>The RuleTable name combined with the sheet name must be unique across all spreadsheet
        files in the same KieBase. If that's not the case, some rules might have the same name
        and only 1 of them will be applied. To show such ignored rules, <a class="link" href="ch04.html#changingTheDefaultBuildResultSeverity" title="4.2.2.5. Changing the Default Build Result Severity">raise the severity of such rule name
          conflicts</a>.</p></div><p> The column of RuleTable indicates the column in which the rules start; columns to the
      left are ignored.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In general the keywords make up name-value pairs.</p></div><p>Referring to row 14 (the row immediately after RuleTable), the keywords CONDITION and
      ACTION indicate that the data in the columns below are for either the LHS or the RHS parts of
      a rule. There are other attributes on the rule which can also be optionally set this
      way.</p><p>Row 15 contains declarations of <em class="firstterm">ObjectTypes</em>. The content in this
      row is optional, but if this option is not in use, the row must be left blank; however this
      option is usually found to be quite useful. When using this row, the values in the cells below
      (row 16) become constraints on that object type. In the above case, it generates
        <code class="code">Person(age=="42")</code> and <code class="code">Cheese(type=="stilton")</code>, where 42 and
      "stilton" come from row 18. In the above example, the "==" is implicit; if just a field name
      is given the translator assumes that it is to generate an exact match.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>An ObjectType declaration can span columns (via merged cells), meaning that all columns
        below the merged range are to be combined into one set of constraints within a single
        pattern matching a single fact at a time, as opposed to non-merged cells containing the same
        ObjectType, but resulting in different patterns, potentially matching different or identical
        facts.</p></div><p>Row 16 contains the rule templates themselves. They can use the "$param" placeholder to
      indicate where data from the cells below should be interpolated. (For multiple insertions, use
      "$1", "$2", etc., indicating parameters from a comma-separated list in a cell below.) Row 17
      is ignored; it may contain textual descriptions of the column's purpose.</p><p>Rows 18 and 19 show data, which will be combined (interpolated) with the templates in row
      15, to generate rules. If a cell contains no data, then its template is ignored. (This would
      mean that some condition or action does not apply for that rule row.) Rule rows are read until
      there is a blank row. Multiple RuleTables can exist in a sheet. Row 20 contains another
      keyword, and a value. The row positions of keywords like this do not matter (most people put
      them at the top) but their column should be the same one where the RuleTable or RuleSet
      keywords should appear. In our case column C has been chosen to be significant, but any other
      column could be used instead.</p><p>In the above example, rules would be rendered like the following (as it uses the
      "ObjectType" row):</p><pre class="screen">//row 18
rule "Cheese_fans_18"
when
    Person(age=="42")
    Cheese(type=="stilton")
then
    list.add("Old man stilton");
end
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The constraints <code class="code">age=="42"</code> and <code class="code">type=="stilton"</code> are interpreted
        as single constraints, to be added to the respective ObjectType in the cell above. If the
        cells above were spanned, then there could be multiple constraints on one "column".</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Very large decision tables may have very large memory requirements.</p></div></div><div class="section" title="6.5.4. Spreadsheet Syntax"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5871"/>6.5.4. Spreadsheet Syntax</h3></div></div></div><div class="section" title="6.5.4.1. Spreadsheet Structure"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5874"/>6.5.4.1. Spreadsheet Structure</h4></div></div></div><p>There are two types of rectangular areas defining data that is used for generating a DRL file. One, marked
      by a cell labelled <code class="code">RuleSet</code>, defines all DRL items except rules. The other one may occur repeatedly
      and is to the right and below a cell whose contents begin with <code class="code">RuleTable</code>. These areas represent the
      actual decision tables, each area resulting in a set of rules of similar structure.</p><p>A Rule Set area may contain cell pairs, one below the <code class="code">RuleSet</code> cell and containing a keyword
      designating the kind of value contained in the other one that follows in the same row.</p><p>The columns of a Rule Table area define patterns and constraints for the left hand sides of the rules
      derived from it, actions for the consequences of the rules, and the values of individual rule attributes. Thus, a
      Rule Table area should contain one or more columns, both for conditions and actions, and an arbitrary selection of
      columns for rule attributes, at most one column for each of these. The first four rows following the row with the
      cell marked with <code class="code">RuleTable</code> are earmarked as header area, mostly used for the definition of code to
      construct the rules. It is any additional row below these four header rows that spawns another rule, with its data
      providing for variations in the code defined in the Rule Table header.</p><p>All keywords are case insensitive.</p><p>Only the first worksheet is examined for decision tables.</p></div><div class="section" title="6.5.4.2. Rule Set Entries"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5899"/>6.5.4.2. Rule Set Entries</h4></div></div></div><p>Entries in a Rule Set area may define DRL constructs (except rules), and specify rule attributes. While
      entries for constructs may be used repeatedly, each rule attribute may be given at most once, and it applies to
      all rules unless it is overruled by the same attribute being defined within the Rule Table area.</p><p>Entries must be given in a vertically stacked sequence of cell pairs. The first one contains a keyword and
      the one to its right the value, as shown in the table below. This sequence of cell pairs may be interrupted by
      blank rows or even a Rule Table, as long as the column marked by <code class="code">RuleSet</code> is upheld as the one
      containing the keyword.</p><div class="table"><a id="d0e5909"/><p class="title"><strong>Table 6.5. Entries in the Rule Set area</strong></p><div class="table-contents"><table summary="Entries in the Rule Set area" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Keyword</th><th>Value</th><th>Usage</th></tr></thead><tbody><tr><td>RuleSet</td><td>The package name for the generated DRL file. Optional, the default is
              <code class="code">rule_table</code>.</td><td>Must be First entry.</td></tr><tr><td>Sequential</td><td>"true" or "false". If "true", then salience is used to ensure that rules fire from the top
              down.</td><td>Optional, at most once. If omitted, no firing order is imposed.</td></tr><tr><td>EscapeQuotes</td><td>"true" or "false". If "true", then quotation marks are escaped so that they appear literally in the
              DRL.</td><td>Optional, at most once. If omitted, quotation marks are escaped.</td></tr><tr><td>Import</td><td>A comma-separated list of Java classes to import.</td><td>Optional, may be used repeatedly.</td></tr><tr><td>Variables</td><td>Declarations of DRL globals, i.e., a type followed by a variable name. Multiple global definitions
              must be separated with a comma.</td><td>Optional, may be used repeatedly.</td></tr><tr><td>Functions</td><td>One or more function definitions, according to DRL syntax.</td><td>Optional, may be used repeatedly.</td></tr><tr><td>Queries</td><td>One or more query definitions, according to DRL syntax.</td><td>Optional, may be used repeatedly.</td></tr><tr><td>Declare</td><td>One or more declarative types, according to DRL syntax.</td><td>Optional, may be used repeatedly.</td></tr></tbody></table></div></div><br class="table-break"/><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>In some locales, MS Office, LibreOffice and OpenOffice will encode a double quoth <code class="literal">"</code>
        differently, which will cause a compilation error. The difference is often hard to see. For example:
        <code class="literal">“A”</code> will fail, but <code class="literal">"A"</code> will work.</p></div><p>For defining rule attributes that apply to all rules in the generated DRL file you can use any of the
      entries in the following table. Notice, however, that the proper keyword must be used. Also, each of these
      attributes may be used only once.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Rule attributes specified in a Rule Set area will affect all rule assets in the same package (not only
          in the spreadsheet). Unless you are sure that the spreadsheet is the only one rule asset in the package, the
          recommendation is to specify rule attributes not in a Rule Set area but in a Rule Table columns for each
          rule instead.</p></div><div class="table"><a id="d0e5998"/><p class="title"><strong>Table 6.6. Rule attribute entries in the Rule Set area</strong></p><div class="table-contents"><table summary="Rule attribute entries in the Rule Set area" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Keyword</th><th>Initial</th><th>Value</th></tr></thead><tbody><tr><td>PRIORITY</td><td>P</td><td>An integer defining the "salience" value for the rule. Overridden by the "Sequential" flag.</td></tr><tr><td>DURATION</td><td>D</td><td>A long integer value defining the "duration" value for the rule.</td></tr><tr><td>TIMER</td><td>T</td><td>A timer definition. See "Timers and Calendars".</td></tr><tr><td>ENABLED</td><td>B</td><td>A Boolean value. "true" enables the rule; "false" disables the rule.</td></tr><tr><td>CALENDARS</td><td>E</td><td>A calendars definition. See "Timers and Calendars".</td></tr><tr><td>NO-LOOP</td><td>U</td><td>A Boolean value. "true" inhibits looping of rules due to changes made by its consequence.</td></tr><tr><td>LOCK-ON-ACTIVE</td><td>L</td><td>A Boolean value. "true" inhibits additional activations of all rules with this flag set within the
              same ruleflow or agenda group.</td></tr><tr><td>AUTO-FOCUS</td><td>F</td><td>A Boolean value. "true" for a rule within an agenda group causes activations of the rule to
              automatically give the focus to the group.</td></tr><tr><td>ACTIVATION-GROUP</td><td>X</td><td>A string identifying an activation (or XOR) group. Only one rule within an activation group will
              fire, i.e., the first one to fire cancels any existing activations of other rules within the same
              group.</td></tr><tr><td>AGENDA-GROUP</td><td>G</td><td>A string identifying an agenda group, which has to be activated by giving it the "focus", which is
              one way of controlling the flow between groups of rules.</td></tr><tr><td>RULEFLOW-GROUP</td><td>R</td><td>A string identifying a rule-flow group.</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" title="6.5.4.3. Rule Tables"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6088"/>6.5.4.3. Rule Tables</h4></div></div></div><p>All Rule Tables begin with a cell containing "RuleTable", optionally followed by a string within the same
      cell. The string is used as the initial part of the name for all rules derived from this Rule Table, with the row
      number appended for distinction. (This automatic naming can be overridden by using a NAME column.) All other cells
      defining rules of this Rule Table are below and to the right of this cell.</p><p>The next row defines the column type, with each column resulting in a part of the condition or the
      consequence, or providing some rule attribute, the rule name or a comment. The table below shows which column
      headers are available; additional columns may be used according to the table showing rule attribute entries given
      in the preceding section. Note that each attribute column may be used at most once. For a column header, either
      use the keyword or any other word beginning with the letter given in the "Initial" column of these tables.</p><div class="table"><a id="d0e6095"/><p class="title"><strong>Table 6.7. Column Headers in the Rule Table</strong></p><div class="table-contents"><table summary="Column Headers in the Rule Table" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>Keyword</th><th>Initial</th><th>Value</th><th>Usage</th></tr></thead><tbody><tr><td>NAME</td><td>N</td><td>Provides the name for the rule generated from that row. The default is constructed from the text
              following the RuleTable tag and the row number.</td><td>At most one column</td></tr><tr><td>DESCRIPTION</td><td>I</td><td>A text, resulting in a comment within the generated rule.</td><td>At most one column</td></tr><tr><td>CONDITION</td><td>C</td><td>Code snippet and interpolated values for constructing a constraint within a pattern in a
              condition.</td><td>At least one per rule table</td></tr><tr><td>ACTION</td><td>A</td><td>Code snippet and interpolated values for constructing an action for the consequence of the
              rule.</td><td>At least one per rule table</td></tr><tr><td>METADATA</td><td>@</td><td>Code snippet and interpolated values for constructing a metadata entry for the rule.</td><td>Optional, any number of columns</td></tr></tbody></table></div></div><br class="table-break"/><p>Given a column headed CONDITION, the cells in successive lines result in a conditional element.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Text in the first cell below CONDITION develops into a pattern for the rule condition, with the snippet
          in the next line becoming a constraint. If the cell is merged with one or more neighbours, a single pattern
          with multiple constraints is formed: all constraints are combined into a parenthesized list and appended to
          the text in this cell. The cell may be left blank, which means that the code snippet in the next row must
          result in a valid conditional element on its own.</p><p>To include a pattern without constraints, you can write the pattern in front of the text for another
          pattern.</p><p>The pattern may be written with or without an empty pair of parentheses. A "from" clause may be appended
          to the pattern.</p><p>If the pattern ends with "eval", code snippets are supposed to produce boolean expressions for inclusion
          into a pair of parentheses after "eval".</p></li><li class="listitem"><p>Text in the second cell below CONDITION is processed in two steps.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The code snippet in this cell is modified by interpolating values from cells farther down in the
              column. If you want to create a constraint consisting of a comparison using "==" with the value from the
              cells below, the field selector alone is sufficient. Any other comparison operator must be specified as
              the last item within the snippet, and the value from the cells below is appended. For all other constraint
              forms, you must mark the position for including the contents of a cell with the symbol
              <code class="code">$param</code>. Multiple insertions are possible by using the symbols <code class="code">$1</code>,
              <code class="code">$2</code>, etc., and a comma-separated list of values in the cells below.</p><p>A text according to the pattern
              <code class="code">forall(</code><span class="emphasis"><em>delimiter</em></span><code class="code">){</code><span class="emphasis"><em>snippet</em></span><code class="code">}</code>
              is expanded by repeating the <span class="emphasis"><em>snippet</em></span> once for each of the values of the
              comma-separated list of values in each of the cells below, inserting the value in place of the symbol
              <code class="code">$</code> and by joining these expansions by the given <span class="emphasis"><em>delimiter</em></span>. Note that the
              forall construct may be surrounded by other text.</p></li><li class="listitem"><p>If the cell in the preceding row is not empty, the completed code snippet is added to the
              conditional element from that cell. A pair of parentheses is provided automatically, as well as a
              separating comma if multiple constraints are added to a pattern in a merged cell.</p><p>If the cell above is empty, the interpolated result is used as is.</p></li></ol></div></li><li class="listitem"><p>Text in the third cell below CONDITION is for documentation only. It should be used to indicate the
          column's purpose to a human reader.</p></li><li class="listitem"><p>From the fourth row on, non-blank entries provide data for interpolation as described above. A blank
          cell results in the omission of the conditional element or constraint for this rule.</p></li></ul></div><p>Given a column headed ACTION, the cells in successive lines result in an action statement.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Text in the first cell below ACTION is optional. If present, it is interpreted as an object
          reference.</p></li><li class="listitem"><p>Text in the second cell below ACTION is processed in two steps.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The code snippet in this cell is modified by interpolating values from cells farther down in the
              column. For a singular insertion, mark the position for including the contents of a cell with the symbol
              <code class="code">$param</code>. Multiple insertions are possible by using the symbols <code class="code">$1</code>,
              <code class="code">$2</code>, etc., and a comma-separated list of values in the cells below.</p><p>A method call without interpolation can be achieved by a text without any marker symbols. In this
              case, use any non-blank entry in a row below to include the statement.</p><p>The forall construct is available here, too.</p></li><li class="listitem"><p>If the first cell is not empty, its text, followed by a period, the text in the second cell and a
              terminating semicolon are stringed together, resulting in a method call which is added as an action
              statement for the consequence.</p><p>If the cell above is empty, the interpolated result is used as is.</p></li></ol></div></li><li class="listitem"><p>Text in the third cell below ACTION is for documentation only. It should be used to indicate the
          column's purpose to a human reader.</p></li><li class="listitem"><p>From the fourth row on, non-blank entries provide data for interpolation as described above. A blank
          cell results in the omission of the action statement for this rule.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Using <code class="code">$1</code> instead of <code class="code">$param</code> works in most cases, but it will fail if the
        replacement text contains a comma: then, only the part preceding the first comma is inserted. Use this
        "abbreviation" judiciously.</p></div><p>Given a column headed METADATA, the cells in successive lines result in a metadata annotation for the
      generated rules.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Text in the first cell below METADATA is ignored.</p></li><li class="listitem"><p>Text in the second cell below METADATA is subject to interpolation, as described above, using values
          from the cells in the rule rows. The metadata marker character <code class="code">@</code> is prefixed automatically, and
          thus it should not be included in the text for this cell.</p></li><li class="listitem"><p>Text in the third cell below METADATA is for documentation only. It should be used to indicate the
          column's purpose to a human reader.</p></li><li class="listitem"><p>From the fourth row on, non-blank entries provide data for interpolation as described above. A blank
          cell results in the omission of the metadata annotation for this rule.</p></li></ul></div></div><div class="section" title="6.5.4.4. Examples"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6280"/>6.5.4.4. Examples</h4></div></div></div><p>The various interpolations are illustrated in the following example.</p><div class="example"><a id="d0e6285"/><p class="title"><strong>Example 6.1. Interpolating cell data</strong></p><div class="example-contents"><p>If the template is <code class="code">Foo(bar == $param)</code> and the cell is <code class="code">42</code>,
          then the result is <code class="code">Foo(bar == 42)</code>.</p><p>If the template is <code class="code">Foo(bar &lt; $1, baz == $2)</code> and the cell contains
            <code class="code">42,43</code>, the result will be <code class="code">Foo(bar &lt; 42, baz ==43)</code>.</p><p>The template <code class="code">forall(&amp;&amp;){bar != $}</code> with a cell containing
            <code class="code">42,43</code> results in <code class="code">bar != 42 &amp;&amp; bar != 43</code>.</p></div></div><br class="example-break"/><p>The next example demonstrates the joint effect of a cell defining the pattern type and
        the code snippet below it. </p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/spanned_column.png"/></div></div><p> This spreadsheet section shows how the <code class="code">Person</code> type declaration
        spans 2 columns, and thus both constraints will appear as <code class="code">Person(age == ..., type ==
          ...)</code>. Since only the field names are present in the snippet, they imply an equality
        test.</p><p>In the following example the marker symbol <code class="code">$param</code> is used. </p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/with_param.png"/></div></div><p> The result of this column is the pattern <code class="code">Person(age == "42"))</code>.
        You may have noticed that the marker and the operator "==" are redundant.</p><p>The next example illustrates that a trailing insertion marker can be omitted. </p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/operator_completion.png"/></div></div><p> Here, appending the value from the cell is implied, resulting in
          <code class="code">Person(age &lt; "42")).</code></p><p>You can provide the definition of a binding variable, as in the example below. . </p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/with_binding.png"/></div></div><p> Here, the result is <code class="code">c: Cheese(type == "stilton").</code> Note that the
        quotes are provided automatically. Actually, anything can be placed in the object type row.
        Apart from the definition of a binding variable, it could also be an additional pattern that
        is to be inserted literally.</p><p>A simple construction of an action statement with the insertion of a single value is
        shown below. </p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/consequence.png"/></div></div><p> The cell below the ACTION header is left blank. Using this style, anything can
        be placed in the consequence, not just a single method call. (The same technique is
        applicable within a CONDITION column as well.)</p><p>Below is a comprehensive example, showing the use of various column headers. It is not
        an error to have no value below a column header (as in the NO-LOOP column): here, the
        attribute will not be applied in any of the rules. </p><div class="figure"><a id="d0e6375"/><p class="title"><strong>Figure 6.17.  Example usage of keywords for imports, headers, etc. </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/Key.png" alt="Example usage of keywords for imports, headers, etc."/></div></div></div></div><p><br class="figure-break"/>
      </p><p>And, finally, here is an example of Import, Variables and Functions. </p><div class="figure"><a id="d0e6385"/><p class="title"><strong>Figure 6.18.  Example usage of keywords for functions, etc. </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/keywords.png" alt="Example usage of keywords for functions, etc."/></div></div></div></div><p><br class="figure-break"/> Multiple package names within the same cell must be separated by a comma. Also,
        the pairs of type and variable names must be comma-separated. Functions, however, must be
        written as they appear in a DRL file. This should appear in the same column as the "RuleSet"
        keyword; it could be above, between or below all the rule rows.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It may be more convenient to use Import, Variables, Functions and Queries repeatedly
          rather than packing several definitions into a single cell.</p></div></div></div><div class="section" title="6.5.5. Creating and integrating Spreadsheet based Decision Tables"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6396"/>6.5.5. Creating and integrating Spreadsheet based Decision Tables</h3></div></div></div><p>The API to use spreadsheet based decision tables is in the drools-decisiontables module. There is really only
    one class to look at: <code class="literal">SpreadsheetCompiler</code>. This class will take spreadsheets in various formats,
    and generate rules in DRL (which you can then use in the normal way). The <code class="literal">SpreadsheetCompiler</code> can
    just be used to generate partial rule files if it is wished, and assemble it into a complete rule package after the
    fact (this allows the separation of technical and non-technical aspects of the rules if needed).</p><p>To get started, a sample spreadsheet can be used as a base. Alternatively, if the plug-in
      is being used (Rule Workbench IDE), the wizard can generate a spreadsheet from a template (to
      edit it an xls compatible spreadsheet editor will need to be used). 
      </p><div class="figure"><a id="d0e6409"/><p class="title"><strong>Figure 6.19.  Wizard in the IDE </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/wizard.png" alt="Wizard in the IDE"/></div></div></div></div><p><br class="figure-break"/>
    </p></div><div class="section" title="6.5.6. Managing Business Rules in Decision Tables"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6417"/>6.5.6. Managing Business Rules in Decision Tables</h3></div></div></div><div class="section" title="6.5.6.1. Workflow and Collaboration"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6420"/>6.5.6.1. Workflow and Collaboration</h4></div></div></div><p>Spreadsheets are well established business tools (in use for over 25 years). Decision tables lend themselves
      to close collaboration between IT and domain experts, while making the business rules clear to business analysts,
      it is an ideal separation of concerns.</p><p>Typically, the whole process of authoring rules (coming up with a new decision table) would be something
      like:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Business analyst takes a template decision table (from a repository, or from IT)</p></li><li class="listitem"><p>Decision table business language descriptions are entered in the table(s)</p></li><li class="listitem"><p>Decision table rules (rows) are entered (roughly)</p></li><li class="listitem"><p>Decision table is handed to a technical resource, who maps the business language (descriptions) to
          scripts (this may involve software development of course, if it is a new application or data model)</p></li><li class="listitem"><p>Technical person hands back and reviews the modifications with the business analyst.</p></li><li class="listitem"><p>The business analyst can continue editing the rule rows as needed (moving columns around is also fine
          etc).</p></li><li class="listitem"><p>In parallel, the technical person can develop test cases for the rules (liaising with business analysts)
          as these test cases can be used to verify rules and rule changes once the system is running.</p></li></ol></div></div><div class="section" title="6.5.6.2. Using spreadsheet features"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6449"/>6.5.6.2. Using spreadsheet features</h4></div></div></div><p>Features of applications like Excel can be used to provide assistance in entering data
        into spreadsheets, such as validating fields. Lists that are stored in other worksheets can
        be used to provide valid lists of values for cells, like in the following diagram. 
        </p><div class="figure"><a id="d0e6454"/><p class="title"><strong>Figure 6.20. </strong></p><div class="figure-contents"><div class="screenshot"><span style="color: red">&lt;title&gt; Wizard in the IDE &lt;/title&gt;</span><div class="mediaobject"><img src="images/DecisionTables/lists.png"/></div></div></div></div><p><br class="figure-break"/>
      </p><p>Some applications provide a limited ability to keep a history of changes, but it is recommended to use an
      alternative means of revision control. When changes are being made to rules over time, older versions are archived
      (many open source solutions exist for this, such as Subversion or Git).</p></div></div><div class="section" title="6.5.7. Rule Templates"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6464"/>6.5.7. Rule Templates</h3></div></div></div><p>Related to decision tables (but not necessarily requiring a spreadsheet) are "Rule
      Templates" (in the drools-templates module). These use any tabular data source as a source of
      rule data - populating a template to generate many rules. This can allow both for more
      flexible spreadsheets, but also rules in existing databases for instance (at the cost of
      developing the template up front to generate the rules).</p><p>With Rule Templates the data is separated from the rule and there are no restrictions on
      which part of the rule is data-driven. So whilst you can do everything you could do in
      decision tables you can also do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>store your data in a database (or any other format)</p></li><li class="listitem"><p>conditionally generate rules based on the values in the data</p></li><li class="listitem"><p>use data for any part of your rules (e.g. condition operator, class name, property
          name)</p></li><li class="listitem"><p>run different templates over the same data</p></li></ul></div><p>As an example, a more classic decision table is shown, but without any hidden rows for the
      rule meta data (so the spreadsheet only contains the raw data to generate the rules).</p><div class="figure"><a id="d0e6486"/><p class="title"><strong>Figure 6.21.  Template data </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/template1.png" alt="Template data"/></div></div></div></div><br class="figure-break"/><p>See the <code class="filename">ExampleCheese.xls</code> in the examples download for the above
      spreadsheet.</p><p>If this was a regular decision table there would be hidden rows before row 1 and between
      rows 1 and 2 containing rule metadata. With rule templates the data is completely separate
      from the rules. This has two handy consequences - you can apply multiple rule templates to the
      same data and your data is not tied to your rules at all. So what does the template look
      like?</p><pre><code class="no-highlight">
1  template header
2  age
3  type
4  log
5
6  package org.drools.examples.templates;
7
8  global java.util.List list;
9
10 template "cheesefans"
11
12 rule "Cheese fans_@{row.rowNumber}"
13 when
14    Person(age == @{age})
15    Cheese(type == "@{type}")
16 then
17    list.add("@{log}");
18 end
19
20 end template
</code></pre><p>Annotations to the preceding program listing: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Line 1: All rule templates start with <code class="code">template header</code>.</p></li><li class="listitem"><p>Lines 2-4: Following the header is the list of columns in the order they appear in
            the data. In this case we are calling the first column <code class="code">age</code>, the second
              <code class="code">type</code> and the third <code class="code">log</code>.</p></li><li class="listitem"><p>Line 5: An empty line signifies the end of the column definitions.</p></li><li class="listitem"><p>Lines 6-9: Standard rule header text. This is standard rule DRL and will appear at
            the top of the generated DRL. Put the package statement and any imports and global and
            function definitions into this section.</p></li><li class="listitem"><p>Line 10: The keyword <code class="code">template</code> signals the start of a rule template.
            There can be more than one template in a template file, but each template should have a
            unique name.</p></li><li class="listitem"><p>Lines 11-18: The rule template - see below for details.</p></li><li class="listitem"><p>Line 20: The keywords <code class="code">end template</code> signify the end of the
            template.</p></li></ul></div><p>The rule templates rely on MVEL to do substitution using the syntax @{token_name}. There
      is currently one built-in expression, @{row.rowNumber} which gives a unique number for each
      row of data and enables you to generate unique rule names. For each row of data a rule will be
      generated with the values in the data substituted for the tokens in the template.</p><p>A rule template has to be included in a file with extension .drt and associated to
      the corresponding decision table when defining the kbase in the kmodule.xml file as in
      the following example</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://drools.org/xsd/kmodule"&gt;
  &lt;kbase name="TemplatesKB" packages="org.drools.examples.templates"&gt;
    &lt;ruleTemplate dtable="org/drools/examples/templates/ExampleCheese.xls"
                  template="org/drools/examples/templates/Cheese.drt"
                  row="2" col="2"/&gt;
      &lt;ksession name="TemplatesKS"/&gt;
      &lt;/kbase&gt;
&lt;/kmodule&gt;
</code></pre><p>With the example data above the following rule file would be generated:</p><pre><code class="no-highlight">
package org.drools.examples.templates;

global java.util.List list;

rule "Cheese fans_1"
when
  Person(age == 42)
  Cheese(type == "stilton")
then
  list.add("Old man stilton");
end

rule "Cheese fans_2"
when
  Person(age == 21)
  Cheese(type == "cheddar")
then
  list.add("Young man cheddar");
end
</code></pre><p>At this point the <code class="code">KieSession</code> named "TemplatesKS" and containing the rules
      generated from the template can be simply created from the <code class="code">KieContainer</code>
      and used as any other <code class="code">KieSession</code>.</p><pre><code class="language-java">
KieSession ksession = kc.newKieSession( "TemplatesKS" );

//now create some test data
ksession.insert( new Cheese( "stilton", 42 ) );
ksession.insert( new Person( "michael", "stilton", 42 ) );
final List&lt;String&gt; list = new ArrayList&lt;String&gt;();
ksession.setGlobal( "list", list );

ksession.fireAllRules();
</code></pre></div></div><div class="section" title="6.6. Logging"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6567"/>6.6. Logging</h2></div></div></div><p>One way to illuminate the black box that is a rule engine, is to play with the logging level.</p><p>Everything is logged to <a class="link" href="http://www.slf4j.org/">SLF4J</a>, which is a simple logging facade
  that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a dependency to the
  logging adaptor for your logging framework of choice. If you're not using any logging framework yet, you can use
  Logback by adding this Maven dependency:</p><pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If you're developing for an ultra light environment, use <code class="literal">slf4j-nop</code> or
    <code class="literal">slf4j-simple</code> instead.</p></div><p>Configure the logging level on the package <code class="literal">org.drools</code>. For example:</p><p>In Logback, configure it in your <code class="filename">logback.xml</code> file:</p><pre><code class="language-xml">&lt;configuration&gt;

    &lt;logger name="org.drools" level="debug"/&gt;

    ...

&lt;configuration&gt;</code></pre><p>In Log4J, configure it in your <code class="filename">log4j.xml</code> file:</p><pre><code class="language-xml">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;

    &lt;category name="org.drools"&gt;
      &lt;priority value="debug" /&gt;
    &lt;/category&gt;

    ...

&lt;/log4j:configuration&gt;</code></pre></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch05.html"><strong>Prev</strong>Chapter 5. Hybrid Reasoning</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch07.html"><strong>Next</strong>Chapter 7. Running</a></li></ul></body></html>