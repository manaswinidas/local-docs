<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools Fusion User Guide</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p></div><hr/></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e11">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16">1.1. Complex Event Processing</a></span></dt><dt><span class="section"><a href="#d0e70">1.2. Drools Fusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e172">2. Drools Fusion Features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e175">2.1. Events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e180">2.1.1. Event Semantics</a></span></dt><dt><span class="section"><a href="#d0e232">2.1.2. Event Declaration</a></span></dt><dt><span class="section"><a href="#d0e281">2.1.3. Event Metadata</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e443">2.2. Session Clock</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e474">2.2.1. Available Clock Implementations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e501">2.3. Streams Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e523">2.3.1. Declaring and Using Entry Points</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e558">2.4. Temporal Reasoning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e622">2.4.1. Temporal Operators</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1048">2.5. Event Processing Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1055">2.5.1. Cloud Mode</a></span></dt><dt><span class="section"><a href="#d0e1086">2.5.2. Stream Mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1159">2.6. Sliding Windows</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1169">2.6.1. Sliding Time Windows</a></span></dt><dt><span class="section"><a href="#d0e1189">2.6.2. Sliding Length Windows</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1209">2.7. Knowledgebase Partitioning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1224">2.7.1. When partitioning is useful</a></span></dt><dt><span class="section"><a href="#d0e1244">2.7.2. How to configure partitioning</a></span></dt><dt><span class="section"><a href="#d0e1260">2.7.3. Multithreading management</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1282">2.8. Memory Management for Events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1300">2.8.1. Explicit expiration offset</a></span></dt><dt><span class="section"><a href="#d0e1312">2.8.2. Inferred expiration offset</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1326">3. References</a></span></dt><dt><span class="index"><a href="#d0e1329">Index</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11"/>Chapter 1. Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16">1.1. Complex Event Processing</a></span></dt><dt><span class="section"><a href="#d0e70">1.2. Drools Fusion</a></span></dt></dl></div><p>In the Drools vision of a unified behavioral modelling platform,
  Drools Fusion is the module responsible for enabling event processing
  behavior.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16"/>1.1. Complex Event Processing</h2></div></div></div><p>Although several tries were made, there isn't up to date any broadly
  accepted definition on the term Complex Event Processing. The term Event by
  itself is frequently overloaded and used to refer to several different
  things, depending on the context it is used. Defining terms is not the goal
  of this guide and as so, lets adopt a loose definition that, although not
  formal, will allow us to proceed with a common understanding.</p><p>So, in the scope of this guide:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p><a id="d0e25" class="indexterm"/> <span class="bold"><strong>Event</strong></span>, is a record of a
    significant change of state in the application domain.</p></div><p>For instance, on a Stock Broker application, when a sell operation is
  executed, it causes a change of state in the domain. This change of state
  can be observed on several entities in the domain, like the price of the
  securities that changed to match the value of the operation, the owner of
  the individual traded assets that change from the seller to the buyer, the
  balance of the accounts from both seller and buyer that are credited and
  debited, etc. Depending on how the domain is modelled, this change of state
  may be represented by a single event, multiple atomic events or even
  hierarchies of correlated events. In any case, in the context of this guide,
  Event is the record of the change on a particular data in the domain.</p><p>Events are processed by computer systems since they were invented, and
  throughout the history, systems responsible for that were given different
  names and different methodologies were employed. It wasn't until the 90's
  though, that a more focused work started on EDA (Event Driven Architecture)
  with a more formal definition on the requirements and goals for event
  processing. Old messaging systems started to change to address such
  requirements and new systems started to be developed with the single purpose
  of event processing. Two trends were born under the names of Event Stream
  Processing and Complex Event Processing.</p><p>In the very begginings, Event Stream Processing was focused on the
  capabilities of processing streams of events in (near) real time, where the
  main focus of Complex Event Processing was on the correlation and
  composition of atomic events into complex (compound) events. An important
  (maybe the most important) milestone was the publishing of the Dr. David
  Luckham's book "The Power of Events" in 2002. In the book, Dr Luckham
  introduces the concept of Complex Event Processing and how it can be used to
  enhance systems that deal with events. Over the years, both trends converged
  to a common understanding and today these systems are all refered as CEP
  systems.</p><p>This is a very simplistic explanation to a really complex and fertile
  field of research, but sets a very highlevel and common understanding for
  the concepts this guide will introduce.</p><p>The current understanding of what Complex Event Processing is may be
  briefly described as the following quote from Wikipedia:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>"<a id="d0e52" class="indexterm"/> <span class="bold"><strong>Complex Event
      Processing</strong></span>, or CEP, is primarily an event processing concept
      that deals with the task of processing multiple events with the goal of
      identifying the meaningful events within the event cloud. CEP employs
      techniques such as detection of complex patterns of many events, event
      correlation and abstraction, event hierarchies, and relationships
      between events such as causality, membership, and timing, and
      event-driven processes."</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution"><a class="ulink" href="http://en.wikipedia.org/wiki/Complex_event_processing">
          <em class="citetitle">wikipedia</em>
        </a></span></td></tr></table></div></div><p>In other words, CEP is about detecting and selecting the interesting
  events (and only them) from an event cloud, finding their relationships and
  infering new data from them and their relationships.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For the remaining of this guide, we will use the terms 
   <span class="bold"><strong>Complex Event Processing</strong></span>
  and <span class="bold"><strong>CEP</strong></span> as a broad reference for any of 
  the related technologies
  and techniques, including but not limited to, CEP, Complex Event Processing,
  ESP, Event Stream Processing and Event Processing in general.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e70"/>1.2. Drools Fusion</h2></div></div></div><p>Event Processing use cases, in general, share several requirements and
  goals with Business Rules use cases. These overlaps happen both on the
  business side and on the technical side.</p><p>On the Business side:</p><div class="itemizedlist"><ul><li><p>Business rules are frequently defined based on the occurrence of
      scenarios triggered by events. Examples could be:</p><div class="itemizedlist"><ul><li><p>On an algorithmic trading application: take an action if the
          security price increases X% compared to the day opening price, where
          the price increases are usually denoted by events on a Stock Trade
          application.</p></li><li><p>On a monitoring application: take an action if the temperature
          on the server room increases X degrees in Y minutes, where sensor
          readings are usually denoted by events.</p></li></ul></div></li><li><p>Both business rules and event processing queries change frequently
      and require immediate response for the business to adapt itself to new
      market conditions, new regulations and new enterprise policies.</p></li></ul></div><p>From a technical perspective:</p><div class="itemizedlist"><ul><li><p>Both require seemless integration with the enterprise
      infrastructure and applications, specially on autonomous governance,
      including, but not limited to, lifecycle management, auditing, security,
      etc.</p></li><li><p>Both have functional requirements like pattern matching and
      non-functional requirements like response time and query/rule
      explanation.</p></li></ul></div><p>Even sharing requirements and goals, historically, both fields were
  born appart and although the industry evolved and one can find good products
  on the market, they either focus on event processing or on business rules
  management. That is due not only because of historical reasons but also
  because, even overlapping in part, use cases do have some different
  requirements.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Drools was also born as a rules engine several years ago, but
    following the vision of becoming a single platform for behavioral
    modelling, it soon realized that it could only achieve this goal by
    crediting the same importante to the three complementary business
    modelling techniques:</p><div class="itemizedlist"><ul><li><p>Business Rules Management</p></li><li><p>Business Processes Management</p></li><li><p>Complex Event Processing</p></li></ul></div></div><p>In this context, Drools Fusion is the module responsible for adding
  event processing capabilities into the platform. </p><p>Supporting Complex Event Processing, though, is much more than simply
  understanding what an event is. CEP scenarios share several common and
  distiguishing characteristics:</p><div class="itemizedlist"><ul><li><p>Usually required to process huge volumes of events, but only a
      small percentage of the events are of real interest.</p></li><li><p>Events are usually immutable, since they are a record of state
      change.</p></li><li><p>Usually the rules and queries on events must run in reactive
      modes, i.e., react to the detection of event patterns.</p></li><li><p>Usually there are strong temporal relationships between related
      events.</p></li><li><p>Individual events are usually not important. The system is
      concerned about patterns of related events and their
      relationships.</p></li><li><p>Usually, the system is required to perform composition and
      aggregation of events.</p></li></ul></div><p>Based on this general common characteristics, Drools Fusion defined a
  set of goals to be achieved in order to support Complex Event Processing
  appropriately:</p><div class="itemizedlist"><ul><li><p>Support Events, with their propper semantics, as first class
      citizens.</p></li><li><p>Allow detection, correlation, aggregation and composition of
      events.</p></li><li><p>Support processing of Streams of events.</p></li><li><p>Support temporal constraints in order to model the temporal
      relationships between events.</p></li><li><p>Support sliding windows of interesting events.</p></li><li><p>Support a session scoped unified clock.</p></li><li><p>Support the required volumes of events for CEP use cases.</p></li><li><p>Support to (re)active rules.</p></li><li><p>Support adapters for event input into the engine
      (pipeline).</p></li></ul></div><p>The above list of goals are based on the requirements not covered by
  Drools Expert itself, since in a unified platform, all features of one
  module are leveraged by the other modules. This way, Drools Fusion is born
  with enterprise grade features like Pattern Matching, that is paramount to a
  CEP product, but that is already provided by Drools Expert. In the same way,
  all features provided by Drools Fusion are leveraged by Drools Flow (and
  vice-versa) making process management aware of event processing and
  vice-versa.</p><p>For the remaining of this guide, we will go through each of the
  features Drools Fusion adds to the platform. All these features are
  available to support different use cases in the CEP world, and the user is
  free to select and use the ones that will help him model his business use
  case.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e172"/>Chapter 2. Drools Fusion Features</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e175">2.1. Events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e180">2.1.1. Event Semantics</a></span></dt><dt><span class="section"><a href="#d0e232">2.1.2. Event Declaration</a></span></dt><dt><span class="section"><a href="#d0e281">2.1.3. Event Metadata</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e443">2.2. Session Clock</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e474">2.2.1. Available Clock Implementations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e501">2.3. Streams Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e523">2.3.1. Declaring and Using Entry Points</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e558">2.4. Temporal Reasoning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e622">2.4.1. Temporal Operators</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1048">2.5. Event Processing Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1055">2.5.1. Cloud Mode</a></span></dt><dt><span class="section"><a href="#d0e1086">2.5.2. Stream Mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1159">2.6. Sliding Windows</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1169">2.6.1. Sliding Time Windows</a></span></dt><dt><span class="section"><a href="#d0e1189">2.6.2. Sliding Length Windows</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1209">2.7. Knowledgebase Partitioning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1224">2.7.1. When partitioning is useful</a></span></dt><dt><span class="section"><a href="#d0e1244">2.7.2. How to configure partitioning</a></span></dt><dt><span class="section"><a href="#d0e1260">2.7.3. Multithreading management</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1282">2.8. Memory Management for Events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1300">2.8.1. Explicit expiration offset</a></span></dt><dt><span class="section"><a href="#d0e1312">2.8.2. Inferred expiration offset</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e175"/>2.1. Events</h2></div></div></div><p>Events, from a Drools perspective are just a special type of fact. In
  this way, we can say that all events are facts, but not all facts are
  events. In the next few sections the specific differences that characterize
  an event are presented.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e180"/>2.1.1. Event Semantics</h3></div></div></div><p>An <span class="emphasis"><em>event</em></span> is a fact that present a few
  distinguishing characteristics:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Usually immutables:</strong></span> since, by the
      previously discussed definition, events are a record of a state change
      in the application domain, i.e., a record of something that already
      happened, and the past can not be "changed", events are immutables. This
      constraint is an important requirement for the development of several
      optimizations and for the specification of the event lifecycle. This
      does not mean that the java object representing the object must be
      immutable. Quite the contrary, the engine does not enforce immutability
      of the object model, because one of the most common usecases for rules
      is event data enrichment.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>As a best practice, the application is allowed to populate
        un-populated event attributes (to enrich the event with infered data),
        but already populated attributes should never be changed.</p></div></li><li><p><span class="bold"><strong>Strong temporal constraints:</strong></span>
      rules involving events usually require the correlation of multiple
      events, specially temporal correlations where events are said to happen
      at some point in time relative to other events.</p></li><li><p><span class="bold"><strong>Managed lifecycle:</strong></span> due to their
      immutable nature and the temporal constraints, events usually will only
      match other events and facts during a limited window of time, making it
      possible for the engine to manage the lifecycle of the events
      automatically. In other words, one an event is inserted into the working
      memory, it is possible for the engine to find out when an event can no
      longer match other facts and automatically retract it, releasing its
      associated resources.</p></li><li><p><span class="bold"><strong>Use of sliding windows:</strong></span> since all
      events have timestamps associated to them, it is possible to define and
      use sliding windows over them, allowing the creation of rules on
      aggregations of values over a period of time. Example: average of an
      event value over 60 minutes.</p></li></ul></div><p>Drools supports the declaration and usage of events with both
  semantics: <span class="bold"><strong>point-in-time</strong></span> events and
  <span class="bold"><strong>interval-based</strong></span> events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>A simplistic way to understand the unitification of the semantics is
    to consider a <span class="emphasis"><em>point-in-time</em></span> event as an
    <span class="emphasis"><em>interval-based</em></span> event whose <span class="emphasis"><em>duration is
    zero</em></span>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e232"/>2.1.2. Event Declaration</h3></div></div></div><p>To declare a fact type as an event, all it is required is to assign
  the @role metadata tag to the fact type. The @role metadata tag accepts two
  possible values:</p><div class="itemizedlist"><ul><li><p>fact : this is the default, declares that the type is to be
      handled as a regular fact.</p></li><li><p>event : declares that the type is to be handled as an
      event.</p></li></ul></div><p>For instance, the example bellow is declaring that the fact type
  StockTick in a stock broker application shall be handled as an event.</p><div class="example"><a id="d0e247"/><p class="title"><b>Example 2.1. declaring a fact type as an event</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> some.package.StockTick

<span class="bold"><strong>declare</strong></span> StockTick
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"/></p><p>The same applies to facts declared inline. So, if StockTick was a fact
  type declared in the DRL itself, instead of a previously existing class, the
  code would be:</p><div class="example"><a id="d0e266"/><p class="title"><b>Example 2.2. declaring a fact type and assiging it the event role</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> StockTick 
    <span class="emphasis"><em>@role</em></span>( event )

    datetime : java.util.Date
    symbol : String
    price : double
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"/>For more information on type declarations, please check the Rule
  Language section of the Drools Expert documentation.</p><p/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e281"/>2.1.3. Event Metadata</h3></div></div></div><p>All events have a set of metadata associated to them. Most of the
  metadata values have defaults that are automatically assigned to each event
  when they are inserted into the working memory, but it is possible to change
  the default on an event type basis, using the metadata tags listed
  bellow.</p><p>For the examples, lets assume the user has the following class in the
  application domain model:</p><div class="example"><a id="d0e288"/><p class="title"><b>Example 2.3. the VoiceCall fact class</b></p><div class="example-contents"><pre class="programlisting"><span class="emphasis"><em>/**
 * A class that represents a voice call in 
 * a Telecom domain model
 */</em></span>
<span class="bold"><strong>public class</strong></span> VoiceCall {
    <span class="bold"><strong>private</strong></span> String  originNumber;
    <span class="bold"><strong>private</strong></span> String  destinationNumber;
    <span class="bold"><strong>private</strong></span> Date    callDateTime;
    <span class="bold"><strong>private</strong></span> long    callDuration;          // in milliseconds

    // constructors, getters and setters
}
</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e310"/>2.1.3.1. @role</h4></div></div></div><p>The @role meta data was already discussed in the previous section
    and is presented here for completeness:</p><pre class="programlisting"><span class="emphasis"><em>@role</em></span>( &lt;fact|event&gt; )
</pre><p>It annotates a given fact type as either a regular fact or event. It
    accepts either "fact" or "event" as a parameter. Default is "fact".</p><div class="example"><a id="d0e321"/><p class="title"><b>Example 2.4. declaring VoiceCall as an event type</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"/><p/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e335"/>2.1.3.2. @timestamp</h4></div></div></div><p>Every event has an associated timestamp assigned to it. By default,
    the timestamp for a given event is read from the Session Clock and
    assigned to the event at the time the event is inserted into the working
    memory. Although, sometimes, the event has the timestamp as one of it's
    own attributes. In this case, the user may tell the engine to use the
    timestamp from the event's attribute instead of reading it from the
    Session Clock.</p><pre class="programlisting"><span class="emphasis"><em>@timestamp</em></span>( &lt;attributeName&gt; )</pre><p>To tell the engine what attribute to use as the source of the
    event's timestamp, just list the attribute name as a parameter to the
    @timestamp tag.</p><div class="example"><a id="d0e346"/><p class="title"><b>Example 2.5. declaring the VoiceCall timestamp attribute</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e362"/>2.1.3.3. @duration</h4></div></div></div><p>Drools supports both event semantics: point-in-time events and
    interval-based events. A point-in-time event is represented as an
    interval-based event whose duration is zero. By default, all events have
    duration zero. The user may attribute a different duration for an event by
    declaring which attribute in the event type contains the duration of the
    event.</p><pre class="programlisting"><span class="emphasis"><em>@duration</em></span>( &lt;attributeName&gt; )</pre><p>So, for our VoiceCall fact type, the declaration would be:</p><div class="example"><a id="d0e373"/><p class="title"><b>Example 2.6. declaring the VoiceCall duration attribute</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e391"/>2.1.3.4. @expires</h4></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>This tag is only considered when running the engine in STREAM
      mode. Also, additional discussion on the effects of using this tag is
      made on the Memory Management section. It is included here for
      completeness.</p></div><p>Events may be automatically expired after some time in the working
    memory. Typically this happens when, based on the existing rules in the
    knowledge base, the event can no longer match and activate any rules.
    Although, it is possible to explicitly define when an event should
    expire.</p><pre class="programlisting"><span class="emphasis"><em>@expires</em></span>( &lt;timeOffset&gt; )</pre><p>The value of <span class="emphasis"><em>timeOffset</em></span> is a temporal interval
    in the form:</p><pre class="programlisting">[#d][#h][#m][#s][#[ms]]</pre><p>Where <span class="emphasis"><em>[ ]</em></span> means an optional parameter and
    <span class="emphasis"><em>#</em></span> means a numeric value.</p><p>So, to declare that the VoiceCall facts should be expired after 1
    hour and 35 minutes after they are inserted into the working memory, the
    user would write:</p><div class="example"><a id="d0e421"/><p class="title"><b>Example 2.7. declaring the expiration offset for the VoiceCall
        events</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
    <span class="emphasis"><em>@expires</em></span>( 1h35m )
<span class="bold"><strong>end</strong></span></pre></div></div><p><br class="example-break"/></p><p/></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e443"/>2.2. Session Clock</h2></div></div></div><p>Reasoning over time requires a reference clock. Just to mention one
  example, if a rule reasons over the average price of a given stock over the
  last 60 minutes, how the engine knows what stock price changes happened over
  the last 60 minutes in order to calculate the average? The obvious response
  is: by comparing the timestamp of the events with the "current time". How
  the engine knows what <span class="bold"><strong>time is now</strong></span>? Again,
  obviously, by querying the Session Clock.</p><p>The session clock implements a strategy pattern, allowing different
  types of clocks to be plugged and used by the engine. This is very important
  because the engine may be running in an array of different scenarios that
  may require different clock implementations. Just to mention a few:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Rules testing:</strong></span> testing always
      requires a controled environment, and when the tests include rules with
      temporal constraints, it is necessary to not only control the input
      rules and facts, but also the flow of time.</p></li><li><p><span class="bold"><strong>Regular execution:</strong></span> usually, when
      running rules in production, the application will require a real time
      clock that allows the rules engine to react immediately to the time
      progression.</p></li><li><p><span class="bold"><strong>Special environments:</strong></span> specific
      environments may have specific requirements on time control. Cluster
      environments may require clock synchronization through heart beats, or
      JEE environments may require the use of an AppServer provided clock,
      etc.</p></li><li><p><span class="bold"><strong>Rules replay or simulation: </strong></span>to
      replay scenarios or simulate scenarios it is necessary that the
      application also controls the flow of time.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e474"/>2.2.1. Available Clock Implementations</h3></div></div></div><p>Drools 5 provides 2 clock implementations out of the box. The default
  real time clock, based on the system clock, and an optional pseudo clock,
  controlled by the application.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e479"/>2.2.1.1. Real Time Clock</h4></div></div></div><p>By default, Drools uses a real time clock implementation that
    internally uses the system clock to determine the current
    timestamp.</p><p>To explicitly configure the engine to use the real time clock, just
    set the session configuration parameter to real time:</p><pre class="programlisting">KnowledgeSessionConfiguration config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e488"/>2.2.1.2. Pseudo Clock</h4></div></div></div><p>Drools also offers out of the box an implementation of a clock that
    is controlled by the application that is called Pseudo Clock. This clock
    is specially useful for unit testing temporal rules since it can be
    controled by the application and so the results become
    deterministic.</p><p>To configure the pseudo session clock, do:</p><pre class="programlisting">KnowledgeSessionConfiguration config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );</pre><p>As an example of how to control the pseudo session clock:</p><pre class="programlisting">KnowledgeSessionConfiguration conf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
conf.setOption( ClockTypeOption.get( "pseudo" ) );
StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession( conf, null );
        
SessionPseudoClock clock = session.getSessionClock();

// then, while inserting facts, advance the clock as necessary:
FactHandle handle1 = session.insert( tick1 );
clock.advanceTime( 10, TimeUnit.SECONDS );
FactHandle handle2 = session.insert( tick2 );
clock.advanceTime( 30, TimeUnit.SECONDS );
FactHandle handle3 = session.insert( tick3 );

</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e501"/>2.3. Streams Support</h2></div></div></div><p>Most CEP use cases have to deal with streams of events. The streams
  can be provided to the application in various forms, from JMS queues to flat
  text files, from database tables to raw sockets or even through web service
  calls. In any case, the streams share a common set of
  characteristics:</p><div class="itemizedlist"><ul><li><p>events in the stream are ordered by a timestamp. The timestamp may
      have different semantics for different streams but they are always
      ordered internally.</p></li><li><p>volumes of events are usually high.</p></li><li><p>atomic events are rarely useful by themselves. Usually meaning is
      extracted from the correlation between multiple events from the stream
      and also from other sources.</p></li><li><p>streams may be homogeneous, i.e. contain a single type of events,
      or heterogeneous, i.e. contain multiple types of events.</p></li></ul></div><p>Drools generalized the concept of a stream as an "entry point" into
  the engine. An entry point is for drools a gate from which facts come. The
  facts may be regular facts or special facts like events.</p><p>In Drools, facts from one entry point (stream) may join with facts
  from any other entry point or event with facts from the working memory.
  Although, they never mix, i.e., they never lose the reference to the entry
  point through which they entered the engine. This is important because one
  may have the same type of facts coming into the engine through several entry
  points, but one fact that is inserted into the engine through entry point A
  will never match a pattern from a entry point B, for example.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e523"/>2.3.1. Declaring and Using Entry Points</h3></div></div></div><p>Entry points are declared implicitly in Drools by directly making use
  of them in rules. I.e. referencing an entry point in a rule will make the
  engine, at compile time, to identify and create the proper internal
  structures to suppor that entry point. </p><p>So, for instance, lets imagine a banking application, where
  transactions are fed into the system coming from streams. One of the streams
  contains all the transactions executed in ATM machines. So, if one of the
  rules says: a withdraw is authorized if and only if the account balance is
  over the requested withdraw amount, the rule would look like:</p><div class="example"><a id="d0e531"/><p class="title"><b>Example 2.8. Example of Stream Usage</b></p><div class="example-contents"><pre class="programlisting">rule "authorize withdraw"
when
    WithdrawRequest( $ai : accountId, $am : amount ) from entry-point "ATM Stream"
    CheckingAccount( accountId == $ai, balance &gt; $am )
then
    // authorize withdraw
end
</pre></div></div><p><br class="example-break"/>In the previous example, the engine compiler will identify that
  the pattern is tied to the entry point "ATM Stream" and will both create all
  the necessary structures for the rulebase to support the "ATM Stream" and
  will only match WithdrawRequests coming from the "ATM Stream". In the
  previous example, the rule is also joining the event from the stream with a
  fact from the main working memory (CheckingAccount).</p><p>Now, lets imagine a second rule that states that a fee of $2 must be
  applied to any account for which a withdraw request is placed at a bank
  branch:</p><div class="example"><a id="d0e540"/><p class="title"><b>Example 2.9. Using a different Stream</b></p><div class="example-contents"><pre class="programlisting">rule "apply fee on withdraws on branches"
when
    WithdrawRequest( $ai : accountId, processed == true ) from entry-point "Branch Stream"
    CheckingAccount( accountId == $ai )
then
    // apply a $2 fee on the account
end
</pre></div></div><p><br class="example-break"/>The previous rule will match events of the exact same type as
  the first rule (WithdrawRequest), but from two different streams, so an
  event inserted into "ATM Stream" will never be evaluated against the pattern
  on the second rule, because the rule states that it is only interested in
  patterns coming from the "Branch Stream".</p><p>So, entry points, besides being a proper abstraction for streams, are
  also a way to scope facts in the working memory, and a valuable tool for
  reducing cross products explosions. But that is a subject for another
  time.</p><p>Inserting events into an entry point is equally simple. Instead of
  inserting events directly into the working memory, insert them into the
  entry point as shown in the example bellow:</p><div class="example"><a id="d0e551"/><p class="title"><b>Example 2.10. Inserting facts into an entry point</b></p><div class="example-contents"><pre class="programlisting">// create your rulebase and your session as usual
StatefulKnowledgeSession session = ...

// get a reference to the entry point
WorkingMemoryEntryPoint atmStream = session.getWorkingMemoryEntryPoint( "ATM Stream" );

// and start inserting your facts into the entry point
atmStream.insert( aWithdrawRequest );
</pre></div></div><p><br class="example-break"/></p><p>The previous example shows how to manually insert facts into a given
  entry point. Although, usually, the application will use one of the many
  adapters to plug a stream end point, like a JMS queue, directly into the
  engine entry point, without coding the inserts manually. The Drools pipeline
  API has several adapters and helpers to do that as well as examples on how
  to do it.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e558"/>2.4. Temporal Reasoning</h2></div></div></div><p>Temporal reasoning is another requirement of any CEP system. As
  discussed previously, one of the distinguishing characteristics of events is
  their strong temporal relationships.</p><p>Temporal reasoning is an extensive field of research, from its roots
  on Temporal Modal Logic to its more practical applications in business
  systems. There are hundreds of papers and thesis written and approches are
  described for several applications. Drools once more takes a pragmatic and
  simple approach based on several sources, but specially worth noting the
  following papers:</p><div class="bibliolist"><div class="biblioentry"><a id="d0e567"/><p>[<abbr class="abbrev">ALLEN81</abbr>] <span class="author">Allen, J.F.. </span><span class="title"><i>An Interval-based Representation of Temporal Knowledge</i>. </span><span class="pubdate">1981. </span></p></div><div class="biblioentry"><a id="d0e578"/><p>[<abbr class="abbrev">ALLEN83</abbr>] <span class="author">Allen, J.F.. </span><span class="title"><i>Maintaining knowledge about temporal intervals</i>. </span><span class="pubdate">1983. </span></p></div><div class="biblioentry"><a id="d0e589"/><p>[<abbr class="abbrev">BENNE00</abbr>] <span class="authorgroup">. </span><span class="title"><i>A Unifying Semantics for Time and Events</i>. </span><span class="pubdate">2005. </span></p></div><div class="biblioentry"><a id="d0e604"/><p>[<abbr class="abbrev">YONEK05</abbr>] <span class="authorgroup">. </span><span class="title"><i>Unified Semantics for Event Correlation Over Time and Space in
      Hybrid Network Environments</i>. </span><span class="pubdate">2005. </span></p></div></div><div class="blockquote"><blockquote class="blockquote"/></div><p>Drools implements the Interval-based Time Event Semantics described by
  Allen, and represents Point-in-Time Events as Interval-based evens with
  duration 0 (zero).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e622"/>2.4.1. Temporal Operators</h3></div></div></div><p>Drools implements all 13 operators defined by Allen and also their
  logical complement (negation). This section details each of the operators
  and their parameters.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e627"/>2.4.1.1. After</h4></div></div></div><p>The after evaluator correlates two events and matches when the
    temporal distance from the current event to the event being correlated
    belongs to the distance range declared for the operator. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this after[ 3m30s, 4m ] $eventB ) </pre><p>The previous pattern will match if and only if the temporal distance
    between the time when $eventB finished and the time when $eventA started
    is between ( 3 minutes and 30 seconds ) and ( 4 minutes ). In other
    words:</p><pre class="programlisting"> 3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m </pre><p>The temporal distance interval for the after operator is optional:
    </p><div class="itemizedlist"><ul><li><p>If two values are defined (like in the example bellow), the
        interval starts on the first value and finishes on the second. </p></li><li><p>If only one value is defined, the interval starts on the value
        and finishes on the positive infinity. </p></li><li><p>If no value is defined, it is assumed that the initial value is
        1ms and the final value is the positive infinity. </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>It is possible to define negative distances for this operator.
      Example: </p><pre class="programlisting">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) </pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If the first value is greater than the second value, the engine
      automatically reverses them, as there is no reason to have the first
      value greater than the second value. Example: the following two patterns
      are considered to have the same semantics: </p><pre class="programlisting">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this after[ -2m, -3m30s ] $eventB ) </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e662"/>2.4.1.2. Before</h4></div></div></div><p>The before evaluator correlates two events and matches when the
    temporal distance from the event being correlated to the current
    correlated belongs to the distance range declared for the operator.
    </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this before[ 3m30s, 4m ] $eventB ) </pre><p>The previous pattern will match if and only if the temporal distance
    between the time when $eventA finished and the time when $eventB started
    is between ( 3 minutes and 30 seconds ) and ( 4 minutes ). In other
    words:</p><pre class="programlisting"> 3m30s &lt;= $eventB.startTimestamp - $eventA.endTimeStamp &lt;= 4m </pre><p>The temporal distance interval for the before operator is optional:
    </p><div class="itemizedlist"><ul><li><p>If two values are defined (like in the example bellow), the
        interval starts on the first value and finishes on the second. </p></li><li><p>If only one value is defined, then the interval starts on the
        value and finishes on the positive infinity. </p></li><li><p>If no value is defined, it is assumed that the initial value is
        1ms and the final value is the positive infinity.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>It is possible to define negative distances for this operator.
      Example: </p><pre class="programlisting">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) </pre></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If the first value is greater than the second value, the engine
      automatically reverses them, as there is no reason to have the first
      value greater than the second value. Example: the following two patterns
      are considered to have the same semantics: </p><pre class="programlisting">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this before[ -2m, -3m30s ] $eventB ) </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e697"/>2.4.1.3. Coincides</h4></div></div></div><p>The coincides evaluator correlates two events and matches when both
    happen at the same time. Optionally, the evaluator accept thresholds for
    the distance between events' start and finish timestamps. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this coincides $eventB ) </pre><p>The previous pattern will match if and only if the start timestamps
    of both $eventA and $eventB are the same AND the end timestamp of both
    $eventA and $eventB also are the same. </p><p>Optionally, this operator accepts one or two parameters. These
    parameters are the thresholds for the distance between matching
    timestamps. </p><div class="itemizedlist"><ul><li><p>If only one paratemer is given, it is used for both start and
        end timestamps.</p></li><li><p>If two parameters are given, then the first is used as a
        threshold for the start timestamp and the second one is used as a
        threshold for the end timestamp.</p></li></ul></div><p>In other words: </p><pre class="programlisting">$eventA : EventA( this coincides[15s, 10s] $eventB ) </pre><p>Above pattern will match if and only if: </p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 15s &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 10s </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use negative interval values for the
      parameters and the engine will raise an error if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e728"/>2.4.1.4. During</h4></div></div></div><p>The during evaluator correlates two events and matches when the
    current event happens during the occurrence of the event being correlated.
    </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this during $eventB ) </pre><p>The previous pattern will match if and only if the $eventA starts
    after $eventB starts and finishes before $eventB finishes. </p><p>In other words: </p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt;= $eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>The during operator accepts 1, 2 or 4 optional parameters as follow:
    </p><div class="itemizedlist"><ul><li><p>If one value is defined, this will be the maximum distance
        between the start timestamp of both event and the maximum distance
        between the end timestamp of both events in order to operator match.
        Example:</p><pre class="programlisting">$eventA : EventA( this during[ 5s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">0 &lt; $eventA.startTimestamp - $eventB.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventB.endTimestamp - $eventA.endTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If two values are defined, the first value will be the minimum
        distance between the timestamps of both events, while the second value
        will be the maximum distance between the timestamps of both events.
        Example: </p><pre class="programlisting">$eventA : EventA( this during[ 5s, 10s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">5s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If four values are defined, the first two values will be the
        minimum and maximum distances between the start timestamp of both
        events, while the last two values will be the minimum and maximum
        distances between the end timestamp of both events. Example:</p><pre class="programlisting">$eventA : EventA( this during[ 2s, 6s, 4s, 10s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">2s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e775"/>2.4.1.5. Finishes</h4></div></div></div><p>The finishes evaluator correlates two events and matches when the
    current event's start timestamp happens after the correlated event's start
    timestamp, but both end timestamps occur at the same time. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this finishes $eventB ) </pre><p>The previous pattern will match if and only if the $eventA starts
    after $eventB starts and finishes at the same time $eventB finishes.
    </p><p>In other words: </p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </pre><p>The finishes evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    both events in order for the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this finishes[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e801"/>2.4.1.6. Finished By</h4></div></div></div><p>The finishedby evaluator correlates two events and matches when the
    current event start timestamp happens before the correlated event start
    timestamp, but both end timestamps occur at the same time. This is the
    symmetrical opposite of finishes evaluator. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this finishedby $eventB ) </pre><p>The previous pattern will match if and only if the $eventA starts
    before $eventB starts and finishes at the same time $eventB finishes.
    </p><p>In other words: </p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </pre><p>The finishedby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    both events in order for the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this finishedby[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e827"/>2.4.1.7. Includes</h4></div></div></div><p>The includes evaluator correlates two events and matches when the
    event being correlated happens during the current event. It is the
    symmetrical opposite of during evaluator. </p><p>Lets look at an example:</p><pre class="programlisting">$eventA : EventA( this includes $eventB ) </pre><p>The previous pattern will match if and only if the $eventB starts
    after $eventA starts and finishes before $eventA finishes. </p><p>In other words: </p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt;= $eventB.endTimestamp &lt; $eventA.endTimestamp </pre><p>The includes operator accepts 1, 2 or 4 optional parameters as
    follow: </p><div class="itemizedlist"><ul><li><p>If one value is defined, this will be the maximum distance
        between the start timestamp of both event and the maximum distance
        between the end timestamp of both events in order to operator match.
        Example:</p><pre class="programlisting">$eventA : EventA( this includes[ 5s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">0 &lt; $eventB.startTimestamp - $eventA.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventA.endTimestamp - $eventB.endTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If two values are defined, the first value will be the minimum
        distance between the timestamps of both events, while the second value
        will be the maximum distance between the timestamps of both events.
        Example:</p><pre class="programlisting">$eventA : EventA( this includes[ 5s, 10s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">5s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If four values are defined, the first two values will be the
        minimum and maximum distances between the start timestamp of both
        events, while the last two values will be the minimum and maximum
        distances between the end timestamp of both events. Example:</p><pre class="programlisting">$eventA : EventA( this includes[ 2s, 6s, 4s, 10s ] $eventB )</pre><p>Will match if and only if: </p><pre class="programlisting">2s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s </pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e874"/>2.4.1.8. Meets</h4></div></div></div><p>The meets evaluator correlates two events and matches when the
    current event's end timestamp happens at the same time as the correlated
    event's start timestamp. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this meets $eventB ) </pre><p>The previous pattern will match if and only if the $eventA finishes
    at the same time $eventB starts.</p><p>In other words: </p><pre class="programlisting">abs( $eventB.startTimestamp - $eventA.endTimestamp ) == 0 </pre><p>The meets evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    current event and the start timestamp of the correlated event in order for
    the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this meets[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">abs( $eventB.startTimestamp - $eventA.endTimestamp) &lt;= 5s </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e900"/>2.4.1.9. Met By</h4></div></div></div><p>The metby evaluator correlates two events and matches when the
    current event's start timestamp happens at the same time as the correlated
    event's end timestamp. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this metby $eventB ) </pre><p>The previous pattern will match if and only if the $eventA starts at
    the same time $eventB finishes. </p><p>In other words: </p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.endTimestamp ) == 0 </pre><p>The metby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the end timestamp of
    the correlated event and the start timestamp of the current event in order
    for the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this metby[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.endTimestamp) &lt;= 5s </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e926"/>2.4.1.10. Overlaps</h4></div></div></div><p>The overlaps evaluator correlates two events and matches when the
    current event starts before the correlated event starts and finishes after
    the correlated event starts, but before the correlated event finishes. In
    other words, both events have an overlapping period. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this overlaps $eventB ) </pre><p>The previous pattern will match if and only if: </p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>The overlaps operator accepts 1 or 2 optional parameters as
    follow:</p><div class="itemizedlist"><ul><li><p>If one parameter is defined, this will be the maximum distance
        between the start timestamp of the correlated event and the end
        timestamp of the current event. Example:</p><pre class="programlisting">$eventA : EventA( this overlaps[ 5s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
0 &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If two values are defined, the first value will be the minimum
        distance and the second value will be the maximum distance between the
        start timestamp of the correlated event and the end timestamp of the
        current event. Example:</p><pre class="programlisting">$eventA : EventA( this overlaps[ 5s, 10s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 10s </pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e961"/>2.4.1.11. Overlapped By</h4></div></div></div><p>The overlappedby evaluator correlates two events and matches when
    the correlated event starts before the current event starts and finishes
    after the current event starts, but before the current event finishes. In
    other words, both events have an overlapping period. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this overlappedby $eventB ) </pre><p>The previous pattern will match if and only if: </p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp </pre><p>The overlappedby operator accepts 1 or 2 optional parameters as
    follow: </p><div class="itemizedlist"><ul><li><p>If one parameter is defined, this will be the maximum distance
        between the start timestamp of the current event and the end timestamp
        of the correlated event. Example: </p><pre class="programlisting">$eventA : EventA( this overlappedby[ 5s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
0 &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>If two values are defined, the first value will be the minimum
        distance and the second value will be the maximum distance between the
        start timestamp of the current event and the end timestamp of the
        correlated event. Example: </p><pre class="programlisting">$eventA : EventA( this overlappedby[ 5s, 10s ] $eventB )</pre><p>Will match if and only if:</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 10s</pre></li></ul></div><p> </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e998"/>2.4.1.12. Starts</h4></div></div></div><p>The starts evaluator correlates two events and matches when the
    current event's end timestamp happens before the correlated event's end
    timestamp, but both start timestamps occur at the same time. </p><p>Lets look at an example: </p><pre class="programlisting">$eventA : EventA( this starts $eventB ) </pre><p>The previous pattern will match if and only if the $eventA finishes
    before $eventB finishes and starts at the same time $eventB starts.
    </p><p>In other words: </p><pre class="programlisting">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>The starts evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the start timestamp of
    both events in order for the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this starts[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1024"/>2.4.1.13. Started By</h4></div></div></div><p>The startedby evaluator correlates two events and matches when the
    correlating event's end timestamp happens before the current event's end
    timestamp, but both start timestamps occur at the same time. Lets look at
    an example: </p><pre class="programlisting">$eventA : EventA( this startedby $eventB ) </pre><p>The previous pattern will match if and only if the $eventB finishes
    before $eventA finishes and starts at the same time $eventB starts.
    </p><p>In other words: </p><pre class="programlisting">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </pre><p>The startedby evaluator accepts one optional parameter. If it is
    defined, it determines the maximum distance between the start timestamp of
    both events in order for the operator to match. Example: </p><pre class="programlisting">$eventA : EventA( this starts[ 5s ] $eventB ) </pre><p>Will match if and only if: </p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>It makes no sense to use a negative interval value for the
      parameter and the engine will raise an exception if that happens.</p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1048"/>2.5. Event Processing Modes</h2></div></div></div><p>Rules engines in general have a well known way of processing data and
  rules and provide the application with the results. Also, there is not many
  requirements on how facts should be presented to the rules engine, specially
  because in general, the processing itself is time independent. That is a
  good assumption for most scenarios, but not for all of them. When the
  requirements include the processing of real time or near real time events,
  time becomes and important variable of the reasoning process.</p><p>The following sections will explain the impact of time on rules
  reasoning and the two modes provided by Drools for the reasoning process.
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1055"/>2.5.1. Cloud Mode</h3></div></div></div><p>The CLOUD processing mode is the default processing mode. Users of
  rules engine are familiar with this mode because it behaves in exactly the
  same way as any pure forward chaining rules engine, including previous
  versions of Drools.</p><p>When running in CLOUD mode, the engine sees all facts in the working
  memory, does not matter if they are regular facts or events, as a whole.
  There is no notion of flow of time, although events have a timestamp as
  usual. In other words, although the engine knows that a given event was
  created, for instance, on January 1st 2009, at 09:35:40.767, it is not
  possible for the engine to determine how "old" the event is, because there
  is no concept of "now".</p><p>In this mode, the engine will apply its usual many-to-many pattern
  matching algorithm, using the rules constraints to find the matching tuples,
  activate and fire rules as usual.</p><p>This mode does not impose any kind of additional requirements on
  facts. So for instance:</p><div class="itemizedlist"><ul><li><p>There is no notion of time. No requirements clock synchronization.
      </p></li><li><p>There is no requirement on event ordering. The engine looks at the
      events as an unnordered cloud against which the engine tries to match
      rules.</p></li></ul></div><p>On the other hand, since there is no requirements, some benefits are
  not available either. For instance, in CLOUD mode, it is not possible to use
  sliding windows, because sliding windows are based on the concept of "now"
  and there is no concept of "now" in CLOUD mode. </p><p>Since there is no ordering requirement on events, it is not possible
  for the engine to determine when events can no longer match and as so, there
  is no automatic life-cycle management for events. I.e., the application must
  explicitly retract events when they are no longer necessary, in the same way
  the application does with regular facts.</p><p>Cloud mode is the default execution mode for Drools, but in any case,
  as any other configuration in Drools, it is possible to change this behavior
  either by setting a system property, using configuration property files or
  using the API. The corresponding property is:</p><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( EventProcessingOption.CLOUD );</pre><p>The equivalent property is:</p><pre class="programlisting">drools.eventProcessingMode = cloud</pre><p/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1086"/>2.5.2. Stream Mode</h3></div></div></div><p>The STREAM processing mode is the mode of choice when the application
  needs to process streams of events. It adds a few common requirements to the
  regular processing, but enables a whole lot of features that make stream
  event processing a lot simpler.</p><p>The main requirements to use STREAM mode are:</p><div class="itemizedlist"><ul><li><p>Events in each stream must be time-ordered. I.e., inside a given
      stream, events that happened first must be inserted first into the
      engine.</p></li><li><p>The engine will force synchronization between streams through the
      use of the session clock, so, although the application does not need to
      enforce time ordering between streams, the use of non-time-synchronized
      streams may result in some unexpected results.</p></li></ul></div><p>Given that the above requirements are met, the application may enable
  the STREAM mode using the following API:</p><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( EventProcessingOption.STREAM );</pre><p>Or, the equivalent property: </p><pre class="programlisting">drools.eventProcessingMode = stream</pre><p>When using the STREAM, the engine knows the concept of flow of time
  and the concept of "now", i.e., the engine understands how old events are
  based on the current timestamp read from the Session Clock. This
  characteristic allows the engine to provide the following additional
  features to the application:</p><div class="itemizedlist"><ul><li><p>Sliding Window support</p></li><li><p>Automatic Event Lifecycle Management</p></li><li><p>Automatic Rule Delaying when using Negative Patterns</p></li></ul></div><p>All these features are explained in the following sections.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1122"/>2.5.2.1. Role of Session Clock in Stream mode</h4></div></div></div><p>When running the engine in CLOUD mode, the session clock is used
    only to time stamp the arriving events that don't have a previously
    defined timestamp attribute. Although, in STREAM mode, the Session Clock
    assumes an even more important role.</p><p>In STREAM mode, the session clock is responsible for keeping the
    current timestamp, and based on it, the engine does all the temporal
    calculations on event's aging, synchronizes streams from multiple sources,
    schedules future tasks and so on.</p><p>Check the documentation on the Session Clock section to know how to
    configure and use different session clock implementations.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1131"/>2.5.2.2. Negative Patterns in Stream Mode</h4></div></div></div><p>Negative patterns behave different in STREAM mode when compared to
    CLOUD mode. In CLOUD mode, the engine assumes that all facts and events
    are known in advance (there is no concept of flow of time) and so,
    negative patterns are evaluated immediately.</p><p>When running in STREAM mode, negative patterns with temporal
    constraints may require the engine to wait for a time period before
    activating a rule. The time period is automatically calculated by the
    engine in a way that the user does not need to use any tricks to achieve
    the desired result.</p><p>For instance:</p><div class="example"><a id="d0e1141"/><p class="title"><b>Example 2.11. a rule that activates immediately upon matching</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( ) )
then
    // sound the alarm
end
</pre></div></div><p><br class="example-break"/>The above rule has no temporal constraints that would require
    delaying the rule, and so, the rule activates immediately. The following
    rule on the other hand, must wait for 10 seconds before activating, since
    it may take up to 10 seconds for the sprinklers to activate:</p><div class="example"><a id="d0e1148"/><p class="title"><b>Example 2.12. a rule that automatically delays activation due to temporal
        constraints</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break"/>This behaviour allows the engine to keep consistency when
    dealing with negative patterns and temporal constraints at the same time.
    The above would be the same as writing the rule as bellow, but does not
    burden the user to calculate and explicitly write the appropriate duration
    parameter:</p><div class="example"><a id="d0e1154"/><p class="title"><b>Example 2.13. same rule with explicit duration parameter</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
    duration( 10s )
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break"/></p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1159"/>2.6. Sliding Windows</h2></div></div></div><p>Sliding Window is a way to scope the events of interest as a the ones
  belonging to a window that is constantly moving. The two most common sliding
  window implementations are time based windows and length based windows.
  </p><p>The next sections will detail each of them.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Sliding Windows are only available when running the engine in STREAM
    mode. Check the Event Processing Mode section for details on how the
    STREAM mode works.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1169"/>2.6.1. Sliding Time Windows</h3></div></div></div><p>Sliding Time Windows allow the user to write rules that will only
  match events occurring in the last X time units. </p><p>For instance, if the user wants to consider only the Stock Ticks that
  happened in the last 2 minutes, the pattern would look like this:</p><pre class="programlisting">StockTick() over window:time( 2m )</pre><p>Drools uses the "over" keyword to associate windows to patterns.
  </p><p>On a more elaborate example, if the user wants to sound an alarm in
  case the average temperature over the last 10 minutes read from a sensor is
  above the threshold value, the rule would look like:</p><div class="example"><a id="d0e1183"/><p class="title"><b>Example 2.14. aggregating values over time windows</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:time( 10m ),
        average( $temp ) )
then
    // sound the alarm
end
</pre></div></div><p><br class="example-break"/>The engine will automatically discard any SensorReading older
  than 10 minutes and keep the calculated average consistent.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1189"/>2.6.2. Sliding Length Windows</h3></div></div></div><p>Sliding Length Windows work the same way as Time Windows, but discard
  events based on the arrival of new events instead of flow of time.</p><p>For instance, if the user wants to consider only the last 10 IBM Stock
  Ticks, independent of how old they are, the pattern would look like
  this:</p><pre class="programlisting">StockTick( company == "IBM" ) over window:length( 10 )</pre><p>As you can see, the pattern is similar to the one presented in the
  previous section, but instead of using window:time to define the sliding
  window, it uses window:length.</p><p>Using a similar example to the one in the previous section, if the
  user wants to sound an alarm in case the average temperature over the last
  100 readings from a sensor is above the threshold value, the rule would look
  like:</p><div class="example"><a id="d0e1203"/><p class="title"><b>Example 2.15. aggregating values over length windows</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:length( 100 ),
        average( $temp ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break"/>The engine will keep only the last 100 readings.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1209"/>2.7. Knowledgebase Partitioning</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>This is an experimental feature, subject to changes in the
    future.</p></div><p>The classic Rete algorithm is usually executed using a single thread.
  Although, as confirmed in several opportunities by Dr. Forgy, the algorithm
  itself is parallelizable. Drools implementation of the ReteOO algorithm
  supports coarse grained parallelization through rulebase
  partitioning.</p><p>When this option is enabled, the rulebase will be partitioned in
  several independent partitions and a pool of worker threads will be used to
  propagate facts through the partitions. The implementation guarantees that
  at most one worker thread will be executing tasks for a given partition, but
  multiple partitions may be "active" at a single point in time.</p><p>Everything should be transparent to the user, except that all working
  memory actions (insert/retract/modify) are executed assynchronously.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>This feature enables parallel LHS evaluation, but does not change
    the behavior of rule firing. I.e., rules will continue to fire
    sequentially, according to the conflict resolution strategy.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1224"/>2.7.1. When partitioning is useful</h3></div></div></div><p>Knowledge base partitioning is a very powerful feature for specific
    scenarios, but it is not a general case solution. To understand if this
    feature would be useful for a given scenario, the user may follow the
    checklist bellow:</p><div class="orderedlist"><ol type="1"><li><p>Does your hardware contains multiple processors?</p></li><li><p>Does your knowledge session process a high volume of
        facts?</p></li><li><p>Are the LHS of your rules expensive to evaluate? (ex: use
        expensive "from" expressions)</p></li><li><p>Does your knowledge base contains hundreds or more rules?</p></li></ol></div><p>If the answer to all the questions above is "yes", then this feature
    will probably increase the overall performance of your rulebase
    evaluation. </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1244"/>2.7.2. How to configure partitioning</h3></div></div></div><p>To enable knowledge base partitioning, set the following
    option:</p><div class="example"><a id="d0e1249"/><p class="title"><b>Example 2.16. enabling multithread evaluation (partitioning)</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( MultithreadEvaluationOption.YES );
</pre></div></div><br class="example-break"/><p>The equivalent property is:</p><pre class="programlisting">drools.multithreadEvaluation = &lt;true|false&gt;</pre><p>The default value for this option is "false" (disabled).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1260"/>2.7.3. Multithreading management</h3></div></div></div><p>Drools offers a simple configuration option for users to control the
    size of the worker thread's pool.</p><p>To define the maximum size for the thread pool, the user may use the
    following configuration option:</p><div class="example"><a id="d0e1268"/><p class="title"><b>Example 2.17. setting the maximum number of threads for rule evaluation to
        5</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( MaxThreadsOption.get(5) );
</pre></div></div><p><br class="example-break"/></p><p>The equivalent property is:</p><pre class="programlisting">drools.maxThreads = &lt;-1|1..n&gt;</pre><p>The default value for this configuration is 3 and a negative number
    means the engine will try to spawn as many threads as there are partitions
    in the rulebase.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>It is usually dangerous to set this option with a negative number.
      Always set it with a sensible positive number of threads.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1282"/>2.8. Memory Management for Events</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>The automatic memory management for events is only performed when
    running the engine in STREAM mode. Check the Event Processing Mode section
    for details on how the STREAM mode works.</p></div><p>One of the benefits of running the engine in STREAM mode is that the
  engine can detect when an event can no longer match any rule due to its
  temporal constraints. When that happens, the engine can safely retract the
  event from the session without side effects and release any resources used
  by that event.</p><p>There are basically 2 ways for the engine to calculate the matching
  window for a given event:</p><div class="itemizedlist"><ul><li><p>explicitly, using the expiration policy</p></li><li><p>implicitly, analyzing the temporal constraints on events</p></li></ul></div><p/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1300"/>2.8.1. Explicit expiration offset</h3></div></div></div><p>The first way of allowing the engine to calculate the window of
  interest for a given event type is by explicitly setting it. To do that,
  just use the declare statement and define an expiration for the fact
  type:</p><div class="example"><a id="d0e1306"/><p class="title"><b>Example 2.18. explicitly defining an expiration offset of 30 minutes for
      StockTick events</b></p><div class="example-contents"><pre class="programlisting">declare StockTick
    @expires( 30m )
end
</pre></div></div><p><br class="example-break"/>The above example declares an expiration offset of 30 minutes
  for StockTick events. After that time, assuming no rule still needs the
  event, the engine will expire and remove the event from the session
  automatically.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1312"/>2.8.2. Inferred expiration offset</h3></div></div></div><p>Another way for the engine to calculate the expiration offset for a
  given event is implicitly, by analyzing the temporal constraints in the
  rules. For instance, given the following rule:</p><div class="example"><a id="d0e1318"/><p class="title"><b>Example 2.19. example rule with temporal constraints</b></p><div class="example-contents"><pre class="programlisting">rule "correlate orders"
when
    $bo : BuyOrderEvent( $id : id ) 
    $ae : AckEvent( id == $id, this after[0,10s] $bo )
then
    // do something
end
</pre></div></div><p><br class="example-break"/>Analyzing the above rule, the engine automatically calculates
  that whenever a BuyOrderEvent matches, it needs to store it for up to 10
  seconds to wait for matching AckEvent's. So, the implicit expiration offset
  for BuyOrderEvent will be 10 seconds. AckEvent, on the other hand, can only
  match existing BuyOrderEvent's, and so its expiration offset will be zero
  seconds.</p><p>The engine will make this analysis for the whole rulebase and find the
  offset for every event type. Whenever an implicit expiration offset clashes
  with the explicit expiration offset, then engine will use the greater of the
  two.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1326"/>Chapter 3. References</h2></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1329"/>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3>C</h3><dl><dt>Complex Event Processing, <a class="indexterm" href="#d0e16">Complex Event Processing</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>Event, <a class="indexterm" href="#d0e16">Complex Event Processing</a></dt></dl></div></div></div></div></body></html>