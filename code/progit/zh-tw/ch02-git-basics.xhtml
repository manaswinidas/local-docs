<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git 基礎</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git 基礎" epub:type="chapter" id="ch02-git-basics">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>基礎</b></small></h1>
</div>
</header>
<div class="abstract" epub:type="preamble">
<p>假如您只能閱讀一章來學習 Git，那麼這個章節就是您的不二選擇。
本章節涵蓋你以後使用 Git 來完成絕大多數工作時，最常被使用的基本指令。
在讀完本章節後，你應該有能力設定及初始化一個倉儲（repository）、開始及停止追蹤檔案（track）、預存（stage）及提交（commit）更新。
本章還會提到如何讓 Git 忽略某些檔案和檔案匹配（patterns）、如何迅速而簡單地撤銷錯誤操作、如何瀏覽你專案的歷史版本及觀看不同提交（commits）之間的變更、以及如何將更新推送（push）至遠端倉儲或從遠端倉儲拉取（pull）提交。</p>
</div>
<section class="sect1" title="取得一個 Git 倉儲">
<h2 id="r_getting_a_repo">取得一個 Git 倉儲</h2>
<p>你有兩種主要方法來取得一個 Git 倉儲。
第一種是將現有的專案或者資料夾匯入 Git；
第二種是從其它伺服器克隆（clone）一份現有的 Git 倉儲。</p>
<section class="sect2" title="在現有資料夾中初始化倉儲">
<h3 id="_在現有資料夾中初始化倉儲">在現有資料夾中初始化倉儲</h3>
<p>若你打算使用 Git 來追蹤（track）現有的專案，只需要進入該專案的資料夾並執行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init</code></pre>
</figure>
<p>這個命令將會建立一個名為 <code class="literal">.git</code> 的子資料夾，其中包含 Git 所有必需的倉儲檔案，也就是 Git 倉儲的骨架。
到現在這步驟為止，倉儲預設沒有追蹤任何檔案。
（想知道你剛建立的 <code class="literal">.git</code> 資料夾內有些什麼檔案，請參考<a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Git Internals</a>）</p>
<p>如果你的專案資料夾原本已經有檔案（不是空的），那麼建議你應該馬上追蹤這些原本就有的檔案，然後進行第一次提交。
你可以通過多次 <code class="literal">git add</code> 指令來追蹤完所有你想要追蹤的檔案，然後執行 <code class="literal">git commit</code> 提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *.c
<span style="font-weight: bold">$</span> git add LICENSE
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial project version&#39;</span></code></pre>
</figure>
<p>進行這些動作應該不會花你太多時間。
到現在這步驟為止，你已經得到了一個追蹤若干檔案及第一次提交內容的 Git 倉儲。</p>
</section>
<section class="sect2" title="克隆現有的倉儲">
<h3 id="r_git_cloning">克隆現有的倉儲</h3>
<p>若你想要取得現有 Git 倉儲的複本（例如：你想要開始協作的倉儲），那你需要使用的命令是 <code class="literal">git clone</code>。
若你熟悉其它像是 Subversion 的版本控制系統，你應該注意現在這個命令是克隆（clone），而非取出（checkout）。
這是 Git 和其他版本控制系統的重要差異：Git 並不僅只是取得專案最新的內容，而是把遠端倉儲內幾乎所有的資料都抓回來了。
專案歷史紀錄中，每個檔案的每個版本預設都會在你執行 <code class="literal">git clone</code> 時被拉取（pull）回來。
實際上，如果伺服器的硬碟損壞，你通常可以使用任何客戶端克隆的倉儲來將伺服器重建回原本克隆的狀態。（你可能遺失一些伺服器的掛勾程式 <code class="literal">hooks</code>，但你所有的版本資料都還會健在，請查看 <a id="xref--ch04-git-server--r_git_on_the_server" href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在伺服器上佈署 Git</a> 獲得更多資訊）</p>
<p>克隆倉庫的命令格式是 <code class="literal">git clone [url]</code>。
例如：若你想克隆名為 libgit2 的 Git linkable library，可以執行下列命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2</code></pre>
</figure>
<p>這指令將會建立名為「libgit2」的資料夾，並在這個資料夾下初始化一個 <code class="literal">.git</code> 資料夾，從遠端倉儲拉取所有資料，並且取出（checkout）專案中最新的版本。
若你進入新建立的 <code class="literal">libgit2</code> 資料夾，你將會看到專案的檔案都在裡面了，並且準備就緒等你進行後續的開發或使用。
若你想要將倉儲克隆到「libgit2」以外名字的資料夾，只需要再多指定一個參數即可：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2 mylibgit</code></pre>
</figure>
<p>這個命令做的事與上一個命令大致相同，只不過在本地創建的倉庫名字變為 <code class="literal">mylibgit</code>。</p>
<p>Git 支援多種數據傳輸協定。
上一個範例採用 <code class="literal">https://</code> 協定，但你可能會看過 <code class="literal">git://</code> 或 <code class="literal">user@server:path/to/repo.git</code> 等使用 SSH 傳輸的協定。
在 <a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在伺服器上佈署 Git</a> 章節將會介紹這些協定在伺服器端如何配置及使用，以及各種方式的優缺點。</p>
</section>
</section>
<section class="sect1" title="紀錄變更到版本庫中">
<h2 id="_紀錄變更到版本庫中">紀錄變更到版本庫中</h2>
<p>現在你的手上有了一個貨真價實的 Git 版本庫和這個專案中所有檔案的檢出（checkout）或工作複本（working copy），
每當你修改檔案到一個你想記錄它的階段時，你就需要提交（commit）這些變更的快照到版本庫中。</p>
<p>請記住，你工作目錄下的每個檔案不外乎兩種狀態：已追蹤、未追蹤。
「已追蹤」檔案是指那些在上次快照中的檔案：它們的狀態可能是「未修改」、「已修改」、「已預存（staged）」；
「未追蹤」則是其它以外的檔案——在工作目錄中，卻不包含在上次的快照中，也不在預存區（staging area）中的任何檔案；
當你第一次克隆（clone）一個版本庫時，所有檔案都是「已追蹤」且「未修改」，因為 Git 剛剛檢出它們並且你尚未編輯過任何檔案。</p>
<p>隨著你編輯某些檔案，Git 會視它們為「已修改」，因為自從上次提交以來你已經更動過它們；
你預存（stage）這些已修改檔案，然後提交所有已預存的修改內容，接著重覆這個循環。</p>
<figure class="image">
<div class="content">
<img src="images/lifecycle.png" alt="檔案狀態的生命週期。"/>
</div>
<figcaption>圖表 1. 檔案狀態的生命週期。</figcaption>
</figure>
<section class="sect2" title="檢查你的檔案狀態">
<h3 id="r_checking_status">檢查你的檔案狀態</h3>
<p><code class="literal">git status</code> 命令是用來偵測哪些檔案處在什麼樣的狀態下的主要工具；
如果你在克隆之後直接執行該命令，應該會看到類似以下內容：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean</code></pre>
</figure>
<p>這意味著你有一個乾淨的工作目錄——換句話說，已追蹤的檔案沒有被修改；
Git 也沒有看到任何未追蹤檔案，否則它們會在這裡被列出來；
最後，這個命令告訴你目前在哪一個分支上，也告訴你它和伺服器上的同名分支是同步的。
到目前為止，該分支一直都是預設的「master」，在這裡你先不用擔心它，
<a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 會詳細地介紹「分支（branch）」和「參照（reference）」。</p>
<p>假設你在專案中新增一個檔案，例如：一個簡單的 <code class="literal">README</code> 檔案；
如果該檔案先前並不存在，執行 <code class="literal">git status</code> 命令後，你會看到未追蹤檔案：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;My Project&#39;</span> &gt; README
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
</figure>
<p>你可以看到新增檔案 README 尚未被追蹤，因為它被列在輸出訊息的「Untracked files」欄位下方；
基本上「未追蹤」表示 Git 發現這個檔案在上次的快照（提交）中並不存在；Git 並不會將此檔案納入你的提交快照，除非你明確地告訴 Git 要這麼做；
它會這樣做是為了避免你意外地將一些二進位暫存檔或其它你並不想要的檔案納入版本控制。
讓我們開始追蹤 README 檔案，因為你確實想要將它開始納入版本控制。</p>
</section>
<section class="sect2" title="追蹤新的檔案">
<h3 id="r_tracking_files">追蹤新的檔案</h3>
<p>要開始追蹤一個新的檔案，可以使用 <code class="literal">git add</code> 命令；
要開始追蹤 README 檔案，你可以執行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>如果再次執行檢查狀態命令，可以看到 README 檔案現在是準備好被提交的「已追蹤」和「已預存」狀態：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README</code></pre>
</figure>
<p>由於它放在「Changes to be committed」欄位下方，你可以得知它已經被預存，
如果你在此時提交，在執行 <code class="literal">git add</code> 的當下所加進來的檔案版本就會被記錄在歷史快照中；
你或許會想到之前執行 <code class="literal">git init</code> 後也有執行過 <code class="literal">git add (files)</code>——那就是開始追蹤目錄內的檔案。
<code class="literal">git add</code> 命令接受「檔案」或「目錄」做為路徑名稱；如果是目錄，該命令會用遞迴的方式加入那個目錄下所有的檔案。</p>
</section>
<section class="sect2" title="預存修改過的檔案">
<h3 id="_預存修改過的檔案">預存修改過的檔案</h3>
<p>讓我們修改一個已追蹤檔案；
假設你修改了一個先前已追蹤的檔案 <code class="literal">CONTRIBUTING.md</code>，接著再次執行 <code class="literal">git status</code>，你會看到類似以下文字：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p><code class="literal">CONTRIBUTING.md</code> 檔案出現在「Changes not staged for commit」欄位下方——代表著位於工作目錄的已追蹤檔案已經被修改，但尚未預存；
要預存該檔案，你可執行 <code class="literal">git add</code> 命令；
<code class="literal">git add</code> 是一個多重用途的指令——用來「開始追蹤」檔案、「預存」檔案以及做一些其它的事，像是「標記合併衝突（merge-conflicted）檔案為已解決」。
比起「把這個檔案加進專案」，把它想成「把檔案內容加入下一個提交中」會比較容易理解。
現在，讓我們執行 <code class="literal">git add</code> 將 <code class="literal">CONTRIBUTING.md</code> 檔案預存起來，並再度執行 <code class="literal">git status</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>這兩個檔案目前都被預存，而且將會成為你下次提交的內容；
此時，假設在提交前你想起要對 <code class="literal">CONTRIBUTING.md</code> 再做一個小修改，
你再次開啟檔案並修改它，然後準備提交；
然而，當我們再次執行 <code class="literal">git status</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>見鬼了？
現在 <code class="literal">CONTRIBUTING.md</code> 同時被列在已預存「及」未預存。
這怎麼可能？
原來 Git 在你執行 <code class="literal">git add</code> 命令時，的確將當時的檔案內容預存起來；
如果你現在提交，最後一次執行 <code class="literal">git add</code> 命令時，那個當下的 <code class="literal">CONTRIBUTING.md</code> 的版本會被提交，而不是在提交時你在工作目錄所看到的檔案版本被提交；
如果你在 <code class="literal">git add</code> 後修改檔案，你必需再次執行 <code class="literal">git add</code> 預存最新版的檔案：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
</section>
<section class="sect2" title="簡潔的狀態輸出">
<h3 id="_簡潔的狀態輸出">簡潔的狀態輸出</h3>
<p>雖然 <code class="literal">git status</code> 輸出內容相當全面，但也相當囉嗦；
Git 另外提供一個簡潔輸出的選項，因此你可以以一種較精簡的方式來檢視你的修改；
如果你執行 <code class="literal">git status -s</code> 或 <code class="literal">git status --short</code>，你可以從該命令得到一個相當簡單的輸出內容：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</figure>
<p>未追蹤的新檔案在開頭被標示為 <code class="literal">??</code>、被加入預存區的新檔案被標為 <code class="literal">A</code>、已修改檔案則是 <code class="literal">M</code> 等等。
標記有二個欄位——左邊欄位用來指示「預存區」狀態，右邊欄位則是「工作目錄」狀態。
所以在這個範例中，在工作目錄中的檔案 <code class="literal">README</code> 是已修改的，但尚未被預存；而 <code class="literal">lib/simplegit.rb</code> 檔案則是已修改且已預存的；
<code class="literal">Rakefile</code> 則是曾經修改過也預存過，但之後又再次修改，所以總共有二次修改，一個有預存一個沒有。</p>
</section>
<section class="sect2" title="忽略不需要的檔案">
<h3 id="r_ignoring">忽略不需要的檔案</h3>
<p>通常你會有一類檔案不想讓 Git 自動加入，也不希望它們被顯示為未追蹤，
這些通常是自動產生的檔案，例如：日誌檔案或者編譯系統產生的檔案；
在這情況下，你可以新建一個名為 <code class="literal">.gitignore</code> 的檔案，在該檔中列舉符合這些檔名的模式（pattern）。
以下是一個 <code class="literal">.gitignore</code> 範例檔內容：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .gitignore
*.[oa]
*~</code></pre>
</figure>
<p>第一列告訴 Git 忽略任何副檔名為「.o」或「.a」的檔案，它們可能是編譯系統建置程式碼時所產生的目的檔及連結檔；
第二列告訴 Git 忽略所有檔名以波浪號（<code class="literal">~</code>）結尾的檔案，這種檔案通常被用在很多文字編輯器中，例如：Emacs 把它用在暫存檔；
你可能也想忽略 log、tmp、pid 目錄、自動產生的文件等等；
在你要開始做事之前將 <code class="literal">.gitignore</code> 設定好通常是一個不錯的主意，這樣你就不會意外地將實際上並不想追蹤的檔案提交到你的 Git 版本庫。</p>
<p>編寫 <code class="literal">.gitignore</code> 檔案的模式規則如下：</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">空白列，或者以 <code class="literal">#</code> 開頭的列會被忽略。</span>
</li>
<li>
<span class="principal">可使用標準的 Glob 模式。</span>
</li>
<li>
<span class="principal">以斜線（<code class="literal">/</code>）開頭以避免路徑遞迴。（譯注：只忽略特定路徑；如果不以斜線開頭，則不管同名檔案或同名資料夾在哪一層都會被忽略。）</span>
</li>
<li>
<span class="principal">以斜線（<code class="literal">/</code>）結尾代表是目錄。</span>
</li>
<li>
<span class="principal">以驚嘆號（<code class="literal">!</code>）開頭表示將模式規則反向。</span>
</li>
</ul>
</div>
<p>Glob 模式就像是 Shell 所使用的簡化版正規運算式（regular expressions）；
一個星號（<code class="literal">*</code>）匹配零個或多個字元、<code class="literal">[abc]</code> 匹配中括弧內的其中一個字元（此例為 a、b、c）、問號（<code class="literal">?</code>）匹配單一個字元、中括孤內的字以連字號連接（如：<code class="literal">[0-9]</code>）用來匹配任何在該範圍內的字元（此例為 0 到 9）；
你也可以使用二個星號用來匹配巢狀目錄；<code class="literal">a/**/z</code> 將會匹配到 <code class="literal">a/z</code>、<code class="literal">a/b/z</code>、<code class="literal">a/b/c/z</code> 等等。</p>
<p>以下是另一個 .gitignore 範例檔案：</p>
<figure class="listing">
<pre class="source language-"><code># 不要追蹤檔名為 .a 結尾的檔案
*.a

# 但是要追蹤 lib.a，即使上面已指定忽略所有的 .a 檔案
!lib.a

# 只忽略根目錄下的 TODO 檔案，不包含子目錄下的 TODO
/TODO

# 忽略 build/ 目錄下所有檔案
build/

# 忽略 doc/notes.txt，但不包含 doc/server/arch.txt
doc/*.txt

# 忽略所有在 doc/ 目錄底下的 .pdf 檔案
doc/**/*.pdf</code></pre>
</figure>
<aside class="admonition tip" title="提示" epub:type="help">
<div class="content">
<p>如果你的專案想要有個好開頭，GitHub 在 <a href="https://github.com/github/gitignore" class="link">https://github.com/github/gitignore</a> 中針對幾十種專案和程式語言維護了一個相當完整、好用的 <code class="literal">.gitignore</code> 範例檔案列表。</p>
</div>
</aside>
</section>
<section class="sect2" title="檢視已預存及未預存的檔案">
<h3 id="r_git_diff_staged">檢視已預存及未預存的檔案</h3>
<p>如果 <code class="literal">git status</code> 命令提供的資訊對你來說太過簡略——你要想精確地知道你修改了什麼，而不只是那些檔案被修改——你可以使用 <code class="literal">git diff</code> 命令；
稍後我們會更詳盡講解 <code class="literal">git diff</code> 命令，然而大部分你在使用它的時候只是為了瞭解兩個問題：已修改但尚未預存的內容是哪些？
已預存而準備被提交的內容又有哪些？
儘管 <code class="literal">git status</code> 命令透過列出檔名的方式大略回答了這些問題，但 <code class="literal">git diff</code> 可顯示檔案裡的哪些列被加入或刪除——如同以往地以補綴（patch）格式呈現。</p>
<p>假設你再次編輯並預存 <code class="literal">README</code> 檔案，接著修改 <code class="literal">CONTRIBUTING.md</code> 檔案卻未預存它，
如果你執行 <code class="literal">git status</code> 命令，你會再次看到類似以下資訊：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>想瞭解尚未預存的修改，輸入不帶其它參數的 <code class="literal">git diff</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<p>這命令會比對「工作目錄」和「預存區」之間的版本，
然後顯示尚未被存入預存區的修改內容。</p>
<p>如果你想檢視你已經預存而接下來將會被提交的內容，可以使用 <code class="literal">git diff --staged</code>；
這個命令比對的對象是「預存區」和「最後一次提交」。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</figure>
<p>很重要且需要注意的一點是 <code class="literal">git diff</code> 不會顯示最後一次提交後的所有變更——只會顯示未預存的變更；
這會讓人困惑，因為如果你預存了所有的變更，<code class="literal">git diff</code> 不會輸出任何內容。</p>
<p>舉其它例子，如果你預存 <code class="literal">CONTRIBUTING.md</code> 檔案後又編輯它，你可以使用 <code class="literal">git diff</code> 檢視檔案中哪些變更是已預存的、哪些是尚未預存的。
如果它看起來像這樣：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# test line&#39;</span> &gt;&gt; CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>現在你可以使用 <code class="literal">git diff</code> 來檢視哪些部分是仍然未預存的：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
<span style="font-weight: bold"> #</span><span style="font-style: italic"># Starter Projects</span>

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</figure>
<p>以及使用 <code class="literal">git diff --cached</code> 檢視哪些部分是已預存的（<code class="literal">--staged</code> 和 <code class="literal">--cached</code> 是同義選項）：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<aside class="admonition note" title="筆記: Git 外部差異比對工具" epub:type="note">
<h2>Git 外部差異比對工具</h2>
<div class="content">
<p>接下來我們還會在書中的其它地方以各種不同的用法來使用 <code class="literal">git diff</code> 命令；
如果你傾向於使用圖形或外部差異比對檢視工具，有另一種方法可以查看這些差異內容；
執行 <code class="literal">git difftool</code> 取代 <code class="literal">git diff</code>，你可以用軟體工具檢視任何這類型的差異，像是 emerge、vimdiff 或其它更多的工具（包括商業化的產品）；
執行 <code class="literal">git difftool --tool-help</code> 以查看在你系統上有什麼可用的。</p>
</div>
</aside>
</section>
<section class="sect2" title="提交你的修改">
<h3 id="r_committing_changes">提交你的修改</h3>
<p>現在你的預存區已被建構成你想要的，你可以開始提交你的變更；
記住：任何未預暫存的檔案——新增的、已修改的，自從你編輯它們卻尚未用 <code class="literal">git add</code> 預存的——將不會納入本次的提交中；
它們仍以「已修改」的身份存在磁碟中。
在目前情況下，假設你上次執行 <code class="literal">git status</code> 時，你看到所有檔案都已經被預存，因此你準備提交你的變更。
最簡單的提交方式是輸入 <code class="literal">git commit</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p>這麼做會啟動你選定的編輯器
（由你的 Shell 的 <code class="literal">$EDITOR</code> 環境變數所指定——通常是 vim 或 emacs；你也可以如同 <a id="xref--ch01-introduction" href="ch01-introduction.xhtml" class="xref">開始</a> 所介紹的，使用 <code class="literal">git config --global core.editor</code> 命令指定任何一個你想使用的）。</p>
<p>編輯器會顯示如下文字（此範例為 Vim 的畫面）：</p>
<figure class="listing">
<pre class="source language-"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</figure>
<p>你可以看到預設的提交訊息中包含最近一次 <code class="literal">git status</code> 的輸出並以註解方式呈現，以及最上方有一列空白列；
你可以移除這些註解後再輸入提交訊息，或者保留它們以提醒你現在正在提交什麼樣的內容。
（如果想對你已經修改的內容得到更明確的提示，可以在 <code class="literal">git commit</code> 上加上 <code class="literal">-v</code> 選項；
這麼做連修改的差異內容也會被放到編輯器中，如此你便可以精確地看到你正在提交的修改內容。）
當你關閉編輯器，Git 會利用這些提交訊息（註解和差異內容會被濾除）產生新的提交。</p>
<p>另一種方式則是在 <code class="literal">commit</code> 命令的 <code class="literal">-m</code> 選項後方直接輸入提交訊息，如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Story 182: Fix benchmarks for speed&quot;</span>
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</figure>
<p>現在你已經建立了你的第一個提交！
你可從輸出訊息看到此提交相關資訊：提交到哪個分支（<code class="literal">master</code>）、提交的 SHA-1 校驗碼（<code class="literal">463dc4f</code>）、有多少檔案被更動，以及統計此提交有多少列被新增和被移除。</p>
<p>記住：那個提交記錄了你放在預存區的快照。
任何你尚未預存的已修改檔案仍然安好地在那裡，你可以做另一次提交來把它加入到你的歷史中；
每一次提交時，你都正在對專案記錄一個快照，可以在之後用來「復原」或「比對」。</p>
</section>
<section class="sect2" title="略過預存區">
<h3 id="_略過預存區">略過預存區</h3>
<p>
雖然「預存區」的用法讓你能夠很有技巧地且精確地提交你想記錄的內容而意外地好用，但有時候它也比你實際需要的工作流程要繁瑣得多；
如果你想跳過預存區，Git 提供了一個簡易的捷徑，
在 <code class="literal">git commit</code> 命令加上 <code class="literal">-a</code> 選項，使 Git 在提交前自動預存所有已追蹤的檔案，讓你略過 <code class="literal">git add</code> 步驟：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;added new benchmarks&#39;</span>
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>請留意這種使用情況：在提交之前，你並不需要執行 <code class="literal">git add</code> 來預存 <code class="literal">CONTRIBUTING.md</code> 檔案；
那是因為 <code class="literal">-a</code> 選項會納入所有已變更的檔案；
很方便，但請小心，有時候它會納入你並不想要的變更。</p>
</section>
<section class="sect2" title="移除檔案">
<h3 id="r_removing_files">移除檔案</h3>
<p>
要從 Git 中刪除一個檔案，你需要將它從已追蹤檔案中移除（更準確地說，是從預存區中移除），然後再提交；
<code class="literal">git rm</code> 命令可完成此工作，它同時也會將該檔案從工作目錄中移除，如此它之後也不會身為未追蹤檔案而被你看到。</p>
<p>如果你僅僅是將檔案從工作目錄中移除，那麼它會被列在 <code class="literal">git status</code> 輸出內容的「Changed but not updated」（也就是「未預存」）欄位下面：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm PROJECTS.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p>如果你接著執行 <code class="literal">git rm</code>，它會預存該檔案的移除動作：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm PROJECTS.md
rm &#39;PROJECTS.md&#39;
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    deleted:    PROJECTS.md</code></pre>
</figure>
<p>下一次提交時，該檔案將會消失而且不再被追蹤；
如果你修改了檔案且已經把修改內容加入索引中（譯注：「加入索引」和「預存」是同義詞），你必需使用 <code class="literal">-f</code> 選項才能強制將它移除；
這是一種為了避免已記錄的快照意外被移除後再也無法使用 Git 復原的保護機制。</p>
<p>另一個有用的技巧是保留工作目錄的檔案，但將它從預存區中移除；
換句話說，你或許想保留在磁碟機上的檔案但不希望 Git 再繼續追蹤它；
當你忘記將某些檔案加到 <code class="literal">.gitignore</code> 中而且不小心預存它的時候會特別用有，像是不小心預存了一個大的日誌檔案或者一堆 <code class="literal">.a</code> 已編譯檔案。
加上 <code class="literal">--cached</code> 選項可做到這件事：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm --cached README</code></pre>
</figure>
<p>你可將「檔案」、「目錄」、「file-glob 模式」做為參數傳給 <code class="literal">git rm</code> 命令，
那意味著你可以做類似下面的事：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm log/<span style="font-weight: bold; font-style: italic">\*</span>.log</code></pre>
</figure>
<p>注意：星號 <code class="literal">*</code> 前面有反斜線（<code class="literal">\</code>）；
這是必須的，因為 Git 在你的 Shell 檔名擴展（filename expansion）之上另外有自己的檔名擴展；
此命令會移除在 <code class="literal">log/</code> 所有副檔名為 <code class="literal">.log</code> 的檔案。
或者你也可以做像下面的事：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm <span style="font-weight: bold; font-style: italic">\*</span>~</code></pre>
</figure>
<p>此命令會移除所有以 <code class="literal">~</code> 結尾的檔案。</p>
</section>
<section class="sect2" title="移動檔案">
<h3 id="r_git_mv">移動檔案</h3>
<p>
Git 不像其它 VCS 系統，它並不會明確地追蹤檔案的移動；
如果你在 Git 中重新命名一個檔案，並不會有任何 Git 後設資料記錄這個動作以辨別你曾經重新命名過檔案；
然而 Git 可以在檔案移動後很聰明地將它們找出來——我們稍後會對偵測檔案的移動再多做一點說明。</p>
<p>因此 Git 有一個 <code class="literal">mv</code> 命令反而有點令人困惑；
如果你想要在 Git 中重新命名一個檔案，你可以執行以下命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv file_from file_to</code></pre>
</figure>
<p>並且它運作地想當好；
事實上，如果你執行類似以下的動作然後檢視一下狀態，你將看到 Git 將該檔案視為一個重新命名過的檔案：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv README.md README
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>其實，它相當於執行下列命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mv README.md README
<span style="font-weight: bold">$</span> git rm README.md
<span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>Git 會在背後判斷檔案被重新命名，因此不管是用上述方法還是用 <code class="literal">mv</code> 命令並沒有差別；
實際上唯一不同的是 <code class="literal">mv</code> 是一個命令，而不是三個——它只是個方便的功能。
更重要的是你可以使用任何你喜歡的工具來重新命名一個檔案，然後在提交前才使用 add/rm。</p>
</section>
</section>
<section class="sect1" title="檢視提交的歷史記錄">
<h2 id="r_viewing_history">檢視提交的歷史記錄</h2>
<p>在產生數筆提交（commit）或者克隆（clone）一個已有歷史記錄的版本庫之後，你或許會想要檢視之前發生過什麼事；
最基本也最具威力的工具就是 <code class="literal">git log</code> 命令。</p>
<p>以下範例使用一個非常簡單的「simplegit」專案做展示；
欲取得此專案，執行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/simplegit-progit</code></pre>
</figure>
<p>在此專案目錄內執行 <code class="literal">git log</code>，你應該會看到類似以下訊息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit</code></pre>
</figure>
<p>預設情況（未加任何選項）<code class="literal">git log</code> 以反向的時間順序列出版本庫的提交歷史記錄——也就是說最新的提交會先被列出來；
如你所見，它也會列出每筆提交的 SHA-1 校驗碼、作者名字及電子郵件、寫入日期以及提交訊息。</p>
<p><code class="literal">git log</code> 命令有大量且多樣的選項，能精確地找出你想搜尋的結果；
在這裡，我們會展示一些最受歡迎的選項。</p>
<p>最有用的選項之一是 <code class="literal">-p</code>，用來顯示每筆提交所做的修改內容；
你還可以加上 <code class="literal">-2</code> 選項，限制只輸出最後兩筆提交內容。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &#39;rake/gempackagetask&#39;
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   &quot;simplegit&quot;
-    s.version   =   &quot;0.1.0&quot;
+    s.version   =   &quot;0.1.1&quot;
     s.author    =   &quot;Scott Chacon&quot;
     s.email     =   &quot;schacon@gee-mail.com&quot;
     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file</code></pre>
</figure>
<p>這個選項除了顯示相同的資訊以外，還會在每筆提交資訊後面附加每個修改檔案的差異內容（譯註：使用 <code class="literal">-</code> <code class="literal">+</code> 來表示差異，<code class="literal">-</code> 是刪除行，<code class="literal">+</code> 是新增行；未修改的上下文資訊預設是三行，用來定位有修改的地方）；
對於「程式碼審核」或「快速瀏覽」協同工作者所新增的一系列提交內容，這是非常有幫助的。
你也可以使用 <code class="literal">git log</code> 提供的一系列「摘要」選項；
例如：若想檢視每筆提交簡略的統計資訊，你可以使用 <code class="literal">--stat</code> 選項：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)</code></pre>
</figure>
<p>如你所見，<code class="literal">--stat</code> 選項在每筆提交訊息的下方列出「被更動的檔案」、「總共有多少檔案被更動」、「這些檔案中有多少行被加入或移除」；
它也會在最後印出總結訊息。</p>
<p>另一個實用的選項是 <code class="literal">--pretty</code>，
用來改變原本預設輸出的格式；
有數個內建的選項供你選用，
其中 <code class="literal">oneline</code> 選項將每一筆提交顯示成單獨一行，對於檢視大量的提交時很有用；
更進一步，<code class="literal">short</code>、<code class="literal">full</code>、<code class="literal">fuller</code> 選項輸出的格式大致相同，但分別會少一些或者多一些資訊。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</code></pre>
</figure>
<p>最有趣的選項是 <code class="literal">format</code>，讓你可以指定自訂的輸出格式；
當需要輸出給機器分析時特別有用——因為明確地指定了格式，即可確定它不會因為更新 Git 而被更動：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h - %an, %ar : %s&quot;</span>
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</code></pre>
</figure>
<p><a id="xref-rpretty_format" href="#rpretty_format" class="xref"><code class="literal">git log --pretty=format</code> 實用選項</a> 列出 <code class="literal">format</code> 一些更實用的選項。</p>
<div class="table">
<div class="content">
<table id="rpretty_format" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>表格 1. <code class="literal">git log --pretty=format</code> 實用選項</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>選項</th>
<th>輸出說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">%H</code></p></td>
<td><p>該提交 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%h</code></p></td>
<td><p>該提交簡短的 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%T</code></p></td>
<td><p>「樹（tree）」物件的 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%t</code></p></td>
<td><p>「樹」物件簡短的 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%P</code></p></td>
<td><p>親代（parent）提交的 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%p</code></p></td>
<td><p>親代提交簡短的 SHA-1 雜湊值</p></td>
</tr>
<tr>
<td><p><code class="literal">%an</code></p></td>
<td><p>作者名字</p></td>
</tr>
<tr>
<td><p><code class="literal">%ae</code></p></td>
<td><p>作者電子郵件</p></td>
</tr>
<tr>
<td><p><code class="literal">%ad</code></p></td>
<td><p>作者日期（依據 --date 選項值而有不同的格式）</p></td>
</tr>
<tr>
<td><p><code class="literal">%ar</code></p></td>
<td><p>作者日期，相對時間格式。</p></td>
</tr>
<tr>
<td><p><code class="literal">%cn</code></p></td>
<td><p>提交者名字</p></td>
</tr>
<tr>
<td><p><code class="literal">%ce</code></p></td>
<td><p>提交者電子郵件</p></td>
</tr>
<tr>
<td><p><code class="literal">%cd</code></p></td>
<td><p>提交者日期</p></td>
</tr>
<tr>
<td><p><code class="literal">%cr</code></p></td>
<td><p>提交者日期，相對時間格式。</p></td>
</tr>
<tr>
<td><p><code class="literal">%s</code></p></td>
<td><p>標題</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>你可能會好奇「作者（author）」與「提交者（committer）」之間的差別，
作者是最初修改的人，而提交者則是最後套用該工作成果的人；
因此，如果你送出某個專案的補綴，而該專案其中一個核心成員套用該補綴，則你與該成員都有功勞——你是作者，而該成員則是提交者。
我們會在 <a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">分散式的 Git</a> 提到更多它們之間的差別。</p>
<p>當 <code class="literal">oneline</code>、<code class="literal">format</code> 和另一個 <code class="literal">log</code> 選項 <code class="literal">--graph</code> 結合在一起使用時將特別有用，
該選項會附加一個還不錯的 ASCII 圖形用來顯示分支及合併的歷史。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span> --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &#39;master&#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &#39;defunkt&#39; into local</code></pre>
</figure>
<p>當下一個章節談到分支（branching）和合併（merging）時，這種輸出型式將會變得更為有趣。</p>
<p>這些只是一些簡單的 <code class="literal">git log</code> 格式化輸出選項——還有更多其它的；
<a id="xref-rlog_options" href="#rlog_options" class="xref"><code class="literal">git log</code> 的常用選項</a> 列出我們目前涵蓋的以及一些你可能常常會用到的格式化選項，以及它們會如何改變 log 命令的輸出格式。</p>
<div class="table">
<div class="content">
<table id="rlog_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>表格 2. <code class="literal">git log</code> 的常用選項</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>選項</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-p</code></p></td>
<td><p>顯示每筆提交的補綴。</p></td>
</tr>
<tr>
<td><p><code class="literal">--stat</code></p></td>
<td><p>顯示每筆提交中更動檔案的統計及摘要資訊。</p></td>
</tr>
<tr>
<td><p><code class="literal">--shortstat</code></p></td>
<td><p>只顯示 --stat 提供的的訊息中關於更動、插入、刪除的文字。</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-only</code></p></td>
<td><p>在提交訊息後方顯示更動的檔案列表。</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-status</code></p></td>
<td><p>在檔案列表顯示「新增」、「更動」、「刪除」等資訊。</p></td>
</tr>
<tr>
<td><p><code class="literal">--abbrev-commit</code></p></td>
<td><p>只顯示 SHA-1 校驗碼的前幾位數，而不是顯示全部 40 位數。</p></td>
</tr>
<tr>
<td><p><code class="literal">--relative-date</code></p></td>
<td><p>以相對時間格式顯示日期（例如：「2 weeks ago」），而不是使用完整的日期格式。</p></td>
</tr>
<tr>
<td><p><code class="literal">--graph</code></p></td>
<td><p>在輸出的日誌旁邊顯示分支及合併歷史的 ASCII 圖形。</p></td>
</tr>
<tr>
<td><p><code class="literal">--pretty</code></p></td>
<td><p>以其它格式顯示提交。選項包括 oneline、short、full、fuller 及可自訂格式的 format。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<section class="sect2" title="限制日誌的輸出">
<h3 id="_限制日誌的輸出">限制日誌的輸出</h3>
<p>除了輸出格式的選項以外，<code class="literal">git log</code> 還有一些有用的輸出限制選項——也就是讓你能夠只顯示一個子集合的提交；
你先前已看過其中一個——用 <code class="literal">-2</code> 選項只顯示最後二筆提交，
事實上，你可以用 <code class="literal">-&lt;n&gt;</code>，其中 <code class="literal">n</code> 是任意整數，用來顯示最後 <code class="literal">n</code> 筆提交；
實際上，你可能不太會那麼常用到它，因為 Git 預設把輸出導向分頁器，所以你一次只能看到一頁的日誌輸出內容。</p>
<p>然而，像 <code class="literal">--since</code> 和 <code class="literal">--until</code> 這些限制時間的選項就很有用；
例如，以下命令列出最近兩週以來的提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --since=2.weeks</code></pre>
</figure>
<p>這個命令支援各種格式——你可以指定特定的日期格式（例如：<code class="literal">"2008-01-15"</code>），或者相對日期格式（例如：<code class="literal">"2 years 1 day 3 minutes ago"</code>）。</p>
<p>你也可以過濾列表中符合某些搜尋條件的提交；
<code class="literal">--author</code> 選項允許你過濾特定作者，而 <code class="literal">--grep</code> 選項允許你以關鍵字搜尋提交訊息。
（注意：如果你想要同時比對作者及提交訊息，你必需加上 <code class="literal">--all-match</code>，否則只要滿足其中一個條件的提交都會被列出來。）</p>
<p>另一個實用的選項是 <code class="literal">-S</code>，用來尋找所修改的內容中被加入或移除某字串的提交；
擧例，如果你想要找出最後一個有加入或移除某個特定函數參照的提交，你可以使用：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -Sfunction_name</code></pre>
</figure>
<p>最後一個實用的 <code class="literal">git log</code> 過濾選項是路徑，
如果你指定一個目錄或檔名，你可以列出只對這些檔案有修改記錄的提交；
這個選項永遠放在最後一個，並且通常使用二個連接號（<code class="literal">--</code>）將路徑與其它選項隔開。</p>
<p>我們在 <a id="xref-rlimit_options" href="#rlimit_options" class="xref">Options to limit the output of <code class="literal">git log</code></a> 中列出這些選項和一些其它常用選項供你參考。</p>
<div class="table">
<div class="content">
<table id="rlimit_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>表格 3. Options to limit the output of <code class="literal">git log</code></caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>選項</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-(n)</code></p></td>
<td><p>只顯示最後 n 筆提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--since</code>, <code class="literal">--after</code></p></td>
<td><p>列出特定日期後的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--until</code>, <code class="literal">--before</code></p></td>
<td><p>列出特定日期前的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--author</code></p></td>
<td><p>列出作者名字符合指定字串的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--committer</code></p></td>
<td><p>列出提交者名字符合指定字串的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--grep</code></p></td>
<td><p>列出提交訊息中符合指定字串的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">-S</code></p></td>
<td><p>列出修改檔案中有加入或移除指定字串的提交。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>例如：如果你想檢視 Git 原始碼的測試檔案中（譯註：它們都放在資料夾 <code class="literal">t/</code>），由 Junio Hamano 在 2008 年 10 月份所提交，但不包含「合併提交」的提交。可執行以下的命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=<span style="font-style: italic">&quot;%h - %s&quot;</span> --author=gitster --since=<span style="font-style: italic">&quot;2008-10-01&quot;</span> <span style="font-weight: bold; font-style: italic">\</span>
   --before=<span style="font-style: italic">&quot;2008-11-01&quot;</span> --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD
b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</code></pre>
</figure>
<p>在 Git 原始碼接近 40,000 筆提交歷史記錄中，這個命令列出其中符合條件的 6 筆。</p>
</section>
</section>
<section class="sect1" title="復原">
<h2 id="r_undoing">復原</h2>
<p>在任何一個過程中，你都可能想要復原某些內容，
在這裡我們會回顧一些基本的工具用來復原你做過的修改內容；
小心！因為復原操作不是永遠都可逆的，
這是少數在使用 Git 時，執行錯誤的動作會遺失資料的情況。</p>
<p>一個常見的復原操作發生在當你太早提交（commit），接著才發現忘了加入某些檔案，或者寫錯了提交訊息；
如果你想要重新提交，你可以在提交命令上使用 <code class="literal">--amend</code> 選項：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>這個命令會再次把預存區（staging area）拿來提交，
如果自從上次提交以來你沒有做過任何檔案修改（例如：在上一次提交後，馬上執行此命令），那麼整個快照看起來會與上次提交的一模一樣，唯一有可能更動的是提交訊息。</p>
<p>同樣用來提交訊息的文字編輯器會先啟動，並且已填好上一次提交的訊息內容；
你可以像往常一樣編輯這些訊息，接著它會覆蓋掉上一次的提交。</p>
<p>例如：如果你提交後才意識到你想要把某些忘記預存（stage）的修改也一併加入到上一個提交中，你可以這樣做：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial commit&#39;</span>
<span style="font-weight: bold">$</span> git add forgotten_file
<span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>最終只會得到一個提交——第二次的提交取代了第一次提交的結果。</p>
<section class="sect2" title="將已預存的檔案移出預存區">
<h3 id="r_unstaging">將已預存的檔案移出預存區</h3>
<p>接下來的兩節會展示如何操作預存區和工作目錄中已修改的檔案；
用來顯示這二個區域狀態的命令也會好心地提示你如何做復原操作，
例如：假設你已經修改了二個檔案，並且想要分別提交它們，但是你卻意外地使用 <code class="literal">git add *</code> 把它們二個都預存了，
要如何將其中一個「移出預存區（unstage）」呢？
<code class="literal">git status</code> 命令提示你：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>在「Changes to be committed」文字正下方，說明了使用 <code class="literal">git reset HEAD &lt;file&gt;...</code> 將檔案移出預存區；
因此，讓我們依循該建議將 <code class="literal">CONTRIBUTING.md</code> 檔案移出預存區：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>這個命令有一點奇怪，不過它的確可行；
<code class="literal">CONTRIBUTING.md</code> 檔案現在又回到了「修改」但「未預存（unstaged）」的狀態。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>雖然 <code class="literal">git reset</code> 命令加上 <code class="literal">--hard</code> 選項會讓它成為一個危險的命令，但在本例中工作目錄內的檔案卻不會被修改到；
這是因為執行沒有附加選項的 <code class="literal">git reset</code> 命令並不危險——它只會修改預存區。</p>
</div>
</aside>
<p>關於 <code class="literal">git reset</code> 命令，到目前為止所有你需要知道的就只有這個神奇用法；
我們將在 <a id="xref--ch07-git-tools--r_git_reset" href="ch07-git-tools.xhtml#r_git_reset" class="xref">Reset Demystified</a> 中深入了解 <code class="literal">reset</code> 更多的細節，包括「它可以做什麼」以及「如何操控它做一些真正有趣的事情」。</p>
</section>
<section class="sect2" title="復原被修改的檔案">
<h3 id="_復原被修改的檔案">復原被修改的檔案</h3>
<p>當你不想要保留 <code class="literal">CONTRIBUTING.md</code> 檔案的修改時該怎麼辦？
你如何才能輕易地復原它——將它還原到上次提交時的樣子（或最初克隆時、或當初放到工作目錄時的版本）？
很幸運的，<code class="literal">git status</code> 也告訴你該如何做；
在上一個範例的輸出中，有修改而未預存的內容長得像這樣：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>它相當明確地提示你如何捨棄工作目錄所做的修改，
讓我們跟著提示做：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -- CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>你可以看到那些修改已經被還原了。</p>
<aside class="admonition important" title="重要" epub:type="warning">
<div class="content">
<p>你必需明瞭一件很重要的事：<code class="literal">git checkout -- &lt;file&gt;</code> 是一個危險的命令，
你對那個檔案所做的任何修改都會消失——Git 只是複製了另一個檔案來覆蓋它；
除非你很肯定地知道你不想要那個檔案了，否則千萬不要使用這個命令。</p>
</div>
</aside>
<p>如果你仍然想保留那個檔案所做的修改，但是某個當下需要先復原檔案，我們將會在 <a href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 中介紹「收藏（stashing）」和「分支（branching）」，一般而言它們是比較好的做法。</p>
<p>切記，在 Git「已提交」的任何東西幾乎總是能夠被復原的，
即使是在被刪除的分支上曾經出現過的提交，或者因為 <code class="literal">--amend</code> 而被覆蓋掉的提交，它們都是可以被復原的（詳見 <a id="xref--ch10-git-internals--r_data_recovery" href="ch10-git-internals.xhtml#r_data_recovery" class="xref">Data Recovery</a> 以了解資料復原）；
然而，從來沒被提交過的內容，失去後大概就沒辦法再救回來了。</p>
</section>
</section>
<section class="sect1" title="與遠端協同工作">
<h2 id="r_remote_repos">與遠端協同工作</h2>
<p>為了能在任意的 Git 專案上協同工作，你需要知道如何管理你的遠端版本庫。
遠端版本庫是指被託管在網際網路或其他網路中的各種專案版本庫。
你可以擁有許多遠端版本庫；通常來說，它如果不是唯讀的，就是可讀寫的。
與其它人協同工作包括了：「管理」遠端版本庫、以及將分享的資料「推送（push）」到端遠版本庫、或者從遠端版本庫「拉取（pull）」分享的資料：
管理遠端版本庫則包括了了解如何：「新增」遠端版本庫、「移除」不再有效的遠端版本庫、管理各式各樣的「遠端分支」、定義遠端分支是否被「追蹤」等等。
我們將在這一節介紹這些遠端管理技巧。</p>
<section class="sect2" title="顯示你的遠端">
<h3 id="_顯示你的遠端">顯示你的遠端</h3>
<p>使用 <code class="literal">git remote</code> 命令可以檢視你已經設定好的遠端版本庫，
它會列出每個遠端版本庫的「簡稱」。
如果你克隆（clone）了一個遠端版本庫，你至少看得到「origin」——它是 Git 給定的預設簡稱，用來代表被克隆的來源。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/ticgit
Cloning into &#39;ticgit&#39;...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> cd ticgit
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
<p>你也可以指定 <code class="literal">-v</code> 選項來顯示 Git 用來讀寫遠端簡稱時所用的網址。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)</code></pre>
</figure>
<p>如果遠端版本庫不止一個，這個命令會將它們全部列出來。
例如，一個版本庫內連結了許多其它協作者的遠端版本庫，可能看起來就像這樣：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd grit
<span style="font-weight: bold">$</span> git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)</code></pre>
</figure>
<p>這意味著我們可以很輕鬆地拉取任何協作者的貢獻；
我們可能對其中某些遠端版本庫還擁有推送權限，不過我們不會在這裡詳述這個部分。</p>
<p>注意：這些遠端版本庫使用了不同的通訊協定；我們將會在 <a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在伺服器上佈署 Git</a> 對它有更多的說明。</p>
</section>
<section class="sect2" title="新增遠端版本庫">
<h3 id="_新增遠端版本庫">新增遠端版本庫</h3>
<p>我們在之前的章節中已經提過並給了一些範例來說明 <code class="literal">clone</code> 命令如何隱式地為你加入 <code class="literal">origin</code> 遠端；
而在這裡將說明如何「明確地」新增一個遠端。
選一個你可以輕鬆引用的簡稱，用來代表要新增的遠端 Git 版本庫，然後執行 <code class="literal">git remote add &lt;簡稱&gt; &lt;url&gt;</code> 來新增它：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote
origin
<span style="font-weight: bold">$</span> git remote add pb https://github.com/paulboone/ticgit
<span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)</code></pre>
</figure>
<p>現在你可以在命令列中使用 <code class="literal">pb</code> 這個字串來代表整個網址；
例如，如果你想從 Paul 的版本庫中取得所有資訊，而這些資訊並不存在於你的版本庫中，你可以執行 <code class="literal">git fetch pb</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -&gt; pb/master
 * [new branch]      ticgit     -&gt; pb/ticgit</code></pre>
</figure>
<p>現在 Paul 的 master 分支可以在本地端透過 <code class="literal">pb/master</code> 存取到（譯註：把 <code class="literal">pb/master</code> 想成 Paul 的 master 在你本地端的「分身」——實際上它被稱為「遠端追蹤分支（remote-tracking branch）」）——你可以把它合併（merge）到你的其中一個分支；或者，如果你想要檢視它的話，可以在它身上檢出（checkout）一個本地分支。
（我們將會在 <a href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 中詳細介紹什麼是分支以及如何使用它們。）</p>
</section>
<section class="sect2" title="從你的遠端獲取或拉取">
<h3 id="r_fetching_and_pulling">從你的遠端獲取或拉取</h3>
<p>如同你剛剛所看到的，要從你的遠端專案中取得資料，你可以執行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch [remote-name]</code></pre>
</figure>
<p>這個命令會連到遠端專案，然後從遠端專案中將你還沒有的資料全部拉下來；
執行完成後，你應該會有那個遠端版本庫中所有分支的參照（reference）（譯註：再次強調，遠端的分支在本地端的分身——遠端追蹤分支），可以隨時用來合併或檢視。</p>
<p>如果你克隆了一個版本庫，<code class="literal">clone</code> 命令會自動增加一個「origin」來代表遠端版本庫；
所以，<code class="literal">git fetch origin</code> 會獲取（fetch）在你克隆（或者最後一次獲取）之後任何被推送到伺服器上的新的工作內容。
很重要的一點是：<code class="literal">git fetch</code> 命令只會下載資料到你的版本庫——它並不會自動合併你的任何工作內容，也不會自動修改你正在修改的東西；
當你準備好合併你的工作內容時，你必需用手動的方式進行合併。</p>
<p>如果你的目前分支被設定為「追蹤」遠端上的分支（閱讀下一節以及 <a href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 以了解更多資訊），你便可使用 <code class="literal">git pull</code> 命令來自動「獲取」並「合併」那個遠端分支到你目前的分支裡去；
由於 <code class="literal">git clone</code> 命令會「自動地」將本地分支 master 設定為「追蹤」遠端上的 master（無論預設分支叫什麼名稱。譯註：只要是預設分支都會自動設定追踨行為，而 master 常常是預設分支），這可能會讓你有比較輕鬆自在的工作流程：
只要執行 <code class="literal">git pull</code> 通常就會從你最初克隆的伺服器上獲取資料，然後試著自動合併到目前的分支。</p>
</section>
<section class="sect2" title="推送到你的遠端">
<h3 id="r_pushing_remotes">推送到你的遠端</h3>
<p>當你想分享你的專案成果時，你必需將它推送到上游。
推送的命令很簡單：<code class="literal">git push [remote-name] [branch-name]</code>。
如果你想要將 master 分支推送到 <code class="literal">origin</code> 伺服器上時（再次說明，克隆時通常會自動地幫你設定好 <code class="literal">master</code> 和 <code class="literal">origin</code> 這二個名稱），那麼你可以執行這個命今將所有你完成的提交（commit）推送回伺服器上。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
<p>只有在你對克隆來源的伺服器有寫入權限，並且在這個當下還沒有其它人推送過，這個命令才會成功；
如果你和其它人同時做了克隆，然後他們先推送到上游，接著換你推送到上游，毫無疑問地你的推送會被拒絕；
你必需先獲取他們的工作內容，將其整併到你之前的工作內容，如此你才會被允許推送。
閱讀 <a href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 以了解更多關於「如何推送到遠端伺服器」的詳細資訊。</p>
</section>
<section class="sect2" title="檢視遠端">
<h3 id="r_inspecting_remote">檢視遠端</h3>
<p>如果你想要對一個特定遠端檢視更多資訊，你可以使用 <code class="literal">git remote show [remote-name]</code> 命令。
如果你在執行這個命令中使用特定的簡稱，例如 <code class="literal">origin</code>，你會得到下面這個類似的訊息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for &#39;git pull&#39;:
    master merges with remote master
  Local ref configured for &#39;git push&#39;:
    master pushes to master (up to date)</code></pre>
</figure>
<p>它同時列出了遠端版本庫的網址和「追蹤分支（tracking branch）」資訊。
這個命令很有用地告訴你：目前分支是 master（譯注：HEAD 意味著目前的），如果你執行 <code class="literal">git pull</code>，它會在獲取所有遠端參照之後，自動將遠端的 master 合併到你的 master 分支。
它也會列出所有已抓下來的遠端參照（譯註：此例中指「master   tracked」和「dev-branch   tracked」）。</p>
<p>這是一個你很可能會遇到的簡單例子；
然而，當你更重度地使用 Git 後，你將會從 <code class="literal">git remote show</code> 中看到更多的資訊：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use &#39;git remote prune&#39; to remove)
  Local branches configured for &#39;git pull&#39;:
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for &#39;git push&#39;:
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)</code></pre>
</figure>
<p>這個命令顯示了當你在特定的分支上執行 <code class="literal">git push</code> 時，它將自動推送到哪一個遠端分支；
它也顯示了：哪些遠端分支是在你的本地端還沒有的（譯註：new 屬性）、哪些你曾獲取過的遠端分支已經在遠端上被移除了（譯註：stale 屬性）、哪些本地分支是有能力在執行 <code class="literal">git pull</code> 後自動和它們的遠端追蹤分支合併。</p>
</section>
<section class="sect2" title="移除或重新命名遠端">
<h3 id="_移除或重新命名遠端">移除或重新命名遠端</h3>
<p>你可以執行 <code class="literal">git remote rename</code> 來重新命名遠端的簡稱。
例如：如果你想要將 <code class="literal">pb</code> 重新命名為 <code class="literal">paul</code>，你可以這樣使用 <code class="literal">git remote rename</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rename pb paul
<span style="font-weight: bold">$</span> git remote
origin
paul</code></pre>
</figure>
<p>值得一提的是：它會更新所有遠端追蹤分支的名稱；
曾經用來被參考的遠端追蹤分支 <code class="literal">pb/master</code> 現在改名為 <code class="literal">paul/master</code>。</p>
<p>如果你因為某些原因想要移除一個遠端——你搬動了伺服器、或者不再使用某個特定的鏡像、或者某個貢獻者不再貢獻了——你可以執行 <code class="literal">git remote rm</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rm paul
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="標籤">
<h2 id="r_git_tagging">標籤</h2>
<p>
跟大多數的版本管理系統一樣，Git 有能力對專案歷史中比較特別的時間點貼標籤，來表示其重要性。
通常大家都會用這個功能來標出發行版本，如 <code class="literal">v1.0</code>…等等。
在這個章節中，你將會學到如何列出所有的標籤，如何建立新的標籤和各種不同的標籤類型。</p>
<section class="sect2" title="列出你的標籤">
<h3 id="_列出你的標籤">列出你的標籤</h3>
<p>想要列出 Git 中所有標籤的方法非常直覺。
只要輸入 <code class="literal">git tag</code> 如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.3</code></pre>
</figure>
<p>這個指令將依字母序列出所有標籤；雖然說標籤用什麼方式列出不是很重要。</p>
<p>你也可以使用特定的 pattern 來搜尋標籤。
舉例來說，在 Git 原始碼的版本庫中，已經包含了超過 500 個標籤。
如果你只想看到 1.8.5 系列的標籤，你可以執行以下指令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -l <span style="font-style: italic">&quot;v1.8.5*&quot;</span>
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
v1.8.5.4
v1.8.5.5</code></pre>
</figure>
</section>
<section class="sect2" title="建立新的標籤">
<h3 id="_建立新的標籤">建立新的標籤</h3>
<p>Git 主要使用兩種類型的標籤：輕量級標籤和有註解的標籤。</p>
<p>一個輕量級的標籤就像是一個不會移動的分支——這個標籤只會指向一個特定的提交。</p>
<p>然而，有註解的標籤，會在 Git 的資料庫中儲存成完整的物件。
它們將被計算校驗碼；包含貼標籤那個人的名字、電子郵件和日期；能夠紀錄一個標籤訊息；並且可以簽署及透過 GNU Privacy Guard (GPG) 驗證。
通常建議你可以建立一個有註解的標籤，以便你可以保留跟這個標籤有關的所有資訊；但是你如果只想要一個暫時的標籤，或是因為某些原因不想保留額外的資訊，你也可以只用輕量級標籤。</p>
</section>
<section class="sect2" title="有註解的標籤">
<h3 id="r_annotated_tags">有註解的標籤</h3>
<p>
建立一個有註解的標籤很簡單。
最簡單的方法是在你建立標籤時，同時指定 <code class="literal">-a</code> 的選項如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.4 -m <span style="font-style: italic">&quot;my version 1.4&quot;</span>
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4</code></pre>
</figure>
<p>指令中的 <code class="literal">-m</code> 選項後面同時指定了一個標籤訊息，這個訊息會和這個標籤一起保存。
如果你沒有為標籤指定一個訊息，那麼 Git 會開啟你的編輯器以便你輸入。</p>
<p>當你使用 <code class="literal">git show</code> 指令時，你可以查看標籤的資訊，還有這個標籤所標記的提交資訊如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4
tag v1.4
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
<p>這樣就可以在提交資訊前顯示出標籤的資訊、標籤被建立的時間以及標籤的訊息。</p>
</section>
<section class="sect2" title="輕量級標籤">
<h3 id="_輕量級標籤">輕量級標籤</h3>
<p>
另外一種能標記提交的標籤是輕量級標籤。
這基本上是把該提交的校驗碼存在一個檔案中，不包含其他資訊。
如果想要建立一個輕量級的標籤，不要指定 <code class="literal">-a</code>、<code class="literal">-s</code> 或 <code class="literal">-m</code> 的選項如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag v1.4-lw
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5</code></pre>
</figure>
<p>此時如果對該標籤使用 <code class="literal">git show</code>，你將不會看到這個標籤的額外資訊。
這個指令就只會顯示標籤所在的提交資訊：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
</section>
<section class="sect2" title="對以前的提交貼標籤">
<h3 id="_對以前的提交貼標籤">對以前的提交貼標籤</h3>
<p>你也可以對過去的提交貼標籤。
假設你的提交歷史看起來如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#39;experiment&#39;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#39;experiment&#39;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</code></pre>
</figure>
<p>現在，假設你忘記在專案的「updated rakefile」提交貼 v1.2 的標籤。
你可以在後來再補貼標籤。
要在那個提交上面貼標籤，你需要在指令後面指定那個提交的校驗碼（可以省略後半段）：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.2 9fceb02</code></pre>
</figure>
<p>你可以看到你已經在那個提交上面貼標籤了：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

<span style="font-weight: bold">$</span> git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...</code></pre>
</figure>
</section>
<section class="sect2" title="分享標籤">
<h3 id="r_sharing_tags">分享標籤</h3>
<p><code class="literal">git push</code> 指令預設不會傳送標籤到遠端伺服器。
在你建立標籤後，你必須明確的要求 Git 將標籤推送到共用的伺服器上面。
這個動作就像是在分享遠端分支一樣——你可以執行 <code class="literal">git push origin [tagname]</code>。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.5 -&gt; v1.5</code></pre>
</figure>
<p>如果想要一次推送很多標籤，也可以在使用 <code class="literal">git push</code> 指令的時候加上 <code class="literal">--tags</code> 選項。
這將會把你所有不在伺服器上面的標籤傳送給遠端伺服器。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.4 -&gt; v1.4
 * [new tag]         v1.4-lw -&gt; v1.4-lw</code></pre>
</figure>
<p>現在，當其他人從版本庫克隆或拉取時，他們就能同時拿到你所貼的標籤，</p>
</section>
<section class="sect2" title="檢出標籤">
<h3 id="_檢出標籤">檢出標籤</h3>
<p>在 Git 中你不能真的檢出一個標籤，因為它們並不能像分支一樣四處移動。
如果你希望工作目錄和版本庫中特定的標籤版本完全一樣，你可以使用 <code class="literal">git checkout -b [branchname] [tagname]</code> 在該標籤上建立一個新分支：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b version2 v2.0.0
Switched to a new branch &#39;version2&#39;</code></pre>
</figure>
<p>當然，如果在建立新分支以後又進行了一次提交，<code class="literal">version2</code> 分支將會和 <code class="literal">v2.0.0</code> 標籤有所差異，因為這個分支已經因為你的提交而改變了，請特別小心。</p>
</section>
</section>
<section class="sect1" title="Git Aliases">
<h2 id="r_git_aliases">Git Aliases</h2>
<p>
在結束「Git 基礎」這個章節以前，在此想和你分享一些使用 Git 的技巧，讓你能夠更簡易且友善的使用 Git——別名（alias）。
在本書的後面章節，我們不會再提到，也不會假設你有使用別名的技巧。 但是你可能會需要知道如何使用它。</p>
<p>如果你只打了某個指令的一部份，Git 並不會自動推測出你想要的指令。
如果你懶得輸入完整的 Git 指令，你可以輕易的使用 <code class="literal">git config</code> 來替指令設定別名。
下面有一些你可能會想要設定別名的範例：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.co checkout
<span style="font-weight: bold">$</span> git config --global alias.br branch
<span style="font-weight: bold">$</span> git config --global alias.ci commit
<span style="font-weight: bold">$</span> git config --global alias.st status</code></pre>
</figure>
<p>舉其中一個例子來說，這樣的設定意味著你可以只打 <code class="literal">git ci</code> 而不需要打 <code class="literal">git commit</code>。
隨著你深入使用 Git，你將會發現某些指令用的很頻繁，不要猶豫，馬上建立新的指令別名。</p>
<p>這個非常有用的技術還能用來創造一些你覺得應該存在的指令。
舉例來說，為了提高 unstage 檔案的方便性，你可以加入你自己的 unstage 別名：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.unstage <span style="font-style: italic">&#39;reset HEAD --&#39;</span></code></pre>
</figure>
<p>而且這個 unstage 別名會讓以下兩個指令有相同的功用：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git unstage fileA
<span style="font-weight: bold">$</span> git reset HEAD -- fileA</code></pre>
</figure>
<p>這樣看起來更加簡單明瞭了。
此外，大家通常還會新增一個 <code class="literal">last</code> 指令如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.last <span style="font-style: italic">&#39;log -1 HEAD&#39;</span></code></pre>
</figure>
<p>如此一來，你可以更簡易的看到最後的提交訊息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</code></pre>
</figure>
<p>如你所見，Git 會將別名直接取代成你別名內設定的指令。
然而，你可能會想要執行一個外部指令，而非 git 下的子指令。
在這個情況下，你需要在指令的開頭加個 <code class="literal">!</code> 字元。
這個技巧在你如果想為 Git 倉儲撰寫自製工具時很有用。
我們可以用以下的範例設定 <code class="literal">git visual</code> 執行 <code class="literal">gitk</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.visual <span style="font-style: italic">&#39;!gitk&#39;</span></code></pre>
</figure>
</section>
<section class="sect1" title="總結">
<h2 id="_總結">總結</h2>
<p class="last">現在，您可以完成所有基本的 Git 本地操作——創建或者克隆一個倉儲、修改檔案、預存並提交這些更改、瀏覽倉儲過去的所有更改歷史。
下一步，本書將介紹 Git 的殺手級功能：Git 的分支模型。</p>
</section>
</section>
</body>
</html>