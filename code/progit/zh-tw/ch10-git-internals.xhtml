<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git Internals</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git Internals" epub:type="chapter" id="ch10-git-internals">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>Internals</b></small></h1>
</div>
</header>
<p>You may have skipped to this chapter from a previous chapter, or you may have gotten here after reading the rest of the book – in either case, this is where we&#8217;ll go over the inner workings and implementation of Git.
We found that learning this information was fundamentally important to understanding how useful and powerful Git is, but others have argued to us that it can be confusing and unnecessarily complex for beginners.
Thus, we&#8217;ve made this discussion the last chapter in the book so you could read it early or later in your learning process.
We leave it up to you to decide.</p>
<p>Now that you&#8217;re here, let&#8217;s get started.
First, if it isn&#8217;t yet clear, Git is fundamentally a content-addressable filesystem with a VCS user interface written on top of it.
You&#8217;ll learn more about what this means in a bit.</p>
<p>In the early days of Git (mostly pre 1.5), the user interface was much more complex because it emphasized this filesystem rather than a polished VCS.
In the last few years, the UI has been refined until it&#8217;s as clean and easy to use as any system out there; but often, the stereotype lingers about the early Git UI that was complex and difficult to learn.</p>
<p>The content-addressable filesystem layer is amazingly cool, so we&#8217;ll cover that first in this chapter; then, you&#8217;ll learn about the transport mechanisms and the repository maintenance tasks that you may eventually have to deal with.</p>
<section class="sect1" title="Plumbing and Porcelain">
<h2 id="r_plumbing_porcelain">Plumbing and Porcelain</h2>
<p>This book covers how to use Git with 30 or so verbs such as <code class="literal">checkout</code>, <code class="literal">branch</code>, <code class="literal">remote</code>, and so on.
But because Git was initially a toolkit for a VCS rather than a full user-friendly VCS, it has a bunch of verbs that do low-level work and were designed to be chained together UNIX style or called from scripts.
These commands are generally referred to as “plumbing” commands, and the more user-friendly commands are called “porcelain” commands.</p>
<p>The book&#8217;s first nine chapters deal almost exclusively with porcelain commands.
But in this chapter, you&#8217;ll be dealing mostly with the lower-level plumbing commands, because they give you access to the inner workings of Git, and help demonstrate how and why Git does what it does.
Many of these commands aren&#8217;t meant to be used manually on the command line, but rather to be used as building blocks for new tools and custom scripts.</p>
<p>When you run <code class="literal">git init</code> in a new or existing directory, Git creates the <code class="literal">.git</code> directory, which is where almost everything that Git stores and manipulates is located.
If you want to back up or clone your repository, copying this single directory elsewhere gives you nearly everything you need.
This entire chapter basically deals with the stuff in this directory.
Here&#8217;s what it looks like:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls -F1
HEAD
config*
description
hooks/
info/
objects/
refs/</code></pre>
</figure>
<p>You may see some other files in there, but this is a fresh <code class="literal">git init</code> repository – it&#8217;s what you see by default.
The <code class="literal">description</code> file is only used by the GitWeb program, so don&#8217;t worry about it.
The <code class="literal">config</code> file contains your project-specific configuration options, and the <code class="literal">info</code> directory keeps a global exclude file  for ignored patterns that you don&#8217;t want to track in a .gitignore file.
The <code class="literal">hooks</code> directory contains your client- or server-side hook scripts, which are discussed in detail in <a id="xref--ch08-customizing-git--r_git_hooks" href="ch08-customizing-git.xhtml#r_git_hooks" class="xref">Git Hooks</a>.</p>
<p>This leaves four important entries: the <code class="literal">HEAD</code> and (yet to be created) <code class="literal">index</code> files, and the <code class="literal">objects</code> and <code class="literal">refs</code> directories.
These are the core parts of Git.
The <code class="literal">objects</code> directory stores all the content for your database, the <code class="literal">refs</code> directory stores pointers into commit objects in that data (branches), the <code class="literal">HEAD</code> file points to the branch you currently have checked out, and the <code class="literal">index</code> file is where Git stores your staging area information.
You&#8217;ll now look at each of these sections in detail to see how Git operates.</p>
</section>
<section class="sect1" title="Git Objects">
<h2 id="r_objects">Git Objects</h2>
<p>Git is a content-addressable filesystem.
Great.
What does that mean?
It means that at the core of Git is a simple key-value data store.
You can insert any kind of content into it, and it will give you back a key that you can use to retrieve the content again at any time.
To demonstrate, you can use the plumbing command <code class="literal">hash-object</code>, which takes some data, stores it in your <code class="literal">.git</code> directory, and gives you back the key the data is stored as.
First, you initialize a new Git repository and verify that there is nothing in the <code class="literal">objects</code> directory:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init test
Initialized empty Git repository in /tmp/test/.git/
<span style="font-weight: bold">$</span> cd test
<span style="font-weight: bold">$</span> find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
<span style="font-weight: bold">$</span> find .git/objects -type f</code></pre>
</figure>
<p>Git has initialized the <code class="literal">objects</code> directory and created <code class="literal">pack</code> and <code class="literal">info</code> subdirectories in it, but there are no regular files.
Now, store some text in your Git database:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;test content&#39;</span> | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>The <code class="literal">-w</code> tells <code class="literal">hash-object</code> to store the object; otherwise, the command simply tells you what the key would be.
<code class="literal">--stdin</code> tells the command to read the content from stdin; if you don&#8217;t specify this, <code class="literal">hash-object</code> expects a file path at the end.
The output from the command is a 40-character checksum hash.
This is the SHA-1 hash – a checksum of the content you&#8217;re storing plus a header, which you&#8217;ll learn about in a bit.
Now you can see how Git has stored your data:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>You can see a file in the <code class="literal">objects</code> directory.
This is how Git stores the content initially – as a single file per piece of content, named with the SHA-1 checksum of the content and its header.
The subdirectory is named with the first 2 characters of the SHA-1, and the filename is the remaining 38 characters.</p>
<p>You can pull the content back out of Git with the <code class="literal">cat-file</code> command.
This command is sort of a Swiss army knife for inspecting Git objects.
Passing <code class="literal">-p</code> to it instructs the <code class="literal">cat-file</code> command to figure out the type of content and display it nicely for you:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>
</figure>
<p>Now, you can add content to Git and pull it back out again.
You can also do this with content in files.
For example, you can do some simple version control on a file.
First, create a new file and save its contents in your database:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;version 1&#39;</span> &gt; test.txt
<span style="font-weight: bold">$</span> git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</code></pre>
</figure>
<p>Then, write some new content to the file, and save it again:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;version 2&#39;</span> &gt; test.txt
<span style="font-weight: bold">$</span> git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>
</figure>
<p>Your database contains the two new versions of the file as well as the first content you stored there:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</figure>
<p>Now you can revert the file back to the first version</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
<span style="font-weight: bold">$</span> cat test.txt
version 1</code></pre>
</figure>
<p>or the second version:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
<span style="font-weight: bold">$</span> cat test.txt
version 2</code></pre>
</figure>
<p>But remembering the SHA-1 key for each version of your file isn&#8217;t practical; plus, you aren&#8217;t storing the filename in your system – just the content.
This object type is called a blob.
You can have Git tell you the object type of any object in Git, given its SHA-1 key, with <code class="literal">cat-file -t</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>
</figure>
<section class="sect2" title="Tree Objects">
<h3 id="r_tree_objects">Tree Objects</h3>
<p>The next type we&#8217;ll look at is the tree, which solves the problem of storing the filename and also allows you to store a group of files together.
Git stores content in a manner similar to a UNIX filesystem, but a bit simplified.
All the content is stored as tree and blob objects, with trees corresponding to UNIX directory entries and blobs corresponding more or less to inodes or file contents.
A single tree object contains one or more tree entries, each of which contains a SHA-1 pointer to a blob or subtree with its associated mode, type, and filename.
For example, the most recent tree in a project may look something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>
</figure>
<p>The <code class="literal">master^{tree}</code> syntax specifies the tree object that is pointed to by the last commit on your <code class="literal">master</code> branch.
Notice that the <code class="literal">lib</code> subdirectory isn&#8217;t a blob but a pointer to another tree:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>
</figure>
<p>Conceptually, the data that Git is storing is something like this:</p>
<figure class="image">
<div class="content">
<img src="images/data-model-1.png" alt="Simple version of the Git data model."/>
</div>
<figcaption>圖表 1. Simple version of the Git data model.</figcaption>
</figure>
<p>You can fairly easily create your own tree.
Git normally creates a tree by taking the state of your staging area or index and writing a series of tree objects from it.
So, to create a tree object, you first have to set up an index by staging some files.
To create an index with a single entry – the first version of your <code class="literal">test.txt</code> file – you can use the plumbing command <code class="literal">update-index</code>.
You use this command to artificially add the earlier version of the <code class="literal">test.txt</code> file to a new staging area.
You must pass it the <code class="literal">--add</code> option because the file doesn&#8217;t yet exist in your staging area (you don&#8217;t even have a staging area set up yet) and <code class="literal">--cacheinfo</code> because the file you&#8217;re adding isn&#8217;t in your directory but is in your database.
Then, you specify the mode, SHA-1, and filename:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-index --add --cacheinfo 100644 <span style="font-weight: bold; font-style: italic">\</span>
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>
</figure>
<p>In this case, you&#8217;re specifying a mode of <code class="literal">100644</code>, which means it&#8217;s a normal file.
Other options are <code class="literal">100755</code>, which means it&#8217;s an executable file; and <code class="literal">120000</code>, which specifies a symbolic link.
The mode is taken from normal UNIX modes but is much less flexible – these three modes are the only ones that are valid for files (blobs) in Git (although other modes are used for directories and submodules).</p>
<p>Now, you can use the <code class="literal">write-tree</code> command to write the staging area out to a tree object.
No <code class="literal">-w</code> option is needed – calling <code class="literal">write-tree</code> automatically creates a tree object from the state of the index if that tree doesn&#8217;t yet exist:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span style="font-weight: bold">$</span> git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>
</figure>
<p>You can also verify that this is a tree object:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>
</figure>
<p>You&#8217;ll now create a new tree with the second version of <code class="literal">test.txt</code> and a new file as well:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;new file&#39;</span> &gt; new.txt
<span style="font-weight: bold">$</span> git update-index test.txt
<span style="font-weight: bold">$</span> git update-index --add new.txt</code></pre>
</figure>
<p>Your staging area now has the new version of <code class="literal">test.txt</code> as well as the new file <code class="literal">new.txt</code>.
Write out that tree (recording the state of the staging area or index to a tree object) and see what it looks like:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
<span style="font-weight: bold">$</span> git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</figure>
<p>Notice that this tree has both file entries and also that the <code class="literal">test.txt</code> SHA-1 is the “version 2” SHA-1 from earlier (<code class="literal">1f7a7a</code>).
Just for fun, you&#8217;ll add the first tree as a subdirectory into this one.
You can read trees into your staging area by calling <code class="literal">read-tree</code>.
In this case, you can read an existing tree into your staging area as a subtree by using the <code class="literal">--prefix</code> option to <code class="literal">read-tree</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span style="font-weight: bold">$</span> git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
<span style="font-weight: bold">$</span> git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</figure>
<p>If you created a working directory from the new tree you just wrote, you would get the two files in the top level of the working directory and a subdirectory named <code class="literal">bak</code> that contained the first version of the <code class="literal">test.txt</code> file.
You can think of the data that Git contains for these structures as being like this:</p>
<figure class="image">
<div class="content">
<img src="images/data-model-2.png" alt="The content structure of your current Git data."/>
</div>
<figcaption>圖表 2. The content structure of your current Git data.</figcaption>
</figure>
</section>
<section class="sect2" title="Commit Objects">
<h3 id="r_git_commit_objects">Commit Objects</h3>
<p>You have three trees that specify the different snapshots of your project that you want to track, but the earlier problem remains: you must remember all three SHA-1 values in order to recall the snapshots.
You also don&#8217;t have any information about who saved the snapshots, when they were saved, or why they were saved.
This is the basic information that the commit object stores for you.</p>
<p>To create a commit object, you call <code class="literal">commit-tree</code> and specify a single tree SHA-1 and which commit objects, if any, directly preceded it.
Start with the first tree you wrote:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;first commit&#39;</span> | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>
</figure>
<p>You will get a different hash value because of different creation time and author data.
Replace commit and tag hashes with your own checksums further in this chapter.
Now you can look at your new commit object with <code class="literal">cat-file</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</code></pre>
</figure>
<p>The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information (which uses your <code class="literal">user.name</code> and <code class="literal">user.email</code> configuration settings and a timestamp); a blank line, and then the commit message.</p>
<p>Next, you&#8217;ll write the other two commit objects, each referencing the commit that came directly before it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;second commit&#39;</span> | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
<span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;third commit&#39;</span>  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>Each of the three commit objects points to one of the three snapshot trees you created.
Oddly enough, you have a real Git history now that you can view with the <code class="literal">git log</code> command, if you run it on the last commit SHA-1:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Amazing.
You&#8217;ve just done the low-level operations to build up a Git history without using any of the front end commands.
This is essentially what Git does when you run the <code class="literal">git add</code> and <code class="literal">git commit</code> commands – it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.
These three main Git objects – the blob, the tree, and the commit – are initially stored as separate files in your <code class="literal">.git/objects</code> directory.
Here are all the objects in the example directory now, commented with what they store:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &#39;test content&#39;
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</figure>
<p>If you follow all the internal pointers, you get an object graph something like this:</p>
<figure class="image">
<div class="content">
<img src="images/data-model-3.png" alt="All the objects in your Git directory."/>
</div>
<figcaption>圖表 3. All the objects in your Git directory.</figcaption>
</figure>
</section>
<section class="sect2" title="Object Storage">
<h3 id="_object_storage">Object Storage</h3>
<p>We mentioned earlier that a header is stored with the content.
Let&#8217;s take a minute to look at how Git stores its objects.
You&#8217;ll see how to store a blob object – in this case, the string “what is up, doc?” – interactively in the Ruby scripting language.</p>
<p>You can start up interactive Ruby mode with the <code class="literal">irb</code> command:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> irb
<span style="font-weight: bold">&gt;</span>&gt; content = <span style="font-style: italic">&quot;what is up, doc?&quot;</span>
=&gt; &quot;what is up, doc?&quot;</code></pre>
</figure>
<p>Git constructs a header that starts with the type of the object, in this case a blob.
Then, it adds a space followed by the size of the content and finally a null byte:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; header = <span style="font-style: italic">&quot;blob #{content.length}\0&quot;</span>
=&gt; &quot;blob 16\u0000&quot;</code></pre>
</figure>
<p>Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content.
You can calculate the SHA-1 value of a string in Ruby by including the SHA1 digest library with the <code class="literal">require</code> command and then calling <code class="literal">Digest::SHA1.hexdigest()</code> with the string:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; store = header + content
=&gt; &quot;blob 16\u0000what is up, doc?&quot;
<span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;digest/sha1&#39;</span>
=&gt; true
<span style="font-weight: bold">&gt;</span>&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</code></pre>
</figure>
<p>Git compresses the new content with zlib, which you can do in Ruby with the zlib library.
First, you need to require the library and then run <code class="literal">Zlib::Deflate.deflate()</code> on the content:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;zlib&#39;</span>
=&gt; true
<span style="font-weight: bold">&gt;</span>&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; &quot;x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D&quot;</code></pre>
</figure>
<p>Finally, you&#8217;ll write your zlib-deflated content to an object on disk.
You&#8217;ll determine the path of the object you want to write out (the first two characters of the SHA-1 value being the subdirectory name, and the last 38 characters being the filename within that directory).
In Ruby, you can use the <code class="literal">FileUtils.mkdir_p()</code> function to create the subdirectory if it doesn&#8217;t exist.
Then, open the file with <code class="literal">File.open()</code> and write out the previously zlib-compressed content to the file with a <code class="literal">write()</code> call on the resulting file handle:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">&gt;</span>&gt; path = <span style="font-style: italic">&#39;.git/objects/&#39;</span> + sha1[0,2] + <span style="font-style: italic">&#39;/&#39;</span> + sha1[2,38]
=&gt; &quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;
<span style="font-weight: bold">&gt;</span>&gt; require <span style="font-style: italic">&#39;fileutils&#39;</span>
=&gt; true
<span style="font-weight: bold">&gt;</span>&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; &quot;.git/objects/bd&quot;
<span style="font-weight: bold">&gt;</span>&gt; File.open(path, <span style="font-style: italic">&#39;w&#39;</span>) { |f| f.write zlib_content }
=&gt; 32</code></pre>
</figure>
<p>That&#8217;s it – you&#8217;ve created a valid Git blob object.
All Git objects are stored the same way, just with different types – instead of the string blob, the header will begin with commit or tree.
Also, although the blob content can be nearly anything, the commit and tree content are very specifically formatted.</p>
</section>
</section>
<section class="sect1" title="Git References">
<h2 id="r_git_refs">Git References</h2>
<p>You can run something like <code class="literal">git log 1a410e</code> to look through your whole history, but you still have to remember that <code class="literal">1a410e</code> is the last commit in order to walk that history to find all those objects.
You need a file in which you can store the SHA-1 value under a simple name so you can use that pointer rather than the raw SHA-1 value.</p>
<p>In Git, these are called “references” or “refs”; you can find the files that contain the SHA-1 values in the <code class="literal">.git/refs</code> directory.
In the current project, this directory contains no files, but it does contain a simple structure:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
<span style="font-weight: bold">$</span> find .git/refs -type f</code></pre>
</figure>
<p>To create a new reference that will help you remember where your latest commit is, you can technically do something as simple as this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot;</span> &gt; .git/refs/heads/master</code></pre>
</figure>
<p>Now, you can use the head reference you just created instead of the SHA-1 value in your Git commands:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>You aren&#8217;t encouraged to directly edit the reference files.
Git provides a safer command to do this if you want to update a reference called <code class="literal">update-ref</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>That&#8217;s basically what a branch in Git is: a simple pointer or reference to the head of a line of work.
To create a branch back at the second commit, you can do this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/heads/test cac0ca</code></pre>
</figure>
<p>Your branch will contain only work from that commit down:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Now, your Git database conceptually looks something like this:</p>
<figure class="image">
<div class="content">
<img src="images/data-model-4.png" alt="Git directory objects with branch head references included."/>
</div>
<figcaption>圖表 4. Git directory objects with branch head references included.</figcaption>
</figure>
<p>When you run commands like <code class="literal">git branch (branchname)</code>, Git basically runs that <code class="literal">update-ref</code> command to add the SHA-1 of the last commit of the branch you&#8217;re on into whatever new reference you want to create.</p>
<section class="sect2" title="The HEAD">
<h3 id="r_the_head">The HEAD</h3>
<p>The question now is, when you run <code class="literal">git branch (branchname)</code>, how does Git know the SHA-1 of the last commit?
The answer is the HEAD file.</p>
<p>The HEAD file is a symbolic reference to the branch you&#8217;re currently on.
By symbolic reference, we mean that unlike a normal reference, it doesn’t generally contain a SHA-1 value but rather a pointer to another reference.
If you look at the file, you&#8217;ll normally see something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/master</code></pre>
</figure>
<p>If you run <code class="literal">git checkout test</code>, Git updates the file to look like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/test</code></pre>
</figure>
<p>When you run <code class="literal">git commit</code>, it creates the commit object, specifying the parent of that commit object to be whatever SHA-1 value the reference in HEAD points to.</p>
<p>You can also manually edit this file, but again a safer command exists to do so: <code class="literal">symbolic-ref</code>.
You can read the value of your HEAD via this command:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD
refs/heads/master</code></pre>
</figure>
<p>You can also set the value of HEAD:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD refs/heads/test
<span style="font-weight: bold">$</span> cat .git/HEAD
ref: refs/heads/test</code></pre>
</figure>
<p>You can&#8217;t set a symbolic reference outside of the refs style:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</figure>
</section>
<section class="sect2" title="Tags">
<h3 id="_tags">Tags</h3>
<p>We just finished discussing Git&#8217;s three main object types, but there is a fourth.
The tag object is very much like a commit object – it contains a tagger, a date, a message, and a pointer.
The main difference is that a tag object generally points to a commit rather than a tree.
It&#8217;s like a branch reference, but it never moves – it always points to the same commit but gives it a friendlier name.</p>
<p>As discussed in <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git 基礎</a>, there are two types of tags: annotated and lightweight.
You can make a lightweight tag by running something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</figure>
<p>That is all a lightweight tag is – a reference that never moves.
An annotated tag is more complex, however.
If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit.
You can see this by creating an annotated tag (<code class="literal">-a</code> specifies that it&#8217;s an annotated tag):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span style="font-style: italic">&#39;test tag&#39;</span></code></pre>
</figure>
<p>Here&#8217;s the object SHA-1 value it created:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</figure>
<p>Now, run the <code class="literal">cat-file</code> command on that SHA-1 value:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</figure>
<p>Notice that the object entry points to the commit SHA-1 value that you tagged.
Also notice that it doesn&#8217;t need to point to a commit; you can tag any Git object.
In the Git source code, for example, the maintainer has added their GPG public key as a blob object and then tagged it.
You can view the public key by running this in a clone of the Git repository:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file blob junio-gpg-pub</code></pre>
</figure>
<p>The Linux kernel repository also has a non-commit-pointing tag object – the first tag created points to the initial tree of the import of the source code.</p>
</section>
<section class="sect2" title="Remotes">
<h3 id="_remotes">Remotes</h3>
<p>The third type of reference that you&#8217;ll see is a remote reference.
If you add a remote and push to it, Git stores the value you last pushed to that remote for each branch in the <code class="literal">refs/remotes</code> directory.
For instance, you can add a remote called <code class="literal">origin</code> and push your <code class="literal">master</code> branch to it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@github.com:schacon/simplegit-progit.git
<span style="font-weight: bold">$</span> git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</figure>
<p>Then, you can see what the <code class="literal">master</code> branch on the <code class="literal">origin</code> remote was the last time you communicated with the server, by checking the <code class="literal">refs/remotes/origin/master</code> file:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</figure>
<p>Remote references differ from branches (<code class="literal">refs/heads</code> references) mainly in that they&#8217;re considered read-only.
You can <code class="literal">git checkout</code> to one, but Git won&#8217;t point HEAD at one, so you&#8217;ll never update it with a <code class="literal">commit</code> command.
Git manages them as bookmarks to the last known state of where those branches were on those servers.</p>
</section>
</section>
<section class="sect1" title="Packfiles">
<h2 id="_packfiles">Packfiles</h2>
<p>Let&#8217;s go back to the objects database for your test Git repository.
At this point, you have 11 objects – 4 blobs, 3 trees, 3 commits, and 1 tag:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &#39;test content&#39;
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</figure>
<p>Git compresses the contents of these files with zlib, and you&#8217;re not storing much, so all these files collectively take up only 925 bytes.
You&#8217;ll add some larger content to the repository to demonstrate an interesting feature of Git.
To demonstrate, we&#8217;ll add the <code class="literal">repo.rb</code> file from the Grit library – this is about a 22K source code file:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb
<span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git add repo.rb
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;added repo.rb&#39;</span>
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)</code></pre>
</figure>
<p>If you look at the resulting tree, you can see the SHA-1 value your repo.rb file got for the blob object:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>
</figure>
<p>You can then use <code class="literal">git cat-file</code> to see how big that object is:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044</code></pre>
</figure>
<p>Now, modify that file a little, and see what happens:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# testing&#39;</span> &gt;&gt; repo.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;modified repo a bit&#39;</span>
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>Check the tree created by that commit, and you see something interesting:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>
</figure>
<p>The blob is now a different blob, which means that although you added only a single line to the end of a 400-line file, Git stored that new content as a completely new object:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054</code></pre>
</figure>
<p>You have two nearly identical 22K objects on your disk (each compressed to approximately 7K).
Wouldn&#8217;t it be nice if Git could store one of them in full but then the second object only as the delta between it and the first?</p>
<p>It turns out that it can.
The initial format in which Git saves objects on disk is called a “loose” object format.
However, occasionally Git packs up several of these objects into a single binary file called a “packfile” in order to save space and be more efficient.
Git does this if you have too many loose objects around, if you run the <code class="literal">git gc</code> command manually, or if you push to a remote server.
To see what happens, you can manually ask Git to pack up the objects by calling the <code class="literal">git gc</code> command:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)</code></pre>
</figure>
<p>If you look in your objects directory, you&#8217;ll find that most of your objects are gone, and a new pair of files has appeared:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</code></pre>
</figure>
<p>The objects that remain are the blobs that aren&#8217;t pointed to by any commit – in this case, the “what is up, doc?” example and the “test content” example blobs you created earlier.
Because you never added them to any commits, they&#8217;re considered dangling and aren&#8217;t packed up in your new packfile.</p>
<p>The other files are your new packfile and an index.
The packfile is a single file containing the contents of all the objects that were removed from your filesystem.
The index is a file that contains offsets into that packfile so you can quickly seek to a specific object.
What is cool is that although the objects on disk before you ran the <code class="literal">gc</code> were collectively about 15K in size, the new packfile is only 7K.
You&#8217;ve cut your disk usage by half by packing your objects.</p>
<p>How does Git do this?
When Git packs objects, it looks for files that are named and sized similarly, and stores just the deltas from one version of the file to the next.
You can look into the packfile and see what Git did to save space.
The <code class="literal">git verify-pack</code> plumbing command allows you to see what was packed up:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</code></pre>
</figure>
<p>Here, the <code class="literal">033b4</code> blob, which if you remember was the first version of your repo.rb file, is referencing the <code class="literal">b042a</code> blob, which was the second version of the file.
The third column in the output is the size of the object in the pack, so you can see that <code class="literal">b042a</code> takes up 22K of the file, but that <code class="literal">033b4</code> only takes up 9 bytes.
What is also interesting is that the second version of the file is the one that is stored intact, whereas the original version is stored as a delta – this is because you&#8217;re most likely to need faster access to the most recent version of the file.</p>
<p>The really nice thing about this is that it can be repacked at any time.
Git will occasionally repack your database automatically, always trying to save more space, but you can also manually repack at any time by running <code class="literal">git gc</code> by hand.</p>
</section>
<section class="sect1" title="The Refspec">
<h2 id="r_refspec">The Refspec</h2>
<p>Throughout this book, we&#8217;ve used simple mappings from remote branches to local references, but they can be more complex.
Suppose you add a remote like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin https://github.com/schacon/simplegit-progit</code></pre>
</figure>
<p>It adds a section to your <code class="literal">.git/config</code> file, specifying the name of the remote (<code class="literal">origin</code>), the URL of the remote repository, and the refspec for fetching:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/*:refs/remotes/origin/*</span></code></pre>
</figure>
<p>The format of the refspec is an optional <code class="literal">+</code>, followed by <code class="literal">&lt;src&gt;:&lt;dst&gt;</code>, where <code class="literal">&lt;src&gt;</code> is the pattern for references on the remote side and <code class="literal">&lt;dst&gt;</code> is where those references will be written locally.
The <code class="literal">+</code> tells Git to update the reference even if it isn&#8217;t a fast-forward.</p>
<p>In the default case that is automatically written by a <code class="literal">git remote add</code> command, Git fetches all the references under <code class="literal">refs/heads/</code> on the server and writes them to <code class="literal">refs/remotes/origin/</code> locally.
So, if there is a <code class="literal">master</code> branch on the server, you can access the log of that branch locally via</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log origin/master
<span style="font-weight: bold">$</span> git log remotes/origin/master
<span style="font-weight: bold">$</span> git log refs/remotes/origin/master</code></pre>
</figure>
<p>They&#8217;re all equivalent, because Git expands each of them to <code class="literal">refs/remotes/origin/master</code>.</p>
<p>If you want Git instead to pull down only the <code class="literal">master</code> branch each time, and not every other branch on the remote server, you can change the fetch line to</p>
<figure class="listing">
<pre class="source language-"><code>fetch = +refs/heads/master:refs/remotes/origin/master</code></pre>
</figure>
<p>This is just the default refspec for <code class="literal">git fetch</code> for that remote.
If you want to do something one time, you can specify the refspec on the command line, too.
To pull the <code class="literal">master</code> branch on the remote down to <code class="literal">origin/mymaster</code> locally, you can run</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin master:refs/remotes/origin/mymaster</code></pre>
</figure>
<p>You can also specify multiple refspecs.
On the command line, you can pull down several branches like so:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin master:refs/remotes/origin/mymaster <span style="font-weight: bold; font-style: italic">\</span>
	 topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
 ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)
 * [new branch]      topic      -&gt; origin/topic</code></pre>
</figure>
<p>In this case, the <code class="literal">master</code> branch pull was rejected because it wasn&#8217;t a fast-forward reference.
You can override that by specifying the <code class="literal">+</code> in front of the refspec.</p>
<p>You can also specify multiple refspecs for fetching in your configuration file.
If you want to always fetch the <code class="literal">master</code> and <code class="literal">experiment</code> branches, add two lines:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/master:refs/remotes/origin/master</span>
<span style="font-style: italic">	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span></code></pre>
</figure>
<p>You can&#8217;t use partial globs in the pattern, so this would be invalid:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>fetch = <span style="font-style: italic">+refs/heads/qa*:refs/remotes/origin/qa*</span></code></pre>
</figure>
<p>However, you can use namespaces (or directories) to accomplish something like that.
If you have a QA team that pushes a series of branches, and you want to get the <code class="literal">master</code> branch and any of the QA team&#8217;s branches but nothing else, you can use a config section like this:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/master:refs/remotes/origin/master</span>
<span style="font-style: italic">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span></code></pre>
</figure>
<p>If you have a complex workflow process that has a QA team pushing branches, developers pushing branches, and integration teams pushing and collaborating on remote branches, you can namespace them easily this way.</p>
<section class="sect2" title="Pushing Refspecs">
<h3 id="r_pushing_refspecs">Pushing Refspecs</h3>
<p>It&#8217;s nice that you can fetch namespaced references that way, but how does the QA team get their branches into a <code class="literal">qa/</code> namespace in the first place?
You accomplish that by using refspecs to push.</p>
<p>If the QA team wants to push their <code class="literal">master</code> branch to <code class="literal">qa/master</code> on the remote server, they can run</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master:refs/heads/qa/master</code></pre>
</figure>
<p>If they want Git to do that automatically each time they run <code class="literal">git push origin</code>, they can add a <code class="literal">push</code> value to their config file:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
	url = <span style="font-style: italic">https://github.com/schacon/simplegit-progit</span>
<span style="font-style: italic">	fetch = +refs/heads/*:refs/remotes/origin/*</span>
<span style="font-style: italic">	push = refs/heads/master:refs/heads/qa/master</span></code></pre>
</figure>
<p>Again, this will cause a <code class="literal">git push origin</code> to push the local <code class="literal">master</code> branch to the remote <code class="literal">qa/master</code> branch by default.</p>
</section>
<section class="sect2" title="Deleting References">
<h3 id="_deleting_references">Deleting References</h3>
<p>You can also use the refspec to delete references from the remote server by running something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin :topic</code></pre>
</figure>
<p>Because the refspec is <code class="literal">&lt;src&gt;:&lt;dst&gt;</code>, by leaving off the <code class="literal">&lt;src&gt;</code> part, this basically says to make the <code class="literal">topic</code> branch on the remote nothing, which deletes it.</p>
</section>
</section>
<section class="sect1" title="Transfer Protocols">
<h2 id="_transfer_protocols">Transfer Protocols</h2>
<p>Git can transfer data between two repositories in two major ways: the “dumb” protocol and the “smart” protocol.
This section will quickly cover how these two main protocols operate.</p>
<section class="sect2" title="The Dumb Protocol">
<h3 id="_the_dumb_protocol">The Dumb Protocol</h3>
<p>If you&#8217;re setting up a repository to be served read-only over HTTP, the dumb protocol is likely what will be used.
This protocol is called “dumb” because it requires no Git-specific code on the server side during the transport process; the fetch process is a series of HTTP <code class="literal">GET</code> requests, where the client can assume the layout of the Git repository on the server.</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>The dumb protocol is fairly rarely used these days.
It&#8217;s difficult to secure or make private, so most Git hosts (both cloud-based and on-premises) will refuse to use it.
It&#8217;s generally advised to use the smart protocol, which we describe a bit further on.</p>
</div>
</aside>
<p>Let&#8217;s follow the <code class="literal">http-fetch</code> process for the simplegit library:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone http://server/simplegit-progit.git</code></pre>
</figure>
<p>The first thing this command does is pull down the <code class="literal">info/refs</code> file.
This file is written by the <code class="literal">update-server-info</code> command, which is why you need to enable that as a <code class="literal">post-receive</code> hook in order for the HTTP transport to work properly:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>
</figure>
<p>Now you have a list of the remote references and SHA-1s.
Next, you look for what the HEAD reference is so you know what to check out when you&#8217;re finished:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>
</figure>
<p>You need to check out the <code class="literal">master</code> branch when you&#8217;ve completed the process.
At this point, you&#8217;re ready to start the walking process.
Because your starting point is the <code class="literal">ca82a6</code> commit object you saw in the <code class="literal">info/refs</code> file, you start by fetching that:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>
</figure>
<p>You get an object back – that object is in loose format on the server, and you fetched it over a static HTTP GET request.
You can zlib-uncompress it, strip off the header, and look at the commit content:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</figure>
<p>Next, you have two more objects to retrieve – <code class="literal">cfda3b</code>, which is the tree of content that the commit we just retrieved points to; and <code class="literal">085bb3</code>, which is the parent commit:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>
</figure>
<p>That gives you your next commit object.
Grab the tree object:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>
</figure>
<p>Oops – it looks like that tree object isn&#8217;t in loose format on the server, so you get a 404 response back.
There are a couple of reasons for this – the object could be in an alternate repository, or it could be in a packfile in this repository.
Git checks for any listed alternates first:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>
</figure>
<p>If this comes back with a list of alternate URLs, Git checks for loose files and packfiles there – this is a nice mechanism for projects that are forks of one another to share objects on disk.
However, because no alternates are listed in this case, your object must be in a packfile.
To see what packfiles are available on this server, you need to get the <code class="literal">objects/info/packs</code> file, which contains a listing of them (also generated by <code class="literal">update-server-info</code>):</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>
</figure>
<p>There is only one packfile on the server, so your object is obviously in there, but you&#8217;ll check the index file to make sure.
This is also useful if you have multiple packfiles on the server, so you can see which packfile contains the object you need:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>
</figure>
<p>Now that you have the packfile index, you can see if your object is in it – because the index lists the SHA-1s of the objects contained in the packfile and the offsets to those objects.
Your object is there, so go ahead and get the whole packfile:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>
</figure>
<p>You have your tree object, so you continue walking your commits.
They&#8217;re all also within the packfile you just downloaded, so you don&#8217;t have to do any more requests to your server.
Git checks out a working copy of the <code class="literal">master</code> branch that was pointed to by the HEAD reference you downloaded at the beginning.</p>
</section>
<section class="sect2" title="The Smart Protocol">
<h3 id="_the_smart_protocol">The Smart Protocol</h3>
<p>The dumb protocol is simple but a bit inefficient, and it can&#8217;t handle writing of data from the client to the server.
The smart protocol is a more common method of transferring data, but it requires a process on the remote end that is intelligent about Git – it can read local data, figure out what the client has and needs, and generate a custom packfile for it.
There are two sets of processes for transferring data: a pair for uploading data and a pair for downloading data.</p>
<section class="sect3" title="Uploading Data">
<h4 id="_uploading_data">Uploading Data</h4>
<p>
To upload data to a remote process, Git uses the <code class="literal">send-pack</code> and <code class="literal">receive-pack</code> processes.
The <code class="literal">send-pack</code> process runs on the client and connects to a <code class="literal">receive-pack</code> process on the remote side.</p>
<section class="sect4" title="SSH">
<h5 id="_ssh">SSH</h5>
<p>For example, say you run <code class="literal">git push origin master</code> in your project, and <code class="literal">origin</code> is defined as a URL that uses the SSH protocol.
Git fires up the <code class="literal">send-pack</code> process, which initiates a connection over SSH to your server.
It tries to run a command on the remote server via an SSH call that looks something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh -x git@server <span style="font-style: italic">&quot;git-receive-pack &#39;simplegit-progit.git&#39;&quot;</span>
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000</code></pre>
</figure>
<p>The <code class="literal">git-receive-pack</code> command immediately responds with one line for each reference it currently has – in this case, just the <code class="literal">master</code> branch and its SHA-1.
The first line also has a list of the server&#8217;s capabilities (here, <code class="literal">report-status</code>, <code class="literal">delete-refs</code>, and some others, including the client identifier).</p>
<p>Each line starts with a 4-character hex value specifying how long the rest of the line is.
Your first line starts with 00a5, which is hexadecimal for 165, meaning that 165 bytes remain on that line.
The next line is 0000, meaning the server is done with its references listing.</p>
<p>Now that it knows the server&#8217;s state, your <code class="literal">send-pack</code> process determines what commits it has that the server doesn&#8217;t.
For each reference that this push will update, the <code class="literal">send-pack</code> process tells the <code class="literal">receive-pack</code> process that information.
For instance, if you&#8217;re updating the <code class="literal">master</code> branch and adding an <code class="literal">experiment</code> branch, the <code class="literal">send-pack</code> response may look something like this:</p>
<figure class="listing">
<pre class="source language-"><code>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</code></pre>
</figure>
<p>Git sends a line for each reference you&#8217;re updating with the line&#8217;s length, the old SHA-1, the new SHA-1, and the reference that is being updated.
The first line also has the client&#8217;s capabilities.
The SHA-1 value of all '0&#8217;s means that nothing was there before – because you&#8217;re adding the experiment reference.
If you were deleting a reference, you would see the opposite: all '0&#8217;s on the right side.</p>
<p>Next, the client sends a packfile of all the objects the server doesn&#8217;t have yet.
Finally, the server responds with a success (or failure) indication:</p>
<figure class="listing">
<pre class="source language-"><code>000eunpack ok</code></pre>
</figure>
</section>
<section class="sect4" title="HTTP(S)">
<h5 id="_http_s">HTTP(S)</h5>
<p>This process is mostly the same over HTTP, though the handshaking is a bit different.
The connection is initiated with this request:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</code></pre>
</figure>
<p>That&#8217;s the end of the first client-server exchange.
The client then makes another request, this time a <code class="literal">POST</code>, with the data that <code class="literal">send-pack</code> provides.</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</code></pre>
</figure>
<p>The <code class="literal">POST</code> request includes the <code class="literal">send-pack</code> output and the packfile as its payload.
The server then indicates success or failure with its HTTP response.</p>
</section>
</section>
<section class="sect3" title="Downloading Data">
<h4 id="_downloading_data">Downloading Data</h4>
<p>
When you download data, the <code class="literal">fetch-pack</code> and <code class="literal">upload-pack</code> processes are involved.
The client initiates a <code class="literal">fetch-pack</code> process that connects to an <code class="literal">upload-pack</code> process on the remote side to negotiate what data will be transferred down.</p>
<section class="sect4" title="SSH">
<h5 id="_ssh_2">SSH</h5>
<p>If you&#8217;re doing the fetch over SSH, <code class="literal">fetch-pack</code> runs something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ssh -x git@server <span style="font-style: italic">&quot;git-upload-pack &#39;simplegit-progit.git&#39;&quot;</span></code></pre>
</figure>
<p>After <code class="literal">fetch-pack</code> connects, <code class="literal">upload-pack</code> sends back something like this:</p>
<figure class="listing">
<pre class="source language-"><code>00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000</code></pre>
</figure>
<p>This is very similar to what <code class="literal">receive-pack</code> responds with, but the capabilities are different.
In addition, it sends back what HEAD points to (<code class="literal">symref=HEAD:refs/heads/master</code>) so the client knows what to check out if this is a clone.</p>
<p>At this point, the <code class="literal">fetch-pack</code> process looks at what objects it has and responds with the objects that it needs by sending “want” and then the SHA-1 it wants.
It sends all the objects it already has with “have” and then the SHA-1.
At the end of this list, it writes “done” to initiate the <code class="literal">upload-pack</code> process to begin sending the packfile of the data it needs:</p>
<figure class="listing">
<pre class="source language-"><code>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</code></pre>
</figure>
</section>
<section class="sect4" title="HTTP(S)">
<h5 id="_http_s_2">HTTP(S)</h5>
<p>The handshake for a fetch operation takes two HTTP requests.
The first is a <code class="literal">GET</code> to the same endpoint used in the dumb protocol:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</figure>
<p>This is very similar to invoking <code class="literal">git-upload-pack</code> over an SSH connection, but the second exchange is performed as a separate request:</p>
<figure class="listing">
<pre class="source language-"><code>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</code></pre>
</figure>
<p>Again, this is the same format as above.
The response to this request indicates success or failure, and includes the packfile.</p>
</section>
</section>
</section>
<section class="sect2" title="Protocols Summary">
<h3 id="_protocols_summary">Protocols Summary</h3>
<p>This section contains a very basic overview of the transfer protocols.
The protocol includes many other features, such as <code class="literal">multi_ack</code> or <code class="literal">side-band</code> capabilities, but covering them is outside the scope of this book.
We&#8217;ve tried to give you a sense of the general back-and-forth between client and server; if you need more knowledge than this, you&#8217;ll probably want to take a look at the Git source code.</p>
</section>
</section>
<section class="sect1" title="Maintenance and Data Recovery">
<h2 id="_maintenance_and_data_recovery">Maintenance and Data Recovery</h2>
<p>Occasionally, you may have to do some cleanup – make a repository more compact, clean up an imported repository, or recover lost work.
This section will cover some of these scenarios.</p>
<section class="sect2" title="Maintenance">
<h3 id="r_git_gc">Maintenance</h3>
<p>Occasionally, Git automatically runs a command called “auto gc”.
Most of the time, this command does nothing.
However, if there are too many loose objects (objects not in a packfile) or too many packfiles, Git launches a full-fledged <code class="literal">git gc</code> command.
The “gc” stands for garbage collect, and the command does a number of things: it gathers up all the loose objects and places them in packfiles, it consolidates packfiles into one big packfile, and it removes objects that aren&#8217;t reachable from any commit and are a few months old.</p>
<p>You can run auto gc manually as follows:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc --auto</code></pre>
</figure>
<p>Again, this generally does nothing.
You must have around 7,000 loose objects or more than 50 packfiles for Git to fire up a real gc command.
You can modify these limits with the <code class="literal">gc.auto</code> and <code class="literal">gc.autopacklimit</code> config settings, respectively.</p>
<p>The other thing <code class="literal">gc</code> will do is pack up your references into a single file.
Suppose your repository contains the following branches and tags:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</code></pre>
</figure>
<p>If you run <code class="literal">git gc</code>, you&#8217;ll no longer have these files in the <code class="literal">refs</code> directory.
Git will move them for the sake of efficiency into a file named <code class="literal">.git/packed-refs</code> that looks like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .git/packed-refs
<span style="font-weight: bold">#</span> pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</figure>
<p>If you update a reference, Git doesn&#8217;t edit this file but instead writes a new file to <code class="literal">refs/heads</code>.
To get the appropriate SHA-1 for a given reference, Git checks for that reference in the <code class="literal">refs</code> directory and then checks the <code class="literal">packed-refs</code> file as a fallback.
However, if you can&#8217;t find a reference in the <code class="literal">refs</code> directory, it&#8217;s probably in your <code class="literal">packed-refs</code> file.</p>
<p>Notice the last line of the file, which begins with a <code class="literal">^</code>.
This means the tag directly above is an annotated tag and that line is the commit that the annotated tag points to.</p>
</section>
<section class="sect2" title="Data Recovery">
<h3 id="r_data_recovery">Data Recovery</h3>
<p>At some point in your Git journey, you may accidentally lose a commit.
Generally, this happens because you force-delete a branch that had work on it, and it turns out you wanted the branch after all; or you hard-reset a branch, thus abandoning commits that you wanted something from.
Assuming this happens, how can you get your commits back?</p>
<p>Here&#8217;s an example that hard-resets the master branch in your test repository to an older commit and then recovers the lost commits.
First, let&#8217;s review where your repository is at this point:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Now, move the <code class="literal">master</code> branch back to the middle commit:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
<span style="font-weight: bold">$</span> git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>You&#8217;ve effectively lost the top two commits – you have no branch from which those commits are reachable.
You need to find the latest commit SHA-1 and then add a branch that points to it.
The trick is finding that latest commit SHA-1 – it&#8217;s not like you&#8217;ve memorized it, right?</p>
<p>Often, the quickest way is to use a tool called <code class="literal">git reflog</code>.
As you&#8217;re working, Git silently records what your HEAD is every time you change it.
Each time you commit or change branches, the reflog is updated.
The reflog is also updated by the <code class="literal">git update-ref</code> command, which is another reason to use it instead of just writing the SHA-1 value to your ref files, as we covered in <a id="xref-r_git_refs" href="#r_git_refs" class="xref">Git References</a>.
You can see where you&#8217;ve been at any time by running <code class="literal">git reflog</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb</code></pre>
</figure>
<p>Here we can see the two commits that we have had checked out, however there is not much information here.
To see the same information in a much more useful way, we can run <code class="literal">git log -g</code>, which will give you a normal log output for your reflog.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit</code></pre>
</figure>
<p>It looks like the bottom commit is the one you lost, so you can recover it by creating a new branch at that commit.
For example, you can start a branch named <code class="literal">recover-branch</code> at that commit (ab1afef):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch recover-branch ab1afef
<span style="font-weight: bold">$</span> git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</figure>
<p>Cool – now you have a branch named <code class="literal">recover-branch</code> that is where your <code class="literal">master</code> branch used to be, making the first two commits reachable again.
Next, suppose your loss was for some reason not in the reflog – you can simulate that by removing <code class="literal">recover-branch</code> and deleting the reflog.
Now the first two commits aren&#8217;t reachable by anything:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -D recover-branch
<span style="font-weight: bold">$</span> rm -Rf .git/logs/</code></pre>
</figure>
<p>Because the reflog data is kept in the <code class="literal">.git/logs/</code> directory, you effectively have no reflog.
How can you recover that commit at this point?
One way is to use the <code class="literal">git fsck</code> utility, which checks your database for integrity.
If you run it with the <code class="literal">--full</code> option, it shows you all objects that aren&#8217;t pointed to by another object:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>
</figure>
<p>In this case, you can see your missing commit after the string “dangling commit”.
You can recover it the same way, by adding a branch that points to that SHA-1.</p>
</section>
<section class="sect2" title="Removing Objects">
<h3 id="r_removing_objects">Removing Objects</h3>
<p>There are a lot of great things about Git, but one feature that can cause issues is the fact that a <code class="literal">git clone</code> downloads the entire history of the project, including every version of every file.
This is fine if the whole thing is source code, because Git is highly optimized to compress that data efficiently.
However, if someone at any point in the history of your project added a single huge file, every clone for all time will be forced to download that large file, even if it was removed from the project in the very next commit.
Because it&#8217;s reachable from the history, it will always be there.</p>
<p>This can be a huge problem when you&#8217;re converting Subversion or Perforce repositories into Git.
Because you don&#8217;t download the whole history in those systems, this type of addition carries few consequences.
If you did an import from another system or otherwise find that your repository is much larger than it should be, here is how you can find and remove large objects.</p>
<p><strong>Be warned: this technique is destructive to your commit history.</strong>
It rewrites every commit object since the earliest tree you have to modify to remove a large file reference.
If you do this immediately after an import, before anyone has started to base work on the commit, you&#8217;re fine – otherwise, you have to notify all contributors that they must rebase their work onto your new commits.</p>
<p>To demonstrate, you&#8217;ll add a large file into your test repository, remove it in the next commit, find it, and remove it permanently from the repository.
First, add a large object to your history:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
<span style="font-weight: bold">$</span> git add git.tgz
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;add git tarball&#39;</span>
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</code></pre>
</figure>
<p>Oops – you didn&#8217;t want to add a huge tarball to your project.
Better get rid of it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm git.tgz
rm &#39;git.tgz&#39;
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;oops - removed large tarball&#39;</span>
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</code></pre>
</figure>
<p>Now, <code class="literal">gc</code> your database and see how much space you&#8217;re using:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</code></pre>
</figure>
<p>You can run the <code class="literal">count-objects</code> command to quickly see how much space you&#8217;re using:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
<p>The <code class="literal">size-pack</code> entry is the size of your packfiles in kilobytes, so you&#8217;re using almost 5MB.
Before the last commit, you were using closer to 2K – clearly, removing the file from the previous commit didn&#8217;t remove it from your history.
Every time anyone clones this repository, they will have to clone all 5MB just to get this tiny project, because you accidentally added a big file.
Let&#8217;s get rid of it.</p>
<p>First you have to find it.
In this case, you already know what file it is.
But suppose you didn&#8217;t; how would you identify what file or files were taking up so much space?
If you run <code class="literal">git gc</code>, all the objects are in a packfile; you can identify the big objects by running another plumbing command called <code class="literal">git verify-pack</code> and sorting on the third field in the output, which is file size.
You can also pipe it through the <code class="literal">tail</code> command because you&#8217;re only interested in the last few largest files:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git verify-pack -v .git/objects/pack/pack-29…69.idx <span style="font-weight: bold; font-style: italic">\</span>
  | sort -k 3 -n <span style="font-weight: bold; font-style: italic">\</span>
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>
</figure>
<p>The big object is at the bottom: 5MB.
To find out what file it is, you&#8217;ll use the <code class="literal">rev-list</code> command, which you used briefly in <a id="xref--ch08-customizing-git--r_enforcing_commit_message_format" href="ch08-customizing-git.xhtml#r_enforcing_commit_message_format" class="xref">Enforcing a Specific Commit-Message Format</a>.
If you pass <code class="literal">--objects</code> to <code class="literal">rev-list</code>, it lists all the commit SHA-1s and also the blob SHA-1s with the file paths associated with them.
You can use this to find your blob&#8217;s name:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>
</figure>
<p>Now, you need to remove this file from all trees in your past.
You can easily see what commits modified this file:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball</code></pre>
</figure>
<p>You must rewrite all the commits downstream from <code class="literal">7b30847</code> to fully remove this file from your Git history.
To do so, you use <code class="literal">filter-branch</code>, which you used in <a id="xref--ch07-git-tools--r_rewriting_history" href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">Rewriting History</a>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --index-filter <span style="font-weight: bold; font-style: italic">\</span>
  <span style="font-style: italic">&#39;git rm --ignore-unmatch --cached git.tgz&#39;</span> -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm &#39;git.tgz&#39;
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>The <code class="literal">--index-filter</code> option is similar to the <code class="literal">--tree-filter</code> option used in <a href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">Rewriting History</a>, except that instead of passing a command that modifies files checked out on disk, you&#8217;re modifying your staging area or index each time.</p>
<p>Rather than remove a specific file with something like <code class="literal">rm file</code>, you have to remove it with <code class="literal">git rm --cached</code> – you must remove it from the index, not from disk.
The reason to do it this way is speed – because Git doesn&#8217;t have to check out each revision to disk before running your filter, the process can be much, much faster.
You can accomplish the same task with <code class="literal">--tree-filter</code> if you want.
The <code class="literal">--ignore-unmatch</code> option to <code class="literal">git rm</code> tells it not to error out if the pattern you&#8217;re trying to remove isn&#8217;t there.
Finally, you ask <code class="literal">filter-branch</code> to rewrite your history only from the <code class="literal">7b30847</code> commit up, because you know that is where this problem started.
Otherwise, it will start from the beginning and will unnecessarily take longer.</p>
<p>Your history no longer contains a reference to that file.
However, your reflog and a new set of refs that Git added when you did the <code class="literal">filter-branch</code> under <code class="literal">.git/refs/original</code> still do, so you have to remove them and then repack the database.
You need to get rid of anything that has a pointer to those old commits before you repack:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm -Rf .git/refs/original
<span style="font-weight: bold">$</span> rm -Rf .git/logs/
<span style="font-weight: bold">$</span> git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</code></pre>
</figure>
<p>Let&#8217;s see how much space you saved.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
<p>The packed repository size is down to 8K, which is much better than 5MB.
You can see from the size value that the big object is still in your loose objects, so it&#8217;s not gone; but it won&#8217;t be transferred on a push or subsequent clone, which is what is important.
If you really wanted to, you could remove the object completely by running <code class="literal">git prune</code> with the <code class="literal">--expire</code> option:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git prune --expire now
<span style="font-weight: bold">$</span> git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="Environment Variables">
<h2 id="_environment_variables">Environment Variables</h2>
<p>Git always runs inside a <code class="literal">bash</code> shell, and uses a number of shell environment variables to determine how it behaves.
Occasionally, it comes in handy to know what these are, and how they can be used to make Git behave the way you want it to.
This isn&#8217;t an exhaustive list of all the environment variables Git pays attention to, but we&#8217;ll cover the most useful.</p>
<section class="sect2" title="Global Behavior">
<h3 id="_global_behavior">Global Behavior</h3>
<p>Some of Git&#8217;s general behavior as a computer program depends on environment variables.</p>
<p><strong><code class="literal">GIT_EXEC_PATH</code></strong> determines where Git looks for its sub-programs (like <code class="literal">git-commit</code>, <code class="literal">git-diff</code>, and others).
  You can check the current setting by running <code class="literal">git --exec-path</code>.</p>
<p><strong><code class="literal">HOME</code></strong> isn&#8217;t usually considered customizable (too many other things depend on it), but it&#8217;s where Git looks for the global configuration file.
  If you want a truly portable Git installation, complete with global configuration, you can override <code class="literal">HOME</code> in the portable Git&#8217;s shell profile.</p>
<p><strong><code class="literal">PREFIX</code></strong> is similar, but for the system-wide configuration.
  Git looks for this file at <code class="literal">$PREFIX/etc/gitconfig</code>.</p>
<p><strong><code class="literal">GIT_CONFIG_NOSYSTEM</code></strong>, if set, disables the use of the system-wide configuration file.
  This is useful if your system config is interfering with your commands, but you don&#8217;t have access to change or remove it.</p>
<p><strong><code class="literal">GIT_PAGER</code></strong> controls the program used to display multi-page output on the command line.
If this is unset, <code class="literal">PAGER</code> will be used as a fallback.</p>
<p><strong><code class="literal">GIT_EDITOR</code></strong> is the editor Git will launch when the user needs to edit some text (a commit message, for example).
If unset, <code class="literal">EDITOR</code> will be used.</p>
</section>
<section class="sect2" title="Repository Locations">
<h3 id="_repository_locations">Repository Locations</h3>
<p>Git uses several environment variables to determine how it interfaces with the current repository.</p>
<p><strong><code class="literal">GIT_DIR</code></strong> is the location of the <code class="literal">.git</code> folder.
If this isn&#8217;t specified, Git walks up the directory tree until it gets to <code class="literal">~</code> or <code class="literal">/</code>, looking for a <code class="literal">.git</code> directory at every step.</p>
<p><strong><code class="literal">GIT_CEILING_DIRECTORIES</code></strong> controls the behavior of searching for a <code class="literal">.git</code> directory.
If you access directories that are slow to load (such as those on a tape drive, or across a slow network connection), you may want to have Git stop trying earlier than it might otherwise, especially if Git is invoked when building your shell prompt.</p>
<p><strong><code class="literal">GIT_WORK_TREE</code></strong> is the location of the root of the working directory for a non-bare repository.
If not specified, the parent directory of <code class="literal">$GIT_DIR</code> is used.</p>
<p><strong><code class="literal">GIT_INDEX_FILE</code></strong> is the path to the index file (non-bare repositories only).</p>
<p><strong><code class="literal">GIT_OBJECT_DIRECTORY</code></strong> can be used to specify the location of the directory that usually resides at <code class="literal">.git/objects</code>.</p>
<p><strong><code class="literal">GIT_ALTERNATE_OBJECT_DIRECTORIES</code></strong> is a colon-separated list (formatted like <code class="literal">/dir/one:/dir/two:…</code>) which tells Git where to check for objects if they aren&#8217;t in <code class="literal">GIT_OBJECT_DIRECTORY</code>.
If you happen to have a lot of projects with large files that have the exact same contents, this can be used to avoid storing too many copies of them.</p>
</section>
<section class="sect2" title="Pathspecs">
<h3 id="_pathspecs">Pathspecs</h3>
<p>A “pathspec” refers to how you specify paths to things in Git, including the use of wildcards.
These are used in the <code class="literal">.gitignore</code> file, but also on the command-line (<code class="literal">git add *.c</code>).</p>
<p><strong><code class="literal">GIT_GLOB_PATHSPECS</code> and <code class="literal">GIT_NOGLOB_PATHSPECS</code></strong> control the default behavior of wildcards in pathspecs.
If <code class="literal">GIT_GLOB_PATHSPECS</code> is set to 1, wildcard characters act as wildcards (which is the default); if <code class="literal">GIT_NOGLOB_PATHSPECS</code> is set to 1, wildcard characters only match themselves, meaning something like <code class="literal">*.c</code> would only match a file <em>named</em> “*.c”, rather than any file whose name ends with <code class="literal">.c</code>.
You can override this in individual cases by starting the pathspec with <code class="literal">:(glob)</code> or <code class="literal">:(literal)</code>, as in <code class="literal">:(glob)*.c</code>.</p>
<p><strong><code class="literal">GIT_LITERAL_PATHSPECS</code></strong> disables both of the above behaviors; no wildcard characters will work, and the override prefixes are disabled as well.</p>
<p><strong><code class="literal">GIT_ICASE_PATHSPECS</code></strong> sets all pathspecs to work in a case-insensitive manner.</p>
</section>
<section class="sect2" title="Committing">
<h3 id="_committing">Committing</h3>
<p>The final creation of a Git commit object is usually done by <code class="literal">git-commit-tree</code>, which uses these environment variables as its primary source of information, falling back to configuration values only if these aren&#8217;t present.</p>
<p><strong><code class="literal">GIT_AUTHOR_NAME</code></strong> is the human-readable name in the “author” field.</p>
<p><strong><code class="literal">GIT_AUTHOR_EMAIL</code></strong> is the email for the “author” field.</p>
<p><strong><code class="literal">GIT_AUTHOR_DATE</code></strong> is the timestamp used for the “author” field.</p>
<p><strong><code class="literal">GIT_COMMITTER_NAME</code></strong> sets the human name for the “committer” field.</p>
<p><strong><code class="literal">GIT_COMMITTER_EMAIL</code></strong> is the email address for the “committer” field.</p>
<p><strong><code class="literal">GIT_COMMITTER_DATE</code></strong> is used for the timestamp in the “committer” field.</p>
<p><strong><code class="literal">EMAIL</code></strong> is the fallback email address in case the <code class="literal">user.email</code> configuration value isn&#8217;t set.
If <em>this</em> isn&#8217;t set, Git falls back to the system user and host names.</p>
</section>
<section class="sect2" title="Networking">
<h3 id="_networking">Networking</h3>
<p>Git uses the <code class="literal">curl</code> library to do network operations over HTTP, so <strong><code class="literal">GIT_CURL_VERBOSE</code></strong> tells Git to emit all the messages generated by that library.
This is similar to doing <code class="literal">curl -v</code> on the command line.</p>
<p><strong><code class="literal">GIT_SSL_NO_VERIFY</code></strong> tells Git not to verify SSL certificates.
This can sometimes be necessary if you&#8217;re using a self-signed certificate to serve Git repositories over HTTPS, or you&#8217;re in the middle of setting up a Git server but haven&#8217;t installed a full certificate yet.</p>
<p>If the data rate of an HTTP operation is lower than <strong><code class="literal">GIT_HTTP_LOW_SPEED_LIMIT</code></strong> bytes per second for longer than <strong><code class="literal">GIT_HTTP_LOW_SPEED_TIME</code></strong> seconds, Git will abort that operation.
These values override the <code class="literal">http.lowSpeedLimit</code> and <code class="literal">http.lowSpeedTime</code> configuration values.</p>
<p><strong><code class="literal">GIT_HTTP_USER_AGENT</code></strong> sets the user-agent string used by Git when communicating over HTTP.
The default is a value like <code class="literal">git/2.0.0</code>.</p>
</section>
<section class="sect2" title="Diffing and Merging">
<h3 id="_diffing_and_merging">Diffing and Merging</h3>
<p><strong><code class="literal">GIT_DIFF_OPTS</code></strong> is a bit of a misnomer.
The only valid values are <code class="literal">-u&lt;n&gt;</code> or <code class="literal">--unified=&lt;n&gt;</code>, which controls the number of context lines shown in a <code class="literal">git diff</code> command.</p>
<p><strong><code class="literal">GIT_EXTERNAL_DIFF</code></strong> is used as an override for the <code class="literal">diff.external</code> configuration value.
If it&#8217;s set, Git will invoke this program when <code class="literal">git diff</code> is invoked.</p>
<p><strong><code class="literal">GIT_DIFF_PATH_COUNTER</code></strong> and <strong><code class="literal">GIT_DIFF_PATH_TOTAL</code></strong> are useful from inside the program specified by <code class="literal">GIT_EXTERNAL_DIFF</code> or <code class="literal">diff.external</code>.
The former represents which file in a series is being diffed (starting with 1), and the latter is the total number of files in the batch.</p>
<p><strong><code class="literal">GIT_MERGE_VERBOSITY</code></strong> controls the output for the recursive merge strategy.
The allowed values are as follows:</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">0 outputs nothing, except possibly a single error message.</span>
</li>
<li>
<span class="principal">1 shows only conflicts.</span>
</li>
<li>
<span class="principal">2 also shows file changes.</span>
</li>
<li>
<span class="principal">3 shows when files are skipped because they haven&#8217;t changed.</span>
</li>
<li>
<span class="principal">4 shows all paths as they are processed.</span>
</li>
<li>
<span class="principal">5 and above show detailed debugging information.</span>
</li>
</ul>
</div>
<p>The default value is 2.</p>
</section>
<section class="sect2" title="Debugging">
<h3 id="_debugging">Debugging</h3>
<p>Want to <em>really</em> know what Git is up to?
Git has a fairly complete set of traces embedded, and all you need to do is turn them on.
The possible values of these variables are as follows:</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">“true”, “1”, or “2” – the trace category is written to stderr.</span>
</li>
<li>
<span class="principal">An absolute path starting with <code class="literal">/</code> – the trace output will be written to that file.</span>
</li>
</ul>
</div>
<p><strong><code class="literal">GIT_TRACE</code></strong> controls general traces, which don&#8217;t fit into any specific category.
This includes the expansion of aliases, and delegation to other sub-programs.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE=true git lga
20:12:49.877982 git.c:554               trace: exec: &#39;git-lga&#39;
20:12:49.878369 run-command.c:341       trace: run_command: &#39;git-lga&#39;
20:12:49.879529 git.c:282               trace: alias expansion: lga =&gt; &#39;log&#39; &#39;--graph&#39; &#39;--pretty=oneline&#39; &#39;--abbrev-commit&#39; &#39;--decorate&#39; &#39;--all&#39;
20:12:49.879885 git.c:349               trace: built-in: git &#39;log&#39; &#39;--graph&#39; &#39;--pretty=oneline&#39; &#39;--abbrev-commit&#39; &#39;--decorate&#39; &#39;--all&#39;
20:12:49.899217 run-command.c:341       trace: run_command: &#39;less&#39;
20:12:49.899675 run-command.c:192       trace: exec: &#39;less&#39;</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PACK_ACCESS</code></strong> controls tracing of packfile access.
The first field is the packfile being accessed, the second is the offset within that file:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PACK_ACCESS=true git status
20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12
20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662
20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175
<span style="font-weight: bold">#</span> […]
20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983
20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PACKET</code></strong> enables packet-level tracing for network operations.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PACKET=true git ls-remote origin
20:15:14.867043 pkt-line.c:46           packet:          git&lt; # service=git-upload-pack
20:15:14.867071 pkt-line.c:46           packet:          git&lt; 0000
20:15:14.867079 pkt-line.c:46           packet:          git&lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4
20:15:14.867088 pkt-line.c:46           packet:          git&lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name
20:15:14.867094 pkt-line.c:46           packet:          git&lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config
<span style="font-weight: bold">#</span> […]</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_PERFORMANCE</code></strong> controls logging of performance data.
The output shows how long each particular git invocation takes.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_PERFORMANCE=true git gc
20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: &#39;git&#39; &#39;pack-refs&#39; &#39;--all&#39; &#39;--prune&#39;
20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: &#39;git&#39; &#39;reflog&#39; &#39;expire&#39; &#39;--all&#39;
Counting objects: 170994, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (43413/43413), done.
Writing objects: 100% (170994/170994), done.
Total 170994 (delta 126176), reused 170524 (delta 125706)
20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: &#39;git&#39; &#39;pack-objects&#39; &#39;--keep-true-parents&#39; &#39;--honor-pack-keep&#39; &#39;--non-empty&#39; &#39;--all&#39; &#39;--reflog&#39; &#39;--unpack-unreachable=2.weeks.ago&#39; &#39;--local&#39; &#39;--delta-base-offset&#39; &#39;.git/objects/pack/.tmp-49190-pack&#39;
20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: &#39;git&#39; &#39;prune-packed&#39;
20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: &#39;git&#39; &#39;update-server-info&#39;
20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: &#39;git&#39; &#39;repack&#39; &#39;-d&#39; &#39;-l&#39; &#39;-A&#39; &#39;--unpack-unreachable=2.weeks.ago&#39;
Checking connectivity: 170994, done.
20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: &#39;git&#39; &#39;prune&#39; &#39;--expire&#39; &#39;2.weeks.ago&#39;
20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: &#39;git&#39; &#39;rerere&#39; &#39;gc&#39;
20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: &#39;git&#39; &#39;gc&#39;</code></pre>
</figure>
<p><strong><code class="literal">GIT_TRACE_SETUP</code></strong> shows information about what Git is discovering about the repository and environment it&#8217;s interacting with.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_TRACE_SETUP=true git status
20:19:47.086765 trace.c:315             setup: git_dir: .git
20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git
20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git
20:19:47.087194 trace.c:318             setup: prefix: (null)
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean</code></pre>
</figure>
</section>
<section class="sect2" title="Miscellaneous">
<h3 id="_miscellaneous">Miscellaneous</h3>
<p><strong><code class="literal">GIT_SSH</code></strong>, if specified, is a program that is invoked instead of <code class="literal">ssh</code> when Git tries to connect to an SSH host.
It is invoked like <code class="literal">$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code>.
Note that this isn&#8217;t the easiest way to customize how <code class="literal">ssh</code> is invoked; it won&#8217;t support extra command-line parameters, so you&#8217;d have to write a wrapper script and set <code class="literal">GIT_SSH</code> to point to it.
It&#8217;s probably easier just to use the <code class="literal">~/.ssh/config</code> file for that.</p>
<p><strong><code class="literal">GIT_ASKPASS</code></strong> is an override for the <code class="literal">core.askpass</code> configuration value.
This is the program invoked whenever Git needs to ask the user for credentials, which can expect a text prompt as a command-line argument, and should return the answer on <code class="literal">stdout</code>.
(See <a id="xref--ch07-git-tools--r_credential_caching" href="ch07-git-tools.xhtml#r_credential_caching" class="xref">Credential Storage</a> for more on this subsystem.)</p>
<p><strong><code class="literal">GIT_NAMESPACE</code></strong> controls access to namespaced refs, and is equivalent to the <code class="literal">--namespace</code> flag.
This is mostly useful on the server side, where you may want to store multiple forks of a single repository in one repository, only keeping the refs separate.</p>
<p><strong><code class="literal">GIT_FLUSH</code></strong> can be used to force Git to use non-buffered I/O when writing incrementally to stdout.
A value of 1 causes Git to flush more often, a value of 0 causes all output to be buffered.
The default value (if this variable is not set) is to choose an appropriate buffering scheme depending on the activity and the output mode.</p>
<p><strong><code class="literal">GIT_REFLOG_ACTION</code></strong> lets you specify the descriptive text written to the reflog.
Here&#8217;s an example:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> GIT_REFLOG_ACTION=<span style="font-style: italic">&quot;my action&quot;</span> git commit --allow-empty -m <span style="font-style: italic">&#39;my message&#39;</span>
[master 9e3d55a] my message
<span style="font-weight: bold">$</span> git reflog -1
9e3d55a HEAD@{0}: my action: my message</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="Summary">
<h2 id="_summary">Summary</h2>
<p>You should have a pretty good understanding of what Git does in the background and, to some degree, how it&#8217;s implemented.
This chapter has covered a number of plumbing commands – commands that are lower level and simpler than the porcelain commands you&#8217;ve learned about in the rest of the book.
Understanding how Git works at a lower level should make it easier to understand why it&#8217;s doing what it&#8217;s doing and also to write your own tools and helping scripts to make your specific workflow work for you.</p>
<p class="last">Git as a content-addressable filesystem is a very powerful tool that you can easily use as more than just a VCS.
We hope you can use your newfound knowledge of Git internals to implement your own cool application of this technology and feel more comfortable using Git in more advanced ways.</p>
</section>
</section>
</body>
</html>