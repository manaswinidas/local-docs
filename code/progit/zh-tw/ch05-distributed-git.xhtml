<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>分散式的 Git</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="分散式的 Git" epub:type="chapter" id="ch05-distributed-git">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>分散式的</b> <b>Git</b></small></h1>
</div>
</header>
<p>
Now that you have a remote Git repository set up as a point for all the developers to share their code, and you&#8217;re familiar with basic Git commands in a local workflow, you&#8217;ll look at how to utilize some of the distributed workflows that Git affords you.</p>
<p>In this chapter, you&#8217;ll see how to work with Git in a distributed environment as a contributor and an integrator.
That is, you&#8217;ll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.</p>
<section class="sect1" title="分散式工作流程">
<h2 id="_分散式工作流程">分散式工作流程</h2>
<p>
Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.
In centralized systems, every developer is a node working more or less equally on a central hub.
In Git, however, every developer is potentially both a node and a hub – that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.
This opens a vast range of workflow possibilities for your project and/or your team, so we&#8217;ll cover a few common paradigms that take advantage of this flexibility.
We&#8217;ll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.</p>
<section class="sect2" title="集中式工作流程">
<h3 id="_集中式工作流程">集中式工作流程</h3>
<p>
In centralized systems, there is generally a single collaboration model–the centralized workflow.
One central hub, or repository, can accept code, and everyone synchronizes their work to it.
A number of developers are nodes – consumers of that hub – and synchronize to that one place.</p>
<figure class="image">
<div class="content">
<img src="images/centralized_workflow.png" alt="Centralized workflow."/>
</div>
<figcaption>圖表 1. Centralized workflow.</figcaption>
</figure>
<p>This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems.
The second developer must merge in the first one&#8217;s work before pushing changes up, so as not to overwrite the first developer&#8217;s changes.
This concept is as true in Git as it is in Subversion (or any CVCS), and this model works perfectly well in Git.</p>
<p>If you are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.
Simply set up a single repository, and give everyone on your team push access; Git won&#8217;t let users overwrite each other.
Say John and Jessica both start working at the same time.
John finishes his change and pushes it to the server.
Then Jessica tries to push her changes, but the server rejects them.
She is told that she&#8217;s trying to push non-fast-forward changes and that she won&#8217;t be able to do so until she fetches and merges.
This workflow is attractive to a lot of people because it&#8217;s a paradigm that many are familiar and comfortable with.</p>
<p>This is also not limited to small teams.
With Git&#8217;s branching model, it&#8217;s possible for hundreds of developers to successfully work on a single project through dozens of branches simultaneously.</p>
</section>
<section class="sect2" title="整合式管理員工作流程">
<h3 id="r_integration_manager">整合式管理員工作流程</h3>
<p>
Because Git allows you to have multiple remote repositories, it&#8217;s possible to have a workflow where each developer has write access to their own public repository and read access to everyone else&#8217;s.
This scenario often includes a canonical repository that represents the “official” project.
To contribute to that project, you create your own public clone of the project and push your changes to it.
Then, you can send a request to the maintainer of the main project to pull in your changes.
The maintainer can then add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.
The process works as follows (see <a id="xref-rwfdiag_b" href="#rwfdiag_b" class="xref">Integration-manager workflow.</a>):</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">The project maintainer pushes to their public repository.</span>
</li>
<li>
<span class="principal">A contributor clones that repository and makes changes.</span>
</li>
<li>
<span class="principal">The contributor pushes to their own public copy.</span>
</li>
<li>
<span class="principal">The contributor sends the maintainer an email asking them to pull changes.</span>
</li>
<li>
<span class="principal">The maintainer adds the contributor&#8217;s repo as a remote and merges locally.</span>
</li>
<li>
<span class="principal">The maintainer pushes merged changes to the main repository.</span>
</li>
</ol>
</div>
<figure id="rwfdiag_b" class="image">
<div class="content">
<img src="images/integration-manager.png" alt="Integration-manager workflow."/>
</div>
<figcaption>圖表 2. Integration-manager workflow.</figcaption>
</figure>
<p>
This is a very common workflow with hub-based tools like GitHub or GitLab, where it&#8217;s easy to fork a project and push your changes into your fork for everyone to see.
One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time.
Contributors don&#8217;t have to wait for the project to incorporate their changes – each party can work at their own pace.</p>
</section>
<section class="sect2" title="司令官與副官工作流程">
<h3 id="_司令官與副官工作流程">司令官與副官工作流程</h3>
<p>
This is a variant of a multiple-repository workflow.
It&#8217;s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
Various integration managers are in charge of certain parts of the repository; they&#8217;re called lieutenants.
All the lieutenants have one integration manager known as the benevolent dictator.
The benevolent dictator&#8217;s repository serves as the reference repository from which all the collaborators need to pull.
The process works like this (see <a id="xref-rwfdiag_c" href="#rwfdiag_c" class="xref">Benevolent dictator workflow.</a>):</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Regular developers work on their topic branch and rebase their work on top of <code class="literal">master</code>.
The <code class="literal">master</code> branch is that of the dictator.</span>
</li>
<li>
<span class="principal">Lieutenants merge the developers' topic branches into their <code class="literal">master</code> branch.</span>
</li>
<li>
<span class="principal">The dictator merges the lieutenants' <code class="literal">master</code> branches into the dictator&#8217;s <code class="literal">master</code> branch.</span>
</li>
<li>
<span class="principal">The dictator pushes their <code class="literal">master</code> to the reference repository so the other developers can rebase on it.</span>
</li>
</ol>
</div>
<figure id="rwfdiag_c" class="image">
<div class="content">
<img src="images/benevolent-dictator.png" alt="Benevolent dictator workflow."/>
</div>
<figcaption>圖表 3. Benevolent dictator workflow.</figcaption>
</figure>
<p>This kind of workflow isn&#8217;t common, but can be useful in very big projects, or in highly hierarchical environments.
It allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.</p>
</section>
<section class="sect2" title="工作流程總結">
<h3 id="_工作流程總結">工作流程總結</h3>
<p>These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow.
Now that you can (hopefully) determine which workflow combination may work for you, we&#8217;ll cover some more specific examples of how to accomplish the main roles that make up the different flows.
In the next section, you&#8217;ll learn about a few common patterns for contributing to a project.</p>
</section>
</section>
<section class="sect1" title="對專案進行貢獻">
<h2 id="r_contributing_project">對專案進行貢獻</h2>
<p>
The main difficulty with describing how to contribute to a project is that there are a huge number of variations on how it&#8217;s done.
Because Git is very flexible, people can and do work together in many ways, and it&#8217;s problematic to describe how you should contribute – every project is a bit different.
Some of the variables involved are active contributor count, chosen workflow, your commit access, and possibly the external contribution method.</p>
<p>The first variable is active contributor count – how many users are actively contributing code to this project, and how often?
In many instances, you&#8217;ll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day.
This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.
Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.
How can you keep your code consistently up to date and your commits valid?</p>
<p>The next variable is the workflow in use for the project.
Is it centralized, with each developer having equal write access to the main codeline?
Does the project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved?
Are you involved in that process?
Is a lieutenant system in place, and do you have to submit your work to them first?</p>
<p>The next issue is your commit access.
The workflow required in order to contribute to a project is much different if you have write access to the project than if you don&#8217;t.
If you don&#8217;t have write access, how does the project prefer to accept contributed work?
Does it even have a policy?
How much work are you contributing at a time?
How often do you contribute?</p>
<p>All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.
We&#8217;ll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.</p>
<section class="sect2" title="提交指南">
<h3 id="r_commit_guidelines">提交指南</h3>
<p>Before we start looking at the specific use cases, here&#8217;s a quick note about commit messages.
Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier.
The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches – you can read it in the Git source code in the <code class="literal">Documentation/SubmittingPatches</code> file.</p>
<p>
First, you don&#8217;t want to submit any whitespace errors.
Git provides an easy way to check for this – before you commit, run <code class="literal">git diff --check</code>, which identifies possible whitespace errors and lists them for you.</p>
<figure class="image">
<div class="content">
<img src="images/git-diff-check.png" alt="Output of `git diff --check`."/>
</div>
<figcaption>圖表 4. Output of <code class="literal">git diff --check</code>.</figcaption>
</figure>
<p>If you run that command before committing, you can tell if you&#8217;re about to commit whitespace issues that may annoy other developers.</p>
<p>Next, try to make each commit a logically separate changeset.
If you can, try to make your changes digestible – don&#8217;t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
Even if you don&#8217;t commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
If some of the changes modify the same file, try to use <code class="literal">git add --patch</code> to partially stage files (covered in detail in <a id="xref--ch07-git-tools--r_interactive_staging" href="ch07-git-tools.xhtml#r_interactive_staging" class="xref">Interactive Staging</a>).
The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.
This approach also makes it easier to pull out or revert one of the changesets if you need to later.
<a id="xref--ch07-git-tools--r_rewriting_history" href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">Rewriting History</a> describes a number of useful Git tricks for rewriting history and interactively staging files – use these tools to help craft a clean and understandable history before sending the work to someone else.</p>
<p>The last thing to keep in mind is the commit message.
Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.
As a general rule, your messages should start with a single line that&#8217;s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior – this is a good guideline to follow.
It&#8217;s also a good idea to use the imperative present tense in these messages.
In other words, use commands.
Instead of “I added tests for” or “Adding tests for,” use “Add tests for.”
Here is a template originally written by Tim Pope:</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here</code></pre>
</figure>
<p>If all your commit messages look like this, things will be a lot easier for you and the developers you work with.
The Git project has well-formatted commit messages – try running <code class="literal">git log --no-merges</code> there to see what a nicely formatted project-commit history looks like.</p>
<p>In the following examples, and throughout most of this book, for the sake of brevity this book doesn&#8217;t have nicely-formatted messages like this; instead, we use the <code class="literal">-m</code> option to <code class="literal">git commit</code>.
Do as we say, not as we do.</p>
</section>
<section class="sect2" title="私有的小團隊">
<h3 id="r_private_team">私有的小團隊</h3>
<p>
The simplest setup you&#8217;re likely to encounter is a private project with one or two other developers.
“Private,” in this context, means closed-source – not accessible to the outside world.
You and the other developers all have push access to the repository.</p>
<p>In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.
You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.
Let&#8217;s see what it might look like when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with <code class="literal">...</code> in these examples to shorten them somewhat.)</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> John<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git clone john@githost:simplegit.git
Cloning into &#39;simplegit&#39;...
...
<span style="font-weight: bold">$</span> cd simplegit/
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;removed invalid default value&#39;</span>
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>The second developer, Jessica, does the same thing – clones the repository and commits a change:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git clone jessica@githost:simplegit.git
Cloning into &#39;simplegit&#39;...
...
<span style="font-weight: bold">$</span> cd simplegit/
<span style="font-weight: bold">$</span> vim TODO
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add reset task&#39;</span>
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>Now, Jessica pushes her work up to the server:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>
</figure>
<p>John tries to push his change up, too:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> John<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to &#39;john@githost:simplegit.git&#39;</code></pre>
</figure>
<p>John isn&#8217;t allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you&#8217;re used to Subversion, because you&#8217;ll notice that the two developers didn&#8217;t edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
John has to fetch Jessica&#8217;s changes and merge them in before he will be allowed to push:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>
</figure>
<p>At this point, John&#8217;s local repository looks something like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-1.png" alt="John's divergent history."/>
</div>
<figcaption>圖表 5. John&#8217;s divergent history.</figcaption>
</figure>
<p>John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>The merge goes smoothly – John&#8217;s commit history now looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-2.png" alt="John's repository after merging `origin/master`."/>
</div>
<figcaption>圖表 6. John&#8217;s repository after merging <code class="literal">origin/master</code>.</figcaption>
</figure>
<p>Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>
</figure>
<p>Finally, John&#8217;s commit history looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-3.png" alt="John's history after pushing to the `origin` server."/>
</div>
<figcaption>圖表 7. John&#8217;s history after pushing to the <code class="literal">origin</code> server.</figcaption>
</figure>
<p>In the meantime, Jessica has been working on a topic branch.
She&#8217;s created a topic branch called <code class="literal">issue54</code> and done three commits on that branch.
She hasn&#8217;t fetched John&#8217;s changes yet, so her commit history looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-4.png" alt="Jessica's topic branch."/>
</div>
<figcaption>圖表 8. Jessica&#8217;s topic branch.</figcaption>
</figure>
<p>Jessica wants to sync up with John, so she fetches:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>
</figure>
<p>That pulls down the work John has pushed up in the meantime.
Jessica&#8217;s history now looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-5.png" alt="Jessica's history after fetching John's changes."/>
</div>
<figcaption>圖表 9. Jessica&#8217;s history after fetching John&#8217;s changes.</figcaption>
</figure>
<p>Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work so that she can push.
She runs <code class="literal">git log</code> to find out:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value</code></pre>
</figure>
<p>The <code class="literal">issue54..origin/master</code> syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case <code class="literal">origin/master</code>) that are not on the first branch (in this case <code class="literal">issue54</code>).
We&#8217;ll go over this syntax in detail in <a id="xref--ch07-git-tools--r_commit_ranges" href="ch07-git-tools.xhtml#r_commit_ranges" class="xref">Commit Ranges</a>.</p>
<p>For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in.
If she merges <code class="literal">origin/master</code>, that is the single commit that will modify her local work.</p>
<p>Now, Jessica can merge her topic work into her master branch, merge John&#8217;s work (<code class="literal">origin/master</code>) into her <code class="literal">master</code> branch, and then push back to the server again.
First, she switches back to her master branch to integrate all this work:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Switched to branch &#39;master&#39;
Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.</code></pre>
</figure>
<p>She can merge either <code class="literal">origin/master</code> or <code class="literal">issue54</code> first – they&#8217;re both upstream, so the order doesn&#8217;t matter.
The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
She chooses to merge in <code class="literal">issue54</code> first:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>No problems occur; as you can see it was a simple fast-forward.
Now Jessica merges in John&#8217;s work (<code class="literal">origin/master</code>):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>Everything merges cleanly, and Jessica&#8217;s history looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-6.png" alt="Jessica's history after merging John's changes."/>
</div>
<figcaption>圖表 10. Jessica&#8217;s history after merging John&#8217;s changes.</figcaption>
</figure>
<p>Now <code class="literal">origin/master</code> is reachable from Jessica&#8217;s <code class="literal">master</code> branch, so she should be able to successfully push (assuming John hasn&#8217;t pushed again in the meantime):</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>
</figure>
<p>Each developer has committed a few times and merged each other&#8217;s work successfully.</p>
<figure class="image">
<div class="content">
<img src="images/small-team-7.png" alt="Jessica's history after pushing all changes back to the server."/>
</div>
<figcaption>圖表 11. Jessica&#8217;s history after pushing all changes back to the server.</figcaption>
</figure>
<p>That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your master branch when it&#8217;s ready to be integrated.
When you want to share that work, you fetch and merge your master from <code class="literal">origin/master</code> if it has changed, and finally push to the <code class="literal">master</code> branch on the server.
The general sequence is something like this:</p>
<figure class="image">
<div class="content">
<img src="images/small-team-flow.png" alt="General sequence of events for a simple multiple-developer Git workflow."/>
</div>
<figcaption>圖表 12. General sequence of events for a simple multiple-developer Git workflow.</figcaption>
</figure>
</section>
<section class="sect2" title="私有團隊">
<h3 id="_私有團隊">私有團隊</h3>
<p>
In this next scenario, you&#8217;ll look at contributor roles in a larger private group.
You&#8217;ll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.</p>
<p>Let&#8217;s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the <code class="literal">master</code> branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.</p>
<p>Let&#8217;s follow Jessica&#8217;s workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on <code class="literal">featureA</code> first.
She creates a new branch for the feature and does some work on it there:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git checkout -b featureA
Switched to a new branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add limit to log function&#39;</span>
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>At this point, she needs to share her work with John, so she pushes her <code class="literal">featureA</code> branch commits up to the server.
Jessica doesn&#8217;t have push access to the <code class="literal">master</code> branch – only the integrators do – so she has to push to another branch in order to collaborate with John:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>
</figure>
<p>Jessica emails John to tell him that she&#8217;s pushed some work into a branch named <code class="literal">featureA</code> and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on <code class="literal">featureB</code> with Josie.
To begin, she starts a new feature branch, basing it off the server&#8217;s <code class="literal">master</code> branch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica<span style="border: 1px solid #FF0000">&#39;</span>s Machine
<span style="font-weight: bold">$</span> git fetch origin
<span style="font-weight: bold">$</span> git checkout -b featureB origin/master
Switched to a new branch &#39;featureB&#39;</code></pre>
</figure>
<p>Now, Jessica makes a couple of commits on the <code class="literal">featureB</code> branch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;made the ls-tree function recursive&#39;</span>
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add ls-files&#39;</span>
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>Jessica&#8217;s repository looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-1.png" alt="Jessica's initial commit history."/>
</div>
<figcaption>圖表 13. Jessica&#8217;s initial commit history.</figcaption>
</figure>
<p>She&#8217;s ready to push up her work, but gets an email from Josie that a branch with some initial work on it was already pushed to the server as <code class="literal">featureBee</code>.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie&#8217;s changes down with <code class="literal">git fetch</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>
</figure>
<p>Jessica can now merge this into the work she did with <code class="literal">git merge</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>There is a bit of a problem – she needs to push the merged work in her <code class="literal">featureB</code> branch to the <code class="literal">featureBee</code> branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the <code class="literal">git push</code> command:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>
</figure>
<p>This is called a <em>refspec</em>.
See <a id="xref--ch10-git-internals--r_refspec" href="ch10-git-internals.xhtml#r_refspec" class="xref">The Refspec</a> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the <code class="literal">-u</code> flag; this is short for <code class="literal">--set-upstream</code>, which configures the branches for easier pushing and pulling later.</p>
<p>Next, John emails Jessica to say he&#8217;s pushed some changes to the <code class="literal">featureA</code> branch and asks her to verify them.
She runs a <code class="literal">git fetch</code> to pull down those changes:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>
</figure>
<p>Then, she can see what has been changed with <code class="literal">git log</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>
</figure>
<p>Finally, she merges John&#8217;s work into her own <code class="literal">featureA</code> branch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout featureA
Switched to branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>Jessica wants to tweak something, so she commits again and then pushes this back up to the server:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;small tweak&#39;</span>
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight: bold">$</span> git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</code></pre>
</figure>
<p>Jessica&#8217;s commit history now looks something like this:</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-2.png" alt="Jessica's history after committing on a feature branch."/>
</div>
<figcaption>圖表 14. Jessica&#8217;s history after committing on a feature branch.</figcaption>
</figure>
<p>Jessica, Josie, and John inform the integrators that the <code class="literal">featureA</code> and <code class="literal">featureBee</code> branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-3.png" alt="Jessica's history after merging both her topic branches."/>
</div>
<figcaption>圖表 15. Jessica&#8217;s history after merging both her topic branches.</figcaption>
</figure>
<p>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-flow.png" alt="Basic sequence of this managed-team workflow."/>
</div>
<figcaption>圖表 16. Basic sequence of this managed-team workflow.</figcaption>
</figure>
</section>
<section class="sect2" title="Fork 公眾專案">
<h3 id="r_public_project">Fork 公眾專案</h3>
<p>
Contributing to public projects is a bit different.
Because you don&#8217;t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via email.</p>
<p>First, you&#8217;ll probably want to clone the main repository, create a topic branch for the patch or patch series you&#8217;re planning to contribute, and do your work there.
The sequence looks basically like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone (url)
<span style="font-weight: bold">$</span> cd project
<span style="font-weight: bold">$</span> git checkout -b featureA
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>You may want to use <code class="literal">rebase -i</code> to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <a href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">Rewriting History</a> for more information about interactive rebasing.</p>
</div>
</aside>
<p>When your branch work is finished and you&#8217;re ready to contribute it back to the maintainers, go to the original project page and click the “Fork” button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named <code class="literal">myfork</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add myfork (url)</code></pre>
</figure>
<p>Then you need to push your work up to it.
It&#8217;s easiest to push the topic branch you&#8217;re working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn&#8217;t accepted or is cherry picked, you don&#8217;t have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you&#8217;ll eventually get it back via pulling from their repository anyhow:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u myfork featureA</code></pre>
</figure>
<p>
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we&#8217;ll go over in <a id="xref--ch06-github" href="ch06-github.xhtml" class="xref">GitHub</a> – or you can run the <code class="literal">git request-pull</code> command and email the output to the project maintainer manually.</p>
<p>The <code class="literal">request-pull</code> command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you&#8217;re asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she&#8217;s done two commits on the topic branch she just pushed up, she can run this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>The output can be sent to the maintainer – it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.</p>
<p>On a project for which you&#8217;re not the maintainer, it&#8217;s generally easier to have a branch like <code class="literal">master</code> always track <code class="literal">origin/master</code> and to do your work in topic branches that you can easily discard if they&#8217;re rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don&#8217;t continue working on the topic branch you just pushed up – start over from the main repository&#8217;s <code class="literal">master</code> branch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureB origin/master
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">$</span> git push myfork featureB
<span style="font-weight: bold">#</span> (email maintainer)
<span style="font-weight: bold">$</span> git fetch origin</code></pre>
</figure>
<p>Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:</p>
<figure class="image">
<div class="content">
<img src="images/public-small-1.png" alt="Initial commit history with `featureB` work."/>
</div>
<figcaption>圖表 17. Initial commit history with <code class="literal">featureB</code> work.</figcaption>
</figure>
<p>Let&#8217;s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of <code class="literal">origin/master</code>, resolve the conflicts for the maintainer, and then resubmit your changes:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout featureA
<span style="font-weight: bold">$</span> git rebase origin/master
<span style="font-weight: bold">$</span> git push -f myfork featureA</code></pre>
</figure>
<p>This rewrites your history to now look like <a id="xref-rpsp_b" href="#rpsp_b" class="xref">Commit history after <code class="literal">featureA</code> work.</a>.</p>
<figure id="rpsp_b" class="image">
<div class="content">
<img src="images/public-small-2.png" alt="Commit history after `featureA` work."/>
</div>
<figcaption>圖表 18. Commit history after <code class="literal">featureA</code> work.</figcaption>
</figure>
<p>Because you rebased the branch, you have to specify the <code class="literal">-f</code> to your push command in order to be able to replace the <code class="literal">featureA</code> branch on the server with a commit that isn&#8217;t a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called <code class="literal">featureAv2</code>).</p>
<p>Let&#8217;s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You&#8217;ll also take this opportunity to move the work to be based off the project&#8217;s current <code class="literal">master</code> branch.
You start a new branch based off the current <code class="literal">origin/master</code> branch, squash the <code class="literal">featureB</code> changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</p>
<p></p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureBv2 origin/master
<span style="font-weight: bold">$</span> git merge --squash featureB
<span style="font-weight: bold">#</span> (change implementation)
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">$</span> git push myfork featureBv2</code></pre>
</figure>
<p>The <code class="literal">--squash</code> option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Also the <code class="literal">--no-commit</code> option can be useful to delay the merge commit in case of the default merge process.</p>
<p>Now you can send the maintainer a message that you&#8217;ve made the requested changes and they can find those changes in your <code class="literal">featureBv2</code> branch.</p>
<figure class="image">
<div class="content">
<img src="images/public-small-3.png" alt="Commit history after `featureBv2` work."/>
</div>
<figcaption>圖表 19. Commit history after <code class="literal">featureBv2</code> work.</figcaption>
</figure>
</section>
<section class="sect2" title="透過電子郵件貢獻到公眾專案">
<h3 id="r_project_over_email">透過電子郵件貢獻到公眾專案</h3>
<p>
Many projects have established procedures for accepting patches – you&#8217;ll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we&#8217;ll go over an example of that now.</p>
<p>The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b topicA
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p>
Now you have two commits that you want to send to the mailing list.
You use <code class="literal">git format-patch</code> to generate the mbox-formatted files that you can email to the list – it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with <code class="literal">format-patch</code> preserves all the commit information properly.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>
</figure>
<p>The <code class="literal">format-patch</code> command prints out the names of the patch files it creates.
The <code class="literal">-M</code> switch tells Git to look for renames.
The files end up looking like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = &#39;master&#39;)
--
2.1.0</code></pre>
</figure>
<p>You can also edit these patch files to add more information for the email list that you don&#8217;t want to show up in the commit message.
If you add text between the <code class="literal">---</code> line and the beginning of the patch (the <code class="literal">diff --git</code> line), then developers can read it; but applying the patch excludes it.</p>
<p>To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with “smarter” clients that don&#8217;t preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We&#8217;ll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned <code class="literal">Documentation/SubmittingPatches</code> file in the Git source code.</p>
<p>
First, you need to set up the imap section in your <code class="literal">~/.gitconfig</code> file.
You can set each value separately with a series of <code class="literal">git config</code> commands, or you can add them manually, but in the end your config file should look something like this:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[imap]</span>
  folder = <span style="font-style: italic">&quot;[Gmail]/Drafts&quot;</span>
<span style="font-style: italic">  host = imaps://imap.gmail.com</span>
<span style="font-style: italic">  user = user@gmail.com</span>
<span style="font-style: italic">  pass = p4ssw0rd</span>
<span style="font-style: italic">  port = 993</span>
<span style="font-style: italic">  sslverify = false</span></code></pre>
</figure>
<p>If your IMAP server doesn&#8217;t use SSL, the last two lines probably aren&#8217;t necessary, and the host value will be <code class="literal">imap://</code> instead of <code class="literal">imaps://</code>.
When that is set up, you can use <code class="literal">git imap-send</code> to place the patch series in the Drafts folder of the specified IMAP server:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</code></pre>
</figure>
<p>At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you&#8217;re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.</p>
<p>You can also send the patches through an SMTP server.
As before, you can set each value separately with a series of <code class="literal">git config</code> commands, or you can add them manually in the sendemail section in your <code class="literal">~/.gitconfig</code> file:</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[sendemail]</span>
  smtpencryption = <span style="font-style: italic">tls</span>
<span style="font-style: italic">  smtpserver = smtp.gmail.com</span>
<span style="font-style: italic">  smtpuser = user@gmail.com</span>
<span style="font-style: italic">  smtpserverport = 587</span></code></pre>
</figure>
<p>After this is done, you can use <code class="literal">git send-email</code> to send your patches:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>
</figure>
<p>Then, Git spits out a bunch of log information looking something like this for each patch you&#8217;re sending:</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line &#39;From: Jessica Smith &lt;jessica@example.com&gt;&#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>
</figure>
</section>
<section class="sect2" title="總結">
<h3 id="_總結">總結</h3>
<p>This section has covered a number of common workflows for dealing with several very different types of Git projects you&#8217;re likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you&#8217;ll see how to work the other side of the coin: maintaining a Git project.
You&#8217;ll learn how to be a benevolent dictator or integration manager.</p>
</section>
</section>
<section class="sect1" title="維護一個專案">
<h2 id="_維護一個專案">維護一個專案</h2>
<p>
In addition to knowing how to effectively contribute to a project, you&#8217;ll likely need to know how to maintain one.
This can consist of accepting and applying patches generated via <code class="literal">format-patch</code> and emailed to you, or integrating changes in remote branches for repositories you&#8217;ve added as remotes to your project.
Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is clearest for other contributors and sustainable by you over the long run.</p>
<section class="sect2" title="使用有特定主題的分支工作">
<h3 id="_使用有特定主題的分支工作">使用有特定主題的分支工作</h3>
<p>
When you&#8217;re thinking of integrating new work, it&#8217;s generally a good idea to try it out in a topic branch – a temporary branch specifically made to try out that new work.
This way, it&#8217;s easy to tweak a patch individually and leave it if it&#8217;s not working until you have time to come back to it.
If you create a simple branch name based on the theme of the work you&#8217;re going to try, such as <code class="literal">ruby_client</code> or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later.
The maintainer of the Git project tends to namespace these branches as well – such as <code class="literal">sc/ruby_client</code>, where <code class="literal">sc</code> is short for the person who contributed the work.
As you&#8217;ll remember, you can create the branch based off your master branch like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch sc/ruby_client master</code></pre>
</figure>
<p>Or, if you want to also switch to it immediately, you can use the <code class="literal">checkout -b</code> option:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b sc/ruby_client master</code></pre>
</figure>
<p>Now you&#8217;re ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.</p>
</section>
<section class="sect2" title="套用從電子郵件來的補丁">
<h3 id="r_patches_from_email">套用從電子郵件來的補丁</h3>
<p>
If you receive a patch over email that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it.
There are two ways to apply an emailed patch: with <code class="literal">git apply</code> or with <code class="literal">git am</code>.</p>
<section class="sect3" title="使用 apply 命令套用補丁">
<h4 id="_使用_apply_命令套用補丁">使用 apply 命令套用補丁</h4>
<p>
If you received the patch from someone who generated it with the <code class="literal">git diff</code> or a Unix <code class="literal">diff</code> command (which is not recommended; see the next section), you can apply it with the <code class="literal">git apply</code> command.
Assuming you saved the patch at <code class="literal">/tmp/patch-ruby-client.patch</code>, you can apply the patch like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply /tmp/patch-ruby-client.patch</code></pre>
</figure>
<p>This modifies the files in your working directory.
It&#8217;s almost identical to running a <code class="literal">patch -p1</code> command to apply the patch, although it&#8217;s more paranoid and accepts fewer fuzzy matches than patch.
It also handles file adds, deletes, and renames if they&#8217;re described in the <code class="literal">git diff</code> format, which <code class="literal">patch</code> won&#8217;t do.
Finally, <code class="literal">git apply</code> is an “apply all or abort all” model where either everything is applied or nothing is, whereas <code class="literal">patch</code> can partially apply patchfiles, leaving your working directory in a weird state.
<code class="literal">git apply</code> is overall much more conservative than <code class="literal">patch</code>.
It won&#8217;t create a commit for you – after running it, you must stage and commit the changes introduced manually.</p>
<p>You can also use git apply to see if a patch applies cleanly before you try actually applying it – you can run <code class="literal">git apply --check</code> with the patch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</figure>
<p>If there is no output, then the patch should apply cleanly.
This command also exits with a non-zero status if the check fails, so you can use it in scripts if you want.</p>
</section>
<section class="sect3" title="使用 am 命令套用補丁">
<h4 id="r_git_am">使用 <code class="literal">am</code> 命令套用補丁</h4>
<p>
If the contributor is a Git user and was good enough to use the <code class="literal">format-patch</code> command to generate their patch, then your job is easier because the patch contains author information and a commit message for you.
If you can, encourage your contributors to use <code class="literal">format-patch</code> instead of <code class="literal">diff</code> to generate patches for you.
You should only have to use <code class="literal">git apply</code> for legacy patches and things like that.</p>
<p>To apply a patch generated by <code class="literal">format-patch</code>, you use <code class="literal">git am</code>.
Technically, <code class="literal">git am</code> is built to read an mbox file, which is a simple, plain-text format for storing one or more email messages in one text file.
It looks something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</figure>
<p>This is the beginning of the output of the format-patch command that you saw in the previous section.
This is also a valid mbox email format.
If someone has emailed you the patch properly using git send-email, and you download that into an mbox format, then you can point git am to that mbox file, and it will start applying all the patches it sees.
If you run a mail client that can save several emails out in mbox format, you can save entire patch series into a file and then use git am to apply them one at a time.</p>
<p>However, if someone uploaded a patch file generated via <code class="literal">format-patch</code> to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to <code class="literal">git am</code> to apply it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am 0001-limit-log-function.patch
Applying: add limit to log function</code></pre>
</figure>
<p>You can see that it applied cleanly and automatically created the new commit for you.
The author information is taken from the email&#8217;s <code class="literal">From</code> and <code class="literal">Date</code> headers, and the message of the commit is taken from the <code class="literal">Subject</code> and body (before the patch) of the email.
For example, if this patch was applied from the mbox example above, the commit generated would look something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>
</figure>
<p>The <code class="literal">Commit</code> information indicates the person who applied the patch and the time it was applied.
The <code class="literal">Author</code> information is the individual who originally created the patch and when it was originally created.</p>
<p>But it&#8217;s possible that the patch won&#8217;t apply cleanly.
Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven&#8217;t applied yet.
In that case, the <code class="literal">git am</code> process will fail and ask you what you want to do:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &quot;git am --resolved&quot;.
If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.
To restore the original branch and stop patching run &quot;git am --abort&quot;.</code></pre>
</figure>
<p>This command puts conflict markers in any files it has issues with, much like a conflicted merge or rebase operation.
You solve this issue much the same way – edit the file to resolve the conflict, stage the new file, and then run <code class="literal">git am --resolved</code> to continue to the next patch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> (fix the file)
<span style="font-weight: bold">$</span> git add ticgit.gemspec
<span style="font-weight: bold">$</span> git am --resolved
Applying: seeing if this helps the gem</code></pre>
</figure>
<p>If you want Git to try a bit more intelligently to resolve the conflict, you can pass a <code class="literal">-3</code> option to it, which makes Git attempt a three-way merge.
This option isn&#8217;t on by default because it doesn&#8217;t work if the commit the patch says it was based on isn&#8217;t in your repository.
If you do have that commit – if the patch was based on a public commit – then the <code class="literal">-3</code> option is generally much smarter about applying a conflicting patch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</figure>
<p>In this case, this patch had already been applied.
Without the <code class="literal">-3</code> option, it looks like a conflict.</p>
<p>If you&#8217;re applying a number of patches from an mbox, you can also run the <code class="literal">am</code> command in interactive mode, which stops at each patch it finds and asks if you want to apply it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</figure>
<p>This is nice if you have a number of patches saved, because you can view the patch first if you don&#8217;t remember what it is, or not apply the patch if you&#8217;ve already done so.</p>
<p>When all the patches for your topic are applied and committed into your branch, you can choose whether and how to integrate them into a longer-running branch.</p>
</section>
</section>
<section class="sect2" title="切換到遠端分支">
<h3 id="r_checking_out_remotes">切換到遠端分支</h3>
<p>
If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and the name of the remote branch the changes are in, you can add them as a remote and do merges locally.</p>
<p>For instance, if Jessica sends you an email saying that she has a great new feature in the <code class="literal">ruby-client</code> branch of her repository, you can test it by adding the remote and checking out that branch locally:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add jessica git://github.com/jessica/myproject.git
<span style="font-weight: bold">$</span> git fetch jessica
<span style="font-weight: bold">$</span> git checkout -b rubyclient jessica/ruby-client</code></pre>
</figure>
<p>If she emails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.</p>
<p>This is most useful if you&#8217;re working with a person consistently.
If someone only has a single patch to contribute once in a while, then accepting it over email may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches.
You&#8217;re also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two.
However, scripts and hosted services may make this easier – it depends largely on how you develop and how your contributors develop.</p>
<p>The other advantage of this approach is that you get the history of the commits as well.
Although you may have legitimate merge issues, you know where in your history their work is based; a proper three-way merge is the default rather than having to supply a <code class="literal">-3</code> and hope the patch was generated off a public commit to which you have access.</p>
<p>If you aren&#8217;t working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the <code class="literal">git pull</code> command.
This does a one-time pull and doesn&#8217;t save the URL as a remote reference:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>
</figure>
</section>
<section class="sect2" title="決定要提到哪些資訊">
<h3 id="r_what_is_introduced">決定要提到哪些資訊</h3>
<p>
Now you have a topic branch that contains contributed work.
At this point, you can determine what you&#8217;d like to do with it.
This section revisits a couple of commands so you can see how you can use them to review exactly what you&#8217;ll be introducing if you merge this into your main branch.</p>
<p>It&#8217;s often helpful to get a review of all the commits that are in this branch but that aren&#8217;t in your master branch.
You can exclude commits in the master branch by adding the <code class="literal">--not</code> option before the branch name.
This does the same thing as the <code class="literal">master..contrib</code> format that we used earlier.
For example, if your contributor sends you two patches and you create a branch called <code class="literal">contrib</code> and applied those patches there, you can run this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</figure>
<p>To see what changes each commit introduces, remember that you can pass the <code class="literal">-p</code> option to <code class="literal">git log</code> and it will append the diff introduced to each commit.</p>
<p>To see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use a weird trick to get the correct results.
You may think to run this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff master</code></pre>
</figure>
<p>This command gives you a diff, but it may be misleading.
If your <code class="literal">master</code> branch has moved forward since you created the topic branch from it, then you&#8217;ll get seemingly strange results.
This happens because Git directly compares the snapshots of the last commit of the topic branch you&#8217;re on and the snapshot of the last commit on the <code class="literal">master</code> branch.
For example, if you&#8217;ve added a line in a file on the <code class="literal">master</code> branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.</p>
<p>If <code class="literal">master</code> is a direct ancestor of your topic branch, this isn&#8217;t a problem; but if the two histories have diverged, the diff will look like you&#8217;re adding all the new stuff in your topic branch and removing everything unique to the <code class="literal">master</code> branch.</p>
<p>What you really want to see are the changes added to the topic branch – the work you&#8217;ll introduce if you merge this branch with master.
You do that by having Git compare the last commit on your topic branch with the first common ancestor it has with the master branch.</p>
<p>Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on it:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
<span style="font-weight: bold">$</span> git diff 36c7db</code></pre>
</figure>
<p>However, that isn&#8217;t convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax.
In the context of the <code class="literal">diff</code> command, you can put three periods after another branch to do a <code class="literal">diff</code> between the last commit of the branch you&#8217;re on and its common ancestor with another branch:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff master...contrib</code></pre>
</figure>
<p>This command shows you only the work your current topic branch has introduced since its common ancestor with master.
That is a very useful syntax to remember.</p>
</section>
<section class="sect2" title="整合貢獻工作">
<h3 id="_整合貢獻工作">整合貢獻工作</h3>
<p>
When all the work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it.
Furthermore, what overall workflow do you want to use to maintain your project?
You have a number of choices, so we&#8217;ll cover a few of them.</p>
<section class="sect3" title="合併工作流程">
<h4 id="_合併工作流程">合併工作流程</h4>
<p>
One simple workflow merges your work into your <code class="literal">master</code> branch.
In this scenario, you have a <code class="literal">master</code> branch that contains basically stable code.
When you have work in a topic branch that you&#8217;ve done or that someone has contributed and you&#8217;ve verified, you merge it into your master branch, delete the topic branch, and then continue the process.
If we have a repository with work in two branches named <code class="literal">ruby_client</code> and <code class="literal">php_client</code> that looks like <a id="xref-rmerwf_a" href="#rmerwf_a" class="xref">History with several topic branches.</a> and merge <code class="literal">ruby_client</code> first and then <code class="literal">php_client</code> next, then your history will end up looking like <a id="xref-rmerwf_b" href="#rmerwf_b" class="xref">After a topic branch merge.</a>.</p>
<figure id="rmerwf_a" class="image">
<div class="content">
<img src="images/merging-workflows-1.png" alt="History with several topic branches."/>
</div>
<figcaption>圖表 20. History with several topic branches.</figcaption>
</figure>
<figure id="rmerwf_b" class="image">
<div class="content">
<img src="images/merging-workflows-2.png" alt="After a topic branch merge."/>
</div>
<figcaption>圖表 21. After a topic branch merge.</figcaption>
</figure>
<p>That is probably the simplest workflow, but it can possibly be problematic if you&#8217;re dealing with larger or more stable projects where you want to be really careful about what you introduce.</p>
<p>If you have a more important project, you might want to use a two-phase merge cycle.
In this scenario, you have two long-running branches, <code class="literal">master</code> and <code class="literal">develop</code>, in which you determine that <code class="literal">master</code> is updated only when a very stable release is cut and all new code is integrated into the <code class="literal">develop</code> branch.
You regularly push both of these branches to the public repository.
Each time you have a new topic branch to merge in (<a id="xref-rmerwf_c" href="#rmerwf_c" class="xref">Before a topic branch merge.</a>), you merge it into <code class="literal">develop</code> (<a id="xref-rmerwf_d" href="#rmerwf_d" class="xref">After a topic branch merge.</a>); then, when you tag a release, you fast-forward <code class="literal">master</code> to wherever the now-stable <code class="literal">develop</code> branch is (<a id="xref-rmerwf_e" href="#rmerwf_e" class="xref">After a project release.</a>).</p>
<figure id="rmerwf_c" class="image">
<div class="content">
<img src="images/merging-workflows-3.png" alt="Before a topic branch merge."/>
</div>
<figcaption>圖表 22. Before a topic branch merge.</figcaption>
</figure>
<figure id="rmerwf_d" class="image">
<div class="content">
<img src="images/merging-workflows-4.png" alt="After a topic branch merge."/>
</div>
<figcaption>圖表 23. After a topic branch merge.</figcaption>
</figure>
<figure id="rmerwf_e" class="image">
<div class="content">
<img src="images/merging-workflows-5.png" alt="After a topic branch release."/>
</div>
<figcaption>圖表 24. After a project release.</figcaption>
</figure>
<p>This way, when people clone your project&#8217;s repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.
You can also continue this concept, having an integrate branch where all the work is merged together.
Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.</p>
</section>
<section class="sect3" title="大量合併的工作六程">
<h4 id="_大量合併的工作六程">大量合併的工作六程</h4>
<p>
The Git project has four long-running branches: <code class="literal">master</code>, <code class="literal">next</code>, and <code class="literal">pu</code> (proposed updates) for new work, and <code class="literal">maint</code> for maintenance backports.
When new work is introduced by contributors, it&#8217;s collected into topic branches in the maintainer&#8217;s repository in a manner similar to what we&#8217;ve described (see <a id="xref-rmerwf_f" href="#rmerwf_f" class="xref">Managing a complex series of parallel contributed topic branches.</a>).
At this point, the topics are evaluated to determine whether they&#8217;re safe and ready for consumption or whether they need more work.
If they&#8217;re safe, they&#8217;re merged into <code class="literal">next</code>, and that branch is pushed up so everyone can try the topics integrated together.</p>
<figure id="rmerwf_f" class="image">
<div class="content">
<img src="images/large-merges-1.png" alt="Managing a complex series of parallel contributed topic branches."/>
</div>
<figcaption>圖表 25. Managing a complex series of parallel contributed topic branches.</figcaption>
</figure>
<p>If the topics still need work, they&#8217;re merged into <code class="literal">pu</code> instead.
When it&#8217;s determined that they&#8217;re totally stable, the topics are re-merged into <code class="literal">master</code> and are then rebuilt from the topics that were in <code class="literal">next</code> but didn&#8217;t yet graduate to <code class="literal">master</code>.
This means <code class="literal">master</code> almost always moves forward, <code class="literal">next</code> is rebased occasionally, and <code class="literal">pu</code> is rebased even more often:</p>
<figure class="image">
<div class="content">
<img src="images/large-merges-2.png" alt="Merging contributed topic branches into long-term integration branches."/>
</div>
<figcaption>圖表 26. Merging contributed topic branches into long-term integration branches.</figcaption>
</figure>
<p>When a topic branch has finally been merged into <code class="literal">master</code>, it&#8217;s removed from the repository.
The Git project also has a <code class="literal">maint</code> branch that is forked off from the last release to provide backported patches in case a maintenance release is required.
Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.</p>
</section>
<section class="sect3" title="衍合與挑揀的工作流程">
<h4 id="r_rebase_cherry_pick">衍合與挑揀的工作流程</h4>
<p>
Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or <code class="literal">develop</code>, and so on) branch.
If that works well, you can fast-forward your <code class="literal">master</code> branch, and you&#8217;ll end up with a linear project history.</p>
<p>
The other way to move introduced work from one branch to another is to cherry-pick it.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you&#8217;re currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you&#8217;d prefer to cherry-pick it rather than run rebase.
For example, suppose you have a project that looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/rebasing-1.png" alt="Example history before a cherry-pick."/>
</div>
<figcaption>圖表 27. Example history before a cherry-pick.</figcaption>
</figure>
<p>If you want to pull commit <code class="literal">e43a6</code> into your master branch, you can run</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</figure>
<p>This pulls the same change introduced in <code class="literal">e43a6</code>, but you get a new commit SHA-1 value, because the date applied is different.
Now your history looks like this:</p>
<figure class="image">
<div class="content">
<img src="images/rebasing-2.png" alt="History after cherry-picking a commit on a topic branch."/>
</div>
<figcaption>圖表 28. History after cherry-picking a commit on a topic branch.</figcaption>
</figure>
<p>Now you can remove your topic branch and drop the commits you didn&#8217;t want to pull in.</p>
</section>
<section class="sect3" title="Rerere">
<h4 id="_rerere">Rerere</h4>
<p>
If you&#8217;re doing lots of merging and rebasing, or you&#8217;re maintaining a long-lived topic branch, Git has a feature called “rerere” that can help.</p>
<p>Rerere stands for “reuse recorded resolution” – it&#8217;s a way of shortcutting manual conflict resolution.
When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there&#8217;s a conflict that looks exactly like one you&#8217;ve already fixed, it&#8217;ll just use the fix from last time, without bothering you with it.</p>
<p>This feature comes in two parts: a configuration setting and a command.
The configuration setting is <code class="literal">rerere.enabled</code>, and it&#8217;s handy enough to put in your global config:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global rerere.enabled true</code></pre>
</figure>
<p>Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.</p>
<p>If you need to, you can interact with the rerere cache using the <code class="literal">git rerere</code> command.
When it&#8217;s invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if <code class="literal">rerere.enabled</code> is set to <code class="literal">true</code>).
There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache.
We will cover rerere in more detail in <a id="xref--ch07-git-tools--r_rerere" href="ch07-git-tools.xhtml#r_rerere" class="xref">Rerere</a>.</p>
</section>
</section>
<section class="sect2" title="為釋出的版本加上標籤">
<h3 id="r_tagging_releases">為釋出的版本加上標籤</h3>
<p>
When you&#8217;ve decided to cut a release, you&#8217;ll probably want to drop a tag so you can re-create that release at any point going forward.
You can create a new tag as discussed in <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git 基礎</a>.
If you decide to sign the tag as the maintainer, the tagging may look something like this:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -s v1.5 -m <span style="font-style: italic">&#39;my signed 1.5 tag&#39;</span>
You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>
</figure>
<p>If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.
The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.
To do this, you can figure out which key you want by running <code class="literal">gpg --list-keys</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</figure>
<p>Then, you can directly import the key into the Git database by exporting it and piping that through <code class="literal">git hash-object</code>, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</figure>
<p>Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the <code class="literal">hash-object</code> command gave you:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</figure>
<p>If you run <code class="literal">git push --tags</code>, the <code class="literal">maintainer-pgp-pub</code> tag will be shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show maintainer-pgp-pub | gpg --import</code></pre>
</figure>
<p>They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running <code class="literal">git show &lt;tag&gt;</code> will let you give the end user more specific instructions about tag verification.</p>
</section>
<section class="sect2" title="產生一個建置編號">
<h3 id="r_build_number">產生一個建置編號</h3>
<p>
Because Git doesn&#8217;t have monotonically increasing numbers like <em>v123</em> or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run <code class="literal">git describe</code> on that commit.
Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you&#8217;re describing:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</figure>
<p>This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, <code class="literal">git --version</code> gives you something that looks like this.
If you&#8217;re describing a commit that you have directly tagged, it gives you the tag name.</p>
<p>The <code class="literal">git describe</code> command favors annotated tags (tags created with the <code class="literal">-a</code> or <code class="literal">-s</code> flag), so release tags should be created this way if you&#8217;re using <code class="literal">git describe</code>, to ensure the commit is named properly when described.
You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older <code class="literal">git describe</code> output names were invalidated.</p>
</section>
<section class="sect2" title="準備釋出一個版本">
<h3 id="r_preparing_release">準備釋出一個版本</h3>
<p>
Now you want to release a build.
One of the things you&#8217;ll want to do is create an archive of the latest snapshot of your code for those poor souls who don&#8217;t use Git.
The command to do this is <code class="literal">git archive</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git archive master --prefix=<span style="font-style: italic">&#39;project/&#39;</span> | gzip &gt; <span style="font-style: italic">`</span>git describe master<span style="font-style: italic">`</span>.tar.gz
<span style="font-weight: bold">$</span> ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</figure>
<p>If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the <code class="literal">--format=zip</code> option to <code class="literal">git archive</code>:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git archive master --prefix=<span style="font-style: italic">&#39;project/&#39;</span> --format=zip &gt; <span style="font-style: italic">`</span>git describe master<span style="font-style: italic">`</span>.zip</code></pre>
</figure>
<p>You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.</p>
</section>
<section class="sect2" title="簡短的日誌">
<h3 id="r_the_shortlog">簡短的日誌</h3>
<p>
It&#8217;s time to email your mailing list of people who want to know what&#8217;s happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or email is to use the <code class="literal">git shortlog</code> command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</figure>
<p>You get a clean summary of all the commits since v1.0.1, grouped by author, that you can email to your list.</p>
</section>
</section>
<section class="sect1" title="Summary">
<h2 id="_summary">Summary</h2>
<p class="last">You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users' contributions.
Congratulations on being an effective Git developer!
In the next chapter, you&#8217;ll learn about how to use the largest and most popular Git hosting service, GitHub.</p>
</section>
</section>
</body>
</html>