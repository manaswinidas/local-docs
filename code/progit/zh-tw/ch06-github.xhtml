<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>GitHub</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="GitHub" epub:type="chapter" id="ch06-github">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>GitHub</b></small></h1>
</div>
</header>
<p>
GitHub 是個上面有大量 Git 倉儲的主機，同時也是數以百萬計的開發者和專案的交流中心。
有非常高比例的 Git 倉儲是被託管在  GitHub 上的。同時也有很多的開源專案使用 GitHub 來做 Git 託管、議題追蹤、程式碼審閱，還有其他各種用途。
雖然這並非 Git 開源計畫的直接目的，但在你專業的使用 Git 時，你還是有很大的機會會想要或需要使用GitHub。</p>
<p>這章節是關於如何有效率的使用 GitHub。
這會包含帳號的申請和管理、 Git 倉儲的建立及使用、參與別人的專案以及管理自己的專案的一般流程、GitHub 的應用程式介面，以及各式各樣能讓你更加便利的小技巧。</p>
<p>如果你對於如何在 GitHub 上託管自己的專案或是與其他人一起在 GitHub上的專案上合作不感興趣的話，你可以放心地直接前進到下個章節 <a id="xref--ch07-git-tools" href="ch07-git-tools.xhtml" class="xref">Git Tools</a> 。</p>
<aside class="admonition warning" title="警告: 介面變更" epub:type="warning">
<h2>介面變更</h2>
<div class="content">
<p>有件很重要的事情是：就像其他的活動中的網站一樣，截圖中的使用者介面會隨時間改變。
希望這並不會影響到我們要做的事情，但如果你想要最新版的截圖，建議您去瀏覽線上版。</p>
</div>
</aside>
<section class="sect1" title="建立帳戶及設定">
<h2 id="_建立帳戶及設定">建立帳戶及設定</h2>
<p>
你第一件要做的事就是建立一個免費的使用者帳戶。
只要去 <a href="http://github.com" class="link">http://github.com</a>，選擇一個尚未被使用過的使用者名稱，輸入一個電郵地址以及一個密碼，然後按下那個大大的綠色「Sign up for GitHub」按鈕就可以了。</p>
<figure class="image">
<div class="content">
<img src="images/signup.png" alt="The GitHub sign-up form."/>
</div>
<figcaption>圖表 1. GitHub 的帳號申請畫面.</figcaption>
</figure>
<p>你會看到各種付費升級方案的頁面，但是在這裡我們只要選免費方案即可。
之後 GitHub 會寄給你一封電子郵件來確認電郵地址。
因為這很重要所快點去做（我們等一下會解釋）。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>你可以用免費帳戶使用 GitHub 所有的功能，但是你所有的專案都只能完全公開（所有人都有讀取權限）。
GitHub 的付費方案會提供數個私人專案的額度，但在本書中我們不會提及這個。</p>
</div>
</aside>
<p>點擊畫面左上的 GitHub 圖示會連結到你的資訊主頁。
你現在可以開始使用 GitHub 了。</p>
<section class="sect2" title="SSH 存取">
<h3 id="_ssh_存取">SSH 存取</h3>
<p>
你現在就可以透過 <code class="literal">https://</code> 協定並使用你剛剛設定的帳號及密碼來認證以連接你的 GitHub 倉儲。
但是，如果只是要克隆公開專案，其實你連註冊都不用 － 剛剛建立的帳號是在我們之後要 fork 專案或是推送變更到你複製的倉儲時才會用到。</p>
<p>如果想要使用 SSH 遠端，你必須要去設定一個公鑰。
（如果你沒有公鑰的話請參考 <a id="xref--ch04-git-server--r_generate_ssh_key" href="ch04-git-server.xhtml#r_generate_ssh_key" class="xref">產生你的 SSH 公鑰</a>。）
點擊視窗右上的連結開啟你的帳戶設定頁面:</p>
<pre class="screen">image::images/account-settings.png[``帳戶設定'' 連結。]</pre>
<p>然後點選左側的「SSH keys」區塊。</p>
<figure class="image">
<div class="content">
<img src="images/ssh-keys.png" alt="``SSH keys'' 連結。"/>
</div>
<figcaption>圖表 2. “SSH keys” 連結.</figcaption>
</figure>
<p>點選 "<code class="literal">Add an SSH key</code>" 按鈕，之後替你的金鑰命名，複製你的 <code class="literal">~/.ssh/id_rsa.pub</code>（或是任意檔名）公鑰檔的內容並貼在文字區塊內，然後點擊「Add key」。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>建議替你的金鑰取個容易記憶的名字。
你可以替你的每個金鑰取類似「我的筆電」或「工作帳號」的名字，這樣在之後要撤銷金鑰時，你可以很輕易地找出你要撤銷的那個金鑰。</p>
</div>
</aside>
</section>
<section class="sect2" title="你的頭像">
<h3 id="r_personal_avatar">你的頭像</h3>
<p>再來，你可以把那個自動生成的頭像換成你希望的那個圖像。
首先，切換到「profile」分頁（在 SSH keys 的上面那一個），然後點選「Upload new picture」。</p>
<figure class="image">
<div class="content">
<img src="images/your-profile.png" alt="``Profile'' 連結."/>
</div>
<figcaption>圖表 3. 「Profile」連結.</figcaption>
</figure>
<p>我們會拿個 Git 的圖示來用，而且我們會需要剪裁它。</p>
<figure class="image">
<div class="content">
<img src="images/avatar-crop.png" alt="裁切你上傳的頭像"/>
</div>
<figcaption>圖表 4. 裁切你的頭像.</figcaption>
</figure>
<p>之後你在網站上的任何互動，大家都會看到你的使用者名稱旁有你的頭像。</p>
<p>如果你剛好有在那知名的 Gravatar 上傳過頭像的話 （通常是 Wordpress 的帳戶會有用到），那個頭像會自動被當成預設的頭像，你就不需要執行這個步驟。</p>
</section>
<section class="sect2" title="你的電子郵件地址">
<h3 id="_你的電子郵件地址">你的電子郵件地址</h3>
<p>GitHub 是用電郵地址把 Git commits 和使用者關聯在一起的。
如果你擁有多個電郵地址，而且你也想要 GitHub 把他們正確的和你關聯在一起，你需要去管理頁面的 Emails 區塊，加入所有你使用的電子郵件。</p>
<figure id="r_add_email_addresses" class="image">
<div class="content">
<img src="images/email-settings.png" alt="加入你所有的電郵地址。"/>
</div>
<figcaption>圖表 5. 加入電郵地址</figcaption>
</figure>
<p>在 <a id="xref-r_add_email_addresses" href="#r_add_email_addresses" class="xref">加入電郵地址</a> 這張圖裡面，我們可以看到各種狀態。
第一個地址是已認證而且設定為主要的電郵地址，意味著所有的通知和其他信件都會寄到這個地址。
第二個地址是已認證，所以可以隨時被切換成主要的地址。
最後一個是未認證的，意味著那並不能作為你的主要地址使用。
如果 GitHub 在站上的任意一個 Git 倉儲的 commit 訊息裡發現有對應的電郵地址，它就會被連結到你的使用者。</p>
</section>
<section class="sect2" title="二階段驗證">
<h3 id="_二階段驗證">二階段驗證</h3>
<p>最後，為了得到額外的安全保障，你應該要設定二階段驗證（或稱作「2FA」）。
二階段驗證是個越來越熱門的驗證技術，能夠在你的密碼被盜取的時候仍能保障你的帳戶的安全。
開啟這個功能後，GitHub 會要求你提供兩個不同的方式來驗證。所以在其中一個失效時，攻擊者仍然不能存取你的帳號。</p>
<p>你可以在你的帳戶設定裡面的安全性分頁找到兩階段驗證的設定。</p>
<figure class="image">
<div class="content">
<img src="images/2fa-1.png" alt="2FA in the Security Tab"/>
</div>
<figcaption>圖表 6. 安全性專頁內的兩階段驗證</figcaption>
</figure>
<p>在點擊「Set up two-factor authentication」按鈕之後，他會連結到設定頁面，讓你可以設定手機 App 以產生第二階段驗證碼 （一個基於時間產生的一次性密碼），或者你也可以讓 GitHub 在你每次要登入時透過簡訊發送一個驗證碼給你。</p>
<p>當你選擇並完成 2FA 的設定之後，你的帳戶會變得更安全。並在之後的每次登入，除了密碼你還要提供一個驗證碼才能登入 GitHub。</p>
</section>
</section>
<section class="sect1" title="參與一個專案">
<h2 id="_參與一個專案">參與一個專案</h2>
<p>現在帳號設定好了，來看看一些關於如何對現有專案做出貢獻的有用小細節吧。</p>
<section class="sect2" title="Fork 專案">
<h3 id="_fork_專案">Fork 專案</h3>
<p>
如果你想要參與一個你沒有推送權限的專案，你可以「fork」一份。這代表說 GitHub 會複製一份這個專案的副本給你，並且你對這副本有全部的權限。這副本會存在於你的帳號下，你可以對它進行推送。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>歷史上，「fork」這件事情在程式開發的領域裡多少帶了點負面意味。因為有些人會透過這途徑將一個開源專案的發展帶往不同方向，甚至是創造出跟原本專案競爭的作品，進而導致貢獻者的分裂。
在 GitHub 上，「fork」就是把一份相同的專案放在你的帳號之下，讓你能夠公開對這專案做變更，做為一個以更開放的方式來參與專案。</p>
</div>
</aside>
<p>透過這方式，專案就不用去煩惱需要把所有協作者加入使用者來讓他們擁有推送的權限。
所有人可以 fork 專案，對 fork 出來的專案推送變更，然後去發出我們等下會提到的 Pull Request，來把這些變更貢獻回原本的專案裡。
這會開立一個能夠作程式碼審閱的討論串，然後擁有者能和貢獻者討論這個變更，直到擁有者覺得可以合併進原始專案裡面。</p>
<p>去到專案頁面，點下右上角的「Fork」鍵，就可以 fork 專案。</p>
<figure class="image">
<div class="content">
<img src="images/forkbutton.png" alt="「Fork」鈕"/>
</div>
<figcaption>圖表 7. 「Fork」鈕</figcaption>
</figure>
<p>幾秒鐘之後，你就會被帶到你有寫入權限的新專案頁面。</p>
</section>
<section class="sect2" title="GitHub 流程">
<h3 id="r_github_flow">GitHub 流程</h3>
<p>
GitHub 是基於一個以 Pull Request 為中心的特別合作流程而設計出來的。
這個流程，不論是你在一個緊密連結的團隊裡共同在單一倉儲上合作；或是一個由散布全球的陌生人們構成的合作網路或是公司，透過大量的 fork 專案來對專案做出貢獻，都能運作。
這一切都是基於我們在 <a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">使用 Git 分支</a> 這章所講過的 <a id="xref--ch03-git-branching--r_topic_branch" href="ch03-git-branching.xhtml#r_topic_branch" class="xref">主題分支</a> 的工作流程。</p>
<p>一般情況下就是照著下面的程序運作的：</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">從 <code class="literal">master</code> 建立一個主題分支。</span>
</li>
<li>
<span class="principal">加入一些變更來改善這個專案。</span>
</li>
<li>
<span class="principal">把這個分支推送到你的 GitHub 專案。</span>
</li>
<li>
<span class="principal">在 GitHub 上建立一個 Pull Request。</span>
</li>
<li>
<span class="principal">討論，並在需要的時候加入新的變更。</span>
</li>
<li>
<span class="principal">專案擁有者視情況決定要把這個 Pull Request 合併進原始專案，或是關閉它。</span>
</li>
</ol>
</div>
<p>這基本上就是我們在 <a id="xref--ch05-distributed-git--r_integration_manager" href="ch05-distributed-git.xhtml#r_integration_manager" class="xref">整合式管理員工作流程</a> 這部分提過的整合式管理流程，不過我們是使用 GitHub 的網頁工具來做溝通或是變更審閱，而非電子郵件。</p>
<p>我們來看看下面的例子來了解如何使用這個流程來對 GitHub 上的專案做出變更吧。</p>
<section class="sect3" title="建立一個 Pull Request">
<h4 id="_建立一個_pull_request">建立一個 Pull Request</h4>
<p>Tony 在找能夠在他的 Arduino 可程式化微控制器上運作的程式碼。然後他在 GitHub 的這個專案 <a href="https://github.com/schacon/blink" class="link">https://github.com/schacon/blink</a> 找到了個很棒的程式碼。</p>
<figure class="image">
<div class="content">
<img src="images/blink-01-start.png" alt="他想要做出貢獻的專案"/>
</div>
<figcaption>圖表 8. 他想要做出貢獻的專案</figcaption>
</figure>
<p>唯一的小問題就是閃爍的頻率太高了，我們覺得放慢成 3 秒一次會比原本的 1 秒一次好。
所以我們來改善這個程式並作為變更要求來提交回去吧。</p>
<p>首先，我們要先按下稍早提過的「Fork」鈕來取得這個專案的副本。
我們在這邊使用的使用者名稱是「tonychacon」，所以這個專案的副本會放在 <code class="literal">https://github.com/tonychacon/blink</code>，而且我們能編輯這個副本。
我們把它克隆一份到電腦上、建立主題分支、對程式碼作變更，最後推送回 GitHub。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/tonychacon/blink <i class="conum" data-value="1">①</i>
Cloning into &#39;blink&#39;...

<span style="font-weight: bold">$</span> cd blink
<span style="font-weight: bold">$</span> git checkout -b slow-blink <i class="conum" data-value="2">②</i>
Switched to a new branch &#39;slow-blink&#39;

<span style="font-weight: bold">$</span> sed -i <span style="font-style: italic">&#39;&#39;</span> <span style="font-style: italic">&#39;s/1000/3000/&#39;</span> blink.ino <i class="conum" data-value="3">③</i>

<span style="font-weight: bold">$</span> git diff --word-diff <i class="conum" data-value="4">④</i>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;three seconds is better&#39;</span> <i class="conum" data-value="5">⑤</i>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

<span style="font-weight: bold">$</span> git push origin slow-blink <i class="conum" data-value="6">⑥</i>
Username for &#39;https://github.com&#39;: tonychacon
Password for &#39;https://tonychacon@github.com&#39;:
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> 把我們 fork 的專案克隆一份到本機</li>
<li><i class="conum" data-value="2">②</i> 建立名稱有意義的主題分支</li>
<li><i class="conum" data-value="3">③</i> 對程式碼作變更</li>
<li><i class="conum" data-value="4">④</i> 確認這個變更一切 OK</li>
<li><i class="conum" data-value="5">⑤</i> 把變更加入我們的主題分支</li>
<li><i class="conum" data-value="6">⑥</i> 把我們的新分支推送回 GitHub 的 fork 上</li>
</ol>
</div>
<p>如果我們回到我們在 GitHub 上的 fork，我們可以看到 GitHub 發現我們推了新分支上來，並且顯示了一個大大的綠色按鈕讓我們可以檢視我們的變更，並能對原始專案開啟一個 Pull Request。</p>
<p>你也可以去到 在 <code class="literal">https://github.com/&lt;user&gt;/&lt;project&gt;/branches</code> 上的「Branches」頁面去找出你的分支並從那邊開啟一個新的 Pull Request。</p>
<figure class="image">
<div class="content">
<img src="images/blink-02-pr.png" alt="Pull Request 按鈕"/>
</div>
<figcaption>圖表 9. Pull Request 按鈕</figcaption>
</figure>
<p>
如果我們按下綠色按鈕，我們會看到一個畫面，要求我們針對這次的 Pull Request 編寫「標題」和「描述」。
花費一些心思在這上面總是值得的，因為好的說明可以幫助原專案的擁有者去確認「你所嘗試的事情」、「你提案的變更內容是否正確」以及「接受這些變更是否有改善到原專案」。</p>
<p>同時我們也會看到在主分支沒有的所有提交列表（在這個範例中只有一個提交），和一個彙整所有修改的差異資訊，以便讓其他人知道當原作者合併後會有哪些差異。</p>
<figure class="image">
<div class="content">
<img src="images/blink-03-pull-request-open.png" alt="建立 Pull Request"/>
</div>
<figcaption>圖表 10. Pull Request 建立頁面</figcaption>
</figure>
<p>當你按下畫面中的「Create pull request」按鈕時，你 fork 的來源專案的擁有者會收到一個通知，通知他有人建議一個變動並且會附上連往包含所有資訊的頁面連結。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>雖然在這種公開專案上，Pull Requests 通常都是在貢獻者已經準備好要加入的變更時才會發出；但是它常用於專案「剛開始」時的一些內部專案。基於 Pull Request 在建立「之後」仍然可以持續加入新的變更的特性，因此也常會在初期建立當作一個團隊合作的環境，而非在最後才使用。</p>
</div>
</aside>
</section>
<section class="sect3" title="重複使用一個 Pull Request">
<h4 id="_重複使用一個_pull_request">重複使用一個 Pull Request</h4>
<p>現在呢，專案的擁有者可以閱覽所有建議的變更，然後決定要合併進來、拒絕變更或是對這留下評論。在這邊我們當作他覺得他喜歡這點子好了，但是他覺得燈暗掉的時間要比亮的時間長一點。</p>
<p>這個互動或許會透過電子郵件並依照在 <a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">分散式的 Git</a> 提到的工作流程運作；而在 GitHub 上，這是在線上運作的。專案擁有者可以在審閱差異總表時，點一下想要評論的那行內容並留下評論。</p>
<figure class="image">
<div class="content">
<img src="images/blink-04-pr-comment.png" alt="Pull Request 行評論"/>
</div>
<figcaption>圖表 11. 對 Pull Request 的某行程式碼下評論</figcaption>
</figure>
<p>當維護者留下評論，建立這個 Pull Request 的人（以及所有關注這個倉儲的人）都會收到通知。我們等等會對這做自訂，不過如果有開啟電子郵件通知，Tony 會這樣的一封信：</p>
<figure id="r_email_notification" class="image">
<div class="content">
<img src="images/blink-04-email.png" alt="郵件通知"/>
</div>
<figcaption>圖表 12. 以電子郵件型式寄送的評論</figcaption>
</figure>
<p>其他人也可以對 Pull Request 留下一般評論。 在 <a id="xref-r_pr_discussion" href="#r_pr_discussion" class="xref">Pull Request 討論頁</a> 裏面我們可以看到專案擁有者對某行程式碼做評論，同時也在討論區塊留了一般評論。你可以看到程式碼評論也會被帶到這個互動之中。</p>
<figure id="r_pr_discussion" class="image">
<div class="content">
<img src="images/blink-05-general-comment.png" alt="PR 討論頁面"/>
</div>
<figcaption>圖表 13. Pull Request 討論頁</figcaption>
</figure>
<p>現在貢獻者就可以知道他要做哪些處理才能讓擁有者接受這個變更。
幸好這事也很直觀。
如果是透過電子郵件的話你需要把所有的變動重新執行一次然後重新上傳，但是在 GitHub 上你只要對主題分支再次做提交然後推送上去，即可更新該 Pull Request。
在 <a id="xref-r_pr_final" href="#r_pr_final" class="xref">結束 Pull Request</a> 中，你也可以看到 Pull Request 中舊的程式碼上的評論都被折疊起來，這是因為它所評論的程式碼已經被更新了。</p>
<p>如果是在已發出的 Pull Request 中再加入新的提交並不會觸發通知，所以一旦 Tony 以這種方式推送修正，他需要再留下一個評論以通知專案擁有者：他已完成所要求的修改。</p>
<figure id="r_pr_final" class="image">
<div class="content">
<img src="images/blink-06-final.png" alt="結束 Pull Request"/>
</div>
<figcaption>圖表 14. 結束 Pull Request</figcaption>
</figure>
<p>有個有趣的東西就是如果你點開 Pull Request 的「Files Changed」分頁，你會得到一份「統整過的」差異表 —— 也就是所有當這個主題分支被合併進主要分支時會做的變動。以「git diff」的方式來講，就是自動顯示給你對 Pull Request 指定的主題分支做「git diff master&#8230;&#8203;&lt;branch&gt;」的結果。看 <a id="xref--ch05-distributed-git--r_what_is_introduced" href="ch05-distributed-git.xhtml#r_what_is_introduced" class="xref">決定要提到哪些資訊</a> 來了解更多關於這種差異表的事情。</p>
<p>另外一件你會注意到的就是 GitHub 會確認這個 Pull Request 是否能直接合併，並顯示一個能讓你直接在伺服器上做合併的按鈕。這個按鈕只有在你對這個倉儲有寫入權限，而且能簡易的合併時才會出現。當你按下這個按鈕時，GiHub 會做一個「非快速向前」的合併，意味著即使這個合併「能」以快速向前的方式處理，GitHub 還是會建立一個合併的提交。</p>
<p>你可以基於你的偏好改用這樣的方式：pull 這個分支下來，然後在本機合併進去。如果你把這個分支合併進 <code class="literal">master</code> 分支並推送上 GitHub，對應的 Pull Request 會自動關閉。</p>
<p>大部分的 GitHub 專案都使用著這樣的基本流程。建立主題分支，基於這分支建立 Pull Request，針對這個做討論，可能還會在這分支上做更多變更，最後這個要求就被關閉或合併了。</p>
<aside class="admonition note" title="筆記: 不只有 Forks" epub:type="note">
<h2>不只有 Forks</h2>
<div class="content">
<p>有件很重要的事情是：你也可以對同個倉儲的兩個分支做 Pull Request。如果你跟別人在一個雙方都有寫入權限的專案編寫新功能；你可以推送一個主題分支到倉儲裡，然後以這個分支對同個專案裡的 <code class="literal">master</code> 建立一個 Pull Request，藉此來做程式碼審閱以及討論。這不需要 Fork。</p>
</div>
</aside>
</section>
</section>
<section class="sect2" title="Pull Request 的進階用法">
<h3 id="_pull_request_的進階用法">Pull Request 的進階用法</h3>
<p>現在我們已經講完關於對 GitHub 上的專案做貢獻的基本部份了。來看看一些讓你可以更有效率的使用 Pull Request 的小技巧吧。</p>
<section class="sect3" title="把 Pull Request 做成補丁">
<h4 id="_把_pull_request_做成補丁">把 Pull Request 做成補丁</h4>
<p>有件很重要的事情是：很多專案並不會把這些 Pull Request 當成一系列可以乾淨確實的使用的完美補丁，就像許多基於郵件清單運作的專案對系列補丁貢獻的看法。大多數的 GitHub 專案是把 Pull Request 分支用來做多次對期望變更的交流溝通，並將結果集中在一個差異檔，並用其做合併。</p>
<p>這是個很重要的差異，因為通常變動會在程式碼完備之前就被提出，這點跟基於郵件清單的運作模式是天差地遠的。這讓維護者們可以更早做溝通，讓適合的解決方案可以在接受更多社群能量下誕生。當有人使用 Pull Request 提出程式碼，然後維護者或是社群建議了一個變更，雖然這補丁系列不會重來，但相對的會以一個新的提交的形式加入這個分支，並讓討論和背景可以齊頭並進。</p>
<p>舉例來說，你可以回到 <a href="#r_pr_final" class="xref">結束 Pull Request</a> 這邊看看，你會注意到那個貢獻者並沒有把他的提交重組之後另外開個新的 Pull Request，而是加入新的提交並推送到原本的分支。如果之後你回去看看 Pull Request，你可以看到之前我們為何做了這樣的變動的背景。當按下網站上的「Merge」鈕時，會建立一個參考那個 Pull Request 的合併提交，這樣當有需要時你可以很容易的就找到它並研究當初的交談內容。</p>
</section>
<section class="sect3" title="跟上上游">
<h4 id="_跟上上游">跟上上游</h4>
<p>如果你的 Pull Request 因為過期或是其他原因導致不能很乾淨的合併，你就會希望去處理這個問題來方便維護者合併它。GitHub 會自動對這點做測試並在頁面最下方告訴你這個 Pull Request 是否能簡易的合併。</p>
<figure id="r_pr_fail" class="image">
<div class="content">
<img src="images/pr-01-fail.png" alt="Pull Request 合併失敗"/>
</div>
<figcaption>圖表 15. 不能乾淨的合併的 Pull Request</figcaption>
</figure>
<p>如果你看到類似 <a id="xref-r_pr_fail" href="#r_pr_fail" class="xref">不能乾淨的合併的 Pull Request</a> 的畫面，你就會希望去對你的分支做修正讓那個標示轉綠，之後維護者就不需要做額外的事。</p>
<p>你有兩個方式可以來處理這個狀況。你可以用變基把你的分支接在目標分支 (通常會是你 fork 的專案的 <code class="literal">master</code> 分支) 上，或是把目標分支合併進你的分支。</p>
<p>大部分在 GitHub 上的開發者都會選擇後者，基於上個章節所提的理由：我們看重的是歷史紀錄和最終的合併，所以變基除了給你一個乾淨一點點的歷史之外，你得到的只會是「非常」大的困難並且更容易犯錯。</p>
<p>如果你想要先對目標分支合併使得你的 Pull Request 能被自動合併，你可以把原始倉儲設定成一個新的遠端、從上面擷取資訊、把那個倉儲的主要分支合併進你的主題分支，修正任何可能的問題，最後再推送回你的開 Pull Request 的 主題分支。</p>
<p>舉之前「tonychacon」的例子來說，原始作者做了一個會和 Pull Request 衝突的變更。所以我們來看看解決這個問題的步驟吧。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add upstream https://github.com/schacon/blink <i class="conum" data-value="1">①</i>

<span style="font-weight: bold">$</span> git fetch upstream <i class="conum" data-value="2">②</i>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

<span style="font-weight: bold">$</span> git merge upstream/master <i class="conum" data-value="3">③</i>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

<span style="font-weight: bold">$</span> vim blink.ino <i class="conum" data-value="4">④</i>
<span style="font-weight: bold">$</span> git add blink.ino
<span style="font-weight: bold">$</span> git commit
[slow-blink 3c8d735] Merge remote-tracking branch &#39;upstream/master&#39; \
    into slower-blink

<span style="font-weight: bold">$</span> git push origin slow-blink <i class="conum" data-value="5">⑤</i>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> 將原本的倉儲新增為遠端，並取名為「upstream」</li>
<li><i class="conum" data-value="2">②</i> 從這個遠端擷取最新的內容</li>
<li><i class="conum" data-value="3">③</i> 把主要分支合併進你的主題分支</li>
<li><i class="conum" data-value="4">④</i> 修正產生的衝突</li>
<li><i class="conum" data-value="5">⑤</i> 再推送回同一個主題分支</li>
</ol>
</div>
<p>當你做完上述步驟，Pull Request 會自動更新並檢查是否能乾淨的合併。</p>
<figure id="r_pr_merge_fix" class="image">
<div class="content">
<img src="images/pr-02-merge-fix.png" alt="已修正的 Pull Request"/>
</div>
<figcaption>圖表 16. Pull Request 現在能乾淨的合併了</figcaption>
</figure>
<p>Git 偉大的事情之一就是你可以一直重複這個過程。當你有個長期運作的專案時，你可以很簡單的重複對目標分支做合併，而你只要對最近一次的合併產生的衝突做處理即可，讓這個程序易於管理。</p>
<p>如果你一定要對分支做變基，你還是可以這樣做，不過強烈建議你不要強制對已經開了 Pull Request 分支做推送。如果其他人已經 pull 下來而且做了些變動，你會遇到所有在 <a id="xref--ch03-git-branching--r_rebase_peril" href="ch03-git-branching.xhtml#r_rebase_peril" class="xref">使用衍和的危險</a> 描述的問題。相對的，應該要把變基過的分支推送到 GitHub 上的新分支，然後建立一個參考至舊的 PR 的新 Pull Request，之後關閉原本的 PR。</p>
</section>
<section class="sect3" title="參考">
<h4 id="_參考">參考</h4>
<p>你的下一個問題可能是「我要怎麼對舊的 Pull Request 做參考連結？」。這有非常非常多的方法可以對其他東西做參考連結，幾乎所有你在 GitHub 上能撰寫訊息的地方都可以做到。</p>
<p>先從怎麼在 Pull Request 或是議題互相做參考開始吧。所有的 Pull Request 在專案裡都會被賦與一個獨一無二的編號。舉例來說你不能同時擁有 Pull Request #3 和議題 #3。如果你要在 Pull Request 裡參考其他的 Pull Request 和議題，你只要在評論或描述打下 <code class="literal">#&lt;num&gt;</code> 即可。你也可以指定參考不在同個專案裡的專案；如果是在同一個倉儲的 fork 裡你可以用 <code class="literal">username#&lt;num&gt;</code> 指定，或是 <code class="literal">username/repo#&lt;num&gt;</code> 來指定別人的其他倉儲裡的專案。</p>
<p>來看個範例吧。假設我們們在上個範例選擇使用變基處理分支，並為此開了新的 Pull Request，之後我們想要在新的 PR 裡放個參考連結到舊的。而且我們也想要參考一個在這個倉儲的 fork 裡的議題，還有一個在完全不同的專案裡的議題。我們的描述就可以用 <a id="xref-r_pr_references" href="#r_pr_references" class="xref">Pull Request 裡的跨倉儲參考</a> 裡的寫法。</p>
<figure id="r_pr_references" class="image">
<div class="content">
<img src="images/mentions-01-syntax.png" alt="PR 參考"/>
</div>
<figcaption>圖表 17. Pull Request 裡的跨倉儲參考</figcaption>
</figure>
<p>當我們送出這個 pull request，我們可以看到內容被渲染成 <a id="xref-r_pr_references_render" href="#r_pr_references_render" class="xref">在 Pull Request 中被渲染後的跨倉儲參考。</a> 裡的型式。</p>
<figure id="r_pr_references_render" class="image">
<div class="content">
<img src="images/mentions-02-render.png" alt="渲染過的 Pull Request"/>
</div>
<figcaption>圖表 18. 在 Pull Request 中被渲染後的跨倉儲參考。</figcaption>
</figure>
<p>可以注意到那完整的 GitHub 網址被簡化了，只留下必需的資訊。</p>
<p>如果 Tony 現在去關閉原本的 Pull Request，當我們在新的 PR 標記它時會得知這件事情，因為 GitHub 會自動在 PR 的時間線上對這件事做反向追蹤。這意味著所有造訪舊的 PR 頁面的人會知道這個 PR 已經被一個新的 PR 取代了，並且能簡單的透過連結造訪新的 PR 頁面。這連結看起來就是 <a id="xref-r_pr_closed" href="#r_pr_closed" class="xref">在 Pull Request 中被渲染後的跨倉儲參考。</a> 這樣。</p>
<figure id="r_pr_closed" class="image">
<div class="content">
<img src="images/mentions-03-closed.png" alt="已關閉的 PR"/>
</div>
<figcaption>圖表 19. 在 Pull Request 中被渲染後的跨倉儲參考。</figcaption>
</figure>
<p>除了議題編號之外，你也可以用 SHA-1 對一個提交做參考。你必須完整的標出 40 字元的 SHA-1，然後 GitHub 在評論裡看到那個 SHA-1 時就會產生該提交的超連結。而且你也可以用和議題一樣的方式，對其他 fork 甚至是其他倉儲的提交做參考。</p>
</section>
</section>
<section class="sect2" title="Markdown">
<h3 id="_markdown">Markdown</h3>
<p>連結其他議題，對於你在 GitHub 大多數的文字方塊裡能做的有趣事情而言，只是個開始。在議題、PR 描述、評論、程式碼評論，以及其他更多的地方，你都可以使用「GitHub 風格的 Markdown」。Markdown 能以純文字方式編輯，但能渲染出豐富的內容。</p>
<p>看看 <a id="xref-r_example_markdown" href="#r_example_markdown" class="xref">一個顯示出 Markdwon 撰寫型式和渲染結果的範例</a> 的範例來看看文字和評論能怎樣撰寫，並接著以 Markdwon 的方式渲染。</p>
<figure id="r_example_markdown" class="image">
<div class="content">
<img src="images/markdown-01-example.png" alt="Markdown 範例"/>
</div>
<figcaption>圖表 20. 一個顯示出 Markdwon 撰寫型式和渲染結果的範例</figcaption>
</figure>
<section class="sect3" title="GitHub Flavored Markdown">
<h4 id="_github_flavored_markdown">GitHub Flavored Markdown</h4>
<p>GitHub 風格的 Markdown 增加了許多你在基本 Markdown 語法做不到的事。這些在你要建立有用的 Pull Request、議題評論、描述時，會非常的有用。</p>
<section class="sect4" title="工作清單">
<h5 id="_工作清單">工作清單</h5>
<p>第一個專屬於 GitHub 的 Markdown 功能，特別是在 Pull Request 上，就是工作清單。工作清單就是一系列對應到你想要完成的事情的核取方塊。把這放在議題或是 Pull Request 裡時，通常表明了你想要完成的事項。</p>
<p>你可以建立這樣的工作清單:</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>- [X] 撰寫程式碼
- [ ] 撰寫所有的測試項
- [ ] 為程式碼做文件</code></pre>
</figure>
<p>如果我們在 Pull Request 的描述裡或是議題裡加入這個，我們就能看到他被渲染成像 <a id="xref-r_task_lists" href="#r_task_lists" class="xref">Markdwon 評論裡渲染後的工作清單。</a> 這樣。</p>
<figure id="r_task_lists" class="image">
<div class="content">
<img src="images/markdown-02-tasks.png" alt="工作清單範例"/>
</div>
<figcaption>圖表 21. Markdwon 評論裡渲染後的工作清單。</figcaption>
</figure>
<p>這個功能在 Pull Request 裏面，常被用來聲明在合併之前，你想要在這個分支裡完成的事情。最酷的地方就是你只要點下核取方塊就能更新你的評論－你不需要為了標記工作完成而得修改 Markdown。</p>
<p>除此之外，GitHub 還會把議題和 Pull Request 裡面所有的工作清單整理起來，把它們作為後設資料顯示在 Pull Request 的清單頁面。舉例來說，如果你的 Pull Rewquest 裡面有工作清單，你可以在所有 Pull Request 的總覽頁面上看到進度。這讓人們得以把一個 Pull Request 分解成數個小工作，同時也便於其他人追蹤這個分支上的進度。你可以在 <a id="xref-r_task_list_progress" href="#r_task_list_progress" class="xref">在 Pull Request 清單裡的工作清單統整。</a> 看到關於這個功能的範例。</p>
<figure id="r_task_list_progress" class="image">
<div class="content">
<img src="images/markdown-03-task-summary.png" alt="工作清單範例"/>
</div>
<figcaption>圖表 22. 在 Pull Request 清單裡的工作清單統整。</figcaption>
</figure>
<p>當你在實作一個功能的開始就開了 Pull Request，並使用工作清單追蹤進度時，這個功能會驚人的好用。</p>
</section>
<section class="sect4" title="程式碼摘錄">
<h5 id="_程式碼摘錄">程式碼摘錄</h5>
<p>你也可以在評論裡摘錄某段程式碼。當你想要展示某段還沒提交到分支的變更時，這會非常的有用。這在展示無法正常運作或是這個 Pull Request 可以實作的的程式碼時也會用到。</p>
<p>你摘錄的程式碼需要用反引號「包」起來。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println(&quot;i is : &quot; + i);
}
```</code></pre>
</figure>
<p>如果你在上面那段代碼的 java 的位置放上其他的程式語言名稱，GitHub 也會試著做語法上色。如果以我們上面的範例來說，上面那段代碼最後會被渲染成 <a id="xref-r_md_code" href="#r_md_code" class="xref">被渲染過的嵌入程式碼片斷</a> 的樣子。</p>
<figure id="r_md_code" class="image">
<div class="content">
<img src="images/markdown-04-fenced-code.png" alt="渲染過的嵌入代碼"/>
</div>
<figcaption>圖表 23. 被渲染過的嵌入程式碼片斷</figcaption>
</figure>
</section>
<section class="sect4" title="引文">
<h5 id="_引文">引文</h5>
<p>如果你要對一長段評論的一部份做回應，你只要複製你需要的片斷，然後在前面加上 <code class="literal">&gt;</code> 即可。事實上，因為這個功能因為太實用也太常用到，所以有一個專用的快捷鍵可用。如果你把評論你要回應的文字反白起來，並按下 <code class="literal">r</code> 鍵，那段文字就會被引文到評論欄裡供你使用。</p>
<p>引文的部份看起來就像這樣：</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>&gt; Whether &#39;tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</code></pre>
</figure>
<p>經過渲染之後評論就會變成 <a id="xref-r_md_quote" href="#r_md_quote" class="xref">渲染過的引文範例</a> 這個樣子。</p>
<figure id="r_md_quote" class="image">
<div class="content">
<img src="images/markdown-05-quote.png" alt="渲染過的引文"/>
</div>
<figcaption>圖表 24. 渲染過的引文範例</figcaption>
</figure>
</section>
<section class="sect4" title="表情符號">
<h5 id="_表情符號">表情符號</h5>
<p>最後就是你可以在評論裡使用表情符號。這個東西很常出現在許多 GitHub 議題和 Pull Request 的評論裏面。GitHub 上甚至有表情符號工具。如果你在評論裡用了 <code class="literal">:</code> 當作開頭，自動完成會協助你找出你想要的表情。</p>
<figure id="r_md_emoji_auto" class="image">
<div class="content">
<img src="images/markdown-06-emoji-complete.png" alt="表情符號自動完成器"/>
</div>
<figcaption>圖表 25. 表情符號的自動完成提示</figcaption>
</figure>
<p>你可以在評論的任何地方打出 <code class="literal">:&lt;name&gt;:</code> 來使用表情符號。舉例來說，你可以寫出這樣的東西：</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it&#39;s :fire::poop:!

:clap::tada::panda_face:</code></pre>
</figure>
<p>經過渲染之後會變成這樣 <a id="xref-r_md_emoji" href="#r_md_emoji" class="xref">使用大量表情符號的評論</a>：</p>
<figure id="r_md_emoji" class="image">
<div class="content">
<img src="images/markdown-07-emoji.png" alt="表情符號"/>
</div>
<figcaption>圖表 26. 使用大量表情符號的評論</figcaption>
</figure>
<p>雖然不能說它是是個非常實用的功能，但它能在這種不方便表達情緒的媒介裡，加入了由趣味和心情構成的元素。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>事實上現在有不少的網路服務可以在上面使用表符字元。這邊有張非常好用的大抄可以讓你很快到找到能表達你現在情緒的符號：</p>
<p><a href="http://www.emoji-cheat-sheet.com" class="link">http://www.emoji-cheat-sheet.com</a></p>
</div>
</aside>
</section>
<section class="sect4" title="圖片">
<h5 id="_圖片">圖片</h5>
<p>技術上來說，雖然這並不是 GitHub 風格的 Markdown，但是還是非常的實用。如果不想用 Markdown 圖片語法這種很難知道是什麼圖片的方法之外，GitHub 允許你以把圖片拖曳至文字方塊的方式來嵌入圖片。</p>
<figure id="r_md_drag" class="image">
<div class="content">
<img src="images/markdown-08-drag-drop.png" alt="圖片拖放"/>
</div>
<figcaption>圖表 27. 以拖曳的方式來上傳並自動嵌入圖片</figcaption>
</figure>
<p>如果你回到 <a href="#r_pr_references" class="xref">Pull Request 裡的跨倉儲參考</a>，你會在文字區塊上看到一個小小的「Parsed as Markdown」提示。點一下那個提示，他就會提供你包含所有在 GitHub 上可以用 Markdown 做的事的小抄。</p>
</section>
</section>
</section>
</section>
<section class="sect1" title="維護專案">
<h2 id="r_maintaining_gh_project">維護專案</h2>
<p>現在我們可以舒適自在地對一個專案做出貢獻了，所以我們來看看另一個面向：建立、維護以及管理一個專案。</p>
<section class="sect2" title="建立一個新倉儲">
<h3 id="_建立一個新倉儲">建立一個新倉儲</h3>
<p>來建立一個拿來分享我們的原始碼的倉儲吧。
首先點擊主控面板右邊的「New Repository」；或是點擊頂端工具列裡面使用者名稱旁邊的 <code class="literal">+</code> 按鈕，如 <a id="xref-r_new_repo_dropdown" href="#r_new_repo_dropdown" class="xref">「New repository」下拉式選單.</a> 所示。</p>
<figure class="image">
<div class="content">
<img src="images/newrepo.png" alt="「Your Repositories」區塊"/>
</div>
<figcaption>圖表 28. 「Your Repositories」區塊</figcaption>
</figure>
<figure id="r_new_repo_dropdown" class="image">
<div class="content">
<img src="images/new-repo.png" alt="「New repository」 下拉式選單"/>
</div>
<figcaption>圖表 29. 「New repository」下拉式選單.</figcaption>
</figure>
<p>這會把你帶到「new repository」表單的所在頁面：</p>
<figure class="image">
<div class="content">
<img src="images/newrepoform.png" alt="「new repositroy」表單"/>
</div>
<figcaption>圖表 30. 「new repositroy」表單</figcaption>
</figure>
<p>你只需要提供專案名稱，因為剩餘的欄位是完全選擇性的。
現在，你只要點下「Create Repository」鈕，然後碰地一聲——你就擁有了一個在 GitHub 上名為 <code class="literal">&lt;user&gt;/&lt;project_name&gt;</code> 的全新倉儲了。</p>
<p>因為你這個倉儲還沒有任何原始碼在裡面，GitHub 會展示一份關於如何建立一個全新的 Git 倉儲或是連結一個舊有 Git 專案的指引。
我們在這邊不會對這這部份多做描述，如果你需要回憶一下，去看看 <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git 基礎</a> 吧。</p>
<p>現在你的專案被託管在 GitHub 上了，你可以把網址給任何你想要分享專案的人。
所有人都可以透過 <code class="literal">https://github.com/&lt;user&gt;/&lt;project_name&gt;</code> 以 HTTP 方式存取，或是透過 <code class="literal">git@github.com:&lt;user&gt;/&lt;project_name&gt;</code> 以 SSH 方式存取。
Git 可以透過上述兩種途徑來推送及擷取資料，但所有操作都會透過對其連結的使用的驗證資訊來做存取控管。</p>
<aside class="admonition note" title="筆記" epub:type="note">
<div class="content">
<p>通常公開專案會傾向於分享基於 HTTP 的網址，因為這樣沒有 GitHub 帳戶的使用者也能夠對其存取來拓製專案。
如果你給了 SSH 版本的網址，使用者必須建立一個帳戶並加入 SSH key 才能存取專案。
而且 HTTP 網址就是他們會貼在瀏覽器裡來瀏覽專案的網址。</p>
</div>
</aside>
</section>
<section class="sect2" title="增加協作者">
<h3 id="_增加協作者">增加協作者</h3>
<p>你必須要把和你合作的人加入「協作者」，這樣他們才能對專案提交變更。
如果 Ben、Jeff 和 Louise 都有 GitHub 帳戶，而且你想要給他們推送變更的權限，你可以把他們加到你的專案。
把他們加入專案後，他們可以對專案「推送」變更，這意味著他們有這專案及專案的 Git 倉儲的讀寫權限。</p>
<p>點擊右側欄最下面的「Settings」連結。</p>
<figure class="image">
<div class="content">
<img src="images/reposettingslink.png" alt="倉儲設定連結。"/>
</div>
<figcaption>圖表 31. 倉儲設定連結。</figcaption>
</figure>
<p>接著選擇右邊選單的「Collaborators」。
然後在文字方塊裡輸入使用者名稱，按下「Add collaborator」。
你可以一直重複這個步驟來賦予所有你想要的人存取權限。
如果你要收回權限，只要點一下那個使用者右手邊的「X」即可。</p>
<figure class="image">
<div class="content">
<img src="images/collaborators.png" alt="倉儲協作者區"/>
</div>
<figcaption>圖表 32. 倉儲協作者</figcaption>
</figure>
</section>
<section class="sect2" title="管理 Pull Requests">
<h3 id="_管理_pull_requests">管理 Pull Requests</h3>
<p>現在你擁有一個裡面有些原始碼的專案，同時也可能會有些擁有推送權限的協作者。然後我們來看看當你收到 Pull Request 時要如何處理吧。</p>
<p>Pull Requests 可能是來自某個 fork 裡的分支，或是同個倉儲裡的某個分支。
兩者之間只差在，來自其他 fork 的 PR 通常你沒有對他們分支的推送權限，他們也沒有；而內部 PR 就是雙方都能存取分支。</p>
<p>關於這些東西的範例，我們就在這邊假設你是「tonychacon」而且你建立了一個名叫「fade」的 Arduino 原始碼專案吧。</p>
<section class="sect3" title="電郵通知">
<h4 id="r_email_notifications">電郵通知</h4>
<p>有人對你的原始碼做了些變更，然後發給你一個 Pull Request。
這時你應該會收到像 <a id="xref-r_email_pr" href="#r_email_pr" class="xref">對於新的 Pull Request 的電郵通知。</a> 這樣的郵件。</p>
<figure id="r_email_pr" class="image">
<div class="content">
<img src="images/maint-01-email.png" alt="Pull Request 電郵通知"/>
</div>
<figcaption>圖表 33. 對於新的 Pull Request 的電郵通知。</figcaption>
</figure>
<p>這電郵裡面有些值得注意的東西。
他會給你一個簡易的差異狀態——一個在這 Pull Request 之中被變更的檔案清單，以及變動量。
內附一個 GitHub PR 連結。
同時也會給你一些可以從指令列操作的網址。</p>
<p>你可能會注意到這行指令 <code class="literal">git pull &lt;url&gt; patch-1</code>，這行指令是可以在不用增加遠端的情況下合併一個遠端分支的簡易方式。
我們曾在 <a id="xref--ch05-distributed-git--r_checking_out_remotes" href="ch05-distributed-git.xhtml#r_checking_out_remotes" class="xref">切換到遠端分支</a> 簡短的提過。
你可以去建立並切換至主題分支，然後執行這條指令以合併 Pull Request 中的變更。</p>
<p>其他有趣的網址就是 <code class="literal">.diff</code> 和 <code class="literal">.patch</code>，你或許猜的到，他們分別提供 Pull Request 的統合差異和系列補綴。
你可以以下述方式來做技術性的合併：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl http://github.com/tonychacon/fade/pull/1.patch | git am</code></pre>
</figure>
</section>
<section class="sect3" title="在 Pull Request 裡合作">
<h4 id="_在_pull_request_裡合作">在 Pull Request 裡合作</h4>
<p>就如我們在 <a id="xref-r_github_flow" href="#r_github_flow" class="xref">GitHub 流程</a> 提過的，你現在可以和建立 Pull Request 的人對談了。
你可以針對某幾行原始碼提出評論、對一整個提交做評論或是對一整個 Pull Request 做評論，而且你在其中每個部分都可以使用 GitHub 風格的 Markdown。</p>
<p>每當有人在 Pull Request 裡留下評論時，你都會收到一封電郵通知，這樣你就能掌握整個 Pull Request 的動態。
每次通知都會附有連結連往 Pull Request 有活動的部分，同時你也可以直接回覆郵件以在 Pull Request 討論串中評論。</p>
<figure class="image">
<div class="content">
<img src="images/maint-03-email-resp.png" alt="電郵回覆"/>
</div>
<figcaption>圖表 34. 包含在討論串中的電郵回覆。</figcaption>
</figure>
<p>當你覺得 PR 裡面的原始碼已經可以合併的時候，你可手動拉取，然後在本地端合併；或是用 <code class="literal">git pull &lt;url&gt; &lt;branch&gt;</code> 這個稍早看過的語法；也可以把那個 fork 加入成遠端之一之後再擷取並合併。</p>
<p>如果這只是個簡單的合併，你可以按下 GitHub 網站上的「Merge」按鈕來解決。
這會做一個「非快進」的合併——即便是可以快進，仍會建立合併提交。
這意味著，不論你在何種情況按下「Merge」，都會建立一個合併提交。
如果你點了提示連結，GitHub 就會會提供你所有的資訊，就像你在 <a id="xref-r_merge_button" href="#r_merge_button" class="xref">Merge 按鈕和手動合併 Pull Request 的指引。</a> 看到的一樣。</p>
<figure id="r_merge_button" class="image">
<div class="content">
<img src="images/maint-02-merge.png" alt="Merge 按鈕"/>
</div>
<figcaption>圖表 35. Merge 按鈕和手動合併 Pull Request 的指引。</figcaption>
</figure>
<p>如果你決定不要合併這個 Pull Request，你只需要關閉這個 Pull Request 即可，同時建立這個 Pull Request 的人也會收到通知。</p>
</section>
<section class="sect3" title="Pull Request 參照">
<h4 id="r_pr_refs">Pull Request 參照</h4>
<p>如果你要處理 <strong>非常多</strong> 的 Pull Request 而且不想加入一堆的遠端或是一直做只會用到一次的拉取，關於這點 GitHub 提供了一個好用的小技巧給你用。
這是個有點進階的技巧，所以我們會在 <a id="xref--ch10-git-internals--r_refspec" href="ch10-git-internals.xhtml#r_refspec" class="xref">The Refspec</a> 提到更多的細節，不過還是非常的有用。</p>
<p>事實上 GitHub 會把倉儲的 Pull Request 當成伺服器上的假分支。
預設情況下你不會在拓製的時候取得它們，但他們還是以隱藏的狀態存在著而且你可以用非常簡單的方式取得它們。</p>
<p>To demonstrate this, we&#8217;re going to use a low-level command (often referred to as a “plumbing” command, which we&#8217;ll read about more in <a id="xref--ch10-git-internals--r_plumbing_porcelain" href="ch10-git-internals.xhtml#r_plumbing_porcelain" class="xref">Plumbing and Porcelain</a>) called <code class="literal">ls-remote</code>.
This command is generally not used in day-to-day Git operations but it&#8217;s useful to show us what references are present on the server.
為了展示這個事實，我們要使用一個比較低階的指令（通常會被稱作「底層」指令，關於這點我們會在 <a href="ch10-git-internals.xhtml#r_plumbing_porcelain" class="xref">Plumbing and Porcelain</a> 再做詳細描述）—— <code class="literal">ls-remote</code>。
這指令通常不會在日常的 Git 操作使用，但在展現伺服器上的所有參照是非常有用的。</p>
<p>如果對我們之前的「blink」倉儲使用這條指令，我們會得到在伺服器上這個倉儲裡所有的分支、標籤和其他各種參照的清單。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge</code></pre>
</figure>
<p>當然，如果你在你的倉儲裡使用 <code class="literal">git ls-remote origin</code> 或是對其他任一個想確認的遠端使用，你會得到一個與這類似的結果。</p>
<p>如果你的倉儲是在 GItHub 上，而且有開放中的 Pull Request；你會看到一些以 <code class="literal">refs/pull/</code> 開頭的參照。
它們基本上也是分支，但是因為他們不是以 <code class="literal">refs/heads</code> 起頭，所以你一般來說不會在拓製或擷取時從伺服器下載到他們——擷取的過程會忽略它們。</p>
<p>每個 Pull Request 都會有兩個參照——以 <code class="literal">/head</code> 結尾的是對應到目前 Pull Request 分支的最後一個提交。
所以，如果有人在我們的倉儲開了一個 Pull Request，而且他的分支名稱叫做 <code class="literal">bug-fix</code> 還有它指向 <code class="literal">a5a775</code> 這個提交，在之後我們的倉儲裡並不會出現 <code class="literal">bug-fix</code> 這個分支，但我們會出現指向 <code class="literal">a5a775</code> 的 <code class="literal">pull/&lt;pr#&gt;/head</code>。
這意味著我們可以非常簡單的直接拉取所有 Pull Request 分支，而非加一大堆的遠端來解決。</p>
<p>現在，你可以直接做些事––好比說擷取參考。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -&gt; FETCH_HEAD</code></pre>
</figure>
<p>這告訴了 Git：「連結到名為 <code class="literal">origin</code> 的遠端，並下載名為  <code class="literal">refs/pull/958/head</code> 的參考。」
Git 很樂意的照做了，之後下載了所有建立這個參考的必要資訊，之後就在 <code class="literal">.git/FETCH_HEAD</code> 裡放了一個指向你所需要的提交的指針。
你可以接著在你想要測試的分支裡執行 <code class="literal">git merge FETCH_HEAD</code>，不過這個合併提交的訊息可能會有點奇怪。
不過，如果你需要審閱「一大堆」的 Pull Request，這會顯得相當的枯燥乏味。</p>
<p>也是有辦法可以擷取「全部」的 Pull Request 的，而且可以在你每次連接到遠端時更新。
用你習慣的編輯器打開 <code class="literal">.git/config</code>，並且找到關於遠端 <code class="literal">origin</code> 的部份。
通常會長的像這樣：</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
    url = <span style="font-style: italic">https://github.com/libgit2/libgit2</span>
<span style="font-style: italic">    fetch = +refs/heads/*:refs/remotes/origin/*</span></code></pre>
</figure>
<p>以 <code class="literal">fetch =</code> 開頭的那行是個「參照規格」。
這是個本地端的 <code class="literal">.git</code> 資料夾裏面的名稱對應到遠端的方法。
這一段告訴 Git：「在遠端 <code class="literal">refs/heads</code> 之下的東西，要保存在本地倉儲的 <code class="literal">refs/remotes/origin</code> 之下。」
你可以編輯這個段落以加入其他的參照規格：</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
    url = <span style="font-style: italic">https://github.com/libgit2/libgit2.git</span>
<span style="font-style: italic">    fetch = +refs/heads/*:refs/remotes/origin/*</span>
<span style="font-style: italic">    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</span></code></pre>
</figure>
<p>最後一行告訴 Git：「所有類似 <code class="literal">refs/pull/123/head</code> 的參照都會以 <code class="literal">refs/remotes/origin/pr/123</code> 的型式儲存在本地端。」
所以現在存檔，然後執行 <code class="literal">git fetch</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
<span style="font-weight: bold">#</span> …
 * [new ref]         refs/pull/1/head -&gt; origin/pr/1
 * [new ref]         refs/pull/2/head -&gt; origin/pr/2
 * [new ref]         refs/pull/4/head -&gt; origin/pr/4
<span style="font-weight: bold">#</span> …</code></pre>
</figure>
<p>現在所有遠端的 Pull Request 都會以類似追蹤分支型式的參照出現在本端；他們是唯讀的，並且會在你做擷取的時候更新。
這讓在本地端測試 pull request 裡的程式碼變成超級簡單的事：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch &#39;pr/2&#39;</code></pre>
</figure>
<p>你們其中某些比較眼尖的人可能已經注意到參照規格中遠端部份的尾巴的 <code class="literal">head</code>。
這同時也是 GitHub 端一個名為 <code class="literal">refs/pull/#/merge</code> 的參照，這代表著當你點下網站上的「Merge」鈕時會產生的提交。
這讓你甚至可以在按下按鈕前測試合併結果。</p>
</section>
<section class="sect3" title="對應到 Pull Request 的 Pull Request">
<h4 id="_對應到_pull_request_的_pull_request">對應到 Pull Request 的 Pull Request</h4>
<p>你不只可以對主要分支或是 <code class="literal">master</code> 分支建立 Pull Request，你也可以對這整個網絡裡的任意一個分支做同樣的事。
事實上，你甚至可以對另外一個 Pull Request 做 Pull Request。</p>
<p>如果你發現一個 Pull Request 正在往良好的方向發展，而你也想加點依賴於它的變更、或是你只是不確定這變更否是個好主意、甚至只是因為你沒有對目的分支推送的權限時，你都可以直接對它開 PR。</p>
<p>當你要開啟一個 Pull Request 時，頁面最上方會有個區塊可以讓你選擇要請求擁有者在哪個分支上拉取變更，以及要從哪個分支拉取。
如果你按下右手邊的「Edit」鈕，你不只能指定分支，也可以指定 fork。</p>
<figure id="r_pr_targets" class="image">
<div class="content">
<img src="images/maint-04-target.png" alt="PR 目標"/>
</div>
<figcaption>圖表 36. 手動指定 Pull Request 的目標 fork 和分支</figcaption>
</figure>
<p>在這邊你可以相當簡單的方式決定你要把你的新分支合併到另一個 Pull Request 或是這專案底下的其他 fork。</p>
</section>
</section>
<section class="sect2" title="提及他人和通知">
<h3 id="_提及他人和通知">提及他人和通知</h3>
<p>GitHub 也有非常好的通知系統，讓徵詢特定人或團隊的意見變成一件易如反掌的事。</p>
<p>在任意一個專案裡，當你一輸入 <code class="literal">@</code> 這個字元後，自動完成就會提供給你所有這個計畫的協作者和貢獻者的顯示名稱及使用者名稱。</p>
<figure class="image">
<div class="content">
<img src="images/maint-05-mentions.png" alt="提及他人"/>
</div>
<figcaption>圖表 37. 輸入 @ 來提到其他人</figcaption>
</figure>
<p>你也可以提及某個並沒有出現在這個下拉式清單的使用者，不過自動完成通常會更快把牠抓出來。</p>
<p>當你發佈了一個有提到其他使用者的評論時，那些被標記的人會收到通知。
這意味著這會是一個非常有效率的把人拉入討論的方式，而非讓那些人主動追蹤討論進度。
在 GitHub 上人們很常把同團隊或是同公司的人拉近討論裡，藉以審閱 Pull Request 或是議題。</p>
<p>如果有人被標記，會被自動訂閱提到他們的 Pull Request 或是議題，之後就會收到所有相關的動態。
你也會自動訂閱所有你建立的東西、你觀注的版本庫或是你曾經發表過評論的東西。
如果你不想繼續收到通知，你可以按下頁面裡的「Unsubscribe」鈕來停止收到後續的更新。</p>
<figure class="image">
<div class="content">
<img src="images/maint-06-unsubscribe.png" alt="取消訂閱"/>
</div>
<figcaption>圖表 38. 取消訂閱 PullRequest 或是議題。</figcaption>
</figure>
<section class="sect3" title="通知總覽頁面">
<h4 id="_通知總覽頁面">通知總覽頁面</h4>
<p>當我們在這邊提到關於 GitHub 的「通知」時，這是指 GitHub 試著讓你跟上新發生的事件的方式，而且你也有許多方式可以自訂。
如果進到設定頁面的「Notification Center」分頁，你會看到一些可以使用的選項。</p>
<figure class="image">
<div class="content">
<img src="images/maint-07-notifications.png" alt="通知中心"/>
</div>
<figcaption>圖表 39. 通知中心選項。</figcaption>
</figure>
<p>在這邊你有兩種取得通知的方式可以選擇––「電子郵件」和「網頁」，你可以決定當你在在參與事情或是接收你關注的版本庫的動態時，你要如何透過這兩個管道接受通知。</p>
<section class="sect4" title="網頁通知">
<h5 id="_網頁通知">網頁通知</h5>
<p>網頁通知僅存在於 GitHub 上，而你也只能在 GitHub 上檢視。
如果你有選用這個選項，當你在收到通知的時候，你會在頁面上方的通知圖示上看到一個藍點，就如 <a id="xref-r_not_center" href="#r_not_center" class="xref">通知中心</a> 所示。</p>
<figure id="r_not_center" class="image">
<div class="content">
<img src="images/maint-08-notifications-page.png" alt="通知中心"/>
</div>
<figcaption>圖表 40. 通知中心</figcaption>
</figure>
<p>如果你點一下那個圖示，你會看到以專案分類的通知清單。
你也可以點擊-左側列表裡的專案名稱來過濾出關於個專案的通知。
你也以按下任一項通知右側的勾選圖示來確認接收，或是點下專案名稱旁的勾選圖示來接收所有關於這個專案的通知。
勾選圖示旁邊也有個靜音按鈕，當你點下那個圖示，代表你將不會收到那項東西的後續通知。</p>
<p>這些工具對於管理大量的通知來說是非常的方便。
許多的 GitHub 的進階使用者會直接關掉所有的電郵通知，然後在這頁面上管理所有的通知。</p>
</section>
<section class="sect4" title="電郵通知">
<h5 id="_電郵通知">電郵通知</h5>
<p>電郵通知是 GitHub 上另一個接受通知的方式。
如果你開啟這個選項，之後每當你收到通知，你就會收到一封電郵。
我們可以在 <a id="xref-r_email_notification" href="#r_email_notification" class="xref">以電子郵件型式寄送的評論</a> 和 <a href="#r_email_pr" class="xref">對於新的 Pull Request 的電郵通知。</a> 有範例。
這廂電子郵件會自動討論串化，如果你在使用討論串式的電郵客戶端，這會是個好事情。</p>
<p>GitHub 會再寄給你的通知郵件的標頭里嵌入相當多的後設資訊，這樣你在建立自訂過濾條件時可以更得心應手。</p>
<p>舉例來說，如果展開在 <a href="#r_email_pr" class="xref">對於新的 Pull Request 的電郵通知。</a> 寄給 Tony 的郵件的真實標頭，我們會看到這樣被寄出的訊息。</p>
<figure class="listing">
<pre class="source language-mbox"><code><span></span>To: tonychacon/fade &lt;fade@noreply.github.com&gt;
Message-ID: &lt;tonychacon/fade/pull/1@github.com&gt;
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade &lt;fade.tonychacon.github.com&gt;
List-Archive: https://github.com/tonychacon/fade
List-Post: &lt;mailto:reply+i-4XXX@reply.github.com&gt;
List-Unsubscribe: &lt;mailto:unsub+i-XXX@reply.github.com&gt;,...
X-GitHub-Recipient-Address: tchacon@example.com</code></pre>
</figure>
<p>這裡面有不少有趣的東西。
如果你想針對特定專案甚至是 Pull Request 的電郵做特別標示或是轉寄時，「Message-ID」這項以 <code class="literal">&lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt;</code> 的格式提供了所有資訊。
如果這是個議題，`&lt;type&gt;`這部分就會是「issue」而非「pull」。</p>
<p>而而你如果有個能夠解析 <code class="literal">List-Post</code> 和 <code class="literal">List-Unsubsribe</code> 這兩個欄位的電郵客戶端的話，你就能直接發表意見到清單裡，
或是直接「取消訂閱」這個串，就像你直接在那 Pull Request 或是議題頁面上做的一樣。</p>
<p>值得一提的是，如果你同時啟用網頁和電郵通知，當你使用允許內嵌圖片的郵件客戶端開啟通知郵件時，網頁上的通知也會被標示為已讀。</p>
</section>
</section>
</section>
<section class="sect2" title="特殊檔案">
<h3 id="_特殊檔案">特殊檔案</h3>
<p>當有些特殊檔案出現在你的版本庫時，GitHub 會注意到它們。</p>
</section>
<section class="sect2" title="README">
<h3 id="_readme">README</h3>
<p>第一個就是 <code class="literal">README</code> 檔，它可以用任意一種可以被 GitHub 便是成文章的格式寫成。
舉例來說，它可以是 <code class="literal">README</code>、<code class="literal">README.md</code>、<code class="literal">README.asciidoc</code>、等等。
如果 GitHub 在你的原始碼裡發現 README 這個檔案時，他會被渲染再在專案首頁。</p>
<p>許多團隊用這檔案來整理所有這專案的相關資訊，來讓第一次接觸這個專案或版本庫的人了解這個專案。
通常會包含這些東西：</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">這個專案的目的</span>
</li>
<li>
<span class="principal">如何設定及安裝</span>
</li>
<li>
<span class="principal">舉個使用或執行的例子</span>
</li>
<li>
<span class="principal">這個專案是基於哪種授權發布的</span>
</li>
<li>
<span class="principal">如何對這專案做貢獻</span>
</li>
</ul>
</div>
<p>因為 GitHub 會渲染這個檔案，所以你可以嵌入圖片或連結來讓他更容易理解。</p>
</section>
<section class="sect2" title="CONTRIBUTING">
<h3 id="_contributing">CONTRIBUTING</h3>
<p>另個 GitHub 會辨識的特殊檔案就是 <code class="literal">CONTRIBUTING</code>。
如果你有個帶著任意種附檔名的 <code class="literal">CONTRIBUTING</code>，GitHub 會把它顯示成 <a id="xref-r_contrib_file" href="#r_contrib_file" class="xref">在有 CONTRIBUTING 這個檔案時建立 Pull Request</a> 給那些想建立 Pull Request 的使用者看。</p>
<figure id="r_contrib_file" class="image">
<div class="content">
<img src="images/maint-09-contrib.png" alt="貢獻須知"/>
</div>
<figcaption>圖表 41. 在有 CONTRIBUTING 這個檔案時建立 Pull Request</figcaption>
</figure>
<p>這檔案就是你可以指定發給你這專案的 Pull Request 裡面可以包含哪些以及不能包含哪些東西。
這樣大家或許就會在建立 Pull Request 前看看這些原則了。</p>
</section>
<section class="sect2" title="專案管理">
<h3 id="_專案管理">專案管理</h3>
<p>你在一個專案上通常沒有什麼管理性的事能做，不過這邊有幾個你或許有興趣的專案。</p>
<section class="sect3" title="變更主分支">
<h4 id="_變更主分支">變更主分支</h4>
<p>如果你希望使用其他不是「master」的分支來作為其他人建立 Pull Request 的預設目標分支，你可以在版本庫的設定頁面的「Options」分頁裡設定。</p>
<figure id="r_default_branch" class="image">
<div class="content">
<img src="images/maint-10-default-branch.png" alt="預設分支"/>
</div>
<figcaption>圖表 42. 變更一個專案的預設分支</figcaption>
</figure>
<p>只要在下拉式清單裡選擇你要的分支，就可以簡單的變更所有主要動作的預設分支，包含其他人在拓製版本庫時預設簽出的分支。</p>
</section>
<section class="sect3" title="版本庫移轉">
<h4 id="_版本庫移轉">版本庫移轉</h4>
<p>如果你想要把一個專案轉移給其他在 GitHub 上的使用者或是組織時，你可以在倉儲設定裡同樣在「Options」分頁的底部找到 「Transfer ownership」來達成這件事。</p>
<figure id="r_transfer_project" class="image">
<div class="content">
<img src="images/maint-11-transfer.png" alt="轉移"/>
</div>
<figcaption>圖表 43. 把一個專案轉移給其他的 GitHub 使用者或是組織</figcaption>
</figure>
<p>這當你要放棄一個專案而有人要接手時很有幫助，或是在你的專案日漸茁壯，你想要把它移到一個組織裡時也有用。</p>
<p>這個動作不只會把所有關注和標記星號的使用者搬到其他地方，同時也會在舊頁面建立連向新頁面的重導向連結。
這也會重導向所有來自 Git 的擷取和拓製動作，不只是網頁請求而已。</p>
</section>
</section>
</section>
<section class="sect1" title="Managing an organization">
<h2 id="r_github_orgs">Managing an organization</h2>
<p>
In addition to single-user accounts, GitHub has what are called Organizations.
Like personal accounts, Organizational accounts have a namespace where all their projects exist, but many other things are different.
These accounts represent a group of people with shared ownership of projects, and there are many tools to manage subgroups of those people.
Normally these accounts are used for Open Source groups (such as “perl” or “rails”) or companies (such as “google” or “twitter”).</p>
<section class="sect2" title="Organization Basics">
<h3 id="_organization_basics">Organization Basics</h3>
<p>An organization is pretty easy to create; just click on the “+” icon at the top-right of any GitHub page, and select “New organization” from the menu.</p>
<figure class="image">
<div class="content">
<img src="images/neworg.png" alt="The ``New organization'' menu item."/>
</div>
<figcaption>圖表 44. The “New organization” menu item.</figcaption>
</figure>
<p>First you&#8217;ll need to name your organization and provide an email address for a main point of contact for the group.
Then you can invite other users to be co-owners of the account if you want to.</p>
<p>Follow these steps and you&#8217;ll soon be the owner of a brand-new organization.
Like personal accounts, organizations are free if everything you plan to store there will be open source.</p>
<p>As an owner in an organization, when you fork a repository, you&#8217;ll have the choice of forking it to your organization&#8217;s namespace.
When you create new repositories you can create them either under your personal account or under any of the organizations that you are an owner in.
You also automatically “watch” any new repository created under these organizations.</p>
<p>Just like in <a id="xref-r_personal_avatar" href="#r_personal_avatar" class="xref">你的頭像</a>, you can upload an avatar for your organization to personalize it a bit.
Also just like personal accounts, you have a landing page for the organization that lists all of your repositories and can be viewed by other people.</p>
<p>Now let&#8217;s cover some of the things that are a bit different with an organizational account.</p>
</section>
<section class="sect2" title="Teams">
<h3 id="_teams">Teams</h3>
<p>Organizations are associated with individual people by way of teams, which are simply a grouping of individual user accounts and repositories within the organization and what kind of access those people have in those repositories.</p>
<p>For example, say your company has three repositories: <code class="literal">frontend</code>, <code class="literal">backend</code>, and <code class="literal">deployscripts</code>.
You&#8217;d want your HTML/CSS/JavaScript developers to have access to <code class="literal">frontend</code> and maybe <code class="literal">backend</code>, and your Operations people to have access to <code class="literal">backend</code> and <code class="literal">deployscripts</code>.
Teams make this easy, without having to manage the collaborators for every individual repository.</p>
<p>The Organization page shows you a simple dashboard of all the repositories, users and teams that are under this organization.</p>
<figure id="r_org_page" class="image">
<div class="content">
<img src="images/orgs-01-page.png" alt="orgs 01 page"/>
</div>
<figcaption>圖表 45. The Organization page.</figcaption>
</figure>
<p>To manage your Teams, you can click on the Teams sidebar on the right hand side of the page in <a id="xref-r_org_page" href="#r_org_page" class="xref">The Organization page.</a>.
This will bring you to a page you can use to add members to the team, add repositories to the team or manage the settings and access control levels for the team.
Each team can have read only, read/write or administrative access to the repositories.
You can change that level by clicking the “Settings” button in <a id="xref-r_team_page" href="#r_team_page" class="xref">The Team page.</a>.</p>
<figure id="r_team_page" class="image">
<div class="content">
<img src="images/orgs-02-teams.png" alt="orgs 02 teams"/>
</div>
<figcaption>圖表 46. The Team page.</figcaption>
</figure>
<p>When you invite someone to a team, they will get an email letting them know they&#8217;ve been invited.</p>
<p>Additionally, team <code class="literal">@mentions</code> (such as <code class="literal">@acmecorp/frontend</code>) work much the same as they do with individual users, except that <strong>all</strong> members of the team are then subscribed to the thread.
This is useful if you want the attention from someone on a team, but you don&#8217;t know exactly who to ask.</p>
<p>A user can belong to any number of teams, so don&#8217;t limit yourself to only access-control teams.
Special-interest teams like <code class="literal">ux</code>, <code class="literal">css</code>, or <code class="literal">refactoring</code> are useful for certain kinds of questions, and others like <code class="literal">legal</code> and <code class="literal">colorblind</code> for an entirely different kind.</p>
</section>
<section class="sect2" title="Audit Log">
<h3 id="_audit_log">Audit Log</h3>
<p>Organizations also give owners access to all the information about what went on under the organization.
You can go to the <em>Audit Log</em> tab and see what events have happened at an organization level, who did them and where in the world they were done.</p>
<figure id="r_audit_log" class="image">
<div class="content">
<img src="images/orgs-03-audit.png" alt="orgs 03 audit"/>
</div>
<figcaption>圖表 47. The Audit log.</figcaption>
</figure>
<p>You can also filter down to specific types of events, specific places or specific people.</p>
</section>
</section>
<section class="sect1" title="Scripting GitHub">
<h2 id="_scripting_github">Scripting GitHub</h2>
<p>So now we&#8217;ve covered all of the major features and workflows of GitHub, but any large group or project will have customizations they may want to make or external services they may want to integrate.</p>
<p>Luckily for us, GitHub is really quite hackable in many ways.
In this section we&#8217;ll cover how to use the GitHub hooks system and its API to make GitHub work how we want it to.</p>
<section class="sect2" title="Hooks">
<h3 id="_hooks">Hooks</h3>
<p>The Hooks and Services section of GitHub repository administration is the easiest way to have GitHub interact with external systems.</p>
<section class="sect3" title="Services">
<h4 id="_services">Services</h4>
<p>First we&#8217;ll take a look at Services.
Both the Hooks and Services integrations can be found in the Settings section of your repository, where we previously looked at adding Collaborators and changing the default branch of your project.
Under the “Webhooks and Services” tab you will see something like <a id="xref-r_services_hooks" href="#r_services_hooks" class="xref">Services and Hooks configuration section.</a>.</p>
<figure id="r_services_hooks" class="image">
<div class="content">
<img src="images/scripting-01-services.png" alt="Services and hooks"/>
</div>
<figcaption>圖表 48. Services and Hooks configuration section.</figcaption>
</figure>
<p>There are dozens of services you can choose from, most of them integrations into other commercial and open source systems.
Most of them are for Continuous Integration services, bug and issue trackers, chat room systems and documentation systems.
We&#8217;ll walk through setting up a very simple one, the Email hook.
If you choose “email” from the “Add Service” dropdown, you&#8217;ll get a configuration screen like <a id="xref-r_service_config" href="#r_service_config" class="xref">Email service configuration.</a>.</p>
<figure id="r_service_config" class="image">
<div class="content">
<img src="images/scripting-02-email-service.png" alt="Email service"/>
</div>
<figcaption>圖表 49. Email service configuration.</figcaption>
</figure>
<p>In this case, if we hit the “Add service” button, the email address we specified will get an email every time someone pushes to the repository.
Services can listen for lots of different types of events, but most only listen for push events and then do something with that data.</p>
<p>If there is a system you are using that you would like to integrate with GitHub, you should check here to see if there is an existing service integration available.
For example, if you&#8217;re using Jenkins to run tests on your codebase, you can enable the Jenkins builtin service integration to kick off a test run every time someone pushes to your repository.</p>
</section>
<section class="sect3" title="Hooks">
<h4 id="_hooks_2">Hooks</h4>
<p>If you need something more specific or you want to integrate with a service or site that is not included in this list, you can instead use the more generic hooks system.
GitHub repository hooks are pretty simple.
You specify a URL and GitHub will post an HTTP payload to that URL on any event you want.</p>
<p>Generally the way this works is you can setup a small web service to listen for a GitHub hook payload and then do something with the data when it is received.</p>
<p>To enable a hook, you click the “Add webhook” button in <a href="#r_services_hooks" class="xref">Services and Hooks configuration section.</a>.
This will bring you to a page that looks like <a id="xref-r_web_hook" href="#r_web_hook" class="xref">Web hook configuration.</a>.</p>
<figure id="r_web_hook" class="image">
<div class="content">
<img src="images/scripting-03-webhook.png" alt="Web hook"/>
</div>
<figcaption>圖表 50. Web hook configuration.</figcaption>
</figure>
<p>The configuration for a web hook is pretty simple.
In most cases you simply enter a URL and a secret key and hit “Add webhook”.
There are a few options for which events you want GitHub to send you a payload for&#8201;&#8212;&#8201;the default is to only get a payload for the <code class="literal">push</code> event, when someone pushes new code to any branch of your repository.</p>
<p>Let&#8217;s see a small example of a web service you may set up to handle a web hook.
We&#8217;ll use the Ruby web framework Sinatra since it&#8217;s fairly concise and you should be able to easily see what we&#8217;re doing.</p>
<p>Let&#8217;s say we want to get an email if a specific person pushes to a specific branch of our project modifying a specific file.
We could fairly easily do that with code like this:</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>require <span style="font-style: italic">&#39;sinatra&#39;</span>
require <span style="font-style: italic">&#39;json&#39;</span>
require <span style="font-style: italic">&#39;mail&#39;</span>

post <span style="font-style: italic">&#39;/payload&#39;</span> <span style="font-weight: bold">do</span>
  push = JSON.parse(request.body.read) <span style="font-style: italic"># parse the JSON</span>

  <span style="font-style: italic"># gather the data we&#39;re looking for</span>
  pusher = push[<span style="font-style: italic">&quot;pusher&quot;</span>][<span style="font-style: italic">&quot;name&quot;</span>]
  branch = push[<span style="font-style: italic">&quot;ref&quot;</span>]

  <span style="font-style: italic"># get a list of all the files touched</span>
  files = push[<span style="font-style: italic">&quot;commits&quot;</span>].map <span style="font-weight: bold">do</span> |commit|
    commit[<span style="font-style: italic">&#39;added&#39;</span>] + commit[<span style="font-style: italic">&#39;modified&#39;</span>] + commit[<span style="font-style: italic">&#39;removed&#39;</span>]
  <span style="font-weight: bold">end</span>
  files = files.flatten.uniq

  <span style="font-style: italic"># check for our criteria</span>
  <span style="font-weight: bold">if</span> pusher == <span style="font-style: italic">&#39;schacon&#39;</span> &amp;&amp;
     branch == <span style="font-style: italic">&#39;ref/heads/special-branch&#39;</span> &amp;&amp;
     files.include?(<span style="font-style: italic">&#39;special-file.txt&#39;</span>)

    Mail.deliver <span style="font-weight: bold">do</span>
      from     <span style="font-style: italic">&#39;tchacon@example.com&#39;</span>
      to       <span style="font-style: italic">&#39;tchacon@example.com&#39;</span>
      subject  <span style="font-style: italic">&#39;Scott Changed the File&#39;</span>
      body     <span style="font-style: italic">&quot;ALARM&quot;</span>
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Here we&#8217;re taking the JSON payload that GitHub delivers us and looking up who pushed it, what branch they pushed to and what files were touched in all the commits that were pushed.
Then we check that against our criteria and send an email if it matches.</p>
<p>In order to develop and test something like this, you have a nice developer console in the same screen where you set the hook up.
You can see the last few deliveries that GitHub has tried to make for that webhook.
For each hook you can dig down into when it was delivered, if it was successful and the body and headers for both the request and the response.
This makes it incredibly easy to test and debug your hooks.</p>
<figure id="r_web_hook_debug" class="image">
<div class="content">
<img src="images/scripting-04-webhook-debug.png" alt="Webhook debug"/>
</div>
<figcaption>圖表 51. Web hook debugging information.</figcaption>
</figure>
<p>The other great feature of this is that you can redeliver any of the payloads to test your service easily.</p>
<p>For more information on how to write webhooks and all the different event types you can listen for, go to the GitHub Developer documentation at <a href="https://developer.github.com/webhooks/" class="link">https://developer.github.com/webhooks/</a></p>
</section>
</section>
<section class="sect2" title="The GitHub API">
<h3 id="_the_github_api">The GitHub API</h3>
<p>
Services and hooks give you a way to receive push notifications about events that happen on your repositories, but what if you need more information about these events? What if you need to automate something like adding collaborators or labeling issues?</p>
<p>This is where the GitHub API comes in handy.
GitHub has tons of API endpoints for doing nearly anything you can do on the website in an automated fashion.
In this section we&#8217;ll learn how to authenticate and connect to the API, how to comment on an issue and how to change the status of a Pull Request through the API.</p>
</section>
<section class="sect2" title="Basic Usage">
<h3 id="_basic_usage">Basic Usage</h3>
<p>The most basic thing you can do is a simple GET request on an endpoint that doesn&#8217;t require authentication.
This could be a user or read-only information on an open source project.
For example, if we want to know more about a user named “schacon”, we can run something like this:</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl https:<span style="font-style: italic">//api.github.com/users/schacon</span>
{
  <span style="font-style: italic">&quot;login&quot;</span>: <span style="font-style: italic">&quot;schacon&quot;</span>,
  <span style="font-style: italic">&quot;id&quot;</span>: 70,
  <span style="font-style: italic">&quot;avatar_url&quot;</span>: <span style="font-style: italic">&quot;https://avatars.githubusercontent.com/u/70&quot;</span>,
<span style="border: 1px solid #FF0000">#</span> <span style="border: 1px solid #FF0000">…</span>
  <span style="font-style: italic">&quot;name&quot;</span>: <span style="font-style: italic">&quot;Scott Chacon&quot;</span>,
  <span style="font-style: italic">&quot;company&quot;</span>: <span style="font-style: italic">&quot;GitHub&quot;</span>,
  <span style="font-style: italic">&quot;following&quot;</span>: 19,
  <span style="font-style: italic">&quot;created_at&quot;</span>: <span style="font-style: italic">&quot;2008-01-27T17:19:28Z&quot;</span>,
  <span style="font-style: italic">&quot;updated_at&quot;</span>: <span style="font-style: italic">&quot;2014-06-10T02:37:23Z&quot;</span>
}</code></pre>
</figure>
<p>There are tons of endpoints like this to get information about organizations, projects, issues, commits&#8201;&#8212;&#8201;just about anything you can publicly see on GitHub.
You can even use the API to render arbitrary Markdown or find a <code class="literal">.gitignore</code> template.</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl https:<span style="font-style: italic">//api.github.com/gitignore/templates/Java</span>
{
  <span style="font-style: italic">&quot;name&quot;</span>: <span style="font-style: italic">&quot;Java&quot;</span>,
  <span style="font-style: italic">&quot;source&quot;</span>: <span style="font-style: italic">&quot;*.class</span>

<span style="font-style: italic"># Mobile Tools for Java (J2ME)</span>
<span style="font-style: italic">.mtj.tmp/</span>

<span style="font-style: italic"># Package Files #</span>
<span style="font-style: italic">*.jar</span>
<span style="font-style: italic">*.war</span>
<span style="font-style: italic">*.ear</span>

<span style="font-style: italic"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span>
<span style="font-style: italic">hs_err_pid*</span>
<span style="font-style: italic">&quot;</span>
}</code></pre>
</figure>
</section>
<section class="sect2" title="Commenting on an Issue">
<h3 id="_commenting_on_an_issue">Commenting on an Issue</h3>
<p>However, if you want to do an action on the website such as comment on an Issue or Pull Request or if you want to view or interact with private content, you&#8217;ll need to authenticate.</p>
<p>There are several ways to authenticate.
You can use basic authentication with just your username and password, but generally it&#8217;s a better idea to use a personal access token.
You can generate this from the “Applications” tab of your settings page.</p>
<figure id="r_access_token" class="image">
<div class="content">
<img src="images/scripting-05-access-token.png" alt="Access Token"/>
</div>
<figcaption>圖表 52. Generate your access token from the “Applications” tab of your settings page.</figcaption>
</figure>
<p>It will ask you which scopes you want for this token and a description.
Make sure to use a good description so you feel comfortable removing the token when your script or application is no longer used.</p>
<p>GitHub will only show you the token once, so be sure to copy it.
You can now use this to authenticate in your script instead of using a username and password.
This is nice because you can limit the scope of what you want to do and the token is revocable.</p>
<p>This also has the added advantage of increasing your rate limit.
Without authenticating, you will be limited to 60 requests per hour.
If you authenticate you can make up to 5,000 requests per hour.</p>
<p>So let&#8217;s use it to make a comment on one of our issues.
Let&#8217;s say we want to leave a comment on a specific issue, Issue #6.
To do so we have to do an HTTP POST request to <code class="literal">repos/&lt;user&gt;/&lt;repo&gt;/issues/&lt;num&gt;/comments</code> with the token we just generated as an Authorization header.</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl -H <span style="font-style: italic">&quot;Content-Type: application/json&quot;</span> \
       -H <span style="font-style: italic">&quot;Authorization: token TOKEN&quot;</span> \
       --data <span style="font-style: italic">&#39;{&quot;body&quot;:&quot;A new comment, :+1:&quot;}&#39;</span> \
       https:<span style="font-style: italic">//api.github.com/repos/schacon/blink/issues/6/comments</span>
{
  <span style="font-style: italic">&quot;id&quot;</span>: 58322100,
  <span style="font-style: italic">&quot;html_url&quot;</span>: <span style="font-style: italic">&quot;https://github.com/schacon/blink/issues/6#issuecomment-58322100&quot;</span>,
  ...
  <span style="font-style: italic">&quot;user&quot;</span>: {
    <span style="font-style: italic">&quot;login&quot;</span>: <span style="font-style: italic">&quot;tonychacon&quot;</span>,
    <span style="font-style: italic">&quot;id&quot;</span>: 7874698,
    <span style="font-style: italic">&quot;avatar_url&quot;</span>: <span style="font-style: italic">&quot;https://avatars.githubusercontent.com/u/7874698?v=2&quot;</span>,
    <span style="font-style: italic">&quot;type&quot;</span>: <span style="font-style: italic">&quot;User&quot;</span>,
  },
  <span style="font-style: italic">&quot;created_at&quot;</span>: <span style="font-style: italic">&quot;2014-10-08T07:48:19Z&quot;</span>,
  <span style="font-style: italic">&quot;updated_at&quot;</span>: <span style="font-style: italic">&quot;2014-10-08T07:48:19Z&quot;</span>,
  <span style="font-style: italic">&quot;body&quot;</span>: <span style="font-style: italic">&quot;A new comment, :+1:&quot;</span>
}</code></pre>
</figure>
<p>Now if you go to that issue, you can see the comment that we just successfully posted as in <a id="xref-r_api_comment" href="#r_api_comment" class="xref">A comment posted from the GitHub API.</a>.</p>
<figure id="r_api_comment" class="image">
<div class="content">
<img src="images/scripting-06-comment.png" alt="API Comment"/>
</div>
<figcaption>圖表 53. A comment posted from the GitHub API.</figcaption>
</figure>
<p>You can use the API to do just about anything you can do on the website&#8201;&#8212;&#8201;creating and setting milestones, assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data, creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams, commenting on lines of code in a Pull Request, searching the site and on and on.</p>
</section>
<section class="sect2" title="Changing the Status of a Pull Request">
<h3 id="_changing_the_status_of_a_pull_request">Changing the Status of a Pull Request</h3>
<p>There is one final example we&#8217;ll look at since it&#8217;s really useful if you&#8217;re working with Pull Requests.
Each commit can have one or more statuses associated with it and there is an API to add and query that status.</p>
<p>Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests.
You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed&#8201;&#8212;&#8201;any number of things.</p>
<p>Let&#8217;s say you set up a webhook on your repository that hits a small web service that checks for a <code class="literal">Signed-off-by</code> string in the commit message.</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>require <span style="font-style: italic">&#39;httparty&#39;</span>
require <span style="font-style: italic">&#39;sinatra&#39;</span>
require <span style="font-style: italic">&#39;json&#39;</span>

post <span style="font-style: italic">&#39;/payload&#39;</span> <span style="font-weight: bold">do</span>
  push = JSON.parse(request.body.read) <span style="font-style: italic"># parse the JSON</span>
  repo_name = push[<span style="font-style: italic">&#39;repository&#39;</span>][<span style="font-style: italic">&#39;full_name&#39;</span>]

  <span style="font-style: italic"># look through each commit message</span>
  push[<span style="font-style: italic">&quot;commits&quot;</span>].each <span style="font-weight: bold">do</span> |commit|

    <span style="font-style: italic"># look for a Signed-off-by string</span>
    <span style="font-weight: bold">if</span> <span style="font-style: italic">/Signed-off-by/</span>.match commit[<span style="font-style: italic">&#39;message&#39;</span>]
      state = <span style="font-style: italic">&#39;success&#39;</span>
      description = <span style="font-style: italic">&#39;Successfully signed off!&#39;</span>
    <span style="font-weight: bold">else</span>
      state = <span style="font-style: italic">&#39;failure&#39;</span>
      description = <span style="font-style: italic">&#39;No signoff found.&#39;</span>
    <span style="font-weight: bold">end</span>

    <span style="font-style: italic"># post status to GitHub</span>
    sha = commit[<span style="font-style: italic">&quot;id&quot;</span>]
    status_url = <span style="font-style: italic">&quot;https://api.github.com/repos/</span><span style="font-weight: bold; font-style: italic">#{</span>repo_name<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">/statuses/</span><span style="font-weight: bold; font-style: italic">#{</span>sha<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>

    status = {
      <span style="font-style: italic">&quot;state&quot;</span>       =&gt; state,
      <span style="font-style: italic">&quot;description&quot;</span> =&gt; description,
      <span style="font-style: italic">&quot;target_url&quot;</span>  =&gt; <span style="font-style: italic">&quot;http://example.com/how-to-signoff&quot;</span>,
      <span style="font-style: italic">&quot;context&quot;</span>     =&gt; <span style="font-style: italic">&quot;validate/signoff&quot;</span>
    }
    HTTParty.post(status_url,
      <span style="font-style: italic">:body</span> =&gt; status.to_json,
      <span style="font-style: italic">:headers</span> =&gt; {
        <span style="font-style: italic">&#39;Content-Type&#39;</span>  =&gt; <span style="font-style: italic">&#39;application/json&#39;</span>,
        <span style="font-style: italic">&#39;User-Agent&#39;</span>    =&gt; <span style="font-style: italic">&#39;tonychacon/signoff&#39;</span>,
        <span style="font-style: italic">&#39;Authorization&#39;</span> =&gt; <span style="font-style: italic">&quot;token </span><span style="font-weight: bold; font-style: italic">#{</span>ENV[<span style="font-style: italic">&#39;TOKEN&#39;</span>]<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span> }
    )
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>Hopefully this is fairly simple to follow.
In this web hook handler we look through each commit that was just pushed, we look for the string <em>Signed-off-by</em> in the commit message and finally we POST via HTTP to the <code class="literal">/repos/&lt;user&gt;/&lt;repo&gt;/statuses/&lt;commit_sha&gt;</code> API endpoint with the status.</p>
<p>In this case you can send a state (<em>success</em>, <em>failure</em>, <em>error</em>), a description of what happened, a target URL the user can go to for more information and a “context” in case there are multiple statuses for a single commit.
For example, a testing service may provide a status and a validation service like this may also provide a status&#8201;&#8212;&#8201;the “context” field is how they&#8217;re differentiated.</p>
<p>If someone opens a new Pull Request on GitHub and this hook is set up, you may see something like <a id="xref-r_commit_status" href="#r_commit_status" class="xref">Commit status via the API.</a>.</p>
<figure id="r_commit_status" class="image">
<div class="content">
<img src="images/scripting-07-status.png" alt="Commit status"/>
</div>
<figcaption>圖表 54. Commit status via the API.</figcaption>
</figure>
<p>You can now see a little green check mark next to the commit that has a “Signed-off-by” string in the message and a red cross through the one where the author forgot to sign off.
You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure.
This is really useful if you&#8217;re using this API for test results so you don&#8217;t accidentally merge something where the last commit is failing tests.</p>
</section>
<section class="sect2" title="Octokit">
<h3 id="_octokit">Octokit</h3>
<p>Though we&#8217;ve been doing nearly everything through <code class="literal">curl</code> and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out <a href="http://github.com/octokit" class="link">http://github.com/octokit</a> for more information on these, as they handle much of the HTTP for you.</p>
<p>Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out <a href="https://developer.github.com" class="link">https://developer.github.com</a>.</p>
</section>
</section>
<section class="sect1" title="總結">
<h2 id="_總結">總結</h2>
<p class="last">現在你是個 GitHub 使用者了。
你現在知道如何建立帳號、管理組織、建立及推送變更到倉儲、參與別人的專案或是接受別人對你專案的變更。
在下個章節，你會學到更加強力的工具及技巧來應對複雜的處境，這會讓你變成真的 Git 專家。</p>
</section>
</section>
</body>
</html>