<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>GitHub</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="GitHub" epub:type="chapter" id="ch06-github">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>GitHub</b></small></h1>
</div>
</header>
<p></p>
<p>GitHub は世界最大の Git リポジトリホスティングサービスで、何百万もの開発者やプロジェクトが集う、共同作業の場になっています。
世の中の Git リポジトリの多くが GitHub に置かれており、多くのオープンソースプロジェクトが、
Git リポジトリ以外にも、課題追跡やコードレビューなどに GitHub を利用しています。
Git そのものとは直接関係ありませんが、Git を使っていれば、遅かれ早かれ GitHub を利用したくなる（あるいはそうせざるを得なくなる）でしょう。</p>
<p>本章では、GitHub を有効活用する方法を説明します。
アカウントの取得や管理、Git リポジトリの作成と利用、
プロジェクトに貢献したり自分のプロジェクトへの貢献を受け入れたりするときの一般的なワークフロー、
GitHubをプログラマティックに利用するためのインターフェイスなどのほかにも、
GitHubをうまく使っていくためのさまざまなヒントを紹介します。</p>
<p>GitHub に自分のプロジェクトを置いたり、GitHub にある他のプロジェクトで共同作業をしたりといったことに興味がないかたは、
本章を読み飛ばして <a id="xref--ch07-git-tools" href="ch07-git-tools.xhtml" class="xref">Git のさまざまなツール</a> に進んでもかまいません。</p>
<aside class="admonition warning" title="Warning: インターフェイスは変わるもの" epub:type="warning">
<h2>インターフェイスは変わるもの</h2>
<div class="content">
<p>GitHub に限ったことではありませんが、本章のスクリーンショットで示している UI は、将来的に変わる可能性があります。
本章で紹介しようとしている考えかたはそれでも伝わるでしょうが、
最新版のスクリーンショットを見たい場合は、オンライン版を見たほうがいいでしょう。</p>
</div>
</aside>
<section class="sect1" title="アカウントの準備と設定">
<h2 id="_アカウントの準備と設定">アカウントの準備と設定</h2>
<p></p>
<p>まずやるべきことは、ユーザーアカウントの作成です。無料で作れます。
<a href="https://github.com" class="link">https://github.com</a> を開いて、他の人が使っていないユーザー名を選び、メールアドレスとパスワードを入力したら、あとは “Sign up for GitHub” という大きな緑色のボタンを押すだけです。</p>
<figure class="image">
<div class="content">
<img src="images/signup.png" alt="GitHub のサインアップフォーム"/>
</div>
<figcaption>Figure 1. GitHub のサインアップフォーム</figcaption>
</figure>
<p>その次に出てくるのは、有償プランへのアップグレードについての説明です。
とりあえずは無視してもかまいません。
先ほど入力したメールアドレスが正しいことを確認するために、GitHubからのメールが届きます。
メールの指示に従ってください。後で見るとおり、これはとても重要です。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>無償版のアカウントで、GitHubのすべての機能が使えます。
ただし、すべてのプロジェクトを公開しなければいけない（誰でも読めるようにしなければいけない）という制約があります。
GitHubの有償プランは、プライベートなプロジェクトを所定の数だけ作れるようになっています。
しかし本書では、この機能については扱いません。</p>
</div>
</aside>
<p>画面左上にある Octocat のロゴをクリックすると、ダッシュボードのページが開きます。
これで、GitHub を使う準備が整いました。</p>
<section class="sect2" title="SSH でのアクセス">
<h3 id="_ssh_でのアクセス">SSH でのアクセス</h3>
<p></p>
<p>この時点ですでに、<code class="literal">https://</code> プロトコルを使った Git リポジトリへの接続ができるようになっています。
接続する際には、先ほど指定したユーザー名とパスワードを利用します。
しかし、単に公開プロジェクトをクローンするだけなら、そもそもアカウントを取得する必要すらありません。
取得したアカウントが役立つのは、プロジェクトをフォークして、そのフォークにプッシュするときです。</p>
<p>SSH を使って接続したい場合は、公開鍵の設定が必要です
（公開鍵をまだ持っていない場合は、 <a id="xref--ch04-git-server--r_generate_ssh_key" href="ch04-git-server.xhtml#r_generate_ssh_key" class="xref">SSH 公開鍵の作成</a> を参照ください）。
画面右上のリンクから、アカウント設定のページを開きましょう。</p>
<figure class="image">
<div class="content">
<img src="images/account-settings.png" alt="``Account settings'' のリンク"/>
</div>
<figcaption>Figure 2. “Account settings” のリンク</figcaption>
</figure>
<p>そして、左側にある “SSH keys” を選択します。</p>
<figure class="image">
<div class="content">
<img src="images/ssh-keys.png" alt="``SSH keys'' のリンク"/>
</div>
<figcaption>Figure 3. “SSH keys” のリンク</figcaption>
</figure>
<p>ここで "<code class="literal">Add an SSH key</code>" ボタンをクリックし、鍵の名前を入力し、自分の公開鍵ファイル (<code class="literal">~/.ssh/id_rsa.pub</code> あるいは、自分で設定したその他の名前)
の内容をテキストエリアに貼り付けて、 “Add key” をクリックします。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>鍵の名前は、自分で覚えやすいものにしておきましょう。鍵ごとに「ラップトップ」「仕事用」などの名前をつけておけば、
後で鍵を破棄することになったときに、どれを破棄すればいいのかがわかりやすくなります。</p>
</div>
</aside>
</section>
<section class="sect2" title="アバター">
<h3 id="r_personal_avatar">アバター</h3>
<p>自分のアカウント用のアバターとして、好きな画像を指定することもできます。
まずは、SSH key タブの上にある “Profile” タブを開き、“Upload new picture” をクリックしましょう。</p>
<figure class="image">
<div class="content">
<img src="images/your-profile.png" alt="``Profile'' のリンク"/>
</div>
<figcaption>Figure 4. “Profile” のリンク</figcaption>
</figure>
<p>ハードディスク上にある Git のロゴを選ぶと、必要な部分だけを切り抜けるようになります。</p>
<figure class="image">
<div class="content">
<img src="images/avatar-crop.png" alt="アップロードしたアバターを切り抜く"/>
</div>
<figcaption>Figure 5. アバターの切り抜き</figcaption>
</figure>
<p>これで、GitHub 上で何かのアクションを起こしたときに、あなたのユーザー名の隣にその画像が表示されるようになりました。</p>
<p>もしすでに Gravatar にアバターを登録している場合
(Wordpress のアカウントを持っている人の多くが、Gravatar を使っています)
は、デフォルトでそのアバターが使われるので、何もする必要がありません。</p>
</section>
<section class="sect2" title="メールアドレス">
<h3 id="_メールアドレス">メールアドレス</h3>
<p>GitHub が Git のコミットとユーザーを紐付けるときに使うのが、メールアドレスです。
複数のメールアドレスを使い分けてコミットしているときに、それをあなたのアカウントに適切にリンクさせるためには、
すべてのメールアドレスを管理画面の Emails セクションで登録する必要があります。</p>
<figure id="r_add_email_addresses" class="image">
<div class="content">
<img src="images/email-settings.png" alt="メールアドレスの追加"/>
</div>
<figcaption>Figure 6. メールアドレスの追加</figcaption>
</figure>
<p><a id="xref-r_add_email_addresses" href="#r_add_email_addresses" class="xref">メールアドレスの追加</a> を見ると、メールアドレスにはさまざまな状態があることがわかります。
最初のアドレスは検証済みで、プライマリアドレスとして設定されています。つまり、各種の通知や有償プランの領収書などが、このアドレスに届くということです。
二番目のアドレスも検証済みです。もしプライマリアドレスをこちらに変更したい場合は、切り替えることができます。
最後のアドレスは未検証です。検証済みになるまでは、これをプライマリアドレスにすることはできません。
GitHub のサイト上にこれらのメールアドレスを含むコミットがあった場合、それがあなたのアカウントと関連づけられます。</p>
</section>
<section class="sect2" title="二要素認証">
<h3 id="_二要素認証">二要素認証</h3>
<p>最後に、セキュリティ高めるために、二要素認証（“2FA”）の設定をしておきましょう。
二要素認証とは、認証方式のひとつで、最近よく使われるようになりつつあります。
この方式を使うと、仮に何らかの方法でパスワードが盗まれてしまった場合でも、アカウントを乗っ取られるリスクを減らせます。
二要素認証を有効にすると、GitHub は複数の方法による認証を行うようになります。
仮にその一方の情報が盗まれたとしても、それだけでは、攻撃者があなたのアカウントにアクセスすることはできないのです。</p>
<p>二要素認証の設定は、アカウント設定画面の「Security」タブの中にあります。</p>
<figure class="image">
<div class="content">
<img src="images/2fa-1.png" alt="Security タブでの二要素認証"/>
</div>
<figcaption>Figure 7. Security タブの二要素認証</figcaption>
</figure>
<p>“Set up two-factor authentication” ボタンをクリックすると、設定ページに移動します。
ここでは、スマホアプリを使ってセキュリティコード（“時刻ベースのワンタイムパスワード”）を設定するか、
ログインのたびに GitHub からの SMS でコードを受け取るようにするのかを選べます。</p>
<p>いずれかのお好みの方法を選び、指示に従って二要素認証を設定し終えたら、
あなたのアカウントは今までよりも少しだけ安全になります。
ただし、GitHub にログインするときには、パスワードだけでなくセキュリティコードも必要になります。</p>
</section>
</section>
<section class="sect1" title="プロジェクトへの貢献">
<h2 id="_プロジェクトへの貢献">プロジェクトへの貢献</h2>
<p>これでアカウントが用意できたので、次は、既存のプロジェクトへの貢献にあたって役立つであろうことを説明していきましょう。</p>
<section class="sect2" title="プロジェクトのフォーク">
<h3 id="_プロジェクトのフォーク">プロジェクトのフォーク</h3>
<p></p>
<p>既存のプロジェクトに貢献したいけれども、そのリポジトリにプッシュする権限がないという場合は、プロジェクトを「フォーク」できます。
「フォーク」するとは、GitHub があなた専用にそのプロジェクトのコピーを作るということです。あなた自身の名前空間に置かれるので、そこには自分でプッシュできます。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>歴史的に、この「フォーク」という用語はあまり好ましくない意味で使われてきました。
何かのオープンソースプロジェクトの方針を気に入らない人が、別の道を歩み出すこと
（そして時には、競合するプロジェクトを作って、貢献者を引き抜いてしまうこと）を指していたのです。
GitHub における「フォーク」とは、単にあなたの配下に作られるコピー以外の何者でもありません。
自分自身による変更を公開の場でそのプロジェクトに適用でき、よりオープンなやりかたでプロジェクトに貢献できるようにするための手段なのです。</p>
</div>
</aside>
<p>この方式なら、協力してくれる人たちにいちいちプッシュアクセス権を付与していく必要はありません。
それぞれがプロジェクトをフォークして、そこにプッシュして、その変更を元のリポジトリに提供したければ、いわゆる「プルリクエスト」を作ればいいのです。
プルリクエストについては、後ほど説明します。
プルリクエストを作ると、そこにコードレビューのスレッドが立ち上がります。
プロジェクトのオーナーとプルリクエストの作者は、そこで変更についての議論を重ねて、
オーナーが納得した時点で、それをマージすることができます。</p>
<p>プロジェクトをフォークするには、プロジェクトのページに行って、ページ右上にある`‘Fork’'ボタンを押します。</p>
<figure class="image">
<div class="content">
<img src="images/forkbutton.png" alt="``Fork'' ボタン"/>
</div>
<figcaption>Figure 8. “Fork” ボタン</figcaption>
</figure>
<p>数秒後、新しいプロジェクトのページに自動的に移動します。これは、あなた自身が書き込み可能なコピーです。</p>
</section>
<section class="sect2" title="GitHub Flow">
<h3 id="r_github_flow">GitHub Flow</h3>
<p></p>
<p>GitHub は、プルリクエストを中心としたコラボレーションのワークフローを想定して作られています。
ひとつのリポジトリを共有する密接に連携したチームでの作業であっても、世界中に広がる企業や個人が関わるプロジェクトで何十ものフォークがあるプロジェクトであっても、
このワークフローはうまく機能します。
その中心になるのが、<a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> でとりあげた <a id="xref--ch03-git-branching--r_topic_branch" href="ch03-git-branching.xhtml#r_topic_branch" class="xref">トピックブランチ</a> のワークフローです。</p>
<p>全体的な流れは、以下のようになります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal"><code class="literal">master</code> からトピックブランチを作る。</span>
</li>
<li>
<span class="principal">そこに、プロジェクトの改良につながるコミットをする。</span>
</li>
<li>
<span class="principal">このブランチを、自分の GitHub プロジェクトにプッシュする。</span>
</li>
<li>
<span class="principal">GitHub 上でプルリクエストを作る。</span>
</li>
<li>
<span class="principal">議論を重ね、必要ならさらにコミットをする。</span>
</li>
<li>
<span class="principal">プロジェクトのオーナーは、プルリクエストをマージする（あるいは、マージせずに閉じる）。</span>
</li>
</ol>
</div>
<p>これは基本的に、<a id="xref--ch05-distributed-git--r_integration_manager" href="ch05-distributed-git.xhtml#r_integration_manager" class="xref">統合マネージャー型のワークフロー</a> でとりあげる、統合マネージャー型のワークフローです。
しかし、変更についてのやりとりやレビューをメールで行う代わりに、ここでは GitHub のウェブベースのツールを使います。</p>
<p>GitHub で公開しているオープンソースのプロジェクトに対して、このフローを使って変更を提案する例を見ていきましょう。</p>
<section class="sect3" title="プルリクエストの作成">
<h4 id="_プルリクエストの作成">プルリクエストの作成</h4>
<p>自分のArduino上で実行するコードを探していたトニーは、GitHub 上にすばらしいプログラムがあることを発見しました。
それが <a href="https://github.com/schacon/blink" class="link">https://github.com/schacon/blink</a> です。</p>
<figure class="image">
<div class="content">
<img src="images/blink-01-start.png" alt="貢献したいプロジェクト"/>
</div>
<figcaption>Figure 9. 貢献したいプロジェクト</figcaption>
</figure>
<p>ただ、ひとつ問題がありました。点滅の間隔が速すぎるのです。1 秒おきに状態を切り替えるのではなく、3 秒くらいは間を置きたいものです。
さて、このプログラムを改良して、その変更を提案してみましょう。</p>
<p>まずは、先ほど説明した <em>Fork</em> ボタンをクリックして、このプロジェクトのコピーを手に入れます。
この例で使うユーザー名は “tonychacon” とします。つまり、できあがったコピーは <code class="literal">https://github.com/tonychacon/blink</code> となり、ここからはこのプロジェクトを変更していきます。
これをローカルにクローンして、トピックブランチを作り、コードを変更して、その変更を GitHub にプッシュしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/tonychacon/blink <i class="conum" data-value="1">①</i>
Cloning into &#39;blink&#39;...

<span style="font-weight: bold">$</span> cd blink
<span style="font-weight: bold">$</span> git checkout -b slow-blink <i class="conum" data-value="2">②</i>
Switched to a new branch &#39;slow-blink&#39;

<span style="font-weight: bold">$</span> sed -i <span style="font-style: italic">&#39;&#39;</span> <span style="font-style: italic">&#39;s/1000/3000/&#39;</span> blink.ino <i class="conum" data-value="3">③</i>

<span style="font-weight: bold">$</span> git diff --word-diff <i class="conum" data-value="4">④</i>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;three seconds is better&#39;</span> <i class="conum" data-value="5">⑤</i>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

<span style="font-weight: bold">$</span> git push origin slow-blink <i class="conum" data-value="6">⑥</i>
Username for &#39;https://github.com&#39;: tonychacon
Password for &#39;https://tonychacon@github.com&#39;:
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> フォークしたプロジェクトを、ローカルにクローンする</li>
<li><i class="conum" data-value="2">②</i> わかりやすい名前のトピックブランチを作る</li>
<li><i class="conum" data-value="3">③</i> コードを変更する</li>
<li><i class="conum" data-value="4">④</i> 問題はなさそうだ</li>
<li><i class="conum" data-value="5">⑤</i> この変更をトピックブランチにコミットする</li>
<li><i class="conum" data-value="6">⑥</i> 新しいトピックブランチを、GitHub 上のフォークに書き戻す</li>
</ol>
</div>
<p>この状態で GitHub 上のフォークに戻ると、GitHub 上に新しいトピックブランチがプッシュされたことを伝えてくれます。
また、大きな緑色のボタンを使えば、変更点を確認したり、元のプロジェクトへのプルリクエストを送ったりできます。</p>
<p>あるいは、<code class="literal">https://github.com/&lt;user&gt;/&lt;project&gt;/branches</code> にある “Branches” ページから自分のトピックブランチに移動して、そこからプルリクエストを送ることもできます。</p>
<figure class="image">
<div class="content">
<img src="images/blink-02-pr.png" alt="プルリクエストのボタン"/>
</div>
<figcaption>Figure 10. プルリクエストのボタン</figcaption>
</figure>
<p></p>
<p>この緑のボタンをクリックすると、プルリクエストのタイトルと説明を入力する画面に遷移します。
ちゃんと時間をかけて説明を書きましょう。損はしないはずです。プルリクエストを受ける側のプロジェクトオーナーからすれば、説明文がよければあなたの意図が汲み取りやすくなるからです。そうすれば、オーナーはプルリクエストの内容を正確に評価できますし、それを取り込むことがプロジェクトにとってプラスかどうかを判断できるでしょう。</p>
<p>この画面では、トピックブランチ内のコミットのうち、`master`よりも先行しているコミットの一覧 (今回の場合はひとつだけ) も確認できます。
また、このブランチをオーナーがマージしたときに適用される変更の、unified形式の差分も表示されます。</p>
<figure class="image">
<div class="content">
<img src="images/blink-03-pull-request-open.png" alt="プルリクエストの作成"/>
</div>
<figcaption>Figure 11. プルリクエストの作成ページ</figcaption>
</figure>
<p>この画面で <em>Create pull request</em> ボタンを押すと、フォーク元のプロジェクトのオーナーに、
誰かが変更を提案しているという通知が届きます。この通知には、変更に関するすべての情報が記載されたページへのリンクが含まれています。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>一般にプルリクエストは、こういった公開プロジェクトに対する変更を、その準備が整った時点で提案するために作るものです。
しかし、内部的なプロジェクトの開発サイクルにおいて、 <em>開発を始めるタイミングで</em> プルリクエストを作ることもよくあります。
プルリクエストを作った*後でも*、そのトピックブランチへのプッシュを続けることができます。
最後の最後にプルリクエストを行うのではなく、早い時点でプルリクエストを作っておけば、
その後の作業状況をチーム内で共有できます。</p>
</div>
</aside>
</section>
<section class="sect3" title="プルリクエストの繰り返し">
<h4 id="_プルリクエストの繰り返し">プルリクエストの繰り返し</h4>
<p>これで、元のプロジェクトのオーナーは、変更の提案を見られるようになりました。それをマージしたり、却下したり、コメントしたりすることができます。
ここでは、オーナーが変更提案を気に入ったものの、ライトが消えている時間を点灯している時間よりも少しだけ長くしたほうがいいと感じたことにしましょう。</p>
<p><a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">Git での分散作業</a> のワークフローなら、この手のやりとりはメールで行うところですが、GitHub の場合はこれをオンラインで行います。
プロジェクトのオーナーはunfied diffをレビューして、コメントを残します。コメントしたい行をクリックすれば、コメントを残せます。</p>
<figure class="image">
<div class="content">
<img src="images/blink-04-pr-comment.png" alt="PRの行コメント"/>
</div>
<figcaption>Figure 12. プルリクエストのコードの特定の行へのコメント</figcaption>
</figure>
<p>メンテナがコメントを入れると、プルリクエストの作者 (そして、そのリポジトリをウォッチしているすべての人たち) に、通知が届きます。
通知をカスタマイズする方法については後述しますが、メールでの通知を受け取るように設定している場合は、以下のようなメールも届きます。</p>
<figure id="r_email_notification" class="image">
<div class="content">
<img src="images/blink-04-email.png" alt="メールでの通知"/>
</div>
<figcaption>Figure 13. 通知メールで送られたコメント</figcaption>
</figure>
<p>オーナーだけでなく誰でも、プルリクエスト全体に対するコメントができます。
<a id="xref-r_pr_discussion" href="#r_pr_discussion" class="xref">プルリクエストのディスカッションページ</a> では、プロジェクトのオーナーがコードの特定の行についてコメントしたうえで、さらにプルリクエスト全体に関するコメントも残しています。
また、コードへのコメントが、一連の会話に組み込まれていることにもお気づきでしょう。</p>
<figure id="r_pr_discussion" class="image">
<div class="content">
<img src="images/blink-05-general-comment.png" alt="PRのディスカッションページ"/>
</div>
<figcaption>Figure 14. プルリクエストのディスカッションページ</figcaption>
</figure>
<p>プルリクエストの作者は、自分の変更を受け入れてもらうために何が必要なのかがわかりました。
幸運にも、そんなに手間のかかることではありません。
メールでのやりとりの場合は、一連の作業をやり直した上でもう一度メーリングリストに投稿する必要がありますが、
GitHub なら、単にトピックブランチにコミットしてそれをプッシュするだけで済みます。
また、<a id="xref-r_pr_final" href="#r_pr_final" class="xref">プルリクエストの最終形</a> にあるように、更新されたプルリクエストでは変更前のコードへのコメント表示が省略されています。追加されたコミットによって変更されたコードへのコメントだからです。</p>
<p>なお、既存のプルリクエストにコミットを追加しても、通知は送られません。そこで、修正をプッシュしたトニーは、修正が終わったことをコメントでプロジェクトオーナーに伝えることにしました。</p>
<figure id="r_pr_final" class="image">
<div class="content">
<img src="images/blink-06-final.png" alt="PRの最終形"/>
</div>
<figcaption>Figure 15. プルリクエストの最終形</figcaption>
</figure>
<p>このプルリクエストのページで “Files Changed” タブをクリックすると、“unified” 形式の diff を確認できます。
つまり、このトピックブランチをマージしたときにどんな変更が施されるのかを、まとめて確認できるのです。
<code class="literal">git diff</code> の用語に直すと、このタブを開いたときに表示される内容は、プルリクエストの対象になっているブランチ上で
<code class="literal">git diff master...&lt;branch&gt;</code> を実行した結果になります。
この形式の diff についての詳細は、<a id="xref--ch05-distributed-git--r_what_is_introduced" href="ch05-distributed-git.xhtml#r_what_is_introduced" class="xref">何が変わるのかの把握</a> を参照ください。</p>
<p>もうひとつお気づきのことがあることでしょう。
GitHub は、このプルリクエストが問題なくマージできることを確認したうえで、サーバー上でマージを実行するためのボタンを表示します。
このボタンが表示されるのは、あなたがこのリポジトリへの書き込みアクセス権限を持っていて、かつ問題なくマージ可能な場合だけです。
このボタンをクリックすると、GitHub は “non-fast-forward” なマージを行います。
つまり、仮に fast-forward 可能なマージであったとしても、明示的にマージコミットを作ります。</p>
<p>お望みなら、このブランチを取得した上で、ローカルでマージすることもできます。
このブランチを <code class="literal">master</code> にマージしてから GitHub にプッシュすると、このプルリクエストは自動的に閉じられます。</p>
<p>これが、大半の GitHub プロジェクトが使っている基本的なワークフローです。
トピックブランチを作り、そこからプルリクエストを作って、議論を重ね、必要に応じてさらに作業を重ねて、最終的にそのリクエストをマージするか、あるいはマージせずに終了します。</p>
<aside class="admonition note" title="Note: フォークしなくてもかまわない" epub:type="note">
<h2>フォークしなくてもかまわない</h2>
<div class="content">
<p>同じリポジトリのふたつのブランチ間でのプルリクエストもできるということを知っておきましょう。
誰かと一緒に何らかのフィーチャーの作業をしていて、両方ともそのプロジェクトへの書き込み権限を持っている場合なら、
トピックブランチをそのリポジトリにプッシュした上で、同じプロジェクトの <code class="literal">master</code> ブランチへのプルリクエストを作ることができます。
そこで、コードのレビューや議論を進めればいいでしょう。
このときに、わざわざフォークする必要はありません。</p>
</div>
</aside>
</section>
</section>
<section class="sect2" title="プルリクエストの応用テクニック">
<h3 id="_プルリクエストの応用テクニック">プルリクエストの応用テクニック</h3>
<p>GitHub のプロジェクトに貢献する際の基本がわかったところで、
プルリクエストに関するちょっとしたヒントやテクニックを紹介しましょう。これらを使えば、プルリクエストをさらに活用できるでしょう。</p>
<section class="sect3" title="パッチとしてのプルリクエスト">
<h4 id="_パッチとしてのプルリクエスト">パッチとしてのプルリクエスト</h4>
<p>実際のところ、多くのプロジェクトは、プルリクエストを完璧なパッチ群である (つまり、きちんと順序どおりに適用しなければいけない) とは考えていません。
これは、メーリングリストベースで運営するプロジェクトで一般的な考えかたとは異なります。
GitHub のプロジェクトでは、プルリクエストのブランチを変更提案に関する議論の場と捕らえていることが多く、
最終的にできあがった unified diff をマージするのだと考えています。</p>
<p>この違いを認識しておくことが大切です。一般に、変更を提案するのは、コードが完璧に仕上がる前の段階です。
一方、メーリングリストベースの運営では、まだできあがってもいないパッチを投稿することなど、まずないでしょう。
未完成の段階で変更を提案することで、メンテナとの議論を早めに始めることができます。
コミュニティの協力で、より適切なソリューションにたどり着けるようになるでしょう。
プルリクエストで提案したコードに対してメンテナやコミュニティから変更の提案があったときに、
パッチをゼロから作り直す必要はありません。
差分だけを、新たなコミットとしてプッシュすればいいのです。
その後の議論は、これまでの経緯を踏まえた上で進みます。</p>
<p><a href="#r_pr_final" class="xref">プルリクエストの最終形</a> をもう一度見てみましょう。プルリクエストの作者は、自分のコミットをリベースして新たなプルリクエストを作ったわけではありません。
単に、新しいコミットを追加して、それを既存のブランチにプッシュしただけです。
そのおかげで、今後このプルリクエストのページを見直すことがあったときにも、最終的な決定に至るまでの経緯を簡単に確認できるのです。
“Merge” ボタンを押したときに、本来不要な場面でも意図的にマージコミットを作っているのは、
後からそのプルリクエストを参照しやすいようにするためです。
必要に応じて、それまでの流れをすぐに調べることができます。</p>
</section>
<section class="sect3" title="上流への追従">
<h4 id="_上流への追従">上流への追従</h4>
<p>プルリクエストを作った後で元のプロジェクトに変更が加わったなどの理由で、プルリクエストがそのままではマージできなくなることがあります。
そんな場合は、そのプルリクエストを修正して、メンテナがマージしやすいようにしておきたいことでしょう。
GitHub は、そのままでマージできるかどうかをチェックして、すべてのプルリクエストのページの最下部に結果を表示します。</p>
<figure id="r_pr_fail" class="image">
<div class="content">
<img src="images/pr-01-fail.png" alt="マージできないPR"/>
</div>
<figcaption>Figure 16. そのままではマージできないプルリクエスト</figcaption>
</figure>
<p><a id="xref-r_pr_fail" href="#r_pr_fail" class="xref">そのままではマージできないプルリクエスト</a> のようになっていたら、自分のブランチを修正して、この表示がグリーンになるようにしたいところです。
そうすれば、メンテナに余計な手間をかけさせずに済みます。</p>
<p>グリーンにするための主な選択肢は、二種類あります。
ひとつは、自分のブランチを、プルリクエストの対象ブランチ (普通は、フォーク元のリポジトリの <code class="literal">master</code>) の先端にリベースすること。
もうひとつは、その対象ブランチを自分のブランチにマージすることです。</p>
<p>GitHub 上の開発者の多くは、後者を選んでいるようです。その理由は、先述したとおりです。
重要なのは、そこにいたるまでの歴史と、最終的にマージしたという事実だと考えているのでしょう。
リベースをすると、歴史がすっきりするという以外の利点はありません。そして、リベースはマージに比べて <strong>ずっと</strong> 難しいし、間違いを起こしやすいものです。</p>
<p>対象ブランチをマージして、自分のプルリクエストをそのまま取り込んでもらえるようにする手順は、次のとおりです。
まず、オリジナルのリポジトリを新しいリモートとして追加して、それをフェッチします。
そして、そのリポジトリのメインブランチを自分のトピックブランチにマージします。
何か問題があれば修正し、その結果をプルリクエストと同じブランチにプッシュします。</p>
<p>先ほどの “tonychacon” の例に戻りましょう。プルリクエストを出した後にオリジナルの作者がリポジトリに変更を加えたため、
プルリクエストがそのままでは取り込めなくなってしまいました。そんな場合の手順は、以下のとおりです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add upstream https://github.com/schacon/blink <i class="conum" data-value="1">①</i>

<span style="font-weight: bold">$</span> git fetch upstream <i class="conum" data-value="2">②</i>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

<span style="font-weight: bold">$</span> git merge upstream/master <i class="conum" data-value="3">③</i>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

<span style="font-weight: bold">$</span> vim blink.ino <i class="conum" data-value="4">④</i>
<span style="font-weight: bold">$</span> git add blink.ino
<span style="font-weight: bold">$</span> git commit
[slow-blink 3c8d735] Merge remote-tracking branch &#39;upstream/master&#39; \
    into slower-blink

<span style="font-weight: bold">$</span> git push origin slow-blink <i class="conum" data-value="5">⑤</i>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> オリジナルのリポジトリを “upstream” という名前のリモートとして追加する</li>
<li><i class="conum" data-value="2">②</i> そのリモートの、最新の状態をフェッチする</li>
<li><i class="conum" data-value="3">③</i> メインブランチを、自分のトピックブランチにマージする</li>
<li><i class="conum" data-value="4">④</i> 衝突を解決する</li>
<li><i class="conum" data-value="5">⑤</i> 同じトピックブランチに、再びプッシュする</li>
</ol>
</div>
<p>これでプルリクエストが自動的に更新されて、マージ可能かどうかが再びチェックされます。</p>
<figure id="r_pr_merge_fix" class="image">
<div class="content">
<img src="images/pr-02-merge-fix.png" alt="修正後のPR"/>
</div>
<figcaption>Figure 17. そのままマージできるようになったプルリクエスト</figcaption>
</figure>
<p>Git のすばらしいところのひとつが、これらの作業を継続的に行えるということです。
長期にわたるプロジェクトでも、対象ブランチからのマージを何度でも繰り返せるので、前回のマージ以降に発生した衝突さえ気をつけていれば、混乱なく作業を続けられます。</p>
<p>ブランチをリベースしてすっきりさせたい場合は、そうしてもかまいません。
しかし、既に作成済みのプルリクエストに対して、それを強制的にプッシュするのは避けたほうがいいでしょう。
もし他の人がそれを手元に取得して何かの作業を進めると、<a id="xref--ch03-git-branching--r_rebase_peril" href="ch03-git-branching.xhtml#r_rebase_peril" class="xref">ほんとうは怖いリベース</a> で説明したような問題が発生します。
リベースした場合は、それを GitHub 上で新しいブランチにして、新しいプルリクエストを作るようにしましょう。
新しいプルリクエストから元のプルリクエストを参照して、そして元のプルリクエストは閉じてしまいます。</p>
</section>
<section class="sect3" title="参照">
<h4 id="_参照">参照</h4>
<p>…と言われて気になるのは、「元のプルリクエストをどうやって参照すればいいの？」ということでしょう。
GitHub 上で他のものを参照するにはいろんな方法があって、GitHub 上で何かを書ける場所ならほぼどこでも他のものを参照できます。</p>
<p>まずは、別のプルリクエストあるいは Issue を相互参照する方法から紹介します。
プルリクエストや Issue には番号が振られていて、この番号はプロジェクト内で一意になっています。
つまり、たとえばプルリクエスト#3とIssue #3が <em>両方とも</em> 存在することはありえないのです。
他のプルリクエストや Issue を参照したい場合は、コメントや説明文の中で単に <code class="literal">#&lt;num&gt;</code> と書くだけでかまいません。
あるいは、もう少し細かく、誰か他の人が作った Issue やプルリクエストを指定することもできます。
<code class="literal">username#&lt;num&gt;</code> と書けば、今いるリポジトリの別のフォーク上での Issue やプルリクエストを参照できるし、
<code class="literal">username/repo#&lt;num&gt;</code> と書けば、別のリポジトリ上のものも参照できます。</p>
<p>実例を見てみましょう。
先ほど説明したとおり、リベースをした上で新しいプルリクエストを作ったものとします。新しいプルリクエストから、古いプルリクエストを参照したいところです。
また、そのリポジトリのフォーク上にある Issue や、まったく別のプロジェクトにある Issue も参照するつもりです。
説明文は、<a id="xref-r_pr_references" href="#r_pr_references" class="xref">プルリクエスト内での相互参照</a> のようになります。</p>
<figure id="r_pr_references" class="image">
<div class="content">
<img src="images/mentions-01-syntax.png" alt="PRの参照"/>
</div>
<figcaption>Figure 18. プルリクエスト内での相互参照</figcaption>
</figure>
<p>このプルリクエストを投稿すると、画面上では <a id="xref-r_pr_references_render" href="#r_pr_references_render" class="xref">プルリクエスト内での相互参照のレンダリング</a> のような表示になります。</p>
<figure id="r_pr_references_render" class="image">
<div class="content">
<img src="images/mentions-02-render.png" alt="PR内での参照のレンダリング"/>
</div>
<figcaption>Figure 19. プルリクエスト内での相互参照のレンダリング</figcaption>
</figure>
<p>GitHub の完全な URL を入力したところも、画面上では短縮されて、必要な情報だけが見えていることがわかるでしょう。</p>
<p>トニーが元のプルリクエストを閉じると、そのことが新しいプルリクエストのほうにも表示されることがわかります。
GitHub が、プルリクエストのタイムラインに自動的にトラックバックを送ったのです。
これで、古いプルリクエストを見にきたすべての人は、そのリクエストの後継となる新しいプルリクエストにたどり着けるようになるのです。
リンクは、<a id="xref-r_pr_closed" href="#r_pr_closed" class="xref">プルリクエスト内での相互参照のレンダリング</a> のように表示されます。</p>
<figure id="r_pr_closed" class="image">
<div class="content">
<img src="images/mentions-03-closed.png" alt="閉じられたPR"/>
</div>
<figcaption>Figure 20. プルリクエスト内での相互参照のレンダリング</figcaption>
</figure>
<p>issue の番号だけでなく、SHA-1 を示して特定のコミットを参照することもできます。
SHA-1 を指定する際には 40 文字ぶんすべてを示す必要がありますが、コメントの中に SHA-1 を発見すると、GitHub はそれを当該コミットへリンクしてくれます。
他のフォークやその他のリポジトリのコミットを参照する場合の方法は、issue の場合と同じです。</p>
</section>
</section>
<section class="sect2" title="Markdown">
<h3 id="_markdown">Markdown</h3>
<p>他の Issue へのリンクは、GitHub のテキストボックスでできるさまざまなことのうちの、ほんの始まりに過ぎません。
Issue やプルリクエストの説明、それに対するコメント、コードに対するコメントなどなどでは、いわゆる “GitHub Flavored Markdown” を使うことができます。
Markdown はプレーンテキストと似ていますが、よりリッチなレンダリングを行います。</p>
<p>コメントや説明文を、Markdown を使って書いた例を <a id="xref-r_example_markdown" href="#r_example_markdown" class="xref">Markdown での記述例と、そのレンダリング結果</a> に示します。</p>
<figure id="r_example_markdown" class="image">
<div class="content">
<img src="images/markdown-01-example.png" alt="Markdown の例"/>
</div>
<figcaption>Figure 21. Markdown での記述例と、そのレンダリング結果</figcaption>
</figure>
<section class="sect3" title="GitHub Flavored Markdown">
<h4 id="_github_flavored_markdown">GitHub Flavored Markdown</h4>
<p>GitHub Flavored Markdownは、基本的なMarkdownの文法に、GitHub 流の味付けをしたものです。
プルリクエストや Issue を作ったり、それにコメントしたりするときに、役立つことでしょう。</p>
<section class="sect4" title="タスクリスト">
<h5 id="_タスクリスト">タスクリスト</h5>
<p>GitHub 流の Markdown で追加された便利な機能の中で、最初に紹介する機能が、タスクリストです。これは、プルリクエストで特に便利です。
タスクリストとは、チェックボックス付きの、やることリストです。
これを Issue やプルリクエストで使うと、完了させるまでに何を済ませなければいけないのかを表せます。</p>
<p>タスクリストの作りかたは、以下のとおりです。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code</code></pre>
</figure>
<p>プルリクエストや Issue の説明文にこのように書いておくと、<a id="xref-r_task_lists" href="#r_task_lists" class="xref">Markdown でのコメント内に表示されたタスクリスト</a> のような表示になります。</p>
<figure id="r_task_lists" class="image">
<div class="content">
<img src="images/markdown-02-tasks.png" alt="タスクリストの例"/>
</div>
<figcaption>Figure 22. Markdown でのコメント内に表示されたタスクリスト</figcaption>
</figure>
<p>これはたとえば、プルリクエストに対して、「これだけのことを済ませればマージの準備が整う」ということを示すために使うことがあります。
この機能のすばらしいところは、単にチェックボックスをクリックするだけで、コメントが更新できるということです。
タスクが完了したときに、わざわざ Markdown を直接編集する必要はありません。</p>
<p>さらに、GitHub は、Issue やプルリクエストの中にあるタスクリストを見つけて、そのメタデータを一覧ページにも表示してくれます。
たとえば、あるプルリクエストの中でタスクを作ったときに、プルリクエストの一覧ページを見ると、タスクがどの程度完了しているのかを確認できるのです。
これは、プルリクエストをサブタスクに切り分けたり、他のひとたちがそのブランチの進捗を追いかけたりする際にも役立ちます。
この機能の実例を <a id="xref-r_task_list_progress" href="#r_task_list_progress" class="xref">プルリクエスト一覧における、タスク一覧の概要表示</a> に示します。</p>
<figure id="r_task_list_progress" class="image">
<div class="content">
<img src="images/markdown-03-task-summary.png" alt="タスクリストの例"/>
</div>
<figcaption>Figure 23. プルリクエスト一覧における、タスク一覧の概要表示</figcaption>
</figure>
<p>この機能は、
トピックブランチを作ったばかりのときにプルリクエストを出して、その後の実装の進捗をプルリクエスト上で追いかけていくような場合に、とても便利です。</p>
</section>
<section class="sect4" title="コードスニペット">
<h5 id="_コードスニペット">コードスニペット</h5>
<p>コメントに、コードスニペットを追加することもできます。
これは、これから <em>やろうとしている</em> ことを、実際に実装する前に表明したりするときに便利です。
また、うまく動かないサンプルコードや、このプルリクエストで実装できることを説明するサンプルコードなどを示すときにも使われます。</p>
<p>コードスニペットを追加するには、バッククォートで「囲む」必要があります。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println(&quot;i is : &quot; + i);
}
```</code></pre>
</figure>
<p>このサンプルでの <em>java</em> のように言語名を追加すると、GitHub はスニペットのシンタックスハイライトを行います。
このサンプルは、最終的に <a id="xref-r_md_code" href="#r_md_code" class="xref">サンプルコードをレンダリングした結果</a> のような表示になります。</p>
<figure id="r_md_code" class="image">
<div class="content">
<img src="images/markdown-04-fenced-code.png" alt="レンダリングされたコード"/>
</div>
<figcaption>Figure 24. サンプルコードをレンダリングした結果</figcaption>
</figure>
</section>
<section class="sect4" title="引用">
<h5 id="_引用">引用</h5>
<p>長いコメントの一部に返信するときは、その部分を引用することができます。引用するには、各行の先頭に <code class="literal">&gt;</code> を付け加えます。
これはとても便利で、よく使われるものなので、キーボードショートカットも用意されています。
コメントの中で返信したい部分を選択して <code class="literal">r</code> キーを押すと、選択した部分を引用した、新しいコメント入力欄が現れます。</p>
<p>引用は、このような感じになります。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>&gt; Whether &#39;tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</code></pre>
</figure>
<p>このコメントが、画面上では <a id="xref-r_md_quote" href="#r_md_quote" class="xref">引用のレンダリングの例</a> のようにレンダリングされます。</p>
<figure id="r_md_quote" class="image">
<div class="content">
<img src="images/markdown-05-quote.png" alt="引用のレンダリング"/>
</div>
<figcaption>Figure 25. 引用のレンダリングの例</figcaption>
</figure>
</section>
<section class="sect4" title="絵文字">
<h5 id="_絵文字">絵文字</h5>
<p>最後に紹介するのが絵文字です。コメントの中で、絵文字を使えます。
実際に、GitHub の Issue やプルリクエストの多くで、絵文字が使われています。
GitHub には、絵文字の入力支援機能もあるのです。
コメントの記入中に <code class="literal">:</code> を入力すると、オートコンプリート機能が立ち上がって、絵文字を探すのを手伝ってくれます。</p>
<figure id="r_md_emoji_auto" class="image">
<div class="content">
<img src="images/markdown-06-emoji-complete.png" alt="絵文字のオートコンプリート"/>
</div>
<figcaption>Figure 26. 絵文字のオートコンプリートの例</figcaption>
</figure>
<p>絵文字は <code class="literal">:&lt;name&gt;:</code> 形式で表し、コメント内のどこでも使えます。
たとえば、このように書いたとしましょう。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it&#39;s :fire::poop:!

:clap::tada::panda_face:</code></pre>
</figure>
<p>これをレンダリングした結果は、<a id="xref-r_md_emoji" href="#r_md_emoji" class="xref">絵文字だらけのコメント</a> のようになります。</p>
<figure id="r_md_emoji" class="image">
<div class="content">
<img src="images/markdown-07-emoji.png" alt="絵文字"/>
</div>
<figcaption>Figure 27. 絵文字だらけのコメント</figcaption>
</figure>
<p>めちゃめちゃ便利というほどのものではありませんが、
楽しさや熱意を伝える手段としては他の追随を許さないものでしょう。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>最近は、絵文字を使えるウェブサービスも多くなってきました。
自分の言いたいことをうまく伝えられる絵文字を見つけるための、チートシートも公開されています。</p>
<p><a href="http://www.emoji-cheat-sheet.com" class="link">http://www.emoji-cheat-sheet.com</a></p>
</div>
</aside>
</section>
<section class="sect4" title="画像">
<h5 id="_画像">画像</h5>
<p>厳密に言うと GitHub Flavored Markdown とは関係ありませんが、これはとても便利な機能です。
Markdown でのコメントに画像のリンクを追加するのは、画像を探したり URL を埋め込んだりと面倒くさいものです。
しかし GitHub では、テキストエリアに画像をドラッグ＆ドロップするだけで、それを埋め込めるのです。</p>
<figure id="r_md_drag" class="image">
<div class="content">
<img src="images/markdown-08-drag-drop.png" alt="画像のドラッグ＆ドロップ"/>
</div>
<figcaption>Figure 28. ドラッグ＆ドロップで画像をアップロードして、自動的に埋め込む</figcaption>
</figure>
<p><a href="#r_pr_references" class="xref">プルリクエスト内での相互参照</a> に戻ると、テキストエリアの上に小さく “Parsed as Markdown” とヒントが書かれていることがわかります。
これをクリックすると、GitHub 上での Markdown でできるすべてのことをまとめた、チートシートを見ることができます。</p>
</section>
</section>
</section>
</section>
<section class="sect1" title="プロジェクトのメンテナンス">
<h2 id="r_maintaining_gh_project">プロジェクトのメンテナンス</h2>
<p>既存のプロジェクトへの貢献のしかたがわかったところで、次はもう一方の側面を見てみましょう。自分自身のプロジェクトを作ったりメンテナンスしたり、管理したりする方法です。</p>
<section class="sect2" title="新しいリポジトリの作成">
<h3 id="_新しいリポジトリの作成">新しいリポジトリの作成</h3>
<p>新しいプロジェクトを作って、自分たちのプロジェクトのコードを共有しましょう。
まずはダッシュボードの右側にある “New repository” ボタンをクリックするか、
上のツールバーでユーザー名の隣にある <code class="literal">+</code> ボタン (<a id="xref-r_new_repo_dropdown" href="#r_new_repo_dropdown" class="xref">“New repository” ドロップダウン</a> を参照) をクリックしましょう。</p>
<figure class="image">
<div class="content">
<img src="images/newrepo.png" alt="``Your repositories'' エリア"/>
</div>
<figcaption>Figure 29. “Your repositories” エリア</figcaption>
</figure>
<figure id="r_new_repo_dropdown" class="image">
<div class="content">
<img src="images/new-repo.png" alt="``new repository'' ドロップダウン"/>
</div>
<figcaption>Figure 30. “New repository” ドロップダウン</figcaption>
</figure>
<p>これで、“new repository” フォームが表示されます。</p>
<figure class="image">
<div class="content">
<img src="images/newrepoform.png" alt="``new repository'' フォーム"/>
</div>
<figcaption>Figure 31. “new repository” フォーム</figcaption>
</figure>
<p>ここで必須なのは、プロジェクト名を入力することだけです。それ以外のフィールドは空のままでもかまいません。
プロジェクト名を入力して “Create Repository” ボタンを押せば、はいできあがり。
これで GitHub 上に、<code class="literal">&lt;user&gt;/&lt;project_name&gt;</code> という新しいリポジトリができました。</p>
<p>まだ何もコードが存在しないので、GitHub はここで、新しい Git リポジトリを作る方法と既存の Git プロジェクトを取り込む方法を教えてくれます。
ここでは、それらの手順について長々と繰り返したりはしません。忘れてしまった人は、<a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git の基本</a> を見直しましょう。</p>
<p>これで GitHub 上にプロジェクトが用意でき、他の人たちにその URL を示せるようになりました。
GitHub 上のすべてのプロジェクトには、HTTP を使って <code class="literal">https://github.com/&lt;user&gt;/&lt;project_name&gt;</code> でアクセスすることができます。
また、SSH 経由での <code class="literal">git@github.com:&lt;user&gt;/&lt;project_name&gt;</code> へのアクセスもできます。
どちらの方式を使ってもデータのフェッチやプッシュができますが、そのプロジェクトに関連付けられたユーザーの認証情報に基づいた、アクセス制御がなされています。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>公開プロジェクトの共有には、HTTP ベースの URL を使うことをお勧めします。
SSH ベースの場合は、プロジェクトをクローンするためには GitHub のアカウントが必要になるからです。
SSH の URL だけを示した場合、それをクローンするには、GitHub のアカウントを作ったうえで SSH 鍵をアップロードする必要があります。
HTTP の URL は、ブラウザでそのプロジェクトのページを表示するときに使うものと同じです。</p>
</div>
</aside>
</section>
<section class="sect2" title="コラボレーターの追加">
<h3 id="_コラボレーターの追加">コラボレーターの追加</h3>
<p>他の人たちにもコミットアクセス権を渡したい場合は、その人たちを “コラボレーター” として追加しなければいけません。
すでに GitHub のアカウントを持っている Ben、Jeff、Louise に、あなたのリポジトリへのプッシュ権限を渡したい場合は、彼らを自分のプロジェクトに追加しましょう。
そうすれば、そのプロジェクトと Git リポジトリに対して、読み込みだけではなく書き込みアクセスもできるようになります。</p>
<p>右側のサイドバーの一番下にあるリンク “Settings” をクリックしましょう。</p>
<figure class="image">
<div class="content">
<img src="images/reposettingslink.png" alt="リポジトリの設定用のリンク"/>
</div>
<figcaption>Figure 32. リポジトリの設定用のリンク</figcaption>
</figure>
<p>そして、左側のメニューから “Collaborators” を選びます。
そこで、ユーザー名を入力して “Add collaborator” をクリックしましょう。
これを、アクセス権を追加したいすべての人に対して繰り返します。
アクセス権を破棄したい場合は、そのアカウントの右側にある “X” をクリックします。</p>
<figure class="image">
<div class="content">
<img src="images/collaborators.png" alt="リポジトリのコラボレーター"/>
</div>
<figcaption>Figure 33. リポジトリのコラボレーター</figcaption>
</figure>
</section>
<section class="sect2" title="プルリクエストの管理">
<h3 id="_プルリクエストの管理">プルリクエストの管理</h3>
<p>さて、プロジェクトに何らかのコードが追加して、何人かのコラボレーターにプッシュ権限も渡せたかと思います。
ここで、プルリクエストを受け取ったときにやるべきことを紹介しましょう。</p>
<p>プルリクエストは、あなたのリポジトリをフォークした先のブランチからやってくることもあれば、同じリポジトリ内の別ブランチから受け取ることもあります。
フォーク先からやってくるプルリクエストの場合は、あなたはそのリポジトリにプッシュできないし、逆にフォークした側の人もあなたのリポジトリにプッシュできないことが多いでしょう。
一方、同一リポジトリからのプルリクエストの場合は、どちらもお互いに、もう一方のブランチにプッシュできることが多くなります。両者の違いは、ただその一点だけです。</p>
<p>ここでは、あなたが “tonychacon” の立場にいて、Arduino のコードを管理する “fade” プロジェクトを作ったものとしましょう。</p>
<section class="sect3" title="メールでの通知">
<h4 id="r_email_notifications">メールでの通知</h4>
<p>あなたのプロジェクトを見つけた誰かが、コードに手を加えてプルリクエストを送ってきました。
このときあなたは、<a id="xref-r_email_pr" href="#r_email_pr" class="xref">プルリクエストのメールでの通知</a> のような通知メールを受け取るはずです。</p>
<figure id="r_email_pr" class="image">
<div class="content">
<img src="images/maint-01-email.png" alt="プルリクエストのメールでの通知"/>
</div>
<figcaption>Figure 34. プルリクエストのメールでの通知</figcaption>
</figure>
<p>このメールの通知の内容を見てみましょう。
まず差分の簡単な状況（このプルリクエストで変更されたファイルの一覧と、どの程度変更されたのか）がわかります。
また、GitHub 上のプルリクエストのページへのリンクがあります。
さらに、コマンドラインから使えるいくつかの URL も挙げられています。</p>
<p><code class="literal">git pull &lt;url&gt; patch-1</code> と書いてある行に注目しましょう。
このようにすれば、リモートを追加しなくても、このブランチをマージできます。
この件については、<a id="xref--ch05-distributed-git--r_checking_out_remotes" href="ch05-distributed-git.xhtml#r_checking_out_remotes" class="xref">リモートブランチのチェックアウト</a> で簡単に紹介しました。
もしお望みなら、トピックブランチを作ってそこに移動し、そしてこのコマンドを実行すれば、プルリクエストの変更をマージできます。</p>
<p>さらに、<code class="literal">.diff</code> と <code class="literal">.patch</code> の URL も記載されています。
拡張子から想像できるとおり、これらはそれぞれ、このプルリクエストの unified diff とパッチを取得するための URL です。
技術的には、たとえば以下のようにすれば、このプルリクエストをマージできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl http://github.com/tonychacon/fade/pull/1.patch | git am</code></pre>
</figure>
</section>
<section class="sect3" title="プルリクエスト上での共同作業">
<h4 id="_プルリクエスト上での共同作業">プルリクエスト上での共同作業</h4>
<p><a id="xref-r_github_flow" href="#r_github_flow" class="xref">GitHub Flow</a> で説明したとおり、プルリクエストの作者とのやりとりができるようになりました。
コードの特定の行にコメントをしたり、コミット全体やプルリクエストそのものに対してコメントしたりすることができ、
その際には GitHub Flavored Markdown が使えます。</p>
<p>プルリクエストに対して誰かがコメントするたびに通知メールが届くので、何らかの動きがあったことを知ることができます。
そのメールには、動きがあったプルリクエストへのリンクが含まれています。そして、通知メールに直接返信すれば、そのプルリクエストのスレッドにコメントをすることができます。</p>
<figure class="image">
<div class="content">
<img src="images/maint-03-email-resp.png" alt="メールでの返信"/>
</div>
<figcaption>Figure 35. メールでの返信が、スレッドに含まれる</figcaption>
</figure>
<p>コードが望みどおりの状態になり、取り込みたいと思えるようになったら、ローカルにそのコードを取得してマージできます。先述の <code class="literal">git pull &lt;url&gt; &lt;branch&gt;</code> 構文を使ってもいいし、
そのフォークをリモートとして追加した上で、フェッチしてからマージしてもいいでしょう。</p>
<p>もし特別な作業をせずにマージできる状態なら、GitHub のサイト上で単に “Merge” ボタンを押すだけでマージを済ませることもできます。
このボタンを押すと “non-fast-forward” マージを行います。つまり、fast-forward マージが可能な場合でも、強制的にマージコミットを作ります。
要するに、どんな場合であっても、マージボタンを押したらマージコミットが作られるということです。
<a id="xref-r_merge_button" href="#r_merge_button" class="xref">マージボタンと、プルリクエストを手動でマージするための手順</a> にあるとおり、ヒントのリンクをクリックすれば、GitHub がこれらの情報をすべて教えてくれます。</p>
<figure id="r_merge_button" class="image">
<div class="content">
<img src="images/maint-02-merge.png" alt="マージボタン"/>
</div>
<figcaption>Figure 36. マージボタンと、プルリクエストを手動でマージするための手順</figcaption>
</figure>
<p>マージしたくないと思った場合は、単にそのプルリクエストをクローズするだけでかまいません。プルリクエストの作者には、その旨通知が届きます。</p>
</section>
<section class="sect3" title="プルリクエストの参照">
<h4 id="r_pr_refs">プルリクエストの参照</h4>
<p><strong>大量の</strong> プルリクエストを扱っていて、取り込むたびにいちいちリモートを追加するのが面倒な場合は、
GitHub が提供するちょっとしたトリックを使えます。
これは高度な話題なので、その詳細は <a id="xref--ch10-git-internals--r_refspec" href="ch10-git-internals.xhtml#r_refspec" class="xref">Refspec</a> であらためて取り上げます。ただ、これはとても便利です。</p>
<p>GitHub は、個々のプルリクエストのブランチを、サーバー上で擬似ブランチとして公開しています。
クローンするときに、デフォルトでは取り込まれませんが、目立たないところに存在していて、簡単にアクセスできます。</p>
<p>その様子を示すために、ここでは、下位レベルのコマンド (「配管」コマンド) である <code class="literal">ls-remote</code> を使います。
このコマンドを日々の Git の操作で使うことはあまりありませんが、サーバー上に何があるのかを見るためには便利です。</p>
<p>先ほどの “blink” リポジトリに対してこのコマンドを実行すると、すべてのブランチやタグ、そしてその他の参照の一覧を取得できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge</code></pre>
</figure>
<p>もちろん、自分のリポジトリにいるときに <code class="literal">git ls-remote origin</code> のようにリモートを指定すると、これと同じような結果が得られるでしょう。</p>
<p>GitHub 上にあるリポジトリで、オープン中のプルリクエストがある場合は、
プルリクエストへの参照も表示されます。これらの参照は、先頭が <code class="literal">refs/pull/</code> となります。
基本的にはブランチですが、<code class="literal">refs/heads/</code> の配下にあるわけではないので、通常のクローンやフェッチで取得することはできません。
フェッチの際には通常、これらのブランチを無視します。</p>
<p>ひとつのプルリクエストにつき、二つの参照が表示されています。
一方は <code class="literal">/head</code> で終わるもので、これは、そのプルリクエストのブランチの最新のコミットを指しています。
誰かが私たちのリポジトリにプルリクエストを送ってきたとして、仮にそのブランチ名が <code class="literal">bug-fix</code> で参照先のコミットが <code class="literal">a5a775</code> だったとしましょう。
<strong>私たちの</strong> リポジトリには <code class="literal">bug-fix</code> ブランチがありません (彼らのフォーク上にしかありません) が、
<code class="literal">pull/&lt;pr#&gt;/head</code> が <code class="literal">a5a775</code> を指すようになるのです。
つまり、大量にリモートを追加したりしなくても、あらゆるプルリクエストのブランチをコマンドひとつで手元に取り込めるのです。</p>
<p>この参照を直接指定して、以下のようにフェッチすることができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -&gt; FETCH_HEAD</code></pre>
</figure>
<p>このコマンドは Git に対して、「リモート <code class="literal">origin</code> に接続して、<code class="literal">refs/pull/958/head</code> をダウンロードしなさい」という指示を出します。
Git はその指示に従い、必要なものをすべてダウンロードして、あなたが必要とするコミットへのポインタを <code class="literal">.git/FETCH_HEAD</code> に置きます。
これを <code class="literal">git merge FETCH_HEAD</code> で自分のブランチに取り込んで試すこともできますが、マージコミットのメッセージは少しわかりにくくなります。
また、<strong>大量の</strong> プルリクエストを処理するときには、この作業は退屈でしょう。</p>
<p><em>すべての</em> プルリクエストを取得して、リモートに接続するたびに最新の状態を保つようにする方法もあります。
<code class="literal">.git/config</code> をお好みのエディタで開いて、リモート <code class="literal">origin</code> の記載を探しましょう。
きっと、このようになっているはずです。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
    url = <span style="font-style: italic">https://github.com/libgit2/libgit2</span>
<span style="font-style: italic">    fetch = +refs/heads/*:refs/remotes/origin/*</span></code></pre>
</figure>
<p><code class="literal">fetch =</code> で始まっている行が、“refspec” です。
ここで、リモートでの名前とローカルの <code class="literal">.git</code> ディレクトリ内での名前のマッピングができます。
この例では、Git に対して「リモートの <code class="literal">refs/heads</code> 配下にあるものを、ローカルのリポジトリ内では <code class="literal">refs/remotes/origin</code> 配下に置くこと」と指示しています。
このセクションを書き換えて、別の refspec を追加できます。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[remote &quot;origin&quot;]</span>
    url = <span style="font-style: italic">https://github.com/libgit2/libgit2.git</span>
<span style="font-style: italic">    fetch = +refs/heads/*:refs/remotes/origin/*</span>
<span style="font-style: italic">    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</span></code></pre>
</figure>
<p>最後のに追加した行は、「<code class="literal">refs/pull/123/head</code> のような参照はすべて、ローカルでは <code class="literal">refs/remotes/origin/pr/123</code> のように保存すること」という意味です。
さて、このファイルを保存したら、<code class="literal">git fetch</code> を実行してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
<span style="font-weight: bold">#</span> …
 * [new ref]         refs/pull/1/head -&gt; origin/pr/1
 * [new ref]         refs/pull/2/head -&gt; origin/pr/2
 * [new ref]         refs/pull/4/head -&gt; origin/pr/4
<span style="font-weight: bold">#</span> …</code></pre>
</figure>
<p>リモートのすべてのプルリクエストが、ローカルでも、まるで追跡ブランチであるかのように表されるようになりました。
これらのブランチは読み込み専用で、フェッチするたびに更新されます。
これで、プルリクエストのコードをローカルで簡単に試せるようになりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch &#39;pr/2&#39;</code></pre>
</figure>
<p>リモート側の refspec の最後に <code class="literal">head</code> と表示されていることに、目ざとい人なら気づいたかもしれません。
GitHub 上には、これだけではなく <code class="literal">refs/pull/#/merge</code> という参照もあります。
これは、サイト上で「マージ」ボタンを押したときに作られるコミットを指す参照です。
これを使えば、マージしたらどうなるかを、ボタンを押す前に確かめることができるのです。</p>
</section>
<section class="sect3" title="プルリクエスト上でのプルリクエスト">
<h4 id="_プルリクエスト上でのプルリクエスト">プルリクエスト上でのプルリクエスト</h4>
<p>別に、プルリクエストの対象がメインブランチ (<code class="literal">master</code> ブランチ) でなければいけないなどという決まりはありません。
ネットワーク上にあるあらゆるブランチに対して、プルリクエストを作ることができます。
別のプルリクエストに対して、プルリクエストを送ることだってできるのです。</p>
<p>正しい方向に進みつつあるプルリクエストに対して、それを元にした新たな変更のアイデアが浮かんだ場合や、
単にそのプルリクエストの対象ブランチへのプッシュ権限がない場合などに、
プルリクエストに対するプルリクエストを作ることができます。</p>
<p>プルリクエストを作る際に、ページの上のほうに二つの入力欄があることがわかります。
それぞれ、どのブランチに対するリクエストなのかと、どのブランチからプルしてほしいのかを指定する欄です。
この欄の右側にある「編集」ボタンを押すと、ブランチ名だけではなく、どのフォークを使うのかも変更できます。</p>
<figure id="r_pr_targets" class="image">
<div class="content">
<img src="images/maint-04-target.png" alt="PRの対象"/>
</div>
<figcaption>Figure 37. プルリクエストの対象となるフォークとブランチを手動で変更する</figcaption>
</figure>
<p>これを使えば、あなたのブランチを別のプルリクエストにマージするよう指定したり、そのプロジェクトの別のフォークへのマージ依頼を出したりするのも簡単です。</p>
</section>
</section>
<section class="sect2" title="言及と通知">
<h3 id="_言及と通知">言及と通知</h3>
<p>GitHub には、よくできた通知システムも組み込まれています。特定の人やチームに質問をしたり、何かのフィードバックが必要だったりする場合に便利です。</p>
<p>コメントの記入時に <code class="literal">@</code> を入力すると、自動補完が始まります。
そのプロジェクトの Collaborator や、これまでの貢献者たちの、名前やユーザー名を補完できます。</p>
<figure class="image">
<div class="content">
<img src="images/maint-05-mentions.png" alt="言及"/>
</div>
<figcaption>Figure 38. 誰かについて言及するには、@ を入力する</figcaption>
</figure>
<p>このドロップダウンに登場しないユーザーについても言及できますが、
通常は、この自動補完を使ったほうがずっとお手軽でしょう。</p>
<p>コメントの中でユーザーについて言及すると、そのユーザーに通知が届きます。
他の人を議論に巻き込みたいときに、これをうまく活用できるでしょう。
GitHub 上のプルリクエストでは、チームや社内の他のメンバーを巻き込んだレビューが行われることも、珍しくありません。</p>
<p>プルリクエストや Issue の中で言及された人は、自動的にそれを「購読した」状態になり、
何らかのアクションがあるたびに通知が届くことになります。
また、自分がウォッチしていたり、何かのコメントをしたりしたことがあるリポジトリに対してプルリクエストや Issue を作った場合も、
あなたはそれを自動的に「購読した」ことになります。
その通知を受け取りたくなくなった場合は、ページ上にある “Unsubscribe” ボタンをクリックすると、更新の通知が届かないようになります。</p>
<figure class="image">
<div class="content">
<img src="images/maint-06-unsubscribe.png" alt="購読解除"/>
</div>
<figcaption>Figure 39. Issue やプルリクエストの購読の解除</figcaption>
</figure>
<section class="sect3" title="通知ページ">
<h4 id="_通知ページ">通知ページ</h4>
<p>GitHub に関する話題で「通知」と言ったときには、それは、
何かの出来事が起こったときに GitHub が私たちにそれを伝える手段のことを指します。
どのように通知を受け取るのかについては、いくつか設定できる項目があります。
設定ページの “Notification center” タブに移動すると、設定可能な選択肢を確認できるでしょう。</p>
<figure class="image">
<div class="content">
<img src="images/maint-07-notifications.png" alt="通知センター"/>
</div>
<figcaption>Figure 40. 通知センターのオプション</figcaption>
</figure>
<p>通知の受け取りかたを、「メールで受け取る」のか「Webで受け取る」のか (あるいはその両方で受け取るのか、どちらでも受け取らないのか) を、
自分がかかわっているものについてと自分がウォッチしているリポジトリについてとで、それぞれ選べます。</p>
<section class="sect4" title="Web での通知">
<h5 id="_web_での通知">Web での通知</h5>
<p>Web での通知は GitHub 上でだけ行われるもので、GitHub のサイトに行かないと確認できません。
このオプションを選んだ場合、あなたに届いた通知は、画面上部の通知アイコンに青い点として表示されて、
<a id="xref-r_not_center" href="#r_not_center" class="xref">通知センター</a> のようになります。</p>
<figure id="r_not_center" class="image">
<div class="content">
<img src="images/maint-08-notifications-page.png" alt="通知センター"/>
</div>
<figcaption>Figure 41. 通知センター</figcaption>
</figure>
<p>これをクリックすると、通知の一覧が、プロジェクトごとにまとまった形式で表示されます。
特定のプロジェクトの通知だけに絞り込むには、左側のサイドバーにあるプロジェクト名をクリックしましょう。
通知の受け取り確認をするには、個々の通知の隣にあるチェックマークをクリックします。
または、プロジェクトごとのグループのプロジェクト名のところにあるチェックマークをクリックすると、そのプロジェクトの <em>すべての</em> 通知を確認済みにできます。
チェックマークの隣にあるのがミュートボタンで、これをクリックすると、その件に関する通知が今後届かなくなります。</p>
<p>これらをうまく活用すれば、通知が大量に届いても、うまくさばくことができます。
GitHub のパワーユーザーの多くは、メールでの通知を完全にオフにしてしまって、通知はすべてこの画面だけで管理しているようです。</p>
</section>
<section class="sect4" title="メールでの通知">
<h5 id="_メールでの通知">メールでの通知</h5>
<p>メールでの通知を使って、GitHub からの通知を処理することもできます。
この機能を有効にしておくと、さまざまな通知をメールで受け取れるようになります。
その例を <a id="xref-r_email_notification" href="#r_email_notification" class="xref">通知メールで送られたコメント</a> と <a href="#r_email_pr" class="xref">プルリクエストのメールでの通知</a> に示します。
メールのスレッド機能にも対応しているので、スレッド対応のメールソフトを使えば適切に表示できることでしょう。</p>
<p>GitHub が送るメールのヘッダーには、さまざまなメタデータが埋め込まれています。
これらを使えば、フィルタリングやフォルダ分けの設定も簡単に行えます。</p>
<p><a href="#r_email_pr" class="xref">プルリクエストのメールでの通知</a> に示す、Tony に送られたメールのヘッダーには、このような情報が含まれています。</p>
<figure class="listing">
<pre class="source language-mbox"><code><span></span>To: tonychacon/fade &lt;fade@noreply.github.com&gt;
Message-ID: &lt;tonychacon/fade/pull/1@github.com&gt;
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade &lt;fade.tonychacon.github.com&gt;
List-Archive: https://github.com/tonychacon/fade
List-Post: &lt;mailto:reply+i-4XXX@reply.github.com&gt;
List-Unsubscribe: &lt;mailto:unsub+i-XXX@reply.github.com&gt;,...
X-GitHub-Recipient-Address: tchacon@example.com</code></pre>
</figure>
<p>いろいろ興味深い内容が含まれていることがわかるでしょう。
特定のプロジェクト、あるいは特定のプルリクエストに関するメールを強調したり転送したりしたければ、
<code class="literal">Message-ID</code> を利用できます。これは <code class="literal">&lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt;</code> 形式になっています。
もしこれば issue に関する通知なら、<code class="literal">&lt;type&gt;</code> の部分が “pull” ではなく “issues” になります。</p>
<p><code class="literal">List-Post</code> や <code class="literal">List-Unsubscribe</code> フィールドを解釈できるメールソフトを使っている場合は、
そのスレッドへの投稿やスレッドからの「脱退」(通知を受け取らないようにすること) を簡単に行えます。
スレッドからの脱退とは、Web の通知画面でミュートボタンを押したり、Issue やプルリクエストのページで “Unsubscribe” をクリックしたりするのと同じことです。</p>
<p>メールと Web の両方で通知を受け取っている場合は、メールでの通知を読んだ時点で、Web 版の通知も既読になります。
ただし、お使いのメールソフトでメール本文中の画像の表示を許可している場合に限ります。</p>
</section>
</section>
</section>
<section class="sect2" title="特別なファイル">
<h3 id="_特別なファイル">特別なファイル</h3>
<p>以下の名前のファイルがリポジトリ内にあった場合、GitHub はそれを特別扱いします。</p>
</section>
<section class="sect2" title="README">
<h3 id="_readme">README</h3>
<p>特別扱いする最初のファイルは <code class="literal">README</code> です。ほとんどのファイル形式について、GitHub 自身がそのフォーマットを解釈します。
たとえば <code class="literal">README</code>、<code class="literal">README.md</code>、<code class="literal">README.asciidoc</code> などが使えます。
README ファイルを発見すると、GitHub はそれをレンダリングして、プロジェクトのトップページに表示します。</p>
<p>多くのチームは、このファイルを使って、プロジェクトに関する情報をまとめています。
そのリポジトリやプロジェクトに初めて参加する人たち向けの情報を含めているのです。たとえば以下のような内容です。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">そのプロジェクトの目的</span>
</li>
<li>
<span class="principal">インストール手順</span>
</li>
<li>
<span class="principal">利用例や、動作させるための手順</span>
</li>
<li>
<span class="principal">そのプロジェクトのライセンス情報</span>
</li>
<li>
<span class="principal">プロジェクトに参加する方法</span>
</li>
</ul>
</div>
<p>GitHub がこのファイルをレンダリングしてくれるので、画像やリンクを追加したりして、わかりやすい説明を書くことができます。</p>
</section>
<section class="sect2" title="CONTRIBUTING">
<h3 id="_contributing">CONTRIBUTING</h3>
<p>GitHub は、<code class="literal">CONTRIBUTING</code> も特別扱いするファイルとして認識します。
<code class="literal">CONTRIBUTING</code> という名前 (拡張子は何でもかまいません) のファイルを用意すると、
誰かがプルリクエストを作ろうとしたときに、GitHub がその内容を <a id="xref-r_contrib_file" href="#r_contrib_file" class="xref">CONTRIBUTING ファイルが存在するプロジェクトへのプルリクエスト</a> のように表示します。</p>
<figure id="r_contrib_file" class="image">
<div class="content">
<img src="images/maint-09-contrib.png" alt="協力にあたっての注意"/>
</div>
<figcaption>Figure 42. CONTRIBUTING ファイルが存在するプロジェクトへのプルリクエスト</figcaption>
</figure>
<p>このファイルには、プロジェクトへのプルリクエストを送る際に気をつけてほしいこと
(あるいは、してほしくないこと) などを書いておくといいでしょう。
プルリクエストを作ろうとした人は、このガイドラインを見ることになります。</p>
</section>
<section class="sect2" title="プロジェクトの管理">
<h3 id="_プロジェクトの管理">プロジェクトの管理</h3>
<p>実際のところ、単独のプロジェクトについての管理操作は、そんなに多くはありません。
しかし、中には皆さんの興味をひくものもあることでしょう。</p>
<section class="sect3" title="デフォルトブランチの変更">
<h4 id="_デフォルトブランチの変更">デフォルトブランチの変更</h4>
<p>“master” 以外のブランチをデフォルトにして、他の人たちからのプルリクエストのデフォルトの送り先をそこにすることができます。
デフォルトブランチを変更するには、“Options” タブの中にある設定ページを使います。</p>
<figure id="r_default_branch" class="image">
<div class="content">
<img src="images/maint-10-default-branch.png" alt="デフォルトブランチ"/>
</div>
<figcaption>Figure 43. プロジェクトのデフォルトブランチの変更</figcaption>
</figure>
<p>ドロップダウンでブランチを変更すれば、それが主要な操作のデフォルトの対象となります。
誰かがそのリポジトリをクローンしたときに、デフォルトでチェックアウトされるのも、このブランチです。</p>
</section>
<section class="sect3" title="プロジェクトの移管">
<h4 id="_プロジェクトの移管">プロジェクトの移管</h4>
<p>GitHub 上で、別のユーザーや組織にプロジェクトを移管したい場合に使えるのが、
同じくリポジトリの設定ページの “Options” タブの一番下にある “Transfer ownership” 欄です。</p>
<figure id="r_transfer_project" class="image">
<div class="content">
<img src="images/maint-11-transfer.png" alt="移管"/>
</div>
<figcaption>Figure 44. 別の GitHub ユーザーや組織への、プロジェクトの移管</figcaption>
</figure>
<p>自分のリポジトリを手放して他の誰かに運営してもらう場合や、プロジェクトが成長したこともあって個人管理から組織での管理に移行したい場合などに使えます。</p>
<p>これは、リポジトリそのものだけではなく、そのリポジトリをウォッチしたり、スターを付けたりしている人の情報も含めて移行します。
さらに、移管前の URL から新しい URL へのリダイレクトの設定も行われます。
もちろん、Web のリクエストに限らず、Git のクローンやフェッチのリクエストもリダイレクトされます。</p>
</section>
</section>
</section>
<section class="sect1" title="組織の管理">
<h2 id="r_github_orgs">組織の管理</h2>
<p></p>
<p>GitHub には、個人ユーザー用のアカウント以外にも、組織 (Organization) 用アカウントが用意されています。
個人アカウントと同様に組織アカウントでも、その名前空間にプロジェクトを持つことができます。
しかし、それ以外の点では異なるところが多数あります。
組織アカウントは、複数の人たちによるプロジェクトの共同所有を表すもので、
さらにその内部でのグループ管理をするための、さまざまなツールが用意されています。
組織アカウントは一般に、オープンソースのグループ (“perl” や “rails” など)
や、一般企業 (“google” や “twitter” など) が使うものです。</p>
<section class="sect2" title="組織についての基本">
<h3 id="_組織についての基本">組織についての基本</h3>
<p>組織アカウントの作成はきわめて簡単です。GitHub 上のすべてのページの右上にある “+”
アイコンをクリックして、メニューから “New organization” を選びましょう。</p>
<figure class="image">
<div class="content">
<img src="images/neworg.png" alt="``New organization'' メニュー"/>
</div>
<figcaption>Figure 45. “New organization” メニュー</figcaption>
</figure>
<p>まず必要になるのが、組織名と、そのグループの連絡先となるメールアドレスです。
もし望むなら、他のユーザーを、共同オーナーとしてこのアカウントに招待することもできます。</p>
<p>この手順に従えば、新しい組織のオーナーになれます。
個人アカウントと同様、組織アカウントも、すべてのプロジェクトをオープンソースにするのであれば無料で使えます。</p>
<p>組織のオーナーであるあなたが何かのプロジェクトをフォークするときには、個人の名前空間にフォークするのか組織の名前空間にフォークするのかを選べるようになります。
新しいプロジェクトを作るときにも同様に、個人アカウントの配下に作るのか組織の配下に作るのかを選べます。
また、組織の配下に作ったリポジトリは、自動的に、個人アカウントからの “ウォッチ” の対象になります。</p>
<p><a id="xref-r_personal_avatar" href="#r_personal_avatar" class="xref">アバター</a> と同様に、組織アカウントにもアバターを設定できるようになっています。
さらに、個人アカウントと同様のランディングページも用意されています。
その組織アカウントが抱えるリポジトリの一覧を、他の人にも見てもらえることでしょう。</p>
<p>さて、ここから先は、個人アカウントとは異なる組織アカウント独特の内容について、説明しましょう。</p>
</section>
<section class="sect2" title="チーム">
<h3 id="_チーム">チーム</h3>
<p>組織アカウントの中では、個々のメンバーをチームとして関連付けることができます。
これは単に、個人ユーザーアカウントと組織内のリポジトリをとりまとめたものであり、
そのリポジトリに対するアクセス権の設定などを行います。</p>
<p>たとえば、あなたの所属する企業の組織アカウントに <code class="literal">frontend</code>、<code class="literal">backend</code>、<code class="literal">deployscripts</code> の三つのリポジトリがあるものとします。
HTML/CSS/Javascript の開発者たちには、<code class="literal">frontend</code> と、おそらくは <code class="literal">backend</code> についてもアクセスさせたいことでしょう。
一方、運用部門の人たちには、<code class="literal">backend</code> や <code class="literal">deployscripts</code> にアクセスできるようにしておきたいところです。
チーム機能を使えば、簡単に実現できます。リポジトリごとに Collaborators を管理する必要はありません。</p>
<p>組織アカウントにはシンプルなダッシュボードがあり、すべてのリポジトリやユーザーそしてチームの情報を確認できます。</p>
<figure id="r_org_page" class="image">
<div class="content">
<img src="images/orgs-01-page.png" alt="orgs 01 page"/>
</div>
<figcaption>Figure 46. 組織アカウントのページ</figcaption>
</figure>
<p>チームの管理作業を行うには、<a id="xref-r_org_page" href="#r_org_page" class="xref">組織アカウントのページ</a> のページ右側にあるサイドバー Teams をクリックします。
移動した先のページでは、チームにメンバーを追加したり、チームにリポジトリを追加したり、チームの設定やアクセス権を管理したりすることができます。
リポジトリに対するチームのアクセス権は、「読み込み限定」「読み書き可能」「管理者」の中から選べます。
この設定の切り替えは、<a id="xref-r_team_page" href="#r_team_page" class="xref">チームのページ</a> の “Settings” ボタンをクリックして行います。</p>
<figure id="r_team_page" class="image">
<div class="content">
<img src="images/orgs-02-teams.png" alt="orgs 02 teams"/>
</div>
<figcaption>Figure 47. チームのページ</figcaption>
</figure>
<p>誰かをチームに招待すると、チームに招待されたことを伝えるメールが、その人に届きます。</p>
<p>さらに、チームへの (<code class="literal">@acmecorp/frontend</code> のような) 言及も、個人アカウントへの言及と同じように機能します。
ただ、個人アカウントと違うところは、このように言及した場合は、チームの <strong>すべての</strong> メンバーが、そのスレッドを購読した状態になるという点です。
これは、そのチームに伝えたいことがある (が、誰に伝えればいいのかわからない) という場合に便利です。</p>
<p>一人のユーザーが複数のチームに属することもできるので、単なるアクセス制御以外の目的でチームを使うこともできます。
たとえば、<code class="literal">ux</code> や <code class="literal">css</code> あるいは <code class="literal">refactoring</code> などのようなチームを用意して、その手の質問に対応させることもできるでしょうし、
<code class="literal">legal</code> や <code class="literal">colorblind</code> など、まったく異なる種類のチームを作ることだってできます。</p>
</section>
<section class="sect2" title="監査ログ">
<h3 id="_監査ログ">監査ログ</h3>
<p>組織アカウントのオーナーは、その組織の配下で起こっていることについてのあらゆる情報を取得できます。
<em>Audit Log</em> タブを開くと、組織レベルで発生した出来事やそれを行った人、そしてそれを行った場所などを確認できます。</p>
<figure id="r_audit_log" class="image">
<div class="content">
<img src="images/orgs-03-audit.png" alt="orgs 03 audit"/>
</div>
<figcaption>Figure 48. 監査ログ</figcaption>
</figure>
<p>このログを、特定の出来事や場所、あるいはユーザーなどに絞って確認することもできます。</p>
</section>
</section>
<section class="sect1" title="スクリプトによる GitHub の操作">
<h2 id="_スクリプトによる_github_の操作">スクリプトによる GitHub の操作</h2>
<p>ここまでで、GitHub の主要な機能や作業の流れはすべて紹介し終えました。
しかし、大規模なグループやプロジェクトでは、もう少しカスタマイズしたり、外部のサービスを組み込んだりしたくなることもあるかもしれません。</p>
<p>GitHub は、そういったハックも簡単にできるようになっています。
ここでは、GitHub のフックシステムとその API の使いかたを説明します。GitHub の動きが望みどおりになるようにしてみましょう。</p>
<section class="sect2" title="フック">
<h3 id="_フック">フック</h3>
<p>GitHub のリポジトリのページ上にある Hooks や Services を利用すると、GitHub と外部のシステムとのやりとりを簡単に行えます。</p>
<section class="sect3" title="サービス">
<h4 id="_サービス">サービス</h4>
<p>まずはサービスから見てみましょう。
フックやサービスの統合は、どちらもリポジトリの設定画面から行えます。
先ほど Collaborator を追加したり、デフォルトのブランチを変更したりしたのと同じ画面です。
“Webhooks and Services” タブを開くと、<a id="xref-r_services_hooks" href="#r_services_hooks" class="xref">サービスとフックの設定画面</a> のような表示になるでしょう。</p>
<figure id="r_services_hooks" class="image">
<div class="content">
<img src="images/scripting-01-services.png" alt="サービスとフック"/>
</div>
<figcaption>Figure 49. サービスとフックの設定画面</figcaption>
</figure>
<p>何十種類ものサービスの中から、追加するサービスを選べます。そのほとんどが、他の商用システムやオープンソースシステムとの統合を行うものです。
継続的インテグレーションサービス、バグ (課題) 追跡システム、チャットシステム、ドキュメント作成システムなどと統合できます。
ここでは、シンプルなサービスの例として、メール送信機能を組み込む方法を示します。
“Add Service” のドロップダウンから “email” を選ぶと、<a id="xref-r_service_config" href="#r_service_config" class="xref">メールサービスの設定</a> のような設定画面が表示されます。</p>
<figure id="r_service_config" class="image">
<div class="content">
<img src="images/scripting-02-email-service.png" alt="メールサービス"/>
</div>
<figcaption>Figure 50. メールサービスの設定</figcaption>
</figure>
<p>ここで “Add service” ボタンを押すと、誰かがリポジトリにプッシュするたびに、指定したアドレスにメールが届くようになります。
サービスでは、プッシュ以外にもさまざまなイベントを待ち受けることができます。
しかし、大半のサービスは、プッシュイベントだけを待ち受けて、そのデータを使って何かをするというものです。</p>
<p>自分たちが使っているシステムを GitHub と統合したいという場合は、
まずここをチェックして、統合のためのサービスが用意されていないかどうかを確かめましょう。
たとえば Jenkins を使ってテストを実行している場合は、Jenkins のサービスを組み込めば、
誰かがプロジェクトにプッシュするたびにテストを実行できるようになります。</p>
</section>
<section class="sect3" title="フック">
<h4 id="_フック_2">フック</h4>
<p>もう少し細やかな処理をしたい場合や、統合したいサービスが一覧に含まれていない場合は、
より汎用的な機能であるフックシステムを使うことができます。
GitHub リポジトリのフック機能は、きわめてシンプルです。
URL を指定すると、何かのイベントが発生するたびに、GitHub がその URL に HTTP POST を行います。</p>
<p>この機能を使うには、GitHub のフック情報を含む投稿を待ち受けるちょっとした Web サービスを準備して、
受け取ったデータに対して何かの操作をさせればいいでしょう。</p>
<p>フックを有効にするには、<a href="#r_services_hooks" class="xref">サービスとフックの設定画面</a> で “Add webhook” ボタンを押します。すると、<a id="xref-r_web_hook" href="#r_web_hook" class="xref">Web フックの設定</a> のようなページに移動します。</p>
<figure id="r_web_hook" class="image">
<div class="content">
<img src="images/scripting-03-webhook.png" alt="Web フック"/>
</div>
<figcaption>Figure 51. Web フックの設定</figcaption>
</figure>
<p>設定項目は、このようにシンプルです。
たいていは、URL とシークレットキーを入力して “Add webhook” を押すだけで済むことでしょう。
どのイベントに対して GitHub から情報を送らせたいのかを選ぶこともできます。
デフォルトでは、<code class="literal">push</code> イベントの情報だけを送るようになっており、
誰かがどこかのブランチにプッシュするたびに、情報が送られます。</p>
<p>Web フックを処理するための、ちょっとした Web サービスの例を見てみましょう。
ここでは、Ruby のフレームワークである Sinatra を使いました。コードが簡潔で、何をやっているかがわかりやすいだろうからです。</p>
<p>特定のプロジェクトの特定のブランチ上にある特定のファイルへの変更を、特定の誰かがプッシュしたときにだけ、メールを送ろうとしています。
こんなコードを書けば、これを簡単に実現できます。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>require <span style="font-style: italic">&#39;sinatra&#39;</span>
require <span style="font-style: italic">&#39;json&#39;</span>
require <span style="font-style: italic">&#39;mail&#39;</span>

post <span style="font-style: italic">&#39;/payload&#39;</span> <span style="font-weight: bold">do</span>
  push = JSON.parse(request.body.read) <span style="font-style: italic"># JSONをパースする</span>

  <span style="font-style: italic"># 使いたいデータを収集する</span>
  pusher = push[<span style="font-style: italic">&quot;pusher&quot;</span>][<span style="font-style: italic">&quot;name&quot;</span>]
  branch = push[<span style="font-style: italic">&quot;ref&quot;</span>]

  <span style="font-style: italic"># 変更されたファイルの一覧を取得する</span>
  files = push[<span style="font-style: italic">&quot;commits&quot;</span>].map <span style="font-weight: bold">do</span> |commit|
    commit[<span style="font-style: italic">&#39;added&#39;</span>] + commit[<span style="font-style: italic">&#39;modified&#39;</span>] + commit[<span style="font-style: italic">&#39;removed&#39;</span>]
  <span style="font-weight: bold">end</span>
  files = files.flatten.uniq

  <span style="font-style: italic"># 条件をチェックする</span>
  <span style="font-weight: bold">if</span> pusher == <span style="font-style: italic">&#39;schacon&#39;</span> &amp;&amp;
     branch == <span style="font-style: italic">&#39;ref/heads/special-branch&#39;</span> &amp;&amp;
     files.include?(<span style="font-style: italic">&#39;special-file.txt&#39;</span>)

    Mail.deliver <span style="font-weight: bold">do</span>
      from     <span style="font-style: italic">&#39;tchacon@example.com&#39;</span>
      to       <span style="font-style: italic">&#39;tchacon@example.com&#39;</span>
      subject  <span style="font-style: italic">&#39;Scott Changed the File&#39;</span>
      body     <span style="font-style: italic">&quot;ALARM&quot;</span>
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>このコードは、GitHub から送られてくる JSON ペイロードを受け取って、
誰がどのブランチにプッシュしたのか、そしてそのコミットがどのファイルを変更したのかを調べています。
そして、条件を満たす変更であった場合に、メールを送信します。</p>
<p>この手のプログラムの開発やテストに使える、便利な開発コンソールが用意されています。これは、フックの設定と同じ画面から利用できます。
このコンソールには、GitHub がそのフックを使おうとした際の記録が、直近の数回ぶん残されています。
それぞれのフックについて、この記録をたどれば、成功したかどうかを調べたり、リクエストとレスポンスの内容を確認したりすることができます。
これを利用すれば、フックのテストやデバッグがとても楽になることでしょう。</p>
<figure id="r_web_hook_debug" class="image">
<div class="content">
<img src="images/scripting-04-webhook-debug.png" alt="Webhook のデバッグ"/>
</div>
<figcaption>Figure 52. Web フックのデバッグ情報</figcaption>
</figure>
<p>また、このコンソールからは、任意のペイロードをサービスに再送することもできます。</p>
<p>Web フックの書きかたや待ち受け可能なイベントなどの情報は、GitHub の開発者向けドキュメント
(<a href="https://developer.github.com/webhooks/" class="link">https://developer.github.com/webhooks/</a>) をご覧ください。</p>
</section>
</section>
<section class="sect2" title="GitHub API">
<h3 id="_github_api">GitHub API</h3>
<p></p>
<p>サービスやフックを使えば、リポジトリ上で発生したイベントについてのプッシュ通知を受け取ることができます。
しかし、そのイベントについて、さらに詳しい情報が知りたい場合はどうすればいいのでしょう？
Collaborator への追加や issue へのラベル付けなどを自動化したい場合は、どうすればいいのでしょう？</p>
<p>そんなときに使えるのが GitHub API です。
GitHub はさまざまな API エンドポイントを提供しており、Web サイト上でできることならほぼすべて、自動化できます。
ここでは、API の認証と接続の方法を学び、
さらに、issue にコメントしたりプルリクエストの状態を変更したりといった操作を、API を使って行います。</p>
</section>
<section class="sect2" title="基本的な使いかた">
<h3 id="_基本的な使いかた">基本的な使いかた</h3>
<p>一番基本的な使いかたは、認証が不要なエンドポイントへのシンプルな GET リクエストです。
ユーザーの情報や、オープンなプロジェクトの情報 (読み込みのみ) を取得できます。
たとえば、“schacon” というユーザーに関する情報を知りたければ、次のようにします。</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl https:<span style="font-style: italic">//api.github.com/users/schacon</span>
{
  <span style="font-style: italic">&quot;login&quot;</span>: <span style="font-style: italic">&quot;schacon&quot;</span>,
  <span style="font-style: italic">&quot;id&quot;</span>: 70,
  <span style="font-style: italic">&quot;avatar_url&quot;</span>: <span style="font-style: italic">&quot;https://avatars.githubusercontent.com/u/70&quot;</span>,
<span style="border: 1px solid #FF0000">#</span> <span style="border: 1px solid #FF0000">…</span>
  <span style="font-style: italic">&quot;name&quot;</span>: <span style="font-style: italic">&quot;Scott Chacon&quot;</span>,
  <span style="font-style: italic">&quot;company&quot;</span>: <span style="font-style: italic">&quot;GitHub&quot;</span>,
  <span style="font-style: italic">&quot;following&quot;</span>: 19,
  <span style="font-style: italic">&quot;created_at&quot;</span>: <span style="font-style: italic">&quot;2008-01-27T17:19:28Z&quot;</span>,
  <span style="font-style: italic">&quot;updated_at&quot;</span>: <span style="font-style: italic">&quot;2014-06-10T02:37:23Z&quot;</span>
}</code></pre>
</figure>
<p>このようなエンドポイントが山ほど用意されており、組織やプロジェクト、issue、コミットなどなど、GitHub 上で公開されているあらゆる情報を取得できます。
API を使って任意の Markdown をレンダリングしたり、<code class="literal">.gitignore</code> のテンプレートを探したりといったことすらできるのです。</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl https:<span style="font-style: italic">//api.github.com/gitignore/templates/Java</span>
{
  <span style="font-style: italic">&quot;name&quot;</span>: <span style="font-style: italic">&quot;Java&quot;</span>,
  <span style="font-style: italic">&quot;source&quot;</span>: <span style="font-style: italic">&quot;*.class</span>

<span style="font-style: italic"># Mobile Tools for Java (J2ME)</span>
<span style="font-style: italic">.mtj.tmp/</span>

<span style="font-style: italic"># Package Files #</span>
<span style="font-style: italic">*.jar</span>
<span style="font-style: italic">*.war</span>
<span style="font-style: italic">*.ear</span>

<span style="font-style: italic"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span>
<span style="font-style: italic">hs_err_pid*</span>
<span style="font-style: italic">&quot;</span>
}</code></pre>
</figure>
</section>
<section class="sect2" title="Issue へのコメント">
<h3 id="_issue_へのコメント">Issue へのコメント</h3>
<p>しかし、Issue やプルリクエストに対してコメントしたり、プライベートなコンテンツを操作したりしたい場合は、
認証が必要になります。</p>
<p>認証には、いくつかの方法があります。
ベーシック認証を使ってユーザー名とパスワードを渡すこともできますが、
通常は、アクセストークンを使うことをお勧めします。
アクセストークンは、自分のアカウントの設定ページの “Applications” タブから生成できます。</p>
<figure id="r_access_token" class="image">
<div class="content">
<img src="images/scripting-05-access-token.png" alt="アクセストークン"/>
</div>
<figcaption>Figure 53. 設定ページの “Applications” タブからの、アクセストークンの生成</figcaption>
</figure>
<p>ここでは、新しいトークンを利用するスコープや、そのトークンについての説明の入力を求められます。
わかりやすい説明を登録するようにしましょう。
そのトークンを使っているスクリプトやアプリケーションを利用しなくなったときに、どのトークンを破棄すればいいのかが、わかりやすくなります。</p>
<p>GitHub は、生成したトークンを一度だけしか表示しません。忘れずにコピーしましょう。
これを使えば、ユーザー名やパスワードを使わなくても、スクリプト内で認証できるようになります。
この方式の利点は、やりたいことにあわせてトークンのスコープを絞れることと、
不要になったトークンを破棄できることです。</p>
<p>さらに、利用制限を緩和できるというメリットもあります。
認証なしの場合は、一時間当たり60リクエストまでという制限がかかります。
認証を済ませると、この制限が、一時間当たり5,000リクエストまでに緩和されます。</p>
<p>では、API を使って issue にコメントをしてみましょう。
ここでは、Issue #6 にコメントします。
そのためには、<code class="literal">repos/&lt;user&gt;/&lt;repo&gt;/issues/&lt;num&gt;/comments</code> に対して HTTP POST リクエストを送ります。
その際に、先ほど生成したトークンを Authorization ヘッダに含めます。</p>
<figure class="listing">
<pre class="source language-javascript"><code><span></span>$ curl -H <span style="font-style: italic">&quot;Content-Type: application/json&quot;</span> \
       -H <span style="font-style: italic">&quot;Authorization: token TOKEN&quot;</span> \
       --data <span style="font-style: italic">&#39;{&quot;body&quot;:&quot;A new comment, :+1:&quot;}&#39;</span> \
       https:<span style="font-style: italic">//api.github.com/repos/schacon/blink/issues/6/comments</span>
{
  <span style="font-style: italic">&quot;id&quot;</span>: 58322100,
  <span style="font-style: italic">&quot;html_url&quot;</span>: <span style="font-style: italic">&quot;https://github.com/schacon/blink/issues/6#issuecomment-58322100&quot;</span>,
  ...
  <span style="font-style: italic">&quot;user&quot;</span>: {
    <span style="font-style: italic">&quot;login&quot;</span>: <span style="font-style: italic">&quot;tonychacon&quot;</span>,
    <span style="font-style: italic">&quot;id&quot;</span>: 7874698,
    <span style="font-style: italic">&quot;avatar_url&quot;</span>: <span style="font-style: italic">&quot;https://avatars.githubusercontent.com/u/7874698?v=2&quot;</span>,
    <span style="font-style: italic">&quot;type&quot;</span>: <span style="font-style: italic">&quot;User&quot;</span>,
  },
  <span style="font-style: italic">&quot;created_at&quot;</span>: <span style="font-style: italic">&quot;2014-10-08T07:48:19Z&quot;</span>,
  <span style="font-style: italic">&quot;updated_at&quot;</span>: <span style="font-style: italic">&quot;2014-10-08T07:48:19Z&quot;</span>,
  <span style="font-style: italic">&quot;body&quot;</span>: <span style="font-style: italic">&quot;A new comment, :+1:&quot;</span>
}</code></pre>
</figure>
<p>さて、実際にこの issue のページを開いてみると、<a id="xref-r_api_comment" href="#r_api_comment" class="xref">GitHub API を使って投稿したコメント</a> のようにコメントに成功していることがわかるでしょう。</p>
<figure id="r_api_comment" class="image">
<div class="content">
<img src="images/scripting-06-comment.png" alt="API によるコメント"/>
</div>
<figcaption>Figure 54. GitHub API を使って投稿したコメント</figcaption>
</figure>
<p>API を使えば、Web サイト上でできることならほぼすべて実行できます。
マイルストーンの作成や設定、Issue やプルリクエストの担当者の割り当て、ラベルの作成や変更、
コミット情報へのアクセス、新しいコミットやブランチの作成、
プルリクエストのオープン、クローズ、そしてマージ、
チームの作成や編集、
プルリクエストの特定の行へのコメント、
サイト内検索なども、API で行えます。</p>
</section>
<section class="sect2" title="プルリクエストのステータスの変更">
<h3 id="_プルリクエストのステータスの変更">プルリクエストのステータスの変更</h3>
<p>最後にもうひとつ、サンプルを見てみましょう。これは、プルリクエストに対応するときに、とても便利なものです。
各コミットには、ひとつあるいは複数のステータスを持たせることができるようになっています。
そして、API を使って、このステータスを追加したり、問い合わせたりすることができるのです。</p>
<p>継続的インテグレーションやテスティングのサービスの大半は、この API を使っています。
コードがプッシュされたらそのコードをテストして、そのコミットがすべてのテストをパスした場合は、結果報告を返したりしているのです。
同様に、コミットメッセージが適切な書式になっているかどうかを調べたり、
コードを貢献するときのガイドラインに沿っているかどうかを調べたり、
適切に署名されているかどうかを調べたり、さまざまなことを行えます。</p>
<p>ここでは、コミットメッセージに <code class="literal">Signed-off-by</code> という文字列が含まれているかどうかを調べるちょっとした Web サービスを、
リポジトリのフック機能で利用することを考えてみましょう。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>require <span style="font-style: italic">&#39;httparty&#39;</span>
require <span style="font-style: italic">&#39;sinatra&#39;</span>
require <span style="font-style: italic">&#39;json&#39;</span>

post <span style="font-style: italic">&#39;/payload&#39;</span> <span style="font-weight: bold">do</span>
  push = JSON.parse(request.body.read) <span style="font-style: italic"># JSONをパースする</span>
  repo_name = push[<span style="font-style: italic">&#39;repository&#39;</span>][<span style="font-style: italic">&#39;full_name&#39;</span>]

  <span style="font-style: italic"># コミットメッセージを調べる</span>
  push[<span style="font-style: italic">&quot;commits&quot;</span>].each <span style="font-weight: bold">do</span> |commit|

    <span style="font-style: italic"># 文字列 Signed-off-by を探す</span>
    <span style="font-weight: bold">if</span> <span style="font-style: italic">/Signed-off-by/</span>.match commit[<span style="font-style: italic">&#39;message&#39;</span>]
      state = <span style="font-style: italic">&#39;success&#39;</span>
      description = <span style="font-style: italic">&#39;Successfully signed off!&#39;</span>
    <span style="font-weight: bold">else</span>
      state = <span style="font-style: italic">&#39;failure&#39;</span>
      description = <span style="font-style: italic">&#39;No signoff found.&#39;</span>
    <span style="font-weight: bold">end</span>

    <span style="font-style: italic"># 状態を GitHub に投稿する</span>
    sha = commit[<span style="font-style: italic">&quot;id&quot;</span>]
    status_url = <span style="font-style: italic">&quot;https://api.github.com/repos/</span><span style="font-weight: bold; font-style: italic">#{</span>repo_name<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">/statuses/</span><span style="font-weight: bold; font-style: italic">#{</span>sha<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>

    status = {
      <span style="font-style: italic">&quot;state&quot;</span>       =&gt; state,
      <span style="font-style: italic">&quot;description&quot;</span> =&gt; description,
      <span style="font-style: italic">&quot;target_url&quot;</span>  =&gt; <span style="font-style: italic">&quot;http://example.com/how-to-signoff&quot;</span>,
      <span style="font-style: italic">&quot;context&quot;</span>     =&gt; <span style="font-style: italic">&quot;validate/signoff&quot;</span>
    }
    HTTParty.post(status_url,
      <span style="font-style: italic">:body</span> =&gt; status.to_json,
      <span style="font-style: italic">:headers</span> =&gt; {
        <span style="font-style: italic">&#39;Content-Type&#39;</span>  =&gt; <span style="font-style: italic">&#39;application/json&#39;</span>,
        <span style="font-style: italic">&#39;User-Agent&#39;</span>    =&gt; <span style="font-style: italic">&#39;tonychacon/signoff&#39;</span>,
        <span style="font-style: italic">&#39;Authorization&#39;</span> =&gt; <span style="font-style: italic">&quot;token </span><span style="font-weight: bold; font-style: italic">#{</span>ENV[<span style="font-style: italic">&#39;TOKEN&#39;</span>]<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span> }
    )
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>おそらく、何をやっているのかを追うのはそんなに難しくないかと思います。
この Web フックは、プッシュされたコミットについて、コミットメッセージに <em>Signed-off-by</em> という文字列が含まれるているかどうかを調べて、
API エンドポイント <code class="literal">/repos/&lt;user&gt;/&lt;repo&gt;/statuses/&lt;commit_sha&gt;</code> への HTTP POST でステータスを指定します。</p>
<p>ここで送信できる情報は、ステータス (<em>success</em>, <em>failure</em>, <em>error</em>) と説明文、詳細な情報を得るための URL、
そして単一のコミットに複数のステータスがある場合の “コンテキスト” です。
たとえば、テスティングサービスがステータスを送ることもあれば、このサンプルのようなバリデーションサービスがステータスを送ることもあります。
それらを区別するのが “context” フィールドです。</p>
<p>誰かが GitHub 上で新しいプルリクエストを作ったときに、もしこのフックを設定していれば、<a id="xref-r_commit_status" href="#r_commit_status" class="xref">API で設定したコミットのステータス</a> のようになるでしょう。</p>
<figure id="r_commit_status" class="image">
<div class="content">
<img src="images/scripting-07-status.png" alt="コミットのステータス"/>
</div>
<figcaption>Figure 55. API で設定したコミットのステータス</figcaption>
</figure>
<p>メッセージに “Signed-off-by” という文字列が含まれているコミットの隣にはグリーンのチェックマークが表示されています。
一方、作者が署名し忘れたコミットの隣には、赤い×印がついています。
また、そのプルリクエストの最新のコミットのステータスを見て、もし failure だったら警告を発しているということもわかります。
テストの結果を見てこの API を使うようにすると、とても便利です。テストが通らなかったコミットを、うっかりマージしてしまわずに済むでしょう。</p>
</section>
<section class="sect2" title="Octokit">
<h3 id="_octokit">Octokit</h3>
<p>ここまでほぼすべてのサンプルは、<code class="literal">curl</code> を使ったシンプルな HTTP リクエストだけで実現してきましたが、
オープンソースのライブラリを使えば、これらの API を、もっと慣用的な書きかたで使えるようになります。
本書の執筆時点では、Go や Objective-C、Ruby、そして .NET 用のライブラリが公開されています。
詳細は <a href="http://github.com/octokit" class="link">http://github.com/octokit</a> をご覧ください。HTTP がらみの大半を、あなたの代わりに処理してくれることでしょう。</p>
<p>これらのツールをうまく活用して GitHub をカスタマイズして、自分自身のワークフローにうまくあてはまるようにしてみましょう。
API の完全なドキュメントや、一般的な使いかたの指針は、 <a href="https://developer.github.com" class="link">https://developer.github.com</a> をご覧ください。</p>
</section>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ">まとめ</h2>
<p>これであなたも GitHub ユーザーです。
アカウントの作りかたもわかったし、
組織を管理したりリポジトリを作ったり、リポジトリにプッシュしたり、
他のプロジェクトに貢献したり、他のユーザーからの貢献を受け入れたりする方法も覚えました。
次の章では、さらに強力なツールやヒントについて学びます。
複雑な状況に対処できるようになり、本当の意味での Git の達人になれることでしょう。</p>
</section>
</section>
</body>
</html>