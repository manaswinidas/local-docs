<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git のさまざまなツール</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git のさまざまなツール" epub:type="chapter" id="ch07-git-tools">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>のさまざまなツール</b></small></h1>
</div>
</header>
<p>Git を使ったソースコード管理のためのリポジトリの管理や保守について、日々使用するコマンドやワークフローの大半を身につけました。
ファイルの追跡やコミットといった基本的なタスクをこなせるようになっただけではなくステージングエリアの威力もいかせるようになりました。また気軽にトピックブランチを切ってマージする方法も知りました。</p>
<p>では、Git の非常に強力な機能の数々をさらに探っていきましょう。日々の作業でこれらを使うことはあまりありませんが、いつかは必要になるかもしれません。</p>
<section class="sect1" title="リビジョンの選択">
<h2 id="r_revision_selection">リビジョンの選択</h2>
<p>Git で特定のコミットやコミットの範囲を指定するにはいくつかの方法があります。
明白なものばかりではありませんが、知っておくと役立つでしょう。</p>
<section class="sect2" title="単一のリビジョン">
<h3 id="_単一のリビジョン">単一のリビジョン</h3>
<p>SHA-1 ハッシュを指定すれば、コミットを明確に参照することができます。しかしそれ以外にも、より人間にやさしい方式でコミットを参照することもできます。
このセクションでは単一のコミットを参照するためのさまざまな方法の概要を説明します。</p>
</section>
<section class="sect2" title="SHA の短縮形">
<h3 id="_sha_の短縮形">SHA の短縮形</h3>
<p>Git は、最初の数文字をタイプしただけであなたがどのコミットを指定したいのかを汲み取ってくれます。条件は、SHA-1 の最初の 4 文字以上を入力していることと、それでひとつのコミットが特定できる (現在のリポジトリに、入力した文字ではじまる SHA-1 のコミットがひとつしかない) ことです。</p>
<p>あるコミットを指定するために <code class="literal">git log</code> コマンドを実行し、とある機能を追加したコミットを見つけました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff</code></pre>
</figure>
<p>探していたのは、<code class="literal">1c002dd....</code> で始まるコミットです。<code class="literal">git show</code> でこのコミットを見るときは、次のどのコマンドでも同じ結果になります (短いバージョンで、重複するコミットはないものとします)。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
<span style="font-weight: bold">$</span> git show 1c002dd4b536e7479f
<span style="font-weight: bold">$</span> git show 1c002d</code></pre>
</figure>
<p>一意に特定できる範囲での SHA-1 の短縮形を Git に見つけさせることもできます。
<code class="literal">git log</code> コマンドで <code class="literal">--abbrev-commit</code> を指定すると、コミットを一意に特定できる範囲の省略形で出力します。デフォルトでは 7 文字ぶん表示しますが、それだけで SHA-1 を特定できない場合はさらに長くなります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit</code></pre>
</figure>
<p>ひとつのプロジェクト内での一意性を確保するには、普通は 8 文字から 10 文字もあれば十分すぎることでしょう。</p>
<p>参考までに数字を挙げておきます。Linux カーネルはコミット数45万、オブジェクト数360万という巨大プロジェクトですが、SHA-1 の最初の12桁が同じになるオブジェクトは存在しません。</p>
<aside class="admonition note" title="Note: SHA-1 に関するちょっとしたメモ" epub:type="note">
<h2>SHA-1 に関するちょっとしたメモ</h2>
<div class="content">
<p>「リポジトリ内のふたつのオブジェクトがたまたま同じ SHA-1 ハッシュ値を持ってしまったらどうするの?」と心配する人も多いでしょう。
実際、どうなるのでしょう?</p>
<p>すでにリポジトリに存在するオブジェクトと同じ SHA-1 値を持つオブジェクトをコミットしてした場合、Git はすでにそのオブジェクトがデータベースに格納されているものと判断します。
そのオブジェクトを後からどこかで取得しようとすると、常に最初のオブジェクトのデータが手元にやってきます (訳注: つまり、後からコミットした内容は存在しないことになってしまう)。</p>
<p>しかし、そんなことはまず起こりえないということを知っておくべきでしょう。SHA-1 ダイジェストの大きさは 20 バイト (160 ビット) です。ランダムなハッシュ値がつけられた中で、たった一つの衝突が 50% の確率で発生するために必要なオブジェクトの数は約 2^80 となります
(衝突の可能性の計算式は <code class="literal">p = (n(n-1)/2) * (1/2^160)</code> です)。
2^80 は、ほぼ 1.2 x 10^24 、つまり一兆二千億のそのまた一兆倍です。
これは、地球上にあるすべての砂粒の数の千二百倍にあたります。</p>
<p>SHA-1 の衝突を見るにはどうしたらいいのか、ひとつの例をごらんに入れましょう。
地球上の人類 65 億人が全員プログラムを書いていたとします。そしてその全員が、Linux カーネルのこれまでの開発履歴 (360 万の Git オブジェクト) と同等のコードを一秒で書き上げ、馬鹿でかい単一の Git リポジトリにプッシュしていくとします。これを2年ほど続けると、SHA-1 オブジェクトの衝突がひとつでも発生する可能性がやっと 50% になります。
それよりも「あなたの所属する開発チームの全メンバーが、同じ夜にそれぞれまったく無関係の事件で全員オオカミに殺されてしまう」可能性のほうがよっぽど高いことでしょう。</p>
</div>
</aside>
</section>
<section class="sect2" title="ブランチの参照">
<h3 id="r_branch_references">ブランチの参照</h3>
<p>特定のコミットを参照するのに一番直感的なのは、そのコミットを指すブランチがある場合です。
コミットオブジェクトや SHA-1 値を指定する場面ではどこでも、その代わりにブランチ名を指定することができます。
たとえば、あるブランチ上の最新のコミットを表示したい場合は次のふたつのコマンドが同じ意味となります (<code class="literal">topic1</code> ブランチが <code class="literal">ca82a6d</code> を指しているものとします)。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show ca82a6dff817ec66f44342007202690a93763949
<span style="font-weight: bold">$</span> git show topic1</code></pre>
</figure>
<p>あるブランチがいったいどの SHA を指しているのか、あるいはその他の例の内容が結局のところどの SHA に行き着くのかといったことを知るには、Git の調査用ツールである <code class="literal">rev-parse</code> を使います。
こういった調査用ツールのより詳しい情報は <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Gitの内側</a> で説明します。<code class="literal">rev-parse</code> は低レベルでの操作用のコマンドであり、日々の操作で使うためのものではありません。
しかし、今実際に何が起こっているのかを知る必要があるときなどには便利です。
ブランチ上で <code class="literal">rev-parse</code> を実行すると、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</figure>
</section>
<section class="sect2" title="参照ログの短縮形">
<h3 id="r_git_reflog">参照ログの短縮形</h3>
<p>あなたがせっせと働いている間に Git が裏でこっそり行っていることのひとつが、“参照ログ” (reflog) の管理です。これは、HEAD とブランチの参照が過去数ヶ月間どのように動いてきたかをあらわすものです。</p>
<p>参照ログを見るには <code class="literal">git reflog</code> を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD</code></pre>
</figure>
<p>何らかの理由でブランチの先端が更新されるたびに、Git はその情報をこの一時履歴に格納します。そして、このデータを使って過去のコミットを指定することもできます。リポジトリの HEAD の五つ前の状態を知りたい場合は、先ほど見た reflog の出力のように <code class="literal">@{n}</code> 形式で参照することができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD@{5}</code></pre>
</figure>
<p>この構文を使うと、指定した期間だけさかのぼったときに特定のブランチがどこを指していたかを知ることもできます。
たとえば <code class="literal">master</code> ブランチの昨日の状態を知るには、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show master@{yesterday}</code></pre>
</figure>
<p>こうすると、そのブランチの先端が昨日どこを指していたかを表示します。
この技が使えるのは参照ログにデータが残っている間だけなので、直近数ヶ月よりも前のコミットについては使うことができません。</p>
<p>参照ログの情報を <code class="literal">git log</code> の出力風の表記で見るには <code class="literal">git log -g</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;</code></pre>
</figure>
<p>参照ログの情報は、完全にローカルなものであることに気をつけましょう。これは、あなた自身が自分のリポジトリで何をしたのかを示す記録です。
つまり、同じリポジトリをコピーした別の人の参照ログとは異なる内容になります。また、最初にリポジトリをクローンした直後の参照ログは空となります。まだリポジトリ上であなたが何もしていないからです。
<code class="literal">git show HEAD@{2.months.ago}</code> が動作するのは、少なくとも二ヶ月以上前にそのリポジトリをクローンした場合のみで、もしつい 5 分前にクローンしたばかりなら何も結果を返しません。</p>
</section>
<section class="sect2" title="家系の参照">
<h3 id="_家系の参照">家系の参照</h3>
<p>コミットを特定する方法として他によく使われるのが、その家系をたどっていく方法です。
参照の最後に <code class="literal">^</code> をつけると、Git はそれを「指定したコミットの親」と解釈します。
あなたのプロジェクトの歴史がこのようになっていたとしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&#39;%h %s&#39;</span> --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit &#39;phedders/rdocs&#39;
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list</code></pre>
</figure>
<p>直前のコミットを見るには <code class="literal">HEAD^</code> を指定します。これは “HEAD の親” という意味になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &#39;phedders/rdocs&#39;</code></pre>
</figure>
<p><code class="literal">^</code> の後に数字を指定することもできます。たとえば <code class="literal">d921970^2</code> は “d921970 の二番目の親” という意味になります。
これが役立つのはマージコミット (親が複数存在する) のときくらいでしょう。
最初の親はマージを実行したときにいたブランチとなり、二番目の親は取り込んだブランチ上のコミットとなります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

<span style="font-weight: bold">$</span> git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</code></pre>
</figure>
<p>家系の指定方法としてもうひとつよく使うのが <code class="literal">~</code> です。
これも最初の親を指します。つまり <code class="literal">HEAD~</code> と <code class="literal">HEAD^</code> は同じ意味になります。
違いが出るのは、数字を指定したときです。
<code class="literal">HEAD~2</code> は「最初の親の最初の親」、 つまり「祖父母」という意味になります。指定した数だけ、順に最初の親をさかのぼっていくことになります。
たとえば、先ほど示したような歴史上では <code class="literal">HEAD~3</code> は次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</figure>
<p>これは <code class="literal">HEAD^^^</code> のようにあらわすこともできます。これは「最初の親の最初の親の最初の親」という意味になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</figure>
<p>これらふたつの構文を組み合わせることもできます。直近の参照 (マージコミットだったとします) の二番目の親を取得するには <code class="literal">HEAD~3^2</code> などとすればいいのです。</p>
</section>
<section class="sect2" title="コミットの範囲指定">
<h3 id="r_commit_ranges">コミットの範囲指定</h3>
<p>個々のコミットを指定できるようになったので、次はコミットの範囲を指定する方法を覚えていきましょう。
これは、ブランチをマージするときに便利です。たくさんのブランチがある場合など、「で、このブランチの作業のなかでまだメインブランチにマージしていないのはどれだったっけ?」といった疑問を解決するために範囲指定を使えます。</p>
<section class="sect3" title="ダブルドット">
<h4 id="_ダブルドット">ダブルドット</h4>
<p>範囲指定の方法としてもっとも一般的なのが、ダブルドット構文です。
これは、ひとつのコミットからはたどれるけれどもうひとつのコミットからはたどれないというコミットの範囲を Git に調べさせるものです。
<a id="xref-rdouble_dot" href="#rdouble_dot" class="xref">範囲指定選択用の歴史の例</a> のようなコミット履歴を例に考えましょう。</p>
<figure id="rdouble_dot" class="image">
<div class="content">
<img src="images/double-dot.png" alt="範囲指定選択用の歴史の例"/>
</div>
<figcaption>Figure 1. 範囲指定選択用の歴史の例</figcaption>
</figure>
<p>experiment ブランチの内容のうち、まだ master ブランチにマージされていないものを調べることになりました。
対象となるコミットのログを見るには、Git に <code class="literal">master..experiment</code> と指示します。これは「experiment からはたどれるけれど、master からはたどれないすべてのコミット」という意味です。
説明を短く簡潔にするため、実際のログの出力のかわりに上の図の中でコミットオブジェクトをあらわす文字を使うことにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log master..experiment
D
C</code></pre>
</figure>
<p>もし逆に、<code class="literal">master</code> には存在するけれども <code class="literal">experiment</code> には存在しないすべてのコミットが知りたいのなら、ブランチ名を逆にすればいいのです。
<code class="literal">experiment..master</code> とすれば、<code class="literal">master</code> のすべてのコミットのうち <code class="literal">experiment</code> からたどれないものを取得できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log experiment..master
F
E</code></pre>
</figure>
<p>これは、<code class="literal">experiment</code> ブランチを最新の状態に保つために何をマージしなければならないのかを知るのに便利です。
もうひとつ、この構文をよく使う例としてあげられるのが、これからリモートにプッシュしようとしている内容を知りたいときです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log origin/master..HEAD</code></pre>
</figure>
<p>このコマンドは、現在のブランチ上でのコミットのうち、リモート <code class="literal">origin</code> の <code class="literal">master</code> ブランチに存在しないものをすべて表示します。
現在のブランチが <code class="literal">origin/master</code> を追跡しているときに <code class="literal">git push</code> を実行すると、<code class="literal">git log origin/master..HEAD</code> で表示されたコミットがサーバーに転送されます。
この構文で、どちらか片方を省略することもできます。その場合、Git は省略したほうを HEAD とみなします。
たとえば、<code class="literal">git log origin/master..</code> と入力すると先ほどの例と同じ結果が得られます。Git は、省略した側を HEAD に置き換えて処理を進めるのです。</p>
</section>
<section class="sect3" title="複数のポイント">
<h4 id="_複数のポイント">複数のポイント</h4>
<p>ダブルドット構文は、とりあえず使うぶんには便利です。しかし、二つよりもっと多くのブランチを指定してリビジョンを特定したいこともあるでしょう。複数のブランチの中から現在いるブランチには存在しないコミットを見つける場合などです。
Git でこれを行うには <code class="literal">^</code> 文字を使うか、あるいはそこからたどりつけるコミットが不要な参照の前に <code class="literal">--not</code> をつけます。
これら三つのコマンドは、同じ意味となります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log refA..refB
<span style="font-weight: bold">$</span> git log ^refA refB
<span style="font-weight: bold">$</span> git log refB --not refA</code></pre>
</figure>
<p>これらの構文が便利なのは、二つよりも多くの参照を使って指定できるというところです。ダブルドット構文では二つの参照しか指定できませんでした。
たとえば、<code class="literal">refA</code> と <code class="literal">refB</code> のどちらかからはたどれるけれども <code class="literal">refC</code> からはたどれないコミットを取得したい場合は、次のいずれかを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log refA refB ^refC
<span style="font-weight: bold">$</span> git log refA refB --not refC</code></pre>
</figure>
<p>この非常に強力なリビジョン問い合わせシステムを使えば、今あなたのブランチに何があるのかを知るのに非常に役立つことでしょう。</p>
</section>
<section class="sect3" title="トリプルドット">
<h4 id="r_triple_dot">トリプルドット</h4>
<p>範囲指定選択の主な構文であとひとつ残っているのがトリプルドット構文です。これは、ふたつの参照のうちどちらか一方からのみたどれるコミット (つまり、両方からたどれるコミットは含まない) を指定します。
<a href="#rdouble_dot" class="xref">範囲指定選択用の歴史の例</a> で示したコミット履歴の例を振り返ってみましょう。
<code class="literal">master</code> あるいは <code class="literal">experiment</code> に存在するコミットのうち、両方に存在するものを除いたコミットを知りたい場合は次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log master...experiment
F
E
D
C</code></pre>
</figure>
<p>これは通常の <code class="literal">log</code> の出力と同じですが、これら四つのコミットについての情報しか表示しません。表示順は、従来どおりコミット日時順となります。</p>
<p>この場合に <code class="literal">log</code> コマンドでよく使用するスイッチが <code class="literal">--left-right</code> です。このスイッチは、それぞれのコミットがどちら側に存在するのかを表示します。
これを使うとデータをより活用しやすくなるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --left-right master...experiment
&lt; F
&lt; E
<span style="font-weight: bold">&gt;</span> D
<span style="font-weight: bold">&gt;</span> C</code></pre>
</figure>
<p>これらのツールを使えば、より簡単に「どれを調べたいのか」を Git に伝えられるようになります。</p>
</section>
</section>
</section>
<section class="sect1" title="対話的なステージング">
<h2 id="r_interactive_staging">対話的なステージング</h2>
<p>Git には、コマンドラインでの作業をしやすくするためのスクリプトがいくつか付属しています。
ここでは、対話コマンドをいくつか紹介しましょう。これらを使うと、コミットの内容に細工をして特定のコミットだけとかファイルの中の一部だけとかを含めるようにすることが簡単にできるようになります。
大量のファイルを変更した後に、それをひとつの馬鹿でかいコミットにしてしまうのではなくテーマごとの複数のコミットに分けて処理したい場合などに非常に便利です。
このようにして各コミットを論理的に独立した状態にしておけば、同僚によるレビューも容易になります。
<code class="literal">git add</code> に <code class="literal">-i</code> あるいは <code class="literal">--interactive</code> というオプションをつけて実行すると、Git は対話シェルモードに移行し、このように表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt;</code></pre>
</figure>
<p>このコマンドは、ステージングエリアに関する情報を違った観点で表示します。<code class="literal">git status</code> で得られる情報と基本的には同じですが、より簡潔で有益なものとなっています。
ステージした変更が左側、そしてステージしていない変更が右側に表示されます。</p>
<p>Commands セクションでは、さまざまなことができるようになっています。
ファイルをステージしたりステージングエリアから戻したり、ファイルの一部だけをステージしたりまだ追跡されていないファイルを追加したり、あるいは何がステージされたのかを diff で見たりといったことが可能です。</p>
<p><code class="literal">What now&gt;</code> プロンプトで <code class="literal">2</code> または <code class="literal">u</code> と入力すると、どのファイルをステージするかを聞いてきます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>What now&gt; 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</code></pre>
</figure>
<p>TODO と index.html をステージするには、その番号を入力します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Update&gt;&gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</code></pre>
</figure>
<p>ファイル名の横に <code class="literal">*</code> がついていれば、そのファイルがステージ対象として選択されたことを意味します。
<code class="literal">Update&gt;&gt;</code> プロンプトで何も入力せずに Enter を押すと、選択されたすべてのファイルを Git がステージします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Update&gt;&gt;
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre>
</figure>
<p>TODO と index.html がステージされ、simplegit.rb はまだステージされていないままです。ここで仮に TODO ファイルのステージを取り消したくなったとしたら、<code class="literal">3</code> あるいは <code class="literal">r</code> (revert の r) を選択します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; [enter]
reverted one path</code></pre>
</figure>
<p>もう一度 Git のステータスを見ると、TODO ファイルのステージが取り消されていることがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre>
</figure>
<p>ステージした変更の diff を見るには、<code class="literal">6</code> あるいは <code class="literal">d</code> (diff の d) を使用します。
このコマンドは、ステージしたファイルの一覧を表示します。その中から、ステージされた diff を見たいファイルを選択します。
これは、コマンドラインで <code class="literal">git diff --cached</code> を使用するのと同じようなことです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&gt;&gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;

-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;
+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;

 &lt;script type=&quot;text/javascript&quot;&gt;</code></pre>
</figure>
<p>これらの基本的なコマンドを使えば、ステージングエリアでの対話的な追加モードを多少簡単に扱えるようになるでしょう。</p>
<section class="sect2" title="パッチのステージ">
<h3 id="_パッチのステージ">パッチのステージ</h3>
<p>Git では、ファイルの特定の箇所だけをステージして他の部分はそのままにしておくということもできます。
たとえば、simplegit.rb のふたつの部分を変更したけれど、そのうちの一方だけをステージしたいという場合があります。Git なら、そんなことも簡単です。
対話モードのプロンプトで <code class="literal">5</code> あるいは <code class="literal">p</code> (patch の p) と入力しましょう。
Git は、どのファイルを部分的にステージしたいのかを聞いてきます。その後、選択したファイルのそれぞれについて diff のハンクを順に表示し、ステージするかどうかをひとつひとつたずねます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log -n 25 #{treeish}&quot;)
+    command(&quot;git log -n 30 #{treeish}&quot;)
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</code></pre>
</figure>
<p>ここでは多くの選択肢があります。
何ができるのかを見るには <code class="literal">?</code> を入力しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help</code></pre>
</figure>
<p>たいていは、<code class="literal">y</code> か <code class="literal">n</code> で各ハンクをステージするかどうかを指定していくでしょう。しかし、それ以外にも「このファイルの残りのハンクをすべてステージする」とか「このハンクをステージするかどうかの判断を先送りする」などというオプションも便利です。
あるファイルのひとつの箇所だけをステージして残りはそのままにした場合、ステータスの出力はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb</code></pre>
</figure>
<p>simplegit.rb のステータスがおもしろいことになっています。
ステージされた行もあれば、ステージされていない行もあるという状態です。
つまり、このファイルを部分的にステージしたというわけです。
この時点で対話的追加モードを抜けて <code class="literal">git commit</code> を実行すると、ステージした部分だけをコミットすることができます。</p>
<p>ファイルを部分的にステージするだけなら、対話的な追加モードに入る必要すらありません。<code class="literal">git add -p</code> や <code class="literal">git add --patch</code> をコマンドラインから実行すれば、同じ機能を呼び出せます。</p>
<p>また、このパッチモードを使って、ファイルの一部分だけをリセットすることもできます。その場合のコマンドは <code class="literal">reset --patch</code> です。同様に、部分的なチェックアウトは <code class="literal">checkout --patch</code> コマンドを、部分的に退避するなら <code class="literal">stash save --patch</code> コマンドを使います。各コマンドの詳細は、より高度な使い方に触れるときに併せて紹介します。</p>
</section>
</section>
<section class="sect1" title="作業の隠しかたと消しかた">
<h2 id="r_git_stashing">作業の隠しかたと消しかた</h2>
<p>何らかのプロジェクトの一員として作業している場合にありがちなのですが、ある作業が中途半端な状態になっているときに、ブランチを切り替えてちょっとだけ別の作業をしたくなることがあります。
中途半端な状態をコミットしてしまうのはいやなので、できればコミットせずにしておいて後でその状態から作業を再開したいものです。
そんなときに使うのが <code class="literal">git stash</code> コマンドです。</p>
<p>これは、作業ディレクトリのダーティな状態 (追跡しているファイルのうち変更されたもの、そしてステージされた変更) を受け取って未完了の作業をスタックに格納し、あとで好きなときに再度それを適用できるようにするものです。</p>
<section class="sect2" title="自分の作業を隠す">
<h3 id="_自分の作業を隠す">自分の作業を隠す</h3>
<p>例を見てみましょう。自分のプロジェクトでいくつかのファイルを編集し、その中のひとつをステージしたとします。
ここで <code class="literal">git status</code> を実行すると、ダーティな状態を確認することができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   index.html

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   lib/simplegit.rb</code></pre>
</figure>
<p>ここで別のブランチに切り替えることになりましたが、現在の作業内容はまだコミットしたくありません。そこで、変更をいったん隠すことにします。
新たにスタックに隠すには <code class="literal">git stash</code> か <code class="literal">git stash save</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash
Saved working directory and index state \
  &quot;WIP on master: 049d078 added the index file&quot;
HEAD is now at 049d078 added the index file
(To restore them type &quot;git stash apply&quot;)</code></pre>
</figure>
<p>これで、作業ディレクトリはきれいな状態になりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
<span style="font-weight: bold">#</span> On branch master
nothing to commit, working directory clean</code></pre>
</figure>
<p>これで、簡単にブランチを切り替えて別の作業をできるようになりました。これまでの変更内容はスタックに格納されています。
今までに格納した内容を見るには <code class="literal">git stash list</code> を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert &quot;added file_size&quot;
stash@{2}: WIP on master: 21d80a5 added number to log</code></pre>
</figure>
<p>この例では、以前にも二回ほど作業を隠していたようです。そこで、三種類の異なる作業にアクセスできるようになっています。
先ほど隠した変更を再度適用するには、stash コマンドの出力に書かれていたように <code class="literal">git stash apply</code> コマンドを実行します。
それよりもっと前に隠したものを適用したい場合は <code class="literal">git stash apply stash@{2}</code> のようにして名前を指定することもできます。
名前を指定しなければ、Git は直近に隠された変更を再適用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash apply
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p>このコマンドによって、さきほど隠したファイルが元に戻ったことがわかるでしょう。
今回は、作業ディレクトリがきれいな状態で変更を書き戻しました。また、変更を隠したときと同じブランチに書き戻しています。しかし、隠した内容を再適用するためにこれらが必須条件であるというわけではありません。
あるブランチの変更を隠し、別のブランチに移動して移動先のブランチにそれを書き戻すこともできます。また、隠した変更を書き戻す際に、現在のブランチに未コミットの変更があってもかまいません。もしうまく書き戻せなかった場合は、マージ時のコンフリクトと同じようになります。</p>
<p>さて、ファイルへの変更はもとどおりになりましたが、以前にステージしていたファイルはステージされていません。
これを行うには、<code class="literal">git stash apply</code> コマンドに <code class="literal">--index</code> オプションをつけて実行し、変更のステージ処理も再適用するよう指示しなければなりません。
先ほどのコマンドのかわりにこれを実行すると、元の状態に戻ります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash apply --index
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   index.html

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   lib/simplegit.rb</code></pre>
</figure>
<p>apply オプションは、スタックに隠した作業を再度適用するだけで、スタックにはまだその作業が残ったままになります。
スタックから削除するには、<code class="literal">git stash drop</code> に削除したい作業の名前を指定して実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert &quot;added file_size&quot;
stash@{2}: WIP on master: 21d80a5 added number to log
<span style="font-weight: bold">$</span> git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</code></pre>
</figure>
<p>あるいは <code class="literal">git stash pop</code> を実行すれば、隠した内容を再適用してその後スタックからも削除してくれます。</p>
</section>
<section class="sect2" title="ファイルを隠す機能の応用">
<h3 id="_ファイルを隠す機能の応用">ファイルを隠す機能の応用</h3>
<p>ファイルの隠しかたは何パターンかあり、役立つものがあるかもしれません。まずひとつ目、<code class="literal">stash save</code> コマンドの <code class="literal">--keep-index</code> オプションです。これはよく使われているオプションで、<code class="literal">git add</code> コマンドでインデックスに追加した内容を隠したくないときに用います。</p>
<p>あれこれと変更したうちの一部だけをコミットして、残りは後ほど処置したい場合、この機能が役立つでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
M  index.html
 M lib/simplegit.rb

<span style="font-weight: bold">$</span> git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

<span style="font-weight: bold">$</span> git status -s
M  index.html</code></pre>
</figure>
<p>変更を隠すときの要望といえば、追跡しているファイルとそうでないファイルをどちらも一緒に隠してしまいたい、というのもあるでしょう。デフォルトでは、<code class="literal">git stash</code> コマンドが保存するのは追跡しているファイルだけです。けれど、<code class="literal">--include-untracked</code>（短縮形は <code class="literal">-u</code>）オプションを使うと、追跡していないファイルも一緒に保管して隠してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

<span style="font-weight: bold">$</span> git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

<span style="font-weight: bold">$</span> git status -s
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p>もうひとつの応用例として、<code class="literal">--patch</code> オプションを挙げておきましょう。これを使うと、変更内容をすべて隠してしまうのではなく、隠したい変更を対話的に選択できるようになります。この場合、選択されなかった変更は作業ディレクトリに残ることになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2&gt;&amp;1`.chomp
       end
     end
+
+    def show(treeish = &#39;master&#39;)
+      command(&quot;git show #{treeish}&quot;)
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file</code></pre>
</figure>
</section>
<section class="sect2" title="隠した変更からのブランチの作成">
<h3 id="_隠した変更からのブランチの作成">隠した変更からのブランチの作成</h3>
<p>作業をいったん隠し、しばらくそのブランチで作業を続けていると、隠した内容を再適用するときに問題が発生する可能性があります。
隠した後に何らかの変更をしたファイルに変更を再適用しようとすると、マージ時にコンフリクトが発生してそれを解決しなければならなくなるでしょう。
もう少しお手軽な方法で以前の作業を確認したい場合は <code class="literal">git stash branch</code> を実行します。このコマンドは、まず新しいブランチを作成し、作業をスタックに隠したときのコミットをチェックアウトし、スタックにある作業を再適用し、それに成功すればスタックからその作業を削除します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch &#39;testchanges&#39;
On branch testchanges
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   index.html

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)</code></pre>
</figure>
<p>これを使うと、保存していた作業をお手軽に復元して新しいブランチで作業をすることができます。</p>
</section>
<section class="sect2" title="作業ディレクトリの掃除">
<h3 id="r_git_clean">作業ディレクトリの掃除</h3>
<p>最後に、作業ディレクトリにある変更内容やファイルを隠すのではなく、取り除いてしまいたい場合の話をしましょう。これは、 <code class="literal">git clean</code> コマンドを使えば実現できます。</p>
<p>このコマンドが役立つのは、マージの結果、あるいは外部ツールによって生成された不要物を取り除いたり、ビルド結果を削除してクリーンな状態でビルドを実行したいときです。</p>
<p>このコマンドを実行するときは十分注意してください。作業ディレクトリにあって追跡されていないファイルは削除されるようになっているからです。後で気が変わっても、削除してしまったデータを取り戻すのは難しいでしょう。代わりに <code class="literal">git stash --all</code> を実行して、すべてを隠してしまうほうが安全です。</p>
<p>不要物を本当に取り除きたい、作業ディレクトリを掃除したい、という場合は、<code class="literal">git clean</code> を実行しましょう。作業ディレクトリの追跡されていないファイルをすべて削除するには、<code class="literal">git clean -f -d</code> を実行します。そうすれば、ファイルをすべて削除し、サブディレクトリを空にしてくれます。<code class="literal">-f</code> オプションは <em>force</em> の省略形で、「本当にそうしたい」という意味です。</p>
<p>このコマンドを実行するとどうなるか知りたいなら、<code class="literal">-n</code> オプションがいいでしょう。これを使うと、「リハーサルをして、何が消される <em>はず</em> だったのかを教えて」と Git に指示してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -d -n
Would remove test.o
Would remove tmp/</code></pre>
</figure>
<p><code class="literal">git clean</code> コマンドがデフォルトで削除するのは、追跡されていなくて、かつ無視されてもいないファイルだけです。<code class="literal">.gitignore</code> ファイルなどの無視設定に合致するファイルは削除されません。そういったファイルも消したい場合は、clean コマンドに <code class="literal">-x</code> オプションを追加するといいでしょう。完全にクリーンなビルドを行うため、以前のビルドで生成された <code class="literal">.o</code> ファイルをすべて削除したい、というような場合に使えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

<span style="font-weight: bold">$</span> git clean -n -d
Would remove build.TMP
Would remove tmp/

<span style="font-weight: bold">$</span> git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/</code></pre>
</figure>
<p><code class="literal">git clean</code> コマンドが何を削除するのかわからず不安なら、<code class="literal">-n</code> オプションを常につけるようにしましょう。何が削除されるかを前もって確認してから、 <code class="literal">-n</code> オプションを <code class="literal">-f</code> に変えてファイルを実際に削除すればよいのです。また、このコマンドを慎重に実行するもうひとつの方法として、<code class="literal">-i</code>、「対話モード」オプションというのもあります。</p>
<p>これを使えば、clean コマンドを対話モードで実行できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now&gt;</code></pre>
</figure>
<p>この方法であれば、ファイルを個別に選んだり、パターンマッチさせるなど対話モードで範囲を絞り込んだうえでファイルを削除できます。</p>
</section>
</section>
<section class="sect1" title="作業内容への署名">
<h2 id="r_signing">作業内容への署名</h2>
<p>Git の仕組みは暗号学の点から見れば堅牢です。しかし、容易には得られません。インターネットを使って貢献を受け付けているとしましょう。受け付けた内容が信頼できる筋からのものかどうか調べたいときに、署名の付与・検証をGPG を使っておこなう複数の仕組みが Git にはあります。</p>
<section class="sect2" title="GPG とは">
<h3 id="_gpg_とは">GPG とは</h3>
<p>まずはじめに、何かを署名するには、GPG を設定し、個人鍵をインストールしなければなりません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
sub   2048R/874529A9 2014-06-04</code></pre>
</figure>
<p>鍵をインストールしていないのなら、<code class="literal">gpg --gen-key</code> を使って生成できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>gpg --gen-key</code></pre>
</figure>
<p>署名付与用の秘密鍵ができたら、Git の設定項目 <code class="literal">user.signingkey</code> に鍵の内容を設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>git config --global user.signingkey 0A46826A</code></pre>
</figure>
<p>こうしておけば、タグやコミットに署名を付与するとき、Git はデフォルトでこの鍵を使うようになります。</p>
</section>
<section class="sect2" title="タグへの署名">
<h3 id="_タグへの署名">タグへの署名</h3>
<p>GPG 秘密鍵の設定を終えていれば、その鍵を使ってタグの作成時に署名できます。
その場合は <code class="literal">-a</code> の代わりに <code class="literal">-s</code> を指定すればいいだけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -s v1.5 -m <span style="font-style: italic">&#39;my signed 1.5 tag&#39;</span>

You need a passphrase to unlock the secret key for
user: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;
2048-bit RSA key, ID 800430EB, created 2014-05-04</code></pre>
</figure>
<p>このタグに対して <code class="literal">git show</code> を実行すると、あなたの GPG 署名が表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.5
tag v1.5
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:29:41 2014 -0700

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut
LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b
hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm
ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp
8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi
RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=
=EFTF
-----END PGP SIGNATURE-----

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
</section>
<section class="sect2" title="タグの検証">
<h3 id="_タグの検証">タグの検証</h3>
<p>署名付きのタグを検証するには <code class="literal">git tag -v [tag-name]</code> を使用します。
このコマンドは、GPG を使って署名を検証します。
これを正しく実行するには、署名者の公開鍵があなたの鍵リングに含まれている必要があります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;
gpg:                 aka &quot;[jpeg image of size 1513]&quot;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</code></pre>
</figure>
<p>署名者の公開鍵を持っていない場合は、このようなメッセージが表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can&#39;t check signature: public key not found
error: could not verify the tag &#39;v1.4.2.1&#39;</code></pre>
</figure>
</section>
<section class="sect2" title="コミットへの署名">
<h3 id="r_signing_commits">コミットへの署名</h3>
<p>最近のバージョン（v1.7.9 以上）では、Git を使ってコミットに署名できるようになりました。
タグだけでなく、コミットにも署名したい場合は、<code class="literal">git commit</code> コマンドの <code class="literal">-S</code> オプションを使いましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -a -S -m <span style="font-style: italic">&#39;signed commit&#39;</span>

You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
2048-bit RSA key, ID 0A46826A, created 2014-06-04

[master 5c3386c] signed commit
 4 files changed, 4 insertions(+), 24 deletions(-)
 rewrite Rakefile (100%)
 create mode 100644 lib/git.rb</code></pre>
</figure>
<p>また、署名の確認・検証を行うための <code class="literal">--show-signature</code> オプションが <code class="literal">git log</code> コマンドに用意されています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --show-signature -1
commit 5c3386cf54bba0a33a32da706aa52bc0155503c2
gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A
gpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Jun 4 19:49:17 2014 -0700

    signed commit</code></pre>
</figure>
<p>さらに、<code class="literal">git log</code> コマンドに署名の有無を出力させることもできます。書式設定で <code class="literal">%G?</code> を使いましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=<span style="font-style: italic">&quot;format:%h %G? %aN  %s&quot;</span>

5c3386c G Scott Chacon  signed commit
ca82a6d N Scott Chacon  changed the version number
085bb3b N Scott Chacon  removed unnecessary test code
a11bef0 N Scott Chacon  first commit</code></pre>
</figure>
<p>そうすれば、この例であれば最新のコミットのみが署名付き、しかもそれが有効であることがわかります。</p>
<p>バージョン 1.8.3 以降の Git であれば、マージやプルのときにコミットを拒否することもできます。<code class="literal">--verify-signatures</code> オプションを使うとコミットが検証され、有効な GPG 署名がない場合はマージやプルが拒否されます。</p>
<p>このオプションをブランチをマージするときに使うと、署名がない、もしくは有効でないコミットが含まれているブランチのマージは失敗します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures non-verify
fatal: Commit ab06180 does not have a GPG signature.</code></pre>
</figure>
<p>逆に、マージ対象のコミットすべてに有効な署名が施されていれば、検証された署名がすべて表示され、マージが実行に移されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
Updating 5c3386c..13ad65e
Fast-forward
 README | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</figure>
<p>また、<code class="literal">git merge</code> コマンドの <code class="literal">-S</code> オプションを使うと、マージコミットにも署名できます。以下のマージの例では、マージ対象コミットの署名を検証し、さらにマージコミットに署名を施しています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge --verify-signatures -S  signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;

You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;
2048-bit RSA key, ID 0A46826A, created 2014-06-04

Merge made by the &#39;recursive&#39; strategy.
 README | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</figure>
</section>
<section class="sect2" title="署名付与は全員で">
<h3 id="_署名付与は全員で">署名付与は全員で</h3>
<p>タグやコミットに署名を付与するのは素晴らしい試みです。ただし、作業手順のひとつとして採用するのであれば、メンバー全員がやり方を知っているかどうか前もって確認しておくべきでしょう。そうしておかないと、作成済みコミットに署名を付与する方法を説明してまわるハメになりかねません。GPG の仕組み、署名を付与することのメリットをよく理解してから、作業手順に組み込むようにしましょう。</p>
</section>
</section>
<section class="sect1" title="検索">
<h2 id="r_searching">検索</h2>
<p>コード量の大小を問わず、関数の参照位置・定義やメソッドの変更履歴を確認したくなることはよくあります。Git には便利なツールがいくつも用意されていて、コードやコミット履歴の確認が簡単にできるようになっています。具体的な方法をいくつか見ていきましょう。</p>
<section class="sect2" title="Git Grep">
<h3 id="r_git_grep">Git Grep</h3>
<p>Git に付属する <code class="literal">grep</code> コマンドを使うと、コミット済みのツリーや作業ディレクトリが簡単に検索（文字列・正規表現）できます。使い方の説明を兼ねて、Git のソースコードを覗いてみることにしましょう。</p>
<p>このコマンドはデフォルトでは作業ディレクトリを検索します。<code class="literal">-n</code> オプションと一緒に使うと、検索条件とマッチした行の番号も表示してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep -n gmtime_r
<span style="font-weight: bold">compat/gmtime.c:3:#</span>undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:429:             if (gmtime_r(&amp;now, &amp;now_tm))
date.c:492:             if (gmtime_r(&amp;time, tm)) {
git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);
<span style="font-weight: bold">git-compat-util.h:723:#</span>define gmtime_r git_gmtime_r</code></pre>
</figure>
<p>その他にも、興味深いオプションがこのコマンドにはいくつも用意されています。</p>
<p>上記の実行例とは違い、コマンド出力を Git に要約させることもできます。例えば、検索にマッチしたファイルの名前とマッチ回数を表示させるには、<code class="literal">--count</code> オプションを使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:2
git-compat-util.h:2</code></pre>
</figure>
<p>検索にマッチした結果からメソッドや関数と思われるものだけを確認したい場合は、<code class="literal">-p</code> オプションを使いましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep -p gmtime_r *.c
date.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)
date.c:         if (gmtime_r(&amp;now, &amp;now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&amp;time, tm)) {</code></pre>
</figure>
<p>この例では、<code class="literal">gmtime_r</code> が date.c ファイルにある関数 <code class="literal">match_multi_number</code> と <code class="literal">match_digit</code> から呼び出されていることがわかります。</p>
<p>また、文字列の複雑な組み合わせを探したい場合は <code class="literal">--and</code> オプションを使いましょう。検索条件がすべて同一行に含まれている行だけを返すためのオプションです。例として、文字列 “LINK” か “BUF_MAX” を含む定数が記述されている行を、Git の古いバージョン 1.8.0 から探してみます。</p>
<p>なお、この例では <code class="literal">--break</code> と <code class="literal">--heading</code> のオプションも使っています。出力を分割して読みやすくするためです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git grep --break --heading <span style="font-weight: bold; font-style: italic">\</span>
    -n -e <span style="font-style: italic">&#39;#define&#39;</span> --and <span style="font-weight: bold; font-style: italic">\(</span> -e LINK -e BUF_MAX <span style="font-weight: bold; font-style: italic">\)</span> v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u&lt;&lt;20)

v1.8.0:cache.h
73:#define S_IFGITLINK  0160000
74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)

v1.8.0:environment.c
54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)

v1.8.0:symlinks.c
53:#define FL_SYMLINK  (1 &lt;&lt; 2)

v1.8.0:zlib.c
<span style="font-weight: bold">30:/* #</span>define ZLIB_BUF_MAX ((uInt)-1) */
31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</code></pre>
</figure>
<p><code class="literal">grep</code> や <code class="literal">ack</code> のような他の検索用コマンドと比較すると、<code class="literal">git grep</code> コマンドには利点がふたつあります。とても早く動作することと、作業ディレクトリだけでなくコミット済みの全ツリーが検索対象であることです。上記の例ではその利点を示すために、検索対象を古いバージョンの Git のソースコードとし、チェックアウトされたバージョンのものにはしませんでした。</p>
</section>
<section class="sect2" title="Git ログの検索">
<h3 id="_git_ログの検索">Git ログの検索</h3>
<p>場合によっては、探しているのは語句の <strong>所在</strong> ではなく、語句が存在した・追加された <strong>時期</strong>、ということもあるでしょう。<code class="literal">git log</code> コマンドの強力なオプションを使うと、コミットメッセージの内容やコミットごとの差分をもとに、特定のコミットを絞り込めます。</p>
<p>ここでは、定数 <code class="literal">ZLIB_BUF_MAX</code> が追加された時期を調べてみましょう。その文字列が追加、あるいは削除されたコミットだけを表示するには、<code class="literal">-S</code> オプションを用います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -SZLIB_BUF_MAX --oneline
e01503b zlib: allow feeding more than 4GB in one go
ef49a7a zlib: zlib can only process 4GB at a time</code></pre>
</figure>
<p>これらのコミットの差分を見てみると、コミット <code class="literal">ef49a7a</code> でこの定数が追加され、コミット <code class="literal">e01503b</code> でそれが変更されたことがわかります。</p>
<p>より詳しく調べたいのなら、<code class="literal">-G</code> オプションをつけましょう。検索に正規表現が使えるようになります。</p>
<section class="sect3" title="ログの行指向検索">
<h4 id="_ログの行指向検索">ログの行指向検索</h4>
<p>一歩進んだログ検索の方法をもうひとつ見ておきましょう。履歴を行指向で検索するという、ものすごく便利な方法です。最近になって Git に追加された機能であまり知られていませんが、本当に便利です。<code class="literal">git log</code> コマンドに <code class="literal">-L</code> オプションをつけると行指向検索が有効になり、指定した行（関数など）の履歴を確認できます。</p>
<p>ここでは仮に、<code class="literal">zlib.c</code> ファイルにある <code class="literal">git_deflate_bound</code> 関数の変更履歴を確認したいとしましょう。用いるコマンドは <code class="literal">git log -L :git_deflate_bound:zlib.c</code> です。これを実行すると、指定された関数の定義範囲がまずは推測されます。そして、その範囲の全変更履歴をパッチの形でひとつずつ、関数が追加されたときの履歴にまでさかのぼって表示します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -L :git_deflate_bound:zlib.c
commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:52:15 2011 -0700

    zlib: zlib can only process 4GB at a time

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -85,5 +130,5 @@
-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)
 {
-       return deflateBound(strm, size);
+       return deflateBound(&amp;strm-&gt;z, size);
 }


commit 225a6f1068f71723a910e8565db4e252b3ca21fa
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:18:17 2011 -0700

    zlib: wrap deflateBound() too

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -81,0 +85,5 @@
+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+{
+       return deflateBound(strm, size);
+}
+</code></pre>
</figure>
<p>検索対象のコードで用いられているプログラミング言語によっては、 Git が関数やメソッドの定義範囲を絞り込めないことがあります。そんな場合は、正規表現を使いましょう。上記の例でいえば <code class="literal">git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c</code> はまったく同じ結果を出力します。また、行番号で検索対象を指定（単一行の指定、複数行で範囲指定の両方が可能）しても、同じような結果が得られます。</p>
</section>
</section>
</section>
<section class="sect1" title="歴史の書き換え">
<h2 id="r_rewriting_history">歴史の書き換え</h2>
<p>Git を使って作業をしていると、何らかの理由でコミットの歴史を書き換えたくなることが多々あります。
Git のすばらしい点のひとつは、何をどうするかの決断をぎりぎりまで先送りできることです。
どのファイルをどのコミットに含めるのかは、ステージングエリアの内容をコミットする直前まで変更することができますし、既に作業した内容でも stash コマンドを使えばまだ作業していないことにできます。また、すでにコミットしてしまった変更についても、それを書き換えてまるで別の方法で行ったかのようにすることもできます。
コミットの順序を変更したり、コミットメッセージやコミットされるファイルを変更したり、複数のコミットをひとつにまとめたりひとつのコミットを複数に分割したり、コミットそのものをなかったことにしたり……といった作業を、変更内容を他のメンバーに公開する前ならいつでもすることができます。</p>
<p>このセクションでは、これらの便利な作業の方法について扱います。これで、あなたのコミットの歴史を思い通りに書き換えてから他の人と共有できるようになります。</p>
<section class="sect2" title="直近のコミットの変更">
<h3 id="r_git_amend">直近のコミットの変更</h3>
<p>直近のコミットを変更するというのは、歴史を書き換える作業のうちもっともよくあるものでしょう。
直近のコミットに対して手を加えるパターンとしては、コミットメッセージを変更したりそのコミットで記録されるスナップショットを変更 (ファイルを追加・変更あるいは削除) したりといったものがあります。</p>
<p>単に直近のコミットメッセージを変更したいだけの場合は非常にシンプルです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>これを実行するとテキストエディタが開きます。すでに直近のコミットメッセージが書き込まれた状態になっており、それを変更することができます。
変更を保存してエディタを終了すると、変更後のメッセージを含む新しいコミットを作成して直近のコミットをそれで置き換えます。</p>
<p>いったんコミットしたあとで、そこにさらにファイルを追加したり変更したりしたくなったとしましょう。「新しく作ったファイルを追加し忘れた」とかがありそうですね。この場合の手順も基本的には同じです。
ファイルを編集して <code class="literal">git add</code> したり追跡中のファイルを <code class="literal">git rm</code> したりしてステージングエリアをお好みの状態にしたら、続いて <code class="literal">git commit --amend</code> を実行します。すると、現在のステージングエリアの状態を次回のコミット用のスナップショットにします。</p>
<p>この技を使う際には注意が必要です。この処理を行うとコミットの SHA-1 が変わるからです。
いわば、非常に小規模なリベースのようなものです。すでにプッシュしているコミットは書き換えないようにしましょう。</p>
</section>
<section class="sect2" title="複数のコミットメッセージの変更">
<h3 id="r_changing_multiple">複数のコミットメッセージの変更</h3>
<p>さらに歴史をさかのぼったコミットを変更したい場合は、もう少し複雑なツールを使わなければなりません。
Git には歴史を修正するツールはありませんが、リベースツールを使って一連のコミットを (別の場所ではなく) もともとあった場所と同じ HEAD につなげるという方法を使うことができます。
対話的なリベースツールを使えば、各コミットについてメッセージを変更したりファイルを追加したりお望みの変更をすることができます。
対話的なリベースを行うには、<code class="literal">git rebase</code> に <code class="literal">-i</code> オプションを追加します。
どこまでさかのぼってコミットを書き換えるかを指示するために、どのコミットにリベースするかを指定しなければなりません。</p>
<p>直近の三つのコミットメッセージあるいはそのいずれかを変更したくなった場合、変更したい最古のコミットの親を <code class="literal">git rebase -i</code> の引数に指定します。ここでは <code class="literal">HEAD~2^</code> あるいは <code class="literal">HEAD~3</code> となります。
直近の三つのコミットを編集しようと考えているのだから、<code class="literal">~3</code> のほうが覚えやすいでしょう。しかし、実際のところは四つ前 (変更したい最古のコミットの親) のコミットを指定していることに注意しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase -i HEAD~3</code></pre>
</figure>
<p>これはリベースコマンドであることを認識しておきましょう。 <code class="literal">HEAD~3..HEAD</code> に含まれるすべてのコミットは、実際にメッセージを変更したか否かにかかわらずすべて書き換えられます。
すでに中央サーバーにプッシュしたコミットをここに含めてはいけません。含めてしまうと、同じ変更が別のバージョンで見えてしまうことになって他の開発者が混乱します。</p>
<p>このコマンドを実行すると、テキストエディタが開いてコミットの一覧が表示され、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

<span style="font-weight: bold">#</span> Rebase 710f0f8..a5f4a0d onto 710f0f8
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Commands:
<span style="font-weight: bold">#</span>  p, pick = use commit
<span style="font-weight: bold">#</span>  r, reword = use commit, but edit the commit message
<span style="font-weight: bold">#</span>  e, edit = use commit, but stop <span style="font-weight: bold">for</span> amending
<span style="font-weight: bold">#</span>  s, squash = use commit, but meld into previous commit
<span style="font-weight: bold">#</span>  f, fixup = like <span style="font-style: italic">&quot;squash&quot;</span>, but discard this commit<span style="border: 1px solid #FF0000">&#39;</span>s log message
<span style="font-weight: bold">#</span>  x, exec = run command (the rest of the line) using shell
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> These lines can be re-ordered; they are executed from top to bottom.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> If you remove a line here THAT COMMIT WILL BE LOST.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> However, <span style="font-weight: bold">if</span> you remove everything, the rebase will be aborted.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Note that empty commits are commented out</code></pre>
</figure>
<p>このコミット一覧の表示順は、<code class="literal">log</code> コマンドを使ったときの通常の表示順とは逆になることに注意しましょう。
<code class="literal">log</code> を実行すると、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span> HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit</code></pre>
</figure>
<p>逆順になっていますね。
対話的なリベースを実行するとスクリプトが出力されるので、それをあとで実行することになります。
このスクリプトはコマンドラインで指定したコミット (<code class="literal">HEAD~3</code>) から始まり、それ以降のコミットを古い順に再現していきます。
最新のものからではなく古いものから表示されているのは、最初に再現するのがいちばん古いコミットだからです。</p>
<p>このスクリプトを編集し、手を加えたいコミットのところでスクリプトを停止させるようにします。そのためには、各コミットのうちスクリプトを停止させたいものについて「pick」を「edit」に変更します。たとえば、三番目のコミットメッセージだけを変更したい場合はこのようにファイルを変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>これを保存してエディタを終了すると、Git はそのリストの最初のコミットまで処理を巻き戻し、次のようなメッセージとともにコマンドラインを返します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue</code></pre>
</figure>
<p>この指示が、まさにこれからすべきことを教えてくれています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>と打ち込んでコミットメッセージを変更してからエディタを終了し、次に</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase --continue</code></pre>
</figure>
<p>を実行します。このコマンドはその他のふたつのコミットも自動的に適用するので、これで作業は終了です。
複数行で「pick」を「edit」に変更した場合は、これらの作業を各コミットについてくりかえすことになります。
それぞれの場面で Git が停止するので、amend でコミットを書き換えて continue で処理を続けます。</p>
</section>
<section class="sect2" title="コミットの並べ替え">
<h3 id="_コミットの並べ替え">コミットの並べ替え</h3>
<p>対話的なリベースで、コミットの順番を変更したり完全に消し去ってしまったりすることもできます。
“added cat-file” のコミットを削除して残りの二つのコミットの適用順を反対にしたい場合は、リベーススクリプトを</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>から</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</code></pre>
</figure>
<p>のように変更します。これを保存してエディタを終了すると、Git はまずこれらのコミットの親までブランチを巻き戻してから <code class="literal">310154e</code> を適用し、その次に <code class="literal">f7f3f6d</code> を適用して停止します。
これで、効率的にコミット順を変更して “added cat-file” のコミットは完全に取り除くことができました。</p>
</section>
<section class="sect2" title="コミットのまとめ">
<h3 id="r_squashing">コミットのまとめ</h3>
<p>一連のコミット群をひとつのコミットにまとめて押し込んでしまうことも、対話的なリベースツールで行うことができます。リベースメッセージの中に、その手順が出力されています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Commands:
<span style="font-weight: bold">#</span>  p, pick = use commit
<span style="font-weight: bold">#</span>  r, reword = use commit, but edit the commit message
<span style="font-weight: bold">#</span>  e, edit = use commit, but stop <span style="font-weight: bold">for</span> amending
<span style="font-weight: bold">#</span>  s, squash = use commit, but meld into previous commit
<span style="font-weight: bold">#</span>  f, fixup = like <span style="font-style: italic">&quot;squash&quot;</span>, but discard this commit<span style="border: 1px solid #FF0000">&#39;</span>s log message
<span style="font-weight: bold">#</span>  x, exec = run command (the rest of the line) using shell
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> These lines can be re-ordered; they are executed from top to bottom.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> If you remove a line here THAT COMMIT WILL BE LOST.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> However, <span style="font-weight: bold">if</span> you remove everything, the rebase will be aborted.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span> Note that empty commits are commented out</code></pre>
</figure>
<p>「pick」や「edit」のかわりに「squash」を指定すると、Git はその変更と直前の変更をひとつにまとめて新たなコミットメッセージを書き込めるようにします。
つまり、これらの三つのコミットをひとつのコミットにまとめたい場合は、スクリプトをこのように変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file</code></pre>
</figure>
<p>これを保存してエディタを終了すると、Git は三つの変更をすべて適用してからエディタに戻るので、そこでコミットメッセージを変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> This is a combination of 3 commits.
<span style="font-weight: bold">#</span> The first commit<span style="border: 1px solid #FF0000">&#39;</span>s message is:
changed my name a bit

<span style="font-weight: bold">#</span> This is the 2nd commit message:

updated README formatting and added blame

<span style="font-weight: bold">#</span> This is the 3rd commit message:

added cat-file</code></pre>
</figure>
<p>これを保存すると、さきほどの三つのコミットの内容をすべて含んだひとつのコミットができあがります。</p>
</section>
<section class="sect2" title="コミットの分割">
<h3 id="_コミットの分割">コミットの分割</h3>
<p>コミットの分割は、いったんコミットを取り消してから部分的なステージとコミットを繰り返して行います。
たとえば、先ほどの三つのコミットのうち真ん中のものを分割することになったとしましょう。
“updated README formatting and added blame” のコミットを、“updated README formatting” と “added blame” のふたつに分割します。
そのためには、<code class="literal">rebase -i</code> スクリプトを実行してそのコミットの指示を「edit」に変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</figure>
<p>続いて、コマンドラインに戻ってコミットをリセットし、その内容を使ってコミットを複数に分割していきます。
まず、変更を保存してエディタを終了すると、Git はリストの最初のコミットの親まで処理を巻き戻します。そして最初のコミット (<code class="literal">f7f3f6d</code>) と二番目のコミット (<code class="literal">310154e</code>) を適用してからコンソールに戻ります。
コミットをリセットするには <code class="literal">git reset HEAD^</code> を実行します。これはコミット自体を取り消し、変更されたファイルはステージしていない状態にします。
そして、その状態から一連のコミットを作ったら、以下のように`git rebase --continue` を実行しましょう｡</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset HEAD^
<span style="font-weight: bold">$</span> git add README
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;updated README formatting&#39;</span>
<span style="font-weight: bold">$</span> git add lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;added blame&#39;</span>
<span style="font-weight: bold">$</span> git rebase --continue</code></pre>
</figure>
<p>Git はスクリプトの最後のコミット (<code class="literal">a5f4a0d</code>) を適用し、歴史はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -4 --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span>
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit</code></pre>
</figure>
<p>念のためにもう一度言いますが、この変更はリスト内のすべてのコミットの SHA を変更します。すでに共有リポジトリにプッシュしたコミットは、このリストに表示させないようにしましょう。</p>
</section>
<section class="sect2" title="最強のオプション: filter-branch">
<h3 id="_最強のオプション_filter_branch">最強のオプション: filter-branch</h3>
<p>歴史を書き換える方法がもうひとつあります。これは、大量のコミットの書き換えを機械的に行いたい場合 (メールアドレスを一括変更したりすべてのコミットからあるファイルを削除したりなど) に使うものです。
そのためのコマンドが <code class="literal">filter-branch</code> です。これは歴史を大規模にばさっと書き換えることができるものなので、プロジェクトを一般に公開した後や書き換え対象のコミットを元にしてだれかが作業を始めている場合はまず使うことはありません。
しかし、これは非常に便利なものでもあります。
一般的な使用例をいくつか説明するので、それをもとにこの機能を使いこなせる場面を考えてみましょう。</p>
<section class="sect3" title="全コミットからのファイルの削除">
<h4 id="r_removing_file_every_commit">全コミットからのファイルの削除</h4>
<p>これは、相当よくあることでしょう。
誰かが不注意で <code class="literal">git add .</code> をした結果、巨大なバイナリファイルが間違えてコミットされてしまったとしましょう。これを何とか削除してしまいたいものです。
あるいは、間違ってパスワードを含むファイルをコミットしてしまったとしましょう。このプロジェクトをオープンソースにしたいと思ったときに困ります。
<code class="literal">filter-branch</code> は、こんな場合に歴史全体を洗うために使うツールです。
<code class="literal">passwords.txt</code> というファイルを歴史から完全に抹殺してしまうには、<code class="literal">filter-branch</code> の <code class="literal">--tree-filter</code> オプションを使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --tree-filter <span style="font-style: italic">&#39;rm -f passwords.txt&#39;</span> HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p><code class="literal">--tree-filter</code> オプションは、プロジェクトの各チェックアウトに対して指定したコマンドを実行し、結果を再コミットします。
この場合は、すべてのスナップショットから <code class="literal">passwords.txt</code> というファイルを削除します。
間違えてコミットしてしまったエディタのバックアップファイルを削除するには、<code class="literal">git filter-branch --tree-filter 'rm -f *~' HEAD</code> のように実行します。</p>
<p>Git がツリーを書き換えてコミットし、ブランチのポインタを末尾に移動させる様子がごらんいただけるでしょう。
この作業は、まずはテスト用ブランチで実行してから結果をよく吟味し、それから master ブランチに適用することをおすすめします。
<code class="literal">filter-branch</code> をすべてのブランチで実行するには、このコマンドに <code class="literal">--all</code> を渡します。</p>
</section>
<section class="sect3" title="サブディレクトリを新たなルートへ">
<h4 id="_サブディレクトリを新たなルートへ">サブディレクトリを新たなルートへ</h4>
<p>別のソース管理システムからのインポートを終えた後、無意味なサブディレクトリ (<code class="literal">trunk</code>、<code class="literal">tags`など) が残っている状態を想定しましょう。
すべてのコミットの `trunk</code> ディレクトリを新たなプロジェクトルートとしたい場合にも、<code class="literal">filter-branch</code> が助けになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p>これで、新たなプロジェクトルートはそれまで <code class="literal">trunk</code> ディレクトリだった場所になります。
Git は、このサブディレクトリに影響を及ぼさないコミットを自動的に削除します。</p>
</section>
<section class="sect3" title="メールアドレスの一括変更">
<h4 id="_メールアドレスの一括変更">メールアドレスの一括変更</h4>
<p>もうひとつよくある例としては、「作業を始める前に <code class="literal">git config</code> で名前とメールアドレスを設定することを忘れていた」とか「業務で開発したプロジェクトをオープンソースにするにあたって、職場のメールアドレスをすべて個人アドレスに変更したい」などがあります。
どちらの場合についても、複数のコミットのメールアドレスを一括で変更することになりますが、これも <code class="literal">filter-branch</code> ですることができます。
注意して、あなたのメールアドレスのみを変更しなければなりません。そこで、<code class="literal">--commit-filter</code> を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --commit-filter <span style="border: 1px solid #FF0000">&#39;</span>
        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
        then
                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
                git commit-tree &quot;$@&quot;;
        else
                git commit-tree &quot;$@&quot;;
        fi&#39; HEAD</code></pre>
</figure>
<p>これで、すべてのコミットであなたのアドレスを新しいものに書き換えます。
コミットにはその親の SHA-1 値が含まれるので、このコマンドは (マッチするメールアドレスが存在するものだけではなく) すべてのコミットを書き換えます。</p>
</section>
</section>
</section>
<section class="sect1" title="リセットコマンド詳説">
<h2 id="r_git_reset">リセットコマンド詳説</h2>
<p>専門的なツールを説明する前に、<code class="literal">reset</code> と <code class="literal">checkout</code> について触れておきます。
いざ使うことになると、一番ややこしい部類の Git コマンドです。
出来ることがあまりに多くて、ちゃんと理解したうえで正しく用いることなど夢のまた夢のようにも思えてしまいます。
よって、ここでは単純な例えを使って説明していきます。</p>
<section class="sect2" title="3つのツリー">
<h3 id="_3つのツリー">3つのツリー</h3>
<p><code class="literal">reset</code> と <code class="literal">checkout</code> を単純化したいので、Git を「3つのツリーのデータを管理するためのツール」と捉えてしまいましょう。
なお、ここでいう「ツリー」とはあくまで「ファイルの集まり」であって、データ構造は含みません。
（Git のインデックスがツリーとは思えないようなケースもありますが、ここでは単純にするため、「ツリー＝ファイルの集まり」で通していきます。）</p>
<p>いつものように Git を使っていくと、以下のツリーを管理・操作していくことになります。</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>ツリー</th>
<th>役割</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>HEAD</p></td>
<td><p>最新コミットのスナップショットで、次は親になる</p></td>
</tr>
<tr>
<td><p>インデックス</p></td>
<td><p>次のコミット候補のスナップショット</p></td>
</tr>
<tr>
<td><p>作業ディレクトリ</p></td>
<td><p>サンドボックス</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<section class="sect3" title="HEAD">
<h4 id="_head">HEAD</h4>
<p>現在のブランチを指し示すポインタは HEAD と呼ばれています。HEAD は、そのブランチの最新コミットを指し示すポインタでもあります。
ということは、HEAD が指し示すコミットは新たに追加されていくコミットの親になる、ということです。
HEAD のことを <strong>最新のコミット</strong> のスナップショットと捉えておくとわかりやすいでしょう。</p>
<p>では、スナップショットの内容を確認してみましょう。実に簡単です。
ディレクトリ構成と SHA-1 チェックサムを HEAD のスナップショットから取得するには、以下のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

<span style="font-weight: bold">$</span> git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib</code></pre>
</figure>
<p><code class="literal">cat-file</code> や <code class="literal">ls-tree</code> は「配管」コマンドなので、日々の作業で使うことはないはずでしょう。ただし、今回のように詳細を把握するには便利です。</p>
</section>
<section class="sect3" title="インデックス">
<h4 id="r_the_index">インデックス</h4>
<p>インデックスとは、<strong>次のコミット候補</strong> のことを指します。Git の「ステージングエリア」と呼ばれることもあります。<code class="literal">git commit</code> を実行すると確認される内容だからです。</p>
<p>インデックスの中身は、前回のチェックアウトで作業ディレクトリに保存されたファイルの一覧になっています。保存時のファイルの状態も記録されています。
ファイルに変更を加え、<code class="literal">git commit</code> コマンドを実行すると、ツリーが作成され新たなコミットとなります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</code></pre>
</figure>
<p>この例で使った <code class="literal">ls-files</code> コマンドも縁の下の力持ち的なコマンドです。インデックスの状態を表示してくれます。</p>
<p>なお、インデックスは厳密にはツリー構造ではありません。実際には、階層のない構造になっています。ただ、理解する上ではツリー構造と捉えて差し支えありません。</p>
</section>
<section class="sect3" title="作業ディレクトリ">
<h4 id="_作業ディレクトリ">作業ディレクトリ</h4>
<p>3つのツリーの最後は作業ディレクトリです。
他のツリーは、データを <code class="literal">.git</code> ディレクトリ内に処理しやすい形で格納してしまうため、人間が取り扱うには不便でした。
一方、作業ディレクトリにはデータが実際のファイルとして展開されます。とても取り扱いやすい形です。
作業ディレクトリのことは <strong>サンドボックス</strong> だと思っておいてください。そこでは、自由に変更を試せます。変更が完了したらステージングエリア（インデックス）に追加し、さらにコミットして歴史に追加するのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files</code></pre>
</figure>
</section>
</section>
<section class="sect2" title="作業手順">
<h3 id="_作業手順">作業手順</h3>
<p>Git を使う主目的は、プロジェクトのスナップショットを健全な状態で取り続けることです。そのためには、3つのツリーを操作する必要があります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-workflow.png" alt="reset workflow"/>
</div>
</figure>
<p>その手順を頭を使って説明しましょう。まず、新しいディレクトリを作って、テキストファイルをひとつ保存したとします。
現段階でのこのファイルを <strong>v1</strong> としましょう（図では青塗りの部分）。
次に <code class="literal">git init</code> を実行して Git リポジトリを生成します。このときの HEAD は、これから生成される予定のブランチを指し示すことになります（ <code class="literal">master</code> はまだ存在しません）。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex1.png" alt="reset ex1"/>
</div>
</figure>
<p>この時点では、作業ディレクトリにしかテキストファイルのデータは存在しません。</p>
<p>では、このファイルをコミットしてみましょう。まずは <code class="literal">git add</code> を実行して、作業ディレクトリ上のデータをインデックスにコピーします。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex2.png" alt="reset ex2"/>
</div>
</figure>
<p>さらに、<code class="literal">git commit</code> を実行し、インデックスの内容でスナップショットを作成します。そうすると、作成したスナップショットをもとにコミットオブジェクトが作成され、<code class="literal">master</code> がそのコミットを指し示すようになります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex3.png" alt="reset ex3"/>
</div>
</figure>
<p>この段階で <code class="literal">git status</code> を実行しても、何も変更点は出てきません。3つのツリーが同じ状態になっているからです。</p>
<p>続いて、このテキストファイルの内容を変更してからコミットしてみましょう。
手順はさきほどと同じです。まずは、作業ディレクトリにあるファイルを変更します。
変更した状態のファイルを <strong>v2</strong> としましょう（図では赤塗りの部分）。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex4.png" alt="reset ex4"/>
</div>
</figure>
<p><code class="literal">git status</code> をここで実行すると、コマンド出力の “Changes not staged for commit” 欄に赤塗り部分のファイルが表示されます。作業ディレクトリ上のそのファイルの状態が、インデックスの内容とは異なっているからです。
では、<code class="literal">git add</code> を実行して変更をインデックスに追加してみましょう。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex5.png" alt="reset ex5"/>
</div>
</figure>
<p>この状態で <code class="literal">git status</code> を実行すると、以下の図で緑色の枠内にあるファイルがコマンド出力の “Changes to be committed” 欄 に表示されます。インデックスと HEAD の内容に差分があるからです。次のコミット候補と前回のコミットの内容に差異が生じた、とも言えます。
では、<code class="literal">git commit</code> を実行してコミット内容を確定させましょう。</p>
<figure class="image">
<div class="content">
<img src="images/reset-ex6.png" alt="reset ex6"/>
</div>
</figure>
<p>ここで <code class="literal">git status</code> を実行しても何も出力されません。3つのツリーが同じ状態に戻ったからです。</p>
<p>なお、ブランチを切り替えたりリモートブランチをクローンしても同じような処理が走ります。
ブランチをチェックアウトしたとしましょう。そうすると、<strong>HEAD</strong> はそのブランチを指すようになります。さらに、HEAD コミットのスナップショットで <strong>インデックス</strong> が上書きされ、そのデータが <strong>作業ディレクトリ</strong> にコピーされます。</p>
</section>
<section class="sect2" title="リセットの役割">
<h3 id="_リセットの役割">リセットの役割</h3>
<p>これから説明する内容に沿って考えれば、<code class="literal">reset</code> コマンドの役割がわかりやすくなるはずです。</p>
<p>説明で使う例として、さきほど使った <code class="literal">file.txt</code> をまた編集し、コミットしたと仮定します。その場合、このリポジトリの歴史は以下のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-start.png" alt="reset start"/>
</div>
</figure>
<p>では、<code class="literal">reset</code> コマンドの処理の流れを順を追って見ていきましょう。単純な方法で3つのツリーが操作されていきます。
一連の処理は、最大で3つになります。</p>
<section class="sect3" title="処理1 HEAD の移動">
<h4 id="_処理1_head_の移動">処理1 HEAD の移動</h4>
<p><code class="literal">reset</code> コマンドを実行すると、HEAD に指し示されているものがまずは移動します。
これは、<code class="literal">checkout</code> のときのような、HEAD そのものを書き換えてしまう処理ではありません。HEAD が指し示すブランチの方が移動する、ということです。
つまり、仮に HEAD が <code class="literal">master</code> ブランチを指している（<code class="literal">master</code> ブランチをチェックアウトした状態）場合、<code class="literal">git reset 9e5e6a4</code> を実行すると <code class="literal">master</code> ブランチがコミット <code class="literal">9e5e6a4</code> を指すようになります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-soft.png" alt="reset soft"/>
</div>
</figure>
<p>付与されたオプションがなんであれ、コミットを指定して <code class="literal">reset</code> コマンド実行すると、必ず上記の処理が走ります。
<code class="literal">reset --soft</code> オプションを使った場合は、コマンドはここで終了します。</p>
<p>そして、改めて図を見てみると、直近の <code class="literal">git commit</code> コマンドが取り消されていることがわかると思います。
通常であれば、<code class="literal">git commit</code> を実行すると新しいコミットが作られ、HEAD が指し示すブランチはそのコミットまで移動します。
また、<code class="literal">reset</code> を実行して <code class="literal">HEAD~</code> （HEAD の親）までリセットすれば、ブランチは以前のコミットまで巻き戻されます。この際、インデックスや作業ディレクトリは変更されません。
なお、この状態でインデックスを更新して <code class="literal">git commit</code> を実行すれば、<code class="literal">git commit --amend</code> を行った場合と同じ結果が得られます（詳しくは <a id="xref-r_git_amend" href="#r_git_amend" class="xref">直近のコミットの変更</a> を参照してください)。</p>
</section>
<section class="sect3" title="処理2 インデックスの更新 (--mixed)">
<h4 id="_処理2_インデックスの更新_mixed">処理2 インデックスの更新 (--mixed)</h4>
<p>ここで <code class="literal">git status</code> を実行すると、インデックスの内容と変更された HEAD の内容との差分がわかることを覚えておきましょう。</p>
<p>第2の処理では、<code class="literal">reset</code> は HEAD が指し示すスナップショットでインデックスを置き換えます。</p>
<figure class="image">
<div class="content">
<img src="images/reset-mixed.png" alt="reset mixed"/>
</div>
</figure>
<p><code class="literal">--mixed</code> オプションを使うと、<code class="literal">reset</code> はここで終了します。
また、このオプションはデフォルトになっています。ここでの例の <code class="literal">git reset HEAD~</code> のようにオプションなしでコマンドを実行しても、<code class="literal">reset</code> はここで終了します。</p>
<p>では、もう一度図を見てみましょう。直近の <code class="literal">commit</code> がさきほどと同様に取り消されており、さらにインデックスの内容も <em>取り消された</em> ことがわかります。
<code class="literal">git add</code> でインデックスに追加し、<code class="literal">git commit</code> でコミットとして確定させた内容が取り消されたということです。</p>
</section>
<section class="sect3" title="処理3 作業ディレクトリの更新 (--hard)">
<h4 id="_処理3_作業ディレクトリの更新_hard">処理3 作業ディレクトリの更新 (--hard)</h4>
<p><code class="literal">reset</code> の第3の処理は、作業ディレクトリをインデックスと同じ状態にすることです。
<code class="literal">--hard</code> オプションを使うと、処理はこの段階まで進むことになります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-hard.png" alt="reset hard"/>
</div>
</figure>
<p>第3の処理が走ると何が起こるのでしょうか。
まず、直近のコミットが巻き戻されます。<code class="literal">git add</code> と <code class="literal">git commit</code> で確定した内容も同様です。<strong>さらに</strong>、作業ディレクトリの状態も巻き戻されてしまいます。</p>
<p><code class="literal">--hard</code> オプションを使った場合に限り、<code class="literal">reset</code> コマンドは危険なコマンドになってしまうことを覚えておいてください。Git がデータを完全に削除してしまう、数少ないパターンです。
<code class="literal">reset</code> コマンドの実行結果は簡単に取り消せますが、<code class="literal">--hard</code> オプションに限ってはそうはいきません。作業ディレクトリを強制的に上書きしてしまうからです。
ここに挙げた例では、<strong>v3</strong> バージョンのファイルは Git のデータベースにコミットとしてまだ残っていて、<code class="literal">reflog</code> を使えば取り戻せます。ただしコミットされていない内容については、上書きされてしまうため取り戻せません。</p>
</section>
<section class="sect3" title="要約">
<h4 id="_要約">要約</h4>
<p><code class="literal">reset</code> コマンドを使うと、3つのツリーを以下の順で上書きしていきます。どこまで上書きするかはオプション次第です。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">HEAD が指し示すブランチを移動する <em>(<code class="literal">--soft</code> オプションを使うと処理はここまで)</em></span>
</li>
<li>
<span class="principal">インデックスの内容を HEAD と同じにする <em>(<code class="literal">--hard</code> オプションを使わなければ処理はここまで)</em></span>
</li>
<li>
<span class="principal">作業ディレクトリの内容をインデックスと同じにする</span>
</li>
</ol>
</div>
</section>
</section>
<section class="sect2" title="パスを指定したリセット">
<h3 id="_パスを指定したリセット">パスを指定したリセット</h3>
<p>ここまでで、<code class="literal">reset</code> の基礎と言える部分を説明してきました。次に、パスを指定して実行した場合の挙動について説明します。
パスを指定して <code class="literal">reset</code> を実行すると、処理1は省略されます。また、処理2と3については、パスで指定された範囲（ファイル郡）に限って実行されます。
このように動作するのはもっともな話です。処理1で操作される HEAD はポインタにすぎず、指し示せるコミットは一つだけだからです（こちらのコミットのこの部分と、あちらのコミットのあの部分、というようには指し示せません）。
一方、インデックスと作業ディレクトリを一部分だけ更新することは <em>可能</em> です。よって、リセットの処理2と3は実行されます。</p>
<p>実際の例として、 <code class="literal">git reset file.txt</code> を実行したらどうなるか見ていきましょう。
このコマンドは <code class="literal">git reset --mixed HEAD file.txt</code> のショートカット版（ブランチやコミットの SHA-1 の指定がなく、 <code class="literal">--soft</code> or <code class="literal">--hard</code> の指定もないため）です。実行すると、</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">HEAD が指し示すブランチを移動する <em>(この処理は省略)</em></span>
</li>
<li>
<span class="principal">HEAD の内容でインデックスを上書きする <em>(処理はここまで)</em></span>
</li>
</ol>
</div>
<p>が行われます。要は、HEAD からインデックスに <code class="literal">file.txt</code> がコピーされるということです。</p>
<figure class="image">
<div class="content">
<img src="images/reset-path1.png" alt="reset path1"/>
</div>
</figure>
<p>同時に、このコマンドは指定したファイルをステージされていない状態に戻す（ <em>unstage</em> )、ということでもあります。
上の図（リセットコマンドを図示したもの）を念頭におきつつ、<code class="literal">git add</code> の挙動を考えてみてください。真逆であることがわかるはずです。</p>
<figure class="image">
<div class="content">
<img src="images/reset-path2.png" alt="reset path2"/>
</div>
</figure>
<p>なお、ファイルをステージされていない状態に戻したいときはこのリセットコマンドを実行するよう、 <code class="literal">git status</code> コマンドの出力には書かれています。その理由は、リセットコマンドが上述のような挙動をするからなのです。
（詳細は <a id="xref--ch02-git-basics--r_unstaging" href="ch02-git-basics.xhtml#r_unstaging" class="xref">ステージしたファイルの取り消し</a> を確認してください）。</p>
<p>「HEAD のデータが欲しい」という前提で処理が行われるのを回避することもできます。とても簡単で、必要なデータを含むコミットを指定するだけです。
<code class="literal">git reset eb43bf file.txt</code> のようなコマンドになります。</p>
<figure class="image">
<div class="content">
<img src="images/reset-path3.png" alt="reset path3"/>
</div>
</figure>
<p>これを実行すると、作業ディレクトリ上の <code class="literal">file.txt</code> が <strong>v1</strong> の状態に戻り、<code class="literal">git add</code> が実行されたあと、作業ディレクトリの状態が <strong>v3</strong> に戻る、のと同じことが起こります（実際にそういった手順で処理されるわけではありませんが）。
さらに <code class="literal">git commit</code> を実行してみましょう。すると、作業ディレクトリ上の状態をまた <strong>v1</strong> に戻したわけではないのに、該当のファイルを <strong>v1</strong> に戻す変更がコミットされます。</p>
<p>もうひとつ、覚えておくべきことを紹介します。 <code class="literal">git add</code> などと同じように、<code class="literal">reset</code> コマンドにも <code class="literal">--patch</code> オプションがあります。これを使うと、ステージした内容を塊ごとに作業ディレクトリに戻せます。
つまり、一部分だけを作業ディレクトリに戻したり以前の状態に巻き戻したりできるわけです。</p>
</section>
<section class="sect2" title="reset を使ったコミットのまとめ">
<h3 id="_code_class_literal_reset_code_を使ったコミットのまとめ"><code class="literal">reset</code> を使ったコミットのまとめ</h3>
<p>本節で学んだ方法を使う、気になる機能を紹介します。コミットのまとめ機能です。</p>
<p>「凡ミス」「WIP」「ファイル追加忘れ」のようなメッセージのコミットがいくつも続いたとします。
そんなときは <code class="literal">reset</code> を使いましょう。すっきりと一つにまとめられます
（別の手段を <a id="xref-r_squashing" href="#r_squashing" class="xref">コミットのまとめ</a> で紹介していますが、今回の例では <code class="literal">reset</code> の方がわかりやすいと思います）。</p>
<p>ここで、最初のコミットはファイル数が1、次のコミットでは最初からあったファイルの変更と新たなファイルの追加、その次のコミットで最初からあったファイルをまた変更、というコミット履歴を経てきたプロジェクトがあったとします。
二つめのコミットは作業途中のもの（WIP）だったので、どこかにまとめてしまいましょう。</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r1.png" alt="reset squash r1"/>
</div>
</figure>
<p>まず、<code class="literal">git reset --soft HEAD~2</code> を実行して HEAD を過去のコミット（消したくはないコミットのうち古い方）へと移動させます。</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r2.png" alt="reset squash r2"/>
</div>
</figure>
<p>そうしたら、あとは <code class="literal">git commit</code> を実行するだけです。</p>
<figure class="image">
<div class="content">
<img src="images/reset-squash-r3.png" alt="reset squash r3"/>
</div>
</figure>
<p>こうしてしまえば、1つめのコミットで <code class="literal">file-a.txt</code> v1 が追加され、2つめのコミットで <code class="literal">file-a.txt</code> が v3 に変更され <code class="literal">file-b.txt</code> が追加された、というコミット履歴が到達可能な歴史（プッシュすることになる歴史）になります。<code class="literal">file-a.txt</code> を v2 に変更したコミットを歴史から取り除くことができました。</p>
</section>
<section class="sect2" title="チェックアウトとの違い">
<h3 id="_チェックアウトとの違い">チェックアウトとの違い</h3>
<p>最後に、<code class="literal">checkout</code> と <code class="literal">reset</code> の違いについて触れておきます。
3つのツリーを操作する、という意味では <code class="literal">checkout</code> は <code class="literal">reset</code> と同様です。けれど、コマンド実行時にファイルパスを指定するかどうかによって、少し違いがでてきます。</p>
<section class="sect3" title="パス指定なしの場合">
<h4 id="_パス指定なしの場合">パス指定なしの場合</h4>
<p><code class="literal">git checkout [branch]</code> と <code class="literal">git reset --hard [branch]</code> の挙動は似ています。どちらのコマンドも、3つのツリーを <code class="literal">[branch]</code> の状態に変更するからです。ただし、大きな違いが2点あります。</p>
<p>まず、<code class="literal">reset --hard</code> とは違い、<code class="literal">checkout</code> は作業ディレクトリを守ろうとします。作業ディレクトリの内容を上書きしてしまう前に、未保存の変更がないかをチェックしてくれるのです。
さらに詳しく見てみると、このコマンドはもっと親切なことがわかります。作業ディレクトリのファイルに対し、“trivial” なマージを試してくれるのです。うまくいけば、<em>未変更</em> のファイルはすべて更新されます。
一方、<code class="literal">reset --hard</code> の場合、このようなチェックは行わずにすべてが上書きされます。</p>
<p>もうひとつの違いは、HEAD の更新方法です。
<code class="literal">reset</code> の場合はブランチの方が移動するのに対し、<code class="literal">checkout</code> の場合は HEAD のそのものが別ブランチに移動します。</p>
<p>具体例を挙げて説明しましょう。<code class="literal">master</code> と <code class="literal">develop</code> の2つのブランチが異なるコミットを指し示していて、<code class="literal">develop</code> の方をチェックアウトしているとします（HEAD は後者の方を向いた状態です）。
ここで <code class="literal">git reset master</code> を実行すると、<code class="literal">master</code> ブランチの最新のコミットを <code class="literal">develop</code> ブランチも指し示すようになります。
ですが、代わりに <code class="literal">git checkout master</code> を実行しても、<code class="literal">develop</code> ブランチは移動しません。HEAD が移動するのです。
その結果、HEAD は <code class="literal">master</code> の方を指し示すようになります。</p>
<p>どちらの場合でも HEAD がコミット A を指すようになるという意味では同じですが、<em>どのように</em> それが行われるかはずいぶん違います。
<code class="literal">reset</code> の場合は HEAD が指し示すブランチの方が移動するのに対し、<code class="literal">checkout</code> の場合は HEAD そのものが移動するのです。</p>
<figure class="image">
<div class="content">
<img src="images/reset-checkout.png" alt="reset checkout"/>
</div>
</figure>
</section>
<section class="sect3" title="パス指定ありの場合">
<h4 id="_パス指定ありの場合">パス指定ありの場合</h4>
<p><code class="literal">checkout</code> はパスを指定して実行することも出来ます。その場合、<code class="literal">reset</code> と同様、HEAD が動くことはありません。
実行されると指定したコミットの指定したファイルでインデックスの内容を置き換えます。<code class="literal">git reset [branch] file</code> と同じ動きです。しかし、<code class="literal">checkout</code> の場合は、さらに作業ディレクトリのファイルも置き換えます。
<code class="literal">git reset --hard [branch] file</code> を実行しても、まったく同じ結果になるでしょう（実際には <code class="literal">reset</code> ではこういうオプションの指定はできません）。作業ディレクトリを保護してはくれませんし、HEAD が動くこともありません。</p>
<p>また、<code class="literal">checkout</code> にも <code class="literal">git reset</code> や <code class="literal">git add</code> のように <code class="literal">--patch</code> オプションがあります。これを使えば、変更点を部分ごとに巻き戻していけます。</p>
</section>
</section>
<section class="sect2" title="まとめ">
<h3 id="_まとめ">まとめ</h3>
<p>これまでの説明で <code class="literal">reset</code> コマンドについての不安は解消されたでしょうか。<code class="literal">checkout</code> との違いがまだまだ曖昧かもしれません。実行の仕方が多すぎて、違いを覚えるのは無理と言っても言い過ぎではないはずです。</p>
<p>どのコマンドがどのツリーを操作するか、以下の表にまとめておきました。
“HEAD” の列は、該当のコマンドが HEAD が指し示すブランチの位置を動かす場合は “REF”、動くのが HEAD そのものの場合は “HEAD” としてあります。
「作業ディレクトリ保護の有無」の列はよく見ておいてください。その列が <strong>いいえ</strong> の場合は、実行結果をよくよく踏まえてからコマンドを実行するようにしてください。</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th></th>
<th>HEAD</th>
<th>インデックス</th>
<th>作業ディレクトリ</th>
<th>作業ディレクトリ保護の有無</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Commit Level</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><p><code class="literal">reset --soft [commit]</code></p></td>
<td><p>REF</p></td>
<td><p>いいえ</p></td>
<td><p>いいえ</p></td>
<td><p>はい</p></td>
</tr>
<tr>
<td><p><code class="literal">reset [commit]</code></p></td>
<td><p>REF</p></td>
<td><p>はい</p></td>
<td><p>いいえ</p></td>
<td><p>はい</p></td>
</tr>
<tr>
<td><p><code class="literal">reset --hard [commit]</code></p></td>
<td><p>REF</p></td>
<td><p>はい</p></td>
<td><p>はい</p></td>
<td><p><strong>いいえ</strong></p></td>
</tr>
<tr>
<td><p><code class="literal">checkout [commit]</code></p></td>
<td><p>HEAD</p></td>
<td><p>はい</p></td>
<td><p>はい</p></td>
<td><p>はい</p></td>
</tr>
<tr>
<td><p><strong>File Level</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><p><code class="literal">reset (commit) [file]</code></p></td>
<td><p>いいえ</p></td>
<td><p>はい</p></td>
<td><p>いいえ</p></td>
<td><p>はい</p></td>
</tr>
<tr>
<td><p><code class="literal">checkout (commit) [file]</code></p></td>
<td><p>いいえ</p></td>
<td><p>はい</p></td>
<td><p>はい</p></td>
<td><p><strong>いいえ</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</section>
<section class="sect1" title="高度なマージ手法">
<h2 id="r_advanced_merging">高度なマージ手法</h2>
<p>Git を使うと、大抵の場合マージは簡単です。違うブランチを何度もマージすることも簡単なので、一度作ったブランチで延々と作業を続けながら、常に最新の状態に保っておけます。そうすれば、マージのたびに少しずつコンフリクトを解消することになるので、作業の最後で一度だけマージする場合のように、膨大なコンフリクトにあっけにとられることもなくなるでしょう。</p>
<p>とはいえ、ややこしいコンフリクトは発生してしまうものです。他のバージョン管理システムとは違い、Git は無理をしてまでコンフリクトを解消しようとはしません。Git は、マージの内容が明確かどうか正確に判断できるよう作られています。しかし、コンフリクトが発生した場合は、わかったつもりになってコンフリクトを解消してしまうようなことはしません。すぐに乖離してしまうようなブランチをいつまでもマージしないでおくと、問題になる場合があります。</p>
<p>この節では、どういった問題が起こりうるのか、そしてそういった状況を解決するのに役立つ Git のツールを見ていきます。また、いつもとは違う方法でマージを行うにはどうすればいいか、マージした内容を元に戻すにはどうすればいいかも見ていきましょう。</p>
<section class="sect2" title="マージのコンフリクト">
<h3 id="_マージのコンフリクト">マージのコンフリクト</h3>
<p>マージのコンフリクトをどのように解消するか、基本的なところを <a id="xref--ch03-git-branching--r_basic_merge_conflicts" href="ch03-git-branching.xhtml#r_basic_merge_conflicts" class="xref">マージ時のコンフリクト</a> で紹介しました。ここでは、複雑なコンフリクトの場合に、状況を把握しコンフリクトを上手に解消するための Git ツールを紹介します。</p>
<p>まず、可能な限り、作業ディレクトリがクリーンな状態であることを確認しましょう。コンフリクトを起こす可能性のあるマージを実行するのはその後です。作業中の内容があるのなら、一時保存用のブランチを作ってコミットするか stash に隠してしまいましょう。こうしておけば、<strong>何が</strong> 起こってもやり直しがききます。以下で説明するヒントのなかには、作業ディレクトリの変更を保存せずにマージを行うと未保存の作業が消えてしまうものもあります。</p>
<p>では、わかりやすい例を見てみましょう。<em>hello world</em> と出力する単純な Ruby スクリプトです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
  puts <span style="font-style: italic">&#39;hello world&#39;</span>
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>このスクリプトが保存されているリポジトリに <code class="literal">whitespace</code> というブランチを作ったら、ファイルの改行コードを Unix から DOS に変更します。これで、空白文字だけが全行分変更されました。次に、“hello world” という行を “hello mundo” に変更してみます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b whitespace
Switched to a new branch &#39;whitespace&#39;

<span style="font-weight: bold">$</span> unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;converted hello.rb to DOS&#39;</span>
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

<span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;^M
 end

 hello()

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;hello mundo change&#39;</span>
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>ここで <code class="literal">master</code> ブランチに切り替えて、コメントで機能を説明しておきましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Switched to branch &#39;master&#39;

<span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts &#39;hello world&#39;
 end

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;document the function&#39;</span>
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>では、<code class="literal">whitespace</code> ブランチをマージしてみましょう。空白文字を変更したため、コンフリクトが発生してしまいます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<section class="sect3" title="マージの中止">
<h4 id="r_abort_merge">マージの中止</h4>
<p>コンフリクトには、対応方法がいくつかあります。まず、現状から抜け出す方法を説明します。コンフリクトが起こるとは思っていなかった、今はまだ処理したくない、といった場合、<code class="literal">git merge --abort</code> を実行すればマージ後の状況から抜け出せます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -sb
<span style="font-weight: bold">#</span><span style="font-style: italic"># master</span>
UU hello.rb

<span style="font-weight: bold">$</span> git merge --abort

<span style="font-weight: bold">$</span> git status -sb
<span style="font-weight: bold">#</span><span style="font-style: italic"># master</span></code></pre>
</figure>
<p><code class="literal">git merge --abort</code> が実行されると、マージを実行する前の状態に戻ろうとします。これがうまくいかない可能性があるのが、作業ディレクトリの変更を隠しておらず、コミットもしていない状態でこのコマンドが実行された場合です。それ以外で失敗することはないでしょう。</p>
<p>また、一度やり直したいときは、<code class="literal">git reset --hard HEAD</code> （もしくは戻りたいコミットを指定）を実行してもよいでしょう。最新コミットの状態にリポジトリを戻してくれます。
ただし、コミットしていない内容が消去されてしまうことだけは覚えておいてください。変更内容をなかったことにしたいときだけ、このコマンドを実行するようにしましょう。</p>
</section>
<section class="sect3" title="空白文字の除外">
<h4 id="_空白文字の除外">空白文字の除外</h4>
<p>この例では、コンフリクトは空白文字が原因で起こっていました。例が簡単なのでそれが明確ですが、実際の場合でも見分けるのは簡単です。というのも、コンフリクトの内容が、一方で全行を削除しつつもう一方では全行を追加した形になっているからです。Git のデフォルトでは、これは「全行が変更された」と見なされ、マージは行えません。</p>
<p>ただし、デフォルトのマージ戦略で指定できる引数には、空白文字を適切に除外できるものもあります。大量の空白文字が原因でマージがうまくいかない場合は、一度中止して最初からやり直してみましょう。その際は、<code class="literal">-Xignore-all-space</code> か <code class="literal">-Xignore-space-change</code> のオプションを使ってください。前者は既存の空白文字に関する変更を <strong>すべて</strong> 無視し、後者は2文字以上の空白文字が連続している場合にそれを同一であるとみなして処理します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the &#39;recursive&#39; strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>この例ではファイルの実際の変更にコンフリクトがないので、空白文字の変更を無視してしまえば、あとはすんなりとマージできます。</p>
<p>チームのメンバーにスペースをタブに変えたがる（もしくはその反対）人がいたりすると、このオプションはきっと大助かりだと思います。</p>
</section>
<section class="sect3" title="マージの手動再実行">
<h4 id="r_manual_remerge">マージの手動再実行</h4>
<p>Git は空白文字を前もって上手に処理してくれます。ただし、自動で処理するのは難しいけれど、変更の内容によっては処理をスクリプトに落とし込める場合があります。ここでは例として、空白文字がうまく処理されず、手動でコンフリクトを解消することになったとしましょう。</p>
<p>その場合、マージしようとしているファイルを前もって <code class="literal">dos2unix</code> プログラムで処理しておく必要があります。どうすればいいでしょうか。</p>
<p>手順はこうです。まずはじめに、実際にコンフリクトを発生させます。次に、コンフリクトしているファイルを、自分たちの分・相手側（マージしようとしているブランチ）の分・共通（両方のブランチの共通の祖先）の分の3バージョン用意します。最後に、自分たちか相手側、どちらかのファイルを修正し、該当のファイル1つだけを改めてマージします。</p>
<p>なお、この手順で使う3バージョンは簡単に用意できます。Git は、これらのバージョンを “stages” というインデックスに番号付きで保存してくれているのです。Stage 1 は共通の祖先、stage 2 は自分たちの分、Stage 3は <code class="literal">MERGE_HEAD</code> （マージしようとしている、“theirs” にあたる）の分になります。</p>
<p>コンフリクトが発生したファイルの3バージョンを用意するには、<code class="literal">git show</code> コマンドを以下のように指定して実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show :1:hello.rb &gt; hello.common.rb
<span style="font-weight: bold">$</span> git show :2:hello.rb &gt; hello.ours.rb
<span style="font-weight: bold">$</span> git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</figure>
<p>そんな簡単なの？と拍子抜けしたのなら、Git の配管コマンドである <code class="literal">ls-files -u</code> を使ってみましょう。各ファイルの blob の SHA-1 を表示してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</figure>
<p>このとおり、<code class="literal">:1:hello.rb</code> は blob の SHA を調べるための簡易記法です。</p>
<p>3バージョン分のデータを作業ディレクトリに取り出せたので、相手側のファイルにある空白文字の問題を解消して、マージを再実行してみましょう。マイナーなコマンドですが、まさにこういったときのために使える <code class="literal">git merge-file</code> というコマンドを用います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

<span style="font-weight: bold">$</span> git merge-file -p <span style="font-weight: bold; font-style: italic">\</span>
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

<span style="font-weight: bold">$</span> git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts &#39;hello world&#39;
+   puts &#39;hello mundo&#39;
  end

  hello()</code></pre>
</figure>
<p>こうすれば、コンフリクトしたファイルをきれいにマージできます。この方法を使うと、空白文字の問題は無視されずにマージ前にきちんと解決されるので、<code class="literal">ignore-space-change</code> オプションを使うよりも便利です。実際、<code class="literal">ignore-space-change</code> でマージを行ったら改行コードが DOS の行が数行残っており、改行コードが混在した状態になってしまっていました。</p>
<p>なお、自分たち（もしくは相手側）のファイルがどのように変更されたかを、ここでの変更をコミットする前に確認したい場合は、<code class="literal">git diff</code> コマンドを使います。そうすれば、作業ディレクトリにあるコミット予定のファイルを、上述の3ステージと比較できるのです。実際にやってみましょう。</p>
<p>まず、マージ前のブランチの状態を手元の現状と比較する（マージが何をどう変更したのか確認する）には、<code class="literal">git diff --ours</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

<span style="font-weight: bold"> #</span> prints out a greeting
 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;
 end

 hello()</code></pre>
</figure>
<p>そうすると、作業中のブランチがどう変更されたか（マージすることでこのファイルがどう変更されるか）がすぐわかります。この例では、変更されるのは1行だけです。</p>
<p>次に、相手側のファイルがマージ前後でどう変わったかを確認するには、<code class="literal">git diff --theirs</code> を使います。なお、この例と次の例では、空白文字を除外するために <code class="literal">-b</code> オプションを使用しています。これから比較するのは空白文字が処理済みの手元のファイル <code class="literal">hello.theirs.rb</code> ではなく、Git のデータベースに格納されているデータだからです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts &#39;hello mundo&#39;
 end</code></pre>
</figure>
<p>そして、自分と相手、両側から変更を確認する場合は <code class="literal">git diff --base</code> を使いましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts &#39;hello world&#39;
+  puts &#39;hello mundo&#39;
 end

 hello()</code></pre>
</figure>
<p>最後に、マージを手動で行うために作成したファイルは <code class="literal">git clean</code> コマンドで削除してしまいましょう。必要になることはもうありません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</figure>
</section>
<section class="sect3" title="コンフリクトのチェックアウト">
<h4 id="r_checking_out_conflicts">コンフリクトのチェックアウト</h4>
<p>ここで、さきほど試したコンフリクトの解決方法があまりよくなかった、もしくはマージ対象の一方（あるいは両方）を編集してもコンフリクトをうまく解消できず、これまでの流れを詳しく把握する必要が生じたとします。</p>
<p>これを解説するには、先程の例を少し変更しておくほうがいいでしょう。今回は両方のブランチそれぞれにコミットが数回なされており、かつマージ時にはコンフリクトが発生するような状態だと仮定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</figure>
<p><code class="literal">master</code> ブランチにしかないコミットが3つあり、<code class="literal">mundo</code> ブランチにしかないコミットも3つある、という状態です。ここで <code class="literal">mundo</code> ブランチをマージすれば、コンフリクトが発生してしまいます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>どのようなコンフリクトが発生したのか確認しておきましょう。ファイルを開いてみると、以下の様な状態になっていました。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts <span style="font-style: italic">&#39;hola world&#39;</span>
=======
  puts <span style="font-style: italic">&#39;hello mundo&#39;</span>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>マージ対象の両サイドで同じファイルの同じ箇所に違う変更を加えた結果、コンフリクトが発生してしまったことがわかります。</p>
<p>こういった場合に使える、コンフリクトの発生原因を確認できるツールを紹介します。コンフリクトをどう解消すればいいかが明確だとは限りません。そういったときは、経緯を把握する必要もあるはずです。</p>
<p>まず1つめは、<code class="literal">git checkout</code> コマンドの <code class="literal">--conflict</code> オプションです。これを実行すると、指定したファイルをもう一度チェックアウトし、コンフリクトマーカーを書きなおします。コンフリクトを手で直していてうまくいかず、最初からやり直すためにリセットしたいときに便利です。</p>
<p><code class="literal">--conflict</code> オプションには <code class="literal">diff3</code> か <code class="literal">merge</code> が指定できます（デフォルトは <code class="literal">merge</code>）。前者を指定すると、コンフリクトマーカーが少し変わってきます。通常のマーカーである “ours” と “theirs” に加え、“base” も表示されるのです。より詳しく状況がわかると思います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout --conflict=diff3 hello.rb</code></pre>
</figure>
<p>これを実行すると、マーカーはいつもとは違い以下のようになるはずです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts <span style="font-style: italic">&#39;hola world&#39;</span>
||||||| base
  puts <span style="font-style: italic">&#39;hello world&#39;</span>
=======
  puts <span style="font-style: italic">&#39;hello mundo&#39;</span>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
<span style="font-weight: bold">end</span>

hello()</code></pre>
</figure>
<p>これをコンフリクトマーカーのデフォルトにすることもできます。この表示の方が好みであれば、設定項目 <code class="literal">merge.conflictstyle</code> を <code class="literal">diff3</code> に変更してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global merge.conflictstyle diff3</code></pre>
</figure>
<p><code class="literal">git checkout</code> コマンドには <code class="literal">--ours</code> や <code class="literal">--theirs</code> オプションを指定することもできます。これを使うと、何かをマージする代わりに、どちらか一方を選択して簡単にチェックアウトできます。</p>
<p>これは、バイナリデータのコンフリクトを解消するとき（使いたい方を選べばよい）や、他のブランチから特定のファイルを取り込みたいときに便利でしょう。後者であれば、マージコマンドを実行してから該当のファイルを <code class="literal">--ours</code> か <code class="literal">--theirs</code> を指定してチェックアウトし、コミットしてください。</p>
</section>
<section class="sect3" title="マージの履歴">
<h4 id="r_merge_log">マージの履歴</h4>
<p>もう一つ、コンフリクトの解決に使える便利なツールが <code class="literal">git log</code> です。どういった流れでコンフリクトが発生したのかを追跡するときに使えます。というのも、歴史を少し紐解いてみると、平行して進行していた2つの開発作業がなぜコードの同じ部分を編集するに至ったか、その理由を思い出せたりするからです。</p>
<p>マージ対象のブランチに含まれるコミットを重複分を除いて表示させるには、<a id="xref-r_triple_dot" href="#r_triple_dot" class="xref">トリプルドット</a> で触れた「トリプルドット」記法を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
<span style="font-weight: bold">&gt;</span> e3eb223 add more tests
<span style="font-weight: bold">&gt;</span> 7cff591 add testing script
<span style="font-weight: bold">&gt;</span> c3ffff1 changed text to hello mundo</code></pre>
</figure>
<p>この例では、全部で6コミットがわかりやすい状態でリスト表示されています。それぞれのコミットがどちらのブランチのものかもわかるようになっています。</p>
<p>また、より細かく流れを把握するために、表示内容を絞り込むこともできます。<code class="literal">git log</code> コマンドの <code class="literal">--merge</code> オプションを使うと、表示されるのはコンフリクトが発生しているファイルを編集したコミットだけになるのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
<span style="font-weight: bold">&gt;</span> c3ffff1 changed text to hello mundo</code></pre>
</figure>
<p>また、このコマンドに <code class="literal">-p</code> オプションを追加すると、表示される内容がコンフリクトしているファイルの差分だけになります。コンフリクトの原因を把握して賢明な方法でそれを解消するために、必要な背景や経緯をすばやく理解したいときに <strong>とても</strong> 役に立つでしょう。</p>
</section>
<section class="sect3" title="Combined Diff 形式">
<h4 id="_combined_diff_形式">Combined Diff 形式</h4>
<p>Git でマージを行うと、うまくマージされた内容はインデックスに追加されます。つまり、マージのコンフリクトが残っている状態で <code class="literal">git diff</code> を実行すると、コンフリクトの内容だけが表示されることになります。これを使えば、残ったコンフリクトだけを確認できます。</p>
<p>実際に、マージのコンフリクトが発生した直後に <code class="literal">git diff</code> を実行してみましょう。特徴的な diff 形式で差分が表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts &#39;hola world&#39;
++=======
+   puts &#39;hello mundo&#39;
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</figure>
<p>これは “Combined Diff” という形式で、各行の行頭2文字を使って関連情報を表示します。具体的には、作業ディレクトリの内容とマージ元のブランチ（「ours」）の内容に差分があれば1文字目を、作業ディレクトリとマージの相手側のブランチ（「theirs」）に差分があれば2文字目が使われます。</p>
<p>この例では、作業ディレクトリには存在する <code class="literal">&gt;&gt;&gt;&gt;&gt;</code> の行が、マージ対象のブランチどちらにも存在していないことがわかります。それもそのはず、これらの行はマージによって挿入されたからです。差分をわかりやすくするために挿入されたこれらの行は、手動で削除する必要があります。</p>
<p>このコンフリクトを解消してから <code class="literal">git diff</code> を実行しても同じような内容が表示されますが、この場合はもう少し気の利いた内容になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim hello.rb
<span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end

  hello()</code></pre>
</figure>
<p>ここから読み取れるのは、“hola world” はマージ元のブランチにはあって作業ディレクトリには存在せず、“hello mundo” はマージ対象のブランチにはあって作業ディレクトリには存在していないこと、更に “hola mundo” はマージ対象の両ブランチには存在しないけれど作業ディレクトリには存在していることです。これを使えば、コンフリクトをどのように解決したか、マージする前に確認できます。</p>
<p><code class="literal">git log</code> を使っても、同じ内容を表示させられます。マージの際にどういった変更がなされたのか、後々になって確認する際に便利です。<code class="literal">git show</code> コマンドをマージコミットに対して実行した場合か、<code class="literal">git log -p</code> （デフォルトではマージコミット以外のコミットの内容をパッチ形式で表示）に <code class="literal">--cc</code> オプションを付与した場合、この形式の差分が出力されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch &#39;mundo&#39;

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end

  hello()</code></pre>
</figure>
</section>
</section>
<section class="sect2" title="マージの取消">
<h3 id="r_undoing_merges">マージの取消</h3>
<p>マージの方法がわかったということは、間違ってマージしてしまう可能性も出てきた、ということになります。
Git を使うことの利点は、間違ってもいい、ということです。というのも、（大抵は簡単に）修正できるからです。</p>
<p>マージコミットももちろん修正可能です。
例えば、トピックブランチで作業を開始し、間違ってそのブランチを <code class="literal">master</code> にマージしてしまったとしましょう。コミット履歴は以下のようになっているはずです。</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-start.png" alt="間違って作成したマージコミット"/>
</div>
<figcaption>Figure 2. 間違って作成したマージコミット</figcaption>
</figure>
<p>この状況を修正するには2通りのやり方があります。どのように修正したいかに応じて使い分けましょう。</p>
<section class="sect3" title="参照の修正">
<h4 id="_参照の修正">参照の修正</h4>
<p>不要なマージコミットをまだプッシュしていないのなら、ブランチが指し示すコミットを変更してしまうのが一番簡単な解決方法です。
大半の場合、間違って実行した <code class="literal">git merge</code> の後に <code class="literal">git reset --hard HEAD~</code> を実行すれば、ブランチのポインタがリセットされます。実行結果は以下のようになるでしょう。</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-reset.png" alt="`git reset --hard HEAD~` 実行後の歴史"/>
</div>
<figcaption>Figure 3. <code class="literal">git reset --hard HEAD~</code> 実行後の歴史</figcaption>
</figure>
<p><code class="literal">reset</code> コマンドについては <a id="xref-r_git_reset" href="#r_git_reset" class="xref">リセットコマンド詳説</a> で触れましたので、ここで何が起こっているか、理解するのは難しいことではないと思います。
念のためおさらいしておきましょう。<code class="literal">reset --hard</code> を実行すると、通常は以下の処理が走ります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">HEAD が指し示すブランチを移動する
この例では、マージコミット (<code class="literal">C6</code>) が作成される前に <code class="literal">master</code> が指していたところまで戻します。</span>
</li>
<li>
<span class="principal">インデックスの内容を HEAD と同じにする</span>
</li>
<li>
<span class="principal">作業ディレクトリの内容をインデックスと同じにする</span>
</li>
</ol>
</div>
<p>この方法の欠点は、歴史を書き換えてしまう点です。共有リポジトリで作業していると、問題視される場合があります。
書き換えようとしているコミットをほかの人たちもプルしてしまっている場合は、<code class="literal">reset</code> は使わないほうが無難でしょう。理由については <a id="xref--ch03-git-branching--r_rebase_peril" href="ch03-git-branching.xhtml#r_rebase_peril" class="xref">ほんとうは怖いリベース</a> を確認してみてください。
また、新たなコミットがマージ以後に追加されている場合は、この方法はうまくいきません。参照を移動してしまうと、追加された内容を削除することになってしまうからです。</p>
</section>
<section class="sect3" title="コミットの打ち消し">
<h4 id="r_reverse_commit">コミットの打ち消し</h4>
<p>ブランチのポインタを動かすという上述の方法が機能しない場合、既存のコミットの内容を打ち消す新しいコミットを作ることもできます。
これは “revert” と呼ばれる操作で、今回の例では以下のようにすると呼び出せます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git revert -m 1 HEAD
[master b1d8379] Revert &quot;Merge branch &#39;topic&#39;&quot;</code></pre>
</figure>
<p><code class="literal">-m 1</code> オプションで、保持すべき「メイン」の親がどれであるかを指定します。
<code class="literal">HEAD</code> に対するマージ（<code class="literal">git merge topic</code>）を実行すると、マージコミットには2つの親ができます。<code class="literal">HEAD</code> (<code class="literal">C6</code>) と マージされるブランチの最新コミット (<code class="literal">C4</code>) です。
この例では、第2の親 (<code class="literal">C4</code>) をマージしたことで生じた変更をすべて打ち消しつつ、第1の親 (<code class="literal">C6</code>) の内容は保持したままにしてみます。</p>
<p>revert のコミットを含む歴史は以下のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert.png" alt="`git revert -m 1` の後の歴史"/>
</div>
<figcaption>Figure 4. <code class="literal">git revert -m 1</code> の後の歴史</figcaption>
</figure>
<p>新しく作成されたコミット <code class="literal">^M</code> の内容はコミット <code class="literal">C6</code> とまったく同じですので、歴史を今後振り返ると、マージなど一度も実施されていないかのように思えます。ただし、実際のところは <code class="literal">HEAD</code> の方の歴史にはマージされていないコミットが残ったままになってしまいます。
この状態で <code class="literal">topic</code> を <code class="literal">master</code> にマージしようとすると、Git は状況を正確に判断できません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge topic
Already up-to-date.</code></pre>
</figure>
<p>これは、<code class="literal">topic</code> ブランチにあるものは <code class="literal">master</code> ブランチにもすべて存在している、という状態です。
更に悪いことに、この状態の <code class="literal">topic</code> ブランチにコミットを追加してマージを行うと、revert されたマージ <em>後</em> の変更だけが取り込まれることになります。</p>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert2.png" alt="よくないマージを含む歴史"/>
</div>
<figcaption>Figure 5. よくないマージを含む歴史</figcaption>
</figure>
<p>ここでは revert してしまった変更を取り戻したいわけですから、revert 済みの古いマージコミットをもう一度 revert し、 <strong>そのうえで</strong> 改めてマージするのが一番いいでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git revert ^M
[master 09f0126] Revert &quot;Revert &quot;Merge branch &#39;topic&#39;&quot;&quot;
<span style="font-weight: bold">$</span> git merge topic</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/undomerge-revert3.png" alt="revert 済みのマージコミットを再度マージした後の歴史"/>
</div>
<figcaption>Figure 6. revert 済みのマージコミットを再度マージした後の歴史</figcaption>
</figure>
<p>そうすると、<code class="literal">M</code> と <code class="literal">^M</code> が互いを打ち消します。
<code class="literal">^^M</code> によって <code class="literal">C3</code> と <code class="literal">C4</code> の変更が取り込まれたことになりますし、<code class="literal">C8</code> のマージコミットによって <code class="literal">C7</code> が取り込まれます。これでようやっと、<code class="literal">topic</code> ブランチはすべてマージされました。</p>
</section>
</section>
<section class="sect2" title="他のマージ手法">
<h3 id="_他のマージ手法">他のマージ手法</h3>
<p>ここまでは2つのブランチをマージする通常の手法を見てきました。一般的には、「再帰」 と呼ばれるマージ戦略によって処理されている手法です。これ以外にもブランチをマージする手法がありますので、いくつかをざっと紹介します。</p>
<section class="sect3" title="Our か Theirs の選択">
<h4 id="_our_か_theirs_の選択">Our か Theirs の選択</h4>
<p>1つめに紹介するのは、マージの「再帰」モードで使える便利なオプションです。<code class="literal">-X</code> と組み合わせて使う <code class="literal">ignore-all-space</code> や <code class="literal">ignore-space-change</code> といったオプションは既に紹介しました。Git ではそれ以外にも、コンフリクトが発生したときにマージ対象のどちらを優先するかを指定できます。</p>
<p>Git のデフォルトでは、マージしようとしているブランチ間でコンフリクトがある場合、コードにはコンフリクトを示すマーカーが挿入され、該当ファイルはコンフリクト扱いとなり、手動で解決することになります。
そうではなく、マージ対象のブランチどちらかを優先して自動でコンフリクトを解消して欲しいとしましょう。その場合、<code class="literal">merge</code> コマンドに <code class="literal">-Xours</code> か <code class="literal">-Xtheirs</code> オプションを指定できます。</p>
<p>これらが指定されると、コンフリクトを示すマーカーは追加されません。マージ可能な差異は通常どおりマージされ、コンフリクトが発生する差異については指定された側のブランチの内容が採用されます。これはバイナリデータについても同様です。</p>
<p>以前使った “hello world” の例で確認してみましょう。作ったブランチをマージしようとするとコンフリクトが発生してしまいます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved &#39;hello.rb&#39; using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>ですが、<code class="literal">-Xours</code> か <code class="literal">-Xtheirs</code> を指定してマージすると、コンフリクトは発生しません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -Xours mundo
Auto-merging hello.rb
Merge made by the &#39;recursive&#39; strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</figure>
<p>そうすると、“hello mundo” と “hola world” でコンフリクトが発生している部分にマーカーを挿入する代わりに、“hola world” の方が採用されます。そして、その場合でも、マージされる側のブランチにあるコンフリクトしない変更についてはすべてマージされます。</p>
<p>このオプションは、既に紹介した <code class="literal">git merge-file</code> コマンドでも使用可能です。<code class="literal">git merge-file --ours</code> のような形で実行すれば、ファイルを個別にマージするときに使えます。</p>
<p>また、同じようなことをしたいけれど、マージされる側の変更点は何一つ取り込みたくない、というようなことになったとしましょう。その場合、より強力な選択肢として “ours” というマージ <em>戦略</em> が使えます。これは “ours” を使って行う再帰的なマージ用の <em>オプション</em> とは異なります。</p>
<p>ではその戦略が何をするかというと、偽のマージが実行されるのです。マージ対象の両ブランチを親としたマージコミットが新たに作成されますが、マージされる側のブランチの内容については一切考慮されません。現在いるブランチの内容が、マージの結果としてそのままそっくり記録されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge -s ours mundo
Merge made by the &#39;ours&#39; strategy.
<span style="font-weight: bold">$</span> git diff HEAD HEAD~
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p>このとおり、マージ結果とマージ直前の状態に一切変更点がないことがわかります。</p>
<p>これが役に立つのは、後々になってマージを行う際に Git を勘違いさせて、ブランチをマージ済みとして取り扱わせたい場合です。具体例を挙げて説明しましょう。「リリース」ブランチを作成して作業を進めているとします。そのブランチは、いずれ “master” ブランチにマージするつもりです。ここで、“master” 上で行われたバグ修正を <code class="literal">release</code> ブランチにも取り込む必要が出てきました。そのためには、まずはバグ修正のブランチを <code class="literal">release</code> ブランチにマージし、続いて <code class="literal">merge -s ours</code> コマンドで同じブランチを <code class="literal">master</code> ブランチにもマージします（修正は既に取り込まれていますが、あえて実施します）。そうしておけば、<code class="literal">release</code> ブランチをマージする際に、バグ修正のブランチが原因でコンフリクトが発生することはありません。</p>
</section>
<section class="sect3" title="サブツリーマージ">
<h4 id="r_subtree_merge">サブツリーマージ</h4>
<p>サブツリーマージの考え方は、ふたつのプロジェクトがあるときに一方のプロジェクトをもうひとつのプロジェクトのサブディレクトリに位置づけるというものです。
サブツリーマージを指定すると、Git は一方が他方のサブツリーであることを大抵の場合は理解して、適切にマージを行います。</p>
<p>これから、既存のプロジェクトに別のプロジェクトを追加し、前者のサブディレクトリとして後者をマージする例を紹介します。</p>
<p>まずは Rack アプリケーションをプロジェクトに追加します。
つまり、Rack プロジェクトをリモート参照として自分のプロジェクトに追加し、そのブランチにチェックアウトします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add rack_remote https://github.com/rack/rack
<span style="font-weight: bold">$</span> git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
<span style="font-weight: bold">$</span> git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch &quot;rack_branch&quot;</code></pre>
</figure>
<p>これで Rack プロジェクトのルートが <code class="literal">rack_branch</code> ブランチに取得でき、あなたのプロジェクトが <code class="literal">master</code> ブランチにある状態になりました。
まずどちらかをチェックアウトしてそれからもう一方に移ると、それぞれ別のプロジェクトルートとなっていることがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
<span style="font-weight: bold">$</span> git checkout master
Switched to branch &quot;master&quot;
<span style="font-weight: bold">$</span> ls
README</code></pre>
</figure>
<p>これは、考えようによっては変な話です。リポジトリにあるブランチがすべて、同一プロジェクトのブランチである必要はない、ということなのですから。めったにない話です（ちょっとやそっとのことでは役に立たないので）が、完全に異なる歴史を持つ複数のブランチを1つのリポジトリで保持するのはとても簡単なのです。</p>
<p>この例では、Rack プロジェクトを <code class="literal">master</code> プロジェクトのサブディレクトリとして取り込みたくなったとしましょう。そのときには、<code class="literal">git read-tree</code> を使います。<code class="literal">read-tree</code> とその仲間たちについては <a href="ch10-git-internals.xhtml" class="xref">Gitの内側</a> で詳しく説明します。現時点では、とりあえず「あるブランチのルートツリーを読み込んで、それを現在のステージングエリアと作業ディレクトリに書き込むもの」だと認識しておけばよいでしょう。まず <code class="literal">master</code> ブランチに戻り、 <code class="literal">rack_branch</code> ブランチの内容を <code class="literal">master</code> ブランチの <code class="literal">rack</code> サブディレクトリに取り込みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git read-tree --prefix=rack/ -u rack_branch</code></pre>
</figure>
<p>これをコミットすると、Rack のファイルをすべてサブディレクトリに取り込んだようになります。そう、まるで tarball からコピーしたかのような状態です。おもしろいのは、あるブランチでの変更を簡単に別のブランチにマージできるということです。もし Rack プロジェクトが更新されたら、そのブランチに切り替えてプルするだけで本家の変更を取得できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout rack_branch
<span style="font-weight: bold">$</span> git pull</code></pre>
</figure>
<p>これで、変更を <code class="literal">master</code> ブランチにマージできるようになりました。<code class="literal">git merge -s subtree</code> を使えばうまく動作します。が、Git は歴史もともにマージしようとします。おそらくこれはお望みの動作ではないでしょう。変更をプルしてコミットメッセージを埋めるには、再帰的マージ戦略を指定するオプション <code class="literal">-Xsubtree</code> のほかに <code class="literal">--squash</code> オプションを使います（再帰的戦略はこの場合のデフォルトにあたりますが、使用されるオプションを明確にするためあえて記載してあります）。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
<span style="font-weight: bold">$</span> git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</figure>
<p>Rack プロジェクトでのすべての変更がマージされ、ローカルにコミットできる準備が整いました。この逆を行うこともできます。master ブランチの <code class="literal">rack</code> サブディレクトリで変更した内容を後で <code class="literal">rack_branch</code> ブランチにマージし、それをメンテナに投稿したり本家にプッシュしたりといったことも可能です。</p>
<p>この機能を使えば、サブモジュールを使った作業手順に似た手順（<a id="xref-r_git_submodules" href="#r_git_submodules" class="xref">サブモジュール</a> で紹介する予定）を、サブモジュールなしで採用できます。違うプロジェクトのデータをブランチとしてプロジェクトリポジトリ内に保持しておけますし、サブツリーマージを使ってそのブランチを取組中のプロジェクトに取り込むこともできます。これは見方によっては、例えば、すべてのコードが同じ場所にコミットされるという意味では、便利だといえるでしょう。ですが、欠点がないわけではありません。構成が複雑になり変更を取り込む際に間違いやすくなってしまうでしょう。関係ないリポジトリに誤ってプッシュしてしまうことだってあるかもしれません。</p>
<p>また、少し違和感を覚えるかもしれませんが、<code class="literal">rack</code> サブディレクトリの内容と <code class="literal">rack_branch</code> ブランチのコードの差分を取得する (そして、マージしなければならない内容を知る) には、通常の <code class="literal">diff</code> コマンドを使うことはできません。そのかわりに、<code class="literal">git diff-tree</code> で比較対象のブランチを指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff-tree -p rack_branch</code></pre>
</figure>
<p>あるいは、<code class="literal">rack</code> サブディレクトリの内容と前回取得したときのサーバーの <code class="literal">master</code> ブランチとを比較するには、次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff-tree -p rack_remote/master</code></pre>
</figure>
</section>
</section>
</section>
<section class="sect1" title="Rerere">
<h2 id="r_rerere">Rerere</h2>
<p><code class="literal">git rerere</code> コマンドはベールに包まれた機能といってもいいでしょう。これは “reuse recorded resolution” の略です。その名が示すとおり、このコマンドは、コンフリクトがどのように解消されたかを記録してくれます。そして、同じコンフリクトに次に出くわしたときに、自動で解消してくれるのです。</p>
<p>いくつもの場面で、この機能がとても役立つと思います。Git のドキュメントで挙げられている例は、長期にわたって開発が続いているトピックブランチを問題なくマージされるようにしておきたいけれど、そのためのマージコミットがいくつも生まれるような状況は避けたい、というものです。<code class="literal">rerere</code> を有効にした状態で、マージをときおり実行し、コンフリクトをそのたびに解消したうえで、マージを取り消してみてください。この手順を継続的に行っておけば、最終的なマージは容易なものになるはずです。<code class="literal">rerere</code> がすべてを自動で処理してくれるからです。</p>
<p>リベースする度に同じコンフリクトを処理することなく、ブランチをリベースされた状態に保っておくときにもこの方法が使えます。あるいは、コンフリクトをすべて解消して、ようやっとマージし終えた後に、リベースを使うことに方針を変更したとしましょう。<code class="literal">rerere</code> を使えば、同じコンフリクトを再度処理せずに済みます。</p>
<p>その他にも、開発中のトピックブランチをいくつもまとめてマージして、テスト可能な HEAD を生成するとき（Git 本体のプロジェクトでよく行われています）にもこのコマンドが使えます。テストが失敗したら、マージを取り消したうえで失敗の原因となったブランチを除外してからテストを再実行するわけですが、<code class="literal">rerere</code> を使えばその際にコンフリクトを解消する必要がなくなるのです。</p>
<p><code class="literal">rerere</code> を有効にするには、以下の設定コマンドを実行しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global rerere.enabled true</code></pre>
</figure>
<p>該当のリポジトリに <code class="literal">.git/rr-cache</code> というディレクトリを作成しても <code class="literal">rerere</code> は有効になりますが、設定するほうがわかりやすいでしょう。設定であれば、全リポジトリに適用することもできます。</p>
<p>では実際の例を見てみましょう。以前使ったような単純な例です。
<code class="literal">hello.rb</code> というファイル名の、以下のようなファイルがあったとします。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
  puts <span style="font-style: italic">&#39;hello world&#39;</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>今いるブランチではこのファイルの “hello” という単語を “hola” に変更し、別のブランチでは “world” を “mundo” に変更したとします。前回と同様ですね。</p>
<figure class="image">
<div class="content">
<img src="images/rerere1.png" alt="rerere1"/>
</div>
</figure>
<p>これら2つのブランチをマージしようとすると、コンフリクトが発生します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for &#39;hello.rb&#39;
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>コマンド出力に <code class="literal">Recorded preimage for FILE</code> という見慣れない行があるのに気づかれたでしょう。他の部分は、よくあるコンフリクトのメッセージと変わりありません。この時点で、<code class="literal">rerere</code> からわかることがいくつかあります。こういった場合、いつもであれば以下のように <code class="literal">git status</code> を実行し、何がコンフリクトしているのかを確認するものです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
<span style="font-weight: bold">#</span> On branch master
<span style="font-weight: bold">#</span> Unmerged paths:
<span style="font-weight: bold">#</span>   (use <span style="font-style: italic">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)
<span style="font-weight: bold">#</span>   (use <span style="font-style: italic">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span>	both modified:      hello.rb
<span style="font-weight: bold">#</span></code></pre>
</figure>
<p>ですが、ここで <code class="literal">git rerere status</code> を実行すると、どのファイルのマージ前の状態が <code class="literal">git rerere</code> によって保存されたかがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere status
hello.rb</code></pre>
</figure>
<p>更に、<code class="literal">git rerere diff</code> を実行すると、コンフリクト解消の状況がわかります。具体的には、着手前がどういう状態であったか、どういう風に解消したのか、がわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts &#39;hello mundo&#39;
-=======
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   puts &#39;hola world&#39;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+=======
+  puts &#39;hello mundo&#39;
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world
 end</code></pre>
</figure>
<p>また（<code class="literal">rerere</code> 特有の話ではありませんが）、コンフリクトしているファイルと、そのファイルの3バージョン（マージ前・コンフリクトマーカー左向き・コンフリクトマーカー右向き）が <code class="literal">ls-files -u</code> を使うとわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</code></pre>
</figure>
<p>さて、このコンフリクトは <code class="literal">puts 'hola mundo'</code> と修正しておきます。そして、 もう一度 <code class="literal">rerere diff</code> コマンドを実行すると、rerere が記録する内容を確認できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
<span style="font-weight: bold"> #</span>! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts &#39;hello mundo&#39;
-=======
-  puts &#39;hola world&#39;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+  puts &#39;hola mundo&#39;
 end</code></pre>
</figure>
<p>これを記録したということは、<code class="literal">hello.rb</code> に同じコンフリクト（一方は “hello mundo” でもう一方が “hola world”）が見つかった場合、自動的に “hola mundo” に修正されるということになります。</p>
<p>では、この変更内容をコミットしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add hello.rb
<span style="font-weight: bold">$</span> git commit
Recorded resolution for &#39;hello.rb&#39;.
[master 68e16e5] Merge branch &#39;i18n&#39;</code></pre>
</figure>
<p>コマンド出力から、Git がコンフリクト解消方法を記録した（"Recorded resolution for FILE"）ことがわかります。</p>
<figure class="image">
<div class="content">
<img src="images/rerere2.png" alt="rerere2"/>
</div>
</figure>
<p>ではここで、このマージを取り消して master ブランチにリベースしてみましょう。<a href="#r_git_reset" class="xref">リセットコマンド詳説</a> で紹介したとおり、ブランチを巻き戻すには <code class="literal">reset</code> を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello</code></pre>
</figure>
<p>マージが取り消されました。続いてトピックブランチをリベースしてみます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout i18n-world
Switched to branch &#39;i18n-world&#39;

<span style="font-weight: bold">$</span> git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved &#39;hello.rb&#39; using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word</code></pre>
</figure>
<p>予想どおり、マージコンフリクトが発生しました。一方、<code class="literal">Resolved FILE using previous resolution</code> というメッセージも出力されています。該当のファイルを確認してみてください。コンフリクトはすでに解消されていて、コンフリクトを示すマーカーは挿入されていないはずです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>

<span style="font-weight: bold">def</span> hello
  puts <span style="font-style: italic">&#39;hola mundo&#39;</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>また、ここで <code class="literal">git diff</code> を実行すると、コンフリクトの再解消がどのように自動処理されたかがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
<span style="font-weight: bold">  #</span>! /usr/bin/env ruby

  def hello
-   puts &#39;hola world&#39;
 -  puts &#39;hello mundo&#39;
++  puts &#39;hola mundo&#39;
  end</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/rerere3.png" alt="rerere3"/>
</div>
</figure>
<p>なお、<code class="literal">checkout</code> コマンドを使うと、ファイルがコンフリクトした状態を再現できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout --conflict=merge hello.rb
<span style="font-weight: bold">$</span> cat hello.rb
<span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts &#39;hola world&#39;
=======
  puts &#39;hello mundo&#39;
<span style="font-weight: bold">&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt; theirs
end</code></pre>
</figure>
<p>これは <a id="xref-r_advanced_merging" href="#r_advanced_merging" class="xref">高度なマージ手法</a> で使用した例と同じ内容ですが、ここでは <code class="literal">rerere</code> を使ってコンフリクトをもう一度解消してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rerere
Resolved &#39;hello.rb&#39; using previous resolution.
<span style="font-weight: bold">$</span> cat hello.rb
<span style="font-weight: bold">#</span>! /usr/bin/env ruby

def hello
  puts &#39;hola mundo&#39;
end</code></pre>
</figure>
<p><code class="literal">rerere</code> がキャッシュした解消方法で、再処理が自動的に行われたようです。結果をインデックスに追加して、リベースを先に進めましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add hello.rb
<span style="font-weight: bold">$</span> git rebase --continue
Applying: i18n one word</code></pre>
</figure>
<p>マージの再実行を何度も行うことがある、頻繁に master ブランチをマージせずにトピックブランチを最新の状態に保ちたい、リベースをよく行う……いずれかに当てはまる場合は <code class="literal">rerere</code> を有効にしておきましょう。日々の生活がちょっとだけ楽になると思います。</p>
</section>
<section class="sect1" title="Git によるデバッグ">
<h2 id="_git_によるデバッグ">Git によるデバッグ</h2>
<p>Git には、プロジェクトで発生した問題をデバッグするためのツールも用意されています。
Git はほとんどあらゆる種類のプロジェクトで使えるように設計されているので、このツールも非常に汎用的なものです。しかし、バグを見つけたり不具合の原因を探したりするための助けとなるでしょう。</p>
<section class="sect2" title="ファイルの注記">
<h3 id="r_file_annotation">ファイルの注記</h3>
<p>コードのバグを追跡しているときに「それが、いつどんな理由で追加されたのか」が知りたくなることがあるでしょう。そんな場合にもっとも便利なのが、ファイルの注記です。
これは、ファイルの各行について、その行を最後に更新したのがどのコミットかを表示します。
もしコードの中の特定のメソッドにバグがあることを見つけたら、そのファイルを <code class="literal">git blame</code> しましょう。そうすれば、そのメソッドの各行がいつ誰によって更新されたのかがわかります。
この例では、<code class="literal">-L</code> オプションを使って 12 行目から 22 行目までに出力を限定しています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &#39;master&#39;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #{tree}&quot;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &#39;master&#39;)
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #{tree}&quot;)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #{path}&quot;)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</code></pre>
</figure>
<p>最初の項目は、その行を最後に更新したコミットの SHA-1 の一部です。
次のふたつの項目は、そのコミットから抽出した作者情報とコミット日時です。これで、いつ誰がその行を更新したのかが簡単にわかります。
それに続いて、行番号とファイルの中身が表示されます。
<code class="literal">^4832fe2</code> のコミットに関する行に注目しましょう。これらの行は、ファイルが最初にコミットされたときのままであることを表します。
このコミットはファイルがプロジェクトに最初に追加されたときのものであり、これらの行はそれ以降変更されていません。
これはちょっと戸惑うかも知れません。Git では、これまで紹介してきただけで少なくとも三種類以上の意味で <code class="literal">^</code> を使っていますからね。しかし、ここではそういう意味になるのです。</p>
<p>Git のすばらしいところのひとつに、ファイルのリネームを明示的には追跡しないということがあります。
スナップショットだけを記録し、もしリネームされていたのなら暗黙のうちにそれを検出します。
この機能の興味深いところは、ファイルのリネームだけでなくコードの移動についても検出できるということです。
<code class="literal">git blame</code> に <code class="literal">-C</code> を渡すと Git はそのファイルを解析し、別のところからコピーされたコード片がないかどうかを探します。
例えば、<code class="literal">GITServerHandler.m</code> というファイルをリファクタリングで複数のファイルに分割したとしましょう。そのうちのひとつが <code class="literal">GITPackUpload.m</code> です。
ここで <code class="literal">-C</code> オプションをつけて <code class="literal">GITPackUpload.m</code> を調べると、コードのどの部分をどのファイルからコピーしたのかを知ることができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</code></pre>
</figure>
<p>これはほんとうに便利です。
通常は、そのファイルがコピーされたときのコミットを知ることになります。コピー先のファイルにおいて最初にその行をさわったのが、その内容をコピーしてきたときだからです。
Git は、その行が本当に書かれたコミットがどこであったのかを (たとえ別のファイルであったとしても) 教えてくれるのです。</p>
</section>
<section class="sect2" title="二分探索">
<h3 id="r_binary_search">二分探索</h3>
<p>ファイルの注記を使えば、その問題がどの時点で始まったのかを知ることができます。
何がおかしくなったのかがわからず、最後にうまく動作していたときから何十何百ものコミットが行われている場合などは、<code class="literal">git bisect</code> に頼ることになるでしょう。
<code class="literal">bisect</code> コマンドはコミットの歴史に対して二分探索を行い、どのコミットで問題が混入したのかを可能な限り手早く見つけ出せるようにします。</p>
<p>自分のコードをリリースして運用環境にプッシュしたあとに、バグ報告を受け取ったと仮定しましょう。そのバグは開発環境では再現せず、なぜそんなことになるのか想像もつきません。
コードをよく調べて問題を再現させることはできましたが、何が悪かったのかがわかりません。
こんな場合に、二分探索で原因を特定することができます。
まず、<code class="literal">git bisect start</code> を実行します。そして次に <code class="literal">git bisect bad</code> を使って、現在のコミットが壊れた状態であることをシステムに伝えます。
次に、まだ壊れていなかったとわかっている直近のコミットを <code class="literal">git bisect good [good_commit]</code> で伝えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect start
<span style="font-weight: bold">$</span> git bisect bad
<span style="font-weight: bold">$</span> git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</code></pre>
</figure>
<p>Git は、まだうまく動いていたと指定されたコミット (v1.0) と現在の壊れたバージョンの間には 12 のコミットがあるということを検出しました。そして、そのちょうど真ん中にあるコミットをチェックアウトしました。
ここでテストを実行すれば、このコミットで同じ問題が発生するかどうかがわかります。
もし問題が発生したなら、実際に問題が混入したのはそれより前のコミットだということになります。そうでなければ、それ以降のコミットで問題が混入したのでしょう。
ここでは、問題が発生しなかったものとします。<code class="literal">git bisect good</code> で Git にその旨を伝え、旅を続けましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</code></pre>
</figure>
<p>また別のコミットがやってきました。先ほど調べたコミットと「壊れている」と伝えたコミットの真ん中にあるものです。
ふたたびテストを実行し、今度はこのコミットで問題が再現したものとします。それを Git に伝えるには <code class="literal">git bisect bad</code> を使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</code></pre>
</figure>
<p>このコミットはうまく動きました。というわけで、問題が混入したコミットを特定するための情報がこれですべて整いました。
Git は問題が混入したコミットの SHA-1 を示し、そのコミット情報とどのファイルが変更されたのかを表示します。これを使って、いったい何が原因でバグが発生したのかを突き止めます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</code></pre>
</figure>
<p>原因がわかったら、作業を始める前に <code class="literal">git bisect reset</code> を実行して HEAD を作業前の状態に戻さなければなりません。そうしないと面倒なことになってしまいます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect reset</code></pre>
</figure>
<p>この強力なツールを使えば、何百ものコミットの中からバグの原因となるコミットを数分で見つけだせるようになります。
実際、プロジェクトが正常なときに 0 を返してどこかおかしいときに 0 以外を返すスクリプトを用意しておけば、<code class="literal">git bisect</code> を完全に自動化することもできます。
まず、先ほどと同じく、壊れているコミットと正しく動作しているコミットを指定します。
これは <code class="literal">bisect start</code> コマンドで行うこともできます。まず最初に壊れているコミット、そしてその後に正しく動作しているコミットを指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bisect start HEAD v1.0
<span style="font-weight: bold">$</span> git bisect run test-error.sh</code></pre>
</figure>
<p>こうすると、チェックアウトされたコミットに対して自動的に <code class="literal">test-error.sh</code> を実行し、壊れる原因となるコミットを見つけ出すまで自動的に処理を続けます。
<code class="literal">make</code> や <code class="literal">make tests</code>、その他自動テストを実行するためのプログラムなどをここで実行させることもできます。</p>
</section>
</section>
<section class="sect1" title="サブモジュール">
<h2 id="r_git_submodules">サブモジュール</h2>
<p>あるプロジェクトで作業をしているときに、プロジェクト内で別のプロジェクトを使わなければならなくなることがよくあります。
サードパーティが開発しているライブラリや、自身が別途開発していて複数の親プロジェクトから利用しているライブラリなどがそれにあたります。
こういったときに出てくるのが「ふたつのプロジェクトはそれぞれ別のものとして管理したい。だけど、一方を他方の一部としても使いたい」という問題です。</p>
<p>例を考えてみましょう。ウェブサイトを制作しているあなたは、Atom フィードを作成することになりました。
Atom 生成コードを自前で書くのではなく、ライブラリを使うことに決めました。
この場合、CPAN や gem などの共有ライブラリからコードをインクルードするか、ソースコードそのものをプロジェクトのツリーに取り込むかのいずれかが必要となります。
ライブラリをインクルードする方式の問題は、ライブラリのカスタマイズが困難であることと配布が面倒になるということです。すべてのクライアントにそのライブラリを導入させなければなりません。
コードをツリーに取り込む方式の問題は、手元でコードに手を加えてしまうと本家の更新に追従しにくくなるということです。</p>
<p>Git では、サブモジュールを使ってこの問題に対応します。
サブモジュールを使うと、ある Git リポジトリを別の Git リポジトリのサブディレクトリとして扱うことができるようになります。
これで、別のリポジトリをプロジェクト内にクローンしても自分のコミットは別管理とすることができるようになります。</p>
<section class="sect2" title="サブモジュールの作り方">
<h3 id="r_starting_submodules">サブモジュールの作り方</h3>
<p>まずは単純な事例を見ていきましょう。大きな1プロジェクトを、メインの1プロジェクトとサブの複数プロジェクトに分割して開発していているとします。</p>
<p>開発を始めるにあたり、作業中のリポジトリのサブモジュールとして既存のリポジトリを追加します。サブモジュールを新たに追加するには <code class="literal">git submodule add</code> コマンドを実行します。追跡したいプロジェクトの URL （絶対・相対のいずれも可）を引数に指定してください。この例では、“DbConnector” というライブラリを追加してみます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/DbConnector
Cloning into &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</figure>
<p>デフォルトでは、このコマンドで指定したリポジトリと同名のディレクトリに、サブプロジェクトのデータが格納されます。他のディレクトリを使いたい場合は、コマンドの末尾にパスを追加してください。</p>
<p>ここで <code class="literal">git status</code> を実行してみましょう。いくつか気づくことがあるはずです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.

Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   .gitmodules
	new file:   DbConnector</code></pre>
</figure>
<p>まず気づくのが、新たに追加された <code class="literal">.gitmodules</code> ファイルです。
この設定ファイルには、プロジェクトの URL とそれを取り込んだローカルサブディレクトリの対応が格納されています。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[submodule &quot;DbConnector&quot;]</span>
	path = <span style="font-style: italic">DbConnector</span>
<span style="font-style: italic">	url = https://github.com/chaconinc/DbConnector</span></code></pre>
</figure>
<p>複数のサブモジュールを追加した場合は、このファイルに複数のエントリが書き込まれます。
このファイルもまた他のファイルと同様にバージョン管理下に置かれることに注意しましょう。<code class="literal">.gitignore</code> ファイルと同じことです。
プロジェクトの他のファイルと同様、このファイルもプッシュやプルの対象となります。
プロジェクトをクローンした人は、このファイルを使ってサブモジュールの取得元を知ることになります。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p><code class="literal">.gitmodules</code> ファイルに記述された URL を他の利用者はまずクローン/フェッチしようとします。よって、可能であればそういった人たちもアクセスできる URL を使うようにしましょう。もし、自分がプッシュする URL と他の利用者がプルする URL が違う場合は、他の利用者もアクセスできる URL をここでは使ってください。そのうえで、<code class="literal">git config submodule.DbConnector.url PRIVATE_URL</code> コマンドを使って自分用の URL を手元の環境に設定するのがいいでしょう。
可能であれば、相対 URL にしておくと便利だと思います。</p>
</div>
</aside>
<p>また、<code class="literal">git status</code> の出力にプロジェクトフォルダも含まれています。
これに対して <code class="literal">git diff</code> を実行すると、ちょっと興味深い結果が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</code></pre>
</figure>
<p><code class="literal">DbConnector</code> は作業ディレクトリ内にあるサブディレクトリですが、Git はそれがサブモジュールであるとみなし、あなたがそのディレクトリにいない限りその中身を追跡することはありません。
そのかわりに、Git はこのサブディレクトリを元のプロジェクトの特定のコミットとして記録します。</p>
<p>差分表示をもうすこしちゃんとさせたいのなら、<code class="literal">git diff</code> コマンドの <code class="literal">--submodule</code> オプションを使いましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule &quot;DbConnector&quot;]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)</code></pre>
</figure>
<p>コミットすると、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;added DbConnector module&#39;</span>
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector</code></pre>
</figure>
<p><code class="literal">DbConnector</code> エントリのモードが <code class="literal">160000</code> となったことに注目しましょう。
これは Git における特別なモードで、サブディレクトリやファイルではなくディレクトリエントリとしてこのコミットを記録したことを意味します。</p>
</section>
<section class="sect2" title="サブモジュールを含むプロジェクトのクローン">
<h3 id="r_cloning_submodules">サブモジュールを含むプロジェクトのクローン</h3>
<p>ここでは、内部にサブモジュールを含むプロジェクトをクローンしてみます。
デフォルトでは、サブモジュールを含むディレクトリは取得できますがその中にはまだ何もファイルが入っていません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/chaconinc/MainProject
Cloning into &#39;MainProject&#39;...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> cd MainProject
<span style="font-weight: bold">$</span> ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
<span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> ls
<span style="font-weight: bold">$</span></code></pre>
</figure>
<p><code class="literal">DbConnector</code> ディレクトリは存在しますが、中身が空っぽです。
ここで、ふたつのコマンドを実行しなければなりません。まず <code class="literal">git submodule init</code> でローカルの設定ファイルを初期化し、次に <code class="literal">git submodule update</code> でプロジェクトからのデータを取得し、親プロジェクトで指定されている適切なコミットをチェックアウトします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule init
Submodule &#39;DbConnector&#39; (https://github.com/chaconinc/DbConnector) registered for path &#39;DbConnector&#39;
<span style="font-weight: bold">$</span> git submodule update
Cloning into &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path &#39;DbConnector&#39;: checked out &#39;c3f01dc8862123d317dd46284b05b6892c7b29bc&#39;</code></pre>
</figure>
<p>これで、サブディレクトリ <code class="literal">DbConnector</code> の中身が先ほどコミットしたときとまったく同じ状態になりました。</p>
<p>また、これをもうすこし簡単に済ませるには、<code class="literal">git clone</code> コマンドの <code class="literal">--recursive</code> オプションを使いましょう。そうすると、リポジトリ内のサブモジュールをすべて初期化し、データを取得してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone --recursive https://github.com/chaconinc/MainProject
Cloning into &#39;MainProject&#39;...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule &#39;DbConnector&#39; (https://github.com/chaconinc/DbConnector) registered for path &#39;DbConnector&#39;
Cloning into &#39;DbConnector&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path &#39;DbConnector&#39;: checked out &#39;c3f01dc8862123d317dd46284b05b6892c7b29bc&#39;</code></pre>
</figure>
</section>
<section class="sect2" title="サブモジュールを含むプロジェクトでの作業">
<h3 id="_サブモジュールを含むプロジェクトでの作業">サブモジュールを含むプロジェクトでの作業</h3>
<p>さて、サブモジュールを含むプロジェクトのデータをコピーできましたので、メインとサブ、両方のプロジェクトでの共同作業をしてみましょう。</p>
<section class="sect3" title="上流の変更の取り込み">
<h4 id="_上流の変更の取り込み">上流の変更の取り込み</h4>
<p>まずはサブモジュールの使用例で一番シンプルなモデルを見ていきます。それは、サブプロジェクトをただ単に使うだけ、というモデルです。上流の更新はときどき取り込みたいけれど、チェックアウトした内容を変更したりはしない、という使い方になります。</p>
<p>サブモジュールが更新されているかどうかを調べるには、サブモジュールのディレクトリで <code class="literal">git fetch</code> を実行します。併せて <code class="literal">git merge</code> で上流のブランチをマージすれば、チェックアウトしてあるコードを更新できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -&gt; origin/master
<span style="font-weight: bold">$</span> git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)</code></pre>
</figure>
<p>ここでメインプロジェクトのディレクトリに戻って <code class="literal">git diff --submodule</code> を実行してみてください。サブモジュールが更新されたこと、どのコミットがサブモジュールに追加されたかがわかるでしょう。なお、<code class="literal">git diff</code> の <code class="literal">--submodule</code> オプションを省略したい場合は、設定項目 <code class="literal">diff.submodule</code> の値に “log” を指定してください。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global diff.submodule log
<span style="font-weight: bold">$</span> git diff
Submodule DbConnector c3f01dc..d0354fc:
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>この状態でコミットしておけば、他の人がサブモジュールを更新したときに新しい内容が取り込まれるようになります。</p>
<p>サブモジュールのディレクトリでのフェッチとマージを手動で行いたくない人のために、もう少し簡単な方法も紹介しておきます。<code class="literal">git submodule update --remote</code> です。これを使えば、ディレクトリに入ってフェッチしてマージして、という作業がコマンドひとつで済みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -&gt; origin/master
Submodule path &#39;DbConnector&#39;: checked out &#39;d0354fc054692d3906c85c3af05ddce39a1c0644&#39;</code></pre>
</figure>
<p>なお、このコマンドはデフォルトでは、サブモジュールのリポジトリの <code class="literal">master</code> ブランチの内容まで手元にチェックアウトした内容を更新する、という前提で動作します。ですが、そうならないよう設定することもできます。たとえば、DbConnector サブモジュールを “stable” ブランチに追従させたいとしましょう。その場合、<code class="literal">.gitmodules</code> ファイルに記述することもできますし（そうすれば、みんなが同じ設定を共有できます）、手元の <code class="literal">.git/config</code> ファイルに記述しても構いません。以下は <code class="literal">.gitmodules</code> に記述した場合の例です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config -f .gitmodules submodule.DbConnector.branch stable

<span style="font-weight: bold">$</span> git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -&gt; origin/stable
Submodule path &#39;DbConnector&#39;: checked out &#39;c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687&#39;</code></pre>
</figure>
<p>また、この設定コマンドから <code class="literal">-f .gitmodules</code> の部分を除くと、設定は手元の環境に対してのみ反映されます。ただ、この設定はリポジトリにコミットして追跡しておくほうがよいと思います。関係者全員が同じ設定を共有できるからです。</p>
<p>ここで <code class="literal">git status</code> を実行すると、「新しいコミット」（“new commits”）がサブモジュールに追加されたことがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p>さらに、設定項目 <code class="literal">status.submodulesummary</code> を指定しておけば、リポジトリ内のサブモジュールの変更点の要約も確認できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config status.submodulesummary 1

<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  &gt; catch non-null terminated lines</code></pre>
</figure>
<p>この段階で`git diff` を実行すると、<code class="literal">.gitmodules</code> ファイルが変更されていることがわかります。
また、サブモジュールについては、上流からコミットがすでにいくつも取得されていて、手元のリポジトリでコミット待ちの状態になっていることがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule &quot;DbConnector&quot;]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>手元のサブモジュールにこれから何をコミットしようとしているのかがわかるので、これはとても便利です。また、実際にコミットしたあとでも、<code class="literal">git log -p</code> を使えばこの情報は確認できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule &quot;DbConnector&quot;]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</figure>
<p>なお、<code class="literal">git submodule update --remote</code> を実行すると、デフォルトではすべてのサブモジュールの更新が行われます。よって、サブモジュールが多い場合は更新したいものだけを指定するとよいでしょう。</p>
</section>
<section class="sect3" title="サブモジュールでの作業">
<h4 id="_サブモジュールでの作業">サブモジュールでの作業</h4>
<p>サブモジュールを使う動機を考えてみましょう。その多くは、メインプロジェクトで（あるいは複数のサブモジュールに渡って）作業をしつつ、サブモジュールのコードも変更したいから、だと思います。というのも、そうでなければ Maven や Rubygems のようなシンプルな依存関係管理の仕組みを使っているはずだからです。</p>
<p>ということでここでは、メインプロジェクトとサブモジュールを行ったり来たりしながら変更を加えていく方法を見ていきましょう。併せて、それらを同時にコミット/公開する方法も紹介します。</p>
<p>これまでの例では、<code class="literal">git submodule update</code> コマンドを実行してサブモジュールのリモートリポジトリの変更内容を取得すると、サブモジュール用ディレクトリ内のファイルは更新されますが、手元のサブモジュール用リポジトリの状態は「切り離された HEAD (detached HEAD)」になってしまっていました。つまり、作業中のブランチ（“master” など）は存在せず、変更も追跡されない、ということです。
このままでは、たとえサブモジュールになにかコミットを追加したとしても、`git submodule update`を実行したタイミングで追加した内容はなくなってしまうことになります。そういった事態を避け、サブモジュールに追加した内容をちゃんと記録するには、事前準備が必要なのです。</p>
<p>では、どうすればサブモジュールをハックしやすくなるでしょうか。やるべきことは2つです。まず、サブモジュール用のディレクトリで、作業用のブランチをチェックアウトしましょう。次に、何らかの変更をサブモジュールに加えたあとに <code class="literal">git submodule update --remote</code> を実行して上流から変更をプルした場合の挙動を設定します。手元の変更内容に上流の変更をマージするか、手元の変更内容を上流の変更にリベースするかのいずれかを選択することになります。</p>
<p>実際にやってみましょう。まず、サブモジュール用のディレクトリに入って、作業用のブランチをチェックアウトします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout stable
Switched to branch &#39;stable&#39;</code></pre>
</figure>
<p>次の手順ですが、ここでは「マージ」することにします.実施のたびに指定するのであれば、<code class="literal">update</code> コマンド実行時に <code class="literal">--merge</code> オプションを使います。以下の例では、サーバーにあるサブモジュールのデータは変更されていて、それがマージされていることがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -&gt; origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path &#39;DbConnector&#39;: merged in &#39;92c7337b30ef9e0893e758dac2459d07362ab5ea&#39;</code></pre>
</figure>
<p>DbConnector ディレクトリを見ると、上流の変更が手元の <code class="literal">stable</code> ブランチに取り込み済みであるとわかります。では次に、手元のファイルに変更を加えている間に、別の変更が上流にプッシュされたらどうなるかを説明しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> vim src/db.c
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;unicode support&#39;</span>
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)</code></pre>
</figure>
<p>この段階でサブモジュールを更新してみましょう。手元のファイルは変更済みで、上流にある別の変更も取り込む必要がある場合、何が起こるかがわかるはずです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path &#39;DbConnector&#39;: rebased into &#39;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&#39;</code></pre>
</figure>
<p><code class="literal">--rebase</code> や <code class="literal">--merge</code> オプションを付け忘れると、サブモジュールはサーバー上の状態で上書きされ、「切り離された HEAD」状態になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote
Submodule path &#39;DbConnector&#39;: checked out &#39;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&#39;</code></pre>
</figure>
<p>ただ、こうなってしまっても慌てる必要はありません。サブモジュールのディレクトリに戻れば、変更を追加したブランチをチェックアウトできます。そのうえで、<code class="literal">origin/stable</code> （などの必要なリモートブランチ）を手動でマージなりリベースなりすればよいのです。</p>
<p>また、手元で加えた変更をコミットしていない状態でサブモジュールを更新したとしましょう。これは問題になりそうですが、実際はそうなりません。リモートの変更だけが取得され、サブモジュール用ディレクトリに加えた変更でコミットしていないものはそのまま残ります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -&gt; origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout &#39;c75e92a2b3855c9e5b66f915308390d9db204aca&#39; in submodule path &#39;DbConnector&#39;</code></pre>
</figure>
<p>手元で加えた変更が上流の変更とコンフリクトする場合は、サブモジュール更新を実施したときにわかるようになっています。
If you made changes that conflict with something changed upstream, Git will let you know when you run the update.</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for &#39;scripts/setup.sh&#39;
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge &#39;c75e92a2b3855c9e5b66f915308390d9db204aca&#39; in submodule path &#39;DbConnector&#39;</code></pre>
</figure>
<p>そうなったら、サブモジュール用ディレクトリのファイルを編集しましょう。いつものようにコンフリクトを解消できます。</p>
</section>
<section class="sect3" title="サブモジュールに加えた変更の公開">
<h4 id="r_publishing_submodules">サブモジュールに加えた変更の公開</h4>
<p>これまでの作業で、サブモジュール用ディレクトリの内容は変更されています。上流の変更を取り込みましたし、手元でも変更を加えました。そして、後者の存在は誰もまだ知りません。プッシュされていないからです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
Submodule DbConnector c87d55d..82d2ad3:
  &gt; Merge from origin/stable
  &gt; updated setup script
  &gt; unicode support
  &gt; remove unnecessary method
  &gt; add new option for conn pooling</code></pre>
</figure>
<p>メインプロジェクトに変更をコミットしてプッシュしたけれど、サブモジュールの変更はプッシュしていないとします。その場合、プッシュされたリポジトリをチェックアウトしようとしてもうまくいかないでしょう。メインプロジェクトの変更が依存しているサブモジュールの変更を、取得する手段がないからです。必要とされる変更内容は、手元の環境にしかありません。</p>
<p>こういった状態にならないよう、サブモジュールの変更がプッシュ済みかどうかを事前に確認する方法があります。メインプロジェクトをプッシュするときに使う <code class="literal">git push</code> コマンドの、 <code class="literal">--recurse-submodules</code> オプションです。 これを “check” か “on-demand” のいずれかに設定します。“check” に設定すれば、サブモジュールの変更でプッシュされていないものがある場合、メインプロジェクトのプッシュは失敗するようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.</code></pre>
</figure>
<p>ご覧のとおり、事態を解決する方法もいくつか提示されます。そのなかで一番単純なのは、全サブモジュールを個別にプッシュしてまわる方法です。サブモジュールの変更が公開された状態になれば、メインプロジェクトのプッシュもうまくいくでしょう。</p>
<p>他にも、このオプションを “on-demand” に設定する方法があります。そうすると、さきほど「単純」といった手順をすべて実行してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push --recurse-submodules=on-demand
Pushing submodule &#39;DbConnector&#39;
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -&gt; stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -&gt; master</code></pre>
</figure>
<p>そうです、DbConnector モジュールがプッシュされたあと、メインプロジェクトがプッシュされています。もしサブモジュールのプッシュが何らかの理由で失敗すれば、メインプロジェクトのプッシュも失敗するようになっています。</p>
</section>
<section class="sect3" title="変更されたサブモジュールのマージ">
<h4 id="_変更されたサブモジュールのマージ">変更されたサブモジュールのマージ</h4>
<p>サブモジュールの参照を他の人と同じタイミングで変更してしまうと、問題になる場合があります。つまり、サブモジュールの歴史が分岐してしまい、その状態が両者の手元にあるメインプロジェクトにコミットされ、ブランチも分岐した状態になってしまいます。これを解消するのは厄介です。</p>
<p>この場合でも、一方のコミットがもう一方のコミットの直系の先祖である場合、新しいほうのコミットがマージされます（fast-forward なマージ）。何も問題にはなりません。</p>
<p>ただし、“trivial” なマージすら行われないケースがあります。具体的には、サブモジュールのコミットが分岐してマージする必要があるようなケースです。その場合、以下のような状態になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -&gt; origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>何が起こったのでしょうか。まず、サブモジュールの歴史の分岐点になっているブランチが2つあって、マージする必要があることがわかります。次に、“merge following commits not found” であることもわかります。え、何がわかったの？と思った方、ご安心ください。もう少し先で説明します。</p>
<p>この問題を解決するには、サブモジュールがどういった状態にあるべきかを把握しなければなりません。ですが、いつもとは違い、上記の Git コマンド出力からは有用な情報は得られません。分岐してしまった歴史で問題となっているコミット SHA-1 すら表示されません。ただ、ありがたいことに、それらは簡単に確認できます。<code class="literal">git diff</code> を実行してみましょう。マージしようとしていた両ブランチのコミット SHA-1 が表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector</code></pre>
</figure>
<p>この例では、コミット <code class="literal">eb41d76</code> は <strong>手元</strong> のサブモジュールに追加されていたもので、コミット <code class="literal">c771610</code> は上流にあったものであることがわかります。さきほどのマージでは処理が行えなかったので、サブモジュール用ディレクトリの最新コミットは <code class="literal">eb41d76</code> のはずです。何らかの理由で仮にそうなっていなければ、そのコミットが最新になっているブランチを作成し、チェックアウトすればよいでしょう。</p>
<p>注目すべきは上流のコミット SHA-1 です。マージしてコンフリクトを解消しなければなりません。SHA-1 を直接指定してマージしてみてもよいですし、該当のコミットを指定して作ったブランチをマージしても構いません。どちらかと言えば後者がオススメです（マージコミットのメッセージがわかりやすくなるくらいのメリットしかありませんが）。</p>
<p>では実際にやってみましょう。サブモジュール用ディレクトリで該当のコミット（さきほどの <code class="literal">git diff</code> の2番目の SHA-1）を指定してブランチを作り、手動でマージしてみます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector

<span style="font-weight: bold">$</span> git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

<span style="font-weight: bold">$</span> git branch try-merge c771610
<span style="font-weight: bold">(DbConnector) $</span> git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for &#39;src/main.c&#39;
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>そうすると、実際にどこがコンフリクトしているかがわかります。それを解決してコミットすれば、その結果をもとにメインプロジェクトがアップデートできる、というわけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim src/main.c <i class="conum" data-value="1">①</i>
<span style="font-weight: bold">$</span> git add src/main.c
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;merged our changes&#39;</span>
Recorded resolution for &#39;src/main.c&#39;.
[master 9fd905e] merged our changes

<span style="font-weight: bold">$</span> cd .. <i class="conum" data-value="2">②</i>
<span style="font-weight: bold">$</span> git diff <i class="conum" data-value="3">③</i>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
<span style="font-weight: bold">$</span> git add DbConnector <i class="conum" data-value="4">④</i>

<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Merge Tom&#39;s Changes&quot;</span> <i class="conum" data-value="5">⑤</i>
[master 10d2c60] Merge Tom&#39;s Changes</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> まずはコンフリクトを解決します</li>
<li><i class="conum" data-value="2">②</i> 次にメインプロジェクトのディレクトリに戻ります</li>
<li><i class="conum" data-value="3">③</i> SHA を改めて確認します</li>
<li><i class="conum" data-value="4">④</i> コンフリクトしていたサブモジュールの登録を解決します</li>
<li><i class="conum" data-value="5">⑤</i> マージした内容をコミットします</li>
</ol>
</div>
<p>少しややこしいかもしれませんが、そう難しくはないはずです。</p>
<p>また、こういったときに別の方法で処理されることもあります。
サブモジュール用ディレクトリの歴史にマージコミットがあって、上述した <strong>両方</strong> のコミットがすでにマージされている場合です。それを用いてもコンフリクトを解消できます。サブモジュールの歴史を確認した Git からすれば、「該当のコミットふたつが含まれたブランチを、誰かがすでにマージしてるよ。それでいいんじゃない？」というわけです。</p>
<p>これは、さきほど説明を省略したエラーメッセージ “merge following commits not found” の原因でもあります。1つめの例、このエラーメッセージを初めて紹介したときは <strong>この方法</strong> は使えなかったからです。わかりにくいのも当然で、誰もそんなことが <strong>行われようとしてる</strong> なんて思わないですよね。</p>
<p>この方法で処理するのに使えそうなマージコミットが見つかると、以下のようなメッセージが表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a &quot;DbConnector&quot;

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</figure>
<p>インデックスを更新してコミットしましょう、ということのようです。<code class="literal">git add</code> コマンドを実行してコミットを解消するのと同じですね。ただ、素直にそうするのはやめておいたほうがよさそうです。その代わり、サブモジュール用ディレクトリの差分を確認し、指示されたコミットまで fast-forward すればいいでしょう。そうすれば、きちんとテストしてからコミットできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd DbConnector/
<span style="font-weight: bold">$</span> git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

<span style="font-weight: bold">$</span> cd ..
<span style="font-weight: bold">$</span> git add DbConnector
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;Fast forwarded to a common submodule child&#39;</span></code></pre>
</figure>
<p>この方法でも処理結果は代わりません。そのうえ、きちんと動作するか確認できますし、作業が終わった後にもサブモジュール用ディレクトリにはコードが残ることになります。</p>
</section>
</section>
<section class="sect2" title="サブモジュールのヒント">
<h3 id="_サブモジュールのヒント">サブモジュールのヒント</h3>
<p>サブモジュールを使った作業の難しさを和らげてくれるヒントをいくつか紹介します。</p>
<section class="sect3" title="Submodule Foreach">
<h4 id="_submodule_foreach">Submodule Foreach</h4>
<p>submodule <code class="literal">foreach</code> コマンドを使うと、サブモジュールごとに任意のコードを実行してくれます。たくさんのサブモジュールをプロジェクトで使っていれば、便利だと思います。</p>
<p>例えば、新機能の開発やバグ修正を着手したいとします。ただし、使っているサブモジュールに加えた変更がまだコミットされていません。この場合、そのコミットされていない状態は簡単に隠しておけます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule foreach <span style="font-style: italic">&#39;git stash&#39;</span>
Entering &#39;CryptoLibrary&#39;
No local changes to save
Entering &#39;DbConnector&#39;
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable</code></pre>
</figure>
<p>うまく隠せたら、全サブモジュールで新しいブランチを作ってチェックアウトします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git submodule foreach <span style="font-style: italic">&#39;git checkout -b featureA&#39;</span>
Entering &#39;CryptoLibrary&#39;
Switched to a new branch &#39;featureA&#39;
Entering &#39;DbConnector&#39;
Switched to a new branch &#39;featureA&#39;</code></pre>
</figure>
<p>どうでしょう、簡単だと思いませんか。他にも、メインプロジェクトとサブプロジェクトの変更内容の差分をユニファイド形式でとることも可能です。これもとても便利です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff; git submodule foreach <span style="font-style: italic">&#39;git diff&#39;</span>
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering &#39;DbConnector&#39;
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;</code></pre>
</figure>
<p>この例では、サブモジュールで関数が定義され、メインプロジェクトでそれを呼び出していることがわかります。簡易な例ではありますが、どんなふうに便利なのかわかったかと思います。</p>
</section>
<section class="sect3" title="便利なエイリアス">
<h4 id="_便利なエイリアス">便利なエイリアス</h4>
<p>紹介してきたコマンドの一部には、エイリアスを設定しておくとよいかもしれません。長いものが多いですし、紹介した挙動がデフォルトになるようには設定できないものが大半だからです。Git でエイリアスを設定する方法は <a id="xref--ch02-git-basics--r_git_aliases" href="ch02-git-basics.xhtml#r_git_aliases" class="xref">Git エイリアス</a> で触れましたが、ここでも設定例を紹介しておきます。Git のサブモジュール機能を多用する場合は、参考にしてみてください。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config alias.sdiff <span style="font-style: italic">&#39;!&#39;&quot;git diff &amp;&amp; git submodule foreach &#39;git diff&#39;&quot;</span>
<span style="font-weight: bold">$</span> git config alias.spush <span style="font-style: italic">&#39;push --recurse-submodules=on-demand&#39;</span>
<span style="font-weight: bold">$</span> git config alias.supdate <span style="font-style: italic">&#39;submodule update --remote --merge&#39;</span></code></pre>
</figure>
<p>このように設定しておくと、<code class="literal">git supdate</code> コマンドを実行すればサブモジュールが更新されるようになります。同様に、<code class="literal">git spush</code> コマンドであれば、サブモジュールの依存関係をチェックしたあとでプッシュするようになります。</p>
</section>
</section>
<section class="sect2" title="サブモジュール使用時に気をつけるべきこと">
<h3 id="_サブモジュール使用時に気をつけるべきこと">サブモジュール使用時に気をつけるべきこと</h3>
<p>しかし、サブモジュールを使っているとなにかしらちょっとした問題が出てくるものです。</p>
<p>例えば、サブモジュールを含むブランチを切り替えるのは、これまた用心が必要です。
新しいブランチを作成してそこにサブモジュールを追加し、サブモジュールを含まないブランチに戻ったとしましょう。そこには、サブモジュールのディレクトリが「追跡されていないディレクトリ」として残ったままになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b add-crypto
Switched to a new branch &#39;add-crypto&#39;

<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into &#39;CryptoLibrary&#39;...
...

<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;adding crypto library&#39;</span>
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

<span style="font-weight: bold">$</span> git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch &#39;master&#39;
Your branch is up-to-date with &#39;origin/master&#39;.

<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
</figure>
<p>残ったディレクトリを削除するのは大変ではありませんが、そもそもそこにディレクトリが残ってしまうのはややこしい感じがします。実際に削除したあとに元のブランチをチェックアウトすると、モジュールを再追加するために <code class="literal">submodule update --init</code> コマンドを実行しなければなりません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clean -fdx
Removing CryptoLibrary/

<span style="font-weight: bold">$</span> git checkout add-crypto
Switched to branch &#39;add-crypto&#39;

<span style="font-weight: bold">$</span> ls CryptoLibrary/

<span style="font-weight: bold">$</span> git submodule update --init
Submodule path &#39;CryptoLibrary&#39;: checked out &#39;b8dda6aa182ea4464f3f3264b11e0268545172af&#39;

<span style="font-weight: bold">$</span> ls CryptoLibrary/
Makefile	includes	scripts		src</code></pre>
</figure>
<p>繰り返しになりますが、大変ではないけれどややこしい感じがしてしまいます。</p>
<p>次にもうひとつ、多くの人がハマるであろう点を指摘しておきましょう。これは、サブディレクトリからサブモジュールへ切り替えるときに起こることです。
プロジェクト内で追跡しているファイルをサブモジュール内に移動したくなったとしましょう。よっぽど注意しないと、Git に怒られてしまいます。
ファイルをプロジェクト内のサブディレクトリで管理しており、それをサブモジュールに切り替えたくなったとしましょう。
サブディレクトリをいったん削除してから <code class="literal">submodule add</code> と実行すると、Git に怒鳴りつけられてしまいます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm -Rf CryptoLibrary/
<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
&#39;CryptoLibrary&#39; already exists in the index</code></pre>
</figure>
<p>まず最初に <code class="literal">CryptoLibrary</code> ディレクトリをアンステージしなければなりません。
それからだと、サブモジュールを追加することができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm -r CryptoLibrary
<span style="font-weight: bold">$</span> git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into &#39;CryptoLibrary&#39;...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</figure>
<p>これをどこかのブランチで行ったとしましょう。
そこから、(まだサブモジュールへの切り替えがすんでおらず実際のツリーがある状態の) 別のブランチに切り替えようとすると、このようなエラーになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting</code></pre>
</figure>
<p><code class="literal">checkout -f</code> を使えば、強引に切り替えられます。ただし、そうしてしまうと未保存の状態はすべて上書きされてしまいます。強引に切り替えるのであれば、すべて保存済みであることをよく確認してから実行してください。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch &#39;master&#39;</code></pre>
</figure>
<p>さて、戻ってきたら、なぜか <code class="literal">CryptoLibrary</code> ディレクトリは空っぽです。しかも、ここで <code class="literal">git submodule update</code> を実行しても状況は変わらないかもしれません。そんな場合は、サブモジュール用のディレクトリで <code class="literal">git checkout .</code> を実行してください。ファイルが元通りになっているはずです。サブモジュールが複数ある場合は、<code class="literal">submodule foreach</code> スクリプトを使ったこの方法を全サブモジュールに対して実行するとよいでしょう。</p>
<p>最後にひとつ、大事なことを説明しておきます。相当古いバージョンの Git でなければ、サブモジュール関連の Git データはメインプロジェクトの <code class="literal">.git</code> ディレクトリに保存されます。古いバージョンを使っていなければ、サブモジュール用ディレクトリを削除してもコミットやブランチのデータは残ったままです。</p>
<p>この節で説明したツールを使ってみてください。依存関係にある複数プロジェクトを、サブモジュールを使ってわかりやすく効率的に開発できるはずです。</p>
</section>
</section>
<section class="sect1" title="バンドルファイルの作成">
<h2 id="r_bundling">バンドルファイルの作成</h2>
<p>Git データをネットワーク越しに転送する方法（HTTP や SSH など）についてはすでに触れましたが、まだ紹介していない方法があります。あまり使われてはいませんが、とても便利な方法です。</p>
<p>Git では、データを「バンドルファイル」という1つのファイルにまとめられます。これが便利な場面はいくつもあるでしょう。例えば、ネットワークが落ちていて同僚に変更を送れないような場合。あるいは、いつもとは違う場所で仕事をしていて、セキュリティ上の理由によってネットワークへのアクセスが禁止されているのかもしれません。無線/有線LAN用のカードが壊れてしまったとか。もしくは、共有サーバーにはアクセス出来ないので作業内容をメールで送りたいけれど、かといって40ものコミットを <code class="literal">format-patch</code> を使って送りたくはない、ということかもしれません。</p>
<p>そんなとき、<code class="literal">git bundle</code> コマンドが役に立つでしょう。このコマンドを使うと、<code class="literal">git push</code> コマンドで転送されるのと同内容のデータを単一のバイナリファイルにまとめてくれます。あとは、そのファイルをメールで送るか USB メモリに入れるなどしておいて、別のリポジトリ上で展開すればいいのです。</p>
<p>コミットが2つあるリポジトリを使って、簡単な例を紹介します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit</code></pre>
</figure>
<p>このリポジトリを相手に送りたいのだけど、プッシュすべきリポジトリの書き込み権限が付与されていないとしましょう（あるいは、わざわざ権限を設定したくなかったのかもしれません）。そういった場合には、<code class="literal">git bundle create</code> コマンドを使うとそのリポジトリをまとめられます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)</code></pre>
</figure>
<p>これで、<code class="literal">repo.bundle</code> というファイルが生成されました。対象リポジトリの <code class="literal">master</code> ブランチを復元できるだけのデータが含まれたファイルです。この <code class="literal">bundle</code> コマンドを使うには、まとめたい対象を範囲指定されたコミットや参照の形で指定する必要があります。クローン元となる予定であれば、HEAD を参照として追加しておくほうがよいでしょう（上記の例と同様）。</p>
<p>この <code class="literal">repo.bundle</code> ファイルはメールで送ってもいいですし、USB メモリに入れて持っていってもかまいません。</p>
<p>では、この <code class="literal">repo.bundle</code> ファイルを受け取った側はどうなるのでしょうか。該当のプロジェクトで作業をしたいとします。その場合、このバイナリファイルをディレクトリ上にクローンできます。URL を指定してクローンするのとなんら変わりありません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone repo.bundle repo
Cloning into &#39;repo&#39;...
...
<span style="font-weight: bold">$</span> cd repo
<span style="font-weight: bold">$</span> git log --oneline
9a466c5 second commit
b1ec324 first commit</code></pre>
</figure>
<p>まとめる対象として HEAD が含まれていないと、ここで、 <code class="literal">-b master</code> のように、なんらかのブランチを指定しなければなりません。そうしないと、どのブランチをチェックアウトすべきか、判断する術がないからです。</p>
<p>続いて、さきほど受け取ったリポジトリにコミットを3つ追加しました。バンドルファイルを作成して、USB メモリかメールで送り返してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit</code></pre>
</figure>
<p>それには、バンドルファイルにまとめたいコミット範囲をまず決めます。ネットワークを使った方法であれば転送すべき範囲を最小限に自動で絞り込んでくれますが、ここでは手動で絞りこまねばなりません。最初にバンドルファイルを作ったときのようにリポジトリ全体をまとめてもかまいませんが、差分（この場合は追加したコミット3つ）だけをまとめるほうがよいでしょう。</p>
<p>そうするには、差分を割り出す必要があります。<a id="xref-r_commit_ranges" href="#r_commit_ranges" class="xref">コミットの範囲指定</a> で解説したとおり、コミット範囲を指定する方法はたくさんあります。手元の master ブランチにはあってクローン元のブランチにはないコミット3つを指定するには、<code class="literal">origin/master..master</code> や <code class="literal">master ^origin/master</code> などとするとよいでしょう。記述をテストするには、<code class="literal">log</code> コマンドを使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo</code></pre>
</figure>
<p>対象のコミットがわかったので、ひとつにまとめてみましょう。バンドルファイルのファイル名と対象のコミット範囲を指定して <code class="literal">git bundle create</code> コマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)</code></pre>
</figure>
<p>このようにすると、リポジトリ内に <code class="literal">commits.bundle</code> ファイルが生成されます。そのファイルを送り返すと、受け取った相手は元のリポジトリにその内容を取り込めます。そのリポジトリに他の作業内容が追加されていたとしても問題にはなりません。</p>
<p>バンドルファイルを受け取った側は、それを検査して中身を確認できます。その後、元のリポジトリに取り込めばよいのです。そのためのコマンドが <code class="literal">bundle verify</code> で、これを実行すると、そのファイルが Git のバンドルファイルであること、そのバンドルファイルを取り込むのに必要となる祖先が手元のリポジトリにあるかどうかを検査できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay</code></pre>
</figure>
<p>バンドルファイルを作る側が、追加されたコミット3つのうち2つしかバンドルファイルに含めなかったとしたらどうなるのでしょうか。その場合、元のリポジトリはそれを取り込めません。歴史を再構成するために必要なデータが揃っていないからです。もし <code class="literal">verify</code> コマンドを実行すれば、以下のようになるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</code></pre>
</figure>
<p>この例では、1つめに検査したバンドルファイルは有効だったので、コミットを取り出せます。バンドルファイルに含まれている取り込み可能なブランチを知りたければ、ブランチ参照をリストアップするためのコマンドもあります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master</code></pre>
</figure>
<p><code class="literal">verify</code> サブコマンドを使っても、同様にブランチ参照をリストアップできます。大事なのは、何が取り込めるのかを確認する、ということです。そうすれば、<code class="literal">fetch</code> や <code class="literal">pull</code> コマンドを使ってバンドルファイルからコミットを取り込めるからです。ここでは、バンドルファイルの <em>master</em> ブランチを、手元のリポジトリの <em>other-master</em> ブランチに取り込んでみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -&gt; other-master</code></pre>
</figure>
<p>そうすると、<em>master</em> ブランチに追加したコミットはそのままで、<em>other-master</em> ブランチ上にバンドルファイルからコミットが取り込まれていることがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit</code></pre>
</figure>
<p>このように、データの共有やネットワークを使う作業に <code class="literal">git bundle</code> はとても便利なコマンドです。特にネットワーク環境や共有リポジトリがない状態ではそれを実感できるでしょう。</p>
</section>
<section class="sect1" title="Git オブジェクトの置き換え">
<h2 id="r_replace">Git オブジェクトの置き換え</h2>
<p>Git オブジェクトは変更できません。その代わりに用意されているのが、Git データベース上のオブジェクトを他のオブジェクトと置き換えたかのように見せる方法です。</p>
<p><code class="literal">replace</code> コマンドを使うと、「このオブジェクトを参照するときは、あたかもあちらを参照してるかのように振る舞え」と Git に指示できます。プロジェクトの歴史のなかで、コミットを別のコミットで置き換えたいときに便利です。</p>
<p>具体的な例として、長い歴史を経たコードベースがあって、それを2つに分割するケースを考えてみましょう。1つは短い歴史で新入りの開発者向け、もう1つは長い歴史でデータマイニングを行いたい人向けです。とある歴史を別の歴史と結びつけるには、新しいほうの歴史の最古のコミットを、古いほうの歴史の最新のコミットと置き換えてやればいいのです。これの利点は、そうしておけば新しいほうの歴史のコミットをすべて書き換える必要がなくなることです。通常であれば、歴史をつなぐにはそうせざるを得ません（コミットの親子関係が算出される SHA-1 に影響するため）。</p>
<p>では、既存のリポジトリを使って実際に試してみましょう。まずは、そのリポジトリを最近のものと過去の経緯を把握するためのものの2つに分割してみます。そのうえで、その2つを結合しつつ前者のリポジトリの SHA-1 を変更せずに済ますために <code class="literal">replace</code> を使ってみます。</p>
<p>ここでは、コミットが5つだけある以下のようなリポジトリを使って説明します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>このリポジトリを2つの歴史に分割してみましょう。1つめの歴史はコミット1からコミット4までで、過去の経緯を把握するためのリポジトリです。2つめの歴史はコミット4とコミット5だけで、これは最近の歴史だけのリポジトリになります。</p>
<figure class="image">
<div class="content">
<img src="images/replace1.png" alt="replace1"/>
</div>
</figure>
<p>過去の経緯を把握するための歴史は簡単に取り出せます。過去のコミットを指定してブランチを切り、新たに作成しておいたリモートリポジトリの master としてそのブランチをプッシュすればよいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch history c6e1e95
<span style="font-weight: bold">$</span> git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/replace2.png" alt="replace2"/>
</div>
</figure>
<p>作成した <code class="literal">history</code> ブランチを、新規リポジトリの <code class="literal">master</code> ブランチにプッシュします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add project-history https://github.com/schacon/project-history
<span style="font-weight: bold">$</span> git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -&gt; master</code></pre>
</figure>
<p>これで新たに作った歴史が公開されました。続いて難しいほう、最近の歴史を小さくするための絞り込みです。双方の歴史に重なる部分がないとコミットの置き換え（一方の歴史のコミットをもう一方の歴史の同等のコミットで置き換え）が出来なくなるので、ここでは最近の歴史をコミット4と5だけに絞り込みます（そうすればコミット4が重なることになります）。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>こういったケースでは、ベースとなるコミットを作って、歴史を展開するための手順を説明しておくとよいでしょう。絞りこまれた歴史のベースコミットに行き当たって「この先が知りたいのに」となった開発者達が、次に取るべき手順を把握できるからです。実際にどうするかというと、まずは上述した手順を含めたコミットオブジェクト（これが最近の歴史の方の基点となります）を作り、残りのコミット（コミット4と5）をそれにリベースします。</p>
<p>そのためには、どこで分割するかを決める必要があります。この例ではコミット3、SHA でいうと <code class="literal">9c68fdc</code> です。そのコミットの後ろに、ベースとなるコミットを作成します。このベースコミットは <code class="literal">commit-tree</code> コマンドで作成できます。ツリーを指定して実行すると、親子関係のない新規のコミットオブジェクト SHA-1 が生成されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;get history from blah blah blah&#39;</span> | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p><code class="literal">commit-tree</code> コマンドは、「配管」コマンドと呼ばれているコマンド群のうちの1つです。元々は直接呼び出すために作られたコマンドではなく、<strong>他の</strong> Git コマンドから呼び出して細かい処理をするためのものです。とはいえ、ここで説明しているような一風変わった作業をする際に使うと、低レベルの処理が出来るようになります。ただし、普段使うためのものではありません。配管コマンドの詳細は、<a id="xref--ch10-git-internals--r_plumbing_porcelain" href="ch10-git-internals.xhtml#r_plumbing_porcelain" class="xref">配管（Plumbing）と磁器（Porcelain）</a> に目を通してみてください。</p>
</div>
</aside>
<figure class="image">
<div class="content">
<img src="images/replace3.png" alt="replace3"/>
</div>
</figure>
<p>これでベースとなるコミットができたので、<code class="literal">git rebase --onto</code> を使って残りの歴史をリベースしましょう。<code class="literal">--onto</code> オプションの引数は先ほど実行した <code class="literal">commit-tree</code> コマンドの返り値、リベースの始点はコミット3（保持しておきたい1つめのコミットの親にあたるコミット。<code class="literal">9c68fdc</code>）です。。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit</code></pre>
</figure>
<figure class="image">
<div class="content">
<img src="images/replace4.png" alt="replace4"/>
</div>
</figure>
<p>以上で、仮で作ったベースコミットのうえに最近の歴史をリベースできました。ベースコミットには、必要であれば全歴史を組み直すための手順が含まれた状態です。この歴史を新しいプロジェクトとしてプッシュしておきましょう。もしそのリポジトリがクローンされると、直近のコミット2つとベースコミット（手順含む）だけが取得されます。</p>
<p>では次に、プロジェクトをクローンする側の動きを見ていきましょう。初回のクローンで、全歴史を必要としているとします。
絞りこまれたリポジトリをクローンした状態で全歴史を取得するには、過去の経緯を把握するためのリポジトリをリモートとして追加してフェッチします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/project
<span style="font-weight: bold">$</span> cd project

<span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

<span style="font-weight: bold">$</span> git remote add project-history https://github.com/schacon/project-history
<span style="font-weight: bold">$</span> git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -&gt; project-history/master</code></pre>
</figure>
<p>こうすると、<code class="literal">master</code> ブランチを見れば最近のコミットがわかり、<code class="literal">project-history/master</code> ブランチを見れば過去のコミットがわかるようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

<span style="font-weight: bold">$</span> git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>ここで <code class="literal">git replace</code> を実行すると、これら2つをつなぐことができます。置き換えられるコミット、置き換えるコミットの順に指定して実行しましょう。この例では、<code class="literal">master</code> ブランチのコミット4を、<code class="literal">project-history/master</code> ブランチのコミット4で置き換えることになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git replace 81a708d c6e1e95</code></pre>
</figure>
<p>では、 <code class="literal">master</code> ブランチの歴史を確認してみましょう。以下のようになっているはずです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</code></pre>
</figure>
<p>ね、これいいでしょ？上流の SHA-1 をすべて書き換えることなく、歴史上のコミット1つをまったく別のコミットと置き換えることができました。他の Git ツール（<code class="literal">bisect</code> や <code class="literal">blame</code> など）も、期待通りに動作してくれます。</p>
<figure class="image">
<div class="content">
<img src="images/replace5.png" alt="replace5"/>
</div>
</figure>
<p>1つ気になるのが、表示されている SHA-1 が <code class="literal">81a708d</code> のまま、という点です。実際に使われているデータは、置き換えるのに使ったコミット <code class="literal">c6e1e95</code> のものなのですが……仮に <code class="literal">cat-file</code> のようなコマンドを実行しても、置き換え後のデータが返ってきます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700

fourth commit</code></pre>
</figure>
<p>振り返ってみればわかるように、<code class="literal">81a708d</code> の本当の親は仮のコミット（<code class="literal">622e88e</code>）であって、このコマンド出力にある <code class="literal">9c68fdce</code> ではありません。</p>
<p>もう1つ注目したいのが、参照のなかに保持されているデータです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git <span style="font-weight: bold">for</span>-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040</code></pre>
</figure>
<p>これはつまり、置き換えの内容を簡単に共有できるということです。サーバーにプッシュできるデータですし、ダウンロードするのも簡単です。この節で説明したように歴史を結びつける場合には、この方法は役に立ちません（というのも、全員が両方の歴史をダウンロードしてしまうからです。そうであれば、わざわざ分割する必要はないですよね）。とはいえ、これが役に立つケースもあるでしょう。</p>
</section>
<section class="sect1" title="認証情報の保存">
<h2 id="r_credential_caching">認証情報の保存</h2>
<p>
</p>
<p>SSH を使ってリモートサーバーと接続しているのなら、パスフレーズなしの鍵を使えます。そうすれば、データ転送を安全に行おうとする際に、ユーザー名やパスワードを入力せずにすみます。
一方、HTTP プロトコルの場合はこうはいきません。接続のたびにユーザー名とパスワードが必要です。
さらに大変になるのが二要素認証が必要なシステムの場合です。パスワードと組み合わせて使うトークンはランダムに生成されており、unpronounceable だからです。</p>
<p>さいわい、Git には認証情報の仕組みがあり、上述のような大変さを軽減してくれます。
標準の仕組みで選択可能なオプションは以下のとおりです。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">デフォルトでは、なにもキャッシュされません。
接続するたび、ユーザー名とパスワードを尋ねられます。</span>
</li>
<li>
<span class="principal">“cache” モードにすると、認証情報が一定の間だけメモリーに記憶されます。
パスワードはディスクには保存されません。15分経つとメモリーから除去されます。</span>
</li>
<li>
<span class="principal">“store” モードにすると、認証情報がテキストファイルでディスクに保存されます。有効期限はありません。
ということは、パスワードを変更するまで、認証情報を入力しなくて済むのです。
ただし、パスワードが暗号化なしのテキストファイルでホームディレクトリに保存される、というデメリットがあります。</span>
</li>
<li>
<span class="principal">Mac を使っているなら、Git の “osxkeychain” モードが使えます。これを使うと、OS のキーチェーン（システムアカウントと紐づく）に認証情報がキャッシュされます。
このモードでも認証情報がディスクに保存され、有効期限切れもありません。ただし先ほどとは違い、保存内容は暗号化（HTTPS 証明書や Safari の自動入力の暗号化と同じ仕組み）されます。</span>
</li>
<li>
<span class="principal">Windows を使っているなら、“wincred” という補助ツールがあります。
“osxkeychain” と同じような仕組み（Windows Credential Store）で、重要な情報を管理します。</span>
</li>
</ul>
</div>
<p>このオプションを設定するには、以下のように Git を設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper cache</code></pre>
</figure>
<p>補助ツールには、オプションを設定できる場合があります。
“store” であれば <code class="literal">--file &lt;path&gt;</code> という引数を指定できます。テキストファイルの保存場所を指定するために用いるオプションです（デフォルトは <code class="literal">~/.git-credentials</code>）。
“cache” であれば <code class="literal">--timeout &lt;seconds&gt;</code> という引数を使って、補助ツールのデーモンが動作する時間を設定できます（デフォルトは “900”、15分です）。
“store” 補助ツールのデフォルト設定を変更するには、以下のような設定コマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper store --file ~/.my-credentials</code></pre>
</figure>
<p>また、複数のヘルパーを有効にし設定することもできます。
サーバーの認証情報が必要になると Git はこれらを順番に検索をかけていき、ヒットした時点で検索を中断します。
認証情報を保存する際は、有効なヘルパー <strong>すべて</strong> にユーザー名とパスワードが渡されます。それらをどう処理するかはヘルパー次第です。
以下は、複数のヘルパーを有効にする <code class="literal">.gitconfig</code> の例になります。USB メモリ上に保存されている認証情報を優先して使うけれど、もし USB メモリが使用不可の場合はパスワードを一定期間キャッシュしておく、という設定です。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[credential]</span>
    helper = <span style="font-style: italic">store --file /mnt/thumbdrive/.git-credentials</span>
<span style="font-style: italic">    helper = cache --timeout 30000</span></code></pre>
</figure>
<section class="sect2" title="認証情報保存の裏側">
<h3 id="_認証情報保存の裏側">認証情報保存の裏側</h3>
<p>認証情報を保存する仕組みは、いったいどのようにして動作しているのでしょうか。
認証情報ヘルパーの仕組みを操作する基本となるコマンドは <code class="literal">git credential</code> です。コマンドと標準入力経由での入力が引数になります。</p>
<p>例を見たほうがわかりやすいかもしれません。
仮に、認証情報ヘルパーが有効になっていて、<code class="literal">mygithost</code> というサーバーの認証情報を保存しているとします。
“fill” コマンド（Git がサーバーの認証情報を探すときに呼び出されるコマンド）を使って設定をおこなうと以下のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential fill <i class="conum" data-value="1">①</i>
protocol=https <i class="conum" data-value="2">②</i>
host=mygithost
 <i class="conum" data-value="3">③</i>
protocol=https <i class="conum" data-value="4">④</i>
host=mygithost
username=bob
password=s3cre7
<span style="font-weight: bold">$</span> git credential fill <i class="conum" data-value="5">⑤</i>
protocol=https
host=unknownhost

Username for &#39;https://unknownhost&#39;: bob
Password for &#39;https://bob@unknownhost&#39;:
protocol=https
host=unknownhost
username=bob
password=s3cre7</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> このコマンドで対話モードが始まります。</li>
<li><i class="conum" data-value="2">②</i> すると、標準入力からの入力を Git-credential が待機している状態になります。
ここでは、わかっている内容（プロトコルとホスト名）を入力してみます。</li>
<li><i class="conum" data-value="3">③</i> 空白行を入力すると入力が締め切られます。そうすると、認証システムに保存された内容が返ってくるはずです。</li>
<li><i class="conum" data-value="4">④</i> そうなると Git-credential の出番です。見つかった情報を標準出力に出力します。</li>
<li><i class="conum" data-value="5">⑤</i> 認証情報が見つからない場合は、ユーザーがユーザー名とパスワードを入力することになります。入力された結果は標準出力に返されます（この例では同じコンソール内で処理されています。）。</li>
</ol>
</div>
<p>認証情報システムが呼び出しているプログラムは Git とは別のプログラムです。どのプログラムがどのように呼び出されるかは、<code class="literal">credential.helper</code> という設定によって異なっており、以下の様な値を設定できます。</p>
<div class="table">
<div class="content">
<table class="table table-framed-topbot table-grid-rows" style="width: 100%">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>設定値</th>
<th>挙動</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">foo</code></p></td>
<td><p><code class="literal">git-credential-foo</code> を実行する</p></td>
</tr>
<tr>
<td><p><code class="literal">foo -a --opt=bcd</code></p></td>
<td><p><code class="literal">git-credential-foo -a --opt=bcd</code> を実行する</p></td>
</tr>
<tr>
<td><p><code class="literal">/absolute/path/foo -xyz</code></p></td>
<td><p><code class="literal">/absolute/path/foo -xyz</code> を実行する</p></td>
</tr>
<tr>
<td><p><code class="literal">!f() { echo "password=s3cre7"; }; f</code></p></td>
<td><p><code class="literal">!</code> 以降のコードがシェルで評価される</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>これはつまり、先ほど説明した一連のヘルパーには、<code class="literal">git-credential-cache</code> や <code class="literal">git-credential-store</code> といった名前がつくということです。コマンドライン引数を受け付けるよう設定することもできます。
設定方法は “git-credential-foo [args] &lt;action&gt;.” になります。
なお、標準入出力のプロトコルは git-credential と同じですが、指定できるアクションが少し違ってきます。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal"><code class="literal">get</code> はユーザー名/パスワードの組み合わせを要求するときに使います。</span>
</li>
<li>
<span class="principal"><code class="literal">store</code> はヘルパーのメモリーに認証情報を保持するよう要求するときに使います。</span>
</li>
<li>
<span class="principal"><code class="literal">erase</code> はヘルパーのメモリーから指定したプロパティの認証情報を削除するよう要求するときに使います。</span>
</li>
</ul>
</div>
<p><code class="literal">store</code> と <code class="literal">erase</code> のアクションの場合、レスポンスは必要ありません（Git はレスポンスを無視してしまいますし）。
ですが、<code class="literal">get</code> アクションの場合は、ヘルパーからのレスポンスは Git にとって重要な意味を持ちます。
まず、使える情報を何も保持していないときは、ヘルパーは何も出力せずに終了できます。ですが、何か情報を保持しているときは、渡された情報に対し自身が保持している情報を付加して返さなければなりません。
ヘルパーからの出力は代入文として処理されます。そしてそれを受け取った Git は、既に保持している情報を受け取った情報で置き換えます。</p>
<p>以下の例は先程のものと同じですが、git-credential の部分を省略して git-credential-store のみになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential-store --file ~/git.store store <i class="conum" data-value="1">①</i>
protocol=https
host=mygithost
username=bob
password=s3cre7
<span style="font-weight: bold">$</span> git credential-store --file ~/git.store get <i class="conum" data-value="2">②</i>
protocol=https
host=mygithost

username=bob <i class="conum" data-value="3">③</i>
password=s3cre7</code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> まずここでは、<code class="literal">git-credential-store</code> を呼び出して認証情報を保存しています。この例では、ユーザー名に “bob” 、パスワードに “s3cre7” を使って <code class="literal">https://mygithost</code> にアクセスすることになります。</li>
<li><i class="conum" data-value="2">②</i> では次に、認証情報を呼び出してみます。
わかっている情報 (<code class="literal">https://mygithost</code>) を入力し、それに続いて空行も入力します。</li>
<li><i class="conum" data-value="3">③</i> すると、<code class="literal">git-credential-store</code> が先ほど保存したユーザー名とパスワード返してくれるのです。</li>
</ol>
</div>
<p>この例での <code class="literal">~/git.store</code> は以下のようになっています。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>https://bob:s3cre7@mygithost</code></pre>
</figure>
<p>中身は認証情報つきの URL がずらずらと続く形になっています。
なお、<code class="literal">osxkeychain</code> や <code class="literal">wincred</code> ヘルパーは情報を保存するために独自のフォーマットを使用し、<code class="literal">cache</code> ヘルパーは独自形式でメモリーに情報を保持します（他のプロセスはこの情報にアクセスできません）。</p>
</section>
<section class="sect2" title="独自の認証情報キャッシュ">
<h3 id="_独自の認証情報キャッシュ">独自の認証情報キャッシュ</h3>
<p>「<code class="literal">git-credential-store</code> などのプログラムは Git から独立している。」このことを理解すると、<em>どんな</em> プログラムであれ Git 認証情報ヘルパーとして機能できるということに気づくのもそれほど大変ではないと思います。
Git についてくるヘルパーは多くのユースケースに対応していますが、全てに対応できるわけではありません。
ここでは一例として、あなたのチームには全員が共有している認証情報があるとしましょう。デプロイ用の認証情報であればありえるケースです。
この情報は共有ディレクトリに保存されていますが、自分専用の認証情報としてコピーしておきたくはありません。頻繁に更新されるからです。
既存のヘルパーはどれもこの例には対応していません。この用途に合うヘルパーを作るには何が必要か、順を追って見ていきましょう。
まず、このプログラムには必要不可欠な機能がいくつもあります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">考慮しなければならないアクションは <code class="literal">get</code> だけなので、書き込みのアクションである <code class="literal">store</code> や <code class="literal">erase</code> を受け取った場合は何もせずに終了することにします。</span>
</li>
<li>
<span class="principal">共有されている認証情報のファイルフォーマットは <code class="literal">git-credential-store</code> のものと同様とします。</span>
</li>
<li>
<span class="principal">同ファイルはみんなが知っているような場所に保存されていますが、もしもの場合に備えてファイルのパスを指定できるようにしておきます。</span>
</li>
</ol>
</div>
<p>繰り返しになりますが、今回はこの拡張を Ruby で書いていきますが実際はどんな言語でも書くことができます。できあがった拡張をGit が実行さえできれば問題ありません。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

require <span style="font-style: italic">&#39;optparse&#39;</span>

path = File.expand_path <span style="font-style: italic">&#39;~/.git-credentials&#39;</span> <i class="conum" data-value="1">①</i>
OptionParser.new <span style="font-weight: bold">do</span> |opts|
    opts.banner = <span style="font-style: italic">&#39;USAGE: git-credential-read-only [options] &lt;action&gt;&#39;</span>
    opts.on(<span style="font-style: italic">&#39;-f&#39;</span>, <span style="font-style: italic">&#39;--file PATH&#39;</span>, <span style="font-style: italic">&#39;Specify path for backing store&#39;</span>) <span style="font-weight: bold">do</span> |argpath|
        path = File.expand_path argpath
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>.parse!

exit(0) <span style="font-weight: bold">unless</span> ARGV[0].downcase == <span style="font-style: italic">&#39;get&#39;</span> <i class="conum" data-value="2">②</i>
exit(0) <span style="font-weight: bold">unless</span> File.exists? path

known = {} <i class="conum" data-value="3">③</i>
<span style="font-weight: bold">while</span> line = STDIN.gets
    <span style="font-weight: bold">break</span> <span style="font-weight: bold">if</span> line.strip == <span style="font-style: italic">&#39;&#39;</span>
    k,v = line.strip.split <span style="font-style: italic">&#39;=&#39;</span>, 2
    known[k] = v
<span style="font-weight: bold">end</span>

File.readlines(path).each <span style="font-weight: bold">do</span> |fileline| <i class="conum" data-value="4">④</i>
    prot,user,pass,host = fileline.scan(<span style="font-style: italic">/^(.*?):\/\/(.*?):(.*?)@(.*)$/</span>).first
    <span style="font-weight: bold">if</span> prot == known[<span style="font-style: italic">&#39;protocol&#39;</span>] <span style="font-weight: bold">and</span> host == known[<span style="font-style: italic">&#39;host&#39;</span>] <span style="font-weight: bold">then</span>
        puts <span style="font-style: italic">&quot;protocol=</span><span style="font-weight: bold; font-style: italic">#{</span>prot<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;host=</span><span style="font-weight: bold; font-style: italic">#{</span>host<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;username=</span><span style="font-weight: bold; font-style: italic">#{</span>user<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        puts <span style="font-style: italic">&quot;password=</span><span style="font-weight: bold; font-style: italic">#{</span>pass<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        exit(0)
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<div class="callout-list">
<ol>
<li><i class="conum" data-value="1">①</i> まずここでコマンドラインオプションをパースし、読み込ませるファイルをユーザーが指定できるようにしておきます。デフォルトで読み込まれるファイルは <code class="literal">~/.git-credentials</code> です。</li>
<li><i class="conum" data-value="2">②</i> このプログラムが応答するのはアクションが <code class="literal">get</code> で、かつ認証情報を保持しているファイルが存在している場合に限られます。</li>
<li><i class="conum" data-value="3">③</i> このループは標準入力を読み取っていて、空行が渡されるまで続きます。
入力された内容は <code class="literal">known</code> というハッシュに保存しておき、のちのち参照することになります。</li>
<li><i class="conum" data-value="4">④</i> こちらのループではファイルの情報を検索します。
<code class="literal">known</code> ハッシュに保持されているプロトコルとハッシュに検索結果が合致した場合、検索結果が標準出力に返されます。</li>
</ol>
</div>
<p>このヘルパーを <code class="literal">git-credential-read-only</code> としてパスの通っているところに保存したら、ファイルを実行可能にしましょう。
実際に実行したときの対話型セッションは、以下のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7</code></pre>
</figure>
<p>ファイル名が “git-” で始まっているので、シンプルな書式を使って設定できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global credential.helper read-only --file /mnt/shared/creds</code></pre>
</figure>
<p>このとおり、Git の認証情報の仕組みを拡張するのはとても単純ですし、個人やチームの悩みを解決するのに役立つはずです。</p>
</section>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ_2">まとめ</h2>
<p>さまざまな高度な道具を使い、コミットやステージングエリアをより細やかに操作できる方法をまとめました。
何か問題が起こったときには、いつ誰がどのコミットでそれを仕込んだのかを容易に見つけられるようになったことでしょう。
また、プロジェクトの中で別のプロジェクトを使いたくなったときのための方法も紹介しました。
Git を使った日々のコマンドラインでの作業の大半を、自信を持ってできるようになったことでしょう。</p>
</section>
</section>
</body>
</html>