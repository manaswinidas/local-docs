<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git のカスタマイズ</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git のカスタマイズ" epub:type="chapter" id="ch08-customizing-git">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>のカスタマイズ</b></small></h1>
</div>
</header>
<div class="abstract" epub:type="preamble">
<p>ここまで本書では、Git の基本動作やその使用法について扱ってきました。また、Git をより簡単に効率よく使うためのさまざまなツールについても紹介しました。
本章では、重要な設定項目やフックシステムを使用して、よりカスタマイズされた方法で Git を操作する方法について扱います。
これらを利用すれば、みなさん自身やその勤務先、所属グループのニーズにあわせた方法で Git を活用できるようになるでしょう。</p>
</div>
<section class="sect1" title="Git の設定">
<h2 id="r_git_config">Git の設定</h2>
<p></p>
<p><a id="xref--ch01-introduction" href="ch01-introduction.xhtml" class="xref">使い始める</a> で手短にごらんいただいたように、<code class="literal">git config</code> コマンドで Gitの設定が行えます。
最初にすることと言えば、名前とメールアドレスの設定でしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global user.name <span style="font-style: italic">&quot;John Doe&quot;</span>
<span style="font-weight: bold">$</span> git config --global user.email johndoe@example.com</code></pre>
</figure>
<p>ここでは、同じようにして設定できるより興味深い項目をいくつか身につけ、Git をカスタマイズしてみましょう。</p>
<p>まず、簡単におさらいしましょう。Git では、いくつかの設定ファイルを使ってデフォルト以外の挙動を定義します。
最初に Git が見るのは <code class="literal">/etc/gitconfig</code> で、ここにはシステム上の全ユーザーの全リポジトリ向けの設定値を記述します。
<code class="literal">git config</code> にオプション <code class="literal">--system</code> を指定すると、このファイルの読み書きを行います。</p>
<p>次に Git が見るのは <code class="literal">~/.gitconfig</code> （または <code class="literal">~/.config/git/config</code> ）で、これは各ユーザー専用のファイルです。
Git でこのファイルの読み書きをするには、<code class="literal">--global</code> オプションを指定します。</p>
<p>最後に Git が設定値を探すのは、現在使用中のリポジトリの設定ファイル (<code class="literal">.git/config</code>) です。
この値は、そのリポジトリだけで有効なものです。</p>
<p>これらの “レベル” （システム、グローバル、ローカル）の間では、いずれも後から読んだ値がその前の値を上書きします。したがって、たとえば <code class="literal">.git/config</code> に書いた値は <code class="literal">/etc/gitconfig</code> での設定よりも優先されます。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Git の設定ファイルはプレーンテキストなので、これらのファイルを手動で編集し、正しい構文で内容を追加することで、上記のような設定を行うことも可能ですが、通常は <code class="literal">git config</code> コマンドを使ったほうが簡単です。</p>
</div>
</aside>
<section class="sect2" title="基本的なクライアントのオプション">
<h3 id="_基本的なクライアントのオプション">基本的なクライアントのオプション</h3>
<p>Git の設定オプションは、おおきく二種類に分類できます。クライアント側のオプションとサーバー側のオプションです。
大半のオプションは、クライアント側のもの、つまり個人的な作業環境を設定するためのものとなります。
大量の、<em>本当に大量の</em> オプションが使用できますが、ここでは、もっとも一般的で、もっともよく使われているものだけを取り上げます。
その他のオプションの多くは特定の場合にのみ有用なものなので、ここでは扱いません。
Git で使えるすべてのオプションを知りたい場合は、次のコマンドを実行しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> man git-config</code></pre>
</figure>
<p>このコマンドは、利用できるすべてのオプションを、簡単な説明とともに一覧表示します。
この内容は、 <a href="http://git-scm.com/docs/git-config.html" class="link">http://git-scm.com/docs/git-config.html</a> にあるリファレンスでも見ることができます。</p>
<section class="sect3" title="core.editor">
<h4 id="_code_class_literal_core_editor_code"><code class="literal">core.editor</code></h4>
<p></p>
<p>デフォルトでは、コミットやタグのメッセージを編集するときには、ユーザーがデフォルトエディタとして設定したエディタ（ <code class="literal">$VISUAL</code> または <code class="literal">$EDITOR</code>）が使われます。デフォルトエディタが設定されていない場合は vi エディタが使われます。
このデフォルト設定を別のものに変更するには <code class="literal">core.editor</code> を設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.editor emacs</code></pre>
</figure>
<p>これで、シェルのデフォルトエディタに関係なく、Git でメッセージを編集する際には Emacs が起動されるようになりました。</p>
</section>
<section class="sect3" title="commit.template">
<h4 id="_code_class_literal_commit_template_code"><code class="literal">commit.template</code></h4>
<p></p>
<p>システム上のファイルへのパスをここに設定すると、Git はそのファイルをコミット時のデフォルトメッセージとして使います。
たとえば、次のようなテンプレートファイルを作って <code class="literal">~/.gitmessage.txt</code> においたとしましょう。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>subject line

what happened

[ticket: X]</code></pre>
</figure>
<p><code class="literal">git commit</code> のときにエディタに表示されるデフォルトメッセージをこれにするには、<code class="literal">commit.template</code> の設定を変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global commit.template ~/.gitmessage.txt
<span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p>すると、コミットメッセージの雛形としてこのような内容がエディタに表示されます。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>subject line

what happened

[ticket: X]
# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
# modified:   lib/test.rb
#
~
~
&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</code></pre>
</figure>
<p>コミットメッセージについてチーム内に所定の決まりがあるのなら、その決まりに従ったテンプレートをシステム上に作って Git にそれを使わせるようにするとよいでしょう。そうすれば、その決まりに従ってもらいやすくなります。</p>
</section>
<section class="sect3" title="core.pager">
<h4 id="_code_class_literal_core_pager_code"><code class="literal">core.pager</code></h4>
<p></p>
<p>core.pager は、Git が <code class="literal">log</code> や <code class="literal">diff</code> などを出力するときに使うページャを設定します。
<code class="literal">more</code> などのお好みのページャを設定したり (デフォルトは <code class="literal">less</code> です)、空文字列を設定してページャを使わないようにしたりできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.pager <span style="font-style: italic">&#39;&#39;</span></code></pre>
</figure>
<p>これを実行すると、すべてのコマンドの出力を、どんなに長くなったとしても全部 Git が出力するようになります。</p>
</section>
<section class="sect3" title="user.signingkey">
<h4 id="_code_class_literal_user_signingkey_code"><code class="literal">user.signingkey</code></h4>
<p></p>
<p>署名入りの注釈付きタグ (<a id="xref--ch07-git-tools--r_signing" href="ch07-git-tools.xhtml#r_signing" class="xref">作業内容への署名</a> で取り上げました) を作る場合は、GPG 署名用の鍵を登録しておくと便利です。
鍵の ID を設定するには、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global user.signingkey &lt;gpg-key-id&gt;</code></pre>
</figure>
<p>これで、<code class="literal">git tag</code> コマンドでいちいち鍵を指定しなくてもタグに署名できるようになりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -s &lt;tag-name&gt;</code></pre>
</figure>
</section>
<section class="sect3" title="core.excludesfile">
<h4 id="_code_class_literal_core_excludesfile_code"><code class="literal">core.excludesfile</code></h4>
<p></p>
<p>プロジェクトごとの <code class="literal">.gitignore</code> ファイルでパターンを指定すると、<code class="literal">git add</code> したときに Git がそのファイルを無視してステージしないようになります。これについては <a id="xref--ch02-git-basics--r_ignoring" href="ch02-git-basics.xhtml#r_ignoring" class="xref">ファイルの無視</a> で説明しました。</p>
<p>ですが、作業中のすべてのリポジトリで、ある特定のファイルを無視したい場合もあります。
Mac OS X を使っているのなら、 <code class="literal">.DS_Store</code> というファイルに見おぼえがあるでしょう。
使っているエディタが Emacs か Vim なら、 <code class="literal">~</code> で終わるファイルのことを知っていることと思います。</p>
<p>このような設定を行うには、グローバルな <code class="literal">.gitignore</code> のようなファイルが必要です。
<code class="literal">~/.gitignore_global</code> ファイルへ次の内容を書き込んで、</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*~
.DS_Store</code></pre>
</figure>
<p>その上で <code class="literal">git config --global core.excludesfile ~/.gitignore_global</code> を実行すれば、これらのファイルで手を煩わすことは二度となくなります。</p>
</section>
<section class="sect3" title="help.autocorrect">
<h4 id="_code_class_literal_help_autocorrect_code"><code class="literal">help.autocorrect</code></h4>
<p></p>
<p>Git でコマンドを打ち間違えると、こんなふうに表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git chekcout master
git: &#39;chekcout&#39; is not a git command. See &#39;git --help&#39;.

Did you mean this?
    checkout</code></pre>
</figure>
<p>Git は気を利かせて、何をしたかったのか推測はしてくれますが、実行まではしません。
<code class="literal">help.autocorrect</code> を 1 にしておくと、 Git は実際にそのコマンドを実行しようとします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git chekcout master
WARNING: You called a Git command named &#39;chekcout&#39;, which does not exist.
Continuing under the assumption that you meant &#39;checkout&#39;
in 0.1 seconds automatically...</code></pre>
</figure>
<p>“0.1 seconds” という箇所に注目してください。 <code class="literal">help.autocorrect</code> は整数値で、0.1秒単位での時間を表しています。
そのため、仮に 50 を設定したなら、自動修正したコマンドが実行される前に 5 秒の猶予が与えられます。</p>
</section>
</section>
<section class="sect2" title="Git における色">
<h3 id="_git_における色">Git における色</h3>
<p></p>
<p>Git では、ターミナルへの出力に色をつけることができます。ぱっと見て、すばやくお手軽に出力内容を把握できるようになるでしょう。
さまざまなオプションで、お好みに合わせて色を設定しましょう。</p>
<section class="sect3" title="color.ui">
<h4 id="_code_class_literal_color_ui_code"><code class="literal">color.ui</code></h4>
<p>Git は自動的に大半の出力に色づけをします。ですが、この挙動が気に入らないなら、そのためのマスタースイッチがあります。
ターミナルへの出力への色付けをすべてオフにするなら、以下のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global color.ui false</code></pre>
</figure>
<p>デフォルトの設定は <code class="literal">auto</code> で、直接ターミナルへ出力する場合には色付けを行いますが、パイプやファイルへリダイレクトした場合にはカラーコントロールコードを出力しません。</p>
<p>また <code class="literal">always</code> を指定すると、ターミナルであってもパイプであっても色をつけます。
<code class="literal">always</code> を使うことは、まずないでしょう。たいていの場合は、カラーコードを含む結果をリダイレクトしたければ、 Git コマンドに <code class="literal">--color</code> フラグを渡せばカラーコードの使用を強制できます。
ふだんはデフォルトの設定で要望を満たせるでしょう。</p>
</section>
<section class="sect3" title="color.*">
<h4 id="_code_class_literal_color_code"><code class="literal">color.*</code></h4>
<p>どのコマンドをどのように色づけするかをより細やかに指定したい場合、コマンド単位の色づけ設定を使用します。
これらの項目には <code class="literal">true</code> 、 <code class="literal">false</code> あるいは <code class="literal">always</code> が指定できます。</p>
<pre class="screen">color.branch
color.diff
color.interactive
color.status</pre>
<p>さらに、これらの項目ではサブ設定が使え、出力の一部について特定の色を使うように指定することもできます。
たとえば、diff の出力で、メタ情報を黒地に青の太字で出力させたい場合は次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global color.diff.meta <span style="font-style: italic">&quot;blue black bold&quot;</span></code></pre>
</figure>
<p>色として指定できる値は <code class="literal">normal</code>、 <code class="literal">black</code>、 <code class="literal">red、 `green</code>、 <code class="literal">yellow</code>、 <code class="literal">blue</code>、 <code class="literal">magenta</code>、 <code class="literal">cyan</code>、 <code class="literal">white</code> のいずれかです。先ほどの例の bold のように属性も指定できます。<code class="literal">bold</code>、 <code class="literal">dim</code>、 <code class="literal">ul</code> （下線つき）、 <code class="literal">blink</code>、 <code class="literal">reverse</code> （文字と背景の色を逆にする）のいずれかを指定できます。</p>
</section>
</section>
<section class="sect2" title="外部のマージツールおよび diff ツール">
<h3 id="r_external_merge_tools">外部のマージツールおよび diff ツール</h3>
<p></p>
<p>Git には、内部的な diff の実装が組み込まれています。本書でこれまで見てきた内容は、それを使用しています。ですが、外部のツールを使うよう設定することもできます。
また、コンフリクトを手動で解決するのではなくグラフィカルなコンフリクト解消ツールを使うよう設定することもできます。
ここでは Perforce Visual Merge Tool (P4Merge) を使って diff の表示とマージの処理を行えるようにする例を示します。これはすばらしいグラフィカルツールで、しかも無料で使えるからです。</p>
<p>P4Merge はすべての主要プラットフォーム上で動作するので、実際に試してみたい人は試してみるとよいでしょう。
この例では、Mac や Linux 形式のパス名を例に使います。Windows の場合は、<code class="literal">/usr/local/bin</code> のところを環境に合わせたパスに置き換えてください。</p>
<p>まず、P4Merge を <a href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools" class="link">からダウンロードします</a>。
次に、コマンドを実行するための外部ラッパースクリプトを用意します。
この例では、Mac 用の実行パスを使います。他のシステムで使う場合は、<code class="literal">p4merge</code> のバイナリがインストールされた場所に置き換えてください。
次のような内容のマージ用ラッパースクリプト <code class="literal">extMerge</code> を用意してください。これは、 <code class="literal">p4merge</code> にすべての引数を渡して呼び出します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /usr/local/bin/extMerge
<span style="font-weight: bold">#</span>!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre>
</figure>
<p>diff のラッパーは、7 つの引数が渡されていることを確認したうえでそのうちのふたつをマージスクリプトに渡します。
デフォルトでは、Git は次のような引数を diff プログラムに渡します。</p>
<figure class="listing">
<pre class="source language-"><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre>
</figure>
<p>ここで必要な引数は <code class="literal">old-file</code> と <code class="literal">new-file</code> だけなので、ラッパースクリプトではこれらを渡すようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /usr/local/bin/extDiff
<span style="font-weight: bold">#</span>!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</code></pre>
</figure>
<p>また、これらのツールは実行可能にしておかなければなりません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo chmod +x /usr/local/bin/extMerge
<span style="font-weight: bold">$</span> sudo chmod +x /usr/local/bin/extDiff</code></pre>
</figure>
<p>これで、自前のマージツールや diff ツールを使えるように設定する準備が整いました。
設定項目はひとつだけではありません。まず <code class="literal">merge.tool</code> でどんなツールを使うのかを Git に伝え、 <code class="literal">mergetool.&lt;tool&gt;.cmd</code> でそのコマンドを実行する方法を指定し、<code class="literal">mergetool.&lt;tool&gt;.trustExitCode</code> では「そのコマンドの終了コードでマージが成功したかどうかを判断できるのか」を指定し、<code class="literal">diff.external</code> では diff の際に実行するコマンドを指定します。つまり、このような 4 つのコマンドを実行することになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global merge.tool extMerge
<span style="font-weight: bold">$</span> git config --global mergetool.extMerge.cmd <span style="font-weight: bold; font-style: italic">\</span>
  <span style="font-style: italic">&#39;extMerge \&quot;$BASE\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$MERGED\&quot;&#39;</span>
<span style="font-weight: bold">$</span> git config --global mergetool.extMerge.trustExitCode false
<span style="font-weight: bold">$</span> git config --global diff.external extDiff</code></pre>
</figure>
<p>あるいは、<code class="literal">~/.gitconfig</code> ファイルを編集してこのような行を追加します。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[merge]</span>
  tool = <span style="font-style: italic">extMerge</span>
<span style="font-weight: bold">[mergetool &quot;extMerge&quot;]</span>
  cmd = <span style="font-style: italic">extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;</span>
<span style="font-style: italic">  trustExitCode = false</span>
<span style="font-weight: bold">[diff]</span>
  external = <span style="font-style: italic">extDiff</span></code></pre>
</figure>
<p>すべて設定し終えたら、このような diff コマンドを実行すると、</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff 32d1776b1^ 32d1776b1</code></pre>
</figure>
<p>結果をコマンドラインに出力するかわりに、Git から P4Merge が呼び出され、次のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/p4merge.png" alt="P4Merge."/>
</div>
<figcaption>Figure 1. P4Merge.</figcaption>
</figure>
<p>ふたつのブランチをマージしてコンフリクトが発生した場合は <code class="literal">git mergetool</code> を実行します。すると P4Merge が立ち上がり、コンフリクトの解決を GUI ツールで行えるようになります。</p>
<p>このようなラッパーを設定しておくと、あとで diff ツールやマージツールを簡単に変更できます。
たとえば <code class="literal">extDiff</code> や <code class="literal">extMerge</code> で KDiff3 を実行させるように変更するには <code class="literal">extMerge</code> ファイルをこのように変更するだけでよいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /usr/local/bin/extMerge
<span style="font-weight: bold">#</span>!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre>
</figure>
<p>これで、Git での diff の閲覧やコンフリクトの解決の際に KDiff3 が立ち上がるようになりました。</p>
<p>Git にはさまざまなマージツール用の設定が事前に準備されており、特に設定しなくても利用できます。
サポートされているツールを確認するには、次のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mergetool --tool-help
&#39;git mergetool --tool=&lt;tool&gt;&#39; may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.</code></pre>
</figure>
<p>KDiff3 を diff ツールとしてではなくマージのときにだけ使いたい場合は、kdiff3 コマンドにパスが通っている状態で次のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global merge.tool kdiff3</code></pre>
</figure>
<p><code class="literal">extMerge</code> や <code class="literal">extDiff</code> を準備せずにこのコマンドを実行すると、マージの解決の際には KDiff3 を立ち上げて diff の際には通常の Git の diff ツールを使うようになります。</p>
</section>
<section class="sect2" title="書式設定と空白文字">
<h3 id="_書式設定と空白文字">書式設定と空白文字</h3>
<p></p>
<p>書式設定や空白文字の問題は微妙にうっとうしいもので、とくにさまざまなプラットフォームで開発している人たちと共同作業をするときに問題になりがちです。
使っているエディタが知らぬ間に空白文字を埋め込んでしまっていたり Windows で開発している人が行末にキャリッジリターンを付け加えてしまったりなどしてパッチが面倒な状態になってしまうことも多々あります。
Git では、こういった問題に対処するための設定項目も用意しています。</p>
<section class="sect3" title="core.autocrlf">
<h4 id="_code_class_literal_core_autocrlf_code"><code class="literal">core.autocrlf</code></h4>
<p></p>
<p>自分が Windows で開発している一方、チームの中に Windows 以外の環境で開発している人がいる場合（逆も同様）には、改行コードの問題に巻き込まれることがありがちです。
Windows ではキャリッジリターンとラインフィードでファイルの改行を表すのですが、Mac や Linux ではラインフィードだけで改行を表すという違いが原因です。
これはささいな違いではありますが、さまざまなプラットフォームにまたがる作業では非常に面倒なものです。Windows のエディタには、LFだけの改行をだまってCRLFに置き換えたり、ユーザがEnterキーを押下した際にCRとLFの両方を挿入したりするものが数多くあります。</p>
<p>Git はこの問題に対処するために、コミットする際には行末の CRLF を LF に自動変換し、ファイルシステム上にチェックアウトするときには逆の変換を行うようにできます。
この機能を使うには <code class="literal">core.autocrlf</code> を設定します。</p>
<p>Windows で作業をするときにこれを <code class="literal">true</code> に設定すると、コードをチェックアウトするときに行末の LF を CRLF に自動変換してくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.autocrlf true</code></pre>
</figure>
<p>Linux や Mac などの行末に LF を使うシステムで作業をしている場合は、Git にチェックアウト時の自動変換をされてしまうと困ります。しかし、行末が CRLF なファイルが紛れ込んでしまった場合には Git に自動修正してもらいたいものです。
コミット時の CRLF から LF への変換はさせたいけれどもそれ以外の自動変換が不要な場合は、<code class="literal">core.autocrlf</code> を input に設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.autocrlf input</code></pre>
</figure>
<p>この設定は、Windows にチェックアウトしたときの CRLF への変換は行いますが、Mac や Linux へのチェックアウト時は LF のままにします。</p>
<p>Windows のみのプロジェクトで作業をしているのなら、この機能を無効にしてキャリッジリターンをそのままリポジトリに記録してもよいでしょう。その場合は、値 <code class="literal">false</code> を設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.autocrlf false</code></pre>
</figure>
</section>
<section class="sect3" title="core.whitespace">
<h4 id="_code_class_literal_core_whitespace_code"><code class="literal">core.whitespace</code></h4>
<p>Git には、空白文字に関する問題を見つけて修正するための設定もあります。
空白文字に関する主要な六つの問題に対応するもので、そのうち三つはデフォルトで有効になっています。残りの三つはデフォルトでは有効になっていませんが、有効化することもできます。</p>
<p>デフォルトで有効になっている設定は、行末の空白文字を見つける <code class="literal">blank-at-eol</code> 、ファイル末尾の空白文字を見つける <code class="literal">blank-at-eof</code> 、行頭のタブ文字より前にある空白文字を見つける <code class="literal">space-before-tab</code> です。</p>
<p>デフォルトでは無効だけれども有効にすることもできる三つの設定は、行頭がタブ文字でなく空白文字になっている行を見つける <code class="literal">indent-with-non-tab</code> （空白文字の数は <code class="literal">tabwidth</code> オプションで制御可能）、行内のインデント部分にあるタブ文字を見つける <code class="literal">tab-in-indent</code> 、行末のキャリッジリターンを許容する <code class="literal">cr-at-eol</code> です。</p>
<p>これらのオン・オフを切り替えるには、<code class="literal">core.whitespace</code> にカンマ区切りで項目を指定します。
無効にしたい場合は、設定文字列でその項目を省略するか、あるいは項目名の前に <code class="literal">-</code> をつけます。
たとえば <code class="literal">cr-at-eol</code> 以外のすべてを設定したい場合は、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.whitespace <span style="font-weight: bold; font-style: italic">\</span>
    trailing-space,space-before-tab,indent-with-non-tab</code></pre>
</figure>
<p><code class="literal">git diff</code> コマンドを実行したときに Git がこれらの問題を検出すると、その部分を色付けして表示します。修正してからコミットするようにしましょう。
この設定は、<code class="literal">git apply</code> でパッチを適用する際にも助けとなります。
空白に関する問題を含むパッチを適用するときに警告を発してほしい場合には、次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply --whitespace=warn &lt;patch&gt;</code></pre>
</figure>
<p>あるいは、問題を自動的に修正してからパッチを適用したい場合は、次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply --whitespace=fix &lt;patch&gt;</code></pre>
</figure>
<p>これらの設定は、<code class="literal">git rebase</code> コマンドにも適用されます。
空白に関する問題を含むコミットをしたけれどまだそれを公開リポジトリにプッシュしていない場合は、 <code class="literal">git rebase --whitespace=fix</code> を実行すれば、パッチを書き換えて空白問題を自動修正してくれます。</p>
</section>
</section>
<section class="sect2" title="サーバーの設定">
<h3 id="_サーバーの設定">サーバーの設定</h3>
<p>Git のサーバー側の設定オプションはそれほど多くありませんが、いくつか興味深いものがあるので紹介します。</p>
<section class="sect3" title="receive.fsckObjects">
<h4 id="_code_class_literal_receive_fsckobjects_code"><code class="literal">receive.fsckObjects</code></h4>
<p>デフォルトでは、Git はプッシュで受け取ったオブジェクトの SHA-1 チェックサムが一致していて有効なオブジェクトを指しているということをチェックさせることができます。
ですが、デフォルトではこのチェックは行わないようになっています。このチェックは比較的重たい処理であり、リポジトリのサイズが大きかったりプッシュする量が多かったりすると、毎回チェックさせるのには時間がかかるでしょう。
毎回のプッシュの際に Git にオブジェクトの一貫性をチェックさせたい場合は、<code class="literal">receive.fsckObjects</code> を true にして強制的にチェックさせるようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --system receive.fsckObjects true</code></pre>
</figure>
<p>これで、Git がリポジトリの整合性を確認してからでないとプッシュが認められないようになります。壊れたデータをまちがって受け入れてしまうことがなくなりました。</p>
</section>
<section class="sect3" title="receive.denyNonFastForwards">
<h4 id="_code_class_literal_receive_denynonfastforwards_code"><code class="literal">receive.denyNonFastForwards</code></h4>
<p>すでにプッシュしたコミットをリベースしてもう一度プッシュした場合、あるいはリモートブランチが現在指しているコミットを含まないコミットをプッシュしようとした場合は、プッシュが拒否されます。
これは悪くない方針でしょう。しかしリベースの場合は、自分が何をしているのかをきちんと把握していれば、プッシュの際に <code class="literal">-f</code> フラグを指定して強制的にリモートブランチを更新することもできます。</p>
<p>このような強制更新機能を無効にするには、<code class="literal">receive.denyNonFastForwards</code> を設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --system receive.denyNonFastForwards true</code></pre>
</figure>
<p>もうひとつの方法として、サーバー側の receive フックを使うこともできます。こちらの方法については後ほど簡単に説明します。
receive フックを使えば、特定のユーザーだけ強制更新を無効にするなどより細やかな制御ができるようになります。</p>
</section>
<section class="sect3" title="receive.denyDeletes">
<h4 id="_code_class_literal_receive_denydeletes_code"><code class="literal">receive.denyDeletes</code></h4>
<p><code class="literal">denyNonFastForwards</code> の制限を回避する方法として、いったんブランチを削除してから新しいコミットを参照するブランチをプッシュしなおすことができます。
これを無効にするには、 <code class="literal">receive.denyDeletes</code> を true に設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --system receive.denyDeletes true</code></pre>
</figure>
<p>これは、プッシュによるブランチやタグの削除を一切拒否し、誰も削除できないようにします。
リモートブランチを削除するには、サーバー上の ref ファイルを手で削除しなければなりません。ACL を使って、ユーザー単位でこれを制限することもできますが、その方法は <a id="xref-r_an_example_git_enforced_policy" href="#r_an_example_git_enforced_policy" class="xref">Git ポリシーの実施例</a> で扱います。</p>
</section>
</section>
</section>
<section class="sect1" title="Git の属性">
<h2 id="_git_の属性">Git の属性</h2>
<p></p>
<p>設定項目の中には、パスに対して指定できるものもあります。Git はこれらの設定を、指定したパスのサブディレクトリやファイルにのみ適用します。
これらパス固有の設定は、 Git の属性と呼ばれ、あるディレクトリ （通常はプロジェクトのルートディレクトリ）の直下の <code class="literal">.gitattributes</code> か、あるいはそのファイルをプロジェクトとともにコミットしたくない場合は <code class="literal">.git/info/attributes</code> に設定します。</p>
<p>属性を使うと、ファイルやディレクトリ単位で個別のマージ戦略を指定したり、テキストファイル以外の diff を取る方法を指示したり、あるいはチェックインやチェックアウトの前にその内容を Git にフィルタリングさせたりできます。
このセクションでは、Git プロジェクトでパスに対して設定できる属性のいくつかについて学び、実際にその機能を使う例を見ていきます。</p>
<section class="sect2" title="バイナリファイル">
<h3 id="_バイナリファイル">バイナリファイル</h3>
<p></p>
<p>Git の属性を使ってできるちょっとした技として、どのファイルがバイナリファイルなのかを (その他の方法で判別できない場合のために) 指定した上で、 Git に対してバイナリファイルの扱い方を指示するというものがあります。
たとえば、機械で生成したテキストファイルの中には diff が取得できないものがありますし、バイナリファイルであっても diff が取得できるものもあります。
それを Git に指示する方法を紹介します。</p>
<section class="sect3" title="バイナリファイルの特定">
<h4 id="_バイナリファイルの特定">バイナリファイルの特定</h4>
<p>テキストファイルのように見えるファイルであっても、何らかの目的のために意図的にバイナリデータとして扱いたいことがあります。
たとえば、Mac の Xcode プロジェクトの中には <code class="literal">.pbxproj</code> で終わる名前のファイルがあります。これは JSON (プレーンテキスト形式の JavaScript のデータフォーマット) のデータセットで、IDE がビルドの設定などをディスクに書き出したものです。
このファイルの内容はすべて UTF-8 の文字なので、理論上はテキストファイルであると言えます。しかし、このファイルをテキストファイルとして扱いたくはありません。実際のところ、このファイルは軽量なデータベースとして使われているからです。他の人が変更した内容はマージできませんし、diff をとってもあまり意味がありません。
このファイルは、基本的に機械が処理するものなのです。
要するに、バイナリファイルと同じように扱いたいということです。</p>
<p>すべての <code class="literal">pbxproj</code> ファイルをバイナリデータとして扱うよう Git に指定するには、次の行を <code class="literal">.gitattributes</code> ファイルに追加します。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*.pbxproj binary</code></pre>
</figure>
<p>これで、Git が CRLF 問題の対応をすることもなくなりますし、<code class="literal">git show</code> や <code class="literal">git diff</code> を実行したときにもこのファイルの diff を調べることはなくなります。</p>
</section>
<section class="sect3" title="バイナリファイルの差分">
<h4 id="_バイナリファイルの差分">バイナリファイルの差分</h4>
<p>バイナリファイルに対して意味のある差分を取る際にも、Git の属性を使うことができます。
普通の diff でも比較できるよう、バイナリデータをテキストデータに変換する方法をGitに教えればいいのです。</p>
<p>このテクニックを使ってまず解決したいことといえば、人類にとって最も厄介な問題のひとつ、Wordで作成した文書のバージョン管理ではないでしょうか。
奇妙なことに、Wordは最悪のエディタだと全ての人が知っているにも係わらず、皆がWordを使っています。
Word文書をバージョン管理したいと思ったなら、Gitのリポジトリにそれらを追加して、まとめてコミットすればいいのです。しかし、それでいいのでしょうか？
あなたが <code class="literal">git diff</code> をいつも通りに実行すると、次のように表示されるだけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ</code></pre>
</figure>
<p>これでは、2つのバージョンをチェックアウトして、目視で見比べなくては、比較はできませんよね？
Gitの属性を使えば、これをうまく解決できます。
`.gitattributes`に次の行を追加して下さい。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*.docx diff=<span style="font-style: italic">word</span></code></pre>
</figure>
<p>これは、指定したパターン (<code class="literal">.docx</code>) にマッチした全てのファイルに対して、差分を表示する時には “word” というフィルタを使うよう Git に指示しているのです。
では、 “word” フィルタとは何でしょうか？
これは自分で用意しなければなりません。
ここでは、 <code class="literal">docx2txt</code> を使ってWord文書をテキストファイルに変換した上で、正しく diff が取れるように設定してみましょう。</p>
<p>まず、 <code class="literal">docx2txt</code> をインストールする必要があります。 <a href="http://docx2txt.sourceforge.net" class="link">http://docx2txt.sourceforge.net</a> からダウンロードしたら、 <code class="literal">INSTALL</code> ファイルの指示に従って、シェルから見える場所にファイルを置いてください。
次に、出力を Git に合わせて変換するラッパースクリプトを作成します。
パスの通った場所に、 `docx2txt`という名前のファイルを次の内容で作成してください。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span>!/bin/bash
docx2txt.pl $1 -</code></pre>
</figure>
<p>作ったファイルに <code class="literal">chmod a+x</code> するのを忘れないでください。
最後に、Git がこのファイルを使うように設定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config diff.word.textconv docx2txt</code></pre>
</figure>
<p>これで、二つのスナップショットの diff を取る際に、ファイル名の末尾が <code class="literal">.docx</code> だったら、 “word” フィルタを通す（この “word” フィルタは <code class="literal">docx2txt</code> というプログラムとして定義されている）ということが Git に伝わりました。
こうすることで、Wordファイルの差分を取る際に、より効果的なテキストベースでの差分を取ることができるようになります。</p>
<p>例を示しましょう。この本の第1章をWord形式に変換し、Gitリポジトリに登録しました。
さらに、新しい段落を追加しました。
<code class="literal">git diff</code> の出力は次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is &quot;version control&quot;, and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people&#39;s version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they&#39;re clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you&#39;re in and accidentally write to the wrong file or copy over files you don&#39;t mean to.</code></pre>
</figure>
<p>Gitは、追加した “Testing: 1, 2, 3.” という正しい文字列を首尾よく、かつ、簡潔に知らせてくれました。
これだけでは完璧ではありません（書式の変更はここでは表示されていません）が、確実に動作しています。</p>
<p>その他の興味深い問題としては、画像ファイルの差分があります。
ひとつの方法として、EXIF情報（多くのファイル形式で使用されているメタデータ）を抽出するフィルタを使う方法があります。
<code class="literal">exiftool`をダウンロードしてインストールすれば、画像データを、メタデータを表すテキストデータへ変換できます。これによって、 diff では少なくとも、変更内容をテキスト形式で表示できるようになります。
ではここで、以下の行を</code>.gitattributes`に追加してみましょう。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*.png diff=<span style="font-style: italic">exif</span></code></pre>
</figure>
<p>続いて、さきほどインストールしたツールを使うようGitの設定を変更します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config diff.exif.textconv exiftool</code></pre>
</figure>
<p>プロジェクト中の画像データを置き換えて <code class="literal">git diff</code> を実行すると、次のように表示されるでしょう。</p>
<figure class="listing">
<pre class="source language-diff"><code><span></span><span style="font-weight: bold">diff --git a/image.png b/image.png</span>
<span style="font-weight: bold">index 88839c4..4afcb7c 100644</span>
--- a/image.png
+++ b/image.png
<span style="font-weight: bold">@@ -1,12 +1,12 @@</span>
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>
</figure>
<p>ファイルのサイズと画像のサイズが変更されたことが簡単に見て取れます。</p>
</section>
</section>
<section class="sect2" title="キーワード展開">
<h3 id="r_keyword_expansion">キーワード展開</h3>
<p></p>
<p>SubversionやCVSを使っていた開発者から、キーワード展開機能をリクエストされることがよくあります。
ここでの主な問題は、Git では、コミットの後に、コミットに関する情報を使ってファイルを変更することはできないということです。これは、Git がコミットの最初にファイルのチェックサムを生成するためです。
しかし、ファイルをチェックアウトする際にテキストを挿入し、コミットへ追加する際にそれを削除することは可能です。
Gitの属性はこれを行うための方法を2つ提供します。</p>
<p>ひとつめの方法として、ファイルの <code class="literal">$Id$</code> フィールドへ、 blob の SHA-1 チェックサムを自動的に挿入できます。
あるファイル、もしくはいくつかのファイルに対してこの属性を設定すれば、次にそのブランチをチェックアウトする時、Gitはこの置き換えを行うようになります。
ただし、挿入されるチェックサムはコミットに対するものではなく、対象となるblobのものであるという点に注意して下さい。
ではここで、以下の行を`.gitattributes`に追加してみましょう。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*.txt ident</code></pre>
</figure>
<p>続いて、`$Id$`への参照をテスト用ファイルに追加します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;$Id$&#39;</span> &gt; test.txt</code></pre>
</figure>
<p>そうすると、次にこのファイルをチェックアウトする時、GitはblobのSHA-1チェックサムを挿入します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm test.txt
<span style="font-weight: bold">$</span> git checkout -- test.txt
<span style="font-weight: bold">$</span> cat test.txt
<span style="font-weight: bold">$</span>Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>
</figure>
<p>しかし、この結果はあまり役に立ちません。
CVSやSubversionのキーワード展開ではタイムスタンプを含めることができます。対して、SHA-1チェックサムは完全にランダムな値ですから、2つの値の新旧を知るための助けにはなりません。</p>
<p>これには、コミットおよびチェックアウトの時にキーワード展開を行うフィルタを書いてやれば対応できます。
このフィルタは “clean” および “smudge” フィルタと呼ばれます。
<code class="literal">.gitattributes</code> ファイルで、特定のパスにフィルタを設定し、チェックアウトの直前（ “smudge” 、 <a id="xref-rfilters_a" href="#rfilters_a" class="xref">チェックアウトする時に “smudge” フィルタを実行する</a> を参照）およびステージングの直前（ “clean” 、 <a id="xref-rfilters_b" href="#rfilters_b" class="xref">ステージングする時に “clean” フィルタを実行する</a> を参照）に処理を行うスクリプトを設定できます。
これらのフィルタは、色々と面白いことに使えます。</p>
<figure id="rfilters_a" class="image">
<div class="content">
<img src="images/smudge.png" alt="チェックアウトする時に ``smudge'' フィルタを実行する"/>
</div>
<figcaption>Figure 2. チェックアウトする時に “smudge” フィルタを実行する</figcaption>
</figure>
<figure id="rfilters_b" class="image">
<div class="content">
<img src="images/clean.png" alt="ステージングする時に ``clean'' フィルタを実行する"/>
</div>
<figcaption>Figure 3. ステージングする時に “clean” フィルタを実行する</figcaption>
</figure>
<p>この機能に対してオリジナルのコミットメッセージは簡単な例を与えてくれています。それはコミット前にCのソースコードを <code class="literal">indent</code> プログラムに通すというものです。
<code class="literal">*.c</code> ファイルに対してこのフィルタを実行するように、`.gitattributes`ファイルにfilter属性を設定できます。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>*.c filter=<span style="font-style: italic">indent</span></code></pre>
</figure>
<p>それから、smudgeとcleanで “indent” フィルタが何を行えばいいのかをGitに教えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global filter.indent.clean indent
<span style="font-weight: bold">$</span> git config --global filter.indent.smudge cat</code></pre>
</figure>
<p>このケースでは、 <code class="literal">*.c</code> にマッチするファイルをコミットした時、Gitはステージング前にindentプログラムにファイルを通し、チェックアウトする前には <code class="literal">cat</code> を通すようにします。
<code class="literal">cat`は基本的に何もしません。入力されたデータと同じデータを吐き出すだけです。
この組み合わせを使えば、Cのソースコードのコミット前に、効果的に `indent</code> を通せます。</p>
<p>もうひとつの興味深い例として、RCSスタイルの <code class="literal">$Date$</code> キーワード展開があります。
これを正しく行うには、ファイル名を受け取り、プロジェクトの最新のコミットの日付を見て、その日付をファイルに挿入するちょっとしたスクリプトが必要になります。
これを行うRubyスクリプトを以下に示します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#! /usr/bin/env ruby</span>
data = STDIN.read
last_date = <span style="font-style: italic">`git log --pretty=format:&quot;%ad&quot; -1`</span>
puts data.gsub(<span style="font-style: italic">&#39;$Date$&#39;</span>, <span style="font-style: italic">&#39;$Date: &#39;</span> + last_date.to_s + <span style="font-style: italic">&#39;$&#39;</span>)</code></pre>
</figure>
<p>このスクリプトは、<code class="literal">git log</code> コマンドの出力から最新のコミットの日付を取得し、標準入力中のすべての <code class="literal">$Date$</code> 文字列にその日付を追加し、結果を出力します。お気に入りのどんな言語で書くにしても、簡単なスクリプトになるでしょう。
このスクリプトファイルに`expand_date`と名前をつけ、実行パスのどこかに置きます。
次に、Git にフィルタ（ここでは <code class="literal">dater`とします）を設定し、チェックアウト時に smudge で `expand_date</code> フィルタを使うように指定します。
コミット時に日付を削除するのには、 Perl の正規表現が使えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config filter.dater.smudge expand_date
<span style="font-weight: bold">$</span> git config filter.dater.clean <span style="font-style: italic">&#39;perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;&#39;</span></code></pre>
</figure>
<p>このPerlのスニペットは、 <code class="literal">$Date$</code> 文字列の内側にある内容を削除し、日付を挿入する前の状態に戻します。
さて、フィルタの準備ができました。このファイルが新しいフィルタに引っかかるように Git の属性を設定し、ファイルに <code class="literal">$Date$</code> キーワードを追加した上で、テストしてみましょう。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>date*.txt filter=<span style="font-style: italic">dater</span></code></pre>
</figure>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# $Date$&#39;</span> &gt; date_test.txt</code></pre>
</figure>
<p>これらの変更をコミットして、再度ファイルをチェックアウトすれば、キーワードが正しく置き換えられているのがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add date_test.txt .gitattributes
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Testing date expansion in Git&quot;</span>
<span style="font-weight: bold">$</span> rm date_test.txt
<span style="font-weight: bold">$</span> git checkout date_test.txt
<span style="font-weight: bold">$</span> cat date_test.txt
<span style="font-weight: bold">#</span> $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>
</figure>
<p>アプリケーションのカスタマイズにあたり、このテクニックがどれほど強力か、おわかりいただけたと思います。
しかし、注意してほしいのですが、 <code class="literal">.gitattributes</code> ファイルはコミットされてプロジェクト内で共有されますが、ドライバ（このケースで言えば、<code class="literal">dater</code>）そうはそうはいきません。そのため、この機能はどこででも働くわけではありません。
フィルタを設計する時には、たとえフィルタが正常に動作しなかったとしても、プロジェクトは適切に動き続けられるようにすべきです。</p>
</section>
<section class="sect2" title="リポジトリをエクスポートする">
<h3 id="_リポジトリをエクスポートする">リポジトリをエクスポートする</h3>
<p></p>
<p>あなたのプロジェクトのアーカイブをエクスポートする時には、Gitの属性データを使って興味深いことができます。</p>
<section class="sect3" title="export-ignore">
<h4 id="_code_class_literal_export_ignore_code"><code class="literal">export-ignore</code></h4>
<p>アーカイブを生成するとき、特定のファイルやディレクトリをエクスポートしないように設定できます。
プロジェクトにはチェックインしたいが、アーカイブファイルには含めたくないディレクトリやファイルがあるなら、それらに <code class="literal">export-ignore</code> 属性を設定することで、分別が行えます。</p>
<p>例えば、プロジェクトをエクスポートする際に tarball に含めたくないテストファイルが、 `test/`ディレクトリ以下に入っているとしましょう。
その場合、次の1行をGitの属性ファイルに追加します。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>test/ export-ignore</code></pre>
</figure>
<p>これで、プロジェクトのtarballを作成するために <code class="literal">git archive</code> を実行した時、アーカイブには <code class="literal">test/</code> ディレクトリが含まれないようになります。</p>
</section>
<section class="sect3" title="export-subst">
<h4 id="_code_class_literal_export_subst_code"><code class="literal">export-subst</code></h4>
<p>デプロイ用にファイルをエクスポートする際に、<code class="literal">export-subst</code> 属性のついたファイルを指定して <code class="literal">git log</code> のログ書式指定機能とキーワード展開機能で生成した内容をファイルに付与できます。
例えば、<code class="literal">LAST_COMMIT`という名前のファイルをプロジェクトに追加し、`git archive`を実行した時にそのファイルのメタデータを最新コミットと同じ内容に変換したい場合、</code>.gitattributes`ファイルと`LAST_COMMIT`ファイルを
次のように設定します。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>LAST_COMMIT export-subst</code></pre>
</figure>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;Last commit date: $Format:%cd by %aN$&#39;</span> &gt; LAST_COMMIT
<span style="font-weight: bold">$</span> git add LAST_COMMIT .gitattributes
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;adding LAST_COMMIT file for archives&#39;</span></code></pre>
</figure>
<p><code class="literal">git archive</code> を実行すると、 <code class="literal">LAST_COMMIT</code> は以下のような内容になっているはずです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git archive HEAD | tar xCf ../deployment-testing -
<span style="font-weight: bold">$</span> cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</code></pre>
</figure>
<p>このような置換に、コミットメッセージや git note を用いることもできます。その際、git log コマンドのワードラップ処理が適用されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$&#39;</span> &gt; LAST_COMMIT
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;export-subst uses git log&#39;</span>s custom formatter

git archive uses git log&#39;s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
&#39;
<span style="font-weight: bold">$</span> git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log&#39;s custom formatter

         git archive uses git log&#39;s `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.</code></pre>
</figure>
<p>この結果作成されたアーカイブはデプロイするのにぴったりです。一方、いったんエクスポートされてしまったアーカイブで開発を続けるのはおすすめできません。</p>
</section>
</section>
<section class="sect2" title="マージの戦略">
<h3 id="_マージの戦略">マージの戦略</h3>
<p></p>
<p>Gitの属性を使えば、プロジェクト中の特定のファイルに対して、異なるマージ戦略を使うこともできます。
非常に有用なオプションのひとつに、指定したファイルで競合が発生した場合に、マージを行わずに、あなたの変更内容で他の誰かの変更を上書きするように設定するというものがあります。</p>
<p>これはプロジェクトにおいて、分岐したブランチや、特別版のブランチで作業をしている時、そのブランチでの変更をマージさせたいが、特定のファイルの変更はなかったことにしたいというような時に助けになります。
例えば、 <code class="literal">database.xml</code> というデータベースの設定ファイルがあり、ふたつのブランチでその内容が異なっているとしましょう。そして、そのデータベースファイルを台無しにすることなしに、一方のブランチへとマージしたいとします。
これは、次のように属性を設定すれば実現できます。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span>database.xml merge=<span style="font-style: italic">ours</span></code></pre>
</figure>
<p>その上で、ダミーのマージ戦略 <code class="literal">ours</code> を次のように定義します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global merge.ours.driver true</code></pre>
</figure>
<p>もう一方のブランチでマージを実行すると、 <code class="literal">database.xml</code> に関する競合は発生せず、次のような結果になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>
</figure>
<p>この場合、 <code class="literal">database.xml</code> は元々のバージョンのまま、書き変わりません。</p>
</section>
</section>
<section class="sect1" title="Git フック">
<h2 id="r_git_hooks">Git フック</h2>
<p></p>
<p>他のバージョンコントロールシステムと同じように、Gitにも特定のアクションが発生した時にカスタムスクリプトを叩く方法があります。
このようなフックは、クライアントサイドとサーバーサイドの二つのグループに分けられます。
クライアントサイドフックはコミットやマージといったクライアントでの操作の際に、サーバーサイドフックはプッシュされたコミットの受け取りといったネットワーク操作の際に、それぞれ実行されます。
これらのフックは、さまざまなな目的に用いることができます。</p>
<section class="sect2" title="フックをインストールする">
<h3 id="_フックをインストールする">フックをインストールする</h3>
<p>フックは、Gitディレクトリの <code class="literal">hooks</code> サブディレクトリ（一般的なプロジェクトでは、<code class="literal">.git/hooks</code> ）に格納されています。
<code class="literal">git init</code> で新しいリポジトリを初期化する時には、Gitに同梱されているスクリプトのサンプルがこの hooks ディレクトリに格納されます。サンプルの多くはそのままでも十分有用ですし、また、各スクリプトの入力値に関するドキュメントもついています。
サンプルは全てシェルスクリプトで書かれており、その中の一部では Perl も使われています。ですが、どんなスクリプトでも、実行可能かつ適切に命名されてさえいれば、問題なく動きます。Ruby や Python などで書くこともできます。
これら同梱のフックスクリプトを使用する場合は、ファイル名の末尾が <code class="literal">.sample</code> となっていますので適宜リネームしてください。</p>
<p>フックスクリプトを有効にするには、Gitディレクトリの <code class="literal">hooks</code> サブディレクトリに、実行可能なファイルを適切な名前（拡張子は使えません）で配置すれば、以降そのファイルが呼び出されます。
ここでは重要なフックファイル名をいくつか取り上げます。</p>
</section>
<section class="sect2" title="クライアントサイドフック">
<h3 id="_クライアントサイドフック">クライアントサイドフック</h3>
<p>クライアントサイドフックにはたくさんの種類があります。
ここではコミットワークフローフック、Eメールワークフロースクリプト、その他クライアントサイドフックに分類します。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>特筆すべき点として、クライアントサイドフックはリポジトリをクローンする際には <strong>コピーされません</strong> 。
スクリプトを使って何らかのポリシーを強制したいのなら、サーバサイドで行う方がよいでしょう。サンプルが <a href="#r_an_example_git_enforced_policy" class="xref">Git ポリシーの実施例</a> にあります。</p>
</div>
</aside>
<section class="sect3" title="コミットワークフローフック">
<h4 id="_コミットワークフローフック">コミットワークフローフック</h4>
<p>最初の4つのフックはコミットプロセスに関するものです。</p>
<p><code class="literal">pre-commit</code> フックは、コミットメッセージが入力される前に実行されます。
これは、いまからコミットされるスナップショットを検査したり、何かし忘れた事がないか確認したり、テストが実行できるか確認したり、何かしらコードを検査する目的で使用されます。
このフックがゼロでない値を返すと、コミットが中断されます。また、この検査は <code class="literal">git commit --no-verify</code> で飛ばすこともできます。
ここではコーディングスタイルの検査（lintを実行するなど）や、行末の空白文字の検査（デフォルトのフックがまさにそうです）、新しく追加されたメソッドのドキュメントが正しいかどうかの検査といったことが可能です。</p>
<p>`prepare-commit-msg`フックは、コミットメッセージエディターが起動する直前、デフォルトメッセージが生成された直後に実行されます。
このフックでは、デフォルトメッセージを、コミットの作者の目に触れる前に編集できます。
このフックにはパラメータがあり、その時点でのコミットメッセージを保存したファイルへのパス、コミットのタイプ、さらにamendされたコミットの場合はコミットの SHA-1 をパラメータとして取ります。
このフックは普段のコミットにおいてはあまり有用ではありませんが、テンプレートが用意されているコミットメッセージ・mergeコミット・squashコミット・amendコミットのような、デフォルトメッセージが自動生成されるコミットにおいて効果を発揮します。
コミットメッセージのテンプレートと組み合わせれば、プログラムで情報を動的に挿入できます。</p>
<p><code class="literal">commit-msg</code> フックは、開発者の書いたコミットメッセージを保存した一時ファイルへのパスをパラメータに取ります。
このスクリプトがゼロ以外の値を返した場合、Git はコミットプロセスを中断します。これを使えば、コミットを許可して処理を進める前に、プロジェクトの状態やコミットメッセージを検査できます。
この章の最後のセクションでは、このフックを使用してコミットメッセージが要求された様式に沿っているか検査するデモンストレーションを行います。</p>
<p>コミットプロセスが全て完了した後には、<code class="literal">post-commit`フックが実行されます。
このフックはパラメータを取りませんが、 `git log -1 HEAD</code> を実行することで直前のコミットを簡単に取り出すことができます。
一般的にこのスクリプトは何かしらの通知といった目的に使用されます。</p>
</section>
<section class="sect3" title="Eメールワークフローフック">
<h4 id="r_email_hooks">Eメールワークフローフック</h4>
<p>Eメールを使ったワークフロー用として、三種類のクライアントサイドフックを設定できます。
これらはすべて <code class="literal">git am</code> コマンドに対して起動されるものなので、ふだんのワークフローでこのコマンドを使っていない場合は次のセクションまで読み飛ばしてもかまいません。
<code class="literal">git format-patch</code> で作ったパッチを受け取ることがあるなら、ここで説明する内容の中に有用なものがあるかもしれません。</p>
<p>最初に実行されるフックは <code class="literal">applypatch-msg</code> です。
これは引数をひとつ（コミットメッセージを含む一時ファイル名）だけ受け取ります。
このスクリプトがゼロ以外の戻り値で終了した場合、Git はパッチの処理を強制終了させます。
このフックを使うと、コミットメッセージの書式が正しいかどうかを確認したり、スクリプトで正しい書式に手直ししたりできます。</p>
<p><code class="literal">git am</code> でパッチを適用するときに二番目に実行されるフックは <code class="literal">pre-applypatch</code> です。
少々ややこしいのですが、このフックはパッチが <em>適用された後</em> 、コミットが作成される前に実行されます。そのため、このフックでは、スナップショットの内容を、コミットする前に調べることができます。
このスクリプトを使えば、テストを実行したり、ワーキングツリーの調査をしたりといったことが行えます。
なにか抜けがあったりテストが失敗したりした場合はスクリプトをゼロ以外の戻り値で終了させます。そうすれば、<code class="literal">git am</code> はパッチをコミットせずに強制終了します。</p>
<p><code class="literal">git am</code> において最後に実行されるフックは <code class="literal">post-applypatch</code> です。このフックは、コミットが作成された後に実行されます。
これを使うと、特定のグループのメンバーや、プルしたパッチの作者に対して、処理の完了を伝えることができます。
このスクリプトでは、パッチの適用を中断させることはできません。</p>
</section>
<section class="sect3" title="その他のクライアントフック">
<h4 id="r_other_client_hooks">その他のクライアントフック</h4>
<p><code class="literal">pre-rebase</code> フックは何かをリベースする前に実行され、ゼロ以外を返せばその処理を中断できます。
このフックを使うと、既にプッシュ済みのコミットのリベースを却下できます。
Git に同梱されているサンプルの <code class="literal">pre-rebase</code> フックがこの処理を行いますが、このフックの前提となっている条件のなかには読者のワークフローに合わないものもあるでしょう。</p>
<p><code class="literal">post-rewrite</code> フックは、既存のコミットを書き換えるコマンド、例えば <code class="literal">git commit --amend</code> や <code class="literal">git rebase</code> を実行した際に実行されます（ただし <code class="literal">git filter-branch</code> では実行されません）。
引数はひとつで、コミットの書き換えを行ったコマンドを引数に取ります。また、書き換えを行ったファイルのリストを <code class="literal">stdin</code> から受け取ります。
このフックは <code class="literal">post-checkout</code> や <code class="literal">post-merge</code> といったフックと同じ用途に使えます。</p>
<p><code class="literal">git checkout</code> が正常に終了すると、<code class="literal">post-checkout</code> フックが実行されます。これを使うと、作業ディレクトリを自分のプロジェクトの環境にあわせて設定できます。
たとえば、バージョン管理対象外の巨大なバイナリファイルを作業ディレクトリに取り込んだり、ドキュメントを自動生成したりといった処理が行えます。</p>
<p><code class="literal">post-merge</code> フックは、<code class="literal">merge</code> コマンドが正常に終了したときに実行されます。
これを使うと、Git では追跡できないパーミッション情報などを作業ツリーに復元できます。
作業ツリーに変更が加わったときに取り込みたい Git の管理対象外のファイルの存在確認などにも使えます。</p>
<p><code class="literal">pre-push</code> フックは、 <code class="literal">git push</code> を実行した際、リモート参照が更新された後、オブジェクトの転送が始まる前に実行されます。
このフックはリモートの名前と場所を引数に取ります。また、これから更新する参照のリストを <code class="literal">stdin</code> から受け取ります。
このフックは、プッシュを行う前に、更新される参照を検査するのに使用できます（ゼロ以外の値を返すとプッシュが中断されます）。</p>
<p>Git は通常の操作の一環として、時折 <code class="literal">git gc --auto</code> を実行してガベージコレクションを行います。
<code class="literal">pre-auto-gc</code> フックは、ガベージコレクションが実行される直前に呼び出されます。このフックは、ガベージコレクションが実行されることを通知したり、タイミングが悪い場合にガベージコレクションを中断したりするのに使用できます。</p>
</section>
</section>
<section class="sect2" title="サーバーサイドフック">
<h3 id="_サーバーサイドフック">サーバーサイドフック</h3>
<p>システム管理者としてプロジェクトのポリシーを強制させる際には、クライアントサイドフックに加え、いくつかのサーバーサイドフックを使うこともできます。
これらのスクリプトは、サーバへのプッシュの前後に実行されます。
pre フックをゼロ以外の値で終了させると、プッシュを却下してエラーメッセージをクライアントに返すことができます。つまり、プッシュに関して、好きなだけ複雑なポリシーを設定できるということです。</p>
<section class="sect3" title="pre-receive">
<h4 id="_code_class_literal_pre_receive_code"><code class="literal">pre-receive</code></h4>
<p>クライアントからのプッシュを処理するときに最初に実行されるスクリプトが <code class="literal">pre-receive</code> です。
このスクリプトは、プッシュされた参照のリストを標準入力から受け取ります。ゼロ以外の値で終了させると、これらはすべて却下されます。
このフックを使うと、更新内容がすべてfast-forwardであることをチェックしたり、プッシュによって変更されるファイルや参照に対するアクセス制御を行ったりできます。</p>
</section>
<section class="sect3" title="update">
<h4 id="_code_class_literal_update_code"><code class="literal">update</code></h4>
<p><code class="literal">update</code> スクリプトは <code class="literal">pre-receive</code> スクリプトと似ていますが、プッシュしてきた人が更新しようとしているブランチごとに実行されるという点が異なります。
複数のブランチへのプッシュがあったときに <code class="literal">pre-receive</code> が実行されるのは一度だけですが、update はブランチ単位でそれぞれ一度ずつ実行されます。
このスクリプトは、標準入力を読み込むのではなく三つの引数を受け取ります。参照 (ブランチ) の名前、プッシュ前を指す参照の SHA-1、そしてプッシュしようとしている参照の SHA-1 です。
update スクリプトをゼロ以外で終了させると、その参照のみが却下されます。それ以外の参照はそのまま更新を続行します。</p>
</section>
<section class="sect3" title="post-receive">
<h4 id="_code_class_literal_post_receive_code"><code class="literal">post-receive</code></h4>
<p><code class="literal">post-receive</code> フックは処理が終了した後で実行されるもので、他のサービスの更新やユーザーへの通知などに使えます。
このフックは、 <code class="literal">pre-receive</code> フックと同じデータを標準入力から受け取ります。
サンプルのスクリプトには、リストをメールしたり、継続的インテグレーションサーバーへ通知したり、チケット追跡システムを更新したりといった処理が含まれています。コミットメッセージを解析して、チケットのオープン・修正・クローズなどの必要性を調べることもできます。
このスクリプトではプッシュの処理を中断させることはできませんが、クライアント側ではこのスクリプトが終了するまで接続を切断できません。このスクリプトで時間のかかる処理をさせるときには十分注意しましょう。</p>
</section>
</section>
</section>
<section class="sect1" title="Git ポリシーの実施例">
<h2 id="r_an_example_git_enforced_policy">Git ポリシーの実施例</h2>
<p></p>
<p>このセクションでは、これまでに学んだ内容を使って実際に Git のワークフローを確立してみます。
コミットメッセージの書式をチェックし、またプロジェクト内の特定のサブディレクトリを特定のユーザーだけが変更できるようにします。
以降では、開発者に対して「なぜプッシュが却下されたのか」を伝えるためのクライアントスクリプトと、ポリシーを強制するためのサーバースクリプトを作成していきます。</p>
<p>以降で示すスクリプトは Ruby で書かれています。理由としては、我々の知的習慣によるところもありますが、Ruby は（たとえ書けないとしても）読むのが簡単というのも理由のひとつです。
しかし、それ以外の言語であってもきちんと動作します。Git に同梱されているサンプルスクリプトはすべて Perl あるいは Bash で書かれています。サンプルスクリプトを見れば、それらの言語による大量のフックの例を見ることができます。</p>
<section class="sect2" title="サーバーサイドフック">
<h3 id="_サーバーサイドフック_2">サーバーサイドフック</h3>
<p>サーバーサイドで行う処理は、すべて <code class="literal">hooks</code> ディレクトリの <code class="literal">update</code> ファイルにまとめます。
<code class="literal">update</code> ファイルはプッシュされるブランチごとに実行され、次の3つの引数を取ります。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">プッシュされる参照の名前</span>
</li>
<li>
<span class="principal">操作前のブランチのリビジョン</span>
</li>
<li>
<span class="principal">プッシュされる新しいリビジョン</span>
</li>
</ul>
</div>
<p>また、SSH 経由でのプッシュの場合は、プッシュしたユーザーを知ることもできます。
全員に共通のユーザー（ “git” など）を使って公開鍵認証をしている場合は、公開鍵の情報に基づいて実際のユーザーを判断して環境変数を設定するというラッパーが必要です。
ここでは、接続しているユーザー名が環境変数 <code class="literal">$USER</code> に格納されているものとします。 <code class="literal">update</code> スクリプトは、まず必要な情報を取得するところから始まります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV[<span style="font-style: italic">&#39;USER&#39;</span>]

puts <span style="font-style: italic">&quot;Enforcing Policies...&quot;</span>
puts <span style="font-style: italic">&quot;(</span><span style="font-weight: bold; font-style: italic">#{</span>$refname<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">) (</span><span style="font-weight: bold; font-style: italic">#{</span>$oldrev[0,6]<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">) (</span><span style="font-weight: bold; font-style: italic">#{</span>$newrev[0,6]<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">)&quot;</span></code></pre>
</figure>
<p>そう、グローバル変数を使ってますね。
が、責めないでください – 実例を示すには、こっちの方が簡単なんです。</p>
<section class="sect3" title="特定のコミットメッセージ書式の強制">
<h4 id="r_enforcing_commit_message_format">特定のコミットメッセージ書式の強制</h4>
<p>まずは、コミットメッセージを特定の書式に従わせることに挑戦してみましょう。
ここでは、コミットメッセージには必ず “ref: 1234” 形式の文字列を含むこと、というルールにします。個々のコミットをチケットシステムの作業項目とリンクさせたいという意図です。
やらなければならないことは、プッシュされてきた各コミットのコミットメッセージに上記の文字列があるか調べ、なければゼロ以外の値を返して終了し、プッシュを却下することです。</p>
<p>プッシュされたすべてのコミットの SHA-1 値を取得するには、<code class="literal">$newrev</code> と <code class="literal">$oldrev</code> の内容を <code class="literal">git rev-list</code> という Git の配管（plumbing）コマンドに渡します。
これは基本的には <code class="literal">git log</code> コマンドのようなものですが、デフォルトでは SHA-1 値だけを表示してそれ以外の情報は出力しません。
ふたつのコミットの間のすべてのコミットの SHA-1 を得るには、次のようなコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</code></pre>
</figure>
<p>この出力を受け取って、ループさせて各コミットの SHA-1 を取得し、個々のメッセージを取り出せば、正規表現でそのメッセージを調べることができます。</p>
<p>さて、これらのコミットからコミットメッセージを取り出す方法を見つけなければなりません。
生のコミットデータを取得するには、別の配管コマンド <code class="literal">git cat-file</code> を使います。
配管コマンドについては <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Gitの内側</a> で詳しく説明しますが、とりあえずはこのコマンドがどんな結果を返すのだけを示します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</figure>
<p>SHA-1 値がわかっているときにコミットからコミットメッセージを得るシンプルな方法は、空行を探してそれ以降をすべて取得するというものです。
これには、Unix システムの <code class="literal">sed</code> コマンドが使えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cat-file commit ca82a6 | sed <span style="font-style: italic">&#39;1,/^$/d&#39;</span>
changed the version number</code></pre>
</figure>
<p>プッシュしようとしているコミットから、この呪文を使ってコミットメッセージを取得し、もし条件にマッチしないものがあれば終了させればよいのです。
スクリプトを抜けてプッシュを却下するには、ゼロ以外の値を返して終了します。
以上を踏まえると、このメソッドは次のようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$regex = <span style="font-style: italic">/\[ref: (\d+)\]/</span>

<span style="font-style: italic"># enforced custom commit message format</span>
<span style="font-weight: bold">def</span> check_message_format
  missed_revs = <span style="font-style: italic">`git rev-list </span><span style="font-weight: bold; font-style: italic">#{</span>$oldrev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">..</span><span style="font-weight: bold; font-style: italic">#{</span>$newrev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>)
  missed_revs.each <span style="font-weight: bold">do</span> |rev|
    message = <span style="font-style: italic">`git cat-file commit </span><span style="font-weight: bold; font-style: italic">#{</span>rev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> | sed &#39;1,/^$/d&#39;`</span>
    <span style="font-weight: bold">if</span> !$regex.match(message)
      puts <span style="font-style: italic">&quot;[POLICY] Your message is not formatted correctly&quot;</span>
      exit 1
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>
check_message_format</code></pre>
</figure>
<p>これを <code class="literal">update</code> スクリプトに追加すると、ルールを守らないコミットメッセージが含まれるコミットのプッシュを却下するようになります。</p>
</section>
<section class="sect3" title="ユーザーベースのアクセス制御">
<h4 id="_ユーザーベースのアクセス制御">ユーザーベースのアクセス制御</h4>
<p>アクセス制御リスト (ACL) を使って、ユーザーごとにプロジェクトのどの部分に対して変更をプッシュできるのかを指定できる仕組みを追加したいとしましょう。
全体にアクセスできるユーザーもいれば、特定のサブディレクトリやファイルにしか変更をプッシュできないユーザーもいる、といった具合です。
これを行うには、ルールを書いたファイル <code class="literal">acl</code> をサーバー上のベア Git リポジトリに置きます。
<code class="literal">update</code> フックにこのファイルを読ませ、プッシュされてきたコミットにどのようなファイルが含まれているのかを調べ、そしてプッシュしたユーザーにそのファイルを変更する権限があるのか判断します。</p>
<p>まずは ACL を作るところから始めましょう。
ここでは、CVS の ACL と似た書式を使います。これは各項目を一行で表し、最初のフィールドは <code class="literal">avail</code> あるいは <code class="literal">unavail</code>、そして次の行がそのルールを適用するユーザーの一覧（カンマ区切り）、そして最後のフィールドがそのルールを適用するパス（ブランクは全体へのアクセスを意味します）です。フィールドの区切りには、パイプ文字 (<code class="literal">|</code>) を使います。</p>
<p>ここでは、全体にアクセスできる管理者、 <code class="literal">doc</code> ディレクトリにアクセスできるドキュメント担当者、そして <code class="literal">lib</code> と <code class="literal">tests</code> ディレクトリだけにアクセスできる開発者を設定します。ACL ファイルは次のようになります。</p>
<figure class="listing">
<pre class="source language-"><code>avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests</code></pre>
</figure>
<p>まずはこのデータを読み込んで、スクリプト内で使えるデータ構造にしてみましょう。
例をシンプルにするために、ここでは <code class="literal">avail</code> ディレクティブだけを使います。
次のメソッドは連想配列を返すものです。配列のキーはユーザー名、キーに対応する値はそのユーザーが書き込み権限を持つパスの配列になります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> get_acl_access_data(acl_file)
  <span style="font-style: italic"># read in ACL data</span>
  acl_file = File.read(acl_file).split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>).reject { |line| line == <span style="font-style: italic">&#39;&#39;</span> }
  access = {}
  acl_file.each <span style="font-weight: bold">do</span> |line|
    avail, users, path = line.split(<span style="font-style: italic">&#39;|&#39;</span>)
    <span style="font-weight: bold">next</span> <span style="font-weight: bold">unless</span> avail == <span style="font-style: italic">&#39;avail&#39;</span>
    users.split(<span style="font-style: italic">&#39;,&#39;</span>).each <span style="font-weight: bold">do</span> |user|
      access[user] ||= []
      access[user] &lt;&lt; path
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
  access
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>先ほどの ACL ファイルをこの <code class="literal">get_acl_access_data</code> メソッドに渡すと、このようなデータ構造を返します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>{<span style="font-style: italic">&quot;defunkt&quot;</span>=&gt;[<span style="font-weight: bold">nil</span>],
 <span style="font-style: italic">&quot;tpw&quot;</span>=&gt;[<span style="font-weight: bold">nil</span>],
 <span style="font-style: italic">&quot;nickh&quot;</span>=&gt;[<span style="font-weight: bold">nil</span>],
 <span style="font-style: italic">&quot;pjhyett&quot;</span>=&gt;[<span style="font-weight: bold">nil</span>],
 <span style="font-style: italic">&quot;schacon&quot;</span>=&gt;[<span style="font-style: italic">&quot;lib&quot;</span>, <span style="font-style: italic">&quot;tests&quot;</span>],
 <span style="font-style: italic">&quot;cdickens&quot;</span>=&gt;[<span style="font-style: italic">&quot;doc&quot;</span>],
 <span style="font-style: italic">&quot;usinclair&quot;</span>=&gt;[<span style="font-style: italic">&quot;doc&quot;</span>],
 <span style="font-style: italic">&quot;ebronte&quot;</span>=&gt;[<span style="font-style: italic">&quot;doc&quot;</span>]}</code></pre>
</figure>
<p>これで権限がわかったので、あとはプッシュされた各コミットがどのパスを変更しようとしているのかを調べれば、そのユーザーがプッシュできるのか判断できます。</p>
<p>あるコミットでどのファイルが変更されるのかを知るのはとても簡単で、<code class="literal">git log</code> コマンドに <code class="literal">--name-only</code> オプションを指定するだけです（<a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git の基本</a> で簡単に説明しました）。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -1 --name-only --pretty=format:<span style="font-style: italic">&#39;&#39;</span> 9f585d

README
lib/test.rb</code></pre>
</figure>
<p><code class="literal">get_acl_access_data</code> メソッドが返す ACL のデータとこのファイルリストを付き合わせれば、そのユーザーにコミットをプッシュする権限があるかどうかを判断できます。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic"># only allows certain users to modify certain subdirectories in a project</span>
<span style="font-weight: bold">def</span> check_directory_perms
  access = get_acl_access_data(<span style="font-style: italic">&#39;acl&#39;</span>)

  <span style="font-style: italic"># see if anyone is trying to push something they can&#39;t</span>
  new_commits = <span style="font-style: italic">`git rev-list </span><span style="font-weight: bold; font-style: italic">#{</span>$oldrev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">..</span><span style="font-weight: bold; font-style: italic">#{</span>$newrev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>)
  new_commits.each <span style="font-weight: bold">do</span> |rev|
    files_modified = <span style="font-style: italic">`git log -1 --name-only --pretty=format:&#39;&#39; </span><span style="font-weight: bold; font-style: italic">#{</span>rev<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>)
    files_modified.each <span style="font-weight: bold">do</span> |path|
      <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> path.size == 0
      has_file_access = <span style="font-weight: bold">false</span>
      access[$user].each <span style="font-weight: bold">do</span> |access_path|
        <span style="font-weight: bold">if</span> !access_path  <span style="font-style: italic"># user has access to everything</span>
           || (path.start_with? access_path) <span style="font-style: italic"># access to this path</span>
          has_file_access = <span style="font-weight: bold">true</span>
        <span style="font-weight: bold">end</span>
      <span style="font-weight: bold">end</span>
      <span style="font-weight: bold">if</span> !has_file_access
        puts <span style="font-style: italic">&quot;[POLICY] You do not have access to push to </span><span style="font-weight: bold; font-style: italic">#{</span>path<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
        exit 1
      <span style="font-weight: bold">end</span>
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>

check_directory_perms</code></pre>
</figure>
<p>最初に <code class="literal">git rev-list</code> でサーバへプッシュされるコミットの一覧を取得します。
次に、それぞれのコミットでどのファイルが変更されるのかを調べ、プッシュしてきたユーザーにそのファイルを変更する権限があるか確かめています。</p>
<p>これで、まずい形式のコミットメッセージや、指定されたパス以外のファイルの変更を含むコミットはプッシュできなくなりました。</p>
</section>
<section class="sect3" title="テストを実施する">
<h4 id="_テストを実施する">テストを実施する</h4>
<p>これまでのコードを書き込んだファイルに対して <code class="literal">chmod u+x .git/hooks/update</code> を実行します。その上で、メッセージが規定に沿っていないコミットをプッシュしてみましょう。すると、こんなメッセージが表示されるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to &#39;git@gitserver:project.git&#39;</code></pre>
</figure>
<p>この中には、興味深い点がいくつかあります。
まず、フックの実行が始まったときの次の表示に注目しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)</code></pre>
</figure>
<p>これは、スクリプトの先頭で標準出力に表示した内容でした。
ここで重要なのは「スクリプトから <code class="literal">stdout</code> に送った内容は、すべてクライアントにも送られる」ということです。</p>
<p>次に注目するのは、エラーメッセージです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master</code></pre>
</figure>
<p>最初の行はスクリプトから出力したもので、その他の 2 行は Git が出力したものです。この 2 行では、スクリプトがゼロ以外の値で終了したためにプッシュが却下されたということを説明しています。
最後に、次の部分に注目します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to &#39;git@gitserver:project.git&#39;</code></pre>
</figure>
<p>フックで却下したすべての参照について、remote rejected メッセージが表示されます。これを見れば、フック内での処理のせいで却下されたのだということがわかります。</p>
<p>また、変更権限のないファイルを変更してそれを含むコミットをプッシュしようとしたときも、同様にエラーが表示されます。
たとえば、ドキュメント担当者が <code class="literal">lib</code> ディレクトリ内の何かを変更しようとした場合のメッセージは次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>[POLICY] You do not have access to push to lib/test.rb</code></pre>
</figure>
<p>以降、この <code class="literal">update</code> スクリプトが動いてさえいれば、指定したパターンを含まないコミットメッセージがリポジトリに登録されることは二度とありません。また、ユーザーに変なところをさわられる心配もなくなります。</p>
</section>
</section>
<section class="sect2" title="クライアントサイドフック">
<h3 id="_クライアントサイドフック_2">クライアントサイドフック</h3>
<p>この方式の弱点は、プッシュが却下されたときにユーザーが泣き寝入りせざるを得なくなるということです。
手間暇かけて仕上げた作業が最後の最後で却下されるというのは、非常にストレスがたまるし不可解です。さらに、プッシュするためには歴史を修正しなければならないのですが、気弱な人にとってそれはかなりつらいことです。</p>
<p>このジレンマに対する答えとして、サーバーが却下するであろう作業をするときに、それをユーザーに伝えるためのクライアントサイドフックを用意します。
そうすれば、何か問題があるときに、それをコミットする前に知ることができるので、取り返しのつかなくなる前に問題を修正できます。
なおプロジェクトをクローンしてもフックはコピーされないので、別の何らかの方法で各ユーザーにスクリプトを配布した上で、各ユーザーにそれを <code class="literal">.git/hooks</code> にコピーさせ、実行可能にさせる必要があります。
フックスクリプト自体をプロジェクトに含めたり別のプロジェクトにしたりすることはできますが、各自の環境でそれをフックとして自動的に設定することはできません。</p>
<p>はじめに、コミットを書き込む直前にコミットメッセージをチェックしなければなりません。コミットメッセージの書式に問題があったがために、変更がサーバーに却下されるということがないように、コミットメッセージの書式を調べるのです。
これを行うには <code class="literal">commit-msg</code> フックを使います。
最初の引数で渡されたファイルからコミットメッセージを読み込んでパターンと比較し、もしマッチしなければ Git の処理を中断させます。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>
message_file = ARGV[0]
message = File.read(message_file)

$regex = <span style="font-style: italic">/\[ref: (\d+)\]/</span>

<span style="font-weight: bold">if</span> !$regex.match(message)
  puts <span style="font-style: italic">&quot;[POLICY] Your message is not formatted correctly&quot;</span>
  exit 1
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>このスクリプトを適切な場所 (<code class="literal">.git/hooks/commit-msg</code>) に置いて実行可能にしておくと、不適切なメッセージを書いてコミットしようとしたときに次のような結果となります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;test&#39;</span>
[POLICY] Your message is not formatted correctly</code></pre>
</figure>
<p>このとき、実際にはコミットされません。
もしメッセージが適切な書式になっていれば、Git はコミットを許可します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;test [ref: 132]&#39;</span>
[master e05c914] test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>次に、ACL で決められた範囲以外のファイルを変更していないことを確認しましょう。
先ほど使った ACL ファイルのコピーがプロジェクトの <code class="literal">.git</code> ディレクトリにあれば、次のような <code class="literal">pre-commit</code> スクリプトでチェックできます。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

$user    = ENV[<span style="font-style: italic">&#39;USER&#39;</span>]

<span style="font-style: italic"># [ insert acl_access_data method from above ]</span>

<span style="font-style: italic"># only allows certain users to modify certain subdirectories in a project</span>
<span style="font-weight: bold">def</span> check_directory_perms
  access = get_acl_access_data(<span style="font-style: italic">&#39;.git/acl&#39;</span>)

  files_modified = <span style="font-style: italic">`git diff-index --cached --name-only HEAD`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>)
  files_modified.each <span style="font-weight: bold">do</span> |path|
    <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> path.size == 0
    has_file_access = <span style="font-weight: bold">false</span>
    access[$user].each <span style="font-weight: bold">do</span> |access_path|
    <span style="font-weight: bold">if</span> !access_path || (path.index(access_path) == 0)
      has_file_access = <span style="font-weight: bold">true</span>
    <span style="font-weight: bold">end</span>
    <span style="font-weight: bold">if</span> !has_file_access
      puts <span style="font-style: italic">&quot;[POLICY] You do not have access to push to </span><span style="font-weight: bold; font-style: italic">#{</span>path<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
      exit 1
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>

check_directory_perms</code></pre>
</figure>
<p>大まかにはサーバーサイドのスクリプトと同じですが、重要な違いがふたつあります。
まず、ACL ファイルの場所が違います。このスクリプトは作業ディレクトリから実行するものであり、<code class="literal">.git</code> ディレクトリから実行するものではないからです。
ACL ファイルの場所を、先ほどの</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>access = get_acl_access_data(<span style="font-style: italic">&#39;acl&#39;</span>)</code></pre>
</figure>
<p>から次のように変更しなければなりません。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>access = get_acl_access_data(<span style="font-style: italic">&#39;.git/acl&#39;</span>)</code></pre>
</figure>
<p>もうひとつの違いは、変更されたファイルの一覧を取得する方法です。
サーバーサイドのメソッドではコミットログを調べていました。しかしこの時点ではまだコミットが記録されていないので、ファイルの一覧はステージング・エリアから取得しなければなりません。
つまり、先ほどの</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>files_modified = <span style="font-style: italic">`git log -1 --name-only --pretty=format:&#39;&#39; </span><span style="font-weight: bold; font-style: italic">#{</span>ref<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span></code></pre>
</figure>
<p>は次のようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>files_modified = <span style="font-style: italic">`git diff-index --cached --name-only HEAD`</span></code></pre>
</figure>
<p>しかし、違うのはこの二点だけで、それ以外はまったく同じように動作します。
ただしこのスクリプトは、ローカルで実行しているユーザーと、リモートマシンにプッシュするときのユーザーが同じであることを前提にしています。
もし異なる場合は、変数 <code class="literal">$user</code> を手動で設定しなければなりません。</p>
<p>最後に残ったのは fast-forward でないプッシュを止めることです。
fast-forward でない参照を取得するには、すでにプッシュした過去のコミットにリベースするか、別のローカルブランチにリモートブランチと同じところまでプッシュしなければなりません。</p>
<p>サーバーサイドではすでに <code class="literal">receive.denyDeletes</code> と <code class="literal">receive.denyNonFastForwards</code> でこのポリシーを強制しているでしょうから、あり得るのは、すでにプッシュ済みのコミットをリベースしようとするときくらいです。</p>
<p>それをチェックする pre-rebase スクリプトの例を示します。
これは書き換えようとしているコミットの一覧を取得し、それがリモート参照の中に存在するかどうかを調べます。
リモート参照から到達可能なコミットがひとつでもあれば、リベースを中断します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

base_branch = ARGV[0]
<span style="font-weight: bold">if</span> ARGV[1]
  topic_branch = ARGV[1]
<span style="font-weight: bold">else</span>
  topic_branch = <span style="font-style: italic">&quot;HEAD&quot;</span>
<span style="font-weight: bold">end</span>

target_shas = <span style="font-style: italic">`git rev-list </span><span style="font-weight: bold; font-style: italic">#{</span>base_branch<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">..</span><span style="font-weight: bold; font-style: italic">#{</span>topic_branch<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>)
remote_refs = <span style="font-style: italic">`git branch -r`</span>.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>).map { |r| r.strip }

target_shas.each <span style="font-weight: bold">do</span> |sha|
  remote_refs.each <span style="font-weight: bold">do</span> |remote_ref|
    shas_pushed = <span style="font-style: italic">`git rev-list ^</span><span style="font-weight: bold; font-style: italic">#{</span>sha<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">^@ refs/remotes/</span><span style="font-weight: bold; font-style: italic">#{</span>remote_ref<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span>
    <span style="font-weight: bold">if</span> shas_pushed.split(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>).include?(sha)
      puts <span style="font-style: italic">&quot;[POLICY] Commit </span><span style="font-weight: bold; font-style: italic">#{</span>sha<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> has already been pushed to </span><span style="font-weight: bold; font-style: italic">#{</span>remote_ref<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
      exit 1
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>このスクリプトでは、 <a id="xref--ch07-git-tools--r_revision_selection" href="ch07-git-tools.xhtml#r_revision_selection" class="xref">リビジョンの選択</a> ではカバーしていない構文を使っています。
既にプッシュ済みのコミットの一覧を得るために、次のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">`git rev-list ^</span><span style="font-weight: bold; font-style: italic">#{</span>sha<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">^@ refs/remotes/</span><span style="font-weight: bold; font-style: italic">#{</span>remote_ref<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">`</span></code></pre>
</figure>
<p><code class="literal">SHA^@</code> 構文は、そのコミットのすべての親を解決します。
リモートの最後のコミットから到達可能で、これからプッシュしようとする SHA-1 の親のいずれかからもアクセスできないコミット（これによって fast-forward であることが分かります）を探します。</p>
<p>この方式の弱点は非常に時間がかかることで、多くの場合このチェックは不要です。<code class="literal">-f</code> つきで強制的にプッシュしようとしない限り、サーバーが警告を出してプッシュできないからです。
しかし練習用の課題としてはおもしろいもので、あとでリベースを取り消してやりなおすはめになることを理屈上は防げるようになります。</p>
</section>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ">まとめ</h2>
<p>Git クライアントとサーバーをカスタマイズして自分たちのプロジェクトやワークフローにあてはめるための主要な方法を説明しました。
あらゆる設定項目やファイルベースの属性、そしてイベントフックについて学び、特定のポリシーを実現するサーバーを構築するサンプルを示しました。
これで、あなたが思い描くであろうほぼすべてのワークフローにあわせて Git を調整できるようになったはずです。</p>
</section>
</section>
</body>
</html>