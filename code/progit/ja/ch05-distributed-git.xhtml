<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git での分散作業</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git での分散作業" epub:type="chapter" id="ch05-distributed-git">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>での分散作業</b></small></h1>
</div>
</header>
<p></p>
<p>リモート Git リポジトリを用意し、すべての開発者がコードを共有できるようになりました。また、ローカル環境で作業をする際に使う基本的な Git コマンドについても身についたことでしょう。次に、Git を使った分散作業の流れを見ていきましょう。</p>
<p>本章では、Git を使った分散環境での作業の流れを説明します。
自分のコードをプロジェクトに提供する方法、そしてプロジェクトのメンテナーと自分の両方が作業を進めやすくする方法、そして多数の開発者からの貢献を受け入れるプロジェクトを運営する方法などを扱います。</p>
<section class="sect1" title="分散作業の流れ">
<h2 id="_分散作業の流れ">分散作業の流れ</h2>
<p></p>
<p>中央管理型のバージョン管理システム (Centralized Version Control System: CVCS) とは違い、Git は分散型だという特徴があります。この特徴を生かすと、プロジェクトの開発者間での共同作業をより柔軟に行えるようになります。
中央管理型のシステムでは、個々の開発者は中央のハブに対するノードという位置づけとなります。
しかし Git では、各開発者はノードであると同時にハブにもなり得ます。つまり、誰もが他のリポジトリに対してコードを提供することができ、誰もが公開リポジトリを管理して他の開発者の作業を受け入れることもできるということです。
これは、みなさんのプロジェクトや開発チームでの作業の流れにさまざまな可能性をもたらします。本章では、この柔軟性を生かすいくつかの実例を示します。
それぞれについて、利点だけでなく想定される弱点についても扱うので、適宜取捨選択してご利用ください。</p>
<section class="sect2" title="中央集権型のワークフロー">
<h3 id="_中央集権型のワークフロー">中央集権型のワークフロー</h3>
<p></p>
<p>中央管理型のシステムでは共同作業の方式は一つだけです。それが中央集権型のワークフローです。
これは、中央にある一つのハブ (リポジトリ) がコードを受け入れ、他のメンバー全員がそこに作業内容を同期させるという流れです。
多数の開発者がハブにつながるノードとなり、作業を一か所に集約します。</p>
<figure class="image">
<div class="content">
<img src="images/centralized_workflow.png" alt="中央集権型のワークフロー"/>
</div>
<figcaption>Figure 1. 中央集権型のワークフロー</figcaption>
</figure>
<p>二人の開発者がハブからのクローンを作成して個々に変更をした場合、最初の開発者がそれをプッシュするのは特に問題なくできます。
もう一人の開発者は、まず最初の開発者の変更をマージしてからサーバーへのプッシュを行い、最初の開発者の変更を消してしまわないようにします。
この考え方は、Git 上でも Subversion  (あるいはその他の CVCS) と同様に生かせます。そしてこの方式は Git でも完全に機能します。</p>
<p>小規模なチームに所属していたり、組織内で既に中央集権型のワークフローになじんでいたりなどの場合は、Git でその方式を続けることも簡単です。
リポジトリをひとつ立ち上げて、チームのメンバー全員がそこにプッシュできるようにすればいいのです。Git は他のユーザーの変更を上書きしてしまうことはありません。
たとえば、John と Jessica が作業を一斉に始めたとしましょう。
先に作業が終わった John が、変更をサーバーにプッシュします。
次に、Jessica が変更をプッシュしようとすると、サーバー側でそのプッシュは拒否されます。
そして Jessica は、直接プッシュすることはできないのでまずは変更内容をマージする必要があることを Git のエラーメッセージから気づきます。
この方式は多くの人にとって魅力的なものでしょう。これまでにもなじみのある方式だし、今までそれでうまくやってきたからです。</p>
<p>また、この例は小規模なチームに限った話ではありません。Git のブランチモデルを用いてひとつのプロジェクト上にたくさんのブランチを作れば、何百人もの開発者が同時並行で作業を進めることだってできるのです。</p>
</section>
<section class="sect2" title="統合マネージャー型のワークフロー">
<h3 id="r_integration_manager">統合マネージャー型のワークフロー</h3>
<p></p>
<p>Git では複数のリモートリポジトリを持つことができるので、書き込み権限を持つ公開リポジトリを各自が持ち、他のメンバーからは読み込みのみのアクセスを許可するという方式をとることもできます。
この方式には、「公式」プロジェクトを表す公式なリポジトリも含みます。
このプロジェクトの開発に参加するには、まずプロジェクトのクローンを自分用に作成し、変更はそこにプッシュします。
次に、メインプロジェクトのメンテナーに「変更を取り込んでほしい」とお願いします。
メンテナーはあなたのリポジトリをリモートに追加し、変更を取り込んでマージします。そしてその結果をリポジトリにプッシュするのです。
この作業の流れは次のようになります ( <a id="xref-rwfdiag_b" href="#rwfdiag_b" class="xref">統合マネージャー型のワークフロー</a> を参照ください)。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">プロジェクトのメンテナーが公開リポジトリにプッシュする</span>
</li>
<li>
<span class="principal">開発者がそのリポジトリをクローンし、変更を加える</span>
</li>
<li>
<span class="principal">開発者が各自の公開リポジトリにプッシュする</span>
</li>
<li>
<span class="principal">開発者がメンテナーに「変更を取り込んでほしい」というメールを送る</span>
</li>
<li>
<span class="principal">メンテナーが開発者のリポジトリをリモートに追加し、それをマージする</span>
</li>
<li>
<span class="principal">マージした結果をメンテナーがメインリポジトリにプッシュする</span>
</li>
</ol>
</div>
<figure id="rwfdiag_b" class="image">
<div class="content">
<img src="images/integration-manager.png" alt="統合マネージャー型のワークフロー"/>
</div>
<figcaption>Figure 2. 統合マネージャー型のワークフロー</figcaption>
</figure>
<p></p>
<p>これは GitHub や GitLab のようなハブ型のツールでよく使われている流れです。プロジェクトを容易にフォークでき、そこにプッシュした内容をみんなに簡単に見てもらえます。
この方式の主な利点の一つは、あなたはそのまま開発を続行し、メインリポジトリのメンテナーはいつでも好きなタイミングで変更を取り込めるということです。
変更を取り込んでもらえるまで作業を止めて待つ必要はありません。自分のペースで作業を進められるのです。</p>
</section>
<section class="sect2" title="独裁者と副官型のワークフロー">
<h3 id="_独裁者と副官型のワークフロー">独裁者と副官型のワークフロー</h3>
<p></p>
<p>これは、複数リポジトリ型のワークフローのひとつです。
何百人もの開発者が参加するような巨大なプロジェクトで採用されています。有名どころでは Linux カーネルがこの方式です。
統合マネージャーを何人も用意し、それぞれにリポジトリの特定の部分を担当させます。彼らは副官 (lieutenant) と呼ばれます。
そしてすべての副官をまとめる統合マネージャーが「慈悲深い独裁者 (benevalent dictator)」です。
独裁者のリポジトリが基準リポジトリとなり、すべてのメンバーはこれをプルします。
この作業の流れは次のようになります ( <a id="xref-rwfdiag_c" href="#rwfdiag_c" class="xref">慈悲深い独裁者型のワークフロー</a> を参照ください)。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">一般の開発者はトピックブランチ上で作業を進め、<code class="literal">master</code> の先頭にリベースする。独裁者の <code class="literal">master</code> ブランチがマスターとなる</span>
</li>
<li>
<span class="principal">副官が各開発者のトピックブランチを自分の <code class="literal">master</code> ブランチにマージする</span>
</li>
<li>
<span class="principal">独裁者が各副官の <code class="literal">master</code> ブランチを自分の <code class="literal">master</code> ブランチにマージする</span>
</li>
<li>
<span class="principal">独裁者が自分の <code class="literal">master</code> をリポジトリにプッシュし、他のメンバーがリベースできるようにする</span>
</li>
</ol>
</div>
<figure id="rwfdiag_c" class="image">
<div class="content">
<img src="images/benevolent-dictator.png" alt="慈悲深い独裁者型のワークフロー"/>
</div>
<figcaption>Figure 3. 慈悲深い独裁者型のワークフロー</figcaption>
</figure>
<p>この手のワークフローはあまり一般的ではありませんが、大規模なプロジェクトや高度に階層化された環境では便利です。
プロジェクトリーダー (独裁者) が大半の作業を委譲し、サブセット単位である程度まとまってからコードを統合することができるからです。</p>
</section>
<section class="sect2" title="ワークフローのまとめ">
<h3 id="_ワークフローのまとめ">ワークフローのまとめ</h3>
<p>Git のような分散システムでよく使われるワークフローの多くは、実社会での何らかのワークフローにあてはめて考えることができます。
これで、どのワークフローがあなたに合うかがわかったことでしょう (ですよね?)。
次は、より特化した例をあげて個々のフローを実現する方法を見ていきましょう。</p>
</section>
</section>
<section class="sect1" title="プロジェクトへの貢献">
<h2 id="r_contributing_project">プロジェクトへの貢献</h2>
<p></p>
<p>どうやってプロジェクトに貢献するか、というのは非常に説明しづらい内容です。というのも、ほんとうにいろいろなパターンがあるからです。
Git は柔軟なシステムなので、いろいろな方法で共同作業をすることができます。そのせいもあり、どのプロジェクトをとってみても微妙に他とは異なる方式を使っているのです。
違いが出てくる原因としては、アクティブな貢献者の数やプロジェクトで使用しているワークフロー、あなたのコミット権、そして外部からの貢献を受け入れる際の方式などがあります。</p>
<p>最初の要素はアクティブな貢献者の数です。そのプロジェクトに対してアクティブにコードを提供している開発者はどれくらいいるのか、そして彼らはどれくらいの頻度で提供しているのか。
よくあるのは、数名の開発者が一日数回のコミットを行うというものです。休眠状態のプロジェクトなら、もう少し頻度が低くなるでしょう。
企業やプロジェクトの規模が大きくなると、開発者の数が数千人になることもあります。数百から下手したら千を超えるようなコミットが毎日やってきます。
開発者の数が増えれば増えるほど、あなたのコードをきちんと適用したり他のコードをマージしたりするのが難しくなります。
あなたが手元で作業をしている間に他の変更が入って、手元で変更した内容が無意味になってしまったりあるいは他の変更を壊してしまう羽目になったり。そのせいで、手元の変更を適用してもらうための待ち時間が発生したり。
手元のコードを常に最新の状態にし、正しいコミットを作るにはどうしたらいいのでしょうか。</p>
<p>次に考えるのは、プロジェクトが採用しているワークフローです。
中央管理型で、すべての開発者がコードに対して同等の書き込みアクセス権を持っている状態?
特定のメンテナーや統合マネージャーがすべてのパッチをチェックしている?
パッチを適用する前にピアレビューをしている?
あなたはパッチをチェックしたりピアレビューに参加したりしている人?
副官型のワークフローを使っており、まず彼らにコードを渡さなければならない?</p>
<p>次の問題は、あなたのコミット権です。
あなたがプロジェクトへの書き込みアクセス権限を持っている場合は、プロジェクトに貢献するための作業の流れが変わってきます。
書き込み権限がない場合、そのプロジェクトではどのような形式での貢献を推奨していますか?
何かポリシーのようなものはありますか?
一度にどれくらいの作業を貢献することになりますか?
また、どれくらいの頻度で貢献することになりますか?</p>
<p>これらの点を考慮して、あなたがどんな流れでどのようにプロジェクトに貢献していくのかが決まります。
単純なものから複雑なものまで、実際の例を見ながら考えていきましょう。これらの例を参考に、あなたなりのワークフローを見つけてください。</p>
<section class="sect2" title="コミットの指針">
<h3 id="r_commit_guidelines">コミットの指針</h3>
<p>個々の例を見る前に、コミットメッセージについてのちょっとした注意点をお話しておきましょう。
コミットに関する指針をきちんと定めてそれを守るようにすると、Git での共同作業がよりうまく進むようになります。
Git プロジェクトでは、パッチの投稿用のコミットを作成するときのヒントをまとめたドキュメントを用意しています。Git のソースの中にある <code class="literal">Documentation/SubmittingPatches</code> をごらんください。</p>
<p></p>
<p>まず、余計な空白文字を含めてしまわないように注意が必要です。
Git には、余計な空白文字をチェックするための簡単な仕組みがあります。コミットする前に <code class="literal">git diff --check</code> を実行してみましょう。おそらく意図したものではないと思われる空白文字を探し、それを教えてくれます。</p>
<figure class="image">
<div class="content">
<img src="images/git-diff-check.png" alt="`git diff --check` 実行結果"/>
</div>
<figcaption>Figure 4. <code class="literal">git diff --check</code> 実行結果</figcaption>
</figure>
<p>コミットの前にこのコマンドを実行すれば、余計な空白文字をコミットしてしまって他の開発者に嫌がられることもなくなるでしょう。</p>
<p>次に、コミットの単位が論理的に独立した変更となるようにしましょう。
つまり、個々の変更内容を把握しやすくするということです。週末に五つの問題点を修正した大規模な変更を、月曜日にまとめてコミットするなどということは避けましょう。
仮に週末の間にコミットできなかったとしても、ステージングエリアを活用して月曜日にコミット内容を調整することができます。修正した問題ごとにコミットを分割し、それぞれに適切なコメントをつければいいのです。
もし別々の問題の修正で同じファイルを変更しているのなら、<code class="literal">git add --patch</code> を使ってその一部だけをステージすることもできます (詳しくは <a id="xref--ch07-git-tools--r_interactive_staging" href="ch07-git-tools.xhtml#r_interactive_staging" class="xref">対話的なステージング</a> で説明します)。
すべての変更を同時に追加しさえすれば、一度にコミットしようが五つのコミットに分割しようがブランチの先端は同じ状態になります。あとから変更内容をレビューする他のメンバーのことも考えて、できるだけレビューしやすい状態でコミットするようにしましょう。
こうしておけば、あとからその変更の一部だけを取り消したりするのにも便利です。
<a id="xref--ch07-git-tools--r_rewriting_history" href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">歴史の書き換え</a> では、Git を使って歴史を書き換えたり対話的にファイルをステージしたりする方法を説明します。作業内容を誰かに送る前にその方法を使えば、きれいでわかりやすい歴史を作り上げることができます。</p>
<p>最後に注意しておきたいのが、コミットメッセージです。
よりよいコミットメッセージを書く習慣を身に着けておくと、Git を使った共同作業をより簡単に行えるようになります。
一般的な規則として、メッセージの最初には変更の概要を一行 (50 文字以内) にまとめた説明をつけるようにします。その後に空行をひとつ置いてからより詳しい説明を続けます。
Git プロジェクトでは、その変更の動機やこれまでの実装との違いなどのできるだけ詳しい説明をつけることを推奨しています。参考にするとよいでしょう。
また、メッセージでは命令形、現在形を使うようにしています。
つまり “私は○○のテストを追加しました (I added tests for)” とか “○○のテストを追加します (Adding tests for,)” ではなく “○○のテストを追加 (Add tests for.)” 形式にするということです。
Tim Pope が書いたテンプレート (の日本語訳) を以下に示します。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>短い (50 文字以下での) 変更内容のまとめ

必要に応じた、より詳細な説明。72文字程度で折り返します。最初の
行がメールの件名、残りの部分がメールの本文だと考えてもよいでしょ
う。最初の行と詳細な説明の間には、必ず空行を入れなければなりま
せん (詳細説明がまったくない場合は空行は不要です)。空行がないと、
rebase などがうまく動作しません。

空行を置いて、さらに段落を続けることもできます。

  - 箇条書きも可能

  - 箇条書きの記号としては、主にハイフンやアスタリスクを使います。
    箇条書き記号の前にはひとつ空白を入れ、各項目の間には空行を入
    れます。しかし、これ以外の流儀もいろいろあります。</code></pre>
</figure>
<p>すべてのコミットメッセージがこのようになっていれば、他の開発者との作業が非常に進めやすくなるでしょう。
Git プロジェクトでは、このようにきれいに整形されたコミットメッセージを使っています。<code class="literal">git log --no-merges</code> を実行すれば、きれいに整形されたプロジェクトの歴史がどのように見えるかがわかります。</p>
<p>これ以降の例を含めて本書では、説明を簡潔にするためにこのような整形を省略します。そのかわりに <code class="literal">git commit</code> の <code class="literal">-m</code> オプションを使います。
本書でのこのやり方をまねするのではなく、ここで説明した方式を使いましょう。</p>
</section>
<section class="sect2" title="非公開な小規模のチーム">
<h3 id="r_private_team">非公開な小規模のチーム</h3>
<p></p>
<p>実際に遭遇するであろう環境のうち最も小規模なのは、非公開のプロジェクトで開発者が数名といったものです。
ここでいう「非公開」とは、クローズドソースであるということ。つまり、チームのメンバー以外は見られないということです。
チーム内のメンバーは全員、リポジトリへのプッシュ権限を持っています。</p>
<p>こういった環境では、今まで Subversion やその他の中央管理型システムを使っていたときとほぼ同じワークフローで作業を進めることができます。
オフラインでコミットできたりブランチやマージが楽だったりといった Git ならではの利点はいかせますが、作業の流れ自体は今までとほぼ同じです。最大の違いは、マージが (コミット時にサーバー側で行われるのではなく) クライアント側で行われるということです。
二人の開発者が共有リポジトリで開発を始めるときにどうなるかを見ていきましょう。
最初の開発者 John が、リポジトリをクローンして変更を加え、それをローカルでコミットします (これ以降のメッセージでは、プロトコル関連のメッセージを <code class="literal">...</code> で省略しています)。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> John のマシン
<span style="font-weight: bold">$</span> git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
<span style="font-weight: bold">$</span> cd simplegit/
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;removed invalid default value&#39;</span>
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>もう一人の開発者 Jessica も同様に、リポジトリをクローンして変更をコミットしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica のマシン
<span style="font-weight: bold">$</span> git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
<span style="font-weight: bold">$</span> cd simplegit/
<span style="font-weight: bold">$</span> vim TODO
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add reset task&#39;</span>
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>Jessica が作業内容をサーバーにプッシュします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica のマシン
<span style="font-weight: bold">$</span> git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>
</figure>
<p>John も同様にプッシュしようとしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> John のマシン
<span style="font-weight: bold">$</span> git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to &#39;john@githost:simplegit.git&#39;</code></pre>
</figure>
<p>John はプッシュできませんでした。Jessica が先にプッシュを済ませていたからです。
Subversion になじみのある人には特に注目してほしいのですが、ここで John と Jessica が編集していたのは別々のファイルです。
Subversion ならこのような場合はサーバー側で自動的にマージを行いますが、Git の場合はローカルでマージしなければなりません。
John は、まず Jessica の変更内容を取得してマージしてからでないと、自分の変更をプッシュできないのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>
</figure>
<p>この時点で、John のローカルリポジトリはこのようになっています。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-1.png" alt="John の分岐した歴史"/>
</div>
<figcaption>Figure 5. John の分岐した歴史</figcaption>
</figure>
<p>John の手元に Jessica がプッシュした内容が届きましたが、さらにそれを彼自身の作業にマージしてからでないとプッシュできません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>マージがうまくいきました。John のコミット履歴は次のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-2.png" alt="`origin/master` をマージしたあとの John のリポジトリ"/>
</div>
<figcaption>Figure 6. <code class="literal">origin/master</code> をマージしたあとの John のリポジトリ</figcaption>
</figure>
<p>自分のコードが正しく動作することを確認した John は、変更内容をサーバーにプッシュします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>
</figure>
<p>最終的に、John のコミット履歴は以下のようになりました。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-3.png" alt="origin サーバーにプッシュした後の John の履歴"/>
</div>
<figcaption>Figure 7. origin サーバーにプッシュした後の John の履歴</figcaption>
</figure>
<p>一方そのころ、Jessica はトピックブランチで作業を進めていました。
<code class="literal">issue54</code> というトピックブランチを作成した彼女は、そこで 3 回コミットをしました。
彼女はまだ John の変更を取得していません。したがって、彼女のコミット履歴はこのような状態です。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-4.png" alt="Jessica のコミット履歴"/>
</div>
<figcaption>Figure 8. Jessica のコミット履歴</figcaption>
</figure>
<p>Jessica は John の作業を取り込もうとしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica のマシン
<span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>
</figure>
<p>これで、さきほど John がプッシュした内容が取り込まれました。Jessica の履歴は次のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-5.png" alt="John の変更を取り込んだ後の Jessica の履歴"/>
</div>
<figcaption>Figure 9. John の変更を取り込んだ後の Jessica の履歴</figcaption>
</figure>
<p>Jessica のトピックブランチ上での作業が完了しました。そこで、自分の作業をプッシュする前に何をマージしなければならないのかを確認するため、
彼女は <code class="literal">git log</code> コマンドを実行しました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value</code></pre>
</figure>
<p><code class="literal">issue54..origin/master</code> はログのフィルター記法です。このように書くと、後者のブランチ（この例では <code class="literal">origin/master</code> ）には含まれるが前者のブランチ（この例では <code class="literal">issue54</code> ）には含まれないコミットのログだけを表示します。この記法の詳細は <a id="xref--ch07-git-tools--r_commit_ranges" href="ch07-git-tools.xhtml#r_commit_ranges" class="xref">コミットの範囲指定</a> で説明します。</p>
<p>この例では、John が作成して Jessica がまだマージしていないコミットがひとつあることがコマンド出力から読み取れます。仮にここで Jessica が <code class="literal">origin/master</code> をマージするとしましょう。その場合、Jessica の手元のファイルを変更するのは John が作成したコミットひとつだけ、という状態になります。</p>
<p>Jessica はトピックブランチの内容を自分の master ブランチにマージし、同じく John の作業 (<code class="literal">origin/master</code>) も自分の <code class="literal">master</code> ブランチにマージして再び変更をサーバーにプッシュすることになります。まずは master ブランチに戻り、これまでの作業を統合できるようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout master
Switched to branch &#39;master&#39;
Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.</code></pre>
</figure>
<p><code class="literal">origin/master</code> と <code class="literal">issue54</code> のどちらからマージしてもかまいません。どちらも上流にあるので、マージする順序が変わっても結果は同じなのです。
どちらの順でマージしても、最終的なスナップショットはまったく同じものになります。ただそこにいたる歴史が微妙に変わってくるだけです。
彼女はまず <code class="literal">issue54</code> からマージすることにしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>何も問題は発生しません。ご覧の通り、単なる fast-forward です。
次に Jessica は John の作業 (<code class="literal">origin/master</code>) をマージします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>こちらもうまく完了しました。Jessica の履歴はこのようになります。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-6.png" alt="John の変更をマージした後の Jessica の履歴"/>
</div>
<figcaption>Figure 10. John の変更をマージした後の Jessica の履歴</figcaption>
</figure>
<p>これで、Jessica の <code class="literal">master</code> ブランチから <code class="literal">origin/master</code> に到達可能となります。これで自分の変更をプッシュできるようになりました (この作業の間に John は何もプッシュしていなかったものとします)。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>
</figure>
<p>各開発者が何度かコミットし、お互いの作業のマージも無事できました。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-7.png" alt="すべての変更をサーバーに書き戻した後の Jessica の履歴"/>
</div>
<figcaption>Figure 11. すべての変更をサーバーに書き戻した後の Jessica の履歴</figcaption>
</figure>
<p>これがもっとも単純なワークフローです。
トピックブランチでしばらく作業を進め、統合できる状態になれば自分の master ブランチにマージする。
他の開発者の作業を取り込む場合は、<code class="literal">origin/master</code> を取得してもし変更があればマージする。そして最終的にそれをサーバーの master ブランチにプッシュする。
全体的な流れは次のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/small-team-flow.png" alt="複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス"/>
</div>
<figcaption>Figure 12. 複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス</figcaption>
</figure>
</section>
<section class="sect2" title="非公開で管理されているチーム">
<h3 id="_非公開で管理されているチーム">非公開で管理されているチーム</h3>
<p></p>
<p>次に扱うシナリオは、大規模な非公開のグループに貢献するものです。
機能単位の小規模なグループで共同作業した結果を別のグループと統合するような環境での作業の進め方を学びましょう。</p>
<p>John と Jessica が共同でとある機能を実装しており、Jessica はそれとは別の件で Josie とも作業をしているものとします。
彼らの勤務先は統合マネージャー型のワークフローを採用しており、各グループの作業を統合する担当者が決まっています。メインリポジトリの <code class="literal">master</code> ブランチを更新できるのは統合担当者だけです。
この場合、すべての作業はチームごとのブランチで行われ、後で統合担当者がまとめることになります。</p>
<p>では、Jessica の作業の流れを追っていきましょう。彼女は二つの機能を同時に実装しており、それぞれ別の開発者と共同作業をしています。
すでに自分用のリポジトリをクローンしている彼女は、まず <code class="literal">featureA</code> の作業を始めることにしました。
この機能用に新しいブランチを作成し、そこで作業を進めます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessica のマシン
<span style="font-weight: bold">$</span> git checkout -b featureA
Switched to a new branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add limit to log function&#39;</span>
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>自分の作業内容を John に渡すため、彼女は <code class="literal">featureA</code> ブランチへのコミットをサーバーにプッシュしました。
Jessica には <code class="literal">master</code> ブランチへのプッシュをする権限はありません。そこにプッシュできるのは統合担当者だけなのです。そこで、John との共同作業用の別のブランチにプッシュします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>
</figure>
<p>Jessica は John に「私の作業を <code class="literal">featureA</code> というブランチにプッシュしておいたので、見てね」というメールを送りました。
John からの返事を待つ間、Jessica はもう一方の <code class="literal">featureB</code> の作業を Josie とはじめます。
まず最初に、この機能用の新しいブランチをサーバーの <code class="literal">master</code> ブランチから作ります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> Jessicaのマシン
<span style="font-weight: bold">$</span> git fetch origin
<span style="font-weight: bold">$</span> git checkout -b featureB origin/master
Switched to a new branch &#39;featureB&#39;</code></pre>
</figure>
<p>そして Jessica は、<code class="literal">featureB</code> ブランチに何度かコミットしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;made the ls-tree function recursive&#39;</span>
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight: bold">$</span> vim lib/simplegit.rb
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;add ls-files&#39;</span>
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>Jessica のリポジトリはこのようになっています。</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-1.png" alt="Jessica のコミット履歴"/>
</div>
<figcaption>Figure 13. Jessica のコミット履歴</figcaption>
</figure>
<p>この変更をプッシュしようと思ったそのときに、Josie から「私の作業を <code class="literal">featureBee</code> というブランチにプッシュしておいたので、見てね」というメールがやってきました。
Jessica はまずこの変更をマージしてからでないとサーバーにプッシュすることはできません。
そこで、まず Josie の変更を <code class="literal">git fetch</code> で取得しました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>
</figure>
<p>次に、<code class="literal">git merge</code> でこの内容を自分の作業にマージします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>ここでちょっとした問題が発生しました。彼女は、手元の <code class="literal">featureB</code> ブランチの内容をサーバーの <code class="literal">featureBee</code> ブランチにプッシュしなければなりません。
このような場合は、<code class="literal">git push</code> コマンドでローカルブランチ名に続けてコロン (:) を書き、その後にリモートブランチ名を指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>
</figure>
<p>これは <em>refspec</em> と呼ばれます。
<a id="xref--ch10-git-internals--r_refspec" href="ch10-git-internals.xhtml#r_refspec" class="xref">Refspec</a> で、Git の refspec の詳細とそれで何ができるのかを説明します。
また、 <code class="literal">-u</code> オプションが使われていることにも注意しましょう。これは <code class="literal">--set-upstream</code> オプションの省略形で、のちのちブランチのプッシュ・プルで楽をするための設定です。</p>
<p>さて、John からメールが返ってきました。「私の変更も <code class="literal">featureA</code> ブランチにプッシュしておいたので、確認よろしく」とのことです。
彼女は <code class="literal">git fetch</code> でその変更を取り込みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>
</figure>
<p>そして、<code class="literal">git log</code> で何が変わったのかを確認します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>
</figure>
<p>確認を終えた彼女は、John の作業を自分の <code class="literal">featureA</code> ブランチにマージしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout featureA
Switched to branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>Jessica はもう少し手を入れたいところがあったので、再びコミットしてそれをサーバーにプッシュします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;small tweak&#39;</span>
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight: bold">$</span> git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</code></pre>
</figure>
<p>Jessica のコミット履歴は、この時点で以下のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-2.png" alt="Jessica がブランチにコミットした後のコミット履歴"/>
</div>
<figcaption>Figure 14. Jessica がブランチにコミットした後のコミット履歴</figcaption>
</figure>
<p>Jessica、Josie そして John は、統合担当者に「<code class="literal">featureA</code> ブランチと <code class="literal">featureBee</code> ブランチは本流に統合できる状態になりました」と報告しました。
これらのブランチを担当者が本流に統合した後でそれを取得すると、マージコミットが新たに追加されてこのような状態になります。</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-3.png" alt="Jessica が両方のトピックブランチをマージしたあとのコミット履歴"/>
</div>
<figcaption>Figure 15. Jessica が両方のトピックブランチをマージしたあとのコミット履歴</figcaption>
</figure>
<p>Git へ移行するグループが続出しているのも、この「複数チームの作業を並行して進め、後で統合できる」という機能のおかげです。
小さなグループ単位でリモートブランチを使った共同作業ができ、しかもそれがチーム全体の作業を妨げることがない。これは Git の大きな利点です。
ここで見たワークフローをまとめると、次のようになります。</p>
<figure class="image">
<div class="content">
<img src="images/managed-team-flow.png" alt="管理されたチームでのワークフローの基本的な流れ"/>
</div>
<figcaption>Figure 16. 管理されたチームでのワークフローの基本的な流れ</figcaption>
</figure>
</section>
<section class="sect2" title="フォークされた公開プロジェクト">
<h3 id="r_public_project">フォークされた公開プロジェクト</h3>
<p></p>
<p>公開プロジェクトに貢献するとなると、また少し話が変わってきます。
そのプロジェクトのブランチを直接更新できる権限はないでしょうから、何か別の方法でメンテナに接触する必要があります。
まずは、フォークをサポートしている Git ホスティングサービスでフォークを使って貢献する方法を説明します。
多くの Git ホスティングサービス（GitHub、 BitBucket、 Google Code、 repo.or.cz など） がフォークをサポートしており、メンテナの多くはこの方式での協力を期待しています。
そしてこの次のセクションでは、メールでパッチを送る形式での貢献について説明します。</p>
<p>まずはメインリポジトリをクローンしましょう。そしてパッチ用のトピックブランチを作り、そこで作業を進めます。
このような流れになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone (url)
<span style="font-weight: bold">$</span> cd project
<span style="font-weight: bold">$</span> git checkout -b featureA
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">#</span> (work)
<span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p><code class="literal">rebase -i</code> を使ってすべての作業をひとつのコミットにまとめたり、メンテナがレビューしやすいようにコミット内容を整理したりといったことも行うかもしれません。対話的なリベースの方法については <a href="ch07-git-tools.xhtml#r_rewriting_history" class="xref">歴史の書き換え</a> で詳しく説明します。</p>
</div>
</aside>
<p>ブランチでの作業を終えてメンテナに渡せる状態になったら、プロジェクトのページに行って “Fork” ボタンを押し、自分用に書き込み可能なフォークを作成します。
このリポジトリの URL を追加のリモートとして設定しなければなりません。ここでは <code class="literal">myfork</code> という名前にしました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add myfork (url)</code></pre>
</figure>
<p>今後、自分の作業内容はここにプッシュすることになります。
変更を master ブランチにマージしてからそれをプッシュするよりも、今作業中の内容をそのままトピックブランチにプッシュするほうが簡単でしょう。
もしその変更が受け入れられなかったり一部だけが取り込まれたりした場合に、master ブランチを巻き戻す必要がなくなるからです。メンテナがあなたの作業をマージするかリベースするかあるいは一部だけ取り込むか、いずれにせよあなたはその結果をリポジトリから再度取り込むことになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push -u myfork featureA</code></pre>
</figure>
<p></p>
<p>自分用のフォークに作業内容をプッシュし終えたら、それをメンテナに伝えましょう。
これは、よく「プルリクエスト」と呼ばれるもので、ウェブサイトから実行する (GutHub には Pull request を行う独自の仕組みがあります。詳しくは <a id="xref--ch06-github" href="ch06-github.xhtml" class="xref">GitHub</a> で説明します) こともできれば、 <code class="literal">git request-pull</code> コマンドの出力をプロジェクトのメンテナにメールで送ることもできます。</p>
<p><code class="literal">request-pull</code> コマンドには、トピックブランチをプルしてもらいたい先のブランチとその Git リポジトリの URL を指定します。すると、プルしてもらいたい変更の概要が出力されます。
たとえば Jessica が John にプルリクエストを送ろうとしたとしましょう。彼女はすでにトピックブランチ上で 2 回のコミットを済ませています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</figure>
<p>この出力をメンテナに送れば「どのブランチからフォークしたのか、どういったコミットをしたのか、そしてそれをどこにプルしてほしいのか」を伝えることができます。</p>
<p>自分がメンテナになっていないプロジェクトで作業をする場合は、<code class="literal">master</code> ブランチでは常に <code class="literal">origin/master</code> を追いかけるようにし、自分の作業はトピックブランチで進めていくほうが楽です。そうすれば、パッチが拒否されたときも簡単にそれを捨てることができます。
また、作業内容ごとにトピックブランチを分離しておけば、本流のリポジトリが更新されてパッチがうまく適用できなくなったとしても簡単にリベースできるようになります。
たとえば、さきほどのプロジェクトに対して別の作業をすることになったとしましょう。その場合は、先ほどプッシュしたトピックブランチを使うのではなく、メインリポジトリの <code class="literal">master</code> ブランチから新たなトピックブランチを作成します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureB origin/master
<span style="font-weight: bold">#</span> （作業）
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">$</span> git push myfork featureB
<span style="font-weight: bold">#</span> （メンテナにメールを送る）
<span style="font-weight: bold">$</span> git fetch origin</code></pre>
</figure>
<p>これで、それぞれのトピックがサイロに入った状態になりました。お互いのトピックが邪魔しあったり依存しあったりすることなく、それぞれ個別に書き換えやリベースが可能となります。詳しくは以下を参照ください。</p>
<figure class="image">
<div class="content">
<img src="images/public-small-1.png" alt="`featureB` に関する作業のコミット履歴"/>
</div>
<figcaption>Figure 17. <code class="literal">featureB</code> に関する作業のコミット履歴</figcaption>
</figure>
<p>プロジェクトのメンテナが、他の大量のパッチを適用したあとであなたの最初のパッチを適用しようとしました。しかしその時点でパッチはすでにそのままでは適用できなくなっています。
こんな場合は、そのブランチを <code class="literal">origin/master</code> の先端にリベースして衝突を解決させ、あらためて変更内容をメンテナに送ります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout featureA
<span style="font-weight: bold">$</span> git rebase origin/master
<span style="font-weight: bold">$</span> git push -f myfork featureA</code></pre>
</figure>
<p>これで、あなたの歴史は <a id="xref-rpsp_b" href="#rpsp_b" class="xref"><code class="literal">featureA</code> の作業を終えた後のコミット履歴</a> のように書き換えられました。</p>
<figure id="rpsp_b" class="image">
<div class="content">
<img src="images/public-small-2.png" alt="`featureA` の作業を終えた後のコミット履歴"/>
</div>
<figcaption>Figure 18. <code class="literal">featureA</code> の作業を終えた後のコミット履歴</figcaption>
</figure>
<p>ブランチをリベースしたので、プッシュする際には <code class="literal">-f</code> を指定しなければなりません。これは、サーバー上の <code class="literal">featureA</code> ブランチをその直系の子孫以外のコミットで上書きするためです。
別のやり方として、今回の作業を別のブランチ (<code class="literal">featureAv2</code> など) にプッシュすることもできます。</p>
<p>もうひとつ別のシナリオを考えてみましょう。あなたの二番目のブランチを見たメンテナが、その考え方は気に入ったものの細かい実装をちょっと変更してほしいと連絡してきました。
この場合も、プロジェクトの <code class="literal">master</code> ブランチから作業を進めます。
現在の <code class="literal">origin/master</code> から新たにブランチを作成し、そこに <code class="literal">featureB</code> ブランチの変更を押し込み、もし衝突があればそれを解決し、実装をちょっと変更してからそれを新しいブランチとしてプッシュします。</p>
<p></p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureBv2 origin/master
<span style="font-weight: bold">$</span> git merge --no-commit --squash featureB
<span style="font-weight: bold">#</span> （実装をちょっと変更する）
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">$</span> git push myfork featureBv2</code></pre>
</figure>
<p><code class="literal">--squash</code> オプションは、マージしたいブランチでのすべての作業をひとつのコミットにまとめ、それを現在のブランチの先頭にマージします。
<code class="literal">--no-commit</code> オプションは、自動的にコミットを記録しないよう Git に指示しています。
こうすれば、別のブランチのすべての変更を取り込んでさらに手元で変更を加えたものを新しいコミットとして記録できるのです。</p>
<p>そして、メンテナに「言われたとおりのちょっとした変更をしたものが <code class="literal">featureBv2</code> ブランチにあるよ」と連絡します。</p>
<figure class="image">
<div class="content">
<img src="images/public-small-3.png" alt="`featureBv2` の作業を終えた後のコミット履歴"/>
</div>
<figcaption>Figure 19. <code class="literal">featureBv2</code> の作業を終えた後のコミット履歴</figcaption>
</figure>
</section>
<section class="sect2" title="メールを使った公開プロジェクトへの貢献">
<h3 id="r_project_over_email">メールを使った公開プロジェクトへの貢献</h3>
<p></p>
<p>多くのプロジェクトでは、パッチを受け付ける手続きが確立されています。プロジェクトによっていろいろ異なるので、まずはそのプロジェクト固有のルールがないかどうか確認しましょう。
また、長期間続いている大規模なプロジェクトには、開発者用メーリングリストでパッチを受け付けているものがいくつかあります。そこで、ここではそういったプロジェクトを例にとって話を進めます。</p>
<p>実際の作業の流れは先ほどとほぼ同じで、作業する内容ごとにトピックブランチを作成することになります。
違うのは、パッチをプロジェクトに提供する方法です。
プロジェクトをフォークし、自分用のリポジトリにプッシュするのではなく、個々のコミットについてメールを作成し、それを開発者用メーリングリストに投稿します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b topicA
<span style="font-weight: bold">#</span> （作業）
<span style="font-weight: bold">$</span> git commit
<span style="font-weight: bold">#</span> （作業）
<span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p></p>
<p>これで二つのコミットができあがりました。これらをメーリングリストに投稿します。
<code class="literal">git format-patch</code> を使うと mbox 形式のファイルが作成されるので、これをメーリングリストに送ることができます。このコマンドは、コミットメッセージの一行目を件名、残りのコミットメッセージとコミット内容のパッチを本文に書いたメールを作成します。
これのよいところは、<code class="literal">format-patch</code> で作成したメールからパッチを適用すると、すべてのコミット情報が適切に維持されるというところです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>
</figure>
<p><code class="literal">format-patch</code> コマンドは、できあがったパッチファイルの名前を出力します。
<code class="literal">-M</code> スイッチは、名前が変わったことを検出するためのものです。
できあがったファイルは次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = &#39;master&#39;)
--
2.1.0</code></pre>
</figure>
<p>このファイルを編集して、コミットメッセージには書けなかったような情報をメーリングリスト用に追加することもできます。
<code class="literal">---</code> の行とパッチの開始位置 ( <code class="literal">diff --git</code> の行) の間にメッセージを書くと、メールを受信した人はそれを読むことができますが、パッチからは除外されます。</p>
<p>これをメーリングリストに投稿するには、メールソフトにファイルの内容を貼り付けるか、あるいはコマンドラインのプログラムを使います。
ファイルの内容をコピーして貼り付けると「かしこい」メールソフトが勝手に改行の位置を変えてしまうなどの問題が起こりがちです。
ありがたいことに Git には、きちんとしたフォーマットのパッチを IMAP で送ることを支援するツールが用意されています。これを使うと便利です。
ここでは、パッチを Gmail で送る方法を説明しましょう。というのも、一番よく知っているメールソフトが Gmail だからです。さまざまなメールソフトでの詳細なメール送信方法が、Git ソースコードにある <code class="literal">Documentation/SubmittingPatches</code> の最後に載っています。</p>
<p></p>
<p>まず、<code class="literal">~/.gitconfig</code> ファイルの imap セクションを設定します。
それぞれの値を <code class="literal">git config</code> コマンドで順に設定してもかまいませんし、このファイルに手で書き加えてもかまいません。最終的に、設定ファイルは次のようになります。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[imap]</span>
  folder = <span style="font-style: italic">&quot;[Gmail]/Drafts&quot;</span>
<span style="font-style: italic">  host = imaps://imap.gmail.com</span>
<span style="font-style: italic">  user = user@gmail.com</span>
<span style="font-style: italic">  pass = p4ssw0rd</span>
<span style="font-style: italic">  port = 993</span>
<span style="font-style: italic">  sslverify = false</span></code></pre>
</figure>
<p>IMAP サーバーで SSL を使っていない場合は、最後の二行はおそらく不要でしょう。そして host のところが <code class="literal">imaps://</code> ではなく <code class="literal">imap://</code> となります。
ここまでの設定が終われば、<code class="literal">git send-email</code> を実行して IMAP サーバーの Drafts フォルダにパッチを置くことができるようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</code></pre>
</figure>
<p>そうすると、下書きがGmailのドラフトフォルダーに保存されているはずです。宛先をメーリングリストのアドレスに変更し、可能であればCCにプロジェクトのメンテナか該当部分の担当者を追加してから送信しましょう。</p>
<p>また、パッチをSMTPサーバー経由で送信することもできます。
設定方法についてはIMAPサーバーの場合と同様に、<code class="literal">git config`コマンドを使って設定項目を個別に入力してもいいですし、</code>~/.gitconfig`ファイルのsendemailセクションを直接編集してもかまいません。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[sendemail]</span>
  smtpencryption = <span style="font-style: italic">tls</span>
<span style="font-style: italic">  smtpserver = smtp.gmail.com</span>
<span style="font-style: italic">  smtpuser = user@gmail.com</span>
<span style="font-style: italic">  smtpserverport = 587</span></code></pre>
</figure>
<p>設定が終われば、`git send-email`コマンドを使ってパッチを送信できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>
</figure>
<p>Git はその後、各パッチについてこのようなログ情報をはき出すはずです。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line &#39;From: Jessica Smith &lt;jessica@example.com&gt;&#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>
</figure>
</section>
<section class="sect2" title="まとめ">
<h3 id="_まとめ">まとめ</h3>
<p>このセクションでは、今後みなさんが遭遇するであろうさまざまな形式の Git プロジェクトについて、関わっていくための作業手順を説明しました。そして、その際に使える新兵器もいくつか紹介しました。
次はもう一方の側、つまり Git プロジェクトを運営する側について見ていきましょう。
慈悲深い独裁者、あるいは統合マネージャーとしての作業手順を説明します。</p>
</section>
</section>
<section class="sect1" title="プロジェクトの運営">
<h2 id="_プロジェクトの運営">プロジェクトの運営</h2>
<p></p>
<p>プロジェクトに貢献する方法だけでなく、プロジェクトを運営する方法についても知っておくといいでしょう。
たとえば <code class="literal">format-patch</code> を使ってメールで送られてきたパッチを処理する方法や、別のリポジトリのリモートブランチでの変更を統合する方法などです。
本流のリポジトリを保守するにせよパッチの検証や適用を手伝うにせよ、どうすれば貢献者たちにとってわかりやすくなるかを知っておくべきでしょう。</p>
<section class="sect2" title="トピックブランチでの作業">
<h3 id="_トピックブランチでの作業">トピックブランチでの作業</h3>
<p></p>
<p>新しい機能を組み込もうと考えている場合は、トピックブランチを作ることをおすすめします。トピックブランチとは、新しく作業を始めるときに一時的に作るブランチのことです。
そうすれば、そのパッチだけを個別にいじることができ、もしうまくいかなかったとしてもすぐに元の状態に戻すことができます。
ブランチの名前は、今からやろうとしている作業の内容にあわせたシンプルな名前にしておきます。たとえば <code class="literal">ruby_client</code> などといったものです。そうすれば、しばらく時間をおいた後でそれを廃棄することになったときに、内容を思い出しやすくなります。
Git プロジェクトのメンテナは、ブランチ名に名前空間を使うことが多いようです。たとえば <code class="literal">sc/ruby_client</code> のようになり、ここでの <code class="literal">sc</code> はその作業をしてくれた人の名前を短縮したものとなります。
自分の master ブランチをもとにしたブランチを作成する方法は、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch sc/ruby_client master</code></pre>
</figure>
<p>作成してすぐそのブランチに切り替えたい場合は、<code class="literal">checkout -b</code> オプションを使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b sc/ruby_client master</code></pre>
</figure>
<p>受け取った作業はこのトピックブランチですすめ、長期ブランチに統合するかどうかを判断することになります。</p>
</section>
<section class="sect2" title="メールで受け取ったパッチの適用">
<h3 id="r_patches_from_email">メールで受け取ったパッチの適用</h3>
<p></p>
<p>あなたのプロジェクトへのパッチをメールで受け取った場合は、まずそれをトピックブランチに適用して中身を検証します。
メールで届いたパッチを適用するには <code class="literal">git apply</code> と <code class="literal">git am</code> の二通りの方法があります。</p>
<section class="sect3" title="apply によるパッチの適用">
<h4 id="_apply_によるパッチの適用">apply によるパッチの適用</h4>
<p></p>
<p><code class="literal">git diff</code> あるいは Unix の <code class="literal">diff</code> コマンドで作ったパッチ（パッチの作り方としては推奨できません。次節で理由を説明します）を受け取ったときは、<code class="literal">git apply</code> コマンドを使ってパッチを適用します。
パッチが <code class="literal">/tmp/patch-ruby-client.patch</code> にあるとすると、このようにすればパッチを適用できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply /tmp/patch-ruby-client.patch</code></pre>
</figure>
<p>これは、作業ディレクトリ内のファイルを変更します。
<code class="literal">patch -p1</code> コマンドでパッチをあてるのとほぼ同じなのですが、それ以上に「これでもか」というほどのこだわりを持ってパッチを適用するので fuzzy マッチになる可能性が少なくなります。
また、<code class="literal">git diff</code> 形式ではファイルの追加・削除やファイル名の変更も扱うことができますが、<code class="literal">patch</code> コマンドにはそれはできません。
そして最後に、<code class="literal">git apply</code> は「全部適用するか、あるいは一切適用しないか」というモデルを採用しています。一方 <code class="literal">patch</code> コマンドの場合は、途中までパッチがあたった中途半端な状態になって困ることがあります。
<code class="literal">git apply</code> のほうが、 <code class="literal">patch</code> よりも慎重に処理を行うのです。
<code class="literal">git apply</code> コマンドはコミットを作成するわけではありません。実行した後で、その変更をステージしてコミットする必要があります。</p>
<p>git apply を使って、そのパッチをきちんと適用できるかどうかを事前に確かめることができます。パッチをチェックするには <code class="literal">git apply --check</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</figure>
<p>何も出力されなければ、そのパッチはうまく適用できるということです。
このコマンドは、チェックに失敗した場合にゼロ以外の値を返して終了します。スクリプト内でチェックしたい場合などにはこの返り値を使用します。</p>
</section>
<section class="sect3" title="am でのパッチの適用">
<h4 id="r_git_am"><code class="literal">am</code> でのパッチの適用</h4>
<p></p>
<p>コードを提供してくれた人が Git のユーザーで、<code class="literal">format-patch</code> コマンドを使ってパッチを送ってくれたとしましょう。この場合、あなたの作業はより簡単になります。パッチの中に、作者の情報やコミットメッセージも含まれているからです。
「パッチを作るときには、できるだけ <code class="literal">diff</code> ではなく <code class="literal">format-patch</code> を使ってね」とお願いしてみるのもいいでしょう。
昔ながらの形式のパッチが届いたときだけは <code class="literal">git apply</code> を使わなければならなくなります。</p>
<p><code class="literal">format-patch</code> で作ったパッチを適用するには <code class="literal">git am</code> を使います。技術的なお話をすると、<code class="literal">git am</code> は mbox ファイルを読み込む仕組みになっています。mbox はシンプルなプレーンテキスト形式で、一通あるいは複数のメールのメッセージをひとつのテキストファイルにまとめるためのものです。中身はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</figure>
<p>先ほどのセクションでごらんいただいたように、format-patch コマンドの出力結果もこれと同じ形式で始まっていますね。
これは、mbox 形式のメールフォーマットとしても正しいものです。
git send-email を正しく使ったパッチが送られてきた場合、受け取ったメールを mbox 形式で保存して git am コマンドでそのファイルを指定すると、すべてのパッチの適用が始まります。
複数のメールをまとめてひとつの mbox に保存できるメールソフトを使っていれば、送られてきたパッチをひとつのファイルにまとめて git am で一度に適用することもできます。</p>
<p>しかし、<code class="literal">format-patch</code> で作ったパッチがチケットシステム (あるいはそれに類する何か) にアップロードされたような場合は、まずそのファイルをローカルに保存して、それを <code class="literal">git am</code> に渡すことになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am 0001-limit-log-function.patch
Applying: add limit to log function</code></pre>
</figure>
<p>どんなパッチを適用したのかが表示され、コミットも自動的に作られます。作者の情報はメールの <code class="literal">From</code> ヘッダと <code class="literal">Date</code> ヘッダから取得し、コミットメッセージは <code class="literal">Subject</code> とメールの本文 (パッチより前の部分) から取得します。たとえば、先ほどごらんいただいた mbox の例にあるパッチを適用した場合は次のようなコミットとなります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>
</figure>
<p><code class="literal">Commit</code> には、そのパッチを適用した人と適用した日時が表示されます。
<code class="literal">Author</code> には、そのパッチを実際に作成した人と作成した日時が表示されます。</p>
<p>しかし、パッチが常にうまく適用できるとは限りません。
パッチを作成したときの状態と現在のメインブランチとが大きくかけ離れてしまっていたり、そのパッチが別の (まだ適用していない) パッチに依存していたりなどといったことがあり得るでしょう。
そんな場合は <code class="literal">git am</code> は失敗し、次にどうするかを聞かれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &quot;git am --resolved&quot;.
If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.
To restore the original branch and stop patching run &quot;git am --abort&quot;.</code></pre>
</figure>
<p>このコマンドは、何か問題が発生したファイルについて衝突マークを書き込みます。これは、マージやリベースに失敗したときに書き込まれるのとよく似たものです。
問題を解決する方法も同じです。まずはファイルを編集して衝突を解決し、新しいファイルをステージし、<code class="literal">git am --resolved</code> を実行して次のパッチに進みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> （ファイルを編集する）
<span style="font-weight: bold">$</span> git add ticgit.gemspec
<span style="font-weight: bold">$</span> git am --resolved
Applying: seeing if this helps the gem</code></pre>
</figure>
<p>Git にもうちょっと賢く働いてもらって衝突を回避したい場合は、<code class="literal">-3</code> オプションを使用します。これは、Git で三方向のマージを行うオプションです。
このオプションはデフォルトでは有効になっていません。適用するパッチの元になっているコミットがあなたのリポジトリ上のものでない場合に正しく動作しないからです。
パッチの元になっているコミットが手元にある場合は、<code class="literal">-3</code> オプションを使うと、衝突しているパッチをうまく適用できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</figure>
<p>ここでは、既に適用済みのパッチを適用してみました。
<code class="literal">-3</code> オプションがなければ、衝突が発生していたことでしょう。</p>
<p>たくさんのパッチが含まれる mbox からパッチを適用するときには、<code class="literal">am</code> コマンドを対話モードで実行することもできます。パッチが見つかるたびに処理を止め、それを適用するかどうかの確認を求められます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</figure>
<p>これは、「大量にあるパッチについて、内容をまず一通り確認したい」「既に適用済みのパッチは適用しないようにしたい」などの場合に便利です。</p>
<p>トピックブランチ上でそのトピックに関するすべてのパッチの適用を済ませてコミットすれば、次はそれを長期ブランチに統合するかどうか (そしてどのように統合するか) を考えることになります。</p>
</section>
</section>
<section class="sect2" title="リモートブランチのチェックアウト">
<h3 id="r_checking_out_remotes">リモートブランチのチェックアウト</h3>
<p></p>
<p>自前のリポジトリを持つ Git ユーザーが自分のリポジトリに変更をプッシュし、そのリポジトリの URL とリモートブランチ名だけをあなたにメールで連絡してきた場合のことを考えてみましょう。そのリポジトリをリモートとして登録し、それをローカルにマージすることになります。</p>
<p>Jessica から「すばらしい新機能を作ったので、私のリポジトリの <code class="literal">ruby-client</code> ブランチを見てください」といったメールが来たとします。これを手元でテストするには、リモートとしてこのリポジトリを追加し、ローカルにブランチをチェックアウトします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add jessica git://github.com/jessica/myproject.git
<span style="font-weight: bold">$</span> git fetch jessica
<span style="font-weight: bold">$</span> git checkout -b rubyclient jessica/ruby-client</code></pre>
</figure>
<p>「この前のとは違う、別のすばらしい機能を作ったの!」と別のブランチを伝えられた場合は、すでにリモートの設定が済んでいるので単にそのブランチを取得してチェックアウトするだけで確認できます。</p>
<p>この方法は、誰かと継続的に共同作業を進めていく際に便利です。
ちょっとしたパッチをたまに提供してくれるだけの人の場合は、パッチをメールで受け取るようにしたほうが時間の節約になるでしょう。全員に自前のサーバーを用意させて、たまに送られてくるパッチを取得するためだけに定期的にリモートの追加と削除を行うなどというのは時間の無駄です。
ほんの数件のパッチを提供してくれる人たちを含めて数百ものリモートを管理することなど、きっとあなたはお望みではないでしょう。
しかし、スクリプトやホスティングサービスを使えばこの手の作業は楽になります。つまり、どのような方式をとるかは、あなたや他のメンバーがどのような方式で開発を進めるかによって決まります。</p>
<p>この方式のもうひとつの利点は、コミットの履歴も同時に取得できるということです。
マージの際に問題が起こることもあるでしょうが、そんな場合にも相手の作業が自分側のどの地点に基づくものなのかを知ることができます。適切に三方向のマージが行われるので、<code class="literal">-3</code> を指定したときに「このパッチの基点となるコミットにアクセスできればいいなぁ」と祈る必要はありません。</p>
<p>継続的に共同作業を続けるわけではないけれど、それでもこの方式でパッチを取得したいという場合は、リモートリポジトリの URL を <code class="literal">git pull</code> コマンドで指定することもできます。
これは一度きりのプルに使うものであり、リモートを参照する URL は保存されません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>
</figure>
</section>
<section class="sect2" title="何が変わるのかの把握">
<h3 id="r_what_is_introduced">何が変わるのかの把握</h3>
<p></p>
<p>トピックブランチの中に、提供してもらった作業が含まれた状態になりました。
次に何をすればいいのか考えてみましょう。
このセクションでは、これまでに扱ったいくつかのコマンドを復習します。それらを使って、もしこの変更をメインブランチにマージしたらいったい何が起こるのかを調べていきましょう。</p>
<p>トピックブランチのコミットのうち、master ブランチに存在しないコミットの内容をひとつひとつレビューできれば便利でしょう。
master ブランチに含まれるコミットを除外するには、ブランチ名の前に <code class="literal">--not</code> オプションを指定します。
これは、これまで使ってきた <code class="literal">master..contrib</code> という書式と同じ役割を果たしてくれます。
たとえば、誰かから受け取った二つのパッチを適用するために <code class="literal">contrib</code> というブランチを作成したとすると、</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</figure>
<p>このようなコマンドを実行すればそれぞれのコミットの内容を確認できます。<code class="literal">git log</code> に <code class="literal">-p</code> オプションを渡せば、コミットの後に diff を表示させることもできます。これも以前に説明しましたね。</p>
<p>このトピックブランチを別のブランチにマージしたときに何が起こるのかを完全な diff で知りたい場合は、ちょっとした裏技を使わないと正しい結果が得られません。
おそらく「こんなコマンドを実行するだけじゃないの?」と考えておられることでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff master</code></pre>
</figure>
<p>このコマンドで表示される diff は、誤解を招きかねないものです。
トピックブランチを切った時点からさらに <code class="literal">master</code> ブランチが先に進んでいたとすると、これは少し奇妙に見える結果を返します。
というのも、Git は現在のトピックブランチの最新のコミットのスナップショットと <code class="literal">master</code> ブランチの最新のコミットのスナップショットを直接比較するからです。
トピックブランチを切った後に <code class="literal">master</code> ブランチ上であるファイルに行を追加したとすると、スナップショットを比較した結果は「トピックブランチでその行を削除しようとしている」状態になります。</p>
<p><code class="literal">master</code> がトピックブランチの直系の先祖である場合は、これは特に問題とはなりません。しかし二つの歴史が分岐している場合には、diff の結果は「トピックブランチで新しく追加したすべての内容を追加し、<code class="literal">master</code> ブランチにしかないものはすべて削除する」というものになります。</p>
<p>本当に知りたいのはトピックブランチで変更された内容、つまりこのブランチを master にマージしたときに master に加わる変更です。
これを知るには、Git に「トピックブランチの最新のコミット」と「トピックブランチと master ブランチの直近の共通の先祖」とを比較させます。</p>
<p>共通の先祖を見つけだしてそこからの diff を取得するには、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
<span style="font-weight: bold">$</span> git diff 36c7db</code></pre>
</figure>
<p>しかし、これでは不便です。そこで Git には、同じことをより手短にやるための手段としてトリプルドット構文が用意されています。
<code class="literal">diff</code> コマンドを実行するときにピリオドを三つ打った後に別のブランチを指定すると、「現在いるブランチの最新のコミット」と「指定した二つのブランチの共通の先祖」とを比較するようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff master...contrib</code></pre>
</figure>
<p>このコマンドは、master との共通の先祖から分岐した現在のトピックブランチで変更された内容のみを表示します。
この構文は、覚えやすいので非常に便利です。</p>
</section>
<section class="sect2" title="提供された作業の取り込み">
<h3 id="_提供された作業の取り込み">提供された作業の取り込み</h3>
<p></p>
<p>トピックブランチでの作業をメインブランチに取り込む準備ができたら、どのように取り込むかを考えることになります。
さらに、プロジェクトを運営していくにあたっての全体的な作業の流れはどのようにしたらいいでしょうか?
さまざまな方法がありますが、ここではそのうちのいくつかを紹介します。</p>
<section class="sect3" title="マージのワークフロー">
<h4 id="_マージのワークフロー">マージのワークフロー</h4>
<p></p>
<p>シンプルなワークフローのひとつとして、作業を自分の <code class="literal">master</code> ブランチに取り込むことを考えます。
ここでは、<code class="literal">master</code> ブランチで安定版のコードを管理しているものとします。
トピックブランチでの作業が一段落したら (あるいは誰かから受け取ったパッチをトピックブランチ上で検証し終えたら)、それを master ブランチにマージしてからトピックブランチを削除し、作業を進めることになります。
<code class="literal">ruby_client</code> および <code class="literal">php_client</code> の二つのブランチを持つ <a id="xref-rmerwf_a" href="#rmerwf_a" class="xref">いくつかのトピックブランチを含む履歴</a> のようなリポジトリでまず <code class="literal">ruby_client</code> をマージしてから <code class="literal">php_client</code> もマージすると、歴史は <a id="xref-rmerwf_b" href="#rmerwf_b" class="xref">トピックブランチをマージした後の状態</a> のようになります。</p>
<figure id="rmerwf_a" class="image">
<div class="content">
<img src="images/merging-workflows-1.png" alt="いくつかのトピックブランチを含む履歴"/>
</div>
<figcaption>Figure 20. いくつかのトピックブランチを含む履歴</figcaption>
</figure>
<figure id="rmerwf_b" class="image">
<div class="content">
<img src="images/merging-workflows-2.png" alt="トピックブランチをマージした後の状態"/>
</div>
<figcaption>Figure 21. トピックブランチをマージした後の状態</figcaption>
</figure>
<p>これがおそらく一番シンプルなワークフローでしょう。ただし、それが問題になることもあります。大規模プロジェクトや安定しているプロジェクトのように、何を受け入れるかを慎重に決めなければいけない場合です。</p>
<p>より重要なプロジェクトの場合は、二段階のマージサイクルを使うこともあるでしょう。
ここでは、長期間運用するブランチが <code class="literal">master</code> と <code class="literal">develop</code> のふたつあるものとします。<code class="literal">master</code> が更新されるのは安定版がリリースされるときだけで、新しいコードはずべて <code class="literal">develop</code> ブランチに統合されるという流れです。
これらのブランチは、両方とも定期的に公開リポジトリにプッシュすることになります。
新しいトピックブランチをマージする準備ができたら (<a id="xref-rmerwf_c" href="#rmerwf_c" class="xref">トピックブランチのマージ前</a>)、それを <code class="literal">develop</code> にマージします (<a id="xref-rmerwf_d" href="#rmerwf_d" class="xref">トピックブランチのマージ後</a>)。そしてリリースタグを打つときに、<code class="literal">master</code> を現在の <code class="literal">develop</code> ブランチが指す位置に進めます (<a id="xref-rmerwf_e" href="#rmerwf_e" class="xref">プロジェクトのリリース後</a>)。</p>
<figure id="rmerwf_c" class="image">
<div class="content">
<img src="images/merging-workflows-3.png" alt="トピックブランチのマージ前"/>
</div>
<figcaption>Figure 22. トピックブランチのマージ前</figcaption>
</figure>
<figure id="rmerwf_d" class="image">
<div class="content">
<img src="images/merging-workflows-4.png" alt="トピックブランチのマージ後"/>
</div>
<figcaption>Figure 23. トピックブランチのマージ後</figcaption>
</figure>
<figure id="rmerwf_e" class="image">
<div class="content">
<img src="images/merging-workflows-5.png" alt="トピックブランチのリリース後"/>
</div>
<figcaption>Figure 24. プロジェクトのリリース後</figcaption>
</figure>
<p>他の人があなたのプロジェクトをクローンするときには、master をチェックアウトすれば最新の安定版をビルドすることができ、その後の更新を追いかけるのも容易にできるようになります。一方 develop をチェックアウトすれば、さらに最先端の状態を取得することができます。
この考え方を推し進めると、統合用のブランチを用意してすべての作業をいったんそこにマージするようにもできます。
統合ブランチ上のコードが安定してテストを通過すれば、それを develop ブランチにマージします。そしてそれが安定していることが確認できたら master ブランチを先に進めるということになります。</p>
</section>
<section class="sect3" title="大規模マージのワークフロー">
<h4 id="_大規模マージのワークフロー">大規模マージのワークフロー</h4>
<p></p>
<p>Git 開発プロジェクトには、常時稼働するブランチが四つあります。<code class="literal">master</code>、<code class="literal">next</code>、そして新しい作業用の <code class="literal">pu</code> (proposed updates) とメンテナンスバックポート用の <code class="literal">maint</code> です。
新しいコードを受け取ったメンテナは、まず自分のリポジトリのトピックブランチにそれを格納します。先ほど説明したのと同じ方式です ( <a id="xref-rmerwf_f" href="#rmerwf_f" class="xref">複数のトピックブランチの並行管理</a> を参照ください)。
そしてその内容を検証し、安全に取り込める状態かさらなる作業が必要かを見極めます。
だいじょうぶだと判断したらそれを <code class="literal">next</code> にマージします。このブランチをプッシュすれば、すべてのメンバーがそれを試せるようになります。</p>
<figure id="rmerwf_f" class="image">
<div class="content">
<img src="images/large-merges-1.png" alt="複数のトピックブランチの並行管理"/>
</div>
<figcaption>Figure 25. 複数のトピックブランチの並行管理</figcaption>
</figure>
<p>さらに作業が必要なトピックについては、<code class="literal">pu</code> にマージします。
完全に安定していると判断されたトピックについては改めて <code class="literal">master</code> にマージされ、<code class="literal">next</code> にあるトピックのうちまだ <code class="literal">master</code> に入っていないものを再構築します。
つまり、<code class="literal">master</code> はほぼ常に前に進み、<code class="literal">next</code> は時々リベースされ、<code class="literal">pu</code> はそれ以上の頻度でリベースされることになります。</p>
<figure class="image">
<div class="content">
<img src="images/large-merges-2.png" alt="常時稼働する統合用ブランチへのトピックブランチのマージ"/>
</div>
<figcaption>Figure 26. 常時稼働する統合用ブランチへのトピックブランチのマージ</figcaption>
</figure>
<p>最終的に <code class="literal">master</code> にマージされたトピックブランチは、リポジトリから削除します。
Git 開発プロジェクトでは <code class="literal">maint</code> ブランチも管理しています。これは最新のリリースからフォークしたもので、メンテナンスリリースに必要なバックポート用のパッチを管理します。
つまり、Git のリポジトリをクローンするとあなたは四つのブランチをチェックアウトすることができるということです。これらのブランチはどれも異なる開発段階を表し、「どこまで最先端を追いかけたいか」「どのように Git プロジェクトに貢献したいか」によって使い分けることになります。メンテナ側では、新たな貢献を受け入れるためのワークフローが整っています。</p>
</section>
<section class="sect3" title="リベースとチェリーピックのワークフロー">
<h4 id="r_rebase_cherry_pick">リベースとチェリーピックのワークフロー</h4>
<p></p>
<p>受け取った作業を master ブランチにマージするのではなく、リベースやチェリーピックを使って master ブランチの先端につなげていく方法を好むメンテナもいます。そのほうがほぼ直線的な歴史を保てるからです。
トピックブランチでの作業を終えて統合できる状態になったと判断したら、そのブランチで rebase コマンドを実行し、その変更を現在の master (あるいは <code class="literal">develop</code> などの) ブランチの先端につなげます。
うまくいけば、<code class="literal">master</code> ブランチをそのまま前に進めてることでプロジェクトの歴史を直線的に進めることができます。</p>
<p></p>
<p>あるブランチの作業を別のブランチに移すための手段として、他にチェリーピック (つまみぐい) という方法があります。
Git におけるチェリーピックとは、コミット単位でのリベースのようなものです。
あるコミットによって変更された内容をパッチとして受け取り、それを現在のブランチに再適用します。
トピックブランチでいくつかコミットしたうちのひとつだけを統合したい場合、あるいはトピックブランチで一回だけコミットしたけれどそれをリベースではなくチェリーピックで取り込みたい場合などにこの方法を使用します。
以下のようなプロジェクトを例にとって考えましょう。</p>
<figure class="image">
<div class="content">
<img src="images/rebasing-1.png" alt="チェリーピック前の歴史"/>
</div>
<figcaption>Figure 27. チェリーピック前の歴史</figcaption>
</figure>
<p>コミット <code class="literal">e43a6</code> を master ブランチに取り込むには、次のようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</figure>
<p>これは <code class="literal">e43a6</code> と同じ内容の変更を施しますが、コミットの SHA-1 値は新しくなります。適用した日時が異なるからです。
これで、歴史は次のように変わりました。</p>
<figure class="image">
<div class="content">
<img src="images/rebasing-2.png" alt="トピックブランチのコミットをチェリーピックした後の歴史"/>
</div>
<figcaption>Figure 28. トピックブランチのコミットをチェリーピックした後の歴史</figcaption>
</figure>
<p>あとは、このトピックブランチを削除すれば取り込みたくない変更を消してしまうことができます。</p>
</section>
<section class="sect3" title="Rerere">
<h4 id="_rerere">Rerere</h4>
<p></p>
<p>マージやリベースを頻繁に行っているなら、もしくは長く続いているトピックブランチをメンテナンスしているなら、Git の “rerere” という機能が役に立つでしょう。</p>
<p>Rerere は “reuse recorded resolution” の略で、コンフリクトを手っ取り早く手動で解消するための方法です。</p>
<p>この機能で用いるのは、設定とコマンドの2つです。
まず設定のほうは <code class="literal">rerere.enabled</code> という項目を用います。Git のグローバル設定に登録しておくとよいでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global rerere.enabled true</code></pre>
</figure>
<p>一度この設定をしておくと、コンフリクトを手動で解消してマージするたびにその内容がキャッシュに記録され、のちのち使えるようになります。</p>
<p>必要に応じてキャッシュを操作することもできます。<code class="literal">git rerere</code> コマンドを使うのです。
このコマンドをオプションなしで実行するとキャッシュが検索され、コンフリクトの内容に合致するものがある場合はそれを用いてコンフリクトの解消が試みられます（ただし、<code class="literal">rerere.enabled</code> が <code class="literal">true</code> に設定されている場合、一連の処理は自動で行われます）。
また、サブコマンドも複数用意されています。それらを使うと、キャッシュされようとしている内容の確認、キャッシュされた内容を指定して削除、キャッシュをすべて削除、などができるようになります。rerere については <a id="xref--ch07-git-tools--r_rerere" href="ch07-git-tools.xhtml#r_rerere" class="xref">Rerere</a> で詳しく説明します。</p>
</section>
</section>
<section class="sect2" title="リリース用のタグ付け">
<h3 id="r_tagging_releases">リリース用のタグ付け</h3>
<p></p>
<p>いよいよリリースする時がきました。おそらく、後からいつでもこのリリースを取得できるようにタグを打っておくことになるでしょう。
新しいタグを打つ方法は <a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git の基本</a> で説明しました。
タグにメンテナの署名を入れておきたい場合は、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -s v1.5 -m <span style="font-style: italic">&#39;my signed 1.5 tag&#39;</span>
You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>
</figure>
<p>タグに署名した場合、署名に使用した PGP 鍵ペアの公開鍵をどのようにして配布するかが問題になるかもしれません。
Git 開発プロジェクトのメンテナ達がこの問題をどのように解決したかというと、自分たちの公開鍵を blob としてリポジトリに含め、それを直接指すタグを追加することにしました。
この方法を使うには、まずどの鍵を使うかを決めるために <code class="literal">gpg --list-keys</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</figure>
<p>鍵を直接 Git データベースにインポートするには、鍵をエクスポートしてそれをパイプで <code class="literal">git hash-object</code> に渡します。これは、鍵の中身を新しい blob として Git に書き込み、その blob の SHA-1 を返します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</figure>
<p>鍵の中身を Git に取り込めたので、この鍵を直接指定するタグを作成できるようになりました。<code class="literal">hash-object</code> コマンドで知った SHA-1 値を指定すればいいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</figure>
<p><code class="literal">git push --tags</code> を実行すると、<code class="literal">maintainer-pgp-pub</code> タグをみんなと共有できるようになります。誰かがタグを検証したい場合は、あなたの PGP 鍵が入った blob をデータベースから直接プルで取得し、それを PGP にインポートすればいいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show maintainer-pgp-pub | gpg --import</code></pre>
</figure>
<p>この鍵をインポートした人は、あなたが署名したすべてのタグを検証できるようになります。タグのメッセージに検証手順の説明を含めておけば、<code class="literal">git show &lt;tag&gt;</code> でエンドユーザー向けに詳しい検証手順を示すことができます。</p>
</section>
<section class="sect2" title="ビルド番号の生成">
<h3 id="r_build_number">ビルド番号の生成</h3>
<p></p>
<p>Git では、コミットごとに <em>v123</em> のような単調な番号を振っていくことはありません。もし特定のコミットに対して人間がわかりやすい名前がほしければ、そのコミットに対して <code class="literal">git describe</code> を実行します。
Git は、そのコミットに最も近いタグの名前とそのタグからのコミット数、そしてそのコミットの SHA-1 値の一部を使った名前を作成します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</figure>
<p>これで、スナップショットやビルドを公開するときにわかりやすい名前をつけられるようになります。
実際、Git そのもののソースコードを Git リポジトリからクローンしてビルドすると、<code class="literal">git --version</code> が返す結果はこの形式になります。
タグが打たれているコミットを直接指定した場合は、タグの名前が返されます。</p>
<p><code class="literal">git describe</code> コマンドは注釈付きのタグ (<code class="literal">-a</code> あるいは <code class="literal">-s</code> フラグをつけて作成したタグ) を使います。したがって、<code class="literal">git describe</code> を使うならリリースタグは注釈付きのタグとしなければなりません。そうすれば、describe したときにコミットの名前を適切につけることができます。
この文字列を checkout コマンドや show コマンドでの対象の指定に使うこともできますが、これは末尾にある SHA-1 値の省略形に依存しているので将来にわたってずっと使えるとは限りません。
たとえば Linux カーネルは、最近 SHA-1 オブジェクトの一意性を確認するための文字数を 8 文字から 10 文字に変更しました。そのため、古い <code class="literal">git describe</code> の出力での名前はもはや使えません。</p>
</section>
<section class="sect2" title="リリースの準備">
<h3 id="r_preparing_release">リリースの準備</h3>
<p></p>
<p>実際にリリースするにあたって行うであろうことのひとつに、最新のスナップショットのアーカイブを作るという作業があります。
Git を使っていないというかわいそうな人たちにもコードを提供するために。
その際に使用するコマンドは <code class="literal">git archive</code> です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git archive master --prefix=<span style="font-style: italic">&#39;project/&#39;</span> | gzip &gt; <span style="font-style: italic">`</span>git describe master<span style="font-style: italic">`</span>.tar.gz
<span style="font-weight: bold">$</span> ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</figure>
<p>tarball を開けば、プロジェクトのディレクトリの下に最新のスナップショットが得られます。まったく同じ方法で zip アーカイブを作成することもできます。
この場合は <code class="literal">git archive</code> で <code class="literal">--format=zip</code> オプションを指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git archive master --prefix=<span style="font-style: italic">&#39;project/&#39;</span> --format=zip &gt; <span style="font-style: italic">`</span>git describe master<span style="font-style: italic">`</span>.zip</code></pre>
</figure>
<p>これで、あなたのプロジェクトのリリース用にすてきな tarball と zip アーカイブができあがりました。これをウェブサイトにアップロードするなりメールで送ってあげるなりしましょう。</p>
</section>
<section class="sect2" title="短いログ">
<h3 id="r_the_shortlog">短いログ</h3>
<p></p>
<p>そろそろメーリングリストにメールを送り、プロジェクトに何が起こったのかをみんなに知らせてあげましょう。
前回のリリースから何が変わったのかの変更履歴を手軽に取得するには <code class="literal">git shortlog</code> コマンドを使います。
これは、指定した範囲のすべてのコミットのまとめを出力します。たとえば、直近のリリースの名前が v1.0.1 だった場合は、次のようにすると前回のリリース以降のすべてのコミットの概要が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</figure>
<p>v1.0.1 以降のすべてのコミットの概要が、作者別にまとめて得られました。これをメーリングリストに投稿するといいでしょう。</p>
</section>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ_2">まとめ</h2>
<p>Git を使っているプロジェクトにコードを提供したり、自分のプロジェクトに他のユーザーからのコードを取り込んだりといった作業を安心してこなせるようになりましたね。
おめでとうございます。Git を使いこなせる開発者の仲間入りです!
次の章では、世界最大で一番人気の Git ホスティングサービス、GitHub の使い方を見ていきましょう。</p>
</section>
</section>
</body>
</html>