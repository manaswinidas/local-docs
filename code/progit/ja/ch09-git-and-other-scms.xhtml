<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Gitとその他のシステムの連携</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Gitとその他のシステムの連携" epub:type="chapter" id="ch09-git-and-other-scms">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Gitとその他のシステムの連携</b></small></h1>
</div>
</header>
<p>世の中はそんなにうまくいくものではありません。
あなたが関わることになったプロジェクトで使うバージョン管理システムを、すぐさまGitに切り替えられることはほとんどないでしょう。
また、関わっているプロジェクトが他のVCSを使っていて、もしこれがGitだったらなぁと思うことも時々あると思います。
この章の前半では、作業中のプロジェクトが他のバージョン管理システムを使っていた場合に、Git をクライアントとして使用する方法を学びます。</p>
<p>どこかの時点で、既存のプロジェクトを Git へ変換したくなることもあるでしょう。
この章の後半では、いくつかの特定のシステムから Git へ、プロジェクトを移行する方法と、既存のインポート用ツールがない場合に使える手法について説明します。</p>
<section class="sect1" title="Git をクライアントとして使用する">
<h2 id="_git_をクライアントとして使用する">Git をクライアントとして使用する</h2>
<p></p>
<p>Git は開発者に対し、非常に優れたユーザ体験を提供してくれます。このユーザ体験は、多くの人々がこれまでに編み出した、自分の端末上で Git を使用する方法に基づいています。それは、同じチームの他のメンバーがまったく別の VCS を使用している場合でも同様です。
そのような場合には “ブリッジ” と呼ばれるアダプタが利用できます。
ここでは、その中でも遭遇する機会が多いであろうものを取り上げます。</p>
<section class="sect2" title="Git と Subversion">
<h3 id="r_git_svn">Git と Subversion</h3>
<p></p>
<p>オープンソース開発プロジェクトの大多数や、かなりの数の企業内プロジェクトが、ソースコードの管理に Subversion を利用しています。
Subversion は10年以上前から使われてきましたが、その間ほとんどの期間、オープンソースプロジェクトのVCSとしては <em>デファクトスタンダード</em> の地位にありました。
Subversion 以前は CVS がソースコード管理に広く用いられていたのですが、多くの点で両者はよく似ています。</p>
<p></p>
<p>Git の素晴しい機能のひとつに、Git と Subversion を双方向にブリッジする <code class="literal">git svn</code> があります。このツールを使うと、Subversion のクライアントとして Git を使うことができます。つまり、ローカルの作業では Git の機能を十分に活用することができて、あたかも Subversion を使っているかのように Subversion サーバーに変更をコミットすることができます。共同作業をしている人達が古き良き方法を使っているのと
同時に、ローカルでのブランチ作成やマージ、ステージング・エリア、リベース、チェリーピックなどの Git の機能を使うことができるということです。共同の作業環境に Git を忍び込ませておいて、仲間の開発者たちが Git より効率良く作業できるように手助けをしつつ、Git の全面的な採用のための根回しをしてゆく、というのが賢いやり方です。Subversion ブリッジは、分散VCS の素晴しい世界へのゲートウェイ・ドラッグといえるでしょう。</p>
<section class="sect3" title="git svn">
<h4 id="_code_class_literal_git_svn_code"><code class="literal">git svn</code></h4>
<p>Git と Subversion の橋渡しをするコマンド群のベースとなるコマンドが <code class="literal">git svn</code> です。
この後に続くコマンドはかなりたくさんあるので、シンプルなワークフローを通してもっともよく使われるものから見ていきます。</p>
<p>注意すべきことは、<code class="literal">git svn</code> を使っているときは Subversion を相手にしているのだということです。これは、Git とはまったく異なる動きをします。
ローカルでのブランチ作成やマージは <strong>できることはできます</strong> が、作業内容をリベースするなどして歴史をできるだけ一直線に保つようにし、Git リモートリポジトリを相手にするときのように考えるのは避けましょう。</p>
<p>歴史を書き換えてもう一度プッシュしようなどとしてはいけません。また、他の開発者との共同作業のために複数の Git リポジトリに並行してプッシュするのもいけません。Subversion が扱えるのは一本の直線上の歴史だけで、ちょっとしたことですぐに混乱してしまいます。チームのメンバーの中に SVN を使う人と Git を使う人がいる場合は、全員が SVN サーバーを使って共同作業するようにしましょう。そうすれば、少しは生きやすくなります。</p>
</section>
<section class="sect3" title="セットアップ">
<h4 id="_セットアップ">セットアップ</h4>
<p>この機能を説明するには、書き込みアクセス権を持つ標準的な SVN リポジトリが必要です。
もしこのサンプルをコピーして試したいのなら、私のテスト用リポジトリの書き込み可能なコピーを作らなければなりません。
これを簡単に行うには、Subversion に付属の <code class="literal">svnsync</code> というツールを使います。
テスト用として、新しい Subversion リポジトリを Google Code 上に作りました。これは <code class="literal">protobuf</code> プロジェクトの一部で、<code class="literal">protobuf</code> は構造化されたデータを符号化してネットワーク上で転送するためのツールです。</p>
<p>まずはじめに、新しいローカル Subversion リポジトリを作ります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mkdir /tmp/test-svn
<span style="font-weight: bold">$</span> svnadmin create /tmp/test-svn</code></pre>
</figure>
<p>そして、すべてのユーザーが revprop を変更できるようにします。簡単な方法は、常に 0 で終了する <code class="literal">pre-revprop-change</code> スクリプトを追加することです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat /tmp/test-svn/hooks/pre-revprop-change
<span style="font-weight: bold">#</span>!/bin/sh
exit 0;
<span style="font-weight: bold">$</span> chmod +x /tmp/test-svn/hooks/pre-revprop-change</code></pre>
</figure>
<p>これで、ローカルマシンにこのプロジェクトを同期できるようになりました。同期元と同期先のリポジトリを指定して <code class="literal">svnsync init</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svnsync init file:///tmp/test-svn <span style="font-weight: bold; font-style: italic">\</span>
  http://progit-example.googlecode.com/svn/</code></pre>
</figure>
<p>このコマンドは、同期を実行するためのプロパティを設定します。次に、このコマンドでコードをコピーします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]</code></pre>
</figure>
<p>この操作は数分で終わりますが、もし元のリポジトリのコピー先がローカルではなく別のリモートリポジトリだった場合、総コミット数がたかだか 100 にも満たなかったとしても、この処理には約一時間かかります。
Subversion では、リビジョンごとにクローンを作ってコピー先のリポジトリに投入していかなければなりません。これはばかばかしいほど非効率的ですが、簡単に済ませるにはこの方法しかないのです。</p>
</section>
<section class="sect3" title="使いはじめる">
<h4 id="_使いはじめる">使いはじめる</h4>
<p>書き込み可能な Subversion リポジトリが手に入ったので、一般的なワークフローに沿って進めましょう。まずは <code class="literal">git svn clone</code> コマンドを実行します。このコマンドは、Subversion リポジトリ全体をローカルの Git リポジトリにインポートします。どこかにホストされている実際の Subversion リポジトリから取り込む場合は <code class="literal">file:///tmp/test-svn</code> の部分を Subversion リポジトリの URL に変更しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75</code></pre>
</figure>
<p>これは、指定した URL に対して <code class="literal">git svn init</code> に続けて <code class="literal">git svn fetch</code> を実行するのと同じ意味です。
しばらく時間がかかります。
test プロジェクトには 75 のコミットしかなくてコードベースもそれほど大きくありませんが、Git は各バージョンをそれぞれチェックアウトしては個別にコミットしています。
もし数百数千のコミットがあるプロジェクトで試すと、終わるまでには数時間から下手をすると数日かかってしまうかもしれません。</p>
<p><code class="literal">-T trunk -b branches -t tags</code> の部分は、この Subversion リポジトリが標準的なブランチとタグの規約に従っていることを表しています。trunk、branches、tags にもし別の名前をつけているのなら、この部分を変更します。この規約は一般に使われているものなので、単に <code class="literal">-s</code> とだけ指定することもできます。これは、先の 3 つのオプションを指定したのと同じ標準のレイアウトを表します。つまり、次のようにしても同じ意味になるということです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn clone file:///tmp/test-svn -s</code></pre>
</figure>
<p>これで、ブランチやタグも取り込んだ Git リポジトリができあがりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk</code></pre>
</figure>
<p>このツールが Subversion のタグをリモート参照としてどのように管理しているかに注目してください。</p>
<p></p>
<p>Git の配管コマンド <code class="literal">show-ref</code> について、もう少し詳しく見ていきましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre>
</figure>
<p>Git が Git サーバからクローンを行う場合はこうはなりません。タグつきのリポジトリに対してクローンを行った直後は、このようになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre>
</figure>
<p>Git は tags ディレクトリの内容をリモートブランチとして扱うのではなく、直接 <code class="literal">refs/tags</code> に格納しています。</p>
</section>
<section class="sect3" title="Subversion へのコミットの書き戻し">
<h4 id="_subversion_へのコミットの書き戻し">Subversion へのコミットの書き戻し</h4>
<p>作業リポジトリを手に入れたあなたはプロジェクト上で何らかの作業を終え、コミットを上流に書き戻すことになりました。Git を SVN クライアントとして使います。どれかひとつのファイルを変更してコミットした時点では、Git上でローカルに存在するそのコミットはSubversionサーバー上には存在しません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;Adding git-svn instructions to the README&#39;</span>
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)</code></pre>
</figure>
<p>次に、これをプッシュして上流を変更しなければなりません。この変更が Subversion に対してどのように作用するのかに注意しましょう。オフラインで行った複数のコミットを、すべて一度に Subversion サーバーにプッシュすることができます。Subversion サーバーにプッシュするには <code class="literal">git svn dcommit</code> コマンドを使います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>このコマンドは、Subversionサーバーからのコード上で行われたすべてのコミットに対して個別に Subversion 上にコミットし、ローカルの Git のコミットを書き換えて一意な識別子を含むようにします。ここで重要なのは、書き換えによってすべてのローカルコミットの SHA-1 チェックサムが変化するということです。この理由もあって、Git ベースのリモートリポジトリにあるプロジェクトと Subversion サーバーを同時に使うことはおすすめできません。直近のコミットを調べれば、新たに <code class="literal">git-svn-id</code> が追記されたことがわかります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre>
</figure>
<p>元のコミットの SHA-1 チェックサムが <code class="literal">4af61fd</code> で始まっていたのに対して今は <code class="literal">95e0222</code> に変わっていることに注目しましょう。Git と Subversion の両方のサーバーにプッシュしたい場合は、まず Subversion サーバーにプッシュ (<code class="literal">dcommit</code>) してから Git のほうにプッシュしなければなりません。dcommit でコミットデータが書き換わるからです。</p>
</section>
<section class="sect3" title="新しい変更の取り込み">
<h4 id="_新しい変更の取り込み">新しい変更の取り込み</h4>
<p>複数の開発者と作業をしていると、遅かれ早かれ、誰かがプッシュしたあとに他の人がプッシュしようとして衝突を起こすということが発生します。他の人の作業をマージするまで、その変更は却下されます。<code class="literal">git svn</code> では、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File &#39;/trunk/README.txt&#39; is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</figure>
<p>この状態を解決するには <code class="literal">git svn rebase</code> を実行します。これは、サーバー上の変更のうちまだ取り込んでいない変更をすべて取り込んでから、自分の作業をリベースします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File &#39;/trunk/README.txt&#39; is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</figure>
<p>これで手元の作業が Subversion サーバー上の最新状態の上でなされたことになったので、無事に <code class="literal">dcommit</code> することができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>ここで注意すべき点は、Git の場合は上流での変更をすべてマージしてからでなければプッシュできないけれど、<code class="literal">git svn</code> の場合は衝突さえしなければマージしなくてもプッシュできる（Subversion の挙動と同じように）ということです。
だれかがあるファイルを変更した後で自分が別のファイルを変更してプッシュしても、<code class="literal">dcommit</code> は正しく動作します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...</code></pre>
</figure>
<p>これは忘れずに覚えておきましょう。というのも、プッシュした後の結果はどの開発者の作業環境にも存在しない状態になっているからです。たまたま衝突しなかっただけで互換性のない変更をプッシュしてしまったときに、その問題を見つけるのが難しくなります。これが、Git サーバーを使う場合と異なる点です。Git の場合はクライアントの状態をチェックしてからでないと変更を公開できませんが、SVN の場合はコミットの直前とコミット後の状態が同等であるかどうかすら確かめられないのです。</p>
<p>もし自分のコミット準備がまだできていなくても、Subversion から変更を取り込むときにもこのコマンドを使わなければなりません。<code class="literal">git svn fetch</code> でも新しいデータを取得することはできますが、<code class="literal">git svn rebase</code> はデータを取得するだけでなくローカルのコミットの更新も行います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.</code></pre>
</figure>
<p><code class="literal">git svn rebase</code> をときどき実行しておけば、手元のコードを常に最新の状態に保っておけます。しかし、このコマンドを実行するときには作業ディレクトリがクリーンな状態であることを確認しておく必要があります。手元で変更をしている場合は、stash で作業を退避させるか一時的にコミットしてからでないと <code class="literal">git svn rebase</code> を実行してはいけません。さもないと、もしリベースの結果としてマージが衝突すればコマンドの実行が止まってしまいます。</p>
</section>
<section class="sect3" title="Git でのブランチに関する問題">
<h4 id="_git_でのブランチに関する問題">Git でのブランチに関する問題</h4>
<p>Git のワークフローに慣れてくると、トピックブランチを作ってそこで作業を行い、それをマージすることもあるでしょう。<code class="literal">git svn</code> を使って Subversion サーバーにプッシュする場合は、それらのブランチをまとめてプッシュするのではなく一つのブランチ上にリベースしてからプッシュしたくなるかもしれません。リベースしたほうがよい理由は、Subversion はリニアに歴史を管理していて Git のようなマージができないからです。<code class="literal">git svn</code> がスナップショットを Subversion のコミットに変換するときには、最初の親だけに続けます。</p>
<p>歴史が次のような状態になっているものとしましょう。<code class="literal">experiment</code> ブランチを作ってそこで 2 回のコミットを済ませ、それを <code class="literal">master</code> にマージしたところです。ここで <code class="literal">dcommit</code> すると、出力はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</figure>
<p>歴史をマージしたブランチで <code class="literal">dcommit</code> を実行してもうまく動作します。ただし、Git プロジェクト上での歴史を見ると、<code class="literal">experiment</code> ブランチ上でのコミットは書き換えられていません。そこでのすべての変更は、SVN 上での単一のマージコミットとなっています。</p>
<p>他の人がその作業をクローンしたときには、 <code class="literal">git merge --squash</code> を実行したときのように、すべての作業をひとまとめにしたマージコミットしか見ることができません。そのコミットがどこから来たのか、そしていつコミットされたのかを知ることができないのです。</p>
</section>
<section class="sect3" title="Subversion のブランチ">
<h4 id="_subversion_のブランチ">Subversion のブランチ</h4>
<p>Subversion のブランチは Git のブランチとは異なります。可能ならば、Subversion のブランチは使わないようにするのがベストでしょう。
しかし、Subversion のブランチの作成やコミットも、<code class="literal">git svn</code> を使ってすることができます。</p>
</section>
<section class="sect3" title="新しい SVN ブランチの作成">
<h4 id="_新しい_svn_ブランチの作成">新しい SVN ブランチの作成</h4>
<p>Subversion に新たなブランチを作るには <code class="literal">git svn branch [ブランチ名]</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre>
</figure>
<p>これは Subversion の <code class="literal">svn copy trunk branches/opera</code> コマンドと同じ意味で、Subversion サーバー上で実行されます。ここで注意すべき点は、このコマンドを実行しても新しいブランチに入ったことにはならないということです。この後コミットをすると、そのコミットはサーバーの <code class="literal">trunk</code> に対して行われます。<code class="literal">opera</code> ではありません。</p>
</section>
<section class="sect3" title="アクティブなブランチの切り替え">
<h4 id="_アクティブなブランチの切り替え">アクティブなブランチの切り替え</h4>
<p>Git が dcommit の行き先のブランチを決めるときには、あなたの手元の歴史上にある Subversion ブランチのいずれかのヒントを使います。手元にはひとつしかないはずで、それは現在のブランチの歴史上の直近のコミットにある <code class="literal">git-svn-id</code> です。</p>
<p>複数のブランチを同時に操作するときは、ローカルブランチを <code class="literal">dcommit</code> でその Subversion ブランチにコミットするのかを設定することができます。そのためには、Subversion のブランチをインポートしてローカルブランチを作ります。<code class="literal">opera</code> ブランチを個別に操作したい場合は、このようなコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch opera remotes/origin/opera</code></pre>
</figure>
<p>これで、<code class="literal">opera</code> ブランチを <code class="literal">trunk</code> (手元の <code class="literal">master</code> ブランチ) にマージするときに通常の <code class="literal">git merge</code> が使えるようになりました。しかし、そのときには適切なコミットメッセージを (<code class="literal">-m</code> で) 指定しなければなりません。さもないと、有用な情報ではなく単なる "Merge branch opera" というメッセージになってしまいます。</p>
<p><code class="literal">git merge</code> を使ってこの操作を行ったとしても、そしてそれが Subversion でのマージよりもずっと簡単だったとしても (Git は自動的に適切なマージベースを検出してくれるからね)、これは通常の Git のマージコミットとは違うということを覚えておきましょう。このデータを Subversion に書き戻すことになりますが Subversion では複数の親を持つコミットは処理できません。そのため、プッシュした後は、別のブランチ上で行ったすべての操作をひとまとめにした単一のコミットに見えてしまいます。あるブランチを別のブランチにマージしたら、元のブランチに戻って作業を続けるのは困難です。Git なら簡単なのですが。<code class="literal">dcommit</code> コマンドを実行すると、どのブランチからマージしたのかという情報はすべて消えてしまいます。そのため、それ以降のマージ元の算出は間違ったものとなります。dcommit は、<code class="literal">git merge</code> の結果をまるで <code class="literal">git merge --squash</code> を実行したのと同じ状態にしてしまうのです。残念ながら、これを回避するよい方法はありません。Subversion 側にこの情報を保持する方法がないからです。Subversion をサーバーに使う以上は、常にこの制約に縛られることになります。問題を回避するには、trunk にマージしたらローカルブランチ (この場合は <code class="literal">opera</code>) を削除しなければなりません。</p>
</section>
<section class="sect3" title="Subversion コマンド">
<h4 id="_subversion_コマンド">Subversion コマンド</h4>
<p><code class="literal">git svn</code> ツールセットには、Git への移行をしやすくするための多くのコマンドが用意されています。Subversion で使い慣れていたのと同等の機能を提供するコマンド群です。その中からいくつかを紹介します。</p>
<section class="sect4" title="SVN 形式のログ">
<h5 id="_svn_形式のログ">SVN 形式のログ</h5>
<p>Subversion に慣れているので SVN が出力する形式で歴史を見たい、という場合は <code class="literal">git svn log</code> を実行しましょう。すると、コミットの歴史が SVN 形式で表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch &#39;experiment&#39;

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog</code></pre>
</figure>
<p><code class="literal">git svn log</code> に関して知っておくべき重要なことがふたつあります。まず。このコマンドはオフラインで動作します。実際の <code class="literal">svn log</code> コマンドのように Subversion サーバーにデータを問い合わせたりしません。次に、すでに Subversion サーバーにコミット済みのコミットしか表示されません。つまり、ローカルの Git へのコミットのうちまだ dcommit していないものは表示されないし、その間に他の人が Subversion サーバーにコミットした内容も表示されません。最後に Subversion サーバーの状態を調べたときのログが表示されると考えればよいでしょう。</p>
</section>
<section class="sect4" title="SVN アノテーション">
<h5 id="_svn_アノテーション">SVN アノテーション</h5>
<p><code class="literal">git svn log</code> コマンドが <code class="literal">svn log</code> コマンドをオフラインでシミュレートしているのと同様に、<code class="literal">svn annotate</code> と同様のことを <code class="literal">git svn blame [FILE]</code> で実現できます。出力は、このようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn blame README.txt
 2   temporal Protocol Buffers - Google&#39;s data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal</code></pre>
</figure>
<p>先ほどと同様、このコマンドも Git にローカルにコミットした内容や他から Subversion にプッシュされていたコミットは表示できません。</p>
</section>
<section class="sect4" title="SVN サーバ情報">
<h5 id="_svn_サーバ情報">SVN サーバ情報</h5>
<p><code class="literal">svn info</code> と同様のサーバー情報を取得するには <code class="literal">git svn info</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre>
</figure>
<p><code class="literal">blame</code> や <code class="literal">log</code> と同様にこれもオフラインで動作し、最後に Subversion サーバーと通信した時点での情報しか表示されません。</p>
</section>
<section class="sect4" title="Subversion が無視するものを無視する">
<h5 id="_subversion_が無視するものを無視する">Subversion が無視するものを無視する</h5>
<p>どこかに <code class="literal">svn:ignore</code> プロパティが設定されている Subversion リポジトリをクローンした場合は、対応する <code class="literal">.gitignore</code> ファイルを用意したくなることでしょう。コミットすべきではないファイルを誤ってコミットしてしまうことを防ぐためにです。<code class="literal">git svn</code> には、この問題に対応するためのコマンドが二つ用意されています。まず最初が <code class="literal">git svn create-ignore</code> で、これは、対応する <code class="literal">.gitignore</code> ファイルを自動生成して次のコミットに含めます。</p>
<p>もうひとつは <code class="literal">git svn show-ignore</code> で、これは <code class="literal">.gitignore</code> に書き込む内容を標準出力に送ります。この出力を、プロジェクトの exclude ファイルにリダイレクトしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn show-ignore &gt; .git/info/exclude</code></pre>
</figure>
<p>これで、プロジェクトに <code class="literal">.gitignore</code> ファイルを散らかさなくてもよくなります。Subversion 使いのチームの中で Git を使うのが自分だけだという場合、他のメンバーにとっては <code class="literal">.gitignore</code> ファイルは目障りでしょう。そのような場合はこの方法が使えます。</p>
</section>
</section>
<section class="sect3" title="Git-Svn のまとめ">
<h4 id="_git_svn_のまとめ">Git-Svn のまとめ</h4>
<p><code class="literal">git svn</code> ツール群は、Subversion サーバーに行き詰まっている場合や使っている開発環境が Subversion サーバー前提になっている場合などに便利です。Git のできそこないだと感じるかもしれません。また、他のメンバーとの間で混乱が起こるかもしれません。トラブルを避けるために、次のガイドラインに従いましょう。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">Git の歴史をリニアに保ち続け、<code class="literal">git merge</code> によるマージコミットを含めないようにする。本流以外のブランチでの作業を書き戻すときは、マージではなくリベースすること。</span>
</li>
<li>
<span class="principal">Git サーバーを別途用意したりしないこと、新しい開発者がクローンするときのスピードをあげるためにサーバーを用意することはあるでしょうが、そこに <code class="literal">git-svn-id</code> エントリを持たないコミットをプッシュしてはいけません。<code class="literal">pre-receive</code> フックを追加してコミットメッセージをチェックし、<code class="literal">git-svn-id</code> がなければプッシュを拒否するようにしてもよいでしょう。</span>
</li>
</ul>
</div>
<p>これらのガイドラインを守れば、Subversion サーバーでの作業にも耐えられることでしょう。しかし、もし本物の Git サーバーに移行できるのなら、そうしたほうがチームにとってずっと利益になります。</p>
</section>
</section>
<section class="sect2" title="Git と Mercurial">
<h3 id="_git_と_mercurial">Git と Mercurial</h3>
<p>
</p>
<p>DVCSの世界にあるのはGitだけではありません。
事実、Git以外にも様々なシステムが存在し、分散バージョン管理を正しく行う方法について、それぞれが独自の見方を持っています。
Gitを除くと、もっとも広く使われているのは Mercurial です。Git と Mercurialは多くの点で似通っています。</p>
<p>良いニュースとして、 Git のクライアントサイドの動作がお好みで、しかし作業中のプロジェクトでは Mercurial でソースを管理しているという場合、 Mercurial でホストされているリポジトリのクライアントに Git を使用するという方法があります。
Git はリモートを通してサーバリポジトリとやりとりしているので、このブリッジがリモートヘルパーとして実装されているのは驚くほどのことでもないと思います。
プロジェクト名は git-remote-hg で、 <a href="https://github.com/felipec/git-remote-hg" class="link">https://github.com/felipec/git-remote-hg</a> から取得できます。</p>
<section class="sect3" title="git-remote-hg">
<h4 id="_git_remote_hg">git-remote-hg</h4>
<p>まず、 git-remote-hg をインストールする必要があります。
ここでは基本的に、そのファイルをどこかパスの通った場所に置く必要があります。以下のような感じです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> curl -o ~/bin/git-remote-hg <span style="font-weight: bold; font-style: italic">\</span>
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
<span style="font-weight: bold">$</span> chmod +x ~/bin/git-remote-hg</code></pre>
</figure>
<p>…ここでは <code class="literal">~/bin</code> が <code class="literal">$PATH</code> に含まれていることを仮定しています。
git-remote-hg にはもう一つ依存先があります。 Python の <code class="literal">mercurial</code> ライブラリです。
Python をインストール済みなら、これは次のようにシンプルなコマンドで行えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> pip install mercurial</code></pre>
</figure>
<p>（Python をインストールしていないなら、まず <a href="https://www.python.org/" class="link">https://www.python.org/</a> からPython を入手してください。）</p>
<p>最後に必要なのは Mercurial のクライアントです。
インストール済みでないなら、 <a href="http://mercurial.selenic.com/" class="link">http://mercurial.selenic.com/</a> から入手してインストールしてください。</p>
<p>これで準備が整いました。
必要なのはプッシュが可能な Mercurial リポジトリだけです。
幸いなことに、 Mercurial リポジトリならどれでもこの操作が可能です。そのため、 Mercurial の使い方を学ぶときにみんなが使う "hello world" リポジトリを使用することにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg clone http://selenic.com/repo/hello /tmp/hello</code></pre>
</figure>
</section>
<section class="sect3" title="使いはじめる">
<h4 id="_使いはじめる_2">使いはじめる</h4>
<p>これで、都合のいい “サーバサイド” のリポジトリができたので、以降では典型的なワークフローを見ていきます。
これから見ていくように、 Git と Mercurial はよく似ているため、食い違う箇所はそう多くありません。</p>
<p>Git でいつもやるように、まずクローンをします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone hg::/tmp/hello /tmp/hello-git
<span style="font-weight: bold">$</span> cd /tmp/hello-git
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>標準的な <code class="literal">git clone</code> コマンドを使用して Mercurial リポジトリを操作しているのが分かると思います。
これは git-remote-hg が非常に低いレベルで動作しているためです。 git-remote-hg は Git が HTTP/S プロトコルを実装しているのと同じようなメカニズム（リモートヘルパー）を使用しています。
Git と Mercurial は両方とも、すべてのクライアントがリポジトリの歴史の完全なコピーを持つように設計されています。そのためこのコマンドは、プロジェクトのすべての歴史を含む完全なクローンを作成します。また、この処理は非常に高速に行われます。</p>
<p>git logコマンドは2つのコミットを表示しています。最新のコミットは大量の参照から指されています。
実は、これらの中のいくつかは、実際には存在しません。
<code class="literal">.git</code> ディレクトリの中に実際には何が入っているか見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files</code></pre>
</figure>
<p>git-remote-hg は、物事をより Git 風にしようとしているわけですが、内部的には、2つの微妙に異なるシステムの間のマッピングを管理しています。
<code class="literal">refs/hg</code> ディレクトリには実際のリモート参照が格納されています。
例えば、 <code class="literal">refs/hg/origin/branches/default</code> は “ac7955c” で始まるSHA-1（ <code class="literal">master</code> が指しているコミットを表している）を含むGitの参照ファイルです。
そのため、 <code class="literal">refs/hg</code> ディレクトリは <code class="literal">refs/remotes/origin</code> の模造品のようなものとも言えます。ただし、ブックマークとブランチの区別が追加されています。</p>
<p><code class="literal">notes/hg</code> ファイルは、 git-remote-hg が Git のコミットハッシュと Mercurial のチェンジセットIDを対応付ける際の開始点となります。
ちょっと見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat notes/hg
d4c10386...

<span style="font-weight: bold">$</span> git cat-file -p d4c10386...
tree 1781c96...
author remote-hg &lt;&gt; 1408066400 -0800
committer remote-hg &lt;&gt; 1408066400 -0800

Notes for master

<span style="font-weight: bold">$</span> git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

<span style="font-weight: bold">$</span> git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre>
</figure>
<p><code class="literal">refs/notes/hg</code> は Git オブジェクトデータベース中にあるツリーを指しており、その内容は他のオブジェクトの名前つきリストになっています。
<code class="literal">git ls-tree</code> はツリー中の要素のモード、タイプ、オブジェクトハッシュ、およびファイル名を出力します。
ツリー中の要素の一つについて掘り下げていくと、その実体は “ac9117f” （ <code class="literal">master</code> が指しているコミットの SHA-1 ハッシュ）という名前の blob で、内容は “0a04b98” （ <code class="literal">default</code> ブランチの先端の Mercurial チェンジセットのID）であることが分かります。</p>
<p>よいニュースとして、これらすべてのことについて、我々が気にする必要はほとんどありません。
典型的なワークフローは、 Git でリモートに対して作業をする場合と大差ありません。</p>
<p>以降の話をする前に、もう一つ注意しておかなければならないことがあります。 ignoreファイルです。
Mercurial と Git はこの点について非常に似通ったメカニズムを使用しています。ですが、おそらく実際に <code class="literal">.gitignore</code> ファイルを Mercurial リポジトリへコミットしたい、ということはないでしょう。
幸いなことに、 Git にはローカルからディスク上のリポジトリへファイルを登録する際に、指定したファイルを無視する方法があります。Mercurial のフォーマットは Git と互換性があるので、単にファイルをコピーするだけで済みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp .hgignore .git/info/exclude</code></pre>
</figure>
<p><code class="literal">.git/info/exclude</code> ファイルは <code class="literal">.gitignore</code> と同様の働きをしますが、コミットには含まれません。</p>
</section>
<section class="sect3" title="ワークフロー">
<h4 id="_ワークフロー">ワークフロー</h4>
<p>現在、何らかの作業をやり終え、 <code class="literal">master</code> ブランチにはコミットがいくつか作成されており、それをリモートリポジトリへプッシュできる状態にあるとしましょう。
現時点では、リポジトリは次のような内容になっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p><code class="literal">master</code> ブランチは <code class="literal">origin/master</code> よりコミット2つぶん進んでいますが、これら2つのコミットはローカルのマシン上にしかありません。
ここで、誰か他の人が、何か重要な作業をこれと同時に行っていたらどうなるか見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -&gt; origin/master
   ac7955c..df85e87  branches/default -&gt; origin/branches/default
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p><code class="literal">--all</code> フラグを指定したため、 “notes” 参照が表示されていますが、これは git-remote-hg が内部的に使用しているものなので、無視して構いません。
残りが期待していた内容です。 <code class="literal">origin/master</code> はコミット1つぶん進んでおり、現在この歴史は枝分かれした状態にあります。
この章で扱っている他のシステムと異なり、 Mercurial にはマージをハンドリングする機能が備わっているので、ややこしいことをする必要は何もありません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging hello.c
Merge made by the &#39;recursive&#39; strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch &#39;origin/master&#39;
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>完璧です。
テストを実行して、結果はすべて正常でした。これで、成果物をチームの他のメンバーと共有できる状態になりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push
To hg::/tmp/hello
   df85e87..0c64627  master -&gt; master</code></pre>
</figure>
<p>これで完了です！
Mercurial リポジトリを見てみれば、期待していた内容が分かるはずです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch &#39;origin/master&#39;
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>番号 <em>2</em> のチェンジセットは Mercurial が作成したもので、番号 <em>3</em> および <em>4</em> のチェンジセットは Git で作成したコミットを git-remote-hg がプッシュして作成したものです。</p>
</section>
<section class="sect3" title="ブランチとブックマーク">
<h4 id="_ブランチとブックマーク">ブランチとブックマーク</h4>
<p>Git のブランチは1種類しかありません。コミットに合わせて移動する参照です。
Mercurial では、この種の参照は “ブックマーク” と呼ばれており、 Git のブランチとほぼ同じように振る舞います。</p>
<p>Mercurial の言う “ブランチ” は Git のそれよりもっと重量級の概念です。
ブランチの上でチェンジセットが作成された場合、ブランチは <em>チェンジセットと一緒に</em> 記録されます。つまり、常にリポジトリの歴史に残ります。
<code class="literal">develop</code> ブランチの上で作成されたコミットの例を次に示します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub &lt;ben@straub.cc&gt;
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation</code></pre>
</figure>
<p>“branch” で始まる行に注目してください。
Git はこれを完全に複製することはできません（また、する必要もありません。いずれのタイプのブランチも Git では参照として表現されるため）が、 Mercurial にとってはこの違いが問題となるため、 git-remote-hg はこの違いを理解している必要があります。</p>
<p>Mercurial のブックマークを作成するのは、 Git のブランチを作成するのと同様に簡単です。
Git 側では、</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b featureA
Switched to a new branch &#39;featureA&#39;
<span style="font-weight: bold">$</span> git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -&gt; featureA</code></pre>
</figure>
<p>これだけです。
Mercurial 側では、これは次のように見えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg bookmarks
   featureA                  5:bd5ac26f11f9
<span style="font-weight: bold">$</span> hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch &#39;origin/master&#39;
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>リビジョン5に付いている新しいタグ <code class="literal">[featureA]</code> に注目してください。
これらの挙動は Git 側から見ると Git のブランチと非常によく似ていますが、一つ例外があります。 Git の側からブックマークを削除することはできません（これはリモートヘルパーの制限によります）。</p>
<p>“重量級” の Mercurial のブランチ上で作業をすることもできます。 <code class="literal">branches</code> 名前空間にブランチを追加します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b branches/permanent
Switched to a new branch &#39;branches/permanent&#39;
<span style="font-weight: bold">$</span> vi Makefile
<span style="font-weight: bold">$</span> git commit -am <span style="font-style: italic">&#39;A permanent change&#39;</span>
<span style="font-weight: bold">$</span> git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -&gt; branches/permanent</code></pre>
</figure>
<p>Mercurial 側ではこれは次のように見えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
<span style="font-weight: bold">$</span> hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub &lt;ben@straub.cc&gt;
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub &lt;ben@straub.cc&gt;
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub &lt;ben@straub.cc&gt;
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch &#39;origin/master&#39;
[...]</code></pre>
</figure>
<p>“permanent” という名前のブランチが、 <em>7</em> とマークされたチェンジセットと一緒に記録されています。</p>
<p>Git 側では、いずれのタイプのブランチで作業をするのも変わりません。普段と同じように、チェックアウト、コミット、フェッチ、マージ、プル、プッシュが行えます。
一つ知っておくべきこととして、 Mercurial は歴史の書き換えをサポートしておらず、追記しか行えません。
対話的リベースと強制プッシュを行うと、 Mercurial リポジトリは次のような内容になります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch &#39;origin/master&#39;
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard &quot;hello, world&quot; program</code></pre>
</figure>
<p>チェンジセット <em>8</em>、 <em>9</em>、 <em>10</em> が作成され、 <code class="literal">permanent</code> ブランチに紐付けられていますが、古いチェンジセットも残っています。
これは Mercurial を使用している他のチームメンバーを <strong>かなり</strong> 混乱させるので、できる限り避けましょう。</p>
</section>
<section class="sect3" title="Mercurial のまとめ">
<h4 id="_mercurial_のまとめ">Mercurial のまとめ</h4>
<p>Git と Mercurial は非常に似通っており、相互に作業してもほとんど苦になりません。
（一般的に推奨されているように）あなたのマシン上にある歴史を変更しないようにさえしていれば、相手側にあるのが Mercurial であることを意識する必要もありません。</p>
</section>
</section>
<section class="sect2" title="Git と Perforce">
<h3 id="_git_と_perforce">Git と Perforce</h3>
<p>
</p>
<p>Perforce は企業内では非常によく使われているバージョン管理システムです。
Perforce が登場したのは 1995 年で、この章で扱う中ではもっとも古いシステムです。
そしてその言葉通り、Perforce は当時の制約に合わせて設計されています。単一の中央サーバへの常時接続を仮定しており、またローカルディスクに保存しておけるバージョンは一つだけです。
確かに、Perforce の機能と制約は、ある特定の問題にはうまく適合します。しかし、実際には Git の方が上手くいくにも関わらず、 Perforce を使用しているというプロジェクトも数多くあります。</p>
<p>Perforce と Git を混在して使用したい場合、2通りの選択肢があります。
1つ目に取り上げるのは Perforce の開発元から出ている “Git Fusion” ブリッジです。これは、 Perforce ディポのサブツリーを読み書き可能な Git リポジトリとして公開させるものです。
2つ目はクライアントサイドのブリッジである git-p4 です。これは Git を Perforce のクライアントとして使用できるようにするもので、 Perforce サーバの設定を変更することなく使用できます。</p>
<section class="sect3" title="Git Fusion">
<h4 id="r_p4_git_fusion">Git Fusion</h4>
<p></p>
<p>Perforce は Git Fusion という製品を提供しています（ <a href="http://www.perforce.com/git-fusion" class="link">http://www.perforce.com/git-fusion</a> から入手可能）。これは、サーバサイドで Perforce サーバと Git リポジトリとを同期させます。</p>
<section class="sect4" title="セットアップ">
<h5 id="_セットアップ_2">セットアップ</h5>
<p>本書の例では、 Git Fusion のもっとも簡単なインストール法として、仮想マシンをダウンロードし、 Perforce デーモンと Git Fusion をその上で実行する方法をとります。
仮想マシンイメージは <a href="http://www.perforce.com/downloads/Perforce/20-User" class="link">http://www.perforce.com/downloads/Perforce/20-User</a> から入手できます。ダウンロードが完了したら、お好みの仮想ソフトへインポートします（本書では VirtualBox を使用します）。</p>
<p>仮想マシンの初回起動時には、3つの Linux ユーザ（ <code class="literal">root</code>、 <code class="literal">perforce</code> 、および <code class="literal">git</code> ）のパスワードを設定するよう要求されます。また、同じネットワーク上の他の仮想マシンとの区別のため、インスタンス名を決めるよう要求されます。
これらすべてが完了したら、次の画面が表示されるはずです。</p>
<figure class="image">
<div class="content">
<img src="images/git-fusion-boot.png" alt="Git Fusion 仮想マシンのブート画面"/>
</div>
<figcaption>Figure 1. Git Fusion 仮想マシンのブート画面</figcaption>
</figure>
<p>ここで表示されるIPアドレスは、後で使用するので、メモしておいてください。
次に、 Perforce ユーザを作成します。
下部にある “Login” オプションを選択肢、Enterキーを押下し（または仮想マシンへSSHで接続し）、 <code class="literal">root</code> としてログインします。
続けて、次のコマンドでユーザを作成します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> p4 -p localhost:1666 -u super user -f john
<span style="font-weight: bold">$</span> p4 -p localhost:1666 -u john passwd
<span style="font-weight: bold">$</span> exit</code></pre>
</figure>
<p>1つめのコマンドは、ユーザのカスタマイズのため VI エディタを起動しますが、 <code class="literal">:wq</code> に続けて Enter を入力すれば、デフォルト設定のまま利用することもできます。
2つめのコマンドは、パスワードを2度入力するようプロンプトを表示します。
シェルプロンプトで行う必要のある作業はこれで全部ですので、セッションを終了します。</p>
<p>次に手順に従って行う必要があるのは、Git が SSL 証明書を検証しないようにすることです。
Git Fusion の仮想マシンイメージには証明書が同梱されていますが、これはあなたの仮想マシンのIPアドレスとは合わないであろうドメインのものなので、 Git は HTTPS 接続を拒否してしまいます。
今回インストールした環境を今後も使い続けるつもりなら、 Perforce Git Fusion マニュアルを参考に、個別の証明書をインストールしてください。本書で例を示すだけの用途なら、以下で十分です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export GIT_SSL_NO_VERIFY=true</code></pre>
</figure>
<p>これで、すべてが動作しているかテストできるようになりました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://10.0.1.254/Talkhouse
Cloning into &#39;Talkhouse&#39;...
Username for &#39;https://10.0.1.254&#39;: john
Password for &#39;https://john@10.0.1.254&#39;:
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.</code></pre>
</figure>
<p>仮想マシンイメージには、クローンできるサンプルプロジェクトが同梱されています。
ここでは、上で作成したユーザ <code class="literal">john</code> を使用し、 HTTPS 経由でクローンしています。今回の接続時には認証情報を要求されますが、以降のリクエストでは Git の認証情報キャッシュが働くので、このステップは省略できます。</p>
</section>
<section class="sect4" title="Fusion の設定">
<h5 id="_fusion_の設定">Fusion の設定</h5>
<p>Git Fusion をインストールし終わったら、設定を調整したいことと思います。
設定の変更は、お好きな Perforce クライアントを使用して、実際非常に簡単に行えます。Perforce サーバの <code class="literal">//.git-fusion</code> ディレクトリをワークスペースにマップするだけです。
ファイル構造は次のようになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files</code></pre>
</figure>
<p><code class="literal">objects</code> ディレクトリは Perforce のオブジェクトを Git へ対応付ける（逆も同様）ために Git Fusion が内部的に使用しているもので、この内容に触れる必要はありません。
このディレクトリにはグローバルな <code class="literal">p4gf_config</code> 設定ファイルがあります。また、このファイルは各リポジトリにも一つずつあります – これらは、 Git Fusion の動作を決定する設定ファイルです。
ルートディレクトリにあるファイルを見てみましょう。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[repo-creation]</span>
charset = <span style="font-style: italic">utf8</span>

<span style="font-weight: bold">[git-to-perforce]</span>
change-owner = <span style="font-style: italic">author</span>
enable-git-branch-creation = <span style="font-style: italic">yes</span>
enable-swarm-reviews = <span style="font-style: italic">yes</span>
enable-git-merge-commits = <span style="font-style: italic">yes</span>
enable-git-submodules = <span style="font-style: italic">yes</span>
preflight-commit = <span style="font-style: italic">none</span>
ignore-author-permissions = <span style="font-style: italic">no</span>
read-permission-check = <span style="font-style: italic">none</span>
git-merge-avoidance-after-change-num = <span style="font-style: italic">12107</span>

<span style="font-weight: bold">[perforce-to-git]</span>
http-url = <span style="font-style: italic">none</span>
ssh-url = <span style="font-style: italic">none</span>

<span style="font-weight: bold">[@features]</span>
imports = <span style="font-style: italic">False</span>
chunked-push = <span style="font-style: italic">False</span>
matrix2 = <span style="font-style: italic">False</span>
parallel-push = <span style="font-style: italic">False</span>

<span style="font-weight: bold">[authentication]</span>
email-case-sensitivity = <span style="font-style: italic">no</span></code></pre>
</figure>
<p>ここでは各フラグの意味については説明しませんが、このファイルが、 Git の設定ファイル同様、単なる INI ファイル形式のテキストファイルであるという点は明記しておきます。
このファイルではグローバルなオプションを設定しています。これらの設定は <code class="literal">repos/Talkhouse/p4gf_config</code> などのリポジトリ固有の設定で上書きできます。
このファイルを開くと、 <code class="literal">[@repo]</code> セクションに、グローバルなデフォルト値とは異なる設定がされているのが分かると思います。
また、次のようなセクションがあると思います。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[Talkhouse-master]</span>
git-branch-name = <span style="font-style: italic">master</span>
view = <span style="font-style: italic">//depot/Talkhouse/main-dev/... ...</span></code></pre>
</figure>
<p>これは Perforce のブランチと Git のブランチのマッピングです。
このセクションの名前は好きなように決められるので、一意になるように長い名前も付けられます。
<code class="literal">git-branch-name</code> を使えば、Git にとってはとても長いディポのパスを、より扱いやすい名前に変換できます。
<code class="literal">view</code> では、 Perforce のファイルが Git のリポジトリへどう対応するかを、通常のビュー・マッピング用のシンタックスで設定します。
複数のマッピングを指定することもできます。次に例を示します。</p>
<figure class="listing">
<pre class="source language-ini"><code><span></span><span style="font-weight: bold">[multi-project-mapping]</span>
git-branch-name = <span style="font-style: italic">master</span>
view = <span style="font-style: italic">//depot/project1/main/... project1/...</span>
<span style="font-style: italic">       //depot/project2/mainline/... project2/...</span></code></pre>
</figure>
<p>通常のワークスペースのマッピングが、ディレクトリの構造の変更を含む場合、この方法では、それも含めてGitリポジトリを複製することができます。</p>
<p>最後に取り上げるのは <code class="literal">users/p4gf_usermap</code> で、これは Perforce のユーザを Git のユーザにマッピングするファイルですが、必要ないかもしれません。
Perforce のチェンジセットを Git のコミットへ変換する際、 Git Fusion のデフォルトの動作では、 Perforce ユーザを探して、そのメールアドレスとフルネームを Git の作成者/コミッターフィールドに使用します。
逆の方向に変換する場合、デフォルトでは Git の作成者フィールドに格納されているメールアドレスで Perforce ユーザを検索し、そのユーザとしてチェンジセットを送信します（パーミッションも適用されます）。
ほとんどの場合、この動作で上手くいきます。ただし、次のマッピングファイルについても考慮しておいてください。</p>
<figure class="listing">
<pre class="source language-"><code>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</code></pre>
</figure>
<p>各行のフォーマットは <code class="literal">&lt;ユーザ名&gt; &lt;メールアドレス&gt; "&lt;氏名&gt;"</code> となっています。一行ごとに一つ、ユーザの対応づけを定義しています。
最初の2行は、2つの異なるメールアドレスを同一の Perforce ユーザアカウントへ対応づけています。
これは、 Git のコミットを複数のメールアドレスで作成していた（または、メールアドレスを変更した）際に、それらを同じ Perforce へ対応づけたい場合に便利です。
Perforce のチェンジセットから Git のコミットを作成する際には、 Perforce のユーザとマッチした最初の行が Git の作成者情報として使用されます。</p>
<p>最後の2行は、Git のコミットから Bob と Joe の氏名とメールアドレスが分からないようにします。
これは、社内のプロジェクトをオープンソース化したいが、社員名簿を全世界へ晒したくはない、というときに役立ちます。
注意すべき点として、すべての Git コミットが実際には存在しない1人のユーザによるものである、としたい場合を除き、メールアドレスと氏名は一意になるよう設定してください。</p>
</section>
<section class="sect4" title="ワークフロー">
<h5 id="_ワークフロー_2">ワークフロー</h5>
<p>Perforce Git Fusion は Perforce と Git の間の双方向ブリッジです。
Gitの側から作業するとどんな感じなのかを見てみましょう。
ここでは、前述した設定ファイルを使用して “Jam” プロジェクトをマッピングしたと仮定しましょう。次のようにクローンが行えます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://10.0.1.254/Jam
Cloning into &#39;Jam&#39;...
Username for &#39;https://10.0.1.254&#39;: john
Password for &#39;https://ben@10.0.1.254&#39;:
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/rel2.1
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam&#39;s NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone&#39;s lynx port.
[...]</code></pre>
</figure>
<p>最初にこれを実行した際には、ちょっと時間がかかるかもしれません。
ここで何が行われているかというと、 Git Fusion が、 Perforce の歴史中にある、適用可能なチェンジセットをすべて Git のコミットへ変換しています。
この処理はサーバ内部で行われるので、比較的高速ですが、大量の歴史がある場合には、ちょっと時間がかかります。
以降のフェッチでは増分だけを変換するので、体感的に Git 本来のスピードにより近づきます。</p>
<p>見て分かるとおり、このリポジトリは普段作業している Git リポジトリと見た目上まったく変わりません。
3つのブランチがあり、 Git は親切なことに <code class="literal">origin/master</code> ブランチを追跡するローカルの <code class="literal">master</code> ブランチまで作成してくれています。
ちょっと作業をして、新しいコミットを2つほど作成してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> ...
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam&#39;s NT handle leak.
[...]</code></pre>
</figure>
<p>新しいコミットが2つできました。
今度は、他の人が作業していなかったか確認してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -&gt; origin/master
<span style="font-weight: bold">$</span> git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam&#39;s NT handle leak.
[...]</code></pre>
</figure>
<p>誰かいたみたいですよ！
このビューからは分からなかったかも知れませんが、コミット <code class="literal">6afeb15</code> は Perforce クライアントを使用して実際に作成されたものです。
Git の視点から見ると、他のコミットと変わりませんが、 そこがポイントです。
Perforce サーバがマージコミットをどのように処理するのかを見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git merge origin/master
Auto-merging README
Merge made by the &#39;recursive&#39; strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
<span style="font-weight: bold">$</span> git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -&gt; master</code></pre>
</figure>
<p>Git からは、うまくいったように見えているようです。
<code class="literal">p4v</code> のリビジョングラフ機能を使用して、 <code class="literal">README</code> ファイルの歴史を Perforce の視点から見てみましょう。</p>
<figure class="image">
<div class="content">
<img src="images/git-fusion-perforce-graph.png" alt="Git でのプッシュの結果作成される Perforce のリビジョングラフ"/>
</div>
<figcaption>Figure 2. Git でのプッシュの結果作成される Perforce のリビジョングラフ</figcaption>
</figure>
<p>この画面を見たことがないと、混乱するかもしれませんが、 Git の歴史をグラフィカルに表示するビューアと同じ概念を示しています。
ここでは <code class="literal">README</code> ファイルの歴史を見ています。そのため、左上のディレクトリツリーでは、様々なブランチなかからそのファイルだけを取り上げて表示しています。
右上には、そのファイルの様々なリビジョンがどのように関連しているか、ビジュアライズされたグラフが表示されます。このグラフの全体像は右下にあります。
ビューの残りの部分では、選択したリビジョン（この場合は <code class="literal">2</code> ）の詳細を表示しています。</p>
<p>ひとつ注目してもらいたいのは、このグラフが Git の歴史のグラフとそっくりだということです。
Perforce にはコミット <code class="literal">1</code> および <code class="literal">2</code> を格納する名前つきのブランチがありません。代わりに “anonymous” ブランチを <code class="literal">.git-fusion</code> ディレクトリに作成し、そこに保管しています。
同様のことは、名前つきの Git のブランチに、対応する名前つきの Perforce のブランチがない場合にも起こります（設定ファイルを使えば、後でそのようなブランチを Perforce のブランチへ対応づけることも可能です）。</p>
<p>これのほとんどは舞台裏で行われますが、最終的には、ひとつのチームの中で、ある人は Git を使用し、またある人は Perforce を使用するということができ、その双方とも他の人が何を使用しているのかを知ることはない、という結果になりました。</p>
</section>
<section class="sect4" title="Git-Fusion のまとめ">
<h5 id="_git_fusion_のまとめ">Git-Fusion のまとめ</h5>
<p>Perforce サーバへのアクセス権がある（または取得できる）なら、 Git Fusion は Git と Perforce が互いにやりとりできるようにする素晴らしい方法です。
多少の設定は必要ですが、学習曲線は急ではありません。
本節は、この章において、 Git の全機能を使用することに関して注意事項のない、数少ない節の一つです。
Perforce は指定した処理すべてを喜んでこなす、とは言いません – すでにプッシュ済みの歴史を書き換えようとしたら、 Git Fusion はそれをリジェクトします – ですが、 Git Fusion は Git そのままの感じになるよう非常に苦心しています。
また、Git のサブモジュールを使用したり（Perforce のユーザには変な風にみえますが）、ブランチのマージをしたり（Perforce 側では統合として記録されます）することも可能です。</p>
<p>Git Fusion をセットアップするようサーバの管理者を説得できなかったとしても、Git と Perforce を一緒に使用する方法は他にもあります。</p>
</section>
</section>
<section class="sect3" title="Git-p4">
<h4 id="_git_p4">Git-p4</h4>
<p></p>
<p>git-p4 は、 Git と Perforce の間の双方向ブリッジです。
git-p4 は Git リポジトリの中だけで動作するので、 Perforce サーバにおけるいかなるアクセス権も必要としません（もちろん、ユーザ権限は必要ですが）。
git-p4 には Git Fusion ほどの柔軟性や完全性はありません。ですが、やりたいであろうことの大半を、サーバ環境に対して侵襲的になることなく実施できます。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>git-p4 で作業を行う場合、 <code class="literal">p4</code> ツールに <code class="literal">PATH</code> が通っている必要があります。
これを書いている時点では、 <code class="literal">p4</code> は <a href="http://www.perforce.com/downloads/Perforce/20-User" class="link">http://www.perforce.com/downloads/Perforce/20-User</a> から無料で入手できます。</p>
</div>
</aside>
<section class="sect4" title="セットアップ">
<h5 id="_セットアップ_3">セットアップ</h5>
<p>例のため、前に見てきたとおり Perforce サーバを Git Fusion OVA で実行しますが、ここでは Git Fusion サーバをバイパスして、 Perforce のバージョン管理機能を直接使用します。</p>
<p><code class="literal">p4</code> コマンドラインクライアント（ git-p4 がこれに依存している）を使用するには、環境変数を2つ設定する必要があります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export P4PORT=10.0.1.254:1666
<span style="font-weight: bold">$</span> export P4USER=john</code></pre>
</figure>
</section>
</section>
<section class="sect3" title="使いはじめる">
<h4 id="_使いはじめる_3">使いはじめる</h4>
<p>Git でやるのと同様、最初にすることはクローンです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre>
</figure>
<p>これで、 Git の用語で言う “シャロー” クローンが作成されます（Perforce の最新のリビジョンだけが Git へインポートされます）。覚えておいて欲しいのですが、 Perforce はすべてのリビジョンをすべてのユーザに渡すようデザインされてはいません。
Git を Perforce のクライアントとして使用するにはこれで十分ですが、それ以外の用途には不十分といえます。</p>
<p>クローンが完了したら、十分な機能を備えた Git リポジトリの出来上がりです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd myproject
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Perforceを表す “p4” リモートがあることに注意が必要ですが、それ以外はすべて、通常のクローンと同じように見えます。
実際、これは少し誤解をまねきやすいのですが、実際にはリモートがあるわけではありません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote -v</code></pre>
</figure>
<p>このリポジトリにはリモートはひとつもありません。
git-p4 は、サーバの状態を表すために参照をいくつか作成します。これが <code class="literal">git log</code> からはリモート参照のように見えます。ですが、これらの参照は Git 自身が管理しているものではなく、またそこへプッシュすることもできません。</p>
</section>
<section class="sect3" title="ワークフロー">
<h4 id="_ワークフロー_3">ワークフロー</h4>
<p>オーケー、それでは作業を始めましょう。
ここでは、ある非常に重要な機能に関して進捗があり、その成果をチームの他のメンバーに見せられる状態になっているとしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>すでに2つのコミットを作成しており、Perforce サーバへ送信する準備もできています。
今日、他の誰かが作業をしていなかったか確認してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>誰かが作業をしていたようです。また、 <code class="literal">master</code> と <code class="literal">p4/master</code> が分岐しています。
Perforce のブランチのシステムは Git とは <em>まったく</em> 異なり、マージコミットを送信しても意味をなしません。
git-p4 では、コミットをリベースすることを推奨しており、そのためのショートカットも用意されています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</figure>
<p>出力から分かったかと思いますが、 <code class="literal">git p4 rebase</code> は <code class="literal">git p4 sync</code> の後に <code class="literal">git rebase p4/master</code> を実行するショートカットです。
実際にはもう少し賢いのですが（特に複数のブランチで作業をしている場合には）、これはよい近似と言えます。</p>
<p>これで歴史がリニアになり、変更を Perforce へ提供できる状態になりました。
<code class="literal">git p4 submit</code> を実行すると、 Git の <code class="literal">p4/master</code> から <code class="literal">master</code> の間の各コミットに対して Perforce のリビジョンを作成しようとします。
実行するとお好みのエディタが開かれます。ファイルの内容は次のような感じです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">#</span> A Perforce Change Specification.
<span style="font-weight: bold">#</span>
<span style="font-weight: bold">#</span>  Change:      The change number. <span style="font-style: italic">&#39;new&#39;</span> on a new changelist.
<span style="font-weight: bold">#</span>  Date:        The date this specification was last modified.
<span style="font-weight: bold">#</span>  Client:      The client on which the changelist was created.  Read-only.
<span style="font-weight: bold">#</span>  User:        The user who created the changelist.
<span style="font-weight: bold">#</span>  Status:      Either <span style="font-style: italic">&#39;pending&#39;</span> or <span style="font-style: italic">&#39;submitted&#39;</span>. Read-only.
<span style="font-weight: bold">#</span>  Type:        Either <span style="font-style: italic">&#39;public&#39;</span> or <span style="font-style: italic">&#39;restricted&#39;</span>. Default is <span style="font-style: italic">&#39;public&#39;</span>.
<span style="font-weight: bold">#</span>  Description: Comments about the changelist.  Required.
<span style="font-weight: bold">#</span>  Jobs:        What opened jobs are to be closed by this changelist.
<span style="font-weight: bold">#</span>               You may delete jobs from this list.  (New changelists only.)
<span style="font-weight: bold">#</span>  Files:       What opened files from the default changelist are to be added
<span style="font-weight: bold">#</span>               to this changelist.  You may delete files from this list.
<span style="font-weight: bold">#</span>               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


<span style="font-weight: bold">#</span><span style="font-style: italic">####### git author ben@straub.cc does not match your p4 account.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### Use option --preserve-user to modify authorship.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### Variable git-p4.skipUserNameCheck hides this message.</span>
<span style="font-weight: bold">#</span><span style="font-style: italic">####### everything below this line is just the diff #######</span>
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 &lt;/td&gt;
 &lt;td valign=top&gt;
 Source and documentation for
-&lt;a href=&quot;http://www.perforce.com/jam/jam.html&quot;&gt;
+&lt;a href=&quot;jam.html&quot;&gt;
 Jam/MR&lt;/a&gt;,
 a software build tool.
 &lt;/td&gt;</code></pre>
</figure>
<p>これは、 git-p4 が気を利かせて末尾に追加している内容を除けば、 <code class="literal">p4 submit</code> を実行した場合とほぼ同じ内容です。
git-p4 は、コミットやチェンジセットに対して氏名を指定する必要がある場合、 Git と Perforce で設定をそれぞれ個別に行えるようにしていますが、その設定を上書きしたい場合もあります。
例えば、 Git のコミットをインポートしていて、そのコミットの作成者が Perforce のユーザアカウントを持っていない場合を考えます。この場合、最終的にできるチェンジセットは（あなたではなく）そのコミットの作成者が書いたように見えるようにしたいだろうと思います。</p>
<p>git-p4 は気が利いていて、Git のコミットからメッセージをインポートして、この Perforce のチェンジセットの内容にセットしてくれます。そのため、ここではファイルの保存とエディタの終了を2回（コミット1つにつき1回）行うだけで済みます。
結果として、シェルへの出力は次のような感じになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>出力は、実際に行われている処理にもっとも近いアナロジーとして、単に <code class="literal">git push</code> を実行したかのような内容になっています。</p>
<p>注意事項として、この処理では Git の各コミットが個別の Perforce のチェンジセットに変換されます。複数のコミットを1つのチェンジセットへスカッシュしたい場合は、 <code class="literal">git p4 submit</code> の前に対話的リベースを行ってください。
また、チェンジセットとして送信された全コミットの SHA-1 ハッシュが変更される点にも注意してください。これは、 git-p4 が変換した各コミットの末尾に行を追加するためです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = &quot;//depot/www/live/&quot;: change = 12144]</code></pre>
</figure>
<p>マージコミットを送信しようとした場合、何が起こるでしょうか？
やってみましょう。
現在の状況は次のようになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch &#39;p4/master&#39;
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>Git と Perforce の歴史が 775a46f の後で分岐しています。
Git 側に2つのコミットがあり、次に Perforce 側の HEAD とのマージコミット、さらにその次にまた別のコミットがあります。
ここでは、これらすべてのコミットを Perforce 側のチェンジセットの一番上に追加してみます。
現時点で送信した場合に何が起こるか見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address</code></pre>
</figure>
<p><code class="literal">-n</code> フラグは <code class="literal">--dry-run</code> の省略形で、送信コマンドを本当に実行したら何が起こるかを表示してくれます。
この場合、 Perforce サーバに存在しない3つの非マージコミットに対応するように、 Perforce のチェンジセットを3つ作成するように見えます。
これは、望む結果そのもののように見えますので、結果どうなったか見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 submit
[…]
<span style="font-weight: bold">$</span> git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</figure>
<p>送信の前にリベースを実行したかのように（実際、それが行われているのですが）、歴史がリニアになりました。
これはつまり、Git 側ではブランチを作成したり、ブランチ上で作業したり、ブランチを放棄したり、ブランチをマージしたりといった作業を自由に行えること、その際に歴史が何らかの形で Perforce と非互換になってしまう心配もないということです。
リベースが行えるなら、その内容を Perforce サーバへ送信できます。</p>
<section class="sect4" title="ブランチ">
<h5 id="r_git_p4_branches">ブランチ</h5>
<p>Perforce プロジェクトに複数のブランチがある場合でも、運の尽きというわけではありません。 git-p4 はそのようなプロジェクトを、 Git と同じように扱えます。
まず、 Perforce のディポが次のような内容になっているとしましょう。</p>
<figure class="listing">
<pre class="source language-"><code>//depot
  └── project
      ├── main
      └── dev</code></pre>
</figure>
<p>さらに、次のようなビュー・スペックを持った <code class="literal">dev</code> ブランチがあるとしましょう。</p>
<figure class="listing">
<pre class="source language-"><code>//depot/project/main/... //depot/project/dev/...</code></pre>
</figure>
<p>git-p4 はこのような状況を自動的に検出し、正しく処理を行います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
<span style="font-weight: bold">$</span> cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init</code></pre>
</figure>
<p>ディポのパスに “@all” という指示子がついていることに注意してください。これは git-p4 に対して、パスの示すサブツリーの最新のチェンジセットだけでなく、そのパスにあったことのあるすべてのチェンジセットをクローンするように指示しています。
これは Git のクローンの考え方に近いですが、作業中のプロジェクトに長い歴史がある場合、ちょっと時間がかかるかもしれません。</p>
<p><code class="literal">--detect-branches</code> フラグは、 git-p4 に対して、Perforce のブランチを Git の参照へマッピングする際に、 Perforce のブランチ仕様を使用するように指示しています。
そのようなマッピングが Perforce サーバになかった場合（これは Perforce を使う分にはまったく問題ないやり方ですが）でも、git-p4 に対してブランチのマッピングがどのようになっているかを指示でき、同じ結果が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init project
Initialized empty Git repository in /tmp/project/.git/
<span style="font-weight: bold">$</span> cd project
<span style="font-weight: bold">$</span> git config git-p4.branchList main:dev
<span style="font-weight: bold">$</span> git clone --detect-branches //depot/project@all .</code></pre>
</figure>
<p>設定値 <code class="literal">git-p4.branchList</code> に <code class="literal">main:dev</code> を設定すると、 “main” と “dev” がいずれもブランチであること、2つめのブランチは1つめのブランチの子であることを git-p4 へ示します。</p>
<p>ここで <code class="literal">git checkout -b dev p4/project/dev</code> を実行してからコミットを作成した場合でも、 git-p4 は充分に賢いので、 <code class="literal">git p4 submit</code> を実行した際には正しいブランチを対象にしてくれます。
なお、残念なことに、 git-p4 ではシャロークローンと複数ブランチを混ぜて使うことができません。巨大なプロジェクトにおいて複数のブランチで作業したい場合、ブランチごとに <code class="literal">git p4 clone</code> を実行する必要があります。</p>
<p>また、ブランチの作成や統合には、 Perforce クライアントを使用する必要があります。
git-p4 にできるのは既存のブランチに対する同期と送信だけで、それも対象にできるのはリニアなチェンジセットを一度にひとつだけです。
Git で2つのブランチをマージして新しいチェンジセットを送信しても、一塊りのファイルの変更として記録されるだけです。マージの対象となったブランチはどれかといったメタデータは失われてしまいます。</p>
</section>
</section>
<section class="sect3" title="Git と Perforce のまとめ">
<h4 id="_git_と_perforce_のまとめ">Git と Perforce のまとめ</h4>
<p>git-p4 は、 Git のワークフローを Perforce サーバ上で使用できるようにします。また、それを非常にうまいやり方で可能にします。
ですが、大元を管理しているのはあくまで Perforce であり、 Git はローカルでの作業にのみ使用しているということは忘れないでください。
Git のコミットの共有については特に気をつけてください。他のメンバーが使用しているリモートがある場合、 Perforce サーバに送信していないコミットをプッシュしないよう気をつけてください。</p>
<p>ソース管理のクライアントに Perforce と Git を自由に混ぜて使いたい場合、さらにサーバの管理者を説得してインストールの許可を貰える場合、Git Fusion は Git を Perforce サーバ用の第一級のバージョン管理クライアントにしてくれます。</p>
</section>
</section>
<section class="sect2" title="Git と TFS">
<h3 id="_git_と_tfs">Git と TFS</h3>
<p>
</p>
<p>Git は Windows を利用する開発者の間でもよく使われるようになってきています。 Windows 上でコードを書いているのなら、 Microsoft の Team Foundation Server (TFS) を使用することもあるでしょう。
TFS はコラボレーションスイートで、不具合および作業成果物に対するトラッキング、 Scrum やその他の開発プロセスのサポート、コードレビュー、そしてバージョン管理といった機能が含まれています。
ここがちょっとややこしいところなのですが、 <strong>TFS</strong> 自体はサーバで、ソースコード管理には、 Git や TFS 専用のバージョン管理システム（ <strong>TFVC</strong> (Team Foundation Version Control) とも呼ばれる）をサポートしています。
TFS の Git サポートは幾分新しい機能（バージョン2013から搭載）なので、それ以前からあったツールはどれも、実際にはほぼ TFVC だけを使用している場合であっても、バージョン管理部分のことを “TFS” と呼んでいます。</p>
<p>所属しているチームは TFVC を使用しているけれど、あなた自身はバージョン管理のクライアントに Git を使用したいという場合には、そのためのプロジェクトがあります。</p>
<section class="sect3" title="どちらのツールを使うか">
<h4 id="_どちらのツールを使うか">どちらのツールを使うか</h4>
<p></p>
<p>実際には、ツールは2つあります。 git-tf と git-tfs です。</p>
<p>git-tfs （ <a href="https://github.com/git-tfs/git-tfs" class="link">https://github.com/git-tfs/git-tfs</a> から入手できます）は .NET プロジェクトで、（これを書いている時点では）Windows でのみ動作します。
git-tfs は、Git リポジトリに対する操作に libgit2 の .NET バインディングを使用しています。libgit2 はライブラリ指向の Git の実装で、処理性能が高く、また Git の内部に対して柔軟な操作が行えるようになっています。
libgit2 は Git の機能を網羅的に実装してはいないため、その差を埋めるために、 git-tfs の一部の操作では実際にはコマンドライン版の Git クライアントが呼び出されています。そのため、Git リポジトリに対する操作に関して、git-tfs の設計に起因した制約は特にありません。
git-tfs は、 TFS サーバの操作に Visual Studio のアセンブリを使用しているため、TFVC 向け機能は非常に成熟しています。
また、これは Visual Studio のアセンブリにアクセスできる必要があるということでもあります。そのため、比較的新しいバージョンの Visual Studio （Visual Studio 2010以降の任意のエディション。バージョン2012以降の Visual Studio Express でもよい）か、Visual Studio SDK のインストールが必要です。</p>
<p>git-tf （ホームページは <a href="https://gittf.codeplex.com" class="link">https://gittf.codeplex.com</a> ）は Java プロジェクトで、Java実行環境のあるあらゆるコンピュータで実行できます。
git-tf は Git リポジトリに対する操作に JGit （JVM 用の Git の実装）を使用しているため、 Git の機能という観点においては事実上制約はありません。
しかし、 TFVC に対するサポートは git-tfs と比較すると限定的です – 例えば、ブランチをサポートしていません。</p>
<p>どちらのツールにも長所と短所があり、また一方よりもう一方が向いている状況というのはいくらでもあります。
本書では、2つのツールの基本的な使用法について取り上げます。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>以降の手順に従って操作を行うには、 TFVC ベースのリポジトリへのアクセス権が必要です。
そのようなリポジトリは Git や Subversion のリポジトリほど世の中にありふれたものではないので、自前で作成する必要があるかもしれません。
この場合、 Codeplex (<a href="https://www.codeplex.com" class="link">https://www.codeplex.com</a>) や Visual Studio Online (<a href="http://www.visualstudio.com" class="link">http://www.visualstudio.com</a>) を利用するのがよいでしょう。</p>
</div>
</aside>
</section>
<section class="sect3" title="使いはじめる: git-tf の場合">
<h4 id="_使いはじめる_code_class_literal_git_tf_code_の場合">使いはじめる: <code class="literal">git-tf</code> の場合</h4>
<p>最初に行うことは、あらゆる Git プロジェクトと同様、クローンです。
 <code class="literal">git-tf</code> は次のような感じです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git</code></pre>
</figure>
<p>最初の引数は TFVC コレクションの URL で、2番目の引数は <code class="literal">$/プロジェクト/ブランチ</code> の形式になっており、3番目の引数はローカルに作成する Git リポジトリのパスです（3番目の引数はオプショナルです）。
git-tf は一度にひとつのブランチしか扱えません。別の TFVC ブランチへチェックインしたい場合は、対象のブランチから新しくクローンを作成する必要があります。</p>
<p>次のコマンドで、フル機能の Git リポジトリが作成できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd project_git
<span style="font-weight: bold">$</span> git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</code></pre>
</figure>
<p>これは <em>シャロー</em> クローンと言われるもので、最新のチェンジセットだけがダウンロードされます。
TFVC は、各クライアントが歴史の完全なコピーを持つようには設計されていません。そのため git-tf は、幾分高速な、最新のバージョンだけを取得する方法をデフォルトとしています。</p>
<p>時間があるなら、プロジェクトの歴史全体をクローンしてみるといいでしょう。 <code class="literal">--deep</code> オプションを使用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main <span style="font-weight: bold; font-style: italic">\</span>
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
<span style="font-weight: bold">$</span> cd project_git
<span style="font-weight: bold">$</span> git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard</code></pre>
</figure>
<p><code class="literal">TFS_C35189</code> のような名前のタグに注目してください。これは、Git のどのコミットが、 TFVC のどのチェンジセットに対応しているかを分かりやすくするための機能です。
タグで表現するというのは上手い方法です。簡単な log コマンドだけで、どのコミットが TFVC 中のどのスナップショットに対応しているか確認できます。
なお、このタグ付けは必須ではありません（実際、 <code class="literal">git config git-tf.tag false</code> で無効にできます） – git-tf では、コミットとチェンジセットとのマッピングは <code class="literal">.git/git-tf</code> に保存されています。</p>
</section>
<section class="sect3" title="使いはじめる: git-tfs の場合">
<h4 id="_使いはじめる_code_class_literal_git_tfs_code_の場合">使いはじめる: <code class="literal">git-tfs</code> の場合</h4>
<p>git-tfs のクローン処理は、 git-tf とは少し異なります。
見てみましょう。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs clone --with-branches \
    https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository <span style="font-weight: bold">in</span> C<span style="border: 1px solid #FF0000">:</span>/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found<span style="border: 1px solid #FF0000">:</span>
- $/tfvc-test/featureA
The name of the local branch will be <span style="border: 1px solid #FF0000">:</span> featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674</code></pre>
</figure>
<p><code class="literal">--with-branches</code> フラグに注意してください。
git-tfs では TFVC のブランチを Git のブランチへマッピングできます。ここで <code class="literal">--with-branches</code> フラグは、 git-tfs に対し、すべての TFVC ブランチについて、対応するブランチをローカルの Git に作成するよう指示しています。
TFS 上で一度でもブランチの作成やマージを行っている場合、このオプションを指定することを強くお勧めします。ただし、このオプションは TFS 2010 より古いバージョンのサーバでは動作しません – それ以前のリリースでは “ブランチ” はただのフォルダだったためです。 git-tfs は単なるフォルダからはそのような指示は行えません。</p>
<p>結果の Git リポジトリを見てみましょう。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/<span style="font-weight: bold">default</span>, master) Hello
* b75da1a New project
PS&gt; git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author<span style="border: 1px solid #FF0000">:</span> Ben Straub &lt;ben@straub.cc&gt;
Date<span style="border: 1px solid #FF0000">:</span>   Fri Aug 1 03<span style="border: 1px solid #FF0000">:</span>41<span style="border: 1px solid #FF0000">:</span>59 2014 +0000

    Hello

    git-tfs-id<span style="border: 1px solid #FF0000">:</span> [https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16</code></pre>
</figure>
<p>2つのローカルブランチ <code class="literal">master</code> と <code class="literal">featureA</code> があり、それぞれ最初のクローンの開始位置（ TFVC の <code class="literal">Trunk</code> ）と、子のブランチ（ TFVC の <code class="literal">featureA</code> ）を表しています。
また “リモート” <code class="literal">tfs</code> にも <code class="literal">default</code> と <code class="literal">featureA</code> の2つの参照があり、これは TFVC のブランチを表現しています。
git-tfs はクローン元のブランチを <code class="literal">tfs/default</code> へマッピングし、それ以外のブランチにはそれぞれのブランチ名を付与します。</p>
<p>もうひとつ注意すべき点として、コミットメッセージにある <code class="literal">git-tfs-id:</code> という行があります。
タグとは異なり、このマーカーは git-tfs が TFVC のチェンジセットを Git のコミットへ対応づけるのに使用しています。
これは、TFVC にプッシュする前と後とで Git のコミットの SHA-1 ハッシュが異なるということを暗黙的に意味しています。</p>
</section>
<section class="sect3" title="git-tf[s] のワークフロー">
<h4 id="_git_tf_s_のワークフロー">git-tf[s] のワークフロー</h4>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>どちらのツールを使用するにせよ、問題を避けるため、次の2つの Git の設定値をセットする必要があります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config set --local core.ignorecase=true
<span style="font-weight: bold">$</span> git config set --local core.autocrlf=false</code></pre>
</figure>
</div>
</aside>
<p>当たり前ですが、次はプロジェクトに対して作業を行いたいことと思います。
TFVC および TFS には、ワークフローをややこしくする機能がいくつかあります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">TFVC 上に現れないフィーチャーブランチがあると、ややこしさが増します。
これには、TFVC と Git とでブランチを表現する方法が <strong>まったく</strong> 異なることが関係しています。</span>
</li>
<li>
<span class="principal">TFVC では、ユーザがサーバからファイルを “チェックアウト” して、他の誰も編集できないようにロックを掛けられることを認識しておいてください。
ローカルリポジトリ上でファイルを編集する妨げには当然なりませんが、変更を TFVC サーバへプッシュする段になって邪魔になるかもしれません。</span>
</li>
<li>
<span class="principal">TFS には “ゲート” チェックインという概念があります。これは、チェックインが許可されるには、 TFS のビルドとテストのサイクルが正常に終了する必要がある、というものです。
これは TFVC の “シェルブ” 機能を使用していますが、これについてはここでは深入りしません。
  手作業でなら、git-tf でもこの方式をまねることはできます。 git-tfs はこれを考慮した <code class="literal">checkintool</code> コマンドを提供しています。</span>
</li>
</ol>
</div>
<p>話を簡潔にするため、ここで取り上げるのは、これらの問題を避けたり起こらないようにした、ハッピーな手順です。</p>
</section>
<section class="sect3" title="ワークフロー: git-tf の場合">
<h4 id="_ワークフロー_code_class_literal_git_tf_code_の場合">ワークフロー: <code class="literal">git-tf</code> の場合</h4>
<p>ここでは、いくつか作業を終えて、 <code class="literal">master</code> に Git のコミットを2つ作成し、作業の成果を TFVC サーバで共有する準備ができているものとします。
Git リポジトリはこんな内容です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p><code class="literal">4178a82</code> のコミットでスナップショットを取って、 TFVC サーバへプッシュしたいものとします。
大事なことから先にとりかかりましょう。最後にリポジトリへ接続した後に、チームの他のメンバーが何か作業をしていなかったか見てみます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>やはり、他の誰かが作業をしているようです。歴史が分岐しています。
これは Git が得意とするところですが、進め方は2種類あります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">Git ユーザなら、マージコミットを行うのが自然に感じられるでしょう（ <code class="literal">git pull</code> が行うのがマージコミットなので）。 git-tf では単に <code class="literal">git tf pull</code> とすればマージコミットが行えます。
ですが、ここで注意が必要なのは、 TFVC はこれを自然とは考えないということです。マージコミットをプッシュしたら、歴史は Git 側と TFVC 側とで異なる見た目になりだし、ややこしいことになります。
一方、すべての変更をひとつのチェンジセットとして送信しようとしているのであれば、おそらくそれがもっとも簡単な選択肢です。</span>
</li>
<li>
<span class="principal">リベースを行うと、歴史がリニアになります。つまり、 Git のコミットひとつひとつを TFVC のチェンジセットへ変換する選択肢がとれるということです。
これが、以降の選択肢をもっとも広く取れる方法なので、この方法をお勧めします。git-tf でも、<code class="literal">git tf pull --rebase</code> で簡単に行えるようになっています。</span>
</li>
</ol>
</div>
<p>どの方法をとるかはあなた次第です。
この例では、リベースする方法をとったとします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>さて、これで TFVC サーバへチェックインする準備ができました。
git-tf では、直近のチェンジセット以降のすべての変更を単一のチェンジセットにまとめる（ <code class="literal">--shallow</code> 、こっちがデフォルト）か、Git のコミットそれぞれに対して新しくチェンジセットを作成する（ <code class="literal">--deep</code> ）かを選択できます。
この例では、単一のチェンジセットにまとめる方法をとったとします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tf checkin -m <span style="font-style: italic">&#39;Updating readme and code&#39;</span>
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
<span style="font-weight: bold">$</span> git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</figure>
<p>新しくタグ <code class="literal">TFS_C35348</code> ができています。これは、 TFVC がコミット <code class="literal">5a0e25e</code> とまったく同じスナップショットを格納していることを意味します。
ここが重要なのですが、Git の各コミットが、すべて TFVC 側と対応づいている必要はありません。例えば、コミット <code class="literal">6eb3eb5</code> は、 TFVC サーバには存在しません。</p>
<p>以上が主なワークフローです。
他にも、考慮すべき点として気をつけるべきものが2つほどあります。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">ブランチはできません。
git-tf にできるのは、 TFVC のブランチから、 Git のリポジトリを作ることだけで、それも一度にひとつずつしか作れません。</span>
</li>
<li>
<span class="principal">共同作業の際は、 TFVC と Git のいずれかだけを使用し、両方は使用しないでください。
ひとつの TFVC リポジトリから、 git-tf で複数のクローンを作成した場合、各コミットの SHA-1 ハッシュそれぞれ異なります。コミットが作成されます。これは終わることのない頭痛の種になります。</span>
</li>
<li>
<span class="principal">チームのワークフローに Git との協調作業が含まれており、定期的に TFVC との同期を取る場合、 TFVC へ接続する Git リポジトリはひとつだけにしてください。</span>
</li>
</ul>
</div>
</section>
<section class="sect3" title="ワークフロー: git-tfs の場合">
<h4 id="_ワークフロー_code_class_literal_git_tfs_code_の場合">ワークフロー: <code class="literal">git-tfs</code> の場合</h4>
<p>git-tfs を使用した場合と同じシナリオを見ていきましょう。
Git リポジトリには、 <code class="literal">master</code> ブランチに対して行った新しいコミットが入っています。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/<span style="font-weight: bold">default</span>) Hello
* b75da1a New project</code></pre>
</figure>
<p>さて、我々が作業している間に、他の誰かが作業をしていなかったか見てみましょう。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS&gt; git log --all --oneline --graph --decorate
* aea74a0 (tfs/<span style="font-weight: bold">default</span>) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>同僚が新しく TFVC のチェンジセットを追加しており、それが新しいコミット <code class="literal">aea74a0</code> として表示されている他に、リモートブランチ <code class="literal">tfs/default</code> が移動されていることがわかりました。</p>
<p>git-tf と同様に、この分岐した歴史を処理する基本的な方法は2つあります。</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">歴史をリニアに保つためにリベースを行う。</span>
</li>
<li>
<span class="principal">実際に起こったことを残しておくためマージを行う。</span>
</li>
</ol>
</div>
<p>この例では、Git の各コミットが TFVC のチェンジセットになる “ディープ” なチェックインを行おうとしているので、リベースをします。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git rebase tfs/<span style="font-weight: bold">default</span>
First, rewinding head to replay your work on top of it...
Applying<span style="border: 1px solid #FF0000">:</span> update readme
Applying<span style="border: 1px solid #FF0000">:</span> update code
PS&gt; git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/<span style="font-weight: bold">default</span>) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>これで、コードを TFVC サーバへチェックインして、 作業を完了する準備ができました。
ここでは <code class="literal">rcheckin</code> コマンドを使用し、HEAD から始めて最初の <code class="literal">tfs</code> リモートブランチが見つかるまでの Git の各コミットに対して、 TFVC のチェンジセットを作成します（ <code class="literal">checkin</code> コマンドでは、 Git のコミットをスカッシュするのと同様に、チェンジセットをひとつだけ作成します）。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs rcheckin
Working with tfs remote<span style="border: 1px solid #FF0000">:</span> <span style="font-weight: bold">default</span>
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 <span style="font-style: italic">&#39;update readme&#39;</span>
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 <span style="font-style: italic">&#39;update code&#39;</span>
 edit .git\tfs\<span style="font-weight: bold">default</span>\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS&gt; git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/<span style="font-weight: bold">default</span>, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>TFVC サーバへのチェックインが成功した後に行われている処理に注目してください。 git-tfs は直前の処理結果に対して、残りの作業結果をリベースしています。
これは、コミットメッセージの末尾に <code class="literal">git-tfs-id</code> フィールドを追記しており、SHA-1 ハッシュが変化するためです。
これは仕様通りの動作であり、何も心配することはありません。ですが、そのような変更がなされていることは（特に、 Git のコミットを他の人と共有している場合は）認識しておいてください。</p>
<p>TFS には、ワークアイテム、レビュー依頼、ゲートチェックインなど、バージョン管理システムと統合されている機能が数多くあります。
これらの機能をコマンドラインツールだけで使うのは大変ですが、幸いなことに、  git-tfs ではグラフィカルなチェックインツールを簡単に起動できるようになっています。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs checkintool
PS&gt; git tfs ct</code></pre>
</figure>
<p>だいたいこんな感じで表示されます。</p>
<figure class="image">
<div class="content">
<img src="images/git-tfs-ct.png" alt="git-tfs のチェックインツール"/>
</div>
<figcaption>Figure 3. git-tfs のチェックインツール</figcaption>
</figure>
<p>TFS ユーザは見慣れていると思いますが、これは Visual Studio から表示されるものと同じダイアログです。</p>
<p>git-tfs では TFVC のブランチを Git のリポジトリから管理することもできます。
例として、ひとつ作成してみましょう。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs branch $/tfvc-test/featureBee
The name of the local branch will be <span style="border: 1px solid #FF0000">:</span> featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS&gt; git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/<span style="font-weight: bold">default</span>, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</figure>
<p>TFVC でブランチを作成するということは、そのブランチが存在する場所にチェンジセットを追加するということなので、結果としてそれは Git のコミットへ反映されます。
git-tfs はリモートブランチ <code class="literal">tfs/featureBee</code> の <strong>作成は</strong> しましたが、 <code class="literal">HEAD</code> は相変わらず <code class="literal">master</code> を指していることに注意してください。
新しく作成したブランチ上で作業をしたい場合は、コミット <code class="literal">1d54865</code> から新しいコミットを作成することになりますが、この場合は恐らくそのコミットから新しくトピックブランチを作成することになるでしょう。</p>
</section>
<section class="sect3" title="Git と TFS のまとめ">
<h4 id="_git_と_tfs_のまとめ">Git と TFS のまとめ</h4>
<p>git-tf と git-tfs は、いずれも TFVC サーバに接続するための優れたツールです。
これらのツールにより、チーム全体を Git へ移行することなしに、ローカルで Git のパワーを享受でき、中央の TFVC サーバを定期的に巡回しなくて済み、開発者としての生活をより楽にすることができます。
Windows 上で作業をしているのなら（チームが TFS を使用しているなら多分そうだと思いますが）、機能がより網羅的な git-tfs を使用したいことと思います。また別のプラットフォーム上で作業をしているのなら、より機能の限られている git-tf を使用することになると思います。
この章で取り上げているほとんどのツールと同様、バージョン管理システムのうちひとつだけを正式なものとして、他は従属的な使い方にしておくべきです – Git か TFVC の両方ではなく、いずれか片方を共同作業の中心に置くべきです。</p>
</section>
</section>
</section>
<section class="sect1" title="Git へ移行する">
<h2 id="r_migrating">Git へ移行する</h2>
<p></p>
<p>Git 以外のバージョン管理システムで管理しているコードベースがあるけれど、Git を使いはじめることにした、という場合、どうにかしてプロジェクトを移行する必要があります。
この節では、主要なバージョン管理システム用のインポーターについて触れた後、独自のインポーターを自前で開発する方法を実際に見ていきます。
ここでは、いくつかの大きくてプロ仕様のソースコード管理システムからデータをインポートする方法を学びます。これは、移行するユーザの多くがそういったシステムのユーザであるのと、そういったシステムでは高品質なツールが簡単に手に入るためです。</p>
<section class="sect2" title="Subversion">
<h3 id="_subversion">Subversion</h3>
<p>
</p>
<p>先ほどの節で <code class="literal">git svn</code> の使い方を読んでいれば、話は簡単です。まず <code class="literal">git svn clone</code> でリポジトリを作り、そして Subversion サーバーを使うのをやめ、新しい Git サーバーにプッシュし、あとはそれを使い始めればいいのです。これまでの歴史が欲しいのなら、それも Subversion サーバーからプルすることができます (多少時間がかかります)。</p>
<p>しかし、インポートは完全ではありません。また時間もかかるので、正しくやるのがいいでしょう。まず最初に問題になるのが作者 (author) の情報です。Subversion ではコミットした人すべてがシステム上にユーザーを持っており、それがコミット情報として記録されます。たとえば先ほどの節のサンプルで言うと <code class="literal">schacon</code> がそれで、<code class="literal">blame</code> の出力や <code class="literal">git svn log</code> の出力に含まれています。これをうまく Git の作者データとしてマップするには、Subversion のユーザーと Git の作者のマッピングが必要です。<code class="literal">users.txt</code> という名前のファイルを作り、このような書式でマッピングを記述します。</p>
<figure class="listing">
<pre class="source language-"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</figure>
<p>SVN で使っている作者の一覧を取得するには、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> svn log --xml | grep author | sort -u | <span style="font-weight: bold; font-style: italic">\</span>
  perl -pe <span style="font-style: italic">&#39;s/.*&gt;(.*?)&lt;.*/$1 = /&#39;</span></code></pre>
</figure>
<p>これは、まずログを XML フォーマットで生成します。その中から作者の情報を含む行だけを抽出し、重複を削除して、XML タグを除去します。
（ちょっと見ればわかりますが、これは <code class="literal">grep</code> や <code class="literal">sort</code>、そして <code class="literal">perl</code> といったコマンドが使える環境でないと動きません）
この出力を <code class="literal">users.txt</code> にリダイレクトし、そこに Git のユーザーデータを書き足していきます。</p>
<p>このファイルを <code class="literal">git svn</code> に渡せば、作者のデータをより正確にマッピングできるようになります。また、Subversion が通常インポートするメタデータを含めないよう <code class="literal">git svn</code> に指示することもできます。そのためには <code class="literal">--no-metadata</code> を <code class="literal">clone</code> コマンドあるいは <code class="literal">init</code> コマンドに渡します。そうすると、 <code class="literal">import</code> コマンドは次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git svn clone http://my-project.googlecode.com/svn/ <span style="font-weight: bold; font-style: italic">\</span>
      --authors-file=users.txt --no-metadata -s my_project</code></pre>
</figure>
<p>これで、Subversion をちょっとマシにインポートした <code class="literal">my_project</code> ディレクトリができあがりました。コミットがこんなふうに記録されるのではなく、</p>
<figure class="listing">
<pre class="source language-"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</figure>
<p>次のように記録されています。</p>
<figure class="listing">
<pre class="source language-"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</figure>
<p>Author フィールドの見た目がずっとよくなっただけではなく、<code class="literal">git-svn-id</code> もなくなっています。</p>
<p>インポートした後には、ちょっとした後始末も行ったほうがよいでしょう。
たとえば、<code class="literal">git svn</code> が作成した変な参照は削除しておくべきです。
まずはタグを移動して、奇妙なリモートブランチではなくちゃんとしたタグとして扱えるようにします。そして、残りのブランチを移動してローカルで扱えるようにします。</p>
<p>タグを Git のタグとして扱うには、次のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
<span style="font-weight: bold">$</span> rm -Rf .git/refs/remotes/origin/tags</code></pre>
</figure>
<p>これは、リモートブランチのうち <code class="literal">remotes/origin/tags/</code> で始まる名前のものを、実際の (軽量な) タグに変えます。</p>
<p>次に、<code class="literal">refs/remotes</code> 以下にあるそれ以外の参照をローカルブランチに移動します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cp -Rf .git/refs/remotes/origin/* .git/refs/heads/
<span style="font-weight: bold">$</span> rm -Rf .git/refs/remotes/origin</code></pre>
</figure>
<p>このとき、Subversionではブランチが1つだったのにもかかわらず、名前が`@xxx`（xxxは数字）で終わる余分なブランチがいくつか出来てしまうことがあります。Subversionの「ペグ・リビジョン」という機能が原因なのですが、Gitにはこれと同等の機能は存在しません。よって、`git svn`コマンドはブランチ名にsvnのバージョン番号をそのまま追加します。svnでペグ・リビジョンをブランチに設定するときとまさに同じやり方です。もうペグ・リビジョンがいらないのであれば、`git branch -d`コマンドで削除してしまいましょう。</p>
<p>インポートが終わり、過去のブランチはGitのブランチへ、過去のタグはGitのタグへと変換できました。</p>
<p>最後に後始末についてです。残念なことに、`git svn`は`trunk`という名前の余計なブランチを生成してしまいます。Subversionにおけるデフォルトブランチではあるのですが、`trunk`の参照が指す場所は`master`と同じです。`master`のほうが用語としてもGitらしいですから、余分なブランチは削除してしまいましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git branch -d trunk</code></pre>
</figure>
<p>これで、今まであった古いブランチはすべて Git のブランチとなり、古いタグもすべて Git のタグになりました。最後に残る作業は、新しい Git サーバーをリモートに追加してプッシュすることです。自分のサーバーをリモートとして追加するには以下のようにします｡</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@my-git-server:myrepository.git</code></pre>
</figure>
<p>すべてのブランチやタグを一緒にプッシュするには、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --all
<span style="font-weight: bold">$</span> git push origin --tags</code></pre>
</figure>
<p>これで、ブランチやタグも含めたすべてを、新しい Git サーバーにきれいにインポートできました。</p>
</section>
<section class="sect2" title="Mercurial">
<h3 id="_mercurial">Mercurial</h3>
<p></p>
<p>Mercurial と Git は、バージョンの表現方法がよく似ており、また Git の方が少し柔軟性が高いので、Mercurial から Git へのリポジトリの変換は非常に素直に行えます。変換には "hg-fast-export" というツールを使用します。このツールは次のコマンドで取得できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</code></pre>
</figure>
<p>変換の最初のステップとして、変換の対象となる Mercurial リポジトリのクローンを取得します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</figure>
<p>次のステップでは、author マッピングファイルを作成します。
チェンジセットの author フィールドへ指定できる内容は、Git より Mercurial の方が制限がゆるいので、これを機に内容を見直すのがよいでしょう。
author マッピングファイルは、<code class="literal">bash</code> シェルなら次のワンライナーで生成できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd /tmp/hg-repo
<span style="font-weight: bold">$</span> hg log | grep user: | sort | uniq | sed <span style="font-style: italic">&#39;s/user: *//&#39;</span> &gt; ../authors</code></pre>
</figure>
<p>プロジェクトの歴史の長さによりますが、このコマンドの実行には数秒かかります。実行後には、 <code class="literal">/tmp/authors</code> ファイルが次のような内容で作成されているはずです。</p>
<figure class="listing">
<pre class="source language-"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</figure>
<p>この例では、同じ人（Bob）がチェンジセットを作成したときの名前が4パターンあり、そのうち1つだけが標準に合った書き方で、また別の1つは Git のコミットとしては完全に無効なように見えます。
hg-fast-export では、このような状態を修正する場合、修正したい行の末尾に <code class="literal">={修正後の氏名とメールアドレス}</code> を追加し、変更したくないユーザ名の行はすべて削除します。
すべてのユーザ名が正しいなら、このファイルは必要ありません。
この例では、ファイルの内容を次のようにします。</p>
<figure class="listing">
<pre class="source language-"><code>bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;</code></pre>
</figure>
<p>次のステップでは、新しい Git リポジトリを作成して、エクスポート用スクリプトを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init /tmp/converted
<span style="font-weight: bold">$</span> cd /tmp/converted
<span style="font-weight: bold">$</span> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</figure>
<p>hg-fast-export に対して、 <code class="literal">-r</code> フラグで、変換の対象となる Mercurial リポジトリの場所を指定しています。また、 <code class="literal">-A</code> フラグで、author マッピングファイルの場所を指定しています。
このスクリプトは、Mercurial のチェンジセットを解析して、Git の "fast-import" 機能（詳細はまた後で説明します）用のスクリプトへ変換します。
これには少し時間がかかります（ネットワーク経由の場合と比べれば <em>かなり</em> 速いですが）。出力は非常に長くなります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc&#39;d objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

<span style="font-weight: bold">$</span> git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</figure>
<p>作業はこれだけです。
すべての Mercurial のタグは Git のタグに変換され、 Mercurial のブランチとブックマークは Git のブランチに変換されています。
これで、リポジトリを新しいサーバ側へプッシュする準備が整いました。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote add origin git@my-git-server:myrepository.git
<span style="font-weight: bold">$</span> git push origin --all</code></pre>
</figure>
</section>
<section class="sect2" title="Perforce">
<h3 id="r_perforce_import">Perforce</h3>
<p></p>
<p>次のインポート元としてとりあげるのは Perforce です。
前述の通り、 Git と Perforce を相互接続するには2つの方法があります。 git-p4 と Perforce Git Fusion です。</p>
<section class="sect3" title="Perforce Git Fusion">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<p>Git Fusion を使えば、移行のプロセスに労力はほぼかかりません。（ <a id="xref-r_p4_git_fusion" href="#r_p4_git_fusion" class="xref">Git Fusion</a> で述べた通り）設定ファイルで、プロジェクトの設定、ユーザのマッピング、およびブランチの設定を行った後、リポジトリをクローンすれば完了です。
Git Fusion がネイティブな Git リポジトリと類似の環境を提供してくれるので、お望みとあればいつでも、本物のネイティブな Git リポジトリへプッシュする準備はできているというわけです。
また、お望みなら、 Perforce を Git のホストとして使用することもできます。</p>
</section>
<section class="sect3" title="git-p4">
<h4 id="r_git_p4">git-p4</h4>
<p>git-p4 はインポート用ツールとしても使えます。
例として、 Perforce Public Depot から Jam プロジェクトをインポートしてみましょう。
クライアントをセットアップするには、環境変数 P4PORT をエクスポートして Perforce ディポの場所を指すようにしなければなりません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> export P4PORT=public.perforce.com:1666</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>以降の手順に従うには、アクセスできる Perforce のディポが必要です。
この例では public.perforce.com にある公開ディポを使用していますが、アクセス権があればどんなディポでも使用できます。</p>
</div>
</aside>
<p></p>
<p><code class="literal">git p4 clone</code> コマンドを実行して、 Perforce サーバから Jam プロジェクトをインポートします。ディポとプロジェクトのパス、およびプロジェクトのインポート先のパスを指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</figure>
<p>このプロジェクトにはブランチがひとつしかありませんが、ブランチビューで設定されたブランチ（またはディレクトリ）があるなら、 <code class="literal">git p4 clone</code> に <code class="literal">--detect-branches</code> フラグを指定すれば、プロジェクトのブランチすべてをインポートできます。
この詳細については <a id="xref-r_git_p4_branches" href="#r_git_p4_branches" class="xref">ブランチ</a> を参照してください。</p>
<p>この時点で作業はおおむね完了です。
<code class="literal">p4import</code> ディレクトリへ移動して <code class="literal">git log</code> を実行すると、インポートした成果物を確認できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 7304]</code></pre>
</figure>
<p><code class="literal">git-p4</code> が各コミットメッセージに識別子を追加しているのが分かると思います。
この識別子はそのままにしておいてもかまいません。後で万一 Perforce のチェンジ番号を参照しなければならなくなったときのために使えます。しかし、もし削除したいのなら、新しいリポジトリ上で何か作業を始める前の、この段階で消しておきましょう。

<code class="literal">git filter-branch</code> を使えば、この識別子を一括削除することができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git filter-branch --msg-filter <span style="font-style: italic">&#39;sed -e &quot;/^\[git-p4:/d&quot;&#39;</span>
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>
</figure>
<p><code class="literal">git log</code> を実行すると、コミットの SHA-1 チェックサムは変わりましたが、 <code class="literal">git-p4</code> という文字列がコミットメッセージから消えたことが分かると思います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</figure>
<p>これで、インポート結果を新しい Git サーバへプッシュする準備ができました。</p>
</section>
</section>
<section class="sect2" title="TFS">
<h3 id="r_git_tfs">TFS</h3>
<p></p>
<p>あなたのチームで、ソース管理を TFVC から Git へ移行したいということになった場合、できる限り最高の忠実度で変換を行いたいことと思います。
そのため、相互運用についてのセクションでは git-tfs と git-tf の両方を取り上げましたが、本セクションでは git-tfs のみを取り上げます。これは git-tfs はブランチをサポートしている一方、 git-tf ではブランチの使用が禁止されており、対応が難しいためです。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>以下で述べるのは、一方通行の変換です。
できあがった Git リポジトリを、元の TFVC プロジェクトと接続することはできません。</p>
</div>
</aside>
<p>最初に行うのはユーザ名のマッピングです。
TFVC ではチェンジセットの author フィールドの内容をかなり自由に設定できますが、 Git では人間に読める形式の名前とメールアドレスが必要です。
この情報は、 <code class="literal">tf</code> コマンドラインクライアントで次のようにして取得できます。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</figure>
<p>このコマンドは、プロジェクトの歴史からすべてのチェンジセットの情報を取ってきて、 AUTHORS_TMP ファイルへ出力します。このファイルは、 <em>User</em> カラム（2番目のカラム）のデータを抽出する際に使用します。
AUTHORS_TMP ファイルを開いて、2番目のカラムの開始位置と終了位置を確認したら、次のコマンドラインの、 <code class="literal">cut</code> コマンドの引数  <code class="literal">11-20</code> を、それぞれ開始位置と終了位置で置き換えてください。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | uniq | sort &gt; AUTHORS</code></pre>
</figure>
<p>この <code class="literal">cut</code> コマンドは、各行の11文字目から20文字目だけを抽出します。
また、この <code class="literal">tail</code>  コマンドは、最初の2行（フィールドヘッダと、下線のアスキーアート）を読み飛ばします。
この処理の結果は、重複を排除するためパイプで <code class="literal">uniq</code> コマンドへ送られた上で、 <code class="literal">AUTHORS</code> ファイルへ保存されます。
次のステップは手作業です。git-tfs でこのファイルを利用するには、各行は次のフォーマットに従っている必要があります。</p>
<figure class="listing">
<pre class="source language-text"><code><span></span>DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</figure>
<p>イコール記号の左側にあるのは TFVC の “User” フィールドの内容、右側にあるのは Git のコミットで使用されるユーザ名です。</p>
<p>このファイルを作りおえたら、次は、対象となる TFVC プロジェクト全体のクローンを作成します。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git tfs clone --with-branches --authors=AUTHORS https<span style="border: 1px solid #FF0000">:</span>//username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</figure>
<p>次は、コミットメッセージの末尾にある <code class="literal">git-tfs-id</code> セクションを消去したいことと思います。
これは、次のコマンドで行えます。</p>
<figure class="listing">
<pre class="source language-powershell"><code><span></span>PS&gt; git <span style="font-weight: bold">filter</span>-branch -f --msg-filter <span style="font-style: italic">&#39;sed &quot;s/^git-tfs-id:.*$//g&quot;&#39;</span> <span style="font-style: italic">&#39;--&#39;</span> --all</code></pre>
</figure>
<p>これは、Git-bash から <code class="literal">sed</code> コマンドを使用して、 “git-tfs-id:” で始まる行を空文字列で置き換えます。 Git は空文字列を無視します。</p>
<p>これらをすべて実施したら、新しいリモートを追加したり、ブランチをプッシュしたり、チームが Git で作業を始めたりする準備はこれで完了です。</p>
</section>
<section class="sect2" title="A Custom Importer">
<h3 id="r_custom_importer">A Custom Importer</h3>
<p>
</p>
<p>前述した以外のシステムを使っている場合は、それ用のインポートツールをオンラインで探さなければなりません。CVS、Clear Case、Visual Source Safe、あるいはアーカイブのディレクトリなど、多くのバージョン管理システムについて、品質の高いインポーターが公開されています。
これらのツールがうまく動かなかったり、もっとマイナーなバージョン管理ツールを使っていたり、あるいはインポート処理で特殊な操作をしたりしたい場合は <code class="literal">git fast-import</code> を使います。
このコマンドはシンプルな指示を標準入力から受け取って、特定の Git データを書き出します。
<code class="literal">git fast-import</code> を使えば、生の Git コマンドを使ったり、生のオブジェクトを書きだそうとしたりする（詳細は <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Gitの内側</a> を参照してください）よりは、ずっと簡単に Git オブジェクトを作ることができます。
この方法を使えばインポートスクリプトを自作することができます。必要な情報を元のシステムから読み込み、単純な指示を標準出力に出せばよいのです。
そして、このスクリプトの出力をパイプで <code class="literal">git fast-import</code> に送ります。</p>
<p>手軽に試してみるために、シンプルなインポーターを書いてみましょう。
<code class="literal">current</code> で作業をしており、プロジェクトのバックアップは時々ディレクトリまるごとのコピーで行っているものとします。バックアップディレクトリの名前は、タイムスタンプをもとに <code class="literal">back_YYYY_MM_DD</code> としています。これらを Git にインポートしてみましょう。
ディレクトリの構造は、このようになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</figure>
<p>Git のディレクトリにインポートするため、まず Git がどのようにデータを格納しているかをおさらいしましょう。
覚えているかもしれませんが、 Git は基本的にはコミットオブジェクトのリンクリストであり、コミットオブジェクトがコンテンツのスナップショットを指しています。
<code class="literal">fast-import</code> に指示しなければならないのは、コンテンツのスナップショットが何でどのコミットデータがそれを指しているのかということと、コミットデータを取り込む順番だけです。
ここでは、スナップショットをひとつずつたどって各ディレクトリの中身を含むコミットオブジェクトを作り、それらを日付順にリンクさせるものとします。</p>
<p><a id="xref--ch08-customizing-git--r_an_example_git_enforced_policy" href="ch08-customizing-git.xhtml#r_an_example_git_enforced_policy" class="xref">Git ポリシーの実施例</a> と同様、ここでも Ruby を使って書きます。Ruby を使うのは、我々が普段使っている言語であり、読みやすくしやすいためです。
このサンプルをあなたの使いなれた言語で書き換えるのも簡単でしょう。単に適切な情報を標準出力に送るだけなのだから。
また、Windows を使っている場合は、行末にキャリッジリターンを含めないように注意が必要です。<code class="literal">git fast-import</code> が想定している行末は LF だけであり、Windows で使われている CRLF は想定していません。</p>
<p>まず最初に対象ディレクトリに移動し、そのサブディレクトリを認識させます。各サブディレクトリがコミットとしてインポートすべきスナップショットとなります。
続いて各サブディレクトリへ移動し、そのサブディレクトリをエクスポートするためのコマンドを出力します。
基本的なメインループは、このようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>last_mark = <span style="font-weight: bold">nil</span>

<span style="font-style: italic"># loop through the directories</span>
Dir.chdir(ARGV[0]) <span style="font-weight: bold">do</span>
  Dir.glob(<span style="font-style: italic">&quot;*&quot;</span>).each <span style="font-weight: bold">do</span> |dir|
    <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> File.file?(dir)

    <span style="font-style: italic"># move into the target directory</span>
    Dir.chdir(dir) <span style="font-weight: bold">do</span>
      last_mark = print_export(dir, last_mark)
    <span style="font-weight: bold">end</span>
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>各ディレクトリ内で実行している <code class="literal">print_export</code> は、前のスナップショットの内容一覧とマークを受け取って、このディレクトリの内容一覧とマークを返します。このようにして、それぞれを適切にリンクさせます。
“マーク” とは <code class="literal">fast-import</code> 用語で、コミットに対する識別子を意味します。コミットを作成するときにマークをつけ、それを使って他のコミットとリンクさせます。
つまり、<code class="literal">print_export</code> メソッドで最初にやることは、ディレクトリ名からマークを生成することです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>mark = convert_dir_to_mark(dir)</code></pre>
</figure>
<p>これを行うには、まずディレクトリの配列を作り、そのインデックスの値をマークとして使います。マークは整数値でなければならないからです。
メソッドの中身はこのようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$marks = []
<span style="font-weight: bold">def</span> convert_dir_to_mark(dir)
  <span style="font-weight: bold">if</span> !$marks.include?(dir)
    $marks &lt;&lt; dir
  <span style="font-weight: bold">end</span>
  ($marks.index(dir) + 1).to_s
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>これで各コミットを表す整数値が取得できました。次に必要なのは、コミットのメタデータ用の日付です。
日付はディレクトリ名に現れているので、ここから取得します。<code class="literal">print_export</code> ファイルで次にすることは、これです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>date = convert_dir_to_date(dir)</code></pre>
</figure>
<p><code class="literal">convert_dir_to_date</code> の定義は次のようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> convert_dir_to_date(dir)
  <span style="font-weight: bold">if</span> dir == <span style="font-style: italic">&#39;current&#39;</span>
    <span style="font-weight: bold">return</span> Time.now().to_i
  <span style="font-weight: bold">else</span>
    dir = dir.gsub(<span style="font-style: italic">&#39;back_&#39;</span>, <span style="font-style: italic">&#39;&#39;</span>)
    (year, month, day) = dir.split(<span style="font-style: italic">&#39;_&#39;</span>)
    <span style="font-weight: bold">return</span> Time.local(year, month, day).to_i
  <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>これは、各ディレクトリの日付に対応する整数値を返します。
コミットのメタ情報として必要な最後の情報はコミッターのデータで、これはグローバル変数にハードコードします。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$author = <span style="font-style: italic">&#39;John Doe &lt;john@example.com&gt;&#39;</span></code></pre>
</figure>
<p>これで、コミットのデータをインポーターに流せるようになりました。
最初の情報では、今定義しているのがコミットオブジェクトであることと、どのブランチにいるのかを示しています。その後に先ほど生成したマークが続き、さらにコミッターの情報とコミットメッセージが続いた後にひとつ前のコミットが (もし存在すれば) 続きます。
コードはこのようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic"># print the import information</span>
puts <span style="font-style: italic">&#39;commit refs/heads/master&#39;</span>
puts <span style="font-style: italic">&#39;mark :&#39;</span> + mark
puts <span style="font-style: italic">&quot;committer </span><span style="font-weight: bold; font-style: italic">#{</span>$author<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>date<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> -0700&quot;</span>
export_data(<span style="font-style: italic">&#39;imported from &#39;</span> + dir)
puts <span style="font-style: italic">&#39;from :&#39;</span> + last_mark <span style="font-weight: bold">if</span> last_mark</code></pre>
</figure>
<p>タイムゾーン (-0700) をハードコードしているのは、そのほうがお手軽だったからです。
別のシステムからインポートする場合は、タイムゾーンをオフセットとして指定しなければなりません。
コミットメッセージは、次のような特殊な書式にする必要があります。</p>
<figure class="listing">
<pre class="source language-"><code>data (size)\n(contents)</code></pre>
</figure>
<p>まず最初に「data」という単語、そして読み込むデータのサイズ、改行、最後にデータがきます。
同じ書式は後でファイルのコンテンツを指定するときにも使うので、ヘルパーメソッド <code class="literal">export_data</code> を作ります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> export_data(string)
  print <span style="font-style: italic">&quot;data </span><span style="font-weight: bold; font-style: italic">#{</span>string.size<span style="font-weight: bold; font-style: italic">}\n#{</span>string<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>残っているのは、各スナップショットが持つファイルのコンテンツを指定することです。
今回の場合はどれも一つのディレクトリにまとまっているので簡単です。<code class="literal">deleteall</code> コマンドを出力し、それに続けてディレクトリ内の各ファイルの中身を出力すればよいのです。
そうすれば、Git が各スナップショットを適切に記録します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>puts <span style="font-style: italic">&#39;deleteall&#39;</span>
Dir.glob(<span style="font-style: italic">&quot;**/*&quot;</span>).each <span style="font-weight: bold">do</span> |file|
  <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> !File.file?(file)
  inline_data(file)
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>注意:多くのシステムではリビジョンを「あるコミットと別のコミットの差分」と考えているので、fast-importでもその形式でコマンドを受け取ることができます。つまりコミットを指定するときに、追加/削除/変更されたファイルと新しいコンテンツの中身で指定できるということです。
各スナップショットの差分を算出してそのデータだけを渡すこともできますが、処理が複雑になります。すべてのデータを渡して、Git に差分を算出させたほうがよいでしょう。
もし差分を渡すほうが手元のデータに適しているようなら、<code class="literal">fast-import</code> のマニュアルで詳細な方法を調べましょう。</p>
<p>新しいファイルの内容、あるいは変更されたファイルと変更後の内容を表す書式は次のようになります。</p>
<figure class="listing">
<pre class="source language-"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</figure>
<p>この 644 はモード (実行可能ファイルがある場合は、そのファイルについては 755 を指定する必要があります) を表し、inline とはファイルの内容をこの次の行に続けて指定するという意味です。<code class="literal">inline_data</code> メソッドは、このようになります。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">def</span> inline_data(file, code = <span style="font-style: italic">&#39;M&#39;</span>, mode = <span style="font-style: italic">&#39;644&#39;</span>)
  content = File.read(file)
  puts <span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">#{</span>code<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>mode<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> inline </span><span style="font-weight: bold; font-style: italic">#{</span>file<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
  export_data(content)
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>先ほど定義した <code class="literal">export_data</code> メソッドを再利用することができます。この書式はコミットメッセージの書式と同じだからです。</p>
<p>最後に必要となるのは、現在のマークを返して次の処理に渡せるようにすることです。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-weight: bold">return</span> mark</code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Windows 上で動かす場合はさらにもう一手間必要です。
先述したように、Windows の改行文字は CRLF ですが <code class="literal">git fast-import</code> は LF にしか対応していません。この問題に対応して <code class="literal">git fast-import</code> をうまく動作させるには、CRLF ではなく LF を使うよう ruby に指示しなければなりません。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span>$stdout.binmode</code></pre>
</figure>
</div>
</aside>
<p>これで終わりです。
スクリプト全体を以下に示します。</p>
<figure class="listing">
<pre class="source language-ruby"><code><span></span><span style="font-style: italic">#!/usr/bin/env ruby</span>

$stdout.binmode
$author = <span style="font-style: italic">&quot;John Doe &lt;john@example.com&gt;&quot;</span>

$marks = []
<span style="font-weight: bold">def</span> convert_dir_to_mark(dir)
    <span style="font-weight: bold">if</span> !$marks.include?(dir)
        $marks &lt;&lt; dir
    <span style="font-weight: bold">end</span>
    ($marks.index(dir)+1).to_s
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> convert_dir_to_date(dir)
    <span style="font-weight: bold">if</span> dir == <span style="font-style: italic">&#39;current&#39;</span>
        <span style="font-weight: bold">return</span> Time.now().to_i
    <span style="font-weight: bold">else</span>
        dir = dir.gsub(<span style="font-style: italic">&#39;back_&#39;</span>, <span style="font-style: italic">&#39;&#39;</span>)
        (year, month, day) = dir.split(<span style="font-style: italic">&#39;_&#39;</span>)
        <span style="font-weight: bold">return</span> Time.local(year, month, day).to_i
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> export_data(string)
    print <span style="font-style: italic">&quot;data </span><span style="font-weight: bold; font-style: italic">#{</span>string.size<span style="font-weight: bold; font-style: italic">}\n#{</span>string<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> inline_data(file, code=<span style="font-style: italic">&#39;M&#39;</span>, mode=<span style="font-style: italic">&#39;644&#39;</span>)
    content = File.read(file)
    puts <span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">#{</span>code<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>mode<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> inline </span><span style="font-weight: bold; font-style: italic">#{</span>file<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
    export_data(content)
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">def</span> print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts <span style="font-style: italic">&#39;commit refs/heads/master&#39;</span>
    puts <span style="font-style: italic">&quot;mark :</span><span style="font-weight: bold; font-style: italic">#{</span>mark<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>
    puts <span style="font-style: italic">&quot;committer </span><span style="font-weight: bold; font-style: italic">#{</span>$author<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> </span><span style="font-weight: bold; font-style: italic">#{</span>date<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic"> -0700&quot;</span>
    export_data(<span style="font-style: italic">&quot;imported from </span><span style="font-weight: bold; font-style: italic">#{</span>dir<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span>)
    puts <span style="font-style: italic">&quot;from :</span><span style="font-weight: bold; font-style: italic">#{</span>last_mark<span style="font-weight: bold; font-style: italic">}</span><span style="font-style: italic">&quot;</span> <span style="font-weight: bold">if</span> last_mark

    puts <span style="font-style: italic">&#39;deleteall&#39;</span>
    Dir.glob(<span style="font-style: italic">&quot;**/*&quot;</span>).each <span style="font-weight: bold">do</span> |file|
        <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> !File.file?(file)
        inline_data(file)
    <span style="font-weight: bold">end</span>
    mark
<span style="font-weight: bold">end</span>


<span style="font-style: italic"># Loop through the directories</span>
last_mark = <span style="font-weight: bold">nil</span>
Dir.chdir(ARGV[0]) <span style="font-weight: bold">do</span>
    Dir.glob(<span style="font-style: italic">&quot;*&quot;</span>).each <span style="font-weight: bold">do</span> |dir|
        <span style="font-weight: bold">next</span> <span style="font-weight: bold">if</span> File.file?(dir)

        <span style="font-style: italic"># move into the target directory</span>
        Dir.chdir(dir) <span style="font-weight: bold">do</span>
            last_mark = print_export(dir, last_mark)
        <span style="font-weight: bold">end</span>
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">end</span></code></pre>
</figure>
<p>このスクリプトを実行すれば、次のような結果が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
<span style="font-weight: bold">#</span> Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
<span style="font-weight: bold">#</span>!/bin/env ruby

puts &quot;Hey there&quot;
M 644 inline README.md
(...)</code></pre>
</figure>
<p>インポーターを動かすには、インポート先の Git レポジトリにおいて､インポーターの出力をパイプで <code class="literal">git fast-import</code> に渡す必要があります。
インポート先に新しいディレクトリを作成したら､以下のように <code class="literal">git init</code> を実行し、そしてスクリプトを実行してみましょう｡</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init
Initialized empty Git repository in /opt/import_to/.git/
<span style="font-weight: bold">$</span> ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc&#39;d objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</figure>
<p>ご覧のとおり、処理が正常に完了すると、処理内容に関する統計情報が表示されます。
この場合は、全部で 13 のオブジェクトからなる 4 つのコミットが 1 つのブランチにインポートされたことがわかります。
では、<code class="literal">git log</code> で新しい歴史を確認しましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</figure>
<p>きれいな Git リポジトリができていますね。
ここで重要なのは、この時点ではまだ何もチェックアウトされていないということです。作業ディレクトリには何もファイルがありません。
ファイルを取得するには、ブランチをリセットして <code class="literal">master</code> の現在の状態にしなければなりません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> ls
<span style="font-weight: bold">$</span> git reset --hard master
HEAD is now at 3caa046 imported from current
<span style="font-weight: bold">$</span> ls
README.md main.rb</code></pre>
</figure>
<p><code class="literal">fast-import</code> ツールにはさらに多くの機能があります。さまざまなモードを処理したりバイナリデータを扱ったり、複数のブランチやそのマージ、タグ、進捗状況表示などです。
より複雑なシナリオのサンプルは Git のソースコードの <code class="literal">contrib/fast-import</code> ディレクトリにあります。</p>
</section>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ">まとめ</h2>
<p>これで、Git を他のバージョン管理システムのクライアントとして使ったり、既存のリポジトリのほぼすべてを、データを失うことなく Git リポジトリにインポートしたりといった作業を、安心して行えるようになったと思います。
次章では、Git の内部に踏み込みます。必要とあらばバイト単位での操作もできることでしょう。</p>
</section>
</section>
</body>
</html>