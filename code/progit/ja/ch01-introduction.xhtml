<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>使い始める</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="使い始める" epub:type="chapter" id="ch01-introduction">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>使い始める</b></small></h1>
</div>
</header>
<div class="abstract" epub:type="preamble">
<p>この章は、Gitを使い始めることについてのものです。
まずはバージョン管理システムの背景に触れ、次にGitをあなたのシステムで動かす方法、最後にGitで作業を始めるための設定方法について説明します。
この章を読み終えるころには、なぜGitがあるのか、なぜGitを使うべきなのかを理解し、また使い始めるための準備が全て整っていることと思います。</p>
</div>
<section class="sect1" title="バージョン管理に関して">
<h2 id="_バージョン管理に関して">バージョン管理に関して</h2>
<p></p>
<p>「バージョン管理」とは何でしょうか。また、なぜそれを気にする必要があるのでしょうか。
バージョン管理とは、一つのファイルやファイルの集合に対して時間とともに加えられていく変更を記録するシステムで、後で特定バージョンを呼び出すことができるようにするためのものです。
本書の例では、バージョン管理されるファイルとしてソフトウェアのソースコードを用いていますが、実際にはコンピューター上のあらゆる種類のファイルをバージョン管理のもとに置くことができます。</p>
<p>もしあなたがグラフィックス・デザイナーやウェブ・デザイナーで、画像やレイアウトの全てのバージョンを保存しておきたいとすると（きっとそうしたいですよね）、バージョン管理システム（VCS）を使うというのはいい考えです。
VCSを使うことで、ファイルを以前の状態まで戻したり、プロジェクト丸ごとを以前の状態に戻したり、過去の変更履歴を比較したり、問題が起こっているかもしれないものを誰が最後に修正したか、誰がいつ問題点を混入させたかを確認したりといった様々なことができるようになります。
また、VCSを使うと、やっていることがめちゃくちゃになってしまったり、ファイルを失ったりしても、普通は簡単に復活させることができるようになります。
それに、これらのことにかかるオーバーヘッドは僅かなものです。</p>
<section class="sect2" title="ローカル・バージョン管理システム">
<h3 id="_ローカル_バージョン管理システム">ローカル・バージョン管理システム</h3>
<p></p>
<p>多くの人々が使っているバージョン管理手法は、他のディレクトリ（気の利いた人であれば、日時のついたディレクトリ）にファイルをコピーするというものです。
このアプローチはとても単純なので非常に一般的ですが、信じられないほど間違いが起こりやすいものです。
どのディレクトリにいるのか忘れやすく、うっかり間違ったファイルに書き込んだり、上書きするつもりのないファイルを上書きしてしまったりします。</p>
<p>この問題を扱うため、はるか昔のプログラマは、ローカルのVCSを開発しました。それは、バージョン管理下のファイルに対する全ての変更を保持するシンプルなデータベースによるものでした。</p>
<figure class="image">
<div class="content">
<img src="images/local.png" alt="ローカル・バージョン管理図解"/>
</div>
<figcaption>Figure 1. ローカル・バージョン管理図解</figcaption>
</figure>
<p>もっとも有名なVCSツールの一つは、RCSと呼ばれるシステムでした。今日でも、依然として多くのコンピューターに入っています。
人気のMac OS Xオペレーティング・システムでも、開発者ツールをインストールすると`rcs`コマンドが入っています。
このツールは基本的に、リビジョン間のパッチ（ファイル間の差分）の集合を特殊なフォーマットでディスク上に保持するという仕組みで動いています。こうすることで、任意のファイルについて、それが過去の任意の時点でどういうものだったかということを、パッチを重ね上げていくことで再現することができます。</p>
</section>
<section class="sect2" title="集中バージョン管理システム">
<h3 id="_集中バージョン管理システム">集中バージョン管理システム</h3>
<p></p>
<p>次に人々が遭遇した大きな問題は、他のシステムを使う開発者と共同作業をする必要があるということです。
この問題に対処するために、集中バージョン管理システム（CVCS）が開発されました。このようなシステムにはCVS、Subversion、Perforceなどがありますが、それらはバージョン管理されたファイルを全て持つ一つのサーバーと、その中心点からファイルをチェックアウトする多数のクライアントからなっています。
長年の間、これはバージョン管理の標準でした。</p>
<figure class="image">
<div class="content">
<img src="images/centralized.png" alt="集中バージョン管理図解"/>
</div>
<figcaption>Figure 2. 集中バージョン管理図解</figcaption>
</figure>
<p>この構成には、特にローカルVCSと比べると、多くの利点があります。
例えば、プロジェクトの他のみんなが何をしているのか、全員がある程度わかります。
管理者は、誰が何をできるのかについて、きめ細かくコントロールできます。それに、一つのCVCSを管理するのは、全てのクライアントのローカル・データベースを取り扱うより、ずっと簡単です。</p>
<p>しかし、この構成には深刻なマイナス面もあります。
もっとも明白なのは、中央サーバーという単一障害点です。
そのサーバーが1時間の間停止すると、その1時間の間は全員が、共同作業も全くできず、作業中のものにバージョンをつけて保存をすることもできなくなります。
もし中央データベースのあるハードディスクが破損し、適切なバックアップが保持されていなければ、完全に全てを失ってしまいます。プロジェクトの全ての履歴は失われ、残るのは個人のローカル・マシンにたまたまあった幾らかの単一スナップショット（訳者注：ある時点のファイル、ディレクトリなどの編集対象の状態）ぐらいです。
ローカルVCSシステムも、これと同じ問題があります。つまり、一つの場所にプロジェクトの全体の履歴を持っていると、全てを失うリスクが常にあります。</p>
</section>
<section class="sect2" title="分散バージョン管理システム">
<h3 id="_分散バージョン管理システム">分散バージョン管理システム</h3>
<p></p>
<p>ここで分散バージョン管理システム(DVCS)の出番になります。
DVCS(Git、Mercurial、Bazaar、Darcsのようなもの)では、クライアントはファイルの最新スナップショットをチェックアウト（訳者注：バージョン管理システムから、作業ディレクトリにファイルやディレクトリをコピーすること）するだけではありません。リポジトリ（訳者注：バージョン管理の対象になるファイル、ディレクトリ、更新履歴などの一群）全体をミラーリングするのです。
そのため、あるサーバーが故障して、DVCSがそのサーバーを介して連携していたとしても、どれでもいいのでクライアント・リポジトリの一つをサーバーにコピーすれば修復できます。
クローンは全て、実際は全データの完全バックアップなのです。</p>
<figure class="image">
<div class="content">
<img src="images/distributed.png" alt="分散バージョン管理図解"/>
</div>
<figcaption>Figure 3. 分散バージョン管理図解</figcaption>
</figure>
<p>さらに、これらのDVCSの多くは、複数のリモート・リポジトリで作業をするということがうまく扱えるようになっているので、異なった方法で異なる人々のグループと同時に同じプロジェクト内で共同作業することができます。
このため、階層モデルなどの、集中システムでは不可能な幾つかのワークフローが構築できるようになっています。</p>
</section>
</section>
<section class="sect1" title="Git略史">
<h2 id="_git略史">Git略史</h2>
<p>人生における多くの素晴らしい出来事のように、Gitはわずかな創造的破壊と熱烈な論争から始まりました。</p>
<p>Linuxカーネルは、非常に巨大な範囲のオープンソース・ソフトウェア・プロジェクトの一つです。
Linuxカーネル保守の大部分の期間（1991-2002）の間は、このソフトウェアに対する変更は、パッチとアーカイブしたファイルとして次々にまわされていました。
2002年に、Linuxカーネル・プロジェクトはプロプライエタリのDVCSであるBitKeeperを使い始めました。</p>
<p>2005年に、Linuxカーネルを開発していたコミュニティと、BitKeeperを開発していた営利企業との間の協力関係が崩壊して、課金無しの状態が取り消されました。
これは、Linux開発コミュニティ（と、特にLinuxの作者のLinus Torvalds）に、BitKeeperを利用している間に学んだ幾つかの教訓を元に、彼ら独自のツールの開発を促しました。
新しいシステムの目標の幾つかは、次の通りでした：</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">スピード</span>
</li>
<li>
<span class="principal">シンプルな設計</span>
</li>
<li>
<span class="principal">ノンリニア開発(数千の並列ブランチ)への強力なサポート</span>
</li>
<li>
<span class="principal">完全な分散</span>
</li>
<li>
<span class="principal">Linux カーネルのような大規模プロジェクトを(スピードとデータサイズで)効率的に取り扱い可能</span>
</li>
</ul>
</div>
<p>2005年のその誕生から、Gitは使いやすく発展・成熟してきており、さらにその初期の品質を維持しています。
とても高速で、巨大プロジェクトではとても効率的で、ノンリニア開発のためのすごい分岐システム（branching system）を備えています（<a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a>参照）。</p>
</section>
<section class="sect1" title="Gitの基本">
<h2 id="_gitの基本">Gitの基本</h2>
<p>では、要するにGitとは何なのでしょうか。
これは、Gitを吸収するには重要な節です。なぜならば、もしGitが何かを理解し、Gitがどうやって稼動しているかの根本を理解できれば、Gitを効果的に使う事が恐らくとても容易になるからです。
Gitを学ぶときは、SubversionやPerforceのような他のVCSに関してあなたが恐らく知っていることは、意識しないでください。このツールを使うときに、ちょっとした混乱を回避することに役立ちます。
ユーザー・インターフェイスがよく似ているにも関わらず、Gitの情報の格納の仕方や情報についての考え方は、それら他のシステムとは大きく異なっています。これらの相違を理解する事は、Gitを扱っている間の混乱を、防いでくれるでしょう。</p>
<section class="sect2" title="スナップショットで、差分ではない">
<h3 id="_スナップショットで_差分ではない">スナップショットで、差分ではない</h3>
<p>Gitと他のVCS (Subversionとその類を含む)の主要な相違は、Gitのデータについての考え方です。
概念的には、他のシステムのほとんどは、情報をファイルを基本とした変更のリストとして格納します。
これらのシステム（CVS、Subversion、Perforce、Bazaar等々）は、図1-4に描かれているように、システムが保持しているファイルの集合と、時間を通じてそれぞれのファイルに加えられた変更の情報を考えます。</p>
<figure class="image">
<div class="content">
<img src="images/deltas.png" alt="他のシステムは、データをそれぞれのファイルの基本バージョンへの変更として格納する傾向があります。"/>
</div>
<figcaption>Figure 4. 他のシステムは、データをそれぞれのファイルの基本バージョンへの変更として格納する傾向があります。</figcaption>
</figure>
<p>Gitは、この方法ではデータを考えたり、格納しません。
代わりに、Gitはデータをミニ・ファイルシステムのスナップショットの集合のように考えます。
Gitで全てのコミット（訳注：commitとは変更を記録・保存するGitの操作。詳細は後の章を参照）をするとき、もしくはプロジェクトの状態を保存するとき、Gitは基本的に、その時の全てのファイルの状態のスナップショットを撮り（訳者注：意訳）、そのスナップショットへの参照を格納するのです。
効率化のため、ファイルに変更が無い場合は、Gitはファイルを再格納せず、既に格納してある、以前の同一のファイルへのリンクを格納します。
Gitは、むしろデータを*一連のスナップショット*のように考えます。</p>
<figure class="image">
<div class="content">
<img src="images/snapshots.png" alt="Gitは時間を通じたプロジェクトのスナップショットとしてデータを格納します。"/>
</div>
<figcaption>Figure 5. Gitは時間を通じたプロジェクトのスナップショットとしてデータを格納します。</figcaption>
</figure>
<p>これが、Gitと類似の全ての他のVCSとの間の重要な違いです。
ほとんどの他のシステムが以前の世代から真似してきた、ほとんど全てのバージョン管理のやり方（訳者注：aspectを意訳）を、Gitに見直させます。
これは、Gitを、単純にVCSと言うより、その上に組み込まれた幾つかの途方も無くパワフルなツールを備えたミニ・ファイルシステムにしています。
このやり方でデータを考えることで得られる利益の幾つかを、<a href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a>を扱ったときに探求します。</p>
</section>
<section class="sect2" title="ほとんど全ての操作がローカル">
<h3 id="_ほとんど全ての操作がローカル">ほとんど全ての操作がローカル</h3>
<p>Gitのほとんどの操作は、ローカル・ファイルと操作する資源だけ必要とします。大体はネットワークの他のコンピューターからの情報は必要ではありません。
ほとんどの操作がネットワーク遅延損失を伴うCVCSに慣れているのであれば、もっさりとしたCVCSに慣れているのであれば、このGitの速度は神業のように感じるでしょう（訳者注：直訳は「このGitの側面はスピードの神様がこの世のものとは思えない力でGitを祝福したと考えさせるでしょう」）。
プロジェクトの履歴は丸ごとすぐそこのローカル・ディスクに保持しているので、大概の操作はほぼ瞬時のように見えます。</p>
<p>例えば、プロジェクトの履歴を閲覧するために、Gitはサーバーに履歴を取得しに行って表示する必要がありません。直接にローカル・データベースからそれを読むだけです。
これは、プロジェクトの履歴をほとんど即座に知るということです。
もし、あるファイルの現在のバージョンと、そのファイルの1ヶ月前の間に導入された変更点を知りたいのであれば、Gitは、遠隔のサーバーに差分を計算するように問い合わせたり、ローカルで差分を計算するために遠隔サーバーからファイルの古いバージョンを持ってくる代わりに、1か月前のファイルを調べてローカルで差分の計算を行なえます。</p>
<p>これはまた、オフラインであるか、VPNから切り離されていたとしても、出来ない事は非常に少ないことを意味します。
もし、飛行機もしくは列車に乗ってちょっとした仕事をしたいとしても、アップロードするためにネットワーク接続し始めるまで、楽しくコミットできます。
もし、帰宅してVPNクライアントを適切に作動させられないとしても、さらに作業ができます。
多くの他のシステムでは、それらを行なう事は、不可能であるか苦痛です。
例えばPerforceにおいては、サーバーに接続できないときは、多くの事が行なえません。SubversionとCVSにおいては、ファイルの編集はできますが、データベースに変更をコミットできません（なぜならば、データベースがオフラインだからです）。
このことは巨大な問題に思えないでしょうが、実に大きな違いを生じうることに驚くでしょう。</p>
</section>
<section class="sect2" title="Gitは完全性を持つ">
<h3 id="_gitは完全性を持つ">Gitは完全性を持つ</h3>
<p>Gitの全てのものは、格納される前にチェックサムが取られ、その後、そのチェックサムで照合されます。
これは、Gitがそれに関して感知することなしに、あらゆるファイルの内容を変更することが不可能であることを意味します。
この機能は、Gitの最下層に組み込まれ、またGitの哲学に不可欠です。
Gitがそれを感知できない状態で、転送中に情報を失う、もしくは壊れたファイルを取得することはありません。</p>
<p>Gitがチェックサム生成に用いる機構は、SHA-1ハッシュと呼ばれます。
これは、16進数の文字（0-9とa-f）で構成された40文字の文字列で、ファイルの内容もしくはGit内のディレクトリ構造を元に計算されます。
SHA-1ハッシュは、このようなもののように見えます:</p>
<figure class="listing">
<pre class="source language-"><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre>
</figure>
<p>Gitはハッシュ値を大変よく利用するので、Gitのいたるところで、これらのハッシュ値を見ることでしょう。
事実、Gitはファイル名ではなく、ファイル内容のハッシュ値によってGitデータベースの中に全てを格納しています。</p>
</section>
<section class="sect2" title="Gitは通常はデータを追加するだけ">
<h3 id="_gitは通常はデータを追加するだけ">Gitは通常はデータを追加するだけ</h3>
<p>Gitで行動するとき、ほとんど全てはGitデータベースにデータを追加するだけです。
システムにいかなる方法でも、UNDO不可能なこと、もしくはデータを消させることをさせるのは困難です。
あらゆるVCSと同様に、まだコミットしていない変更は失ったり、台無しにできたりします。しかし、スナップショットをGitにコミットした後は、特にもし定期的にデータベースを他のリポジトリにプッシュ（訳注：pushはGitで管理するあるリポジトリのデータを、他のリポジトリに転送する操作。詳細は後の章を参照）していれば、変更を失うことは大変難しくなります。</p>
<p>激しく物事をもみくちゃにする危険なしに試行錯誤を行なえるため、これはGitの利用を喜びに変えます。Gitがデータをどのように格納しているのかと失われたように思えるデータをどうやって回復できるのかについての、より詳細な解説に関しては、<a id="xref--ch02-git-basics--r_undoing" href="ch02-git-basics.xhtml#r_undoing" class="xref">作業のやり直し</a>を参照してください。</p>
</section>
<section class="sect2" title="三つの状態">
<h3 id="_三つの状態">三つの状態</h3>
<p>今、注意してください。
もし学習プロセスの残りをスムーズに進めたいのであれば、これはGitに関して覚えておく主要な事です。
Gitは、ファイルが帰属する、コミット済、修正済、ステージ済の、三つの主要な状態を持ちます。
コミット済は、ローカル・データベースにデータが安全に格納されていることを意味します。
修正済は、ファイルに変更を加えていますが、データベースにそれがまだコミットされていないことを意味します。
ステージ済は、次のスナップショットのコミットに加えるために、現在のバージョンの修正されたファイルに印をつけている状態を意味します。</p>
<p>このことは、Gitプロジェクト（訳者注：ディレクトリ内）の、Gitディレクトリ、作業ディレクトリ、ステージング・エリアの三つの主要な部分（訳者注：の理解）に導きます。</p>
<figure class="image">
<div class="content">
<img src="images/areas.png" alt="作業ディレクトリ、ステージング・エリア、Gitディレクトリ"/>
</div>
<figcaption>Figure 6. 作業ディレクトリ、ステージング・エリア、Gitディレクトリ</figcaption>
</figure>
<p>Gitディレクトリは、プロジェクトのためのメタデータ（訳者注：Gitが管理するファイルやディレクトリなどのオブジェクトの要約）とオブジェクトのデータベースがあるところです。
これは、Gitの最も重要な部分で、他のコンピューターからリポジトリをクローン（訳者注：コピー元の情報を記録した状態で、Gitリポジトリをコピーすること）したときに、コピーされるものです。</p>
<p>作業ディレクトリは、プロジェクトの一つのバージョンの単一チェックアウトです。
これらのファイルはGitディレクトリの圧縮されたデータベースから引き出されて、利用するか修正するためにディスクに配置されます。</p>
<p>ステージング・エリアは、普通はGitディレクトリに含まれる、次のコミットに何が含まれるかに関しての情報を蓄えた一つのファイルです。
「インデックス」と呼ばれることもありますが、ステージング・エリアと呼ばれることも多いです。</p>
<p>基本的なGitのワークフローは、このような風に進みます：</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal">作業ディレクトリのファイルを修正します。</span>
</li>
<li>
<span class="principal">修正されたファイルのスナップショットをステージング・エリアに追加して、ファイルをステージします。</span>
</li>
<li>
<span class="principal">コミットします。（訳者注：Gitでは）これは、ステージング・エリアにあるファイルを取得し、永久不変に保持するスナップショットとしてGitディレクトリに格納することです。</span>
</li>
</ol>
</div>
<p>もしファイルの特定のバージョンがGitディレクトリの中にあるとしたら、コミット済だと見なされます。
もし修正されていて、ステージング・エリアに加えられていれば、ステージ済です。
そして、チェックアウトされてから変更されましたが、ステージされていないとするなら、修正済です。
<a id="xref--ch02-git-basics" href="ch02-git-basics.xhtml" class="xref">Git の基本</a>では、これらの状態と、どうやってこれらを利用をするか、もしくは完全にステージ化部分を省略するかに関してより詳しく学習します。</p>
</section>
</section>
<section class="sect1" title="コマンドライン">
<h2 id="_コマンドライン">コマンドライン</h2>
<p>様々な方法でGitを使うことができます。
公式のコマンドラインツールがあり、用途別のグラフィカルユーザーインターフェースも数多く提供されています。
本書では、Gitのコマンドラインツールを使うことにします。
その理由は2つあります。まず、コマンドラインでのみ、Gitのコマンド群を*全て*実行できるからです。GUIの大半は、実装する機能を限定することで複雑になることを回避しています。
コマンドラインのほうを使えるようになれば、GUIのほうの使い方もおおむね把握できるでしょう。ただし、逆も真なり、とはいかないはずです。
2つめの理由として、どのGUIクライアントを使うかはあなたの好み次第、という点が挙げられます。一方、コマンドラインツールのほうは_全員_が同じものを使うことになります。</p>
<p>よって本書では、Macの場合はターミナル、Windowsの場合はコマンド・プロンプトやPowerShellを読者の皆さんが起動できる、という前提で説明してきます。
この節に書かれていることがよくわからない場合は、これ以上読み進める前に不明点を調べおきましょう。そうしておけば、これから出くわすことになる例や説明を理解しやすくなるはずです。</p>
</section>
<section class="sect1" title="Gitのインストール">
<h2 id="_gitのインストール">Gitのインストール</h2>
<p>Gitを使い始める前に、まずはコンピューターでそれを使えるようにしなければなりません。
仮にインストールされていたとしても、最新バージョンにアップデートしておくとよいでしょう。
パッケージやインストーラーを使ってインストールすることもできますし、ソースコードをダウンロードしてコンパイルすることもできます。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>本書は、Git <strong>2.0.0</strong> の情報をもとに書かれています。登場するコマンドの大半は旧来のバージョンのGitでも使えるはずですが、バージョンによっては動作しなかったり、挙動が異なるものがあるかもしれません。ただし、Gitでは後方互換性がとてもよく維持されていますので、2.0以降のバージョンであれば問題はないはずです。</p>
</div>
</aside>
<section class="sect2" title="Linuxにインストール">
<h3 id="_linuxにインストール">Linuxにインストール</h3>
<p></p>
<p>バイナリのインストーラーを使ってLinux上にGitと主な関連ツールをインストールしたいのであれば、大抵はディストリビューションに付属する基本的なパッケージ・マネジメント・ツールを使って、それを行なう事ができます。
もしFedoraを使っているのであれば、yumを使う事が出来ます：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo yum install git-all</code></pre>
</figure>
<p>もしUbuntuのようなDebianベースのディストリュビューションを使っているのであれば、apt-getを試してみましょう：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo apt-get install git-all</code></pre>
</figure>
<p>そのほかにも、いくつかのLinuxディストリビューション用のインストール手順がGitのウェブサイト <a href="http://git-scm.com/download/linux" class="link">http://git-scm.com/download/linux</a> に掲載されています。</p>
</section>
<section class="sect2" title="Macにインストール">
<h3 id="_macにインストール">Macにインストール</h3>
<p></p>
<p>いくつかの方法でGitをMacにインストールできます。
そのうち最も簡単なのは、Xcode Command Line Toolsをインストールすることでしょう。
それは、Mavericks (10.9)以降のバージョンであれば、'git&#8217;をターミナルから実行しようとするだけで実現できます。
もしXcode Command Line Toolsがインストールされていなければ、インストールするよう促してくれます。</p>
<p>最新バージョンのGitを使いたいのであれば、インストーラーを使うといいでしょう。
OSX用のGitインストーラーはよくメンテナンスされており、Gitのウェブサイト <a href="http://git-scm.com/download/mac" class="link">http://git-scm.com/download/mac</a> からダウンロードできます。</p>
<figure class="image">
<div class="content">
<img src="images/git-osx-installer.png" alt="Git OS Xインストーラー"/>
</div>
<figcaption>Figure 7. Git OS Xインストーラー</figcaption>
</figure>
<p>あるいは、GitHub for Macの一部としてGitをインストールすることもできます。
GitHubが提供しているGUIのGitツールには、コマンドラインツールをインストールするオプションもあるのです。
このツールは、GitHub for Macのウェブサイト <a href="http://mac.github.com" class="link">http://mac.github.com</a> からダウンロードできます。</p>
</section>
<section class="sect2" title="Windowsにインストール">
<h3 id="_windowsにインストール">Windowsにインストール</h3>
<p>Windowsの場合でも、いくつかの方法でGitをインストールできます。
最も公式なビルドは、Gitのウェブサイトからダウンロードできます。
<a href="http://git-scm.com/download/win" class="link">http://git-scm.com/download/win</a> にアクセスすると、ダウンロードが自動で始まるようになっています。
注意事項として、このプロジェクトはGit for Windowsという名前で、Gitそのものとは別のプロジェクトです。詳細については <a href="https://git-for-windows.github.io/" class="link">https://git-for-windows.github.io/</a> を参照してください。</p>
<p>もう一つ、Gitをインストールする簡単な方法として、GitHub for Windowsがあります。
GitHub for Windowsのインストーラーには、GUIとコマンドラインバージョンのGitが含まれています。
PowerShellとの連携がしっかりしていて、認証情報のキャッシュは確実、CRLF改行コードの設定はまともです。
これらについては後ほど説明しますので、ここでは「Gitを使うとほしくなるもの」とだけ言っておきます。
GitHub for Windowsは、 <a href="http://windows.github.com" class="link">http://windows.github.com</a> からダウンロードできます。</p>
</section>
<section class="sect2" title="ソースからのインストール">
<h3 id="_ソースからのインストール">ソースからのインストール</h3>
<p>上述のような方法ではなく、Gitをソースからインストールするほうが便利だと思う人もいるかもしれません。そうすれば、最新バージョンを利用できるからです。
インストーラーは最新からは少しですが遅れがちです。とはいえ、Gitの完成度が高まってきたおかげで、今ではその差はさほどでもありません。</p>
<p>Gitをソースからインストールするのなら、Gitが依存する以下のライブラリが必要です：curl、zlib、openssl、expat、libiconv
もし、使っているシステムでyumが使えたり（Fedoraなど）、apt-getが使えたり（Debianベースのシステムなど）する場合は、それぞれ次のようなコマンドを使うと Git のバイナリをコンパイルしインストールするための必要最低限の依存ライブラリをインストールしてくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo yum install curl-devel expat-devel gettext-devel <span style="font-weight: bold; font-style: italic">\</span>
  openssl-devel perl-devel zlib-devel
<span style="font-weight: bold">$</span> sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <span style="font-weight: bold; font-style: italic">\</span>
  libz-dev libssl-dev</code></pre>
</figure>
<p>なお、ドキュメントを doc、html、info 形式等で出力したい場合は、以下の依存ライブラリも必要になります（RHELやRHEL派生のディストリビューション（CentOS・Scientific Linuxなど）では、 <a href="https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F" class="link">EPELリポジトリを有効</a> にしてください。`docbook2X`パッケージをダウンロードするのに必要になります）。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo yum install asciidoc xmlto docbook2X
<span style="font-weight: bold">$</span> sudo apt-get install asciidoc xmlto docbook2x</code></pre>
</figure>
<p>さらに、Fedora・RHEL・RHEL派生のディストリビューションを使っている場合は、以下のコマンドを実行してください。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi</code></pre>
</figure>
<p>バイナリー名が異なるために生じる問題を解消するためです。</p>
<p>依存関係のインストールが完了したら、次にタグ付けされた最新のリリース用tarballを入手しましょう。複数のサイトから入手できます。
具体的なサイトとしては、Kernel.org <a href="https://www.kernel.org/pub/software/scm/git" class="link">https://www.kernel.org/pub/software/scm/git</a> やGitHub上のミラー <a href="https://github.com/git/git/releases" class="link">https://github.com/git/git/releases</a> があります。
どのバージョンが最新なのかはGitHubのほうがわかりやすくなっています。一方、kernel.orgのほうにはリリースごとの署名が用意されており、ダウンロードしたファイルの検証に使えます。</p>
<p>ダウンロードが終わったら、コンパイルしてインストールします：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> tar -zxf git-2.0.0.tar.gz
<span style="font-weight: bold">$</span> cd git-2.0.0
<span style="font-weight: bold">$</span> make configure
<span style="font-weight: bold">$</span> ./configure --prefix=/usr
<span style="font-weight: bold">$</span> make all doc info
<span style="font-weight: bold">$</span> sudo make install install-doc install-html install-info</code></pre>
</figure>
<p>一度この手順を済ませると、次からはGitを使ってGitそのものをアップデートできます：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone git://git.kernel.org/pub/scm/git/git.git</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="最初のGitの構成">
<h2 id="r_first_time">最初のGitの構成</h2>
<p>今や、Gitがシステムにあります。Git環境をカスタマイズするためにしたい事が少しはあることでしょう。
どんなコンピューターであれ、その作業は一度だけ行えばいいでしょう。Gitをアップグレードしても設定は引き継がれるからです。
またそれらは、またコマンドを実行することによっていつでも変更することができます。</p>
<p>Gitには、`git config`と呼ばれるツールが付属します。これで、どのようにGitが見えて機能するかの全ての面を制御できる設定変数を取得し、設定することができます。
これらの変数は三つの異なる場所に格納されうります：</p>
<div class="ordered-list arabic">
<ol class="arabic">
<li>
<span class="principal"><code class="literal">/etc/gitconfig</code> ファイル: システム上の全てのユーザーと全てのリポジトリに対する設定値を保持します。
もし`--system`オプションを`git config`に指定すると、明確にこのファイルに読み書きを行ないます。</span>
</li>
<li>
<span class="principal"><code class="literal">~/.gitconfig</code> か <code class="literal">~/.config/git/config</code> ファイル: 特定のユーザーに対する設定値を保持します。
`--global`オプションを指定することで、Gitに、明確にこのファイルに読み書きを行なわせることができます。</span>
</li>
<li>
<span class="principal">現在使っているリポジトリのGitディレクトリにある`config`ファイル(`.git/config`のことです): 特定の単一リポジトリに対する設定値を保持します。</span>
</li>
</ol>
</div>
<p>それぞれのレベルの値は以前のレベルの値を上書きするため、<code class="literal">.git/config`の中の設定値は</code>/etc/gitconfig`の設定値に優先されます。</p>
<p>Windowsの場合、Gitはまず <code class="literal">$HOME</code> ディレクトリ（通常は <code class="literal">C:\Users\$USER</code> です。）にある <code class="literal">.gitconfig</code> ファイルを検索します。
また、<code class="literal">/etc/gitconfig</code> も他のシステムと同様に検索されます。ただし、実際に検索される場所は、MSysのルート（Gitのインストーラーを実行した際に指定したパス。）からの相対パスになります。
さらに、Git for Windows 2.x以降を使っている場合は、システム全体で有効な設定ファイルも検索されます。Windows XPであれば <code class="literal">C:\Documents and Settings\All Users\Application Data\Git\config</code>、Windows Vista以降であれば <code class="literal">C:\ProgramData\Git\config</code> です。
なお、検索される設定ファイルは、管理者権限で <code class="literal">git config -f &lt;file&gt;</code> を実行すれば変更できます。</p>
<section class="sect2" title="個人の識別情報">
<h3 id="_個人の識別情報">個人の識別情報</h3>
<p>Gitをインストールしたときに最初にすべきことは、ユーザー名とEmailアドレスを設定することです。
全てのGitのコミットはこの情報を用いるため、これは重要で、作成するコミットに永続的に焼き付けられます：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global user.name <span style="font-style: italic">&quot;John Doe&quot;</span>
<span style="font-weight: bold">$</span> git config --global user.email johndoe@example.com</code></pre>
</figure>
<p>また、もし`--global`オプションを指定するのであれば、Gitはその後、そのシステム上で行なう（訳者注：あるユーザーの）全ての操作に対して常にこの情報を使うようになるため、この操作を行なう必要はたった一度だけです。
もし、違う名前とEmailアドレスを特定のプロジェクトで上書きしたいのであれば、そのプロジェクトの（訳者注：Gitディレクトリの）中で、`--global`オプション無しでこのコマンドを実行することができます。</p>
<p>GUIのツールの場合、初めて起動した際にこの作業を行うよう促されることが多いようです。</p>
</section>
<section class="sect2" title="エディター">
<h3 id="_エディター">エディター</h3>
<p>個人の識別情報が設定できたので、Gitがメッセージのタイプをさせる必要があるときに使う、標準のテキストエディターを設定できます。
これが設定されていない場合、Gitはシステムのデフォルトエディターを使います。
Emacsのような違うテキストエディターを使いたい場合は、次のようにします：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.editor emacs</code></pre>
</figure>
<p>また、Windowsで違うエディタ（Notepad++など）を使いたいのなら、以下のように設定してみてください。</p>
<p>32bit版Windowsの場合</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.editor <span style="font-style: italic">&quot;&#39;C:/Program Files/Notepad++/notepad++.exe&#39; -multiInst -nosession&quot;</span></code></pre>
</figure>
<p>64bit版Windowsの場合</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global core.editor <span style="font-style: italic">&quot;&#39;C:/Program Files (x86)/Notepad++/notepad++.exe&#39; -multiInst -nosession&quot;</span></code></pre>
</figure>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>Vim、Emacs、Notepad++は人気があり、LinuxやMacのようなUnixベースのシステムやWindowsのシステム使う開発者たちに特によく使われています。
それらのエディターをあまり知らない場合は、好みのエディターをGitで使うにはどうすればいいか、個別に調べる必要があるかもしれません。</p>
</div>
</aside>
<aside class="admonition warning" title="Warning" epub:type="warning">
<div class="content">
<p>Git用のエディターを設定していなくて、Gitを使っている最中にそれらが立ち上がって困惑することになってしまうでしょう。
特にWindowsの場合、Gitを操作する過程でのテキスト編集を中断してしまうと、やっかいなことになることがあります。</p>
</div>
</aside>
</section>
<section class="sect2" title="設定の確認">
<h3 id="_設定の確認">設定の確認</h3>
<p>設定を確認したい場合は、その時点でGitが見つけられる全ての設定を一覧するコマンドである`git config --list`を使う事ができます：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...</code></pre>
</figure>
<p>Gitは異なったファイル(例えば`/etc/gitconfig`と`~/.gitconfig`)から同一のキーを読み込むため、同一のキーを1度以上見ることになるでしょう。この場合、Gitは見つけたそれぞれ同一のキーに対して最後の値を用います。</p>
<p>また、Gitに設定されている特定のキーの値を、`git config &lt;key&gt;`とタイプすることで確認することができます：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config user.name
John Doe</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="ヘルプを見る">
<h2 id="r_git_help">ヘルプを見る</h2>
<p>もし、Gitを使っている間は助けがいつも必要なら、あらゆるGitコマンドのヘルプのマニュアル・ページ（manpage）を参照する3種類の方法があります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git help &lt;verb&gt;
<span style="font-weight: bold">$</span> git &lt;verb&gt; --help
<span style="font-weight: bold">$</span> man git-&lt;verb&gt;</code></pre>
</figure>
<p>例えば、configコマンドのヘルプのmanpageを次のコマンドを走らせることで見ることができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git help config</code></pre>
</figure>
<p>これらのコマンドは、オフラインのときでさえ、どこでも見る事ができるので、すばらしいです。
もしmanpageとこの本が十分でなく、人の助けが必要であれば、フリーノードIRCサーバー（irc.freenode.net）の`#git`もしくは`#github`チャンネルにアクセスしてみてください。
これらのチャンネルはいつも、Gitに関してとても知識があり、よく助けてくれようとする数百人の人々でいっぱいです。</p>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ">まとめ</h2>
<p>Gitとは何か、どのように今まで使われてきた他のCVCSと異なるのかについて、基本的な理解ができたはずです。
また、今や個人情報の設定ができた、システムに稼動するバージョンのGitがあるはずです。
今や、本格的にGitの基本を学習するときです。</p>
</section>
</section>
</body>
</html>