<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git の基本</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git の基本" epub:type="chapter" id="ch02-git-basics">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>の基本</b></small></h1>
</div>
</header>
<div class="abstract" epub:type="preamble">
<p>Git を使い始めるにあたってどれかひとつの章だけしか読めないとしたら、読むべきは本章です。
この章では、あなたが実際に Git を使う際に必要となる基本コマンドをすべて取り上げています。
本章を最後まで読めば、リポジトリの設定や初期化、ファイルの追跡、そして変更内容のステージやコミットなどができるようになるでしょう。
また、Git で特定のファイル (あるいは特定のファイルパターン) を無視させる方法やミスを簡単に取り消す方法、プロジェクトの歴史や各コミットの変更内容を見る方法、リモートリポジトリとの間でのプッシュやプルを行う方法についても説明します。</p>
</div>
<section class="sect1" title="Git リポジトリの取得">
<h2 id="r_getting_a_repo">Git リポジトリの取得</h2>
<p>Git プロジェクトを取得するには、大きく二通りの方法があります。
ひとつは既存のプロジェクトやディレクトリを Git にインポートする方法、
そしてもうひとつは既存の Git リポジトリを別のサーバーからクローンする方法です。</p>
<section class="sect2" title="既存のディレクトリでのリポジトリの初期化">
<h3 id="_既存のディレクトリでのリポジトリの初期化">既存のディレクトリでのリポジトリの初期化</h3>
<p>既存のプロジェクトを Git で管理し始めるときは、そのプロジェクトのディレクトリに移動して次のように打ち込みます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init</code></pre>
</figure>
<p>これを実行すると <code class="literal">.git</code> という名前の新しいサブディレクトリが作られ、リポジトリに必要なすべてのファイル (Git リポジトリのスケルトン) がその中に格納されます。
この時点では、まだプロジェクト内のファイルは一切管理対象になっていません
(今作った <code class="literal">.git</code> ディレクトリに実際のところどんなファイルが含まれているのかについての詳細な情報は、<a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Gitの内側</a>を参照ください)。</p>
<p>空のディレクトリではなくすでに存在するファイルのバージョン管理を始めたい場合は、まずそのファイルを監視対象に追加してから最初のコミットをすることになります。この場合は、追加したいファイルについて <code class="literal">git add</code> コマンドを実行したあとで <code class="literal">git commit</code> コマンドを行います。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *.c
<span style="font-weight: bold">$</span> git add LICENSE
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial project version&#39;</span></code></pre>
</figure>
<p>これが実際のところどういう意味なのかについては後で説明します。ひとまずこの時点で、監視対象のファイルを持つ Git リポジトリができあがり最初のコミットまで済んだことになります。</p>
</section>
<section class="sect2" title="既存のリポジトリのクローン">
<h3 id="r_git_cloning">既存のリポジトリのクローン</h3>
<p>既存の Git リポジトリ (何か協力したいと思っているプロジェクトなど) のコピーを取得したい場合に使うコマンドが、<code class="literal">git clone</code> です。
Subversion などの他の VCS を使っている人なら「"checkout" じゃなくて "clone" なのか」と気になることでしょう。
これは重要な違いです。ワーキングコピーを取得するのではなく、Git はサーバーが保持しているデータをほぼすべてコピーするのです。
そのプロジェクトのすべてのファイルのすべての歴史が、デフォルトでは <code class="literal">git clone</code> で手元にやってきます。
実際、もし仮にサーバーのディスクが壊れてしまったとしても、どこかのクライアントに残っているクローンをサーバーに戻せばクローンした時点まで多くの場合は復元できるでしょう(サーバーサイドのフックなど一部の情報は失われてしまいますが、これまでのバージョン管理履歴はすべてそこに残っています。<a id="xref--ch04-git-server--r_git_on_the_server" href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">サーバー用の Git の取得</a>で詳しく説明します)。</p>
<p>リポジトリをクローンするには <code class="literal">git clone [url]</code> とします。
たとえば、多言語へのバインディングが可能なGitライブラリであるlibgitをクローンする場合は次のようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2</code></pre>
</figure>
<p>これは、まず`‘libgit2’<em>というディレクトリを作成してその中で <code class="literal">.git</code> ディレクトリを初期化し、リポジトリのすべてのデータを引き出し、そして最新バージョンの作業コピーをチェックアウトします。
新しくできた <code class="literal">libgit2</code> ディレクトリに入ると、プロジェクトのファイルをごらんいただけます。
もし``libgit2</em>'ではない別の名前のディレクトリにクローンしたいのなら、コマンドラインオプションでディレクトリ名を指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2 mylibgit</code></pre>
</figure>
<p>このコマンドは先ほどと同じ処理をしますが、ディレクトリ名は <code class="literal">mylibgit</code> となります。</p>
<p>Git では、さまざまな転送プロトコルを使用することができます。先ほどの例では <code class="literal">https://</code> プロトコルを使用しましたが、<code class="literal">git://</code> や <code class="literal">user@server:/path/to/repo.git</code> といった形式を使うこともできます。これらは SSH プロトコルを使用します。<a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">サーバー用の Git の取得</a>で、サーバー側で準備できるすべてのアクセス方式についての利点と欠点を説明します。</p>
</section>
</section>
<section class="sect1" title="変更内容のリポジトリへの記録">
<h2 id="_変更内容のリポジトリへの記録">変更内容のリポジトリへの記録</h2>
<p>これで、れっきとした Git リポジトリを準備して、そのプロジェクト内のファイルの作業コピーを取得することができました。
次は、そのコピーに対して何らかの変更を行い、適当な時点で変更内容のスナップショットをリポジトリにコミットすることになります。</p>
<p>作業コピー内の各ファイルには追跡されている(tracked)ものと追跡されてない(untracked)ものの二通りがあることを知っておきましょう。
追跡されているファイルとは、直近のスナップショットに存在したファイルのことです。これらのファイルについては変更されていない(unmodified)」「変更されている(modified)」「ステージされている(staged)」の三つの状態があります。
追跡されていないファイルは、そのどれでもありません。直近のスナップショットには存在せず、ステージングエリアにも存在しないファイルのことです。
最初にプロジェクトをクローンした時点では、すべてのファイルは「追跡されている」かつ「変更されていない」状態となります。チェックアウトしただけで何も編集していない状態だからです。</p>
<p>ファイルを編集すると、Git はそれを「変更された」とみなします。直近のコミットの後で変更が加えられたからです。変更されたファイルをステージし、それをコミットする。この繰り返しです。</p>
<figure class="image">
<div class="content">
<img src="images/lifecycle.png" alt="ファイルの状態の流れ"/>
</div>
<figcaption>Figure 1. ファイルの状態の流れ</figcaption>
</figure>
<section class="sect2" title="ファイルの状態の確認">
<h3 id="r_checking_status">ファイルの状態の確認</h3>
<p>どのファイルがどの状態にあるのかを知るために主に使うツールが <code class="literal">git status</code> コマンドです。
このコマンドをクローン直後に実行すると、このような結果となるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
nothing to commit, working directory clean</code></pre>
</figure>
<p>これは、クリーンな作業コピーである (つまり、追跡されているファイルの中に変更されているものがない) ことを意味します。
また、追跡されていないファイルも存在しません (もし追跡されていないファイルがあれば、Git はそれを表示します)。
最後に、このコマンドを実行するとあなたが今どのブランチにいるのか、サーバー上の同一ブランチから分岐してしまっていないかどうかがわかります。
現時点では常に “master” となります。これはデフォルトであり、ここでは特に気にする必要はありません。
ブランチについては <a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> で詳しく説明します。</p>
<p>ではここで、新しいファイルをプロジェクトに追加してみましょう。シンプルに、READMEファイルを追加してみます。
それ以前に README ファイルがなかった場合、<code class="literal">git status</code> を実行すると次のように表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;My Project&#39;</span> &gt; README
<span style="font-weight: bold">$</span> git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
</figure>
<p>出力結果の “Untracked files” 欄にREADMEファイルがあることから、このファイルが追跡されていないということがわかります。
これは、Git が「前回のスナップショット (コミット) にはこのファイルが存在しなかった」とみなしたということです。明示的に指示しない限り、Git はコミット時にこのファイルを含めることはありません。
自動生成されたバイナリファイルなど、コミットしたくないファイルを間違えてコミットしてしまう心配はないということです。
今回は README をコミットに含めたいわけですから、まずファイルを追跡対象に含めるようにしましょう。</p>
</section>
<section class="sect2" title="新しいファイルの追跡">
<h3 id="r_tracking_files">新しいファイルの追跡</h3>
<p>新しいファイルの追跡を開始するには <code class="literal">git add</code> コマンドを使用します。
READMEファイルの追跡を開始する場合はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>再び status コマンドを実行すると、READMEファイルが追跡対象となってステージされており、コミットする準備ができていることがわかるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README</code></pre>
</figure>
<p>ステージされていると判断できるのは、 “Changes to be committed” 欄に表示されているからです。
ここでコミットを行うと、<code class="literal">git add</code> した時点の状態のファイルがスナップショットとして歴史に書き込まれます。
先ほど <code class="literal">git init</code> をしたときに、ディレクトリ内のファイルを追跡するためにその後 <code class="literal">git add (ファイル)</code> としたことを思い出すことでしょう。
<code class="literal">git add</code> コマンドには、ファイルあるいはディレクトリのパスを指定します。ディレクトリを指定した場合は、そのディレクトリ以下にあるすべてのファイルを再帰的に追加します。</p>
</section>
<section class="sect2" title="変更したファイルのステージング">
<h3 id="_変更したファイルのステージング">変更したファイルのステージング</h3>
<p>すでに追跡対象となっているファイルを変更してみましょう。
たとえば、すでに追跡対象となっているファイル <code class="literal">CONTRIBUTING.md</code> を変更して <code class="literal">git status</code> コマンドを実行すると、結果はこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p><code class="literal">CONTRIBUTING.md</code> ファイルは “Changed but not staged for commit” という欄に表示されます。これは、追跡対象のファイルが作業ディレクトリ内で変更されたけれどもまだステージされていないという意味です。
ステージするには <code class="literal">git add</code> コマンドを実行します。 <code class="literal">git add</code> にはいろんな意味合いがあり、新しいファイルの追跡開始・ファイルのステージング・マージ時に衝突が発生したファイルに対する「解決済み」マーク付けなどで使用します。‘`指定したファイルをプロジェクトに追加(add)する’<em>コマンド、というよりは、``指定した内容を次のコミットに追加(add)する</em>'コマンド、と捉えるほうがわかりやすいかもしれません。
では、<code class="literal">git add</code> で <code class="literal">CONTRIBUTING.md</code> をステージしてもういちど <code class="literal">git status</code> を実行してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>両方のファイルがステージされました。これで、次回のコミットに両方のファイルが含まれるようになります。
ここで、さらに <code class="literal">CONTRIBUTING.md</code> にちょっとした変更を加えてからコミットしたくなったとしましょう。
ファイルを開いて変更を終え、コミットの準備が整いました。
しかし、<code class="literal">git status</code> を実行してみると何か変です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>これはどういうことでしょう?
<code class="literal">CONTRIBUTING.md</code> が、ステージされているほうとステージされていないほうの_両方に_登場しています。
こんなことってありえるんでしょうか?
要するに、Git は「<code class="literal">git add</code> コマンドを実行した時点の状態のファイル」をステージするということです。
ここでコミットをすると、実際にコミットされるのは <code class="literal">git add</code> を実行した時点の <code class="literal">CONTRIBUTING.md</code> であり、<code class="literal">git commit</code> した時点の作業ディレクトリにある内容とは違うものになります。
<code class="literal">git add</code> した後にファイルを変更した場合に、最新版のファイルをステージしなおすにはもう一度 <code class="literal">git add</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
</section>
<section class="sect2" title="状態表示の簡略化">
<h3 id="_状態表示の簡略化">状態表示の簡略化</h3>
<p><code class="literal">git status</code> の出力はとてもわかりやすいですが、一方で冗長でもあります。
Gitにはそれを簡略化するためのオプションもあり、変更点をより簡潔に確認できます。
`git status -s`や`git status --short`コマンドを実行して、簡略化された状態表示を見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</figure>
<p>まだ追跡されていない新しいファイルには`??`が、ステージングエリアに追加されたファイルには`A`が、変更されたファイルには`M`が、といったように、ファイル名の左側に文字列が表示されます。
内容は2文字の組み合わせです。1文字目はステージされたファイルの状態を、2文字はファイルが変更されたかどうかを示しています。
この例でいうと、`README`ファイルは作業ディレクトリ上にあって変更されているけれどステージされてはいません。
`lib/simplegit.rb`ファイルは変更済みでステージもされています。
`Rakefile`のほうはどうかというと、変更されステージされたあと、また変更された、という状態です。変更の内容にステージされたものとそうでないものがあることになります。</p>
</section>
<section class="sect2" title="ファイルの無視">
<h3 id="r_ignoring">ファイルの無視</h3>
<p>ある種のファイルについては、Git で自動的に追加してほしくないしそもそも「追跡されていない」と表示されるのも気になってしまう。そんなことがよくあります。
たとえば、ログファイルやビルドシステムが生成するファイルなどの自動生成されるファイルがそれにあたるでしょう。
そんな場合は、無視させたいファイルのパターンを並べた <code class="literal">.gitignore</code> というファイルを作成します。
<code class="literal">.gitignore</code> ファイルは、たとえばこのようになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .gitignore
*.[oa]
*~</code></pre>
</figure>
<p>最初の行は “.o” あるいは “.a” で終わる名前のファイル (コードをビルドする際にできるであろうオブジェクトファイルとアーカイブファイル) を無視するよう Git に伝えています。次の行で Git に無視させているのは、チルダ (<code class="literal">~</code>) で終わる名前のファイルです。Emacs をはじめとする多くのエディタが、この形式の一時ファイルを作成します。これ以外には、たとえば log、tmp、pid といった名前のディレクトリや自動生成されるドキュメントなどもここに含めることになるでしょう。実際に作業を始める前に <code class="literal">.gitignore</code> ファイルを準備しておくことをお勧めします。そうすれば、予期せぬファイルを間違って Git リポジトリにコミットしてしまう事故を防げます。</p>
<p><code class="literal">.gitignore</code> ファイルに記述するパターンの規則は、次のようになります。</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">空行あるいは <code class="literal">#</code> で始まる行は無視される</span>
</li>
<li>
<span class="principal">標準の glob パターンを使用可能</span>
</li>
<li>
<span class="principal">再帰を避けるためには、パターンの最初にスラッシュ (<code class="literal">/</code>) をつける</span>
</li>
<li>
<span class="principal">ディレクトリを指定するには、パターンの最後にスラッシュ (<code class="literal">/</code>) をつける</span>
</li>
<li>
<span class="principal">パターンを逆転させるには、最初に感嘆符 (<code class="literal">!</code>) をつける</span>
</li>
</ul>
</div>
<p>glob パターンとは、シェルで用いる簡易正規表現のようなものです。
アスタリスク (<code class="literal">*</code>) は、ゼロ個以上の文字にマッチします。
<code class="literal">[abc]</code> は、角括弧内の任意の文字 (この場合は a、b あるいは c) にマッチします。
疑問符 (<code class="literal">?</code>) は一文字にマッチします。
また、ハイフン区切りの文字を角括弧で囲んだ形式 (<code class="literal">[0-9]</code>) は、
ふたつの文字の間の任意の文字 (この場合は 0 から 9 までの間の文字) にマッチします。
アスタリクスを2つ続けて、ネストされたディレクトリにマッチさせることもできます。
<code class="literal">a/**/z</code> のように書けば、<code class="literal">a/z</code>、<code class="literal">a/b/z</code>、`a/b/c/z`などにマッチします。</p>
<p>では、<code class="literal">.gitignore</code> ファイルの例をもうひとつ見てみましょう。</p>
<figure class="listing">
<pre class="source language-"><code># no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf</code></pre>
</figure>
<aside class="admonition tip" title="Tip" epub:type="help">
<div class="content">
<p>GitHubが管理している <code class="literal">.gitignore</code> ファイルのサンプル集 <a href="https://github.com/github/gitignore" class="link">https://github.com/github/gitignore</a> はよくまとまっていて、多くのプロジェクト・言語で使えます。
プロジェクトを始めるときのとっかかりになるでしょう。</p>
</div>
</aside>
</section>
<section class="sect2" title="ステージされている変更 / されていない変更の閲覧">
<h3 id="r_git_diff_staged">ステージされている変更 / されていない変更の閲覧</h3>
<p><code class="literal">git status</code> コマンドだけではよくわからない
（どのファイルが変更されたのかだけではなく、実際にどのように変わったのかが知りたい）
という場合は <code class="literal">git diff</code> コマンドを使用します。
<code class="literal">git diff</code> コマンドについては後で詳しく解説します。
おそらく、最もよく使う場面としては次の二つの問いに答えるときになるでしょう。
「変更したけどまだステージしていない変更は?」「コミット対象としてステージした変更は?」
<code class="literal">git status</code> が出力するファイル名のリストを見れば、
これらの質問に対するおおまかな答えは得られますが、
<code class="literal">git diff</code> の場合は追加したり削除したりした正確な行をパッチ形式で表示します。</p>
<p>先ほどの続きで、ふたたび <code class="literal">README</code> ファイルを編集してステージし、
一方 <code class="literal">CONTRIBUTING.md</code> ファイルは編集だけしてステージしない状態にあると仮定しましょう。
ここで <code class="literal">git status</code> コマンドを実行すると、次のような結果となります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>変更したけれどもまだステージしていない内容を見るには、引数なしで <code class="literal">git diff</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<p>このコマンドは、作業ディレクトリの内容とステージングエリアの内容を比較します。
この結果を見れば、あなたが変更した内容のうちまだステージされていないものを知ることができます。</p>
<p>次のコミットに含めるべくステージされた内容を知りたい場合は、<code class="literal">git diff --staged</code> を使用します。
このコマンドは、ステージされている変更と直近のコミットの内容を比較します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</figure>
<p><code class="literal">git diff</code> 自体は、直近のコミット以降のすべての変更を表示するわけではないことに注意しましょう。
あくまでもステージされていない変更だけの表示となります。
これにはすこし戸惑うかもしれません。
変更内容をすべてステージしてしまえば <code class="literal">git diff</code> は何も出力しなくなるわけですから。</p>
<p>もうひとつの例を見てみましょう。<code class="literal">CONTRIBUTING.md</code> ファイルをいったんステージした後に編集してみましょう。
<code class="literal">git diff</code> を使用すると、ステージされたファイルの変更とまだステージされていないファイルの変更を見ることができます。以下のような状態だとすると、</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# test line&#39;</span> &gt;&gt; CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p><code class="literal">git diff</code> を使うことで、まだステージされていない内容を知ることができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
<span style="font-weight: bold"> #</span><span style="font-style: italic"># Starter Projects</span>

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</figure>
<p>そして <code class="literal">git diff --cached</code> を使うと、これまでにステージした内容を知ることができます（<code class="literal">--staged</code> と <code class="literal">--cached</code> は同義です）。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<aside class="admonition note" title="Note: GitのDiffを他のツールで見る" epub:type="note">
<h2>GitのDiffを他のツールで見る</h2>
<div class="content">
<p>この本では、引き続き`git diff`コマンドを様々な方法で使っていきます。
一方、このコマンドを使わずに差分を見る方法も用意されています。GUIベースだったり、他のツールが好みの場合、役に立つでしょう。
`git diff`の代わりに`git difftool`を実行してください。そうすれば、emerge、vimdiffなどのツールを使って差分を見られます（商用のツールもいくつもあります）。
また、`git difftool --tool-help`を実行すれば、利用可能なdiffツールを確認することもできます。</p>
</div>
</aside>
</section>
<section class="sect2" title="変更のコミット">
<h3 id="r_committing_changes">変更のコミット</h3>
<p>ステージングエリアの準備ができたら、変更内容をコミットすることができます。
コミットの対象となるのはステージされたものだけ、
つまり追加したり変更したりしただけでまだ <code class="literal">git add</code> を実行していないファイルはコミットされないことを覚えておきましょう。
そういったファイルは、変更されたままの状態でディスク上に残ります。
ここでは、最後に <code class="literal">git status</code> を実行したときにすべてがステージされていることを確認したとしましょう。つまり、変更をコミットする準備ができた状態です。
コミットするための最もシンプルな方法は <code class="literal">git commit</code> と打ち込むことです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p>これを実行すると、指定したエディタが立ち上がります
（シェルの <code class="literal">$EDITOR</code> 環境変数で設定されているエディタ。
通常は vim あるいは emacs でしょう。しかし、
それ以外にも<a id="xref--ch01-introduction" href="ch01-introduction.xhtml" class="xref">使い始める</a>で説明した <code class="literal">git config --global core.editor</code> コマンドで
お好みのエディタを指定することもできます）。</p>
<p>エディタには次のようなテキストが表示されています (これは Vim の画面の例です)。</p>
<figure class="listing">
<pre class="source language-"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</figure>
<p>デフォルトのコミットメッセージとして、
直近の <code class="literal">git status</code> コマンドの結果がコメントアウトして表示され、
先頭に空行があることがわかるでしょう。
このコメントを消して自分でコミットメッセージを書き入れていくこともできますし、
何をコミットしようとしているのかの確認のためにそのまま残しておいてもかまいません
(何を変更したのかをより明確に知りたい場合は、<code class="literal">git commit</code> に <code class="literal">-v</code> オプションを指定します。
そうすると、diff の内容がエディタに表示されるので何をコミットしようとしているかが正確にわかるようになります)。
エディタを終了させると、Git はそのメッセージつきのコミットを作成します
(コメントおよび diff は削除されます)。</p>
<p>あるいは、コミットメッセージをインラインで記述することもできます。その場合は、<code class="literal">commit</code> コマンドの後で <code class="literal">-m</code> フラグに続けて次のように記述します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Story 182: Fix benchmarks for speed&quot;</span>
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</figure>
<p>これではじめてのコミットができました!
今回のコミットについて、
「どのブランチにコミットしたのか (<code class="literal">master</code>)」「そのコミットの SHA-1 チェックサム (<code class="literal">463dc4f</code>)」「変更されたファイルの数」「そのコミットで追加されたり削除されたりした行数」
といった情報が表示されているのがわかるでしょう。</p>
<p>コミットが記録するのは、ステージングエリアのスナップショットであることを覚えておきましょう。
ステージしていない情報については変更された状態のまま残っています。
別のコミットで歴史にそれを書き加えるには、改めて add する必要があります。
コミットするたびにプロジェクトのスナップショットが記録され、あとからそれを取り消したり参照したりできるようになります。</p>
</section>
<section class="sect2" title="ステージングエリアの省略">
<h3 id="_ステージングエリアの省略">ステージングエリアの省略</h3>
<p></p>
<p>コミットの内容を思い通りに作り上げることができるという点でステージングエリアは非常に便利なのですが、
普段の作業においては必要以上に複雑に感じられることもあるでしょう。
ステージングエリアを省略したい場合のために、Git ではシンプルなショートカットを用意しています。
<code class="literal">git commit</code> コマンドに <code class="literal">-a</code> オプションを指定すると、追跡対象となっているファイルを自動的にステージしてからコミットを行います。
つまり <code class="literal">git add</code> を省略できるというわけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;added new benchmarks&#39;</span>
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>この場合、コミットする前に <code class="literal">CONTRIBUTING.md</code> を <code class="literal">git add</code> する必要がないことに気づいたでしょうか。
<code class="literal">-a</code> というフラグのおかげで、変更したファイルがすべてコミットに含まれたからです。
このように <code class="literal">-a</code> は便利なフラグですが、ときには意図しない変更をコミットに含んでしまうことにもなりますので気をつけましょう。</p>
</section>
<section class="sect2" title="ファイルの削除">
<h3 id="r_removing_files">ファイルの削除</h3>
<p></p>
<p>ファイルを Git から削除するには、追跡対象からはずし (より正確に言うとステージングエリアから削除し)、そしてコミットします。
<code class="literal">git rm</code> コマンドは、この作業を行い、そして作業ディレクトリからファイルを削除します。
つまり、追跡されていないファイルとして残り続けることはありません。</p>
<p>単に作業ディレクトリからファイルを削除しただけの場合は、<code class="literal">git status</code> の出力の中では “Changed but not updated” (つまり <em>ステージされていない</em>) 欄に表示されます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm PROJECTS.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p><code class="literal">git rm</code> を実行すると、ファイルの削除がステージされます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm PROJECTS.md
rm &#39;PROJECTS.md&#39;
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    deleted:    PROJECTS.md</code></pre>
</figure>
<p>次にコミットするときにファイルが削除され、追跡対象外となります。
変更したファイルをすでにステージしている場合は、<code class="literal">-f</code> オプションで強制的に削除しなければなりません。
まだスナップショットに記録されていないファイルを誤って削除してしまうと Git で復旧することができなくなってしまうので、それを防ぐための安全装置です。</p>
<p>ほかに「こんなことできたらいいな」と思われるであろう機能として、
ファイル自体は作業ツリーに残しつつステージングエリアからの削除だけを行うこともできます。
つまり、ハードディスク上にはファイルを残しておきたいけれど、もう Git では追跡させたくないというような場合のことです。
これが特に便利なのは、<code class="literal">.gitignore</code> ファイルに書き足すのを忘れたために巨大なログファイルや大量の <code class="literal">.a</code> ファイルがステージされてしまったなどというときです。
そんな場合は <code class="literal">--cached</code> オプションを使用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm --cached README</code></pre>
</figure>
<p>ファイル名やディレクトリ名、そしてファイル glob パターンを <code class="literal">git rm</code> コマンドに渡すことができます。
つまり、このようなこともできるということです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm log/<span style="font-weight: bold; font-style: italic">\*</span>.log</code></pre>
</figure>
<p><code class="literal">*</code> の前にバックスラッシュ (<code class="literal">\</code>) があることに注意しましょう。
これが必要なのは、シェルによるファイル名の展開だけでなく Git が自前でファイル名の展開を行うからです。
このコマンドは、<code class="literal">log/</code> ディレクトリにある拡張子 <code class="literal">.log</code> のファイルをすべて削除します。
あるいは、このような書き方もできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm <span style="font-weight: bold; font-style: italic">\*</span>~</code></pre>
</figure>
<p>このコマンドは、<code class="literal">~</code> で終わるファイル名のファイルをすべて削除します。</p>
</section>
<section class="sect2" title="ファイルの移動">
<h3 id="r_git_mv">ファイルの移動</h3>
<p></p>
<p>他の多くの VCS とは異なり、Git はファイルの移動を明示的に追跡することはありません。
Git の中でファイル名を変更しても、「ファイル名を変更した」というメタデータは Git には保存されないのです。
しかし Git は賢いので、ファイル名が変わったことを知ることができます。ファイルの移動を検出する仕組みについては後ほど説明します。</p>
<p>しかし Git には <code class="literal">mv</code> コマンドがあります。ちょっと混乱するかもしれませんね。
Git の中でファイル名を変更したい場合は次のようなコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv file_from file_to</code></pre>
</figure>
<p>このようなコマンドを実行してからステータスを確認すると、Git はそれをファイル名が変更されたと解釈していることがわかるでしょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv README.md README
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>しかし、実際のところこれは、次のようなコマンドを実行するのと同じ意味となります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mv README.md README
<span style="font-weight: bold">$</span> git rm README.md
<span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>Git はこれが暗黙的なファイル名の変更であると理解するので、この方法であろうが <code class="literal">mv</code> コマンドを使おうがどちらでもかまいません。
唯一の違いは、この方法だと 3 つのコマンドが必要になるかわりに <code class="literal">mv</code> だとひとつのコマンドだけで実行できるという点です。
より重要なのは、ファイル名の変更は何でもお好みのツールで行えるということです。あとでコミットする前に add/rm を指示してやればいいのです。</p>
</section>
</section>
<section class="sect1" title="コミット履歴の閲覧">
<h2 id="r_viewing_history">コミット履歴の閲覧</h2>
<p>何度かコミットを繰り返すと、あるいはコミット履歴つきの既存のリポジトリをクローンすると、
過去に何が起こったのかを振り返りたくなることでしょう。
そのために使用するもっとも基本的かつパワフルな道具が <code class="literal">git log</code> コマンドです。</p>
<p>ここからの例では、“simplegit” という非常にシンプルなプロジェクトを使用します。これは、次のようにして取得できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/simplegit-progit</code></pre>
</figure>
<p>このプロジェクトで <code class="literal">git log</code> を実行すると、このような結果が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit</code></pre>
</figure>
<p>デフォルトで引数を何も指定しなければ、<code class="literal">git log</code> はそのリポジトリでのコミットを新しい順に表示します。
つまり、直近のコミットが最初に登場するということです。
ごらんのとおり、このコマンドは各コミットについて SHA-1 チェックサム・作者の名前とメールアドレス・コミット日時・コミットメッセージを一覧表示します。</p>
<p><code class="literal">git log</code> コマンドには数多くのバラエティに富んだオプションがあり、あなたが本当に見たいものを表示させることができます。ここでは、人気の高いオプションのいくつかをご覧に入れましょう。</p>
<p>もっとも便利なオプションのひとつが <code class="literal">-p</code> で、これは各コミットで反映された変更点を表示します。また <code class="literal">-2</code> は、直近の 2 エントリだけを出力します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &#39;rake/gempackagetask&#39;
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   &quot;simplegit&quot;
-    s.version   =   &quot;0.1.0&quot;
+    s.version   =   &quot;0.1.1&quot;
     s.author    =   &quot;Scott Chacon&quot;
     s.email     =   &quot;schacon@gee-mail.com&quot;
     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file</code></pre>
</figure>
<p>このオプションは、先ほどと同じ情報を表示するとともに、各エントリの直後にその diff を表示します。
これはコードレビューのときに非常に便利です。また、他のメンバーが一連のコミットで何を行ったのかをざっと眺めるのにも便利でしょう。
また、<code class="literal">git log</code> では「まとめ」系のオプションを使うこともできます。
たとえば、各コミットに関するちょっとした統計情報を見たい場合は <code class="literal">--stat</code> オプションを使用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)</code></pre>
</figure>
<p>ごらんの通り <code class="literal">--stat</code> オプションは、各コミットエントリに続けて変更されたファイルの一覧と変更されたファイルの数、追加・削除された行数が表示されます。
また、それらの情報のまとめを最後に出力します。</p>
<p>もうひとつの便利なオプションが <code class="literal">--pretty</code> です。
これは、ログをデフォルトの書式以外で出力します。
あらかじめ用意されているいくつかのオプションを指定することができます。
<code class="literal">oneline</code> オプションは、各コミットを一行で出力します。
これは、大量のコミットを見る場合に便利です。
さらに <code class="literal">short</code> や <code class="literal">full</code> そして <code class="literal">fuller</code> といったオプションもあり、
これは標準とほぼ同じ書式だけれども情報量がそれぞれ少なめあるいは多めになります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</code></pre>
</figure>
<p>もっとも興味深いオプションは <code class="literal">format</code> で、これは独自のログ出力フォーマットを指定することができます。
これは、出力結果を機械にパースさせる際に非常に便利です。
自分でフォーマットを指定しておけば、将来 Git をアップデートしても結果が変わらないようにできるからです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h - %an, %ar : %s&quot;</span>
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</code></pre>
</figure>
<p><a id="xref-rpretty_format" href="#rpretty_format" class="xref"><code class="literal">git log --pretty=format</code> 用の便利なオプション</a> は、format で使用できる便利なオプションをまとめたものです。</p>
<div class="table">
<div class="content">
<table id="rpretty_format" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 1. <code class="literal">git log --pretty=format</code> 用の便利なオプション</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>オプション</th>
<th>出力される内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">%H</code></p></td>
<td><p>コミットのハッシュ</p></td>
</tr>
<tr>
<td><p><code class="literal">%h</code></p></td>
<td><p>コミットのハッシュ (短縮版)</p></td>
</tr>
<tr>
<td><p><code class="literal">%T</code></p></td>
<td><p>ツリーのハッシュ</p></td>
</tr>
<tr>
<td><p><code class="literal">%t</code></p></td>
<td><p>ツリーのハッシュ (短縮版)</p></td>
</tr>
<tr>
<td><p><code class="literal">%P</code></p></td>
<td><p>親のハッシュ</p></td>
</tr>
<tr>
<td><p><code class="literal">%p</code></p></td>
<td><p>親のハッシュ (短縮版)</p></td>
</tr>
<tr>
<td><p><code class="literal">%an</code></p></td>
<td><p>Author の名前</p></td>
</tr>
<tr>
<td><p><code class="literal">%ae</code></p></td>
<td><p>Author のメールアドレス</p></td>
</tr>
<tr>
<td><p><code class="literal">%ad</code></p></td>
<td><p>Author の日付 (--date= オプションに従った形式)</p></td>
</tr>
<tr>
<td><p><code class="literal">%ar</code></p></td>
<td><p>Author の相対日付</p></td>
</tr>
<tr>
<td><p><code class="literal">%cn</code></p></td>
<td><p>Committer の名前</p></td>
</tr>
<tr>
<td><p><code class="literal">%ce</code></p></td>
<td><p>Committer のメールアドレス</p></td>
</tr>
<tr>
<td><p><code class="literal">%cd</code></p></td>
<td><p>Committer の日付</p></td>
</tr>
<tr>
<td><p><code class="literal">%cr</code></p></td>
<td><p>Committer の相対日付</p></td>
</tr>
<tr>
<td><p><code class="literal">%s</code></p></td>
<td><p>件名</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p><em>author</em> と <em>committer</em> は何が違うのか気になる方もいるでしょう。
authorとはその作業をもともと行った人、committerとはその作業を適用した人のことを指します。
あなたがとあるプロジェクトにパッチを送り、コアメンバーのだれかがそのパッチを適用したとしましょう。
この場合、両方がクレジットされます (あなたがauthor、コアメンバーがcommitterです)。
この区別については<a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">Git での分散作業</a>でもう少し詳しく説明します。</p>
<p><code class="literal">oneline`オプションおよび`format`オプションは、`log</code> のもうひとつのオプションである <code class="literal">--graph</code> と組み合わせるとさらに便利です。
このオプションは、ちょっといい感じのアスキーグラフでブランチやマージの歴史を表示します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span> --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &#39;master&#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &#39;defunkt&#39; into local</code></pre>
</figure>
<p>こういった表示の良さは、ブランチやマージに関する次章を読むと明らかになるでしょう。</p>
<p>これらは <code class="literal">git log</code> の出力フォーマット指定のほんの一部でしかありません。
まだまだオプションはあります。
<a id="xref-rlog_options" href="#rlog_options" class="xref">`git log`のよく使われるオプション</a> に、今まで取り上げたオプションやそれ以外によく使われるオプション、
そしてそれぞれが`log`の出力をどのように変えるのかをまとめました。</p>
<div class="table">
<div class="content">
<table id="rlog_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 2. `git log`のよく使われるオプション</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>オプション</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-p</code></p></td>
<td><p>各コミットのパッチを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--stat</code></p></td>
<td><p>各コミットで変更されたファイルの統計情報を表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--shortstat</code></p></td>
<td><p>--stat コマンドのうち、変更/追加/削除 の行だけを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-only</code></p></td>
<td><p>コミット情報の後に変更されたファイルの一覧を表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-status</code></p></td>
<td><p>変更されたファイルと 追加/修正/削除 情報を表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--abbrev-commit</code></p></td>
<td><p>SHA-1 チェックサムの全体 (40文字) ではなく最初の数文字のみを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--relative-date</code></p></td>
<td><p>完全な日付フォーマットではなく、相対フォーマット (“2 weeks ago” など) で日付を表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--graph</code></p></td>
<td><p>ブランチやマージの歴史を、ログ出力とともにアスキーグラフで表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--pretty</code></p></td>
<td><p>コミットを別のフォーマットで表示する。オプションとして oneline, short, full, fuller そして format (独自フォーマットを設定する) を指定可能</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<section class="sect2" title="ログ出力の制限">
<h3 id="_ログ出力の制限">ログ出力の制限</h3>
<p>出力のフォーマット用オプションだけでなく、
<code class="literal">git log</code> にはログの制限用の便利なオプションもあります。
コミットの一部だけを表示するようなオプションのことです。
既にひとつだけ紹介していますね。
<code class="literal">-2</code> オプション、これは直近のふたつのコミットだけを表示するものです。
実は <code class="literal">-&lt;n&gt;</code> の <code class="literal">n</code> には任意の整数値を指定することができ、直近の <code class="literal">n</code> 件のコミットだけを表示させることができます。
ただ、実際のところはこれを使うことはあまりないでしょう。
というのも、Git はデフォルトですべての出力をページャにパイプするので、
ログを一度に 1 ページだけ見ることになるからです。</p>
<p>しかし <code class="literal">--since</code> や <code class="literal">--until</code> のような時間制限のオプションは非常に便利です。
たとえばこのコマンドは、過去二週間のコミットの一覧を取得します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --since=2.weeks</code></pre>
</figure>
<p>このコマンドはさまざまな書式で動作します。特定の日を指定する (<code class="literal">"2008-01-15"</code>) こともできますし、
相対日付を`"2 years 1 day 3 minutes ago"`のように指定することも可能です。</p>
<p>コミット一覧から検索条件にマッチするものだけを取り出すこともできます。
<code class="literal">--author</code> オプションは特定のauthorのみを抜き出し、
<code class="literal">--grep</code> オプションはコミットメッセージの中のキーワードを検索します
（author と grep を両方指定する場合は、`--all-match`オプションも一緒に使ってください。
そうしないと、どちらか一方にだけマッチするものも対象になってしまいます）。</p>
<p>もうひとつ、`-S`オプションというとても便利なフィルタがあります。
このオプションは任意の文字列を引数にでき、その文字列が追加・削除されたコミットのみを抜き出してくれます。
仮に、とある関数の呼び出しをコードに追加・削除したコミットのなかから、最新のものが欲しいとしましょう。こうすれば探すことができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -Sfunction_name</code></pre>
</figure>
<p>最後に紹介する <code class="literal">git log</code> のフィルタリング用オプションは、パスです。
ディレクトリ名あるいはファイル名を指定すると、それを変更したコミットのみが対象となります。
このオプションは常に最後に指定し、一般にダブルダッシュ (<code class="literal">--</code>) の後に記述します。
このダブルダッシュが他のオプションとパスの区切りとなります。</p>
<p><a id="xref-rlimit_options" href="#rlimit_options" class="xref">`git log`の出力を制限するためのオプション</a> に、これらのオプションとその他の一般的なオプションをまとめました。</p>
<div class="table">
<div class="content">
<table id="rlimit_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 3. `git log`の出力を制限するためのオプション</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>オプション</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-(n)</code></p></td>
<td><p>直近の n 件のコミットのみを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--since</code>, <code class="literal">--after</code></p></td>
<td><p>指定した日付より後に作成されたコミットのみに制限する</p></td>
</tr>
<tr>
<td><p><code class="literal">--until</code>, <code class="literal">--before</code></p></td>
<td><p>指定した日付より前に作成されたコミットのみに制限する</p></td>
</tr>
<tr>
<td><p><code class="literal">--author</code></p></td>
<td><p>エントリが指定した文字列にマッチするコミットのみを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--committer</code></p></td>
<td><p>エントリが指定した文字列にマッチするコミットのみを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">--grep</code></p></td>
<td><p>指定した文字列がコミットメッセージに含まれているコミットのみを表示する</p></td>
</tr>
<tr>
<td><p><code class="literal">-S</code></p></td>
<td><p>指定した文字列をコードに追加・削除したコミットのみを表示する</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>一つ例を挙げておきましょう。Git ソースツリーのテストファイルに対する変更があったコミットのうち、Junio Hamano がコミットしたものでかつ2008年10月にマージされたものを知りたければ、次のように指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=<span style="font-style: italic">&quot;%h - %s&quot;</span> --author=gitster --since=<span style="font-style: italic">&quot;2008-10-01&quot;</span> <span style="font-weight: bold; font-style: italic">\</span>
   --before=<span style="font-style: italic">&quot;2008-11-01&quot;</span> --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD
b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</code></pre>
</figure>
<p>約 40,000 件におよぶ Git ソースコードのコミットの歴史の中で、このコマンドの条件にマッチするのは 6 件となります。</p>
</section>
</section>
<section class="sect1" title="作業のやり直し">
<h2 id="r_undoing">作業のやり直し</h2>
<p>どんな場面であっても、何かをやり直したくなることはあります。
ここでは、行った変更を取り消すための基本的なツールについて説明します。
注意点は、ここで扱う内容の中には「やり直しのやり直し」ができないものもあるということです。
Git で何か間違えたときに作業内容を失ってしまう数少ない例がここにあります。</p>
<p>やり直しを行う場面としてもっともよくあるのは、「コミットを早まりすぎて追加すべきファイルを忘れてしまった」「コミットメッセージが変になってしまった」などです。
そのコミットをもう一度やりなおす場合は、<code class="literal">--amend</code> オプションをつけてもう一度コミットします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>このコマンドは、ステージングエリアの内容をコミットに使用します。
直近のコミット以降に何も変更をしていない場合 (たとえば、コミットの直後にこのコマンドを実行したような場合)、
スナップショットの内容はまったく同じでありコミットメッセージを変更することになります。</p>
<p>コミットメッセージのエディタが同じように立ち上がりますが、既に前回のコミット時のメッセージが書き込まれた状態になっています。
ふだんと同様にメッセージを編集できますが、前回のコミット時のメッセージがその内容で上書きされます。</p>
<p>たとえば、いったんコミットした後、何かのファイルをステージするのを忘れていたのに気づいたとしましょう。そんな場合はこのようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial commit&#39;</span>
<span style="font-weight: bold">$</span> git add forgotten_file
<span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>最終的にできあがるのはひとつのコミットです。二番目のコミットが、最初のコミットの結果を上書きするのです。</p>
<section class="sect2" title="ステージしたファイルの取り消し">
<h3 id="r_unstaging">ステージしたファイルの取り消し</h3>
<p>続くふたつのセクションでは、ステージングエリアと作業ディレクトリの変更に関する作業を扱います。
すばらしいことに、これらふたつの場所の状態を表示するコマンドを使用すると、変更内容を取り消す方法も同時に表示されます。
たとえば、ふたつのファイルを変更し、それぞれを別のコミットとするつもりだったのに間違えて <code class="literal">git add *</code> と打ち込んでしまったときのことを考えましょう。
ファイルが両方ともステージされてしまいました。
ふたつのうちの一方だけのステージを解除するにはどうすればいいでしょう?
<code class="literal">git status</code> コマンドが教えてくれます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>“Changes to be committed” の直後に、"use <code class="literal">git reset HEAD &lt;file&gt;...</code> to unstage" と書かれています。このアドバイスに従って、<code class="literal">CONTRIBUTING.md</code> ファイルのステージを解除してみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>ちょっと奇妙に見えるコマンドですが、きちんと動作します。
<code class="literal">CONTRIBUTING.md</code> ファイルは、変更されたもののステージされていない状態に戻りました。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p><code class="literal">git reset</code> は、危険なコマンドに_なりえます_。その条件は、「<code class="literal">--hard`オプションをつけて実行すること」です。
ただし、上述の例はそうしておらず、作業ディレクトリにあるファイルに変更は加えられていません。
`git reset</code> をオプションなしで実行するのは危険ではありません。
ステージングエリアのファイルに変更が加えられるだけなのです。</p>
</div>
</aside>
<p>今のところは、`git reset`については上記の魔法の呪文を知っておけば十分でしょう。<a id="xref--ch07-git-tools--r_git_reset" href="ch07-git-tools.xhtml#r_git_reset" class="xref">リセットコマンド詳説</a>で、より詳細に、`reset`の役割と使いこなし方について説明します。色々とおもしろいことができるようになりますよ。</p>
</section>
<section class="sect2" title="ファイルへの変更の取り消し">
<h3 id="_ファイルへの変更の取り消し">ファイルへの変更の取り消し</h3>
<p><code class="literal">CONTRIBUTING.md</code> に加えた変更が、実は不要なものだったとしたらどうしますか?
変更を取り消す (直近のコミット時点の状態、あるいは最初にクローンしたり最初に作業ディレクトリに取得したときの状態に戻す) 最も簡単な方法は?
幸いなことに、またもや <code class="literal">git status</code> がその方法を教えてくれます。
先ほどの例の出力結果で、ステージされていないファイル一覧の部分を見てみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>とても明確に、変更を取り消す方法が書かれています 。
ではそのとおりにしてみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -- CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>変更が取り消されたことがわかります。</p>
<aside class="admonition important" title="Important" epub:type="warning">
<div class="content">
<p>ここで理解しておくべきなのが、`git checkout&#8201;&#8212;&#8201;[file]`は危険なコマンドだ、ということです。
あなたがファイルに加えた変更はすべて消えてしまいます。変更した内容を、別のファイルで上書きしたのと同じことになります。そのファイルが不要であることが確実にわかっているとき以外は、このコマンドを使わないようにしましょう。</p>
</div>
</aside>
<p>やりたいことが、「ファイルに加えた変更はとっておきつつ、一時的に横に追いやっておきたい」ということであれば、<a href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> で説明する stash やブランチを調べてみましょう。一般にこちらのほうがおすすめの方法です。</p>
<p>Git に<em>コミットした</em>内容のすべては、ほぼ常に取り消しが可能であることを覚えておきましょう。
削除したブランチへのコミットや <code class="literal">--amend</code> コミットで上書きされた元のコミットでさえも復旧することができます (データの復元方法については <a id="xref--ch10-git-internals--r_data_recovery" href="ch10-git-internals.xhtml#r_data_recovery" class="xref">データリカバリ</a> を参照ください)。
しかし、まだコミットしていない内容を失ってしまうと、それは二度と取り戻せません。</p>
</section>
</section>
<section class="sect1" title="リモートでの作業">
<h2 id="r_remote_repos">リモートでの作業</h2>
<p>Git を使ったプロジェクトで共同作業を進めていくには、リモートリポジトリの扱い方を知る必要があります。
リモートリポジトリとは、インターネット上あるいはその他ネットワーク上のどこかに存在するプロジェクトのことです。
複数のリモートリポジトリを持つこともできますし、それぞれを読み込み専用にしたり読み書き可能にしたりすることもできます。
他のメンバーと共同作業を進めていくにあたっては、これらのリモートリポジトリを管理し、必要に応じてデータのプル・プッシュを行うことで作業を分担していくことになります。
リモートリポジトリの管理には「リモートリポジトリの追加」「不要になったリモートリポジトリの削除」「リモートブランチの管理や追跡対象/追跡対象外の設定」などさまざまな作業が含まれます。
このセクションでは、これらのうちいくつかの作業について説明します。</p>
<section class="sect2" title="リモートの表示">
<h3 id="_リモートの表示">リモートの表示</h3>
<p>今までにどのリモートサーバーを設定したのかを知るには <code class="literal">git remote</code> コマンドを実行します。
これは、今までに設定したリモートハンドルの名前を一覧表示します。
リポジトリをクローンしたのなら、少なくとも origin という名前が見えるはずです。
これは、クローン元のサーバーに対して Git がデフォルトでつける名前です。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/ticgit
Cloning into &#39;ticgit&#39;...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> cd ticgit
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
<p><code class="literal">-v</code> を指定すると、その名前に対応するURLを書き込み用と読み取り用の2つ表示します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)</code></pre>
</figure>
<p>複数のリモートを設定している場合は、このコマンドはそれをすべて表示します。
たとえば、他のメンバーとの共同作業のために複数のリモートが設定してあるリポジトリの場合、このようになっています。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd grit
<span style="font-weight: bold">$</span> git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)</code></pre>
</figure>
<p>つまり、これらのユーザーによる変更を容易にプルして取り込めるということです。
さらに、これらのうちのいくつかにはプッシュできる場合もあります（この表示からはそれは読み取れませんが）。</p>
<p>ここでは、リモートのプロトコルが多様であることに注意しておきましょう。<a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">サーバー用の Git の取得</a>で、これについて詳しく説明します。</p>
</section>
<section class="sect2" title="リモートリポジトリの追加">
<h3 id="_リモートリポジトリの追加">リモートリポジトリの追加</h3>
<p>これまでのセクションでも何度かリモートリポジトリの追加を行ってきましたが、
ここで改めてその方法をきちんと説明しておきます。
新しいリモート Git リポジトリにアクセスしやすいような名前をつけて追加するには、
<code class="literal">git remote add &lt;shortname&gt; &lt;url&gt;</code> を実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote
origin
<span style="font-weight: bold">$</span> git remote add pb https://github.com/paulboone/ticgit
<span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)</code></pre>
</figure>
<p>これで、コマンドラインに URL を全部打ち込むかわりに <code class="literal">pb</code> という文字列を指定するだけでよくなりました。
たとえば、Paul が持つ情報の中で自分のリポジトリにまだ存在しないものをすべて取得するには、<code class="literal">git fetch pb</code> を実行すればよいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -&gt; pb/master
 * [new branch]      ticgit     -&gt; pb/ticgit</code></pre>
</figure>
<p>Paul の master ブランチは、ローカルでは <code class="literal">pb/master</code> としてアクセスできます。
これを自分のブランチにマージしたり、ローカルブランチとしてチェックアウトして中身を調べたりといったことが可能となります。
（ブランチの役割と使い方については、 <a href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> で詳しく説明します。）</p>
</section>
<section class="sect2" title="リモートからのフェッチ、そしてプル">
<h3 id="r_fetching_and_pulling">リモートからのフェッチ、そしてプル</h3>
<p>ごらんいただいたように、データをリモートリポジトリから取得するには次のコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch [remote-name]</code></pre>
</figure>
<p>このコマンドは、リモートプロジェクトのすべてのデータの中からまだあなたが持っていないものを引き出します。
実行後は、リモートにあるすべてのブランチを参照できるようになり、いつでもそれをマージしたり中身を調べたりすることが可能となります。</p>
<p>リポジトリをクローンしたときには、リモートリポジトリに対して自動的に “origin” という名前がつけられます。
つまり、<code class="literal">git fetch origin</code> とすると、クローンしたとき (あるいは直近でフェッチを実行したとき) 以降にサーバーにプッシュされた変更をすべて取得することができます。
ひとつ注意すべき点は、 <code class="literal">git fetch</code> コマンドはデータをローカルリポジトリに引き出すだけだということです。
ローカルの環境にマージされたり作業中の内容を書き換えたりすることはありません。
したがって、必要に応じて自分でマージをする必要があります。</p>
<p>リモートブランチを追跡するためのブランチを作成すれば (次のセクションと <a href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> で詳しく説明します)、<code class="literal">git pull</code> コマンドを使うことができます。
これは、自動的にフェッチを行い、リモートブランチの内容を現在のブランチにマージします。
おそらくこのほうが、よりお手軽で使いやすいことでしょう。
また、 <code class="literal">git clone</code> コマンドはローカルの master ブランチ（実際のところ、デフォルトブランチであれば名前はなんでもかまいません）がリモートの master ブランチを追跡するよう、デフォルトで自動設定します。
<code class="literal">git pull</code> を実行すると、通常は最初にクローンしたサーバーからデータを取得し、現在作業中のコードへのマージを試みます。</p>
</section>
<section class="sect2" title="リモートへのプッシュ">
<h3 id="r_pushing_remotes">リモートへのプッシュ</h3>
<p>あなたのプロジェクトがみんなと共有できる状態に達したら、それを上流にプッシュしなければなりません。
そのためのコマンドが <code class="literal">git push [remote-name] [branch-name]</code> です。
追加したコミットを <code class="literal">origin</code> サーバー (何度も言いますが、クローンした時点でこのブランチ名とサーバー名が自動設定されます) にプッシュしたい場合は、このように実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
<p>このコマンドが動作するのは、自分が書き込みアクセス権を持つサーバーからクローンし、かつその後だれもそのサーバーにプッシュしていない場合のみです。
あなた以外の誰かが同じサーバーからクローンし、誰かが上流にプッシュした後で自分がプッシュしようとすると、それは拒否されます。
拒否された場合は、まず誰かがプッシュした作業内容を引き出してきてローカル環境で調整してからでないとプッシュできません。
リモートサーバーへのプッシュ方法の詳細については <a href="ch03-git-branching.xhtml" class="xref">Git のブランチ機能</a> を参照ください。</p>
</section>
<section class="sect2" title="リモートの調査">
<h3 id="r_inspecting_remote">リモートの調査</h3>
<p>特定のリモートの情報をより詳しく知りたい場合は <code class="literal">git remote show [remote-name]</code> コマンドを実行します。
たとえば <code class="literal">origin</code> のように名前を指定すると、このような結果が得られます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for &#39;git pull&#39;:
    master merges with remote master
  Local ref configured for &#39;git push&#39;:
    master pushes to master (up to date)</code></pre>
</figure>
<p>リモートリポジトリの URL と、追跡対象になっているブランチの情報が表示されます。
また、ご丁寧にも「master ブランチ上で <code class="literal">git pull</code> すると、リモートの情報を取得した後で自動的にリモートの master ブランチの内容をマージする」という説明があります。
さらに、引き出してきたすべてのリモート情報も一覧表示されます。</p>
<p>ただし、これはほんの一例にすぎません。Git をもっと使い込むようになると、<code class="literal">git remote show</code> で得られる情報はどんどん増えていきます。たとえば次のような結果を得ることになるかもしれません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use &#39;git remote prune&#39; to remove)
  Local branches configured for &#39;git pull&#39;:
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for &#39;git push&#39;:
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)</code></pre>
</figure>
<p>このコマンドは、特定のブランチ上で <code class="literal">git push</code> したときにどのブランチに自動プッシュされるのかを表示しています。
また、サーバー上のリモートブランチのうちまだ手元に持っていないもの、手元にあるブランチのうちすでにサーバー上では削除されているもの、<code class="literal">git pull</code> を実行したときに自動的にマージされるブランチなども表示されています。</p>
</section>
<section class="sect2" title="リモートの削除・リネーム">
<h3 id="_リモートの削除_リネーム">リモートの削除・リネーム</h3>
<p>リモートを参照する名前を変更したい場合、 <code class="literal">git remote rename</code> を使うことができます。
たとえば <code class="literal">pb</code> を <code class="literal">paul</code> に変更したい場合は <code class="literal">git remote rename</code> をこのように実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rename pb paul
<span style="font-weight: bold">$</span> git remote
origin
paul</code></pre>
</figure>
<p>そうすると、リモートブランチ名も併せて変更されることを付け加えておきましょう。
これまで <code class="literal">pb/master</code> として参照していたブランチは、これからは <code class="literal">paul/master</code> となります。</p>
<p>何らかの理由でリモートを削除したい場合 (サーバーを移動したとか特定のミラーを使わなくなったとか、あるいはプロジェクトからメンバーが抜けたとかいった場合) は <code class="literal">git remote rm</code> を使用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rm paul
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="タグ">
<h2 id="r_git_tagging">タグ</h2>
<p></p>
<p>多くの VCS と同様に Git にもタグ機能があり、歴史上の重要なポイントに印をつけることができます。よくあるのは、この機能を (v 1.0など) リリースポイントとして使うことです。このセクションでは、既存のタグ一覧の取得や新しいタグの作成、さまざまなタグの形式などについて扱います。</p>
<section class="sect2" title="タグの一覧表示">
<h3 id="_タグの一覧表示">タグの一覧表示</h3>
<p>Git で既存のタグの一覧を表示するのは簡単で、
単に <code class="literal">git tag</code> と打ち込むだけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.3</code></pre>
</figure>
<p>このコマンドは、タグをアルファベット順に表示します。この表示順に深い意味はありません。</p>
<p>パターンを指定してタグを検索することもできます。Git のソースリポジトリを例にとると、500以上のタグが登録されています。その中で 1.8.5 系のタグのみを見たい場合は、このようにします。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -l <span style="font-style: italic">&quot;v1.8.5*&quot;</span>
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
v1.8.5.4
v1.8.5.5</code></pre>
</figure>
</section>
<section class="sect2" title="タグの作成">
<h3 id="_タグの作成">タグの作成</h3>
<p>Git のタグには、軽量 (lightweight) 版と注釈付き (annotated) 版の二通りがあります。</p>
<p>軽量版のタグは、変更のないブランチのようなものです。特定のコミットに対する単なるポインタでしかありません。</p>
<p>しかし注釈付きのタグは、Git データベース内に完全なオブジェクトとして格納されます。
チェックサムが付き、タグを作成した人の名前・メールアドレス・作成日時・タグ付け時のメッセージなども含まれます。
また、署名をつけて GNU Privacy Guard (GPG) で検証することもできます。
一般的には、これらの情報を含められる注釈付きのタグを使うことをおすすめします。
しかし、一時的に使うだけのタグである場合や何らかの理由で情報を含めたくない場合は、
軽量版のタグも使用可能です。</p>
</section>
<section class="sect2" title="注釈付きのタグ">
<h3 id="r_annotated_tags">注釈付きのタグ</h3>
<p></p>
<p>Git では、注釈付きのタグをシンプルな方法で作成できます。もっとも簡単な方法は、<code class="literal">tag</code> コマンドの実行時に <code class="literal">-a</code> を指定することです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.4 -m <span style="font-style: italic">&quot;my version 1.4&quot;</span>
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4</code></pre>
</figure>
<p><code class="literal">-m</code> で、タグ付け時のメッセージを指定します。これはタグとともに格納されます。注釈付きタグの作成時にメッセージを省略すると、エディタが立ち上がるのでそこでメッセージを記入します。</p>
<p>タグのデータとそれに関連づけられたコミットを見るには <code class="literal">git show</code> コマンドを使用します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4
tag v1.4
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
<p>タグ付けした人の情報とその日時、そして注釈メッセージを表示したあとにコミットの情報が続きます。</p>
</section>
<section class="sect2" title="軽量版のタグ">
<h3 id="_軽量版のタグ">軽量版のタグ</h3>
<p></p>
<p>コミットにタグをつけるもうひとつの方法が、軽量版のタグです。
これは基本的に、コミットのチェックサムだけを保持するもので、それ以外の情報は含まれません。
軽量版のタグを作成するには <code class="literal">-a</code>、<code class="literal">-s</code> あるいは <code class="literal">-m</code> といったオプションをつけずにコマンドを実行します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag v1.4-lw
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5</code></pre>
</figure>
<p>このタグに対して <code class="literal">git show</code> を実行しても、先ほどのような追加情報は表示されません。
単に、対応するコミットの情報を表示するだけです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
</section>
<section class="sect2" title="後からのタグ付け">
<h3 id="_後からのタグ付け">後からのタグ付け</h3>
<p>過去にさかのぼってコミットにタグ付けすることもできます。
仮にあなたのコミットの歴史が次のようなものであったとしましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#39;experiment&#39;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#39;experiment&#39;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</code></pre>
</figure>
<p>今になって、このプロジェクトに v1.2のタグをつけるのを忘れていたことに気づきました。
本来なら “updated rakefile” のコミットにつけておくべきだったものです。
しかし今からでも遅くありません。
特定のコミットにタグをつけるには、そのコミットのチェックサム (あるいはその一部) をコマンドの最後に指定します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.2 9fceb02</code></pre>
</figure>
<p>これで、そのコミットにタグがつけられたことが確認できます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

<span style="font-weight: bold">$</span> git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...</code></pre>
</figure>
</section>
<section class="sect2" title="タグの共有">
<h3 id="r_sharing_tags">タグの共有</h3>
<p>デフォルトでは、<code class="literal">git push</code> コマンドはタグ情報をリモートに送りません。
タグを作ったら、タグをリモートサーバーにプッシュするよう明示する必要があります。
その方法は、リモートブランチを共有するときと似ています。
<code class="literal">git push origin [tagname]</code> を実行するのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.5 -&gt; v1.5</code></pre>
</figure>
<p>多くのタグを一度にプッシュしたい場合は、
<code class="literal">git push</code> コマンドのオプション <code class="literal">--tags</code> を使用します。
これは、手元にあるタグのうちまだリモートサーバーに存在しないものをすべて転送します。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.4 -&gt; v1.4
 * [new tag]         v1.4-lw -&gt; v1.4-lw</code></pre>
</figure>
<p>これで、誰か他の人がリポジトリのクローンやプルを行ったときにすべてのタグを取得できるようになりました。</p>
</section>
<section class="sect2" title="タグのチェックアウト">
<h3 id="_タグのチェックアウト">タグのチェックアウト</h3>
<p>実際のところ、タグのチェックアウトはGitではできないも同然です。
というのも、タグ付けされた内容に変更を加えられないからです。
仮に、とある時点でのリポジトリの内容を、
タグ付けされたような形で作業ディレクトリに保持したいとしましょう。
その場合、<code class="literal">git checkout -b [branchname] [tagname]</code> を実行すると特定のタグと紐付けたブランチを作成することはできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b version2 v2.0.0
Switched to a new branch &#39;version2&#39;</code></pre>
</figure>
<p>とはいえ、この状態でコミットを追加すると、 <code class="literal">version2</code> ブランチは <code class="literal">v2.0.0</code> タグの内容とは異なってしまいます。
ブランチの状態が先へ進んでしまうからです。十分に気をつけて作業しましょう。</p>
</section>
</section>
<section class="sect1" title="Git エイリアス">
<h2 id="r_git_aliases">Git エイリアス</h2>
<p></p>
<p>この章で進めてきたGitの基本に関する説明を終える前に、ひとつヒントを教えましょう。Gitの使い勝手をシンプルに、簡単に、わかりやすくしてくれる、エイリアスです。</p>
<p>Git は、コマンドの一部だけが入力された状態でそのコマンドを自動的に推測することはありません。
Git の各コマンドをいちいち全部入力するのがいやなら、 <code class="literal">git config</code> でコマンドのエイリアスを設定することができます。
たとえばこんなふうに設定すると便利かもしれません。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.co checkout
<span style="font-weight: bold">$</span> git config --global alias.br branch
<span style="font-weight: bold">$</span> git config --global alias.ci commit
<span style="font-weight: bold">$</span> git config --global alias.st status</code></pre>
</figure>
<p>こうすると、たとえば <code class="literal">git commit</code> と同じことが単に <code class="literal">git ci</code> と入力するだけでできるようになります。
Git を使い続けるにつれて、よく使うコマンドがさらに増えてくることでしょう。
そんな場合は、きにせずどんどん新しいエイリアスを作りましょう。</p>
<p>このテクニックは、「こんなことできたらいいな」というコマンドを作る際にも便利です。
たとえば、ステージを解除するときにどうしたらいいかいつも迷うという人なら、
こんなふうに自分で unstage エイリアスを追加してしまえばいいのです。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.unstage <span style="font-style: italic">&#39;reset HEAD --&#39;</span></code></pre>
</figure>
<p>こうすれば、次のふたつのコマンドが同じ意味となります。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git unstage fileA
<span style="font-weight: bold">$</span> git reset HEAD -- fileA</code></pre>
</figure>
<p>少しはわかりやすくなりましたね。あるいは、こんなふうに <code class="literal">last</code> コマンドを追加することもできます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.last <span style="font-style: italic">&#39;log -1 HEAD&#39;</span></code></pre>
</figure>
<p>こうすれば、直近のコミットの情報を見ることができます。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</code></pre>
</figure>
<p>Git が単に新しいコマンドをエイリアスで置き換えていることがわかります。
しかし、時には Git のサブコマンドではなく外部コマンドを実行したくなることもあるでしょう。
そんな場合は、コマンドの先頭に <code class="literal">!</code> をつけます。
これは、Git リポジトリ上で動作する自作のツールを書くときに便利です。
例として、<code class="literal">git visual</code> で <code class="literal">gitk</code> が起動するようにしてみましょう。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.visual <span style="font-style: italic">&#39;!gitk&#39;</span></code></pre>
</figure>
</section>
<section class="sect1" title="まとめ">
<h2 id="_まとめ">まとめ</h2>
<p>これで、ローカルでの Git の基本的な操作がこなせるようになりました。リポジトリの作成やクローン、リポジトリへの変更・ステージ・コミット、リポジトリのこれまでの変更履歴の閲覧などです。
次は、Git の強力な機能であるブランチモデルについて説明しましょう。</p>
</section>
</section>
</body>
</html>