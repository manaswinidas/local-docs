<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="UTF-8"/>
<title>Git 基础</title>
<link rel="stylesheet" type="text/css" href="styles/epub3.css"/>
<link rel="stylesheet" type="text/css" href="styles/epub3-css3-only.css" media="(min-device-width: 0px)"/>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(event, reader) {
  if (!(reader = navigator.epubReadingSystem)) {
    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };
    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;
  }
  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));
});
</script>
</head>
<body>
<section class="chapter" title="Git 基础" epub:type="chapter" id="ch02-git-basics">
<header>
<div class="chapter-header">
<h1 class="chapter-title"><small class="subtitle"><b>Git</b> <b>基础</b></small></h1>
</div>
</header>
<div class="abstract" epub:type="preamble">
<p>假如你只能阅读一章来学习 Git，本章就是你的不二选择。
本章内容涵盖你在使用 Git 完成各种工作中将要使用的各种基本命令。
在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。
本章也将向你演示如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p>
</div>
<section class="sect1" title="获取 Git 仓库">
<h2 id="r_getting_a_repo">获取 Git 仓库</h2>
<p>有两种取得 Git 项目仓库的方法。
第一种是在现有项目或目录下导入所有文件到 Git 中；
第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<section class="sect2" title="在现有目录中初始化仓库">
<h3 id="_在现有目录中初始化仓库">在现有目录中初始化仓库</h3>
<p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git init</code></pre>
</figure>
<p>该命令将创建一个名为 <code class="literal">.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。
但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。
(参见 <a id="xref--ch10-git-internals" href="ch10-git-internals.xhtml" class="xref">Git 内部原理</a> 来了解更多关于到底 <code class="literal">.git</code> 文件夹中包含了哪些文件的信息。)</p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。
你可通过 <code class="literal">git add</code> 命令来实现对指定文件的跟踪，然后执行 <code class="literal">git commit</code> 提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *.c
<span style="font-weight: bold">$</span> git add LICENSE
<span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial project version&#39;</span></code></pre>
</figure>
<p>稍后我们再逐一解释每一条指令的意思。
现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git 仓库。</p>
</section>
<section class="sect2" title="克隆现有的仓库">
<h3 id="r_git_cloning">克隆现有的仓库</h3>
<p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code class="literal">git clone</code> 命令。
如果你对其它的 VCS 系统（比如说Subversion）很熟悉，请留心一下你所使用的命令是"clone"而不是"checkout"。
这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。
当你执行 <code class="literal">git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。
事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在，详见 <a id="xref--ch04-git-server--r_git_on_the_server" href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在服务器上搭建 Git</a> ）。</p>
<p>克隆仓库的命令格式是 <code class="literal">git clone [url]</code> 。
比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2</code></pre>
</figure>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code class="literal">.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code class="literal">.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。
如果你进入到这个新建的 <code class="literal">libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。
如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/libgit2/libgit2 mylibgit</code></pre>
</figure>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 <code class="literal">mylibgit</code>。</p>
<p>Git 支持多种数据传输协议。
上面的例子使用的是 <code class="literal">https://</code> 协议，不过你也可以使用 <code class="literal">git://</code> 协议或者使用 SSH 传输协议，比如 <code class="literal">user@server:path/to/repo.git</code> 。
<a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在服务器上搭建 Git</a> 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。</p>
</section>
</section>
<section class="sect1" title="记录每次更新到仓库">
<h2 id="_记录每次更新到仓库">记录每次更新到仓库</h2>
<p>现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。
接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。
已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。
工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。
初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。
我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p>
<figure class="image">
<div class="content">
<img src="images/lifecycle.png" alt="Git 下文件生命周期图。"/>
</div>
<figcaption>Figure 1. 文件的状态变化周期</figcaption>
</figure>
<section class="sect2" title="检查当前文件状态">
<h3 id="r_checking_status">检查当前文件状态</h3>
<p>要查看哪些文件处于什么状态，可以用 <code class="literal">git status</code> 命令。
如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
nothing to commit, working directory clean</code></pre>
</figure>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。
此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。
最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。
现在，分支名是 “master”,这是默认的分支名。
我们在 <a id="xref--ch03-git-branching" href="ch03-git-branching.xhtml" class="xref">Git 分支</a>  会详细讨论分支和引用。</p>
<p>现在，让我们在项目下创建一个新的 README 文件。
如果之前并不存在这个文件，使用 <code class="literal">git status</code> 命令，你将看到一个新的未跟踪文件：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;My Project&#39;</span> &gt; README
<span style="font-weight: bold">$</span> git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
</figure>
<p>在状态报告中可以看到新建的 README 文件出现在 <code class="literal">Untracked files</code> 下面。
未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，
这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。
不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
</section>
<section class="sect2" title="跟踪新文件">
<h3 id="r_tracking_files">跟踪新文件</h3>
<p>使用命令 <code class="literal">git add</code> 开始跟踪一个文件。
所以，要跟踪 README 文件，运行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>此时再运行 <code class="literal">git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README</code></pre>
</figure>
<p>只要在 <code class="literal">Changes to be committed</code> 这行下面的，就说明是已暂存状态。
如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。
你可能会想起之前我们使用 <code class="literal">git init</code> 后就运行了 <code class="literal">git add (files)</code> 命令，开始跟踪当前目录下的文件。
<code class="literal">git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
</section>
<section class="sect2" title="暂存已修改文件">
<h3 id="_暂存已修改文件">暂存已修改文件</h3>
<p>现在我们来修改一个已被跟踪的文件。
如果你修改了一个名为 <code class="literal">CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code class="literal">git status</code> 命令，会看到下面内容：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>文件 <code class="literal">CONTRIBUTING.md</code> 出现在 <code class="literal">Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。
要暂存这次更新，需要运行 <code class="literal">git add</code> 命令。
这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。
将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。
现在让我们运行 <code class="literal">git add</code> 将"CONTRIBUTING.md"放到暂存区，然后再看看 <code class="literal">git status</code> 的输出：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。
假设此时，你想要在 <code class="literal">CONTRIBUTING.md</code> 里再加条注释，
重新编辑存盘后，准备好提交。
不过且慢，再运行 <code class="literal">git status</code> 看看：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> vim CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>怎么回事？
现在 <code class="literal">CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。
这怎么可能呢？
好吧，实际上 Git 只不过暂存了你运行 <code class="literal">git add</code> 命令时的版本，
如果你现在提交，<code class="literal">CONTRIBUTING.md</code> 的版本是你最后一次运行 <code class="literal">git add</code> 命令时的那个版本，而不是你运行 <code class="literal">git commit</code> 时，在工作目录中的当前版本。
所以，运行了 <code class="literal">git add</code> 之后又作了修订的文件，需要重新运行 <code class="literal">git add</code> 把最新版本重新暂存起来：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
</section>
<section class="sect2" title="状态简览">
<h3 id="_状态简览">状态简览</h3>
<p><code class="literal">git status</code> 命令的输出十分详细，但其用语有些繁琐。
如果你使用 <code class="literal">git status -s</code> 命令或 <code class="literal">git status --short</code> 命令，你将得到一种更为紧凑的格式输出。
运行 <code class="literal">git status -s</code> ，状态报告输出如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</figure>
<p>新添加的未跟踪文件前面有 <code class="literal">??</code> 标记，新添加到暂存区中的文件前面有 <code class="literal">A</code> 标记，修改过的文件前面有 <code class="literal">M</code> 标记。
你可能注意到了 <code class="literal">M</code> 有两个可以出现的位置，出现在右边的 <code class="literal">M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code class="literal">M</code> 表示该文件被修改了并放入了暂存区。
例如，上面的状态报告显示： <code class="literal">README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code class="literal">lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。
而 <code class="literal">Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
</section>
<section class="sect2" title="忽略文件">
<h3 id="r_ignoring">忽略文件</h3>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。
在这种情况下，我们可以创建一个名为 <code class="literal">.gitignore</code> 的文件，列出要忽略的文件模式。
来看一个实际的例子：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cat .gitignore
*.[oa]
*~</code></pre>
</figure>
<p>第一行告诉 Git 忽略所有以 <code class="literal">.o</code> 或 <code class="literal">.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。
第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。
此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。
要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code class="literal">.gitignore</code> 的格式规范如下：</p>
<div class="itemized-list">
<ul>
<li>
<span class="principal">所有空行或者以 <code class="literal">＃</code> 开头的行都会被 Git 忽略。</span>
</li>
<li>
<span class="principal">可以使用标准的 glob 模式匹配。</span>
</li>
<li>
<span class="principal">匹配模式可以以（<code class="literal">/</code>）开头防止递归。</span>
</li>
<li>
<span class="principal">匹配模式可以以（<code class="literal">/</code>）结尾指定目录。</span>
</li>
<li>
<span class="principal">要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code class="literal">!</code>）取反。</span>
</li>
</ul>
</div>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。
星号（<code class="literal">*</code>）匹配零个或多个任意字符；<code class="literal">[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code class="literal">?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code class="literal">[0-9]</code> 表示匹配所有 0 到 9 的数字）。
使用两个星号（<code class="literal">*</code>) 表示匹配任意中间目录，比如 <code class="literal">a/**/z</code> 可以匹配 <code class="literal">a/z</code> , <code class="literal">a/b/z</code> 或 <code class="literal">a/b/c/z</code> 等。</p>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="listing">
<pre class="source language-"><code># no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf</code></pre>
</figure>
<aside class="admonition tip" title="Tip" epub:type="help">
<div class="content">
<p>GitHub 有一个十分详细的针对数十种项目及语言的 <code class="literal">.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore" class="link">https://github.com/github/gitignore</a> 找到它.</p>
</div>
</aside>
</section>
<section class="sect2" title="查看已暂存和未暂存的修改">
<h3 id="r_git_diff_staged">查看已暂存和未暂存的修改</h3>
<p>如果 <code class="literal">git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code class="literal">git diff</code> 命令。
稍后我们会详细介绍 <code class="literal">git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？
有哪些更新已经暂存起来准备好了下次提交？
尽管 <code class="literal">git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，<code class="literal">git diff</code> 将通过文件补丁的格式显示具体哪些行发生了改变。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 <code class="literal">CONTRIBUTING.md</code> 文件后先不暂存，
运行 <code class="literal">status</code> 命令将会看到：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code class="literal">git diff</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，
也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code class="literal">git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code class="literal">git diff --staged</code>，效果是相同的，但更好记些。）</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</figure>
<p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。
所以有时候你一下子暂存了所有更新过的文件后，运行 <code class="literal">git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code class="literal">CONTRIBUTING.md</code> 后再编辑，运行 <code class="literal">git status</code> 会看到暂存前后的两个版本。
如果我们的环境（终端输出）看起来如下：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add CONTRIBUTING.md
<span style="font-weight: bold">$</span> echo <span style="font-style: italic">&#39;# test line&#39;</span> &gt;&gt; CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>现在运行 <code class="literal">git diff</code> 看暂存前后的变化：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
<span style="font-weight: bold"> #</span><span style="font-style: italic"># Starter Projects</span>

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</figure>
<p>然后用 <code class="literal">git diff --cached</code> 查看已经暂存起来的变化：（--staged 和 --cached 是同义词）</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s</code></pre>
</figure>
<aside class="admonition note" title="Note: Git Diff 的插件版本" epub:type="note">
<h2>Git Diff 的插件版本</h2>
<div class="content">
<p>在本书中，我们使用 <code class="literal">git diff</code> 来分析文件差异。
但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 <code class="literal">git difftool</code> 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。
使用 <code class="literal">git difftool --tool-help</code> 命令来看你的系统支持哪些 Git Diff 插件。</p>
</div>
</aside>
</section>
<section class="sect2" title="提交更新">
<h3 id="r_committing_changes">提交更新</h3>
<p>现在的暂存区域已经准备妥当可以提交了。
在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code class="literal">git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。
这些修改过的文件只保留在本地磁盘。
所以，每次准备提交前，先用 <code class="literal">git status</code> 看下，是不是都已暂存起来了，
然后再运行提交命令 <code class="literal">git commit</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit</code></pre>
</figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。
(默认会启用 shell 的环境变量 <code class="literal">$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 <a id="xref--ch01-introduction" href="ch01-introduction.xhtml" class="xref">起步</a> 介绍的方式，使用 <code class="literal">git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<figure class="listing">
<pre class="source language-"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</figure>
<p>可以看到，默认的提交消息包含最后一次运行 <code class="literal">git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。
你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。
(如果想要更详细的对修改了哪些内容的提示，可以用 <code class="literal">-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。）
退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>另外，你也可以在 <code class="literal">commit</code> 命令后添加 <code class="literal">-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&quot;Story 182: Fix benchmarks for speed&quot;</span>
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</figure>
<p>好，现在你已经创建了第一个提交！
可以看到，提交后它会告诉你，当前是在哪个分支（<code class="literal">master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code class="literal">463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。
任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。
每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
</section>
<section class="sect2" title="跳过使用暂存区域">
<h3 id="_跳过使用暂存区域">跳过使用暂存区域</h3>
<p>
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。
Git 提供了一个跳过使用暂存区域的方式，
只要在提交的时候，给 <code class="literal">git commit</code> 加上 <code class="literal">-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code class="literal">git add</code> 步骤：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
<span style="font-weight: bold">$</span> git commit -a -m <span style="font-style: italic">&#39;added new benchmarks&#39;</span>
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</figure>
<p>看到了吗？提交之前不再需要 <code class="literal">git add</code> 文件“CONTRIBUTING.md”了。</p>
</section>
<section class="sect2" title="移除文件">
<h3 id="r_removing_files">移除文件</h3>
<p>
要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。
可以用 <code class="literal">git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code class="literal">git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> rm PROJECTS.md
<span style="font-weight: bold">$</span> git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</figure>
<p>然后再运行 <code class="literal">git rm</code> 记录此次移除文件的操作：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm PROJECTS.md
rm &#39;PROJECTS.md&#39;
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    deleted:    PROJECTS.md</code></pre>
</figure>
<p>下一次提交时，该文件就不再纳入版本管理了。
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code class="literal">-f</code>（译注：即 force 的首字母）。
这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。
换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。
当你忘记添加 <code class="literal">.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code class="literal">.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。
为达到这一目的，使用 <code class="literal">--cached</code> 选项：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm --cached README</code></pre>
</figure>
<p><code class="literal">git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code class="literal">glob</code> 模式。
比方说：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm log/<span style="font-weight: bold; font-style: italic">\*</span>.log</code></pre>
</figure>
<p>注意到星号 <code class="literal">*</code> 之前的反斜杠 <code class="literal">\</code>，
因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。
此命令删除 <code class="literal">log/</code> 目录下扩展名为 <code class="literal">.log</code> 的所有文件。
类似的比如：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git rm <span style="font-weight: bold; font-style: italic">\*</span>~</code></pre>
</figure>
<p>该命令为删除以 <code class="literal">~</code> 结尾的所有文件。</p>
</section>
<section class="sect2" title="移动文件">
<h3 id="r_git_mv">移动文件</h3>
<p>
不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。
如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。
不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code class="literal">mv</code> 命令时一定会困惑不已。
要在 Git 中对文件改名，可以这么做：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv file_from file_to</code></pre>
</figure>
<p>它会恰如预期般正常工作。
实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git mv README.md README
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>其实，运行 <code class="literal">git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> mv README.md README
<span style="font-weight: bold">$</span> git rm README.md
<span style="font-weight: bold">$</span> git add README</code></pre>
</figure>
<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。
两者唯一的区别是，<code class="literal">mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code class="literal">git mv</code> 轻便得多。
不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
</section>
</section>
<section class="sect1" title="查看提交历史">
<h2 id="r_viewing_history">查看提交历史</h2>
<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。
完成这个任务最简单而又有效的工具是 <code class="literal">git log</code> 命令。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，
运行下面的命令获取该项目源代码：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>git clone https://github.com/schacon/simplegit-progit</code></pre>
</figure>
<p>然后在此项目中运行 git log，应该会看到下面的输出：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit</code></pre>
</figure>
<p>默认不用任何参数的话，<code class="literal">git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。
正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code class="literal">git log</code> 有许多选项可以帮助你搜寻你所要找的提交，
接下来我们介绍些最常用的。</p>
<p>一个常用的选项是 <code class="literal">-p</code>，用来显示每次提交的内容差异。
你也可以加上 <code class="literal">-2</code> 来仅显示最近两次提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &#39;rake/gempackagetask&#39;
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   &quot;simplegit&quot;
-    s.version   =   &quot;0.1.0&quot;
+    s.version   =   &quot;0.1.1&quot;
     s.author    =   &quot;Scott Chacon&quot;
     s.email     =   &quot;schacon@gee-mail.com&quot;
     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file</code></pre>
</figure>
<p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。
当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。
你也可以为 <code class="literal">git log</code> 附带一系列的总结性选项。
比如说，如果你想看到每次提交的简略的统计信息，你可以使用 <code class="literal">--stat</code> 选项：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)</code></pre>
</figure>
<p>正如你所看到的，<code class="literal">--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。
在每次提交的最后还有一个总结。</p>
<p>另外一个常用的选项是 <code class="literal">--pretty</code>。
这个选项可以指定使用不同于默认格式的方式展示提交历史。
这个选项有一些内建的子选项供你使用。
比如用 <code class="literal">oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。
另外还有 <code class="literal">short</code>，<code class="literal">full</code> 和 <code class="literal">fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</code></pre>
</figure>
<p>但最有意思的是 format，可以定制要显示的记录格式。
这样的输出对后期提取分析格外有用&#8201;&#8212;&#8201;因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h - %an, %ar : %s&quot;</span>
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</code></pre>
</figure>
<p><a id="xref-rpretty_format" href="#rpretty_format" class="xref"><code class="literal">git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<div class="table">
<div class="content">
<table id="rpretty_format" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 1. <code class="literal">git log --pretty=format</code> 常用的选项</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">%H</code></p></td>
<td><p>提交对象（commit）的完整哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%h</code></p></td>
<td><p>提交对象的简短哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%T</code></p></td>
<td><p>树对象（tree）的完整哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%t</code></p></td>
<td><p>树对象的简短哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%P</code></p></td>
<td><p>父对象（parent）的完整哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%p</code></p></td>
<td><p>父对象的简短哈希字串</p></td>
</tr>
<tr>
<td><p><code class="literal">%an</code></p></td>
<td><p>作者（author）的名字</p></td>
</tr>
<tr>
<td><p><code class="literal">%ae</code></p></td>
<td><p>作者的电子邮件地址</p></td>
</tr>
<tr>
<td><p><code class="literal">%ad</code></p></td>
<td><p>作者修订日期（可以用 --date= 选项定制格式）</p></td>
</tr>
<tr>
<td><p><code class="literal">%ar</code></p></td>
<td><p>作者修订日期，按多久以前的方式显示</p></td>
</tr>
<tr>
<td><p><code class="literal">%cn</code></p></td>
<td><p>提交者（committer）的名字</p></td>
</tr>
<tr>
<td><p><code class="literal">%ce</code></p></td>
<td><p>提交者的电子邮件地址</p></td>
</tr>
<tr>
<td><p><code class="literal">%cd</code></p></td>
<td><p>提交日期</p></td>
</tr>
<tr>
<td><p><code class="literal">%cr</code></p></td>
<td><p>提交日期，按多久以前的方式显示</p></td>
</tr>
<tr>
<td><p><code class="literal">%s</code></p></td>
<td><p>提交说明</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别，
其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。
所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。
我们会在 <a id="xref--ch05-distributed-git" href="ch05-distributed-git.xhtml" class="xref">分布式 Git</a> 再详细介绍两者之间的细微差别。</p>
<p>当 oneline 或 format 与另一个 <code class="literal">log</code> 选项 <code class="literal">--graph</code> 结合使用时尤其有用。
这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=format:<span style="font-style: italic">&quot;%h %s&quot;</span> --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &#39;master&#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &#39;defunkt&#39; into local</code></pre>
</figure>
<p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p>
<p>以上只是简单介绍了一些 <code class="literal">git log</code> 命令支持的选项。
<a id="xref-rlog_options" href="#rlog_options" class="xref"><code class="literal">git log</code> 的常用选项</a> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p>
<div class="table">
<div class="content">
<table id="rlog_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 2. <code class="literal">git log</code> 的常用选项</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-p</code></p></td>
<td><p>按补丁格式显示每个更新之间的差异。</p></td>
</tr>
<tr>
<td><p><code class="literal">--stat</code></p></td>
<td><p>显示每次更新的文件修改统计信息。</p></td>
</tr>
<tr>
<td><p><code class="literal">--shortstat</code></p></td>
<td><p>只显示 --stat 中最后的行数修改添加移除统计。</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-only</code></p></td>
<td><p>仅在提交信息后显示已修改的文件清单。</p></td>
</tr>
<tr>
<td><p><code class="literal">--name-status</code></p></td>
<td><p>显示新增、修改、删除的文件清单。</p></td>
</tr>
<tr>
<td><p><code class="literal">--abbrev-commit</code></p></td>
<td><p>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</p></td>
</tr>
<tr>
<td><p><code class="literal">--relative-date</code></p></td>
<td><p>使用较短的相对时间显示（比如，“2 weeks ago”）。</p></td>
</tr>
<tr>
<td><p><code class="literal">--graph</code></p></td>
<td><p>显示 ASCII 图形表示的分支合并历史。</p></td>
</tr>
<tr>
<td><p><code class="literal">--pretty</code></p></td>
<td><p>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<section class="sect2" title="限制输出长度">
<h3 id="_限制输出长度">限制输出长度</h3>
<p>除了定制输出格式的选项之外，<code class="literal">git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
之前你已经看到过 <code class="literal">-2</code> 了，它只显示最近的两条提交，
实际上，这是 <code class="literal">-&lt;n&gt;</code> 选项的写法，其中的 <code class="literal">n</code> 可以是任何整数，表示仅显示最近的若干条提交。
不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如 <code class="literal">--since</code> 和 <code class="literal">--until</code> 也很有用。
例如，下面的命令列出所有最近两周内的提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --since=2.weeks</code></pre>
</figure>
<p>这个命令可以在多种格式下工作，比如说具体的某一天 <code class="literal">"2008-01-15"</code>，或者是相对地多久以前 <code class="literal">"2 years 1 day 3 minutes ago"</code>。</p>
<p>还可以给出若干搜索条件，列出符合的提交。
用 <code class="literal">--author</code> 选项显示指定作者的提交，用 <code class="literal">--grep</code> 选项搜索提交说明中的关键字。
（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code class="literal">--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个非常有用的筛选选项是 <code class="literal">-S</code>，可以列出那些添加或移除了某些字符串的提交。
比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log -Sfunction_name</code></pre>
</figure>
<p>最后一个很实用的 <code class="literal">git log</code> 选项是路径（path），
如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。
因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。</p>
<p>在 <a id="xref-rlimit_options" href="#rlimit_options" class="xref">限制 <code class="literal">git log</code> 输出的选项</a> 中列出了常用的选项</p>
<div class="table">
<div class="content">
<table id="rlimit_options" class="table table-framed-topbot table-grid-rows" style="width: 100%">
<caption>Table 3. 限制 <code class="literal">git log</code> 输出的选项</caption>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code class="literal">-(n)</code></p></td>
<td><p>仅显示最近的 n 条提交</p></td>
</tr>
<tr>
<td><p><code class="literal">--since</code>, <code class="literal">--after</code></p></td>
<td><p>仅显示指定时间之后的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--until</code>, <code class="literal">--before</code></p></td>
<td><p>仅显示指定时间之前的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--author</code></p></td>
<td><p>仅显示指定作者相关的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--committer</code></p></td>
<td><p>仅显示指定提交者相关的提交。</p></td>
</tr>
<tr>
<td><p><code class="literal">--grep</code></p></td>
<td><p>仅显示含指定关键字的提交</p></td>
</tr>
<tr>
<td><p><code class="literal">-S</code></p></td>
<td><p>仅显示添加或移除了某个关键字的提交</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=<span style="font-style: italic">&quot;%h - %s&quot;</span> --author=gitster --since=<span style="font-style: italic">&quot;2008-10-01&quot;</span> <span style="font-weight: bold; font-style: italic">\</span>
   --before=<span style="font-style: italic">&quot;2008-11-01&quot;</span> --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD
b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</code></pre>
</figure>
<p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
</section>
</section>
<section class="sect1" title="撤消操作">
<h2 id="r_undoing">撤消操作</h2>
<p>在任何一个阶段，你都有可能想要撤消某些操作。
这里，我们将会学习几个撤消你所做修改的基本工具。
注意，有些撤消操作是不可逆的。
这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。
此时，可以运行带有 <code class="literal">--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>这个命令会将暂存区中的文件提交。
如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。
编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git commit -m <span style="font-style: italic">&#39;initial commit&#39;</span>
<span style="font-weight: bold">$</span> git add forgotten_file
<span style="font-weight: bold">$</span> git commit --amend</code></pre>
</figure>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<section class="sect2" title="取消暂存的文件">
<h3 id="r_unstaging">取消暂存的文件</h3>
<p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。
这些命令在修改文件状态的同时，也会提示如何撤消操作。
例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code class="literal">git add *</code> 暂存了它们两个。
如何只取消暂存两个中的一个呢？
<code class="literal">git status</code> 命令提示了你：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git add *
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>在 “Changes to be committed” 文字正下方，提示使用 <code class="literal">git reset HEAD &lt;file&gt;...</code> 来取消暂存。
所以，我们可以这样来取消暂存 <code class="literal">CONTRIBUTING.md</code> 文件：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>这个命令有点儿奇怪，但是起作用了。
<code class="literal">CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p>
<aside class="admonition note" title="Note" epub:type="note">
<div class="content">
<p>虽然在调用时加上 <code class="literal">--hard</code> 选项<strong>可以</strong>令 <code class="literal">git reset</code> 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。
不加选项地调用 <code class="literal">git reset</code> 并不危险 — 它只会修改暂存区域。</p>
</div>
</aside>
<p>到目前为止这个神奇的调用就是你需要对 <code class="literal">git reset</code> 命令了解的全部。我们将会在 <a id="xref--ch07-git-tools--r_git_reset" href="ch07-git-tools.xhtml#r_git_reset" class="xref">重置揭密</a> 中了解 <code class="literal">reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p>
</section>
<section class="sect2" title="撤消对文件的修改">
<h3 id="_撤消对文件的修改">撤消对文件的修改</h3>
<p>如果你并不想保留对 <code class="literal">CONTRIBUTING.md</code> 文件的修改怎么办？
你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？
幸运的是，<code class="literal">git status</code> 也告诉了你应该如何做。
在最后一个例子中，未暂存区域是这样：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span>Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改。
让我们来按照提示执行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -- CONTRIBUTING.md
<span style="font-weight: bold">$</span> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README</code></pre>
</figure>
<p>可以看到那些修改已经被撤消了。</p>
<aside class="admonition important" title="Important" epub:type="warning">
<div class="content">
<p>你需要知道 <code class="literal">git checkout -- [file]</code> 是一个危险的命令，这很重要。
你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。
除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>
</div>
</aside>
<p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="ch03-git-branching.xhtml" class="xref">Git 分支</a> 介绍保存进度与分支；这些通常是更好的做法。</p>
<p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。
甚至那些被删除的分支中的提交或使用 <code class="literal">--amend</code> 选项覆盖的提交也可以恢复（阅读 <a id="xref--ch10-git-internals--r_data_recovery" href="ch10-git-internals.xhtml#r_data_recovery" class="xref">数据恢复</a> 了解数据恢复）。
然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
</section>
</section>
<section class="sect1" title="远程仓库的使用">
<h2 id="r_remote_repos">远程仓库的使用</h2>
<p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。
远程仓库是指托管在因特网或其他网络中的你的项目的版本库。
你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。
与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。
管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。
在本节中，我们将介绍一部分远程管理的技能。</p>
<section class="sect2" title="查看远程仓库">
<h3 id="_查看远程仓库">查看远程仓库</h3>
<p>如果想查看你已经配置的远程仓库服务器，可以运行 <code class="literal">git remote</code> 命令。
它会列出你指定的每一个远程服务器的简写。
如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git clone https://github.com/schacon/ticgit
Cloning into &#39;ticgit&#39;...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
<span style="font-weight: bold">$</span> cd ticgit
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
<p>你也可以指定选项 <code class="literal">-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)</code></pre>
</figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。
例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> cd grit
<span style="font-weight: bold">$</span> git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)</code></pre>
</figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。
此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p>
<p>注意这些远程仓库使用了不同的协议；我们将会在 <a href="ch04-git-server.xhtml#r_git_on_the_server" class="xref">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p>
</section>
<section class="sect2" title="添加远程仓库">
<h3 id="_添加远程仓库">添加远程仓库</h3>
<p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。
运行 <code class="literal">git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote
origin
<span style="font-weight: bold">$</span> git remote add pb https://github.com/paulboone/ticgit
<span style="font-weight: bold">$</span> git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)</code></pre>
</figure>
<p>现在你可以在命令行中使用字符串 <code class="literal">pb</code> 来代替整个 URL。
例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code class="literal">git fetch pb</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -&gt; pb/master
 * [new branch]      ticgit     -&gt; pb/ticgit</code></pre>
</figure>
<p>现在 Paul 的 master 分支可以在本地通过 <code class="literal">pb/master</code> 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。
（我们将会在 <a href="ch03-git-branching.xhtml" class="xref">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p>
</section>
<section class="sect2" title="从远程仓库中抓取与拉取">
<h3 id="r_fetching_and_pulling">从远程仓库中抓取与拉取</h3>
<p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git fetch [remote-name]</code></pre>
</figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。
执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code class="literal">clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。
所以，<code class="literal">git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。
必须注意 <code class="literal">git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。
当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="ch03-git-branching.xhtml" class="xref">Git 分支</a> 了解更多信息），可以使用 <code class="literal">git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。
这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code class="literal">git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。
运行 <code class="literal">git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
</section>
<section class="sect2" title="推送到远程仓库">
<h3 id="r_pushing_remotes">推送到远程仓库</h3>
<p>当你想分享你的项目时，必须将其推送到上游。
这个命令很简单：<code class="literal">git push [remote-name] [branch-name]</code>。
当你想要将 master 分支推送到 <code class="literal">origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin master</code></pre>
</figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。
当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。
你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。
阅读 <a href="ch03-git-branching.xhtml" class="xref">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p>
</section>
<section class="sect2" title="查看远程仓库">
<h3 id="r_inspecting_remote">查看远程仓库</h3>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code class="literal">git remote show [remote-name]</code> 命令。
如果想以一个特定的缩写名运行这个命令，例如 <code class="literal">origin</code>，会得到像下面类似的信息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for &#39;git pull&#39;:
    master merges with remote master
  Local ref configured for &#39;git push&#39;:
    master pushes to master (up to date)</code></pre>
</figure>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。
这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。
它也会列出拉取到的所有远程引用。</p>
<p>这是一个经常遇到的简单例子。
如果你是 Git 的重度使用者，那么还可以通过 <code class="literal">git remote show</code> 看到更多的信息。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use &#39;git remote prune&#39; to remove)
  Local branches configured for &#39;git pull&#39;:
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for &#39;git push&#39;:
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)</code></pre>
</figure>
<p>这个命令列出了当你在特定的分支上执行 <code class="literal">git push</code> 会自动地推送到哪一个远程分支。
它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code class="literal">git pull</code> 时哪些分支会自动合并。</p>
</section>
<section class="sect2" title="远程仓库的移除与重命名">
<h3 id="_远程仓库的移除与重命名">远程仓库的移除与重命名</h3>
<p>如果想要重命名引用的名字可以运行 <code class="literal">git remote rename</code> 去修改一个远程仓库的简写名。
例如，想要将 <code class="literal">pb</code> 重命名为 <code class="literal">paul</code>，可以用 <code class="literal">git remote rename</code> 这样做：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rename pb paul
<span style="font-weight: bold">$</span> git remote
origin
paul</code></pre>
</figure>
<p>值得注意的是这同样也会修改你的远程分支名字。
那些过去引用 <code class="literal">pb/master</code> 的现在会引用 <code class="literal">paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code class="literal">git remote rm</code> ：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git remote rm paul
<span style="font-weight: bold">$</span> git remote
origin</code></pre>
</figure>
</section>
</section>
<section class="sect1" title="打标签">
<h2 id="r_git_tagging">打标签</h2>
<p>
像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。
比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p>
<section class="sect2" title="列出标签">
<h3 id="_列出标签">列出标签</h3>
<p>在 Git 中列出已有的标签是非常简单直观的。
只需要输入 <code class="literal">git tag</code>：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.3</code></pre>
</figure>
<p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p>
<p>你也可以使用特定的模式查找标签。
例如，Git 自身的源代码仓库包含标签的数量超过 500 个。
如果只对 1.8.5 系列感兴趣，可以运行：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -l <span style="font-style: italic">&#39;v1.8.5*&#39;</span>
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
v1.8.5.4
v1.8.5.5</code></pre>
</figure>
</section>
<section class="sect2" title="创建标签">
<h3 id="_创建标签">创建标签</h3>
<p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。
它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。
通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
</section>
<section class="sect2" title="附注标签">
<h3 id="r_annotated_tags">附注标签</h3>
<p>
在 Git 中创建一个附注标签是很简单的。
最简单的方式是当你在运行 <code class="literal">tag</code> 命令时指定 <code class="literal">-a</code> 选项：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.4 -m <span style="font-style: italic">&#39;my version 1.4&#39;</span>
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4</code></pre>
</figure>
<p><code class="literal">-m</code> 选项指定了一条将会存储在标签中的信息。
如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 <code class="literal">git show</code> 命令可以看到标签信息与对应的提交信息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4
tag v1.4
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
</section>
<section class="sect2" title="轻量标签">
<h3 id="_轻量标签">轻量标签</h3>
<p>
另一种给提交打标签的方式是使用轻量标签。
轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。
创建轻量标签，不需要使用 <code class="literal">-a</code>、<code class="literal">-s</code> 或 <code class="literal">-m</code> 选项，只需要提供标签名字：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag v1.4-lw
<span style="font-weight: bold">$</span> git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5</code></pre>
</figure>
<p>这时，如果在标签上运行 <code class="literal">git show</code>，你不会看到额外的标签信息。
命令只会显示出提交信息：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</code></pre>
</figure>
</section>
<section class="sect2" title="后期打标签">
<h3 id="_后期打标签">后期打标签</h3>
<p>你也可以对过去的提交打标签。
假设提交历史是这样的：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#39;experiment&#39;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#39;experiment&#39;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</code></pre>
</figure>
<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。
你可以在之后补上标签。
要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -a v1.2 9fceb02</code></pre>
</figure>
<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

<span style="font-weight: bold">$</span> git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...</code></pre>
</figure>
</section>
<section class="sect2" title="共享标签">
<h3 id="r_sharing_tags">共享标签</h3>
<p>默认情况下，<code class="literal">git push</code> 命令并不会传送标签到远程仓库服务器上。
在创建完标签后你必须显式地推送标签到共享服务器上。
这个过程就像共享远程分支一样 - 你可以运行 <code class="literal">git push origin [tagname]</code>。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.5 -&gt; v1.5</code></pre>
</figure>
<p>如果想要一次性推送很多标签，也可以使用带有 <code class="literal">--tags</code> 选项的 <code class="literal">git push</code> 命令。
这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.4 -&gt; v1.4
 * [new tag]         v1.4-lw -&gt; v1.4-lw</code></pre>
</figure>
<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
</section>
<section class="sect2" title="删除标签">
<h3 id="_删除标签">删除标签</h3>
<p>要删除掉你本地仓库上的标签，可以使用命令 <code class="literal">git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git tag -d v1.4-lw
Deleted tag &#39;v1.4-lw&#39; (was e7d5add)</code></pre>
</figure>
<p>应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 <code class="literal">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git push origin :refs/tags/v1.4-lw
To /git@github.com:schacon/simplegit.git
 - [deleted]         v1.4-lw</code></pre>
</figure>
</section>
<section class="sect2" title="检出标签">
<h3 id="_检出标签">检出标签</h3>
<p>如果你想查看某个标签所指向的文件版本，可以使用 <code class="literal">git checkout</code> 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout 2.0.0
Note: checking out &#39;2.0.0&#39;.

You are in &#39;detached HEAD&#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch&gt;

HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final

<span style="font-weight: bold">$</span> git checkout 2.0-beta-0.1
Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final
HEAD is now at df3f601... add atlas.json and cover image</code></pre>
</figure>
<p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git checkout -b version2 v2.0.0
Switched to a new branch &#39;version2&#39;</code></pre>
</figure>
<p>当然，如果在这之后又进行了一次提交，<code class="literal">version2</code> 分支会因为这个改动向前移动，<code class="literal">version2</code> 分支就会和 <code class="literal">v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p>
</section>
</section>
<section class="sect1" title="Git 别名">
<h2 id="r_git_aliases">Git 别名</h2>
<p>
在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。
我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。
如果不想每次都输入完整的 Git 命令，可以通过 <code class="literal">git config</code> 文件来轻松地为每一个命令设置一个别名。
这里有一些例子你可以试试：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.co checkout
<span style="font-weight: bold">$</span> git config --global alias.br branch
<span style="font-weight: bold">$</span> git config --global alias.ci commit
<span style="font-weight: bold">$</span> git config --global alias.st status</code></pre>
</figure>
<p>这意味着，当要输入 <code class="literal">git commit</code> 时，只需要输入 <code class="literal">git ci</code>。
随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>
<p>在创建你认为应该存在的命令时这个技术会很有用。
例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.unstage <span style="font-style: italic">&#39;reset HEAD --&#39;</span></code></pre>
</figure>
<p>这会使下面的两个命令等价：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git unstage fileA
<span style="font-weight: bold">$</span> git reset HEAD -- fileA</code></pre>
</figure>
<p>这样看起来更清楚一些。
通常也会添加一个 <code class="literal">last</code> 命令，像这样：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.last <span style="font-style: italic">&#39;log -1 HEAD&#39;</span></code></pre>
</figure>
<p>这样，可以轻松地看到最后一次提交：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</code></pre>
</figure>
<p>可以看出，Git 只是简单地将别名替换为对应的命令。
然而，你可能想要执行外部命令，而不是一个 Git 子命令。
如果是那样的话，可以在命令前面加入 <code class="literal">!</code> 符号。
如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。
我们现在演示将 <code class="literal">git visual</code> 定义为 <code class="literal">gitk</code> 的别名：</p>
<figure class="listing">
<pre class="source language-console"><code><span></span><span style="font-weight: bold">$</span> git config --global alias.visual <span style="font-style: italic">&#39;!gitk&#39;</span></code></pre>
</figure>
</section>
<section class="sect1" title="总结">
<h2 id="_总结">总结</h2>
<p>现在，你可以完成所有基本的 Git 本地操作－创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。
下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>
</section>
</section>
</body>
</html>