<html><head></head><body lang="zh-Hans" ><!-- This text is a brief description of the features that are present in
the Bash shell (version 5.0, 12 May 2019).

This is Edition 5.0, last updated 12 May 2019,
of The GNU Bash Reference Manual,
for Bash, Version 5.0.

Copyright (C) 1988-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
"GNU Free Documentation License". --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Bash参考手册</title>

<meta name="description" content="Bash Reference Manual">
<meta name="keywords" content="Bash Reference Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Indexes" rel="index" title="Indexes">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="/manual" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">





<h1 class="settitle" align="center">Bash参考手册</h1>










<a name="SEC_Contents"></a>
<h2 class="contents-heading">目录</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Introduction-1" href="#Introduction">1引言</a>
  <ul class="no-bullet">
    <li><a name="toc-What-is-Bash_003f-1" href="#What-is-Bash_003f">1.1什么是Bash？</a></li>
    <li><a name="toc-What-is-a-shell_003f-1" href="#What-is-a-shell_003f">1.2什么是外壳？</a></li>
  </ul></li>
  <li><a name="toc-Definitions-1" href="#Definitions">2定义</a></li>
  <li><a name="toc-Basic-Shell-Features-1" href="#Basic-Shell-Features">3 Shell的基本功能</a>
  <ul class="no-bullet">
    <li><a name="toc-Shell-Syntax-1" href="#Shell-Syntax">3.1 Shell语法</a>
    <ul class="no-bullet">
      <li><a name="toc-Shell-Operation-1" href="#Shell-Operation">3.1.1 Shell操作</a></li>
      <li><a name="toc-Quoting-1" href="#Quoting">3.1.2报价</a>
      <ul class="no-bullet">
        <li><a name="toc-Escape-Character-1" href="#Escape-Character">3.1.2.1转义符</a></li>
        <li><a name="toc-Single-Quotes-1" href="#Single-Quotes">3.1.2.2单引号</a></li>
        <li><a name="toc-Double-Quotes-1" href="#Double-Quotes">3.1.2.3双引号</a></li>
        <li><a name="toc-ANSI_002dC-Quoting-1" href="#ANSI_002dC-Quoting">3.1.2.4 ANSI-C报价</a></li>
        <li><a name="toc-Locale_002dSpecific-Translation" href="#Locale-Translation">3.1.2.5特定于语言环境的翻译</a></li>
      </ul></li>
      <li><a name="toc-Comments-1" href="#Comments">3.1.3注释</a></li>
    </ul></li>
    <li><a name="toc-Shell-Commands-1" href="#Shell-Commands">3.2 Shell命令</a>
    <ul class="no-bullet">
      <li><a name="toc-Simple-Commands-1" href="#Simple-Commands">3.2.1简单命令</a></li>
      <li><a name="toc-Pipelines-1" href="#Pipelines">3.2.2管道</a></li>
      <li><a name="toc-Lists-of-Commands" href="#Lists">3.2.3命令列表</a></li>
      <li><a name="toc-Compound-Commands-1" href="#Compound-Commands">3.2.4复合命令</a>
      <ul class="no-bullet">
        <li><a name="toc-Looping-Constructs-1" href="#Looping-Constructs">3.2.4.1循环构造</a></li>
        <li><a name="toc-Conditional-Constructs-1" href="#Conditional-Constructs">3.2.4.2条件构造</a></li>
        <li><a name="toc-Grouping-Commands" href="#Command-Grouping">3.2.4.3分组命令</a></li>
      </ul></li>
      <li><a name="toc-Coprocesses-1" href="#Coprocesses">3.2.5协同过程</a></li>
      <li><a name="toc-GNU-Parallel-1" href="#GNU-Parallel">3.2.6 GNU并行</a></li>
    </ul></li>
    <li><a name="toc-Shell-Functions-1" href="#Shell-Functions">3.3 Shell功能</a></li>
    <li><a name="toc-Shell-Parameters-1" href="#Shell-Parameters">3.4外壳参数</a>
    <ul class="no-bullet">
      <li><a name="toc-Positional-Parameters-1" href="#Positional-Parameters">3.4.1位置参数</a></li>
      <li><a name="toc-Special-Parameters-1" href="#Special-Parameters">3.4.2特殊参数</a></li>
    </ul></li>
    <li><a name="toc-Shell-Expansions-1" href="#Shell-Expansions">3.5外壳扩展</a>
    <ul class="no-bullet">
      <li><a name="toc-Brace-Expansion-1" href="#Brace-Expansion">3.5.1括号扩展</a></li>
      <li><a name="toc-Tilde-Expansion-1" href="#Tilde-Expansion">3.5.2波浪扩展</a></li>
      <li><a name="toc-Shell-Parameter-Expansion-1" href="#Shell-Parameter-Expansion">3.5.3 Shell参数扩展</a></li>
      <li><a name="toc-Command-Substitution-1" href="#Command-Substitution">3.5.4命令替换</a></li>
      <li><a name="toc-Arithmetic-Expansion-1" href="#Arithmetic-Expansion">3.5.5算术扩展</a></li>
      <li><a name="toc-Process-Substitution-1" href="#Process-Substitution">3.5.6流程替代</a></li>
      <li><a name="toc-Word-Splitting-1" href="#Word-Splitting">3.5.7分词</a></li>
      <li><a name="toc-Filename-Expansion-1" href="#Filename-Expansion">3.5.8扩展文件名</a>
      <ul class="no-bullet">
        <li><a name="toc-Pattern-Matching-1" href="#Pattern-Matching">3.5.8.1模式匹配</a></li>
      </ul></li>
      <li><a name="toc-Quote-Removal-1" href="#Quote-Removal">3.5.9删除报价</a></li>
    </ul></li>
    <li><a name="toc-Redirections-1" href="#Redirections">3.6重定向</a>
    <ul class="no-bullet">
      <li><a name="toc-Redirecting-Input" href="#Redirecting-Input">3.6.1重定向输入</a></li>
      <li><a name="toc-Redirecting-Output" href="#Redirecting-Output">3.6.2重定向输出</a></li>
      <li><a name="toc-Appending-Redirected-Output" href="#Appending-Redirected-Output">3.6.3附加重定向输出</a></li>
      <li><a name="toc-Redirecting-Standard-Output-and-Standard-Error" href="#Redirecting-Standard-Output-and-Standard-Error">3.6.4重定向标准输出和标准错误</a></li>
      <li><a name="toc-Appending-Standard-Output-and-Standard-Error" href="#Appending-Standard-Output-and-Standard-Error">3.6.5追加标准输出和标准误差</a></li>
      <li><a name="toc-Here-Documents" href="#Here-Documents">3.6.6此处文件</a></li>
      <li><a name="toc-Here-Strings" href="#Here-Strings">3.6.7字符串</a></li>
      <li><a name="toc-Duplicating-File-Descriptors" href="#Duplicating-File-Descriptors">3.6.8复制文件描述符</a></li>
      <li><a name="toc-Moving-File-Descriptors" href="#Moving-File-Descriptors">3.6.9移动文件描述符</a></li>
      <li><a name="toc-Opening-File-Descriptors-for-Reading-and-Writing" href="#Opening-File-Descriptors-for-Reading-and-Writing">3.6.10打开文件描述符进行读写</a></li>
    </ul></li>
    <li><a name="toc-Executing-Commands-1" href="#Executing-Commands">3.7执行命令</a>
    <ul class="no-bullet">
      <li><a name="toc-Simple-Command-Expansion-1" href="#Simple-Command-Expansion">3.7.1简单命令扩展</a></li>
      <li><a name="toc-Command-Search-and-Execution-1" href="#Command-Search-and-Execution">3.7.2命令搜索和执行</a></li>
      <li><a name="toc-Command-Execution-Environment-1" href="#Command-Execution-Environment">3.7.3命令执行环境</a></li>
      <li><a name="toc-Environment-1" href="#Environment">3.7.4环境</a></li>
      <li><a name="toc-Exit-Status-1" href="#Exit-Status">3.7.5退出状态</a></li>
      <li><a name="toc-Signals-1" href="#Signals">3.7.6信号</a></li>
    </ul></li>
    <li><a name="toc-Shell-Scripts-1" href="#Shell-Scripts">3.8 Shell脚本</a></li>
  </ul></li>
  <li><a name="toc-Shell-Builtin-Commands-1" href="#Shell-Builtin-Commands">4个Shell内置命令</a>
  <ul class="no-bullet">
    <li><a name="toc-Bourne-Shell-Builtins-1" href="#Bourne-Shell-Builtins">4.1 Bourne Shell内置</a></li>
    <li><a name="toc-Bash-Builtin-Commands" href="#Bash-Builtins">4.2 Bash内置命令</a></li>
    <li><a name="toc-Modifying-Shell-Behavior-1" href="#Modifying-Shell-Behavior">4.3修改Shell行为</a>
    <ul class="no-bullet">
      <li><a name="toc-The-Set-Builtin-1" href="#The-Set-Builtin">4.3.1内置集合</a></li>
      <li><a name="toc-The-Shopt-Builtin-1" href="#The-Shopt-Builtin">4.3.2 Shopt内置</a></li>
    </ul></li>
    <li><a name="toc-Special-Builtins-1" href="#Special-Builtins">4.4特殊内置</a></li>
  </ul></li>
  <li><a name="toc-Shell-Variables-1" href="#Shell-Variables">5个Shell变量</a>
  <ul class="no-bullet">
    <li><a name="toc-Bourne-Shell-Variables-1" href="#Bourne-Shell-Variables">5.1 Bourne Shell变量</a></li>
    <li><a name="toc-Bash-Variables-1" href="#Bash-Variables">5.2 Bash变量</a></li>
  </ul></li>
  <li><a name="toc-Bash-Features-2" href="#Bash-Features">6 Bash功能</a>
  <ul class="no-bullet">
    <li><a name="toc-Invoking-Bash-1" href="#Invoking-Bash">6.1调用Bash</a></li>
    <li><a name="toc-Bash-Startup-Files-1" href="#Bash-Startup-Files">6.2 Bash启动文件</a></li>
    <li><a name="toc-Interactive-Shells-1" href="#Interactive-Shells">6.3互动壳</a>
    <ul class="no-bullet">
      <li><a name="toc-What-is-an-Interactive-Shell_003f-1" href="#What-is-an-Interactive-Shell_003f">6.3.1什么是交互式外壳？</a></li>
      <li><a name="toc-Is-this-Shell-Interactive_003f-1" href="#Is-this-Shell-Interactive_003f">6.3.2此Shell是交互式的吗？</a></li>
      <li><a name="toc-Interactive-Shell-Behavior-1" href="#Interactive-Shell-Behavior">6.3.3交互式Shell行为</a></li>
    </ul></li>
    <li><a name="toc-Bash-Conditional-Expressions-1" href="#Bash-Conditional-Expressions">6.4 Bash条件表达式</a></li>
    <li><a name="toc-Shell-Arithmetic-1" href="#Shell-Arithmetic">6.5 Shell算术</a></li>
    <li><a name="toc-Aliases-1" href="#Aliases">6.6别名</a></li>
    <li><a name="toc-Arrays-1" href="#Arrays">6.7阵列</a></li>
    <li><a name="toc-The-Directory-Stack-1" href="#The-Directory-Stack">6.8目录栈</a>
    <ul class="no-bullet">
      <li><a name="toc-Directory-Stack-Builtins-1" href="#Directory-Stack-Builtins">6.8.1目录堆栈内置</a></li>
    </ul></li>
    <li><a name="toc-Controlling-the-Prompt-1" href="#Controlling-the-Prompt">6.9控制提示</a></li>
    <li><a name="toc-The-Restricted-Shell-1" href="#The-Restricted-Shell">6.10受限外壳</a></li>
    <li><a name="toc-Bash-POSIX-Mode-1" href="#Bash-POSIX-Mode">6.11 Bash POSIX模式</a></li>
  </ul></li>
  <li><a name="toc-Job-Control-1" href="#Job-Control">7工作控制</a>
  <ul class="no-bullet">
    <li><a name="toc-Job-Control-Basics-1" href="#Job-Control-Basics">7.1工作控制基础</a></li>
    <li><a name="toc-Job-Control-Builtins-1" href="#Job-Control-Builtins">7.2作业控制内置</a></li>
    <li><a name="toc-Job-Control-Variables-1" href="#Job-Control-Variables">7.3作业控制变量</a></li>
  </ul></li>
  <li><a name="toc-Command-Line-Editing-1" href="#Command-Line-Editing">8命令行编辑</a>
  <ul class="no-bullet">
    <li><a name="toc-Introduction-to-Line-Editing" href="#Introduction-and-Notation">8.1行编辑简介</a></li>
    <li><a name="toc-Readline-Interaction-1" href="#Readline-Interaction">8.2 Readline互动</a>
    <ul class="no-bullet">
      <li><a name="toc-Readline-Bare-Essentials-1" href="#Readline-Bare-Essentials">8.2.1 Readline Bare Essentials</a></li>
      <li><a name="toc-Readline-Movement-Commands-1" href="#Readline-Movement-Commands">8.2.2 Readline移动命令</a></li>
      <li><a name="toc-Readline-Killing-Commands-1" href="#Readline-Killing-Commands">8.2.3 Readline杀死命令</a></li>
      <li><a name="toc-Readline-Arguments-1" href="#Readline-Arguments">8.2.4 Readline参数</a></li>
      <li><a name="toc-Searching-for-Commands-in-the-History" href="#Searching">8.2.5在历史记录中搜索命令</a></li>
    </ul></li>
    <li><a name="toc-Readline-Init-File-1" href="#Readline-Init-File">8.3 Readline初始化文件</a>
    <ul class="no-bullet">
      <li><a name="toc-Readline-Init-File-Syntax-1" href="#Readline-Init-File-Syntax">8.3.1 Readline初始化文件语法</a></li>
      <li><a name="toc-Conditional-Init-Constructs-1" href="#Conditional-Init-Constructs">8.3.2条件初始化构造</a></li>
      <li><a name="toc-Sample-Init-File-1" href="#Sample-Init-File">8.3.3样本初始化文件</a></li>
    </ul></li>
    <li><a name="toc-Bindable-Readline-Commands-1" href="#Bindable-Readline-Commands">8.4可绑定的Readline命令</a>
    <ul class="no-bullet">
      <li><a name="toc-Commands-For-Moving-1" href="#Commands-For-Moving">8.4.1移动命令</a></li>
      <li><a name="toc-Commands-For-Manipulating-The-History" href="#Commands-For-History">8.4.2操作历史的命令</a></li>
      <li><a name="toc-Commands-For-Changing-Text" href="#Commands-For-Text">8.4.3更改文本的命令</a></li>
      <li><a name="toc-Killing-And-Yanking" href="#Commands-For-Killing">8.4.4杀与杀</a></li>
      <li><a name="toc-Specifying-Numeric-Arguments" href="#Numeric-Arguments">8.4.5指定数值参数</a></li>
      <li><a name="toc-Letting-Readline-Type-For-You" href="#Commands-For-Completion">8.4.6为您提供Readline类型</a></li>
      <li><a name="toc-Keyboard-Macros-1" href="#Keyboard-Macros">8.4.7键盘宏</a></li>
      <li><a name="toc-Some-Miscellaneous-Commands" href="#Miscellaneous-Commands">8.4.8一些其他命令</a></li>
    </ul></li>
    <li><a name="toc-Readline-vi-Mode-1" href="#Readline-vi-Mode">8.5 Readline vi模式</a></li>
    <li><a name="toc-Programmable-Completion-1" href="#Programmable-Completion">8.6可编程完成</a></li>
    <li><a name="toc-Programmable-Completion-Builtins-1" href="#Programmable-Completion-Builtins">8.7可编程完成内置函数</a></li>
    <li><a name="toc-A-Programmable-Completion-Example-1" href="#A-Programmable-Completion-Example">8.8可编程完成示例</a></li>
  </ul></li>
  <li><a name="toc-Using-History-Interactively-1" href="#Using-History-Interactively">9交互使用历史</a>
  <ul class="no-bullet">
    <li><a name="toc-Bash-History-Facilities-1" href="#Bash-History-Facilities">9.1 Bash历史记录设施</a></li>
    <li><a name="toc-Bash-History-Builtins-1" href="#Bash-History-Builtins">9.2 Bash历史内置</a></li>
    <li><a name="toc-History-Expansion" href="#History-Interaction">9.3历史扩展</a>
    <ul class="no-bullet">
      <li><a name="toc-Event-Designators-1" href="#Event-Designators">9.3.1事件指示符</a></li>
      <li><a name="toc-Word-Designators-1" href="#Word-Designators">9.3.2字指示符</a></li>
      <li><a name="toc-Modifiers-1" href="#Modifiers">9.3.3修饰符</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Installing-Bash-1" href="#Installing-Bash">10安装Bash</a>
  <ul class="no-bullet">
    <li><a name="toc-Basic-Installation-1" href="#Basic-Installation">10.1基本安装</a></li>
    <li><a name="toc-Compilers-and-Options-1" href="#Compilers-and-Options">10.2编译器和选项</a></li>
    <li><a name="toc-Compiling-For-Multiple-Architectures-1" href="#Compiling-For-Multiple-Architectures">10.3多种架构的编译</a></li>
    <li><a name="toc-Installation-Names-1" href="#Installation-Names">10.4安装名称</a></li>
    <li><a name="toc-Specifying-the-System-Type-1" href="#Specifying-the-System-Type">10.5指定系统类型</a></li>
    <li><a name="toc-Sharing-Defaults-1" href="#Sharing-Defaults">10.6共享默认值</a></li>
    <li><a name="toc-Operation-Controls-1" href="#Operation-Controls">10.7操作控制</a></li>
    <li><a name="toc-Optional-Features-1" href="#Optional-Features">10.8可选功能</a></li>
  </ul></li>
  <li><a name="toc-Reporting-Bugs-1" href="#Reporting-Bugs">附录A报告错误</a></li>
  <li><a name="toc-Major-Differences-From-The-Bourne-Shell-1" href="#Major-Differences-From-The-Bourne-Shell">附录B与Bourne Shell的主要区别</a>
  <ul class="no-bullet">
    <li><a name="toc-Implementation-Differences-From-The-SVR4_002e2-Shell" href="#Implementation-Differences-From-The-SVR4_002e2-Shell">B.1与SVR4.2 Shell的实现差异</a></li>
  </ul></li>
  <li><a name="toc-GNU-Free-Documentation-License-1" href="#GNU-Free-Documentation-License">附录C GNU自由文档许可证</a></li>
  <li><a name="toc-Indexes-1" href="#Indexes">附录D索引</a>
  <ul class="no-bullet">
    <li><a name="toc-Index-of-Shell-Builtin-Commands" href="#Builtin-Index">D.1 Shell内置命令索引</a></li>
    <li><a name="toc-Index-of-Shell-Reserved-Words" href="#Reserved-Word-Index">D.2 Shell保留字索引</a></li>
    <li><a name="toc-Parameter-and-Variable-Index" href="#Variable-Index">D.3参数和变量索引</a></li>
    <li><a name="toc-Function-Index-1" href="#Function-Index">D.4功能索引</a></li>
    <li><a name="toc-Concept-Index-1" href="#Concept-Index">D.5概念索引</a></li>
  </ul></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>下一个： <a href="#Introduction" rel="next" accesskey="n">简介</a> ，上一个： <a href="/manual" rel="prev" accesskey="p">（dir）</a> ，上一个： <a href="/manual" rel="up" accesskey="u">（dir）</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Features-1"></a>
<h1 class="top">重击功能</h1>

<p>本文是对Bash Shell中存在的功能的简要说明（版本5.0,2019年5月12日）。Bash主页是<a href="http://www.gnu.org/software/bash/">http://www.gnu.org/software/bash/</a> 。</p>
<p>这是<cite>《 GNU Bash参考手册》的</cite> 5.0版，最新更新于2019年5月12日，适用于<code>Bash</code> ，版本5.0。
</p>
<p>Bash包含出现在其他流行Shell中的功能，以及一些仅出现在Bash中的功能。Bash借鉴了一些概念的外壳是Bourne Shell（ <samp>sh</samp> ），Korn Shell（ <samp>ksh</samp> ）和C-shell（ <samp>csh</samp>及其后继者<samp>tcsh</samp> ）。以下菜单将功能分为几类，并指出哪些功能是受其他shell启发的，哪些是Bash特有的。
</p>
<p>本手册旨在简要介绍Bash中的功能。Bash手册页应该用作有关Shell行为的权威参考。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Introduction" accesskey="1">简介</a> ：</td><td>  </td><td align="left" valign="top">外壳介绍。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Definitions" accesskey="2">定义</a> ：</td><td>  </td><td align="left" valign="top">本手册其余部分中使用的一些定义。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Basic-Shell-Features" accesskey="3">基本外壳功能</a> ：</td><td>  </td><td align="left" valign="top">外壳“构建基块”。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Builtin-Commands" accesskey="4">Shell内置命令</a> ：</td><td>  </td><td align="left" valign="top">属于外壳程序的命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Variables" accesskey="5">Shell变量</a> ：</td><td>  </td><td align="left" valign="top">Bash使用或设置的变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-Features" accesskey="6">Bash功能</a> ：</td><td>  </td><td align="left" valign="top">仅在Bash中找到的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Job-Control" accesskey="7">工作控制</a> ：</td><td>  </td><td align="left" valign="top">什么是作业控制以及Bash如何允许您使用它。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Line-Editing" accesskey="8">命令行编辑</a> ：</td><td>  </td><td align="left" valign="top">本章介绍命令行编辑功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Using-History-Interactively" accesskey="9">交互使用历史记录</a> ：</td><td>  </td><td align="left" valign="top">命令历史扩展</td></tr>
<tr><td align="left" valign="top">• <a href="#Installing-Bash">安装Bash</a> ：</td><td>  </td><td align="left" valign="top">如何在系统上构建和安装Bash。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reporting-Bugs">报告错误</a> ：</td><td>  </td><td align="left" valign="top">如何报告Bash中的错误。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Major-Differences-From-The-Bourne-Shell">与Bourne Shell的主要区别</a> ：</td><td>  </td><td align="left" valign="top">Bash和/ bin / sh历史版本之间差异的简要列表。
</td></tr>
<tr><td align="left" valign="top">• <a href="#GNU-Free-Documentation-License">GNU自由文档许可证</a> ：</td><td>  </td><td align="left" valign="top">复制和共享此文档。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Indexes">指标</a> ：</td><td>  </td><td align="left" valign="top">本手册的各种索引。
</td></tr>
</tbody></table>

<hr>
<a name="Introduction"></a>
<div class="header">
<p>下一页： <a href="#Definitions" rel="next" accesskey="n">定义</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Introduction-1"></a>
<h2 class="chapter">1引言</h2>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#What-is-Bash_003f" accesskey="1">什么是Bash？</a> ：</td><td>  </td><td align="left" valign="top">Bash的简短描述。
</td></tr>
<tr><td align="left" valign="top">• <a href="#What-is-a-shell_003f" accesskey="2">什么是外壳？</a> ：</td><td>  </td><td align="left" valign="top">壳的简要介绍。
</td></tr>
</tbody></table>

<hr>
<a name="What-is-Bash_003f"></a>
<div class="header">
<p>下一页： <a href="#What-is-a-shell_003f" rel="next" accesskey="n">什么是外壳？</a> ，上： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-is-Bash_003f-1"></a>
<h3 class="section">1.1什么是Bash？</h3>

<p>Bash是<small>GNU</small>操作系统的外壳程序或命令语言解释器。名称是“ <samp>Bourne-Again SHell</samp> '，对当前Unix shell的直接祖先作者Stephen Bourne的双关语<code>sh</code> ，该版本出现在Unix的第七版贝尔实验室研究版中。
</p>
<p>Bash与<code>sh</code>并结合了Korn shell中的有用功能<code>ksh</code>和C壳<code>csh</code> 。它旨在成为<small>IEEE</small> <small>POSIX</small>规范（ <small>IEEE</small>标准1003.1）的<small>IEEE</small> <small>POSIX</small>外壳和工具部分的一致实现。它提供了功能上的改进<code>sh</code>用于交互和编程。
</p>
<p>尽管<small>GNU</small>操作系统提供了其他shell，包括一个<code>csh</code> ，Bash是默认的shell。像其他<small>GNU</small>软件一样，Bash具有很好的可移植性。当前，它几乎可以在Unix的每个版本和其他一些操作系统上运行<small>-MS-DOS</small> ， <small>OS / 2</small>和Windows平台存在独立支持的端口。
</p>
<hr>
<a name="What-is-a-shell_003f"></a>
<div class="header">
<p>上<a href="#What-is-Bash_003f" rel="prev" accesskey="p">一篇</a> ： <a href="#What-is-Bash_003f" rel="prev" accesskey="p">什么是Bash？</a> ，上： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-is-a-shell_003f-1"></a>
<h3 class="section">1.2什么是外壳？</h3>

<p>从根本上说，外壳程序只是执行命令的宏处理器。术语宏处理器是指将文本和符号扩展以创建更大的表达式的功能。
</p>
<p>Unix shell既是命令解释器又是编程语言。作为命令解释器，shell为丰富的<small>GNU</small>实用程序集提供了用户界面。编程语言功能允许组合这些实用程序。包含命令的文件可以创建，也可以成为命令本身。这些新命令的状态与目录中的系统命令相同，例如<samp>/bin</samp> ，允许用户或组建立自定义环境以自动化其常见任务。
</p>
<p>外壳可以交互使用或非交互使用。在交互模式下，它们接受键盘输入的输入。当以非交互方式执行时，shell执行从文件读取的命令。
</p>
<p>Shell允许同步和异步执行<small>GNU</small>命令。在接受更多输入之前，shell等待同步命令完成。异步命令继续与外壳程序并行执行，同时读取并执行其他命令。<em>重定向</em>结构允许对这些命令的输入和输出进行细粒度的控制。而且，外壳程序允许控制命令环境的内容。
</p>
<p>Shell还提供了一<em>小组内置</em>命令（ <em>builtins</em> ），这些命令实现了无法或不方便通过单独的实用程序获得的功能。例如， <code>cd</code> ， <code>break</code> ， <code>continue</code>和<code>exec</code>不能在Shell外部实现，因为它们直接操纵Shell本身。的<code>history</code> ， <code>getopts</code> ， <code>kill</code> ， 要么<code>pwd</code>内置命令等可以在单独的实用程序中实现，但是用作内置命令更方便。后续各节将介绍所有的shell内建函数。
</p>
<p>尽管执行命令是必不可少的，但是大多数Shell的功能（和复杂性）都归功于它们的嵌入式编程语言。像任何高级语言一样，shell提供变量，流控制构造，引用和函数。
</p>
<p>Shell提供了专门为交互使用而设计的功能，而不是扩展编程语言。这些交互式功能包括作业控制，命令行编辑，命令历史记录和别名。这些功能的每一个都在本手册中进行了描述。
</p>
<hr>
<a name="Definitions"></a>
<div class="header">
<p>下一页： <a href="#Basic-Shell-Features" rel="next" accesskey="n">Shell的基本功能</a> ，上一页： <a href="#Introduction" rel="prev" accesskey="p">简介</a> ，上一页： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Definitions-1"></a>
<h2 class="chapter">2定义</h2>
<p>这些定义将在本手册的其余部分中使用。
</p>
<dl compact>
<dt><code>POSIX</code></dt>
<dd><a name="index-POSIX"></a>
<p>基于Unix的一系列开放系统标准。Bash主要关注<small>POSIX</small> 1003.1标准的Shell和Utilities部分。
</p>
</dd>
<dt><code>blank</code></dt>
<dd><p>空格或制表符。
</p>
</dd>
<dt><code>builtin</code></dt>
<dd><a name="index-builtin-1"></a>
<p>由Shell本身在内部实现的命令，而不是由文件系统中某个位置的可执行程序实现的命令。
</p>
</dd>
<dt><code>control operator</code></dt>
<dd><a name="index-control-operator"></a>
<p>一种<code>token</code>执行控制功能。它是一个<code>newline</code>或以下之一： <samp>||</samp> '，' <samp>&&</samp> '，' <samp>&</samp> '，' <samp>;</samp> '，' <samp>;;</samp> '，' <samp>;&</samp> '，' <samp>;;&</samp> '，' <samp>|</samp> '，' <samp>|&</samp> '，' <samp>(</samp> '， 要么 ' <samp>)</samp> '。
</p>
</dd>
<dt><code>exit status</code></dt>
<dd><a name="index-exit-status"></a>
<p>命令返回给调用者的值。该值限制为八位，因此最大值为255。
</p>
</dd>
<dt><code>field</code></dt>
<dd><a name="index-field"></a>
<p>外壳扩展之一导致的文本单位。扩展后，执行命令时，结果字段将用作命令名称和参数。
</p>
</dd>
<dt><code>filename</code></dt>
<dd><a name="index-filename"></a>
<p>用于标识文件的字符串。
</p>
</dd>
<dt><code>job</code></dt>
<dd><a name="index-job"></a>
<p>一组由管道组成的过程，以及所有从其衍生的过程，它们都在同一过程组中。
</p>
</dd>
<dt><code>job control</code></dt>
<dd><a name="index-job-control"></a>
<p>一种机制，用户可以通过该机制选择性地停止（挂起）并重新开始（恢复）进程的执行。
</p>
</dd>
<dt><code>metacharacter</code></dt>
<dd><a name="index-metacharacter"></a>
<p>当不加引号时，用于分隔单词的字符。元字符是<code>space</code> ， <code>tab</code> ， <code>newline</code> ，或以下字符之一：' <samp>|</samp> '，' <samp>&</samp> '，' <samp>;</samp> '，' <samp>(</samp> '，' <samp>)</samp> '，' <samp><</samp> '， 要么 ' <samp>></samp> '。
</p>
</dd>
<dt><code>name</code></dt>
<dd><a name="index-name"></a>
<a name="index-identifier"></a>
<p>一种<code>word</code>仅由字母，数字和下划线组成，并以字母或下划线开头。 <code>Name</code>用作shell变量和函数名称。也称为<code>identifier</code> 。
</p>
</dd>
<dt><code>operator</code></dt>
<dd><a name="index-operator_002c-shell"></a>
<p>一种<code>control operator</code>或一个<code>redirection operator</code> 。有关<a href="#Redirections">重定向</a>操作符的列表，请参见<a href="#Redirections">重定向</a> 。运算符包含至少一个未引用的<code>metacharacter</code> 。
</p>
</dd>
<dt><code>process group</code></dt>
<dd><a name="index-process-group"></a>
<p>相关进程的集合，每个进程具有相同的进程组<small>ID</small> 。</p>
</dd>
<dt><code>process group ID</code></dt>
<dd><a name="index-process-group-ID"></a>
<p>代表一个唯一标识符<code>process group</code>在其一生中。
</p>
</dd>
<dt><code>reserved word</code></dt>
<dd><a name="index-reserved-word"></a>
<p>一种<code>word</code>对外壳有特殊的意义大多数保留字介绍了外壳流控制构造，例如<code>for</code>和<code>while</code> 。
</p>
</dd>
<dt><code>return status</code></dt>
<dd><a name="index-return-status"></a>
<p>的同义词<code>exit status</code> 。
</p>
</dd>
<dt><code>signal</code></dt>
<dd><a name="index-signal"></a>
<p>一种机制，内核可以通过该机制通知系统中发生的事件。
</p>
</dd>
<dt><code>special builtin</code></dt>
<dd><a name="index-special-builtin"></a>
<p>一个外壳内置命令，已由<small>POSIX</small>标准分类为特殊命令。
</p>
</dd>
<dt><code>token</code></dt>
<dd><a name="index-token"></a>
<p>外壳程序将单个字符视为一个单元。它要么是<code>word</code>或<code>operator</code> 。
</p>
</dd>
<dt><code>word</code></dt>
<dd><a name="index-word"></a>
<p>Shell将一个字符序列视为一个单元。单词可能不包含未引号<code>metacharacters</code> 。
</p></dd>
</dl>

<hr>
<a name="Basic-Shell-Features"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Builtin-Commands" rel="next" accesskey="n">Shell内置命令</a> ，上一篇： <a href="#Definitions" rel="prev" accesskey="p">定义</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Basic-Shell-Features-1"></a>
<h2 class="chapter">3 Shell的基本功能</h2>
<a name="index-Bourne-shell"></a>

<p>Bash是“ <samp>Bourne-Again SHell</samp> '。Bourne shell是最初由Stephen Bourne编写的传统Unix shell。所有的Bourne shell内置命令都可以在Bash中获得。评估和引用规则取自<small>POSIX</small>规范中的“标准” Unix shell。
</p>
<p>本章简要总结了shell的“构建块”：命令，控制结构，shell函数，shell <i>参数</i> ，shell扩展， <i>重定向</i> ，它们是在命名文件之间直接输入和输出以及shell如何执行命令的方法。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Shell-Syntax" accesskey="1">Shell语法</a> ：</td><td>  </td><td align="left" valign="top">您的输入对外壳意味着什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Commands" accesskey="2">Shell命令</a> ：</td><td>  </td><td align="left" valign="top">您可以使用的命令类型。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Functions" accesskey="3">Shell功能</a> ：</td><td>  </td><td align="left" valign="top">按名称对命令进行分组。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Parameters" accesskey="4">Shell参数</a> ：</td><td>  </td><td align="left" valign="top">Shell如何存储值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Expansions" accesskey="5">外壳扩展</a> ：</td><td>  </td><td align="left" valign="top">Bash如何扩展参数以及可用的各种扩展。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Redirections" accesskey="6">重定向</a> ：</td><td>  </td><td align="left" valign="top">一种控制输入和输出位置的方法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Executing-Commands" accesskey="7">执行命令</a> ：</td><td>  </td><td align="left" valign="top">运行命令时会发生什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Scripts" accesskey="8">Shell脚本</a> ：</td><td>  </td><td align="left" valign="top">执行shell命令文件。
</td></tr>
</tbody></table>

<hr>
<a name="Shell-Syntax"></a>
<div class="header">
<p>下一页： <a href="#Shell-Commands" rel="next" accesskey="n">Shell命令</a> ，上一篇： <a href="#Shell-Commands" rel="next" accesskey="n">Shell的</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Syntax-1"></a>
<h3 class="section">3.1 Shell语法</h3>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Shell-Operation" accesskey="1">Shell操作</a> ：</td><td>  </td><td align="left" valign="top">shell的基本操作。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Quoting" accesskey="2">报价</a> ：</td><td>  </td><td align="left" valign="top">如何从字符中删除特殊含义。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Comments" accesskey="3">评论</a> ：</td><td>  </td><td align="left" valign="top">如何指定注释。
</td></tr>
</tbody></table>

<p>当shell读取输入时，它将继续执行一系列操作。如果输入指示注释的开头，则外壳将忽略注释符号（“ <samp>#</samp> '），以及该行的其余部分。
</p>                                
<p>否则，大致来说，shell会读取其输入并将输入分为单词和运算符，并使用引用规则来选择分配各种单词和字符的含义。
</p>
<p>然后，shell将这些标记解析为命令和其他构造，删除某些单词或字符的特殊含义，扩展其他字符，根据需要重定向输入和输出，执行指定的命令，等待命令的退出状态，并使退出状态可用供进一步检查或处理。
</p>
<hr>
<a name="Shell-Operation"></a>
<div class="header">
<p>下一篇： <a href="#Quoting" rel="next" accesskey="n">引用</a> ，上一篇： <a href="#Shell-Syntax" rel="up" accesskey="u">Shell语法</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Operation-1"></a>
<h4 class="subsection">3.1.1 Shell操作</h4>

<p>以下是外壳程序读取和执行命令时的操作的简要说明。基本上，shell执行以下操作：</p>
<ol>
<li>从文件（请参阅<a href="#Shell-Scripts">Shell Scripts</a> ），从作为参数提供的字符串中读取其输入。 <samp>-c</samp>调用选项（请参阅“ <a href="#Invoking-Bash">调用Bash”</a> ），或从用户终端。

</li><li>打破输入字和操作符，服从中描述的引用规则<a href="#Quoting">引用</a> 。这些标记由<code>metacharacters</code> 。别名扩展是通过此步骤执行的（请参见<a href="#Aliases">Aliases</a> ）。

</li><li>将标记解析为简单的复合命令（请参阅<a href="#Shell-Commands">Shell命令</a> ）。

</li><li>执行各种shell扩展（请参阅<a href="#Shell-Expansions">Shell Expansions</a> ），将扩展的令牌分为文件名列表（请参见<a href="#Filename-Expansion">Filename Expansion</a> ）以及命令和参数。

</li><li>执行任何必要的重定向（请参阅<a href="#Redirections">Redirections</a> ），并从参数列表中删除重定向运算符及其操作数。

</li><li>执行命令（请参阅<a href="#Executing-Commands">执行命令</a> ）。

</li><li>（可选）等待命令完成并收集其退出状态（请参阅“ <a href="#Exit-Status">退出状态”</a> ）。

</li></ol>

<hr>
<a name="Quoting"></a>
<div class="header">
<p>下一页： <a href="#Comments" rel="next" accesskey="n">注释</a> ，上一篇： <a href="#Shell-Operation" rel="prev" accesskey="p">Shell操作</a> ，上一篇： <a href="#Shell-Syntax" rel="up" accesskey="u">Shell语法</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Quoting-1"></a>
<h4 class="subsection">3.1.2报价</h4>
<a name="index-quoting"></a>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Escape-Character" accesskey="1">转义字符</a> ：</td><td>  </td><td align="left" valign="top">如何从单个字符中删除特殊含义。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Single-Quotes" accesskey="2">单引号</a> ：</td><td>  </td><td align="left" valign="top">如何禁止对一个字符序列的所有解释。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Double-Quotes" accesskey="3">双引号</a> ：</td><td>  </td><td align="left" valign="top">如何抑制大多数解释字符序列。
</td></tr>
<tr><td align="left" valign="top">• <a href="#ANSI_002dC-Quoting" accesskey="4">ANSI-C报价</a> ：</td><td>  </td><td align="left" valign="top">如何在带引号的字符串中扩展ANSI-C序列。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Locale-Translation" accesskey="5">语言环境翻译</a> ：</td><td>  </td><td align="left" valign="top">如何将字符串翻译成不同的语言。
</td></tr>
</tbody></table>

<p>引用用于将某些字符或单词的特殊含义删除。引用可用于禁用对特殊字符的特殊处理，以防止保留字被识别为此类，并防止参数扩展。
</p>
<p>每个外壳程序元字符（请参见<a href="#Definitions">定义</a> ）对外壳程序都有特殊含义，如果要表示自身，则必须加引号。使用命令历史记录扩展功能时（请参阅<a href="#History-Interaction">History Interaction</a> ）， <var>history expansion</var>字符，通常是“ <samp>!</samp> '，必须加引号以防止历史记录扩展。有关历史扩展的更多详细信息，请参见<a href="#Bash-History-Facilities">Bash历史设施</a> 。
</p>
<p>共有三种报价机制： <var>escape character</var> ，单引号和双引号。
</p>
<hr>
<a name="Escape-Character"></a>
<div class="header">
<p>下一篇： <a href="#Single-Quotes" rel="next" accesskey="n">单引号</a> ，上一篇： <a href="#Quoting" rel="up" accesskey="u">引用</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Escape-Character-1"></a>
<h4 class="subsubsection">3.1.2.1转义符</h4>
<p>不带引号的反斜杠“ <samp>\</samp> '是Bash转义字符。它保留了下一个字符的字面值，但以下字符除外<code>newline</code> 。如果一个<code>\newline</code>出现对，并且反斜杠本身未加引号， <code>\newline</code>被视为行连续（即，它已从输入流中删除并被有效忽略）。
</p>
<hr>
<a name="Single-Quotes"></a>
<div class="header">
<p>下一篇： <a href="#Double-Quotes" rel="next" accesskey="n">双引号</a> ，上一篇： <a href="#Escape-Character" rel="prev" accesskey="p">转义</a> <a href="#Double-Quotes" rel="next" accesskey="n">符</a> ，上一篇： <a href="#Quoting" rel="up" accesskey="u">引用</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Single-Quotes-1"></a>
<h4 class="subsubsection">3.1.2.2单引号</h4>

<p>将字符括在单引号（' <samp>'</samp> '）保留引号内每个字符的字面值。即使在单引号之前加反斜杠，也不能在单引号之间引起单引号。
</p>
<hr>
<a name="Double-Quotes"></a>
<div class="header">
<p>下一篇： <a href="#ANSI_002dC-Quoting" rel="next" accesskey="n">ANSI-C引用</a> ，上一篇： <a href="#Single-Quotes" rel="prev" accesskey="p">单引号</a> ，上一篇： <a href="#Quoting" rel="up" accesskey="u">引用</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Double-Quotes-1"></a>
<h4 class="subsubsection">3.1.2.3双引号</h4>

<p>将字符括在双引号（' <samp>"</samp> '）保留引号内所有字符的字面值，但' <samp>$</samp> '，' <samp>`</samp> '，' <samp>\</samp> '，并且在启用历史记录扩展后，' <samp>!</samp> '。当外壳处于<small>POSIX</small>模式（请参见<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）时， <samp>!</samp>即使启用了历史记录扩展，双引号中的'也没有特殊含义。那些角色 ' <samp>$</samp> '和' <samp>`</samp>保留双引号中的特殊含义（请参见<a href="#Shell-Expansions">Shell Expansions</a> ）。仅当反斜杠后面带有以下字符之一时，才保留其特殊含义：' <samp>$</samp> '，' <samp>`</samp> '，' <samp>"</samp> '，' <samp>\</samp> '， 要么<code>newline</code> 。在双引号中，将删除反斜杠，后跟这些字符之一。没有特殊含义的反斜杠前面的字符将保持不变。双引号可以在双引号内加上反斜杠。如果启用，将执行历史记录扩展，除非“ <samp>!</samp> '用双引号引起来的使用反斜杠进行转义。'前的反斜杠<samp>!</samp> '未删除。
</p>
<p>特殊参数<samp>*</samp> '和' <samp>@</samp> '在双引号中具有特殊含义（请参见<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。
</p>
<hr>
<a name="ANSI_002dC-Quoting"></a>
<div class="header">
<p>下一篇： <a href="#Locale-Translation" rel="next" accesskey="n">区域设置翻译</a> ，上一篇： <a href="#Double-Quotes" rel="prev" accesskey="p">双引号</a> ，上一篇： <a href="#Quoting" rel="up" accesskey="u">引用</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="ANSI_002dC-Quoting-1"></a>
<h4 class="subsubsection">3.1.2.4 ANSI-C报价</h4>
<a name="index-quoting_002c-ANSI"></a>

<p>形式的话<code>$'<var>string</var>'</code>被特殊对待。这个词扩展为<var>string</var> ，并按ANSI C标准的规定替换反斜杠转义字符。反斜杠转义序列（如果存在）的解码方式如下：</p>
<dl compact>
<dt><code>\a</code></dt>
<dd><p>警觉</p></dd>
<dt><code>\b</code></dt>
<dd><p>退格键</p></dd>
<dt><code>\e</code></dt>
<dt><code>\E</code></dt>
<dd><p>转义字符（不是ANSI C）</p></dd>
<dt><code>\f</code></dt>
<dd><p>换页</p></dd>
<dt><code>\n</code></dt>
<dd><p>新队</p></dd>
<dt><code>\r</code></dt>
<dd><p>回车</p></dd>
<dt><code>\t</code></dt>
<dd><p>水平标签</p></dd>
<dt><code>\v</code></dt>
<dd><p>垂直标签</p></dd>
<dt><code>\\</code></dt>
<dd><p>反斜杠</p></dd>
<dt><code>\'</code></dt>
<dd><p>单引号</p></dd>
<dt><code>\"</code></dt>
<dd><p>双引号</p></dd>
<dt><code>\?</code></dt>
<dd><p>问号</p></dd>
<dt><code>\<var>nnn</var></code></dt>
<dd><p>八位字符，其值为八进制值<var>nnn</var> （一到三个八进制数字）</p></dd>
<dt><code>\x<var>HH</var></code></dt>
<dd><p>八位字符，其值为十六进制值<var>HH</var> （一个或两个十六进制数字）</p></dd>
<dt><code>\u<var>HHHH</var></code></dt>
<dd><p>Unicode（ISO / IEC 10646）字符，其值为十六进制值<var>HHHH</var> （一到四个十六进制数字）</p></dd>
<dt><code>\U<var>HHHHHHHH</var></code></dt>
<dd><p>Unicode（ISO / IEC 10646）字符，其值为十六进制值<var>HHHHHHHH</var> （1到8个十六进制数字）</p></dd>
<dt><code>\c<var>x</var></code></dt>
<dd><p>控制- <var>x</var>字符</p></dd>
</dl>

<p>扩展结果是单引号，好像没有美元符号。
</p>
<hr>
<a name="Locale-Translation"></a>
<div class="header">
<p>上一页： <a href="#ANSI_002dC-Quoting" rel="prev" accesskey="p">ANSI-C引用</a> ，向上： <a href="#Quoting" rel="up" accesskey="u">引用</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Locale_002dSpecific-Translation"></a>
<h4 class="subsubsection">3.1.2.5特定于语言环境的翻译</h4>
<a name="index-localization"></a>
<a name="index-internationalization"></a>
<a name="index-native-languages"></a>
<a name="index-translation_002c-native-languages"></a>

<p>用双引号引起来的字符串，后跟一个美元符号（' <samp>$</samp> '）将导致字符串根据当前语言环境进行翻译。如果当前语言环境是<code>C</code>要么<code>POSIX</code> ，则忽略美元符号。如果字符串被翻译和替换，替换将被双引号引起来。
</p>
<a name="index-LC_005fMESSAGES"></a>
<a name="index-TEXTDOMAIN"></a>
<a name="index-TEXTDOMAINDIR"></a>
<p>某些系统使用由<code>LC_MESSAGES</code>外壳变量。其他人根据的值创建消息目录的名称。 <code>TEXTDOMAIN</code> shell变量，可能添加后缀' <samp>.mo</samp> '。如果您使用<code>TEXTDOMAIN</code>变量，您可能需要设置<code>TEXTDOMAINDIR</code>变量设置为消息目录文件的位置。还有一些人以这种方式使用两个变量： <code>TEXTDOMAINDIR</code> / <code>LC_MESSAGES</code> / LC_MESSAGES / <code>TEXTDOMAIN</code> .mo。
</p>
<hr>
<a name="Comments"></a>
<div class="header">
<p>上<a href="#Quoting" rel="prev" accesskey="p">一篇</a> ： <a href="#Quoting" rel="prev" accesskey="p">引用</a> ，上<a href="#Quoting" rel="prev" accesskey="p">一篇</a> ： <a href="#Shell-Syntax" rel="up" accesskey="u">Shell语法</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Comments-1"></a>
<h4 class="subsection">3.1.3注释</h4>
<a name="index-comments_002c-shell"></a>

<p>在非交互式外壳中，或在其中<code>interactive_comments</code>选项<code>shopt</code>启用了<a href="#The-Shopt-Builtin">Builtin</a> （请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），以' <samp>#</samp> '会导致忽略该单词和该行上的所有剩余字符。一个没有<code>interactive_comments</code>启用的选项不允许评论。的<code>interactive_comments</code>在交互式shell中，默认情况下该选项处于启用状态。请参阅<a href="#Interactive-Shells">Interactive Shells</a> ，以获取使Shell交互式的内容的描述。
</p>
<hr>
<a name="Shell-Commands"></a>
<div class="header">
<p>下一页： <a href="#Shell-Functions" rel="next" accesskey="n">Shell函数</a> ，上一篇： <a href="#Shell-Functions" rel="next" accesskey="n">Shell</a> <a href="#Shell-Syntax" rel="prev" accesskey="p">语法</a> ，上一篇： <a href="#Shell-Functions" rel="next" accesskey="n">Shell</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Commands-1"></a>
<h3 class="section">3.2 Shell命令</h3>
<a name="index-commands_002c-shell"></a>

<p>一个简单的shell命令，例如<code>echo a b c</code>由命令本身和后跟参数（由空格分隔）组成。
</p>
<p>更复杂的Shell命令由以各种方式排列在一起的简单命令组成：在管道中，一个命令的输出成为第二个命令的输入，在循环或条件构造中，或在其他一些分组中。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Simple-Commands" accesskey="1">简单命令</a> ：</td><td>  </td><td align="left" valign="top">最常见的命令类型。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pipelines" accesskey="2">管道</a> ：</td><td>  </td><td align="left" valign="top">连接几个命令的输入和输出。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Lists" accesskey="3">清单</a> ：</td><td>  </td><td align="left" valign="top">如何顺序执行命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Compound-Commands" accesskey="4">复合命令</a> ：</td><td>  </td><td align="left" valign="top">用于控制流的Shell命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Coprocesses" accesskey="5">协同处理</a> ：</td><td>  </td><td align="left" valign="top">命令之间的双向通讯。
</td></tr>
<tr><td align="left" valign="top">• <a href="#GNU-Parallel" accesskey="6">GNU并行</a> ：</td><td>  </td><td align="left" valign="top">并行运行命令。
</td></tr>
</tbody></table>

<hr>
<a name="Simple-Commands"></a>
<div class="header">
<p>下一页： <a href="#Pipelines" rel="next" accesskey="n">管道</a> ，向上： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Simple-Commands-1"></a>
<h4 class="subsection">3.2.1简单命令</h4>
<a name="index-commands_002c-simple"></a>

<p>简单命令是最常遇到的命令。只是一个单词序列，由<code>blank</code> s，由外壳程序的控制运算符之一终止（请参见“ <a href="#Definitions">定义”</a> ）。通常，第一个单词指定要执行的命令，其余单词是该命令的参数。
</p>
<p>简单命令的返回状态（请参阅<a href="#Exit-Status">退出状态</a> ）是<small>POSIX</small> 1003.1提供的退出状态。 <code>waitpid</code>功能，或128+ <var>n</var>如果命令被信号终止<var>n</var> 。
</p>
<hr>
<a name="Pipelines"></a>
<div class="header">
<p>下一页： <a href="#Lists" rel="next" accesskey="n">列表</a> ，上一页： <a href="#Simple-Commands" rel="prev" accesskey="p">简单命令</a> ，上一页： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Pipelines-1"></a>
<h4 class="subsection">3.2.2管道</h4>
<a name="index-pipeline"></a>
<a name="index-commands_002c-pipelines"></a>

<p>一种<code>pipeline</code>是由一个或多个控制操作符分隔的一个或多个命令的序列<samp>|</samp> ' 要么 ' <samp>|&</samp> '。
</p>
<a name="index-time"></a>
<a name="index-_0021"></a>
<a name="index-command-timing"></a>
<p>管道的格式为</p><div class="example">
<pre class="example">[time [-p]] [!] <var>command1</var> [ | or |&amp; <var>command2</var> ] &hellip;
</pre></div>

<p>管道中每个命令的输出通过管道连接到下一个命令的输入。也就是说，每个命令都读取前一个命令的输出。该连接在命令指定的任何重定向之前执行。
</p>
<p>如果“ <samp>|&</samp> ' 用来， <var>command1</var>的标准错误，除了其标准输出外，还与<var>command2</var>通过管道的标准输入；这是简写<code>2>&1 |</code> 。将标准错误隐式重定向到标准输出是在命令指定的任何重定向之后执行的。
</p>
<p>保留字<code>time</code>导致完成后为管道打印时序统计信息。当前的统计信息包括执行时间（挂钟）以及命令执行所消耗的用户和系统时间。的<samp>-p</samp>选项将输出格式更改为<small>POSIX</small>指定的格式。当外壳程序处于<small>POSIX</small>模式（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）时，它无法识别<code>time</code>如果下一个标记以'开头，则作为保留字<samp>-</samp> '。的<code>TIMEFORMAT</code>变量可以设置为格式字符串，该格式字符串指定应如何显示计时信息。有关可用格式的说明，请参见<a href="#Bash-Variables">Bash变量</a> 。指某东西的用途<code>time</code>因为保留字允许对shell内置，shell函数和管道进行计时。外部<code>time</code>命令无法轻松计时这些时间。
</p>
<p>当外壳处于<small>POSIX</small>模式时（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）， <code>time</code>可能后跟换行符。在这种情况下，外壳程序会显示外壳程序及其子级消耗的总用户和系统时间。的<code>TIMEFORMAT</code>变量可用于指定时间信息的格式。
</p>
<p>如果管道不是异步执行的（请参见<a href="#Lists">Lists</a> ），则Shell将等待管道中的所有命令完成。
</p>
<p>管道中的每个命令都在其自己的子外壳中执行，该子外壳是一个单独的进程（请参阅<a href="#Command-Execution-Environment">命令执行环境</a> ）。如果<code>lastpipe</code>使用以下选项启用<code>shopt</code>内置（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），管道的最后一个元素可以由Shell进程运行。
</p>
<p>管道的退出状态是管道中最后一条命令的退出状态，除非<code>pipefail</code>选项已启用（请参阅<a href="#The-Set-Builtin">内置内置集</a> ）。如果<code>pipefail</code>启用后，管道的返回状态是最后一个（最右边的）命令的值（非零状态）；如果所有命令成功退出，则返回零。如果保留字为“ <samp>!</samp> '在管道之前，退出状态是如上所述退出状态的逻辑取反。在返回值之前，shell等待管道中的所有命令终止。
</p>
<hr>
<a name="Lists"></a>
<div class="header">
<p>下一篇： <a href="#Compound-Commands" rel="next" accesskey="n">复合命令</a> ，上一篇： <a href="#Pipelines" rel="prev" accesskey="p">管道</a> ，上一篇： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Lists-of-Commands"></a>
<h4 class="subsection">3.2.3命令列表</h4>
<a name="index-commands_002c-lists"></a>

<p>一种<code>list</code>是由一个或多个操作员分隔的一个或多个管道的序列<samp>;</samp> '，' <samp>&</samp> '，' <samp>&&</samp> '， 要么 ' <samp>||</samp> '，并可以选择以' <samp>;</samp> '，' <samp>&</samp> '或<code>newline</code> 。
</p>
<p>在这些列表运算符中，“ <samp>&&</samp> '和' <samp>||</samp> '具有相同的优先级，后跟' <samp>;</samp> '和' <samp>&</samp> '，它们具有相同的优先级。
</p>
<p>一个或多个换行符的序列可能会出现在<code>list</code>分隔命令，等同于分号。
</p>
<p>如果命令被控制操作员终止， <samp>&</samp> '，shell在子shell中异步执行命令。这称为在<var>background</var> ，这些被称为<var>asynchronous</var>命令。外壳程序不等待命令完成，返回状态为0（true）。当作业控制未激活时（请参见<a href="#Job-Control">Job Control</a> ），异步命令的标准输入在没有任何显式重定向的情况下从重定向。 <code>/dev/null</code> 。
</p>
<p>以'分隔的命令<samp>;</samp> '按顺序执行； Shell等待每个命令依次终止。返回状态是最后执行的命令的退出状态。
</p>
<p><small>AND</small>和<small>OR</small>列表是由控制运算符分隔的一个或多个管道的序列<samp>&&</samp> '和' <samp>||</samp> '， 分别。<small>AND</small>和<small>OR</small>列表以左关联性执行。
</p>
<p><small>AND</small>清单的格式</p><div class="example">
<pre class="example"><var>command1</var> &amp;&amp; <var>command2</var>
</pre></div>

<p><var>command2</var>仅在以下情况下执行<var>command1</var>返回退出状态为零（成功）。
</p>
<p><small>或</small>列表具有以下形式</p><div class="example">
<pre class="example"><var>command1</var> || <var>command2</var>
</pre></div>

<p><var>command2</var>仅在以下情况下执行<var>command1</var>返回非零退出状态。
</p>
<p><small>AND</small>和<small>OR</small>列表的返回状态是列表中最后执行的命令的退出状态。
</p>
<hr>
<a name="Compound-Commands"></a>
<div class="header">
<p>下一页： <a href="#Coprocesses" rel="next" accesskey="n">协同过程</a> ，上一页： <a href="#Lists" rel="prev" accesskey="p">列表</a> ，上一页： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Compound-Commands-1"></a>
<h4 class="subsection">3.2.4复合命令</h4>
<a name="index-commands_002c-compound"></a>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Looping-Constructs" accesskey="1">循环构造</a> ：</td><td>  </td><td align="left" valign="top">Shell命令进行迭代操作。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditional-Constructs" accesskey="2">条件构造</a> ：</td><td>  </td><td align="left" valign="top">用于条件执行的Shell命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Grouping" accesskey="3">命令分组</a> ：</td><td>  </td><td align="left" valign="top">分组命令的方式。
</td></tr>
</tbody></table>

<p>复合命令是Shell编程语言的构造。每个构造都以保留字或控制运算符开头，并以相应的保留字或控制符终止。与复合命令关联的所有重定向（请参阅<a href="#Redirections">Redirections</a> ）都适用于该复合命令中的所有命令，除非明确覆盖。
</p>
<p>在大多数情况下，复合命令描述中的命令列表可以用一个或多个换行符与其余命令分开，并且可以用换行符代替分号。
</p>
<p>Bash提供了循环构造，条件命令以及将命令分组并作为一个单元执行的机制。
</p>
<hr>
<a name="Looping-Constructs"></a>
<div class="header">
<p>下一篇： <a href="#Conditional-Constructs" rel="next" accesskey="n">条件构造</a> ，上一篇： <a href="#Compound-Commands" rel="up" accesskey="u">复合命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Looping-Constructs-1"></a>
<h4 class="subsubsection">3.2.4.1循环构造</h4>
<a name="index-commands_002c-looping"></a>

<p>Bash支持以下循环构造。
</p>
<p>请注意，无论“ <samp>;</samp> '出现在命令语法的描述中，可以用一个或多个换行符代替。
</p>
<dl compact>
<dt><code>until</code></dt>
<dd><a name="index-until"></a>
<a name="index-do"></a>
<a name="index-done"></a>
<p>的语法<code>until</code>命令是：</p>
<div class="example">
<pre class="example">until <var>test-commands</var>; do <var>consequent-commands</var>; done
</pre></div>

<p>执行<var>consequent-commands</var>只要<var>test-commands</var>退出状态不为零。返回状态是在中执行的最后一条命令的退出状态<var>consequent-commands</var> ，如果未执行任何操作，则返回零。
</p>
</dd>
<dt><code>while</code></dt>
<dd><a name="index-while"></a>
<p>的语法<code>while</code>命令是：</p>
<div class="example">
<pre class="example">while <var>test-commands</var>; do <var>consequent-commands</var>; done
</pre></div>

<p>执行<var>consequent-commands</var>只要<var>test-commands</var>退出状态为零。返回状态是在中执行的最后一条命令的退出状态<var>consequent-commands</var> ，如果未执行任何操作，则返回零。
</p>
</dd>
<dt><code>for</code></dt>
<dd><a name="index-for"></a>
<p>的语法<code>for</code>命令是：</p>
<div class="example">
<pre class="example">for <var>name</var> [ [in [<var>words</var> &hellip;] ] ; ] do <var>commands</var>; done
</pre></div>

<p>扩大<var>words</var> （请参阅<a href="#Shell-Expansions">Shell Expansions</a> ），然后执行<var>commands</var>对于结果列表中的每个成员一次， <var>name</var>绑定到当前成员。如果“ <samp>in <var>words</var></samp> '不存在， <code>for</code>命令执行<var>commands</var>对于设置的每个位置参数一次，就像“ <samp>in "$@"</samp> '已指定（请参见<a href="#Special-Parameters">特殊参数</a> ）。
</p>
<p>返回状态是最后执行的命令的退出状态。如果扩展中没有项目<var>words</var> ，不执行任何命令，返回状态为零。
</p>
<p>另一种形式<code>for</code>命令也受支持：</p>
<div class="example">
<pre class="example">for (( <var>expr1</var> ; <var>expr2</var> ; <var>expr3</var> )) ; do <var>commands</var> ; done
</pre></div>

<p>一，算术表达式<var>expr1</var>根据下面描述的规则进行评估（请参阅<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。算术表达式<var>expr2</var>然后重复评估，直到评估为零。每一次<var>expr2</var>评估为非零值， <var>commands</var>被执行和算术表达式<var>expr3</var>被评估。如果省略任何表达式，则其行为就好像其值为1。返回值是最后一条命令的退出状态<var>commands</var>被执行；如果任何表达式无效，则返回false。
</p></dd>
</dl>

<p>的<code>break</code>和<code>continue</code>内置程序（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置程序</a> ）可用于控制循环执行。
</p>
<hr>
<a name="Conditional-Constructs"></a>
<div class="header">
<p>下一篇： <a href="#Command-Grouping" rel="next" accesskey="n">命令分组</a> ，上一篇： <a href="#Looping-Constructs" rel="prev" accesskey="p">循环构造</a> ，上一篇： <a href="#Compound-Commands" rel="up" accesskey="u">复合命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Conditional-Constructs-1"></a>
<h4 class="subsubsection">3.2.4.2条件构造</h4>
<a name="index-commands_002c-conditional"></a>

<dl compact>
<dt><code>if</code></dt>
<dd><a name="index-if"></a>
<a name="index-then"></a>
<a name="index-else"></a>
<a name="index-elif"></a>
<a name="index-fi"></a>
<p>的语法<code>if</code>命令是：</p>
<div class="example">
<pre class="example">if <var>test-commands</var>; then
  <var>consequent-commands</var>;
[elif <var>more-test-commands</var>; then
  <var>more-consequents</var>;]
[else <var>alternate-consequents</var>;]
fi
</pre></div>

<p>的<var>test-commands</var>执行列表，如果其返回状态为零，则<var>consequent-commands</var>清单已执行。如果<var>test-commands</var>返回非零状态，每个状态<code>elif</code>依次执行列表，如果其退出状态为零，则对应的<var>more-consequents</var>执行并完成命令。如果“ <samp>else <var>alternate-consequents</var></samp> '存在，并且最终命令在最终<code>if</code>要么<code>elif</code>子句的退出状态为非零，则<var>alternate-consequents</var>被执行。返回状态是最后执行的命令的退出状态，如果没有条件测试为真，则返回零。
</p>
</dd>
<dt><code>case</code></dt>
<dd><a name="index-case"></a>
<a name="index-in"></a>
<a name="index-esac"></a>
<p>的语法<code>case</code>命令是：</p>
<div class="example">
<pre class="example">case <var>word</var> in
    [ [(] <var>pattern</var> [| <var>pattern</var>]&hellip;) <var>command-list</var> ;;]&hellip;
esac
</pre></div>

<p><code>case</code>将有选择地执行<var>command-list</var>对应第一个<var>pattern</var>匹配<var>word</var> 。根据以下“ <a href="#Pattern-Matching">模式匹配”中</a>所述的规则执行<a href="#Pattern-Matching">匹配</a> 。如果<code>nocasematch</code> shell选项（请参阅<code>shopt</code> <a href="#The-Shopt-Builtin">如果启用了“内置商店”</a> ），则匹配时将不考虑字母字符的大小写。' <samp>|</samp> '用于分隔多个模式，而' <samp>)</samp> '运算符终止模式列表。模式列表和相关的命令列表称为<var>clause</var> 。
</p>
<p>每个子句都必须以' <samp>;;</samp> '，' <samp>;&</samp> '， 要么 ' <samp>;;&</samp> '。的<var>word</var>在尝试匹配之前，先进行代字扩展，参数扩展，命令替换，算术扩展和引号删除（请参阅<a href="#Shell-Parameter-Expansion">Shell Parameter Expansion</a> ）。每<var>pattern</var>进行波浪线扩展，参数扩展，命令替换和算术扩展。
</p>
<p>可能有任意数量的<code>case</code>条款，每个条款以“ <samp>;;</samp> '，' <samp>;&</samp> '， 要么 ' <samp>;;&</samp> '。匹配的第一个模式确定要执行的命令列表。使用“ <samp>*</samp> '作为定义默认大小写的最终模式，因为该模式将始终匹配。
</p>
<p>这是一个使用示例<code>case</code>在可以用来描述动物有趣特征的脚本中：</p>
<div class="example">
<pre class="example">echo -n &quot;Enter the name of an animal: &quot;
read ANIMAL
echo -n &quot;The $ANIMAL has &quot;
case $ANIMAL in
  horse | dog | cat) echo -n &quot;four&quot;;;
  man | kangaroo ) echo -n &quot;two&quot;;;
  *) echo -n &quot;an unknown number of&quot;;;
esac
echo &quot; legs.&quot;
</pre></div>


<p>如果“ <samp>;;</samp>使用'运算符，在第一个模式匹配之后不尝试后续匹配。使用“ <samp>;&</samp>代替<samp>;;</samp> '使执行继续<var>command-list</var>与下一个子句相关联（如果有）。使用“ <samp>;;&</samp>代替<samp>;;</samp> '使外壳测试下一个子句中的模式（如果有），并执行任何关联的<var>command-list</var>如果匹配成功，则继续执行case语句，就像模式列表不匹配一样。
</p>
<p>如果否，则返回状态为零<var>pattern</var>被匹配。否则，返回状态是商品的退出状态<var>command-list</var>被执行。
</p>
</dd>
<dt><code>select</code></dt>
<dd><a name="index-select"></a>

<p>的<code>select</code>构造允许轻松生成菜单。它的语法与<code>for</code>命令：</p>
<div class="example">
<pre class="example">select <var>name</var> [in <var>words</var> &hellip;]; do <var>commands</var>; done
</pre></div>

<p>以下单词列表<code>in</code>展开，生成项目列表。扩展单词的集合被打印在标准错误输出流上，每个单词前面都有一个数字。如果“ <samp>in <var>words</var></samp>省略'，将打印位置参数，就像' <samp>in "$@"</samp>已指定。的<code>PS3</code>然后显示提示，并从标准输入中读取一行。如果该行由对应于所显示单词之一的数字组成，则<var>name</var>设置为该单词。如果该行为空，则再次显示单词和提示。如果<code>EOF</code>被读取， <code>select</code>命令完成。任何其他读取值的原因<var>name</var>设置为null。读取的行保存在变量中<code>REPLY</code> 。
</p>
<p>的<var>commands</var>在每次选择后执行，直到<code>break</code>命令被执行，此时<code>select</code>命令完成。
</p>
<p>这是一个示例，允许用户从当前目录中选择文件名，并显示所选文件的名称和索引。
</p>
<div class="example">
<pre class="example">select fname in *;
do
	echo you picked $fname \($REPLY\)
	break;
done
</pre></div>

</dd>
<dt><code>((…))</code></dt>
<dd><div class="example">
<pre class="example">(( <var>expression</var> ))
</pre></div>

<p>算术<var>expression</var>根据下面描述的规则进行评估（请参阅<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。如果表达式的值不为零，则返回状态为0；否则，返回值为0。否则返回状态为1。这完全等同于</p><div class="example">
<pre class="example">let &quot;<var>expression</var>&quot;
</pre></div>
<p>有关<a href="#Bash-Builtins">Bash</a>的完整说明，请参见<a href="#Bash-Builtins">Bash Builtins</a> 。 <code>let</code>内置的。
</p>
</dd>
<dt><code>[[…]]</code></dt>
<dd><a name="index-_005b_005b"></a>
<a name="index-_005d_005d"></a>
<div class="example">
<pre class="example">[[ <var>expression</var> ]]
</pre></div>

<p>根据条件表达式的评估返回状态0或1 <var>expression</var> 。表达式由下面的<a href="#Bash-Conditional-Expressions">Bash条件表达式</a>中描述的主键组成。不对单词之间的单词执行分词和文件名扩展<code>[[</code>和<code>]]</code> ;执行波浪号扩展，参数和变量扩展，算术扩展，命令替换，进程替换和引用删除。条件运算符，例如“ <samp>-f</samp> '必须不加引号，才能被识别为主要字符。
</p>
<p>当与<code>[[</code> ， <samp><</samp> '和' <samp>></samp> '运算符使用当前语言环境按字典顺序排序。
</p>
<p>当。。。的时候 ' <samp>==</samp> '和' <samp>!=</samp>如果使用'运算符，则运算符右边的字符串将被视为模式，并根据以下“ <a href="#Pattern-Matching">模式</a>匹配”中所述的规则进行<a href="#Pattern-Matching">匹配</a> ，就像<code>extglob</code> Shell选项已启用。' <samp>=</samp> '运算符等于' <samp>==</samp> '。如果<code>nocasematch</code> shell选项（请参阅<code>shopt</code> <a href="#The-Shopt-Builtin">如果启用了“内置商店”</a> ），则匹配时将不考虑字母字符的大小写。如果字符串匹配（' <samp>==</samp> '）或不匹配（' <samp>!=</samp> '）模式，否则为1。模式的任何部分都可以加引号，以强制将引号部分匹配为字符串。
</p>
<p>另一个二进制运算符，' <samp>=~</samp> '，可用，优先级与' <samp>==</samp> '和' <samp>!=</samp> '。使用它时，运算符右边的字符串被视为<small>POSIX</small>扩展正则表达式，并进行了相应的匹配（如<i>正则表达式</i> 3中所示）。如果字符串与模式匹配，则返回值为0，否则为1。如果正则表达式在语法上不正确，则条件表达式的返回值为2。如果<code>nocasematch</code> shell选项（请参阅<code>shopt</code> <a href="#The-Shopt-Builtin">如果启用了“内置商店”</a> ），则匹配时将不考虑字母字符的大小写。可以引用模式的任何部分以强制将引用的部分作为字符串进行匹配。正则表达式中的括号表达式必须谨慎对待，因为普通的引号字符在括号之间会失去其含义。如果模式存储在shell变量中，则引用变量扩展将强制将整个模式作为字符串进行匹配。正则表达式中与括号内的子表达式匹配的子字符串保存在数组变量中<code>BASH_REMATCH</code> 。的元素<code>BASH_REMATCH</code>索引为0的字符串是与整个正则表达式匹配的部分。的元素<code>BASH_REMATCH</code>带索引<var>n</var>是匹配字符串的部分<var>n</var>括号内的子表达式。
</p>
<p>例如，以下将匹配一行（存储在shell变量中<var>line</var> ），如果值中包含一个字符序列，该序列由任意数量（包括零）的空格字符，零个或一个' <samp>a</samp> '，然后是' <samp>b</samp> '：</p><div class="example">
<pre class="example">[[ $line =~ [[:space:]]*?(a)b ]]
</pre></div>

<p>这意味着像“ <samp>aab</samp> '和' <samp>aaaaaab</samp> '将匹配，包含' <samp>b</samp>的价值。
</p>
<p>将正则表达式存储在shell变量中通常是一种有用的方法，可以避免引用shell特有的字符时出现问题。有时很难在不使用引号的情况下从字面上指定正则表达式，或者在注意外壳程序的引号删除时跟踪正则表达式使用的引号。使用shell变量存储模式可以减少这些问题。例如，以下等同于以上内容：</p><div class="example">
<pre class="example">pattern='[[:space:]]*?(a)b'
[[ $line =~ $pattern ]]
</pre></div>

<p>如果要匹配正则表达式语法的特殊字符，则必须将其引号以删除其特殊含义。这意味着在模式“ <samp>xxx.txt</samp> '，' <samp>.</samp> '匹配字符串中的任何字符（其通常的正则表达式含义），但匹配模式' <samp>"xxx.txt"</samp> '它只能匹配文字' <samp>.</samp> '。Shell程序员应特别注意反斜杠，因为外壳程序和正则表达式都使用反斜杠来删除以下字符的特殊含义。以下两组命令<em>不</em>等效：</p><div class="example">
<pre class="example">pattern='\.'

[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ &quot;$pattern&quot; ]]
[[ . =~ '\.' ]]
</pre></div>

<p>前两个匹配将成功，但是后两个将不成功，因为在后两个中，反斜杠将成为要匹配的模式的一部分。在前两个示例中，反斜杠删除了“ <samp>.</samp> '，因此字面意思为' <samp>.</samp> ' 火柴。如果第一个示例中的字符串不是' <samp>.</samp> '，说' <samp>a</samp> '，该模式将不匹配，因为引号为' <samp>.</samp>模式中的'失去了匹配任何单个字符的特殊含义。
</p>
<p>可以使用以下运算符组合表达式，这些运算符以降序排列：</p>
<dl compact>
<dt><code>( <var>expression</var> )</code></dt>
<dd><p>返回的值<var>expression</var> 。这可用于覆盖运算符的常规优先级。
</p>
</dd>
<dt><code>! <var>expression</var></code></dt>
<dd><p>如果为真<var>expression</var>是错误的。
</p>
</dd>
<dt><code><var>expression1</var> && <var>expression2</var></code></dt>
<dd><p>如果两者都为真<var>expression1</var>和<var>expression2</var>是真的。
</p>
</dd>
<dt><code><var>expression1</var> || <var>expression2</var></code></dt>
<dd><p>如果有则为真<var>expression1</var>要么<var>expression2</var>是真的。
</p></dd>
</dl>

<p>的<code>&&</code>和<code>||</code>运营商不评估<var>expression2</var>如果值<var>expression1</var>足以确定整个条件表达式的返回值。
</p></dd>
</dl>

<hr>
<a name="Command-Grouping"></a>
<div class="header">
<p>上一页： <a href="#Conditional-Constructs" rel="prev" accesskey="p">条件构造</a> ，向上： <a href="#Compound-Commands" rel="up" accesskey="u">复合命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Grouping-Commands"></a>
<h4 class="subsubsection">3.2.4.3分组命令</h4>
<a name="index-commands_002c-grouping"></a>

<p>Bash提供了两种方法来对要作为一个单元执行的命令列表进行分组。将命令分组后，重定向可能会应用于整个命令列表。例如，列表中所有命令的输出可以重定向到单个流。
</p>
<dl compact>
<dt><code>()</code></dt>
<dd><div class="example">
<pre class="example">( <var>list</var> )
</pre></div>

<p>将命令列表放在括号之间会导致创建一个子外壳环境（请参阅“ <a href="#Command-Execution-Environment">命令执行环境”</a> ），并且其中的每个命令<var>list</var>在该子shell中执行。自从<var>list</var>在子Shell中执行时，变量赋值在子Shell完成后不会保持有效。
</p>
</dd>
<dt><code>{}</code></dt>
<dd><a name="index-_007b"></a>
<a name="index-_007d"></a>
<div class="example">
<pre class="example">{ <var>list</var>; }
</pre></div>

<p>在大括号之间放置命令列表会导致该列表在当前Shell上下文中执行。没有创建子外壳。以下的分号（或换行符） <var>list</var>是必须的。
</p></dd>
</dl>

<p>除了创建子外壳之外，由于历史原因，这两种构造之间还存在细微的差异。大括号是<code>reserved words</code> ，因此必须将它们与<var>list</var>通过<code>blank</code>或其他Shell元字符。括号是<code>operators</code> ，即使它们未与<var>list</var>通过空格。
</p>
<p>这两个构造的退出状态均为的退出状态。 <var>list</var> 。
</p>
<hr>
<a name="Coprocesses"></a>
<div class="header">
<p>下一篇： <a href="#GNU-Parallel" rel="next" accesskey="n">GNU Parallel</a> ，上一篇： <a href="#Compound-Commands" rel="prev" accesskey="p">复合命令</a> ，上一篇： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Coprocesses-1"></a>
<h4 class="subsection">3.2.5协同过程</h4>
<a name="index-coprocess"></a>

<p>一种<code>coprocess</code>是一个Shell命令，前面是<code>coproc</code>保留字。协同处理在子Shell中异步执行，就好像命令已经以' <samp>&</samp>控制操作员，在执行外壳和协同处理之间建立了双向管道。
</p>
<p>协同处理的格式为：</p><div class="example">
<pre class="example">coproc [<var>NAME</var>] <var>command</var> [<var>redirections</var>]
</pre></div>

<p>这将创建一个名为<var>NAME</var> 。如果<var>NAME</var>未提供，默认名称是<var>COPROC</var> 。
<var>NAME</var>如果没有提供<var>command</var>是一个简单的命令（请参阅<a href="#Simple-Commands">简单命令</a> ）；否则，它将被解释为简单命令的第一个单词。
</p>
<p>当执行coprocess时，shell创建一个名为的数组变量（请参见<a href="#Arrays">Arrays</a> ）。 <code>NAME</code>在执行外壳程序的上下文中。标准输出<var>command</var>通过管道连接到执行外壳程序中的文件描述符，并且该文件描述符被分配给<code>NAME</code> [0]。标准输入<var>command</var>通过管道连接到执行外壳程序中的文件描述符，并且该文件描述符被分配给<code>NAME</code> [1]。该管道是在命令指定的任何重定向之前建立的（请参阅<a href="#Redirections">Redirections</a> ）。文件描述符可以用作标准命令扩展的shell命令和重定向的参数。除了为执行命令和进程替换而创建的文件描述符之外，文件描述符在子外壳程序中不可用。
</p>
<p>生成用于执行协同处理的shell的进程ID可作为变量的值使用<code>NAME</code> _PID。的<code>wait</code>内置命令可用于等待协同进程终止。
</p>
<p>由于协同处理是作为异步命令创建的，因此<code>coproc</code>命令总是返回成功。协同过程的返回状态是的退出状态<var>command</var> 。
</p>
<hr>
<a name="GNU-Parallel"></a>
<div class="header">
<p>上一页： <a href="#Coprocesses" rel="prev" accesskey="p">协同处理</a> ，向上： <a href="#Shell-Commands" rel="up" accesskey="u">Shell命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Parallel-1"></a>
<h4 class="subsection">3.2.6 GNU并行</h4>

<p>Bash中没有内置并行运行命令的方法。GNU Parallel是用于执行此操作的工具。
</p>
<p>顾名思义，GNU Parallel可用于并行构建和运行命令。您可以使用不同的参数运行同一命令，无论它们是文件名，用户名，主机名还是从文件读取的行。GNU Parallel提供了对许多最常见操作（输入行，输入行的各个部分，指定输入源的不同方式等）的简写引用。平行可替代<code>xargs</code>或从其输入源向多个Bash实例提供命令。
</p>
<p>有关完整的描述，请参考GNU Parallel文档。一些示例应简要介绍其用法。
</p>
<p>例如，很容易更换<code>xargs</code> gzip当前目录及其子目录中的所有html文件：</p><div class="example">
<pre class="example">find . -type f -name '*.html' -print | parallel gzip
</pre></div>
<p>如果您需要保护特殊字符（例如文件名中的换行符），请使用find的<samp>-print0</samp>选项和并行的<samp>-0</samp>选项。
</p>
<p>当文件数量太大而无法用一个文件处理时，可以使用Parallel从当前目录移动文件<code>mv</code>调用：</p><div class="example">
<pre class="example">ls | parallel mv {} destdir
</pre></div>

<p>如您所见，{}被替换为从标准输入读取的每一行。使用时<code>ls</code>可以在大多数情况下使用，但不足以处理所有文件名。如果需要在文件名中包含特殊字符，则可以使用</p>
<div class="example">
<pre class="example">find . -depth 1 \! -name '.*' -print0 | parallel -0 mv {} destdir
</pre></div>

<p>如上所述。
</p>
<p>这将运行尽可能多的<code>mv</code>命令，因为当前目录中有文件。您可以模拟并行<code>xargs</code>通过添加<samp>-X</samp>选项：</p><div class="example">
<pre class="example">find . -depth 1 \! -name '.*' -print0 | parallel -0 -X mv {} destdir
</pre></div>

<p>GNU Parallel可以替换某些从文件读取的行上使用的常见用法（在这种情况下，文件名每行列出一个）：</p><div class="example">
<pre class="example">	while IFS= read -r x; do
		do-something1 &quot;$x&quot; &quot;config-$x&quot;
		do-something2 &lt; &quot;$x&quot;
	done &lt; file | process-output
</pre></div>

<p>具有更紧凑的语法，让人联想到lambdas：</p><div class="example">
<pre class="example">cat list | parallel &quot;do-something1 {} config-{} ; do-something2 &lt; {}&quot; |
           process-output
</pre></div>

<p>Parallel提供了一种内置的机制来删除文件名扩展名，这使其可以进行批处理文件转换或重命名：</p><div class="example">
<pre class="example">ls *.gz | parallel -j+0 &quot;zcat {} | bzip2 &gt;{.}.bz2 &amp;&amp; rm {}&quot;
</pre></div>
<p>这将使用bzip2重新压缩当前目录中所有名称以.gz结尾的文件，每个CPU（-j + 0）并行运行一个作业。（我们用<code>ls</code>为了简洁起见使用<code>find</code>对于包含意外字符的文件名，上述方法更加健壮。）并行可以从命令行获取参数；以上也可以写成</p>
<div class="example">
<pre class="example">parallel &quot;zcat {} | bzip2 &gt;{.}.bz2 &amp;&amp; rm {}&quot; ::: *.gz
</pre></div>

<p>如果命令生成输出，则可能要在输出中保留输入顺序。例如，以下命令</p><div class="example">
<pre class="example">{
    echo foss.org.my ;
    echo debian.org ;
    echo freenetproject.org ;
} | parallel traceroute
</pre></div>
<p>将作为输出显示首先完成的traceroute调用。添加<samp>-k</samp>选项</p><div class="example">
<pre class="example">{
    echo foss.org.my ;
    echo debian.org ;
    echo freenetproject.org ;
} | parallel -k traceroute
</pre></div>
<p>将确保输出<code>traceroute foss.org.my</code>首先显示。
</p>
<p>最后，可以使用Parallel并行运行一系列Shell命令，类似于' <samp>cat file | bash</samp> '。获取文件名列表，创建一系列shell命令以对其进行操作并将命令列表馈送到shell并不少见。并行可以加快速度。假如说<samp>file</samp>包含一列shell命令，每行一个，</p>
<div class="example">
<pre class="example">parallel -j 10 &lt; file
</pre></div>

<p>会使用外壳程序评估命令（因为没有提供任何显式命令作为参数），一次以十个外壳程序作业为块。
</p>
<hr>
<a name="Shell-Functions"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Parameters" rel="next" accesskey="n">Shell参数</a> ，上一篇： <a href="#Shell-Parameters" rel="next" accesskey="n">Shell</a> <a href="#Shell-Commands" rel="prev" accesskey="p">命令</a> ，上一篇： <a href="#Shell-Parameters" rel="next" accesskey="n">Shell</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Functions-1"></a>
<h3 class="section">3.3 Shell功能</h3>
<a name="index-shell-function"></a>
<a name="index-functions_002c-shell"></a>

<p>Shell函数是一种使用单个组名称对命令进行分组以便以后执行的方法。它们像“常规”命令一样执行。当将shell函数的名称用作简单命令名称时，将执行与该函数名称关联的命令列表。Shell函数是在当前Shell上下文中执行的；没有创建新的过程来解释它们。
</p>
<p>使用以下语法声明函数： <a name="index-function"></a>
</p><div class="example">
<pre class="example"><var>name</var> () <var>compound-command</var> [ <var>redirections</var> ]
</pre></div>

<p>要么</p>
<div class="example">
<pre class="example">function <var>name</var> [()] <var>compound-command</var> [ <var>redirections</var> ]
</pre></div>

<p>这定义了一个名为<var>name</var> 。保留字<code>function</code>是可选的。如果<code>function</code>提供保留字，括号是可选的。的<var>body</var>功能的是复合命令<var>compound-command</var> （请参阅“ <a href="#Compound-Commands">复合命令”</a> ）。该命令通常是<var>list</var>括在{和}之间，但可以是上面列出的任何复合命令，但有一个例外：如果<code>function</code>使用保留字，但不提供括号，必须使用花括号。
<var>compound-command</var>每当执行<var>name</var>指定为命令的名称。当外壳处于<small>POSIX</small>模式时（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）， <var>name</var>可能与特殊内置程序之一不同（请参阅<a href="#Special-Builtins">特殊内置程序</a> ）。与shell函数关联的任何重定向（请参阅<a href="#Redirections">Redirections</a> ）都在执行该函数时执行。
</p>
<p>可以使用<samp>-f</samp>选项<code>unset</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ）。
</p>
<p>除非发生语法错误或具有相同名称的只读函数，否则函数定义的退出状态为零。执行时，功能的退出状态是主体中最后执行的命令的退出状态。
</p>
<p>请注意，由于历史原因，在最常见的用法中，包围函数主体的花括号必须通过以下方式与主体分开： <code>blank</code> s或换行符。这是因为括号是保留字，并且仅当它们由空格或另一个shell元字符与命令列表分隔时，才被识别为保留字。另外，当使用大括号时， <var>list</var>必须以分号（“ <samp>&</samp> ”或换行符。
</p>
<p>执行某个函数时，该函数的参数将在执行过程中变为位置参数（请参见<a href="#Positional-Parameters">Positional Parameters</a> ）。特殊参数“ <samp>#</samp>扩展到位置参数数量的'被更新以反映更改。特殊参数<code>0</code>不变。第一个要素<code>FUNCNAME</code>在函数执行期间，变量被设置为函数的名称。
</p>
<p>Shell执行环境的所有其他方面在函数及其调用者之间是相同的，但以下情况除外： <code>DEBUG</code>和<code>RETURN</code>除非函数已被赋予陷阱，否则不会继承陷阱<code>trace</code>属性使用<code>declare</code>内置或<code>-o functrace</code>选项已通过<code>set</code>内置（在这种情况下，所有函数都继承<code>DEBUG</code>和<code>RETURN</code>陷阱），以及<code>ERR</code>陷阱不会被继承，除非<code>-o errtrace</code> shell选项已启用。请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ，获取有关<code>trap</code>内置的。
</p>
<p>的<code>FUNCNEST</code>如果将变量设置为大于0的数值，则定义最大函数嵌套级别。超出限制的函数调用会导致整个命令中止。
</p>
<p>如果内置命令<code>return</code>在函数中执行，函数完成并在函数调用后从下一个命令恢复执行。与<code>RETURN</code>陷阱在执行恢复之前执行。函数完成后，位置参数和特殊参数' <samp>#</samp> '将恢复为执行函数之前的值。如果给定一个数字参数<code>return</code> ，即函数的返回状态；否则，函数的返回状态是在执行之前最后执行的命令的退出状态<code>return</code> 。
</p>
<p>函数局部变量可以用<code>local</code>内置的。这些变量仅对函数及其调用的命令可见。当外壳函数调用其他函数时，这尤其重要。
</p>
<p>与先前作用域声明的名称相同的局部变量“影子”变量。例如，在函数中声明的局部变量隐藏了同名的全局变量：引用和赋值引用了局部变量，而使全局变量保持不变。当函数返回时，全局变量再次可见。
</p>
<p>外壳用途<var>dynamic scoping</var>在函数中控制变量的可见性。通过动态作用域，可见变量及其值是函数调用序列的结果，这些调用导致执行到达当前函数。函数所看到的变量的值取决于其调用方中的值（如果有），无论该调用方是“全局”作用域还是另一个Shell函数。这也是局部变量声明“阴影”的值，以及函数返回时恢复的值。
</p>
<p>例如，如果一个变量<var>var</var>在函数中声明为局部<var>func1</var>和<var>func1</var>调用另一个函数<var>func2</var> ，对<var>var</var>由内部制成<var>func2</var>将解析为局部变量<var>var</var>从<var>func1</var> ，遮盖了任何名为<var>var</var> 。
</p>
<p>下面的脚本演示了此行为。执行后，脚本显示</p>
<div class="example">
<pre class="example">In func2, var = func1 local
</pre></div>

<div class="example">
<pre class="example">func1()
{
    local var='func1 local'
    func2
}

func2()
{
    echo &quot;In func2, var = $var&quot;
}

var=global
func1
</pre></div>

<p>的<code>unset</code>内建函数也使用相同的动态范围进行操作：如果变量在当前范围内是局部的， <code>unset</code>将其取消；否则，未设置将引用如上所述在任何调用范围中找到的变量。如果未设置当前本地作用域中的变量，则该变量将保持不变，直到在该作用域中将其重置或函数返回为止。该函数返回后，该变量在先前作用域的任何实例将变为可见。如果unset作用于先前作用域中的变量，则具有该名称的已被阴影遮盖的变量的任何实例都将变为可见。
</p>
<p>函数名称和定义可能与<samp>-f</samp>选项<code>declare</code> （ <code>typeset</code> ）内建命令（请参阅<a href="#Bash-Builtins">Bash</a>内建）。的<samp>-F</samp>选择<code>declare</code>要么<code>typeset</code>将仅列出函数名称（如果可能，则列出源文件和行号） <code>extdebug</code> shell选项已启用）。可以导出函数，以便子外壳自动使用<samp>-f</samp>选项<code>export</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ）。
</p>
<p>函数可能是递归的。的<code>FUNCNEST</code>变量可用于限制函数调用堆栈的深度并限制函数调用的次数。默认情况下，递归调用数没有限制。
</p>
<hr>
<a name="Shell-Parameters"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Expansions" rel="next" accesskey="n">Shell扩展</a> ，上一篇： <a href="#Shell-Expansions" rel="next" accesskey="n">Shell</a> <a href="#Shell-Functions" rel="prev" accesskey="p">函数</a> ，上一篇： <a href="#Shell-Expansions" rel="next" accesskey="n">Shell</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Parameters-1"></a>
<h3 class="section">3.4外壳参数</h3>
<a name="index-parameters"></a>
<a name="index-variable_002c-shell"></a>
<a name="index-shell-variable"></a>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Positional-Parameters" accesskey="1">位置参数</a> ：</td><td>  </td><td align="left" valign="top">Shell的命令行参数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Parameters" accesskey="2">特殊参数</a> ：</td><td>  </td><td align="left" valign="top">用特殊字符表示的参数。
</td></tr>
</tbody></table>

<p>一种<var>parameter</var>是存储值的实体。可以是<code>name</code> ，数字或下面列出的特殊字符之一。一种<var>variable</var>是由a表示的参数<code>name</code> 。变量有一个<var>value</var>零个或多个<var>attributes</var> 。使用<code>declare</code>内置命令（请参阅<code>declare</code>在<a href="#Bash-Builtins">Bash Builtins中内置</a> ）。
</p>
<p>如果已为参数分配了值，则设置该参数。空字符串是有效值。设置变量后，只能通过使用<code>unset</code>内置命令。
</p>
<p>变量可以通过以下形式的语句分配给</p><div class="example">
<pre class="example"><var>name</var>=[<var>value</var>]
</pre></div>
<p>如果<var>value</var>未给出，则为变量分配空字符串。所有<var>value</var>进行波浪号扩展，参数和变量扩展，命令替换，算术扩展和引号删除（详细信息如下）。如果变量具有其<code>integer</code>属性集，然后<var>value</var>被计算为算术表达式，即使<code>$((…))</code>不使用<a href="#Arithmetic-Expansion">扩展</a> （请参阅<a href="#Arithmetic-Expansion">算术扩展</a> ）。不执行分词，但以下情况除外<code>"$@"</code>如下所述。不执行文件名扩展。赋值语句也可能显示为<code>alias</code> ， <code>declare</code> ， <code>typeset</code> ， <code>export</code> ， <code>readonly</code>和<code>local</code>内置命令<var>declaration</var>命令）。在<small>POSIX</small>模式下（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ），这些内置<a href="#Bash-POSIX-Mode">函数</a>可能会在命令的一个或多个实例之后出现在命令中。 <code>command</code>内置并保留这些赋值语句属性。
</p>
<p>在赋值语句为外壳变量或数组索引赋值的情况下（请参见<a href="#Arrays">Arrays</a> ），“ <samp>+=</samp> '运算符可用于附加或添加到变量的先前值。这包括内置命令的参数，例如<code>declare</code>接受赋值语句（ <var>declaration</var>命令）。什么时候 ' <samp>+=</samp> '应用于变量<var>integer</var>属性已设置， <var>value</var>被作为算术表达式求值，并添加到变量的当前值中，该值也被求值。什么时候 ' <samp>+=</samp> '使用复合赋值应用于数组变量（请参见<a href="#Arrays">Arrays</a> ），该变量的值不会未设置（如使用' <samp>=</samp> '），并且新值将从数组的最大索引（对于索引数组）开始，比数组的最大索引大一个，或者作为关联数组中的其他键值对添加。当应用于字符串值的变量时， <var>value</var>展开并附加到变量的值。
</p>
<p>可以为变量分配<var>nameref</var>属性使用<samp>-n</samp>选项<code>declare</code>要么<code>local</code>内置命令（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）来创建一个<var>nameref</var> ，或对另一个变量的引用。这允许变量被间接操纵。每当对nameref变量进行引用，分配，设置或修改其属性时（除了使用或更改nameref属性本身之外），实际上都会对nameref变量的值所指定的变量执行操作。在外壳函数中，通常使用nameref来引用变量，变量的名称作为参数传递给该函数。例如，如果将变量名作为第一个参数传递给shell函数，则运行</p><div class="example">
<pre class="example">declare -n ref=$1
</pre></div>
<p>在函数内部创建一个nameref变量<var>ref</var>其值是作为第一个参数传递的变量名称。参考和分配<var>ref</var> ，以及对其属性的更改，将视为对其名称传递为的变量的引用，赋值和属性修改<code>$1</code> 。
</p>
<p>如果控制变量在<code>for</code>循环具有nameref属性，单词列表可以是shell变量列表，并且在执行循环时，将依次为列表中的每个单词建立名称引用。数组变量不能被赋予nameref属性。但是，nameref变量可以引用数组变量和下标数组变量。可以使用<samp>-n</samp>选项<code>unset</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ）。否则，如果<code>unset</code>如果以nameref变量的名称作为参数执行，则nameref变量引用的变量将不会设置。
</p>
<hr>
<a name="Positional-Parameters"></a>
<div class="header">
<p>下一页： <a href="#Special-Parameters" rel="next" accesskey="n">特殊参数</a> ，向上： <a href="#Shell-Parameters" rel="up" accesskey="u">Shell参数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Positional-Parameters-1"></a>
<h4 class="subsection">3.4.1位置参数</h4>
<a name="index-parameters_002c-positional"></a>

<p>一种<var>positional parameter</var>是用一位或多位数字表示的参数，而不是一位数字<code>0</code> 。位置参数是在调用shell时从shell的参数中分配的，可以使用<code>set</code>内置命令。位置参数<code>N</code>可以称为<code>${N}</code> ，或<code>$N</code>什么时候<code>N</code>由一位数字组成。位置参数不能与赋值语句一起赋值。的<code>set</code>和<code>shift</code> Builtins用于设置和取消设置它们（请参见<a href="#Shell-Builtin-Commands">Shell Builtin Commands</a> ）。当执行<a href="#Shell-Functions">Shell函数</a>时，位置参数将被临时替换（请参见<a href="#Shell-Functions">Shell Functions</a> ）。
</p>
<p>扩展包含多个数字的位置参数时，必须将其括在大括号中。
</p>
<hr>
<a name="Special-Parameters"></a>
<div class="header">
<p>上一页： <a href="#Positional-Parameters" rel="prev" accesskey="p">位置参数</a> ，向上： <a href="#Shell-Parameters" rel="up" accesskey="u">壳参数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Special-Parameters-1"></a>
<h4 class="subsection">3.4.2特殊参数</h4>
<a name="index-parameters_002c-special"></a>

<p>外壳专门处理几个参数。这些参数只能被引用；不允许分配给他们。
</p>
<dl compact>
<dt><code>*</code>
<a name="index-_002a"></a>
</dt>
<dd><a name="index-_0024_002a"></a>
<p>（$ *）从一个开始扩展到位置参数。当扩展不在双引号内时，每个位置参数都扩展为单独的单词。在执行该操作的上下文中，这些单词会受到进一步的单词拆分和路径名扩展的影响。当扩展出现在双引号内时，它将扩展为一个单词，每个参数的值由逗号的第一个字符分隔<code>IFS</code>特殊变量。那是， <code>"$*"</code>相当于<code>"$1<var>c</var>$2<var>c</var>…"</code> ，在哪里<var>c</var>是值的第一个字符<code>IFS</code>变量。如果<code>IFS</code>未设置，参数用空格分隔。如果<code>IFS</code>为null，将在不插入分隔符的情况下连接参数。
</p>
</dd>
<dt><code>@</code>
<a name="index-_0040"></a>
</dt>
<dd><a name="index-_0024_0040"></a>
<p>（$ @）从一个开始扩展到位置参数。在执行单词拆分的情况下，这会将每个位置参数扩展为一个单独的单词；如果不在双引号中，则这些单词会被拆分。在不执行单词拆分的情况下，此扩展为单个单词，每个位置参数之间用空格分隔。当在双引号内进行扩展并执行单词拆分时，每个参数都会扩展为单独的单词。那是， <code>"$@"</code>相当于<code>"$1" "$2" …</code> 。如果双引号扩展出现在单词内，则第一个参数的扩展与原始单词的开头部分合并，而最后一个参数的扩展与原始单词的末尾部分连接。如果没有位置参数， <code>"$@"</code>和<code>$@</code>扩展为空（即将其删除）。
</p>
</dd>
<dt><code>#</code>
<a name="index-_0023"></a>
</dt>
<dd><a name="index-_0024_0023"></a>
<p>（$＃）扩展为十进制的位置参数数。
</p>
</dd>
<dt><code>?</code>
<a name="index-_003f"></a>
</dt>
<dd><a name="index-_0024_003f"></a>
<p>（$？）扩展到最近执行的前台管道的退出状态。
</p>
</dd>
<dt><code>-</code>
<a name="index-_002d"></a>
</dt>
<dd><a name="index-_0024_002d"></a>
<p>（$-，连字符。）扩展为调用时指定的当前选项标志，由<code>set</code>内置命令，或由外壳程序本身设置的命令（例如<samp>-i</samp>选项）。
</p>
</dd>
<dt><code>$</code>
<a name="index-_0024"></a>
</dt>
<dd><a name="index-_0024_0024"></a>
<p>（$$）扩展到外壳的进程<small>ID</small> 。在一个<code>()</code>子外壳程序，它将扩展为调用外壳程序的进程<small>ID</small> ，而不是子外壳程序。
</p>
</dd>
<dt><code>!</code>
<a name="index-_0021-1"></a>
</dt>
<dd><a name="index-_0024_0021"></a>
<p>（$！）扩展为最近放置到后台的作业的进程<small>ID</small> ，无论是作为异步命令执行还是使用<code>bg</code>内置（请参见<a href="#Job-Control-Builtins">Job Control内置</a> ）。
</p>
</dd>
<dt><code>0</code>
<a name="index-0"></a>
</dt>
<dd><a name="index-_00240"></a>
<p>（$ 0）扩展为shell或shell脚本的名称。这是在外壳初始化时设置的。如果使用命令文件调用Bash（请参见<a href="#Shell-Scripts">Shell脚本</a> ）， <code>$0</code>设置为该文件的名称。如果Bash以<samp>-c</samp>选项（请参阅“ <a href="#Invoking-Bash">调用Bash”</a> ），然后<code>$0</code>如果存在，则将其设置为要执行的字符串之后的第一个参数。否则，将其设置为用于调用Bash的文件名，如参数0所示。
</p>
</dd>
<dt><code>_</code>
<a name="index-_005f"></a>
</dt>
<dd><a name="index-_0024_005f"></a>
<p>（$ _，下划线。）在shell启动时，设置为用于调用环境或参数列表中传递的正在执行的shell或shell脚本的绝对路径名。随后，扩展后，将扩展为在前台执行的上一个简单命令的最后一个参数。还设置为用于调用每个执行的命令的完整路径名，并将其放置在导出到该命令的环境中。检查邮件时，此参数保存邮件文件的名称。
</p></dd>
</dl>

<hr>
<a name="Shell-Expansions"></a>
<div class="header">
<p>下一篇： <a href="#Redirections" rel="next" accesskey="n">重定向</a> ，上一篇： <a href="#Shell-Parameters" rel="prev" accesskey="p">Shell参数</a> ，上一篇： <a href="#Shell-Parameters" rel="prev" accesskey="p">Shell的</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Expansions-1"></a>
<h3 class="section">3.5外壳扩展</h3>
<a name="index-expansion"></a>

<p>拆分为命令行后，在命令行上执行扩展<code>token</code> s。进行了七种扩展：</p>
<ul>
<li>大括号扩展</li><li>波浪线扩展</li><li>参数和变量展开</li><li>命令替换</li><li>算术展开</li><li>分词</li><li>文件名扩展</li></ul>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Brace-Expansion" accesskey="1">括号扩展</a> ：</td><td>  </td><td align="left" valign="top">括号内的表达式扩展。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Tilde-Expansion" accesskey="2">波浪扩展</a> ：</td><td>  </td><td align="left" valign="top">扩展〜字符。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Parameter-Expansion" accesskey="3">Shell参数扩展</a> ：</td><td>  </td><td align="left" valign="top">Bash如何将变量扩展为它们的值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Substitution" accesskey="4">命令替换</a> ：</td><td>  </td><td align="left" valign="top">使用命令的输出作为参数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Arithmetic-Expansion" accesskey="5">算术扩展</a> ：</td><td>  </td><td align="left" valign="top">如何在Shell扩展中使用算术。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Process-Substitution" accesskey="6">流程替代</a> ：</td><td>  </td><td align="left" valign="top">一种在命令之间读写的方式。
</td></tr>
<tr><td align="left" valign="top">•分<a href="#Word-Splitting" accesskey="7">词</a> ：</td><td>  </td><td align="left" valign="top">扩展结果如何拆分为单独的参数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Filename-Expansion" accesskey="8">文件名扩展</a> ：</td><td>  </td><td align="left" valign="top">指定文件名匹配模式的简写。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Quote-Removal" accesskey="9">删除报价</a> ：</td><td>  </td><td align="left" valign="top">如何以及何时从单词中删除引号字符。
</td></tr>
</tbody></table>

<p>扩展顺序为：大括号扩展；波浪号扩展，参数和变量扩展，算术扩展和命令替换（以从左到右的方式完成）；分词和文件名扩展。
</p>
<p>在可以支持它的系统上，还有一个附加扩展： <var>process substitution</var> 。这与代字号，参数，变量以及算术扩展和命令替换同时执行。
</p>
<p>执行完这些扩展后，原始单词中存在的引号字符将被删除，除非它们本身已被引号（ <var>quote removal</var> ）。
</p>
<p>只有大括号扩展，单词拆分和文件名扩展可以增加扩展的单词数；其他扩展将单个单词扩展为单个单词。唯一的例外是的扩展<code>"$@"</code>和<code>$*</code> （请参阅<a href="#Special-Parameters">特殊参数</a> ），以及<code>"${<var>name</var>[@]}"</code>和<code>${<var>name</var>[*]}</code> （请参见<a href="#Arrays">Arrays</a> ）。
</p>
<p>经过全部扩展<code>quote removal</code> （请参阅<a href="#Quote-Removal">去除报价</a> ）。
</p>
<hr>
<a name="Brace-Expansion"></a>
<div class="header">
<p>下一页： <a href="#Tilde-Expansion" rel="next" accesskey="n">提尔德扩展</a> ，上： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Brace-Expansion-1"></a>
<h4 class="subsection">3.5.1括号扩展</h4>
<a name="index-brace-expansion"></a>
<a name="index-expansion_002c-brace"></a>

<p>括号扩展是一种可以生成任意字符串的机制。该机制类似于<var>filename expansion</var> （请参阅<a href="#Filename-Expansion">文件名扩展</a> ），但是生成的文件名不必存在。大括号扩展的模式采用可选形式<var>preamble</var> ，然后是一系列逗号分隔的字符串或一对大括号之间的序列表达式，然后是可选<var>postscript</var> 。前缀在花括号中包含的每个字符串之前加上前缀，然后将后记附加到每个结果字符串之后，从左向右扩展。
</p>
<p>括号扩展名可能会嵌套。每个扩展字符串的结果均未排序；保留从左到右的顺序。例如，</p><div class="example">
<pre class="example">bash$ echo a{d,c,b}e
ade ace abe
</pre></div>

<p>序列表达式采用以下形式<code>{<var>x</var>..<var>y</var>[..<var>incr</var>]}</code> ，在哪里<var>x</var>和<var>y</var>是整数或单个字符，并且<var>incr</var> （可选的增量）是整数。提供整数时，表达式将扩展为<var>x</var>和<var>y</var> ， 包括的。提供的整数可以以' <samp>0</samp> '强制每个术语具有相同的宽度。什么时候<var>x</var>要么<var>y</var>从零开始，shell会尝试强制所有生成的术语包含相同数量的数字，并在必要时进行零填充。提供字符后，表达式将按字典顺序扩展到每个字符之间<var>x</var>和<var>y</var> ，包括使用默认C语言环境。请注意， <var>x</var>和<var>y</var>必须是同一类型。提供增量时，将其用作每个项之间的差。默认增量为1或-1（视情况而定）。
</p>
<p>括号扩展在任何其他扩展之前执行，并且其他扩展专用的任何字符都保留在结果中。严格来说是文字。Bash对扩展的上下文或大括号之间的文本不应用任何语法解释。
</p>
<p>格式正确的括号扩展必须包含不带引号的左括号和右括号，以及至少一个不带引号的逗号或有效的序列表达式。任何形式不正确的支架扩张均保持不变。
</p>
<p>一个{或' <samp>,</samp> '可能会加上反斜杠，以防止其被视为大括号表达式的一部分。为避免与参数扩展冲突，字符串' <samp>${</samp> '不被视为具有大括号扩展的条件，并在大括号关闭之前禁止大括号扩展' <samp>}</samp> '。
</p>
<p>当要生成的字符串的公共前缀比上面的示例长时，通常将此构造用作速记：</p><div class="example">
<pre class="example">mkdir /usr/local/src/bash/{old,new,dist,bugs}
</pre></div>
<p>要么</p><div class="example">
<pre class="example">chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
</pre></div>

<hr>
<a name="Tilde-Expansion"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Parameter-Expansion" rel="next" accesskey="n">Shell参数扩展</a> ，上一篇： <a href="#Brace-Expansion" rel="prev" accesskey="p">括号扩展</a> ，上一篇： <a href="#Shell-Parameter-Expansion" rel="next" accesskey="n">Shell</a> <a href="#Shell-Expansions" rel="up" accesskey="u">扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tilde-Expansion-1"></a>
<h4 class="subsection">3.5.2波浪扩展</h4>
<a name="index-tilde-expansion"></a>
<a name="index-expansion_002c-tilde"></a>

<p>如果单词以无引号的波浪号字符开头（ <samp>~</samp> '），直到第一个未加引号的斜杠（或所有字符，如果没有未加引号的斜杠）之前的所有字符都被视为<var>tilde-prefix</var> 。如果没有使用波浪号前缀的字符，那么在波浪号后的波浪号前缀中的字符将被视为可能<var>login name</var> 。如果此登录名是空字符串，则波浪号将替换为<code>HOME</code>外壳变量。如果<code>HOME</code>未设置，则替换执行shell的用户的主目录。否则，将波浪号前缀替换为与指定登录名关联的主目录。
</p>
<p>如果波浪号前缀为' <samp>~+</samp> '，shell变量的值<code>PWD</code>替换波浪号前缀。如果波浪号前缀为' <samp>~-</samp> '，shell变量的值<code>OLDPWD</code> （如果已设置）被替换。
</p>
<p>如果波浪号前缀中波浪号后的字符由数字组成<var>N</var> ，可选地以'为前缀<samp>+</samp> '或' <samp>-</samp> '，将波浪号前缀替换为目录堆栈中的相应元素，因为它将由<code>dirs</code>用tilde-prefix中tilde后面的字符作为参数调用的Builtin（请参阅<a href="#The-Directory-Stack">目录堆栈</a> ）。如果波浪号前缀（不带波浪号）由不带前导'的数字组成<samp>+</samp> ' 要么 ' <samp>-</samp> '，' <samp>+</samp> ' 假设。
</p>
<p>如果登录名无效，或者代字号扩展失败，则该词保持不变。
</p>
<p>紧接在'之后，将检查每个变量赋值是否存在未引号的代字号前缀。 <samp>:</samp> '或第一个' <samp>=</samp> '。在这些情况下，还将执行波浪号扩展。因此，在分配给<code>PATH</code> ， <code>MAILPATH</code>和<code>CDPATH</code> ，然后外壳程序分配扩展值。
</p>
<p>下表显示了Bash如何处理未加引号的波浪号前缀：</p>
<dl compact>
<dt><code>~</code></dt>
<dd><p>的价值<code>$HOME</code>
</p></dd>
<dt><code>~/foo</code></dt>
<dd><p><samp>$HOME/foo</samp>
</p>
</dd>
<dt><code>~fred/foo</code></dt>
<dd><p>子目录<code>foo</code>用户主目录的<code>fred</code>
</p>
</dd>
<dt><code>~+/foo</code></dt>
<dd><p><samp>$PWD/foo</samp>
</p>
</dd>
<dt><code>~-/foo</code></dt>
<dd><p><samp>${OLDPWD-'~-'}/foo</samp>
</p>
</dd>
<dt><code>~<var>N</var></code></dt>
<dd><p>将由'显示的字符串<samp>dirs +<var>N</var></samp> '</p>
</dd>
<dt><code>~+<var>N</var></code></dt>
<dd><p>将由'显示的字符串<samp>dirs +<var>N</var></samp> '</p>
</dd>
<dt><code>~-<var>N</var></code></dt>
<dd><p>将由'显示的字符串<samp>dirs -<var>N</var></samp> '</p></dd>
</dl>

<p>当满足变量赋值条件的单词（作为<a href="#Shell-Parameters">Shell参数</a> ）作为简单命令的参数出现时，Bash还会对它们进行波浪号扩展。Bash不会这样做，除了<var>declaration</var>在<small>POSIX</small>模式下，上面列出的命令。
</p>
<hr>
<a name="Shell-Parameter-Expansion"></a>
<div class="header">
<p>下一篇： <a href="#Command-Substitution" rel="next" accesskey="n">命令替代</a> ，上一篇： <a href="#Tilde-Expansion" rel="prev" accesskey="p">波浪扩展</a> ，上一篇： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Parameter-Expansion-1"></a>
<h4 class="subsection">3.5.3 Shell参数扩展</h4>
<a name="index-parameter-expansion"></a>
<a name="index-expansion_002c-parameter"></a>

<p>' <samp>$</samp>字符会引入参数扩展，命令替换或算术扩展。可以将要扩展的参数名称或符号括在括号中，该括号是可选的，但用于保护要扩展的变量不受紧随其后的字符的影响，这些字符可以解释为名称的一部分。
</p>
<p>使用花括号时，匹配的结尾花括号是第一个' <samp>}</samp> '不能由反斜杠或带引号的字符串进行转义，也不能在嵌入式算术扩展，命令替换或参数扩展中进行转义。
</p>
<p>参数扩展的基本形式是$ { <var>parameter</var> }。的价值<var>parameter</var>被取代。的<var>parameter</var>是如上所述的shell参数（请参见<a href="#Shell-Parameters">Shell Parameters</a> ）或数组引用（请参见<a href="#Arrays">Arrays</a> ）。在以下情况下需要大括号<var>parameter</var>是具有多个数字的位置参数，或者<var>parameter</var>后跟一个字符，该字符不应被解释为其名称的一部分。
</p>
<p>如果第一个字符<var>parameter</var>是一个感叹号（！），并且<var>parameter</var>不是一个<var>nameref</var> ，它引入了一个间接级别。Bash使用通过扩展其余部分形成的价值<var>parameter</var>作为新的<var>parameter</var> ;然后对其进行扩展，并在其余扩展中使用该值，而不是原始扩展<var>parameter</var> 。这被称为<code>indirect expansion</code> 。该值可进行波浪号扩展，参数扩展，命令替换和算术扩展。如果<var>parameter</var>是一个nameref，它将扩展为由引用的变量的名称<var>parameter</var>而不是执行完整的间接扩展。$ {的扩展名除外！<var>prefix</var> *}和$ {！ <var>name</var> [@]} 如下面所描述的。感叹号必须紧随左括号之后才能引入间接指示。
</p>
<p>在以下每种情况下， <var>word</var>受波浪号，参数扩展，命令替换和算术扩展的影响。
</p>
<p>当不执行子字符串扩展时，请使用下面描述的形式（例如，“ <samp>:-</samp> '），Bash将测试未设置或为null的参数。省略冒号只会对未设置的参数进行测试。换句话说，如果包含冒号，则操作员会同时测试两个<var>parameter</var>的存在，并且其值不为null；如果省略了冒号，则运算符仅测试是否存在。
</p>
<dl compact>
<dt><code>${<var>parameter</var>:-<var>word</var>}</code></dt>
<dd><p>如果<var>parameter</var>未设置或为null，则展开<var>word</var>被取代。否则，值<var>parameter</var>被取代。
</p>
</dd>
<dt><code>${<var>parameter</var>:=<var>word</var>}</code></dt>
<dd><p>如果<var>parameter</var>未设置或为null，则展开<var>word</var>被分配给<var>parameter</var> 。的价值<var>parameter</var>然后被替换。不能以此方式分配位置参数和特殊参数。
</p>
</dd>
<dt><code>${<var>parameter</var>:?<var>word</var>}</code></dt>
<dd><p>如果<var>parameter</var>为null或未设置，则扩展<var>word</var> （或在此情况下发出的信息， <var>word</var>不存在）写入标准错误，并且外壳程序（如果不是交互式的）退出。否则，值<var>parameter</var>被取代。
</p>
</dd>
<dt><code>${<var>parameter</var>:+<var>word</var>}</code></dt>
<dd><p>如果<var>parameter</var>为null或未设置，则不替换任何内容，否则扩展<var>word</var>被取代。
</p>
</dd>
<dt><code>${<var>parameter</var>:<var>offset</var>}</code></dt>
<dt><code>${<var>parameter</var>:<var>offset</var>:<var>length</var>}</code></dt>
<dd><p>这称为子字符串扩展。最多可扩展到<var>length</var>价值的字符<var>parameter</var>从指定的字符开始<var>offset</var> 。如果<var>parameter</var>是' <samp>@</samp> '，下标为' <samp>@</samp> ' 要么 ' <samp>*</samp>或关联数组名称，结果将有所不同，如下所述。如果<var>length</var>省略，它将扩展为的值的子字符串<var>parameter</var>从指定的字符开始<var>offset</var>并扩展到值的末尾。
<var>length</var>和<var>offset</var>是算术表达式（请参见<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。
</p>
<p>如果<var>offset</var>计算结果为小于零的数字，该值用作相对于的值末尾的字符偏移量<var>parameter</var> 。如果<var>length</var>计算结果为小于零的数字，将其解释为相对于值的末尾的字符偏移量<var>parameter</var>而不是多个字符，而扩展是<var>offset</var>结果。请注意，负偏移必须与冒号隔开至少一个空格，以免与' <samp>:-</samp>扩展。
</p>
<p>以下示例说明了参数和下标数组上的子字符串扩展：</p>
<pre class="verbatim">$ string=01234567890abcdefgh
$ echo ${string:7}
7890abcdefgh
$ echo ${string:7:0}

$ echo ${string:7:2}
78
$ echo ${string:7:-2}
7890abcdef
$ echo ${string: -7}
bcdefgh
$ echo ${string: -7:0}

$ echo ${string: -7:2}
bc
$ echo ${string: -7:-2}
bcdef
$ set -- 01234567890abcdefgh
$ echo ${1:7}
7890abcdefgh
$ echo ${1:7:0}

$ echo ${1:7:2}
78
$ echo ${1:7:-2}
7890abcdef
$ echo ${1: -7}
bcdefgh
$ echo ${1: -7:0}

$ echo ${1: -7:2}
bc
$ echo ${1: -7:-2}
bcdef
$ array[0]=01234567890abcdefgh
$ echo ${array[0]:7}
7890abcdefgh
$ echo ${array[0]:7:0}

$ echo ${array[0]:7:2}
78
$ echo ${array[0]:7:-2}
7890abcdef
$ echo ${array[0]: -7}
bcdefgh
$ echo ${array[0]: -7:0}

$ echo ${array[0]: -7:2}
bc
$ echo ${array[0]: -7:-2}
bcdef
</pre>
<p>如果<var>parameter</var>是' <samp>@</samp> '，结果是<var>length</var>位置参数始于<var>offset</var> 。负面的<var>offset</var>相对于比最大位置参数大的一个参数取，因此偏移-1表示最后一个位置参数。如果是扩展错误<var>length</var>得出小于零的数字。
</p>
<p>以下示例说明了使用位置参数进行子字符串扩展：</p>
<pre class="verbatim">$ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${@:7}
7 8 9 0 a b c d e f g h
$ echo ${@:7:0}

$ echo ${@:7:2}
7 8
$ echo ${@:7:-2}
bash: -2: substring expression &lt; 0
$ echo ${@: -7:2}
b c
$ echo ${@:0}
./bash 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${@:0:2}
./bash 1
$ echo ${@: -7:0}

</pre>
<p>如果<var>parameter</var>是下标为'的索引数组名称<samp>@</samp> ' 要么 ' <samp>*</samp> '，结果是<var>length</var>以数组开头的成员<code>${<var>parameter</var>[<var>offset</var>]}</code> 。负面的<var>offset</var>相对于大于指定数组的最大索引的整数取。如果是扩展错误<var>length</var>得出小于零的数字。
</p>
<p>这些示例说明如何在索引数组中使用子字符串扩展：</p>
<pre class="verbatim">$ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)
$ echo ${array[@]:7}
7 8 9 0 a b c d e f g h
$ echo ${array[@]:7:2}
7 8
$ echo ${array[@]: -7:2}
b c
$ echo ${array[@]: -7:-2}
bash: -2: substring expression &lt; 0
$ echo ${array[@]:0}
0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${array[@]:0:2}
0 1
$ echo ${array[@]: -7:0}

</pre>
<p>子字符串扩展应用于关联数组会产生不确定的结果。
</p>
<p>除非使用位置参数，否则子字符串索引从零开始，在这种情况下，索引默认从1开始。如果<var>offset</var>是0，并且使用了位置参数， <code>$@</code>是列表的前缀。
</p>
</dd>
<dt><code>${!<var>prefix</var>*}</code></dt>
<dt><code>${!<var>prefix</var>@}</code></dt>
<dd><p>扩展为名称以开头的变量的名称<var>prefix</var> ，以第一个字符分隔<code>IFS</code>特殊变量。什么时候 ' <samp>@</samp>使用'，并且扩展名出现在双引号中，每个变量名扩展为一个单独的单词。
</p>
</dd>
<dt><code>${!<var>name</var>[@]}</code></dt>
<dt><code>${!<var>name</var>[*]}</code></dt>
<dd><p>如果<var>name</var>是一个数组变量，扩展到在中分配的数组索引（键）列表<var>name</var> 。如果<var>name</var>不是数组，如果扩展为0 <var>name</var>设置，否则为null。什么时候 ' <samp>@</samp>使用'，并且扩展名出现在双引号中，每个键扩展为一个单独的单词。
</p>
</dd>
<dt><code>${#<var>parameter</var>}</code></dt>
<dd><p>的扩展值的字符长度<var>parameter</var>被取代。如果<var>parameter</var>是' <samp>*</samp> ' 要么 ' <samp>@</samp> '，则替换的值为位置参数的数量。如果<var>parameter</var>是下标为'的数组名称<samp>*</samp> ' 要么 ' <samp>@</samp> '，则替换的值为数组中元素的数量。如果<var>parameter</var>是一个索引数组名称，下标一个负数，该数字被解释为相对于大于最大索引的一个<var>parameter</var> ，因此负索引从数组末尾算起，索引-1引用最后一个元素。
</p>
</dd>
<dt><code>${<var>parameter</var>#<var>word</var>}</code></dt>
<dt><code>${<var>parameter</var>##<var>word</var>}</code></dt>
<dd><p>的<var>word</var>展开以生成模式，并根据以下描述的规则进行<a href="#Pattern-Matching">匹配</a> （请参见<a href="#Pattern-Matching">模式匹配</a> ）。如果模式与的扩展值的开头匹配<var>parameter</var> ，则扩展的结果是的扩展值<var>parameter</var>匹配模式最短（“ <samp>#</samp> '大小写）或最长的匹配模式（' <samp>##</samp> '案例）删除。如果<var>parameter</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp>然后，将模式删除操作依次应用于每个位置参数，并且扩展是结果列表。如果<var>parameter</var>是下标为'的数组变量<samp>@</samp> ' 要么 ' <samp>*</samp>然后，将模式删除操作依次应用于数组的每个成员，并且扩展是结果列表。
</p>
</dd>
<dt><code>${<var>parameter</var>%<var>word</var>}</code></dt>
<dt><code>${<var>parameter</var>%%<var>word</var>}</code></dt>
<dd><p>的<var>word</var>展开以生成模式，并根据以下描述的规则进行<a href="#Pattern-Matching">匹配</a> （请参见<a href="#Pattern-Matching">模式匹配</a> ）。如果格式与的扩展值的尾部部分匹配<var>parameter</var> ，那么扩展的结果就是<var>parameter</var>匹配模式最短（“ <samp>%</samp> '大小写）或最长的匹配模式（' <samp>%%</samp> '案例）删除。如果<var>parameter</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp>然后，将模式删除操作依次应用于每个位置参数，并且扩展是结果列表。如果<var>parameter</var>是下标为'的数组变量<samp>@</samp> ' 要么 ' <samp>*</samp>然后，将模式删除操作依次应用于数组的每个成员，并且扩展是结果列表。
</p>
</dd>
<dt><code>${<var>parameter</var>/<var>pattern</var>/<var>string</var>}</code></dt>
<dd>
<p>的<var>pattern</var>像文件名扩展一样被扩展以产生模式。
<var>Parameter</var>展开，最长的匹配项<var>pattern</var>它的价值被替换为<var>string</var> 。匹配是根据下面描述的规则执行的（请参阅<a href="#Pattern-Matching">模式匹配</a> ）。如果<var>pattern</var>开始于 ' <samp>/</samp> '，所有的匹配项<var>pattern</var>被替换为<var>string</var> 。通常只替换第一个比赛。如果<var>pattern</var>开始于 ' <samp>#</samp> '，它必须与扩展值的开头匹配<var>parameter</var> 。如果<var>pattern</var>开始于 ' <samp>%</samp> '，它必须在扩展值的末尾匹配<var>parameter</var> 。如果<var>string</var>为空，匹配的<var>pattern</var>被删除， <code>/</code>以下<var>pattern</var>可以省略。如果<code>nocasematch</code> shell选项（请参阅<code>shopt</code> <a href="#The-Shopt-Builtin">如果启用了“内置商店”</a> ），则匹配时将不考虑字母字符的大小写。如果<var>parameter</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp>然后，将替换操作依次应用于每个位置参数，并且扩展是结果列表。如果<var>parameter</var>是下标为'的数组变量<samp>@</samp> ' 要么 ' <samp>*</samp> '，则将替换操作依次应用于数组的每个成员，并且扩展为结果列表。
</p>
</dd>
<dt><code>${<var>parameter</var>^<var>pattern</var>}</code></dt>
<dt><code>${<var>parameter</var>^^<var>pattern</var>}</code></dt>
<dt><code>${<var>parameter</var>,<var>pattern</var>}</code></dt>
<dt><code>${<var>parameter</var>,,<var>pattern</var>}</code></dt>
<dd><p>此扩展修改了英文字母的大小写<var>parameter</var> 。的<var>pattern</var>像文件名扩展一样被扩展以产生模式。每个字符的展开值<var>parameter</var>经过测试<var>pattern</var> ，如果与模式匹配，则转换大小写。该模式不应尝试匹配多个字符。' <samp>^</samp> '运算符转换小写字母匹配<var>pattern</var>大写' <samp>,</samp> '运算符将匹配的大写字母转换为小写字母。' <samp>^^</samp> '和' <samp>,,</samp> '扩展将每个匹配的字符转换为扩展值； ' <samp>^</samp> '和' <samp>,</samp> '扩展名仅匹配并转换扩展值中的第一个字符。如果<var>pattern</var>省略，将其视为' <samp>?</samp> '，与每个字符匹配。如果<var>parameter</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp>然后，将大小写修改操作依次应用于每个位置参数，并且扩展是结果列表。如果<var>parameter</var>是下标为'的数组变量<samp>@</samp> ' 要么 ' <samp>*</samp> '，大小写修改操作依次应用于数组的每个成员，并且扩展是结果列表。
</p>
</dd>
<dt><code>${<var>parameter</var>@<var>operator</var>}</code></dt>
<dd><p>扩张要么是<var>parameter</var>或有关的信息<var>parameter</var>本身，取决于<var>operator</var> 。每<var>operator</var>是一个字母：</p>
<dl compact>
<dt><code>Q</code></dt>
<dd><p>扩展名是一个字符串，它是<var>parameter</var>引用的格式可以重复用作输入。
</p></dd>
<dt><code>E</code></dt>
<dd><p>扩展名是一个字符串，它是<var>parameter</var>反斜杠转义序列与<code>$'…'</code>报价机制。
</p></dd>
<dt><code>P</code></dt>
<dd><p>扩展是一个字符串，它是扩展的值的结果<var>parameter</var>就像是一个提示字符串一样（请参阅<a href="#Controlling-the-Prompt">控制提示</a> ）。
</p></dd>
<dt><code>A</code></dt>
<dd><p>扩展是一个赋值语句或<code>declare</code>如果被评估，将重新创建的命令<var>parameter</var>及其属性和价值。
</p></dd>
<dt><code>a</code></dt>
<dd><p>扩展是由标志值组成的字符串，代表<var>parameter</var>的属性。
</p></dd>
</dl>

<p>如果<var>parameter</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp> '，该操作依次应用于每个位置参数，并且扩展是结果列表。如果<var>parameter</var>是下标为'的数组变量<samp>@</samp> ' 要么 ' <samp>*</samp> '，该操作依次应用于数组的每个成员，并且扩展为结果列表。
</p>
<p>扩展的结果将进行词拆分和路径名扩展，如下所述。
</p></dd>
</dl>

<hr>
<a name="Command-Substitution"></a>
<div class="header">
<p>下一篇： <a href="#Arithmetic-Expansion" rel="next" accesskey="n">算术扩展</a> ，上一篇： <a href="#Shell-Parameter-Expansion" rel="prev" accesskey="p">Shell参数扩展</a> ，上一篇： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Command-Substitution-1"></a>
<h4 class="subsection">3.5.4命令替换</h4>
<a name="index-command-substitution"></a>

<p>命令替换允许命令的输出替换命令本身。如下括起命令时，将发生命令替换：</p><div class="example">
<pre class="example">$(<var>command</var>)
</pre></div>
<p>要么</p><div class="example">
<pre class="example">`<var>command</var>`
</pre></div>

<p>Bash通过执行执行扩展<var>command</var>在subshell环境中，并用命令的标准输出替换命令替换，并删除所有尾随的换行符。嵌入的换行符不会被删除，但是可以在分词时将其删除。命令替换<code>$(cat <var>file</var>)</code>可以用等效但更快的速度代替<code>$(< <var>file</var>)</code> 。
</p>
<p>使用旧式的反引号形式的替换时，反斜杠保留其字面意思，但后面加上' <samp>$</samp> '，' <samp>`</samp> '， 要么 ' <samp>\</samp> '。没有反斜杠的第一个反引号将终止命令替换。使用时<code>$(<var>command</var>)</code>形式，括号之间的所有字符组成命令；没有一个被特别对待。
</p>
<p>命令替换可以嵌套。要在使用反引号形式时嵌套，请使用反斜杠对内部反引号进行转义。
</p>
<p>如果替换出现在双引号中，则不会对结果执行单词拆分和文件名扩展。
</p>
<hr>
<a name="Arithmetic-Expansion"></a>
<div class="header">
<p>下一篇： <a href="#Process-Substitution" rel="next" accesskey="n">进程替代</a> ，上一篇： <a href="#Command-Substitution" rel="prev" accesskey="p">命令替代</a> ，上一篇： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Arithmetic-Expansion-1"></a>
<h4 class="subsection">3.5.5算术扩展</h4>
<a name="index-expansion_002c-arithmetic"></a>
<a name="index-arithmetic-expansion"></a>

<p>算术扩展允许对算术表达式进行求值并替换结果。算术扩展的格式为：</p>
<div class="example">
<pre class="example">$(( <var>expression</var> ))
</pre></div>

<p>将该表达式视为在双引号内，但括号内的双引号没有被特殊对待。表达式中的所有标记都经过参数和变量扩展，命令替换和引号删除。将结果视为要评估的算术表达式。算术扩展可以嵌套。
</p>
<p>根据下面列出的规则执行评估（请参阅<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。如果表达式无效，则Bash会显示一条消息，指示标准错误失败，并且不会发生替换。
</p>
<hr>
<a name="Process-Substitution"></a>
<div class="header">
<p>下一篇：分<a href="#Word-Splitting" rel="next" accesskey="n">词</a> ，上一篇： <a href="#Arithmetic-Expansion" rel="prev" accesskey="p">算术扩展</a> ，上一篇： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Process-Substitution-1"></a>
<h4 class="subsection">3.5.6流程替代</h4>
<a name="index-process-substitution"></a>

<p>进程替换允许使用文件名引用进程的输入或输出。它采取的形式</p><div class="example">
<pre class="example">&lt;(<var>list</var>)
</pre></div>
<p>要么</p><div class="example">
<pre class="example">&gt;(<var>list</var>)
</pre></div>
<p>过程<var>list</var>异步运行，其输入或输出显示为文件名。作为扩展结果，此文件名将作为参数传递给当前命令。如果<code>>(<var>list</var>)</code>使用表格时，写入文件将为<var>list</var> 。如果<code><(<var>list</var>)</code>使用form时，应读取作为参数传递的文件以获取输出<var>list</var> 。请注意， <code><</code>要么<code>></code>和左括号，否则该构造将被解释为重定向。在支持命名管道（ <small>FIFO</small> ）或<samp>/dev/fd</samp>命名打开文件的方法。
</p>
<p>如果可用，进程替换将与参数和变量扩展，命令替换和算术扩展同时执行。
</p>
<hr>
<a name="Word-Splitting"></a>
<div class="header">
<p>下一个： <a href="#Filename-Expansion" rel="next" accesskey="n">文件名扩展</a> ，上一个： <a href="#Process-Substitution" rel="prev" accesskey="p">进程替换</a> ，上一个： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Word-Splitting-1"></a>
<h4 class="subsection">3.5.7分词</h4>
<a name="index-word-splitting"></a>

<p>Shell扫描参数扩展，命令替换和算术扩展的结果，这些结果在双引号中未出现，以进行词拆分。
</p>
<p>外壳对待的每个字符<code>$IFS</code>作为定界符，并使用这些字符作为字段终止符将其他扩展的结果拆分为单词。如果<code>IFS</code>未设置，或者其值正好<code><space><tab><newline></code> ，默认值，然后是<code><space></code> ， <code><tab></code>和<code><newline></code>之前扩展结果的开头和结尾将被忽略，并且任何顺序的<code>IFS</code>不在开头或结尾的字符用于分隔单词。如果<code>IFS</code>的值不是默认值，然后是空格字符序列<code>space</code> ， <code>tab</code>和<code>newline</code>只要单词的开头和结尾都被忽略，只要空格字符位于<code>IFS</code> （一个<code>IFS</code>空格字符）。中的任何字符<code>IFS</code>那不是<code>IFS</code>空格以及任何相邻的空格<code>IFS</code>空格字符，分隔字段。一系列<code>IFS</code>空格字符也被视为定界符。如果值<code>IFS</code>为null，不会发生分词。
</p>
<p>显式null参数（ <code>""</code>要么<code>''</code> ）保留并作为空字符串传递给命令。删除因无值的参数扩展而导致的未引用的隐式空参数。如果将不带值的参数用双引号引起来，则会生成空参数，并保留该参数并将其作为空字符串传递给命令。当带引号的空参数作为扩展为非空的单词的一部分出现时，空参数将被删除。也就是说，这个词<code>-d''</code>变成<code>-d</code>分词和删除空参数之后。
</p>
<p>请注意，如果不发生扩展，则不会执行拆分。
</p>
<hr>
<a name="Filename-Expansion"></a>
<div class="header">
<p>下一篇： <a href="#Quote-Removal" rel="next" accesskey="n">删除引号</a>上一篇：分<a href="#Word-Splitting" rel="prev" accesskey="p">词</a>上一篇： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Filename-Expansion-1"></a>
<h4 class="subsection">3.5.8扩展文件名</h4>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Pattern-Matching" accesskey="1">模式匹配</a> ：</td><td>  </td><td align="left" valign="top">外壳如何匹配模式。
</td></tr>
</tbody></table>
<a name="index-expansion_002c-filename"></a>
<a name="index-expansion_002c-pathname"></a>
<a name="index-filename-expansion"></a>
<a name="index-pathname-expansion"></a>

<p>分词后，除非<samp>-f</samp>选项已设置（请参见<a href="#The-Set-Builtin">The Set Builtin</a> ），Bash会在每个单词中扫描字符“ <samp>*</samp> '，' <samp>?</samp> '和' <samp>[</samp> '。如果出现这些字符之一，则该单词被视为<var>pattern</var> ，并替换为与<a href="#Pattern-Matching">模式匹配</a>的文件名按字母顺序排序的列表（请参阅<a href="#Pattern-Matching">模式匹配</a> ）。如果找不到匹配的文件名，则使用shell选项<code>nullglob</code>被禁用，该词保持不变。如果<code>nullglob</code>设置了选项，并且没有找到匹配项，则删除了单词。如果<code>failglob</code>设置了shell选项，但没有找到匹配项，将显示一条错误消息，并且不执行该命令。如果使用shell选项<code>nocaseglob</code>如果启用，匹配将不考虑字母字符的大小写。
</p>
<p>当使用模式扩展文件名时，字符' <samp>.</samp>除非shell选项，否则必须在文件名开头或紧跟在斜杠后立即匹配' <code>dotglob</code>被设置。文件名“ <samp>.</samp> '和' <samp>..</samp> '必须始终明确匹配，即使<code>dotglob</code>被设置。在其他情况下， <samp>.</samp> '字符不被特殊对待。
</p>
<p>与文件名匹配时，斜杠字符必须始终在模式中由斜杠显式地匹配，但是在其他匹配上下文中，可以通过特殊的模式字符将其匹配，如下所述（请参见<a href="#Pattern-Matching">模式匹配</a> ）。
</p>
<p>参见说明<code>shopt</code>在<a href="#The-Shopt-Builtin">The Shopt Builtin中</a> ，有关<code>nocaseglob</code> ， <code>nullglob</code> ， <code>failglob</code>和<code>dotglob</code>选项。
</p>
<p>的<code>GLOBIGNORE</code> shell变量可用于限制与模式匹配的文件名集。如果<code>GLOBIGNORE</code>设置后，每个匹配的文件名也会与其中的一种模式匹配<code>GLOBIGNORE</code>从匹配列表中删除。如果<code>nocaseglob</code>设置了选项，则与模式中的匹配<code>GLOBIGNORE</code>执行时不考虑大小写。文件名<samp>.</samp>和<samp>..</samp>什么时候总是被忽略<code>GLOBIGNORE</code>设置且不为null。但是，设置<code>GLOBIGNORE</code>设为非null值的效果是启用<code>dotglob</code> shell选项，因此所有其他文件名均以' <samp>.</samp>将匹配。要获得忽略以'开头的文件名的旧行为<samp>.</samp> '，使' <samp>.*</samp> '的模式之一<code>GLOBIGNORE</code> 。的<code>dotglob</code>该选项在以下情况下被禁用<code>GLOBIGNORE</code>未设置。
</p>
<hr>
<a name="Pattern-Matching"></a>
<div class="header">
<p>上： <a href="#Filename-Expansion" rel="up" accesskey="u">文件名扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Pattern-Matching-1"></a>
<h4 class="subsubsection">3.5.8.1模式匹配</h4>
<a name="index-pattern-matching"></a>
<a name="index-matching_002c-pattern"></a>

<p>模式中显示的任何字符（以下所述的特殊模式字符除外）都可以匹配。<small>NUL</small>字符可能不会出现在模式中。反斜杠转义以下字符；匹配时，转义的反斜杠将被丢弃。如果要在字面上进行匹配，则必须对特殊模式字符加引号。
</p>
<p>特殊模式字符具有以下含义：</p><dl compact>
<dt><code>*</code></dt>
<dd><p>匹配任何字符串，包括空字符串。当。。。的时候<code>globstar</code> shell选项已启用，并且' <samp>*</samp> '用于文件名扩展上下文，两个相邻的' <samp>*</samp>用作单个模式将匹配所有文件以及零个或多个目录和子目录。如果后接“ <samp>/</samp> '，两个相邻的' <samp>*</samp>的仅与目录和子目录匹配。
</p></dd>
<dt><code>?</code></dt>
<dd><p>匹配任何单个字符。
</p></dd>
<dt><code>[…]</code></dt>
<dd><p>匹配其中任何一个字符。用连字符分隔的一对字符表示<var>range expression</var> ;使用当前语言环境的整理顺序和字符集，匹配介于这两个字符（包括两个字符）之间的任何字符。如果“ <samp>[</samp> '是' <samp>!</samp> '或' <samp>^</samp> '则匹配任何未包含的字符。一种 ' <samp>-</samp>可以通过将其作为集合中的第一个或最后一个字符来进行匹配。一种 ' <samp>]</samp>可以通过将其作为集合中的第一个字符进行匹配。范围表达式中字符的排序顺序由当前语言环境和<code>LC_COLLATE</code>和<code>LC_ALL</code> shell变量（如果设置）。
</p>
<p>例如，在默认的C语言环境中，“ <samp>[a-dx-z]</samp> '等价于' <samp>[abcdxyz]</samp> '。许多语言环境都按字典顺序对字符进行排序，而在这些语言环境中，“ <samp>[a-dx-z]</samp> '通常不等同于' <samp>[abcdxyz]</samp> ';它可能等同于“ <samp>[aBbCcDdxXyYz]</samp> '， 例如。要获得括号表达式中范围的传统解释，您可以通过设置C语言环境来强制使用C语言环境<code>LC_COLLATE</code>要么<code>LC_ALL</code>环境变量为值' <samp>C</samp> '，或启用<code>globasciiranges</code>外壳选项。
</p>
<p>中 ' <samp>[</samp> '和' <samp>]</samp> '， <var>character classes</var>可以使用语法指定<code>[:</code><var>class</var><code>:]</code> ，在哪里<var>class</var>是<small>POSIX</small>标准中定义的以下类之一：</p><div class="example">
<pre class="example">alnum   alpha   ascii   blank   cntrl   digit   graph   lower
print   punct   space   upper   word    xdigit
</pre></div>
<p>字符类别与属于该类别的任何字符匹配。的<code>word</code>字符类匹配字母，数字和字符' <samp>_</samp> '。
</p>
<p>中 ' <samp>[</samp> '和' <samp>]</samp> '， <var>equivalence class</var>可以使用语法指定<code>[=</code><var>c</var><code>=]</code> ，它与所有具有相同排序规则权重（由当前语言环境定义）的字符匹配<var>c</var> 。
</p>
<p>中 ' <samp>[</samp> '和' <samp>]</samp> '，语法<code>[.</code><var>symbol</var><code>.]</code>匹配整理符号<var>symbol</var> 。
</p></dd>
</dl>

<p>如果<code>extglob</code>使用以下命令启用shell选项<code>shopt</code>内置，可以识别几个扩展的模式匹配运算符。在以下说明中， <var>pattern-list</var>是由'分隔的一个或多个模式的列表<samp>|</samp> '。可以使用以下一个或多个子图案来形成复合图案：</p>
<dl compact>
<dt><code>?(<var>pattern-list</var>)</code></dt>
<dd><p>匹配零个或一次出现的给定模式。
</p>
</dd>
<dt><code>*(<var>pattern-list</var>)</code></dt>
<dd><p>匹配零个或多个给定模式的出现。
</p>
</dd>
<dt><code>+(<var>pattern-list</var>)</code></dt>
<dd><p>匹配给定模式的一个或多个出现。
</p>
</dd>
<dt><code>@(<var>pattern-list</var>)</code></dt>
<dd><p>匹配给定的模式之一。
</p>
</dd>
<dt><code>!(<var>pattern-list</var>)</code></dt>
<dd><p>匹配除给定模式之一以外的任何内容。
</p></dd>
</dl>

<p>针对长字符串的复杂扩展模式匹配速度很慢，尤其是当模式包含轮换且字符串包含多个匹配项时。对较短的字符串使用单独的匹配项，或者使用字符串数组而不是单个长字符串，可能会更快。
</p>
<hr>
<a name="Quote-Removal"></a>
<div class="header">
<p>上一页： <a href="#Filename-Expansion" rel="prev" accesskey="p">文件名扩展</a> ，向上： <a href="#Shell-Expansions" rel="up" accesskey="u">Shell扩展</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Quote-Removal-1"></a>
<h4 class="subsection">3.5.9删除报价</h4>

<p>经过上述扩展后，所有未加引号的字符“ <samp>\</samp> '，' <samp>'</samp> '和' <samp>"</samp> '并非由上述扩展之一产生的。
</p>
<hr>
<a name="Redirections"></a>
<div class="header">
<p>下一页： <a href="#Executing-Commands" rel="next" accesskey="n">执行命令</a> ，上一页： <a href="#Shell-Expansions" rel="prev" accesskey="p">Shell扩展</a> ，向上： <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本Shell功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Redirections-1"></a>
<h3 class="section">3.6重定向</h3>
<a name="index-redirection"></a>

<p>在执行命令之前，其输入和输出可能是<var>redirected</var>使用外壳解释的特殊符号。重定向允许复制，打开，关闭命令的文件句柄，使其引用不同的文件，并且可以更改命令读取和写入的文件。重定向还可以用于在当前Shell执行环境中修改文件句柄。以下重定向运算符可以在简单命令中的任何地方出现或出现，或者可以在命令之后。重定向按照从左到右的顺序显示。
</p>
<p>可能在文件描述符编号之后的每个重定向都可以在前面加上{ <var>varname</var> }。在这种情况下，对于>＆-和<＆-以外的每个重定向运算符，shell都会分配一个大于10的文件描述符，并将其分配给{ <var>varname</var> }。如果>＆-或<＆-后跟{ <var>varname</var> }， 的价值<var>varname</var>定义要关闭的文件描述符。如果{ <var>varname</var>提供了}，重定向将保留在命令范围之外，从而使Shell程序员可以自己管理文件描述符。
</p>
<p>在以下描述中，如果省略文件描述符号，并且重定向运算符的第一个字符为' <samp><</samp> '，重定向是指标准输入（文件描述符0）。如果重定向运算符的第一个字符是' <samp>></samp> '，重定向是指标准输出（文件描述符1）。
</p>
<p>除非另有说明，否则以下说明中重定向运算符后面的单词将进行大括号扩展，代字号扩展，参数扩展，命令替换，算术扩展，引用删除，文件名扩展和单词拆分。如果扩展到多个单词，Bash将报告错误。
</p>
<p>请注意，重定向的顺序很重要。例如，命令</p><div class="example">
<pre class="example">ls &gt; <var>dirlist</var> 2&gt;&amp;1
</pre></div>
<p>将标准输出（文件描述符1）和标准错误（文件描述符2）都定向到文件<var>dirlist</var> ，而命令</p><div class="example">
<pre class="example">ls 2&gt;&amp;1 &gt; <var>dirlist</var>
</pre></div>
<p>仅将标准输出定向到文件<var>dirlist</var> ，因为在标准输出重定向到之前，标准错误是标准输出的副本<var>dirlist</var> 。
</p>
<p>Bash在重定向中专门处理多个文件名，如下表所述。如果运行Bash的操作系统提供了这些特殊文件，则bash将使用它们；否则，bash将使用它们。否则，它将使用下面描述的行为在内部模拟它们。
</p>
<dl compact>
<dt><code>/dev/fd/<var>fd</var></code></dt>
<dd><p>如果<var>fd</var>是有效的整数文件描述符<var>fd</var>被重复。
</p>
</dd>
<dt><code>/dev/stdin</code></dt>
<dd><p>文件描述符0被复制。
</p>
</dd>
<dt><code>/dev/stdout</code></dt>
<dd><p>文件描述符1被复制。
</p>
</dd>
<dt><code>/dev/stderr</code></dt>
<dd><p>文件描述符2被复制。
</p>
</dd>
<dt><code>/dev/tcp/<var>host</var>/<var>port</var></code></dt>
<dd><p>如果<var>host</var>是有效的主机名或Internet地址，并且<var>port</var>是整数端口号或服务名，Bash尝试打开相应的TCP套接字。
</p>
</dd>
<dt><code>/dev/udp/<var>host</var>/<var>port</var></code></dt>
<dd><p>如果<var>host</var>是有效的主机名或Internet地址，并且<var>port</var>是整数端口号或服务名，Bash尝试打开相应的UDP套接字。
</p></dd>
</dl>

<p>打开或创建文件失败会导致重定向失败。
</p>
<p>应谨慎使用使用大于9的文件描述符的重定向，因为它们可能与shell内部使用的文件描述符冲突。
</p>
<a name="Redirecting-Input"></a>
<h4 class="subsection">3.6.1重定向输入</h4>
<p>输入的重定向导致文件的名称来自于<var>word</var>打开以读取文件描述符<code>n</code> ，或者标准输入（文件描述符0），如果<code>n</code>未指定。
</p>
<p>重定向输入的一般格式为：</p><div class="example">
<pre class="example">[<var>n</var>]&lt;<var>word</var>
</pre></div>

<a name="Redirecting-Output"></a>
<h4 class="subsection">3.6.2重定向输出</h4>
<p>重定向输出会导致文件的名称来自于<var>word</var>打开以在文件描述符上写入<var>n</var> ，或者标准输出（文件描述符1），如果<var>n</var>未指定。如果文件不存在，则创建该文件；如果确实存在，则将其截断为零大小。
</p>
<p>重定向输出的一般格式为：</p><div class="example">
<pre class="example">[<var>n</var>]&gt;[|]<var>word</var>
</pre></div>

<p>如果重定向运算符为“ <samp>></samp> '和<code>noclobber</code>选项<code>set</code>内建功能已启用，如果文件的名称来自扩展名，则重定向将失败<var>word</var>存在并且是常规文件。如果重定向运算符为“ <samp>>|</samp> '，或重定向运算符为' <samp>></samp>和<code>noclobber</code>选项未启用，即使由命名的文件也会尝试进行重定向<var>word</var>存在。
</p>
<a name="Appending-Redirected-Output"></a>
<h4 class="subsection">3.6.3附加重定向输出</h4>
<p>以这种方式重定向输出会导致文件的名称来自于<var>word</var>打开以附加在文件描述符上<var>n</var> ，或者标准输出（文件描述符1），如果<var>n</var>未指定。如果文件不存在，则会创建该文件。
</p>
<p>附加输出的一般格式为：</p><div class="example">
<pre class="example">[<var>n</var>]&gt;&gt;<var>word</var>
</pre></div>

<a name="Redirecting-Standard-Output-and-Standard-Error"></a>
<h4 class="subsection">3.6.4重定向标准输出和标准错误</h4>
<p>此结构允许将标准输出（文件描述符1）和标准错误输出（文件描述符2）都重定向到名称为的扩展名的文件。 <var>word</var> 。
</p>
<p>重定向标准输出和标准错误有两种格式：</p><div class="example">
<pre class="example">&amp;&gt;<var>word</var>
</pre></div>
<p>和</p><div class="example">
<pre class="example">&gt;&amp;<var>word</var>
</pre></div>
<p>在两种形式中，第一种是优选的。这在语义上等同于</p><div class="example">
<pre class="example">&gt;<var>word</var> 2&gt;&amp;1
</pre></div>
<p>使用第二种形式时， <var>word</var>不能扩展为数字或' <samp>-</samp> '。如果是这样，出于兼容性原因，将应用其他重定向操作符（请参阅下面的“复制文件描述符”）。
</p>
<a name="Appending-Standard-Output-and-Standard-Error"></a>
<h4 class="subsection">3.6.5追加标准输出和标准误差</h4>
<p>此结构允许将标准输出（文件描述符1）和标准错误输出（文件描述符2）都附加到名称为扩展的文件上。 <var>word</var> 。
</p>
<p>附加标准输出和标准错误的格式为：</p><div class="example">
<pre class="example">&amp;&gt;&gt;<var>word</var>
</pre></div>
<p>这在语义上等同于</p><div class="example">
<pre class="example">&gt;&gt;<var>word</var> 2&gt;&amp;1
</pre></div>
<p>（请参见下面的复制文件描述符）。
</p>
<a name="Here-Documents"></a>
<h4 class="subsection">3.6.6此处文件</h4>
<p>这种重定向类型指示Shell从当前源读取输入，直到仅包含一行的行<var>word</var> （没有尾随空白）。读取到该点的所有行均用作标准输入（或文件描述符） <var>n</var>如果<var>n</var>指定）。
</p>
<p>此处文档的格式为：</p><div class="example">
<pre class="example">[<var>n</var>]&lt;&lt;[-]<var>word</var>
        <var>here-document</var>
<var>delimiter</var>
</pre></div>

<p>不对以下参数执行参数和变量扩展，命令替换，算术扩展或文件名扩展<var>word</var> 。如果有<var>word</var>引用， <var>delimiter</var>是取消引用的结果<var>word</var> ，并且此处文档中的行未展开。如果<var>word</var>如果不加引号，则本文档的所有行均经过参数扩展，命令替换和算术扩展，字符序列<code>\newline</code>被忽略，并且' <samp>\</samp> “必须用于引用字符” <samp>\</samp> '，' <samp>$</samp> '和' <samp>`</samp> '。
</p>
<p>如果重定向运算符为“ <samp><<-</samp> '，然后从输入行和包含该行的行中删除所有前导制表符<var>delimiter</var> 。这允许外壳脚本中的此处文档以自然方式缩进。
</p>
<a name="Here-Strings"></a>
<h4 class="subsection">3.6.7字符串</h4>
<p>这里文档的一种变体，格式为：</p><div class="example">
<pre class="example">[<var>n</var>]&lt;&lt;&lt; <var>word</var>
</pre></div>

<p>的<var>word</var>进行波浪线扩展，参数和变量扩展，命令替换，算术扩展和引号删除。不执行路径名扩展和单词拆分。结果以单个字符串的形式提供，并在命令的标准输入（或文件描述符）上附加换行符<var>n</var>如果<var>n</var>指定）。
</p>
<a name="Duplicating-File-Descriptors"></a>
<h4 class="subsection">3.6.8复制文件描述符</h4>
<p>重定向运算符</p><div class="example">
<pre class="example">[<var>n</var>]&lt;&amp;<var>word</var>
</pre></div>
<p>用于复制输入文件描述符。如果<var>word</var>扩展到一个或多个数字，文件描述符由表示<var>n</var>被制成该文件描述符的副本。如果数字在<var>word</var>如果未指定打开的文件描述符用于输入，则会发生重定向错误。如果<var>word</var>评估为“ <samp>-</samp> '，文件描述符<var>n</var>已经关了。如果<var>n</var>如果未指定，则使用标准输入（文件描述符0）。
</p>
<p>运营商</p><div class="example">
<pre class="example">[<var>n</var>]&gt;&amp;<var>word</var>
</pre></div>
<p>类似地用于复制输出文件描述符。如果<var>n</var>如果未指定，则使用标准输出（文件描述符1）。如果数字在<var>word</var>如果未指定为输出打开的文件描述符，则会发生重定向错误。如果<var>word</var>评估为“ <samp>-</samp> '，文件描述符<var>n</var>已经关了。作为特殊情况，如果<var>n</var>被省略，并且<var>word</var>不能扩展为一个或多个数字或' <samp>-</samp> '，如前所述重定向标准输出和标准错误。
</p>
<a name="Moving-File-Descriptors"></a>
<h4 class="subsection">3.6.9移动文件描述符</h4>
<p>重定向运算符</p><div class="example">
<pre class="example">[<var>n</var>]&lt;&amp;<var>digit</var>-
</pre></div>
<p>移动文件描述符<var>digit</var>到文件描述符<var>n</var> ，或者标准输入（文件描述符0），如果<var>n</var>未指定。
<var>digit</var>复制到后关闭<var>n</var> 。
</p>
<p>同样，重定向运算符</p><div class="example">
<pre class="example">[<var>n</var>]&gt;&amp;<var>digit</var>-
</pre></div>
<p>移动文件描述符<var>digit</var>到文件描述符<var>n</var> ，或者标准输出（文件描述符1），如果<var>n</var>未指定。
</p>
<a name="Opening-File-Descriptors-for-Reading-and-Writing"></a>
<h4 class="subsection">3.6.10打开文件描述符进行读写</h4>
<p>重定向运算符</p><div class="example">
<pre class="example">[<var>n</var>]&lt;&gt;<var>word</var>
</pre></div>
<p>导致名称为<var>word</var>可以打开以读取和写入文件描述符<var>n</var> ，如果文件描述符为0，则为<var>n</var>未指定。如果该文件不存在，则会创建它。
</p>
<hr>
<a name="Executing-Commands"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Scripts" rel="next" accesskey="n">Shell脚本</a> ，上一篇： <a href="#Redirections" rel="prev" accesskey="p">重定向</a> ，上一篇： <a href="#Shell-Scripts" rel="next" accesskey="n">Shell</a> <a href="#Basic-Shell-Features" rel="up" accesskey="u">基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Executing-Commands-1"></a>
<h3 class="section">3.7执行命令</h3>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Simple-Command-Expansion" accesskey="1">简单命令扩展</a> ：</td><td>  </td><td align="left" valign="top">Bash如何在执行前扩展简单命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Search-and-Execution" accesskey="2">命令搜索和执行</a> ：</td><td>  </td><td align="left" valign="top">Bash如何查找并运行命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Execution-Environment" accesskey="3">命令执行环境</a> ：</td><td>  </td><td align="left" valign="top">Bash执行不是shell内置命令的环境。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Environment" accesskey="4">环境</a> ：</td><td>  </td><td align="left" valign="top">给命令的环境。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Exit-Status" accesskey="5">退出状态</a> ：</td><td>  </td><td align="left" valign="top">命令返回的状态以及Bash对其解释的方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Signals" accesskey="6">信号</a> ：</td><td>  </td><td align="left" valign="top">当Bash或其运行的命令接收到信号时会发生什么。
</td></tr>
</tbody></table>

<hr>
<a name="Simple-Command-Expansion"></a>
<div class="header">
<p>下一页： <a href="#Command-Search-and-Execution" rel="next" accesskey="n">命令搜索和执行</a> ，上一篇： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Simple-Command-Expansion-1"></a>
<h4 class="subsection">3.7.1简单命令扩展</h4>
<a name="index-command-expansion"></a>

<p>当执行一个简单命令时，shell从左到右执行以下扩展，分配和重定向。
</p>
<ol>
<li>解析器标记为变量分配的单词（在命令名称之前的单词）和重定向将被保存以供以后处理。

</li><li>不是变量分配或重定向的单词将被扩展（请参阅<a href="#Shell-Expansions">Shell Expansions</a> ）。如果扩展后还剩下任何单词，则将第一个单词作为命令的名称，并将其余单词作为参数。

</li><li>重定向如上所述进行（请参阅<a href="#Redirections">重定向</a> ）。

</li><li>'之后的文字<samp>=</samp>在分配给变量之前，每个变量分配中的'都会经历代字号扩展，参数扩展，命令替换，算术扩展和引号删除。
</li></ol>

<p>如果没有命令名称，则变量分配会影响当前的shell环境。否则，变量将添加到已执行命令的环境中，并且不会影响当前的shell环境。如果任何分配尝试将值分配给只读变量，都会发生错误，并且命令以非零状态退出。
</p>
<p>如果没有命令名称，则执行重定向，但不会影响当前的shell环境。重定向错误导致命令以非零状态退出。
</p>
<p>如果扩展后还剩下命令名称，则执行如下所述。否则，命令退出。如果其中一个扩展包含命令替换，则命令的退出状态为上次执行的命令替换的退出状态。如果没有命令替换，则命令以零状态退出。
</p>
<hr>
<a name="Command-Search-and-Execution"></a>
<div class="header">
<p>下一篇： <a href="#Command-Execution-Environment" rel="next" accesskey="n">命令执行环境</a> ，上一篇： <a href="#Simple-Command-Expansion" rel="prev" accesskey="p">简单命令扩展</a> ，上一篇： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Command-Search-and-Execution-1"></a>
<h4 class="subsection">3.7.2命令搜索和执行</h4>
<a name="index-command-execution"></a>
<a name="index-command-search"></a>

<p>将命令拆分为单词后，如果产生一条简单的命令和可选的参数列表，则将执行以下操作。
</p>
<ol>
<li>如果命令名称不包含斜杠，则外壳程序将尝试找到它。如果存在具有该名称的<a href="#Shell-Functions">Shell函数</a> ，则将按照<a href="#Shell-Functions">Shell Functions中的</a>描述调用该<a href="#Shell-Functions">函数</a> 。

</li><li>如果名称与函数不匹配，则shell在shell内置列表中搜索它。如果找到匹配项，则调用该内置函数。

</li><li>如果名称既不是外壳函数也不是内置函数，并且不包含任何斜杠，则Bash会搜索其中的每个元素<code>$PATH</code>包含包含该名称的可执行文件的目录。Bash使用哈希表来记住可执行文件的完整路径名，以避免多个<code>PATH</code>搜索（请参阅<code>hash</code>在<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins中</a> ）。完整搜索目录<code>$PATH</code>仅当在哈希表中找不到命令时才执行该命令。如果搜索失败，则外壳程序将搜索已定义的外壳程序函数，命名为<code>command_not_found_handle</code> 。如果该函数存在，则在单独的执行环境中以原始命令和原始命令的参数作为其参数来调用它，并且该函数的退出状态成为该子Shell的退出状态。如果未定义该函数，则外壳程序将显示一条错误消息并返回退出状态127。

</li><li>如果搜索成功，或者命令名称包含一个或多个斜杠，则Shell将在单独的执行环境中执行命名的程序。参数0设置为给定的名称，命令的其余参数设置为提供的参数（如果有）。

</li><li>如果由于文件不是可执行文件格式并且文件不是目录而导致执行失败，则假定该文件为目录。 <var>shell script</var>然后Shell按照<a href="#Shell-Scripts">Shell脚本中的</a>描述执行它。

</li><li>如果命令不是以异步方式启动的，则Shell将等待命令完成并收集其退出状态。

</li></ol>

<hr>
<a name="Command-Execution-Environment"></a>
<div class="header">
<p>下一篇： <a href="#Environment" rel="next" accesskey="n">环境</a> ，上一篇： <a href="#Command-Search-and-Execution" rel="prev" accesskey="p">命令搜索和执行</a> ，上一篇： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Command-Execution-Environment-1"></a>
<h4 class="subsection">3.7.3命令执行环境</h4>
<a name="index-execution-environment"></a>

<p>外壳有一个<var>execution environment</var> ，由以下内容组成：</p>
<ul>
<li>外壳程序在调用时继承的打开文件，并通过提供给<code>exec</code>内建的</li><li>由设置的当前工作目录<code>cd</code> ， <code>pushd</code> ， 要么<code>popd</code> ，或由外壳程序在调用时继承</li><li>由设置的文件创建模式掩码<code>umask</code>或从外壳的父级继承</li><li>当前陷阱设置<code>trap</code>

</li><li>通过变量分配或通过<code>set</code>或从环境中的Shell父级继承</li><li>在执行期间定义或从环境中的Shell父级继承的Shell函数</li><li>调用时启用的选项（默认情况下或使用命令行参数）或<code>set</code>

</li><li>由启用的选项<code>shopt</code> （请参阅<a href="#The-Shopt-Builtin">内置的Shopt</a> ）</li><li>定义的shell别名<code>alias</code> （请参阅<a href="#Aliases">别名</a> ）</li><li>各种进程<small>ID</small> ，包括后台作业的<small>ID</small> （请参见<a href="#Lists">清单</a> ）， <code>$$</code> ，以及<code>$PPID</code>

</li></ul>

<p>当要执行除内置函数或外壳函数以外的简单命令时，将在包含以下内容的单独执行环境中调用该命令。除非另有说明，否则这些值是从Shell继承的。
</p>
<ul>
<li>Shell的打开文件，以及通过重定向到命令指定的任何修改和添加</li><li>当前工作目录</li><li>文件创建模式掩码</li><li>标记为导出的shell变量和函数，以及为命令导出的变量，在环境中传递（请参阅<a href="#Environment">Environment</a> ）</li><li>外壳程序捕获的陷阱将重置为从外壳程序的父级继承的值，并且外壳程序忽略的陷阱将被忽略</li></ul>

<p>在此单独环境中调用的命令不会影响Shell的执行环境。
</p>
<p>在与shell环境重复的子shell环境中调用命令替换，用括号分组的命令以及异步命令，除了将shell捕获的陷阱重置为shell在调用时从其父级继承的值。作为流水线的一部分调用的内置命令也在子外壳环境中执行。对子外壳环境所做的更改不会影响外壳的执行环境。
</p>
<p>产生来执行命令替换的子外壳继承了<samp>-e</samp>父外壳中的选项。当不在<small>POSIX</small>模式下时，Bash清除<samp>-e</samp>此类子shell中的选项。
</p>
<p>如果命令后跟一个' <samp>&</samp> '并且作业控制未激活，该命令的默认标准输入是空文件<samp>/dev/null</samp> 。否则，被调用的命令将继承通过重定向修改的调用shell的文件描述符。
</p>
<hr>
<a name="Environment"></a>
<div class="header">
<p>下一篇： <a href="#Exit-Status" rel="next" accesskey="n">退出状态</a> ，上一篇： <a href="#Command-Execution-Environment" rel="prev" accesskey="p">命令执行环境</a> ，上一篇： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Environment-1"></a>
<h4 class="subsection">3.7.4环境</h4>
<a name="index-environment"></a>

<p>程序被调用时，会得到一个字符串数组，称为<var>environment</var> 。这是名称-值对的列表，格式为<code>name=value</code> 。
</p>
<p>Bash提供了几种操作环境的方法。调用时，shell扫描其自身的环境并为找到的每个名称创建一个参数，并自动将其标记为<var>export</var>子进程。执行的命令会继承环境。的<code>export</code>和' <samp>declare -x</samp> '命令允许将参数和功能添加到环境中或从环境中删除。如果修改了环境中参数的值，则新值将成为环境的一部分，替换旧的值。任何执行的命令所继承的环境都由外壳程序的初始环境组成，其初始值可以在外壳程序中进行修改，减去由命令删除的任何对。 <code>unset</code>和' <samp>export -n</samp> '命令，以及通过<code>export</code>和' <samp>declare -x</samp> '命令。
</p>
<p>如<a href="#Shell-Parameters">Shell Parameters中</a>所述，可以通过在其前面加上参数分配来临时扩展任何简单命令或功能的环境。这些赋值语句仅影响该命令看到的环境。
</p>
<p>如果<samp>-k</samp>设置选项（请参见<a href="#The-Set-Builtin">The Set Builtin</a> ），然后将所有参数分配放置在命令环境中，而不仅仅是命令名称之前的参数分配。
</p>
<p>当Bash调用外部命令时，变量' <samp>$_</samp> '设置为命令的完整路径名，并在其环境中传递给该命令。
</p>
<hr>
<a name="Exit-Status"></a>
<div class="header">
<p>下一篇： <a href="#Signals" rel="next" accesskey="n">信号</a> ，上一篇： <a href="#Environment" rel="prev" accesskey="p">环境</a> ，上一篇： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Exit-Status-1"></a>
<h4 class="subsection">3.7.5退出状态</h4>
<a name="index-exit-status-1"></a>

<p>已执行命令的退出状态是命令返回的值。 <var>waitpid</var>系统调用或等效功能。退出状态介于0到255之间，但是，如下所述，shell可能会特别使用125以上的值。Shell内置命令和复合命令的退出状态也限制在此范围内。在某些情况下，外壳将使用特殊值来指示特定的故障模式。
</p>
<p>出于shell的目的，成功执行了以零退出状态退出的命令。非零退出状态表示失败。使用了这种看似违反直觉的方案，因此存在一种明确定义的方法来指示成功，并且有多种方法来指示各种故障模式。当命令终止于致命信号时，其编号为<var>N</var> ，Bash使用值128+ <var>N</var>作为退出状态。
</p>
<p>如果未找到命令，则为执行该命令而创建的子进程将返回状态127。如果找到命令但无法执行，则返回状态为126。
</p>
<p>如果命令由于扩展或重定向期间的错误而失败，则退出状态大于零。
</p>
<p>Bash条件命令（请参阅<a href="#Conditional-Constructs">条件构造</a> ）和一些列表构造（请参见<a href="#Lists">Lists</a> ）使用退出状态。
</p>
<p>如果所有Bash内置程序成功，返回的退出状态为零，失败时返回的状态为非零，因此它们可以被条件和列表构造使用。所有内建函数都返回退出状态2，以指示使用不正确，通常无效的选项或缺少参数。
</p>
<hr>
<a name="Signals"></a>
<div class="header">
<p>上一页： <a href="#Exit-Status" rel="prev" accesskey="p">退出状态</a> ，向上： <a href="#Executing-Commands" rel="up" accesskey="u">执行命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Signals-1"></a>
<h4 class="subsection">3.7.6信号</h4>
<a name="index-signal-handling"></a>

<p>当Bash是交互式的时，在没有任何陷阱的情况下，它将忽略<code>SIGTERM</code> （以便 ' <samp>kill 0</samp> '不会杀死交互式外壳），并且<code>SIGINT</code>被捕获并处理（以便<code>wait</code>内置可中断）。当Bash收到<code>SIGINT</code> ，它脱离了任何执行循环。在所有情况下，Bash都会忽略<code>SIGQUIT</code> 。如果作业控制有效（请参阅“ <a href="#Job-Control">作业控制”</a> ），则Bash会忽略<code>SIGTTIN</code> ， <code>SIGTTOU</code>和<code>SIGTSTP</code> 。
</p>
<p>由Bash启动的非内置命令将信号处理程序设置为shell从其父级继承的值。当作业控制无效时，异步命令将忽略<code>SIGINT</code>和<code>SIGQUIT</code>除了这些继承的处理程序。由于命令替换而运行的命令会忽略键盘生成的作业控制信号<code>SIGTTIN</code> ， <code>SIGTTOU</code>和<code>SIGTSTP</code> 。
</p>
<p>默认情况下，shell会在收到<code>SIGHUP</code> 。退出之前，交互式外壳会重新发送<code>SIGHUP</code>所有正在运行或已停止的作业。发送已停止的作业<code>SIGCONT</code>确保他们收到<code>SIGHUP</code> 。为了防止外壳发送<code>SIGHUP</code>信号发送到特定作业，应使用<code>disown</code>内置（请参阅<a href="#Job-Control-Builtins">Job Control内置</a> ）或标记为不接收<code>SIGHUP</code>使用<code>disown -h</code> 。
</p>
<p>如果<code>huponexit</code> shell选项已设置为<code>shopt</code> （请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），Bash发送了一个<code>SIGHUP</code>交互式登录外壳退出时处理所有作业。
</p>
<p>如果Bash正在等待命令完成并接收到已设置陷阱的信号，则在命令完成之前将不执行陷阱。当Bash正在等待通过<code>wait</code>内置，接收到已设置陷阱的信号将导致<code>wait</code>内置返回状态大于128的立即返回，此后立即执行陷阱。
</p>
<hr>
<a name="Shell-Scripts"></a>
<div class="header">
<p>上<a href="#Executing-Commands" rel="prev" accesskey="p">一篇</a> ： <a href="#Executing-Commands" rel="prev" accesskey="p">执行命令</a> ，上一篇： <a href="#Basic-Shell-Features" rel="up" accesskey="u">Shell的基本功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Scripts-1"></a>
<h3 class="section">3.8 Shell脚本</h3>
<a name="index-shell-script"></a>

<p>Shell脚本是包含Shell命令的文本文件。当调用Bash时将此类文件用作第一个非选项参数时， <samp>-c</samp>也不<samp>-s</samp>提供了option选项（请参阅<a href="#Invoking-Bash">Invoking Bash</a> ），Bash从文件读取并执行命令，然后退出。这种操作模式将创建非交互式外壳。Shell首先在当前目录中搜索文件，然后在目录中查找<code>$PATH</code>如果在那儿找不到。
</p>
<p>当Bash运行shell脚本时，它会设置特殊参数<code>0</code>文件名而不是外壳程序名，位置参数设置为其余参数（如果有的话）。如果未提供其他参数，则未设置位置参数。
</p>
<p>可以使用以下命令使Shell脚本可执行： <code>chmod</code>命令打开执行位。当Bash在搜寻<code>$PATH</code>对于命令，它产生一个子shell来执行它。换句话说，执行</p><div class="example">
<pre class="example">filename <var>arguments</var>
</pre></div>
<p>相当于执行</p><div class="example">
<pre class="example">bash filename <var>arguments</var>
</pre></div>

<p>如果<code>filename</code>是可执行的Shell脚本。该子Shell自身会重新初始化，因此效果就像调用了一个新Shell来解释脚本一样，但父级记住的命令位置除外（请参见<code>hash</code>在<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins中</a> ）由孩子保留。
</p>
<p>Unix的大多数版本使它成为操作系统命令执行机制的一部分。如果脚本的第一行以两个字符开头， <samp>#!</samp> '，该行的其余部分指定程序的解释器。因此，您可以指定Bash， <code>awk</code> ，Perl或其他解释器，然后使用该语言编写脚本文件的其余部分。
</p>
<p>解释器的参数由一个可选参数组成，该参数位于脚本文件第一行中解释器名称之后，然后是脚本文件的名称，然后是其余参数。Bash将在不自行处理的操作系统上执行此操作。请注意，某些较旧的Unix版本将解释器名称和参数限制为最多32个字符。
</p>
<p>Bash脚本通常以<code>#! /bin/bash</code> （假设Bash已安装在<samp>/bin</samp> ），因为这样可以确保Bash会被用来解释脚本，即使该脚本是在另一个shell下执行的也是如此。
</p>
<hr>
<a name="Shell-Builtin-Commands"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Variables" rel="next" accesskey="n">Shell变量</a> ，上一篇： <a href="#Shell-Variables" rel="next" accesskey="n">Shell</a> <a href="#Basic-Shell-Features" rel="prev" accesskey="p">基本功能</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">页首</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Builtin-Commands-1"></a>
<h2 class="chapter">4个Shell内置命令</h2>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Bourne-Shell-Builtins" accesskey="1">Bourne Shell Builtins</a> ：</td><td>  </td><td align="left" valign="top">从Bourne Shell继承的内置命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-Builtins" accesskey="2">Bash内置函数</a> ：</td><td>  </td><td align="left" valign="top">特定于Bash的内置表。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Modifying-Shell-Behavior" accesskey="3">修改Shell行为</a> ：</td><td>  </td><td align="left" valign="top">内置程序可修改外壳程序属性和可选行为。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Builtins" accesskey="4">特殊内置</a> ：</td><td>  </td><td align="left" valign="top">内置命令由POSIX专门分类。</td></tr>
</tbody></table>

<p>内置命令包含在外壳本身内。当将内置命令的名称用作简单命令的第一个单词时（请参见<a href="#Simple-Commands">Simple Commands</a> ），shell将直接执行该命令，而无需调用其他程序。内置命令对于实现使用单独的实用工具无法获得或不方便的功能是必需的。
</p>
<p>本节简要描述了Bash从Bourne Shell继承的内置命令，以及Bash特有或已在Bash中扩展的内置命令。
</p>
<p>其他章节中描述了几个内置命令：内置命令，它们为作业控制工具提供Bash接口（请参阅<a href="#Job-Control-Builtins">Job Control Builtins</a> ），目录堆栈（请参阅<a href="#Directory-Stack-Builtins">Directory Stack Builtins</a> ），命令历史记录（请参阅<a href="#Bash-History-Builtins">Bash History Builtins</a> ）和可编程完成工具（请参阅“ <a href="#Programmable-Completion-Builtins">可编程完成内置函数”</a> ）。
</p>
<p><small>POSIX</small>或Bash已扩展了许多内置<small>函数</small> 。
</p>
<p>除非另有说明，否则每个内置命令均以接受选项的形式记录，并以' <samp>-</samp> '接受' <samp>--</samp> '表示选项结束。的<code>:</code> ， <code>true</code> ， <code>false</code>和<code>test</code> / <code>[</code>内建函数不接受选项，也不将' <samp>--</samp>特别地。的<code>exit</code> ， <code>logout</code> ， <code>return</code> ， <code>break</code> ， <code>continue</code> ， <code>let</code>和<code>shift</code>内建函数接受和处理以'开头的参数<samp>-</samp> '不需要' <samp>--</samp> '。其他接受参数但未指定为接受选项的内建函数会解释以'开头的参数<samp>-</samp> '作为无效选项，并要求' <samp>--</samp>以防止这种解释。
</p>
<hr>
<a name="Bourne-Shell-Builtins"></a>
<div class="header">
<p>下一页： <a href="#Bash-Builtins" rel="next" accesskey="n">Bash内置程序</a> ，上： <a href="#Shell-Builtin-Commands" rel="up" accesskey="u">Shell内置命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bourne-Shell-Builtins-1"></a>
<h3 class="section">4.1 Bourne Shell内置</h3>

<p>以下Shell内置命令是从Bourne Shell继承的。这些命令按照<small>POSIX</small>标准指定的方式实现。
</p>
<dl compact>
<dt><code>: <span class="roman">(a colon)</span></code></dt>
<dd><a name="index-_003a"></a>
<div class="example">
<pre class="example">: [<var>arguments</var>]
</pre></div>

<p>无所不包<var>arguments</var>并执行重定向。返回状态为零。
</p>
</dd>
<dt><code>. <span class="roman">(a period)</span></code></dt>
<dd><a name="index-_002e"></a>
<div class="example">
<pre class="example">. <var>filename</var> [<var>arguments</var>]
</pre></div>

<p>读取并执行命令<var>filename</var>当前shell上下文中的参数。如果<var>filename</var>不包含斜线， <code>PATH</code>变量用于查找<var>filename</var> 。当Bash不在<small>POSIX</small>模式下时，搜索当前目录是否<var>filename</var>在中找不到<code>$PATH</code> 。如果有的话<var>arguments</var>提供时，它们将成为位置参数<var>filename</var>被执行。否则，位置参数将保持不变。如果<samp>-T</samp>选项已启用， <code>source</code>继承任何陷阱<code>DEBUG</code> ;如果不是的话<code>DEBUG</code>陷阱字符串被保存并在对的调用周围恢复<code>source</code>和<code>source</code>取消设置<code>DEBUG</code>执行时陷阱。如果<samp>-T</samp>未设置，并且源文件更改了<code>DEBUG</code>陷阱，保留新值<code>source</code>完成。返回状态是最后执行的命令的退出状态；如果未执行任何命令，则返回零。如果<var>filename</var>找不到或无法读取，返回状态为非零。这个内置相当于<code>source</code> 。
</p>
</dd>
<dt><code>break</code></dt>
<dd><a name="index-break"></a>
<div class="example">
<pre class="example">break [<var>n</var>]
</pre></div>

<p>从一个出口<code>for</code> ， <code>while</code> ， <code>until</code> ， 要么<code>select</code>环。如果<var>n</var>提供， <var>n</var>第一个封闭循环退出。
<var>n</var>必须大于或等于1。返回状态为零，除非<var>n</var>不大于或等于1。
</p>
</dd>
<dt><code>cd</code></dt>
<dd><a name="index-cd"></a>
<div class="example">
<pre class="example">cd [-L|[-P [-e]] [-@] [<var>directory</var>]
</pre></div>

<p>将当前工作目录更改为<var>directory</var> 。如果<var>directory</var>未提供，则<code>HOME</code>使用shell变量。之后的任何其他参数<var>directory</var>被忽略。如果shell变量<code>CDPATH</code>存在，它用作搜索路径：中的每个目录名称<code>CDPATH</code>被搜索<var>directory</var> ，其中包含备用目录名<code>CDPATH</code>用冒号隔开（' <samp>:</samp> '）。如果<var>directory</var>以斜线开头， <code>CDPATH</code>未使用。
</p>
<p>的<samp>-P</samp>选项表示不遵循符号链接：符号链接在<code>cd</code>正在遍历<var>directory</var>并且在处理“ <samp>..</samp>在<var>directory</var> 。
</p>
<p>默认情况下，或<samp>-L</samp>提供了选项，符号链接位于<var>directory</var>之后解决<code>cd</code>处理' <samp>..</samp>在<var>directory</var> 。
</p>
<p>如果“ <samp>..</samp> '出现在<var>directory</var> ，则可以通过删除紧接在前的路径名组件，返回到斜杠或<var>directory</var> 。
</p>
<p>如果<samp>-e</samp>选件随附<samp>-P</samp>成功更改目录后，无法成功确定当前工作目录， <code>cd</code>将返回失败状态。
</p>
<p>在支持它的系统上， <samp>-@</samp>选项将与文件关联的扩展属性显示为目录。
</p>
<p>如果<var>directory</var>是' <samp>-</samp> '，它将转换为<code>$OLDPWD</code>尝试更改目录之前。
</p>
<p>如果来自一个非空目录名<code>CDPATH</code>被使用，或者<samp>-</samp> '是第一个参数，并且目录更改成功，新工作目录的绝对路径名被写入标准输出。
</p>
<p>如果成功更改目录，则返回状态为零，否则为非零。
</p>
</dd>
<dt><code>continue</code></dt>
<dd><a name="index-continue"></a>
<div class="example">
<pre class="example">continue [<var>n</var>]
</pre></div>

<p>恢复封闭的下一个迭代<code>for</code> ， <code>while</code> ， <code>until</code> ， 要么<code>select</code>环。如果<var>n</var>提供，执行<var>n</var>封闭循环将恢复。
<var>n</var>必须大于或等于1。返回状态为零，除非<var>n</var>不大于或等于1。
</p>
</dd>
<dt><code>eval</code></dt>
<dd><a name="index-eval"></a>
<div class="example">
<pre class="example">eval [<var>arguments</var>]
</pre></div>

<p>将参数串联在一起成为一个命令，然后读取并执行该命令，并将其退出状态作为以下命令的退出状态返回： <code>eval</code> 。如果没有参数或只有空参数，则返回状态为零。
</p>
</dd>
<dt><code>exec</code></dt>
<dd><a name="index-exec"></a>
<div class="example">
<pre class="example">exec [-cl] [-a <var>name</var>] [<var>command</var> [<var>arguments</var>]]
</pre></div>

<p>如果<var>command</var>提供，它将替换外壳，而无需创建新进程。如果<samp>-l</samp>提供了option，shell在传递给的第零个参数的开头放置一个破折号<var>command</var> 。这就是<code>login</code>程序呢。的<samp>-c</samp>选择原因<var>command</var>在空环境下执行。如果<samp>-a</samp>提供，外壳通过<var>name</var>作为第零个参数<var>command</var> 。如果<var>command</var>由于某种原因而无法执行，则非交互式外壳程序将退出，除非<code>execfail</code> Shell选项已启用。在这种情况下，它将返回失败。如果无法执行文件，则交互式外壳程序将返回失败。如果以下情况，子外壳将无条件退出<code>exec</code>失败。如果不<var>command</var>如果指定了重定向，则可以使用重定向来影响当前的shell环境。如果没有重定向错误，则返回状态为零；否则为0。否则，返回状态为非零。
</p>
</dd>
<dt><code>exit</code></dt>
<dd><a name="index-exit"></a>
<div class="example">
<pre class="example">exit [<var>n</var>]
</pre></div>

<p>退出外壳程序，返回状态<var>n</var>到外壳的父级。如果<var>n</var>如果省略，则退出状态是最后执行的命令的退出状态。任何陷阱<code>EXIT</code>在外壳终止之前执行。
</p>
</dd>
<dt><code>export</code></dt>
<dd><a name="index-export"></a>
<div class="example">
<pre class="example">export [-fn] [-p] [<var>name</var>[=<var>value</var>]]
</pre></div>

<p>标记每个<var>name</var>传递给环境中的子进程。如果<samp>-f</samp>提供选项， <var>name</var> s是指shell函数；否则，名称指的是shell变量。的<samp>-n</samp>选项意味着不再标记每个<var>name</var>出口。如果不<var>names</var>提供，或者<samp>-p</samp>给定选项，将显示所有导出变量的名称列表。的<samp>-p</samp>选项以可以重用作为输入的形式显示输出。如果变量名后跟= <var>value</var> ，变量的值设置为<var>value</var> 。
</p>
<p>除非提供了无效的选项，否则返回状态为零，其中一个名称不是有效的Shell变量名称，或者<samp>-f</samp>提供的名称不是shell函数。
</p>
</dd>
<dt><code>getopts</code></dt>
<dd><a name="index-getopts"></a>
<div class="example">
<pre class="example">getopts <var>optstring</var> <var>name</var> [<var>args</var>]
</pre></div>

<p><code>getopts</code>由Shell脚本用于解析位置参数。
<var>optstring</var>包含要识别的选项字符；如果一个字符后跟一个冒号，则该选项应具有一个参数，该参数应由空格分隔。冒号（' <samp>:</samp> '）和问号（' <samp>?</samp> '）不能用作选项字符。每次调用它时， <code>getopts</code>将下一个选项放在shell变量中<var>name</var> ，初始化<var>name</var>如果不存在，则将下一个参数的索引处理到变量中<code>OPTIND</code> 。
<code>OPTIND</code>每次调用shell或shell脚本时，初始化为1。当一个选项需要一个参数时， <code>getopts</code>将该参数放入变量中<code>OPTARG</code> 。外壳不重置<code>OPTIND</code>自动必须在多次调用之间手动重置<code>getopts</code>如果要使用一组新的参数，则在同一Shell调用内进行。
</p>
<p>当遇到选项结尾时， <code>getopts</code>以大于零的返回值退出。
<code>OPTIND</code>设置为第一个非选项参数的索引，并且<var>name</var>被设定为 ' <samp>?</samp> '。
</p>
<p><code>getopts</code>通常会解析位置参数，但是如果在<var>args</var> ， <code>getopts</code>解析那些。
</p>
<p><code>getopts</code>可以通过两种方式报告错误。如果第一个字符<var>optstring</var>是冒号<var>silent</var>使用错误报告。在正常操作中，遇到无效选项或缺少选项参数时，将打印诊断消息。如果变量<code>OPTERR</code>设置为0，即使的第一个字符也不会显示错误消息<code>optstring</code>不是冒号。
</p>
<p>如果看到无效的选项， <code>getopts</code>地方<samp>?</samp> '成<var>name</var>并且，如果不是无提示，则会打印一条错误消息并取消设置<code>OPTARG</code> 。如果<code>getopts</code>保持沉默，找到的选项字符放置在<code>OPTARG</code>并且没有打印诊断消息。
</p>
<p>如果找不到必需的参数，并且<code>getopts</code>不沉默，问号（' <samp>?</samp> '）放在<var>name</var> ， <code>OPTARG</code>未设置，并打印诊断消息。如果<code>getopts</code>保持沉默，然后冒号（' <samp>:</samp> '）放在<var>name</var>和<code>OPTARG</code>设置为找到的选项字符。
</p>
</dd>
<dt><code>hash</code></dt>
<dd><a name="index-hash"></a>
<div class="example">
<pre class="example">hash [-r] [-p <var>filename</var>] [-dt] [<var>name</var>]
</pre></div>

<p>每一次<code>hash</code>被调用时，它会记住指定为的命令的完整路径名<var>name</var>参数，因此无需在后续调用中搜索它们。通过搜索目录中列出的目录可以找到命令<code>$PATH</code> 。任何先前记住的路径名都将被丢弃。的<samp>-p</samp>选项禁止路径搜索，并且<var>filename</var>用作位置<var>name</var> 。的<samp>-r</samp>选项使外壳程序忘记所有记住的位置。的<samp>-d</samp>选项导致外壳忘记每个位置的记忆位置<var>name</var> 。如果<samp>-t</samp>提供了选项，每个选项都提供了完整的路径名<var>name</var>对应打印。如果多个<var>name</var>参数随<samp>-t</samp> ， <var>name</var>在散列的完整路径名之前打印。的<samp>-l</samp>选项导致输出以可以重新用作输入的格式显示。如果没有给出参数，或者仅<samp>-l</samp>提供时，将打印有关记住的命令的信息。返回状态为零，除非出现<var>name</var>找不到或提供了无效的选项。
</p>
</dd>
<dt><code>pwd</code></dt>
<dd><a name="index-pwd"></a>
<div class="example">
<pre class="example">pwd [-LP]
</pre></div>

<p>打印当前工作目录的绝对路径名。如果<samp>-P</samp>提供选项，打印的路径名将不包含符号链接。如果<samp>-L</samp>提供选项，打印的路径名可能包含符号链接。除非确定当前目录的名称时遇到错误或提供了无效的选项，否则返回状态为零。
</p>
</dd>
<dt><code>readonly</code></dt>
<dd><a name="index-readonly"></a>
<div class="example">
<pre class="example">readonly [-aAf] [-p] [<var>name</var>[=<var>value</var>]] &hellip;
</pre></div>

<p>标记每个<var>name</var>作为只读。这些名称的值可能无法通过后续分配进行更改。如果<samp>-f</samp>提供了选件，每个<var>name</var>指壳函数。的<samp>-a</samp>选项表示每个<var>name</var>引用索引数组变量；的<samp>-A</samp>选项表示每个<var>name</var>指关联数组变量。如果同时提供两个选项， <samp>-A</samp>优先。如果不<var>name</var>给定参数，或者<samp>-p</samp>提供选项，将打印所有只读名称的列表。其他选项可用于将输出限制为只读名称集的子集。的<samp>-p</samp>选项导致输出以可以重新用作输入的格式显示。如果变量名后跟= <var>value</var> ，变量的值设置为<var>value</var> 。除非提供了无效的选项，否则返回状态为零，其中之一是<var>name</var> arguments不是有效的Shell变量或函数名称，或者<samp>-f</samp> option提供的名称不是shell函数。
</p>
</dd>
<dt><code>return</code></dt>
<dd><a name="index-return"></a>
<div class="example">
<pre class="example">return [<var>n</var>]
</pre></div>

<p>使Shell函数停止执行并返回值<var>n</var>给它的呼叫者。如果<var>n</var>如果未提供，则返回值是函数中最后执行的命令的退出状态。如果<code>return</code>由陷阱处理程序执行，最后一个用于确定状态的命令是陷阱处理程序之前执行的最后一个命令。如果<code>return</code>在执行期间<code>DEBUG</code>陷阱，用于确定状态的最后一条命令是陷阱处理程序在执行之前的最后一条命令<code>return</code>被调用。
<code>return</code>也可以用于终止执行脚本时执行<code>.</code> （ <code>source</code> ）内置，返回<var>n</var>或脚本中最后执行的命令的退出状态作为脚本的退出状态。如果<var>n</var>提供后，返回值为其最低有效8位。与<code>RETURN</code>陷阱在函数或脚本之后恢复执行之前执行。返回状态为非零，如果<code>return</code>被提供一个非数字参数或在函数外部使用，而不是在脚本执行期间由<code>.</code>要么<code>source</code> 。
</p>
</dd>
<dt><code>shift</code></dt>
<dd><a name="index-shift"></a>
<div class="example">
<pre class="example">shift [<var>n</var>]
</pre></div>

<p>将位置参数向左移动<var>n</var> 。位置参数来自<var>n</var> +1… <code>$#</code>被重命名为<code>$1</code> … <code>$#</code> -- <var>n</var> 。用数字表示的参数<code>$#</code>至<code>$#</code> -- <var>n</var> +1未设置。
<var>n</var>必须是一个小于或等于的非负数<code>$#</code> 。如果<var>n</var>为零或大于<code>$#</code> ，位置参数不会更改。如果<var>n</var>未提供，则假定为1。返回状态为零，除非<var>n</var>大于<code>$#</code>或小于零，否则为非零。
</p>
</dd>
<dt><code>test</code></dt>
<dt><code>[</code></dt>
<dd><a name="index-test"></a>
<a name="index-_005b"></a>
<div class="example">
<pre class="example">test <var>expr</var>
</pre></div>

<p>评估条件表达式<var>expr</var>并返回状态0（真）或1（假）。每个运算符和操作数必须是一个单独的参数。表达式由下面的<a href="#Bash-Conditional-Expressions">Bash条件表达式</a>中描述的主键组成。
<code>test</code>不接受任何选项，也不接受和忽略<samp>--</samp>表示选项已结束。
</p>
<p>当。。。的时候<code>[</code>使用形式时，命令的最后一个参数必须为<code>]</code> 。
</p>
<p>可以使用以下运算符组合表达式，这些运算符按优先级从高到低的顺序列出。求值取决于参数的数量。见下文。当有五个或更多参数时，使用运算符优先级。
</p>
<dl compact>
<dt><code>! <var>expr</var></code></dt>
<dd><p>如果为真<var>expr</var>是错误的。
</p>
</dd>
<dt><code>( <var>expr</var> )</code></dt>
<dd><p>返回的值<var>expr</var> 。这可用于覆盖运算符的常规优先级。
</p>
</dd>
<dt><code><var>expr1</var> -a <var>expr2</var></code></dt>
<dd><p>如果两者都为真<var>expr1</var>和<var>expr2</var>是真的。
</p>
</dd>
<dt><code><var>expr1</var> -o <var>expr2</var></code></dt>
<dd><p>如果有则为真<var>expr1</var>要么<var>expr2</var>是真的。
</p></dd>
</dl>

<p>的<code>test</code>和<code>[</code>内置函数使用一组基于参数数量的规则来评估条件表达式。
</p>
<dl compact>
<dt>0个参数</dt>
<dd><p>表达式为假。
</p>
</dd>
<dt>1个论点</dt>
<dd><p>当且仅当参数不为null时，表达式才为true。
</p>
</dd>
<dt>2个论点</dt>
<dd><p>如果第一个参数是“ <samp>!</samp> '，且仅当第二个参数为null时，表达式才为true。如果第一个参数是一元条件运算符之一（请参见<a href="#Bash-Conditional-Expressions">Bash条件表达式</a> ），则如果一元检验为true，则表达式为true。如果第一个参数不是有效的一元运算符，则表达式为false。
</p>
</dd>
<dt>3个论点</dt>
<dd><p>以下条件按列出的顺序应用。
</p>
<ol>
<li>如果第二个参数是二进制条件运算符之一（请参阅<a href="#Bash-Conditional-Expressions">Bash条件表达式</a> ），则表达式的结果是使用第一个和第三个参数作为操作数的二进制测试的结果。' <samp>-a</samp> '和' <samp>-o</samp>当有三个参数时，'运算符被视为二进制运算符。
</li><li>如果第一个参数是“ <samp>!</samp> '，该值是使用第二和第三个参数的二参数测试的取反。
</li><li>如果第一个参数正好是“ <samp>(</samp> '，第三个参数恰好是' <samp>)</samp> '，结果是第二个参数的单参数测试。
</li><li>否则，表达式为假。
</li></ol>

</dd>
<dt>4个论点</dt>
<dd><p>如果第一个参数是“ <samp>!</samp> '，结果是由剩余参数组成的三参数表达式的求反。否则，将使用上面列出的规则根据优先级来解析和评估表达式。
</p>
</dd>
<dt>5个或更多参数</dt>
<dd><p>使用上面列出的规则，将根据优先级对表达式进行解析和评估。
</p></dd>
</dl>

<p>当与<code>test</code>要么 ' <samp>[</samp> '，' <samp><</samp> '和' <samp>></samp> '运算符使用ASCII顺序按字典顺序排序。
</p>
</dd>
<dt><code>times</code></dt>
<dd><a name="index-times"></a>
<div class="example">
<pre class="example">times
</pre></div>

<p>打印出外壳及其子级使用的用户和系统时间。返回状态为零。
</p>
</dd>
<dt><code>trap</code></dt>
<dd><a name="index-trap"></a>
<div class="example">
<pre class="example">trap [-lp] [<var>arg</var>] [<var>sigspec</var> &hellip;]
</pre></div>

<p>中的命令<var>arg</var>当shell接收到信号时读取并执行<var>sigspec</var> 。如果<var>arg</var>缺席（只有一个<var>sigspec</var> ）或等于' <samp>-</samp> '，将每个指定信号的配置重置为启动外壳程序时具有的值。如果<var>arg</var>是空字符串，则每个字符串指定的信号<var>sigspec</var>被shell及其调用的命令忽略。如果<var>arg</var>不存在并且<samp>-p</samp>已经提供了，shell显示与每个命令关联的陷阱命令<var>sigspec</var> 。如果未提供任何参数，或仅<samp>-p</samp>给出， <code>trap</code>以可以用作外壳程序输入的形式打印与每个信号号关联的命令列表。的<samp>-l</samp> option使外壳程序输出信号名称及其对应编号的列表。每<var>sigspec</var>是信号名称或信号编号。信号名称不区分大小写，并且<code>SIG</code>前缀是可选的。
</p>
<p>如果一个<var>sigspec</var>是<code>0</code>要么<code>EXIT</code> ， <var>arg</var>在外壳退出时执行。如果一个<var>sigspec</var>是<code>DEBUG</code> ， 命令<var>arg</var>在每个简单命令之前执行， <code>for</code>命令， <code>case</code>命令， <code>select</code>命令，所有算术<code>for</code>命令，并且在shell函数中执行第一个命令之前。请参阅<code>extdebug</code>选项<code>shopt</code>内置（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），以了解其对<code>DEBUG</code>陷阱。如果一个<var>sigspec</var>是<code>RETURN</code> ， 命令<var>arg</var>每次使用shell函数或脚本执行时都会执行<code>.</code>要么<code>source</code> Builtins完成执行。
</p>
<p>如果一个<var>sigspec</var>是<code>ERR</code> ， 命令<var>arg</var>每当满足以下条件时，只要管道（可能由一个简单命令组成），列表或复合命令返回非零退出状态，便会执行。的<code>ERR</code>如果失败的命令是紧随在命令列表之后的命令列表的一部分，则不执行陷阱<code>until</code>要么<code>while</code>关键字，是测试之后的一部分<code>if</code>要么<code>elif</code>保留字，是在<code>&&</code>要么<code>||</code>列出除最后一个命令之后的命令<code>&&</code>要么<code>||</code> ，管道中除最后一条命令之外的任何命令，或者使用<code>!</code> 。这些是相同的条件<code>errexit</code> （ <samp>-e</samp> ） 选项。
</p>
<p>进入外壳时忽略的信号无法捕获或重置。创建一个子外壳或子外壳环境时，不会被忽略的陷印信号会重置为其原始值。
</p>
<p>返回状态为零，除非出现<var>sigspec</var>没有指定有效的信号。
</p>
</dd>
<dt><code>umask</code></dt>
<dd><a name="index-umask"></a>
<div class="example">
<pre class="example">umask [-p] [-S] [<var>mode</var>]
</pre></div>

<p>将外壳程序的文件创建掩码设置为<var>mode</var> 。如果<var>mode</var>以数字开头，它被解释为八进制数字；如果不是，则将其解释为符号模式掩码，类似于<code>chmod</code>命令。如果<var>mode</var>如果省略，将打印掩码的当前值。如果<samp>-S</samp>提供的选件不带<var>mode</var>参数，则掩码以符号格式打印。如果<samp>-p</samp>提供了选件，并且<var>mode</var>如果省略，则输出的形式可以复用为输入。如果成功更改了模式，或者没有更改，则返回状态为零<var>mode</var>提供参数，否则提供非零值。
</p>
<p>请注意，当模式被解释为八进制数时，umask的每个数字都会从中减去<code>7</code> 。因此， <code>022</code>导致获得以下权限<code>755</code> 。
</p>
</dd>
<dt><code>unset</code></dt>
<dd><a name="index-unset"></a>
<div class="example">
<pre class="example">unset [-fnv] [<var>name</var>]
</pre></div>

<p>删除每个变量或函数<var>name</var> 。如果<samp>-v</samp>给出了选项，每个<var>name</var>指的是一个外壳变量，该变量被删除。如果<samp>-f</samp>给定选项， <var>name</var> s引用shell函数，并且删除了函数定义。如果<samp>-n</samp>提供了选件，并且<var>name</var>是带有<var>nameref</var>属性， <var>name</var>将未设置，而不是它引用的变量。
<samp>-n</samp>如果<samp>-f</samp>提供选项。如果未提供任何选件，则每个<var>name</var>指变量；如果该名称没有变量，则未设置任何具有该名称的函数。只读变量和函数可能未设置。返回状态为零，除非出现<var>name</var>是只读的。
</p></dd>
</dl>

<hr>
<a name="Bash-Builtins"></a>
<div class="header">
<p>下一篇： <a href="#Modifying-Shell-Behavior" rel="next" accesskey="n">修改Shell行为</a> ，上一篇： <a href="#Bourne-Shell-Builtins" rel="prev" accesskey="p">Bourne Shell内置文件</a> ，上： <a href="#Shell-Builtin-Commands" rel="up" accesskey="u">Shell内置命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Builtin-Commands"></a>
<h3 class="section">4.2 Bash内置命令</h3>

<p>本节介绍了Bash特有的或已在Bash中扩展的内置命令。其中一些命令在<small>POSIX</small>标准中指定。
</p>
<dl compact>
<dt><code>alias</code></dt>
<dd><a name="index-alias"></a>
<div class="example">
<pre class="example">alias [-p] [<var>name</var>[=<var>value</var>] &hellip;]
</pre></div>

<p>不带参数或带<samp>-p</samp>选项， <code>alias</code>以某种格式将别名打印在标准输出上，以使其可以重复用作输入。如果提供了参数，则为每个参数定义一个别名<var>name</var>谁的<var>value</var>给出。如果不<var>value</var>指定后，将打印别名的名称和值。别名在<a href="#Aliases">别名</a>中描述。
</p>
</dd>
<dt><code>bind</code></dt>
<dd><a name="index-bind"></a>
<div class="example">
<pre class="example">bind [-m <var>keymap</var>] [-lpsvPSVX]
bind [-m <var>keymap</var>] [-q <var>function</var>] [-u <var>function</var>] [-r <var>keyseq</var>]
bind [-m <var>keymap</var>] -f <var>filename</var>
bind [-m <var>keymap</var>] -x <var>keyseq:shell-command</var>
bind [-m <var>keymap</var>] <var>keyseq:function-name</var>
bind [-m <var>keymap</var>] <var>keyseq:readline-command</var>
</pre></div>

<p>显示当前的Readline（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）键和函数绑定，将键序列绑定到Readline函数或宏，或设置Readline变量。每个非选项参数都是一个命令，就像在Readline初始化文件中一样（请参见<a href="#Readline-Init-File">Readline Init File</a> ），但是每个绑定或命令必须作为单独的参数传递；例如，“ <samp>"\C-x\C-r":re-read-init-file</samp> '。
</p>
<p>选件（如果提供）具有以下含义：</p>
<dl compact>
<dt><code>-m <var>keymap</var></code></dt>
<dd><p>使用<var>keymap</var>作为要受后续绑定影响的键映射。可以接受<var>keymap</var>名字是<code>emacs</code> ， <code>emacs-standard</code> ， <code>emacs-meta</code> ， <code>emacs-ctlx</code> ， <code>vi</code> ， <code>vi-move</code> ， <code>vi-command</code>和<code>vi-insert</code> 。
<code>vi</code>相当于<code>vi-command</code> （ <code>vi-move</code>也是同义词）； <code>emacs</code>相当于<code>emacs-standard</code> 。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>列出所有Readline函数的名称。
</p>
</dd>
<dt><code>-p</code></dt>
<dd><p>以可以用作输入或在Readline初始化文件中使用的方式显示Readline函数名称和绑定。
</p>
</dd>
<dt><code>-P</code></dt>
<dd><p>列出当前的Readline函数名称和绑定。
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>显示Readline变量名称和值，使其可以用作输入或在Readline初始化文件中使用。
</p>
</dd>
<dt><code>-V</code></dt>
<dd><p>列出当前的Readline变量名称和值。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>显示绑定到宏的Readline键序列及其输出的字符串，使它们可用作输入或在Readline初始化文件中使用。
</p>
</dd>
<dt><code>-S</code></dt>
<dd><p>显示绑定到宏的Readline键序列及其输出的字符串。
</p>
</dd>
<dt><code>-f <var>filename</var></code></dt>
<dd><p>从读取键绑定<var>filename</var> 。
</p>
</dd>
<dt><code>-q <var>function</var></code></dt>
<dd><p>查询哪些键调用命名的<var>function</var> 。
</p>
</dd>
<dt><code>-u <var>function</var></code></dt>
<dd><p>取消绑定到已命名的所有键<var>function</var> 。
</p>
</dd>
<dt><code>-r <var>keyseq</var></code></dt>
<dd><p>删除任何当前的绑定<var>keyseq</var> 。
</p>
</dd>
<dt><code>-x <var>keyseq:shell-command</var></code></dt>
<dd><p>原因<var>shell-command</var>随时执行<var>keyseq</var>输入。什么时候<var>shell-command</var>执行后，shell将<code>READLINE_LINE</code>变量为Readline行缓冲区和<code>READLINE_POINT</code>变量到插入点的当前位置。如果执行的命令更改了值<code>READLINE_LINE</code>要么<code>READLINE_POINT</code> ，这些新值将反映在编辑状态中。
</p>
</dd>
<dt><code>-X</code></dt>
<dd><p>以可复用为输入的格式列出绑定到shell命令和关联命令的所有键序列。
</p></dd>
</dl>

<p>除非提供了无效的选项或发生错误，否则返回状态为零。
</p>
</dd>
<dt><code>builtin</code></dt>
<dd><a name="index-builtin"></a>
<div class="example">
<pre class="example">builtin [<var>shell-builtin</var> [<var>args</var>]]
</pre></div>

<p>运行内置的shell，并将其传递<var>args</var> ，并返回其退出状态。当定义与外壳程序内置名称相同的外壳程序功能时，这很有用，同时将内置功能保留在该功能内。返回状态为非零，如果<var>shell-builtin</var>不是shell内置命令。
</p>
</dd>
<dt><code>caller</code></dt>
<dd><a name="index-caller"></a>
<div class="example">
<pre class="example">caller [<var>expr</var>]
</pre></div>

<p>返回任何活动子例程调用的上下文（shell函数或使用<code>.</code>要么<code>source</code>内置）。
</p>
<p>不带<var>expr</var> ， <code>caller</code>显示当前子例程调用的行号和源文件名。如果提供非负整数作为<var>expr</var> ， <code>caller</code>显示与当前执行调用堆栈中该位置相对应的行号，子例程名称和源文件。例如，可以使用此额外信息来打印堆栈跟踪。当前帧是帧0。
</p>
<p>除非外壳程序不执行子例程调用，否则返回值为0。 <var>expr</var>不对应于调用堆栈中的有效位置。
</p>
</dd>
<dt><code>command</code></dt>
<dd><a name="index-command"></a>
<div class="example">
<pre class="example">command [-pVv] <var>command</var> [<var>arguments</var> &hellip;]
</pre></div>

<p>运行<var>command</var>与<var>arguments</var>忽略任何名为<var>command</var> 。仅外壳内置命令或通过搜索找到的命令<code>PATH</code>被执行。如果有一个名为<code>ls</code> ，运行“ <samp>command ls</samp>函数中的'将执行外部命令<code>ls</code>而不是递归地调用该函数。的<samp>-p</samp>选项表示将默认值用于<code>PATH</code>这样可以保证找到所有标准实用程序。在这种情况下，返回状态为127 <var>command</var>找不到或发生错误，并且退出状态为<var>command</var>除此以外。
</p>
<p>如果有<samp>-V</samp>要么<samp>-v</samp>提供了选件，对<var>command</var>打印。的<samp>-v</samp>选项导致一个单词，指示用于调用的命令或文件名<var>command</var>显示；的<samp>-V</samp>选项产生更详细的描述。在这种情况下，如果<var>command</var>被找到，如果没有则为非零。
</p>
</dd>
<dt><code>declare</code></dt>
<dd><a name="index-declare"></a>
<div class="example">
<pre class="example">declare [-aAfFgilnrtux] [-p] [<var>name</var>[=<var>value</var>] &hellip;]
</pre></div>

<p>声明变量并为其赋予属性。如果不<var>name</var>给出，然后显示变量的值。
</p>
<p>的<samp>-p</samp>选项将显示每个属性和值<var>name</var> 。什么时候<samp>-p</samp>用于<var>name</var>参数，其他选项，除<samp>-f</samp>和<samp>-F</samp> ，将被忽略。
</p>
<p>什么时候<samp>-p</samp>没有提供<var>name</var>论据<code>declare</code>将显示具有由附加选项指定的属性的所有变量的属性和值。如果没有附带其他选项<samp>-p</samp> ， <code>declare</code>将显示所有外壳变量的属性和值。的<samp>-f</samp>选项将显示限制为外壳函数。
</p>
<p>的<samp>-F</samp>选项禁止显示功能定义；仅打印函数名称和属性。如果<code>extdebug</code>使用以下命令启用shell选项<code>shopt</code> （请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），每个文件的源文件名和行号<var>name</var>也将显示定义。
<samp>-F</samp>暗示<samp>-f</samp> 。
</p>
<p>的<samp>-g</samp>该选项强制在全局范围内创建或修改变量，即使在<code>declare</code>在shell函数中执行。在所有其他情况下，它将被忽略。
</p>
<p>以下选项可用于将输出限制为具有指定属性的变量或为变量提供属性：</p>
<dl compact>
<dt><code>-a</code></dt>
<dd><p>每<var>name</var>是一个索引数组变量（请参见<a href="#Arrays">Arrays</a> ）。
</p>
</dd>
<dt><code>-A</code></dt>
<dd><p>每<var>name</var>是一个关联数组变量（请参见<a href="#Arrays">Arrays</a> ）。
</p>
</dd>
<dt><code>-f</code></dt>
<dd><p>仅使用函数名称。
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>该变量将被视为整数；给变量赋值时，将执行算术评估（请参阅<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>为变量分配值后，所有大写字符都将转换为小写。大写属性被禁用。
</p>
</dd>
<dt><code>-n</code></dt>
<dd><p>给每个<var>name</var>的<var>nameref</var>属性，使其成为对另一个变量的名称引用。该其他变量由的值定义<var>name</var> 。对以下内容的所有引用，分配和属性修改<var>name</var> ，但那些使用或更改<samp>-n</samp>属性本身，是对引用的变量执行<var>name</var>的价值。nameref属性不能应用于数组变量。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>使<var>name</var> s只读。然后，这些名称不能通过后续的赋值语句来赋值或取消设置。
</p>
</dd>
<dt><code>-t</code></dt>
<dd><p>给每个<var>name</var>的<code>trace</code>属性。跟踪函数继承<code>DEBUG</code>和<code>RETURN</code>从调用外壳捕获陷阱。trace属性对变量没有特殊含义。
</p>
</dd>
<dt><code>-u</code></dt>
<dd><p>为变量分配值后，所有小写字符都将转换为大写。小写属性已禁用。
</p>
</dd>
<dt><code>-x</code></dt>
<dd><p>标记每个<var>name</var>用于通过环境导出到后续命令。
</p></dd>
</dl>

<p>使用“ <samp>+</samp> ' 代替 ' <samp>-</samp> '而是关闭属性，但以下情况除外： <samp>+a</samp> '和' <samp>+A</samp> '可能无法用于销毁数组变量，并且' <samp>+r</samp> '不会删除readonly属性。在功能中使用时， <code>declare</code>使每个<var>name</var>本地的，就像<code>local</code>命令，除非<samp>-g</samp>使用选项。如果变量名后跟= <var>value</var> ，变量的值设置为<var>value</var> 。
</p>
<p>使用时<samp>-a</samp>要么<samp>-A</samp>以及用于创建数组变量的复合赋值语法，其他属性直到后续赋值才生效。
</p>
<p>除非遇到无效的选项，否则返回状态为零，尝试使用' <samp>-f foo=bar</samp> '，尝试将值分配给只读变量，尝试将值分配给数组变量，而不使用复合分配语法（请参见<a href="#Arrays">Arrays</a> ）， <var>names</var>不是有效的Shell变量名称，试图关闭只读变量的只读状态，试图关闭数组变量的阵列状态或试图显示不存在的函数以及<samp>-f</samp> 。
</p>
</dd>
<dt><code>echo</code></dt>
<dd><a name="index-echo"></a>
<div class="example">
<pre class="example">echo [-neE] [<var>arg</var> &hellip;]
</pre></div>

<p>输出<var>arg</var> s，以空格分隔，以换行符终止。除非发生写入错误，否则返回状态为0。如果<samp>-n</samp>指定时，尾随换行符被取消。如果<samp>-e</samp>给定选项，将启用对以下反斜杠转义字符的解释。的<samp>-E</samp>选项禁用对这些转义符的解释，即使在默认情况下对它们进行解释的系统上也是如此。的<code>xpg_echo</code> shell选项可用于动态确定是否<code>echo</code>默认情况下扩展这些转义字符。
<code>echo</code>不解释<samp>--</samp>意味着选择权的终结。
</p>
<p><code>echo</code>解释以下转义序列：</p><dl compact>
<dt><code>\a</code></dt>
<dd><p>警觉</p></dd>
<dt><code>\b</code></dt>
<dd><p>退格键</p></dd>
<dt><code>\c</code></dt>
<dd><p>抑制进一步的输出</p></dd>
<dt><code>\e</code></dt>
<dt><code>\E</code></dt>
<dd><p>逃逸</p></dd>
<dt><code>\f</code></dt>
<dd><p>换页</p></dd>
<dt><code>\n</code></dt>
<dd><p>新队</p></dd>
<dt><code>\r</code></dt>
<dd><p>回车</p></dd>
<dt><code>\t</code></dt>
<dd><p>水平标签</p></dd>
<dt><code>\v</code></dt>
<dd><p>垂直标签</p></dd>
<dt><code>\\</code></dt>
<dd><p>反斜杠</p></dd>
<dt><code>\0<var>nnn</var></code></dt>
<dd><p>八位字符，其值为八进制值<var>nnn</var> （零到三个八进制数字）</p></dd>
<dt><code>\x<var>HH</var></code></dt>
<dd><p>八位字符，其值为十六进制值<var>HH</var> （一个或两个十六进制数字）</p></dd>
<dt><code>\u<var>HHHH</var></code></dt>
<dd><p>Unicode（ISO / IEC 10646）字符，其值为十六进制值<var>HHHH</var> （一到四个十六进制数字）</p></dd>
<dt><code>\U<var>HHHHHHHH</var></code></dt>
<dd><p>Unicode（ISO / IEC 10646）字符，其值为十六进制值<var>HHHHHHHH</var> （1到8个十六进制数字）</p></dd>
</dl>

</dd>
<dt><code>enable</code></dt>
<dd><a name="index-enable"></a>
<div class="example">
<pre class="example">enable [-a] [-dnps] [-f <var>filename</var>] [<var>name</var> &hellip;]
</pre></div>

<p>启用和禁用内置的shell命令。禁用内置命令后，即使外壳程序通常在磁盘命令之前搜索内置程序，也可以在不指定完整路径名的情况下执行与外壳程序内置程序名称相同的磁盘命令。如果<samp>-n</samp>使用， <var>name</var>被禁用。除此以外<var>name</var>已启用。例如，使用<code>test</code>通过找到二进制文件<code>$PATH</code>而不是Shell内置版本，请输入' <samp>enable -n test</samp> '。
</p>
<p>如果<samp>-p</samp>提供选件，否则<var>name</var>出现参数时，将输出shell内置列表。没有其他参数，该列表由所有启用的Shell内置程序组成。的<samp>-a</samp>选项意味着列出每个内置功能，并指示是否启用了该功能。
</p>
<p>的<samp>-f</samp>选项意味着加载新的内置命令<var>name</var>来自共享对象<var>filename</var>在支持动态加载的系统上。的<samp>-d</samp>选项将删除加载了<samp>-f</samp> 。
</p>
<p>如果没有选项，则会显示shell内置列表。的<samp>-s</samp>选项限制<code>enable</code> <small>POSIX</small>特殊内置<small>函数</small> 。如果<samp>-s</samp>用于<samp>-f</samp> ，新的内置变量将成为特殊的内置变量（请参见<a href="#Special-Builtins">Special Builtins</a> ）。
</p>
<p>返回状态为零，除非出现<var>name</var>不是内置的Shell，或者从共享库加载新的内置错误。
</p>
</dd>
<dt><code>help</code></dt>
<dd><a name="index-help"></a>
<div class="example">
<pre class="example">help [-dms] [<var>pattern</var>]
</pre></div>

<p>显示有关内置命令的有用信息。如果<var>pattern</var>被指定<code>help</code>提供所有匹配命令的详细帮助<var>pattern</var> ，否则将打印出内置列表。
</p>
<p>选件（如果提供）具有以下含义：</p>
<dl compact>
<dt><code>-d</code></dt>
<dd><p>显示每个的简短描述<var>pattern</var>
</p></dd>
<dt><code>-m</code></dt>
<dd><p>显示每个的描述<var>pattern</var>以类似手册页的格式</p></dd>
<dt><code>-s</code></dt>
<dd><p>仅显示每个的简短使用提要<var>pattern</var>
</p></dd>
</dl>

<p>除非没有命令匹配，否则返回状态为零<var>pattern</var> 。
</p>
</dd>
<dt><code>let</code></dt>
<dd><a name="index-let"></a>
<div class="example">
<pre class="example">let <var>expression</var> [<var>expression</var> &hellip;]
</pre></div>

<p>的<code>let</code>内置允许对shell变量执行算术运算。每<var>expression</var>根据下面的<a href="#Shell-Arithmetic">Shell Arithmetic中</a>给出的规则进行评估。如果最后<var>expression</var>评估为0， <code>let</code>返回1；否则返回0。
</p>
</dd>
<dt><code>local</code></dt>
<dd><a name="index-local"></a>
<div class="example">
<pre class="example">local [<var>option</var>] <var>name</var>[=<var>value</var>] &hellip;
</pre></div>

<p>对于每个参数，一个名为<var>name</var>创建并分配<var>value</var> 。的<var>option</var>可以是被接受的任何选项<code>declare</code> 。
<code>local</code>只能在一个函数内使用；它使变量<var>name</var>具有仅限于该功能及其子功能的可见范围。如果<var>name</var>是' <samp>-</samp> '，则将shell选项集本地化为<code>local</code>被调用：使用<code>set</code>当函数返回时，函数内部的内置函数将恢复为其原始值。返回状态为零，除非<code>local</code>在函数外部使用，无效<var>name</var>提供，或<var>name</var>是一个只读变量。
</p>
</dd>
<dt><code>logout</code></dt>
<dd><a name="index-logout"></a>
<div class="example">
<pre class="example">logout [<var>n</var>]
</pre></div>

<p>退出登录shell，返回状态<var>n</var>到外壳的父级。
</p>
</dd>
<dt><code>mapfile</code></dt>
<dd><a name="index-mapfile"></a>
<div class="example">
<pre class="example">mapfile [-d <var>delim</var>] [-n <var>count</var>] [-O <var>origin</var>] [-s <var>count</var>]
    [-t] [-u <var>fd</var>] [-C <var>callback</var>] [-c <var>quantum</var>] [<var>array</var>]
</pre></div>

<p>从标准输入读取行到索引数组变量<var>array</var> ，或来自文件描述符<var>fd</var>如果<samp>-u</samp>提供选项。变量<code>MAPFILE</code>是默认值<var>array</var> 。选件（如果提供）具有以下含义：</p>
<dl compact>
<dt><code>-d</code></dt>
<dd><p>的第一个字符<var>delim</var>用于终止每个输入行，而不是换行符。如果<var>delim</var>是空字符串， <code>mapfile</code>读取NUL字符时将终止一行。
</p></dd>
<dt><code>-n</code></dt>
<dd><p>最多复制<var>count</var>线。如果<var>count</var>为0，将复制所有行。
</p></dd>
<dt><code>-O</code></dt>
<dd><p>开始分配给<var>array</var>在索引<var>origin</var> 。默认索引为0。
</p></dd>
<dt><code>-s</code></dt>
<dd><p>丢弃第一个<var>count</var>行读。
</p></dd>
<dt><code>-t</code></dt>
<dd><p>删除尾随<var>delim</var> （默认换行符）从每行读取。
</p></dd>
<dt><code>-u</code></dt>
<dd><p>从文件描述符读取行<var>fd</var>而不是标准输入。
</p></dd>
<dt><code>-C</code></dt>
<dd><p>评估<var>callback</var>每一次<var>quantum</var>读取行。的<samp>-c</samp>选项指定<var>quantum</var> 。
</p></dd>
<dt><code>-c</code></dt>
<dd><p>指定每次调用之间读取的行数<var>callback</var> 。
</p></dd>
</dl>

<p>如果<samp>-C</samp>指定不带<samp>-c</samp> ，默认数量是5000。什么时候<var>callback</var>被评估时，将提供要分配的下一个数组元素的索引以及要分配给该元素的行作为其他参数。
<var>callback</var>在读取行之后但在分配数组元素之前进行求值。
</p>
<p>如果未提供明确的来源， <code>mapfile</code>会清除<var>array</var>分配给它之前。
</p>
<p><code>mapfile</code>成功返回，除非提供了无效的选项或选项参数， <var>array</var>无效或不可分配，或<var>array</var>不是索引数组。
</p>
</dd>
<dt><code>printf</code></dt>
<dd><a name="index-printf"></a>
<div class="example">
<pre class="example">printf [-v <var>var</var>] <var>format</var> [<var>arguments</var>]
</pre></div>

<p>写格式化<var>arguments</var>到标准输出的控制下<var>format</var> 。的<samp>-v</samp>选项导致将输出分配给变量<var>var</var>而不是打印到标准输出。
</p>
<p>的<var>format</var>是包含三个类型的对象的字符串：简单字符（简单地复制到标准输出中），字符转义序列（转换并复制到标准输出中）以及格式规范，每种格式都会导致下一个连续的打印<var>argument</var> 。除了标准<code>printf(1)</code>格式， <code>printf</code>解释以下扩展名：</p>
<dl compact>
<dt><code>%b</code></dt>
<dd><p>原因<code>printf</code>在相应的位置扩展反斜杠转义序列<var>argument</var>在相同的方式<code>echo -e</code> （请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。
</p></dd>
<dt><code>%q</code></dt>
<dd><p>原因<code>printf</code>输出相应的<var>argument</var>以一种可以作为shell输入重用的格式。
</p></dd>
<dt><code>%(<var>datefmt</var>)T</code></dt>
<dd><p>原因<code>printf</code>输出使用产生的日期时间字符串<var>datefmt</var>作为以下内容的格式字符串<code>strftime</code> （3）。相应的<var>argument</var>是一个整数，表示自纪元以来的秒数。可以使用两个特殊的参数值：-1表示当前时间，-2表示调用Shell的时间。如果未指定任何参数，则转换的行为就像已给出-1。这是通常的例外<code>printf</code>行为。
</p></dd>
</dl>

<p>非字符串格式说明符的参数被视为C语言常量，但允许使用前导加号或减号，并且如果前导字符是单引号或双引号，则该值是后继字符的ASCII值。
</p>
<p>的<var>format</var>根据需要重复使用以消耗所有<var>arguments</var> 。如果<var>format</var>需要更多<var>arguments</var>如果超过所提供的值，则多余的格式规范的行为就好像已经提供了零值或空字符串一样。成功时返回值为零，失败时返回非零。
</p>
</dd>
<dt><code>read</code></dt>
<dd><a name="index-read"></a>
<div class="example">
<pre class="example">read [-ers] [-a <var>aname</var>] [-d <var>delim</var>] [-i <var>text</var>] [-n <var>nchars</var>]
    [-N <var>nchars</var>] [-p <var>prompt</var>] [-t <var>timeout</var>] [-u <var>fd</var>] [<var>name</var> &hellip;]
</pre></div>

<p>从标准输入或文件描述符中读取一行<var>fd</var>作为参数提供给<samp>-u</samp>选项，如上文“ <a href="#Word-Splitting">单词拆分”中</a>所述拆分为单词，然后将第一个单词分配给第一个单词<var>name</var> ，第二个字到第二个<var>name</var> ， 等等。如果单词比名称多，则其余单词及其中间的分隔符将分配给最后一个<var>name</var> 。如果从输入流中读取的单词少于名称，则为其余名称分配空值。值中的字符<code>IFS</code>变量用于使用外壳程序用于扩展的相同规则将行拆分为单词（以上在<a href="#Word-Splitting">Word Splitting中进行了介绍</a> ）。反斜杠字符“ <samp>\</samp> '可以用于删除下一个读取字符和换行的任何特殊含义。如果未提供名称，则将读取的行分配给变量<code>REPLY</code> 。退出状态为零，除非遇到文件结尾， <code>read</code>超时（在这种情况下，状态大于128），发生变量分配错误（例如，分配给只读变量），或者提供了无效的文件描述符作为参数给<samp>-u</samp> 。
</p>
<p>选件（如果提供）具有以下含义：</p>
<dl compact>
<dt><code>-a <var>aname</var></code></dt>
<dd><p>单词被分配给数组变量的顺序索引<var>aname</var> ，从0开始。从中删除所有元素<var>aname</var>在分配之前。其他<var>name</var>参数将被忽略。
</p>
</dd>
<dt><code>-d <var>delim</var></code></dt>
<dd><p>的第一个字符<var>delim</var>用于终止输入行，而不是换行符。如果<var>delim</var>是空字符串， <code>read</code>读取NUL字符时将终止一行。
</p>
</dd>
<dt><code>-e</code></dt>
<dd><p>Readline（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）用于获取该行。Readline使用当前（或默认，如果以前未进行行编辑）编辑设置，但使用Readline的默认文件名补全。
</p>
</dd>
<dt><code>-i <var>text</var></code></dt>
<dd><p>如果使用Readline读取该行， <var>text</var>在开始编辑之前将其放入编辑缓冲区。
</p>
</dd>
<dt><code>-n <var>nchars</var></code></dt>
<dd><p><code>read</code>阅读后返回<var>nchars</var>字符，而不是等待完整的输入行，但如果少于<var>nchars</var>在定界符之前读取字符。
</p>
</dd>
<dt><code>-N <var>nchars</var></code></dt>
<dd><p><code>read</code>完全阅读后返回<var>nchars</var>字符，而不是等待完整的输入行，除非遇到EOF或<code>read</code>超时。输入中遇到的定界符字符不会得到特别处理，不会导致<code>read</code>返回直到<var>nchars</var>读取字符。结果不按<code>IFS</code> ;目的是为变量分配准确的读取字符（反斜杠除外；请参见<samp>-r</samp>下面的选项）。
</p>
</dd>
<dt><code>-p <var>prompt</var></code></dt>
<dd><p>显示<var>prompt</var> ，而不要在结尾加上换行符，然后再尝试读取任何输入。仅当输入来自终端时才显示提示。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>如果指定了此选项，则反斜杠不会充当转义字符。反斜杠被认为是该行的一部分。特别是，反斜杠-换行符对然后不能用作行继续。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>静音模式。如果输入来自终端，则不会回显字符。
</p>
</dd>
<dt><code>-t <var>timeout</var></code></dt>
<dd><p>原因<code>read</code>如果未读完整行输入（或指定数量的字符），则会超时并返回失败<var>timeout</var>秒。
<var>timeout</var>可以是一个十进制数字，小数点后面是小数部分。该选项仅在以下情况下有效<code>read</code>正在从终端，管道或其他特殊文件读取输入；从常规文件读取时无效。如果<code>read</code>超时， <code>read</code>将读取的任何部分输入保存到指定变量中<var>name</var> 。如果<var>timeout</var>是0 <code>read</code>立即返回，而无需尝试读取和数据。如果输入在指定的文件描述符上可用，则退出状态为0，否则为非零。如果超时，则退出状态大于128。
</p>
</dd>
<dt><code>-u <var>fd</var></code></dt>
<dd><p>从文件描述符读取输入<var>fd</var> 。
</p></dd>
</dl>

</dd>
<dt><code>readarray</code></dt>
<dd><a name="index-readarray"></a>
<div class="example">
<pre class="example">readarray [-d <var>delim</var>] [-n <var>count</var>] [-O <var>origin</var>] [-s <var>count</var>]
    [-t] [-u <var>fd</var>] [-C <var>callback</var>] [-c <var>quantum</var>] [<var>array</var>]
</pre></div>

<p>从标准输入读取行到索引数组变量<var>array</var> ，或来自文件描述符<var>fd</var>如果<samp>-u</samp>提供选项。
</p>
<p>的同义词<code>mapfile</code> 。
</p>
</dd>
<dt><code>source</code></dt>
<dd><a name="index-source"></a>
<div class="example">
<pre class="example">source <var>filename</var>
</pre></div>

<p>的同义词<code>.</code> （请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。
</p>
</dd>
<dt><code>type</code></dt>
<dd><a name="index-type"></a>
<div class="example">
<pre class="example">type [-afptP] [<var>name</var> &hellip;]
</pre></div>

<p>对于每个<var>name</var> ，指示如果用作命令名将如何解释它。
</p>
<p>如果<samp>-t</samp>使用选项<code>type</code>打印一个单词，它是“ <samp>alias</samp> '，' <samp>function</samp> '，' <samp>builtin</samp> '，' <samp>file</samp> ' 要么 ' <samp>keyword</samp> '，如果<var>name</var>是别名，shell函数，shell内置文件，磁盘文件或shell保留字。如果<var>name</var>找不到，则什么也不会打印，并且<code>type</code>返回失败状态。
</p>
<p>如果<samp>-p</samp>使用选项<code>type</code>要么返回将要执行的磁盘文件的名称，要么返回<samp>-t</samp>不会返回' <samp>file</samp> '。
</p>
<p>的<samp>-P</samp>选项强制为每个路径搜索<var>name</var> ， 即使<samp>-t</samp>不会返回' <samp>file</samp> '。
</p>
<p>如果命令被散列， <samp>-p</samp>和<samp>-P</samp>打印哈希值，不一定是第一个出现的文件<code>$PATH</code> 。
</p>
<p>如果<samp>-a</samp>使用选项<code>type</code>返回包含名为可执行文件的所有位置<var>file</var> 。仅当且仅当<samp>-p</samp>选项也没有使用。
</p>
<p>如果<samp>-f</samp>使用选项<code>type</code>不会像<code>command</code>内置的。
</p>
<p>如果所有<var>names</var>找到，非零（如果没有找到）。
</p>
</dd>
<dt><code>typeset</code></dt>
<dd><a name="index-typeset"></a>
<div class="example">
<pre class="example">typeset [-afFgrxilnrtux] [-p] [<var>name</var>[=<var>value</var>] &hellip;]
</pre></div>

<p>的<code>typeset</code>提供了与Korn shell兼容的命令。它是<code>declare</code>内置命令。
</p>
</dd>
<dt><code>ulimit</code></dt>
<dd><a name="index-ulimit"></a>
<div class="example">
<pre class="example">ulimit [-HSabcdefiklmnpqrstuvxPT] [<var>limit</var>]
</pre></div>

<p><code>ulimit</code>在允许进行此类控制的系统上，对由Shell启动的进程可用的资源进行控制。如果给出了一个选项，则解释如下：</p>
<dl compact>
<dt><code>-S</code></dt>
<dd><p>更改并报告与资源关联的软限制。
</p>
</dd>
<dt><code>-H</code></dt>
<dd><p>更改并报告与资源关联的硬限制。
</p>
</dd>
<dt><code>-a</code></dt>
<dd><p>报告所有当前极限。
</p>
</dd>
<dt><code>-b</code></dt>
<dd><p>最大套接字缓冲区大小。
</p>
</dd>
<dt><code>-c</code></dt>
<dd><p>创建的核心文件的最大大小。
</p>
</dd>
<dt><code>-d</code></dt>
<dd><p>流程数据段的最大大小。
</p>
</dd>
<dt><code>-e</code></dt>
<dd><p>最大调度优先级（“ nice”）。
</p>
</dd>
<dt><code>-f</code></dt>
<dd><p>Shell及其子级写入的最大文件大小。
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>未决信号的最大数量。
</p>
</dd>
<dt><code>-k</code></dt>
<dd><p>可以分配的最大队列数。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>可以锁定到内存的最大大小。
</p>
</dd>
<dt><code>-m</code></dt>
<dd><p>最大居民集大小（许多系统不遵守此限制）。
</p>
</dd>
<dt><code>-n</code></dt>
<dd><p>打开文件描述符的最大数量（大多数系统不允许设置此值）。
</p>
</dd>
<dt><code>-p</code></dt>
<dd><p>管道缓冲区大小。
</p>
</dd>
<dt><code>-q</code></dt>
<dd><p>POSIX消息队列中的最大字节数。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>最大实时调度优先级。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>最大堆栈大小。
</p>
</dd>
<dt><code>-t</code></dt>
<dd><p>CPU的最大时间（以秒为单位）。
</p>
</dd>
<dt><code>-u</code></dt>
<dd><p>单个用户可用的最大进程数。
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>可用于外壳以及在某些系统上可用于其子组件的最大虚拟内存量。
</p>
</dd>
<dt><code>-x</code></dt>
<dd><p>文件锁的最大数量。
</p>
</dd>
<dt><code>-P</code></dt>
<dd><p>伪终端的最大数量。
</p>
</dd>
<dt><code>-T</code></dt>
<dd><p>最大线程数。
</p></dd>
</dl>

<p>如果<var>limit</var>被给予，并且<samp>-a</samp>选项未使用， <var>limit</var>是指定资源的新值。特别的<var>limit</var>价值观<code>hard</code> ， <code>soft</code>和<code>unlimited</code>分别代表当前硬限制，当前软限制和无限制。设置硬限制后，非root用户就无法增加硬限制。软限制可以增加到硬限制的值。否则，将打印指定资源的软限制的当前值，除非<samp>-H</samp>提供选项。设置新限制时，如果都不<samp>-H</samp>也不<samp>-S</samp>提供时，硬性和软性限制均已设置。如果没有选择，则<samp>-f</samp>假设。值以1024字节为增量，除了<samp>-t</samp> ，以秒为单位； <samp>-p</samp> ，以512字节块为单位； <samp>-P</samp> ， <samp>-T</samp> ， <samp>-b</samp> ， <samp>-k</samp> ， <samp>-n</samp>和<samp>-u</samp> ，它们是未缩放的值；并且，在<small>POSIX</small>模式下（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）， <samp>-c</samp>和<samp>-f</samp> ，以512字节为增量。
</p>
<p>除非提供了无效的选项或参数，否则返回状态为零，或者在设置新的限制时发生错误。
</p>
</dd>
<dt><code>unalias</code></dt>
<dd><a name="index-unalias"></a>
<div class="example">
<pre class="example">unalias [-a] [<var>name</var> &hellip; ]
</pre></div>

<p>删除每个<var>name</var>从别名列表中。如果<samp>-a</samp>提供时，将删除所有别名。别名在<a href="#Aliases">别名</a>中描述。
</p></dd>
</dl>

<hr>
<a name="Modifying-Shell-Behavior"></a>
<div class="header">
<p>下一篇： <a href="#Special-Builtins" rel="next" accesskey="n">特殊内置程序</a> ，上一篇： <a href="#Bash-Builtins" rel="prev" accesskey="p">Bash内置程序</a> ，上： <a href="#Shell-Builtin-Commands" rel="up" accesskey="u">Shell内置命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Modifying-Shell-Behavior-1"></a>
<h3 class="section">4.3修改Shell行为</h3>
 
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#The-Set-Builtin" accesskey="1">内置集合</a> ：</td><td>  </td><td align="left" valign="top">更改壳属性和位置参数的值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#The-Shopt-Builtin" accesskey="2">内置Shopt</a> ：</td><td>  </td><td align="left" valign="top">修改外壳程序的可选行为。
</td></tr>
</tbody></table>

<hr>
<a name="The-Set-Builtin"></a>
<div class="header">
<p>下一页： <a href="#The-Shopt-Builtin" rel="next" accesskey="n">内置的Shopt</a> ，向上： <a href="#Modifying-Shell-Behavior" rel="up" accesskey="u">修改Shell行为</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Set-Builtin-1"></a>
<h4 class="subsection">4.3.1内置集合</h4>

<p>这个内建函数是如此复杂，以至于它自己的部分。<code>set</code>允许您更改壳选项的值并设置位置参数，或显示壳变量的名称和值。
</p>
<dl compact>
<dt><code>set</code></dt>
<dd><a name="index-set"></a>
<div class="example">
<pre class="example">set [--abefhkmnptuvxBCEHPT] [-o <var>option-name</var>] [<var>argument</var> &hellip;]
set [+abefhkmnptuvxBCEHPT] [+o <var>option-name</var>] [<var>argument</var> &hellip;]
</pre></div>

<p>如果没有提供选项或参数， <code>set</code>显示所有shell变量和函数的名称和值（根据当前语言环境排序），其格式可以复用为设置或重置当前设置的变量的输入。只读变量无法重置。在<small>POSIX</small>模式下，仅列出shell变量。
</p>
<p>提供选项时，它们会设置或取消设置外壳程序属性。选项（如果指定）具有以下含义：</p>
<dl compact>
<dt><code>-a</code></dt>
<dd><p>创建或修改的每个变量或函数都具有导出属性，并标记为导出到后续命令的环境。
</p>
</dd>
<dt><code>-b</code></dt>
<dd><p>导致立即报告终止的后台作业的状态，而不是在打印下一个主要提示之前。
</p>
</dd>
<dt><code>-e</code></dt>
<dd><p>如果可能由单个简单命令（请参见<a href="#Simple-Commands">Simple Commands</a> ），列表（请参见<a href="#Lists">Lists</a> ）或复合命令（请参见<a href="#Compound-Commands">Composite Commands</a> ）组成的管道（请参见<a href="#Pipelines">Pipelines</a> ）返回非零状态，则立即退出。如果失败的命令是紧随在命令之后的命令列表的一部分，则外壳程序不会退出<code>while</code>要么<code>until</code>关键字，是<code>if</code>语句，是在<code>&&</code>要么<code>||</code>列出除最后一个命令之后的命令<code>&&</code>要么<code>||</code> ，管道中除最后一条命令之外的任何命令，或者该命令的返回状态正与<code>!</code> 。如果除子shell以外的复合命令返回非零状态，因为该命令在<samp>-e</samp>被忽略，外壳不会退出。陷阱<code>ERR</code> （如果已设置）在外壳退出之前执行。
</p>
<p>此选项分别适用于Shell环境和每个子Shell环境（请参见<a href="#Command-Execution-Environment">Command Execution Environment</a> ），并且可能导致子Shell在执行子Shell中的所有命令之前退出。
</p>
<p>如果复合命令或shell函数在以下环境中执行<samp>-e</samp>被忽略时，复合命令或函数体内执行的所有命令均不会受到<samp>-e</samp>设置，即使<samp>-e</samp>设置并且命令返回失败状态。如果有复合命令或外壳函数设置<samp>-e</samp>在上下文中执行时<samp>-e</samp>如果忽略该设置，则在复合命令或包含函数调用的命令完成之前，该设置将无效。
</p>
</dd>
<dt><code>-f</code></dt>
<dd><p>禁用文件名扩展（globbing）。
</p>
</dd>
<dt><code>-h</code></dt>
<dd><p>查找并记住（哈希）命令，以查找它们以执行。默认情况下启用此选项。
</p>
</dd>
<dt><code>-k</code></dt>
<dd><p>所有赋值语句形式的参数都放置在命令环境中，而不仅仅是命令名称之前的参数。
</p>
</dd>
<dt><code>-m</code></dt>
<dd><p>作业控制已启用（请参阅<a href="#Job-Control">作业控制</a> ）。所有进程都在单独的进程组中运行。后台作业完成后，shell将打印包含其退出状态的行。
</p>
</dd>
<dt><code>-n</code></dt>
<dd><p>读取命令但不执行。这可以用于检查脚本中的语法错误。交互式外壳程序将忽略此选项。
</p>
</dd>
<dt><code>-o <var>option-name</var></code></dt>
<dd>
<p>设置对应的选项<var>option-name</var> ：</p>
<dl compact>
<dt><code>allexport</code></dt>
<dd><p>和...一样<code>-a</code> 。
</p>
</dd>
<dt><code>braceexpand</code></dt>
<dd><p>和...一样<code>-B</code> 。
</p>
</dd>
<dt><code>emacs</code></dt>
<dd><p>使用<code>emacs</code>样式的行编辑界面（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）。这也会影响用于<code>read -e</code> 。
</p>
</dd>
<dt><code>errexit</code></dt>
<dd><p>和...一样<code>-e</code> 。
</p>
</dd>
<dt><code>errtrace</code></dt>
<dd><p>和...一样<code>-E</code> 。
</p>
</dd>
<dt><code>functrace</code></dt>
<dd><p>和...一样<code>-T</code> 。
</p>
</dd>
<dt><code>hashall</code></dt>
<dd><p>和...一样<code>-h</code> 。
</p>
</dd>
<dt><code>histexpand</code></dt>
<dd><p>和...一样<code>-H</code> 。
</p>
</dd>
<dt><code>history</code></dt>
<dd><p>启用命令历史记录，如<a href="#Bash-History-Facilities">Bash History Facilities中所述</a> 。默认情况下，此选项在交互式shell中处于启用状态。
</p>
</dd>
<dt><code>ignoreeof</code></dt>
<dd><p>读取EOF时，交互式外壳将不会退出。</p>
</dd>
<dt><code>keyword</code></dt>
<dd><p>和...一样<code>-k</code> 。
</p>
</dd>
<dt><code>monitor</code></dt>
<dd><p>和...一样<code>-m</code> 。
</p>
</dd>
<dt><code>noclobber</code></dt>
<dd><p>和...一样<code>-C</code> 。
</p>
</dd>
<dt><code>noexec</code></dt>
<dd><p>和...一样<code>-n</code> 。
</p>
</dd>
<dt><code>noglob</code></dt>
<dd><p>和...一样<code>-f</code> 。
</p>
</dd>
<dt><code>nolog</code></dt>
<dd><p>目前被忽略。
</p>
</dd>
<dt><code>notify</code></dt>
<dd><p>和...一样<code>-b</code> 。
</p>
</dd>
<dt><code>nounset</code></dt>
<dd><p>和...一样<code>-u</code> 。
</p>
</dd>
<dt><code>onecmd</code></dt>
<dd><p>和...一样<code>-t</code> 。
</p>
</dd>
<dt><code>physical</code></dt>
<dd><p>和...一样<code>-P</code> 。
</p>
</dd>
<dt><code>pipefail</code></dt>
<dd><p>如果设置，则管道的返回值是以非零状态退出的最后一个（最右边）命令的值，如果管道中的所有命令成功退出，则返回零。默认情况下禁用此选项。
</p>
</dd>
<dt><code>posix</code></dt>
<dd><p>更改默认操作与<small>POSIX</small>标准不同的Bash行为以使其符合标准（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）。这旨在使Bash成为该标准的严格超集。
</p>
</dd>
<dt><code>privileged</code></dt>
<dd><p>和...一样<code>-p</code> 。
</p>
</dd>
<dt><code>verbose</code></dt>
<dd><p>和...一样<code>-v</code> 。
</p>
</dd>
<dt><code>vi</code></dt>
<dd><p>用一个<code>vi</code>样式的线编辑界面。这也会影响用于<code>read -e</code> 。
</p>
</dd>
<dt><code>xtrace</code></dt>
<dd><p>和...一样<code>-x</code> 。
</p></dd>
</dl>

</dd>
<dt><code>-p</code></dt>
<dd><p>打开特权模式。在此模式下， <code>$BASH_ENV</code>和<code>$ENV</code>文件不会被处理，shell函数不会从环境中继承，并且<code>SHELLOPTS</code> ， <code>BASHOPTS</code> ， <code>CDPATH</code>和<code>GLOBIGNORE</code>如果变量出现在环境中，则将被忽略。如果外壳程序以有效用户（组）ID与实际用户（组）ID不相等的方式启动，并且<samp>-p</samp>选项未提供，将执行这些操作并将有效用户ID设置为实际用户ID。如果<samp>-p</samp>选项在启动时提供，有效用户ID不会重置。关闭此选项会使有效的用户和组ID设置为实际用户和组ID。
</p>
</dd>
<dt><code>-t</code></dt>
<dd><p>读取并执行一个命令后退出。
</p>
</dd>
<dt><code>-u</code></dt>
<dd><p>处理未设置的变量和参数（特殊参数除外） <samp>@</samp> ' 要么 ' <samp>*</samp> '作为执行参数扩展时的错误。错误消息将被写入标准错误，并且非交互式外壳将退出。
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>读取时打印外壳输入行。
</p>
</dd>
<dt><code>-x</code></dt>
<dd><p>打印一些简单的命令， <code>for</code>命令， <code>case</code>命令， <code>select</code>命令和算术<code>for</code>命令及其参数或关联的单词列表在展开后执行之前。的价值<code>PS4</code>变量将被扩展，结果值将在命令及其扩展的参数之前输出。
</p>
</dd>
<dt><code>-B</code></dt>
<dd><p>外壳将执行大括号扩展（请参阅<a href="#Brace-Expansion">Brace Expansion</a> ）。默认情况下，此选项处于启用状态。
</p>
</dd>
<dt><code>-C</code></dt>
<dd><p>使用'防止输出重定向<samp>></samp> '，' <samp>>&</samp> '和' <samp><></samp>覆盖现有文件。
</p>
</dd>
<dt><code>-E</code></dt>
<dd><p>如果设置，则任何陷阱<code>ERR</code>由Shell函数，命令替换和在子Shell环境中执行的命令继承。的<code>ERR</code>在这种情况下，通常不会继承陷阱。
</p>
</dd>
<dt><code>-H</code></dt>
<dd><p>启用“ <samp>!</samp>样式历史记录替换（请参见<a href="#History-Interaction">History Interaction</a> ）。交互式外壳程序默认情况下启用此选项。
</p>
</dd>
<dt><code>-P</code></dt>
<dd><p>如果设置，执行以下命令时不要解析符号链接<code>cd</code>更改当前目录。而是使用物理目录。默认情况下，Bash在执行更改当前目录的命令时会遵循目录的逻辑链。
</p>
<p>例如，如果<samp>/usr/sys</samp>是指向的符号链接<samp>/usr/local/sys</samp>然后：</p><div class="example">
<pre class="example">$ cd /usr/sys; echo $PWD
/usr/sys
$ cd ..; pwd
/usr
</pre></div>

<p>如果<code>set -P</code>开启，然后：</p><div class="example">
<pre class="example">$ cd /usr/sys; echo $PWD
/usr/local/sys
$ cd ..; pwd
/usr/local
</pre></div>

</dd>
<dt><code>-T</code></dt>
<dd><p>如果设置，则任何陷阱<code>DEBUG</code>和<code>RETURN</code>由Shell函数，命令替换和在子Shell环境中执行的命令继承。的<code>DEBUG</code>和<code>RETURN</code>在这种情况下通常不会继承陷阱。
</p>
</dd>
<dt><code>--</code></dt>
<dd><p>如果没有参数跟随此选项，则位置参数未设置。否则，将位置参数设置为<var>arguments</var> ，即使其中一些以“ <samp>-</samp> '。
</p>
</dd>
<dt><code>-</code></dt>
<dd><p>信号选项结束，导致所有剩余<var>arguments</var>分配给位置参数。的<samp>-x</samp>和<samp>-v</samp>选项已关闭。如果没有参数，则位置参数保持不变。
</p></dd>
</dl>

<p>使用“ <samp>+</samp> ' 而不是 ' <samp>-</samp> '导致这些选项被关闭。这些选项也可以在调用Shell时使用。当前的选项集可以在<code>$-</code> 。
</p>
<p>剩余的N <var>arguments</var>是位置参数，并按顺序分配给<code>$1</code> ， <code>$2</code> ，… <code>$N</code> 。特殊参数<code>#</code>设置为N。</p>
<p>除非提供了无效的选项，否则返回状态始终为零。
</p></dd>
</dl>

<hr>
<a name="The-Shopt-Builtin"></a>
<div class="header">
<p>上一页： <a href="#The-Set-Builtin" rel="prev" accesskey="p">内置集合</a> ，上<a href="#The-Set-Builtin" rel="prev" accesskey="p">一篇</a> ： <a href="#Modifying-Shell-Behavior" rel="up" accesskey="u">修改Shell行为</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Shopt-Builtin-1"></a>
<h4 class="subsection">4.3.2 Shopt内置</h4>

<p>此内置函数使您可以更改其他Shell可选行为。
</p>
<dl compact>
<dt><code>shopt</code></dt>
<dd><a name="index-shopt"></a>
<div class="example">
<pre class="example">shopt [-pqsu] [-o] [<var>optname</var> &hellip;]
</pre></div>

<p>切换控制可选外壳程序行为的设置的值。这些设置可以是下面列出的设置，也可以是<samp>-o</samp>选项被使用，那些与<samp>-o</samp>选项<code>set</code>内置命令（请参阅<a href="#The-Set-Builtin">“内置集”</a> ）。没有选项，或者<samp>-p</samp>选项，将显示所有可设置选项的列表，并指示是否已设置每个选项；如果<var>optnames</var>提供时，输出仅限于这些选项。的<samp>-p</samp>选项使输出以可以重新用作输入的形式显示。其他选项具有以下含义：</p>
<dl compact>
<dt><code>-s</code></dt>
<dd><p>分别启用（设置） <var>optname</var> 。
</p>
</dd>
<dt><code>-u</code></dt>
<dd><p>分别禁用（取消设置） <var>optname</var> 。
</p>
</dd>
<dt><code>-q</code></dt>
<dd><p>抑制正常输出；返回状态指示是否<var>optname</var>已设置或未设置。如果多个<var>optname</var>参数给出<samp>-q</samp> ，如果全部返回状态为零<var>optnames</var>已启用；否则为非零。
</p>
</dd>
<dt><code>-o</code></dt>
<dd><p>限制值<var>optname</var>被定义为<samp>-o</samp>选项<code>set</code>内置（请参阅<a href="#The-Set-Builtin">《内置集》</a> ）。
</p></dd>
</dl>

<p>如果有<samp>-s</samp>要么<samp>-u</samp>不使用<var>optname</var>论据<code>shopt</code>仅显示分别设置或未设置的那些选项。
</p>
<p>除非另有说明，否则<code>shopt</code>默认情况下，选项处于禁用状态（关闭）。
</p>
<p>如果全部列出，则列表选项的返回状态为零<var>optnames</var>启用，否则为非零。设置或取消设置选项时，返回状态为零，除非出现<var>optname</var>不是有效的Shell选项。
</p>
<p>的清单<code>shopt</code>选项是：</p><dl compact>
<dt><code>assoc_expand_once</code></dt>
<dd><p>如果设置，则外壳将在算术表达式求值期间，执行可执行变量赋值的内置函数以及执行可执行数组解引用的内置函数时抑制对关联数组下标的多次求值。
</p>
</dd>
<dt><code>autocd</code></dt>
<dd><p>如果设置，将执行作为目录名称的命令名称，就好像它是命令的参数一样。 <code>cd</code>命令。此选项仅由交互式外壳程序使用。
</p>
</dd>
<dt><code>cdable_vars</code></dt>
<dd><p>如果已设置，则<code>cd</code>不是目录的内置命令被假定为变量的名称，该变量的值是要更改的目录。
</p>
</dd>
<dt><code>cdspell</code></dt>
<dd><p>如果设置，则在<code>cd</code>命令将被更正。检查的错误是转置字符，丢失的字符和太多的字符。如果找到更正，则打印更正的路径，然后继续执行命令。此选项仅由交互式外壳程序使用。
</p>
</dd>
<dt><code>checkhash</code></dt>
<dd><p>如果设置了此选项，则Bash会在尝试执行该命令之前检查在哈希表中找到的命令是否存在。如果哈希命令不再存在，则执行常规路径搜索。
</p>
</dd>
<dt><code>checkjobs</code></dt>
<dd><p>如果设置，Bash会在退出交互式外壳程序之前列出所有已停止和正在运行的作业的状态。如果有任何作业在运行，这将导致退出被推迟到尝试第二次退出而没有中间命令（请参见<a href="#Job-Control">Job Control</a> ）。如果停止任何作业，shell总是会推迟退出。
</p>
</dd>
<dt><code>checkwinsize</code></dt>
<dd><p>如果设置，Bash将在每个外部（非内置）命令之后检查窗口大小，并在必要时更新<code>LINES</code>和<code>COLUMNS</code> 。默认情况下启用此选项。
</p>
</dd>
<dt><code>cmdhist</code></dt>
<dd><p>如果设置，则Bash尝试将多行命令的所有行保存在同一历史记录条目中。这样可以轻松地重新编辑多行命令。此选项默认情况下处于启用状态，但仅在启用命令历史记录后才有效（请参阅<a href="#Bash-History-Facilities">Bash历史记录工具</a> ）。
</p>
</dd>
<dt><code>compat31</code></dt>
<dd><p>如果已设置，则Bash会将条件命令的' <samp>=~</samp> '运算符，并在使用<code>[[</code>条件命令的<samp><</samp> '和' <samp>></samp> '运算符。bash-4.1之前的Bash版本使用ASCII归类和strcmp（3）; bash-4.1和更高版本使用当前语言环境的排序规则序列和strcoll（3）。
</p>
</dd>
<dt><code>compat32</code></dt>
<dd><p>如果设置了该选项，则Bash在使用<code>[[</code>条件命令的<samp><</samp> '和' <samp>></samp> '运算符（请参见上一项）和中断命令列表的效果。由于中断而终止后，Bash 3.2及更早版本将继续执行列表中的下一个命令。
</p>
</dd>
<dt><code>compat40</code></dt>
<dd><p>如果设置了该选项，则Bash在使用<code>[[</code>条件命令的<samp><</samp> '和' <samp>></samp> '运算子（请参阅<code>compat31</code> ）和中断命令列表的效果。Bash 4.0和更高版本会中断列表，就像外壳程序收到中断一样；先前的版本在列表中继续执行下一个命令。
</p>
</dd>
<dt><code>compat41</code></dt>
<dd><p>如果设置为Bash，则在<small>POSIX</small>模式下，Bash将双引号参数扩展中的单引号视为特殊字符。单引号必须匹配（偶数），并且单引号之间的字符被视为带引号。这是4.1版中<small>POSIX</small>模式的行为。默认的Bash行为保持与以前的版本相同。
</p>
</dd>
<dt><code>compat42</code></dt>
<dd><p>如果设置，则Bash不会使用引号删除来处理模式替换字扩展中的替换字符串。
</p>
</dd>
<dt><code>compat43</code></dt>
<dd><p>如果设置，则尝试使用带引号的复合数组赋值作为Bash的参数时，Bash不会打印警告消息。 <code>declare</code> ，使字扩展错误成为非致命错误，从而导致当前命令失败（默认行为是使致命错误导致shell退出），并且在执行shell函数时不重置循环状态（这允许<code>break</code>要么<code>continue</code>在shell函数中影响调用者上下文中的循环）。
</p>
</dd>
<dt><code>compat44</code></dt>
<dd><p>如果设置，则Bash会在使用位置参数之前将位置参数保存到BASH_ARGV和BASH_ARGC，而不管是否启用扩展调试模式。
</p>
</dd>
<dt><code>complete_fullquote</code></dt>
<dd><p>如果设置，则Bash执行完成时会在文件名和目录名称中引用所有外壳程序元字符。如果未设置，则Bash会从字符集中删除元符号等元字符，当这些元字符以要完成的单词形式出现在shell变量引用中时，这些字符将在已完成的文件名中引用。这意味着在变量名中扩展到目录的美元符号将不被引用；但是，文件名中出现的任何美元符号也不会被引用。仅当bash使用反斜杠引用完整的文件名时，此选项才有效。默认情况下设置此变量，这是从4.2版开始的默认Bash行为。
</p>
</dd>
<dt><code>direxpand</code></dt>
<dd><p>如果设置，则Bash在执行文件名补全时将目录名替换为单词扩展的结果。这将更改读取行编辑缓冲区的内容。如果未设置，则Bash尝试保留用户键入的内容。
</p>
</dd>
<dt><code>dirspell</code></dt>
<dd><p>如果设置，则Bash尝试在单词完成过程中对目录名称进行拼写校正，如果最初提供的目录名称不存在。
</p>
</dd>
<dt><code>dotglob</code></dt>
<dd><p>如果设置，则Bash包含以“。”开头的文件名。文件名扩展的结果。文件名“ <samp>.</samp> '和' <samp>..</samp> '必须始终明确匹配，即使<code>dotglob</code>被设置。
</p>
</dd>
<dt><code>execfail</code></dt>
<dd><p>如果设置了该选项，则非交互式外壳程序如果无法执行指定为参数的文件，则不会退出<code>exec</code>内置命令。如果出现以下情况，交互式外壳程序不会退出<code>exec</code>失败。
</p>
</dd>
<dt><code>expand_aliases</code></dt>
<dd><p>如果设置了别名，则将按照以下别名， <a href="#Aliases">别名</a>下的说明扩展<a href="#Aliases">别名</a> 。默认情况下，此选项对于交互式Shell启用。
</p>
</dd>
<dt><code>extdebug</code></dt>
<dd><p>如果是在shell调用或在shell启动文件中设置的，则安排在shell启动之前执行调试器配置文件，与<samp>--debugger</samp>选项。如果在调用后设置，则启用了供调试器使用的行为：</p>
<ol>
<li>的<samp>-F</samp>选项<code>declare</code> Builtin（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）显示源文件名和与作为参数提供的每个函数名相对应的行号。

</li><li>如果命令由<code>DEBUG</code> trap返回一个非零值，下一条命令被跳过而不执行。

</li><li>如果命令由<code>DEBUG</code> trap返回的值为2，并且外壳程序正在子例程中执行（外壳函数或由外壳程序执行的外壳程序脚本） <code>.</code>要么<code>source</code>内置程序），外壳程序会模拟对<code>return</code> 。

</li><li> <code>BASH_ARGC</code>和<code>BASH_ARGV</code>按照它们的描述进行更新（请参阅<a href="#Bash-Variables">Bash变量</a> ）。

</li><li>启用了函数跟踪：命令替换，shell函数以及使用以下命令调用的子shell <code>( <var>command</var> )</code>继承<code>DEBUG</code>和<code>RETURN</code>陷阱。

</li><li>启用了错误跟踪：命令替换，shell函数以及使用以下命令调用的子shell <code>( <var>command</var> )</code>继承<code>ERR</code>陷阱。
</li></ol>

</dd>
<dt><code>extglob</code></dt>
<dd><p>如果设置，则启用上述扩展的模式匹配功能（请参阅<a href="#Pattern-Matching">模式匹配</a> ）。
</p>
</dd>
<dt><code>extquote</code></dt>
<dd><p>如果设置， <code>$'<var>string</var>'</code>和<code>$"<var>string</var>"</code>报价是在<code>${<var>parameter</var>}</code>扩展名用双引号引起来。默认情况下启用此选项。
</p>
</dd>
<dt><code>failglob</code></dt>
<dd><p>如果设置，在文件名扩展过程中与文件名不匹配的模式将导致扩展错误。
</p>
</dd>
<dt><code>force_fignore</code></dt>
<dd><p>如果设置，则由<code>FIGNORE</code> shell变量会导致在执行单词补全时忽略单词，即使被忽略的单词是唯一可能的补全。有关<a href="#Bash-Variables">Bash变量</a>的说明，请参见<a href="#Bash-Variables">Bash变量</a> 。 <code>FIGNORE</code> 。默认情况下启用此选项。
</p>
</dd>
<dt><code>globasciiranges</code></dt>
<dd><p>如果设置，则在执行比较时，模式匹配括号表达式（请参见<a href="#Pattern-Matching">模式匹配</a> ）中使用的范围表达式的行为就像在传统C语言环境中一样。也就是说，没有考虑当前语言环境的整理顺序，因此“ <samp>b</samp> '不会在'之间整理<samp>A</samp> '和' <samp>B</samp> '，大写和小写ASCII字符将整理在一起。
</p>
</dd>
<dt><code>globstar</code></dt>
<dd><p>如果设置，则模式' <samp>**</samp>在文件名扩展上下文中使用的'将匹配所有文件以及零个或多个目录和子目录。如果模式后跟一个' <samp>/</samp> '，仅目录和子目录匹配。
</p>
</dd>
<dt><code>gnu_errfmt</code></dt>
<dd><p>如果设置，则外壳错误消息将以标准<small>GNU</small>错误消息格式编写。
</p>
</dd>
<dt><code>histappend</code></dt>
<dd><p>如果设置，则将历史记录列表追加到以<code>HISTFILE</code>退出外壳程序时变量，而不是覆盖文件。
</p>
</dd>
<dt><code>histreedit</code></dt>
<dd><p>如果已设置并且正在使用Readline，则将为用户提供重新编辑失败的历史记录替换的机会。
</p>
</dd>
<dt><code>histverify</code></dt>
<dd><p>如果已设置并且正在使用Readline，则历史替换的结果不会立即传递到Shell解析器。而是将结果行加载到Readline编辑缓冲区中，以允许进一步修改。
</p>
</dd>
<dt><code>hostcomplete</code></dt>
<dd><p>如果已设置，并且正在使用Readline，则当Bash单词中包含“ <samp>@</samp> '正在完成（请参阅<a href="#Commands-For-Completion">“完成命令”</a> ）。默认情况下启用此选项。
</p>
</dd>
<dt><code>huponexit</code></dt>
<dd><p>如果设置，Bash将发送<code>SIGHUP</code>退出交互式登录外壳时，将所有作业都移至所有作业（请参阅<a href="#Signals">Signals</a> ）。
</p>
</dd>
<dt><code>inherit_errexit</code></dt>
<dd><p>如果设置，命令替换将继承<code>errexit</code>选项，而不是在subshell环境中取消设置。当启用<small>POSIX</small>模式时，启用此选项。
</p>
</dd>
<dt><code>interactive_comments</code></dt>
<dd><p>允许以“ <samp>#</samp> '使该单词和该行上的所有剩余字符在交互式shell中被忽略。默认情况下启用此选项。
</p>
</dd>
<dt><code>lastpipe</code></dt>
<dd><p>如果设置了该选项，并且作业控制未处于活动状态，那么外壳程序将在当前外壳程序环境中运行不在后台执行的管道的最后一个命令。
</p>
</dd>
<dt><code>lithist</code></dt>
<dd><p>如果启用，则<code>cmdhist</code>选项启用后，多行命令将使用嵌入式换行符保存到历史记录中，而不是在可能的情况下使用分号分隔符。
</p>
</dd>
<dt><code>localvar_inherit</code></dt>
<dd><p>如果设置，则局部变量将继承在分配任何新值之前在先前作用域中存在的同名变量的值和属性。的<var>nameref</var>属性未继承。
</p>
</dd>
<dt><code>localvar_unset</code></dt>
<dd><p>如果设置，则调用<code>unset</code>在先前函数作用域中的局部变量上标记它们，以便后续查找发现它们未设置，直到该函数返回为止。这与在当前函数作用域上取消设置局部变量的行为相同。
</p>
</dd>
<dt><code>login_shell</code></dt>
<dd><p>如果外壳程序作为登录外壳程序启动，则外壳程序将设置此选项（请参阅<a href="#Invoking-Bash">Invoking Bash</a> ）。该值不能更改。
</p>
</dd>
<dt><code>mailwarn</code></dt>
<dd><p>如果已设置，并且自上次检查以来已访问了Bash正在检查邮件的文件，则该消息<code>"The mail in <var>mailfile</var> has been read"</code>被陈列。
</p>
</dd>
<dt><code>no_empty_cmd_completion</code></dt>
<dd><p>如果已设置，并且正在使用Readline，则Bash不会尝试搜索<code>PATH</code>在空行上尝试完成时的可能完成。
</p>
</dd>
<dt><code>nocaseglob</code></dt>
<dd><p>如果设置，则Bash在执行文件名扩展时以不区分大小写的方式匹配文件名。
</p>
</dd>
<dt><code>nocasematch</code></dt>
<dd><p>如果设置，则Bash在执行时执行匹配时以不区分大小写的方式匹配模式<code>case</code>要么<code>[[</code>条件命令，执行模式替换字扩展时，或在过滤可能的补全作为可编程补全的一部分时。
</p>
</dd>
<dt><code>nullglob</code></dt>
<dd><p>如果设置，Bash允许不匹配文件的文件名模式扩展为空字符串，而不是扩展为它们自己。
</p>
</dd>
<dt><code>progcomp</code></dt>
<dd><p>如果设置，则启用可编程完成功能（请参阅“ <a href="#Programmable-Completion">可编程完成”</a> ）。默认情况下启用此选项。
</p>
</dd>
<dt><code>progcomp_alias</code></dt>
<dd><p>如果设置了该选项，并且启用了可编程补全功能，则Bash会将没有任何补全的命令名称视为可能的别名，然后尝试扩展别名。如果它具有别名，则Bash会尝试使用扩展别名产生的命令字来完成编程。
</p>
</dd>
<dt><code>promptvars</code></dt>
<dd><p>如果设置，提示字符串将按如下所述进行扩展，然后进行参数扩展，命令替换，算术扩展和引号删除（请参阅<a href="#Controlling-the-Prompt">控制提示</a> ）。默认情况下启用此选项。
</p>
</dd>
<dt><code>restricted_shell</code></dt>
<dd><p>如果外壳程序在受限模式下启动，那么它将设置此选项（请参阅<a href="#The-Restricted-Shell">The Restricted Shell</a> ）。该值不能更改。执行启动文件时不会重置此设置，从而允许启动文件发现是否限制了外壳程序。
</p>
</dd>
<dt><code>shift_verbose</code></dt>
<dd><p>如果已设置，则<code>shift</code>当班次计数超过位置参数的数量时，internal会输出一条错误消息。
</p>
</dd>
<dt><code>sourcepath</code></dt>
<dd><p>如果设置，则<code>source</code>内置使用的值<code>PATH</code>查找包含作为参数提供的文件的目录。默认情况下启用此选项。
</p>
</dd>
<dt><code>xpg_echo</code></dt>
<dd><p>如果设置，则<code>echo</code>内置默认会扩展反斜杠转义序列。
</p>
</dd>
</dl>

<p>如果全部列出，则列表选项的返回状态为零<var>optnames</var>启用，否则为非零。设置或取消设置选项时，返回状态为零，除非出现<var>optname</var>不是有效的Shell选项。
</p></dd>
</dl>

<hr>
<a name="Special-Builtins"></a>
<div class="header">
<p>Previous： <a href="#Modifying-Shell-Behavior" rel="prev" accesskey="p">修改Shell行为</a> ，上： <a href="#Shell-Builtin-Commands" rel="up" accesskey="u">Shell内置命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Special-Builtins-1"></a>
<h3 class="section">4.4特殊内置</h3>
<a name="index-special-builtin-1"></a>

<p>由于历史原因， <small>POSIX</small>标准已将几个内置命令归类为<em>special</em> 。当Bash在<small>POSIX</small>模式下执行时，特殊的内置命令在以下三个方面与其他内置命令有所不同：</p>
<ol>
<li>在命令查找期间，在shell函数之前会找到特殊的内置函数。

</li><li>如果特殊的内置函数返回错误状态，则退出非交互式外壳。

</li><li>命令完成后，命令前的赋值语句在shell环境中仍然有效。
</li></ol>

<p>当Bash不在<small>POSIX</small>模式下执行时，这些内置<small>函数的</small>行为与其余的Bash内置命令没有什么不同。Bash <small>POSIX</small>模式中介绍了<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> 。
</p>
<p>这些是<small>POSIX</small>特殊的内置<small>函数</small> ：</p><div class="example">
<pre class="example">break : . continue eval exec exit export readonly return set<!-- /@w -->
shift trap unset<!-- /@w -->
</pre></div>

<hr>
<a name="Shell-Variables"></a>
<div class="header">
<p>下一篇： <a href="#Bash-Features" rel="next" accesskey="n">Bash功能</a> ，上一篇： <a href="#Shell-Builtin-Commands" rel="prev" accesskey="p">Shell内置命令</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Variables-1"></a>
<h2 class="chapter">5个Shell变量</h2>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Bourne-Shell-Variables" accesskey="1">Bourne Shell变量</a> ：</td><td>  </td><td align="left" valign="top">Bash使用与Bourne Shell相同的方式使用的变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-Variables" accesskey="2">Bash变量</a> ：</td><td>  </td><td align="left" valign="top">Bash中存在的变量列表。
</td></tr>
</tbody></table>

<p>本章描述了Bash使用的shell变量。Bash自动将默认值分配给多个变量。
</p>
<hr>
<a name="Bourne-Shell-Variables"></a>
<div class="header">
<p>下一页： <a href="#Bash-Variables" rel="next" accesskey="n">Bash变量</a> ，上一篇： <a href="#Shell-Variables" rel="up" accesskey="u">Shell变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bourne-Shell-Variables-1"></a>
<h3 class="section">5.1 Bourne Shell变量</h3>

<p>Bash使用与Bourne Shell相同的方式使用某些Shell变量。在某些情况下，Bash将默认值分配给变量。
</p>
<dl compact>
<dt><code>CDPATH</code>
<a name="index-CDPATH"></a>
</dt>
<dd><p>用冒号分隔的目录列表，用作目录的搜索路径<code>cd</code>内置命令。
</p>
</dd>
<dt><code>HOME</code>
<a name="index-HOME"></a>
</dt>
<dd><p>当前用户的主目录；的默认值<code>cd</code>内置命令。代字号扩展也使用此变量的值（请参见<a href="#Tilde-Expansion">Tilde Expansion</a> ）。
</p>
</dd>
<dt><code>IFS</code>
<a name="index-IFS"></a>
</dt>
<dd><p>分隔字段的字符列表；在外壳程序将单词作为扩展的一部分拆分时使用。
</p>
</dd>
<dt><code>MAIL</code>
<a name="index-MAIL"></a>
</dt>
<dd><p>如果此参数设置为文件名或目录名，并且<code>MAILPATH</code>变量未设置，Bash通知用户邮件到达指定文件或Maildir格式目录中。
</p>
</dd>
<dt><code>MAILPATH</code>
<a name="index-MAILPATH"></a>
</dt>
<dd><p>用冒号分隔的文件名列表，shell会定期检查这些文件名以查找新邮件。每个列表条目都可以指定新邮件到达邮件文件时打印的邮件，方法是使用“' <samp>?</samp> '。在邮件文字中使用时， <code>$_</code>扩展为当前邮件文件的名称。
</p>
</dd>
<dt><code>OPTARG</code>
<a name="index-OPTARG"></a>
</dt>
<dd><p>最后一个选项参数的值由<code>getopts</code>内置的。
</p>
</dd>
<dt><code>OPTIND</code>
<a name="index-OPTIND"></a>
</dt>
<dd><p>最后一个选项参数的索引由<code>getopts</code>内置的。
</p>
</dd>
<dt><code>PATH</code>
<a name="index-PATH"></a>
</dt>
<dd><p>用冒号分隔的目录列表，shell在其中查找命令。零长度（空）目录名称，其值为<code>PATH</code>指示当前目录。空目录名称可能显示为两个相邻的冒号，或显示为初始或结尾的冒号。
</p>
</dd>
<dt><code>PS1</code>
<a name="index-PS1"></a>
</dt>
<dd><p>主提示字符串。默认值为“ <samp>\s-\v\$</samp> '。有关在之前扩展的转义序列的完整列表，请参见<a href="#Controlling-the-Prompt">控制提示</a> 。 <code>PS1</code>被陈列。
</p>
</dd>
<dt><code>PS2</code>
<a name="index-PS2"></a>
</dt>
<dd><p>次要提示字符串。默认值为“ <samp>></samp> '。
<code>PS2</code>的扩展方式与<code>PS1</code>在显示之前。
</p>
</dd>
</dl>

<hr>
<a name="Bash-Variables"></a>
<div class="header">
<p>上一页： <a href="#Bourne-Shell-Variables" rel="prev" accesskey="p">Bourne Shell变量</a> ，上： <a href="#Shell-Variables" rel="up" accesskey="u">Shell变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Variables-1"></a>
<h3 class="section">5.2 Bash变量</h3>

<p>这些变量由Bash设置或使用，但是其他shell通常不会对其进行特殊处理。
</p>
<p>Bash使用的一些变量在不同的章节中进行了介绍：用于控制作业控制工具的<a href="#Job-Control-Variables">变量</a> （请参阅<a href="#Job-Control-Variables">作业控制变量</a> ）。
</p>
<dl compact>
<dt><code>BASH</code>
<a name="index-BASH"></a>
</dt>
<dd><p>用于执行Bash当前实例的完整路径名。
</p>
</dd>
<dt><code>BASHOPTS</code>
<a name="index-BASHOPTS"></a>
</dt>
<dd><p>以冒号分隔的已启用外壳程序选项列表。列表中的每个字词都是<samp>-s</samp>选项<code>shopt</code>内置命令（请参阅<a href="#The-Shopt-Builtin">Shopt</a>内置命令）。选项出现在<code>BASHOPTS</code>被报告为“ <samp>on</samp>由<samp>shopt</samp> '。如果Bash启动时该变量在环境中，则在读取任何启动文件之前，将启用列表中的每个shell选项。此变量是只读的。
</p>
</dd>
<dt><code>BASHPID</code>
<a name="index-BASHPID"></a>
</dt>
<dd><p>扩展为当前Bash进程的进程ID。这不同于<code>$$</code>在某些情况下，例如不需要重新初始化Bash的子外壳。分配给<code>BASHPID</code>没有效果。如果<code>BASHPID</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>BASH_ALIASES</code>
<a name="index-BASH_005fALIASES"></a>
</dt>
<dd><p>关联数组变量，其成员与别名的内部列表相对应，该别名由<code>alias</code>内置的。（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。添加到该数组的元素将出现在别名列表中。但是，取消设置数组元素当前不会导致别名从别名列表中删除。如果<code>BASH_ALIASES</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>BASH_ARGC</code>
<a name="index-BASH_005fARGC"></a>
</dt>
<dd><p>一个数组变量，其值是当前bash执行调用堆栈每一帧中的参数数。当前子例程的参数数（使用以下命令执行的shell函数或脚本） <code>.</code>要么<code>source</code> ）位于堆栈的顶部。当执行子例程时，将传递的参数数量压入<code>BASH_ARGC</code> 。贝壳套<code>BASH_ARGC</code>仅当处于扩展调试模式时（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin）</a> <code>extdebug</code>选项<code>shopt</code>内置）。设置<code>extdebug</code>在外壳程序开始执行脚本后，或在以下情况下引用此变量后<code>extdebug</code>未设置，可能导致值不一致。
</p>
</dd>
<dt><code>BASH_ARGV</code>
<a name="index-BASH_005fARGV"></a>
</dt>
<dd><p>一个数组变量，包含当前bash执行调用堆栈中的所有参数。最后一个子例程调用的最后一个参数位于堆栈的顶部。初始调用的第一个参数在底部。执行子程序时，将提供的参数压入<code>BASH_ARGV</code> 。贝壳套<code>BASH_ARGV</code>仅当处于扩展调试模式时（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin）</a> <code>extdebug</code>选项<code>shopt</code>内置）。设置<code>extdebug</code>在外壳程序开始执行脚本后，或在以下情况下引用此变量后<code>extdebug</code>未设置，可能导致值不一致。
</p>
</dd>
<dt><code>BASH_ARGV0</code>
<a name="index-BASH_005fARGV0"></a>
</dt>
<dd><p>引用时，此变量扩展为shell或shell脚本的名称（与<code>$0</code> ;有关特殊参数0的说明，请参见<a href="#Special-Parameters">特殊参数</a> 。分配给<code>BASH_ARGV0</code>使分配的值也分配给<code>$0</code> 。如果<code>BASH_ARGV0</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>BASH_CMDS</code>
<a name="index-BASH_005fCMDS"></a>
</dt>
<dd><p>一个关联数组变量，其成员与命令的内部哈希表相对应，该哈希表由<code>hash</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ）。添加到该数组的元素将显示在哈希表中；但是，取消设置数组元素当前不会导致从哈希表中删除命令名称。如果<code>BASH_CMDS</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>BASH_COMMAND</code>
<a name="index-BASH_005fCOMMAND"></a>
</dt>
<dd><p>当前正在执行或将要执行的命令，除非shell由于陷阱而正在执行命令，在这种情况下，它是在陷阱发生时执行的命令。
</p>
</dd>
<dt><code>BASH_COMPAT</code>
<a name="index-BASH_005fCOMPAT"></a>
</dt>
<dd><p>该值用于设置外壳的兼容性级别。有关各种兼容性级别及其效果的说明，请参见<a href="#The-Shopt-Builtin">内置Shopt</a> 。该值可以是对应于所需兼容性级别的十进制数（例如4.2）或整数（例如42）。如果<code>BASH_COMPAT</code>未设置或设置为空字符串，兼容性级别设置为当前版本的默认值。如果<code>BASH_COMPAT</code>如果将其设置为不是有效兼容性级别之一的值，则外壳程序将显示一条错误消息，并将兼容性级别设置为当前版本的默认级别。有效的兼容级别对应于<code>shopt</code>上述内置函数（例如， <var>compat42</var>表示4.2和42是有效值）。当前版本也是有效值。
</p>
</dd>
<dt><code>BASH_ENV</code>
<a name="index-BASH_005fENV"></a>
</dt>
<dd><p>如果在调用Bash执行Shell脚本时设置了此变量，则将其值扩展并用作在执行脚本之前要读取的启动文件的名称。请参阅<a href="#Bash-Startup-Files">Bash启动文件</a> 。
</p>
</dd>
<dt><code>BASH_EXECUTION_STRING</code>
<a name="index-BASH_005fEXECUTION_005fSTRING"></a>
</dt>
<dd><p>命令参数<samp>-c</samp>调用选项。
</p>
</dd>
<dt><code>BASH_LINENO</code>
<a name="index-BASH_005fLINENO"></a>
</dt>
<dd><p>一个数组变量，其成员是源文件中的行号，其中每个对应的成员<var>FUNCNAME</var>被调用。
<code>${BASH_LINENO[$i]}</code>是源文件中的行号（ <code>${BASH_SOURCE[$i+1]}</code> ）哪里<code>${FUNCNAME[$i]}</code>被称为（或<code>${BASH_LINENO[$i-1]}</code>如果在另一个Shell函数中引用）。使用<code>LINENO</code>获取当前行号。
</p>
</dd>
<dt><code>BASH_LOADABLES_PATH</code>
<a name="index-BASH_005fLOADABLES_005fPATH"></a>
</dt>
<dd><p>用冒号分隔的目录列表，外壳程序在其中查找由<code>enable</code>命令。
</p>
</dd>
<dt><code>BASH_REMATCH</code>
<a name="index-BASH_005fREMATCH"></a>
</dt>
<dd><p>一个数组变量，其成员由' <samp>=~</samp> '二进制运算符<code>[[</code>条件命令（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。索引为0的元素是字符串中与整个正则表达式匹配的部分。具有索引的元素<var>n</var>是匹配字符串的部分<var>n</var>括号内的子表达式。该变量是只读的。
</p>
</dd>
<dt><code>BASH_SOURCE</code>
<a name="index-BASH_005fSOURCE"></a>
</dt>
<dd><p>一个数组变量，其成员是源文件名，其中相应的shell函数名称在<code>FUNCNAME</code>定义了数组变量。外壳功能<code>${FUNCNAME[$i]}</code>在文件中定义<code>${BASH_SOURCE[$i]}</code>并从<code>${BASH_SOURCE[$i+1]}</code>
</p>
</dd>
<dt><code>BASH_SUBSHELL</code>
<a name="index-BASH_005fSUBSHELL"></a>
</dt>
<dd><p>当外壳在该子外壳或子外壳环境中开始执行时，在每个子外壳或子外壳环境中增加一个。初始值为0。
</p>
</dd>
<dt><code>BASH_VERSINFO</code>
<a name="index-BASH_005fVERSINFO"></a>
</dt>
<dd><p>一个只读数组变量（请参阅<a href="#Arrays">Arrays</a> ），其成员保存此Bash实例的版本信息。分配给数组成员的值如下：</p>
<dl compact>
<dt><code>BASH_VERSINFO[0]</code></dt>
<dd><p>主要版本号（ <var>release</var> ）。
</p>
</dd>
<dt><code>BASH_VERSINFO[1]</code></dt>
<dd><p>次要版本号（ <var>version</var> ）。
</p>
</dd>
<dt><code>BASH_VERSINFO[2]</code></dt>
<dd><p>补丁程序级别。
</p>
</dd>
<dt><code>BASH_VERSINFO[3]</code></dt>
<dd><p>构建版本。
</p>
</dd>
<dt><code>BASH_VERSINFO[4]</code></dt>
<dd><p>发布状态（例如， <var>beta1</var> ）。
</p>
</dd>
<dt><code>BASH_VERSINFO[5]</code></dt>
<dd><p>的价值<code>MACHTYPE</code> 。
</p></dd>
</dl>

</dd>
<dt><code>BASH_VERSION</code>
<a name="index-BASH_005fVERSION"></a>
</dt>
<dd><p>Bash当前实例的版本号。
</p>
</dd>
<dt><code>BASH_XTRACEFD</code>
<a name="index-BASH_005fXTRACEFD"></a>
</dt>
<dd><p>如果将其设置为与有效文件描述符相对应的整数，则Bash会写入以下情况下生成的跟踪输出： <samp>set -x</samp>已启用该文件描述符。这样可以将跟踪输出与诊断和错误消息分开。文件描述符在以下情况下关闭<code>BASH_XTRACEFD</code>未设置或分配了新值。取消设定<code>BASH_XTRACEFD</code>或为其分配空字符串会导致将跟踪输出发送到标准错误。注意设置<code>BASH_XTRACEFD</code>到2（标准错误文件描述符），然后取消设置将导致标准错误被关闭。
</p>
</dd>
<dt><code>CHILD_MAX</code>
<a name="index-CHILD_005fMAX"></a>
</dt>
<dd><p>设置要记住的外壳程序退出子状态值的数量。Bash不允许将此值减小到<small>POSIX</small>规定的最小值以下，并且有一个最大值（当前为8192），可能不会超过该最大值。最小值取决于系统。
</p>
</dd>
<dt><code>COLUMNS</code>
<a name="index-COLUMNS"></a>
</dt>
<dd><p>由<code>select</code>命令在打印选择列表时确定端子宽度。自动设置是否<code>checkwinsize</code>选项已启用（请参阅<a href="#The-Shopt-Builtin">内置的Shopt</a> ），或者在收到<code>SIGWINCH</code> 。
</p>
</dd>
<dt><code>COMP_CWORD</code>
<a name="index-COMP_005fCWORD"></a>
</dt>
<dd><p>索引<code>${COMP_WORDS}</code>包含当前光标位置的单词。此变量仅在由可编程完成工具调用的shell函数中可用（请参阅<a href="#Programmable-Completion">可编程完成</a> ）。
</p>
</dd>
<dt><code>COMP_LINE</code>
<a name="index-COMP_005fLINE"></a>
</dt>
<dd><p>当前命令行。此变量仅在外壳函数和由可编程完成工具调用的外部命令中可用（请参阅<a href="#Programmable-Completion">可编程完成</a> ）。
</p>
</dd>
<dt><code>COMP_POINT</code>
<a name="index-COMP_005fPOINT"></a>
</dt>
<dd><p>当前光标位置相对于当前命令开头的索引。如果当前光标位置在当前命令的末尾，则此变量的值等于<code>${#COMP_LINE}</code> 。该变量仅在外壳函数和由可编程完成工具调用的外部命令中可用（请参阅<a href="#Programmable-Completion">可编程完成</a> ）。
</p>
</dd>
<dt><code>COMP_TYPE</code>
<a name="index-COMP_005fTYPE"></a>
</dt>
<dd><p>设置为与导致完成函数被调用的尝试完成类型相对应的整数值： <var>TAB</var> ，以便正常完成， <samp>?</samp> '，用于在连续的制表符之后列出补全，' <samp>!</samp> '，用于列出部分单词补全的替代项，' <samp>@</samp> '，如果单词未修改，则列出补全，或' <samp>%</samp> '，以完成菜单。此变量仅在外壳函数和由可编程完成工具调用的外部命令中可用（请参阅<a href="#Programmable-Completion">可编程完成</a> ）。
</p>
</dd>
<dt><code>COMP_KEY</code>
<a name="index-COMP_005fKEY"></a>
</dt>
<dd><p>用于调用当前完成功能的键（或键序列的最终键）。
</p>
</dd>
<dt><code>COMP_WORDBREAKS</code>
<a name="index-COMP_005fWORDBREAKS"></a>
</dt>
<dd><p>在执行单词补全时，Readline库将其视为单词分隔符的字符集。如果<code>COMP_WORDBREAKS</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>COMP_WORDS</code>
<a name="index-COMP_005fWORDS"></a>
</dt>
<dd><p>由当前命令行中的各个单词组成的数组变量。该行被拆分为单词，就像Readline会将其拆分为<code>COMP_WORDBREAKS</code>如上所述。此变量仅在由可编程完成工具调用的shell函数中可用（请参阅<a href="#Programmable-Completion">可编程完成</a> ）。
</p>
</dd>
<dt><code>COMPREPLY</code>
<a name="index-COMPREPLY"></a>
</dt>
<dd><p>Bash从中读取一个数组变量，该变量由可编程完成工具调用的shell函数生成的可能的完成（请参阅<a href="#Programmable-Completion">Programmable Completion</a> ）。每个数组元素包含一个可能的补全。
</p>
</dd>
<dt><code>COPROC</code>
<a name="index-COPROC"></a>
</dt>
<dd><p>创建一个数组变量来保存文件描述符，以供未命名的协同处理程序输出和输入（未命名）（请参阅<a href="#Coprocesses">Coprocesses</a> ）。
</p>
</dd>
<dt><code>DIRSTACK</code>
<a name="index-DIRSTACK"></a>
</dt>
<dd><p>包含目录堆栈当前内容的数组变量。目录在堆栈中的显示顺序是<code>dirs</code>内置的。分配给该数组变量的成员可用于修改堆栈中已存在的目录，但是<code>pushd</code>和<code>popd</code>必须使用buildins来添加和删除目录。分配给该变量将不会更改当前目录。如果<code>DIRSTACK</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>EMACS</code>
<a name="index-EMACS"></a>
</dt>
<dd><p>如果Bash在shell以值'开头时在环境中找到此变量<samp>t</samp> '，假设该外壳程序正在Emacs外壳程序缓冲区中运行，并且禁用了行编辑。
</p>
</dd>
<dt><code>ENV</code>
<a name="index-ENV"></a>
</dt>
<dd><p>相似<code>BASH_ENV</code> ;在<small>POSIX</small>模式下调用shell时使用（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）。
</p>
</dd>
<dt><code>EPOCHREALTIME</code>
<a name="index-EPOCHREALTIME"></a>
</dt>
<dd><p>每次引用此参数时，它都会扩展到自Unix纪元以来的秒数（以微秒为单位的浮点值）（请参阅C库函数的文档<var>time</var> （对于时代的定义）。分配给<code>EPOCHREALTIME</code>被忽略。如果<code>EPOCHREALTIME</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>EPOCHSECONDS</code>
<a name="index-EPOCHSECONDS"></a>
</dt>
<dd><p>每次引用此参数时，它都会扩展到自Unix纪元以来的秒数（请参见C库函数的文档<var>time</var> （对于时代的定义）。分配给<code>EPOCHSECONDS</code>被忽略。如果<code>EPOCHSECONDS</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>EUID</code>
<a name="index-EUID"></a>
</dt>
<dd><p>当前用户的数字有效用户ID。此变量是只读的。
</p>
</dd>
<dt><code>EXECIGNORE</code>
<a name="index-EXECIGNORE"></a>
</dt>
<dd><p>用冒号分隔的外壳模式列表（请参见<a href="#Pattern-Matching">模式匹配</a> ），定义了使用以下命令搜索将忽略的文件名列表<code>PATH</code> 。完整路径名与这些模式之一匹配的文件出于完成和命令执行的目的，不被视为可执行文件。 <code>PATH</code>抬头。这不会影响<code>[</code> ， <code>test</code>和<code>[[</code>命令。命令哈希表中的完整路径名不受限制<code>EXECIGNORE</code> 。使用此变量可忽略设置了可执行位但不是可执行文件的共享库文件。模式匹配遵循设置<code>extglob</code>外壳选项。
</p>
</dd>
<dt><code>FCEDIT</code>
<a name="index-FCEDIT"></a>
</dt>
<dd><p>该编辑器默认为<samp>-e</samp>选项<code>fc</code>内置命令。
</p>
</dd>
<dt><code>FIGNORE</code>
<a name="index-FIGNORE"></a>
</dt>
<dd><p>用冒号分隔的后缀列表在执行文件名完成时要忽略。后缀与以下项之一匹配的文件名<code>FIGNORE</code>从匹配的文件名列表中排除。样本值为“ <samp>.o:~</samp> '</p>
</dd>
<dt><code>FUNCNAME</code>
<a name="index-FUNCNAME"></a>
</dt>
<dd><p>一个数组变量，包含当前在执行调用堆栈中的所有shell函数的名称。索引为0的元素是任何当前正在执行的Shell函数的名称。最底部的元素（具有最高索引的元素）是<code>"main"</code> 。仅当执行Shell函数时，此变量才存在。分配给<code>FUNCNAME</code>没有效果。如果<code>FUNCNAME</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
<p>该变量可以与<code>BASH_LINENO</code>和<code>BASH_SOURCE</code> 。每个元素<code>FUNCNAME</code>在具有相应的元素<code>BASH_LINENO</code>和<code>BASH_SOURCE</code>描述调用堆栈。例如， <code>${FUNCNAME[$i]}</code>从文件中被调用<code>${BASH_SOURCE[$i+1]}</code>在行号<code>${BASH_LINENO[$i]}</code> 。的<code>caller</code>内置使用此信息显示当前调用堆栈。
</p>
</dd>
<dt><code>FUNCNEST</code>
<a name="index-FUNCNEST"></a>
</dt>
<dd><p>如果设置为大于0的数值，则定义最大函数嵌套级别。超出此嵌套级别的函数调用将导致当前命令中止。
</p>
</dd>
<dt><code>GLOBIGNORE</code>
<a name="index-GLOBIGNORE"></a>
</dt>
<dd><p>用冒号分隔的模式列表，定义文件名扩展将忽略的文件名集。如果与文件名扩展模式匹配的文件名也与以下文件中的模式之一匹配<code>GLOBIGNORE</code> ，则会从匹配列表中将其删除。模式匹配遵循设置<code>extglob</code>外壳选项。
</p>
</dd>
<dt><code>GROUPS</code>
<a name="index-GROUPS"></a>
</dt>
<dd><p>一个数组变量，其中包含当前用户是其成员的组的列表。分配给<code>GROUPS</code>没有效果。如果<code>GROUPS</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>histchars</code>
<a name="index-histchars"></a>
</dt>
<dd><p>最多三个用于控制历史记录扩展，快速替换和标记化的字符（请参阅<a href="#History-Interaction">History Interaction</a> ）。第一个字符是<var>history expansion</var>字符，即表示历史扩展开始的字符，通常为“ <samp>!</samp> '。第二个字符是当被视为一行的第一个字符时，通常表示“快速替换”的字符， <samp>^</samp> '。可选的第三个字符是表示该行的其余部分作为单词的第一个字符时通常是注释的字符，通常为' <samp>#</samp> '。历史注释字符使该行上其余单词的历史替换被跳过。它不一定会使Shell解析器将其余的行视为注释。
</p>
</dd>
<dt><code>HISTCMD</code>
<a name="index-HISTCMD"></a>
</dt>
<dd><p>当前命令的历史记录号或历史记录列表中的索引。如果<code>HISTCMD</code>未设置时，即使随后将其重置，它也会丢失其特殊属性。
</p>
</dd>
<dt><code>HISTCONTROL</code>
<a name="index-HISTCONTROL"></a>
</dt>
<dd><p>用冒号分隔的值列表，用于控制如何在历史记录列表中保存命令。如果值列表包含“ <samp>ignorespace</samp> '，以空格字符开头的行不会保存在历史记录列表中。值为“ <samp>ignoredups</samp> '导致与以前的历史记录条目匹配的行无法保存。值为“ <samp>ignoreboth</samp> '是'的简写<samp>ignorespace</samp> '和' <samp>ignoredups</samp> '。值为“ <samp>erasedups</samp> '使与当前行匹配的所有先前行在保存该行之前从历史记录列表中删除。不在上面列表中的任何值都将被忽略。如果<code>HISTCONTROL</code>未设置，或不包含有效值，shell解析器读取的所有行均保存在历史记录列表中，具体取决于<code>HISTIGNORE</code> 。多行复合命令的第二行和后续行未经过测试，并且无论历史记录的值如何，都会添加到历史记录中<code>HISTCONTROL</code> 。
</p>
</dd>
<dt><code>HISTFILE</code>
<a name="index-HISTFILE"></a>
</dt>
<dd><p>命令历史记录保存到的文件名。默认值为<samp>~/.bash_history</samp> 。
</p>
</dd>
<dt><code>HISTFILESIZE</code>
<a name="index-HISTFILESIZE"></a>
</dt>
<dd><p>历史记录文件中包含的最大行数。为该变量分配值后，如果有必要，通过删除最旧的条目，历史记录文件将被截断以包含不超过该行数。在退出外壳程序时，将历史文件写入后也将被截断为该大小。如果值为0，则历史记录文件将被截断为零大小。非数值和小于零的数值禁止截断。外壳程序将默认值设置为<code>HISTSIZE</code>读取任何启动文件后。
</p>
</dd>
<dt><code>HISTIGNORE</code>
<a name="index-HISTIGNORE"></a>
</dt>
<dd><p>用冒号分隔的模式列表，用于决定应在历史记录列表中保存哪些命令行。每个模式都锚定在行的开头，并且必须与整行匹配（没有隐式的' <samp>*</samp> ”）。在指定的检查之后，针对该行测试每个模式<code>HISTCONTROL</code>被应用。除了正常的外壳模式匹配字符之外，' <samp>&</samp> '与上一个历史记录行匹配。' <samp>&</samp> '可以使用反斜杠转义；尝试进行匹配之前，请删除反斜杠。多行复合命令的第二行和后续行未经过测试，并且无论历史记录的值如何，都会添加到历史记录中<code>HISTIGNORE</code> 。模式匹配遵循设置<code>extglob</code>外壳选项。
</p>
<p><code>HISTIGNORE</code>包含功能<code>HISTCONTROL</code> 。一种“ <samp>&</samp> '等同于<code>ignoredups</code> ，以及“ <samp>[ ]*</samp> '等同于<code>ignorespace</code> 。结合这两种模式，并用冒号隔开，可以提供以下功能： <code>ignoreboth</code> 。
</p>
</dd>
<dt><code>HISTSIZE</code>
<a name="index-HISTSIZE"></a>
</dt>
<dd><p>历史记录列表中要记住的最大命令数。如果值为0，则命令不会保存在历史记录列表中。数值小于零会导致每个命令都保存在历史记录列表中（没有限制）。读取任何启动文件后，shell会将默认值设置为500。
</p>
</dd>
<dt><code>HISTTIMEFORMAT</code>
<a name="index-HISTTIMEFORMAT"></a>
</dt>
<dd><p>如果设置了此变量且不为null，则其值将用作以下内容的格式字符串<var>strftime</var>打印与每个历史记录条目相关的时间戳<code>history</code>内置的。如果设置了此变量，则将时间戳记写入历史文件，以便可以在Shell会话之间保留它们。这使用历史记录注释字符将时间戳记与其他历史记录行区分开。
</p>
</dd>
<dt><code>HOSTFILE</code>
<a name="index-HOSTFILE"></a>
</dt>
<dd><p>包含与以下格式相同的文件名<samp>/etc/hosts</samp>当外壳程序需要完成主机名时，应该读取该文件。Shell运行时可能会更改可能的主机名列表。值更改后下一次尝试完成主机名时，Bash将新文件的内容添加到现有列表中。如果<code>HOSTFILE</code>被设置，但是没有值，或者没有命名可读文件，Bash尝试读取<samp>/etc/hosts</samp>获取可能的主机名完成列表。什么时候<code>HOSTFILE</code>未设置，则清除主机名列表。
</p>
</dd>
<dt><code>HOSTNAME</code>
<a name="index-HOSTNAME"></a>
</dt>
<dd><p>当前主机的名称。
</p>
</dd>
<dt><code>HOSTTYPE</code>
<a name="index-HOSTTYPE"></a>
</dt>
<dd><p>描述运行Bash的机器的字符串。
</p>
</dd>
<dt><code>IGNOREEOF</code>
<a name="index-IGNOREEOF"></a>
</dt>
<dd><p>控制外壳程序在收到命令后的操作<code>EOF</code>字符作为唯一输入。如果设置，则该值表示连续的数量<code>EOF</code>可以退出外壳程序之前在输入行上第一个字符读取的字符。如果变量存在但没有数字值或没有值，则默认值为10。如果该变量不存在，则<code>EOF</code>表示输入到外壳的结尾。这仅对交互式外壳有效。
</p>
</dd>
<dt><code>INPUTRC</code>
<a name="index-INPUTRC"></a>
</dt>
<dd><p>Readline初始化文件的名称，覆盖默认值<samp>~/.inputrc</samp> 。
</p>
</dd>
<dt><code>INSIDE_EMACS</code>
<a name="index-INSIDE_005fEMACS"></a>
</dt>
<dd><p>如果Bash在shell启动时在环境中找到此变量，则假定shell在Emacs shell缓冲区中运行，并且可能会根据以下命令的值禁用行编辑： <code>TERM</code> 。
</p>
</dd>
<dt><code>LANG</code>
<a name="index-LANG"></a>
</dt>
<dd><p>用于确定未特别选择的任何类别的语言环境类别，这些变量的开头不是一个变量<code>LC_</code> 。
</p>
</dd>
<dt><code>LC_ALL</code>
<a name="index-LC_005fALL"></a>
</dt>
<dd><p>此变量将覆盖<code>LANG</code>和其他<code>LC_</code>指定语言环境类别的变量。
</p>
</dd>
<dt><code>LC_COLLATE</code>
<a name="index-LC_005fCOLLATE"></a>
</dt>
<dd><p>该变量确定排序文件名扩展结果时使用的排序规则顺序，并确定范围表达式，等价类以及文件名扩展和模式匹配内的排序序列的行为（请参见<a href="#Filename-Expansion">Filename Expansion</a> ）。
</p>
</dd>
<dt><code>LC_CTYPE</code>
<a name="index-LC_005fCTYPE"></a>
</dt>
<dd><p>此变量确定文件名扩展和模式匹配中的字符解释和字符类的行为（请参见<a href="#Filename-Expansion">Filename Expansion</a> ）。
</p>
</dd>
<dt><code>LC_MESSAGES</code>
<a name="index-LC_005fMESSAGES-1"></a>
</dt>
<dd><p>此变量确定用于翻译带双引号的字符串的语言环境，后跟一个' <samp>$</samp> '（请参阅<a href="#Locale-Translation">语言环境翻译</a> ）。
</p>
</dd>
<dt><code>LC_NUMERIC</code>
<a name="index-LC_005fNUMERIC"></a>
</dt>
<dd><p>此变量确定用于数字格式设置的语言环境类别。
</p>
</dd>
<dt><code>LC_TIME</code>
<a name="index-LC_005fTIME"></a>
</dt>
<dd><p>此变量确定用于数据和时间格式化的语言环境类别。
</p>
</dd>
<dt><code>LINENO</code>
<a name="index-LINENO"></a>
</dt>
<dd><p>当前正在执行的脚本或外壳函数中的行号。
</p>
</dd>
<dt><code>LINES</code>
<a name="index-LINES"></a>
</dt>
<dd><p>由<code>select</code>命令确定打印选择列表的列长。自动设置是否<code>checkwinsize</code>选项已启用（请参阅<a href="#The-Shopt-Builtin">内置的Shopt</a> ），或者在收到<code>SIGWINCH</code> 。
</p>
</dd>
<dt><code>MACHTYPE</code>
<a name="index-MACHTYPE"></a>
</dt>
<dd><p>一个字符串，该字符串完全描述标准<small>GNU中</small>执行Bash的系统类型<var>cpu-company-system</var>格式。
</p>
</dd>
<dt><code>MAILCHECK</code>
<a name="index-MAILCHECK"></a>
</dt>
<dd><p>Shell应该多久（以秒为单位）检查在<code>MAILPATH</code>要么<code>MAIL</code>变量。默认值为60秒。当需要检查邮件时，外壳程序会在显示主提示之前进行检查。如果未设置此变量，或者将其设置为不是大于或等于零的数字的值，则Shell将禁用邮件检查。
</p>
</dd>
<dt><code>MAPFILE</code>
<a name="index-MAPFILE"></a>
</dt>
<dd><p>创建的数组变量，用于保存由<code>mapfile</code>没有提供变量名时内置。
</p>
</dd>
<dt><code>OLDPWD</code>
<a name="index-OLDPWD"></a>
</dt>
<dd><p>上一个工作目录由<code>cd</code>内置的。
</p>
</dd>
<dt><code>OPTERR</code>
<a name="index-OPTERR"></a>
</dt>
<dd><p>如果设置为值1，Bash将显示由<code>getopts</code>内置命令。
</p>
</dd>
<dt><code>OSTYPE</code>
<a name="index-OSTYPE"></a>
</dt>
<dd><p>描述运行Bash的操作系统的字符串。
</p>
</dd>
<dt><code>PIPESTATUS</code>
<a name="index-PIPESTATUS"></a>
</dt>
<dd><p>一个数组变量（请参阅<a href="#Arrays">Arrays</a> ），其中包含最近执行的前台管道（可能仅包含一个命令）中进程的退出状态值的列表。
</p>
</dd>
<dt><code>POSIXLY_CORRECT</code>
<a name="index-POSIXLY_005fCORRECT"></a>
</dt>
<dd><p>如果此变量在Bash启动时所在的环境中，则外壳程序将在读取启动文件之前进入<small>POSIX</small>模式（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX Mode</a> ），就像<samp>--posix</samp>提供了调用选项。如果在外壳程序运行时设置了它，则Bash启用<small>POSIX</small>模式，就像命令</p><div class="example">
<pre class="example"><code>set -o posix</code>
</pre></div>
<p>已被处决。当外壳程序进入<small>POSIX</small>模式时，如果尚未设置此变量，它将设置该变量。
</p>
</dd>
<dt><code>PPID</code>
<a name="index-PPID"></a>
</dt>
<dd><p>Shell的父进程的进程<small>ID</small> 。此变量是只读的。
</p>
</dd>
<dt><code>PROMPT_COMMAND</code>
<a name="index-PROMPT_005fCOMMAND"></a>
</dt>
<dd><p>如果设置了该值，则该值将解释为在打印每个主提示之前执行的命令（ <code>$PS1</code> ）。
</p>
</dd>
<dt><code>PROMPT_DIRTRIM</code>
<a name="index-PROMPT_005fDIRTRIM"></a>
</dt>
<dd><p>如果设置为大于零的数字，则该值将用作扩展目录扩展时保留的尾随目录组件的数量。 <code>\w</code>和<code>\W</code>提示字符串转义（请参阅<a href="#Controlling-the-Prompt">控制提示</a> ）。删除的字符将替换为省略号。
</p>
</dd>
<dt><code>PS0</code>
<a name="index-PS0"></a>
</dt>
<dd><p>该参数的值像<var>PS1</var>并在读取命令之后和执行命令之前由交互式外壳显示。
</p>
</dd>
<dt><code>PS3</code>
<a name="index-PS3"></a>
</dt>
<dd><p>此变量的值用作提示。 <code>select</code>命令。如果未设置此变量，则<code>select</code>命令提示符带有' <samp>#?</samp> '</p>
</dd>
<dt><code>PS4</code>
<a name="index-PS4"></a>
</dt>
<dd><p>该参数的值像<var>PS1</var>展开的值是在执行以下操作时在回显命令行之前打印的提示<samp>-x</samp>选项已设置（请参阅<a href="#The-Set-Builtin">内置内置集</a> ）。必要时，将扩展值的第一个字符复制多次，以指示多个间接级别。默认值为“ <samp>+</samp> '。
</p>
</dd>
<dt><code>PWD</code>
<a name="index-PWD"></a>
</dt>
<dd><p>当前工作目录由设置<code>cd</code>内置的。
</p>
</dd>
<dt><code>RANDOM</code>
<a name="index-RANDOM"></a>
</dt>
<dd><p>每次引用此参数时，都会生成0到32767之间的随机整数。为该变量分配值将为随机数生成器提供种子。
</p>
</dd>
<dt><code>READLINE_LINE</code>
<a name="index-READLINE_005fLINE"></a>
</dt>
<dd><p>Readline行缓冲区的内容，与' <samp>bind -x</samp> '（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。
</p>
</dd>
<dt><code>READLINE_POINT</code>
<a name="index-READLINE_005fPOINT"></a>
</dt>
<dd><p>插入点在Readline行缓冲区中的位置，用于与' <samp>bind -x</samp> '（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。
</p>
</dd>
<dt><code>REPLY</code>
<a name="index-REPLY"></a>
</dt>
<dd><p>的默认变量<code>read</code>内置的。
</p>
</dd>
<dt><code>SECONDS</code>
<a name="index-SECONDS"></a>
</dt>
<dd><p>此变量扩展为自启动外壳以来的秒数。分配给该变量会将计数重置为分配的值，展开的值将成为分配的值加上分配以来的秒数。
</p>
</dd>
<dt><code>SHELL</code>
<a name="index-SHELL"></a>
</dt>
<dd><p>外壳程序的完整路径名保留在此环境变量中。如果外壳启动时未设置，则Bash为其分配当前用户登录外壳的完整路径名。
</p>
</dd>
<dt><code>SHELLOPTS</code>
<a name="index-SHELLOPTS"></a>
</dt>
<dd><p>以冒号分隔的已启用外壳程序选项列表。列表中的每个字词都是<samp>-o</samp>选项<code>set</code>内置命令（请参阅<a href="#The-Set-Builtin">“内置集”</a> ）。选项出现在<code>SHELLOPTS</code>被报告为“ <samp>on</samp>由<samp>set -o</samp> '。如果Bash启动时该变量在环境中，则在读取任何启动文件之前，将启用列表中的每个shell选项。此变量是只读的。
</p>
</dd>
<dt><code>SHLVL</code>
<a name="index-SHLVL"></a>
</dt>
<dd><p>每次启动新的Bash实例时增加一。这是为了统计您的Bash shell嵌套的深度。
</p>
</dd>
<dt><code>TIMEFORMAT</code>
<a name="index-TIMEFORMAT"></a>
</dt>
<dd><p>此参数的值用作格式字符串，用于指定前缀为的管道的定时信息的方式。 <code>time</code>应显示保留字。' <samp>%</samp>字符引入了转义序列，该序列被扩展为时间值或其他信息。转义序列及其含义如下：大括号表示可选部分。
</p>
<dl compact>
<dt><code>%%</code></dt>
<dd><p>文字' <samp>%</samp> '。
</p>
</dd>
<dt><code>%[<var>p</var>][l]R</code></dt>
<dd><p>经过的时间（以秒为单位）。
</p>
</dd>
<dt><code>%[<var>p</var>][l]U</code></dt>
<dd><p>用户模式下花费的CPU秒数。
</p>
</dd>
<dt><code>%[<var>p</var>][l]S</code></dt>
<dd><p>在系统模式下花费的CPU秒数。
</p>
</dd>
<dt><code>%P</code></dt>
<dd><p>CPU百分比，计算为（％U +％S）/％R。</p></dd>
</dl>

<p>可选的<var>p</var>是指定精度的数字，即小数点后的小数位数。值为0不会输出小数点或小数。小数点后最多可指定三个位置；的值<var>p</var>大于3更改为3。如果<var>p</var>未指定，则使用值3。
</p>
<p>可选的<code>l</code>指定表格的较长格式，包括分钟<var>MM</var>米<var>SS</var> 。 <var>FF</var> s。的价值<var>p</var>确定是否包含分数。
</p>
<p>如果未设置此变量，则Bash的行为就好像它具有该值</p><div class="example">
<pre class="example"><code>$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'</code>
</pre></div>
<p>如果值为空，则不显示任何计时信息。显示格式字符串时，将添加尾随换行符。
</p>
</dd>
<dt><code>TMOUT</code>
<a name="index-TMOUT"></a>
</dt>
<dd><p>如果设置为大于零的值， <code>TMOUT</code>被视为默认超时<code>read</code>内置（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。的<code>select</code>如果输入在之后没有到达，则命令（请参阅<a href="#Conditional-Constructs">条件构造</a> ）终止<code>TMOUT</code>输入来自终端的秒数。
</p>
<p>在交互式外壳程序中，该值解释为发出主提示后等待一行输入的秒数。如果没有完整的输入行，Bash将在等待该秒数后终止。
</p>
</dd>
<dt><code>TMPDIR</code>
<a name="index-TMPDIR"></a>
</dt>
<dd><p>如果设置，则Bash将其值用作目录的名称，Bash在该目录中创建临时文件以供Shell使用。
</p>
</dd>
<dt><code>UID</code>
<a name="index-UID"></a>
</dt>
<dd><p>当前用户的数字真实用户ID。此变量是只读的。
</p>
</dd>
</dl>

<hr>
<a name="Bash-Features"></a>
<div class="header">
<p>下一篇： <a href="#Job-Control" rel="next" accesskey="n">作业控制</a> ，上一篇： <a href="#Shell-Variables" rel="prev" accesskey="p">Shell变量</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Features-2"></a>
<h2 class="chapter">6 Bash功能</h2>

<p>本章介绍Bash独有的功能。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Invoking-Bash" accesskey="1">调用Bash</a> ：</td><td>  </td><td align="left" valign="top">您可以为Bash提供的命令行选项。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-Startup-Files" accesskey="2">Bash启动文件</a> ：</td><td>  </td><td align="left" valign="top">Bash何时以及如何执行脚本。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Interactive-Shells" accesskey="3">交互式外壳</a> ：</td><td>  </td><td align="left" valign="top">什么是交互式外壳。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-Conditional-Expressions" accesskey="4">Bash条件表达式</a> ：</td><td>  </td><td align="left" valign="top">用于构成表达式的基元<code>test</code>内置的。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Arithmetic" accesskey="5">Shell算术</a> ：</td><td>  </td><td align="left" valign="top">Shell变量的算术运算。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Aliases" accesskey="6">别名</a> ：</td><td>  </td><td align="left" valign="top">用一个命令代替另一个命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Arrays" accesskey="7">数组</a> ：</td><td>  </td><td align="left" valign="top">数组变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#The-Directory-Stack" accesskey="8">目录堆栈</a> ：</td><td>  </td><td align="left" valign="top">访问目录的历史记录。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Controlling-the-Prompt" accesskey="9">控制提示</a> ：</td><td>  </td><td align="left" valign="top">自定义各种提示字符串。
</td></tr>
<tr><td align="left" valign="top">• <a href="#The-Restricted-Shell">受限外壳</a> ：</td><td>  </td><td align="left" valign="top">一种更受控制的Shell执行模式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ：</td><td>  </td><td align="left" valign="top">使Bash的行为更接近POSIX标准指定的行为。
</td></tr>
</tbody></table>

<hr>
<a name="Invoking-Bash"></a>
<div class="header">
<p>下一页： <a href="#Bash-Startup-Files" rel="next" accesskey="n">Bash启动文件</a> ，上： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Invoking-Bash-1"></a>
<h3 class="section">6.1调用Bash</h3>

<div class="example">
<pre class="example">bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o <var>option</var>]
    [-O <var>shopt_option</var>] [<var>argument</var> &hellip;]
bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o <var>option</var>]
    [-O <var>shopt_option</var>] -c <var>string</var> [<var>argument</var> &hellip;]
bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o <var>option</var>]
    [-O <var>shopt_option</var>] [<var>argument</var> &hellip;]
</pre></div>

<p>与一起使用的所有单字符选项<code>set</code>当调用shell时，builtin（请参阅<a href="#The-Set-Builtin">Set Builtin</a> ）可以用作选项。此外，您可以使用多个多字符选项。这些选项必须出现在命令行上，然后才能识别单字符选项。
</p>
<dl compact>
<dt><code>--debugger</code></dt>
<dd><p>安排在Shell启动之前执行调试器概要文件。打开扩展调试模式（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin）</a> <code>extdebug</code>选项<code>shopt</code>内置）。
</p>
</dd>
<dt><code>--dump-po-strings</code></dt>
<dd><p>所有带双引号的字符串的列表，后跟' <samp>$</samp> '打印在<small>GNU中</small>的标准输出上<code>gettext</code> PO（便携式对象）文件格式。相当于<samp>-D</samp>除了输出格式。
</p>
</dd>
<dt><code>--dump-strings</code></dt>
<dd><p>相当于<samp>-D</samp> 。
</p>
</dd>
<dt><code>--help</code></dt>
<dd><p>在标准输出上显示用法消息，并成功退出。
</p>
</dd>
<dt><code>--init-file <var>filename</var></code></dt>
<dt><code>--rcfile <var>filename</var></code></dt>
<dd><p>从执行命令<var>filename</var> （代替<samp>~/.bashrc</samp> ）放在一个交互式外壳中。
</p>
</dd>
<dt><code>--login</code></dt>
<dd><p>相当于<samp>-l</samp> 。
</p>
</dd>
<dt><code>--noediting</code></dt>
<dd><p>当外壳是交互式的时，不要使用<small>GNU</small> Readline库（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）来读取命令行。
</p>
</dd>
<dt><code>--noprofile</code></dt>
<dd><p>不要加载系统范围的启动文件<samp>/etc/profile</samp>或任何个人初始化文件<samp>~/.bash_profile</samp> ， <samp>~/.bash_login</samp> ， 要么<samp>~/.profile</samp>当Bash作为登录shell调用时。
</p>
</dd>
<dt><code>--norc</code></dt>
<dd><p>不要读<samp>~/.bashrc</samp>交互式外壳中的初始化文件。默认情况下，如果shell被调用为<code>sh</code> 。
</p>
</dd>
<dt><code>--posix</code></dt>
<dd><p>更改默认操作与<small>POSIX</small>标准不同的Bash行为，以匹配该标准。这旨在使Bash成为该标准的严格超集。见<a href="#Bash-POSIX-Mode">击POSIX模式</a> ，对于击<small>POSIX</small>模式的描述。
</p>
</dd>
<dt><code>--restricted</code></dt>
<dd><p>使该外壳成为受限外壳（请参阅<a href="#The-Restricted-Shell">受限外壳</a> ）。
</p>
</dd>
<dt><code>--verbose</code></dt>
<dd><p>相当于<samp>-v</samp> 。在读取时打印外壳输入行。
</p>
</dd>
<dt><code>--version</code></dt>
<dd><p>在标准输出上显示此Bash实例的版本信息，并成功退出。
</p></dd>
</dl>

<p>调用时可能会提供几个单字符选项，但这些选项不随<code>set</code>内置的。
</p>
<dl compact>
<dt><code>-c</code></dt>
<dd><p>从第一个非选项参数读取并执行命令<var>command_string</var> ，然后退出。如果后面有参数<var>command_string</var> ，第一个参数分配给<code>$0</code>剩下的所有参数都分配给位置参数。分配给<code>$0</code>设置外壳的名称，该名称用于警告和错误消息。
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>强制外壳以交互方式运行。交互式外壳在<a href="#Interactive-Shells">交互式外壳中</a>进行了描述。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>使此shell行为就像登录时已直接调用它一样。如果外壳是交互式的，则等效于使用' <samp>exec -l bash</samp> '。当外壳不是交互式的时，将执行登录外壳启动文件。' <samp>exec bash -l</samp> ' 要么 ' <samp>exec bash --login</samp> '将用Bash登录shell替换当前shell。有关登录Shell特殊行为的说明，请参见<a href="#Bash-Startup-Files">Bash启动文件</a> 。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>使该外壳成为受限外壳（请参阅<a href="#The-Restricted-Shell">受限外壳</a> ）。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>如果存在此选项，或者在选项处理之后没有剩余参数，那么将从标准输入中读取命令。该选项允许在调用交互式外壳或通过管道读取输入时设置位置参数。
</p>
</dd>
<dt><code>-D</code></dt>
<dd><p>所有带双引号的字符串的列表，后跟' <samp>$</samp> '打印在标准输出上。这些是在当前语言环境不存在时需要进行语言翻译的字符串<code>C</code>要么<code>POSIX</code> （请参阅<a href="#Locale-Translation">语言环境翻译</a> ）。这意味着<samp>-n</samp>选项;没有命令将被执行。
</p>
</dd>
<dt><code>[-+]O [<var>shopt_option</var>]</code></dt>
<dd><p><var>shopt_option</var>是<code>shopt</code>内置（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ）。如果<var>shopt_option</var>存在， <samp>-O</samp>设置该选项的值； <samp>+O</samp>取消设置。如果<var>shopt_option</var>未提供，则接受的shell选项的名称和值<code>shopt</code>在标准输出上打印。如果调用选项是<samp>+O</samp> ，输出将以一种可以重复用作输入的格式显示。
</p>
</dd>
<dt><code>--</code></dt>
<dd><p>一种<code>--</code>向选项结束发出信号，并禁用进一步的选项处理。后面的任何参数<code>--</code>被视为文件名和参数。
</p></dd>
</dl>

<a name="index-login-shell"></a>
<p><em>登录</em> shell是一个参数为零的第一个字符为' <samp>-</samp> '，或使用<samp>--login</samp>选项。
</p>
<a name="index-interactive-shell"></a>
<p><em>交互式</em> shell是一个没有非选项参数的启动，除非<samp>-s</samp>指定，但不指定<samp>-c</samp>选件，其输入和输出都连接到端子（由<code>isatty(3)</code> ），或者以<samp>-i</samp>选项。有关更多信息，请参见<a href="#Interactive-Shells">Interactive Shells</a> 。
</p>
<p>如果在处理选项后仍保留参数，并且<samp>-c</samp>也不是<samp>-s</samp>提供了option选项后，第一个参数假定为包含shell命令的文件名（请参见<a href="#Shell-Scripts">Shell Scripts</a> ）。当以这种方式调用Bash时， <code>$0</code>设置为文件名，位置参数设置为其余参数。Bash从该文件读取并执行命令，然后退出。Bash的退出状态是脚本中最后执行的命令的退出状态。如果未执行任何命令，则退出状态为0。
</p>
<hr>
<a name="Bash-Startup-Files"></a>
<div class="header">
<p>下一篇： <a href="#Interactive-Shells" rel="next" accesskey="n">交互式Shells</a> ，上一篇： <a href="#Invoking-Bash" rel="prev" accesskey="p">调用Bash</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Startup-Files-1"></a>
<h3 class="section">6.2 Bash启动文件</h3>
<a name="index-startup-files"></a>

<p>本节描述Bash如何执行其启动文件。如果存在任何文件但无法读取，则Bash报告错误。如上在“ Tilde扩展”下所述，Tildes的文件名被扩展（请参见<a href="#Tilde-Expansion">Tilde Expansion</a> ）。
</p>
<p>交互式外壳在<a href="#Interactive-Shells">交互式外壳中</a>进行了描述。
</p>
<a name="Invoked-as-an-interactive-login-shell_002c-or-with-_002d_002dlogin"></a>
<h4 class="subsubheading">作为交互式登录shell调用，或与<samp>--login</samp></h4>

<p>当Bash作为交互式登录shell或作为非交互式shell与<samp>--login</samp>选项，它首先从文件中读取并执行命令<samp>/etc/profile</samp> ，如果该文件存在。读取该文件后，它会寻找<samp>~/.bash_profile</samp> ， <samp>~/.bash_login</samp>和<samp>~/.profile</samp> ，然后从存在的第一个可读命令中读取并执行命令。的<samp>--noprofile</samp>启动外壳程序时，可以使用该选项来禁止此行为。
</p>
<p>当交互式登录外壳退出时，或非交互式登录外壳执行<code>exit</code>内置命令，Bash从文件中读取并执行命令<samp>~/.bash_logout</samp> （如果存在）。
</p>
<a name="Invoked-as-an-interactive-non_002dlogin-shell"></a>
<h4 class="subsubheading">作为交互式非登录外壳程序调用</h4>

<p>当启动非登录外壳程序的交互式外壳程序时，Bash将读取并执行以下命令： <samp>~/.bashrc</samp> ，如果该文件存在。这可以通过使用<samp>--norc</samp>选项。的<samp>--rcfile <var>file</var></samp>选项将强制Bash从中读取和执行命令<var>file</var>代替<samp>~/.bashrc</samp> 。
</p>
<p>所以通常<samp>~/.bash_profile</samp>包含行</p><div class="example">
<pre class="example"><code>if [ -f ~/.bashrc ]; then . ~/.bashrc; fi</code>
</pre></div>
<p>在任何特定于登录的初始化之后（或之前）。
</p>
<a name="Invoked-non_002dinteractively"></a>
<h4 class="subsubheading">非交互调用</h4>

<p>例如，以非交互方式启动Bash时，要运行shell脚本，它将查找变量<code>BASH_ENV</code>在环境中，展开它的值（如果它出现在其中），并使用展开的值作为要读取和执行的文件的名称。Bash的行为就像执行以下命令一样：</p><div class="example">
<pre class="example"><code>if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi</code>
</pre></div>
<p>但价值<code>PATH</code>变量不用于搜索文件名。
</p>
<p>如上所述，如果使用<samp>--login</samp>选项，Bash尝试从登录Shell启动文件中读取和执行命令。
</p>
<a name="Invoked-with-name-sh"></a>
<h4 class="subsubheading">用名称调用<code>sh</code></h4>

<p>如果使用名称调用Bash <code>sh</code> ，它试图模仿历史版本的启动行为<code>sh</code>尽可能接近，同时也要符合<small>POSIX</small>标准。
</p>
<p>当作为交互式登录外壳程序或与<samp>--login</samp>选项，它首先尝试从中读取和执行命令<samp>/etc/profile</samp>和<samp>~/.profile</samp> ， 以该顺序。的<samp>--noprofile</samp>选项可用于禁止这种行为。当作为具有名称的交互式外壳程序调用时<code>sh</code> ，Bash查找变量<code>ENV</code> ，则扩展其值（如果已定义），并将扩展后的值用作要读取和执行的文件的名称。由于shell被调用为<code>sh</code>不会尝试从任何其他启动文件读取和执行命令， <samp>--rcfile</samp>选项无效。使用名称调用的非交互式外壳<code>sh</code>不会尝试读取任何其他启动文件。
</p>
<p>当作为<code>sh</code> ，读取启动文件后Bash进入<small>POSIX</small>模式。
</p>
<a name="Invoked-in-POSIX-mode"></a>
<h4 class="subsubheading">以<small>POSIX</small>模式调用</h4>

<p>当以<small>POSIX</small>模式启动Bash时， <samp>--posix</samp>命令行选项，它遵循用于启动文件的<small>POSIX</small>标准。在这种模式下，交互式外壳扩展了<code>ENV</code>从名称为扩展值的文件中读取并执行变量和命令。不会读取其他启动文件。
</p>
<a name="Invoked-by-remote-shell-daemon"></a>
<h4 class="subsubheading">由远程Shell守护程序调用</h4>

<p>Bash尝试确定何时在其标准输入连接到网络连接的情况下运行它，通常是由远程Shell守护程序执行时<code>rshd</code>或安全Shell守护程序<code>sshd</code> 。如果Bash确定它是以这种方式运行的，它将读取并执行以下命令： <samp>~/.bashrc</samp> ，如果该文件存在并且可读。如果作为调用，它将不会执行此操作<code>sh</code> 。的<samp>--norc</samp>选项可以用来禁止这种行为，并且<samp>--rcfile</samp>选项可用于强制读取另一个文件，但都不<code>rshd</code>也不<code>sshd</code>通常使用这些选项来调用shell或允许它们被指定。
</p>
<a name="Invoked-with-unequal-effective-and-real-UID_002fGIDs"></a>
<h4 class="subsubheading">用不相等的有效和实际<small>UID / GID</small>调用</h4>

<p>如果Bash在有效用户（组）ID不等于真实用户（组）ID的情况下启动，并且<samp>-p</samp>未提供该选项，未读取任何启动文件，未从环境继承shell函数， <code>SHELLOPTS</code> ， <code>BASHOPTS</code> ， <code>CDPATH</code>和<code>GLOBIGNORE</code>如果变量出现在环境中，则将其忽略，并将有效用户ID设置为实际用户ID。如果<samp>-p</samp>选项在调用时提供，启动行为相同，但是有效用户标识未重置。
</p>
<hr>
<a name="Interactive-Shells"></a>
<div class="header">
<p>下一篇： <a href="#Bash-Conditional-Expressions" rel="next" accesskey="n">Bash条件表达式</a> ，上一篇： <a href="#Bash-Conditional-Expressions" rel="next" accesskey="n">Bash</a> <a href="#Bash-Startup-Files" rel="prev" accesskey="p">启动文件</a> ，上一篇： <a href="#Bash-Conditional-Expressions" rel="next" accesskey="n">Bash</a> <a href="#Bash-Features" rel="up" accesskey="u">功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Interactive-Shells-1"></a>
<h3 class="section">6.3互动壳</h3>
<a name="index-interactive-shell-1"></a>
<a name="index-shell_002c-interactive"></a>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#What-is-an-Interactive-Shell_003f" accesskey="1">什么是交互式外壳？</a> ：</td><td>  </td><td align="left" valign="top">什么决定了外壳是否是交互式的。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Is-this-Shell-Interactive_003f" accesskey="2">此Shell互动吗？</a> ：</td><td>  </td><td align="left" valign="top">如何判断外壳是否是交互式的。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Interactive-Shell-Behavior" accesskey="3">交互式外壳行为</a> ：</td><td>  </td><td align="left" valign="top">交互式外壳中有哪些变化？
</td></tr>
</tbody></table>

<hr>
<a name="What-is-an-Interactive-Shell_003f"></a>
<div class="header">
<p>下一页： <a href="#Is-this-Shell-Interactive_003f" rel="next" accesskey="n">此Shell互动吗？</a> ，上： <a href="#Interactive-Shells" rel="up" accesskey="u">Interactive Shells</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-is-an-Interactive-Shell_003f-1"></a>
<h4 class="subsection">6.3.1什么是交互式外壳？</h4>

<p>交互式shell是一个没有非选项参数的启动，除非<samp>-s</samp>指定，但不指定<samp>-c</samp>选件，其输入和错误输出均连接到端子（由<code>isatty(3)</code> ），或者以<samp>-i</samp>选项。
</p>
<p>交互式外壳程序通常从用户终端读取和写入用户终端。
</p>
<p>的<samp>-s</samp>交互式外壳程序启动时，可以使用invocation选项来设置位置参数。
</p>
<hr>
<a name="Is-this-Shell-Interactive_003f"></a>
<div class="header">
<p>下一篇： <a href="#Interactive-Shell-Behavior" rel="next" accesskey="n">Interactive Shell行为</a> ，上一篇： <a href="#What-is-an-Interactive-Shell_003f" rel="prev" accesskey="p">什么是Interactive Shell？</a> ，上： <a href="#Interactive-Shells" rel="up" accesskey="u">Interactive Shells</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Is-this-Shell-Interactive_003f-1"></a>
<h4 class="subsection">6.3.2此Shell是交互式的吗？</h4>

<p>要确定启动脚本中Bash是否正在交互式运行，请测试“ <samp>-</samp> '特殊参数。它包含<code>i</code>当外壳是交互式的时。例如：</p>
<div class="example">
<pre class="example">case &quot;$-&quot; in
*i*)	echo This shell is interactive ;;
*)	echo This shell is not interactive ;;
esac
</pre></div>

<p>或者，启动脚本可以检查变量<code>PS1</code> ;在非交互式shell中未设置它，而在交互式shell中设置它。从而：</p>
<div class="example">
<pre class="example">if [ -z &quot;$PS1&quot; ]; then
        echo This shell is not interactive
else
        echo This shell is interactive
fi
</pre></div>

<hr>
<a name="Interactive-Shell-Behavior"></a>
<div class="header">
<p>上一篇： <a href="#Is-this-Shell-Interactive_003f" rel="prev" accesskey="p">此Shell互动吗？</a> ，上： <a href="#Interactive-Shells" rel="up" accesskey="u">Interactive Shells</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Interactive-Shell-Behavior-1"></a>
<h4 class="subsection">6.3.3交互式Shell行为</h4>

<p>当shell交互式运行时，它将以几种方式改变其行为。
</p>
<ol>
<li>按照<a href="#Bash-Startup-Files">Bash</a>启动文件中的说明读取和执行<a href="#Bash-Startup-Files">启动文件</a> 。

</li><li>默认情况下，作业控制（请参阅<a href="#Job-Control">作业控制</a> ）处于启用状态。当作业控制生效时，Bash会忽略键盘生成的作业控制信号<code>SIGTTIN</code> ， <code>SIGTTOU</code>和<code>SIGTSTP</code> 。

</li><li>Bash展开并显示<code>PS1</code>在阅读命令的第一行之前，展开并显示<code>PS2</code>在阅读多行命令的第二行和后续行之前。Bash展开并显示<code>PS0</code>在读取命令之后但在执行命令之前。有关提示字符串转义序列的完整列表，请参见<a href="#Controlling-the-Prompt">控制提示</a> 。

</li><li>Bash执行<code>PROMPT_COMMAND</code>在打印主提示之前将变量作为命令， <code>$PS1</code> （请参阅<a href="#Bash-Variables">Bash变量</a> ）。

</li><li>Readline（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）用于从用户终端读取命令。

</li><li>Bash会检查<code>ignoreeof</code>选择<code>set -o</code>而不是在收到提示后立即退出<code>EOF</code>读取命令时，在其标准输入上输入（请参阅<a href="#The-Set-Builtin">《内置函数》</a> ）。

</li><li>默认情况下，命令历史记录（请参阅<a href="#Bash-History-Facilities">Bash历史记录工具</a> ）和历史记录扩展（请参阅<a href="#History-Interaction">History Interaction</a> ）处于启用状态。Bash会将命令历史记录保存到名为的文件中<code>$HISTFILE</code>当启用历史记录的shell退出时。

</li><li>默认情况下执行别名扩展（请参阅<a href="#Aliases">Aliases</a> ）。

</li><li>在没有任何陷阱的情况下，Bash会忽略<code>SIGTERM</code> （请参阅<a href="#Signals">信号</a> ）。

</li><li>在没有任何陷阱的情况下， <code>SIGINT</code>被捕获并处理（请参阅<a href="#Signals">信号</a> ）。
<code>SIGINT</code>将中断一些shell内置程序。

</li><li>交互式登录外壳发送一个<code>SIGHUP</code>退出时所有作业<code>huponexit</code> shell选项已启用（请参阅<a href="#Signals">Signals</a> ）。

</li><li>的<samp>-n</samp>调用选项将被忽略，并且' <samp>set -n</samp> '无效（请参阅<a href="#The-Set-Builtin">内置内置集</a> ）。

</li><li>Bash会定期检查邮件，具体取决于<code>MAIL</code> ， <code>MAILPATH</code>和<code>MAILCHECK</code> shell变量（请参阅<a href="#Bash-Variables">Bash变量</a> ）。

</li><li>由于在'之后引用了未绑定的shell变量，导致发生扩展错误<samp>set -u</samp>启用'将不会导致外壳退出（请参阅<a href="#The-Set-Builtin">内置内置集</a> ）。

</li><li>由于以下原因导致的扩展错误，shell不会退出<var>var</var>未设置或为null <code>${<var>var</var>:?<var>word</var>}</code>扩展（请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>Shell内置程序遇到的重定向错误不会导致Shell退出。

</li><li>在<small>POSIX</small>模式下运行时，返回错误状态的特殊内置函数不会导致Shell退出（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）。

</li><li>失败了<code>exec</code>不会导致外壳退出（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。

</li><li>解析器语法错误不会导致外壳退出。

</li><li>目录参数的简单拼写更正<code>cd</code>默认启用内置功能（请参阅<code>cdspell</code>选项<code>shopt</code>内置于<a href="#The-Shopt-Builtin">Shopt内置</a> ）。

</li><li>外壳程序将检查<code>TMOUT</code>变量，如果在打印后指定的秒数内未读取命令，则退出<code>$PS1</code> （请参阅<a href="#Bash-Variables">Bash变量</a> ）。

</li></ol>

<hr>
<a name="Bash-Conditional-Expressions"></a>
<div class="header">
<p>下一篇： <a href="#Shell-Arithmetic" rel="next" accesskey="n">Shell算术</a> ，上一篇： <a href="#Interactive-Shells" rel="prev" accesskey="p">交互式</a> <a href="#Shell-Arithmetic" rel="next" accesskey="n">Shell</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-Conditional-Expressions-1"></a>
<h3 class="section">6.4 Bash条件表达式</h3>
<a name="index-expressions_002c-conditional"></a>

<p>条件表达式由<code>[[</code>复合命令和<code>test</code>和<code>[</code>内置命令。的<code>test</code>和<code>[</code>命令根据参数的数量确定其行为；有关其他任何特定于命令的操作，请参见这些命令的说明。
</p>
<p>表达式可以是一元的也可以是二进制的，并且由以下基本形式组成。一元表达式通常用于检查文件的状态。也有字符串运算符和数字比较运算符。当在表达式中使用它们时，Bash特别处理多个文件名。如果运行Bash的操作系统提供了这些特殊文件，则Bash将使用它们；否则，将使用它们。否则，它将在内部用以下行为模拟它们： <var>file</var>其中一个原语的论证形式为<samp>/dev/fd/<var>N</var></samp> ，然后是文件描述符<var>N</var>被检查。如果<var>file</var>对其中一个原点的论证是其中之一<samp>/dev/stdin</samp> ， <samp>/dev/stdout</samp> ， 要么<samp>/dev/stderr</samp>分别检查文件描述符0、1或2。
</p>
<p>当与<code>[[</code> ， <samp><</samp> '和' <samp>></samp> '运算符使用当前语言环境按字典顺序排序。的<code>test</code>命令使用ASCII顺序。
</p>
<p>除非另有说明，否则对文件进行操作的原语将遵循符号链接并针对链接的目标而不是链接本身进行操作。
</p>
<dl compact>
<dt><code>-a <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在。
</p>
</dd>
<dt><code>-b <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在，并且是块特殊文件。
</p>
</dd>
<dt><code>-c <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是字符特殊文件。
</p>
</dd>
<dt><code>-d <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是目录。
</p>
</dd>
<dt><code>-e <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在。
</p>
</dd>
<dt><code>-f <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是常规文件。
</p>
</dd>
<dt><code>-g <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且其set-group-id位置1。
</p>
</dd>
<dt><code>-h <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是符号链接。
</p>
</dd>
<dt><code>-k <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且其“粘性”位被设置。
</p>
</dd>
<dt><code>-p <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是命名管道（FIFO）。
</p>
</dd>
<dt><code>-r <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且可读。
</p>
</dd>
<dt><code>-s <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且大小大于零。
</p>
</dd>
<dt><code>-t <var>fd</var></code></dt>
<dd><p>如果文件描述符为真<var>fd</var>是开放的，是指终端。
</p>
</dd>
<dt><code>-u <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在，并且其设置用户标识位已设置。
</p>
</dd>
<dt><code>-w <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在且可写。
</p>
</dd>
<dt><code>-x <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且可执行。
</p>
</dd>
<dt><code>-G <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且由有效组ID拥有。
</p>
</dd>
<dt><code>-L <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是符号链接。
</p>
</dd>
<dt><code>-N <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在，并且自上次读取以来已被修改。
</p>
</dd>
<dt><code>-O <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并由有效用户ID拥有。
</p>
</dd>
<dt><code>-S <var>file</var></code></dt>
<dd><p>如果为真<var>file</var>存在并且是一个套接字。
</p>
</dd>
<dt><code><var>file1</var> -ef <var>file2</var></code></dt>
<dd><p>如果为真<var>file1</var>和<var>file2</var>指相同的设备和inode编号。
</p>
</dd>
<dt><code><var>file1</var> -nt <var>file2</var></code></dt>
<dd><p>如果为真<var>file1</var> （根据修改日期）比<var>file2</var> ， 或者如果<var>file1</var>存在并且<var>file2</var>才不是。
</p>
</dd>
<dt><code><var>file1</var> -ot <var>file2</var></code></dt>
<dd><p>如果为真<var>file1</var>比...大<var>file2</var> ， 或者如果<var>file2</var>存在并且<var>file1</var>才不是。
</p>
</dd>
<dt><code>-o <var>optname</var></code></dt>
<dd><p>如果shell选项为true <var>optname</var>已启用。选项列表显示在<samp>-o</samp>选项<code>set</code>内置（请参阅<a href="#The-Set-Builtin">《内置集》</a> ）。
</p>
</dd>
<dt><code>-v <var>varname</var></code></dt>
<dd><p>如果shell变量为true <var>varname</var>设置（已分配值）。
</p>
</dd>
<dt><code>-R <var>varname</var></code></dt>
<dd><p>如果shell变量为true <var>varname</var>已设置，并且是名称参考。
</p>
</dd>
<dt><code>-z <var>string</var></code></dt>
<dd><p>如果长度为真<var>string</var>是零。
</p>
</dd>
<dt><code>-n <var>string</var></code></dt>
<dt><code><var>string</var></code></dt>
<dd><p>如果长度为真<var>string</var>不为零。
</p>
</dd>
<dt><code><var>string1</var> == <var>string2</var></code></dt>
<dt><code><var>string1</var> = <var>string2</var></code></dt>
<dd><p>如果字符串相等，则为真。当与<code>[[</code>命令，它将如上所述执行模式匹配（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。
</p>
<p>' <samp>=</samp> '应该与<code>test</code> <small>POSIX</small>一致性命令。
</p>
</dd>
<dt><code><var>string1</var> != <var>string2</var></code></dt>
<dd><p>如果字符串不相等，则为真。
</p>
</dd>
<dt><code><var>string1</var> < <var>string2</var></code></dt>
<dd><p>如果为真<var>string1</var>之前排序<var>string2</var>从字典上讲。
</p>
</dd>
<dt><code><var>string1</var> > <var>string2</var></code></dt>
<dd><p>如果为真<var>string1</var>排序之后<var>string2</var>从字典上讲。
</p>
</dd>
<dt><code><var>arg1</var> OP <var>arg2</var></code></dt>
<dd><p><code>OP</code>是其中之一 ' <samp>-eq</samp> '，' <samp>-ne</samp> '，' <samp>-lt</samp> '，' <samp>-le</samp> '，' <samp>-gt</samp> '， 要么 ' <samp>-ge</samp> '。这些算术二进制运算符在以下情况下返回true <var>arg1</var>等于，不等于，小于，小于或等于，大于或大于或等于<var>arg2</var> ， 分别。 <var>Arg1</var>和<var>arg2</var>可以是正整数或负整数。当与<code>[[</code>命令， <var>Arg1</var>和<var>Arg2</var>被评估为算术表达式（请参见<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。
</p></dd>
</dl>

<hr>
<a name="Shell-Arithmetic"></a>
<div class="header">
<p>下一篇： <a href="#Aliases" rel="next" accesskey="n">别名</a> ，上一篇： <a href="#Bash-Conditional-Expressions" rel="prev" accesskey="p">Bash条件表达式</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Shell-Arithmetic-1"></a>
<h3 class="section">6.5 Shell算术</h3>
<a name="index-arithmetic_002c-shell"></a>
<a name="index-shell-arithmetic"></a>
<a name="index-expressions_002c-arithmetic"></a>
<a name="index-evaluation_002c-arithmetic"></a>
<a name="index-arithmetic-evaluation"></a>

<p>Shell允许算术表达式作为Shell扩展之一或通过使用<code>((</code>复合命令<code>let</code>内置或<samp>-i</samp>选项<code>declare</code>内置的。
</p>
<p>评估是使用固定宽度的整数完成的，不检查溢出，尽管陷阱会被除以0并标记为错误。运算符及其优先级，关联性和值与C语言中的相同。以下运算符列表被分组为等优先级运算符。这些级别按优先级从高到低的顺序列出。
</p>
<dl compact>
<dt><code><var>id</var>++ <var>id</var>--</code></dt>
<dd><p>可变的后递增和后递减</p>
</dd>
<dt><code>++<var>id</var> --<var>id</var></code></dt>
<dd><p>可变的预增和预减</p>
</dd>
<dt><code>- +</code></dt>
<dd><p>一元减号和加号</p>
</dd>
<dt><code>! ~</code></dt>
<dd><p>逻辑与按位取反</p>
</dd>
<dt><code>**</code></dt>
<dd><p>求幂</p>
</dd>
<dt><code>* / %</code></dt>
<dd><p>乘法，除法，余数</p>
</dd>
<dt><code>+ -</code></dt>
<dd><p>加，减</p>
</dd>
<dt><code><< >></code></dt>
<dd><p>左右位移</p>
</dd>
<dt><code><= >= < ></code></dt>
<dd><p>比较</p>
</dd>
<dt><code>== !=</code></dt>
<dd><p>平等与不平等</p>
</dd>
<dt><code>&</code></dt>
<dd><p>按位与</p>
</dd>
<dt><code>^</code></dt>
<dd><p>按位异或</p>
</dd>
<dt><code>|</code></dt>
<dd><p>按位或</p>
</dd>
<dt><code>&&</code></dt>
<dd><p>逻辑与</p>
</dd>
<dt><code>||</code></dt>
<dd><p>逻辑或</p>
</dd>
<dt><code>expr ? expr : expr</code></dt>
<dd><p>条件运算符</p>
</dd>
<dt><code>= *= /= %= += -= <<= >>= &= ^= |=</code></dt>
<dd><p>分配</p>
</dd>
<dt><code>expr1 , expr2</code></dt>
<dd><p>逗号</p></dd>
</dl>

<p>允许使用Shell变量作为操作数；在对表达式求值之前执行参数扩展。在表达式中，也可以使用名称来引用shell变量，而无需使用参数扩展语法。如果使用名称引用而不使用参数扩展语法，则null或未设置的shell变量的值为0。变量的值在被引用时或当变量被赋予<var>integer</var>使用' <samp>declare -i</samp> '被分配了一个值。空值的计算结果为0。一个shell变量不需要它的<var>integer</var>启用该属性以在表达式中使用。
</p>
<p>前导0的常量被解释为八进制数。领先的<samp>0x</samp> ' 要么 ' <samp>0X</samp> '表示十六进制。否则，数字采用[ <var>base</var><code>#</code> ] <var>n</var> ，其中可选<var>base</var>是2到64之间的十进制数字，代表算术基数，并且<var>n</var>是该基数中的数字。如果<var>base</var><code>#</code>省略，则使用基数10。指定时<var>n</var> ，大于9的数字由小写字母，大写字母' <samp>@</samp> '和' <samp>_</samp> '， 以该顺序。如果<var>base</var>小于或等于36，小写字母和大写字母可以互换使用，以表示10到35之间的数字。
</p>
<p>运算符按优先级顺序进行评估。括号中的子表达式将首先求值，并且可能会覆盖上面的优先级规则。
</p>
<hr>
<a name="Aliases"></a>
<div class="header">
<p>下一篇： <a href="#Arrays" rel="next" accesskey="n">数组</a> ，上一篇： <a href="#Shell-Arithmetic" rel="prev" accesskey="p">Shell算术</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Aliases-1"></a>
<h3 class="section">6.6别名</h3>
<a name="index-alias-expansion"></a>

<p><var>Aliases</var>当将字符串用作简单命令的第一个单词时，允许将字符串替换为单词。Shell会维护一个别名列表，该别名可以使用<code>alias</code>和<code>unalias</code>内置命令。
</p>
<p>检查每个简单命令的第一个单词（如果未引用），以查看其是否具有别名。如果是这样，则将该单词替换为别名的文本。那些角色 ' <samp>/</samp> '，' <samp>$</samp> '，' <samp>`</samp> '，' <samp>=</samp> '，并且上面列出的任何shell元字符或引号字符都不能出现在别名中。替换文本可以包含任何有效的外壳程序输入，包括外壳程序元字符。测试替换文本的第一个单词是否具有别名，但是与被扩展的别名相同的单词不会第二次扩展。这意味着可能会有别名<code>ls</code>至<code>"ls -F"</code>例如，并且Bash不会尝试递归扩展替换文本。如果别名值的最后一个字符是<var>blank</var> ，然后还会检查别名后面的下一个命令字是否扩展了别名。
</p>
<p>别名被创建并与<code>alias</code>命令，并使用<code>unalias</code>命令。
</p>
<p>没有在替换文本中使用参数的机制，如<code>csh</code> 。如果需要参数，则应使用shell函数（请参见<a href="#Shell-Functions">Shell Functions</a> ）。
</p>
<p>如果外壳不是交互式的，则别名不会扩展，除非<code>expand_aliases</code>外壳选项使用<code>shopt</code> （请参阅<a href="#The-Shopt-Builtin">内置Shopt</a> ）。
</p>
<p>有关别名的定义和使用的规则有些混乱。在执行该行或复合命令上的任何命令之前，Bash始终至少读取完整的一行输入以及构成复合命令的所有行。读取命令时（而不是执行命令时），别名会扩展。因此，与另一条命令在同一行上出现的别名定义在读取下一行输入之前不会生效。该行中别名定义之后的命令不受新别名的影响。执行功能时，此行为也是一个问题。读取函数定义时（而不是执行函数时）会扩展别名，因为函数定义本身就是命令。结果，在函数中定义的别名直到该函数执行后才可用。为了安全起见，请始终将别名定义放在单独的行上，并且不要使用<code>alias</code>在复合命令中。
</p>
<p>对于几乎所有目的，shell函数优先于别名。
</p>
<hr>
<a name="Arrays"></a>
<div class="header">
<p>下一篇： <a href="#The-Directory-Stack" rel="next" accesskey="n">目录堆栈</a> ，上一篇： <a href="#Aliases" rel="prev" accesskey="p">别名</a> ，上： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Arrays-1"></a>
<h3 class="section">6.7阵列</h3>
<a name="index-arrays"></a>

<p>Bash提供一维索引和关联数组变量。任何变量都可以用作索引数组。的<code>declare</code>内置将显式声明一个数组。对数组的大小没有最大限制，也没有对成员进行索引或连续分配的任何要求。索引数组使用整数（包括算术表达式（请参见<a href="#Shell-Arithmetic">Shell Arithmetic</a> ））进行引用，并且从零开始。关联数组使用任意字符串。除非另有说明，否则索引数组索引必须是非负整数。
</p>
<p>如果使用语法将任何变量分配给索引数组，则将自动创建索引数组</p><div class="example">
<pre class="example"><var>name</var>[<var>subscript</var>]=<var>value</var>
</pre></div>

<p>的<var>subscript</var>被视为必须计算为数字的算术表达式。要显式声明一个数组，请使用</p><div class="example">
<pre class="example">declare -a <var>name</var>
</pre></div>
<p>语法</p><div class="example">
<pre class="example">declare -a <var>name</var>[<var>subscript</var>]
</pre></div>
<p>也被接受；的<var>subscript</var>被忽略。
</p>
<p>关联数组是使用以下方法创建的</p><div class="example">
<pre class="example">declare -A <var>name</var>
</pre></div>

<p>可以使用以下命令为数组变量指定属性<code>declare</code>和<code>readonly</code>内置。每个属性都适用于数组的所有成员。
</p>
<p>使用以下形式的复合分配将数组分配给</p><div class="example">
<pre class="example"><var>name</var>=(<var>value1</var> <var>value2</var> &hellip; )
</pre></div>
<p>每个在哪里<var>value</var>的形式<code>[<var>subscript</var>]=</code><var>string</var> 。索引数组分配不需要任何东西，但是<var>string</var> 。分配给索引数组时，如果提供了可选的下标，则该索引将分配给它；否则，分配的元素的索引是该语句分配的最后一个索引加一个。索引从零开始。
</p>
<p>分配给关联数组时，下标是必需的。
</p>
<p>该语法也被<code>declare</code>内置的。可以使用<code><var>name</var>[<var>subscript</var>]=<var>value</var></code>上面介绍的语法。
</p>
<p>分配给索引数组时，如果<var>name</var>用负数下标，该数字被解释为相对于大于最大索引的1。 <var>name</var> ，因此负索引从数组末尾算起，索引-1引用最后一个元素。
</p>
<p>数组的任何元素都可以使用<code>${<var>name</var>[<var>subscript</var>]}</code> 。需要使用花括号来避免与Shell的文件名扩展运算符冲突。如果<var>subscript</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp> '，单词扩展到数组的所有成员<var>name</var> 。仅当单词出现在双引号中时，这些下标才不同。如果单词被双引号<code>${<var>name</var>[*]}</code>扩展为一个单词，每个数组成员的值由<code>IFS</code>变量，和<code>${<var>name</var>[@]}</code>展开的每个元素<var>name</var>换一个词。没有数组成员时<code>${<var>name</var>[@]}</code>扩展为空。如果双引号扩展出现在单词内，则第一个参数的扩展与原始单词的开头部分合并，而最后一个参数的扩展与原始单词的末尾部分连接。这类似于特殊参数的扩展<samp>@</samp> '和' <samp>*</samp> '。
<code>${#<var>name</var>[<var>subscript</var>]}</code>扩展到<code>${<var>name</var>[<var>subscript</var>]}</code> 。如果<var>subscript</var>是' <samp>@</samp> ' 要么 ' <samp>*</samp> '，扩展是数组中元素的数量。如果<var>subscript</var>用于引用索引数组的元素的结果的值小于零，它被解释为相对于大于数组最大索引的数，因此负索引从数组末尾算起，索引为- 1表示最后一个元素。
</p>
<p>引用没有下标的数组变量等效于引用下标0。使用有效下标对变量的任何引用都是合法的，并且<code>bash</code>必要时将创建一个数组。
</p>
<p>如果下标已分配值，则认为数组变量已设置。空字符串是有效值。
</p>
<p>可以获得数组的键（索引）以及值。$ {！ <var>name</var> [@]}和$ {！ <var>name</var> [*]}扩展到数组变量中分配的索引<var>name</var> 。双引号中的处理类似于特殊参数的扩展' <samp>@</samp> '和' <samp>*</samp> '用双引号引起来。
</p>
<p>的<code>unset</code>内置用于破坏数组。
<code>unset <var>name</var>[<var>subscript</var>]</code>销毁索引处的数组元素<var>subscript</var> 。如上所述，对索引数组的负下标进行解释。取消设置数组变量的最后一个元素不会取消设置该变量。
<code>unset <var>name</var></code> ，在哪里<var>name</var>是一个数组，删除整个数组。'的下标<samp>*</samp> ' 要么 ' <samp>@</samp>也会删除整个数组。
</p>
<p>当使用带下标的变量名称作为命令的参数时，例如<code>unset</code> ，而无需使用上述单词扩展语法，则该参数将受Shell的文件名扩展的约束。如果不需要扩展文件名，则应使用引号。
</p>
<p>的<code>declare</code> ， <code>local</code>和<code>readonly</code>内置函数每个接受一个<samp>-a</samp>指定索引数组的选项和一个<samp>-A</samp>指定关联数组的选项。如果同时提供两个选项， <samp>-A</samp>优先。的<code>read</code>内置接受<samp>-a</samp>选项，将从标准输入读取的单词列表分配给一个数组，并且可以从标准输入读取值到单个数组元素。的<code>set</code>和<code>declare</code>内建函数以允许它们重新用作输入的方式显示数组值。
</p>
<hr>
<a name="The-Directory-Stack"></a>
<div class="header">
<p>下一篇： <a href="#Controlling-the-Prompt" rel="next" accesskey="n">控制提示符</a> ，上一篇： <a href="#Arrays" rel="prev" accesskey="p">数组</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Directory-Stack-1"></a>
<h3 class="section">6.8目录栈</h3>
<a name="index-directory-stack"></a>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Directory-Stack-Builtins" accesskey="1">目录堆栈内置</a> ：</td><td>  </td><td align="left" valign="top">Bash内置命令可操纵目录堆栈。
</td></tr>
</tbody></table>

<p>目录堆栈是最近访问的目录的列表。的<code>pushd</code>内置会在更改当前目录时将目录添加到堆栈中，并且<code>popd</code>内置从堆栈中删除指定的目录，并将当前目录更改为已删除的目录。的<code>dirs</code>内置显示目录堆栈的内容。当前目录始终是目录堆栈的“顶部”。
</p>
<p>目录堆栈的内容也可以作为<code>DIRSTACK</code>外壳变量。
</p>
<hr>
<a name="Directory-Stack-Builtins"></a>
<div class="header">
<p>上一篇： <a href="#The-Directory-Stack" rel="up" accesskey="u">目录堆栈</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Directory-Stack-Builtins-1"></a>
<h4 class="subsection">6.8.1目录堆栈内置</h4>

<dl compact>
<dt><code>dirs</code></dt>
<dd><a name="index-dirs"></a>
<div class="example">
<pre class="example">dirs [-clpv] [+<var>N</var> | -<var>N</var>]
</pre></div>

<p>显示当前记忆目录的列表。目录随即添加到列表中<code>pushd</code>命令;的<code>popd</code>命令从列表中删除目录。当前目录始终是堆栈中的第一个目录。
</p>
<dl compact>
<dt><code>-c</code></dt>
<dd><p>通过删除所有元素来清除目录堆栈。
</p></dd>
<dt><code>-l</code></dt>
<dd><p>使用完整路径名生成列表；默认列表格式使用波浪号来表示主目录。
</p></dd>
<dt><code>-p</code></dt>
<dd><p>原因<code>dirs</code>打印每行只有一个条目的目录堆栈。
</p></dd>
<dt><code>-v</code></dt>
<dd><p>原因<code>dirs</code>打印每行只有一个条目的目录堆栈，并在堆栈中为每个条目加上索引。
</p></dd>
<dt><code>+<var>N</var></code></dt>
<dd><p>显示<var>N</var>目录（从列表的左侧开始计数，由<code>dirs</code> （不带选项调用时），从零开始。
</p></dd>
<dt><code>-<var>N</var></code></dt>
<dd><p>显示<var>N</var>目录（从列表的右边开始计数） <code>dirs</code> （不带选项调用时），从零开始。
</p></dd>
</dl>

</dd>
<dt><code>popd</code></dt>
<dd><a name="index-popd"></a>
<div class="example">
<pre class="example">popd [-n] [+<var>N</var> | -<var>N</var>]
</pre></div>

<p>如果没有给出任何参数， <code>popd</code>从堆栈中删除顶层目录并执行<code>cd</code>到新的顶层目录。元素从0开始编号，从列出的第一个目录开始<code>dirs</code> ;那是， <code>popd</code>相当于<code>popd +0</code> 。
</p>
<dl compact>
<dt><code>-n</code></dt>
<dd><p>从堆栈中删除目录时，禁止正常的目录更改，以便仅操作堆栈。
</p></dd>
<dt><code>+<var>N</var></code></dt>
<dd><p>删除<var>N</var>目录（从列表的左侧开始计数，由<code>dirs</code> ），从零开始。
</p></dd>
<dt><code>-<var>N</var></code></dt>
<dd><p>删除<var>N</var>目录（从列表的右边开始计数） <code>dirs</code> ），从零开始。
</p></dd>
</dl>

<a name="index-pushd"></a>
</dd>
<dt><code>pushd</code></dt>
<dd><div class="example">
<pre class="example">pushd [-n] [<var>+N</var> | <var>-N</var> | <var>dir</var>]
</pre></div>

<p>将当前目录保存在目录堆栈的顶部，然后<code>cd</code>至<var>dir</var> 。没有争执<code>pushd</code>交换前两个目录并使新的前一个成为当前目录。
</p>
<dl compact>
<dt><code>-n</code></dt>
<dd><p>在旋转目录或将目录添加到堆栈时，禁止目录的正常更改，从而仅操作堆栈。
</p></dd>
<dt><code>+<var>N</var></code></dt>
<dd><p>带来<var>N</var>目录（从列表的左侧开始计数，由<code>dirs</code> ，从零开始）到列表顶部（通过旋转堆栈）。
</p></dd>
<dt><code>-<var>N</var></code></dt>
<dd><p>带来<var>N</var>目录（从列表的右边开始计数） <code>dirs</code> ，从零开始）到列表顶部（通过旋转堆栈）。
</p></dd>
<dt><code><var>dir</var></code></dt>
<dd><p>使<var>dir</var>是堆栈的顶部，使其成为新的当前目录，就好像它已作为参数提供给了<code>cd</code>内置的。
</p></dd>
</dl>
</dd>
</dl>

<hr>
<a name="Controlling-the-Prompt"></a>
<div class="header">
<p>下一篇： <a href="#The-Restricted-Shell" rel="next" accesskey="n">受限Shell</a> ，上一篇： <a href="#The-Directory-Stack" rel="prev" accesskey="p">目录堆栈</a> ，上一篇： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Controlling-the-Prompt-1"></a>
<h3 class="section">6.9控制提示</h3>
<a name="index-prompting"></a>

<p>变量的值<code>PROMPT_COMMAND</code>在Bash打印每个主要提示之前进行检查。如果<code>PROMPT_COMMAND</code>设置为并且具有非空值，然后将执行该值，就像在命令行上键入该值一样。
</p>
<p>此外，下表描述了可能出现在提示变量中的特殊字符<code>PS0</code> ， <code>PS1</code> ， <code>PS2</code>和<code>PS4</code> ：</p>
<dl compact>
<dt><code>\a</code></dt>
<dd><p>响铃字符。
</p></dd>
<dt><code>\d</code></dt>
<dd><p>日期，采用“工作日月份日期”格式（例如，“ 5月26日星期二”）。
</p></dd>
<dt><code>\D{<var>format</var>}</code></dt>
<dd><p>的<var>format</var>被传递给<code>strftime</code> （3）将结果插入提示字符串中；一个空的<var>format</var>导致特定于语言环境的时间表示。括号是必需的。
</p></dd>
<dt><code>\e</code></dt>
<dd><p>转义字符。
</p></dd>
<dt><code>\h</code></dt>
<dd><p>主机名，最多第一个“。”。
</p></dd>
<dt><code>\H</code></dt>
<dd><p>主机名。
</p></dd>
<dt><code>\j</code></dt>
<dd><p>Shell当前管理的作业数。
</p></dd>
<dt><code>\l</code></dt>
<dd><p>Shell的终端设备名称的基本名称。
</p></dd>
<dt><code>\n</code></dt>
<dd><p>换行符。
</p></dd>
<dt><code>\r</code></dt>
<dd><p>回车。
</p></dd>
<dt><code>\s</code></dt>
<dd><p>外壳的名称，基的名称<code>$0</code> （最后一个斜杠之后的部分）。
</p></dd>
<dt><code>\t</code></dt>
<dd><p>时间，采用24小时制HH：MM：SS格式。
</p></dd>
<dt><code>\T</code></dt>
<dd><p>时间，采用12小时制HH：MM：SS格式。
</p></dd>
<dt><code>\@</code></dt>
<dd><p>时间，采用12小时制。
</p></dd>
<dt><code>\A</code></dt>
<dd><p>时间，采用24小时制HH：MM格式。
</p></dd>
<dt><code>\u</code></dt>
<dd><p>当前用户的用户名。
</p></dd>
<dt><code>\v</code></dt>
<dd><p>Bash的版本（例如2.00）</p></dd>
<dt><code>\V</code></dt>
<dd><p>Bash的版本+补丁级别（例如2.00.0）</p></dd>
<dt><code>\w</code></dt>
<dd><p>当前工作目录，带有<code>$HOME</code>带波浪号的缩写（使用<code>$PROMPT_DIRTRIM</code>变量）。
</p></dd>
<dt><code>\W</code></dt>
<dd><p>的基本名称<code>$PWD</code> ，带有<code>$HOME</code>缩写为波浪号。
</p></dd>
<dt><code>\!</code></dt>
<dd><p>此命令的历史记录号。
</p></dd>
<dt><code>\#</code></dt>
<dd><p>该命令的命令号。
</p></dd>
<dt><code>\$</code></dt>
<dd><p>如果有效uid为0， <code>#</code> ， 除此以外<code>$</code> 。
</p></dd>
<dt><code>\<var>nnn</var></code></dt>
<dd><p>ASCII码为八进制值的字符<var>nnn</var> 。
</p></dd>
<dt><code>\\</code></dt>
<dd><p>反斜杠。
</p></dd>
<dt><code>\[</code></dt>
<dd><p>开始一系列非打印字符。这可用于将终端控制序列嵌入到提示中。
</p></dd>
<dt><code>\]</code></dt>
<dd><p>结束一系列非打印字符。
</p></dd>
</dl>

<p>命令编号和历史编号通常是不同的：命令的历史编号是它在历史列表中的位置，其中可能包括从历史文件中还原的命令（请参阅<a href="#Bash-History-Facilities">Bash History Facilities</a> ），而命令编号是在目录中的位置。在当前shell会话期间执行的命令序列。
</p>
<p>字符串解码后，将根据参数的值，命令替换，算术扩展和引号删除进行扩展。 <code>promptvars</code> shell选项（请参阅<a href="#The-Shopt-Builtin">内置Shopt</a> ）。如果字符串的转义部分出现在命令替换中或包含单词扩展专用字符，则可能会产生有害的副作用。
</p>
<hr>
<a name="The-Restricted-Shell"></a>
<div class="header">
<p>下一篇： <a href="#Bash-POSIX-Mode" rel="next" accesskey="n">Bash POSIX模式</a> ，上一篇： <a href="#Controlling-the-Prompt" rel="prev" accesskey="p">控制提示</a> ，上一篇： <a href="#Bash-POSIX-Mode" rel="next" accesskey="n">Bash</a> <a href="#Bash-Features" rel="up" accesskey="u">功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Restricted-Shell-1"></a>
<h3 class="section">6.10受限外壳</h3>
<a name="index-restricted-shell"></a>

<p>如果Bash以以下名称开头<code>rbash</code> ， 或者<samp>--restricted</samp>要么<samp>-r</samp>在调用时提供了option，shell受到限制。受限外壳用于设置比标准外壳更受控制的环境。受限制的外壳的行为与<code>bash</code>但不允许或不执行以下操作除外：</p>
<ul>
<li>使用更改目录<code>cd</code>内置的。
</li><li>设置或取消设置<code>SHELL</code> ， <code>PATH</code> ， <code>ENV</code> ， 要么<code>BASH_ENV</code>变量。
</li><li>指定包含斜杠的命令名称。
</li><li>指定包含斜杠的文件名作为参数<code>.</code>内置命令。
</li><li>指定包含斜杠的文件名作为参数<samp>-p</samp>选项<code>hash</code>内置命令。
</li><li>在启动时从外壳环境导入函数定义。
</li><li>解析值<code>SHELLOPTS</code>从启动时的Shell环境中获取。
</li><li>使用' <samp>></samp> '，' <samp>>|</samp> '，' <samp><></samp> '，' <samp>>&</samp> '，' <samp>&></samp> '和' <samp>>></samp>重定向运算符。
</li><li>使用<code>exec</code>内置用另一个命令替换外壳。
</li><li>使用添加或删除内置命令<samp>-f</samp>和<samp>-d</samp>选项<code>enable</code>内置的。
</li><li>使用<code>enable</code> builtin命令启用禁用的shell内置程序。
</li><li>指定<samp>-p</samp>选项<code>command</code>内置的。
</li><li>使用“关闭限制模式” <samp>set +r</samp> ' 要么 ' <samp>set +o restricted</samp> '。
</li></ul>

<p>读取任何启动文件后，将强制执行这些限制。
</p>
<p>当执行被发现是外壳程序脚本的命令时（请参见<a href="#Shell-Scripts">Shell Scripts</a> ）， <code>rbash</code>关闭在外壳程序中产生的执行脚本的所有限制。
</p>
<p>受限外壳模式只是有用的受限环境的一个组成部分。它应该伴随设置<code>PATH</code>设置为一个值，该值仅允许执行一些已验证的命令（允许shell逸出的命令特别容易受到攻击），从而使用户在登录后将其保留在除其主目录之外的其他不可写目录中，不允许受限制的shell执行shell脚本，并清理导致某些命令修改其行为的变量环境（例如， <code>VISUAL</code>要么<code>PAGER</code> ）。
</p>
<p>现代系统提供了更安全的方式来实现受限环境，例如<code>jails</code> ， <code>zones</code> ， 要么<code>containers</code> 。
</p>

<hr>
<a name="Bash-POSIX-Mode"></a>
<div class="header">
<p>上一篇： <a href="#The-Restricted-Shell" rel="prev" accesskey="p">受限Shell</a> ，上： <a href="#Bash-Features" rel="up" accesskey="u">Bash功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-POSIX-Mode-1"></a>
<h3 class="section">6.11 Bash POSIX模式</h3>
<a name="index-POSIX-Mode"></a>

<p>从Bash开始<samp>--posix</samp>命令行选项或执行' <samp>set -o posix</samp>当Bash运行时，通过更改其行为以使其与Bash默认值不同的区域中的<small>POSIX</small>指定的行为相匹配，将使Bash更符合<small>POSIX</small>标准。
</p>
<p>当作为<code>sh</code> ，Bash在读取启动文件后进入<small>POSIX</small>模式。
</p>
<p>以下列表是“ <small>POSIX</small>模式”生效时的更改：</p>
<ol>
<li>Bash确保<code>POSIXLY_CORRECT</code>变量已设置。

</li><li>当哈希表中的命令不再存在时，Bash将重新搜索<code>$PATH</code>查找新位置。也可以在“ <samp>shopt -s checkhash</samp> '。

</li><li>当作业以非零状态退出时，由作业控制代码打印并内置的消息为“完成（状态）”。

</li><li>作业停止时，由作业控制代码打印并内置的消息为'Stopped（ <var>signame</var> ）'，在哪里<var>signame</var>例如， <code>SIGTSTP</code> 。

</li><li>即使在非交互式外壳中，也始终启用别名扩展。

</li><li>在识别出保留字的上下文中出现的保留字不会进行别名扩展。

</li><li><small>POSIX</small> <code>PS1</code>和<code>PS2</code>的扩展<samp>!</samp> '到历史编号和' <samp>!!</samp> ' 至 ' <samp>!</samp> '启用，并且参数扩展对<code>PS1</code>和<code>PS2</code>无论设置为<code>promptvars</code>选项。

</li><li><small>POSIX</small>启动文件被执行（ <code>$ENV</code> ），而不是普通的Bash文件。

</li><li>波浪号扩展仅在命令名之前的赋值上执行，而不是在行上的所有赋值语句上执行。

</li><li>默认历史记录文件是<samp>~/.sh_history</samp> （这是默认值<code>$HISTFILE</code> ）。

</li><li>除非外壳程序是交互式的，否则重定向操作符不会对重定向中的单词执行文件名扩展。

</li><li>重定向运算符不对重定向中的单词执行单词拆分。

</li><li>函数名称必须是有效的shell <code>name</code> s。也就是说，它们不能包含字母，数字和下划线以外的字符，并且不能以数字开头。声明具有无效名称的函数会在非交互式外壳程序中导致致命的语法错误。

</li><li>函数名称可能与<small>POSIX</small>特殊内置函数之一不同。

</li><li> 在命令查找期间，在Shell函数之前可以找到<small>POSIX</small>特殊内置函数。

</li><li>在打印外壳函数定义时（例如，通过<code>type</code> ），Bash不会打印<code>function</code>关键词。

</li><li>文字波浪号显示为元素中的第一个字符<code>PATH</code>变量不按<a href="#Tilde-Expansion">Tilde Expansion的说明进行扩展</a> 。

</li><li>的<code>time</code>保留字本身可以用作命令。当以这种方式使用时，它将显示外壳及其完成的子代的计时统计信息。的<code>TIMEFORMAT</code>变量控制时间信息的格式。

</li><li>解析和扩展出现在双引号中的$ {…}扩展时，单引号不再是特殊的，不能用于引用右括号或其他特殊字符，除非运算符是定义为执行模式删除的运算符之一。在这种情况下，它们不必显示为匹配对。

</li><li>解析器无法识别<code>time</code>如果下一个标记以'开头，则作为保留字<samp>-</samp> '。

</li><li>' <samp>!</samp> '字符不会在双引号字符串内引入历史扩展，即使<code>histexpand</code>选项已启用。

</li><li>如果<small>POSIX</small>特殊内置<small>函数</small>返回错误状态，则退出非交互式Shell。致命错误是<small>POSIX</small>标准中列出的那些错误，包括传递错误的选项，重定向错误，命令名之前的分配的变量分配错误等。

</li><li>如果在赋值语句后没有命令名时发生变量赋值错误，则非交互式外壳将以错误状态退出。例如，当尝试将值分配给只读变量时，会发生变量分配错误。

</li><li>如果在特殊内置函数之前的赋值语句中发生变量赋值错误，则非交互式外壳会退出并显示错误状态，而其他任何简单命令都不会。

</li><li>如果非交互式外壳程序中的迭代变量位于<code>for</code>语句或选择变量<code>select</code>语句是一个只读变量。

</li><li>如果非交互式外壳退出<var>filename</var>在<code>.</code><var>filename</var>找不到。

</li><li>如果算术扩展中的语法错误导致表达式无效，则会退出非交互式外壳。

</li><li>如果发生参数扩展错误，则非交互式外壳退出。

</li><li>如果使用以下命令读取的脚本中存在语法错误，则会退出非交互式外壳程序<code>.</code>要么<code>source</code>内置函数或由<code>eval</code>内置的。

</li><li>进程替代不可用。

</li><li>虽然可以使用变量间接寻址，但它可能不适用于“ <samp>#</samp> '和' <samp>?</samp> '特殊参数。

</li><li>扩展“ <samp>*</samp> '在扩展名用双引号括起来的模式上下文中的特殊参数不处理<code>$*</code>好像是双引号一样。

</li><li>内建完成后， <small>POSIX</small>特殊内建之前的赋值语句会保留在Shell环境中。

</li><li>在外壳函数调用之前的赋值语句在函数返回之后仍保留在外壳环境中，就好像已执行<small>POSIX</small>特殊内置命令一样。

</li><li>的<code>command</code>内置不阻止以赋值语句作为参数的内置物将其扩展为赋值语句；当不在<small>POSIX</small>模式下时，赋值内建<small>函数</small>在后面带有赋值声明扩展属性时会丢失<code>command</code> 。

</li><li>的<code>bg</code>内置使用所需的格式来描述放置在后台的每个作业，但不包括该作业是当前作业还是先前作业的指示。

</li><li>'的输出<samp>kill -l</samp> '将所有信号名称打印在一行中，并用空格分隔，不带' <samp>SIG</samp> ' 字首。

</li><li>的<code>kill</code>内置不接受带有' <samp>SIG</samp> ' 字首。

</li><li>的<code>export</code>和<code>readonly</code>内置命令以<small>POSIX</small>要求的格式显示其输出。</li><li>的<code>trap</code>内置显示信号名称，不带前导<code>SIG</code> 。

</li><li>的<code>trap</code> Builtin不会检查第一个参数是否有可能的信号规格，如果可能，则不将信号处理恢复为原始配置，除非该参数仅由数字组成并且是有效的信号编号。如果用户要将给定信号的处理程序重置为原始配置，则应使用“ <samp>-</samp> '作为第一个论点。

</li><li>的<code>.</code>和<code>source</code>如果通过搜索找不到内置文件，则内置文件不会在当前目录中搜索filename参数<code>PATH</code> 。

</li><li>启用<small>POSIX</small>模式具有设置<code>inherit_errexit</code>选项，因此产生的执行命令替换的子shell继承了<samp>-e</samp>父外壳中的选项。当。。。的时候<code>inherit_errexit</code>选项未启用，Bash清除<samp>-e</samp>此类子shell中的选项。

</li><li>启用<small>POSIX</small>模式具有设置<code>shift_verbose</code>选项，因此要使用数值参数<code>shift</code>超过位置参数的数量将导致错误消息。

</li><li>当。。。的时候<code>alias</code>内置显示别名定义，但不显示前导' <samp>alias</samp>除非<samp>-p</samp>提供选项。

</li><li>当。。。的时候<code>set</code>内置调用时不带选项，它不显示外壳函数名称和定义。

</li><li>当。。。的时候<code>set</code>内置调用时不带选项，它显示不带引号的变量值，除非它们包含外壳元字符，即使结果包含非打印字符也是如此。

</li><li>当。。。的时候<code>cd</code>内置调用<var>logical</var>模式，路径名由<code>$PWD</code>并且作为参数提供的目录名称不引用现有目录， <code>cd</code>将失败而不是退回到<var>physical</var>模式。

</li><li>当。。。的时候<code>cd</code> Builtin无法更改目录，因为从中构造的路径名的长度<code>$PWD</code>并且作为参数提供的目录名称超过<var>PATH_MAX</var>当所有符号链接都展开后， <code>cd</code>将失败，而不是尝试仅使用提供的目录名。

</li><li>的<code>pwd</code>内置程序会验证其打印的值是否与当前目录相同，即使不要求使用以下命令检查文件系统也是如此。 <samp>-P</samp>选项。

</li><li>列出历史记录时， <code>fc</code>内置不包括历史记录条目是否已被修改的指示。

</li><li>所使用的默认编辑器<code>fc</code>是<code>ed</code> 。

</li><li>的<code>type</code>和<code>command</code>内置文件将不会报告已找到的非可执行文件，尽管如果Shell是在Windows中找到的唯一这样的文件，它将尝试执行该文件。 <code>$PATH</code> 。

</li><li>的<code>vi</code>编辑模式将调用<code>vi</code>直接在“ <samp>v</samp> '命令运行，而不是检查<code>$VISUAL</code>和<code>$EDITOR</code> 。

</li><li>当。。。的时候<code>xpg_echo</code>选项启用后，Bash不会尝试将任何参数解释为<code>echo</code>作为选择。转换了转义字符后，将显示每个参数。

</li><li>的<code>ulimit</code>内置将512字节的块大小用于<samp>-c</samp>和<samp>-f</samp>选项。

</li><li>的到来<code>SIGCHLD</code>设置陷阱时<code>SIGCHLD</code>不会打断<code>wait</code>内置，并使其立即返回。trap命令对每个退出的孩子运行一次。

</li><li>的<code>read</code>内置信号可能会被设置了陷阱的信号打断。如果Bash在执行时收到陷阱信号<code>read</code> ，陷阱处理程序执行并<code>read</code>返回大于128的退出状态。

</li><li>Bash会在此类状态之后从此类状态列表中删除退出的后台进程的状态。 <code>wait</code>内置用于获取它。

</li></ol>

<p>即使在<small>POSIX</small>模式下，Bash在默认情况下也不会实现其他<small>POSIX</small>行为。特别：</p>
<ol>
<li>的<code>fc</code>内置检查<code>$EDITOR</code>作为编辑历史记录条目的程序，如果<code>FCEDIT</code>未设置，而不是直接默认为<code>ed</code> 。 <code>fc</code>用途<code>ed</code>如果<code>EDITOR</code>未设置。

</li><li>如上所述，Bash需要<code>xpg_echo</code>为该选项启用的选项<code>echo</code>内置以完全符合要求。

</li></ol>

<p>通过指定Bash，可以将Bash默认配置为符合<small>POSIX</small>标准<samp>--enable-strict-posix-default</samp>至<code>configure</code>在构建时（请参阅<a href="#Optional-Features">可选功能</a> ）。
</p>
<hr>
<a name="Job-Control"></a>
<div class="header">
<p>下一篇： <a href="#Command-Line-Editing" rel="next" accesskey="n">命令行编辑</a> ，上一篇： <a href="#Bash-Features" rel="prev" accesskey="p">Bash功能</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Job-Control-1"></a>
<h2 class="chapter">7工作控制</h2>

<p>本章讨论什么是作业控制，其工作方式以及Bash如何允许您访问其设施。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Job-Control-Basics" accesskey="1">工作控制基础</a> ：</td><td>  </td><td align="left" valign="top">工作控制的工作原理。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Job-Control-Builtins" accesskey="2">作业控制内置</a> ：</td><td>  </td><td align="left" valign="top">Bash内置命令，用于与作业控制进行交互。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Job-Control-Variables" accesskey="3">作业控制变量</a> ：</td><td>  </td><td align="left" valign="top">Bash用于自定义作业控制的变量。
</td></tr>
</tbody></table>

<hr>
<a name="Job-Control-Basics"></a>
<div class="header">
<p>下一页： <a href="#Job-Control-Builtins" rel="next" accesskey="n">作业控制内置命令</a> ，上级： <a href="#Job-Control" rel="up" accesskey="u">作业控制</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Job-Control-Basics-1"></a>
<h3 class="section">7.1工作控制基础</h3>
<a name="index-job-control-1"></a>
<a name="index-foreground"></a>
<a name="index-background"></a>
<a name="index-suspending-jobs"></a>

<p>作业控制是指有选择地停止（挂起）进程的执行并在以后继续（恢复）其执行的能力。用户通常通过操作系统内核的终端驱动程序和Bash共同提供的交互式界面来使用此功能。
</p>
<p>壳关联一个<var>job</var>每个管道。它保留了当前正在执行的作业的表，该表可能与<code>jobs</code>命令。当Bash异步启动作业时，它会打印一条类似于以下内容的行：</p><div class="example">
<pre class="example">[1] 25647
</pre></div>
<p>表示此作业是作业编号1，并且与此作业相关联的管道中最后一个进程的进程<small>ID</small>是25647。单个管道中的所有流程都是同一作业的成员。Bash使用<var>job</var>抽象作为工作控制的基础。
</p>
<p>为了便于用户界面实现作业控制，操作系统保留了当前终端进程组<small>ID</small>的概念。该进程组的成员（进程组<small>ID</small>等于当前终端进程组<small>ID的</small>进程）接收键盘生成的信号，例如<code>SIGINT</code> 。据说这些过程是前台。后台进程是那些进程组<small>ID</small>与终端的<small>ID</small>不同的进程。这样的过程不受键盘产生的信号的影响。如果用户指定使用，则仅允许前台进程读取或<code>stty tostop</code> ，写入终端。尝试从中读取（写入到何时）的后台进程<code>stty tostop</code>有效）向终端发送了一个<code>SIGTTIN</code> （ <code>SIGTTOU</code> ）信号由内核的终端驱动程序发出，除非捕获，否则将中止进程。
</p>
<p>如果运行Bash的操作系统支持作业控制，则Bash包含使用它的工具。打字<var>suspend</var>字符（通常为“ <samp>^Z</samp> '，Control-Z）在进程运行时导致该进程停止并将控制权返回给Bash。打字<var>delayed suspend</var>字符（通常为“ <samp>^Y</samp> '，Control-Y）使进程在尝试从终端读取输入时停止，然后将控件返回给Bash。然后，用户使用<code>bg</code>命令在后台继续执行<code>fg</code>命令以使其在前台继续执行，或者<code>kill</code>命令杀死它。一种 ' <samp>^Z</samp> '会立即生效，并具有导致待处理的输出和提前输入被丢弃的其他副作用。
</p>
<p>在Shell中有多种方法可以引用作业。性格 ' <samp>%</samp> '介绍了工作规范（ <var>jobspec</var> ）。
</p>
<p>工作编号<code>n</code>可以称为“ <samp>%n</samp> '。符号“ <samp>%%</samp> '和' <samp>%+</samp> '指的是当前作业的shell概念，即当作业在前台或后台启动时停止的最后一个作业。单个“ <samp>%</samp> '（无随附的工作说明）也指当前工作。以前的工作可以使用' <samp>%-</samp> '。如果只有一项工作， <samp>%+</samp> '和' <samp>%-</samp>都可以用来指代该工作。在与工作有关的输出中（例如， <code>jobs</code>命令），当前作业始终标有' <samp>+</samp> ”，而以前的工作中带有“ <samp>-</samp> '。
</p>
<p>也可以使用用于启动作业的名称的前缀或在其命令行中显示的子字符串来引用作业。例如， ' <samp>%ce</samp> '指停止<code>ce</code>工作。使用“ <samp>%?ce</samp>另一方面，“”指的是包含字符串“ <samp>ce</samp>在其命令行中。如果前缀或子字符串与多个作业匹配，则Bash报告错误。
</p>
<p>简单地命名一个工作就可以使它成为前台： <samp>%1</samp> '是'的同义词<samp>fg %1</samp> '，将作业1从后台移到前台。同样，“ <samp>%1 &</samp> '在后台恢复作业1，相当于' <samp>bg %1</samp> '</p>
<p>只要作业更改状态，shell就会立即学习。通常，Bash会等到要打印提示后再报告作业状态的更改，以免打扰其他任何输出。如果<samp>-b</samp>选项<code>set</code>启用内置命令后，Bash会立即报告此类更改（请参阅<a href="#The-Set-Builtin">The Set Builtin</a> ）。任何陷阱<code>SIGCHLD</code>对每个退出的子进程执行。
</p>
<p>如果在作业停止（或正在运行）时尝试退出Bash， <code>checkjobs</code>选项已启用–请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），外壳程序会显示警告消息，如果<code>checkjobs</code>选项启用后，列出作业及其状态。的<code>jobs</code>然后可以使用命令检查其状态。如果在没有中间命令的情况下再次尝试退出，则Bash不会打印另一条警告，并且任何停止的作业都将终止。
</p>
<p>当Shell使用以下命令等待作业或进程时<code>wait</code>内置，并且启用了作业控制， <code>wait</code>作业更改状态时将返回。的<samp>-f</samp>选择原因<code>wait</code>等待作业或进程终止后再返回。
</p>
<hr>
<a name="Job-Control-Builtins"></a>
<div class="header">
<p>下一页： <a href="#Job-Control-Variables" rel="next" accesskey="n">作业控制变量</a> ，上一篇： <a href="#Job-Control-Basics" rel="prev" accesskey="p">作业控制基础</a> ，向上： <a href="#Job-Control" rel="up" accesskey="u">作业控制</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Job-Control-Builtins-1"></a>
<h3 class="section">7.2作业控制内置</h3>

<dl compact>
<dt><code>bg</code></dt>
<dd><a name="index-bg"></a>
<div class="example">
<pre class="example">bg [<var>jobspec</var> &hellip;]
</pre></div>

<p>恢复每个暂停的作业<var>jobspec</var>在后台，就好像它以' <samp>&</samp> '。如果<var>jobspec</var>未提供，则使用当前作业。除非在未启用作业控制的情况下运行返回状态，否则返回状态为零；或者在启用作业控制的情况下，返回状态为零<var>jobspec</var>找不到或指定了没有作业控制就开始的作业。
</p>
</dd>
<dt><code>fg</code></dt>
<dd><a name="index-fg"></a>
<div class="example">
<pre class="example">fg [<var>jobspec</var>]
</pre></div>

<p>恢复工作<var>jobspec</var>在前台，使其成为当前工作。如果<var>jobspec</var>未提供，则使用当前作业。返回状态是放在前台的命令的状态，如果在禁用作业控制时运行，或者在启用作业控制的情况下运行，则返回非零。 <var>jobspec</var>没有指定有效的工作，或者<var>jobspec</var>指定在没有作业控制的情况下开始的作业。
</p>
</dd>
<dt><code>jobs</code></dt>
<dd><a name="index-jobs"></a>
<div class="example">
<pre class="example">jobs [-lnprs] [<var>jobspec</var>]
jobs -x <var>command</var> [<var>arguments</var>]
</pre></div>

<p>第一种形式列出了活动作业。这些选项具有以下含义：</p>
<dl compact>
<dt><code>-l</code></dt>
<dd><p>除常规信息外，还列出进程<small>ID</small> 。
</p>
</dd>
<dt><code>-n</code></dt>
<dd><p>仅显示有关自上次通知用户状态以来已更改状态的作业的信息。
</p>
</dd>
<dt><code>-p</code></dt>
<dd><p>仅列出作业的流程组负责人的流程<small>ID</small> 。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>仅显示正在运行的作业。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>仅显示已停止的作业。
</p></dd>
</dl>

<p>如果<var>jobspec</var>如果给出，则输出仅限于有关该作业的信息。如果<var>jobspec</var>未提供，将列出所有作业的状态。
</p>
<p>如果<samp>-x</samp>提供了选件， <code>jobs</code>取代任何<var>jobspec</var>在发现<var>command</var>要么<var>arguments</var>与相应的进程组<small>ID一起</small>执行<var>command</var>传递<var>argument</var> s，返回其退出状态。
</p>
</dd>
<dt><code>kill</code></dt>
<dd><a name="index-kill"></a>
<div class="example">
<pre class="example">kill [-s <var>sigspec</var>] [-n <var>signum</var>] [-<var>sigspec</var>] <var>jobspec</var> or <var>pid</var>
kill -l|-L [<var>exit_status</var>]
</pre></div>

<p>发送指定的信号<var>sigspec</var>要么<var>signum</var>到由工作规范指定的过程<var>jobspec</var>或进程<small>ID</small> <var>pid</var> 。
<var>sigspec</var>是不区分大小写的信号名称，例如<code>SIGINT</code> （有或没有<code>SIG</code>前缀）或信号编号； <var>signum</var>是一个信号号。如果<var>sigspec</var>和<var>signum</var>不存在<code>SIGTERM</code>用来。的<samp>-l</samp>选项列出信号名称。如果何时提供任何参数<samp>-l</samp>给定后，列出与自变量对应的信号的名称，返回状态为零。
<var>exit_status</var>是一个数字，指定信号号或信号终止的进程的退出状态。的<samp>-L</samp>选项等效于<samp>-l</samp> 。如果成功发送了至少一个信号，则返回状态为零；如果发生错误或遇到无效的选项，则返回状态为非零。
</p>
</dd>
<dt><code>wait</code></dt>
<dd><a name="index-wait"></a>
<div class="example">
<pre class="example">wait [-fn] [<var>jobspec</var> or <var>pid</var> &hellip;]
</pre></div>

<p>等到每个进程<small>ID</small>指定的子进程<var>pid</var>或工作说明<var>jobspec</var>退出并返回等待的最后一个命令的退出状态。如果给出了作业说明，则将等待作业中的所有过程。如果未提供任何参数，则将等待所有当前活动的子进程，并且返回状态为零。如果<samp>-n</samp>提供了选件， <code>wait</code>等待单个作业终止并返回其退出状态。供应<samp>-f</samp>选项，启用作业控制后，强制<code>wait</code>等待每个<var>pid</var>要么<var>jobspec</var>在返回其状态之前终止，表示在更改状态时返回。如果两者都不<var>jobspec</var>也不<var>pid</var>指定外壳的活动子进程，返回状态为127。
</p>
</dd>
<dt><code>disown</code></dt>
<dd><a name="index-disown"></a>
<div class="example">
<pre class="example">disown [-ar] [-h] [<var>jobspec</var> &hellip; | <var>pid</var> &hellip; ]
</pre></div>

<p>如果没有选项，请删除每个<var>jobspec</var>从活动作业表中。如果<samp>-h</samp>给定选项，该作业不会从表中删除，而是被标记为<code>SIGHUP</code>如果Shell收到一个<code>SIGHUP</code> 。如果<var>jobspec</var>不存在，并且<samp>-a</samp>也不是<samp>-r</samp>提供选项，将使用当前作业。如果不<var>jobspec</var>提供， <samp>-a</samp>选项意味着删除或标记所有作业；的<samp>-r</samp>没有选项<var>jobspec</var>参数将操作限制为正在运行的作业。
</p>
</dd>
<dt><code>suspend</code></dt>
<dd><a name="index-suspend"></a>
<div class="example">
<pre class="example">suspend [-f]
</pre></div>

<p>暂停执行该外壳程序，直到收到一个<code>SIGCONT</code>信号。登录shell无法挂起；的<samp>-f</samp>选项可用于替代此选项并强制中止。
</p></dd>
</dl>

<p>当作业控制未激活时， <code>kill</code>和<code>wait</code>内置不接受<var>jobspec</var>论点。必须为其提供进程<small>ID</small> 。
</p>
<hr>
<a name="Job-Control-Variables"></a>
<div class="header">
<p>上<a href="#Job-Control-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Job-Control-Builtins" rel="prev" accesskey="p">内置作业控制</a> ，上<a href="#Job-Control-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Job-Control" rel="up" accesskey="u">作业控制</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Job-Control-Variables-1"></a>
<h3 class="section">7.3作业控制变量</h3>

<dl compact>
<dt><code>auto_resume</code>
<a name="index-auto_005fresume"></a>
</dt>
<dd><p>此变量控制外壳如何与用户和作业控件交互。如果存在此变量，则将不带重定向的单个单词简单命令视为恢复现有作业的候选对象。不存在歧义。如果有多个以键入的字符串开头的作业，则将选择最近访问的作业。在这种情况下，已停止作业的名称是用于启动该作业的命令行。如果此变量设置为值' <samp>exact</samp> '，提供的字符串必须与已停止作业的名称完全匹配；如果设置为“ <samp>substring</samp> '，提供的字符串需要匹配已停止作业名称的子字符串。' <samp>substring</samp> '值提供的功能类似于' <samp>%?</samp>作业<small>ID</small> （请参阅“ <a href="#Job-Control-Basics">作业控制基础知识”</a> ）。如果设置为任何其他值，则提供的字符串必须是已停止作业名称的前缀；这提供了类似于“ <samp>%</samp>职位<small>ID</small> 。</p>
</dd>
</dl>

<a name="index-Readline_002c-how-to-use"></a>




<hr>
<a name="Command-Line-Editing"></a>
<div class="header">
<p>下一篇： <a href="#Using-History-Interactively" rel="next" accesskey="n">交互式使用历史记录</a> ，上一篇： <a href="#Job-Control" rel="prev" accesskey="p">作业控制</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Command-Line-Editing-1"></a>
<h2 class="chapter">8命令行编辑</h2>

<p>本章介绍<small>GNU</small>命令行编辑界面的基本功能。Readline库提供了命令行编辑功能，该程序被包括Bash在内的多个不同程序使用。使用交互式外壳程序时，默认情况下会启用命令行编辑，除非<samp>--noediting</samp>该选项在外壳程序调用时提供。当使用<samp>-e</samp>选项<code>read</code>内置命令（请参阅<a href="#Bash-Builtins">Bash内置文件</a> ）。默认情况下，行编辑命令与Emacs相似。也可以使用vi样式的线编辑界面。您可以随时使用<samp>-o emacs</samp>要么<samp>-o vi</samp>选项<code>set</code>内置命令（请参阅<a href="#The-Set-Builtin">设置</a>内置命令），或使用<samp>+o emacs</samp>要么<samp>+o vi</samp>的选项<code>set</code> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Introduction-and-Notation" accesskey="1">介绍和符号</a> ：</td><td>  </td><td align="left" valign="top">本文中使用的符号。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-Interaction" accesskey="2">Readline互动</a> ：</td><td>  </td><td align="left" valign="top">用于编辑行的最小命令集。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-Init-File" accesskey="3">Readline初始化文件</a> ：</td><td>  </td><td align="left" valign="top">从用户的角度定制Readline。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bindable-Readline-Commands" accesskey="4">可绑定的Readline命令</a> ：</td><td>  </td><td align="left" valign="top">大部分可用于绑定的Readline命令的说明</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-vi-Mode" accesskey="5">Readline vi模式</a> ：</td><td>  </td><td align="left" valign="top">关于如何使Readline像vi编辑器一样进行简短描述。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Programmable-Completion" accesskey="6">可编程完成</a> ：</td><td>  </td><td align="left" valign="top">如何为特定命令指定可能的完成。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Programmable-Completion-Builtins" accesskey="7">可编程完成内置函数</a> ：</td><td>  </td><td align="left" valign="top">内置命令，用于指定如何完成特定命令的参数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#A-Programmable-Completion-Example" accesskey="8">可编程完成示例</a> ：</td><td>  </td><td align="left" valign="top">一个示例shell函数，用于生成可能的补全。
</td></tr>
</tbody></table>

<hr>
<a name="Introduction-and-Notation"></a>
<div class="header">
<p>下一篇： <a href="#Readline-Interaction" rel="next" accesskey="n">Readline交互</a> ，上一篇： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Introduction-to-Line-Editing"></a>
<h3 class="section">8.1行编辑简介</h3>

<p>以下各段描述了用于表示击键的符号。
</p>
<p>文本<kbd>C-k</kbd>表示为“ Control-K”，它描述了在按下Control键的同时按下<tt class="key">k</tt>键时产生的字符。
</p>
<p>文本<kbd>M-k</kbd>表示为“ Meta-K”，它描述了按下Meta键（如果有）并按下<tt class="key">k</tt>键时产生的字符。在许多键盘上，Meta键都标记为<tt class="key">ALT</tt> 。在带有两个标记为<tt class="key">ALT的</tt>键的键盘上（通常在空格键的任一侧），通常将左侧的<tt class="key">ALT</tt>设置为用作Meta键。右侧的<tt class="key">ALT</tt>键也可以配置为用作Meta键，也可以配置为其他修饰符，例如用于键入带重音符号的Compose键。
</p>
<p>如果你没有Meta或<tt class="key">Alt</tt>键，或者其他关键工作作为Meta键，可以通过<em>先</em>输入<tt class="key">ESC，</tt>然后键入<tt class="key">k</tt>为产生相同的按键。任一过程都称为<em>metafying</em> <tt class="key">k</tt>键。
</p>
<p>文本<kbd>M-C-k</kbd>读取为“ Meta-Control-k”，并描述了通过<em>metafying</em>产生的<em>字符</em> <kbd>C-k</kbd> 。
</p>
<p>此外，几个键都有自己的名称。特别是，在本文或init文件中（请参阅<a href="#Readline-Init-File">Readline Init File</a> ）， <tt class="key">DEL</tt> ， <tt class="key">ESC</tt> ， <tt class="key">LFD</tt> ， <tt class="key">SPC</tt> ， <tt class="key">RET</tt>和<tt class="key">TAB</tt>都代表自己。如果键盘缺少<tt class="key">LFD</tt>键，则键入<tt class="key">Cj</tt>将产生所需的字符。在某些键盘上， <tt class="key">RET</tt>键可能标记为<tt class="key">Return</tt>或<tt class="key">Enter</tt> 。
</p>
<hr>
<a name="Readline-Interaction"></a>
<div class="header">
<p>下一页： <a href="#Readline-Init-File" rel="next" accesskey="n">Readline初始化文件</a> ，上一页： <a href="#Introduction-and-Notation" rel="prev" accesskey="p">简介和注释</a> ，向上： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Interaction-1"></a>
<h3 class="section">8.2 Readline互动</h3>
<a name="index-interaction_002c-readline"></a>

<p>通常在交互式会话中，您会输入一长行文本，只是要注意该行的第一个单词拼写错误。Readline库为您提供了一组命令，用于在您键入文本时对其进行处理，从而使您可以仅修正拼写错误，而不必强迫您重新键入大部分行。使用这些编辑命令，将光标移至需要更正的位置，然后删除或插入更正的文本。然后，当您对线路满意时，只需按<tt class="key">RET即可</tt> 。您不必在一行的最后按<tt class="key">RET</tt>键；无论光标在行中的位置如何，整行都将被接受。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Readline-Bare-Essentials" accesskey="1">Readline Bare Essentials</a> ：</td><td>  </td><td align="left" valign="top">您至少需要了解Readline。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-Movement-Commands" accesskey="2">Readline运动命令</a> ：</td><td>  </td><td align="left" valign="top">在输入线上移动。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-Killing-Commands" accesskey="3">Readline杀死命令</a> ：</td><td>  </td><td align="left" valign="top">如何删除文字，以及如何找回！
</td></tr>
<tr><td align="left" valign="top">• <a href="#Readline-Arguments" accesskey="4">Readline参数</a> ：</td><td>  </td><td align="left" valign="top">将数字参数赋予命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Searching" accesskey="5">搜索</a> ：</td><td>  </td><td align="left" valign="top">搜索前几行。
</td></tr>
</tbody></table>

<hr>
<a name="Readline-Bare-Essentials"></a>
<div class="header">
<p>下一页： <a href="#Readline-Movement-Commands" rel="next" accesskey="n">Readline移动命令</a> ，上一篇： <a href="#Readline-Movement-Commands" rel="next" accesskey="n">Readline</a> <a href="#Readline-Interaction" rel="up" accesskey="u">交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Bare-Essentials-1"></a>
<h4 class="subsection">8.2.1 Readline Bare Essentials</h4>
<a name="index-notation_002c-readline"></a>
<a name="index-command-editing"></a>
<a name="index-editing-command-lines"></a>

<p>为了在行中输入字符，只需键入它们。键入的字符出现在光标所在的位置，然后光标向右移动一个空格。如果您键入错误的字符，则可以使用擦除字符来备份和删除键入错误的字符。
</p>
<p>有时您可能会键入错误的字符，直到您键入了其他几个字符才注意到错误。在这种情况下，您可以输入<kbd>C-b</kbd>将光标向左移动，然后更正您的错误。之后，您可以使用<kbd>C-f</kbd> 。
</p>
<p>当您在一行的中间添加文本时，您会注意到光标右侧的字符被“推到”上方，以便为所插入的文本腾出空间。同样，当您删除光标后面的文本时，光标右侧的字符将被“拉回”以填充删除文本所创建的空白。以下是编辑输入行文本的基本要点列表。
</p>
<dl compact>
<dt><kbd>C-b</kbd></dt>
<dd><p>向后移一个字符。
</p></dd>
<dt><kbd>C-f</kbd></dt>
<dd><p>向前移动一个字符。
</p></dd>
<dt><tt class="key">DEL</tt>或<tt class="key">退格键</tt></dt>
<dd><p>删除光标左侧的字符。
</p></dd>
<dt><kbd>C-d</kbd></dt>
<dd><p>删除光标下方的字符。
</p></dd>
<dt>打印字符<!-- /@w --></dt>
<dd><p>将字符插入光标所在的行中。
</p></dd>
<dt><kbd>C-_</kbd>要么<kbd>C-x C-u</kbd></dt>
<dd><p>撤消上一个编辑命令。您可以一路撤消以返回空行。
</p></dd>
</dl>

<p>（根据您的配置，将<tt class="key">Backspace</tt>键设置为删除光标左侧的字符，将<tt class="key">DEL</tt>键设置为删除光标下方的字符，例如<kbd>C-d</kbd> ，而不是光标左侧的字符。）
</p>
<hr>
<a name="Readline-Movement-Commands"></a>
<div class="header">
<p>下一篇： <a href="#Readline-Killing-Commands" rel="next" accesskey="n">Readline Killing命令</a> ，上一篇： <a href="#Readline-Killing-Commands" rel="next" accesskey="n">Readline</a> <a href="#Readline-Bare-Essentials" rel="prev" accesskey="p">Bare Essentials</a> ，上一篇： <a href="#Readline-Killing-Commands" rel="next" accesskey="n">Readline</a> <a href="#Readline-Interaction" rel="up" accesskey="u">交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Movement-Commands-1"></a>
<h4 class="subsection">8.2.2 Readline移动命令</h4>


<p>上表描述了进行输入行编辑所需的最基本的击键。为了您的方便，除了添加了许多其他命令<kbd>C-b</kbd> ， <kbd>C-f</kbd> ， <kbd>C-d</kbd>和<tt class="key">DEL</tt> 。这里有一些命令可以更快地在生产线上移动。
</p>
<dl compact>
<dt><kbd>C-a</kbd></dt>
<dd><p>移至行首。
</p></dd>
<dt><kbd>C-e</kbd></dt>
<dd><p>移至行尾。
</p></dd>
<dt><kbd>M-f</kbd></dt>
<dd><p>向前移动一个单词，该单词由字母和数字组成。
</p></dd>
<dt><kbd>M-b</kbd></dt>
<dd><p>向后移动一个字。
</p></dd>
<dt><kbd>C-l</kbd></dt>
<dd><p>清除屏幕，在顶部重新打印当前行。
</p></dd>
</dl>

<p>注意如何<kbd>C-f</kbd>向前移动一个角色，而<kbd>M-f</kbd>向前移动一个字。这是一个宽松的约定，控制键击操作字符，而元键击操作单词。
</p>
<hr>
<a name="Readline-Killing-Commands"></a>
<div class="header">
<p>下一页： <a href="#Readline-Arguments" rel="next" accesskey="n">Readline参数</a> ，Previous： <a href="#Readline-Movement-Commands" rel="prev" accesskey="p">Readline移动命令</a> ，Up： <a href="#Readline-Interaction" rel="up" accesskey="u">Readline交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Killing-Commands-1"></a>
<h4 class="subsection">8.2.3 Readline杀死命令</h4>

<a name="index-killing-text"></a>
<a name="index-yanking-text"></a>

<p><em>杀死</em>文本意味着删除该行中的文本，但是将其保存以备后用，通常是<em>将</em>其拉回（重新插入）到该行中。（“剪切”和“粘贴”是“杀”和“扬子”的最新术语。）
</p>
<p>如果命令说明说它“杀死”了文本，那么您可以确定以后可以将文本恢复到其他（或相同）位置。
</p>
<p>使用kill命令时，文本将保存在<em>kill-ring中</em> 。任意数量的连续杀死都将所有被杀死的文本保存在一起，这样，当您将其拉回原位时，便可以全部获得。终止环不是特定于行的；您在先前键入的行上杀死的文本可在以后键入另一行时再次拉回。
<a name="index-kill-ring"></a>
</p>
<p>这是杀死文本的命令列表。
</p>
<dl compact>
<dt><kbd>C-k</kbd></dt>
<dd><p>从当前光标位置终止到行尾的文本。
</p>
</dd>
<dt><kbd>M-d</kbd></dt>
<dd><p>从光标终止到当前单词的末尾，或者，如果在单词之间，则终止至下一个单词的末尾。字边界与<kbd>M-f</kbd> 。
</p>
</dd>
<dt><kbd>M-<span class="key">DEL</span></kbd></dt>
<dd><p>从光标处杀死当前单词的开头，或者，如果在单词之间，则终止至上一个单词的开头。字边界与<kbd>M-b</kbd> 。
</p>
</dd>
<dt><kbd>C-w</kbd></dt>
<dd><p>从光标杀死前一个空格。这与<kbd>M-<span class="key">DEL</span></kbd>因为单词边界不同。
</p>
</dd>
</dl>

<p>下面是如何<em>抽出</em>文本回线。Yanking意味着从kill缓冲区复制最近被杀死的文本。
</p>
<dl compact>
<dt><kbd>C-y</kbd></dt>
<dd><p>将最近被杀死的文本拉回到光标处的缓冲区中。
</p>
</dd>
<dt><kbd>M-y</kbd></dt>
<dd><p>旋转压环，然后拉出新的顶部。仅当先前命令为<kbd>C-y</kbd>要么<kbd>M-y</kbd> 。
</p></dd>
</dl>

<hr>
<a name="Readline-Arguments"></a>
<div class="header">
<p>下一页： <a href="#Searching" rel="next" accesskey="n">搜索</a> ，上一篇： <a href="#Readline-Killing-Commands" rel="prev" accesskey="p">Readline杀死命令</a> ，上一篇： <a href="#Readline-Interaction" rel="up" accesskey="u">Readline交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Arguments-1"></a>
<h4 class="subsection">8.2.4 Readline参数</h4>

<p>您可以将数字参数传递给Readline命令。有时，该参数充当重复计数，而有时，它是有意义的参数<i>符号</i> 。如果将负参数传递给通常以正向作用的命令，则该命令将以反向作用。例如，要杀死文本回到行首，您可以输入“ <samp>M-- C-k</samp> '。
</p>
<p>将数字参数传递给命令的一般方法是在命令前键入元数字。如果键入的第一个“数字”是减号（ <samp>-</samp> '），则参数的符号将为负。键入一个元数字以启动参数后，可以键入其余数字，然后键入命令。例如，给<kbd>C-d</kbd>输入10的参数，您可以输入' <samp>M-1 0 C-d</samp> '，这将删除输入行中的后十个字符。
</p>
<hr>
<a name="Searching"></a>
<div class="header">
<p>上<a href="#Readline-Arguments" rel="prev" accesskey="p">一篇</a> ： <a href="#Readline-Arguments" rel="prev" accesskey="p">Readline参数</a> ，上<a href="#Readline-Interaction" rel="up" accesskey="u">一篇</a> ： <a href="#Readline-Interaction" rel="up" accesskey="u">Readline交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Searching-for-Commands-in-the-History"></a>
<h4 class="subsection">8.2.5在历史记录中搜索命令</h4>

<p>Readline提供了一些命令，用于在命令历史记录（请参阅<a href="#Bash-History-Facilities">Bash历史记录工具</a> ）中搜索包含指定字符串的行。有两种搜索模式： <em>增量</em>和<em>非增量</em> 。
</p>
<p>增量搜索在用户完成键入搜索字符串之前开始。输入搜索字符串的每个字符时，Readline会显示历史记录中与到目前为止输入的字符串匹配的下一个条目。增量搜索仅需要查找所需的历史记录条目所需的字符数即可。要在历史记录中向后搜索特定的字符串，请键入<kbd>C-r</kbd> 。打字<kbd>C-s</kbd>向前搜索历史。值中存在的字符<code>isearch-terminators</code>变量用于终止增量搜索。如果尚未为该变量分配值， <tt class="key">则按ESC</tt>和<kbd>C-J</kbd>字符将终止增量搜索。
<kbd>C-g</kbd>将终止增量搜索并恢复原始行。搜索终止后，包含搜索字符串的历史记录条目将成为当前行。
</p>
<p>要在历史记录列表中查找其他匹配条目，请键入<kbd>C-r</kbd>要么<kbd>C-s</kbd>作为适当的。这将在历史记录中向后或向前搜索与当前输入的搜索字符串匹配的下一个条目。与Readline命令绑定的任何其他键序列都将终止搜索并执行该命令。例如， <tt class="key">RET</tt>将终止搜索并接受该行，从而从历史记录列表中执行命令。移动命令将终止搜索，使最后一行找到当前行，然后开始编辑。
</p>
<p>Readline会记住最后一个增量搜索字符串。如果两个<kbd>C-r</kbd>输入s时不会插入任何定义新搜索字符串的中间字符，而是使用任何记住的搜索字符串。
</p>
<p>非增量搜索在开始搜索匹配的历史记录行之前会读取整个搜索字符串。搜索字符串可以由用户键入，也可以是当前行内容的一部分。
</p>
<hr>
<a name="Readline-Init-File"></a>
<div class="header">
<p>下一篇： <a href="#Bindable-Readline-Commands" rel="next" accesskey="n">可绑定的Readline命令</a> ，上一篇： <a href="#Readline-Interaction" rel="prev" accesskey="p">Readline交互</a> ，上一篇： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Init-File-1"></a>
<h3 class="section">8.3 Readline初始化文件</h3>
<a name="index-initialization-file_002c-readline"></a>

<p>尽管Readline库默认情况下安装了一组类似Emacs的键绑定，但是可以使用另一组键绑定。任何用户都可以通过将命令放入通常位于其主目录中的<em>inputrc</em>文件中来定制使用Readline的程序。该文件的名称取自shell变量的值<code>INPUTRC</code> 。如果未设置该变量，则默认为<samp>~/.inputrc</samp> 。如果该文件不存在或无法读取，则最终默认值为<samp>/etc/inputrc</samp> 。的<code>bind</code> <!-- /@w -->内置命令也可以用于设置Readline键绑定和变量。参见<a href="#Bash-Builtins">Bash Builtins</a> 。
</p>
<p>当启动使用Readline库的程序时，将读取init文件并设置键绑定。
</p>
<p>除此之外<code>C-x C-r</code>命令将重新读取该初始化文件，从而合并您可能对其进行的所有更改。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Readline-Init-File-Syntax" accesskey="1">Readline初始化文件语法</a> ：</td><td>  </td><td align="left" valign="top">inputrc文件中命令的语法。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Conditional-Init-Constructs" accesskey="2">条件初始化构造</a> ：</td><td>  </td><td align="left" valign="top">inputrc文件中的条件键绑定。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Sample-Init-File" accesskey="3">示例初始化文件</a> ：</td><td>  </td><td align="left" valign="top">一个示例inputrc文件。
</td></tr>
</tbody></table>

<hr>
<a name="Readline-Init-File-Syntax"></a>
<div class="header">
<p>下一页： <a href="#Conditional-Init-Constructs" rel="next" accesskey="n">条件初始化构造</a> ，上： <a href="#Readline-Init-File" rel="up" accesskey="u">Readline初始化文件</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-Init-File-Syntax-1"></a>
<h4 class="subsection">8.3.1 Readline初始化文件语法</h4>

<p>Readline初始化文件中只允许几个基本构造。空行将被忽略。以'开头的行<samp>#</samp> '是评论。以'开头的行<samp>$</samp> '表示条件构造（请参阅<a href="#Conditional-Init-Constructs">条件初始化构造</a> ）。其他行表示变量设置和键绑定。
</p>
<dl compact>
<dt>变量设定</dt>
<dd><p>您可以使用以下命令通过更改Readline中变量的值来修改Readline的运行时行为： <code>set</code>初始化文件中的命令。语法很简单：</p>
<div class="example">
<pre class="example">set <var>variable</var> <var>value</var>
</pre></div>

<p>例如，这里是如何从默认的类似Emacs的键绑定更改为使用<code>vi</code>行编辑命令：</p>
<div class="example">
<pre class="example">set editing-mode vi
</pre></div>

<p>在适当的情况下，不区分大小写地识别变量名和值。无法识别的变量名将被忽略。
</p>
<p>如果值为null或为空，则将布尔变量（可以设置为on或off的变量）设置为on， <var>on</var> （不区分大小写），或1。任何其他值都会导致变量设置为off。
</p>
<p>的<code>bind <span class="nolinebreak">-V</span></code> <!-- /@w -->命令列出当前的Readline变量名称和值。参见<a href="#Bash-Builtins">Bash Builtins</a> 。
</p>
<p>使用以下变量可以更改许多运行时行为。
</p>
<a name="index-variables_002c-readline"></a>
<dl compact>
<dt><code>bell-style</code></dt>
<dd><a name="index-bell_002dstyle"></a>
<p>控制Readline想要响铃时发生的情况。如果设置为“ <samp>none</samp> '，雷德琳从不敲响铃铛。如果设置为“ <samp>visible</samp> '，如果可用，Readline会使用可见的铃声。如果设置为“ <samp>audible</samp> '（默认设置），Readline会尝试敲响终端的铃声。
</p>
</dd>
<dt><code>bind-tty-special-chars</code></dt>
<dd><a name="index-bind_002dtty_002dspecial_002dchars"></a>
<p>如果设置为“ <samp>on</samp> '（默认设置），Readline尝试将内核终端驱动程序特别对待的控制字符绑定到它们的Readline等效项。
</p>
</dd>
<dt><code>blink-matching-paren</code></dt>
<dd><a name="index-blink_002dmatching_002dparen"></a>
<p>如果设置为“ <samp>on</samp> '，在插入右括号时，Readline会尝试将光标短暂移动到左括号。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>colored-completion-prefix</code></dt>
<dd><a name="index-colored_002dcompletion_002dprefix"></a>
<p>如果设置为“ <samp>on</samp> '，当列出补全时，Readline使用不同的颜色显示可能补全的公共前缀。颜色定义取自<code>LS_COLORS</code>环境变量。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>colored-stats</code></dt>
<dd><a name="index-colored_002dstats"></a>
<p>如果设置为“ <samp>on</samp> '，Readline使用不同的颜色显示可能的补全，以指示其文件类型。颜色定义取自<code>LS_COLORS</code>环境变量。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>comment-begin</code></dt>
<dd><a name="index-comment_002dbegin"></a>
<p>当行开始时要插入到行首的字符串<code>insert-comment</code>命令被执行。默认值为<code>"#"</code> 。
</p>
</dd>
<dt><code>completion-display-width</code></dt>
<dd><a name="index-completion_002ddisplay_002dwidth"></a>
<p>执行完成时用于显示可能的匹配项的屏幕列数。如果该值小于0或大于终端屏幕宽度，则将忽略该值。值为0将使匹配项每行显示一次。默认值为-1。
</p>
</dd>
<dt><code>completion-ignore-case</code></dt>
<dd><a name="index-completion_002dignore_002dcase"></a>
<p>如果设置为“ <samp>on</samp> '，Readline以不区分大小写的方式执行文件名匹配和完成。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>completion-map-case</code></dt>
<dd><a name="index-completion_002dmap_002dcase"></a>
<p>如果设置为“ <samp>on</samp> '和<var>completion-ignore-case</var>启用后，Readline会处理连字符（' <samp>-</samp> '）和下划线（' <samp>_</samp> '）等价于不区分大小写的文件名匹配和补全。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>completion-prefix-display-length</code></dt>
<dd><a name="index-completion_002dprefix_002ddisplay_002dlength"></a>
<p>可能完成的列表的公共前缀的字符长度，无需更改即可显示。如果将其设置为大于零的值，则在显示可能的补全时，长于该值的公共前缀将用省略号替换。
</p>
</dd>
<dt><code>completion-query-items</code></dt>
<dd><a name="index-completion_002dquery_002ditems"></a>
<p>可能完成的次数，确定何时询问用户是否应显示可能性列表。如果可能的完成数量大于此值，Readline将询问用户是否希望查看它们；否则，将仅列出它们。此变量必须设置为大于或等于0的整数值。负值表示Readline永远不要问。默认限制是<code>100</code> 。
</p>
</dd>
<dt><code>convert-meta</code></dt>
<dd><a name="index-convert_002dmeta"></a>
<p>如果设置为“ <samp>on</samp> '，Readline会通过去除第八位并给<tt class="key">ESC</tt>字符加上前缀，将设置为第八位的字符转换为<small>ASCII</small>键序列，将其转换为元前缀的键序列。默认值为“ <samp>on</samp> '，但将设置为' <samp>off</samp> '（如果语言环境是包含八位字符的语言环境）。
</p>
</dd>
<dt><code>disable-completion</code></dt>
<dd><a name="index-disable_002dcompletion"></a>
<p>如果设置为“ <samp>On</samp> '，Readline将禁止单词补全。完成字符将被插入到该行中，就像它们已映射到<code>self-insert</code> 。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>echo-control-characters</code></dt>
<dd><a name="index-echo_002dcontrol_002dcharacters"></a>
<p>当设置为“ <samp>on</samp>在表示支持的操作系统上，readline会回显与键盘产生的信号相对应的字符。默认值为“ <samp>on</samp> '。
</p>
</dd>
<dt><code>editing-mode</code></dt>
<dd><a name="index-editing_002dmode"></a>
<p>的<code>editing-mode</code>变量控制使用哪个默认的键绑定集。默认情况下，Readline在Emacs编辑模式下启动，其击键与Emacs最相似。该变量可以设置为“ <samp>emacs</samp> ' 要么 ' <samp>vi</samp> '。
</p>
</dd>
<dt><code>emacs-mode-string</code></dt>
<dd><a name="index-emacs_002dmode_002dstring"></a>
<p>如果<var>show-mode-in-prompt</var>启用了变量，当emacs编辑模式处于活动状态时，此字符串显示在主提示符的最后一行之前。该值像键绑定一样扩展，因此可以使用标准的元和控制前缀以及反斜杠转义序列集。使用 ' <samp>\1</samp> '和' <samp>\2</samp> '转义非打印字符的开始和结束序列，这些序列可用于将终端控制序列嵌入到模式字符串中。默认值为“ <samp>@</samp> '。
</p>
</dd>
<dt><code>enable-bracketed-paste</code></dt>
<dd><a name="index-enable_002dbracketed_002dpaste"></a>
<p>当设置为“ <samp>On</samp> '，Readline将以某种方式配置终端，使终端可以将每个粘贴作为单个字符串插入到编辑缓冲区中，而不是像对待每个字符一样从键盘读取。这样可以防止将粘贴的字符解释为编辑命令。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>enable-keypad</code></dt>
<dd><a name="index-enable_002dkeypad"></a>
<p>当设置为“ <samp>on</samp> '，Readline会在被调用时尝试启用应用程序键盘。某些系统需要启用箭头键。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>enable-meta-key</code></dt>
<dd><p>当设置为“ <samp>on</samp> '，Readline将尝试启用终端声称支持的任何meta修饰符键。在许多终端上，元密钥用于发送八位字符。默认值为“ <samp>on</samp> '。
</p>
</dd>
<dt><code>expand-tilde</code></dt>
<dd><a name="index-expand_002dtilde"></a>
<p>如果设置为“ <samp>on</samp> '，在Readline尝试单词补全时执行波浪号扩展。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>history-preserve-point</code></dt>
<dd><a name="index-history_002dpreserve_002dpoint"></a>
<p>如果设置为“ <samp>on</samp> '，历史代码会尝试将点（当前光标位置）放置在通过以下方式检索到的每个历史行上的同一位置<code>previous-history</code>要么<code>next-history</code> 。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>history-size</code></dt>
<dd><a name="index-history_002dsize"></a>
<p>设置历史列表中保存的最大历史条目数。如果设置为零，则将删除任何现有历史记录条目，并且不保存任何新条目。如果设置为小于零的值，则历史记录条目的数量不受限制。默认情况下，历史记录条目的数量不受限制。如果尝试设置<var>history-size</var>设置为非数字值，历史记录条目的最大数量将设置为500。
</p>
</dd>
<dt><code>horizontal-scroll-mode</code></dt>
<dd><a name="index-horizontal_002dscroll_002dmode"></a>
<p>该变量可以设置为“ <samp>on</samp> ' 要么 ' <samp>off</samp> '。将其设置为“ <samp>on</samp> '表示当正在编辑的行的文本长于屏幕宽度时，它们将在单个屏幕行上水平滚动，而不是换行到新的屏幕行上。默认情况下，此变量设置为' <samp>off</samp> '。
</p>
</dd>
<dt><code>input-meta</code></dt>
<dd><a name="index-input_002dmeta"></a>
<a name="index-meta_002dflag"></a>
<p>如果设置为“ <samp>on</samp> '，Readline将启用八位输入（不会清除其读取的字符中的第八位），无论终端声称它可以支持什么。默认值为“ <samp>off</samp> '，但Readline会将其设置为' <samp>on</samp> '（如果语言环境包含八位字符）。名字<code>meta-flag</code>是此变量的同义词。
</p>
</dd>
<dt><code>isearch-terminators</code></dt>
<dd><a name="index-isearch_002dterminators"></a>
<p>应终止增量搜索而无需随后将其作为命令执行的字符字符串（请参阅“ <a href="#Searching">搜索”</a> ）。如果未给该变量赋值，则字符<tt class="key">ESC</tt>和<kbd>C-J</kbd>将终止增量搜索。
</p>
</dd>
<dt><code>keymap</code></dt>
<dd><a name="index-keymap"></a>
<p>设置Readline对键绑定命令的当前键映射的想法。内建<code>keymap</code>名字是<code>emacs</code> ， <code>emacs-standard</code> ， <code>emacs-meta</code> ， <code>emacs-ctlx</code> ， <code>vi</code> ， <code>vi-move</code> ， <code>vi-command</code>和<code>vi-insert</code> 。
<code>vi</code>相当于<code>vi-command</code> （ <code>vi-move</code>也是同义词）； <code>emacs</code>相当于<code>emacs-standard</code> 。应用程序可以添加其他名称。默认值为<code>emacs</code> 。的价值<code>editing-mode</code>变量也会影响默认的键盘映射。
</p>
</dd>
<dt><code>keyseq-timeout</code></dt>
<dd><p>指定在读取歧义键序列时Readline等待字符的持续时间（可以使用到目前为止的输入来形成完整的键序列，或者可以使用其他输入来完成更长的键序列）。如果在超时时间内未收到任何输入，Readline将使用较短但完整的键序列。Readline使用此值来确定当前输入源上是否有可用的输入（ <code>rl_instream</code>默认）。该值以毫秒为单位指定，因此值1000表示Readline将等待一秒钟以进行其他输入。如果将此变量设置为小于或等于零的值或非数字值，Readline将等待直到按下另一个键来确定要完成哪个键序列。默认值为<code>500</code> 。
</p>
</dd>
<dt><code>mark-directories</code></dt>
<dd><p>如果设置为“ <samp>on</samp> '，完整的目录名称后会加上斜杠。默认值为“ <samp>on</samp> '。
</p>
</dd>
<dt><code>mark-modified-lines</code></dt>
<dd><a name="index-mark_002dmodified_002dlines"></a>
<p>将此变量设置为“ <samp>on</samp> '，使Readline显示星号（' <samp>*</samp> '）在已修改的历史记录行的开头。此变量是“ <samp>off</samp> ' 默认。
</p>
</dd>
<dt><code>mark-symlinked-directories</code></dt>
<dd><a name="index-mark_002dsymlinked_002ddirectories"></a>
<p>如果设置为“ <samp>on</samp> '，是指向目录的符号链接的完整名称后加斜杠（取决于<code>mark-directories</code> ）。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>match-hidden-files</code></dt>
<dd><a name="index-match_002dhidden_002dfiles"></a>
<p>将此变量设置为“ <samp>on</samp> '，使Readline匹配名称以'开始的文件<samp>.</samp>文件名补全时为'（隐藏文件）。如果设置为“ <samp>off</samp> '，领先' <samp>.</samp>用户必须在文件名中提供'才能完成。此变量是“ <samp>on</samp> ' 默认。
</p>
</dd>
<dt><code>menu-complete-display-prefix</code></dt>
<dd><a name="index-menu_002dcomplete_002ddisplay_002dprefix"></a>
<p>如果设置为“ <samp>on</samp>在菜单循环显示之前，菜单完成显示可能完成列表的公共前缀（可能为空）。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>output-meta</code></dt>
<dd><a name="index-output_002dmeta"></a>
<p>如果设置为“ <samp>on</samp> '，Readline将直接显示设置了第八位的字符，而不是使用元前缀的转义序列。默认值为“ <samp>off</samp> '，但Readline会将其设置为' <samp>on</samp> '（如果语言环境包含八位字符）。
</p>
</dd>
<dt><code>page-completions</code></dt>
<dd><a name="index-page_002dcompletions"></a>
<p>如果设置为“ <samp>on</samp> '，Readline使用内部<code>more</code>类似的寻呼机，一次显示所有可能完成的屏幕。此变量是“ <samp>on</samp> ' 默认。
</p>
</dd>
<dt><code>print-completions-horizontally</code></dt>
<dd><p>如果设置为“ <samp>on</samp> '，Readline将显示按字母顺序水平排列的匹配的补全，而不是向下显示在屏幕上。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>revert-all-at-newline</code></dt>
<dd><a name="index-revert_002dall_002dat_002dnewline"></a>
<p>如果设置为“ <samp>on</samp> '，Readline将在返回以下内容之前撤消对历史记录行的所有更改： <code>accept-line</code>被执行。默认情况下，历史记录行可能会被修改，并在对的调用中保留各个撤消列表<code>readline</code> 。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>show-all-if-ambiguous</code></dt>
<dd><a name="index-show_002dall_002dif_002dambiguous"></a>
<p>这会更改完成功能的默认行为。如果设置为“ <samp>on</samp> '，具有多个可能补全的单词会导致立即列出匹配项，而不是按响。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>show-all-if-unmodified</code></dt>
<dd><a name="index-show_002dall_002dif_002dunmodified"></a>
<p>这将以类似于以下方式更改完成功能的默认行为： <var>show-all-if-ambiguous</var> 。如果设置为“ <samp>on</samp> '，具有多个可能补全而没有任何可能的部分补全（可能的补全不具有公共前缀）的单词会导致立即列出匹配项，而不是按响。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>show-mode-in-prompt</code></dt>
<dd><a name="index-show_002dmode_002din_002dprompt"></a>
<p>如果设置为“ <samp>on</samp> '，在提示的开头添加一个字符串，指示编辑模式：emacs，vi命令或vi插入。模式字符串是用户可设置的（例如， <var>emacs-mode-string</var> ）。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>skip-completed-text</code></dt>
<dd><a name="index-skip_002dcompleted_002dtext"></a>
<p>如果设置为“ <samp>on</samp> '，当在行中插入单个匹配项时，这会更改默认的完成行为。仅在单词中间执行补全时才有效。如果启用，readline不会从补全中插入与要补全单词中的点之后的字符匹配的字符，因此不会重复光标后面的单词部分。例如，如果启用了此功能，则当光标位于“ <samp>e</samp> '在' <samp>Makefile</samp> '将导致' <samp>Makefile</samp> ' 而不是 ' <samp>Makefilefile</samp> '，假设有一个可能的完成。默认值为“ <samp>off</samp> '。
</p>
</dd>
<dt><code>vi-cmd-mode-string</code></dt>
<dd><a name="index-vi_002dcmd_002dmode_002dstring"></a>
<p>如果<var>show-mode-in-prompt</var>启用了变量，当vi编辑模式处于活动状态且处于命令模式时，该字符串显示在主提示符的最后一行之前。该值像键绑定一样扩展，因此可以使用标准的元和控制前缀以及反斜杠转义序列集。使用 ' <samp>\1</samp> '和' <samp>\2</samp> '转义非打印字符的开始和结束序列，这些序列可用于将终端控制序列嵌入到模式字符串中。默认值为“ <samp>(cmd)</samp> '。
</p>
</dd>
<dt><code>vi-ins-mode-string</code></dt>
<dd><a name="index-vi_002dins_002dmode_002dstring"></a>
<p>如果<var>show-mode-in-prompt</var>启用了变量，当vi编辑模式处于活动状态且处于插入模式时，该字符串显示在主提示符最后一行的紧前面。该值像键绑定一样扩展，因此可以使用标准的元和控制前缀以及反斜杠转义序列集。使用 ' <samp>\1</samp> '和' <samp>\2</samp> '转义非打印字符的开始和结束序列，这些序列可用于将终端控制序列嵌入到模式字符串中。默认值为“ <samp>(ins)</samp> '。
</p>
</dd>
<dt><code>visible-stats</code></dt>
<dd><a name="index-visible_002dstats"></a>
<p>如果设置为“ <samp>on</samp> '，表示可能的补全时，在文件名后会附加一个表示文件类型的字符。默认值为“ <samp>off</samp> '。
</p>
</dd>
</dl>

</dd>
<dt>按键绑定</dt>
<dd><p>控制init文件中的键绑定的语法很简单。首先，您需要找到要更改的命令的名称。以下各节包含命令名称，默认键绑定（如果有）以及命令功能的简短说明的表。
</p>
<p>知道命令名称后，只需在初始化文件中的一行上放置您希望将命令绑定到的键的名称，冒号，然后是命令的名称。关键字名称和冒号之间不能有空格-这将被解释为关键字名称的一部分。钥匙的名称可以用不同的方式表示，具体取决于您觉得最舒适的方式。
</p>
<p>除命令名称外，readline还允许将键绑定到按下键时插入的字符串（ <var>macro</var> ）。
</p>
<p>的<code>bind <span class="nolinebreak">-p</span></code> <!-- /@w -->命令以可以直接放入初始化文件的格式显示Readline函数名称和绑定。参见<a href="#Bash-Builtins">Bash Builtins</a> 。
</p>
<dl compact>
<dt><var>keyname</var> ： <var><span class="nolinebreak">function-name</span></var>要么<var>macro</var> <!-- /@w --></dt>
<dd><p><var>keyname</var>是用英文拼写的密钥名称。例如：</p><div class="example">
<pre class="example">Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: &quot;&gt; output&quot;
</pre></div>

<p>在上面的示例中， <kbd>C-u</kbd>绑定到功能<code>universal-argument</code> ， <kbd>M-DEL</kbd>绑定到功能<code>backward-kill-word</code>和<kbd>C-o</kbd>势必会运行右侧表示的宏（即，插入文本“ <samp>> output</samp> '）。
</p>
<p>在处理此键绑定语法时，会识别出许多符号字符名称： <var>DEL</var> ， <var>ESC</var> ， <var>ESCAPE</var> ， <var>LFD</var> ， <var>NEWLINE</var> ， <var>RET</var> ， <var>RETURN</var> ， <var>RUBOUT</var> ， <var>SPACE</var> ， <var>SPC</var>和<var>TAB</var> 。
</p>
</dd>
<dt>” <var>keyseq</var> “： <var><span class="nolinebreak">function-name</span></var>要么<var>macro</var> <!-- /@w --></dt>
<dd><p><var>keyseq</var>不同于<var>keyname</var>通过将关键字序列放在双引号中，可以指定表示整个关键字序列的字符串。可以使用某些<small>GNU</small> Emacs样式的键转义符，如下面的示例所示，但是不能识别特殊字符名称。
</p>
<div class="example">
<pre class="example">&quot;\C-u&quot;: universal-argument
&quot;\C-x\C-r&quot;: re-read-init-file
&quot;\e[11~&quot;: &quot;Function Key 1&quot;
</pre></div>

<p>在以上示例中， <kbd>C-u</kbd>再次绑定到功能<code>universal-argument</code> （就像在第一个示例中一样），“ <samp><kbd>C-x</kbd> <kbd>C-r</kbd></samp> '绑定到功能<code>re-read-init-file</code>和' <samp><span class="key">ESC</span> <span class="key">[</span> <span class="key">1</span> <span class="key">1</span> <span class="key">~</span></samp> '必将插入文本' <samp>Function Key 1</samp> '。
</p>
</dd>
</dl>

<p>指定键序列时，可以使用以下<small>GNU</small> Emacs样式转义序列：</p>
<dl compact>
<dt><code><kbd>\C-</kbd></code></dt>
<dd><p>控制字头</p></dd>
<dt><code><kbd>\M-</kbd></code></dt>
<dd><p>元前缀</p></dd>
<dt><code><kbd>\e</kbd></code></dt>
<dd><p>转义字符</p></dd>
<dt><code><kbd>\\</kbd></code></dt>
<dd><p>反斜杠</p></dd>
<dt><code><kbd>\"</kbd></code></dt>
<dd><p><tt class="key">“</tt> ，双引号</p></dd>
<dt><code><kbd>\'</kbd></code></dt>
<dd><p><tt class="key">'</tt> ，单引号或撇号</p></dd>
</dl>

<p>除了<small>GNU</small> Emacs样式转义序列外，还有第二组反斜杠转义：</p>
<dl compact>
<dt><code>\a</code></dt>
<dd><p>警觉</p></dd>
<dt><code>\b</code></dt>
<dd><p>退格键</p></dd>
<dt><code>\d</code></dt>
<dd><p>删除</p></dd>
<dt><code>\f</code></dt>
<dd><p>换页</p></dd>
<dt><code>\n</code></dt>
<dd><p>新队</p></dd>
<dt><code>\r</code></dt>
<dd><p>回车</p></dd>
<dt><code>\t</code></dt>
<dd><p>水平标签</p></dd>
<dt><code>\v</code></dt>
<dd><p>垂直标签</p></dd>
<dt><code>\<var>nnn</var></code></dt>
<dd><p>八位字符，其值为八进制值<var>nnn</var> （一到三位数）</p></dd>
<dt><code>\x<var>HH</var></code></dt>
<dd><p>八位字符，其值为十六进制值<var>HH</var> （一个或两个十六进制数字）</p></dd>
</dl>

<p>输入宏文本时，必须使用单引号或双引号表示宏定义。假定未加引号的文本为函数名称。在宏主体中，上述反斜杠转义符得到扩展。反斜杠将引用宏文本中的任何其他字符，包括“ <samp>"</samp> '和' <samp>'</samp> '。例如，以下绑定将使“ <samp><kbd>C-x</kbd> \</samp> '插入一个' <samp>\</samp> '进入行：</p><div class="example">
<pre class="example">&quot;\C-x\\&quot;: &quot;\\&quot;
</pre></div>

</dd>
</dl>

<hr>
<a name="Conditional-Init-Constructs"></a>
<div class="header">
<p>下一页： <a href="#Sample-Init-File" rel="next" accesskey="n">示例初始化文件</a> ，上一篇： <a href="#Readline-Init-File-Syntax" rel="prev" accesskey="p">Readline初始化文件语法</a> ，上一篇： <a href="#Readline-Init-File" rel="up" accesskey="u">Readline初始化文件</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Conditional-Init-Constructs-1"></a>
<h4 class="subsection">8.3.2条件初始化构造</h4>

<p>Readline在精神上实现了与C预处理程序的条件编译功能类似的功能，该功能允许根据测试结果执行键绑定和变量设置。使用了四个解析器指令。
</p>
<dl compact>
<dt><code>$if</code></dt>
<dd><p>的<code>$if</code>构造允许根据编辑模式，使用的终端或使用Readline的应用程序进行绑定。在进行任何比较运算符之后，测试文本将扩展到该行的末尾；除非另有说明，否则不需要任何字符来隔离它。
</p>
<dl compact>
<dt><code>mode</code></dt>
<dd><p>的<code>mode=</code>的形式<code>$if</code>指令用于测试Readline是否在<code>emacs</code>要么<code>vi</code>模式。这可以与“ <samp>set keymap</samp> '命令，例如，在<code>emacs-standard</code>和<code>emacs-ctlx</code>仅当Readline开始于<code>emacs</code>模式。
</p>
</dd>
<dt><code>term</code></dt>
<dd><p>的<code>term=</code>表格可以用于包含特定于终端的键绑定，也可以用于绑定终端功能键输出的键序列。' <samp>=</samp> '会根据终端的全名和第一个'前的终端名称部分进行测试<samp>-</samp> '。这允许<code>sun</code>同时匹配<code>sun</code>和<code>sun-cmd</code> ， 例如。
</p>
</dd>
<dt><code>version</code></dt>
<dd><p>的<code>version</code>测试可用于与特定Readline版本进行比较。的<code>version</code>扩展到当前的Readline版本。比较运算符集包括“ <samp>=</samp> '（和' <samp>==</samp> '），' <samp>!=</samp> '，' <samp><=</samp> '，' <samp>>=</samp> '，' <samp><</samp> '和' <samp>></samp> '。操作员右侧提供的版本号由主版本号，可选的小数点和可选的次要版本（例如' <samp>7.1</samp> '）。如果省略了次要版本，则假定为“ <samp>0</samp> '。运算符可以与字符串分开<code>version</code>并从版本号参数中输入空格。如果使用的Readline版本是7.0或更高版本，以下示例将设置一个变量：</p><div class="example">
<pre class="example">$if version &gt;= 7.0
set show-mode-in-prompt on
$endif
</pre></div>

</dd>
<dt><code>application</code></dt>
<dd><p>的<var>application</var>构造用于包含特定于应用程序的设置。每个使用Readline库的程序都会设置<var>application name</var> ，您可以测试特定的值。这可用于将键序列绑定到对特定程序有用的功能。例如，以下命令添加了一个键序列，该键序列引用Bash中的当前单词或上一个单词：</p><div class="example">
<pre class="example">$if Bash
# Quote the current or previous word
&quot;\C-xq&quot;: &quot;\eb\&quot;\ef\&quot;&quot;
$endif
</pre></div>

</dd>
<dt><code>variable</code></dt>
<dd><p>的<var>variable</var>构造为Readline变量和值提供简单的相等性测试。允许的比较运算符为“ <samp>=</samp> '，' <samp>==</samp> '和' <samp>!=</samp> '。变量名称必须与比较运算符之间用空格隔开；运算符可以与右侧的值用空格隔开。字符串和布尔变量都可以测试。布尔变量必须根据值进行测试<var>on</var>和<var>off</var> 。以下示例等效于<code>mode=emacs</code>上述测试：</p><div class="example">
<pre class="example">$if editing-mode == emacs
set show-mode-in-prompt on
$endif
</pre></div>
</dd>
</dl>

</dd>
<dt><code>$endif</code></dt>
<dd><p>如上例所示，该命令将终止<code>$if</code>命令。
</p>
</dd>
<dt><code>$else</code></dt>
<dd><p>此分支中的命令<code>$if</code>如果测试失败，则执行指令。
</p>
</dd>
<dt><code>$include</code></dt>
<dd><p>该指令将单个文件名作为参数，并从该文件读取命令和绑定。例如，以下指令从<samp>/etc/inputrc</samp> ：</p><div class="example">
<pre class="example">$include /etc/inputrc
</pre></div>
</dd>
</dl>

<hr>
<a name="Sample-Init-File"></a>
<div class="header">
<p>上<a href="#Readline-Init-File" rel="up" accesskey="u">一篇</a> ： <a href="#Conditional-Init-Constructs" rel="prev" accesskey="p">条件初始化构造</a> ，上<a href="#Readline-Init-File" rel="up" accesskey="u">一篇</a> ： <a href="#Readline-Init-File" rel="up" accesskey="u">Readline初始化文件</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Sample-Init-File-1"></a>
<h4 class="subsection">8.3.3样本初始化文件</h4>

<p>这是一个例子<var>inputrc</var>文件。这说明了键绑定，变量分配和条件语法。
</p>
<div class="example">
<pre class="example"># This file controls the behaviour of line input editing for
# programs that use the GNU Readline library.  Existing
# programs include FTP, Bash, and GDB.
#
# You can re-read the inputrc file with C-x C-r.
# Lines beginning with '#' are comments.
#
# First, include any system-wide bindings and variable
# assignments from /etc/Inputrc
$include /etc/Inputrc

#
# Set various bindings for emacs mode.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:	backward-kill-word	Text after the function name is ignored

#
# Arrow keys in keypad mode
#
#&quot;\M-OD&quot;:        backward-char
#&quot;\M-OC&quot;:        forward-char
#&quot;\M-OA&quot;:        previous-history
#&quot;\M-OB&quot;:        next-history
#
# Arrow keys in ANSI mode
#
&quot;\M-[D&quot;:        backward-char
&quot;\M-[C&quot;:        forward-char
&quot;\M-[A&quot;:        previous-history
&quot;\M-[B&quot;:        next-history
#
# Arrow keys in 8 bit keypad mode
#
#&quot;\M-\C-OD&quot;:       backward-char
#&quot;\M-\C-OC&quot;:       forward-char
#&quot;\M-\C-OA&quot;:       previous-history
#&quot;\M-\C-OB&quot;:       next-history
#
# Arrow keys in 8 bit ANSI mode
#
#&quot;\M-\C-[D&quot;:       backward-char
#&quot;\M-\C-[C&quot;:       forward-char
#&quot;\M-\C-[A&quot;:       previous-history
#&quot;\M-\C-[B&quot;:       next-history

C-q: quoted-insert

$endif

# An old-style binding.  This happens to be the default.
TAB: complete

# Macros that are convenient for shell interaction
$if Bash
# edit the path
&quot;\C-xp&quot;: &quot;PATH=${PATH}\e\C-e\C-a\ef\C-f&quot;
# prepare to type a quoted word --
# insert open and close double quotes
# and move to just after the open quote
&quot;\C-x\&quot;&quot;: &quot;\&quot;\&quot;\C-b&quot;
# insert a backslash (testing backslash escapes
# in sequences and macros)
&quot;\C-x\\&quot;: &quot;\\&quot;
# Quote the current or previous word
&quot;\C-xq&quot;: &quot;\eb\&quot;\ef\&quot;&quot;
# Add a binding to refresh the line, which is unbound
&quot;\C-xr&quot;: redraw-current-line
# Edit variable on current line.
&quot;\M-\C-v&quot;: &quot;\C-a\C-k$\C-y\M-\C-e\C-a\C-y=&quot;
$endif

# use a visible bell if one is available
set bell-style visible

# don't strip characters to 7 bits when reading
set input-meta on

# allow iso-latin1 characters to be inserted rather
# than converted to prefix-meta sequences
set convert-meta off

# display characters with the eighth bit set directly
# rather than as meta-prefixed characters
set output-meta on

# if there are more than 150 possible completions for
# a word, ask the user if he wants to see all of them
set completion-query-items 150

# For FTP
$if Ftp
&quot;\C-xg&quot;: &quot;get \M-?&quot;
&quot;\C-xt&quot;: &quot;put \M-?&quot;
&quot;\M-.&quot;: yank-last-arg
$endif
</pre></div>

<hr>
<a name="Bindable-Readline-Commands"></a>
<div class="header">
<p>下一个： <a href="#Readline-vi-Mode" rel="next" accesskey="n">Readline vi Mode</a> ，上一个： <a href="#Readline-Init-File" rel="prev" accesskey="p">Readline Init File</a> ，上一个： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bindable-Readline-Commands-1"></a>
<h3 class="section">8.4可绑定的Readline命令</h3>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Commands-For-Moving" accesskey="1">移动命令</a> ：</td><td>  </td><td align="left" valign="top">沿线移动。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Commands-For-History" accesskey="2">历史命令</a> ：</td><td>  </td><td align="left" valign="top">了解前几行。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Commands-For-Text" accesskey="3">文本命令</a> ：</td><td>  </td><td align="left" valign="top">更改文本的命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Commands-For-Killing" accesskey="4">杀死命令</a> ：</td><td>  </td><td align="left" valign="top">杀死和猛击的命令。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Numeric-Arguments" accesskey="5">数值参数</a> ：</td><td>  </td><td align="left" valign="top">指定数字参数，重复计数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Commands-For-Completion" accesskey="6">完成命令</a> ：</td><td>  </td><td align="left" valign="top">让Readline为您打字。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Keyboard-Macros" accesskey="7">键盘宏</a> ：</td><td>  </td><td align="left" valign="top">保存并重新执行键入的字符</td></tr>
<tr><td align="left" valign="top">• <a href="#Miscellaneous-Commands" accesskey="8">其他命令</a> ：</td><td>  </td><td align="left" valign="top">其他杂项命令。
</td></tr>
</tbody></table>

<p>本节描述了可能绑定到按键序列的Readline命令。您可以通过执行来列出您的键绑定<code>bind <span class="nolinebreak">-P</span></code> <!-- /@w -->或者，对于更简洁的格式，适用于<var>inputrc</var>文件， <code>bind <span class="nolinebreak">-p</span></code> <!-- /@w --> 。（请参阅<a href="#Bash-Builtins">Bash Builtins</a> 。）默认情况下，不带键序的命令名称是未绑定的。
</p>
<p>在以下描述中， <em>点</em>是指当前光标位置，而<em>标记</em>是指由光标保存的光标位置。 <code>set-mark</code>命令。点和标记之间的文本称为<em>区域</em> 。
</p>
<hr>
<a name="Commands-For-Moving"></a>
<div class="header">
<p>下一页： <a href="#Commands-For-History" rel="next" accesskey="n">历史命令</a> ，上一篇： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Commands-For-Moving-1"></a>
<h4 class="subsection">8.4.1移动命令</h4>
<dl compact>
<dt><code>beginning-of-line (C-a)</code>
<a name="index-beginning_002dof_002dline-_0028C_002da_0029"></a>
</dt>
<dd><p>移至当前行的开头。
</p>
</dd>
<dt><code>end-of-line (C-e)</code>
<a name="index-end_002dof_002dline-_0028C_002de_0029"></a>
</dt>
<dd><p>移至行尾。
</p>
</dd>
<dt><code>forward-char (C-f)</code>
<a name="index-forward_002dchar-_0028C_002df_0029"></a>
</dt>
<dd><p>前进一个角色。
</p>
</dd>
<dt><code>backward-char (C-b)</code>
<a name="index-backward_002dchar-_0028C_002db_0029"></a>
</dt>
<dd><p>向后移动一个字符。
</p>
</dd>
<dt><code>forward-word (M-f)</code>
<a name="index-forward_002dword-_0028M_002df_0029"></a>
</dt>
<dd><p>前进到下一个单词的末尾。单词由字母和数字组成。
</p>
</dd>
<dt><code>backward-word (M-b)</code>
<a name="index-backward_002dword-_0028M_002db_0029"></a>
</dt>
<dd><p>移回当前或上一个单词的开头。单词由字母和数字组成。
</p>
</dd>
<dt><code>shell-forward-word ()</code>
<a name="index-shell_002dforward_002dword-_0028_0029"></a>
</dt>
<dd><p>前进到下一个单词的末尾。单词由未引用的外壳元字符定界。
</p>
</dd>
<dt><code>shell-backward-word ()</code>
<a name="index-shell_002dbackward_002dword-_0028_0029"></a>
</dt>
<dd><p>移回当前或上一个单词的开头。单词由未引用的外壳元字符定界。
</p>
</dd>
<dt><code>previous-screen-line ()</code>
<a name="index-previous_002dscreen_002dline-_0028_0029"></a>
</dt>
<dd><p>尝试将点移动到上一个物理屏幕行上的同一物理屏幕列。如果当前的Readline行不占用多于一条物理行，或者如果point不大于提示的长度加屏幕宽度，则将不会达到预期的效果。
</p>
</dd>
<dt><code>next-screen-line ()</code>
<a name="index-next_002dscreen_002dline-_0028_0029"></a>
</dt>
<dd><p>尝试将点移动到下一个物理屏幕行上的同一物理屏幕列。如果当前的Readline行不多于一条物理行，或者当前的Readline行的长度不大于提示的长度加屏幕宽度，则将不会达到预期的效果。
</p>
</dd>
<dt><code>clear-screen (C-l)</code>
<a name="index-clear_002dscreen-_0028C_002dl_0029"></a>
</dt>
<dd><p>清除屏幕并重绘当前行，将当前行留在屏幕顶部。
</p>
</dd>
<dt><code>redraw-current-line ()</code>
<a name="index-redraw_002dcurrent_002dline-_0028_0029"></a>
</dt>
<dd><p>刷新当前行。默认情况下，这是未绑定的。
</p>
</dd>
</dl>

<hr>
<a name="Commands-For-History"></a>
<div class="header">
<p>下一个： <a href="#Commands-For-Text" rel="next" accesskey="n">文本命令</a> ，上一个： <a href="#Commands-For-Moving" rel="prev" accesskey="p">移动命令</a> ，向上： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Commands-For-Manipulating-The-History"></a>
<h4 class="subsection">8.4.2操作历史的命令</h4>

<dl compact>
<dt><code>accept-line (Newline or Return)</code>
<a name="index-accept_002dline-_0028Newline-or-Return_0029"></a>
</dt>
<dd><p>无论光标在哪里，都接受该行。如果此行为非空行，则根据该行的设置将其添加到历史记录列表中<code>HISTCONTROL</code>和<code>HISTIGNORE</code>变量。如果此行是修改后的历史记录行，则将历史记录行恢复为其原始状态。
</p>
</dd>
<dt><code>previous-history (C-p)</code>
<a name="index-previous_002dhistory-_0028C_002dp_0029"></a>
</dt>
<dd><p>在历史记录列表中移动“后退”，以获取上一个命令。
</p>
</dd>
<dt><code>next-history (C-n)</code>
<a name="index-next_002dhistory-_0028C_002dn_0029"></a>
</dt>
<dd><p>在历史记录列表中“前进”，获取下一个命令。
</p>
</dd>
<dt><code>beginning-of-history (M-<)</code>
<a name="index-beginning_002dof_002dhistory-_0028M_002d_003c_0029"></a>
</dt>
<dd><p>移至历史记录的第一行。
</p>
</dd>
<dt><code>end-of-history (M->)</code>
<a name="index-end_002dof_002dhistory-_0028M_002d_003e_0029"></a>
</dt>
<dd><p>移至输入历史记录的末尾，即当前正在输入的行。
</p>
</dd>
<dt><code>reverse-search-history (C-r)</code>
<a name="index-reverse_002dsearch_002dhistory-_0028C_002dr_0029"></a>
</dt>
<dd><p>从当前行开始向后搜索，并根据需要在历史记录中向上移动。这是一个增量搜索。
</p>
</dd>
<dt><code>forward-search-history (C-s)</code>
<a name="index-forward_002dsearch_002dhistory-_0028C_002ds_0029"></a>
</dt>
<dd><p>从当前行开始向前搜索，并根据需要在历史记录中“向下”移动。这是一个增量搜索。
</p>
</dd>
<dt><code>non-incremental-reverse-search-history (M-p)</code>
<a name="index-non_002dincremental_002dreverse_002dsearch_002dhistory-_0028M_002dp_0029"></a>
</dt>
<dd><p>从当前行开始向后搜索，并根据需要使用非增量搜索用户提供的字符串在历史记录中“向上”移动。搜索字符串可能与历史记录行中的任何位置匹配。
</p>
</dd>
<dt><code>non-incremental-forward-search-history (M-n)</code>
<a name="index-non_002dincremental_002dforward_002dsearch_002dhistory-_0028M_002dn_0029"></a>
</dt>
<dd><p>从当前行开始向前搜索，并根据需要使用非增量搜索用户提供的字符串在历史记录中“向下”移动。搜索字符串可能与历史记录行中的任何位置匹配。
</p>
</dd>
<dt><code>history-search-forward ()</code>
<a name="index-history_002dsearch_002dforward-_0028_0029"></a>
</dt>
<dd><p>在历史记录中向前搜索当前行的起点与该点之间的字符串。搜索字符串必须在历史记录行的开头匹配。这是非增量搜索。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>history-search-backward ()</code>
<a name="index-history_002dsearch_002dbackward-_0028_0029"></a>
</dt>
<dd><p>在历史记录中向后搜索当前行的起点与该点之间的字符串。搜索字符串必须在历史记录行的开头匹配。这是非增量搜索。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>history-substring-search-forward ()</code>
<a name="index-history_002dsubstring_002dsearch_002dforward-_0028_0029"></a>
</dt>
<dd><p>在历史记录中向前搜索当前行的起点与该点之间的字符串。搜索字符串可能与历史记录行中的任何位置匹配。这是非增量搜索。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>history-substring-search-backward ()</code>
<a name="index-history_002dsubstring_002dsearch_002dbackward-_0028_0029"></a>
</dt>
<dd><p>在历史记录中向后搜索当前行的起点与该点之间的字符串。搜索字符串可能与历史记录行中的任何位置匹配。这是非增量搜索。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>yank-nth-arg (M-C-y)</code>
<a name="index-yank_002dnth_002darg-_0028M_002dC_002dy_0029"></a>
</dt>
<dd><p>将第一个参数插入上一个命令（通常是前一行的第二个单词）。有争论<var>n</var> ，插入<var>n</var>上一个命令中的第一个单词（上一个命令中的单词以单词0开头）。否定参数插入<var>n</var>前一个命令末尾的第一个字。一旦争论<var>n</var>计算后，提取参数就像“ <samp>!<var>n</var></samp>已指定历史扩展。
</p>
</dd>
<dt><code>yank-last-arg (M-. or M-_)</code>
<a name="index-yank_002dlast_002darg-_0028M_002d_002e-or-M_002d_005f_0029"></a>
</dt>
<dd><p>将上一个参数插入上一个命令（上一个历史记录条目的最后一个单词）。使用数字参数时，其行为与<code>yank-nth-arg</code> 。连续致电<code>yank-last-arg</code>返回历史记录列表，依次插入每行的最后一个单词（或第一个调用的参数指定的单词）。提供给这些连续调用的任何数字参数都确定在历史记录中移动的方向。否定参数可切换历史记录的方向（后退或前进）。历史记录扩展工具用于提取最后一个参数，就像“ <samp>!$</samp>已指定历史扩展。
</p>
</dd>
</dl>

<hr>
<a name="Commands-For-Text"></a>
<div class="header">
<p>下一页： <a href="#Commands-For-Killing" rel="next" accesskey="n">命令杀害</a> ，上一篇： <a href="#Commands-For-History" rel="prev" accesskey="p">命令对于历史</a> ，最多： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的ReadLine命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Commands-For-Changing-Text"></a>
<h4 class="subsection">8.4.3更改文本的命令</h4>

<dl compact>
<dt><code><i>end-of-file</i> (usually C-d)</code>
<a name="index-end_002dof_002dfile-_0028usually-C_002dd_0029"></a>
</dt>
<dd><p>表示文件结束的字符，例如，由<code>stty</code> 。如果在行上没有字符且点位于行的开头时读取了此字符，则Readline会将其解释为输入的结尾，并返回<small>EOF</small> 。</p>
</dd>
<dt><code>delete-char (C-d)</code>
<a name="index-delete_002dchar-_0028C_002dd_0029"></a>
</dt>
<dd><p>删除角色点。如果此函数与tty <small>EOF</small>字符绑定到相同的字符，则为<kbd>C-d</kbd>通常是，请参阅上面的效果。
</p>
</dd>
<dt><code>backward-delete-char (Rubout)</code>
<a name="index-backward_002ddelete_002dchar-_0028Rubout_0029"></a>
</dt>
<dd><p>删除光标后面的字符。数字参数表示杀死字符而不是删除它们。
</p>
</dd>
<dt><code>forward-backward-delete-char ()</code>
<a name="index-forward_002dbackward_002ddelete_002dchar-_0028_0029"></a>
</dt>
<dd><p>删除光标下方的字符，除非光标位于该行的末尾，在这种情况下，光标后面的字符将被删除。默认情况下，此键未绑定到密钥。
</p>
</dd>
<dt><code>quoted-insert (C-q or C-v)</code>
<a name="index-quoted_002dinsert-_0028C_002dq-or-C_002dv_0029"></a>
</dt>
<dd><p>将键入的下一个字符逐字添加到行中。这是如何插入键序列<kbd>C-q</kbd> ， 例如。
</p>

</dd>
<dt><code>self-insert (a, b, A, 1, !, …)</code>
<a name="index-self_002dinsert-_0028a_002c-b_002c-A_002c-1_002c-_0021_002c-_2026_0029"></a>
</dt>
<dd><p>插入自己。
</p>
</dd>
<dt><code>bracketed-paste-begin ()</code>
<a name="index-bracketed_002dpaste_002dbegin-_0028_0029"></a>
</dt>
<dd><p>该功能旨在绑定到某些终端发送的“带括号粘贴”转义序列，并且默认情况下分配了这种绑定。它允许Readline将粘贴的文本作为一个单元插入，而不必像对待每个字符一样从键盘读取文本。插入字符，就像每个字符都绑定到一样<code>self-insert</code>而不是执行任何编辑命令。
</p>
</dd>
<dt><code>transpose-chars (C-t)</code>
<a name="index-transpose_002dchars-_0028C_002dt_0029"></a>
</dt>
<dd><p>将光标之前的字符向前拖动到光标处的字符上方，也向前移动光标。如果插入点在该行的末尾，则它将转置该行的最后两个字符。否定论点无效。
</p>
</dd>
<dt><code>transpose-words (M-t)</code>
<a name="index-transpose_002dwords-_0028M_002dt_0029"></a>
</dt>
<dd><p>将单词之前的单词拖到单词之后的单词上，也将单词移动到单词之后。如果插入点在该行的末尾，则这将对行的最后两个单词进行转置。
</p>
</dd>
<dt><code>upcase-word (M-u)</code>
<a name="index-upcase_002dword-_0028M_002du_0029"></a>
</dt>
<dd><p>大写当前（或后面）的单词。带有负参数时，将上一个单词大写，但不要移动光标。
</p>
</dd>
<dt><code>downcase-word (M-l)</code>
<a name="index-downcase_002dword-_0028M_002dl_0029"></a>
</dt>
<dd><p>小写当前（或后面）的单词。带有负参数时，将前一个单词小写，但不要移动光标。
</p>
</dd>
<dt><code>capitalize-word (M-c)</code>
<a name="index-capitalize_002dword-_0028M_002dc_0029"></a>
</dt>
<dd><p>大写当前（或后面）的单词。如果参数为负，则将前一个单词大写，但不要移动光标。
</p>
</dd>
<dt><code>overwrite-mode ()</code>
<a name="index-overwrite_002dmode-_0028_0029"></a>
</dt>
<dd><p>切换覆盖模式。使用显式正数值参数，切换到覆盖模式。使用显式的非正数值参数，切换到插入模式。此命令仅影响<code>emacs</code>模式; <code>vi</code>模式覆盖的方式有所不同。每次致电<code>readline()</code>在插入模式下启动。
</p>
<p>在覆盖模式下，字符绑定到<code>self-insert</code>在此处替换文本，而不是将文本推到右侧。绑定到的字符<code>backward-delete-char</code>用空格替换点之前的字符。
</p>
<p>默认情况下，此命令是未绑定的。
</p>
</dd>
</dl>

<hr>
<a name="Commands-For-Killing"></a>
<div class="header">
<p>下一篇： <a href="#Numeric-Arguments" rel="next" accesskey="n">数值参数</a> ，上一篇： <a href="#Commands-For-Text" rel="prev" accesskey="p">文本命令</a> ，上一篇： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Killing-And-Yanking"></a>
<h4 class="subsection">8.4.4杀与杀</h4>

<dl compact>
<dt><code>kill-line (C-k)</code>
<a name="index-kill_002dline-_0028C_002dk_0029"></a>
</dt>
<dd><p>从点到行的末尾杀死文本。
</p>
</dd>
<dt><code>backward-kill-line (C-x Rubout)</code>
<a name="index-backward_002dkill_002dline-_0028C_002dx-Rubout_0029"></a>
</dt>
<dd><p>从光标向后杀死到当前行的开头。
</p>
</dd>
<dt><code>unix-line-discard (C-u)</code>
<a name="index-unix_002dline_002ddiscard-_0028C_002du_0029"></a>
</dt>
<dd><p>从光标向后杀死到当前行的开头。
</p>
</dd>
<dt><code>kill-whole-line ()</code>
<a name="index-kill_002dwhole_002dline-_0028_0029"></a>
</dt>
<dd><p>无论指向何处，都要杀死当前行上的所有字符。默认情况下，这是未绑定的。
</p>
</dd>
<dt><code>kill-word (M-d)</code>
<a name="index-kill_002dword-_0028M_002dd_0029"></a>
</dt>
<dd><p>从点杀死到当前单词的末尾，或者从单词之间终止，直到下一个单词的末尾。字边界与<code>forward-word</code> 。
</p>
</dd>
<dt><code>backward-kill-word (M-<span class="key">DEL</span>)</code>
<a name="index-backward_002dkill_002dword-_0028M_002dDEL_0029"></a>
</dt>
<dd><p>杀了这个词。字边界与<code>backward-word</code> 。
</p>
</dd>
<dt><code>shell-kill-word ()</code>
<a name="index-shell_002dkill_002dword-_0028_0029"></a>
</dt>
<dd><p>从点杀死到当前单词的末尾，或者从单词之间终止，直到下一个单词的末尾。字边界与<code>shell-forward-word</code> 。
</p>
</dd>
<dt><code>shell-backward-kill-word ()</code>
<a name="index-shell_002dbackward_002dkill_002dword-_0028_0029"></a>
</dt>
<dd><p>杀了这个词。字边界与<code>shell-backward-word</code> 。
</p>
</dd>
<dt><code>unix-word-rubout (C-w)</code>
<a name="index-unix_002dword_002drubout-_0028C_002dw_0029"></a>
</dt>
<dd><p>使用空格作为单词边界，杀死点后面的单词。被杀死的文本保存在杀伤环上。
</p>
</dd>
<dt><code>unix-filename-rubout ()</code>
<a name="index-unix_002dfilename_002drubout-_0028_0029"></a>
</dt>
<dd><p>使用空格和斜线字符作为单词边界，杀死点后面的单词。被杀死的文本保存在杀伤环上。
</p>
</dd>
<dt><code>delete-horizontal-space ()</code>
<a name="index-delete_002dhorizontal_002dspace-_0028_0029"></a>
</dt>
<dd><p>删除点周围的所有空格和制表符。默认情况下，这是未绑定的。
</p>
</dd>
<dt><code>kill-region ()</code>
<a name="index-kill_002dregion-_0028_0029"></a>
</dt>
<dd><p>杀死当前区域中的文本。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>copy-region-as-kill ()</code>
<a name="index-copy_002dregion_002das_002dkill-_0028_0029"></a>
</dt>
<dd><p>将区域中的文本复制到终止缓冲区，以便立即将其取消。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>copy-backward-word ()</code>
<a name="index-copy_002dbackward_002dword-_0028_0029"></a>
</dt>
<dd><p>将单词之前的单词复制到终止缓冲区。边界一词与<code>backward-word</code> 。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>copy-forward-word ()</code>
<a name="index-copy_002dforward_002dword-_0028_0029"></a>
</dt>
<dd><p>将以下单词复制到终止缓冲区。边界一词与<code>forward-word</code> 。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>yank (C-y)</code>
<a name="index-yank-_0028C_002dy_0029"></a>
</dt>
<dd><p>将终止环的顶部插入点处的缓冲区。
</p>
</dd>
<dt><code>yank-pop (M-y)</code>
<a name="index-yank_002dpop-_0028M_002dy_0029"></a>
</dt>
<dd><p>旋转压环，然后拉出新的顶部。仅当先前命令为<code>yank</code>要么<code>yank-pop</code> 。
</p></dd>
</dl>

<hr>
<a name="Numeric-Arguments"></a>
<div class="header">
<p>下一个： <a href="#Commands-For-Completion" rel="next" accesskey="n">完成命令</a> ，上一个： <a href="#Commands-For-Killing" rel="prev" accesskey="p">杀死命令</a> ，向上： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Specifying-Numeric-Arguments"></a>
<h4 class="subsection">8.4.5指定数值参数</h4>
<dl compact>
<dt><code>digit-argument (<kbd>M-0</kbd>, <kbd>M-1</kbd>, … <kbd>M--</kbd>)</code>
<a name="index-digit_002dargument-_0028M_002d0_002c-M_002d1_002c-_2026-M_002d_002d_0029"></a>
</dt>
<dd><p>将此数字添加到已经累加的参数中，或开始一个新的参数。 <kbd>M--</kbd>开始否定论点。
</p>
</dd>
<dt><code>universal-argument ()</code>
<a name="index-universal_002dargument-_0028_0029"></a>
</dt>
<dd><p>这是指定参数的另一种方法。如果此命令后跟一个或多个数字，可以选择在其前面加上减号，则这些数字将定义参数。如果命令后跟数字，则执行<code>universal-argument</code>再次结束数值参数，但否则将被忽略。作为一种特殊情况，如果此命令后紧跟一个既不是数字也不是负号的字符，则下一个命令的参数计数将乘以四。参数计数最初为1，因此第一次执行此功能将使参数计数为4，第二次使参数计数为16，依此类推。默认情况下，此键未绑定到密钥。
</p></dd>
</dl>

<hr>
<a name="Commands-For-Completion"></a>
<div class="header">
<p>下一篇： <a href="#Keyboard-Macros" rel="next" accesskey="n">键盘宏</a> ，上一篇： <a href="#Numeric-Arguments" rel="prev" accesskey="p">数字参数</a> ，上一篇： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Letting-Readline-Type-For-You"></a>
<h4 class="subsection">8.4.6为您提供Readline类型</h4>

<dl compact>
<dt><code>complete (<span class="key">TAB</span>)</code>
<a name="index-complete-_0028TAB_0029"></a>
</dt>
<dd><p>尝试对点之前的文本执行补全。实际执行的完成是特定于应用程序的。Bash尝试完成将文本视为变量的操作（如果文本以“ <samp>$</samp> '），用户名（如果文字以' <samp>~</samp> '），主机名（如果文本以' <samp>@</samp> '），或依次使用命令（包括别名和函数）。如果没有一个匹配项，则尝试完成文件名。
</p>
</dd>
<dt><code>possible-completions (M-?)</code>
<a name="index-possible_002dcompletions-_0028M_002d_003f_0029"></a>
</dt>
<dd><p>在要点之前列出可能的文本补全。显示完成时，Readline将用于显示的列数设置为<code>completion-display-width</code> ，环境变量的值<code>COLUMNS</code>或屏幕宽度（按此顺序）。
</p>
</dd>
<dt><code>insert-completions (M-*)</code>
<a name="index-insert_002dcompletions-_0028M_002d_002a_0029"></a>
</dt>
<dd><p>在将要生成的点之前插入所有文本补全<code>possible-completions</code> 。
</p>
</dd>
<dt><code>menu-complete ()</code>
<a name="index-menu_002dcomplete-_0028_0029"></a>
</dt>
<dd><p>相似<code>complete</code> ，但用可能补全列表中的单个匹配替换要补全的单词。重复执行<code>menu-complete</code>逐步浏览可能的补全列表，依次插入每个匹配项。在完成列表的末尾，钟声响起（取决于设置<code>bell-style</code> ），然后恢复原始文本。的论点<var>n</var>动作<var>n</var>在比赛名单中的前锋位置；否定参数可用于在列表中向后移动。该命令旨在绑定到<tt class="key">TAB</tt> ，但默认情况下未绑定。
</p>
</dd>
<dt><code>menu-complete-backward ()</code>
<a name="index-menu_002dcomplete_002dbackward-_0028_0029"></a>
</dt>
<dd><p>相同<code>menu-complete</code> ，但在可能完成的列表中向后移动，就像<code>menu-complete</code>被否定了。
</p>
</dd>
<dt><code>delete-char-or-list ()</code>
<a name="index-delete_002dchar_002dor_002dlist-_0028_0029"></a>
</dt>
<dd><p>如果不在行首或行尾，则删除光标下方的字符（例如<code>delete-char</code> ）。如果在行尾，则行为与<code>possible-completions</code> 。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>complete-filename (M-/)</code>
<a name="index-complete_002dfilename-_0028M_002d_002f_0029"></a>
</dt>
<dd><p>尝试在点之前的文本上完成文件名。
</p>
</dd>
<dt><code>possible-filename-completions (C-x /)</code>
<a name="index-possible_002dfilename_002dcompletions-_0028C_002dx-_002f_0029"></a>
</dt>
<dd><p>在要点之前列出可能的文本补全，将其视为文件名。
</p>
</dd>
<dt><code>complete-username (M-~)</code>
<a name="index-complete_002dusername-_0028M_002d_007e_0029"></a>
</dt>
<dd><p>尝试在文本之前完成输入，将其视为用户名。
</p>
</dd>
<dt><code>possible-username-completions (C-x ~)</code>
<a name="index-possible_002dusername_002dcompletions-_0028C_002dx-_007e_0029"></a>
</dt>
<dd><p>在要点之前列出可能的文本补全，将其视为用户名。
</p>
</dd>
<dt><code>complete-variable (M-$)</code>
<a name="index-complete_002dvariable-_0028M_002d_0024_0029"></a>
</dt>
<dd><p>尝试在point之前的文本上完成操作，将其视为shell变量。
</p>
</dd>
<dt><code>possible-variable-completions (C-x $)</code>
<a name="index-possible_002dvariable_002dcompletions-_0028C_002dx-_0024_0029"></a>
</dt>
<dd><p>在要点之前列出文本的可能补全内容，将其视为shell变量。
</p>
</dd>
<dt><code>complete-hostname (M-@)</code>
<a name="index-complete_002dhostname-_0028M_002d_0040_0029"></a>
</dt>
<dd><p>尝试在文本之前完成输入，将其视为主机名。
</p>
</dd>
<dt><code>possible-hostname-completions (C-x @)</code>
<a name="index-possible_002dhostname_002dcompletions-_0028C_002dx-_0040_0029"></a>
</dt>
<dd><p>在要点之前列出文本的可能补全内容，将其视为主机名。
</p>
</dd>
<dt><code>complete-command (M-!)</code>
<a name="index-complete_002dcommand-_0028M_002d_0021_0029"></a>
</dt>
<dd><p>尝试在指向点之前的文本上完成操作，将其视为命令名称。命令完成尝试按该顺序将文本与别名，保留字，shell函数，shell内置文件以及最终的可执行文件名进行匹配。
</p>
</dd>
<dt><code>possible-command-completions (C-x !)</code>
<a name="index-possible_002dcommand_002dcompletions-_0028C_002dx-_0021_0029"></a>
</dt>
<dd><p>在要点之前列出可能的文本补全，将其视为命令名称。
</p>
</dd>
<dt><code>dynamic-complete-history (M-<span class="key">TAB</span>)</code>
<a name="index-dynamic_002dcomplete_002dhistory-_0028M_002dTAB_0029"></a>
</dt>
<dd><p>尝试对之前的文本进行补全，将文本与历史记录列表中的行进行比较以查找可能的补全匹配项。
</p>
</dd>
<dt><code>dabbrev-expand ()</code>
<a name="index-dabbrev_002dexpand-_0028_0029"></a>
</dt>
<dd><p>尝试在点之前的文本上完成菜单，将文本与历史列表中的行进行比较，以查找可能的完成匹配项。
</p>
</dd>
<dt><code>complete-into-braces (M-{)</code>
<a name="index-complete_002dinto_002dbraces-_0028M_002d_007b_0029"></a>
</dt>
<dd><p>执行文件名补全并插入花括号中的可能补全列表，以便该列表可用于外壳程序（请参阅<a href="#Brace-Expansion">Brace Expansion</a> ）。
</p>
</dd>
</dl>

<hr>
<a name="Keyboard-Macros"></a>
<div class="header">
<p>下一篇： <a href="#Miscellaneous-Commands" rel="next" accesskey="n">杂项命令</a> ，上一篇： <a href="#Commands-For-Completion" rel="prev" accesskey="p">完成</a> <a href="#Miscellaneous-Commands" rel="next" accesskey="n">命令</a> ，上一篇： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Keyboard-Macros-1"></a>
<h4 class="subsection">8.4.7键盘宏</h4>
<dl compact>
<dt><code>start-kbd-macro (C-x ()</code>
<a name="index-start_002dkbd_002dmacro-_0028C_002dx-_0028_0029"></a>
</dt>
<dd><p>开始保存键入到当前键盘宏中的字符。
</p>
</dd>
<dt><code>end-kbd-macro (C-x ))</code>
<a name="index-end_002dkbd_002dmacro-_0028C_002dx-_0029_0029"></a>
</dt>
<dd><p>停止保存键入到当前键盘宏中的字符并保存定义。
</p>
</dd>
<dt><code>call-last-kbd-macro (C-x e)</code>
<a name="index-call_002dlast_002dkbd_002dmacro-_0028C_002dx-e_0029"></a>
</dt>
<dd><p>通过使宏中的字符看起来像在键盘上键入一样，重新执行最后定义的键盘宏。
</p>
</dd>
<dt><code>print-last-kbd-macro ()</code>
<a name="index-print_002dlast_002dkbd_002dmacro-_0028_0029"></a>
</dt>
<dd><p>以适合以下格式的格式打印最后定义的keboard宏<var>inputrc</var>文件。
</p>
</dd>
</dl>

<hr>
<a name="Miscellaneous-Commands"></a>
<div class="header">
<p>上<a href="#Bindable-Readline-Commands" rel="up" accesskey="u">一篇</a> ： <a href="#Keyboard-Macros" rel="prev" accesskey="p">键盘宏</a> ，上<a href="#Bindable-Readline-Commands" rel="up" accesskey="u">一篇</a> ： <a href="#Bindable-Readline-Commands" rel="up" accesskey="u">可绑定的Readline命令</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Some-Miscellaneous-Commands"></a>
<h4 class="subsection">8.4.8一些其他命令</h4>
<dl compact>
<dt><code>re-read-init-file (C-x C-r)</code>
<a name="index-re_002dread_002dinit_002dfile-_0028C_002dx-C_002dr_0029"></a>
</dt>
<dd><p>阅读内容<var>inputrc</var>文件，并合并在那里找到的所有绑定或变量分配。
</p>
</dd>
<dt><code>abort (C-g)</code>
<a name="index-abort-_0028C_002dg_0029"></a>
</dt>
<dd><p>中止当前的编辑命令并按终端的铃声（取决于<code>bell-style</code> ）。
</p>
</dd>
<dt><code>do-lowercase-version (M-A, M-B, M-<var>x</var>, …)</code>
<a name="index-do_002dlowercase_002dversion-_0028M_002dA_002c-M_002dB_002c-M_002dx_002c-_2026_0029"></a>
</dt>
<dd><p>如果变相人物<var>x</var>如果是大写字母，请运行绑定到相应的元化小写字母的命令。如果以下行为未定义<var>x</var>已经是小写了。
</p>
</dd>
<dt><code>prefix-meta (<span class="key">ESC</span>)</code>
<a name="index-prefix_002dmeta-_0028ESC_0029"></a>
</dt>
<dd><p>Metafy下一个键入的字符。这适用于没有元键的键盘。输入' <samp><span class="key">ESC</span> f</samp> '相当于打字<kbd>M-f</kbd> 。
</p>
</dd>
<dt><code>undo (C-_ or C-x C-u)</code>
<a name="index-undo-_0028C_002d_005f-or-C_002dx-C_002du_0029"></a>
</dt>
<dd><p>增量撤消，每行分别记住。
</p>
</dd>
<dt><code>revert-line (M-r)</code>
<a name="index-revert_002dline-_0028M_002dr_0029"></a>
</dt>
<dd><p>撤消对此行所做的所有更改。这就像执行<code>undo</code>命令足够的时间回到起点。
</p>
</dd>
<dt><code>tilde-expand (M-&)</code>
<a name="index-tilde_002dexpand-_0028M_002d_0026_0029"></a>
</dt>
<dd><p>对当前单词执行波浪号扩展。
</p>
</dd>
<dt><code>set-mark (C-@)</code>
<a name="index-set_002dmark-_0028C_002d_0040_0029"></a>
</dt>
<dd><p>将标记设置到该点。如果提供了数字参数，则将标记设置到该位置。
</p>
</dd>
<dt><code>exchange-point-and-mark (C-x C-x)</code>
<a name="index-exchange_002dpoint_002dand_002dmark-_0028C_002dx-C_002dx_0029"></a>
</dt>
<dd><p>用标记交换点。当前光标位置设置为保存位置，旧光标位置保存为标记。
</p>
</dd>
<dt><code>character-search (C-])</code>
<a name="index-character_002dsearch-_0028C_002d_005d_0029"></a>
</dt>
<dd><p>读取一个字符并将点移动到该字符的下一个出现位置。负数搜索以前的事件。
</p>
</dd>
<dt><code>character-search-backward (M-C-])</code>
<a name="index-character_002dsearch_002dbackward-_0028M_002dC_002d_005d_0029"></a>
</dt>
<dd><p>读取一个字符并将点移动到该字符的上一个出现位置。负数搜索后续事件。
</p>
</dd>
<dt><code>skip-csi-sequence ()</code>
<a name="index-skip_002dcsi_002dsequence-_0028_0029"></a>
</dt>
<dd><p>读取足够的字符以使用多键序列，例如为诸如Home和End之类的键定义的序列。这样的序列以控制序列指示符（CSI）开始，通常为ESC- [。如果将此序列绑定到“ \ e [”，则除非明确将其绑定到readline命令，否则不要将杂散字符插入编辑缓冲区，否则生成此类序列的键将无效。默认情况下未绑定，但通常绑定到ESC- [。
</p>
</dd>
<dt><code>insert-comment (M-#)</code>
<a name="index-insert_002dcomment-_0028M_002d_0023_0029"></a>
</dt>
<dd><p>如果没有数字参数，则<code>comment-begin</code>变量插入到当前行的开头。如果提供了数字参数，则此命令将作为切换：如果行开头的字符与的值不匹配。 <code>comment-begin</code> ，则插入值，否则将插入字符<code>comment-begin</code>从该行的开头删除。在这两种情况下，都将接受该行，就像键入了换行符一样。的默认值<code>comment-begin</code>使该命令使当前行成为外壳程序注释。如果数字参数导致注释字符被删除，则该行将由Shell执行。
</p>
</dd>
<dt><code>dump-functions ()</code>
<a name="index-dump_002dfunctions-_0028_0029"></a>
</dt>
<dd><p>将所有功能及其键绑定打印到Readline输出流。如果提供了数字参数，则将输出格式化为可以将其作为<var>inputrc</var>文件。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>dump-variables ()</code>
<a name="index-dump_002dvariables-_0028_0029"></a>
</dt>
<dd><p>将所有可设置变量及其值打印到Readline输出流中。如果提供了数字参数，则将输出格式化为可以将其作为<var>inputrc</var>文件。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>dump-macros ()</code>
<a name="index-dump_002dmacros-_0028_0029"></a>
</dt>
<dd><p>打印所有绑定到宏的Readline键序列及其输出的字符串。如果提供了数字参数，则将输出格式化为可以将其作为<var>inputrc</var>文件。默认情况下，此命令是未绑定的。
</p>
</dd>
<dt><code>glob-complete-word (M-g)</code>
<a name="index-glob_002dcomplete_002dword-_0028M_002dg_0029"></a>
</dt>
<dd><p>point之前的单词被视为路径名扩展的模式，并在其后面隐含一个星号。此模式用于生成匹配文件名的列表，以完成可能的操作。
</p>
</dd>
<dt><code>glob-expand-word (C-x *)</code>
<a name="index-glob_002dexpand_002dword-_0028C_002dx-_002a_0029"></a>
</dt>
<dd><p>point之前的单词被视为路径名扩展的模式，并且插入了匹配文件名列表，以替换该单词。如果提供了数字参数，则' <samp>*</samp> '会在路径名扩展之前添加。
</p>
</dd>
<dt><code>glob-list-expansions (C-x g)</code>
<a name="index-glob_002dlist_002dexpansions-_0028C_002dx-g_0029"></a>
</dt>
<dd><p>由...生成的扩展列表<code>glob-expand-word</code>显示，然后重画线。如果提供了数字参数，则' <samp>*</samp> '会在路径名扩展之前添加。
</p>
</dd>
<dt><code>display-shell-version (C-x C-v)</code>
<a name="index-display_002dshell_002dversion-_0028C_002dx-C_002dv_0029"></a>
</dt>
<dd><p>显示有关当前Bash实例的版本信息。
</p>
</dd>
<dt><code>shell-expand-line (M-C-e)</code>
<a name="index-shell_002dexpand_002dline-_0028M_002dC_002de_0029"></a>
</dt>
<dd><p>像外壳一样展开线。这将执行别名和历史记录扩展以及所有shell单词扩展（请参阅<a href="#Shell-Expansions">Shell Expansions</a> ）。
</p>
</dd>
<dt><code>history-expand-line (M-^)</code>
<a name="index-history_002dexpand_002dline-_0028M_002d_005e_0029"></a>
</dt>
<dd><p>在当前行执行历史记录扩展。
</p>
</dd>
<dt><code>magic-space ()</code>
<a name="index-magic_002dspace-_0028_0029"></a>
</dt>
<dd><p>在当前行执行历史记录扩展，并插入一个空格（请参见<a href="#History-Interaction">History Interaction</a> ）。
</p>
</dd>
<dt><code>alias-expand-line ()</code>
<a name="index-alias_002dexpand_002dline-_0028_0029"></a>
</dt>
<dd><p>在当前行执行别名扩展（请参阅<a href="#Aliases">Aliases</a> ）。
</p>
</dd>
<dt><code>history-and-alias-expand-line ()</code>
<a name="index-history_002dand_002dalias_002dexpand_002dline-_0028_0029"></a>
</dt>
<dd><p>在当前行执行历史记录和别名扩展。
</p>
</dd>
<dt><code>insert-last-argument (M-. or M-_)</code>
<a name="index-insert_002dlast_002dargument-_0028M_002d_002e-or-M_002d_005f_0029"></a>
</dt>
<dd><p>的同义词<code>yank-last-arg</code> 。
</p>
</dd>
<dt><code>operate-and-get-next (C-o)</code>
<a name="index-operate_002dand_002dget_002dnext-_0028C_002do_0029"></a>
</dt>
<dd><p>接受要执行的当前行，并从历史记录中获取相对于当前行的下一行以进行编辑。如果提供了数字参数，则指定要使用的历史记录条目而不是当前行。
</p>
</dd>
<dt><code>edit-and-execute-command (C-x C-e)</code>
<a name="index-edit_002dand_002dexecute_002dcommand-_0028C_002dx-C_002de_0029"></a>
</dt>
<dd><p>在当前命令行上调用编辑器，然后将结果作为shell命令执行。Bash尝试调用<code>$VISUAL</code> ， <code>$EDITOR</code>和<code>emacs</code>作为编辑，按此顺序。
</p>


</dd>
</dl>

<hr>
<a name="Readline-vi-Mode"></a>
<div class="header">
<p>下一篇： <a href="#Programmable-Completion" rel="next" accesskey="n">可编程完成</a> ，上一篇： <a href="#Bindable-Readline-Commands" rel="prev" accesskey="p">可绑定的Readline命令</a> ，上一篇： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Readline-vi-Mode-1"></a>
<h3 class="section">8.5 Readline vi模式</h3>

<p>虽然Readline库没有全套的<code>vi</code>编辑功能，它确实包含足以允许对行进行简单编辑的功能。阅读热线<code>vi</code>模式的行为与<small>POSIX</small>标准中指定的相同。
</p>
<p>为了在之间进行交互切换<code>emacs</code>和<code>vi</code>编辑模式，请使用' <samp>set -o emacs</samp> '和' <samp>set -o vi</samp> '命令（请参阅<a href="#The-Set-Builtin">内置集合</a> ）。Readline的默认值为<code>emacs</code>模式。
</p>
<p>当您输入一行<code>vi</code>模式，您已经处于“插入”模式，就像您键入了“ <samp>i</samp> '。按下<tt class="key">ESC</tt>键可将您切换到“命令”模式，在此模式下，您可以使用标准<code>vi</code>移动键，使用“ <samp>k</samp> ”以及后面带有“ <samp>j</samp>等等。
</p>
<hr>
<a name="Programmable-Completion"></a>
<div class="header">
<p>下一篇： <a href="#Programmable-Completion-Builtins" rel="next" accesskey="n">可编程补全内置函数</a> ，上一篇： <a href="#Readline-vi-Mode" rel="prev" accesskey="p">Readline vi模式</a> ，上一篇： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Programmable-Completion-1"></a>
<h3 class="section">8.6可编程完成</h3>
<a name="index-programmable-completion"></a>

<p>当尝试对命令的自变量进行单词补全时，需为其指定补全规范（ <var>compspec</var> ）已使用<code>complete</code>内置（请参见<a href="#Programmable-Completion-Builtins">Programmable Completion Builtins</a> ），将调用可编程完成功能。
</p>
<p>首先，确定命令名称。如果已为该命令定义了compspec，则使用compspec来生成该单词可能的补全列表。如果命令字为空字符串（尝试在空行的开头完成），则使用<samp>-E</samp>选择<code>complete</code>用来。如果命令字是完整路径名，则首先搜索完整路径名的compspec。如果找不到完整路径名的compspec，则尝试为最后斜杠后的部分找到compspec。如果这些搜索未产生compspec，则使用<samp>-D</samp>选择<code>complete</code>用作默认值。如果没有默认的compspec，则Bash会尝试对命令字进行别名扩展作为最终手段，并尝试从任何成功的扩展中查找命令字的compspec</p>
<p>找到compspec后，将使用它生成匹配单词的列表。如果未找到compspec，则执行上述默认的Bash <a href="#Commands-For-Completion">补全</a> （请参阅<a href="#Commands-For-Completion">“完成命令”</a> ）。
</p>
<p>首先，使用compspec指定的动作。仅返回以完成的单词为前缀的匹配。当。。。的时候<samp>-f</samp>要么<samp>-d</samp>选项用于文件名或目录名的完成，shell变量<code>FIGNORE</code>用于过滤匹配项。有关<a href="#Bash-Variables">Bash变量</a>的说明，请参见<a href="#Bash-Variables">Bash变量</a> 。 <code>FIGNORE</code> 。
</p>
<p>由文件名扩展模式指定的所有补全<samp>-G</samp>接下来生成选项。模式生成的单词不必与要完成的单词匹配。的<code>GLOBIGNORE</code> shell变量不用于过滤匹配项，但是<code>FIGNORE</code>使用shell变量。
</p>
<p>接下来，将字符串指定为<samp>-W</samp>选项被考虑。首先使用<code>IFS</code>特殊变量作为分隔符。字符串中应使用引号引起来，以提供一种机制，使单词包含值中的壳元字符或字符<code>IFS</code> 。然后，使用大括号扩展，代字号扩展，参数和变量扩展，命令替换以及算术扩展来扩展每个单词，如上所述（请参见<a href="#Shell-Expansions">Shell Expansions</a> ）。使用上述规则对结果进行拆分（请参见<a href="#Word-Splitting">单词拆分</a> ）。扩展的结果与要完成的单词进行前缀匹配，匹配的单词成为可能的完成。
</p>
<p>生成这些匹配项后，使用<samp>-F</samp>和<samp>-C</samp>选项被调用。调用命令或函数时， <code>COMP_LINE</code> ， <code>COMP_POINT</code> ， <code>COMP_KEY</code>和<code>COMP_TYPE</code>如上所述，为变量分配值（请参阅<a href="#Bash-Variables">Bash变量</a> ）。如果正在调用Shell函数，则<code>COMP_WORDS</code>和<code>COMP_CWORD</code>变量也被设置。调用函数或命令时，第一个参数（$ 1）是要完成其参数的命令的名称，第二个参数（$ 2）是要完成的单词，第三个参数（$ 3）是该参数之前的单词在当前命令行上完成的单词。不针对完成的单词对生成的完成进行过滤；函数或命令在生成匹配项方面具有完全的自由度。
</p>
<p>任何指定的功能<samp>-F</samp>首先被调用。该功能可以使用任何外壳程序设施，包括<code>compgen</code>和<code>compopt</code>如下所述的<a href="#Programmable-Completion-Builtins">buildins</a> （请参阅<a href="#Programmable-Completion-Builtins">Programmable Completion Builtins</a> ），以生成匹配项。它必须将可能的补全放在<code>COMPREPLY</code>数组变量，每个数组元素一个。
</p>
<p>接下来，使用<samp>-C</samp> option在等效于命令替换的环境中调用。它应该将完成的列表（每行一个）打印到标准输出。如有必要，可以使用反斜杠转义换行符。
</p>
<p>生成所有可能的完成信息后，使用<samp>-X</samp>选项将应用于列表。过滤器是用于路径名扩展的模式。一种 ' <samp>&</samp>模式中的'替换为要完成的单词的文本。文字' <samp>&</samp> '可以用反斜杠转义；尝试进行匹配之前，请删除反斜杠。任何与模式匹配的补全将从列表中删除。领先的<samp>!</samp> '否定了模式；在这种情况下，任何与模式不匹配的补全将被删除。如果<code>nocasematch</code> shell选项（请参阅<code>shopt</code> <a href="#The-Shopt-Builtin">如果启用了“内置商店”</a> ），则匹配时将不考虑字母字符的大小写。
</p>
<p>最后，使用<samp>-P</samp>和<samp>-S</samp>选项会添加到完成列表的每个成员，结果会作为可能的完成列表返回到Readline完成代码。
</p>
<p>如果先前应用的操作未生成任何匹配项，则<samp>-o dirnames</samp>选项已提供给<code>complete</code>定义compspec时，将尝试完成目录名称。
</p>
<p>如果<samp>-o plusdirs</samp>选项已提供给<code>complete</code>定义compspec时，将尝试完成目录名称，并将所有匹配项添加到其他操作的结果中。
</p>
<p>默认情况下，如果找到compspec，则它将生成的所有内容作为完整的可能补全集返回到补全代码。不尝试默认的Bash补全，并且Readline默认的文件名补全被禁用。如果<samp>-o bashdefault</samp>选项已提供给<code>complete</code>定义compspec时，如果compspec不生成匹配项，则尝试默认的Bash完成。如果<samp>-o default</samp>选项已提供给<code>complete</code>定义compspec时，如果compspec（以及尝试的默认Bash完成）未生成匹配项，则将执行Readline的默认完成。
</p>
<p>当compspec指示需要完成目录名称时，可编程完成功能会强制Readline在已完成的名称后附加一个斜杠，这些名称是指向目录的符号链接，但要取决于目录的值。 <var>mark-directories</var> Readline变量，无论设置为<var>mark-symlinked-directories</var> Readline变量。
</p>
<p>有一些支持动态修改补全。与结合使用指定的默认完成一起使用时，此功能最有用<samp>-D</samp> 。作为完成处理程序执行的shell函数有可能指示应通过返回退出状态124来重试完成。如果shell函数返回124，并更改与尝试执行补全的命令相关的compspec（执行该函数时作为第一个参数提供），则可编程补全将从头重新启动，并尝试为该补全查找新的compspec。该命令。这允许在尝试完成时动态构建一组完成，而不是一次全部加载。
</p>
<p>例如，假设有一个compspec库，每个库都保存在与命令名称相对应的文件中，则以下默认完成功能将动态加载完成：</p>
<div class="example">
<pre class="example">_completion_loader()
{
    . &quot;/etc/bash_completion.d/$1.sh&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; return 124
}
complete -D -F _completion_loader -o bashdefault -o default
</pre></div>

<hr>
<a name="Programmable-Completion-Builtins"></a>
<div class="header">
<p>下一个： <a href="#A-Programmable-Completion-Example" rel="next" accesskey="n">可编程完成示例</a> ，上一个： <a href="#Programmable-Completion" rel="prev" accesskey="p">可编程完成</a> ，上： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Programmable-Completion-Builtins-1"></a>
<h3 class="section">8.7可编程完成内置函数</h3>
<a name="index-completion-builtins"></a>

<p>可使用三种内置命令来操作可编程完成功能：一种用于指定如何完成特定命令的参数，另一种用于在完成时修改完成。
</p>
<dl compact>
<dt><code>compgen</code></dt>
<dd><a name="index-compgen"></a>
<div class="example">
<pre class="example"><code>compgen [<var>option</var>] [<var>word</var>]</code>
</pre></div>

<p>为生成可能的完成匹配<var>word</var>根据<var>option</var> s，它可以是<code>complete</code>内置的，除了<samp>-p</samp>和<samp>-r</samp> ，并将匹配项写入标准输出。使用时<samp>-F</samp>要么<samp>-C</samp>选项，由可编程完成工具设置的各种shell变量（如果可用）将没有有用的值。
</p>
<p>将以与可编程完成代码直接从具有相同标志的完成规范中生成它们的方式相同的方式生成匹配项。如果<var>word</var>被指定，只有那些匹配的补全<var>word</var>将显示。
</p>
<p>除非提供了无效的选项，否则未返回任何匹配项，则返回值为true。
</p>
</dd>
<dt><code>complete</code></dt>
<dd><a name="index-complete"></a>
<div class="example">
<pre class="example"><code>complete [-abcdefgjksuv] [-o <var>comp-option</var>] [-DEI] [-A <var>action</var>] [-G <var>globpat</var>]
[-W <var>wordlist</var>] [-F <var>function</var>] [-C <var>command</var>] [-X <var>filterpat</var>]
[-P <var>prefix</var>] [-S <var>suffix</var>] <var>name</var> [<var>name</var> &hellip;]</code>
<code>complete -pr [-DEI] [<var>name</var> &hellip;]</code>
</pre></div>

<p>指定每个参数的方式<var>name</var>应该完成。如果<samp>-p</samp>选项已提供，或者如果未提供任何选项，则会以允许它们重新用作输入的方式打印现有的完成规范。的<samp>-r</samp>选项删除每个的完成规范<var>name</var> ，或者，如果没有<var>name</var>提供了所有完成规格。的<samp>-D</samp>选项指示其他提供的选项和操作应应用于“默认”命令完成；也就是说，尝试对先前未定义完成的命令尝试完成。的<samp>-E</samp> option指示其他提供的选项和操作应适用于“空”命令完成；也就是说，尝试在空白行上完成。的<samp>-I</samp> option指示其他提供的选项和操作应适用于该行上的初始非分配字，或在诸如“' <samp>;</samp> ' 要么 ' <samp>|</samp> '，通常是命令名称完成。如果提供了多个选项，则<samp>-D</samp>选项优先<samp>-E</samp> ，并且都优先于<samp>-I</samp> 。如果有<samp>-D</samp> ， <samp>-E</samp> ， 要么<samp>-I</samp>提供，任何其他<var>name</var>参数被忽略；这些完成仅适用于该选项指定的情况。
</p>
<p>上面描述了尝试单词<a href="#Programmable-Completion">补全</a>时应用这些<a href="#Programmable-Completion">补全</a>规范的过程（请参阅<a href="#Programmable-Completion">可编程补全</a> ）。
</p>
<p>其他选项（如果指定）具有以下含义。的论点<samp>-G</samp> ， <samp>-W</samp>和<samp>-X</samp>选项（必要时还有<samp>-P</samp>和<samp>-S</samp>选项），以防止它们在扩展之前被引用<code>complete</code>内置调用。
</p>

<dl compact>
<dt><code>-o <var>comp-option</var></code></dt>
<dd><p>的<var>comp-option</var>除了完成的简单生成之外，还控制compspec行为的几个方面。
<var>comp-option</var>可能是以下之一：</p>
<dl compact>
<dt><code>bashdefault</code></dt>
<dd><p>如果compspec没有生成匹配项，则执行其余的默认Bash补全。
</p>
</dd>
<dt><code>default</code></dt>
<dd><p>如果compspec没有生成匹配项，请使用Readline的默认文件名补全。
</p>
</dd>
<dt><code>dirnames</code></dt>
<dd><p>如果compspec没有生成匹配项，请执行目录名称完成。
</p>
</dd>
<dt><code>filenames</code></dt>
<dd><p>告诉Readline compspec会生成文件名，因此它可以执行任何文件名特定的处理（例如，在目录名称中添加斜杠，引用特殊字符或取消尾部空格）。此选项旨在与通过以下方式指定的shell函数一起使用<samp>-F</samp> 。
</p>
</dd>
<dt><code>noquote</code></dt>
<dd><p>告诉Readline如果文件名是完整的单词，则不要引用它们（默认情况下，引用文件名）。
</p>
</dd>
<dt><code>nosort</code></dt>
<dd><p>告诉Readline不要按字母顺序对可能完成的列表进行排序。
</p>
</dd>
<dt><code>nospace</code></dt>
<dd><p>告诉Readline不要在行尾完成的单词后面添加空格（默认值）。
</p>
</dd>
<dt><code>plusdirs</code></dt>
<dd><p>生成compspec定义的任何匹配项后，将尝试完成目录名称，并将所有匹配项添加到其他操作的结果中。
</p>
</dd>
</dl>

</dd>
<dt><code>-A <var>action</var></code></dt>
<dd><p>的<var>action</var>可能是生成可能完成的列表的以下之一：</p>
<dl compact>
<dt><code>alias</code></dt>
<dd><p>别名。也可以指定为<samp>-a</samp> 。
</p>
</dd>
<dt><code>arrayvar</code></dt>
<dd><p>数组变量名称。
</p>
</dd>
<dt><code>binding</code></dt>
<dd><p>Readline键绑定名称（请参阅<a href="#Bindable-Readline-Commands">Bindable Readline Commands</a> ）。
</p>
</dd>
<dt><code>builtin</code></dt>
<dd><p>Shell内置命令的名称。也可以指定为<samp>-b</samp> 。
</p>
</dd>
<dt><code>command</code></dt>
<dd><p>命令名称。也可以指定为<samp>-c</samp> 。
</p>
</dd>
<dt><code>directory</code></dt>
<dd><p>目录名称。也可以指定为<samp>-d</samp> 。
</p>
</dd>
<dt><code>disabled</code></dt>
<dd><p>禁用的shell内置程序的名称。
</p>
</dd>
<dt><code>enabled</code></dt>
<dd><p>启用的shell内置程序的名称。
</p>
</dd>
<dt><code>export</code></dt>
<dd><p>导出的外壳变量的名称。也可以指定为<samp>-e</samp> 。
</p>
</dd>
<dt><code>file</code></dt>
<dd><p>文件名也可以指定为<samp>-f</samp> 。
</p>
</dd>
<dt><code>function</code></dt>
<dd><p>Shell函数的名称。
</p>
</dd>
<dt><code>group</code></dt>
<dd><p>组名。也可以指定为<samp>-g</samp> 。
</p>
</dd>
<dt><code>helptopic</code></dt>
<dd><p>接受的帮助主题<code>help</code>内置（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。
</p>
</dd>
<dt><code>hostname</code></dt>
<dd><p>主机名，取自<code>HOSTFILE</code> shell变量（请参阅<a href="#Bash-Variables">Bash变量</a> ）。
</p>
</dd>
<dt><code>job</code></dt>
<dd><p>作业名称，如果作业控制处于活动状态。也可以指定为<samp>-j</samp> 。
</p>
</dd>
<dt><code>keyword</code></dt>
<dd><p>外壳保留字。也可以指定为<samp>-k</samp> 。
</p>
</dd>
<dt><code>running</code></dt>
<dd><p>正在运行的作业的名称（如果作业控制处于活动状态）。
</p>
</dd>
<dt><code>service</code></dt>
<dd><p>服务名称。也可以指定为<samp>-s</samp> 。
</p>
</dd>
<dt><code>setopt</code></dt>
<dd><p>的有效参数<samp>-o</samp>选项<code>set</code>内置（请参阅<a href="#The-Set-Builtin">《内置集》</a> ）。
</p>
</dd>
<dt><code>shopt</code></dt>
<dd><p>Shell选项名称，由<code>shopt</code>内置（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。
</p>
</dd>
<dt><code>signal</code></dt>
<dd><p>信号名称。
</p>
</dd>
<dt><code>stopped</code></dt>
<dd><p>如果作业控制处于活动状态，则停止的作业的名称。
</p>
</dd>
<dt><code>user</code></dt>
<dd><p>用户名。也可以指定为<samp>-u</samp> 。
</p>
</dd>
<dt><code>variable</code></dt>
<dd><p>所有shell变量的名称。也可以指定为<samp>-v</samp> 。
</p></dd>
</dl>

</dd>
<dt><code>-C <var>command</var></code></dt>
<dd><p><var>command</var>在subshell环境中执行，并且其输出用作可能的完成。
</p>
</dd>
<dt><code>-F <var>function</var></code></dt>
<dd><p>外壳功能<var>function</var>在当前的shell环境中执行。执行该命令时，如上所述，$ 1是其参数已完成的命令的名称，$ 2是正在完成的单词，而$ 3是正在完成的单词之前的单词（请参见<a href="#Programmable-Completion">Programmable Completion</a> ）。完成时，将从的值中检索可能的完成。 <code>COMPREPLY</code>数组变量。
</p>
</dd>
<dt><code>-G <var>globpat</var></code></dt>
<dd><p>文件名扩展模式<var>globpat</var>被扩展以生成可能的完成。
</p>
</dd>
<dt><code>-P <var>prefix</var></code></dt>
<dd><p><var>prefix</var>在应用所有其他选项之后，将在每个可能完成的开始处添加。
</p>
</dd>
<dt><code>-S <var>suffix</var></code></dt>
<dd><p><var>suffix</var>在应用了所有其他选项之后，会将追加到每个可能的完成。
</p>
</dd>
<dt><code>-W <var>wordlist</var></code></dt>
<dd><p>的<var>wordlist</var>使用中的字符分割<code>IFS</code>特殊变量作为定界符，并且每个结果词都会扩展。可能的补全是结果列表中与要补全单词匹配的成员。
</p>
</dd>
<dt><code>-X <var>filterpat</var></code></dt>
<dd><p><var>filterpat</var>是用于文件名扩展的模式。它应用于由前面的选项和参数生成的可能完成的列表，并且每个完成都匹配<var>filterpat</var>从列表中删除。领先的<samp>!</samp>在<var>filterpat</var>否定模式；在这种情况下，任何不匹配的补全<var>filterpat</var>已移除。
</p></dd>
</dl>

<p>除非提供了无效的选项，否则返回值是true。 <samp>-p</samp>要么<samp>-r</samp>提供不带<var>name</var>参数，尝试删除一个<var>name</var>其不存在任何规范，或者添加完成规范会发生错误。
</p>
</dd>
<dt><code>compopt</code></dt>
<dd><a name="index-compopt"></a>
<div class="example">
<pre class="example"><code>compopt</code> [-o <var>option</var>] [-DEI] [+o <var>option</var>] [<var>name</var>]
</pre></div>
<p>修改每个的完成选项<var>name</var>根据<var>option</var> s，如果没有，则为当前正在执行的完成<var>name</var>提供了。如果不<var>option</var>给出，显示每个的完成选项<var>name</var>或当前完成。的可能值<var>option</var>是那些对<code>complete</code>内置上述。的<samp>-D</samp>选项指示其他提供的选项应应用于“默认”命令完成；也就是说，尝试对先前未定义完成的命令尝试完成。的<samp>-E</samp> option指示其他提供的选项应适用于“空”命令完成；也就是说，尝试在空白行上完成。的<samp>-I</samp> option指示其他提供的选项应适用于该行上的初始非赋值字的补全，或在诸如“ <samp>;</samp> ' 要么 ' <samp>|</samp> '，通常是命令名称完成。
</p>
<p>如果提供了多个选项，则<samp>-D</samp>选项优先<samp>-E</samp> ，并且都优先于<samp>-I</samp>
</p>
<p>除非提供了无效的选项，否则返回值是true，否则将尝试为以下选项修改选项： <var>name</var>其不存在完成规范，或发生输出错误。
</p>
</dd>
</dl>

<hr>
<a name="A-Programmable-Completion-Example"></a>
<div class="header">
<p>上<a href="#Programmable-Completion-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Programmable-Completion-Builtins" rel="prev" accesskey="p">内置可编程补全</a> ，上<a href="#Programmable-Completion-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Command-Line-Editing" rel="up" accesskey="u">命令行编辑</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="A-Programmable-Completion-Example-1"></a>
<h3 class="section">8.8可编程完成示例</h3>

<p>获取默认操作以外的其他完成功能的最常用方法<code>complete</code>和<code>compgen</code>提供是使用shell函数，并使用以下命令将其绑定到特定命令<code>complete -F</code> 。
</p>
<p>以下功能提供了<code>cd</code>内置的。这是一个很好的例子，说明了shell函数在完成使用时必须做什么。此函数使用传递为<code>$2</code>确定要完成的目录名称。您也可以使用<code>COMP_WORDS</code>数组变量当前单词由索引<code>COMP_CWORD</code>变量。
</p>
<p>该功能依赖于<code>complete</code>和<code>compgen</code>内置程序可以完成很多工作，仅添加Bash <code>cd</code>不仅接受基本目录名称：波浪号扩展（请参阅<a href="#Tilde-Expansion">Tilde Expansion</a> ），在以下位置搜索目录<var>$CDPATH</var> ，如上文所述（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ），以及对<code>cdable_vars</code> shell选项（请参阅<a href="#The-Shopt-Builtin">内置Shopt</a> ）。
<code>_comp_cd</code>修改的值<var>IFS</var>因此它仅包含换行符以容纳包含空格和制表符的文件名– <code>compgen</code>打印每行生成一个可能的补全。
</p>
<p>可能的完成工作进入<var>COMPREPLY</var>数组变量，每个数组元素一个完成。当函数返回时，可编程完成系统从那里检索完成。
</p>
<div class="example">
<pre class="example"># A completion function for the cd builtin
# based on the cd completion function from the bash_completion package
_comp_cd()
{
    local IFS=$' \t\n'    # normalize IFS
    local cur _skipdot _cdpath
    local i j k

    # Tilde expansion, which also expands tilde to full pathname
    case &quot;$2&quot; in
    \~*)    eval cur=&quot;$2&quot; ;;
    *)      cur=$2 ;;
    esac

    # no cdpath or absolute pathname -- straight directory completion
    if [[ -z &quot;${CDPATH:-}&quot; ]] || [[ &quot;$cur&quot; == @(./*|../*|/*) ]]; then
        # compgen prints paths one per line; could also use while loop
        IFS=$'\n'
        COMPREPLY=( $(compgen -d -- &quot;$cur&quot;) )
        IFS=$' \t\n'
    # CDPATH+directories in the current directory if not in CDPATH
    else
        IFS=$'\n'
        _skipdot=false
        # preprocess CDPATH to convert null directory names to .
        _cdpath=${CDPATH/#:/.:}
        _cdpath=${_cdpath//::/:.:}
        _cdpath=${_cdpath/%:/:.}
        for i in ${_cdpath//:/$'\n'}; do
            if [[ $i -ef . ]]; then _skipdot=true; fi
            k=&quot;${#COMPREPLY[@]}&quot;
            for j in $( compgen -d -- &quot;$i/$cur&quot; ); do
                COMPREPLY[k++]=${j#$i/}        # cut off directory
            done
        done
        $_skipdot || COMPREPLY+=( $(compgen -d -- &quot;$cur&quot;) )
        IFS=$' \t\n'
    fi

    # variable names if appropriate shell option set and no completions
    if shopt -q cdable_vars &amp;&amp; [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        COMPREPLY=( $(compgen -v -- &quot;$cur&quot;) )
    fi

    return 0
}
</pre></div>

<p>我们使用以下命令安装完成功能<samp>-F</samp>选择<code>complete</code> ：</p>
<div class="example">
<pre class="example"># Tell readline to quote appropriate and append slashes to directories;
# use the bash default completion for other arguments
complete -o filenames -o nospace -o bashdefault -F _comp_cd cd
</pre></div>

<p>由于我们希望Bash和Readline为我们处理其他一些细节，因此我们使用其他几个选项来告诉Bash和Readline该做什么。的<samp>-o filenames</samp>选项告诉Readline应该将可能的补全视为文件名，并适当地加引号。该选项还将导致Readline在可以确定目录的文件名后加上斜杠（这就是我们可能要扩展的原因<code>_comp_cd</code>如果我们使用通过以下目录找到目录，则添加一个斜杠<var>CDPATH</var> ：Readline无法告诉您这些补全是目录）。的<samp>-o nospace</samp>选项告诉Readline不要在目录名称后添加空格字符，以防万一我们要在目录名称后添加空格。的<samp>-o bashdefault</samp>选项将引入其余的“ Bash默认”补全– Bash可能添加到默认Readline集的补全。其中包括命令名称完成，以'开头的单词的变量完成<samp>$</samp> ' 要么 ' <samp>${</samp> '，包含路径名扩展模式的补全（请参见<a href="#Filename-Expansion">Filename Expansion</a> ），等等。
</p>
<p>一旦安装使用<code>complete</code> ， <code>_comp_cd</code>每当我们尝试将单词补全为<code>cd</code>命令。
</p>
<p>作为bash_completion项目的一部分，还有更多示例-大部分常见的GNU，Unix和Linux命令的大量补全集。默认情况下，它已安装在许多GNU / Linux发行版中。该项目最初由Ian Macdonald撰写，现在位于<a href="https://github.com/scop/bash-completion/">https://github.com/scop/bash-completion/</a> 。有用于其他系统的端口，例如Solaris和Mac OSX。</p>
<p>bash_completion软件包的旧版本与bash一起分发在<samp>examples/complete</samp>子目录。
</p>
<a name="index-History_002c-how-to-use"></a>

<hr>
<a name="Using-History-Interactively"></a>
<div class="header">
<p>下一篇： <a href="#Installing-Bash" rel="next" accesskey="n">安装Bash</a> ，上一篇： <a href="#Command-Line-Editing" rel="prev" accesskey="p">命令行编辑</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-History-Interactively-1"></a>
<h2 class="chapter">9交互使用历史</h2>


<p>本章从用户的角度描述了如何交互使用<small>GNU</small>历史库。它应被视为用户指南。有关在其他程序中使用<small>GNU</small>历史库的信息，请参见《 <small>GNU</small> Readline库手册》。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Bash-History-Facilities" accesskey="1">Bash历史记录设施</a> ：</td><td>  </td><td align="left" valign="top">Bash如何让您操纵命令历史记录。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bash-History-Builtins" accesskey="2">Bash历史内建函数</a> ：</td><td>  </td><td align="left" valign="top">Bash内置命令可操纵命令历史记录。
</td></tr>
<tr><td align="left" valign="top">• <a href="#History-Interaction" accesskey="3">历史互动</a> ：</td><td>  </td><td align="left" valign="top">使用“历史记录”作为用户的感觉。
</td></tr>
</tbody></table>

<hr>
<a name="Bash-History-Facilities"></a>
<div class="header">
<p>下一页： <a href="#Bash-History-Builtins" rel="next" accesskey="n">Bash历史内置程序</a> ，上一篇： <a href="#Using-History-Interactively" rel="up" accesskey="u">交互使用历史</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-History-Facilities-1"></a>
<h3 class="section">9.1 Bash历史记录设施</h3>
<a name="index-command-history"></a>
<a name="index-history-list"></a>

<p>当。。。的时候<samp>-o history</samp>选项<code>set</code>启用了<a href="#The-Set-Builtin">内置</a> <em>命令</em> （请参阅<a href="#The-Set-Builtin">The Set Builtin</a> ），外壳程序提供对<em>命令历史记录</em> （先前键入的命令列表）的访问。的价值<code>HISTSIZE</code> shell变量用作要保存在历史记录列表中的命令数。最后的文字<code>$HISTSIZE</code>命令（默认为500）已保存。Shell在参数和变量扩展之前但在执行历史扩展之后，将每个命令存储在历史列表中，但要视Shell变量的值而定<code>HISTIGNORE</code>和<code>HISTCONTROL</code> 。
</p>
<p>当外壳启动时，历史记录将从由<code>HISTFILE</code>变量（默认<samp>~/.bash_history</samp> ）。由值命名的文件<code>HISTFILE</code>在必要时被截断，以包含的行数不超过<code>HISTFILESIZE</code>变量。当启用历史记录的shell退出时，最后一个<code>$HISTSIZE</code>行从历史记录列表复制到名称为的文件<code>$HISTFILE</code> 。如果<code>histappend</code>设置了shell选项（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ），这些<a href="#Bash-Builtins">行将</a>追加到历史文件中，否则历史文件将被覆盖。如果<code>HISTFILE</code>未设置，或者如果历史记录文件不可写，则不会保存历史记录。保存历史记录后，历史记录文件将被截断以包含不超过<code>$HISTFILESIZE</code>线。如果<code>HISTFILESIZE</code>如果未设置或将其设置为null，非数字值或小于零的数字值，则历史记录文件不会被截断。
</p>
<p>如果<code>HISTTIMEFORMAT</code>设置为时，将与每个历史记录条目关联的时间戳信息写入历史记录文件，并用历史记录注释字符标记。读取历史记录文件时，以历史记录注释字符开头的行以及紧随其后的数字将被解释为以下历史记录条目的时间戳。
</p>
<p>内置命令<code>fc</code>可用于列出或编辑并重新执行历史记录列表的一部分。的<code>history</code>内置可用于显示或修改历史记录列表以及操作历史记录文件。使用命令行编辑时，在每种编辑模式下都可以使用搜索命令，这些命令提供对历史记录列表的访问（请参阅<a href="#Commands-For-History">历史记录命令</a> ）。
</p>
<p>该外壳程序可以控制将哪些命令保存在历史记录列表中。的<code>HISTCONTROL</code>和<code>HISTIGNORE</code>可以设置变量以使外壳仅保存输入的命令的子集。的<code>cmdhist</code> shell选项（如果启用）使Shell尝试将多行命令的每一行保存在同一历史记录条目中，并在必要时添加分号以保持语法正确性。的<code>lithist</code> shell选项使Shell用嵌入式换行符而不是分号保存命令。的<code>shopt</code>内置用于设置这些选项。有关说明，请参见<a href="#The-Shopt-Builtin">内置商店</a> 。 <code>shopt</code> 。
</p>
<hr>
<a name="Bash-History-Builtins"></a>
<div class="header">
<p>下一篇： <a href="#History-Interaction" rel="next" accesskey="n">历史互动</a> ，上一篇： <a href="#Bash-History-Facilities" rel="prev" accesskey="p">Bash历史工具</a> ，上一篇： <a href="#History-Interaction" rel="next" accesskey="n">交互式</a> <a href="#Using-History-Interactively" rel="up" accesskey="u">使用历史</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Bash-History-Builtins-1"></a>
<h3 class="section">9.2 Bash历史内置</h3>
<a name="index-history-builtins"></a>

<p>Bash提供了两个内置命令来操纵历史记录列表和历史记录文件。
</p>
<dl compact>
<dt><code>fc</code></dt>
<dd><a name="index-fc"></a>
<div class="example">
<pre class="example"><code>fc [-e <var>ename</var>] [-lnr] [<var>first</var>] [<var>last</var>]</code>
<code>fc -s [<var>pat</var>=<var>rep</var>] [<var>command</var>]</code>
</pre></div>

<p>第一种形式从中选择一系列命令<var>first</var>至<var>last</var>从历史记录列表中显示并编辑并重新执行它们。都<var>first</var>和<var>last</var>可以指定为字符串（以查找以该字符串开头的最新命令）或数字（历史记录列表的索引，其中负数用作当前命令号的偏移量）。如果<var>last</var>未指定，设置为<var>first</var> 。如果<var>first</var>未指定，则设置为上一个命令进行编辑，设置为-16进行列表。如果<samp>-l</samp>给出标志，命令在标准输出上列出。的<samp>-n</samp>标志在列出时禁止显示命令编号。的<samp>-r</samp>标志颠倒列表的顺序。否则，由<var>ename</var>在包含这些命令的文件上调用。如果<var>ename</var>未给出，则使用以下变量扩展的值： <code>${FCEDIT:-${EDITOR:-vi}}</code> 。这表示要使用<code>FCEDIT</code>变量（如果已设置）或<code>EDITOR</code>变量（如果已设置），或者<code>vi</code>如果两者均未设置。编辑完成后，将回显并执行已编辑的命令。
</p>
<p>在第二种形式中<var>command</var>在每个实例之后重新执行<var>pat</var>在所选命令中被替换为<var>rep</var> 。
<var>command</var>被解释为与<var>first</var>以上。
</p>
<p>有用的别名<code>fc</code>命令是<code>r='fc -s'</code> ，这样输入“ <samp>r cc</samp> '以最后一个命令运行<code>cc</code>然后输入“ <samp>r</samp> '重新执行最后一条命令（请参见<a href="#Aliases">Aliases</a> ）。
</p>
</dd>
<dt><code>history</code></dt>
<dd><a name="index-history"></a>
<div class="example">
<pre class="example">history [<var>n</var>]
history -c
history -d <var>offset</var>
history -d <var>start</var>-<var>end</var>
history [-anrw] [<var>filename</var>]
history -ps <var>arg</var>
</pre></div>

<p>如果没有选项，则显示带有行号的历史记录列表。以'为前缀的行<samp>*</samp> '已被修改。的论点<var>n</var>只列出最后一个<var>n</var>线。如果shell变量<code>HISTTIMEFORMAT</code>设置且不为null，它用作以下格式的字符串<var>strftime</var>显示与每个显示的历史记录条目关联的时间戳。在格式化的时间戳和历史记录行之间不会打印任何空白。
</p>
<p>选件（如果提供）具有以下含义：</p>
<dl compact>
<dt><code>-c</code></dt>
<dd><p>清除历史记录列表。可以将其与其他选项组合以完全替换历史记录列表。
</p>
</dd>
<dt><code>-d <var>offset</var></code></dt>
<dd><p>删除位置上的历史记录条目<var>offset</var> 。如果<var>offset</var>为正数时，应指定其在显示历史记录时所显示的样子。如果<var>offset</var>为负数，它被解释为相对于上一个历史记录的位置大一个，因此负数索引从历史记录的末尾算起，索引为' <samp>-1</samp> '指当前<code>history -d</code>命令。
</p>
</dd>
<dt><code>-d <var>start</var>-<var>end</var></code></dt>
<dd><p>删除位置之间的历史记录条目<var>start</var>和<var>end</var> ， 包括的。正值和负值<var>start</var>和<var>end</var>如上所述解释。
</p>
</dd>
<dt><code>-a</code></dt>
<dd><p>将新的历史记录行添加到历史记录文件。这些是自当前Bash会话开始以来输入的历史记录行，但尚未附加到历史记录文件中。
</p>
</dd>
<dt><code>-n</code></dt>
<dd><p>将尚未从历史文件中读取的历史行追加到当前历史列表中。这些是自当前Bash会话开始以来附加到历史文件的行。
</p>
</dd>
<dt><code>-r</code></dt>
<dd><p>读取历史文件，并将其内容附加到历史列表中。
</p>
</dd>
<dt><code>-w</code></dt>
<dd><p>将当前历史记录列表写到历史记录文件中。
</p>
</dd>
<dt><code>-p</code></dt>
<dd><p>在上执行历史记录替换<var>arg</var>并在标准输出上显示结果，而不将结果存储在历史记录列表中。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>的<var>arg</var>将s作为单个条目添加到历史记录列表的末尾。
</p>
</dd>
</dl>

<p>当任何<samp>-w</samp> ， <samp>-r</samp> ， <samp>-a</samp> ， 要么<samp>-n</samp>如果使用选项<var>filename</var>给定，然后用作历史文件。如果不是，则该值<code>HISTFILE</code>使用变量。
</p>
</dd>
</dl>

<hr>
<a name="History-Interaction"></a>
<div class="header">
<p>上<a href="#Bash-History-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Bash-History-Builtins" rel="prev" accesskey="p">Bash历史内置程序</a> ，上<a href="#Bash-History-Builtins" rel="prev" accesskey="p">一篇</a> ： <a href="#Using-History-Interactively" rel="up" accesskey="u">交互使用历史</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="History-Expansion"></a>
<h3 class="section">9.3历史扩展</h3>
<a name="index-history-expansion"></a>

<p>历史记录库提供的历史记录扩展功能类似于<code>csh</code> 。本节介绍用于处理历史记录信息的语法。
</p>
<p>历史记录扩展将历史记录列表中的单词引入输入流，从而可以轻松地重复命令，将上一个命令的参数插入当前输入行，或快速修复先前命令中的错误。
</p>
<p>历史扩展在读取完整行之后，在外壳将其分解为单词之前立即执行，并且分别在每行上执行。Bash试图通知历史扩展功能有关先前行中仍然有效的引用。
</p>
<p>历史扩展分为两个部分。首先是确定在替换过程中应使用历史记录列表中的哪一行。第二个是选择该行的部分以包含在当前行中。从历史记录中选择的行称为<em>事件</em> ，行中作用的部分称为<em>单词</em> 。各种<em>修饰符</em>可用于操纵所选单词。该行以与Bash相同的方式分解为单词，因此用引号引起的几个单词被视为一个单词。历史扩展是由历史扩展字符的出现引入的，即“ <samp>!</samp> ' 默认。
</p>
<p>历史扩展实现了类似于shell的引用约定：反斜杠可用于删除对下一个字符的特殊处理；单引号包含字符的逐字序列，可用于禁止历史扩展；并且用双引号引起来的字符可能会进行历史扩展，因为反斜杠可以避开历史扩展字符，但是不能使用单引号，因为在双引号中没有对它们进行特殊处理。
</p>
<p>使用外壳时，仅' <samp>\</samp> '和' <samp>'</samp> '可以用于转义历史扩展字符，但是如果在双引号字符串中紧接双引号之前，则将历史扩展字符也视为带引号。
</p>
<p>可使用<code>shopt</code>内置（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ）可用于调整历史记录扩展的行为。如果<code>histverify</code>启用了shell选项，并且正在使用Readline，历史替换不会立即传递到Shell解析器。而是将展开的行重新加载到Readline编辑缓冲区中以进行进一步修改。如果正在使用Readline，并且<code>histreedit</code>如果启用了shell选项，则失败的历史记录扩展将重新加载到Readline编辑缓冲区中以进行更正。的<samp>-p</samp>选项<code>history</code>内置命令可用于查看历史扩展在使用之前将执行的操作。的<samp>-s</samp>选项<code>history</code>内置函数可用于将命令添加到历史记录列表的末尾，而无需实际执行它们，因此它们可用于后续调用。与Readline结合使用时，此功能最为有用。
</p>
<p>该外壳程序可以通过以下命令控制历史扩展机制使用的各种字符<code>histchars</code>变量，如上所述（请参阅<a href="#Bash-Variables">Bash变量</a> ）。编写历史记录文件时，shell使用历史记录注释字符标记历史记录时间戳。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Event-Designators" accesskey="1">活动代号</a> ：</td><td>  </td><td align="left" valign="top">如何指定要使用的历史记录行。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Word-Designators" accesskey="2">单词代号</a> ：</td><td>  </td><td align="left" valign="top">指定感兴趣的单词。</td></tr>
<tr><td align="left" valign="top">• <a href="#Modifiers" accesskey="3">修饰符</a> ：</td><td>  </td><td align="left" valign="top">修改替换结果。
</td></tr>
</tbody></table>

<hr>
<a name="Event-Designators"></a>
<div class="header">
<p>下一页： <a href="#Word-Designators" rel="next" accesskey="n">单词指示符</a> ，向上： <a href="#History-Interaction" rel="up" accesskey="u">历史交互</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Event-Designators-1"></a>
<h4 class="subsection">9.3.1事件指示符</h4>
<a name="index-event-designators"></a>

<p>事件指示符是对历史记录列表中命令行条目的引用。除非绝对引用，否则事件将相对于历史记录列表中的当前位置。
<a name="index-history-events"></a>
</p>
<dl compact>
<dt><code>!</code></dt>
<dd><p>开始历史记录替换，除非在其后接空格，制表符，行尾' <samp>=</samp> ' 要么 ' <samp>(</samp> ' （当。。。的时候<code>extglob</code>使用以下命令启用shell选项<code>shopt</code>内置）。
</p>
</dd>
<dt><code>!<var>n</var></code></dt>
<dd><p>参考命令行<var>n</var> 。
</p>
</dd>
<dt><code>!-<var>n</var></code></dt>
<dd><p>参考命令<var>n</var>回线。
</p>
</dd>
<dt><code>!!</code></dt>
<dd><p>请参考上一条命令。这是“ <samp>!-1</samp> '。
</p>
</dd>
<dt><code>!<var>string</var></code></dt>
<dd><p>请参考历史记录列表中当前位置之前的最新命令，从<var>string</var> 。
</p>
</dd>
<dt><code>!?<var>string</var>[?]</code></dt>
<dd><p>请参考包含以下内容的历史记录列表中当前位置之前的最新命令： <var>string</var> 。尾随的' <samp>?</samp>如果“ <var>string</var>紧跟着换行符。
</p>
</dd>
<dt><code>^<var>string1</var>^<var>string2</var>^</code></dt>
<dd><p>快速替换。重复最后一条命令，替换<var>string1</var>与<var>string2</var> 。相当于<code>!!:s/<var>string1</var>/<var>string2</var>/</code> 。
</p>
</dd>
<dt><code>!#</code></dt>
<dd><p>到目前为止，整个命令行都已键入。
</p>
</dd>
</dl>

<hr>
<a name="Word-Designators"></a>
<div class="header">
<p>下一篇： <a href="#Modifiers" rel="next" accesskey="n">修饰符</a> ，上一篇： <a href="#Event-Designators" rel="prev" accesskey="p">事件指示符</a> ，上一篇： <a href="#History-Interaction" rel="up" accesskey="u">历史互动</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Word-Designators-1"></a>
<h4 class="subsection">9.3.2字指示符</h4>

<p>单词指示符用于从事件中选择所需单词。一种 ' <samp>:</samp> '将事件说明与单词指示符分开。如果单词指示符以'开头，则可以省略<samp>^</samp> '，' <samp>$</samp> '，' <samp>*</samp> '，' <samp>-</samp> '， 要么 ' <samp>%</samp> '。单词从行的开头开始编号，第一个单词用0（零）表示。将单词插入到当前行中，并用单个空格分隔。
</p>
<p>例如，</p>
<dl compact>
<dt><code>!!</code></dt>
<dd><p>指定前面的命令。键入此命令时，toto中将重复前面的命令。
</p>
</dd>
<dt><code>!!:$</code></dt>
<dd><p>指定前面命令的最后一个参数。这可以缩短为<code>!$</code> 。
</p>
</dd>
<dt><code>!fi:2</code></dt>
<dd><p>指定以字母开头的最新命令的第二个自变量<code>fi</code> 。
</p></dd>
</dl>

<p>这是单词代号：</p> 
<dl compact>
<dt><code>0 (zero)</code></dt>
<dd><p>的<code>0</code>字。对于许多应用程序，这是命令字。
</p>
</dd>
<dt><code><var>n</var></code></dt>
<dd><p>的<var>n</var>字。
</p>
</dd>
<dt><code>^</code></dt>
<dd><p>第一个论点；即单词1。
</p>
</dd>
<dt><code>$</code></dt>
<dd><p>最后一个参数。
</p>
</dd>
<dt><code>%</code></dt>
<dd><p>这个词与最近的' <samp>?<var>string</var>?</samp>搜索。
</p>
</dd>
<dt><code><var>x</var>-<var>y</var></code></dt>
<dd><p>单词范围； ' <samp>-<var>y</var></samp> '缩写' <samp>0-<var>y</var></samp> '。
</p>
</dd>
<dt><code>*</code></dt>
<dd><p>所有的词，除了<code>0</code> th。这是“ <samp>1-$</samp> '。使用'不是错误<samp>*</samp> '如果活动中只有一个字，在这种情况下，将返回空字符串。
</p>
</dd>
<dt><code><var>x</var>*</code></dt>
<dd><p>缩写“ <samp><var>x</var>-$</samp> '</p>
</dd>
<dt><code><var>x</var>-</code></dt>
<dd><p>缩写“ <samp><var>x</var>-$</samp> ' 喜欢 ' <samp><var>x</var>*</samp> '，但省略了最后一句话。
</p>
</dd>
</dl>

<p>如果提供的单词指示符没有事件说明，则将先前的命令用作事件。
</p>
<hr>
<a name="Modifiers"></a>
<div class="header">
<p>上一篇： <a href="#Word-Designators" rel="prev" accesskey="p">单词指定器</a> ，上一篇： <a href="#History-Interaction" rel="up" accesskey="u">历史互动</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Modifiers-1"></a>
<h4 class="subsection">9.3.3修饰符</h4>

<p>在可选的单词指示符之后，您可以添加一个或多个以下修饰符的序列，每个修饰符前面均带有' <samp>:</samp> '。
</p>
<dl compact>
<dt><code>h</code></dt>
<dd><p>删除尾随的路径名组件，仅保留头部。
</p>
</dd>
<dt><code>t</code></dt>
<dd><p>删除所有前导路径名组件，保留结尾。
</p>
</dd>
<dt><code>r</code></dt>
<dd><p>删除格式为'的结尾后缀<samp>.<var>suffix</var></samp> '，保留基本名称。
</p>
</dd>
<dt><code>e</code></dt>
<dd><p>除去尾随的所有内容。
</p>
</dd>
<dt><code>p</code></dt>
<dd><p>打印新命令，但不执行它。
</p>
</dd>
<dt><code>q</code></dt>
<dd><p>引用替换的单词，以免进一步替换。
</p>
</dd>
<dt><code>x</code></dt>
<dd><p>用'引用替换的单词<samp>q</samp> ”，但在空格，制表符和换行符处分词。
</p>
</dd>
<dt><code>s/<var>old</var>/<var>new</var>/</code></dt>
<dd><p>替代<var>new</var>第一次出现<var>old</var>在事件行中。可以使用任何定界符代替“ <samp>/</samp> '。分隔符可以用引号引起来<var>old</var>和<var>new</var>一个反斜杠。如果“ <samp>&</samp> '出现在<var>new</var> ，它被替换为<var>old</var> 。单个反斜杠将引用“ <samp>&</samp> '。如果最后定界符是输入行上的最后一个字符，则它是可选的。
</p>
</dd>
<dt><code>&</code></dt>
<dd><p>重复上一个替换。
</p>
</dd>
<dt><code>g</code></dt>
<dt><code>a</code></dt>
<dd><p>使更改应用于整个事件行。与“ <samp>s</samp> '，如<code>gs/<var>old</var>/<var>new</var>/</code> ，或使用' <samp>&</samp> '。
</p>
</dd>
<dt><code>G</code></dt>
<dd><p>应用以下“ <samp>s</samp> '修饰语一次出现在每个单词中。
</p>
</dd>
</dl>

<hr>
<a name="Installing-Bash"></a>
<div class="header">
<p>下一篇： <a href="#Reporting-Bugs" rel="next" accesskey="n">报告错误</a> ，上一篇： <a href="#Using-History-Interactively" rel="prev" accesskey="p">交互使用历史记录</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Installing-Bash-1"></a>
<h2 class="chapter">10安装Bash</h2>

<p>本章提供了在各种支持的平台上安装Bash的基本说明。该发行版支持<small>GNU</small>操作系统，几乎每个版本的Unix以及一些非Unix系统，例如BeOS和Interix。还存在用于<small>MS-DOS</small> ， <small>OS / 2</small>和Windows平台的其他独立端口。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Basic-Installation" accesskey="1">基本安装</a> ：</td><td>  </td><td align="left" valign="top">安装说明。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Compilers-and-Options" accesskey="2">编译器和选项</a> ：</td><td>  </td><td align="left" valign="top">如何为各种系统设置特殊选项。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Compiling-For-Multiple-Architectures" accesskey="3">针对多种架构进行编译</a> ：</td><td>  </td><td align="left" valign="top">如何从同一源代码树为多种系统编译Bash。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Installation-Names" accesskey="4">安装名称</a> ：</td><td>  </td><td align="left" valign="top">如何设置安装使用的各种路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Specifying-the-System-Type" accesskey="5">指定系统类型</a> ：</td><td>  </td><td align="left" valign="top">如何为特定系统配置Bash。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Sharing-Defaults" accesskey="6">共享默认值</a> ：</td><td>  </td><td align="left" valign="top">如何在GNU程序之间共享默认配置值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Operation-Controls" accesskey="7">操作控制</a> ：</td><td>  </td><td align="left" valign="top">配置程序识别的选项。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Optional-Features" accesskey="8">可选功能</a> ：</td><td>  </td><td align="left" valign="top">构建Bash时如何启用和禁用可选功能。
</td></tr>
</tbody></table>

<hr>
<a name="Basic-Installation"></a>
<div class="header">
<p>下一页： <a href="#Compilers-and-Options" rel="next" accesskey="n">编译器和选项</a> ，上一篇： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Basic-Installation-1"></a>
<h3 class="section">10.1基本安装</h3>
<a name="index-installation"></a>
<a name="index-configuration"></a>
<a name="index-Bash-installation"></a>
<a name="index-Bash-configuration"></a>

<p>这些是Bash的安装说明。
</p>
<p>编译Bash的最简单方法是：</p>
<ol>
<li> <code>cd</code>到包含源代码的目录，然后键入“ <samp>./configure</samp> '为您的系统配置Bash。如果您正在使用<code>csh</code>在旧版本的System V上，您可能需要输入“ <samp>sh ./configure</samp> '相反是为了防止<code>csh</code>从试图执行<code>configure</code>本身。

<p>跑步<code>configure</code>需要一些时间。在运行时，它会打印消息，告知正在检查的功能。
</p>
</li><li>输入“ <samp>make</samp>来编译Bash并构建<code>bashbug</code>错误报告脚本。

</li><li>（可选）输入“ <samp>make tests</samp>以运行Bash测试套件。

</li><li>输入“ <samp>make install</samp> ' 安装<code>bash</code>和<code>bashbug</code> 。这还将安装手册页和信息文件。

</li></ol>

<p>的<code>configure</code> Shell脚本尝试为编译期间使用的各种与系统相关的变量猜测正确的值。它使用这些值来创建一个<samp>Makefile</samp>在软件包的每个目录中（顶层目录， <samp>builtins</samp> ， <samp>doc</samp>和<samp>support</samp>目录，每个目录在<samp>lib</samp> ，以及其他几个）。它还会创建一个<samp>config.h</samp>包含与系统有关的定义的文件。最后，它创建一个名为<code>config.status</code>您可以在以后运行以重新创建当前配置的文件<samp>config.cache</samp>保存测试结果以加快重新配置的速度，并保存一个文件<samp>config.log</samp>包含编译器输出（主要用于调试<code>configure</code> ）。如果在某个时候<samp>config.cache</samp>包含您不想保留的结果，可以将其删除或编辑。
</p>
<p>要了解有关选项和参数的更多信息， <code>configure</code>脚本可以理解，输入</p>
<div class="example">
<pre class="example">bash-4.2$ ./configure --help
</pre></div>

<p>在Bash源目录中的Bash提示符下。
</p>
<p>如果要在与源目录不同的目录中构建Bash（例如，要针对多种体系结构进行构建），只需使用configure脚本的完整路径即可。以下命令将在以下目录中构建bash <samp>/usr/local/build</samp>从中的源代码<samp>/usr/local/src/bash-4.4</samp> ：</p>
<div class="example">
<pre class="example">mkdir /usr/local/build/bash-4.4
cd /usr/local/build/bash-4.4
bash /usr/local/src/bash-4.4/configure
make
</pre></div>

<p>有关在不同于源的目录中进行构建的更多信息，请参见<a href="#Compiling-For-Multiple-Architectures">针对多种体系结构</a>进行<a href="#Compiling-For-Multiple-Architectures">编译</a> 。
</p>
<p>如果您需要做一些不寻常的事情来编译Bash，请尝试弄清楚如何<code>configure</code>可以检查是否要执行此操作，并将差异或说明发送至<a href="mailto:bash-maintainers@gnu.org">bash-maintainers@gnu.org，</a>以便可以在下一个发行版中考虑它们。
</p>
<p>文件<samp>configure.ac</samp>用于创建<code>configure</code>通过一个名为Autoconf的程序。你只需要<samp>configure.ac</samp>如果要更改或重新生成<code>configure</code>使用较新版本的Autoconf。如果这样做，请确保您使用的是Autoconf 2.50版或更高版本。
</p>
<p>您可以通过键入'从源代码目录中删除程序二进制文件和目标文件。 <samp>make clean</samp> '。还要删除那些<code>configure</code>创建（以便您可以为其他类型的计算机编译Bash），请输入“ <samp>make distclean</samp> '。
</p>
<hr>
<a name="Compilers-and-Options"></a>
<div class="header">
<p>下一页： <a href="#Compiling-For-Multiple-Architectures" rel="next" accesskey="n">针对多种体系结构进行编译</a> ，Previous： <a href="#Basic-Installation" rel="prev" accesskey="p">基本安装</a> ，Up： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Compilers-and-Options-1"></a>
<h3 class="section">10.2编译器和选项</h3>

<p>某些系统需要不寻常的选项来进行编译或链接， <code>configure</code>脚本不知道。你可以给<code>configure</code>通过在环境中设置变量的初始值。使用兼容Bourne的shell，您可以在命令行上执行以下操作：</p>
<div class="example">
<pre class="example">CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
</pre></div>

<p>在具有<code>env</code>程序，您可以这样做：</p>
<div class="example">
<pre class="example">env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
</pre></div>

<p>如果可用，配置过程将使用GCC来构建Bash。
</p>
<hr>
<a name="Compiling-For-Multiple-Architectures"></a>
<div class="header">
<p>下一页： <a href="#Installation-Names" rel="next" accesskey="n">安装名称</a> ，上一篇： <a href="#Compilers-and-Options" rel="prev" accesskey="p">编译器和选项</a> ，上一篇： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Compiling-For-Multiple-Architectures-1"></a>
<h3 class="section">10.3多种架构的编译</h3>

<p>通过将每种体系结构的目标文件放在各自的目录中，您可以同时为多种计算机编译Bash。为此，您必须使用<code>make</code>支持<code>VPATH</code>变量，例如GNU <code>make</code> 。
<code>cd</code>到您想要目标文件和可执行文件运行的目录<code>configure</code>源目录中的脚本（请参阅<a href="#Basic-Installation">基本安装</a> ）。您可能需要提供<samp>--srcdir=PATH</samp>要说的论点<code>configure</code>源文件在哪里。 <code>configure</code>自动检查目录中的源代码<code>configure</code>在“ ..”中。
</p>
<p>如果您必须使用<code>make</code>不支持<code>VPATH</code>变量，您可以在源代码目录中一次为一种架构编译Bash。为一种架构安装Bash后，请使用“ <samp>make distclean</samp>在重新配置为其他架构之前。
</p>
<p>或者，如果您的系统支持符号链接，则可以使用<samp>support/mkclone</samp>脚本来创建构建树，该构建树具有指向源目录中每个文件的符号链接。这是一个从源目录在当前目录中创建构建目录的示例<samp>/usr/gnu/src/bash-2.0</samp> ：</p>
<div class="example">
<pre class="example">bash /usr/gnu/src/bash-2.0/support/mkclone -s /usr/gnu/src/bash-2.0 .
</pre></div>

<p>的<code>mkclone</code>该脚本需要Bash，因此您必须已经为至少一种架构构建了Bash，然后才能为其他架构创建构建目录。
</p>
<hr>
<a name="Installation-Names"></a>
<div class="header">
<p>下一篇： <a href="#Specifying-the-System-Type" rel="next" accesskey="n">指定系统类型</a> ，上一篇： <a href="#Compiling-For-Multiple-Architectures" rel="prev" accesskey="p">针对多种体系结构进行编译</a> ，上一篇： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Installation-Names-1"></a>
<h3 class="section">10.4安装名称</h3>

<p>默认， ' <samp>make install</samp> '将安装到<samp>/usr/local/bin</samp> ， <samp>/usr/local/man</samp>等您可以指定除以下以外的安装前缀<samp>/usr/local</samp>通过给予<code>configure</code>选项<samp>--prefix=<var>PATH</var></samp> ，或者通过为<code>DESTDIR</code> ' <samp>make</samp> “运行时变量” <samp>make install</samp> '。
</p>
<p>您可以为特定于体系结构的文件和独立于体系结构的文件指定单独的安装前缀。如果你给<code>configure</code>选项<samp>--exec-prefix=<var>PATH</var></samp> ，' <samp>make install</samp> ' 将使用<var>PATH</var>作为安装程序和库的前缀。文档和其他数据文件仍将使用常规前缀。
</p>
<hr>
<a name="Specifying-the-System-Type"></a>
<div class="header">
<p>下一页： <a href="#Sharing-Defaults" rel="next" accesskey="n">共享默认值</a> ，上一篇： <a href="#Installation-Names" rel="prev" accesskey="p">安装名称</a> ，上一篇： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Specifying-the-System-Type-1"></a>
<h3 class="section">10.5指定系统类型</h3>

<p>可能有一些功能<code>configure</code>无法自动找出来，而是需要通过Bash所运行的主机类型来确定。通常<code>configure</code>可以解决这个问题，但是如果它显示一条消息，说它无法猜测主机类型，请给它<samp>--host=TYPE</samp>选项。 ' <samp>TYPE</samp> '可以是系统类型的简称，例如' <samp>sun4</samp> '，或具有三个字段的规范名称：' <samp>CPU-COMPANY-SYSTEM</samp> '（例如，' <samp>i386-unknown-freebsd4.2</samp> '）。
</p>
<p>查看档案<samp>support/config.sub</samp>每个字段的可能值。
</p>
<hr>
<a name="Sharing-Defaults"></a>
<div class="header">
<p>下一页： <a href="#Operation-Controls" rel="next" accesskey="n">操作控件</a> ，上一页： <a href="#Specifying-the-System-Type" rel="prev" accesskey="p">指定系统类型</a> ，上一页： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Sharing-Defaults-1"></a>
<h3 class="section">10.6共享默认值</h3>

<p>如果要设置默认值<code>configure</code>要共享的脚本，您可以创建一个名为<code>config.site</code>为变量提供默认值，例如<code>CC</code> ， <code>cache_file</code>和<code>prefix</code> 。<code>configure</code>寻找<samp>PREFIX/share/config.site</samp>如果存在，那么<samp>PREFIX/etc/config.site</samp>如果存在。或者，您可以设置<code>CONFIG_SITE</code>环境变量到站点脚本的位置。警告：重击<code>configure</code>寻找网站脚本，但不是全部<code>configure</code>脚本。
</p>
<hr>
<a name="Operation-Controls"></a>
<div class="header">
<p>下一页： <a href="#Optional-Features" rel="next" accesskey="n">可选功能</a> ，上一页： <a href="#Sharing-Defaults" rel="prev" accesskey="p">共享默认值</a> ，向上： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Operation-Controls-1"></a>
<h3 class="section">10.7操作控制</h3>

<p><code>configure</code>可以识别以下选项来控制其操作方式。
</p>
<dl compact>
<dt><code>--cache-file=<var>file</var></code></dt>
<dd><p>使用测试结果并将其保存在<var>file</var>代替<samp>./config.cache</samp> 。组<var>file</var>至<samp>/dev/null</samp>禁用缓存，用于调试<code>configure</code> 。
</p>
</dd>
<dt><code>--help</code></dt>
<dd><p>打印选项摘要<code>configure</code> ，然后退出。
</p>
</dd>
<dt><code>--quiet</code></dt>
<dt><code>--silent</code></dt>
<dt><code>-q</code></dt>
<dd><p>不要打印说明正在检查的消息。
</p>
</dd>
<dt><code>--srcdir=<var>dir</var></code></dt>
<dd><p>在目录中查找Bash源代码<var>dir</var> 。通常<code>configure</code>可以自动确定该目录。
</p>
</dd>
<dt><code>--version</code></dt>
<dd><p>打印用于生成<code>configure</code>脚本，然后退出。
</p></dd>
</dl>

<p><code>configure</code>也接受其他未广泛使用的样板选项。 ' <samp>configure --help</samp> '打印完整列表。
</p>
<hr>
<a name="Optional-Features"></a>
<div class="header">
<p>上一页： <a href="#Operation-Controls" rel="prev" accesskey="p">操作控件</a> ，向上： <a href="#Installing-Bash" rel="up" accesskey="u">安装Bash</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Optional-Features-1"></a>
<h3 class="section">10.8可选功能</h3>

<p>重击<code>configure</code>有一些<samp>--enable-<var>feature</var></samp>选项，在哪里<var>feature</var>表示Bash的可选部分。也有几个<samp>--with-<var>package</var></samp>选项，在哪里<var>package</var>是类似“ <samp>bash-malloc</samp> ' 要么 ' <samp>purify</samp> '。要关闭软件包的默认使用，请使用<samp>--without-<var>package</var></samp> 。要配置不具有默认启用的功能的Bash，请使用<samp>--disable-<var>feature</var></samp> 。
</p>
<p>这是完整的清单<samp>--enable-</samp>和<samp>--with-</samp> Bash的选项<code>configure</code>认识。
</p>
<dl compact>
<dt><code>--with-afs</code></dt>
<dd><p>定义是否正在使用Transarc的Andrew文件系统。
</p>
</dd>
<dt><code>--with-bash-malloc</code></dt>
<dd><p>使用Bash版本的<code>malloc</code>在目录中<samp>lib/malloc</samp> 。这不一样<code>malloc</code>出现在<small>GNU</small> libc中，但最初源自4.2 <small>BSD</small> <code>malloc</code> 。这个<code>malloc</code>速度非常快，但是每次分配都会浪费一些空间。默认情况下启用此选项。的<samp>NOTES</samp>该文件包含应关闭此功能的系统列表，以及<code>configure</code>对于许多系统，将自动禁用此选项。
</p>
</dd>
<dt><code>--with-curses</code></dt>
<dd><p>使用curses库而不是termcap库。如果您的系统的termcap数据库不足或不完整，则应提供此文件。
</p>
</dd>
<dt><code>--with-gnu-malloc</code></dt>
<dd><p>的同义词<code>--with-bash-malloc</code> 。
</p>
</dd>
<dt><code>--with-installed-readline[=<var>PREFIX</var>]</code></dt>
<dd><p>定义它以使Bash与本地安装的Readline版本（而不是在Windows中的版本）链接<samp>lib/readline</samp> 。这仅适用于Readline 5.0和更高版本。如果<var>PREFIX</var>是<code>yes</code>或不提供， <code>configure</code>使用make变量的值<code>includedir</code>和<code>libdir</code> ，这是的子目录<code>prefix</code>默认情况下，如果标准系统的include和库目录中未包含Readline，则查找已安装的版本。如果<var>PREFIX</var>是<code>no</code> ，Bash与版本中的链接<samp>lib/readline</samp> 。如果<var>PREFIX</var>设置为任何其他值， <code>configure</code>将其视为目录路径名，并在该目录的子目录中查找Readline的安装版本（包括<var>PREFIX</var> / <code>include</code>和图书馆<var>PREFIX</var> / <code>lib</code> ）。
</p>
</dd>
<dt><code>--with-purify</code></dt>
<dd><p>定义它以使用Rational Software中的Purify内存分配检查器。
</p>
</dd>
<dt><code>--enable-minimal-config</code></dt>
<dd><p>这样产生的外壳具有极少的功能，接近历史上的伯恩外壳。
</p></dd>
</dl>

<p>有几种<samp>--enable-</samp>更改Bash的编译和链接方式的选项，而不是更改运行时功能。
</p>
<dl compact>
<dt><code>--enable-largefile</code></dt>
<dd><p>如果操作系统需要特殊的编译器选项来构建可以访问大文件的程序，则启用对<a href="http://www.unix.org/version2/whatsnew/lfs20mar.html">大文件的</a>支持。如果操作系统提供大文件支持，则默认情况下启用此功能。
</p>
</dd>
<dt><code>--enable-profiling</code></dt>
<dd><p>这将构建一个Bash二进制文件，该二进制文件将生成分析信息以供处理<code>gprof</code>每次执行时。
</p>
</dd>
<dt><code>--enable-static-link</code></dt>
<dd><p>这会导致Bash静态链接，如果<code>gcc</code>正在被使用。这可用于构建用作root用户的shell的版本。
</p></dd>
</dl>

<p>' <samp>minimal-config</samp> '选项可用于禁用以下所有选项，但会先进行处理，因此可以使用' <samp>enable-<var>feature</var></samp> '。
</p>
<p>除“ <samp>disabled-builtins</samp> '，' <samp>direxpand-default</samp> '和' <samp>xpg-echo-default</samp>除非操作系统未提供必要的支持，否则默认情况下会启用。
</p>
<dl compact>
<dt><code>--enable-alias</code></dt>
<dd><p>允许别名扩展并包括<code>alias</code>和<code>unalias</code>内置（请参阅<a href="#Aliases">Aliases</a> ）。
</p>
</dd>
<dt><code>--enable-arith-for-command</code></dt>
<dd><p>包括对替代形式的支持<code>for</code>行为类似于C语言的命令<code>for</code>语句（请参见<a href="#Looping-Constructs">循环构造</a> ）。
</p>
</dd>
<dt><code>--enable-array-variables</code></dt>
<dd><p>包括对一维数组外壳变量的支持（请参阅<a href="#Arrays">Arrays</a> ）。
</p>
</dd>
<dt><code>--enable-bang-history</code></dt>
<dd><p>包括对<code>csh</code>类似的历史记录替换（请参见<a href="#History-Interaction">History Interaction</a> ）。
</p>
</dd>
<dt><code>--enable-brace-expansion</code></dt>
<dd><p>包括<code>csh</code>状的撑杆膨胀（ <code>b{a,b}c</code> → <code>bac bbc</code> ）。有关完整说明，请参见<a href="#Brace-Expansion">Brace Expansion</a> 。
</p>
</dd>
<dt><code>--enable-casemod-attributes</code></dt>
<dd><p>包括对大小写修改属性的支持<code>declare</code>内置和赋值语句。带有变量<var>uppercase</var>例如，属性将在赋值时将其值转换为大写。
</p>
</dd>
<dt><code>--enable-casemod-expansion</code></dt>
<dd><p>包括对大小写修饰词扩展的支持。
</p>
</dd>
<dt><code>--enable-command-timing</code></dt>
<dd><p>包括对识别的支持<code>time</code>作为保留字并用于显示以下管道的时序统计信息<code>time</code> （请参阅<a href="#Pipelines">管道</a> ）。这允许对管道以及外壳内置和函数进行计时。
</p>
</dd>
<dt><code>--enable-cond-command</code></dt>
<dd><p>包括对<code>[[</code>条件命令。（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。
</p>
</dd>
<dt><code>--enable-cond-regexp</code></dt>
<dd><p>包括使用'匹配<small>POSIX</small>正则表达式的支持<samp>=~</samp> '中的二进制运算符<code>[[</code>条件命令。（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。
</p>
</dd>
<dt><code>--enable-coprocesses</code></dt>
<dd><p>包括对协同流程和<code>coproc</code>保留字（请参见<a href="#Pipelines">管道</a> ）。
</p>
</dd>
<dt><code>--enable-debugger</code></dt>
<dd><p>包括对bash调试器的支持（单独分发）。
</p>
</dd>
<dt><code>--enable-dev-fd-stat-broken</code></dt>
<dd><p>如果打电话<code>stat</code>在/ dev / fd / <var>N</var>返回与调用不同的结果<code>fstat</code>在文件描述符上<var>N</var> ，请提供此选项以启用解决方法。这对测试文件属性的条件命令有影响。
</p>
</dd>
<dt><code>--enable-direxpand-default</code></dt>
<dd><p>原因<code>direxpand</code> shell启动时将默认启用shell选项（请参见<a href="#The-Shopt-Builtin">Shopt Builtin</a> ）。通常默认情况下禁用它。
</p>
</dd>
<dt><code>--enable-directory-stack</code></dt>
<dd><p>包括对<code>csh</code>类目录堆栈和<code>pushd</code> ， <code>popd</code>和<code>dirs</code>内置文件（请参阅<a href="#The-Directory-Stack">目录堆栈</a> ）。
</p>
</dd>
<dt><code>--enable-disabled-builtins</code></dt>
<dd><p>允许通过'调用内置命令<samp>builtin xxx</samp> ' 即使<code>xxx</code>已使用“ <samp>enable -n xxx</samp> '。有关详细信息，请参见<a href="#Bash-Builtins">Bash Builtins</a> 。 <code>builtin</code>和<code>enable</code>内置命令。
</p>
</dd>
<dt><code>--enable-dparen-arithmetic</code></dt>
<dd><p>包括对<code>((…))</code>命令（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。
</p>
</dd>
<dt><code>--enable-extended-glob</code></dt>
<dd><p>在“ <a href="#Pattern-Matching">模式匹配”</a>下包括对上述扩展模式匹配功能的支持。
</p>
</dd>
<dt><code>--enable-extended-glob-default</code></dt>
<dd><p>设置默认值<var>extglob</var>启用“ <a href="#The-Shopt-Builtin">内置Shopt”</a>下所述的shell选项。
</p>
</dd>
<dt><code>--enable-function-import</code></dt>
<dd><p>包括对导入由外壳的另一个实例从环境中导出的函数定义的支持。默认情况下启用此选项。
</p>
</dd>
<dt><code>--enable-glob-asciirange-default</code></dt>
<dd><p>设置默认值<var>globasciiranges</var>启用“ <a href="#The-Shopt-Builtin">内置Shopt”</a>下所述的shell选项。在模式匹配括号表达式中使用时，这可以控制字符范围的行为。
</p>
</dd>
<dt><code>--enable-help-builtin</code></dt>
<dd><p>包括<code>help</code> builtin，它显示有关shell内建函数和变量的帮助（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。
</p>
</dd>
<dt><code>--enable-history</code></dt>
<dd><p>包括命令历史记录和<code>fc</code>和<code>history</code>内置命令（请参阅<a href="#Bash-History-Facilities">Bash历史记录工具</a> ）。
</p>
</dd>
<dt><code>--enable-job-control</code></dt>
<dd><p>如果操作系统支持，则会启用作业控制功能（请参阅“ <a href="#Job-Control">作业控制”</a> ）。
</p>
</dd>
<dt><code>--enable-multibyte</code></dt>
<dd><p>如果操作系统提供了必要的支持，则可以支持多字节字符。
</p>
</dd>
<dt><code>--enable-net-redirections</code></dt>
<dd><p>这样可以对表单的文件名进行特殊处理<code>/dev/tcp/<var>host</var>/<var>port</var></code>和<code>/dev/udp/<var>host</var>/<var>port</var></code>在重定向中使用时（请参阅<a href="#Redirections">重定向</a> ）。
</p>
</dd>
<dt><code>--enable-process-substitution</code></dt>
<dd><p>如果操作系统提供了必要的支持，则可以启用进程替换（请参阅<a href="#Process-Substitution">Process Substitution</a> ）。
</p>
</dd>
<dt><code>--enable-progcomp</code></dt>
<dd><p>启用可编程完成功能（请参阅“ <a href="#Programmable-Completion">可编程完成”</a> ）。如果未启用Readline，则此选项无效。
</p>
</dd>
<dt><code>--enable-prompt-string-decoding</code></dt>
<dd><p>开启翻译器中许多反斜杠转义字符的解释<code>$PS0</code> ， <code>$PS1</code> ， <code>$PS2</code>和<code>$PS4</code>提示字符串。有关提示字符串转义序列的完整列表，请参见<a href="#Controlling-the-Prompt">控制提示</a> 。
</p>
</dd>
<dt><code>--enable-readline</code></dt>
<dd><p>Bash版本的Readline库包括对命令行编辑和历史记录的支持（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ）。
</p>
</dd>
<dt><code>--enable-restricted</code></dt>
<dd><p>包括对<em>受限外壳的</em>支持。如果启用了此功能，则Bash在被称为<code>rbash</code> ，进入限制模式。有关受限模式的说明，请参见<a href="#The-Restricted-Shell">受限外壳</a> 。
</p>
</dd>
<dt><code>--enable-select</code></dt>
<dd><p>包括<code>select</code>复合命令，它允许生成简单的菜单（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。
</p>
</dd>
<dt><code>--enable-separate-helpfiles</code></dt>
<dd><p>使用外部文件作为文档显示的文档<code>help</code>内置而不是内部存储文本。
</p>
</dd>
<dt><code>--enable-single-help-strings</code></dt>
<dd><p>存储由<code>help</code>内置为每个帮助主题的单个字符串。这有助于将文本翻译成不同的语言。如果您的编译器无法处理非常长的字符串文字，则可能需要禁用此功能。
</p>
</dd>
<dt><code>--enable-strict-posix-default</code></dt>
<dd><p>使Bash <small>POSIX</small>保持默认状态（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）。
</p>
</dd>
<dt><code>--enable-usg-echo-default</code></dt>
<dd><p>的同义词<code>--enable-xpg-echo-default</code> 。
</p>
</dd>
<dt><code>--enable-xpg-echo-default</code></dt>
<dd><p>使<code>echo</code>内置默认情况下扩展反斜杠转义字符，而无需<samp>-e</samp>选项。这将设置默认值<code>xpg_echo</code>外壳选项<code>on</code> ，这使得Bash <code>echo</code>行为更像是Single Unix Specification版本3中指定的版本。请参阅<a href="#Bash-Builtins">Bash Builtins</a> ，有关转义序列的说明， <code>echo</code>认识。
</p></dd>
</dl>

<p>文件<samp>config-top.h</samp>包含C预处理程序' <samp>#define</samp> '声明，说明不能从中设置的选项<code>configure</code> 。其中一些并不意味着要改变；如果这样做，请当心后果。阅读与每个定义相关的注释，以获取有关其效果的更多信息。
</p>
<hr>
<a name="Reporting-Bugs"></a>
<div class="header">
<p>下一篇： <a href="#Major-Differences-From-The-Bourne-Shell" rel="next" accesskey="n">与Bourne Shell的主要区别</a> ，上一篇： <a href="#Installing-Bash" rel="prev" accesskey="p">安装Bash</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Reporting-Bugs-1"></a>
<h2 class="appendix">附录A报告错误</h2>

<p>请报告您在Bash中发现的所有错误。但是首先，您应该确保它确实是一个错误，并且它出现在最新版本的Bash中。最新版本的Bash始终可从<a href="ftp://ftp.gnu.org/pub/gnu/bash/">ftp://ftp.gnu.org/pub/gnu/bash/下载</a>到FTP。</p>
<p>确定错误确实存在后，请使用<code>bashbug</code>命令提交错误报告。如果有修复程序，建议您也将其邮寄！建议和“哲学性”的错误报告可以发送至<a href="mailto:bug-bash@gnu.org">bug-bash@gnu.org</a>或发布到Usenet新闻组<code>gnu.bash.bug</code> 。
</p>
<p>所有错误报告应包括：</p><ul>
<li>Bash的版本号。
</li><li>硬件和操作系统。
</li><li>该编译器用于编译Bash。
</li><li>错误行为的描述。
</li><li>一个简短的脚本或“食谱”，可以练习该错误并可以重现该错误。
</li></ul>

<p><code>bashbug</code>将前三个项目自动插入模板中，该模板用于提交错误报告。
</p>
<p>请将有关本手册的所有报告发送至<a href="mailto:bug-bash@gnu.org">bug-bash@gnu.org</a> 。
</p>
<hr>
<a name="Major-Differences-From-The-Bourne-Shell"></a>
<div class="header">
<p>下一篇： <a href="#GNU-Free-Documentation-License" rel="next" accesskey="n">GNU自由文档许可证</a> ，上一篇： <a href="#Reporting-Bugs" rel="prev" accesskey="p">报告错误</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Major-Differences-From-The-Bourne-Shell-1"></a>
<h2 class="appendix">附录B与Bourne Shell的主要区别</h2>

<p>Bash实现了与Bourne Shell相同的语法，参数和变量扩展，重定向和引用。Bash使用<small>POSIX</small>标准作为如何实现这些功能的规范。传统的Bourne外壳和Bash之间有一些区别；本节将快速详细介绍重要性差异。在前面的部分中，对这些差异进行了更深入的解释。本部分使用的版本<code>sh</code> SVR4.2中包含的内容（历史Bourne Shell的最新版本）作为基准。
</p>
<ul>
<li>Bash符合<small>POSIX</small> ，即使<small>POSIX</small>规范不同于传统<code>sh</code>行为（请参阅<a href="#Bash-POSIX-Mode">Bash POSIX模式</a> ）。

</li><li>Bash具有多字符调用选项（请参阅“ <a href="#Invoking-Bash">调用Bash”</a> ）。

</li><li>Bash具有命令行编辑功能（请参阅<a href="#Command-Line-Editing">命令行编辑</a> ），并且Bash具有<code>bind</code>内置的。

</li><li>Bash提供了可编程的单词完成机制（请参阅<a href="#Programmable-Completion">Programmable Completion</a> ）和内置命令<code>complete</code> ， <code>compgen</code>和<code>compopt</code> ，以操纵它。

</li><li>Bash具有命令历史记录（请参阅<a href="#Bash-History-Facilities">Bash历史记录设施</a> ），并且<code>history</code>和<code>fc</code>内置操作它。Bash历史记录列表会维护时间戳记信息，并使用<code>HISTTIMEFORMAT</code>变量以显示它。

</li><li>打击工具<code>csh</code>类似于历史的扩展（请参阅<a href="#History-Interaction">历史交互</a> ）。

</li><li>Bash具有一维数组变量（请参阅<a href="#Arrays">Arrays</a> ），以及使用它们的适当变量扩展和赋值语法。一些Bash内置函数采用选项来对阵列起作用。Bash提供了许多内置数组变量。

</li><li>的<code>$'…'</code>支持引号语法，该语法在单引号之间的文本中扩展ANSI-C反斜杠转义字符（请参见<a href="#ANSI_002dC-Quoting">ANSI-C引用</a> ）。

</li><li>Bash支持<code>$"…"</code>用引号语法对双引号之间的字符进行语言环境特定的翻译。的<samp>-D</samp> ， <samp>--dump-strings</samp>和<samp>--dump-po-strings</samp>调用选项列出了在脚本中找到的可翻译字符串（请参阅<a href="#Locale-Translation">Locale Translation</a> ）。

</li><li>Bash实现了<code>!</code>关键字来否定管道的返回值（请参阅<a href="#Pipelines">Pipelines</a> ）。当一个<code>if</code>语句仅在测试失败时才需要执行。重击<samp>-o pipefail</samp> '选项<code>set</code>如果任何命令失败，将导致管道返回失败状态。

</li><li>重击有<code>time</code>保留字和命令定时（请参见<a href="#Pipelines">管道</a> ）。时序统计的显示可以通过<code>TIMEFORMAT</code>变量。

</li><li>Bash实现了<code>for (( <var>expr1</var> ; <var>expr2</var> ; <var>expr3</var> ))</code>命令的算法，类似于C语言（请参见<a href="#Looping-Constructs">循环结构</a> ）。

</li><li>重击包括<code>select</code>复合命令，它允许生成简单的菜单（请参阅<a href="#Conditional-Constructs">条件构造</a> ）。

</li><li>重击包括<code>[[</code>复合命令，它使条件测试成为shell语法的一部分（请参阅<a href="#Conditional-Constructs">条件构造</a> ），包括可选的正则表达式匹配。

</li><li>Bash提供了可选的不区分大小写的匹配<code>case</code>和<code>[[</code>结构体。

</li><li>Bash包括括号扩展（请参阅<a href="#Brace-Expansion">Brace Expansion</a> ）和波浪号扩展（请参见<a href="#Tilde-Expansion">Tilde Expansion</a> ）。

</li><li>Bash实现命令别名，并且<code>alias</code>和<code>unalias</code>内置（请参阅<a href="#Aliases">Aliases</a> ）。

</li><li>Bash提供了shell算术， <code>((</code>复合命令（请参阅<a href="#Conditional-Constructs">条件构造</a> ）和算术扩展（请参阅<a href="#Shell-Arithmetic">Shell Arithmetic</a> ）。

</li><li>Shell初始环境中存在的变量会自动导出到子进程。Bourne shell通常不会执行此操作，除非使用<code>export</code>命令。

</li><li>Bash支持“ <samp>+=</samp> '赋值运算符，它附加在左侧命名的变量的值上。

</li><li>Bash包含<small>POSIX</small>模式删除' <samp>%</samp> '，' <samp>#</samp> '，' <samp>%%</samp> '和' <samp>##</samp> '扩展可从变量值中删除前导或尾随子字符串（请参见<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>扩张<code>${#xx}</code> ，它返回的长度<code>${xx}</code>受支持（请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>扩张<code>${var:</code><var>offset</var><code>[:</code><var>length</var><code>]}</code> ，扩展为的子字符串<code>var</code>的长度值<var>length</var> ，从<var>offset</var>存在（请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>扩张<code>${var/[/]</code><var>pattern</var><code>[/</code><var>replacement</var><code>]}</code> ，与<var>pattern</var>并替换为<var>replacement</var>的价值<code>var</code>可用（请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>扩张<code>${!<var>prefix</var>*}</code>扩展，扩展为名称以“。”开头的所有shell变量的名称<var>prefix</var>可用（请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>重击有<var>indirect</var>使用变量展开<code>${!word}</code> （请参阅<a href="#Shell-Parameter-Expansion">Shell参数扩展</a> ）。

</li><li>Bash可以将位置参数扩展到<code>$9</code>使用<code>${<var>num</var>}</code> 。

</li><li><small>POSIX</small> <code>$()</code>实现了命令替换的形式（请参见<a href="#Command-Substitution">Command Substitution</a> ），并且它是Bourne shell的首选形式<code>``</code> （也为了向后兼容而实现）。

</li><li>Bash具有流程替代（请参阅<a href="#Process-Substitution">流程替代</a> ）。

</li><li>Bash自动分配变量，以提供有关当前用户的信息（ <code>UID</code> ， <code>EUID</code>和<code>GROUPS</code> ），当前主机（ <code>HOSTTYPE</code> ， <code>OSTYPE</code> ， <code>MACHTYPE</code>和<code>HOSTNAME</code> ），以及正在运行的Bash实例（ <code>BASH</code> ， <code>BASH_VERSION</code>和<code>BASH_VERSINFO</code> ）。有关详细信息，请参见<a href="#Bash-Variables">Bash变量</a> 。

</li><li>的<code>IFS</code>变量仅用于拆分扩展结果，而不用于拆分所有单词（请参见<a href="#Word-Splitting">单词拆分</a> ）。这就关闭了一个长期存在的外壳安全漏洞。

</li><li>文件名扩展括号表达式代码使用' <samp>!</samp> '和' <samp>^</samp> '取消括号之间的字符集。Bourne外壳仅使用' <samp>!</samp> '。

</li><li>Bash实现了全套<small>POSIX</small>文件名扩展操作符，包括<var>character classes</var> ， <var>equivalence classes</var>和<var>collating symbols</var> （请参阅<a href="#Filename-Expansion">文件名扩展</a> ）。

</li><li>当Bash执行以下操作时，Bash实现扩展的模式匹配功能<code>extglob</code> shell选项已启用（请参阅<a href="#Pattern-Matching">模式匹配</a> ）。

</li><li>变量和函数可以具有相同的名称； <code>sh</code>不分隔两个名称空间。

</li><li>Bash函数可以使用<code>local</code>内置的，因此可以编写有用的递归函数（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。

</li><li>前面命令的变量分配仅影响该命令，甚至影响内置函数和函数（请参见<a href="#Environment">环境</a> ）。在<code>sh</code> ，除非命令是从文件系统执行的，否则命令之前的所有变量分配都是全局的。

</li><li>Bash对指定为输入和输出重定向运算符的操作数的文件名执行文件名扩展（请参阅<a href="#Redirections">Redirections</a> ）。

</li><li>Bash包含“ <samp><></samp>重定向操作符，允许同时打开文件进行读写，而' <samp>&></samp>重定向操作符，用于将标准输出和标准错误定向到同一文件（请参阅<a href="#Redirections">重定向</a> ）。

</li><li>Bash包含“ <samp><<<</samp>重定向运算符，允许将字符串用作命令的标准输入。

</li><li>Bash实现了“ <samp>[n]<&<var>word</var></samp> '和' <samp>[n]>&<var>word</var></samp>重定向运算符，将一个文件描述符移动到另一个文件描述符。

</li><li>当Bash在重定向操作符中使用时，Bash特别对待许多文件名（请参阅<a href="#Redirections">Redirections</a> ）。

</li><li>Bash可以使用重定向操作符打开与任意机器和服务的网络连接（请参阅<a href="#Redirections">重定向</a> ）。

</li><li>的<code>noclobber</code>选项可用于避免通过输出重定向覆盖现有文件（请参见<a href="#The-Set-Builtin">The Set Builtin</a> ）。' <samp>>|</samp>重定向运算符可用于覆盖<code>noclobber</code> 。

</li><li>重击<code>cd</code>和<code>pwd</code> buildins（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）各取<samp>-L</samp>和<samp>-P</samp>在逻辑模式和物理模式之间切换的选项。

</li><li>Bash允许函数覆盖具有相同名称的内置函数，并通过<code>builtin</code>和<code>command</code>内置（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。

</li><li>的<code>command</code>内置命令允许在执行命令查找时有选择地禁用功能（请参阅<a href="#Bash-Builtins">Bash内置命令</a> ）。

</li><li>可以使用<code>enable</code>内置（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。

</li><li>重击<code>exec</code> Builtin提供了其他选项，这些选项允许用户控制传递给已执行命令的环境的内容以及该命令的第零个参数是什么（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。

</li><li>Shell函数可以使用以下命令通过环境导出到子级<code>export -f</code> （请参阅<a href="#Shell-Functions">Shell函数</a> ）。

</li><li>重击<code>export</code> ， <code>readonly</code>和<code>declare</code>内建函数可以<samp>-f</samp>用于执行shell函数的选项<samp>-p</samp>选项显示具有各种属性的变量，这些变量以可以用作shell输入的格式设置， <samp>-n</samp>删除各种变量属性的选项，以及' <samp>name=value</samp> '参数可同时设置变量属性和值。

</li><li>重击<code>hash</code>内置功能允许将名称与任意文件名相关联，即使无法通过搜索名称找到该文件名<code>$PATH</code> ，使用“ <samp>hash -p</samp> '（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。

</li><li>重击包括<code>help</code> Builtin可以快速参考shell设施（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。

</li><li>的<code>printf</code>内置可用于显示格式化的输出（请参阅<a href="#Bash-Builtins">Bash内置</a> ）。

</li><li>重击<code>read</code> Builtin（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）将读取以' <samp>\</samp>与<samp>-r</samp>选项，并将使用<code>REPLY</code>如果未提供非选项参数，则将变量作为默认值。重击<code>read</code>内建函数还接受带有<samp>-p</samp>选项，并且在给定<samp>-e</samp>选项。的<code>read</code>内置还具有其他选项来控制输入： <samp>-s</samp>该选项将关闭输入字符的读取回显， <samp>-t</samp>选项将允许<code>read</code>如果输入未在指定的秒数内到达超时，则<samp>-n</samp>选项将仅读取指定数量的字符，而不是整行，并且<samp>-d</samp>选项将一直读取到特定字符而不是换行符为止。

</li><li>的<code>return</code>内置可用于中止用<code>.</code>要么<code>source</code>内置程序（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置程序</a> ）。

</li><li>重击包括<code>shopt</code>内置，用于更好地控制shell可选功能（请参见<a href="#The-Shopt-Builtin">The Shopt Builtin</a> ），并允许在shell调用时设置和取消设置这些选项（请参见<a href="#Invoking-Bash">Invoking Bash</a> ）。

</li><li>Bash具有更多的可选行为，可通过<code>set</code>内置（请参阅<a href="#The-Set-Builtin">《内置集》</a> ）。

</li><li>' <samp>-x</samp> '（ <samp>xtrace</samp> ）选项在执行执行跟踪时显示除简单命令以外的命令（请参见<a href="#The-Set-Builtin">内置集</a> ）。

</li><li>的<code>test</code> Builtin（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）稍有不同，因为它实现了<small>POSIX</small>算法，该算法根据参数的数量指定行为。

</li><li>重击包括<code>caller</code>内置，可显示任何活动子例程调用的上下文（shell函数或使用<code>.</code>要么<code>source</code>内置）。这支持bash调试器。

</li><li>的<code>trap</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ） <code>DEBUG</code>伪信号规范，类似于<code>EXIT</code> 。用a指定的命令<code>DEBUG</code>陷阱在每个简单命令之前执行， <code>for</code>命令， <code>case</code>命令， <code>select</code>命令，所有算术<code>for</code>命令，并且在shell函数中执行第一个命令之前。的<code>DEBUG</code>除非外壳函数已向其提供陷阱，否则外壳函数不会继承该陷阱<code>trace</code>属性或<code>functrace</code>选项已使用<code>shopt</code>内置的。的<code>extdebug</code> shell选项对<code>DEBUG</code>陷阱。

<p>的<code>trap</code>内置（请参见<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ）， <code>ERR</code>伪信号规范，类似于<code>EXIT</code>和<code>DEBUG</code> 。用一个指定的命令<code>ERR</code>一个简单的命令失败后将执行trap，但有一些例外。的<code>ERR</code>陷阱不能被外壳函数继承，除非<code>-o errtrace</code>选项<code>set</code>内置启用。
</p>
<p>的<code>trap</code>内置（请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell内置</a> ） <code>RETURN</code>伪信号规范，类似于<code>EXIT</code>和<code>DEBUG</code> 。用一个指定的命令<code>RETURN</code>在执行了shell函数或shell脚本后，将在执行恢复之前执行trap <code>.</code>要么<code>source</code>返回。的<code>RETURN</code>除非外壳函数已向其提供陷阱，否则外壳函数不会继承该陷阱<code>trace</code>属性或<code>functrace</code>选项已使用<code>shopt</code>内置的。
</p>
</li><li>重击<code>type</code> Builtin更为广泛，并提供了有关它所找到名称的更多信息（请参阅<a href="#Bash-Builtins">Bash Builtins</a> ）。

</li><li>重击<code>umask</code>内置许可证<samp>-p</samp>选项以使输出以a的形式显示<code>umask</code>可以重用作为输入的<a href="#Bourne-Shell-Builtins">命令</a> （请参阅<a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a> ）。

</li><li>Bash实现了<code>csh</code>类目录堆栈，并提供<code>pushd</code> ， <code>popd</code>和<code>dirs</code>内置操作它的方法（请参阅<a href="#The-Directory-Stack">目录堆栈</a> ）。Bash还将目录堆栈显示为<code>DIRSTACK</code>外壳变量。

</li><li>交互时，Bash会在提示字符串中解释特殊的反斜杠转义字符（请参阅<a href="#Controlling-the-Prompt">控制提示</a> ）。

</li><li>Bash受限模式更有用（请参阅<a href="#The-Restricted-Shell">The Restricted Shell</a> ）； SVR4.2 shell限制模式太受限。

</li><li>的<code>disown</code> Builtin可以从内部Shell作业表中删除作业（请参阅<a href="#Job-Control-Builtins">Job Control Builtins</a> ），也可以禁止发送<code>SIGHUP</code>当外壳由于以下原因而退出时作业<code>SIGHUP</code> 。

</li><li>Bash包含许多功能，以支持针对Shell脚本的单独调试器。

</li><li>SVR4.2 Shell具有两个与权限相关的内置程序（ <code>mldmode</code>和<code>priv</code> ）不存在于Bash中。

</li><li>Bash没有<code>stop</code>要么<code>newgrp</code>内置。

</li><li>Bash不使用<code>SHACCT</code>变量或执行Shell记帐。

</li><li>SVR4.2 <code>sh</code>使用一个<code>TIMEOUT</code>像Bash使用一样的变量<code>TMOUT</code> 。

</li></ul>

<p>在<a href="#Bash-Features">Bash功能中</a>可以找到<a href="#Bash-Features">Bash</a>独有的更多功能。
</p>

<a name="Implementation-Differences-From-The-SVR4_002e2-Shell"></a>
<h3 class="appendixsec">B.1与SVR4.2 Shell的实现差异</h3>

<p>由于Bash是全新的实现，因此它不受SVR4.2 Shell的许多限制。例如：</p>
<ul>
<li>当重定向到外壳控制结构或从中退出时，Bash不会派生子外壳。 <code>if</code>要么<code>while</code>声明。

</li><li>Bash不允许使用不平衡的报价。SVR4.2 shell将在以下位置静默插入所需的结束语<code>EOF</code>在某些情况下。这可能是一些难以发现的错误的原因。

</li><li>SVR4.2 Shell使用基于陷阱的巴洛克式内存管理方案<code>SIGSEGV</code> 。如果外壳程序是从以下进程启动的<code>SIGSEGV</code>被阻止（例如，通过使用<code>system()</code> C库函数调用），它的行为异常严重。

</li><li>为了安全起见，在未使用SVR4.2 shell的情况下调用SVR4.2 shell <samp>-p</samp>选项，如果它们小于某个魔术阈值（通常为100），则会更改其实际有效<small>UID</small>和<small>GID</small> 。这可能会导致意外结果。

</li><li>SVR4.2 Shell不允许用户捕获<code>SIGSEGV</code> ， <code>SIGALRM</code> ， 要么<code>SIGCHLD</code> 。

</li><li>SVR4.2 Shell不允许<code>IFS</code> ， <code>MAILCHECK</code> ， <code>PATH</code> ， <code>PS1</code> ， 要么<code>PS2</code>要设置的变量。

</li><li>SVR4.2外壳将' <samp>^</samp> '等同于' <samp>|</samp> '。

</li><li>Bash在调用时允许多个选项参数（ <code>-x -v</code> ）; SVR4.2 Shell仅允许一个选项参数（ <code>-xv</code> ）。实际上，如果第二个参数以“' <samp>-</samp> '。

</li><li>如果任何内置失败，则SVR4.2 shell退出脚本； Bash仅在<small>POSIX</small>特殊内置程序之一失败时才退出脚本，并且仅在某些失败时才退出脚本，如<small>POSIX</small>标准中所列举的那样。

</li><li>当SVR4.2 shell被调用为<code>jsh</code> （打开工作控制）。
</li></ul>

<hr>
<a name="GNU-Free-Documentation-License"></a>
<div class="header">
<p>下一篇： <a href="#Indexes" rel="next" accesskey="n">索引</a> ，上一篇： <a href="#Major-Differences-From-The-Bourne-Shell" rel="prev" accesskey="p">与Bourne Shell的主要区别</a> ，上： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Free-Documentation-License-1"></a>
<h2 class="appendix">附录C GNU自由文档许可证</h2>

<div align="center">1.3版，2008年11月3日</div>

<div class="display">
<pre class="display">Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<a href="http://fsf.org/">http://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol start="0">
<li>前言<p>本许可的目的是免费提供手册，教科书或其他实用且有用的文档： <em>自由</em> ，以确保每个人都有有效的自由，无论是否进行商业或非商业修改，都可以对其进行复制和重新分发。其次，本许可证为作者和出版商保留了一种因其作品而获得好评的方式，同时不被视为对他人所做的修改负责。
</p>
<p>该许可是一种“版权所有”，这意味着该文档的衍生作品本身必须在相同意义上是免费的。它是GNU通用公共许可证的补充，GNU通用公共许可证是专为自由软件设计的Copyleft许可证。
</p>
<p>我们设计此许可证是为了将其用于免费软件的手册，因为免费软件需要免费的文档：免费程序应随附手册，以提供与软件相同的自由。但是本许可不限于软件手册；它可以用于任何文本作品，而无论其主题是什么，或者它是否作为印刷书籍出版。我们建议您将此许可证主要用于目的是作为指导或参考的作品。
</p>
</li><li>适用性和定义<p>本许可适用于任何形式的任何手册或其他作品，其中包含版权所有者发布的声明，声明其可以根据本许可的条款进行分发。此类通知授予了全球范围内的免版税使用许可，期限不限，可以在此处所述的条件下使用该作品。下面的“文档”是指任何此类手册或作品。任何公众人士都是被许可人，称呼为“您”。如果您按照版权法要求许可的方式复制，修改或分发作品，则您接受许可。
</p>
<p>文档的“修改版本”是指包含文档或文档一部分的任何作品，无论是逐字复制还是经过修改和/或翻译成另一种语言。
</p>
<p>“第二部分”是本文档的命名附录或最重要的部分，专门处理本文档的出版者或作者与本文档的整体主题（或相关事宜）之间的关系，不包含任何可能直接涉及的内容。在整个主题范围内。（因此，如果该文档部分是一本数学教科书，那么第二部分可能不会解释任何数学。）这种关系可以是与主题或相关问题的历史联系，也可以是关于它们的法律，商业，哲学，伦理或政治立场。
</p>
<p>“不变部分”是某些二级部分，在其声明中指出，该文件的标题与不变部分的标题相同，即该文件是根据本许可发布的。如果某个部分不符合上面对“辅助”的定义，则不允许将其指定为“不变式”。该文档可能包含零个不变部分。如果文档未标识任何不变节，则没有任何不变节。
</p>
<p>“封面文字”是某些简短的文本段落，在声明中指出该文档是根据本许可发布的，这些文字作为“封面文字”或“封面文字”列出。“封面文本”最多可以包含5个字，“封面文本”最多可以包含25个字。
</p>
<p>文档的“透明”副本是指一种机器可读的副本，以其规格可供大众使用的格式表示，适用于使用通用文本编辑器或（对于由像素组成的图像）通用颜料进行直接修改的文档程序或（用于绘图的）一些广泛使用的绘图编辑器，并且适合于输入文本格式化程序或自动转换为适合输入到文本格式化程序的多种格式。以其他方式透明的文件格式制作的副本，其标记或没有标记的安排，可以阻止或阻止读者的后续修改，则该副本不是透明的。如果用于大量文本，则图像格式不是“透明”的。非“透明”的副本称为“不透明”。
</p>
<p>适用于透明副本的格式的示例包括不带标记的纯<small>ASCII</small> ，Texinfo输入格式，LaTeX输入格式，使用公开可用的<acronym>DTD的</acronym> <acronym>SGML</acronym>或<acronym>XML</acronym>以及设计用于人为修改的符合标准的简单<acronym>HTML</acronym> ，PostScript或<acronym>PDF</acronym> 。透明图像格式的示例包括<acronym>PNG</acronym> ， <acronym>XCF</acronym>和<acronym>JPG</acronym> 。不透明格式包括只能由专有文字处理器， <acronym>SGML</acronym>或<acronym>XML</acronym>读取和编辑的专有格式，而<acronym>SGML</acronym>或<acronym>XML</acronym>通常不提供<acronym>DTD</acronym>和/或处理工具，以及某些文字处理器为某些文字处理器生成的机器生成的<acronym>HTML</acronym> ，PostScript或<acronym>PDF</acronym>仅用于输出目的。
</p>
<p>“标题页”对于印刷书籍而言，是指标题页本身，以及以下用于保持本许可证要求在标题页中显示的材料的以下页面。对于没有此类标题页的格式的作品，“标题页”是指在文本正文开头之前，靠近作品标题最突出外观的文本。
</p>
<p>“发布者”是指向公众分发文档副本的任何个人或实体。
</p>
<p>“标题为XYZ”一节是指文档的命名子单元，其标题恰好是XYZ或在括号中包含XYZ的文字，后面是将XYZ转换为另一种语言的文字。（此处XYZ代表以下提到的特定部分名称，例如“致谢”，“奉献”，“认可”或“历史记录”。）在修改文档时，要“保留此部分的标题”，则意味着根据此定义，该部分仍为“已命名的XYZ”部分。
</p>
<p>该文件的声明旁边可能包含“免责声明”，该声明指出本许可适用于该文件。这些保修免责声明被视为已包含在本许可中，但仅用于免责声明：这些保修免责声明可能具有的任何其他暗示都是无效的，并且对本许可的含义没有任何影响。
</p>
</li><li>VERBATIM复制<p>您可以在任何媒介中以商业或非商业方式复制和分发本文档，但前提是本许可，版权声明和声明本许可适用于本文档的许可声明均以所有副本形式复制，并且您不添加任何其他条件符合本许可的规定。您不得使用技术措施来阻碍或控制您复制或分发的副本的阅读或进一步复制。但是，您可以接受赔偿以换取副本。如果分发足够多的副本，则还必须遵循第3节中的条件。
</p>
<p>您还可以在上述相同条件下出借副本，并可以公开展示副本。
</p>
</li><li>大量复制<p>如果您发布文档的印刷副本（或通常具有印刷封面的介质副本），且编号超过100，并且文档的许可通知书要求包含封面文字，则必须将这些副本随附在清晰可见的所有文档中封面文字：封面上的封面文字和封底上的封面文字。两种封面都必须清楚，清楚地标识您是这些副本的发行者。封面必须显示完整的标题，标题中的所有单词均应同样醒目且可见。您还可以在封面上添加其他材料。只要封面保留了文档标题并满足这些条件，则仅对封面进行更改即可在其他方面被视为逐字复印。
</p>
<p>如果任何一个封面所需的文本量太大，无法清晰地容纳，则应将列出的第一个（合理合理的数量）放在实际的封面上，然后将其余部分继续放在相邻的页面上。
</p>
<p>如果您发布或分发的Opaque文档副本数量超过100，则必须在每份Opaque副本中包含机器可读的透明副本，或者在每份Opaque副本中或其中声明一个计算机网络位置，通用网络将从该位置开始使用public可以使用公共标准网络协议下载完整的文档透明副本，而无需添加任何材料。如果使用后一种选项，则在开始批量分发不透明副本时，必须采取合理的审慎步骤，以确保该透明副本将在指定位置保持可访问的状态，直到您上一次分发不透明副本至少一年之后。该版本的不透明副本（直接或通过您的代理商或零售商）向公众发布。
</p>
<p>要求（但不是必须）在重新分发大量副本之前，与文档作者保持良好联系，以便他们有机会为您提供文档的更新版本。
</p>
</li><li>修改方式<p>您可以在上述第2节和第3节的条件下复制和分发本文档的修改版本，前提是您严格按照本许可协议发布修改版本，而修改版本则充当文档的角色，从而许可对本文档的分发和修改拥有副本的修改版本。此外，您必须在修改后的版本中执行以下操作：</p>
<ol type="A" start="1">
<li>在标题页（和封面，如果有的话）中使用与本文档以及先前版本（如果有的话，应在文档的“历史记录”部分中列出）不同的标题。如果该版本的原始发行者给予许可，则可以使用与先前版本相同的标题。

</li><li>在标题页上列出作者，一个或多个负责修改版本著作权的作者或实体，以及至少五名文档的主要作者（所有主要作者，如果少于五），除非他们使您脱离此要求。

</li><li>在“标题”页面上声明修改版本的发布者的名称，作为发布者。

</li><li>保留文档的所有版权声明。

</li><li>在其他版权声明旁边添加用于修改的适当版权声明。

</li><li>在版权声明之后，立即包含一个许可声明，以下面的附录中所示的形式，向公众授予根据本许可条款使用修改版的许可。

</li><li>在该许可证声明中保留不可变部分的完整列表以及文档的许可证声明中提供的必需封面文字。

</li><li>随附本许可证的未更改副本。

</li><li>保留标题为“历史”的部分，保留其标题，并在其上添加至少说明标题页上给出的修改版本的标题，年份，新作者和发行者的项目。如果文档中没有标题为“历史记录”的部分，请在其标题页上创建一个说明文档的标题，年份，作者和出版者的内容，然后添加一项描述上一句中所述的修改版本。

</li><li>保留文档中给出的网络位置（如果有），以供公众访问文档的透明副本，同样，保留文档中给出的基于其以前版本的网络位置。这些可以放在“历史记录”部分中。对于在文档本身之前至少四年出版的作品，或者如果其所指版本的原始发行者给予许可，您可以省略其网络位置。

</li><li>对于标题为“致谢”或“奉献”的任何部分，请保留本部分的标题，并在本部分中保留其中给出的每个贡献者致谢和/或奉献的所有内容和基调。

</li><li>保留文档的所有不变部分，其文本和标题保持不变。章节编号或同等编号不视为章节标题的一部分。

</li><li>删除任何标题为“背书”的部分。这样的部分可能不包含在修改版本中。

</li><li>请勿将任何现有部分的标题重命名为“背书”，或与任何不变部分的标题冲突。

</li><li>保留所有保修免责声明。
</li></ol>

<p>如果修改后的版本包括新的前节或附录，这些节或附录符合第二节的规定，并且不包含从文档中复制的材料，则可以选择将其中的部分或全部指定为不变的。为此，请将其标题添加到“修改版本”许可声明中的“不变部分”列表中。这些标题必须与任何其他节标题不同。
</p>
<p>您可以添加标题为“背书”的部分，但其中仅包含各方对您的修改版本的背书，例如，同行评审声明或该文本已被组织批准为标准的权威定义。
</p>
<p>您可以在修改版本的封面文本列表的末尾添加最多5个单词的段落作为“封面文本”，以及最多25个单词的段落作为“封面文本”。任何一个实体（或通过它们的安排）都只能添加“封面文字”和“封面文字”中的一个段落。如果文档已经包含同一封面的封面文字，该文字是您先前添加的或由您代表的同一实体做出的安排而添加的，则不得添加其他文字；但是您可以在添加了旧版本的以前的发布者的明确许可下替换旧版本。
</p>
<p>本文档的作者和发行者未获得本许可证的许可，不得使用其名称进行宣传或主张或暗示认可任何修改版本。
</p>
</li><li>合并文件<p>您可以根据上文第4节中针对修改版本定义的条款，将文档与根据本许可发布的其他文档进行组合，但前提是您必须将所有未经修改的原始文档的所有不变部分都包含在其中，并列出所有这些文档作为您许可协议中合并工作的不变部分，并保留其所有保修免责声明。
</p>
<p>合并后的作品仅包含此许可的一个副本，并且多个相同的不变部分可用一个副本代替。如果存在多个具有相同名称但内容不同的不变部分，请在该部分的末尾加上括号，在该部分的末尾添加原始作者或发布者的名称（如果已知），以使每个此类的标题唯一。唯一编号。对合并作品的许可声明中不变部分列表中的部分标题进行相同的调整。
</p>
<p>在组合中，必须将各种原始文档中标题为“ History”的任何部分组合在一起，组成一个标题为“ History”的部分；同样，将标题为“致谢”的所有部分以及标题为“奉献”的任何部分组合在一起。您必须删除所有标题为“背书”的部分。
</p>
</li><li>文件收集<p>您可以收集由本许可协议下发布的文档和其他文档组成的集合，并在该文档中将其替换为各个文档中包含的单个副本，前提是您遵守本许可协议的规定。在所有其他方面逐字逐字复印。
</p>
<p>您可以从此类集合中提取单个文档，并根据本许可证单独分发它，前提是您将本许可证的副本插入提取的文档中，并且在与该文档的逐字复制有关的所有其他方面遵守本许可证。
</p>
</li><li>独立工作的集合<p>如果文件或衍生产品的版权不用于限制合法权利，则该文件或其衍生物与其他单独或独立的文件或作品在存储或分发介质中或在其上的汇编将被称为“汇总”。汇编用户的数量超出了个人作品的许可范围。当文档包含在汇总中时，本许可不适用于汇总中的其他作品，而这些作品本身不是文档的衍生作品。
</p>
<p>如果第3节的封面文字要求适用于本文档的这些副本，则如果该文档少于全部汇总的一半，则可以将文档的封面文字放在汇总中将文档括起来的封面上，或者如果文档为电子形式，则具有等同的封面电子形式。否则，它们必须出现在将整个集合括起来的印刷封面上。
</p>
</li><li>翻译<p>翻译被视为一种修改，因此您可以根据第4节的条款分发文档的翻译。用翻译替换不变部分需要其版权所有者的特殊许可，但是除了这些不变部分的原始版本之外，您还可以包括部分或全部不变部分的翻译。您可以在本文档以及所有保修免责声明中包括本许可，所有许可声明的翻译，但前提是您还包括本许可的原始英文版本以及这些声明和免责声明的原始版本。如果本许可的翻译版本与原始版本或声明或免责声明之间存在分歧，则以原始版本为准。
</p>
<p>如果文档中某节的标题为“致谢”，“奉献”或“历史记录”，则保留其标题（第1节）的要求（第4节）通常需要更改实际标题。
</p>
</li><li>终止<p>除非本许可明确规定，否则您不得复制，修改，再许可或分发文档。否则，任何尝试复制，修改，再许可或分发的尝试均无效，并且将自动终止您在本许可下的权利。
</p>
<p>但是，如果您停止所有对本许可的违反，则（a）临时恢复特定版权持有者的许可，除非且直到版权持有者明确终止并最终终止您的许可为止；以及（b）如果版权持有者失败，则永久地在停止交易发生后的60天之内通过某种合理的方式通知您违规行为。
</p>
<p>此外，如果版权所有者以某种合理的方式通知您有关侵权的信息，那么该版权所有者的许可将被永久恢复，这是您第一次从该版权所有者那里收到针对任何作品的违反本许可的通知，并且您会在收到通知后的30天内纠正违规行为。
</p>
<p>根据本节终止您的权利并不会终止根据本许可从您那里收到副本或权利的各方的许可。如果您的权利已被终止且未永久恢复，则收到部分或全部相同材料的副本将不会赋予您使用该材料的任何权利。
</p>
</li><li>本许可证的未来修订<p>自由软件基金会可能会不时发布GNU自由文档许可证的新修订版。这样的新版本将在本质上与当前版本相似，但是可能在细节上有所不同以解决新问题或疑虑。参见<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a> 。</p>
<p>许可证的每个版本都有一个不同的版本号。如果文档指定适用于此许可的特定编号版本“或任何更高版本”，则您可以选择遵循该指定版本或已发布的任何更高版本的条款和条件（不作为草稿）由自由软件基金会提供。如果文档未指定此许可的版本号，则可以选择自由软件基金会曾经发布的任何版本（而不是草稿）。如果文档指定代理可以决定可以使用此许可证的将来版本，则该代理对版本的公开接受声明将永久授权您为文档选择该版本。
</p>
</li><li>许可<p>“大型多作者协作网站”（或“ MMC网站”）是指发布版权作品并为任何人提供编辑这些作品的重要便利的任何万维网服务器。任何人都可以编辑的公共Wiki是此类服务器的示例。网站中包含的“大型多作者合作”（或“ MMC”）是指在MMC网站上发布的任何受版权保护的作品集。
</p>
<p>“ CC-BY-SA”指由知识共享公司发行的知识共享署名-相同方式共享3.0许可，该公司是一家非营利性公司，主要营业地点位于加利福尼亚州旧金山，并且该版本的未来copyleft版本该组织发布的许可。
</p>
<p>“合并”是指作为另一文档的一部分全部或部分发布或重新发布文档。
</p>
<p>如果MMC已根据本许可获得许可，并且所有根据该许可在MMC以外的其他地方首次发行并随后全部或部分合并到MMC中的作品，则该MMC是“有资格获得许可的”，（1）没有封面文字或不变部分，因此（2）在2008年11月1日之前合并。
</p>
<p>MMC站点的运营商可以在2009年8月1日之前的任何时间在CC-BY-SA之下的同一站点上重新发布该站点中包含的MMC，前提是该MMC有资格获得许可。
</p>
</li></ol>

<a name="ADDENDUM_003a-How-to-use-this-License-for-your-documents"></a>
<h3 class="heading">附录：如何对您的文档使用此许可证</h3>

<p>要在您编写的文档中使用此许可，请在该文档中包括一个许可副本，并在标题页后放置以下版权和许可声明：</p>
<div class="smallexample">
<pre class="smallexample">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>如果您有不变的部分，封面文本和封面文本，则将“ with…Texts。”行替换为：</p>
<div class="smallexample">
<pre class="smallexample">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>如果您有不带封面文本的不变部分，或这三个部分的其他组合，请合并这两种选择以适应情况。
</p>
<p>如果您的文档包含不平凡的程序代码示例，我们建议您根据自由软件许可（例如GNU通用公共许可）的选择，并行发布这些示例，以允许它们在自由软件中使用。
</p>


<hr>
<a name="Indexes"></a>
<div class="header">
<p>上一篇： <a href="#GNU-Free-Documentation-License" rel="prev" accesskey="p">GNU自由文档许可证</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Indexes-1"></a>
<h2 class="appendix">附录D索引</h2>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Builtin-Index" accesskey="1">内置索引</a> ：</td><td>  </td><td align="left" valign="top">Bash内置命令的索引。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reserved-Word-Index" accesskey="2">保留字索引</a> ：</td><td>  </td><td align="left" valign="top">Bash保留字的索引。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variable-Index" accesskey="3">可变索引</a> ：</td><td>  </td><td align="left" valign="top">快速参考可帮助您找到所需的变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Function-Index" accesskey="4">功能指标</a> ：</td><td>  </td><td align="left" valign="top">可绑定Readline函数的索引。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Concept-Index" accesskey="5">概念索引</a> ：</td><td>  </td><td align="left" valign="top">本手册中描述的概念的常规索引。
</td></tr>
</tbody></table>

<hr>
<a name="Builtin-Index"></a>
<div class="header">
<p>下一页： <a href="#Reserved-Word-Index" rel="next" accesskey="n">保留字索引</a> ，上一页： <a href="#Indexes" rel="up" accesskey="u">索引</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Index-of-Shell-Builtin-Commands"></a>
<h3 class="appendixsec">D.1 Shell内置命令索引</h3>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Builtin-Index_bt_symbol-1"><b>。</b></a>
   
<a class="summary-letter" href="#Builtin-Index_bt_symbol-2"><b>：</b></a> <a class="summary-letter" href="#Builtin-Index_bt_symbol-3"><b>[</b></a>
   
<br>
<a class="summary-letter" href="#Builtin-Index_bt_letter-A"><b>A</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-B"><b>B</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-C"><b>C</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-D"><b>D</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-E"><b>E</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-F"><b>F</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-G"><b>G</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-H"><b>H</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-J"><b>J</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-K"><b>K</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-L"><b>L</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-M"><b>M</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-P"><b>P</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-R"><b>R</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-S"><b>S</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-T"><b>T</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-U"><b>U</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-W"><b>W</b></a>
   
</td></tr></tbody></table>
<table class="index-bt" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_symbol-1">。</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002e"><code>.</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_symbol-2">：</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a"><code>:</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_symbol-3">[</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b"><code>[</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-alias"><code>alias</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-bg"><code>bg</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bind"><code>bind</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-break"><code>break</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-builtin"><code>builtin</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-caller"><code>caller</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cd"><code>cd</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command"><code>command</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compgen"><code>compgen</code></a> ：</td><td> </td><td valign="top"><a href="#Programmable-Completion-Builtins">可编程完成内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete"><code>complete</code></a> ：</td><td> </td><td valign="top"><a href="#Programmable-Completion-Builtins">可编程完成内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compopt"><code>compopt</code></a> ：</td><td> </td><td valign="top"><a href="#Programmable-Completion-Builtins">可编程完成内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continue"><code>continue</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-declare"><code>declare</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dirs"><code>dirs</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Stack-Builtins">目录堆栈内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-disown"><code>disown</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-echo"><code>echo</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enable"><code>enable</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eval"><code>eval</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exec"><code>exec</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit"><code>exit</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-export"><code>export</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-fc"><code>fc</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-History-Builtins">重击历史内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fg"><code>fg</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-getopts"><code>getopts</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hash"><code>hash</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-help"><code>help</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history"><code>history</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-History-Builtins">重击历史内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-J">Ĵ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-jobs"><code>jobs</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-K">ķ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill"><code>kill</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-let"><code>let</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-local"><code>local</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-logout"><code>logout</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-mapfile"><code>mapfile</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-popd"><code>popd</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Stack-Builtins">目录堆栈内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf"><code>printf</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pushd"><code>pushd</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Stack-Builtins">目录堆栈内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pwd"><code>pwd</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-read"><code>read</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readarray"><code>readarray</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readonly"><code>readonly</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return"><code>return</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-set"><code>set</code></a> ：</td><td> </td><td valign="top"><a href="#The-Set-Builtin">内置套件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shift"><code>shift</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shopt"><code>shopt</code></a> ：</td><td> </td><td valign="top"><a href="#The-Shopt-Builtin">内置Shopt</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source"><code>source</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suspend"><code>suspend</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-test"><code>test</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-times"><code>times</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trap"><code>trap</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-type"><code>type</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-typeset"><code>typeset</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ulimit"><code>ulimit</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-umask"><code>umask</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unalias"><code>unalias</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Builtins">重击内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unset"><code>unset</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Builtins">Bourne Shell Builtins</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Builtin-Index_bt_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-wait"><code>wait</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Builtins">作业控制内置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Builtin-Index_bt_symbol-1"><b>。</b></a>
   
<a class="summary-letter" href="#Builtin-Index_bt_symbol-2"><b>：</b></a> <a class="summary-letter" href="#Builtin-Index_bt_symbol-3"><b>[</b></a>
   
<br>
<a class="summary-letter" href="#Builtin-Index_bt_letter-A"><b>A</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-B"><b>B</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-C"><b>C</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-D"><b>D</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-E"><b>E</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-F"><b>F</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-G"><b>G</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-H"><b>H</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-J"><b>J</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-K"><b>K</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-L"><b>L</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-M"><b>M</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-P"><b>P</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-R"><b>R</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-S"><b>S</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-T"><b>T</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-U"><b>U</b></a> <a class="summary-letter" href="#Builtin-Index_bt_letter-W"><b>W</b></a>
   
</td></tr></tbody></table>

<hr>
<a name="Reserved-Word-Index"></a>
<div class="header">
<p>下一篇： <a href="#Variable-Index" rel="next" accesskey="n">可变索引</a> ，上一篇： <a href="#Builtin-Index" rel="prev" accesskey="p">内置索引</a> ，上一篇： <a href="#Indexes" rel="up" accesskey="u">索引</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Index-of-Shell-Reserved-Words"></a>
<h3 class="appendixsec">D.2 Shell保留字索引</h3>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-2"><b>[</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-3"><b>]</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-4"><b>{</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-5"><b>}</b></a>
   
<br>
<a class="summary-letter" href="#Reserved-Word-Index_rw_letter-C"><b>C</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-D"><b>D</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-E"><b>E</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-F"><b>F</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-I"><b>I</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-S"><b>S</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-T"><b>T</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-U"><b>U</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-W"><b>W</b></a>
   
</td></tr></tbody></table>
<table class="index-rw" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_symbol-1">！</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021"><code>!</code></a> ：</td><td> </td><td valign="top"><a href="#Pipelines">流水线</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_symbol-2">[</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_005b"><code>[[</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_symbol-3">]</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005d_005d"><code>]]</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_symbol-4">{</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007b"><code>{</code></a> ：</td><td> </td><td valign="top"><a href="#Command-Grouping">命令分组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_symbol-5">}</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007d"><code>}</code></a> ：</td><td> </td><td valign="top"><a href="#Command-Grouping">命令分组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-case"><code>case</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-do"><code>do</code></a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-done"><code>done</code></a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-elif"><code>elif</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-else"><code>else</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-esac"><code>esac</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-fi"><code>fi</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for"><code>for</code></a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function"><code>function</code></a> ：</td><td> </td><td valign="top"><a href="#Shell-Functions">外壳功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-if"><code>if</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in"><code>in</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-select"><code>select</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-then"><code>then</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time"><code>time</code></a> ：</td><td> </td><td valign="top"><a href="#Pipelines">流水线</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-until"><code>until</code></a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Reserved-Word-Index_rw_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-while"><code>while</code></a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-2"><b>[</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-3"><b>]</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-4"><b>{</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_symbol-5"><b>}</b></a>
   
<br>
<a class="summary-letter" href="#Reserved-Word-Index_rw_letter-C"><b>C</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-D"><b>D</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-E"><b>E</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-F"><b>F</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-I"><b>I</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-S"><b>S</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-T"><b>T</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-U"><b>U</b></a> <a class="summary-letter" href="#Reserved-Word-Index_rw_letter-W"><b>W</b></a>
   
</td></tr></tbody></table>

<hr>
<a name="Variable-Index"></a>
<div class="header">
<p>下一篇： <a href="#Function-Index" rel="next" accesskey="n">函数索引</a> ，上一篇： <a href="#Reserved-Word-Index" rel="prev" accesskey="p">保留字索引</a> ，上一篇： <a href="#Indexes" rel="up" accesskey="u">索引</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Parameter-and-Variable-Index"></a>
<h3 class="appendixsec">D.3参数和变量索引</h3>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Variable-Index_vr_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Variable-Index_vr_symbol-2"><b>＃</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-3"><b>$</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-4"><b>*</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-5"><b>-</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-6"><b>0</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-7"><b>？</b></a>
   
<a class="summary-letter" href="#Variable-Index_vr_symbol-8"><b>@</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-9"><b>_</b></a>
   
<br>
<a class="summary-letter" href="#Variable-Index_vr_letter-A"><b>A</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-B"><b>B</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-C"><b>C</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-D"><b>D</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-E"><b>E</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-F"><b>F</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-G"><b>G</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-H"><b>H</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-I"><b>I</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-K"><b>K</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-L"><b>L</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-M"><b>M</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-O"><b>O</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-P"><b>P</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-R"><b>R</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-S"><b>S</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-T"><b>T</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-U"><b>U</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-V"><b>V</b></a>
   
</td></tr></tbody></table>
<table class="index-vr" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-1">！</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-1"><code>!</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-2">＃</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023"><code>#</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-3">$</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024"><code>$</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0021"><code>$!</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0023"><code>$#</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0024"><code>$$</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002a"><code>$*</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002d"><code>$-</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_00240"><code>$0</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_003f"><code>$?</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0040"><code>$@</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_005f"><code>$_</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-4">*</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a"><code>*</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-5">--</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d"><code>-</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-6">0</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-0"><code>0</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-7">？</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f"><code>?</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-8">@</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040"><code>@</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_symbol-9">_</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005f"><code>_</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-auto_005fresume"><code>auto_resume</code></a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Variables">作业控制变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH"><code>BASH</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASHOPTS"><code>BASHOPTS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASHPID"><code>BASHPID</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fALIASES"><code>BASH_ALIASES</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fARGC"><code>BASH_ARGC</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fARGV"><code>BASH_ARGV</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fARGV0"><code>BASH_ARGV0</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fCMDS"><code>BASH_CMDS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fCOMMAND"><code>BASH_COMMAND</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fCOMPAT"><code>BASH_COMPAT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fENV"><code>BASH_ENV</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fEXECUTION_005fSTRING"><code>BASH_EXECUTION_STRING</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fLINENO"><code>BASH_LINENO</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fLOADABLES_005fPATH"><code>BASH_LOADABLES_PATH</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fREMATCH"><code>BASH_REMATCH</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fSOURCE"><code>BASH_SOURCE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fSUBSHELL"><code>BASH_SUBSHELL</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fVERSINFO"><code>BASH_VERSINFO</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fVERSION"><code>BASH_VERSION</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASH_005fXTRACEFD"><code>BASH_XTRACEFD</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bell_002dstyle"><code>bell-style</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bind_002dtty_002dspecial_002dchars"><code>bind-tty-special-chars</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blink_002dmatching_002dparen"><code>blink-matching-paren</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-CDPATH"><code>CDPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CHILD_005fMAX"><code>CHILD_MAX</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-colored_002dcompletion_002dprefix"><code>colored-completion-prefix</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-colored_002dstats"><code>colored-stats</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COLUMNS"><code>COLUMNS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comment_002dbegin"><code>comment-begin</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion_002ddisplay_002dwidth"><code>completion-display-width</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion_002dignore_002dcase"><code>completion-ignore-case</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion_002dmap_002dcase"><code>completion-map-case</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion_002dprefix_002ddisplay_002dlength"><code>completion-prefix-display-length</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion_002dquery_002ditems"><code>completion-query-items</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMPREPLY"><code>COMPREPLY</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fCWORD"><code>COMP_CWORD</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fKEY"><code>COMP_KEY</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fLINE"><code>COMP_LINE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fPOINT"><code>COMP_POINT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fTYPE"><code>COMP_TYPE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fWORDBREAKS"><code>COMP_WORDBREAKS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMP_005fWORDS"><code>COMP_WORDS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert_002dmeta"><code>convert-meta</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COPROC"><code>COPROC</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-DIRSTACK"><code>DIRSTACK</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-disable_002dcompletion"><code>disable-completion</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-echo_002dcontrol_002dcharacters"><code>echo-control-characters</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-editing_002dmode"><code>editing-mode</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EMACS"><code>EMACS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-emacs_002dmode_002dstring"><code>emacs-mode-string</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enable_002dbracketed_002dpaste"><code>enable-bracketed-paste</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enable_002dkeypad"><code>enable-keypad</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ENV"><code>ENV</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EPOCHREALTIME"><code>EPOCHREALTIME</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EPOCHSECONDS"><code>EPOCHSECONDS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EUID"><code>EUID</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EXECIGNORE"><code>EXECIGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expand_002dtilde"><code>expand-tilde</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-FCEDIT"><code>FCEDIT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FIGNORE"><code>FIGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FUNCNAME"><code>FUNCNAME</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FUNCNEST"><code>FUNCNEST</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-GLOBIGNORE"><code>GLOBIGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GROUPS"><code>GROUPS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-histchars"><code>histchars</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTCMD"><code>HISTCMD</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTCONTROL"><code>HISTCONTROL</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTFILE"><code>HISTFILE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTFILESIZE"><code>HISTFILESIZE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTIGNORE"><code>HISTIGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dpreserve_002dpoint"><code>history-preserve-point</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dsize"><code>history-size</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTSIZE"><code>HISTSIZE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HISTTIMEFORMAT"><code>HISTTIMEFORMAT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HOME"><code>HOME</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-horizontal_002dscroll_002dmode"><code>horizontal-scroll-mode</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HOSTFILE"><code>HOSTFILE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HOSTNAME"><code>HOSTNAME</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HOSTTYPE"><code>HOSTTYPE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-IFS"><code>IFS</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNOREEOF"><code>IGNOREEOF</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002dmeta"><code>input-meta</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-INPUTRC"><code>INPUTRC</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-INSIDE_005fEMACS"><code>INSIDE_EMACS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-isearch_002dterminators"><code>isearch-terminators</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-K">ķ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-keymap"><code>keymap</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-LANG"><code>LANG</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fALL"><code>LC_ALL</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fCOLLATE"><code>LC_COLLATE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fCTYPE"><code>LC_CTYPE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fMESSAGES"><code>LC_MESSAGES</code></a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fMESSAGES-1"><code>LC_MESSAGES</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fNUMERIC"><code>LC_NUMERIC</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fTIME"><code>LC_TIME</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LINENO"><code>LINENO</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LINES"><code>LINES</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-MACHTYPE"><code>MACHTYPE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAIL"><code>MAIL</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAILCHECK"><code>MAILCHECK</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAILPATH"><code>MAILPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAPFILE"><code>MAPFILE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mark_002dmodified_002dlines"><code>mark-modified-lines</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mark_002dsymlinked_002ddirectories"><code>mark-symlinked-directories</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match_002dhidden_002dfiles"><code>match-hidden-files</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-menu_002dcomplete_002ddisplay_002dprefix"><code>menu-complete-display-prefix</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-meta_002dflag"><code>meta-flag</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-OLDPWD"><code>OLDPWD</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OPTARG"><code>OPTARG</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OPTERR"><code>OPTERR</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OPTIND"><code>OPTIND</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OSTYPE"><code>OSTYPE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002dmeta"><code>output-meta</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-page_002dcompletions"><code>page-completions</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PATH"><code>PATH</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PIPESTATUS"><code>PIPESTATUS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIXLY_005fCORRECT"><code>POSIXLY_CORRECT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PPID"><code>PPID</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROMPT_005fCOMMAND"><code>PROMPT_COMMAND</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROMPT_005fDIRTRIM"><code>PROMPT_DIRTRIM</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PS0"><code>PS0</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PS1"><code>PS1</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PS2"><code>PS2</code></a> ：</td><td> </td><td valign="top"><a href="#Bourne-Shell-Variables">伯恩壳变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PS3"><code>PS3</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PS4"><code>PS4</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PWD"><code>PWD</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-RANDOM"><code>RANDOM</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-READLINE_005fLINE"><code>READLINE_LINE</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-READLINE_005fPOINT"><code>READLINE_POINT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-REPLY"><code>REPLY</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-revert_002dall_002dat_002dnewline"><code>revert-all-at-newline</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-SECONDS"><code>SECONDS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL"><code>SHELL</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELLOPTS"><code>SHELLOPTS</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHLVL"><code>SHLVL</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show_002dall_002dif_002dambiguous"><code>show-all-if-ambiguous</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show_002dall_002dif_002dunmodified"><code>show-all-if-unmodified</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show_002dmode_002din_002dprompt"><code>show-mode-in-prompt</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-skip_002dcompleted_002dtext"><code>skip-completed-text</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAIN"><code>TEXTDOMAIN</code></a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAINDIR"><code>TEXTDOMAINDIR</code></a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TIMEFORMAT"><code>TIMEFORMAT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TMOUT"><code>TMOUT</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TMPDIR"><code>TMPDIR</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-UID"><code>UID</code></a> ：</td><td> </td><td valign="top"><a href="#Bash-Variables">重击变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Variable-Index_vr_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-vi_002dcmd_002dmode_002dstring"><code>vi-cmd-mode-string</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vi_002dins_002dmode_002dstring"><code>vi-ins-mode-string</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-visible_002dstats"><code>visible-stats</code></a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Variable-Index_vr_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Variable-Index_vr_symbol-2"><b>＃</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-3"><b>$</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-4"><b>*</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-5"><b>-</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-6"><b>0</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-7"><b>？</b></a>
   
<a class="summary-letter" href="#Variable-Index_vr_symbol-8"><b>@</b></a> <a class="summary-letter" href="#Variable-Index_vr_symbol-9"><b>_</b></a>
   
<br>
<a class="summary-letter" href="#Variable-Index_vr_letter-A"><b>A</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-B"><b>B</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-C"><b>C</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-D"><b>D</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-E"><b>E</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-F"><b>F</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-G"><b>G</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-H"><b>H</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-I"><b>I</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-K"><b>K</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-L"><b>L</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-M"><b>M</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-O"><b>O</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-P"><b>P</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-R"><b>R</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-S"><b>S</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-T"><b>T</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-U"><b>U</b></a> <a class="summary-letter" href="#Variable-Index_vr_letter-V"><b>V</b></a>
   
</td></tr></tbody></table>

<hr>
<a name="Function-Index"></a>
<div class="header">
<p>下一篇： <a href="#Concept-Index" rel="next" accesskey="n">概念索引</a> ，上一篇： <a href="#Variable-Index" rel="prev" accesskey="p">可变索引</a> ，上一篇： <a href="#Indexes" rel="up" accesskey="u">索引</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Function-Index-1"></a>
<h3 class="appendixsec">D.4功能索引</h3>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-F"><b>F</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-H"><b>H</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-I"><b>I</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-K"><b>K</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-N"><b>N</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-O"><b>O</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-R"><b>R</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>
<table class="index-fn" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abort-_0028C_002dg_0029"><code>abort (C-g)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-accept_002dline-_0028Newline-or-Return_0029"><code>accept-line (Newline or Return)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alias_002dexpand_002dline-_0028_0029"><code>alias-expand-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-backward_002dchar-_0028C_002db_0029"><code>backward-char (C-b)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backward_002ddelete_002dchar-_0028Rubout_0029"><code>backward-delete-char (Rubout)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backward_002dkill_002dline-_0028C_002dx-Rubout_0029"><code>backward-kill-line (C-x Rubout)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backward_002dkill_002dword-_0028M_002dDEL_0029"><code>backward-kill-word (M-<span class="key">DEL</span>)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backward_002dword-_0028M_002db_0029"><code>backward-word (M-b)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-beginning_002dof_002dhistory-_0028M_002d_003c_0029"><code>beginning-of-history (M-<)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-beginning_002dof_002dline-_0028C_002da_0029"><code>beginning-of-line (C-a)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracketed_002dpaste_002dbegin-_0028_0029"><code>bracketed-paste-begin ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-call_002dlast_002dkbd_002dmacro-_0028C_002dx-e_0029"><code>call-last-kbd-macro (C-x e)</code></a> ：</td><td> </td><td valign="top"><a href="#Keyboard-Macros">键盘宏</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-capitalize_002dword-_0028M_002dc_0029"><code>capitalize-word (M-c)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character_002dsearch-_0028C_002d_005d_0029"><code>character-search (C-])</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character_002dsearch_002dbackward-_0028M_002dC_002d_005d_0029"><code>character-search-backward (M-C-])</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clear_002dscreen-_0028C_002dl_0029"><code>clear-screen (C-l)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete-_0028TAB_0029"><code>complete (<span class="key">TAB</span>)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dcommand-_0028M_002d_0021_0029"><code>complete-command (M-!)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dfilename-_0028M_002d_002f_0029"><code>complete-filename (M-/)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dhostname-_0028M_002d_0040_0029"><code>complete-hostname (M-@)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dinto_002dbraces-_0028M_002d_007b_0029"><code>complete-into-braces (M-{)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dusername-_0028M_002d_007e_0029"><code>complete-username (M-~)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complete_002dvariable-_0028M_002d_0024_0029"><code>complete-variable (M-$)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-copy_002dbackward_002dword-_0028_0029"><code>copy-backward-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-copy_002dforward_002dword-_0028_0029"><code>copy-forward-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-copy_002dregion_002das_002dkill-_0028_0029"><code>copy-region-as-kill ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-dabbrev_002dexpand-_0028_0029"><code>dabbrev-expand ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete_002dchar-_0028C_002dd_0029"><code>delete-char (C-d)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete_002dchar_002dor_002dlist-_0028_0029"><code>delete-char-or-list ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete_002dhorizontal_002dspace-_0028_0029"><code>delete-horizontal-space ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-digit_002dargument-_0028M_002d0_002c-M_002d1_002c-_2026-M_002d_002d_0029"><code>digit-argument (<kbd>M-0</kbd>, <kbd>M-1</kbd>, … <kbd>M--</kbd>)</code></a> ：</td><td> </td><td valign="top"><a href="#Numeric-Arguments">数值参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-display_002dshell_002dversion-_0028C_002dx-C_002dv_0029"><code>display-shell-version (C-x C-v)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do_002dlowercase_002dversion-_0028M_002dA_002c-M_002dB_002c-M_002dx_002c-_2026_0029"><code>do-lowercase-version (M-A, M-B, M-<var>x</var>, …)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-downcase_002dword-_0028M_002dl_0029"><code>downcase-word (M-l)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dump_002dfunctions-_0028_0029"><code>dump-functions ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dump_002dmacros-_0028_0029"><code>dump-macros ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dump_002dvariables-_0028_0029"><code>dump-variables ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dynamic_002dcomplete_002dhistory-_0028M_002dTAB_0029"><code>dynamic-complete-history (M-<span class="key">TAB</span>)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-edit_002dand_002dexecute_002dcommand-_0028C_002dx-C_002de_0029"><code>edit-and-execute-command (C-x C-e)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end_002dkbd_002dmacro-_0028C_002dx-_0029_0029"><code>end-kbd-macro (C-x ))</code></a> ：</td><td> </td><td valign="top"><a href="#Keyboard-Macros">键盘宏</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end_002dof_002dfile-_0028usually-C_002dd_0029"><code><i>end-of-file</i> (usually C-d)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end_002dof_002dhistory-_0028M_002d_003e_0029"><code>end-of-history (M->)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end_002dof_002dline-_0028C_002de_0029"><code>end-of-line (C-e)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exchange_002dpoint_002dand_002dmark-_0028C_002dx-C_002dx_0029"><code>exchange-point-and-mark (C-x C-x)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward_002dbackward_002ddelete_002dchar-_0028_0029"><code>forward-backward-delete-char ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward_002dchar-_0028C_002df_0029"><code>forward-char (C-f)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward_002dsearch_002dhistory-_0028C_002ds_0029"><code>forward-search-history (C-s)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward_002dword-_0028M_002df_0029"><code>forward-word (M-f)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-glob_002dcomplete_002dword-_0028M_002dg_0029"><code>glob-complete-word (M-g)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-glob_002dexpand_002dword-_0028C_002dx-_002a_0029"><code>glob-expand-word (C-x *)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-glob_002dlist_002dexpansions-_0028C_002dx-g_0029"><code>glob-list-expansions (C-x g)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dand_002dalias_002dexpand_002dline-_0028_0029"><code>history-and-alias-expand-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dexpand_002dline-_0028M_002d_005e_0029"><code>history-expand-line (M-^)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dsearch_002dbackward-_0028_0029"><code>history-search-backward ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dsearch_002dforward-_0028_0029"><code>history-search-forward ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dsubstring_002dsearch_002dbackward-_0028_0029"><code>history-substring-search-backward ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history_002dsubstring_002dsearch_002dforward-_0028_0029"><code>history-substring-search-forward ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-insert_002dcomment-_0028M_002d_0023_0029"><code>insert-comment (M-#)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-insert_002dcompletions-_0028M_002d_002a_0029"><code>insert-completions (M-*)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-insert_002dlast_002dargument-_0028M_002d_002e-or-M_002d_005f_0029"><code>insert-last-argument (M-. or M-_)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-K">ķ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill_002dline-_0028C_002dk_0029"><code>kill-line (C-k)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill_002dregion-_0028_0029"><code>kill-region ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill_002dwhole_002dline-_0028_0029"><code>kill-whole-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill_002dword-_0028M_002dd_0029"><code>kill-word (M-d)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-magic_002dspace-_0028_0029"><code>magic-space ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-menu_002dcomplete-_0028_0029"><code>menu-complete ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-menu_002dcomplete_002dbackward-_0028_0029"><code>menu-complete-backward ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-N">ñ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-next_002dhistory-_0028C_002dn_0029"><code>next-history (C-n)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next_002dscreen_002dline-_0028_0029"><code>next-screen-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dincremental_002dforward_002dsearch_002dhistory-_0028M_002dn_0029"><code>non-incremental-forward-search-history (M-n)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dincremental_002dreverse_002dsearch_002dhistory-_0028M_002dp_0029"><code>non-incremental-reverse-search-history (M-p)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-operate_002dand_002dget_002dnext-_0028C_002do_0029"><code>operate-and-get-next (C-o)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-overwrite_002dmode-_0028_0029"><code>overwrite-mode ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dcommand_002dcompletions-_0028C_002dx-_0021_0029"><code>possible-command-completions (C-x !)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dcompletions-_0028M_002d_003f_0029"><code>possible-completions (M-?)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dfilename_002dcompletions-_0028C_002dx-_002f_0029"><code>possible-filename-completions (C-x /)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dhostname_002dcompletions-_0028C_002dx-_0040_0029"><code>possible-hostname-completions (C-x @)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dusername_002dcompletions-_0028C_002dx-_007e_0029"><code>possible-username-completions (C-x ~)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-possible_002dvariable_002dcompletions-_0028C_002dx-_0024_0029"><code>possible-variable-completions (C-x $)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Completion">完成命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix_002dmeta-_0028ESC_0029"><code>prefix-meta (<span class="key">ESC</span>)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-previous_002dhistory-_0028C_002dp_0029"><code>previous-history (C-p)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-previous_002dscreen_002dline-_0028_0029"><code>previous-screen-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print_002dlast_002dkbd_002dmacro-_0028_0029"><code>print-last-kbd-macro ()</code></a> ：</td><td> </td><td valign="top"><a href="#Keyboard-Macros">键盘宏</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-Q">问</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoted_002dinsert-_0028C_002dq-or-C_002dv_0029"><code>quoted-insert (C-q or C-v)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dread_002dinit_002dfile-_0028C_002dx-C_002dr_0029"><code>re-read-init-file (C-x C-r)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redraw_002dcurrent_002dline-_0028_0029"><code>redraw-current-line ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reverse_002dsearch_002dhistory-_0028C_002dr_0029"><code>reverse-search-history (C-r)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-revert_002dline-_0028M_002dr_0029"><code>revert-line (M-r)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-self_002dinsert-_0028a_002c-b_002c-A_002c-1_002c-_0021_002c-_2026_0029"><code>self-insert (a, b, A, 1, !, …)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-set_002dmark-_0028C_002d_0040_0029"><code>set-mark (C-@)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002dbackward_002dkill_002dword-_0028_0029"><code>shell-backward-kill-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002dbackward_002dword-_0028_0029"><code>shell-backward-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002dexpand_002dline-_0028M_002dC_002de_0029"><code>shell-expand-line (M-C-e)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002dforward_002dword-_0028_0029"><code>shell-forward-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Moving">移动命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002dkill_002dword-_0028_0029"><code>shell-kill-word ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-skip_002dcsi_002dsequence-_0028_0029"><code>skip-csi-sequence ()</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-start_002dkbd_002dmacro-_0028C_002dx-_0028_0029"><code>start-kbd-macro (C-x ()</code></a> ：</td><td> </td><td valign="top"><a href="#Keyboard-Macros">键盘宏</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde_002dexpand-_0028M_002d_0026_0029"><code>tilde-expand (M-&)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-transpose_002dchars-_0028C_002dt_0029"><code>transpose-chars (C-t)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-transpose_002dwords-_0028M_002dt_0029"><code>transpose-words (M-t)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-undo-_0028C_002d_005f-or-C_002dx-C_002du_0029"><code>undo (C-_ or C-x C-u)</code></a> ：</td><td> </td><td valign="top"><a href="#Miscellaneous-Commands">杂项命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-universal_002dargument-_0028_0029"><code>universal-argument ()</code></a> ：</td><td> </td><td valign="top"><a href="#Numeric-Arguments">数值参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unix_002dfilename_002drubout-_0028_0029"><code>unix-filename-rubout ()</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unix_002dline_002ddiscard-_0028C_002du_0029"><code>unix-line-discard (C-u)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unix_002dword_002drubout-_0028C_002dw_0029"><code>unix-word-rubout (C-w)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-upcase_002dword-_0028M_002du_0029"><code>upcase-word (M-u)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Text">文字指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-Y">ÿ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-yank-_0028C_002dy_0029"><code>yank (C-y)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yank_002dlast_002darg-_0028M_002d_002e-or-M_002d_005f_0029"><code>yank-last-arg (M-. or M-_)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yank_002dnth_002darg-_0028M_002dC_002dy_0029"><code>yank-nth-arg (M-C-y)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-History">历史命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yank_002dpop-_0028M_002dy_0029"><code>yank-pop (M-y)</code></a> ：</td><td> </td><td valign="top"><a href="#Commands-For-Killing">杀人命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-F"><b>F</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-H"><b>H</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-I"><b>I</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-K"><b>K</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-N"><b>N</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-O"><b>O</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-R"><b>R</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a> <a class="summary-letter" href="#Function-Index_fn_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>

<hr>
<a name="Concept-Index"></a>
<div class="header">
<p>上一页： <a href="#Function-Index" rel="prev" accesskey="p">函数索引</a> ，上一篇： <a href="#Indexes" rel="up" accesskey="u">索引</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Indexes" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Concept-Index-1"></a>
<h3 class="appendixsec">D.5概念索引</h3>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>
<table class="index-cp" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-alias-expansion">别名扩展</a> ：</td><td> </td><td valign="top"><a href="#Aliases">别名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arithmetic-evaluation">算术评估</a> ：</td><td> </td><td valign="top"><a href="#Shell-Arithmetic">壳算术</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arithmetic-expansion">算术扩展</a> ：</td><td> </td><td valign="top"><a href="#Arithmetic-Expansion">算术扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arithmetic_002c-shell">算术，壳</a> ：</td><td> </td><td valign="top"><a href="#Shell-Arithmetic">壳算术</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays">数组</a> ：</td><td> </td><td valign="top"><a href="#Arrays">数组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-background">背景</a></td><td> </td><td valign="top"><a href="#Job-Control-Basics">工作控制基础</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bash-configuration">Bash配置</a> ：</td><td> </td><td valign="top"><a href="#Basic-Installation">基本安装</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bash-installation">Bash安装</a> ：</td><td> </td><td valign="top"><a href="#Basic-Installation">基本安装</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bourne-shell">伯恩贝壳</a> ：</td><td> </td><td valign="top"><a href="#Basic-Shell-Features">基本的Shell功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-brace-expansion">大括号扩展</a> ：</td><td> </td><td valign="top"><a href="#Brace-Expansion">支撑扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-builtin-1">内置</a></td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-editing">命令编辑</a> ：</td><td> </td><td valign="top"><a href="#Readline-Bare-Essentials">Readline Bare Essentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-execution">命令执行</a> ：</td><td> </td><td valign="top"><a href="#Command-Search-and-Execution">命令搜索和执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-expansion">命令扩展</a> ：</td><td> </td><td valign="top"><a href="#Simple-Command-Expansion">简单命令扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-history">命令历史</a> ：</td><td> </td><td valign="top"><a href="#Bash-History-Facilities">重击历史设施</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-search">命令搜索</a> ：</td><td> </td><td valign="top"><a href="#Command-Search-and-Execution">命令搜索和执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-substitution">命令替换</a> ：</td><td> </td><td valign="top"><a href="#Command-Substitution">命令替换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-timing">命令时间</a> ：</td><td> </td><td valign="top"><a href="#Pipelines">流水线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-compound">命令，复合</a> ：</td><td> </td><td valign="top"><a href="#Compound-Commands">复合命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-conditional">有条件的命令</a> ：</td><td> </td><td valign="top"><a href="#Conditional-Constructs">条件构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-grouping">命令，分组</a> ：</td><td> </td><td valign="top"><a href="#Command-Grouping">命令分组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-lists">命令，列表</a> ：</td><td> </td><td valign="top"><a href="#Lists">清单</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-looping">命令，循环</a> ：</td><td> </td><td valign="top"><a href="#Looping-Constructs">循环构造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-pipelines">命令，管道</a> ：</td><td> </td><td valign="top"><a href="#Pipelines">流水线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-shell">命令，shell</a> ：</td><td> </td><td valign="top"><a href="#Shell-Commands">Shell命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-simple">命令，简单</a> ：</td><td> </td><td valign="top"><a href="#Simple-Commands">简单命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comments_002c-shell">注释，外壳</a> ：</td><td> </td><td valign="top"><a href="#Comments">评论</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion-builtins">完成内置函数</a> ：</td><td> </td><td valign="top"><a href="#Programmable-Completion-Builtins">可编程完成内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration">配置</a> ：</td><td> </td><td valign="top"><a href="#Basic-Installation">基本安装</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-control-operator">控制操作员</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coprocess">协同处理</a> ：</td><td> </td><td valign="top"><a href="#Coprocesses">协同处理</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-stack">目录堆栈</a> ：</td><td> </td><td valign="top"><a href="#The-Directory-Stack">目录堆栈</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-editing-command-lines">编辑命令行</a> ：</td><td> </td><td valign="top"><a href="#Readline-Bare-Essentials">Readline Bare Essentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment">环境</a> ：</td><td> </td><td valign="top"><a href="#Environment">环境</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluation_002c-arithmetic">评估，算术</a> ：</td><td> </td><td valign="top"><a href="#Shell-Arithmetic">壳算术</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event-designators">活动代号</a> ：</td><td> </td><td valign="top"><a href="#Event-Designators">活动代号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-execution-environment">执行环境</a> ：</td><td> </td><td valign="top"><a href="#Command-Execution-Environment">命令执行环境</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status">退出状态</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status-1">退出状态</a> ：</td><td> </td><td valign="top"><a href="#Exit-Status">退出状态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion">扩展</a> ：</td><td> </td><td valign="top"><a href="#Shell-Expansions">壳牌扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-arithmetic">扩展，算术</a> ：</td><td> </td><td valign="top"><a href="#Arithmetic-Expansion">算术扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-brace">扩展，括号</a> ：</td><td> </td><td valign="top"><a href="#Brace-Expansion">支撑扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-filename">扩展名，文件名</a> ：</td><td> </td><td valign="top"><a href="#Filename-Expansion">文件名扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-parameter">扩展，参数</a> ：</td><td> </td><td valign="top"><a href="#Shell-Parameter-Expansion">Shell参数扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-pathname">扩展名，路径名</a> ：</td><td> </td><td valign="top"><a href="#Filename-Expansion">文件名扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-tilde">扩展名，波浪号</a> ：</td><td> </td><td valign="top"><a href="#Tilde-Expansion">波浪扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-arithmetic">表达式，算术</a> ：</td><td> </td><td valign="top"><a href="#Shell-Arithmetic">壳算术</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-conditional">条件表达式</a> ：</td><td> </td><td valign="top"><a href="#Bash-Conditional-Expressions">Bash条件表达式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-field">领域</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filename">文件名</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filename-expansion">文件名扩展</a> ：</td><td> </td><td valign="top"><a href="#Filename-Expansion">文件名扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreground">前景</a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Basics">工作控制基础</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-shell">功能，外壳</a> ：</td><td> </td><td valign="top"><a href="#Shell-Functions">外壳功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-history-builtins">历史内置</a> ：</td><td> </td><td valign="top"><a href="#Bash-History-Builtins">重击历史内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history-events">历史事件</a> ：</td><td> </td><td valign="top"><a href="#Event-Designators">活动代号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history-expansion">历史扩展</a> ：</td><td> </td><td valign="top"><a href="#History-Interaction">历史互动</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history-list">历史记录</a> ：</td><td> </td><td valign="top"><a href="#Bash-History-Facilities">重击历史设施</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-History_002c-how-to-use">历史，如何使用</a> ：</td><td> </td><td valign="top"><a href="#A-Programmable-Completion-Example">可编程完成示例</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-identifier">标识符</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-initialization-file_002c-readline">初始化文件，readline</a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File">Readline初始化文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installation">安装方式</a> ：</td><td> </td><td valign="top"><a href="#Basic-Installation">基本安装</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interaction_002c-readline">互动，阅读热线</a> ：</td><td> </td><td valign="top"><a href="#Readline-Interaction">Readline互动</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interactive-shell">互动壳</a> ：</td><td> </td><td valign="top"><a href="#Invoking-Bash">调用重击</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interactive-shell-1">互动壳</a> ：</td><td> </td><td valign="top"><a href="#Interactive-Shells">互动壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization">国际化</a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-J">Ĵ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-job">工作</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-job-control">工作控制</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-job-control-1">工作控制</a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Basics">工作控制基础</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-K">ķ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill-ring">杀死戒指</a> ：</td><td> </td><td valign="top"><a href="#Readline-Killing-Commands">Readline杀死命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-killing-text">杀死文字</a> ：</td><td> </td><td valign="top"><a href="#Readline-Killing-Commands">Readline杀死命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-localization">本地化</a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-login-shell">登录外壳</a> ：</td><td> </td><td valign="top"><a href="#Invoking-Bash">调用重击</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-matching_002c-pattern">匹配，模式</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Matching">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-metacharacter">元字符</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-N">ñ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-name">名称</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-native-languages">母语</a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-notation_002c-readline">表示法，readline</a> ：</td><td> </td><td valign="top"><a href="#Readline-Bare-Essentials">Readline Bare Essentials</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-operator_002c-shell">运算符，shell</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-parameter-expansion">参数扩展</a> ：</td><td> </td><td valign="top"><a href="#Shell-Parameter-Expansion">Shell参数扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parameters">参数</a> ：</td><td> </td><td valign="top"><a href="#Shell-Parameters">外壳参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parameters_002c-positional">位置参数</a> ：</td><td> </td><td valign="top"><a href="#Positional-Parameters">位置参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parameters_002c-special">特殊参数</a> ：</td><td> </td><td valign="top"><a href="#Special-Parameters">特殊参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pathname-expansion">路径扩展</a> ：</td><td> </td><td valign="top"><a href="#Filename-Expansion">文件名扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-matching">模式匹配</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Matching">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pipeline">管道</a> ：</td><td> </td><td valign="top"><a href="#Pipelines">流水线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX">POSIX</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-Mode">POSIX模式</a> ：</td><td> </td><td valign="top"><a href="#Bash-POSIX-Mode">Bash POSIX模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-process-group">流程组</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-process-group-ID">进程组ID</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-process-substitution">流程替代</a> ：</td><td> </td><td valign="top"><a href="#Process-Substitution">流程替代</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programmable-completion">可编程完成</a> ：</td><td> </td><td valign="top"><a href="#Programmable-Completion">可编程完成</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prompting">提示</a> ：</td><td> </td><td valign="top"><a href="#Controlling-the-Prompt">控制提示</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-Q">问</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting">引用</a> ：</td><td> </td><td valign="top"><a href="#Quoting">报价单</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting_002c-ANSI">引用ANSI</a> ：</td><td> </td><td valign="top"><a href="#ANSI_002dC-Quoting">ANSI-C报价</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Readline_002c-how-to-use">Readline，如何使用</a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Variables">作业控制变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redirection">重定向</a> ：</td><td> </td><td valign="top"><a href="#Redirections">重新导向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reserved-word">保留字</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-restricted-shell">限制壳</a> ：</td><td> </td><td valign="top"><a href="#The-Restricted-Shell">限制壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return-status">退货状态</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-arithmetic">壳算术</a> ：</td><td> </td><td valign="top"><a href="#Shell-Arithmetic">壳算术</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-function">外壳功能</a> ：</td><td> </td><td valign="top"><a href="#Shell-Functions">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-script">外壳脚本</a> ：</td><td> </td><td valign="top"><a href="#Shell-Scripts">Shell脚本</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-variable">shell变量</a> ：</td><td> </td><td valign="top"><a href="#Shell-Parameters">外壳参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002c-interactive">外壳，交互式的</a> ：</td><td> </td><td valign="top"><a href="#Interactive-Shells">互动壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signal">信号</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signal-handling">信号处理</a> ：</td><td> </td><td valign="top"><a href="#Signals">讯号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-special-builtin">特殊内置</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-special-builtin-1">特殊内置</a> ：</td><td> </td><td valign="top"><a href="#Special-Builtins">特殊内置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-startup-files">启动文件</a> ：</td><td> </td><td valign="top"><a href="#Bash-Startup-Files">Bash启动文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suspending-jobs">暂停工作</a> ：</td><td> </td><td valign="top"><a href="#Job-Control-Basics">工作控制基础</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-expansion">波浪线扩展</a> ：</td><td> </td><td valign="top"><a href="#Tilde-Expansion">波浪扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-token">令牌</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translation_002c-native-languages">翻译，母语</a> ：</td><td> </td><td valign="top"><a href="#Locale-Translation">语言环境翻译</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002c-shell">变量，壳</a> ：</td><td> </td><td valign="top"><a href="#Shell-Parameters">外壳参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-readline">变量，readline</a> ：</td><td> </td><td valign="top"><a href="#Readline-Init-File-Syntax">Readline初始化文件语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-word">字</a> ：</td><td> </td><td valign="top"><a href="#Definitions">定义</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word-splitting">分词</a> ：</td><td> </td><td valign="top"><a href="#Word-Splitting">分词</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-Y">ÿ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-yanking-text">文字</a> ：</td><td> </td><td valign="top"><a href="#Readline-Killing-Commands">Readline杀死命令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>

<hr>





</body></html>