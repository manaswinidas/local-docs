<html ><head></head><body lang="zh-Hans" bgcolor="#FFFFFF"  text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">﻿<!-- 
This manual is for GNU Java Training Wheels (version 2.0,
25 July 2016), which is a system for making it easier for novices
to learn to program in the Java language.

Copyright (C) 2016 Davin Pearson.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
"GNU Free Documentation License". --><!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<title>GNU Java训练轮2.0</title>

<meta name="description" content="GNU Java Training Wheels 2.0">
<meta name="keywords" content="GNU Java Training Wheels 2.0">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#Index" rel="index" title="Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="/manual" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">





<h1 class="settitle" align="center">GNU Java训练轮2.0</h1>





<a name="SEC_Contents"></a>
<h2 class="contents-heading">目录</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-About-GNU-Java-Training-Wheels-1" href="#About-GNU-Java-Training-Wheels">1关于GNU Java培训轮</a></li>
  <li><a name="toc-J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro-1" href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro">2 JTW概念验证＃1 superfor宏</a>
  <ul class="no-bullet">
    <li><a name="toc-Elisp-source-code-for-the-superfor-macro" href="#Elisp-source-code-for-the-superfor-macro">2.1 superfor宏的Elisp源代码</a></li>
    <li><a name="toc-A-bug-in-J_002eT_002eW_002e-superfor" href="#A-bug-in-J_002eT_002eW_002e-superfor">2.2 JTW superfor中的错误</a></li>
  </ul></li>
  <li><a name="toc-J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion-1" href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion">3 JTW概念证明＃2文件包含</a></li>
  <li><a name="toc-J_002eT_002eW_002e-Tutorials-1" href="#J_002eT_002eW_002e-Tutorials">4个JTW教程</a>
  <ul class="no-bullet">
    <li><a name="toc-Tutorial-1-Your-first-program-1" href="#Tutorial-1-Your-first-program">4.1教程1您的第一个程序</a></li>
    <li><a name="toc-Tutorial-2-Introduction-to-programming-in-Java-1" href="#Tutorial-2-Introduction-to-programming-in-Java">4.2教程2 Java编程简介</a></li>
    <li><a name="toc-Tutorial-3-superfor-loops-and-for-loops-1" href="#Tutorial-3-superfor-loops-and-for-loops">4.3教程3 superfor循环和for循环</a></li>
    <li><a name="toc-Tutorial-4-Four-looping-constructs-1" href="#Tutorial-4-Four-looping-constructs">4.4教程4四个循环结构</a></li>
    <li><a name="toc-Tutorial-5-A-beer-drinking-song-1" href="#Tutorial-5-A-beer-drinking-song">4.5教程5喝啤酒的歌</a></li>
    <li><a name="toc-Tutorial-6-Class-variables-1" href="#Tutorial-6-Class-variables">4.6教程6类变量</a></li>
    <li><a name="toc-Tutorial-7-Non_002dObject-arrays-1" href="#Tutorial-7-Non_002dObject-arrays">4.7教程7非对象数组</a>
    <ul class="no-bullet">
      <li><a name="toc-Single_002ddimensional-non_002dObject-arrays-1" href="#Single_002ddimensional-non_002dObject-arrays-1">4.7.1一维非对象数组</a></li>
      <li><a name="toc-Two-dimensional-non_002dObject-arrays" href="#Two-dimensional-non_002dObject-arrays">4.7.2二维非对象数组</a></li>
      <li><a name="toc-Three_002ddimensional-non_002dObject-arrays" href="#Three_002ddimensional-non_002dObject-arrays">4.7.3三维非对象数组</a></li>
    </ul></li>
    <li><a name="toc-Tutorial-8-Accessing-functions-and-class-variables-from-another-class-1" href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class">4.8教程8从另一个类访问函数和类变量</a></li>
    <li><a name="toc-Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods-1" href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">4.9教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a>
    <ul class="no-bullet">
      <li><a name="toc-Elementary-classes_003a-using-a-single-class-for-everything" href="#Elementary-classes_003a-using-a-single-class-for-everything">4.9.1基础类：对所有内容使用单个类</a></li>
      <li><a name="toc-Improved-classes_003a-one-object-per-class" href="#Improved-classes_003a-one-object-per-class">4.9.2改进的类：每个类一个对象</a></li>
      <li><a name="toc-True-O_002eO_002eP_002e_003a-more-than-one-object-per-class" href="#True-O_002eO_002eP_002e_003a-more-than-one-object-per-class">4.9.3真正的OOP：每个类有多个对象</a></li>
      <li><a name="toc-A-common-design-pattern_003a-private-properties_002cpublic-constructor-and-public-getters" href="#A-common-design-pattern_003a-private-properties_002cpublic-constructor-and-public-getters">4.9.4常见的设计模式：私有属性，公共构造函数和公共获取者</a></li>
      <li><a name="toc-Comparing-strings" href="#Comparing-strings">4.9.5比较字符串</a></li>
      <li><a name="toc-The-null-value-for-references" href="#The-null-value-for-references">4.9.6引用的空值</a></li>
      <li><a name="toc-Why-the-toString-method-is-better-than-any-other-method-or" href="#Why-the-toString-method-is-better-than-any-other-method-or">4.9.7为什么toString方法比其他任何方法都要好？</a></li>
    </ul></li>
    <li><a name="toc-Tutorial-10-Object-arrays-1" href="#Tutorial-10-Object-arrays">4.10教程10对象数组</a>
    <ul class="no-bullet">
      <li><a name="toc-Single_002ddimensional-arrays-of-Objects" href="#Single_002ddimensional-arrays-of-Objects">4.10.1对象的一维数组</a></li>
      <li><a name="toc-Two_002ddimensional-arrays-of-Objects" href="#Two_002ddimensional-arrays-of-Objects">4.10.2对象的二维数组</a></li>
      <li><a name="toc-Three_002ddimensional-arrays-of-Objects" href="#Three_002ddimensional-arrays-of-Objects">4.10.3对象的三维数组</a></li>
    </ul></li>
    <li><a name="toc-Tutorial-11-References-to-another-class-1" href="#Tutorial-11-References-to-another-class">4.11教程11对另一个类的引用</a></li>
    <li><a name="toc-Tutorial-12-Overloading-methods-1" href="#Tutorial-12-Overloading-methods">4.12教程12重载方法</a></li>
    <li><a name="toc-Tutorial-13-More-about-references-1" href="#Tutorial-13-More-about-references">4.13教程13有关参考的更多信息</a></li>
    <li><a name="toc-Tutorial-14-Linked-lists-1" href="#Tutorial-14-Linked-lists">4.14教程14链接列表</a></li>
    <li><a name="toc-Tutorial-15-Introducing-inheritance-1" href="#Tutorial-15-Introducing-inheritance">4.15教程15继承介绍</a>
    <ul class="no-bullet">
      <li><a name="toc-Basic-Inheritance" href="#Basic-Inheritance">4.15.1基本继承</a></li>
      <li><a name="toc-Run_002dtime-type-inquiry" href="#Run_002dtime-type-inquiry">4.15.2运行时类型查询</a></li>
      <li><a name="toc-The-superclass-of-all-objects" href="#The-superclass-of-all-objects">4.15.3所有对象的超类</a></li>
    </ul></li>
    <li><a name="toc-Tutorial-16-More-inheritance-1" href="#Tutorial-16-More-inheritance">4.16教程16更多继承</a></li>
    <li><a name="toc-Tutorial-17-Arrays-inheritance-and-polymorphism-1" href="#Tutorial-17-Arrays-inheritance-and-polymorphism">4.17教程17数组的继承和多态</a></li>
    <li><a name="toc-Tutorial-18-Advanced-J_002eT_002eW_002e-1" href="#Tutorial-18-Advanced-J_002eT_002eW_002e">4.18教程18高级JTW</a>
    <ul class="no-bullet">
      <li><a name="toc-Mapping-J_002eT_002eW_002e-to-Java-1" href="#Mapping-J_002eT_002eW_002e-to-Java">4.18.1将JTW映射到Java</a></li>
      <li><a name="toc-Piping-the-output-of-javac-and-java-1" href="#Piping-the-output-of-javac-and-java">4.18.2用管道输送javac和java的输出</a></li>
      <li><a name="toc-Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files-1" href="#Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files">4.18.3 Makefile，用于将* .jtw构建到* .java中并运行* .class文件</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Packages-in-J_002eT_002eW_002e-and-Java-1" href="#Packages-in-J_002eT_002eW_002e-and-Java">5个JTW和Java软件包</a>
  <ul class="no-bullet">
    <li><a name="toc-Moving-a-class-into-a-package-1" href="#Moving-a-class-into-a-package">5.1将类移到包中</a></li>
    <li><a name="toc-Moving-a-class-into-a-sub_002dpackage-1" href="#Moving-a-class-into-a-sub_002dpackage">5.2将类移到子包中</a></li>
    <li><a name="toc-Importing-a-package-1" href="#Importing-a-package">5.3导入包</a></li>
    <li><a name="toc-Importing-a-package-from-another-package-1" href="#Importing-a-package-from-another-package">5.4从另一个包导入一个包</a></li>
    <li><a name="toc-How-to-build-a-collection-of-class-files-or-an-entire-package-1" href="#How-to-build-a-collection-of-class-files-or-an-entire-package">5.5如何构建类文件或整个包的集合</a></li>
    <li><a name="toc-How-to-invoke-javadoc-on-a-package-1" href="#How-to-invoke-javadoc-on-a-package">5.6如何在包上调用javadoc</a></li>
  </ul></li>
  <li><a name="toc-GNU-Free-Documentation-License-1" href="#GNU-Free-Documentation-License">附录A GNU自由文档许可证</a></li>
  <li><a name="toc-Passwords-for-the-answers-to-the-tutorials-1" href="#Passwords-for-the-answers-to-the-tutorials">附录B教程答案的密码</a></li>
  <li><a name="toc-Index-1" href="#Index">指数</a></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>下一页： <a href="#About-GNU-Java-Training-Wheels" rel="next" accesskey="n">关于GNU Java Training Wheels</a> ，向上： <a href="/manual" rel="up" accesskey="u">（dir）</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Java-Training-Wheels"></a>
<h1 class="top">GNU Java培训轮</h1>

<p>本手册适用于GNU Java Training Wheels（2.0版，2016年7月25日）。
</p>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#About-GNU-Java-Training-Wheels" accesskey="1">关于GNU Java培训轮</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro" accesskey="2">JTW概念证明＃1 superfor宏</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" accesskey="3">JTW概念证明＃2文件包含</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#J_002eT_002eW_002e-Tutorials" accesskey="4">JTW教程</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Packages-in-J_002eT_002eW_002e-and-Java" accesskey="5">JTW和Java中的软件包</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#GNU-Free-Documentation-License" accesskey="6">GNU自由文档许可证</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Passwords-for-the-answers-to-the-tutorials" accesskey="7">教程答案的密码</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Index" accesskey="8">索引</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
</tbody></table>

<hr>
<a name="About-GNU-Java-Training-Wheels"></a>
<div class="header">
<p>下一篇： <a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro" rel="next" accesskey="n">JTW概念证明＃1一个superfor宏</a> ，上<a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro" rel="next" accesskey="n">一篇</a> ： <a href="#Top" rel="prev" accesskey="p">顶部</a> ，上： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="About-GNU-Java-Training-Wheels-1"></a>
<h2 class="chapter">1关于GNU Java培训轮</h2>

<a name="index-About-GNU-Java-Training-Wheels"></a>

<p>该文档记录了由我写的一种新的编程语言，Davin Pearson（电子邮件：gmail.com上的davin dot pearson），称为JTW，是Java Training Wheels的缩写，其唯一目的是使学习Java编程变得更加容易。JTW语言与Delphi，Pascal，BASIC和JavaScript具有相似的语法，因此与从头学习Java相比，在学习Java之前或学习JTW时学习曲线不那么陡峭。由于许多原因，您甚至可能更喜欢使用JTW而不是Java进行编程。这就是为什么您应该在学习Java之前或同时学习JTW的原因：</p>
<ul>
<li>解析器支持JTW语言，该解析器使用清晰的错误消息对有问题的JTW代码进行故障排除。

<a name="index-Trouble_002dshooting-problematic-J_002eT_002eW_002e-constructs"></a>
<a name="index-Problematic-J_002eT_002eW_002e-constructs_002c-trouble_002dshooting"></a>

</li><li>JTW语言以自然和直接的方式编译为Java，因此一旦您了解JTW，就很容易学习Java。请参见下图，以比较JTW和Java构建过程。

<a name="index-Mapping-from-J_002eT_002eW_002e-_002d_003e-Java"></a>
<a name="index-J_002eT_002eW_002e-_002d_003e-Java-mapping"></a>

<div class="example">
<pre class="example">    +-----+
    |*.jtw|
    +--+--+
       |
       v Emacs' batch mode
    +------+                   +------+
    |*.java|                   |*.java|
    +--+---+                   +--+---+
       |                          |
       v javac compiler           v javac compiler
    +-------+                  +-------+
    |*.class|                  |*.class|
    +--+----+                  +--+----+
       |                          |
       | java                     | java
       V                          V
runs the class             runs the class


</pre></div>

  

</li><li>支持Pascal风格的begin ... end构造，而不是C风格的{...}构造，这对新手而言尤其明智。

<a name="index-Pascal_002dstyle-begin-_002e_002e_002e-end-construct-versus-the-C_002dstyle-_007b-_002e_002e_002e-_007d-construct"></a>

</li><li>主要函数的简单语法：beginMain ... endMain而不是相当麻烦：public static void main（String [] args）{...}。

<a name="index-A-simple-syntax-for-the-main-function_002e"></a>
<a name="index-main-function_002c-a-simple-syntax-for_002e"></a>

</li><li>类变量，属性，函数，方法和构造函数的声明与Delphi一样，使您的代码看起来更加清晰。具体来说，有新的关键字classVar，构造函数，函数，方法和属性。

<a name="index-classVar-construct"></a>
<a name="index-constructor-construct"></a>
<a name="index-function-construct"></a>
<a name="index-method-construct"></a>
<a name="index-property-construct"></a>

</li><li>Delphi / Pascal / JavaScript关键字var用于更清晰的局部变量。

<a name="index-The-Delphi_002fPascal_002fJavaScript-keyword-var-for-clearer-local-variables"></a>
<a name="index-var-for-clearer-local-variables"></a>

<a name="index-The-Pascal_002fBASIC-keyword-then-for-clearer-if-statements"></a>
<a name="index-then-for-clearer-if-statements"></a>

</li><li>然后使用Pascal / BASIC关键字来更清晰地显示if语句。

<a name="index-BASIC-style-and-and-or-constructs-rather-than-Java_0027s-cumbersome-_0026_0026-_007c_007c-constructs_002e"></a>

<a name="index-C_002b_002b-style-and-and-or-constructs-rather-than-Java_0027s-cumbersome-_0026_0026-_007c_007c-constructs_002e"></a>

<a name="index-and-construct-from-BASIC-and-C_002b_002b-in-J_002eT_002eW_002e"></a>

<a name="index-or-construct-from-BASIC-and-C_002b_002b-in-J_002eT_002eW_002e"></a>

</li><li>BASIC和C ++样式关键字和和（或）而不是Java相当繁琐的&&和||。

<a name="index-elseif-construct-rather-than-else-if"></a>

</li><li>支持PHP关键字elseif，而不是Java繁琐的else if。

<a name="index-superfor-macro"></a>

</li><li>作为概念证明，为增强的BASIC样式的循环提供了一个superfor宏。请参阅<a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro">JTW概念验证＃1 A superfor宏</a> 。

<a name="index-File-inclusion-in-J_002eT_002eW_002e"></a>

</li><li>作为概念证明，支持文件包含，因此您可以将一个类分散在多个文件中。自然划分是方法。对于方法变大且笨拙的情况，可以将不同的方法放置在不同的源文件中。看到<p><a href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion">JTW概念证明＃2文件包含</a> 。
</p>
  
  

</li><li>新！从JTW 2.0版开始，现在支持软件包。请参阅<a href="#Packages-in-J_002eT_002eW_002e-and-Java">JTW和Java中的软件包</a> 。

  

</li></ul>

<hr>
<a name="J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro"></a>
<div class="header">
<p>下一篇： <a href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" rel="next" accesskey="n">JTW概念证明＃2文件包含</a> ，上一篇： <a href="#About-GNU-Java-Training-Wheels" rel="prev" accesskey="p">关于GNU Java Training Wheels</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro-1"></a>
<h2 class="chapter">2 JTW概念验证＃1 superfor宏</h2>

<a name="index-superfor-looping-construct"></a>


<p>JTW预处理器的概念证明是superfor宏，它是增强的BASIC风格的for循环。这是在* .jtw文件中调用superfor宏的方法：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 0 to 10)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>上面的代码将导致以下打印输出：</p>
<div class="example">
<pre class="example">i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
i=10
</pre></div>

<p>step size参数是可选的，下面是一个示例，其中声明了明确的step size：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 0 to 10 step 2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>上面的代码将导致以下打印输出：</p>
<div class="example">
<pre class="example">i=0
i=2
i=4
i=6
i=8
i=10
</pre></div>

<p>如果给出了downto关键字而不是to关键字，那么即使给出了肯定的步长，循环也会从第一个给定的数字向下计数到第二个。这是一个步长为负的示例：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 10 downto 0 step 2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>上面的代码将导致以下打印输出：</p>
<div class="example">
<pre class="example">i=10
i=8
i=6
i=4
i=2
i=0
</pre></div>

<p>请注意，superfor宏的规范对于start，stop和step-size的值不需要常数。它们可以是任何变量，或更笼统地说可以是任何Java表达式，并且这些表达式仅在您的代码具有副作用（即更改代码中的变量值）的情况下才被评估一次。请参见以下示例。表达式++ y具有返回y值之前先增加y值的副作用：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int x = 20;
&nbsp;&nbsp;&nbsp; var int y = 15;
&nbsp;&nbsp;&nbsp; superfor (var int i = x to (2 * ++y))
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>上面的代码将导致以下打印输出：</p>
<div class="example">
<pre class="example">i=20
i=21
i=22
i=23
i=24
i=25
i=26
i=27
i=28
i=29
i=30
i=31
i=32
</pre></div>

<a name="Elisp-source-code-for-the-superfor-macro"></a>
<h3 class="section">2.1 superfor宏的Elisp源代码</h3>

<p>以下代码属于〜/ jtw / jtw-build-jtw.el文件，该文件本身太大，无法包含在本手册中。您可以通过访问<a href="#J_002eT_002eW_002e-tarball">JTW tarball</a>找到此代码。或者，您可以研究〜/ jtw / jtw-build-jtw.el文件的此片段，该片段处理superfor宏。在下面的清单中，* pp-namespace *存储一个包含任意长名称的字符串，以防止意外将include指令与其他注释代码混叠。
</p>

<div class="example">
<pre class="example">(let (p1 p2 str form type variable T var start stop step-size step-size-2
             this_start this_stop this_step this_step_size file line p-prior
             beg0 end0)
      (setq strobe nil)
      (checkpoint &quot;2&quot;)
      (save-excursion
        (goto-char (point-min))
        (setq *superfor* 0)
        (while (re-search-forward &quot;\\&lt;superfor\\&gt;&quot; nil t)
          (setq beg0 (match-beginning 0))
          (setq end0 (match-end 0))
          ;;(checkpoint &quot;sitting for 1 seconds...&quot;)
          (font-lock-fontify-buffer)
          ;;(sit-for 1)
          (when (save-excursion
                  (save-match-data
                    (re-search-forward &quot;(&quot; (point-at-eol) t)
                    (forward-char -1)
                    (re-search-forward &quot;\\&lt;var\\&gt;&quot; nil t)
                    (not (warn--inside-comment-or-string))))
            ;;(error &quot;Smelly cat&quot;)
            (setq *current-buffer* (current-buffer))
            ;;(switch-to-buffer *current-buffer*)
            (setq p1 beg0)
            (assert (save-match-data
                      (looking-at &quot; \t\r\n*(&quot;)))
            (setq p2 (save-excursion
                       (forward-sexp 1)
                       (point)))
            (setq str (buffer-substring-no-properties end0 p2))
            ;;(checkpoint &quot;str=%s&quot; str)
            (setq form (read-str str))
            ;;(checkpoint &quot;form=%s&quot; form)
            ;;(debug &quot;form&quot;)
            (assert (consp form))
            (message &quot;*** form=%s&quot; form)
            ;;(error &quot;Rolling Stones plays Cuba&quot;)
            (delete-region p1 p2)
            (incf *superfor*)
            (setq this (format &quot;superfor_%d_&quot; *superfor*))
            (when (not (eq (nth 0 form) 'var))
              (warn--log-message &quot;Error 35: Keyword var missing from superfor construct&quot;)
              (when (and (not (eq (nth 1 form) 'char))
                         (not (eq (nth 1 form) 'short))
                         (not (eq (nth 1 form) 'int))
                         (not (eq (nth 1 form) 'long))
                         (not (eq (nth 1 form) 'float))
                         (not (eq (nth 1 form) 'double)))
                (warn--log-message (concat
                                    &quot;Error 37:#1 argument type to superfor macro must be&quot;
                                    &quot; one of char/short/int/long/float/double&quot;))))
            (when (eq (nth 0 form) 'var)
              (if (and (not (eq (nth 1 form) 'char))
                       (not (eq (nth 1 form) 'short))
                       (not (eq (nth 1 form) 'int))
                       (not (eq (nth 1 form) 'long))
                       (not (eq (nth 1 form) 'float))
                       (not (eq (nth 1 form) 'double)))
                  (warn--log-message (concat
                                      &quot;Error 37:#2 argument type to superfor macro must be&quot;
                                      &quot; one of char/short/int/long/float/double&quot;)))
              (progn
                ;;(debug &quot;Radiohead: Let Down&quot;)
                ;; (setq form '(var int i=0 to stop))
                ;; (setq form '(var int i =0 to stop))
                ;; (setq form '(var int i = 0 to stop))
                (setq type     (nth 1 form))
                (setq T        (prin1-to-string type))
                (setq variable (prin1-to-string (nth 2 form)))
                (if (string-match &quot;=&quot; variable)
                    (progn
                      (setq pre-red-str--variable (substring variable 0 (match-beginning 0)))
                      ;;(string-match &quot;=&quot; variable-equals)
                      (setq pre-red-str--start    (substring variable (match-end 0)))
                      ;;(debug &quot;Radiohead: Fitter Happier&quot;)
                      ;;(debug &quot;Jean Jarre: Equinoxe Part III&quot;)
                      (setq variable (and (not (string= &quot;&quot; pre-red-str--variable))
                                          (prin1-to-string (read-str pre-red-str--variable))))
                      (setq start (and (not (string= &quot;&quot; pre-red-str--start))
                                       (prin1-to-string (read-str pre-red-str--start))))
                      (cond
                       ((eq (nth 3 form) nil)
                        (setq start (concat start &quot;()&quot;))
                        (setq strobe t)
                        (debug &quot;Queen: One Vision&quot;)
                        (cond
                         ((eq (nth 4 form) 'to)
                          (setq to 'to))
                         ((eq (nth 4 form) 'downto)
                          (setq to 'downto))
                         (t
                          (debug &quot;Pretenders: Space Invader&quot;)))
                        (setq stop (prin1-to-string (nth 5 form)))
                        (cond
                         ((and (eq (nth 6 form) nil) (&gt; (length form) 6))
                          (setq stop (concat stop &quot;()&quot;))
                          ;;(debug &quot;The Pretenders: Kid&quot;)
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ((string-match &quot;(&quot; (prin1-to-string (nth 6 form)))
                          (setq stop (concat stop (and (nth 6 form) (prin1-to-string (nth 6 form)))))
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ((eq (nth 6 form) 'step)
                          (debug &quot;Pretenders: Private Life&quot;)
                          (setq step-size (nth 7 form)))
                         (t
                          ;;(debug &quot;Queen: It's a Kind of Magic&quot;)
                          )
                         ) ;; end COND!
                        (if strobe (debug &quot;Queen: One Year of Love&quot;))
                        )
                       ((string-match &quot;(&quot; (prin1-to-string (nth 3 form)))
                        ;;(debug &quot;Public Enemy: Letter to the New York Post&quot;)
                        (setq start (and (nth 3 form) (concat start (prin1-to-string (nth 3 form)))))
                        (cond
                         ((eq (nth 4 form) 'to)
                          (setq to 'to))
                         ((eq (nth 4 form) 'downto)
                          (setq to 'downto))
                         (t
                          (debug &quot;Elvis: King Creole&quot;)))
                        (setq stop (prin1-to-string (nth 5 form)))
                        (cond
                         ((and (eq (nth 6 form) nil) (&gt; (length form) 6))
                          (setq stop (concat stop &quot;()&quot;))
                          ;;(debug &quot;The Pretenders: Kid&quot;)
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ;; ------------------------------------------
                         ((string-match &quot;(&quot; (prin1-to-string (nth 6 form)))
                          (setq stop (concat stop (prin1-to-string (nth 6 form))))
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ;; ------------------------------------------
                         ((eq (nth 6 form) 'step)
                          (debug &quot;Pretenders: Private Life&quot;)
                          (setq step-size (nth 7 form)))
                         (t
                          ;;(debug &quot;Queen: It's a Kind of Magic&quot;)
                          )
                         )
                        ((eq (nth 3 form) 'to)
                         (setq to 'to)
                         (setq stop (nth 4 form))
                         (if (eq (nth 5 form) 'step)
                             (setq step-size (nth 6 form))
                           )
                         ;;(debug &quot;aaa&quot;)
                         )
                        ((eq (nth 3 form) 'downto)
                         (setq to 'downto)
                         (setq stop (nth 4 form))
                         (if (eq (nth 5 form) 'step)
                             (setq step-size (nth 6 form))
                           )
                         (debug &quot;bbb&quot;)
                         )
                        (t
                         (debug &quot;Dire Straits: The Bug&quot;)))
                       )
                      ;;(debug &quot;Bach's Mass in B Minor: Et in terra pax&quot;)
                      )
                  (if (eq (nth 3 form) '=)
                      (setq start (and (nth 4 form) (prin1-to-string (nth 4 form))))
                    (setq   start (and (nth 3 form) (prin1-to-string (nth 3 form))))
                    )) ;; end if!
                ;;(debug &quot;Bach's Mass in B Minor: Kyrie eleison&quot;)
                (cond
                 ((eq (nth 3 form) 'to)
                  (setq to 'to)
                  (setq stop (prin1-to-string (nth 4 form)))
                  (if (and (eq (nth 5 form) nil) (&gt; (length form) 5))
                      (setq stop (concat stop &quot;()&quot;))
                    (if (string-match &quot;(&quot; (prin1-to-string (nth 5 form)))
                        (setq stop (concat stop (prin1-to-string (nth 5 form))))
                      (if (eq (nth 5 form) 'step)
                          (setq step-size (prin1-to-string (nth 6 form))))))
                  )
                 ((eq (nth 3 form) 'downto)
                  (setq to 'downto)
                  (setq stop (prin1-to-string (nth 4 form)))
                  (if (and (eq (nth 5 form) nil) (&gt; (length form) 5))
                      (setq stop (concat stop &quot;()&quot;))
                    (if (string-match &quot;(&quot; (prin1-to-string (nth 5 form)))
                        (setq stop (concat stop (prin1-to-string (nth 5 form))))
                      (if (eq (nth 5 form) 'step)
                          (setq step-size (prin1-to-string (nth 6 form))))))
                  )
                 (t
                  ;;(debug &quot;Jean Michel Jarre: Oxygene III&quot;)))
                  ;;(debug &quot;Joaquin Rodrigo&quot;)
                  (setq start (prin1-to-string (nth 4 form)))
                  (cond
                   ((eq (nth 5 form) 'to)
                    (setq to 'to))
                   ((eq (nth 5 form) 'downto)
                    (setq to 'downto))
                   (t
                    (debug &quot;Dire Straits: Planet of New Orleans&quot;)))
                  (setq stop (prin1-to-string (nth 6 form)))
                  (if (eq (nth 7 form) 'step)
                      (progn
                        (setq step-size (and (nth 8 form) (prin1-to-string (nth 8 form))))
                        (assert (numberp (nth 8 form)))
                        )
                    )
                  )
                 )
                )
              ;;(debug &quot;Rod Stewart's Maggie May&quot;)
              (progn
                (setq var         variable)
                (setq start-2     (warn--cull-quotes (warn--splat-quest start)))
                (setq stop-2      (warn--cull-quotes (warn--splat-quest stop)))
                (setq step-size-2 (warn--splat-quest (and step-size (prin1-to-string step-size))))
                ) ;; end PROGN!
              ;; -----------------------------------------------------
              ;;(debug &quot;The Pretenders: Precious&quot;)
              (setq this_start     (concat this &quot;start&quot;))
              (setq this_stop      (concat this &quot;stop&quot;))
              (setq this_step      (concat this &quot;step&quot;))
              (setq this_step_size (concat this &quot;step_size&quot;))
              ;;(debug &quot;My Parties&quot;)
              (insert (concat (concat &quot;var &quot; T &quot; &quot; this_start &quot; = &quot; start-2 &quot;; &quot;)
                              (concat &quot;var &quot; T &quot; &quot; this_stop  &quot; = &quot; stop-2  &quot;; &quot;)
                              (if step-size
                                  (concat &quot;var &quot; T &quot; &quot; this_step &quot; = &quot; step-size-2 &quot;; &quot;
                                          &quot;var &quot; T &quot; &quot; this_step_size &quot; = &quot;
                                          (cond
                                           ((eq to 'to)
                                            (concat &quot;Math.abs(&quot; this_step &quot;)&quot;))
                                           ((eq to 'downto)
                                            (concat &quot;-Math.abs(&quot; this_step &quot;)&quot;))
                                           (t
                                            (debug &quot;Dire Straits: Heavy Fuel&quot;)))
                                          &quot;;\n&quot;)
                                (concat &quot;var &quot; T &quot; &quot; this_step_size &quot; = &quot;
                                        (cond
                                         ((eq to 'to)
                                          &quot;1&quot;)
                                         ((eq to 'downto)
                                          &quot;-1&quot;)
                                         (t
                                          (debug &quot;Dire Straits: Ticket to Heaven&quot;)))
                                        ) ;; end CONCAT!
                                )         ;; end if!
                              &quot;;\n&quot;)      ;; end CONCAT!
                      )                   ;; end INSERT!
              ;;(debug &quot;Rod Stewart: Hot Legs&quot;)
              (setq line 0)
              (setq p-prior
                    (save-excursion
                      (beginning-of-line)
                      (setq str (concat &quot;^ \t*//+ &quot; *pp-namespace* &quot; #location0-9&quot;
                                        &quot; (\\(&quot;       *drive-spec*   &quot;-a-zA-Z0-9_./+\\):\\(0-9+\\))&quot;))
                      (if (or (looking-at str) (re-search-backward str nil t))
                          (progn
                            ;;(debug &quot;Antonio Vivaldi&quot;)
                            (setq file (buffer-substring-no-properties           (match-beginning 1)
                                                                                 (match-end 1)))
                            (assert (stringp file))
                            (setq line (read-str (buffer-substring-no-properties (match-beginning 3)
                                                                                 (match-end 3))))
                            (assert (integerp line))
                            (point)
                            )
                        (setq file (concat *def-dir* *stump* &quot;.jtw&quot;))
                        (setq line 1)
                        (goto-char (point-min))
                        (forward-line 2)
                        (point)
                        )))
              (setq line (+ line (count-lines p-prior (point))))
              (decf line)
              (decf line)
              (insert (format &quot;// %s (setq file-stack '%s)\n&quot; *list-namespace* (prin1-to-string file-stack)))
              (insert (format &quot;// %s #location3 (%s:%d)\n&quot;    *pp-namespace*   file line))
              (insert (concat &quot;for (var &quot; T &quot; &quot; var &quot; = &quot; this_start &quot;;&quot;
                              &quot; ((&quot; this_step_size &quot; &gt; 0) ? &quot; var &quot; &lt;= &quot;
                              this_stop &quot; : &quot; var &quot; &gt;= &quot; this_stop &quot;); &quot;
                              var &quot; += &quot; this_step_size &quot;)&quot;))
              (if strobe (debug &quot;Pretenders: The Wait&quot;))
              ;;(debug &quot;Yehudi Menuhin&quot;)
              )))))
</pre></div>


<a name="A-bug-in-J_002eT_002eW_002e-superfor"></a>
<h3 class="section">2.2 JTW superfor中的错误</h3>

<p>问号运算符a？b：c扩展为</p>
<div class="example">
<pre class="example">Type result;
if (a) then
begin
&nbsp;&nbsp;&nbsp; result = b;
end
else
begin
&nbsp;&nbsp;&nbsp; result = c;
end
</pre></div>

<p>JTW中superfor宏的参数不直接支持其中type可以是任何Java类型的类型在其他地方支持问号。而是在superfor宏中，您必须编写以下代码以在线获取问号运算符：</p>
<div class="example">
<pre class="example">class SuperFor
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; foo(1,2);
&nbsp;&nbsp;&nbsp; endMain
&nbsp;&nbsp;&nbsp; function void foo(int x, int y)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to (x &lt; y QUEST 10 : 20))
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end
end
</pre></div>


<p>QUEST符号会编译成问号：？。生成后，程序将打印出以下内容：</p>
<div class="example">
<pre class="example">i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
i=10
</pre></div>



<hr>
<a name="J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion"></a>
<div class="header">
<p>下一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="next" accesskey="n">JTW教程</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="next" accesskey="n">JTW</a> <a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro" rel="prev" accesskey="p">概念证明＃1一个superfor宏</a> ，上<a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro" rel="prev" accesskey="p">一篇</a> ： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion-1"></a>
<h2 class="chapter">3 JTW概念证明＃2文件包含</h2>


<p>当您的类变大且笨拙时，将源文件拆分为多个编译单元将很有用。最自然地划分为编译单元是在方法级别。通过将每个方法放在单独的文件中，您可以管理太大的方法。这是在JTW语言中使用文件包含的方法。首先是Foo.jtw文件，其中包含从中获取的所有方法：</p>

<div class="example">
<pre class="example">class Foo
begin
&nbsp;&nbsp;&nbsp; include &quot;Foo-apple.method&quot;;
&nbsp;&nbsp;&nbsp; include &quot;Foo-banana.method&quot;;
&nbsp;&nbsp;&nbsp; include &quot;Foo-carrot.method&quot;;
end
</pre></div>

<p>这是包含的文件。第一个文件是Foo-apple.method：</p>
<div class="example">
<pre class="example">property int prop1; /* declares a property for use with the apple method. */

method void apple(/* parameters */)
begin
&nbsp;&nbsp;&nbsp; prop1 = prop1 + 1;
&nbsp;&nbsp;&nbsp; /* rest of body of apple method */
end
</pre></div>

<p>第二个文件是Foo-banana.method：</p>
<div class="example">
<pre class="example">method void banana(/* parameters */)
begin
&nbsp;&nbsp;&nbsp; /* body of banana method */
end
</pre></div>

<p>第三个文件是Foo-carrot.method：</p>
<div class="example">
<pre class="example">method void carrot(/* parameters */)
begin
&nbsp;&nbsp;&nbsp; /* body of carrot method */
end
</pre></div>

<p>当JTW对Java编译器执行了所有文件包含时，javac看到的代码将如下所示：</p>
<div class="example">
<pre class="example">/* Automatically generated file. Do not edit! */
// #foomatic #location (Foo.jtw:1)
class Foo
{
&nbsp;&nbsp;&nbsp; // #foomatic #location (apple.method:1)
&nbsp;&nbsp;&nbsp; int prop1; /* declares a property for use with the apple method. */
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; void apple(/* parameters */)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prop1 = prop1 + 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* rest of body of apple method */
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // #foomatic #location (banana.method:1)
&nbsp;&nbsp;&nbsp; void banana(/* parameters */)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* body of banana method */
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // #foomatic #location (carrot.method:1)
&nbsp;&nbsp;&nbsp; void carrot(/* parameters */)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* body of carrot method */
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // #foomatic #location (Foo.jtw:6)
}
</pre></div>

<p>请注意，使用字符串* pp-namespace *（其中pp代表预处理程序）的值#foomatic是一个任意定义的长字符串，以防止意外注释与系统用户可能会使用的其余注释代码混淆写。#location指令用于跟踪源文件中的原始行号。使用Emacs批处理模式执行Elisp代码：jtw-build-jtw.el，现在Foo.java中的错误消息会指向原始Foo.jtw文件，或者像以下这样包含#include的文件之一：apple.method，香蕉方法或胡萝卜方法。如果您特别聪明，则可以在不同的类中重用相同的方法。
</p>
<p>JTW的1.0版使用C预处理器（cpp）来管理#location指令，但不幸的是cpp破坏了目标文件中的注释，而Java使用/ ** ... * /注释来记录程序的行为，因此cpp不能用过的。
</p>


<hr>
<a name="J_002eT_002eW_002e-Tutorials"></a>
<div class="header">
<p>下一篇： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="next" accesskey="n">JTW和Java包</a> ，上一篇： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="next" accesskey="n">JTW</a> <a href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" rel="prev" accesskey="p">概念证明＃2文件包含</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="J_002eT_002eW_002e-Tutorials-1"></a>
<h2 class="chapter">4个JTW教程</h2>

<a name="index-Davin-Pearson_0027s-Personal-Website-http_003a_002f_002fdavin_002e50webs_002ecom"></a>

<p>以下教程，包括完整的模型答案，可以在我的网站的以下位置找到：</p>
<div align="center"><a href="http://davin.50webs.com/J.T.W">http://davin.50webs.com/JTW</a>
</div>
<p>使用我的在线教程的优势在于，这些教程对代码示例进行了出色的语法突出显示。请参阅以下链接“ <a href="#Passwords-for-the-answers-to-the-tutorials">密码”以</a>获取本网站上密码<a href="#Passwords-for-the-answers-to-the-tutorials">的教程答案</a> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-1-Your-first-program" accesskey="1">教程1您的第一个程序</a> ：</td><td>  </td><td align="left" valign="top">您的第一个程序并介绍函数，参数，参数，字符串，System.out.println和注释，以为您提供足够的基本JTW来帮助您入门。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-2-Introduction-to-programming-in-Java" accesskey="2">教程2 Java编程简介</a> ：</td><td>  </td><td align="left" valign="top">介绍chars，==和=之间的区别，布尔值，if（...）then ...elseif（...）... elseif（...）... else ...构造，局部变量，整数，for构造，并教您如何调用String类的现有方法，但不教您如何在教程9之前编写自己的方法。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-3-superfor-loops-and-for-loops" accesskey="3">教程3 superfor循环和for循环</a> ：</td><td>  </td><td align="left" valign="top">引入System.out.print进行打印，而无需返回回车符，引入superfor构造，修改使用for构造的循环，引入双精度并修改int和chars。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-4-Four-looping-constructs" accesskey="4">教程4四个循环结构</a> ：</td><td>  </td><td align="left" valign="top">其他类型的循环，例如superfor，while和do ... while，以及修改if语句和for循环。了解这四个循环结构中的最佳方法。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-5-A-beer-drinking-song" accesskey="5">教程5喝啤酒的歌</a> ：</td><td>  </td><td align="left" valign="top">使用到目前为止学习的所有JTW构造重写一首歌曲，使其更具通用性。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-6-Class-variables" accesskey="6">教程6类变量</a> ：</td><td>  </td><td align="left" valign="top">介绍与函数局部变量不同的类变量。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-7-Non_002dObject-arrays" accesskey="7">教程7非对象数组</a> ：</td><td>  </td><td align="left" valign="top">介绍使用两种不同的初始化语法的单维或多维非对象数组，并引入函数名称重载。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class" accesskey="8">教程8从另一个类访问函数和类变量</a> ：</td><td>  </td><td align="left" valign="top">学习如何从另一个类访问函数并介绍布尔数组。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods" accesskey="9">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
   This gives you the full power of O.O.P. (Object Oriented
   Programming) classes.  Introducing getter methods and references
   for accessing objects. Introducing the null keyword for
   representing no object and introducing the toString method,
   while explaining why this method is better than any other method or
   property for debugging your code.

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-10-Object-arrays">教程10对象数组</a> ：</td><td>  </td><td align="left" valign="top">介绍一维或多维的对象数组。在非对象数组上，从教程7修订了两种不同的初始化语法。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-11-References-to-another-class">教程11对另一个类的引用</a> ：</td><td>  </td><td align="left" valign="top">当类在其属性中引用其他类的对象时，则可以在不同类之间建立关系。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-12-Overloading-methods">教程12重载方法</a> ：</td><td>  </td><td align="left" valign="top">交换两个对象的属性，并将方法转换为函数，反之亦然。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-13-More-about-references">教程13有关参考的更多信息</a> ：</td><td>  </td><td align="left" valign="top">有关参考的更多问题。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
<a name="index-Linked-lists"></a>
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-14-Linked-lists">教程14链接列表</a> ：</td><td>  </td><td align="left" valign="top">当一个类将自己作为属性进行引用时，则可以从该类的对象中构建链接列表。警告：链表对于新手程序员来说很棘手。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a> ：</td><td>  </td><td align="left" valign="top">介绍继承，多态，getter和setter方法，用于运行时类型查询的instanceof关键字，并介绍Object类。引入null关键字表示没有对象，并介绍了toString方法，同时说明了为什么此方法比任何其他调试代码的方法或属性都要好。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-16-More-inheritance">教程16更多继承</a> ：</td><td>  </td><td align="left" valign="top">向您展示如何使用继承来减少代码重复量。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态性</a> ：</td><td>  </td><td align="left" valign="top">了解为什么在大多数情况下，使用多态性比运行时类型查询更好。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top">• <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e">教程18高级JTW</a> ：</td><td>  </td><td align="left" valign="top">将JTW映射到Java以及JTW系统的内部细节，包括GNU Makefile。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr></tbody></table>

<hr>
<a name="Tutorial-1-Your-first-program"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-2-Introduction-to-programming-in-Java" rel="next" accesskey="n">教程2 Java编程简介</a> ，上： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-1-Your-first-program-1"></a>
<h3 class="section">4.1教程1您的第一个程序</h3>


<a name="J_002eT_002eW_002e-tarball"></a><a name="index-A-tarball-to-get-you-started"></a>
<a name="index-_007e_002fjtw_002dtutorials"></a>

<p>问题4.1.1：一些代码可以帮助您入门。首先，请访问以下网站<a href="http://davin.50webs.com/J.T.W/download-links.html">http://davin.50webs.com/JTW/download-links.html，</a>了解在JTW中进行任何编码之前需要安装的程序。然后，您应该下载一个tarball（也称为压缩存档文件）： <a href="http://davinpearson.com/binaries/java-training-wheels.tar.gz">http</a> : <a href="http://davinpearson.com/binaries/java-training-wheels.tar.gz">//davinpearson.com/binaries/java-training-wheels.tar.gz，</a>其中包含您需要入门的代码。然后解压缩tarball并将目录更改为java-training-wheels并在GNU / Linux系统上发出以下命令：./configure或在MS Windows系统上：bash configure。如果使用的是MS Windows，并且未设置HOME变量，则需要将其设置为合理的值。如果您的d驱动器是硬盘驱动器，则HOME变量的合理值示例包括c：\或c：\ home或d：\ home。要在Windows中设置HOME变量，请按Windows E并右键单击“我的电脑”（Windows XP）或“这台计算机”（Windows 10），然后单击“属性”，然后单击“高级系统设置”，再单击“高级”，然后单击“新环境”。变量以设置HOME变量。
</p>
<a name="index-Installing-Davin_0027s-version-of-Emacs-dlisp_002etar_002egz"></a>
<a name="index-Davin_0027s-version-of-Emacs-dlisp_002etar_002egz"></a>
<a name="index-dlisp_002etar_002egz_002c-Davin_0027s-version-of-GNU-Emacs"></a>
<a name="index-Installing-Davin_0027s-jtw_002dmode"></a>
<a name="index-Davin_0027s-jtw_002dmode_002eel_002c-a-major-mode-for-editing-_002a_002ejtw-files"></a>
<a name="index-jtw_002dmode_002eel-Davin_0027s-major-mode-for-editing-_002a_002ejtw-files"></a>

<p>运行配置脚本时，将提示您输入前缀目录的位置以及用于保存* .jtw文件的位置。还会询问您是否仅安装Davin的jtw-mode或Davin的完整版Emacs。
</p>
<p>注意：如果正在本地文件系统上读取此文件，则您已经完成了此问题。
</p>
<a name="index-My-first-program"></a>
<a name="index-Your-first-program"></a>
<a name="index-Your-first-J_002eT_002eW_002e-program"></a>
<a name="index-_0060_0060Hello_002c-World_0021_0027_0027"></a>
<a name="index-Hello_002c-World_0021"></a>

<p>问题4.1.2：您的第一个JTW程序。传统上，在计算机科学中，您用任何一种编程语言编写的第一个程序都是什么都不做，只能打印“ Hello，World”的程序。下面的代码就是这样做的。在以下代码中，请注意类构造的用法。在Java和JTW中，执行某些实际计算工作的每段程序代码都位于某个描述的类中。
</p>


<div class="example">
<pre class="example">class MyFirstProgram
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello, World!&quot;);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<a name="index-make-build-X_002erun-to-build-and-run-a-class-file_002e"></a>
<a name="index-Building-code-that-uses-a-class"></a>

<p>这些教程中任何X类的代码都应驻留在名为X.jtw的文件中。因此，以上代码应放入名为MyFirstProgram.jtw的文件中。如果两个类X和Y互相使用，并且X包含main函数，则将它们都放置在名为X.jtw的文件中会很方便。要构建和运行一些代码，首先需要在〜/ jtw-tutorials文件夹中，其次您需要发出以下shell命令：make X.run其中X是要运行的类的名称，因此它是</p>
<div align="center">使MyFirstProgram.run</div>
<p>在这种情况下。对于此问题之后的所有问题，都将假定您知道该如何做。有关<a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">构建</a>在不同文件中使用其他类的类或构建整个包的更多信息，请参见<a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个包的集合</a> 。
</p>
<p>问题4.1.3：多次调用System.out.println（）。通过打印字符串“ Hello，World！”来更改上面的代码。”以打印以下消息。请注意，使用System.out.println（）多次调用将是最简单的方法，该调用将文本发送到屏幕上以供查看。
</p>
<a name="index-System_002eout_002eprintln_0028_002f_002a-args-_002a_002f_0029_003b"></a>

<div class="example">
<pre class="example">Hello, Anne! How are you doing?
Hello, Brian! How are you doing?
Hello, Clare! How are you doing?
</pre></div>

<p>问题4.1.4：函数，参数和自变量。函数是一段代码，它执行一些计算工作并有选择地返回一个值。请注意，下面的hello函数如何使用其名字向其打招呼的值。该值称为参数。通过调用函数传递给参数的值称为参数。出于这个问题的目的，在main函数中向hello函数添加了两个调用，以获得与上一个问题的代码相同的结果。关键字void指示此函数不返回值。有关返回值的函数，请参见下一个问题。
</p>
<a name="index-Functions_002c-parameters-and-arguments"></a>

<div class="example">
<pre class="example">class MySecondProgram
begin
&nbsp;&nbsp;&nbsp; function void hello(String who)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello &quot; + who + &quot;, how are you doing?&quot;);
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hello(&quot;Anne&quot;);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.1.5：返回值。请注意以下hello函数如何返回字符串而不是打印出该字符串。在下面的hello函数中再添加两个调用，以获得与问题4.1.4相同的结果。
</p>
<a name="index-Return-values"></a>

<div class="example">
<pre class="example">class MyThirdProgram
begin
&nbsp;&nbsp;&nbsp; function String hello(String who)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;Hello &quot; + who + &quot;, how are you doing?&quot;;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(hello(&quot;Anne&quot;));
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.1.6：忽略返回值。在JTW和Java中，没有必要使用函数返回的值。有时这会浪费计算资源，因为没有使用该函数计算出的值，但是有时将其值忽略的函数会通过将某些变量的值设置为不同的值来做一些额外的工作，然后函数调用并不浪费资源。要忽略hello函数返回的值，只需调用函数而不使用如下值：hello（“ Ignored”）;出于这个问题的目的，请尝试在主函数中添加一行代码，以在不使用返回值的情况下调用hello函数。
</p>
<a name="index-Ignoring-the-return-values-of-functions-and-methods_002e"></a>

<p>问题4.1.7：评论。学习以下代码。注意注释的使用。注释用于出于调试目的禁用代码，还有助于说明程序的工作方式。在JTW和Java中，最有用的注释是/ **，直到第一个* /。Javadoc收集了这种类型的注释，以生成有关类如何工作的文档。第二和第三最有用的注释分别是//，直到行的末尾，和/ *，直到第一个* /。第三种注释不是很有用，因为在Java中不允许在一个注释中包含一个注释，因此，如果使用这种类型的注释，则将不断需要搜索并删除* /结束注释。在随后的教程中，您将看到许多注释，尽管主要是第一和第二类型的注释。
</p>
<a name="index-Comments-harvested-by-Javadoc"></a>
<a name="index-Javadoc_002c-harvesting-of-comments"></a>

<div class="example">
<pre class="example">/** This comment is harvested by Javadoc
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; to document the MyFourthProgram class */
class MyFourthProgram
begin // I am a single line comment
&nbsp;&nbsp;&nbsp; /* I am
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a multi-line
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; comment */
&nbsp;&nbsp;&nbsp; /** This comment is harvested by Javadoc
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; to document the hello function */
&nbsp;&nbsp;&nbsp; function String hello(String who)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;Hello &quot; + who + &quot;, how are you doing?&quot;;
&nbsp;&nbsp;&nbsp; end )
&nbsp;&nbsp;&nbsp; /** This comment is harvested by Javadoc
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; to document the main function */
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(hello(&quot;Anne&quot;));
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>



<hr>
<a name="Tutorial-2-Introduction-to-programming-in-Java"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-3-superfor-loops-and-for-loops" rel="next" accesskey="n">教程3 superfor循环和for循环</a> ，上一篇： <a href="#Tutorial-3-superfor-loops-and-for-loops" rel="next" accesskey="n">教程</a> <a href="#Tutorial-1-Your-first-program" rel="prev" accesskey="p">1您的第一个程序</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-2-Introduction-to-programming-in-Java-1"></a>
<h3 class="section">4.2教程2 Java编程简介</h3>

<p>问题4.2.1：以下代码返回当前参数ch是否为元音。参数ch是char类型的，用于保存字符串的组成部分。也就是说，字符串是根据字符序列构建的。还要注意使用Character.toUpperCase函数将字符转换为大写字符，以便该代码对于isVowel（'a'）和isVowel（'A'）同样有效。学习，编译并运行以下代码。它会打印出您期望的样子吗？如果不是，则修复该错误。
</p>
<a name="index-Character_002etoUpperCase"></a>
<a name="index-Introducing-chars"></a>
<a name="index-chars_002c-introducing"></a>

<div class="example">
<pre class="example">class Scrabble
begin
&nbsp;&nbsp;&nbsp; function boolean isVowel(char ch)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ch = Character.toUpperCase(ch);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((ch == 'A') or (ch == 'E') or (ch == 'I') or (ch == 'O') or (ch == 'U'))
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then return true;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else return false;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(isVowel('a'));
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<a name="index-The-difference-between-_003d_003d-and-_003d"></a>

<p>在上面的代码中，请注意a = b示例：ch = Character.toUpperCase（ch）和a == b示例：ch =='A'之间的区别。第一个是将a设置为b的值的赋值，而第二个是一个问题，说明两个参数a和b是否相等。
</p>
<p>请注意，在本教程的后面部分，您将学到，这不是比较两个字符串的方法。还要注意布尔返回类型的使用。这意味着返回值是true或false。
</p>
<p>问题4.2.2：复制上面代码建立的模式，编写一个函数isConsonant，该函数返回给定的参数是否不是元音。最简单的方法是编写isVowel（ch）== false，这意味着：“ ch不是元音”。您还需要确保参数ch大于或等于'A'并且小于或等于'Z'。然后通过从主函数调用isConsonant来测试代码。
</p>
<p>问题4.2.3：通过复制以下代码中建立的模式：</p>
<div class="example">
<pre class="example">function int countVowels(String word)
begin
&nbsp;&nbsp;&nbsp; var int result = 0;
&nbsp;&nbsp;&nbsp; superfor (var int i=0 to i&lt;word.length()-1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var char ch = word.charAt(i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isVowel(ch)) then result = result + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; return result;
end
</pre></div>

<p>编写一个函数来计算单词中辅音的数量。请注意，使用var关键字定义函数局部变量。局部变量与上一教程中介绍的参数非常相似。在上面的代码中，请注意word.charAt（i）和word.length（）的使用。这些结果中的第一个结果是字符串单词中由i的值给出的位置处的字符，而第二个结果则返回了字符串单词的长度。在教程11中，您将学习到这些被称为方法的方法，这些方法不同于当前知道如何编写的函数。在阅读本教程之前，我们准备好教您如何编写自己的方法，您将仅调用现有方法，例如上述String类的方法。然后通过从main函数调用代码来测试您的代码。
</p>
<a name="index-Calling-existing-methods-of-the-String-class"></a>

<p>问题4.2.4：编写一个函数simpleScoreWord，它调用countVowels和countConsonants给出单词的简单分数。单词的简单分数是单词中的元音数量加上单词中辅音的数量乘以十。然后通过从main函数调用代码来测试您的代码。
</p>
<p>问题4.2.5：编写一个函数AdvancedScoreLetter，该函数返回字母的高级分数。这是用于计算高级分数的字母分布的细分。
</p>
<div class="example">
<pre class="example">2 blank tiles (scoring 0 points)
1 point: E 12 tiles, A 9 tiles, I 9 tiles, O 8 tiles, N 6 tiles, R 6 tiles, T 6 tiles, L 4 tiles, S 4 tiles, U 4 tiles
2 points: D 4 tiles, G 3 tiles
3 points: B 2 tiles, C 2 tiles, M 2 tiles, P 2 tiles
4 points: F 2 tiles, H 2 tiles, V 2 tiles, W 2 tiles, Y 2 tiles
5 points: K 1 tiles
8 points: J 1 tiles, X 1 tiles
10 points: Q 1 tiles, Z 1 tiles
</pre></div>

<p>然后通过从main函数调用代码来测试您的代码。
</p>
<p>问题4.2.6：编写一个函数AdvancedScoreWord，该函数返回单词的高级分数。单词的高级分数是单词中每个字母的高级分数的总和。如果单词的长度为八个字母，则应在分数上多加50分。然后通过从main函数调用代码来测试您的代码。
</p>
<p>问题4.2.7：比较字符串。修改advancedScoreWord函数，以使脏话得分为零。出于这个问题的目的，您只需要考虑三个誓言词即可添加到代码中。为了不冒犯任何人的利益，请您对脏话的选择保持温和。当比较字符串时，使用==是一个错误，您已经知道这是如何比较到目前为止所知道的以下类型：布尔值，字符和整数。在字符串上使用==可以编译并运行，但是会给您不正确的结果。比较字符串的正确方法是使用字符串类的equals方法，如下所示：word.equals（“ bugger”）根据字符串单词当前是否包含值“ bugger”，返回true或false。
</p>
<p>问题4.2.8：更改advancedScoreWord函数，以使其与大写单词和小写单词同样有效。您将需要写操作来调用word.toUpperCase（）或word.toLowerCase（）并将结果存储在word中。
</p>
<a name="index-toUpperCase_0028_0029-of-the-String-class"></a>
<a name="index-toLowerCase_0028_0029-of-the-String-class"></a>



<hr>
<a name="Tutorial-3-superfor-loops-and-for-loops"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-4-Four-looping-constructs" rel="next" accesskey="n">教程4四个循环结构</a> ，上一篇： <a href="#Tutorial-4-Four-looping-constructs" rel="next" accesskey="n">教程</a> <a href="#Tutorial-2-Introduction-to-programming-in-Java" rel="prev" accesskey="p">2 Java编程简介</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-3-superfor-loops-and-for-loops-1"></a>
<h3 class="section">4.3教程3 superfor循环和for循环</h3>


<p>问题4.3.1a：对于以1为步长累加的循环。研究以下代码，并通过编译和运行它来验证它是否打印出“ 2 3 4 5 6 7 8 9 10”。请注意，在打印参数值后，System.out.print（）函数调用不会打印回车符。这就是为什么在for循环superfor和for的末尾需要System.out.println（）函数调用，以便在该行的末尾打印回车的原因。还要注意，使用加号连接字符串，并使用数字产生字符串结果。
</p>
<a name="index-Introducing-the-System_002eout_002eprint-construct"></a>
<a name="index-Introducing-the-System_002eout_002eprintln-construct"></a>
<a name="index-System_002eout_002eprint-construct_002c-introducing"></a>
<a name="index-System_002eout_002eprintln-construct_002c-introducing"></a>
<a name="index-Introducing-the-superfor-construct"></a>
<a name="index-superfor-construct_002c-Introducing"></a>

<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain )
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=2 to 10) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int i=2; i&lt;=10; i=i+1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>



<p>问题4.3.1b：更改superfor循环和普通的for循环以输出以下数字：“ 5 6 7 8 9 10”。
</p>
<p>问题4.3.1c：更改superfor循环和普通的for循环以输出以下数字：“ 234 235 236 237 238”。
</p>
<p>问题4.3.1d：更改superfor循环和普通的for循环以输出以下数字：“ 48 49 50 ... 75 76”。
</p>
<p>问题4.3.1e：更改superfor循环和普通的for循环以输出以下数字：“-5 -4 -3 -2 -1 0 1 2 3”。
</p>
<p>问题4.3.2a：对于以大于1的步长累加的循环。研究以下代码，并通过编译并运行它来验证它是否打印出“ 10 15 20 25 30 35 40”。
</p>
<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain )
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=10 to 40 step 5) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int i=10; i&lt;=40; i=i+5) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.3.2b：更改superfor循环和普通的for循环以输出以下数字：“ 20 25 30 35 40”。
</p>
<p>问题4.3.2c：更改superfor循环和普通的for循环以输出以下数字：“ 100 105 110 115 120 125”。
</p>
<p>问题4.3.2d：更改superfor循环和普通的for循环以输出以下数字：“ 2 4 6 8 10 12 14”。
</p>
<p>问题4.3.2e：更改superfor循环和普通的for循环以输出以下数字：“ 10 13 16 19 22 25”。
</p>
<p>问题4.3.3a：对于以一步为单位递减计数的循环。研究以下代码，并通过编译和运行它来验证它是否打印出“ 10 9 8 7 6 5 4 3 2 1”。
</p>
<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=10 downto 1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int i=10; i&gt;=1; i=i-1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.3.3b：更改superfor循环和普通的for循环以输出以下数字：“ 10 9 8 7 6 5 4”。
</p>
<p>问题4.3.3c：更改superfor循环和普通for循环以输出以下数字：“ 20 19 18 17 16 15 15 14 13 12”。
</p>
<p>问题4.3.3d：更改superfor循环和普通的for循环以输出以下数字：“ 66 65 64 ... 47”。
</p>
<p>问题4.3.3e：更改superfor循环和普通的for循环以输出以下数字：“ 3 2 1 -1 -2 -3 -4 -5 -6 -7”。
</p>
<p>问题4.3.4a：对于递减计数大于1的循环。研究以下代码，并通过编译并运行它来验证是否打印出“ 100 90 80 70 70 60 50 40 30 20”。
</p>
<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=100 downto 20 step -10) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int=100; i&gt;=20; i=i-10) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.3.4b：更改superfor循环和普通for循环以打印出以下数字：“ 80 70 60 50 40 30 20”。
</p>
<p>问题4.3.4c：更改superfor循环和普通的for循环以输出以下数字：“ 500 490 480 470 460”。
</p>
<p>问题4.3.4d：更改superfor循环和普通的for循环以输出以下数字：“ 10 8 6 4 2 0”。
</p>
<p>问题4.3.4e：更改superfor循环和普通的for循环以输出以下数字：“ 33 28 23 18 13 8 3”。
</p>
<p>问题4.3.5a：对于使用浮点数进行计数的循环。研究以下代码，并通过编译和运行它来验证它输出“ 1.1 2.2 3.3 4.4”。类型名称double是short，代表double精度浮点。很自然地要问：为什么不使用单精度浮点数？这个问题的答案是，双精度浮点比单精度浮点产生的编译错误更少。
</p>
<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain )
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var double i=1.1 to 4.4 step 1.1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var double i=1.1; i&lt;=4.4; i=i+1.1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.3.5b：更改superfor循环和普通的for循环以输出以下数字：“ 0 2.2 4.4 6.6”。请注意，舍入错误可能会阻止您获得此准确答案。还要注意，此问题的答案不是您不运行代码就天真的期望。
</p>
<p>问题4.3.5c：更改superfor循环和普通的for循环以输出以下数字：“-30 -19.9 -9.8 0.3 10.4 20.5”。
</p>
<p>问题4.3.5d：更改superfor循环和普通的for循环以输出以下数字：“ 100.0 96.7 93.4 90.1 86.8 83.5 80.2 76.9”。
</p>
<p>问题4.3.5e：更改superfor循环和普通的for循环以输出以下数字：“-100.0 -105.5 -111.0 -116.5”。
</p>
<p>问题4.3.6a：对于使用字符进行计数的循环。研究以下代码，并验证并通过运行它来打印出“ abcdefghijklmnopq rstuvwxy z”。
</p>
<div class="example">
<pre class="example">class ForTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the superfor loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var char i='a' to 'z') System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Here is the ordinary for loop: */
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var char i='a'; i&lt;='z'; i=i+1) System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.3.6b：更改superfor循环和普通的for循环以打印出以下数字：“ abcde f”。
</p>
<p>问题4.3.6c：更改superfor循环和普通的for循环以输出以下数字：“ zyxwvutsrqponmlkjihgf edcb a”。
</p>
<p>问题4.3.6d：更改superfor循环和普通的for循环以输出以下数字：“ ponmlkji h”。
</p>
<p>问题4.3.6e：更改superfor循环和普通的for循环以输出以下数字：“ ABCDEFGHIJKLMNOPQRSTU VWXY Z”。
</p>



<hr>
<a name="Tutorial-4-Four-looping-constructs"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-5-A-beer-drinking-song" rel="next" accesskey="n">教程5喝啤酒的歌</a> ，上一篇： <a href="#Tutorial-5-A-beer-drinking-song" rel="next" accesskey="n">教程</a> <a href="#Tutorial-3-superfor-loops-and-for-loops" rel="prev" accesskey="p">3 superfor循环和for循环</a> ，上： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-4-Four-looping-constructs-1"></a>
<h3 class="section">4.4教程4四个循环结构</h3>

<p>问题4.4.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class LoopTest
begin
&nbsp;&nbsp;&nbsp; function int powerOf2A(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int counter = n;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int result  = 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (counter &gt; 0)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = 2 * result;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; counter = counter - 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function int powerOf2B(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int counter = n;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int result  = 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; do
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = 2 * result;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; counter = counter - 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end while (counter &gt; 0);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function int powerOf2C(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int result = 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int counter = n; counter &gt; 0; counter = counter - 1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = 2 * result;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function int powerOf2D(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int result = 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int counter=n downto 1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = 2 * result;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp;  /**
&nbsp;&nbsp;&nbsp;   * Prints a row of stars of a given length.
&nbsp;&nbsp;&nbsp;   */
&nbsp;&nbsp;&nbsp; function void printLineC(int length)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int i = 0; i&lt;length; i=i+1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.print(&quot;#&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // For Question 4.4.1 add some code here...
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<a name="index-Introducing-while-loops-do-_002e_002e_002e-while-loops"></a>
<a name="index-while-loop"></a>
<a name="index-do-_002e_002e_002e-while-loop"></a>
<a name="index-for-loop"></a>

<p>问题4.4.2：在主函数中添加一些代码来调用函数powerOf2A，powerOf2B，powerOf2C和powerOf2D，以验证它们均返回相同的结果。要检查结果，您需要将System.out.println（）语句应用于这些函数返回的值。
</p>
<p>问题4.4.3：powerOf2B函数中存在一个错误，因为在n为零或更小的情况下，它无法正确运行。在此函数的顶部放置一个if（...）then ...语句，以使其正确处理零的情况。如果n小于零，也使它返回1。
</p>
<p>问题4.4.4：powerOf2D函数中有一个错误，因为在n为零或负数的情况下，它无法正确运行。如果n <= 0，则使其返回1。放一个if（...）然后...该函数顶部的语句，以使其能够正确处理这些情况。由于此函数返回一个int，因此在这种情况下使其返回1。
</p>
<p>问题4.4.5：通过复制powerOf2A，powerOf2B，powerOf2C和powerOf2D的模式，编写函数printLineA，printLineB和printLineD的功能与函数printLineC相同，不同之处在于它们分别使用while循环，do循环和superfor循环。在主函数中添加一些代码以对其进行测试。
</p>
<p>问题4.4.6：基于前面的三个问题，是否存在最佳的循环结构？还是取决于要使用的循环构造？
</p>
<a name="index-The-best-of-the-four-looping-constructs-superfor_002c-for_002c-while-and-do-_002e_002e_002e-while"></a>



<hr>
<a name="Tutorial-5-A-beer-drinking-song"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-6-Class-variables" rel="next" accesskey="n">教程6类变量</a> ，上一篇： <a href="#Tutorial-6-Class-variables" rel="next" accesskey="n">教程</a> <a href="#Tutorial-4-Four-looping-constructs" rel="prev" accesskey="p">4四个循环结构</a> ，上： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-5-A-beer-drinking-song-1"></a>
<h3 class="section">4.5教程5喝啤酒的歌</h3>

<p>问题4.5.1：研究以下代码，然后编译并运行它以验证是否将歌词打印为流行歌曲：</p>
<a name="index-Beer-drinking-song"></a>

<div class="example">
<pre class="example">class BeerSong
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Five bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Five bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;there'd be four bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Four bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Four bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;there'd be three bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Three bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Three bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;there'd be two bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Two bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Two bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;There'd be one bottle of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;One bottle of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;One bottle of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;there'd be no bottles of beer on the wall.&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.5.2：以下是使代码更小但保持相同输出的第一次尝试：如果编译并运行以下代码，您会注意到它从1开始而不是从n开始递减计数。更改for循环，使其运行而不是运行。有关如何编写for循环的信息，请参阅教程4.2。
</p>
<div class="example">
<pre class="example">class BeerSong
begin
&nbsp;&nbsp;&nbsp; function song(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=1 to n)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(i + &quot; bottles of beer on the wall&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(i + &quot; bottles of beer on the wall&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;If one bottle of beer should accidentally fall,&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;there'd be &quot; + (i-1) + &quot; bottles of beer on the wall&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; song(5);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问4.5.3：完成下面的number2string函数，并在song函数中向该函数添加一个新函数调用，以使其输出文本数字而不是数字。
</p>
<div class="example">
<pre class="example">function String number2string(int n)
begin
&nbsp;&nbsp;&nbsp; assert n&gt;=0 : n;
&nbsp;&nbsp;&nbsp; assert n&lt;=10: n;
&nbsp;&nbsp;&nbsp; if (n == 0) then return &quot;no&quot;;
&nbsp;&nbsp;&nbsp; if (n == 1) then return &quot;one&quot;;
&nbsp;&nbsp;&nbsp; if (n == 2) then return &quot;two&quot;;
&nbsp;&nbsp;&nbsp; /* rest of code goes here */
&nbsp;&nbsp;&nbsp; if (n == 9) then return &quot;nine&quot;;
&nbsp;&nbsp;&nbsp; if (n == 10) then return &quot;ten&quot;;
&nbsp;&nbsp;&nbsp; assert false;
end
</pre></div>

<p>问题4.5.4：添加一个新函数String capitalize（String s）以大写String中的第一个单词，然后从song函数中调用此函数，以便每个句子中的第一个单词都被大写。您应该在软件包java.lang中找到Character.toUpperCase函数以及charAt和substring方法对编写此函数很有帮助。有关更多详细信息，请参见位于<a href="http://docs.oracle.com/javase/1.5.0/docs/api">http://docs.oracle.com/javase/1.5.0/docs/api的</a> java.lang软件包中的String类。
</p>
<p>问题4.5.5：添加新的函数调用String plural（int n），如果n不等于1，则返回字符串“ s”，否则返回空字符串“”。然后从song函数调用此函数，以便短语“ bottle”在应有的时候复数。
</p>
<p>问题4.5.6：编写一个名为number2string2的函数，该函数可以处理不超过100的值。请注意，您将需要多个if ... then语句来实现此目的。请注意，如果n是数字，则以下表达式很有用：</p>
<div class="example">
<pre class="example">&nbsp;&nbsp;&nbsp;  var int temp1 = n / 10 % 10 results in temp1 holding the tens digit of n and is zero in the case that n&lt;10.
&nbsp;&nbsp;&nbsp;  var int temp2 = n % 10 results in temp2 holding the ones digit of n.
</pre></div>

<p>在n> = 100的情况下，还要打印出“一百或更多”</p>
<p>问题4.5.7：更改song函数，以便调用以下函数：song（5，“ rum”）;在主功能中将得到以下打印输出：</p>
<div class="example">
<pre class="example">Five bottles of rum on the wall.

...

there'd be no bottles of rum on the wall.
</pre></div>

<p>问题4.5.8：一旦所有代码都起作用，则将以下行添加到主函数中：song（100，“ gin”）;以便打印出以下内容：</p>
<div class="example">
<pre class="example">One hundred bottles of gin on the wall.

...

there'd be zero bottles of gin on the wall.
</pre></div>

<p>问题4.5.9：编写一个新函数number2string3，其功能类似于number2string2和number2string，但它最多处理999个数字。内部number2string3应该调用number2string2。您可能会发现以下功能有用：</p>
<div class="example">
<pre class="example">function String textand(String a, String b)
begin
&nbsp;&nbsp;&nbsp; if (a.equals(&quot;&quot;) or b.equals(&quot;&quot;)) then return a + b;
&nbsp;&nbsp;&nbsp; else return a + &quot; and &quot; + b;
end
</pre></div>

<p>问题4.5.10：棘手！编写一个新函数number2string4，其功能类似于number2string3 execpt，它处理的数字最多为99.99.99.99.99，即999,999,999。函数number2string4应该在内部调用number2string3，如下所示：</p>
<div class="example">
<pre class="example">var String ones = number2string3(n % 1000);
var String thousands = number2string3(n / 1000 % 1000);
var String millions = number2string3(n / 1000 / 1000 % 1000);
</pre></div>

<p>请注意，上面的变量将具有从0到999（含）之间的值。
</p>


<hr>
<a name="Tutorial-6-Class-variables"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-7-Non_002dObject-arrays" rel="next" accesskey="n">教程7非对象数组</a> ，上一篇： <a href="#Tutorial-7-Non_002dObject-arrays" rel="next" accesskey="n">教程</a> <a href="#Tutorial-5-A-beer-drinking-song" rel="prev" accesskey="p">5喝啤酒的歌</a> ，上<a href="#Tutorial-5-A-beer-drinking-song" rel="prev" accesskey="p">一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-6-Class-variables-1"></a>
<h3 class="section">4.6教程6类变量</h3>

<p>问题4.6.1：研究，编译并运行以下代码。注意使用类变量myMoney。类变量与函数局部变量不同，因为类变量的生存期是在程序运行期间，而局部变量的生存期是在函数调用期间。在下面的代码中，变量myMoney用于存储数值，以表示您有多少钱。
</p>
<a name="index-Introducing-class-variables"></a>

<div class="example">
<pre class="example">class Money
begin
&nbsp;&nbsp;&nbsp; /** Property myMoney stores money value in dollars */
&nbsp;&nbsp;&nbsp; classVar int myMoney;

&nbsp;&nbsp;&nbsp; function void spend(String item, int value)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; myMoney = myMoney - value;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;*** spent $&quot; +
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  value +
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &quot; on &quot; + item +
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &quot;, leaving you with $&quot; + myMoney);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; myMoney = 100;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; spend(&quot;aquarium&quot;,50);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; spend(&quot;shoes&quot;,100);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; spend(&quot;lipstick&quot;,20);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.6.2：更改myMoney类变量，使其为双精度（双精度浮点数的缩写）而不是整数。您将需要添加一个新函数money2string，该函数将双精度值转换为字符串。例如，浮点数1.2345应该打印为$ 1.23。如果x是双精度数，则以下表达式将x从双精度数转换为美元（int）x，以下表达式将x转换为美分（int）（money * 100）-100 *美元。请注意，您将需要制作它，以便将$ 1.03作为该值打印出来。
</p>
<p>问题4.6.3：将一个if语句添加到支出函数，以便如果此人的银行帐户中没有足够的资金来支付item参数，则它使用System.out.println（）打印错误消息。
</p>
<p>问题4.6.4：添加一个新的类别变量doublegovernmentsMoney，并使每一项的成本的12.5％以商品及服务税的形式交给政府，商品及服务税代表增值税。
</p>
<p>问题4.6.5：添加一个新的类变量numBattleships，该变量记录政府拥有多少个BATTLEship。编写一个功能buyBattleShips，使政府购买力所能及的尽可能多的战舰。做到这一点，使buyBattleShips函数可以打印出购买了多少艘战舰。假设每艘战舰的成本为一百万美元，并将此值存储在一个名为costOfShip的变量中。请注意，如果政府的钱少于一百万美元，那么就不会购买战列舰。
</p>
<p>问题4.6.6：将governanceMoney的初始值设置为两百万美元，然后调用buyBattleShips函数并验证是否购买了两艘战舰。
</p>

<hr>
<a name="Tutorial-7-Non_002dObject-arrays"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class" rel="next" accesskey="n">教程8从另一个类访问函数和类变量，上一篇</a> ： <a href="#Tutorial-6-Class-variables" rel="prev" accesskey="p">教程6类变量</a> ，上<a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class" rel="next" accesskey="n">一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-7-Non_002dObject-arrays-1"></a>
<h3 class="section">4.7教程7非对象数组</h3>




<p>本教程教您如何创建非对象的一维和多维数组。Java中的非对象类型是未在类内部声明的类型，因此它包括以下类型：布尔，char，int，float和double。Java中的一个有用约定是，非对象类型以小写字母开头，而对象类型以大写字母开头，例如String类作为Object类型的示例。除此之外，还提供了两种不同的数组初始化语法。
</p>
<a name="index-Arrays"></a>
<a name="index-Introducing-non_002dObject-arrays"></a>
<a name="index-Introducing-single_002ddimensional-non_002dObject-arrays"></a>
<a name="index-Arrays-of-non_002dObject-type_002c-single_002ddimensional"></a>
<a name="index-Non_002dObject-arrays_002c-single_002ddimensional"></a>

<a name="Single_002ddimensional-non_002dObject-arrays-1"></a>
<h4 class="subsection">4.7.1一维非对象数组</h4>

<a name="Single_002ddimensional-non_002dObject-arrays"></a>
<a name="index-Arrays-of-non_002dObject-type_002c-first-initialization-syntax"></a>
<a name="index-First-initialization-syntax-for-arrays-of-non_002dObject-type"></a>



<p>问题4.7.1：这是一个方便的一维数组初始化语法的示例。学习，编译并运行以下代码。应该将int []代码读为int数组，表示变量a是int数组，也称为int数组。请注意，下面的for循环的第一个值为零。这是因为在JTW和Java中，数组的第一个索引为零而不是一个。该约定可以追溯到C编程语言的旧时代，之所以被使用是因为它在低级别的机器语言中比从一个数组中计数数组更有效。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int[] a = { 1,2,3 };
&nbsp;&nbsp;&nbsp; superfor (var int i=0 to a.length-1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;a[&quot; + i + &quot;]=&quot; + a[i]);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>由于Java创建者的设计监督，您不能使用此语法重新初始化数组，如下所示：</p>
<div class="example">
<pre class="example">a = { 4,5,6 }; // Compilation error
</pre></div>

<p>幸运的是，有一种方法可以绕过这种监督，那就是使用一种设计模式，在其中引入一个临时变量，如下所示：</p>
<div class="example">
<pre class="example">var int[] temp = { 4,5,6 };
a = temp; // Array &quot;a&quot; now holds 4 5 6
</pre></div>

<p>稍后，您将了解为什么这种设计模式对于重新初始化多维数组很有用。
</p>
<p>问题4.7.2：编写一个带有int数组参数并打印出数组的函数print。您将需要使用array参数的length属性，以便您的函数可以使用任意大小的数组。将main函数更改为以下内容，以便包含对print函数的调用。
</p>
<div class="example">
<pre class="example">var int[] a = { 1,2,3 };
print(a);
</pre></div>

<p>问题4.7.3：编写一个函数，其名称与先前的打印函数相同，不同之处在于该函数应采用double []（也称为double数组）作为参数。Java中允许在同一类中使用两个具有相同名称的函数，并且使用惯例有一个特殊名称，即：函数名称重载。仅当两个具有相同名称的函数具有不同的参数时，才允许重载。调用重载函数时，JTW和Java会查看参数的数量和类型，并由此确定要调用哪个重载函数。将main函数更改为以下内容，以便它初始化一个双精度浮点变量数组，然后调用第二个print函数。
</p>
<div class="example">
<pre class="example">var double[] b = { 1.1,2.2,3.3 };
print(b);
</pre></div>

<a name="index-Arrays-of-non_002dObject-type_002c-second-initialization-syntax"></a>
<a name="index-Second-initialization-syntax-for-arrays-of-non_002dObjects"></a>

<p>这是第二种初始化语法的示例。对于此特定示例，最好使用更简单，更早的初始化语法，但是当要在运行时确定要创建的数组的大小时，则应使用第二种语法。下一个问题将向您显示一个示例。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int[] a = new int[3]; )
&nbsp;&nbsp;&nbsp; // at this point the array is all zeroes
&nbsp;&nbsp;&nbsp; for (var int i=0; i&lt;3; i=i+1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a[i] = i;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问题4.7.4：编写一个函数create需要一个int参数，即要创建的数组的大小，并返回该大小的int数组。使它的数组的第i个元素初始化为i。从主函数调用此函数，如下所示：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int[] a = create(3);
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问题4.7.5：编写一个函数create2时需要一个int参数，即要创建的数组的大小，并返回该大小的双精度数组。使其数组的第i个元素初始化为ii为什么不能重载该create函数？试试看，看看编译器怎么说。从主函数调用create2，如下所示：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var double[] a = create2(3);
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问题4.7.6：编写一个函数加倍器，该函数加一个整数数组x，并返回一个新的整数数组结果，该结果是x的两倍。将x复制到结果中，然后再返回。结果中的多余元素应全部为零。
</p>
<p>问题4.7.7：更改doubler函数，以便将数组结果中的每个零都设置为值13。
</p>
<a name="Two-dimensional-non_002dObject-arrays"></a>
<h4 class="subsection">4.7.2二维非对象数组</h4>

<a name="index-Two_002ddimensional-non_002dObject-arrays"></a>
<a name="index-Non_002dObject-arrays_002c-two_002ddimensional"></a>
<a name="index-Arrays-of-non_002dObject-type_002c-two_002ddimensional"></a>

<p>问题4.7.8：这是一个方便的二维数组初始化语法的示例。学习，编译并运行以下代码。代码int [] []应该作为int数组数组大声读出，指示变量a是int数组数组，也称为int的二维数组。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int[][] a = { { 1,2,3 } { 4,5 } { 6 } }

&nbsp;&nbsp;&nbsp; for (var int y=0; y&lt;a.length; y=y+1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var int x=0; x&lt;a[y].length; x=x+1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.print(&quot; &quot; + a[y][x]);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>问题4.7.9：通过复制上面的代码模式，通过编写两个新的打印函数对打印函数进行更多重载，一个新的打印函数是一个二维整数数组，另一个是一个二维的双精度数组。从主函数调用这两个函数。
</p>
<a name="index-Function-name-overloading"></a>

<p>注意，如果x是一个整数的二维数组，则x [i]是一个整数数组，每个整数的范围为0 ... x.length-1。请注意，在上面的代码中，a [0]是三个整数的数组，a [1]是两个整数的数组，而a [2]是一个整数的数组。这些子阵列大小各异的原因是为了节省计算机的宝贵内存。例如，您可以拥有一个比其他所有子数组都长得多的子数组，而无需分配一整堆将不使用的内存。由于a [0]是一个int数组，因此您天真地希望它能够像这样被重新初始化：</p>
<div class="example">
<pre class="example">a[0] = { 4,5,6,7};)
</pre></div>

<p>因此，在此代码之后，a [0]保存着四个元素长的数组4,5,6和7。但是如上所述，在<a href="#Single_002ddimensional-non_002dObject-arrays">一维非对象数组中</a> ，由于Java的创建者对设计的监督，因此无法使用。幸运的是，如上所述，可以通过一种临时变量来避免这种监督：</p>
<div class="example">
<pre class="example">var int[] temp = { 4,5,6,7};
a[0] = temp;) // Array &quot;a[0]&quot; now holds 4 5 6 7
</pre></div>

<p>像一维数组一样，二维数组也有第二种初始化语法。与上面的代码不同，子数组a [0]，a [1]和a [2]的大小相等，即为三个。
</p>
<div class="example">
<pre class="example">var int[][] a = new int[3][3];
a[0][0] = 1; a[1][0] = 2; a[2][0] = 3;
a[0][1] = 4; a[1][1] = 5;
a[0][2] = 6;
</pre></div>

<p>问题4.7.10：编写一个函数int3和create4，它们具有int参数大小，并分别返回一个由int或double类型组成的二维数组。Make是这样，如果a是返回数组的名称，则a [y] [x]设置为x + y的值。
</p>
<a name="Three_002ddimensional-non_002dObject-arrays"></a>
<h4 class="subsection">4.7.3三维非对象数组</h4>

<a name="index-Three_002ddimensional-non_002dObject-arrays"></a>
<a name="index-Arrays-of-non_002dObject-type_002c-three_002ddimensional"></a>

<p>问题4.7.11：使用到目前为止所获得的有关数组的知识，创建，初始化和打印3维整数数组。
</p>



<hr>
<a name="Tutorial-8-Accessing-functions-and-class-variables-from-another-class"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods" rel="next" accesskey="n">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a> ，上一篇： <a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods" rel="next" accesskey="n">教程</a> <a href="#Tutorial-7-Non_002dObject-arrays" rel="prev" accesskey="p">7非对象数组</a> ，上<a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-8-Accessing-functions-and-class-variables-from-another-class-1"></a>
<h3 class="section">4.8教程8从另一个类访问函数和类变量</h3>




<p>问题4.8.1：研究，编译并运行以下代码，该代码位于名为Box.jtw的文件中。注意，使用System.out.print（）进行打印时不使用尾随换行符，而使用System.out.println（）进行打印时使用尾随换行符。ln部分告诉您这一点。
</p>
<div class="example">
<pre class="example">class Box
begin
&nbsp;&nbsp;&nbsp; function void square(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int y=0 to n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int x=0 to n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((x == 0) or (x == n-1) or (y == 0) or (y == n-1))
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then System.out.print(&quot;#&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else System.out.print(&quot; &quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; square(5);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>请注意，这是上述代码针对n参数的不同值的输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">###<br>＃＃<br>###<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">####<br>＃＃<br>＃＃<br>####<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">#####<br>＃＃<br>＃＃<br>＃＃<br>#####<br></td></tr>
</tbody></table>

<p>问题4.8.2：复制上面代码中建立的模式，编写一个now函数square2，生成以下输出。请注意，您将需要删除上述square方法中的某些or子句，以获取以下输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">###<br>
      <br>###<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">####<br>
      <br>
      <br>####<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">#####<br>
      <br>
      <br>
      <br>#####<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.3：复制上面代码中建立的模式，编写一个now函数square3，该函数生成以下输出：n = 1</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">＃＃<br>＃＃<br>＃＃<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">＃＃<br>＃＃<br>＃＃<br>＃＃<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">＃＃<br>＃＃<br>＃＃<br>＃＃<br>＃＃<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.4：研究，编译并运行以下代码，该代码位于名为Box.java的文件中：</p>
<div class="example">
<pre class="example">class Box
begin
&nbsp;&nbsp;&nbsp; function void x(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int y=0 t0 n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int x=0 to n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((x == y) or (x == n-1-y)) then System.out.print(&quot;#&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else System.out.print(&quot; &quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x(5);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>请注意，这是上述代码针对n参数的不同值的输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">＃＃<br>＃<br>＃＃<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">＃＃<br>##<br>##<br>＃＃<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">＃＃<br>＃＃<br>＃<br>＃＃<br>＃＃<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.5：通过复制以上代码中建立的模式，编写一个now函数x2，生成以下输出。请注意，您将需要删除上述x函数中的or子句之一，以获取以下输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">＃<br>＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">＃<br>＃<br>＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">＃<br>＃<br>＃<br>＃<br>＃<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.6：通过复制以上代码中建立的模式，编写一个now函数x3，该函数生成以下输出。请注意，您将需要删除上述x方法中的or子句之一，以获取以下输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">＃<br>＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">＃<br>＃<br>＃<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">＃<br>＃<br>＃<br>＃<br>＃<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.7：研究，编译并运行以下代码，该代码位于Box.java文件中：</p>
<div class="example">
<pre class="example">class Box
begin
&nbsp;&nbsp;&nbsp; function void triangle(int n)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int y=0 to n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int x=0 to n-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (x &lt; y)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then System.out.print(&quot;#&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else System.out.print(&quot; &quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; triangle(5);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>请注意，这是上述代码针对n参数的不同值的输出：n = 1</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">＃<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">＃<br>##<br>###<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">＃<br>##<br>###<br>####<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">＃<br>##<br>###<br>####<br>#####<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.8：通过复制以上代码中建立的模式，编写一个新函数triangle2，该函数将生成以下输出。请注意，您将需要在上述三角形方法中更改if子句以获取以下输出：n = 1</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">###<br>##<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">####<br>###<br>##<br>＃<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">#####<br>####<br>###<br>##<br>＃<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.9：编写一个名为box的新函数，该函数生成以下输出。请注意，您将需要修改上面的三角形方法以获得以下输出：</p>
<table>
<tbody><tr><td width="25%">n = 1<br></td><td width="25%">＃<br>
<br></td></tr>
<tr><td width="25%">n = 2<br></td><td width="25%">##<br>##<br>
<br></td></tr>
<tr><td width="25%">n = 3<br></td><td width="25%">###<br>###<br>###<br>
<br></td></tr>
<tr><td width="25%">n = 4<br></td><td width="25%">####<br>####<br>####<br>####<br>
<br></td></tr>
<tr><td width="25%">n = 5<br></td><td width="25%">#####<br>#####<br>#####<br>#####<br>#####<br>
<br></td></tr>
</tbody></table>

<p>问题4.8.10：将以下代码添加到Box.java中：</p>
<a name="index-Introducing-boolean-arrays"></a>

<div class="example">
<pre class="example">class Grid
begin
&nbsp;&nbsp;&nbsp; /* NOTE: the use of &quot;final&quot; below to denote a value whose value cannot be changed. */
&nbsp;&nbsp;&nbsp; final classVar int SIZE = 20;

&nbsp;&nbsp;&nbsp; /* NOTE: the array below is a two-dimensional array */
&nbsp;&nbsp;&nbsp; classVar boolean[][] array = new boolean[SIZE][SIZE];

&nbsp;&nbsp;&nbsp; function void set(int x, int y, boolean v)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((x&gt;=0) and (x&lt;SIZE) and (y&gt;=0) and (y&lt;SIZE)) then
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; array[x][y] = v;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function void print(int size)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int y=0 to size-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int x=0 to size-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (array[x][y])
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then System.out.print(&quot;#&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else System.out.print(&quot; &quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();) // prints an empty line between shapes
&nbsp;&nbsp;&nbsp; end
end
</pre></div>

<a name="index-How-to-access-class-variables-and-functions-from-another-class"></a>
<a name="index-Accessing-class-variables-and-functions-from-another-class"></a>
<a name="index-Class-variables-from-another-class_002c-accessing"></a>

<p>问题4.8.11：以下问题将指导您完成使绘图算法更强大的过程。代替将形状直接打印到屏幕上，它们将存储在阵列中，仅在完全设置阵列后才打印出来。您无需对数组有太多了解即可回答本节剩余的问题，因为上面的Grid类中已为您编写了数组代码。对于Box.java中对System.out.println（）的每次调用，请将其替换为对Grid类的set方法的调用。请注意，set方法中的第三个参数的类型为布尔值，也就是说，它必须为true或false。要调用另一个类的函数，您需要像这样对类的名称添加前缀：Grid.set（/ *参数值* /）。最后，在Box类中所有函数的末尾，除了main函数，您将需要调用Grid类的Grid.print方法以实际打印出数组。
</p>
<p>问题4.8.12：从Box类的主函数重新初始化名为array的布尔数组。提示：要从另一个类访问一个类变量，您需要在其变量之前加上其类名称的名称，在本例中为Grid。将数组变量重新初始化为尺寸为100 x 100的二维数组。还要将size变量设置为100，以使Grid类的功能仍然有效。
</p>






<hr>
<a name="Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-10-Object-arrays" rel="next" accesskey="n">教程10对象数组</a> ，上一篇： <a href="#Tutorial-10-Object-arrays" rel="next" accesskey="n">教程</a> <a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class" rel="prev" accesskey="p">8从另一个类访问函数和类变量，上一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods-1"></a>
<h3 class="section">4.9教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</h3>


<a name="Elementary-classes_003a-using-a-single-class-for-everything"></a>
<h4 class="subsection">4.9.1基础类：对所有内容使用单个类</h4>

<p>出于以下文本的目的，OOP代表面向对象编程。
</p>
<p>问题4.9.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class PersonDriver1
begin
&nbsp;&nbsp;&nbsp; classVar String homersName = &quot;Homer Simpson&quot;;
&nbsp;&nbsp;&nbsp; classVar int    homersAge  = 40; // Homer's age in years

&nbsp;&nbsp;&nbsp; classVar String fredsName  = &quot;Fred Flintstone&quot;;
&nbsp;&nbsp;&nbsp; classVar int    fredsAge   = 45; // Fred's age in years

&nbsp;&nbsp;&nbsp; classVar String darthsName = &quot;Darth Vader&quot;;
&nbsp;&nbsp;&nbsp; classVar int    darthsAge  = 55; // Darth's age in years

&nbsp;&nbsp;&nbsp; function void growHomer()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; homersAge = homersAge + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void growFred()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fredsAge = fredsAge + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void growDarth()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; darthsAge = darthsAge + 1;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function void knightHomer()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; homersName = &quot;Sir &quot; + homersName;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void knightFred()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fredsName = &quot;Sir &quot; + fredsName;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void knightDarth()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; darthsName = &quot;Sir &quot; + darthsName;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function void printHomer()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + homersName + &quot;, my age is &quot; + homersAge);
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void printFred()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + fredsName + &quot;, my age is &quot; + fredsAge);
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void printDarth()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + darthsName + &quot;, my age is &quot; + darthsAge);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; growHomer();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; knightHomer();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printHomer();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printFred();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printDarth();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.9.2：通过复制现有代码中建立的模式，编写一些新的类变量来表示一个叫做巴拉克·奥巴马的新人。请注意，他出生于1961年8月4日，因此在撰写本手册时，他已经54岁。
</p>

<p>问题4.9.3：然后编写一些函数来与这个新人一起工作。
</p>
<p>问题4.9.4：最后从主函数调用这些函数。
</p>
<a name="Improved-classes_003a-one-object-per-class"></a>
<h4 class="subsection">4.9.2改进的类：每个类一个对象</h4>

<p>随着程序变大（例如超过1000行），将所有代码放在同一个类中变得不再可行。因此，将每个相关代码放在自己的类中是很自然的。JTW编程语言支持将类拆分为其组成方法，并为每个方法提供一个文件。只需使用include指令，JTW就会为您添加文件，如下所示：</p>
<p>包括“一种方法”；</p>
<p>将包含一个名为a的方法。
</p>
<p>问题4.9.5：研究，编译和运行以下代码：每个此类都可以放在各自的文件中。对于每个X类，可以将该类放入一个名为X.jtw的文件中。但是，出于本教程的目的，您可能会发现将所有类合并到同一文件中并合并到名为PersonDriver2.jtw的文件中会比较容易。</p>
<div class="example">
<pre class="example">class Homer
begin
&nbsp;&nbsp;&nbsp; classVar String name = &quot;Homer Simpson&quot;;
&nbsp;&nbsp;&nbsp; classVar int    age  = 40;) // Homer's age in years

&nbsp;&nbsp;&nbsp; function void grow()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age = age + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void knight()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = &quot;Sir &quot; + name;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void print()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + name + &quot;, my age is &quot; + age);
&nbsp;&nbsp;&nbsp; end
end

class Fred
begin
&nbsp;&nbsp;&nbsp; classVar String name = &quot;Fred Flintstone&quot;;
&nbsp;&nbsp;&nbsp; classVar int    age  = 45;) // Fred's age in years

&nbsp;&nbsp;&nbsp; function void grow()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age = age + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void knight()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = &quot;Sir &quot; + name;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void print()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + name + &quot;, my age is &quot; + age);
&nbsp;&nbsp;&nbsp; end
end

class Darth
begin
&nbsp;&nbsp;&nbsp; classVar String name = &quot;Darth Vader&quot;;
&nbsp;&nbsp;&nbsp; classVar int    age  = 55;) // Darth's age in years

&nbsp;&nbsp;&nbsp; function void grow()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age = age + 1;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void knight()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = &quot;Sir &quot; + name;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; function void print()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + name + &quot;, my age is &quot; + age);
&nbsp;&nbsp;&nbsp; end
end

class PersonDriver2
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Homer.grow();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Fred.knight();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Homer.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Fred.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Darth.print();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.9.6：通过复制现有代码中建立的模式，编写一个新类来代表巴拉克·奥巴马。
</p>
<p>问题4.9.7：从驱动程序类的主函数调用函数。
</p>
<a name="True-O_002eO_002eP_002e_003a-more-than-one-object-per-class"></a>
<h4 class="subsection">4.9.3真正的OOP：每个类有多个对象</h4>

<p>为了每个类允许一个以上的对象，大多数（如果不是全部）类变量需要被制成所谓的实例变量（或更简单地，并且通常被称为属性），而大多数（如果不是全部）则需要被制成对象变量。称为方法。
</p>
<a name="index-Mapping-from-class-variables-_002d_003e-instance-variables-_0028also-known-as-properties_0029"></a>
<a name="index-Mapping-from-functions-_002d_003e-methods"></a>

<p>问题4.9.8：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class Person
begin )
&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp; * NOTE: the use of the &quot;property&quot; keyword here instead of the
&nbsp;&nbsp;&nbsp; * &quot;classVar&quot; keyword.
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property String name; // Person's full name
&nbsp;&nbsp;&nbsp; property int    age;  // Person's age in years

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp; * NOTE: the use of the &quot;method&quot; keyword here instead of the
&nbsp;&nbsp;&nbsp; * &quot;function&quot; keyword.
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; method void grow()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age = age + 1;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void knight()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = &quot;Sir &quot; + name;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void print()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + name + &quot;, my age is &quot; + age);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person h = new Person();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.name = &quot;Homer Simpson&quot;;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.age  = 40;

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person f = new Person();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; f.name = &quot;Fred Flintstone&quot;;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; f.age  = 45;

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person d = new Person();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; d.name = &quot;Darth Vader&quot;;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; d.age  = 55;

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.grow();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.knight();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; f.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; d.print();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>在上面的代码中，请注意使用三个引用h，f和d。
</p>
<p>问题4.9.9：通过复制现有代码中建立的模式，将一些代码添加到主函数中，从而添加一些代码以为Barak Obama创建新人员。
</p>
<a name="index-A-common-design-pattern_003a-private-properties_002c-public-constructor-and-public-getters"></a>
<a name="index-Design-pattern_003a-private-properties_002c-public-constructor-and-public-getters"></a>
<a name="index-private-properties_002c-public-constructor-and-public-getters_002c-a-common-design-pattern"></a>

<a name="A-common-design-pattern_003a-private-properties_002cpublic-constructor-and-public-getters"></a>
<h4 class="subsection">4.9.4常见的设计模式：私有属性，公共构造函数和公共获取者</h4>

<a name="index-Encapsulation"></a>

<p>Java的一种常见设计模式（我在下面的代码中为您介绍）是通过将所有属性设为私有并提供非私有的getter方法，使类的所有属性对所有客户端类有效地只读。获取属性的值。原始类可以更改属性的值，但是其他类（例如下面的PersonTest）不能执行此操作，而无需调用原始类的方法，例如Person类的grow和knight方法。最后，使用称为构造函数的其他东西来确保对象使用其属性的有意义的值进行初始化。
</p>
<p>问题4.9.10：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class Person
begin

&nbsp;&nbsp;&nbsp; private property String name;
&nbsp;&nbsp;&nbsp; private property int    age; // Age in years
)
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; // NOTE: Getter methods
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; public method String getName()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return name;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method int getAge()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return age;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public constructor Person(String aName, int anAge)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.name = aName;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.age  = anAge;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void grow()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age = age + 1;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void knight()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = &quot;Sir &quot; + name;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void print()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;I am &quot; + name + &quot;, my age is &quot; + age);
&nbsp;&nbsp;&nbsp; end
end

class PersonDriver3
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // NOTE: In the following constructor calls the age and name are set by the constructor
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person h = new Person(&quot;Homer Simpson&quot;,40);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person f = new Person(&quot;Fred Flintstone&quot;,45);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person d = new Person(&quot;Darth Vader&quot;,55);

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.grow();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.knight();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; f.print();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; d.print();

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.name = &quot;Luke Skywalker&quot;;)                 // ERROR: name is private
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; h.age = h.age + 1;                          // ERROR: age is private

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;name=&quot; + h.name);       // ERROR: name is private
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;age=&quot;  + h.age);        // ERROR: age is private

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;name=&quot; + h.getName());  // OK: getter is non-private
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;age=&quot;  + h.getAge());   // OK: getter is non-private
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>请注意，您必须从上述文件中删除错误行，以便编译代码。
</p>
<p>问题4.9.11：通过复制现有代码中建立的模式，将一些代码添加到主函数中，以创建一个名为Hillary Clinton的新人员。希拉里·克林顿（Hillary Clinton）于1947年10月26日出生，所以在撰写本手册时她已经68岁了。</p><a name="Comparing-strings"></a>
<h4 class="subsection">4.9.5比较字符串</h4>

<p>问题4.9.12：添加方法unknight（），如果有“ Sir”标题，则将其删除。使用JTW或Java的年轻玩家的一个陷阱是使用运算符==来比较字符串，如下所示：</p>
<div class="example">
<pre class="example">function boolean myCompare(String a, String b)
begin
&nbsp;&nbsp;&nbsp; return a == b;) // Works but not as expected!
end
</pre></div>

<p>它编译没有错误，但是没有给您期望的结果。相反，您需要使用String类的equals方法，如下所示：</p>
<div class="example">
<pre class="example">function boolean myCompare(String a, String b)
begin
&nbsp;&nbsp;&nbsp; return a.equals(b);
end
</pre></div>

<p>更一般而言，如果x和y是对对象的引用，则x == y返回x和y是否指向同一对象，而x.equals（y）返回是否引用了对象的内容x和y相等。单词内容的含义因类而异，但是在字符串的情况下，意味着字符串包含相同的数据。
</p>
<p>您还将在这里找到String类的子字符串和（toUpperCase或toLowerCase）方法。有关这两种方法的更多详细信息，请参见位于<a href="http://docs.oracle.com/javase/1.5.0/docs/api">http://docs.oracle.com/javase/1.5.0/docs/api的</a> java.lang软件包中的String类。
</p>
<a name="The-null-value-for-references"></a>
<h4 class="subsection">4.9.6引用的空值</h4>

<a name="index-null-value-for-references"></a>

<p>一旦学习了如何使用引用，就需要知道所有引用变量都可以将值保留为null，这意味着没有值。特别是当属性本身是引用时（如您在教程11中所发现的），那么默认情况下，这些属性被初始化为null。默认情况下，还将使用两种初始化语法中的第二种在教程10中学习的对象数组也将初始化为null。
</p>
<a name="index-The-toString-method_002e"></a>
<a name="index-toString-method_002e"></a>

<a name="Why-the-toString-method-is-better-than-any-other-method-or"></a>
<h4 class="subsection">4.9.7为什么toString方法比其他任何方法都要好？</h4>
<p>用于调试的属性</p>
<a name="index-NullPointerException"></a>

<p>如果x是对类X的引用（包括当前类的引用），并且m是X的方法，而p是X的属性，并且如果x当前为null，则以下各行将引发NullPointerException执行时：</p>
<div class="example">
<pre class="example">x.p;
x.m();
</pre></div>

<p>而如果x为空，则</p>
<div class="example">
<pre class="example">System.out.println(x); and
System.out.println(&quot;x=&quot; + x);
</pre></div>

<p>分别打印出：</p>
<div class="example">
<pre class="example">null, and
x=null.
</pre></div>

<p>如果x不为null，则调用</p>
<div class="example">
<pre class="example">System.out.println(x.toString());
System.out.println(&quot;x=&quot; + x.toString());
</pre></div>

<p>因此在x可能为null的情况下，使用这些表达式比使用任何其他方法或属性更安全。toString方法的语法如下：</p>
<div class="example">
<pre class="example">public method String toString()
begin
&nbsp;&nbsp;&nbsp; // Code goes here...
end
</pre></div>

<p>重要的是，出于稍后将说明的原因，必须以公共可见性声明toString方法。对于要与null引用一起安全使用的其他属性和方法，您需要在方法或属性的调用周围包装条件if构造，例如对于属性：</p>
<div class="example">
<pre class="example">if (x != null)
then begin
&nbsp;&nbsp;&nbsp; System.out.println(x.p);
end
</pre></div>

<p>或类似的方法：</p>
<div class="example">
<pre class="example">if (x != null)
then begin
&nbsp;&nbsp;&nbsp; System.out.println(x.m());
end
</pre></div>

<p>因此，toString方法比任何其他方法或属性都更方便。
</p>
<a name="index-Why-the-toString-method-is-better-than-any-other-method-or-property-for-debugging-your-code"></a>

<p>问题4.9.13：将上面的打印方法从打印到屏幕上的方法更改为返回字符串的toString方法。
</p>
<a name="index-Writing-your-own-methods"></a>

<p>问题4.9.14：在主函数中调用toString方法而不是print方法。
</p>

<hr>
<a name="Tutorial-10-Object-arrays"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-11-References-to-another-class" rel="next" accesskey="n">教程11对另一个类的引用，上一篇</a> ： <a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods" rel="prev" accesskey="p">教程9将类变量映射到实例变量（也称为属性）和函数映射到方法</a> ，上<a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-10-Object-arrays-1"></a>
<h3 class="section">4.10教程10对象数组</h3>




<p>本教程教您如何创建对象的一维和多维数组。除了布尔，char，int，float和double以外，Object类型都是所有类型。Java中的一个有用约定是，对象类型以大写字母开头，而非对象类型以小写字母开头，例如String类作为对象类型的示例。除此之外，还提供了两种不同的数组初始化语法。
</p>
<a name="index-Arrays-1"></a>
<a name="index-Object-arrays"></a>
<a name="index-Arrays-of-Object-type_002c-single_002ddimensional"></a>
<a name="index-Single_002ddimensional-arrays-of-Objects"></a>

<a name="Single_002ddimensional-arrays-of-Objects"></a>
<h4 class="subsection">4.10.1对象的一维数组</h4>

<p>问4.10.1：这是一个方便的一维数组初始化语法的示例。学习，编译并运行以下代码。应该将代码Person []大声读出为“人数组”，表示变量a是人数组，也称为“人数组”。
</p>
<div class="example">
<pre class="example">class Person
begin
&nbsp;&nbsp;&nbsp; private property String name;

&nbsp;&nbsp;&nbsp; constructor Person(String aName)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = aName;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return name;
&nbsp;&nbsp;&nbsp; end
end

class PersonTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Person[] a = { new Person(&quot;Person # 1&quot;), new Person(&quot;Person # 2&quot;), new Person(&quot;Person # 3&quot;) };
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to a.length-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;a[&quot; + i + &quot;]=&quot; + a[i]);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<a name="index-Arrays-of-Object-type_002c-initialization"></a>
<a name="index-Arrays-of-Object-type_002c-first-initialization-syntax"></a>
<a name="index-First-initialization-syntax-for-arrays-of-Objects"></a>

<p>由于Java创建者的设计监督，您不能使用此语法重新初始化数组，如下所示：</p>
<div class="example">
<pre class="example">// Compilation error
a = { new Person(&quot;Person # 4&quot;), new Person(&quot;Person # 5&quot;), new Person(&quot;Person # 6&quot;), new Person(&quot;Person # 7&quot;) };
</pre></div>

<p>幸运的是，有一种方法可以绕过这种监督，那就是使用一种设计模式，在其中引入一个临时变量，如下所示：</p>
<div class="example">
<pre class="example">// No error
var Person[] temp = { new Person(&quot;Person # 4&quot;), new Person(&quot;Person # 5&quot;), new Person(&quot;Person # 6&quot;), new Person(&quot;Person # 7&quot;) };
a = temp; // Array &quot;a&quot; now holds Person # 4,Person # 5,Person # 6,Person # 7
</pre></div>

<p>稍后，您将了解为什么这种设计模式对于重新初始化多维数组很有用。
</p>
<p>问题4.10.2：在PersonTest类中编写一个名为print的函数，该函数接受一个Person数组参数并打印出该数组。您将需要使用array参数的length属性，以便您的函数可以使用任意大小的数组。将main函数更改为以下内容，以便包含对printx函数的调用。
</p>
<div class="example">
<pre class="example">var Person[] a = { new Person(&quot;Person # 1&quot;), new Person(&quot;Person # 2&quot;), new Person(&quot;Person # 3&quot;)};
print(a);
</pre></div>

<p>问4.10.3：使用一个int参数构造函数，一个私有int属性p和一个将p转换为字符串的toString方法，编写类似于Person类的自己的Mine类。然后在PersonTest类中编写一个函数，该函数与上一个打印函数的名称相同，不同之处在于该函数采用Mine []，也称为Mine数组。您可能会从教程7中回忆起，使用两个具有相同名称的函数的做法称为函数名称重载。将main函数更改为以下内容，以便初始化Mine点变量的数组，然后调用第二个print函数。
</p>
<div class="example">
<pre class="example">var Mine[] b = { new Mine(1), new Mine(2), new Mine(3) };
print(b);
</pre></div>

<a name="index-Arrays-of-Object-type_002c-second-initialization-syntax"></a>
<a name="index-Second-initialization-syntax-for-arrays-of-Objects"></a>

<p>这是第二种初始化语法的示例。对于此特定示例，最好使用更简单，更早的初始化语法，但是当要在运行时确定要创建的数组的大小时，则应使用第二种语法。下一个问题将向您显示一个示例。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Person[] a = new Person[3];
&nbsp;&nbsp;&nbsp; // at this point the array is all nulls
&nbsp;&nbsp;&nbsp; superfor (var int i=0 to a.length-1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a[i] = new Person(&quot;Person # &quot; + (i+1));
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问4.10.4：写一个函数create需要一个int参数，即要创建的数组的大小，并返回该大小的Person数组。使其数组的第ith个元素初始化为“ Person＃” + i。从主函数调用此函数，如下所示：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Person[] a = create(3);
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问4.10.5：写一个函数create2需要一个int参数，即要创建的数组的大小，并返回该大小的Mine数组。做到这一点，以便数组的toString方法的第ith个元素打印出“ Mine＃” + i。为什么不能重载该create函数？试试看，看看编译器怎么说。从主函数调用create2，如下所示：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Mine[] a = create2(3);
&nbsp;&nbsp;&nbsp; print(a);
endMain
</pre></div>

<p>问4.10.6：编写一个函数加倍器，该函数加一个Person数组x，并返回一个新的Person数组，其结果是x的两倍。将x复制到结果中，然后再返回。结果中的多余元素都应为null。
</p>
<p>问4.10.7：更改doubler函数，以便将数组结果中的每个null都设置为一个新的Person，使每个新的Person对象具有不同的name属性。
</p>
<a name="Two_002ddimensional-arrays-of-Objects"></a>
<h4 class="subsection">4.10.2对象的二维数组</h4>

<a name="index-Two_002ddimensional-arrays-of-Objects"></a>
<a name="index-Arrays-of-Object-type_002c-two_002ddimensional"></a>
<a name="index-Object-arrays_002c-two_002ddimensional"></a>

<p>问4.10.8：这是一个方便的二维数组初始化语法的示例。学习，编译并运行以下代码。代码Person [] []应该大声读出，因为人员数组数组指示变量a是人员数组阵列，也称为人员二维数组。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Person[][] a = { { new Person(&quot;Person # 1&quot;), new Person(&quot;Person # 2&quot;), new Person(&quot;Person # 3&quot;) },
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { new Person(&quot;Person # 4&quot;), new Person(&quot;Person # 5&quot;) },
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { new Person(&quot;Person # 6&quot;) } };

&nbsp;&nbsp;&nbsp; superfor (var int y=0 to a.length-1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int x=0; to a[y].length-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.print(&quot; &quot; + a[y][x]);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>问4.10.9：通过复制上述代码的模式，通过编写两个新的打印函数对打印函数进行一些重载，一个新的打印函数是Person的二维数组，另一个是Mine的二维数组。从主函数调用这两个函数。
</p>
<p>由于a [0]是一个Person数组，因此您会天真地希望它能够像这样重新初始化：</p>
<div class="example">
<pre class="example">a[0] = { new Person(&quot;Person # 4&quot;),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new Person(&quot;Person # 5&quot;),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new Person(&quot;Person # 6&quot;) };
</pre></div>

<p>因此，在此代码之后，a0拥有由四个元素组成的长数组Person＃4，Person＃5和Person＃6，但是由于Java的创建者对设计的监督，它无法正常工作。幸运的是，如上所述，可以通过一种临时变量来避免这种监督：</p>
<div class="example">
<pre class="example">var Person[] temp = { new Person(&quot;Person # 4&quot;),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new Person(&quot;Person # 5&quot;),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new Person(&quot;Person # 6&quot;) };
a[0] = temp; // Array &quot;a[0]&quot; now holds Person # 4,Person # 5,Person # 6
</pre></div>

<p>像一维数组一样，二维数组也有第二种初始化语法。与上面的代码不同，子数组a [0]，a [1]和a [2]大小相等，即三个。
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Person[][] a = new Person[3][3];
&nbsp;&nbsp;&nbsp; a[0][0] = new Person(&quot;Person # 1&quot;);
&nbsp;&nbsp;&nbsp; a[0][1] = new Person(&quot;Person # 2&quot;);
&nbsp;&nbsp;&nbsp; a[0][2] = new Person(&quot;Person # 3&quot;);
&nbsp;&nbsp;&nbsp; a[1][0] = new Person(&quot;Person # 4&quot;);
&nbsp;&nbsp;&nbsp; a[1][1] = new Person(&quot;Person # 5&quot;);
&nbsp;&nbsp;&nbsp; a[1][2] = new Person(&quot;Person # 6&quot;);
&nbsp;&nbsp;&nbsp; a[2][0] = new Person(&quot;Person # 7&quot;);
&nbsp;&nbsp;&nbsp; a[2][1] = new Person(&quot;Person # 8&quot;);
&nbsp;&nbsp;&nbsp; a[2][2] = new Person(&quot;Person # 9&quot;);
endMain
</pre></div>

<p>问题4.10.10：编写一个函数int3和create4，该函数采用int参数大小并分别返回Person或Mine的二维数组。使用独立的计数器变量var int count，使每个Person或Mine Object都有自己的编号。
</p>
<a name="Three_002ddimensional-arrays-of-Objects"></a>
<h4 class="subsection">4.10.3对象的三维数组</h4>

<a name="index-Three_002ddimensional-arrays-of-Objects"></a>
<a name="index-Arrays-of-Object-type_002c-three_002ddimensional"></a>

<p>问4.10.11：使用到目前为止所获得的有关数组的知识，创建，初始化和打印三维人数组。使用单独的计数器变量var int count来使每个Person Object都有自己的编号。
</p>



<hr>
<a name="Tutorial-11-References-to-another-class"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-12-Overloading-methods" rel="next" accesskey="n">教程12的重载方法</a> ，上一篇： <a href="#Tutorial-12-Overloading-methods" rel="next" accesskey="n">教程</a> <a href="#Tutorial-10-Object-arrays" rel="prev" accesskey="p">10的对象数组</a> ，上篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-11-References-to-another-class-1"></a>
<h3 class="section">4.11教程11对另一个类的引用</h3>


<p>下面的代码提供了涉及三个类的示例，分别是Flea，Dog和DogOwner，以表示狗有跳蚤，而狗主人有狗的想法。DogTest类是驱动程序类。本教程的关键概念是，类可以引用另一个类的对象，以便在两个类之间建立关系。
</p>
<a name="index-Setting-up-relationships-between-different-classes_002e"></a>
<a name="index-Relationships-between-different-classes_002e"></a>

<p>问题4.11.1：研究以下代码，并在其中找到两个错误。修复错误，然后编译并运行它以验证它是否打印出“ p =我是一个叫做Pop的跳蚤”。
</p>
<div class="example">
<pre class="example">class Flea
begin
&nbsp;&nbsp;&nbsp; property String name;

&nbsp;&nbsp;&nbsp; constructor Flea(String aName)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; aName = name;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;I am a flea called &quot; + name;
&nbsp;&nbsp;&nbsp; end
end

class Dog
begin
&nbsp;&nbsp;&nbsp; property String name;
&nbsp;&nbsp;&nbsp; property int age; // Age in years
&nbsp;&nbsp;&nbsp; property Flea dogsFlea;

&nbsp;&nbsp;&nbsp; constructor Turtle(String aName, int anAge, Flea aFlea)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name     = aName;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age      = anAge;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dogsFlea = aFlea;
&nbsp;&nbsp;&nbsp; end
end

class DogTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Flea p = new Flea(&quot;Pop&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Flea s = new Flea(&quot;Squeak&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Flea z = new Flea(&quot;Zip&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;p=&quot; + p);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.11.2：在DogTest类的主函数中，编写代码以调用s和z引用的跳蚤的toString方法。
</p>
<p>问题4.11.3：在DogTest类的主要函数中，编写代码以构造三个称为“ Fido”，“ Jimbo”和“ Rex”的狗。出于其余这些问题的目的，让Fido，Jimbo和Rex的引用名称为f，j和r。请注意，Dog类的第三个参数是Flea类型。因此，您需要为每只狗提供跳蚤参考。使其成为Fido的跳蚤叫Pop，Jimbo的跳蚤叫Squeak，而Rex的跳蚤叫Zip。
</p>
<p>提示：如果变量名称p引用了名为Pop的跳蚤，则该引用应作为对Dog构造函数的调用中的第三个参数出现。
</p>
<p>问4.11.4：在Dog类中编写一个toString方法，该方法的工作原理类似于Flea类中的toString方法。然后从主函数调用此方法，以打印出您刚刚在问题11.3中创建的三只狗的完整统计信息。
</p>
<p>问4.11.5：通过复制跳蚤和狗类的模式，编写一个具有三个非私有属性的类DogOwner：名称，薪水和ownerDog。还要为DogOwner类编写一个三参数构造函数，以设置这些属性。
</p>
<p>问4.11.6：在主要功能中添加一些代码，以构建三个叫安格斯，布莱恩和查尔斯的狗主人。做到这样，安格斯有一只叫雷克斯的狗，布莱恩有一只叫金波的狗，查尔斯有一只叫费多的狗。出于其余这些问题的目的，将Angus，Brian和Charles的引用的名称分别命名为a，b和c。使用在问题11.3中创建的Dog引用来实现此目的。做到使安格斯，布莱恩和查尔斯的起薪分别为10,000、20,000和30,000。
</p>
<p>问4.11.7：在不更改对DogOwner构造函数的调用的情况下，将由a引用的对象的salary属性的值更改为1,000,000。请注意，由于DogOwner类的salary属性是非私有的，因此您应该能够从DogTest的主要功能中设置salary属性的值。</p>
<p>问4.11.8：为DogOwner类编写一个toString方法，并在主要函数中添加一些代码，以供Angus，Brian和Charles调用。
</p>
<p>问题4.11.9：a.ownersDog.dogsFlea.toString（）的值是什么？将一些代码添加到main函数中，以了解它是否可以执行您认为应该执行的操作。
</p>

<hr>
<a name="Tutorial-12-Overloading-methods"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-13-More-about-references" rel="next" accesskey="n">教程13有关引用的更多信息</a> ，上一篇： <a href="#Tutorial-13-More-about-references" rel="next" accesskey="n">教程</a> <a href="#Tutorial-11-References-to-another-class" rel="prev" accesskey="p">11对另一个类的</a> <a href="#Tutorial-13-More-about-references" rel="next" accesskey="n">引用</a> ，上<a href="#Tutorial-11-References-to-another-class" rel="prev" accesskey="p">一篇</a> ： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-12-Overloading-methods-1"></a>
<h3 class="section">4.12教程12重载方法</h3>


<p>问4.12.1：通过查看主函数以查看每个构造函数有多少个参数，为下面的SportsShoe和Runner类编写构造函数。
</p>
<div class="example">
<pre class="example">class SportsShoe
begin

&nbsp;&nbsp;&nbsp; property String model;      // what kind of shoe it is
&nbsp;&nbsp;&nbsp; property double speedBoost; // the boosting factor of the shoe

&nbsp;&nbsp;&nbsp; // constructor goes here:

&nbsp;&nbsp;&nbsp; // Useful method for debugging
&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;I am a shoe called &quot; + model + &quot; and my boosting factor is &quot; + speedBoost;
&nbsp;&nbsp;&nbsp; end
end

class Runner
begin
&nbsp;&nbsp;&nbsp; private property String     name;  // Runner's name.
&nbsp;&nbsp;&nbsp; private property int        speed; // speed of runner in km/hr.
&nbsp;&nbsp;&nbsp; private property SportsShoe shoes; // which shoe they are wearing.

&nbsp;&nbsp;&nbsp; // constructor goes here:

&nbsp;&nbsp;&nbsp; // Useful method for debugging
&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;I am a runner and my name is &quot; + name + &quot; and my shoes are &quot; + shoes;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; *** This private method computeSpeed works out the runners speed,
&nbsp;&nbsp;&nbsp; *** based on their basic speed and the speed boost due to the
&nbsp;&nbsp;&nbsp; *** SportsShoe that they are currently wearing.
&nbsp;&nbsp;&nbsp; */

&nbsp;&nbsp;&nbsp; // method goes here:


&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; ** Prints the result of racing two runners against each other.
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; function void race(Runner r1, Runner r2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (r1.computeSpeed()&gt;r2.computeSpeed())
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Runner &quot; + r1.name + &quot; beats &quot; + r2.name);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Runner &quot; + r2.name + &quot; beats &quot; + r1.name);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; ** Swaps the shoes of two runners.
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; function void swapShoes(Runner r1, Runner r2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var SportsShoe tempShoe = r1.shoes;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; r1.shoes = r2.shoes;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; r2.shoes = tempShoe;
&nbsp;&nbsp;&nbsp; end
end

class RunnerTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var SportsShoe nike    = new SportsShoe(&quot;Nike NX-71&quot;, 2.0);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var SportsShoe reebock = new SportsShoe(&quot;Reebock R20&quot;, 2.3);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var SportsShoe puma    = new SportsShoe(&quot;Puma P200-MMX&quot;,4.8);

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Runner sg = new Runner(&quot;Speedy Gonzalez&quot;, 55, nike);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Runner sw = new Runner(&quot;Slick Willy&quot;, 49, reebock);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Runner fa = new Runner(&quot;Fat Albert&quot;, 15, puma);

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Runner.race(sg,sw);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Runner.race(sg,sw,fa);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // sg.raceAgainst(sw);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.12.2：在Runner类中，编写不带参数的私有方法computeSpeed，并返回等于跑步者运行速度的双精度浮点值。请注意，跑步者的速度是通过将其速度属性与所穿鞋子的speedBoost属性相乘来确定的。例如，Speedy Gonzalez的跑步速度= 55 * 2.0 = 110.0。
</p>
<p>问4.12.3：修正竞赛方法，以便检查是否平局。
</p>
<p>问4.12.4：通过复制竞赛方法，编写一种三参数竞赛方法，以使三个跑步者彼此竞赛。同一类中具有相同名称的两个方法在JTW和Java中称为重载。从主函数添加对此方法的调用。
</p>
<a name="index-Overloading-methods"></a>
<a name="index-Methods_002c-overloading"></a>

<p>问4.1.5：方法和函数有什么区别？编写一个行为完全类似于两参数函数Race的单参数方法raceAgainst。有两种方法，一种是可选地使用this关键字，而不是参数r1或r2之一。第二种方法是Race可以简单地使用此参数作为函数的参数之一来调用race。
</p>
<a name="index-Converting-from-functions-to-methods-and-vice_002dversa"></a>
<a name="index-Functions-to-methods-and-vice_002dversa"></a>
<a name="index-Methods-to-functions-and-vice_002dversa"></a>

<p>问4.12.6：是否可以将任何方法重新构造为函数，反之亦然？
</p>
<a name="index-Swapping-the-properties-of-two-objects"></a>
<a name="index-Property-swapping"></a>

<p>问4.12.7：Runner类中的swapShoes方法交换两个跑步者的鞋子。在主函数中添加一些代码以交换两个跑步者的鞋子，并验证鞋子是否确实被交换了。
</p>
<p>问4.12.8：编写一个名为swapNames的方法来交换两个跑步者的名字。您可以将该函数放入任何类，但是将其放入Runner类是最有意义的，因为它具有两个Runner参数。
</p>
<p>问4.12.9：编写一个方法swapSpeeds来交换两个跑步者的速度属性。
</p>

<hr>
<a name="Tutorial-13-More-about-references"></a>
<div class="header">
<p>下一页： <a href="#Tutorial-14-Linked-lists" rel="next" accesskey="n">教程14链接列表</a> ，上一篇： <a href="#Tutorial-14-Linked-lists" rel="next" accesskey="n">教程</a> <a href="#Tutorial-12-Overloading-methods" rel="prev" accesskey="p">12重载方法</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-13-More-about-references-1"></a>
<h3 class="section">4.13教程13有关参考的更多信息</h3>

<p>问题4.13.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class Car
begin
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Car's model name
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property String model;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Car's value in dollars
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property int value;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Car's serial number
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property int serialNumber;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; *   Global serial number counter
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private classVar int serialCounter = 1000;

&nbsp;&nbsp;&nbsp; constructor Car(String aModel, int aValue)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; model = aModel;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; value = aValue;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; serialNumber = serialCounter;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; serialCounter = serialCounter + 1;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;I am a car, model=&quot; + model + &quot;, value=&quot; + value +
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &quot;, serial number=&quot; + serialNumber;
&nbsp;&nbsp;&nbsp; end
end

class Owner
begin

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Owner's full name
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property String name;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Owner's money in dollars
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property int money;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp; * Owner's car
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; property Car ownersCar;

&nbsp;&nbsp;&nbsp; constructor Owner(String aName, int aMoney, Car aCar)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name = aName;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; money = aMoney;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ownersCar = aCar;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &quot;I am a car owner, name=&quot; + name + &quot;, money=&quot; + money +
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  &quot;, car=&quot; + ownersCar;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void describe()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(toString());
&nbsp;&nbsp;&nbsp; end
end

class CarTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Car   ford = new Car(&quot;Ford Escort&quot;,1000);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Car   nissan = new Car(&quot;Nissan Nivara&quot;,2000);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Owner joe = new Owner(&quot;Joe Bloggs&quot;,500,ford);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;) // Mary has no car to start with.
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Owner mary = new Owner(&quot;Mary Smith&quot;,600,null);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joe.describe();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问4.13.2：类变量serialCounter的用途是什么？
</p>
<p>问4.13.3：编写一个sellCar方法，将所有者的钱增加其汽车价值的一半，并且所有者的汽车参考被设置为null，因为没有汽车。如果所有者不拥有汽车（空），则什么也不做。
</p>
<p>问题4.13.4：在Owner类中编写一个称为Purchase的方法，以便：</p>
<div class="example">
<pre class="example">Car newCar = new Car(&quot;Mini Cooper&quot;,1000);
joe.purchase(newCar);
</pre></div>

<p>导致Joe的钱减少了$ 1000，并且Joe的汽车被设置为newCar。在Joe购买新车之前，请调用sellCar方法，以便Joe在之前出售其当前汽车</p>
<p>问题4.13.5：在Owner类中编写一个名为netWorth的函数，以便：</p>
<div class="example">
<pre class="example">System.out.println(&quot;Joe's net worth = &quot; + joe.netWorth());
</pre></div>

<p>打印乔斯的钱加上他的汽车价值（如果他有汽车）。
</p>
<p>问题4.13.6：在Owner类中编写一个名为smashCar的方法，以便：</p>
<div class="example">
<pre class="example">mary.smashCar();
</pre></div>

<p>将玛丽汽车的价值减半。
</p>
<p>问4.13.7：在所有者类中编写一个名为stealCarFrom的方法，以便：</p>
<div class="example">
<pre class="example">mary.stealCarFrom(joe);
</pre></div>

<p>结果导致Mary出售其当前汽车（如果有的话）的市值，并且Mary获得了Joe的汽车的所有权。也可以调用Mary的sellCar方法，以使Mary在偷走Joe的汽车之前先出售其当前的汽车。
</p>
<p>问题4.13.8：在Owner类中编写一个名为swapMoney的函数，以便：</p>
<div class="example">
<pre class="example">Owner.swapMoney(joe,mary);
</pre></div>

<p>交换乔和玛丽的钱。
</p>
<p>问题4.13.9：在Owner类中编写一个名为swapCars的函数，以便：</p>
<div class="example">
<pre class="example">Owner.swapCars(joe,mary);
</pre></div>

<p>交换乔和玛丽的汽车。
</p>
<p>问题4.13.10：在Car类中编写一个名为swapSerialNumbers的函数，以便：</p>
<div class="example">
<pre class="example">Car.swapSerialNumbers(ford,nissan);
</pre></div>

<p>交换福特和日产的序列号。
</p>
<p>问4.13.11：在Owner类中编写一个名为sellCarTo的函数，以便</p>
<div class="example">
<pre class="example">joe.sellCarTo(mary);
</pre></div>

<p>导致乔的钱随着他的汽车的价值上升而玛丽的钱随着他的汽车的价值下降，并且玛丽的汽车的所有权被转移给了乔。
</p>

<hr>
<a name="Tutorial-14-Linked-lists"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-15-Introducing-inheritance" rel="next" accesskey="n">教程15继承入门</a> ，上一篇： <a href="#Tutorial-15-Introducing-inheritance" rel="next" accesskey="n">教程</a> <a href="#Tutorial-13-More-about-references" rel="prev" accesskey="p">13更多关于引用的信息</a> ，上篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-14-Linked-lists-1"></a>
<h3 class="section">4.14教程14链接列表</h3>

<a name="index-Yertle-the-Turtle"></a>
<a name="index-Linked-lists-1"></a>

<p>苏斯博士的故事<a href="https://en.wikipedia.org/wiki/Yertle_the_Turtle">“海龟亚特尔”</a>描述了一只叫<a href="https://en.wikipedia.org/wiki/Yertle_the_Turtle">亚特尔的海龟</a>如何坐在其他海龟的顶部。在此示例中，一堆海龟由“海龟”对象的链接列表表示，其中down属性用于将一个“海龟”对象连接到另一个。如果Turtle对象具有非null down属性，则表示它位于另一只Turtle之上。链接列表中的最后一个乌龟是位于桩底的乌龟，其down属性的值为空。请注意，您不能使用superfor构造来迭代链表。在这种情况下，for构造是最明智的。
</p>
<p>问题4.14.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class Turtle
begin

&nbsp;&nbsp;&nbsp; private property String     name;   // Turtle's name
&nbsp;&nbsp;&nbsp; private property int        age;    // Turtle's age in years
&nbsp;&nbsp;&nbsp; private property double     weight; // Turtle's weight in kg

&nbsp;&nbsp;&nbsp; // NOTE: this property allows for linked lists
&nbsp;&nbsp;&nbsp; property Turtle down;

&nbsp;&nbsp;&nbsp; constructor Turtle(String aName, int anAge, double aWeight)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name   = aName;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age    = anAge;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; weight = aWeight;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; /** Getter method for name property */
&nbsp;&nbsp;&nbsp; method String getName()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return name;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; /** Useful method for debugging */
&nbsp;&nbsp;&nbsp; public method String toString()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return name;
&nbsp;&nbsp;&nbsp; end
end

class TurtleTest
begin
&nbsp;&nbsp;&nbsp; beginMain

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Turtle yertle = new Turtle(&quot;Yertle&quot;, 103, 20);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Turtle zippy  = new Turtle(&quot;Zippy&quot;,  102, 30);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Turtle bungle = new Turtle(&quot;Bungle&quot;, 101, 40);

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // *** see later
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; yertle.down = zippy;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; zippy.down = bungle;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bungle.down  = null; // NOTE: not needed as bungle.down is null by default

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int totalWeight = 0;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // NOTE: demonstrates how to iterate through a linked list:
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (var Turtle current = yertle; current != null; current=current.down)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; totalWeight = totalWeight + current.getWeight();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;The total weight is &quot; + totalWeight);
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>***之后的main函数中的代码设置了三个Turtle对象（Yertle，Bungle和Zippy）之间的以下关系。下图显示了不同乌龟之间的关系。遍历海龟列表时，您必须始终从顶部的海龟开始（称为链接列表的头部）。如果为顶部乌龟提供不同的值，则代码将认为给定的乌龟是堆顶部的乌龟，您将得到错误的结果。
</p>
<pre class="verbatim">+------+
|Yertle|
+------+----+
            |
+------+&lt;---+
|Zippy |
+------+----+
            |
+------+&lt;---+
|Bungle|
+------+----+
            |
    null&lt;---+

</pre>
<p>问题4.14.2：将用于计算海龟总重量的代码从主函数移到Turtle类中的函数void printTotalWeight（Turtle bottom）函数，该函数会打印出海龟的总重量。然后从主函数调用该函数以获取与以前相同的结果。请注意，如果printTotalWeight是一个方法，则使用null（表示一个空列表）来调用该方法，例如：null.printTotalWeight（）将是错误，而Turtle.printTotalWeight（null）则不会，因此更好。这是方法和功能如何不同的一个示例。
</p>
<p>问题4.14.3：吸气剂的修订问题。通过复制由getName方法建立的模式，将两个getter方法添加到Turtle类：getAge返回当前乌龟的年龄，以及getWeight返回当前乌龟的体重。然后在main函数的Yertle对象上调用这些方法。请注意，toString方法会更合适，因为它可以更好地处理null，但是您知道yertle引用不是null，因此可以安全地在yertle引用上调用getAge和getWeight方法。
</p>
<p>问4.14.4：编写一个函数Turtle findBottomTurtle（Turtle top），该函数返回位于桩顶部的Turtle对象，如果没有，则返回null。
</p>
<p>问题4.14.5：然后使用System.out.println（）和顶部的Turtle Yertle从主函数中调用此函数。
</p>
<p>问4.14.6：编写一个函数Turtle findOldestTurtle（Turtle top）返回最旧的乌龟，如果没有，则返回null。
</p>
<p>问题4.14.7：然后使用System.out.println（）和顶部的Turtle Yertle从主函数中调用此函数。
</p>
<p>问题4.14.8：编写一个函数Turtle findHeaviestTurtle（Turtle top）返回最重的Turtle，如果没有，则返回null。
</p>
<p>问题4.14.9：然后使用System.out.println（）和顶部的Turtle Yertle从主函数中调用此函数。
</p>
<p>问题4.14.10：编写一个函数sayPile（Turtle top），该函数从顶部的乌龟开始到底部的乌龟结束打印堆中的乌龟名称。然后从主函数调用此函数。
</p>
<p>问题4.14.11：在什么情况下可以将羽绒属性的可见性更改为私有，例如名称，年龄和重量属性？
</p>
<p>问题4.14.12：向构造函数添加一个额外的参数，该参数是对当前参数下方的乌龟的引用。然后从主函数中删除所有出现的down属性。请注意，您需要颠倒创建乌龟的顺序，以便首先构造底部乌龟，依此类推。这样做的好处是，它使您可以将down属性的可见性更改为private。
</p>


<hr>
<a name="Tutorial-15-Introducing-inheritance"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-16-More-inheritance" rel="next" accesskey="n">教程16更多继承</a> ，上一篇： <a href="#Tutorial-16-More-inheritance" rel="next" accesskey="n">教程</a> <a href="#Tutorial-14-Linked-lists" rel="prev" accesskey="p">14链接列表</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-15-Introducing-inheritance-1"></a>
<h3 class="section">4.15教程15继承介绍</h3>

<a name="Basic-Inheritance"></a>
<h4 class="subsection">4.15.1基本继承</h4>

<a name="index-Inheritance"></a>

<p>当您看到以下代码时：类X扩展了Y，这意味着类X继承自类Y。类X被称为子类，类Y被称为超类或父类。当类X从Y扩展时，它从超类Y中提取所有非私有方法和属性。继承的方法可以覆盖超类中相同方法的行为，以提供特定于行为的行为。子类。覆盖其他方法的方法的概念称为动态方法绑定，或更通俗地说是更令人印象深刻的名称：多态。本教程显示的主要内容是继承是一种非对称关系。例如：在下面的代码中，Bird类继承自Animal类，这对应于每只鸟都是动物的想法。相反，每只动物都是鸟，显然是不正确的！继承迫使您认识到这一点。
</p>
<p>问题4.15.1：研究，编译并运行以下代码。以下代码显示了继承的工作方式。在以下代码中，Bird类继承自Animal类。Bird类引入了Animal类的age属性以及canFly和talk方法。重要的是，canFly属性会覆盖父Animal类的canFly方法的行为，这反映了通常情况下鸟类可以飞翔的事实。在下面的代码中，请注意int属性默认情况下初始化为零，并且如果超类中有零参数构造函数，则默认情况下会调用super方法（也称为超类的构造函数），默认情况下，即使您不写，也有！
</p>
<div class="example">
<pre class="example">class Animal
begin

&nbsp;&nbsp;&nbsp; property int age;    // Animal's age in years
&nbsp;&nbsp;&nbsp; property int health; // Animal's health in hit points

&nbsp;&nbsp;&nbsp; constructor Animal()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age    = 0; // NOTE: not needed as set by default
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; health = 100;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method boolean canFly()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void talk()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello&quot;);
&nbsp;&nbsp;&nbsp; end
end

class Bird extends Animal
begin

&nbsp;&nbsp;&nbsp; property double flySpeed;) // Bird's speed in km/h

&nbsp;&nbsp;&nbsp; constructor Bird()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super();      // NOTE: not needed as called by default
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; flySpeed = 0; // NOTE: not needed as set by default
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method boolean canFly()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void peck()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;peck&quot;);
&nbsp;&nbsp;&nbsp; end
end

class InheriTest
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Bird eagle = new Bird();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; eagle.talk();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; eagle.peck();
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问题4.15.2：覆盖Bird类中Animal类的讲话方法，以打印出“ Tweet Tweet！”。而不是“打招呼”，以便更准确地谈论鸟类物体。
</p>
<p>问题4.15.3：通过复制在Bird类中建立的模式，将老鹰从Bird类的实例更改为自己的类，然后在InheriTest的主要函数中创建该类的实例。您的Eagle类应该具有一个属性：int numberOfKills和一个方法：void Attack（）在内部增加numberOfKills的值。在main函数中，应该调用Eagle类及其超类的每个方法。
</p>
<p>问题4.15.4：使用一个新的单独类来表示一个新对象而不是使用一个现有类的实例有什么好处？
</p>
<a name="index-Writing-your-own-classes"></a>

<p>问4.15.5：创建一个继承自Bird类的新类Kiwi。您的猕猴桃类应重写canFly方法以返回false，这反映了一个事实，即一般来说鸟类可以飞翔，但特别是猕猴桃不能飞翔。您的Kiwi类具有numberOfWorms属性。一旦编写了Kiwi类，就应该在main函数中创建Kiwi类的实例。
</p>
<p>问4.15.6：为什么主函数中的以下代码行输出100，但是在Kiwi类中没有将该变量设置为该值？
</p>
<div class="example">
<pre class="example">System.out.println(k.health);
</pre></div>

<p>问题4.15.7：在Animal，Bird，Eagle和Kiwi类中，删除所有canFly方法并将其替换为Animal类的单个canFly属性。在构造函数中，您需要将canFly属性的值设置为适合该类的值。例如，在Bird类的构造函数中，应将canFly属性设置为true，而在Kiwi类的构造函数中，应将canFly属性设置为false。
</p>
<p>问4.15.8：与一堆canFly方法相比，拥有canFly属性有什么优势？
</p>
<p>除了在Animal类中具有公共属性外，还有一种同样有效的替代方法，那就是在Animal类中具有私有属性canFly和这样的一对用于获取和设置canFly属性值的方法。在JTW和Java中，这些方法称为getter方法和setter方法，因为顾名思义，getter用于获取某物的值，而setter用于设置某物的值。上面代码的canFly方法与下面代码中的getCanFly方法相对应。
</p>
<div class="example">
<pre class="example">private property boolean canFly;

method boolean getCanFly()
begin
&nbsp;&nbsp;&nbsp; return canFly;
end

method void setCanFly(boolean aCanFly)
begin
&nbsp;&nbsp;&nbsp; canFly = aCanFly;
end
</pre></div>

<a name="index-Getter-and-setter-methods"></a>
<a name="index-Setter-and-getter-methods"></a>

<p>您可能会认为拥有一件事（单个非私有属性）比拥有三个事物（私有属性，非私有getter方法和非私有setter方法）更简单，并且您是对的。但是，从使用Animal类的客户端代码的角度来看，这两种方法是相同的。稍后，当您了解更多信息时，您将了解在哪种情况下第二种获取和设置方法更好。
</p>
<p>问题4.15.9：将主要功能更改为以下内容：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Bird b = new Bird(10);
&nbsp;&nbsp;&nbsp; var Animal a = b;
&nbsp;&nbsp;&nbsp; a.talk();
&nbsp;&nbsp;&nbsp; a.peck();
endMain
</pre></div>

<p>当您编译此代码时，会出现编译错误。哪行给出错误，错误的原因是什么？
</p>
<p>问题4.15.10：将主要功能更改为以下内容：</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var Animal a = new Animal();
&nbsp;&nbsp;&nbsp; var Bird b = a;
&nbsp;&nbsp;&nbsp; b.talk();
&nbsp;&nbsp;&nbsp; b.peck();
endMain
</pre></div>

<p>当您编译此代码时，会出现编译错误。哪行给出错误，错误的原因是什么？
</p>
<a name="Run_002dtime-type-inquiry"></a>
<h4 class="subsection">4.15.2运行时类型查询</h4>

<p>在JTW和Java中，有一个名为instanceof的关键字，它对对象的类型进行运行时检查。以下功能：</p>
<div class="example">
<pre class="example">function void say(Animal a)
begin
&nbsp;&nbsp;&nbsp; System.out.println(a instanceof Bird);
end
</pre></div>

<p>使用instanceof关键字确定引用a的运行时类型，并打印出引用是否引用Bird对象。一些例子可以澄清这种情况：</p>
<a name="index-instanceof-keyword"></a>

<ul>
<li>say（new Bird（））打印为true，由于参数a在运行时指向鸟类对象，</li><li>say（new Animal（））打印错误，因为并非每只动物都是鸟，</li><li>因为每只鹰都是鸟，所以say（new Eagle（））打印为真，并且</li><li>因为每个猕猴桃都是鸟，所以say（new Kiwi（））打印为true。
</li><li>var Animal a = new Animal（）;说（a）;打印false，因为在运行时a未指向鸟类对象</li><li>var Animal a = new Bird（）;说（a）;打印true，因为在运行时a指向鸟类对象。
</li></ul>

<p>在教程17中，您将了解为什么在大多数情况下，对于运行时类型查询，最好使用多态性而不是instanceof关键字。
</p>
<a name="The-superclass-of-all-objects"></a>
<h4 class="subsection">4.15.3所有对象的超类</h4>
<a name="index-Object-superclass-of-all-objects"></a>

<p>Java中的每个类都直接或间接继承自称为Object的类。也就是说，如果x是参考变量，则运行时表达式x instanceof Object始终为true，除非病理情况下x为null（即当前指向无对象）。Object类包含一个名为toString的方法，该方法返回一个字符串，该字符串包含以基数16（也称为十六进制）格式的对象的运行时类名称与该对象的内存地址的哈希码连接在一起。由于每个类都继承自Object，因此每个对象都可以对其调用toString。更好的是，每个类X都可以重写toString以提供适合X的调试信息。因此，toString方法便于调试。由于toString方法是Object类的公共方法，因此必须将其作为公共方法重写，因为重写的函数不能具有较弱的访问权限。
</p>
<a name="index-The-toString-method-and-its-usefulness-in-debugging_002e"></a>


<hr>
<a name="Tutorial-16-More-inheritance"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-17-Arrays-inheritance-and-polymorphism" rel="next" accesskey="n">教程17数组的继承和多态性</a> ，上一篇： <a href="#Tutorial-17-Arrays-inheritance-and-polymorphism" rel="next" accesskey="n">教程</a> <a href="#Tutorial-15-Introducing-inheritance" rel="prev" accesskey="p">15继承的介绍</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-16-More-inheritance-1"></a>
<h3 class="section">4.16教程16更多继承</h3>


<p>本教程向您展示了一个实用的继承示例。StarWars.jtw文件由三类组成：XWing，TieFighter和StarWars。前两个代表《星球大战》电影两面的航天器。StarWars类是驱动程序类，其中包含用于执行X翼和Tie Fighters之间的战斗的代码。
</p>
<a name="index-Inheritance-and-removing-duplication-of-code_002e"></a>

<p>问题4.16.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class XWing
begin

&nbsp;&nbsp;&nbsp; private property int     shields;
&nbsp;&nbsp;&nbsp; private property int     weapon;
&nbsp;&nbsp;&nbsp; private property boolean dead;

&nbsp;&nbsp;&nbsp; constructor XWing()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; shields = 1000;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; weapon  = 10;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method int getWeapon()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return weapon;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; method boolean isDead()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return dead;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; method void hit(int damage)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; shields = shields - damage;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (shields&lt;0)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;BOOM!!!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dead = true;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
end

class TieFighter
begin

&nbsp;&nbsp;&nbsp; private property int     shields;
&nbsp;&nbsp;&nbsp; private property int     weapon;
&nbsp;&nbsp;&nbsp; private property boolean dead;

&nbsp;&nbsp;&nbsp; constructor TieFighter()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; shields = 500;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; weapon  = 20;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method int getWeapon()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return weapon;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; method boolean isDead()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return dead;
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; method void hit(int damage)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; shields = shields - damage;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (shields&lt;0)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;BOOM!!!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dead = true;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
end

class StarWars
begin

&nbsp;&nbsp;&nbsp; private function void duel(XWing x, TieFighter t)
&nbsp;&nbsp;&nbsp; begin

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (;;)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x.hit(t.getWeapon());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (x.isDead())
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;X-Wing is dead&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; t.hit(x.getWeapon());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (t.isDead())
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Tie Fighter is dead&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; private function void battle(XWing good, TieFighter evil)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int g          = 0;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int e          = 0;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int goodDeaths = 0;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int evilDeaths = 0;

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (g&lt;good.length and e&lt;evil.length)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;battling X-Wing #&quot; + g + &quot; versus Tie Fighter #&quot; + e);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; duel(goodg,evile);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (goodg.isDead())
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g = g + 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goodDeaths = goodDeaths + 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (evile.isDead())
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e = e + 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; evilDeaths = evilDeaths + 1;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int finalGood = good.length - goodDeaths;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var int finalEvil = evil.length - evilDeaths;

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Battle Report: &nbsp;&nbsp;&nbsp; X-Wings &nbsp;&nbsp;&nbsp; Tie Fighters&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;----------------------------------------------&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Initial ships:&quot; + good.length + &quot;  &quot; + evil.length);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Killed ships:&quot;  + goodDeaths  + &quot;  &quot; + evilDeaths);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Final ships:&quot;&nbsp;&nbsp;&nbsp; + finalGoodPD + &quot;  &quot; + finalEvil);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (finalGood&gt;finalEvil)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; then begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;The rebel alliance is victorious!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;The dark side has conquered!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // defines the goodies array
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var XWing goodies = new XWing3;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // initialises the elements of the goodies array
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to goodies.length-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goodiesi = new XWing();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // defines the baddies array
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var TieFighter baddies = new TieFighter3;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // initialises the elements of the baddies array
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to baddies.length-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; baddiesi = new TieFighter();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; battle(goodies,baddies);

&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>问4.16.2：编译并运行此文件，以查看X翼战机和打架战斗机之间的战斗。
</p>
<p>问4.16.3：如果查看XWing和TieFighter类的Java代码，您会发现它们几乎是相同的：它们具有相同的方法和属性，唯一的区别是XWing对象使用不同的值初始化。它们的盾牌和武器属性添加到TieFighter对象。
</p>
<p>接下来的几个问题将指导您完成使用继承的过程，以消除不必要的代码重复。将创建一个名为SpaceShip的新类，并将XWing和TieFighter通用的所有代码移入该类。然后将修改XWing和TieFighter类，以便它们都继承自SpaceShip。
</p>
<p>问题4.16.4：此过程的第一步是创建SpaceShip类的外壳，现在应在其中键入：</p>
<div class="example">
<pre class="example">class SpaceShip
begin
end
</pre></div>

<p>问4.16.5：将属性盾牌，武器和死者移出XWing和TieFighter类，并移入SpaceShip类。您必须将属性的隐私状态从私有更改为受保护。受保护的修饰符被发明为公共和私人之间的中间隐私级别。像private一样，它允许对定义方法或属性的同一类可见，但是与private不同，它也允许对定义方法或属性的类的子类进行可见。
</p>
<p>问4.16.6：将三种方法getWeapon，isDead移到XWing和TieFighter类中，然后移入SpaceShip类。此时，XWing和TieFighter类应该只包含构造函数。
</p>
<p>问4.16.7：最后，将extends关键字添加到XWing和TieFighter类的第一行：</p>
<div class="example">
<pre class="example">class XWing extends SpaceShip)
</pre></div>

<p>和</p>
<div class="example">
<pre class="example">class TieFighter extends SpaceShip)
</pre></div>

<p>问4.16.8：再次编译并运行您的程序，并确保在使用继承后它产生的结果相同。
</p>
<p>问4.16.9：SpaceShip类是XWing和TieFighter的超类，包含X-Wings和Tie Fighter共同包含的所有内容。因为SpaceShip类的作用仅仅是保持这些共性，所以我们可以选择用abstract关键字标记该类：</p>
<div class="example">
<pre class="example">abstract class SpaceShip)
</pre></div>

<p>这使我们无法创建SpaceShip类的实例。没有abstract修饰符，我们可以愉快地创建一个新的SpaceShip（），该对象不是X翼，也不是Tie Fighter，而只是模糊的“太空飞船”。如果我们认为这是一个逻辑错误，则可以使用摘要来防止对SpaceShip构造函数的此类调用。将类SpaceShip更改为抽象，并观察编译器如何不接受任何形式的行：</p>
<div class="example">
<pre class="example">var SpaceShip s = new SpaceShip();) // compiler error
</pre></div>

<p>删除abstract关键字，并注意编译器随后将如何允许此行进行编译。
</p>

<hr>
<a name="Tutorial-17-Arrays-inheritance-and-polymorphism"></a>
<div class="header">
<p>下一篇： <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="next" accesskey="n">教程18高级JTW</a> ，上一篇： <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="next" accesskey="n">教程</a> <a href="#Tutorial-16-More-inheritance" rel="prev" accesskey="p">16更多继承</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-17-Arrays-inheritance-and-polymorphism-1"></a>
<h3 class="section">4.17教程17数组的继承和多态</h3>




<p>问题4.17.1：研究，编译并运行以下代码：</p>
<div class="example">
<pre class="example">class AnimalTest
begin
&nbsp;&nbsp;&nbsp; private function void chatter(Animal[] a)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to a.length-1)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a[i].talk();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Animal[] farm = { new Dog(), new Cow(), new Fish() };
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Animal[] ark  = { new Dog(), new Dog(), new Cow(), new Cow(), new Fish(), new Fish() };
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var Cow[]    herd = { new Cow(), new Cow(), new Cow() };
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; chatter(farm);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; chatter(ark);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; chatter(herd);
&nbsp;&nbsp;&nbsp; endMain
end

class Animal
begin
&nbsp;&nbsp;&nbsp; method boolean breathesUnderwater()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method boolean isPredator()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void talk()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; end
end

class Dog extends Animal
begin
&nbsp;&nbsp;&nbsp; method boolean isPredator()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void talk()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Woof woof!&quot;);
&nbsp;&nbsp;&nbsp; end
end
</pre></div>

<p>问题4.17.2：编写以下类作为上述动物类的子类：牛，猫，鱼和鲸鱼。
</p>
<a name="index-Writing-your-own-classes-1"></a>

<p>问4.17.3：编写扩展Fish类的Shark类。覆盖所有必要的方法。为了这个示例和下面的代码，假设shark的talk方法打印出“ Chomp Chomp！”。
</p>
<a name="index-Polymorphism"></a>

<p>问4.17.4：运行AnimalTest类以确保所有方法都能正常工作。
</p>
<p>问4.17.5：重写chatter方法，以使其从不调用talk方法，而使用一系列if（...）then ...语句和instanceof运算符来测试数组中每个对象的运行时类型。以下是一些入门代码：</p>
<a name="index-Arrays-2"></a>
<a name="index-Arrays-of-Object-type"></a>

<div class="example">
<pre class="example">private function void chatter(Animal[] a)
begin
&nbsp;&nbsp;&nbsp; superfor (var int i=0 to a.length-1)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (a[i] instanceof Cow) then
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Moo!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; elseif (a[i] instanceof Cat) then
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Meow!&quot;);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* other code goes here */
&nbsp;&nbsp;&nbsp; end
end
</pre></div>

<p>请注意，在上面的代码中，子类必须出现在超类之前，否则对于子类将输出错误消息。
</p>
<p>问4.17.6：为什么最后一个问题的代码不如调用每个动物的说话方法好？通常，多态性优于运行时类型查询。
</p>
<a name="index-Polymorphism-versus-run_002dtime-type-inquiry"></a>
<a name="index-Run_002dtime-type-inquiry-versus-Polymorphism"></a>
<a name="index-Why-it-is-better-to-use-polymorphism-rather-than-run_002dtime-type-inquiry"></a>




<hr>
<a name="Tutorial-18-Advanced-J_002eT_002eW_002e"></a>
<div class="header">
<p>上一页： <a href="#Tutorial-17-Arrays-inheritance-and-polymorphism" rel="prev" accesskey="p">教程17数组的继承和多态性</a> ，上： <a href="#J_002eT_002eW_002e-Tutorials" rel="up" accesskey="u">JTW教程</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Tutorial-18-Advanced-J_002eT_002eW_002e-1"></a>
<h3 class="section">4.18教程18高级JTW</h3>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">•将<a href="#Mapping-J_002eT_002eW_002e-to-Java" accesskey="1">JTW映射到Java</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">•用<a href="#Piping-the-output-of-javac-and-java" accesskey="2">管道输送javac和java的输出</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files" accesskey="3">用于将* .jtw构建到* .java并运行* .class文件的Makefile</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
</tbody></table>

<p>请参阅<a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个程序包的集合，</a>以获取有关编译整个类<a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">程序包</a>的更多信息。
</p>

<hr>
<a name="Mapping-J_002eT_002eW_002e-to-Java"></a>
<div class="header">
<p>下一篇： <a href="#Piping-the-output-of-javac-and-java" rel="next" accesskey="n">管道化javac和java的输出，上</a>一篇： <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="up" accesskey="u">教程18 Advanced JTW</a>   [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Mapping-J_002eT_002eW_002e-to-Java-1"></a>
<h4 class="subsection">4.18.1将JTW映射到Java</h4>

<a name="index-Mapping-from-_002a_002ejtw-_002d_003e-_002a_002ejava"></a>
<a name="index-J_002eT_002eW_002e-internal-details"></a>
<a name="index-Internal-details-of-the-J_002eT_002eW_002e-system"></a>

<p>这是从JTW映射到Java的方法：</p>


<table>
<tbody><tr><td width="10%">功能</td><td width="70%">->静态</td></tr>
<tr><td width="10%">变种</td><td width="70%">->没有</td></tr>
<tr><td width="10%">classVar</td><td width="70%">->静态</td></tr>
<tr><td width="10%">属性</td><td width="70%">->没有</td></tr>
<tr><td width="10%">方法</td><td width="70%">->没有</td></tr>
<tr><td width="10%">建设者</td><td width="70%">->没有</td></tr>
<tr><td width="10%">开始</td><td width="70%">-> {</td></tr>
<tr><td width="10%">结束</td><td width="70%">->}</td></tr>
<tr><td width="10%">beginMain</td><td width="70%">->公共静态void main（String [] args）{</td></tr>
<tr><td width="10%">endMain</td><td width="70%">->}</td></tr>
<tr><td width="10%">和</td><td width="70%">-> &&</td></tr>
<tr><td width="10%">要么</td><td width="70%">-> ||</td></tr>
<tr><td width="10%">然后</td><td width="70%">->没有</td></tr>
<tr><td width="10%">elseif</td><td width="70%">->否则</td></tr>
</tbody></table>

<p>这是一个JTW程序：</p>
<div class="example">
<pre class="example">class HelloWorld
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello, World!&quot;)
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>转换为Java语言后，这是相同的JTW程序：</p>
<div class="example">
<pre class="example">class HelloWorld
{
&nbsp;&nbsp;&nbsp; public static void main(String[] args)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello, World!&quot;)
&nbsp;&nbsp;&nbsp; }
}
</pre></div>

<p>请注意，上图左侧的这些JTW关键字不应映射到它们在字符串和注释中的Java等效项。该转换最初是使用m4语言编写的，用于将JTW映射到Java，但是这种方法的缺点是，像字符串中的begin和end这样的关键字被映射为它们的Java等效项，如下所示：</p>

<table>
<tbody><tr><td width="10%">System.out.println（“ function”）;</td><td width="70%">-> System.out.println（“ static”）;</td></tr>
<tr><td width="10%">System.out.println（“ classVar”）;</td><td width="70%">-> System.out.println（“ static”）;</td></tr>
<tr><td width="10%">System.out.println（“ property”）;</td><td width="70%">-> System.out.println（“”）;</td></tr>
<tr><td width="10%">System.out.println（“ method”）;</td><td width="70%">-> System.out.println（“”）;</td></tr>
<tr><td width="10%">System.out.println（“ constructor”）;</td><td width="70%">-> System.out.println（“”）;</td></tr>
<tr><td width="10%">System.out.println（“ begin”）;</td><td width="70%">-> System.out.println（“ {”）;</td></tr>
<tr><td width="10%">System.out.println（“ end”）;</td><td width="70%">-> System.out.println（“}”）;</td></tr>
<tr><td width="10%">System.out.println（“ beginMain”）;</td><td width="70%">-> System.out.println（“ public static void main（String [] args）{”）;</td></tr>
<tr><td width="10%">System.out.println（“ endMain”）;</td><td width="70%">-> System.out.println（“}”）;</td></tr>
<tr><td width="10%">System.out.println（“ and”）;</td><td width="70%">-> System.out.println（“ &&”）;</td></tr>
<tr><td width="10%">System.out.println（“ or”）;</td><td width="70%">-> System.out.println（“ ||”）;</td></tr>
<tr><td width="10%">System.out.println（“ then”）;</td><td width="70%">-> System.out.println（“”）;</td></tr>
<tr><td width="10%">System.out.println（“ elseif”）;</td><td width="70%">-> System.out.println（“ else if”）;</td></tr>
</tbody></table>



<p>这当然是错误的行为。克服此限制的一种方法是分解JTW关键字，如下所示：</p>
<div class="example">
<pre class="example">System.out.println(&quot;be&quot; + &quot;gin&quot;);)
</pre></div>

<p>通过使用Flex将JTW编译为Java或使用Emacs进行相同的操作，可以解决此问题，但是仅比Flex的速度慢一点。最后，我选择GNU Emacs作为预处理器语言JTW的宿主，因为它是免费，自由和开源软件，足以满足我的编程需求，并且比Flex或m4强大。为了弥补这种缺陷，使用了Emacs的批处理模式来完成从JTW到Java的转换。这意味着GNU Emacs必须存在于客户端系统上才能进行JTW到Java的映射。当然，使用Emacs作为编辑器没有强迫性，尽管这样做有很多好处。第一是JTW关键字和注释具有自动语法突出显示功能。第二点是Emacs可以对JTW代码进行正确的自动缩进。
</p>
<hr>
<a name="Piping-the-output-of-javac-and-java"></a>
<div class="header">
<p>下一篇： <a href="#Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files" rel="next" accesskey="n">用于将* .jtw构建到* .java并运行* .class文件的Makefile，上</a>一篇：将<a href="#Mapping-J_002eT_002eW_002e-to-Java" rel="prev" accesskey="p">JTW映射到Java</a> ，上<a href="#Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files" rel="next" accesskey="n">一篇</a> ： <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="up" accesskey="u">教程18高级JTW</a>   [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Piping-the-output-of-javac-and-java-1"></a>
<h4 class="subsection">4.18.2用管道输送javac和java的输出</h4>
<a name="index-Piping-the-output-of-javac-and-java"></a>

<p>可执行文件javac和java的输出将其标准输出流和标准错误流传递到Emacs的批处理模式，这样即使文件包含在内，诸如Foo.java:123之类的错误消息也会指向正确的文件Foo.jtw：123（ <a href="#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion">JTW证明概念＃2的文件包含</a> ）已被使用。grep和sed程序在转换过程中也用作管道，因此它们必须存在于客户端系统上。
</p>
<hr>
<a name="Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files"></a>
<div class="header">
<p>上<a href="#Piping-the-output-of-javac-and-java" rel="prev" accesskey="p">一篇</a> ： <a href="#Piping-the-output-of-javac-and-java" rel="prev" accesskey="p">管道化javac和java的输出</a> ，上<a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="up" accesskey="u">一篇</a> ： <a href="#Tutorial-18-Advanced-J_002eT_002eW_002e" rel="up" accesskey="u">教程18 Advanced JTW</a>   [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files-1"></a>
<h4 class="subsection">4.18.3 Makefile，用于将* .jtw构建到* .java中并运行* .class文件</h4>
<a name="index-Makefile-for-generating-_002a_002eclass-files-from-_002a_002ejtw-files"></a>

<p>这是用于构建* .java文件和* .class文件并运行它们的GNU Makefile。
</p>
<div class="example">
<pre class="example">.PRECIOUS:
.PRECIOUS: %.java %.class

JAVAC_FLAGS = -source 1.5 -Xlint:unchecked -Xlint:deprecation
JAVA_FLAGS  = -enableassertions
SHELL       = /bin/bash

%.java: %.jtw
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; @echo &quot;* Stage 1 : Debugging $*.jtw and building $*.java file&quot;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; emacs --batch --eval &quot;(setq *stump* \&quot;$*\&quot;)&quot; --load jtw-build-jtw.el --funcall doit

%.class: %.java
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; @echo &quot;* Stage 2 : Debugging *.java and building *.class file(s)&quot;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; javac $(JAVAC_FLAGS) $$(find . -name &quot;*.java&quot;) |&amp; emacs --batch --eval &quot;(setq *stump* \&quot;$*\&quot;)&quot; --load jtw-javac.el --funcall doit |&amp; grep &quot;input0-9:&quot; - |&amp; sed -e &quot;s/input0-9:s//g&quot; -

%.run: %.class
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; @echo &quot;* Stage 3 : Running $*.class File&quot;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; java $(JAVA_FLAGS) $* |&amp; emacs --batch --load jtw-java.el --funcall doit |&amp; grep &quot;input0-9*:&quot; - |&amp; sed -e &quot;s/input0-9*://g&quot; -

build: clean
</pre></div>

<p>第一行。不带任何参数的PRECIOUS会清除珍贵文件列表，该文件列表在构建过程中不会删除。
</p>


<hr>
<a name="Packages-in-J_002eT_002eW_002e-and-Java"></a>
<div class="header">
<p>下一篇： <a href="#GNU-Free-Documentation-License" rel="next" accesskey="n">GNU自由文档许可证</a> ，上一篇： <a href="#J_002eT_002eW_002e-Tutorials" rel="prev" accesskey="p">JTW教程</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Packages-in-J_002eT_002eW_002e-and-Java-1"></a>
<h2 class="chapter">5个JTW和Java软件包</h2>

<p>软件包的结构反映了文件系统。例如，您可以拥有一个名为（出于参数考虑）pkg的程序包，该程序包对应于〜/ jtw-tutorials文件夹中的文件夹pkg。您可以有一个名为（出于参数考虑）inner的子包，它将位于〜/ jtw-tutorials / pkg / inner文件夹中。即使第二个程序包位于第一个程序包的内部，它们仍被视为单独的程序包。
</p>


<p>有一个我不会使用的命名约定，它有助于为您的程序包赋予唯一的名称。如果您拥有<a href="http://davinpearson.com">davinpearson.com之</a>类的网站， <a href="http://davinpearson.com">则</a>可以这样命名软件包：com / davinpearson / inner / inner2，其中com / davinpearson，其中com.davinpearson.inner和com.davinpearson.inner.inner2是单独的软件包。我拥有域名davinpearson.com的事实确保了我的软件包说明com / davinpearson是唯一的。com首先出现，因为它是实际域名，而不是唯一的com扩展名。因此，将任何代码直接放置在com文件夹中是不明智的。因此，实际上，我们正在背负现有标准，即Internet域名。网站使用相同的功能，因为您的电子邮件地址是个人唯一的，因此要求您提供电子邮件地址作为登录名。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Moving-a-class-into-a-package" accesskey="1">将课程移至包中</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Moving-a-class-into-a-sub_002dpackage" accesskey="2">将类移到子包中</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Importing-a-package" accesskey="3">导入包</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#Importing-a-package-from-another-package" accesskey="4">从另一个包导入一个包</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#How-to-build-a-collection-of-class-files-or-an-entire-package" accesskey="5">如何构建类文件或整个包的集合</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">• <a href="#How-to-invoke-javadoc-on-a-package" accesskey="6">如何在包上调用javadoc</a> ：</td><td>  </td><td align="left" valign="top">
</td></tr>
</tbody></table>

<hr>
<a name="Moving-a-class-into-a-package"></a>
<div class="header">
<p>下一页： <a href="#Moving-a-class-into-a-sub_002dpackage" rel="next" accesskey="n">将类移动到子包中</a> ，上： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Moving-a-class-into-a-package-1"></a>
<h3 class="section">5.1将类移到包中</h3>

<a name="index-Packages_002c-moving-a-class-into-a-package"></a>

<p>考虑一个典型的类：</p>


<div class="example">
<pre class="example">class A
begin
&nbsp;&nbsp;&nbsp; property int data;

&nbsp;&nbsp;&nbsp; classVar int data2 = 666;

&nbsp;&nbsp;&nbsp; constructor A(int d)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = d;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void meth1()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth1:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; method void meth2()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth2:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; function void func()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;func:&quot; + data2);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a1 = new A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a2 = new A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>要将此类移入名为（出于参数考虑）pkg的包中，您需要将类的可见性状态从无（即包可见性）设置为public。同样，如果要能够从包外部访问这些项目，则每个可见的包（即，没有私有或公共或受保护的规范）类变量，函数，方法和属性都需要将其可见性状态从包更改为公共。如果同一文件中有多个类，则必须将它们分成单独的文件，因为每个文件只能有一个公共类。另外，必须通过诸如pkg软件包之类的软件包规范来声明软件包名称。在文件的顶部，而不是任何实际的类或接口定义。这是相同的源文件，准备放入包中：</p>
<div class="example">
<pre class="example">package pkg;

public class A
begin
&nbsp;&nbsp;&nbsp; public property int data;

&nbsp;&nbsp;&nbsp; public classVar int data2 = 666;

&nbsp;&nbsp;&nbsp; public constructor A(int d)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = d;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void meth1()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth1:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void meth2()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth2:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public function void func()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;func:&quot; + data2);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a1 = new A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a2 = new A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>同样，该类的源文件也需要移动到文件夹〜/ jtw-tutorials / pkg中。要运行该类，您将需要调用Makefile命令：</p>
<div align="center">清洁pkg / A.run</div>
<hr>
<a name="Moving-a-class-into-a-sub_002dpackage"></a>
<div class="header">
<p>下一篇： <a href="#Importing-a-package" rel="next" accesskey="n">导入软件包</a> ，上一篇： <a href="#Importing-a-package" rel="next" accesskey="n">将</a> <a href="#Moving-a-class-into-a-package" rel="prev" accesskey="p">类移入软件包</a> ，上<a href="#Moving-a-class-into-a-package" rel="prev" accesskey="p">一篇</a> ： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的软件包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Moving-a-class-into-a-sub_002dpackage-1"></a>
<h3 class="section">5.2将类移到子包中</h3>

<p>假设您想将A类从无包（〜/ jtw-tutorials文件夹）移动到为参数pkg.inner调用<a href="#Moving-a-class-into-a-package">的包，则</a>需要遵循<a href="#Moving-a-class-into-a-package">将类移入包</a>的步骤，唯一的区别是软件包规格需要更改为pkg.inner软件包；并且需要将文件移到pkg / inner文件夹中。要运行类文件，您需要调用以下Make命令：</p>
<div align="center">进行干净的pkg / inner / A.run。
</div>
<p>这是〜/ jtw-tutorials / pkg / inner / A.jtw文件的类定义：</p>
<div class="example">
<pre class="example">package pkg.inner;

public class A
begin
&nbsp;&nbsp;&nbsp; public property int data;

&nbsp;&nbsp;&nbsp; public classVar int data2 = 666;

&nbsp;&nbsp;&nbsp; public constructor A(int d)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = d;
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void meth1()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth1:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public method void meth2()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;meth2:&quot; + data);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; public function void func()
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;func:&quot; + data2);
&nbsp;&nbsp;&nbsp; end

&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a1 = new A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a2 = new A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<hr>
<a name="Importing-a-package"></a>
<div class="header">
<p>下一篇： <a href="#Importing-a-package-from-another-package" rel="next" accesskey="n">从另一个包中导入一个包</a> ，上一篇： <a href="#Importing-a-package-from-another-package" rel="next" accesskey="n">将</a> <a href="#Moving-a-class-into-a-sub_002dpackage" rel="prev" accesskey="p">类移动到子包中</a> ，上<a href="#Moving-a-class-into-a-sub_002dpackage" rel="prev" accesskey="p">一篇</a> ： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Importing-a-package-1"></a>
<h3 class="section">5.3导入包</h3>

<a name="index-Packages_002c-importing"></a>

<p>当引用包中的类或接口时，您需要在要访问的包中的每个类名和接口名前面指定包名，例如，在主文件夹〜/ jtw-tutorials中（在任何目录之外）包）：</p>
<div class="example">
<pre class="example">class B
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var pkg.A a1 = new pkg.A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var pkg.A a2 = new pkg.A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pkg.A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>为了避免必须使用其包来限定每个类名和接口名，您需要像这样在类的定义之前使用import指令：</p>
<div class="example">
<pre class="example">import pkg.*;

class B
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a1 = new A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a2 = new A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<hr>
<a name="Importing-a-package-from-another-package"></a>
<div class="header">
<p>下一页： <a href="#How-to-build-a-collection-of-class-files-or-an-entire-package" rel="next" accesskey="n">如何构建类文件或整个程序包的集合</a> ，上一页： <a href="#Importing-a-package" rel="prev" accesskey="p">导入程序包</a> ，向上： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的程序包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Importing-a-package-from-another-package-1"></a>
<h3 class="section">5.4从另一个包导入一个包</h3>

<p>在引用包中的类或接口时，需要在要访问的包中的每个类名或接口名前面指定包名，例如，在〜/ jtw-tutorials / pkg文件夹中（即\在pkg包中）。
</p>
<div class="example">
<pre class="example">package pkg;

public class C
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var pkg.inner.A a1 = new pkg.inner.A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var pkg.inner.A a2 = new pkg.inner.A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pkg.inner.A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<p>为了避免必须使用其包来限定每个类名或接口名，您需要像在包声明之后但在类或接口的定义之前那样使用import指令，如下所示：</p>
<div class="example">
<pre class="example">package pkg;

import pkg.inner.*;

public class C
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a1 = new A(123);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a1.meth1(); <i>// prints out &quot;meth1:123&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var A a2 = new A(456);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a2.meth2(); <i>// prints out &quot;meth2:456&quot;</i>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A.func(); <i>// prints out &quot;func:666&quot;</i>
&nbsp;&nbsp;&nbsp; endMain
end
</pre></div>

<hr>
<a name="How-to-build-a-collection-of-class-files-or-an-entire-package"></a>
<div class="header">
<p>下一页： <a href="#How-to-invoke-javadoc-on-a-package" rel="next" accesskey="n">如何在程序包</a>上<a href="#How-to-invoke-javadoc-on-a-package" rel="next" accesskey="n">调用javadoc</a> ，上一页： <a href="#Importing-a-package-from-another-package" rel="prev" accesskey="p">从另一个程序包导入程序</a> ，向上： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的程序包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-to-build-a-collection-of-class-files-or-an-entire-package-1"></a>
<h3 class="section">5.5如何构建类文件或整个包的集合</h3>

<a name="index-Building-code-that-uses-a-package"></a>
<a name="index-Building-a-collection-of-classes"></a>
<a name="index-Packages_002c-building"></a>
<a name="index-Collection-of-classes_002c-building"></a>

<p>当您的类X在另一个文件中使用另一个类Y时，则需要添加到Makefile的构建目标中，该目标最初是这样的：</p>
<div align="center">身材：干净</div>
<p>如下：</p>
<div align="center">构建：干净的Y.java</div>
<p>如果您的Y类位于另一个包中，例如〜/ jtw-tutorials / path / to / dir / Y.class类，即位于path.to.dir包中，则需要像这样将其添加到Makefile的构建目标中：</p>
<div align="center">构建：干净的路径/到/目录/ Y.java</div>
<p>对于从主类X直接或间接调用的每个类，都应重复此过程。通过将此过程应用于软件包中的每个文件，您只需调用Makefile命令make build即可构建整个软件包。要实际编译并运行X类，请让〜/ jtw-tutorials / path2 / to / dir / X.class为X类的位置。然后，您需要调用以下Makefile目标：</p>
<div align="center">使构建路径2 / to / dir / X.run</div>
<p>构建目标调用“干净”目标，该目标直接或间接删除文件夹〜/ jtw-tutorials中的所有* .java和* .class文件。如果您不这样做，那么尽管构建过程中存在较早的错误，java仍可能运行旧版本的* .class文件。这是因为在构建和执行* .class文件中使用管道会隐藏程序javac和java的返回值。
</p>
<hr>
<a name="How-to-invoke-javadoc-on-a-package"></a>
<div class="header">
<p>上一页： <a href="#How-to-build-a-collection-of-class-files-or-an-entire-package" rel="prev" accesskey="p">如何构建类文件或整个软件包的集合，上一篇</a> ： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="up" accesskey="u">JTW和Java中的软件包</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-to-invoke-javadoc-on-a-package-1"></a>
<h3 class="section">5.6如何在包上调用javadoc</h3>

<p>要调用javadoc，首先需要从文件夹〜/ jtw-tutorials发出以下命令：</p>
<div align="center">建立</div>
<p>有关设置构建目标的更多信息，请参见<a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个程序包的集合</a> 。然后，您需要从文件夹〜/ jtw-tutorials发出以下命令：</p>
<div align="center">javadoc path3 / to / pkg -d / path4 / to / dir</div>
<p>其中path3.to.pkg是要构建的软件包的名称，/ path4 / to / dir是* .html格式的文档文件的所需位置。
</p>


<hr>
<a name="GNU-Free-Documentation-License"></a>
<div class="header">
<p>下一篇： <a href="#Passwords-for-the-answers-to-the-tutorials" rel="next" accesskey="n">教程答案的密码，上</a>一篇： <a href="#Packages-in-J_002eT_002eW_002e-and-Java" rel="prev" accesskey="p">JTW和Java包</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Free-Documentation-License-1"></a>
<h2 class="appendix">附录A GNU自由文档许可证</h2>



<p>GNU自由文档许可证版本1.3，2008年11月3日</p>

<p>版权所有（C）2000、2001、2002、2007、2008 Free Software Foundation，Inc. <http: ="" fsf.org=""></http:>允许每个人复制和分发此许可证文档的逐字记录副本，但不允许对其进行更改。
</p>
<p>0。前言</p>
<p>本许可的目的是使自由意义上的“手册”，教科书或其他实用和有用的文件“免费”：保证每个人都有有效的自由，无论是否进行商业或非商业修改，都可以对其进行复制和重新分发。其次，本许可证为作者和出版商保留了一种因其作品而获得好评的方式，同时不被视为对他人所做的修改负责。
</p>
<p>该许可是一种“ copyleft”，这意味着文档的衍生作品本身必须在相同意义上是免费的。它是GNU通用公共许可证的补充，GNU通用公共许可证是专为自由软件设计的Copyleft许可证。
</p>
<p>我们设计此许可证是为了将其用于免费软件的手册，因为免费软件需要免费的文档：免费程序应随附手册，以提供与软件相同的自由。但是本许可不限于软件手册；它可以用于任何文本作品，而无论其主题是什么，或者它是否作为印刷书籍出版。我们建议您将此许可证主要用于目的是作为指导或参考的作品。
</p>

<p>1。适用性和定义</p>
<p>本许可适用于任何形式的任何手册或其他作品，其中包含版权所有者发布的声明，声明其可以根据本许可的条款进行分发。此类通知授予了全球范围内的免版税使用许可，期限不限，可以在此处所述的条件下使用该作品。下面的“文档”是指任何此类手册或作品。任何公众人士都是被许可人，称呼为“您”。如果您按照版权法要求许可的方式复制，修改或分发作品，则您接受许可。
</p>
<p>文档的“修改版本”是指包含文档或文档一部分的任何作品，可以逐字复制，也可以进行修改和/或翻译成另一种语言。
</p>
<p>“次要部分”是文档的命名附录或最重要的部分，专门处理文档的出版者或作者与文档的整体主题（或相关事宜）之间的关系，不包含任何可能直接涉及的内容在整个主题范围内。（因此，如果该文档部分是一本数学教科书，那么第二部分可能不会解释任何数学。）这种关系可以是与主题或相关问题的历史联系，也可以是关于它们的法律，商业，哲学，伦理或政治立场。
</p>
<p>“不变部分”是某些二级部分，其标题在声明中指出，文档是根据本许可发布的，其标题与不变部分相同。如果某个部分不符合上面对“辅助”的定义，则不允许将其指定为“不变式”。该文档可能包含零个不变部分。如果文档未标识任何不变节，则没有任何不变节。
</p>
<p>“封面文字”是某些简短的文本段落，在声明中指出该文档是根据本许可发布的，这些文字作为“封面文字”或“封面文字”列出。“封面文本”最多可以包含5个字，“封面文本”最多可以包含25个字。
</p>
<p>文档的“透明”副本是指一种机器可读的副本，以其规格可供大众使用的格式表示，适用于使用常规文本编辑器或（对于由像素组成的图像）常规颜料进行直接修改的文档程序或（用于绘图的）一些广泛使用的绘图编辑器，它适合于输入文本格式化程序或自动转换为适合输入到文本格式化程序的多种格式。以其他方式透明的文件格式制作的副本，其标记或没有标记的安排，可以阻止或阻止读者的后续修改，则该副本不是透明的。如果用于大量文本，则图像格式不是“透明”的。不是“透明”的副本称为“不透明”。
</p>
<p>适用于透明副本的格式的示例包括不带标记的纯ASCII，Texinfo输入格式，LaTeX输入格式，使用公开可用的DTD的SGML或XML，以及设计用于人工修改的符合标准的简单HTML，PostScript或PDF。透明图像格式的示例包括PNG，XCF和JPG。不透明格式包括只能由专有文字处理器，SGML或XML读取和编辑的专有格式，而SGML或XML通常不提供DTD和/或处理工具，以及某些文字处理器为某些文字处理器生成的机器生成的HTML，PostScript或PDF仅用于输出目的。
</p>
<p>对于印刷书籍，“标题页”指的是标题页本身，以及随后的以下几页，这些页可以清晰地容纳本许可证要求在标题页中显示的材料。对于没有这样的标题页的格式的作品，“标题页”是指在文本正文开头之前靠近作品标题最突出外观的文本。
</p>
<p>“发布者”是指向公众分发文档副本的任何个人或实体。
</p>
<p>“带标题的XYZ”部分是指文档的命名子单元，其标题要么恰好是XYZ，要么在括号中包含XYZ，之后是将XYZ转换为其他语言的文本。（此处XYZ代表以下提到的特定部分名称，例如“致谢”，“奉献精神”，“认可”或“历史记录”。）在修改文档时，要“保留此部分的标题”，则意味着根据此定义，该部分仍为“已命名的XYZ”部分。
</p>
<p>该文件的声明旁边可能包含“免责声明”，该声明指出本许可适用于该文件。这些保修免责声明被视为已包含在本许可中，但仅用于免责声明：这些保修免责声明可能具有的任何其他暗示都是无效的，并且对本许可的含义没有任何影响。
</p>
<p>2。VERBATIM复制</p>
<p>您可以在任何媒介中以商业或非商业方式复制和分发本文档，但前提是本许可，版权声明和声明本许可适用于本文档的许可声明均以所有副本形式复制，并且您不添加任何其他条件符合本许可的规定。您不得使用技术措施来阻碍或控制您复制或分发的副本的阅读或进一步复制。但是，您可以接受赔偿以换取副本。如果分发足够多的副本，则还必须遵循第3节中的条件。
</p>
<p>您还可以在上述相同条件下出借副本，并可以公开展示副本。
</p>

<p>3。大量复制</p>
<p>如果您发布文档的印刷副本（或通常具有印刷封面的介质副本），且编号超过100，并且文档的许可通知书要求包含封面文字，则必须将这些副本随附在清晰可见的所有文档中封面文字：封面上的封面文字和封底上的封面文字。两种封面都必须清楚，清楚地标识您是这些副本的发行者。封面必须显示完整的标题，标题中的所有单词均应同样醒目且可见。您还可以在封面上添加其他材料。只要封面保留了文档标题并满足这些条件，则仅对封面进行更改即可在其他方面被视为逐字复印。
</p>
<p>如果任何一个封面所需的文本量太大，无法清晰地容纳，则应将列出的第一个（合理合理的数量）放在实际的封面上，然后将其余部分继续放在相邻的页面上。
</p>
<p>如果您发布或分发的Opaque文档副本数量超过100，则必须在每份Opaque副本中包含机器可读的透明副本，或者在每份Opaque副本中或其中声明一个计算机网络位置，通用网络将从该位置开始使用public可以使用公共标准网络协议下载完整的文档透明副本，而无需添加任何材料。如果使用后一种选项，则在开始批量分发不透明副本时，必须采取合理的审慎步骤，以确保该透明副本将在指定位置保持可访问的状态，直到您上一次分发不透明副本至少一年之后。该版本的不透明副本（直接或通过您的代理商或零售商）向公众发布。
</p>
<p>要求（但不是必须）在重新分发大量副本之前，与文档作者保持良好联系，以便他们有机会为您提供文档的更新版本。
</p>

<p>4。修改方式</p>
<p>您可以在上述第2节和第3节的条件下复制和分发本文档的修改版本，前提是您严格按照本许可协议发布修改版本，而修改版本则充当文档的角色，从而许可对本文档的分发和修改拥有副本的修改版本。此外，您必须在修改后的版本中执行以下操作：</p>
<p>A.在标题页（和封面，如果有的话）中使用与本文档以及以前版本（如果有的话，应在文档的“历史记录”部分列出）不同的标题。如果该版本的原始发行者给予许可，则可以使用与先前版本相同的标题。B.在标题页上列出一位或多位负责修改版本著作权的作者或个人，以及至少五名文档的主要作者（如果有的话，其所有主要作者）少于五个），除非他们使您脱离此要求。C.在“标题”页面上注明修改版本的发布者的名称，即发布者。D.保留文档的所有版权声明。E.在其他版权声明旁边添加一个适当的版权声明供您进行修改。F.在版权声明之后，立即附上许可声明，以下面的附录中所示的形式，向公众授予根据本许可条款使用修改版的许可。G.在该许可声明中保留文档许可声明中给出的不变部分的完整列表和必填封面文本。H.包括本许可证的未更改副本。I.保留标题为“历史”的部分，保留其标题，并在其上添加至少说明标题页上给出的修改版本的标题，年份，新作者和发行者的项目。如果文档中没有标题为“历史记录”的部分，请在其标题页上创建一个说明文档的标题，年份，作者和出版者的内容，然后添加一项描述上一句中所述的修改版本。J.保留文档中给出的网络位置（如果有），以供公众访问文档的透明副本，同样，保留文档中给出的基于其以前版本的网络位置。这些可以放在“历史记录”部分中。对于在文档本身之前至少四年出版的作品，或者如果其所指版本的原始发行者给予许可，您可以省略其网络位置。K.对于标题为“致谢”或“奉献”的任何部分，请保留该部分的标题，并在该部分中保留其中给出的每个贡献者致谢和/或奉献的所有内容和基调。L.保留文档的所有不变部分，其内容和标题均保持不变。章节编号或同等编号不视为章节标题的一部分。M.删除任何标题为“背书”的部分。这样的部分可能不包含在修改版本中。N.请勿将任何现有的节重新命名为“背书”，或与任何不变节的标题冲突。O.保留所有免责声明。
</p>
<p>如果修改后的版本包括新的前节或附录，这些节或附录符合第二节的规定，并且不包含从文档中复制的材料，则可以选择将其中的部分或全部指定为不变的。为此，请将其标题添加到“修改版本”许可声明中的“不变部分”列表中。这些标题必须与任何其他节标题不同。
</p>
<p>您可以添加标题为“背书”的部分，但其中仅包含各方对您的修改版本的背书，例如，同行评审的声明或文本已被组织批准为标准的权威定义。
</p>
<p>您可以在修改版本的封面文本列表的末尾添加最多5个单词的段落作为“封面文本”，以及最多25个单词的段落作为“封面文本”。任何一个实体（或通过它们的安排）都只能添加“封面文字”和“封面文字”中的一个段落。如果文档已经包含同一封面的封面文字，该文字是您先前添加的或由您代表的同一实体做出的安排而添加的，则不得添加其他文字；但是您可以在添加了旧版本的以前的发布者的明确许可下替换旧版本。
</p>
<p>本文档的作者和发行者未获得本许可证的许可，不得使用其名称进行宣传或主张或暗示认可任何修改版本。
</p>

<p>5，合并文件</p>
<p>您可以根据上文第4节中针对修改版本定义的条款，将文档与根据本许可发布的其他文档进行组合，但前提是您必须将所有未经修改的原始文档的所有不变部分都包含在其中，并列出所有这些文档作为您许可协议中合并工作的不变部分，并保留其所有保修免责声明。
</p>
<p>合并后的作品仅包含此许可的一个副本，并且多个相同的不变部分可用一个副本代替。如果存在多个具有相同名称但内容不同的不变部分，请在该部分的末尾加上括号，在该部分的末尾添加原始作者或发布者的名称（如果已知），以使每个此类的标题唯一。唯一编号。对合并作品的许可声明中不变部分列表中的部分标题进行相同的调整。
</p>
<p>在组合中，您必须将各种原始文档中标题为“ History”的任何部分组合在一起，组成一个标题为“ History”的部分；同样，将标题为“致谢”的所有部分与标题为“奉献”的任何部分组合在一起。您必须删除所有标题为“认可”的部分。
</p>

<p>6。文件收集</p>
<p>您可以收集由本许可协议下发布的文档和其他文档组成的集合，并在该文档中将其替换为各个文档中包含的单个副本，前提是您遵守本许可协议的规定。在所有其他方面逐字逐字复印。
</p>
<p>您可以从此类集合中提取单个文档，并根据本许可证单独分发它，前提是您将本许可证的副本插入提取的文档中，并且在与该文档的逐字复制有关的所有其他方面遵守本许可证。
</p>

<p>7。独立工作的集合</p>
<p>如果存储内容或分发介质中或存储介质上或该介质上的文档或其衍生物与其他单独且独立的文档或作品的汇编，如果该汇编所产生的版权不用于限制合法权利，则称为“汇总”汇编用户的数量超出了个人作品的许可范围。当文档包含在汇总中时，本许可不适用于汇总中的其他作品，而这些作品本身不是文档的衍生作品。
</p>
<p>如果第3节的封面文字要求适用于本文档的这些副本，则如果该文档少于全部汇总的一半，则可以将文档的封面文字放在汇总中将文档括起来的封面上，或者如果文档为电子形式，则具有等同的封面电子形式。否则，它们必须出现在将整个集合括起来的印刷封面上。
</p>

<p>8。翻译</p>
<p>翻译被视为一种修改，因此您可以根据第4节的条款分发文档的翻译。用翻译替换不变部分需要其版权所有者的特殊许可，但是除了这些不变部分的原始版本之外，您还可以包括部分或全部不变部分的翻译。您可以在本文档以及所有保修免责声明中包括本许可，所有许可声明的翻译，但前提是您还包括本许可的原始英文版本以及这些声明和免责声明的原始版本。如果本许可的翻译版本与原始版本或声明或免责声明之间存在分歧，则以原始版本为准。
</p>
<p>如果文档中某节的标题为“致谢”，“奉献”或“历史记录”，则保留其标题（第1节）的要求（第4节）通常需要更改实际标题。
</p>

<p>9。终止</p>
<p>除非本许可明确规定，否则您不得复制，修改，再许可或分发文档。否则，任何尝试复制，修改，再许可或分发的尝试均无效，并且将自动终止您在本许可下的权利。
</p>
<p>但是，如果您停止所有对本许可的违反，则（a）临时恢复特定版权持有者的许可，除非且直到版权持有者明确终止并最终终止您的许可为止；以及（b）如果版权持有者失败，则永久地在停止交易发生后的60天之内通过某种合理的方式通知您违规行为。
</p>
<p>此外，如果版权所有者以某种合理的方式通知您有关侵权的信息，那么该版权所有者的许可将被永久恢复，这是您第一次从该版权所有者那里收到针对任何作品的违反本许可的通知，并且您会在收到通知后的30天内纠正违规行为。
</p>
<p>根据本节终止您的权利并不会终止根据本许可从您那里收到副本或权利的各方的许可。如果您的权利已被终止且未永久恢复，则收到部分或全部相同材料的副本将不会赋予您使用该材料的任何权利。
</p>

<p>10。本许可证的未来修订</p>
<p>自由软件基金会可能会不时发布GNU自由文档许可证的新修订版。这样的新版本将在本质上与当前版本相似，但是可能在细节上有所不同以解决新问题或疑虑。参见http://www.gnu.org/copyleft/。</p>
<p>许可证的每个版本都有一个不同的版本号。如果文档指定适用于此许可证的特定编号版本“或任何更高版本”，则您可以选择遵循该指定版本或已发布的任何更高版本的条款和条件（不作为草稿）由自由软件基金会提供。如果文档未指定此许可的版本号，则可以选择自由软件基金会曾经发布的任何版本（而不是草稿）。如果文档指定代理可以决定可以使用此许可证的将来版本，则该代理对版本的公开接受声明将永久授权您为文档选择该版本。
</p>
<p>11。许可</p>
<p>“大型多作者协作网站”（或“ MMC网站”）是指发布版权作品并为任何人提供编辑这些作品的重要工具的任何万维网服务器。任何人都可以编辑的公共Wiki是此类服务器的示例。网站中包含的“大型多作者合作”（或“ MMC”）是指在MMC网站上发布的任何受版权保护的作品集。
</p>
<p>“ CC-BY-SA”是指Creative Commons Corporation（一家非营利性公司，主要营业地点位于加利福尼亚州旧金山）发行的Creative Commons Attribution-Share Alike 3.0许可证，以及该版本的未来copyleft版本该组织发布的许可。
</p>
<p>“合并”是指作为另一文档的一部分全部或部分发布或重新发布文档。
</p>
<p>如果MMC已根据本许可获得许可，并且所有根据本许可在MMC之外的其他地方首次发行且随后全部或部分合并到MMC中的作品，则该MMC是“有资格获得许可的”，（1）没有封面文字或不变部分，因此（2）在2008年11月1日之前合并。
</p>
<p>MMC站点的运营商可以在2009年8月1日之前的任何时间在CC-BY-SA之下的同一站点上重新发布该站点中包含的MMC，前提是该MMC有资格获得许可。
</p>

<p>附录：如何对您的文档使用此许可证</p>
<p>要在您编写的文档中使用此许可，请在该文档中包括一个许可副本，并在标题页后放置以下版权和许可声明：</p>
<p>版权所有（c）您的姓名。根据GNU自由文档许可版本1.3或自由软件基金会发布的任何更高版本，授予复制，分发和/或修改本文档的权限；没有不变的部分，没有前封面文字，也没有后封面文字。许可证的副本包含在标题为“ GNU自由文档许可证”的部分中。
</p>
<p>如果您有不变部分，前封面文字和后封面文字，则将“替换为...”文本。”与此行：</p>
<p>不变部分为列表标题，前盖文本为列表，后盖文本为列表。</p>
<p>如果您有不带封面文本的不变部分，或这三个部分的其他组合，请合并这两种选择以适应情况。
</p>
<p>如果您的文档包含不平凡的程序代码示例，我们建议您根据自由软件许可（例如GNU通用公共许可）的选择，并行发布这些示例，以允许它们在自由软件中使用。
</p>
<hr>
<a name="Passwords-for-the-answers-to-the-tutorials"></a>
<div class="header">
<p>下一页： <a href="#Index" rel="next" accesskey="n">索引</a> ，上一篇： <a href="#GNU-Free-Documentation-License" rel="prev" accesskey="p">GNU自由文档许可证</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Passwords-for-the-answers-to-the-tutorials-1"></a>
<h2 class="appendix">附录B教程答案的密码</h2>


<p>这是教程的密码，位于以下网站上： <a href="http://davin.50webs.com/J.T.W">http</a> : <a href="http://davin.50webs.com/J.T.W">//davin.50webs.com/JTW</a> 。通过单击文档教程的第3部分答案中的链接可以找到它们。
</p>
<table>
<tbody><tr><td width="10%">没有。</td><td width="50%">密码：</td></tr>
<tr><td width="10%">1个</td><td width="50%">警鱼</td></tr>
<tr><td width="10%">2</td><td width="50%">象棋</td></tr>
<tr><td width="10%">3</td><td width="50%">高笔</td></tr>
<tr><td width="10%">4</td><td width="50%">鲜鲸</td></tr>
<tr><td width="10%">5</td><td width="50%">魔术师</td></tr>
<tr><td width="10%">6</td><td width="50%">金泵</td></tr>
<tr><td width="10%">7</td><td width="50%">湖mar石</td></tr>
<tr><td width="10%">8</td><td width="50%">营养灯</td></tr>
<tr><td width="10%">9</td><td width="50%">Sadbutter</td></tr>
<tr><td width="10%">10</td><td width="50%">清新的</td></tr>
<tr><td width="10%">11</td><td width="50%">五喜pies</td></tr>
<tr><td width="10%">12</td><td width="50%">电话棚</td></tr>
<tr><td width="10%">13</td><td width="50%">甜蜜的</td></tr>
<tr><td width="10%">14</td><td width="50%">夜路</td></tr>
<tr><td width="10%">15</td><td width="50%">黑螺丝</td></tr>
<tr><td width="10%">16</td><td width="50%">雪蛙</td></tr>
<tr><td width="10%">17</td><td width="50%">天花</td></tr>
</tbody></table>



<hr>
<a name="Index"></a>
<div class="header">
<p>上一篇： <a href="#Passwords-for-the-answers-to-the-tutorials" rel="prev" accesskey="p">教程答案的密码</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Index-1"></a>
<h2 class="unnumbered">指数</h2>

<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Index_cp_symbol-1"><b>“</b></a> <a class="summary-letter" href="#Index_cp_symbol-2"><b>〜</b></a>
   
<br>
<a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a> <a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>
<table class="index-cp" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_symbol-1">”</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0060_0060Hello_002c-World_0021_0027_0027">“你好，世界！”</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_symbol-2">〜</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e_002fjtw_002dtutorials">〜/ jtw-tutorials</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-A-common-design-pattern_003a-private-properties_002c-public-constructor-and-public-getters">常见的设计模式：私有属性，公共构造函数和公共获取者</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-A-simple-syntax-for-the-main-function_002e">main函数的简单语法。</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-A-tarball-to-get-you-started">帮助您入门的压缩包</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-About-GNU-Java-Training-Wheels">关于GNU Java Training Wheels</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Accessing-class-variables-and-functions-from-another-class">从另一个类访问类变量和函数</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class">教程8从另一个类访问函数和类变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-and-construct-from-BASIC-and-C_002b_002b-in-J_002eT_002eW_002e">并在JTW中从BASIC和C ++构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays">数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-1">数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-2">数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-non_002dObject-type_002c-first-initialization-syntax">非对象类型的数组，第一个初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-non_002dObject-type_002c-second-initialization-syntax">非对象类型的数组，第二种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-non_002dObject-type_002c-single_002ddimensional">非对象类型的数组，一维的</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-non_002dObject-type_002c-three_002ddimensional">非对象类型的数组，三维</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-non_002dObject-type_002c-two_002ddimensional">非对象类型的数组，二维</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type">对象类型的数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-first-initialization-syntax">对象类型数组，第一个初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-initialization">对象类型的数组，初始化</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-second-initialization-syntax">对象类型数组，第二种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-single_002ddimensional">一维对象类型的数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-three_002ddimensional">三维对象类型数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arrays-of-Object-type_002c-two_002ddimensional">二维对象类型的数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-BASIC-style-and-and-or-constructs-rather-than-Java_0027s-cumbersome-_0026_0026-_007c_007c-constructs_002e">BASIC样式和和或构造而不是Java繁琐的&& ||结构体。</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Beer-drinking-song">啤酒饮歌</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-5-A-beer-drinking-song">指南5喝啤酒的歌</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Building-a-collection-of-classes">建立一个类的集合</a> ：</td><td> </td><td valign="top"><a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个包的集合</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Building-code-that-uses-a-class">使用类的构建代码</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Building-code-that-uses-a-package">使用包的构建代码</a> ：</td><td> </td><td valign="top"><a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个包的集合</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-C_002b_002b-style-and-and-or-constructs-rather-than-Java_0027s-cumbersome-_0026_0026-_007c_007c-constructs_002e">C ++样式和和或构造而不是Java繁琐的&& ||结构体。</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Calling-existing-methods-of-the-String-class">调用String类的现有方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Character_002etoUpperCase">Character.toUpperCase</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chars_002c-introducing">字符，介绍</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Class-variables-from-another-class_002c-accessing">来自另一个类的类变量，访问</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class">教程8从另一个类访问函数和类变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-classVar-construct">classVar构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Collection-of-classes_002c-building">收集课程，建筑物</a> ：</td><td> </td><td valign="top"><a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个包的集合</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Comments-harvested-by-Javadoc">Javadoc收集的评论</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constructor-construct">构造函数</a></td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Converting-from-functions-to-methods-and-vice_002dversa">从函数转换为方法，反之亦然</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Davin-Pearson_0027s-Personal-Website-http_003a_002f_002fdavin_002e50webs_002ecom">戴文·皮尔森（Davin Pearson）的个人网站</a> <a href="http://davin.50webs.com">http://davin.50webs.com</a> ：</td><td> </td><td valign="top"><a href="#J_002eT_002eW_002e-Tutorials">JTW教程</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Davin_0027s-jtw_002dmode_002eel_002c-a-major-mode-for-editing-_002a_002ejtw-files">达文的jtw-mode.el，是编辑* .jtw文件的主要模式</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Davin_0027s-version-of-Emacs-dlisp_002etar_002egz">达文版的Emacs dlisp.tar.gz</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Design-pattern_003a-private-properties_002c-public-constructor-and-public-getters">设计模式：私有财产，公共构造函数和公共获取者</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dlisp_002etar_002egz_002c-Davin_0027s-version-of-GNU-Emacs">dlisp.tar.gz，Davin的GNU Emacs版本</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do-_002e_002e_002e-while-loop">做... while循环</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-4-Four-looping-constructs">教程4四个循环结构</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-elseif-construct-rather-than-else-if">elseif构造，而不是else</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Encapsulation">封装形式</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-File-inclusion-in-J_002eT_002eW_002e">文件包含在JTW中</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-First-initialization-syntax-for-arrays-of-non_002dObject-type">非对象类型的数组的第一种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-First-initialization-syntax-for-arrays-of-Objects">对象数组的第一种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for-loop">for循环</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-4-Four-looping-constructs">教程4四个循环结构</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-construct">函数构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Function-name-overloading">函数名称重载</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Functions-to-methods-and-vice_002dversa">方法的功能，反之亦然</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Functions_002c-parameters-and-arguments">函数，参数和参数</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Getter-and-setter-methods">获取和设置方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hello_002c-World_0021">你好，世界！</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-How-to-access-class-variables-and-functions-from-another-class">如何从另一个类访问类变量和函数</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class">教程8从另一个类访问函数和类变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ignoring-the-return-values-of-functions-and-methods_002e">忽略函数和方法的返回值。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Inheritance">继承</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Inheritance-and-removing-duplication-of-code_002e">继承并删除重复的代码。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-16-More-inheritance">教程16更多继承</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Installing-Davin_0027s-jtw_002dmode">安装Davin的jtw-mode</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Installing-Davin_0027s-version-of-Emacs-dlisp_002etar_002egz">安装达文版的Emacs dlisp.tar.gz</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-instanceof-keyword">instanceof关键字</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Internal-details-of-the-J_002eT_002eW_002e-system">JTW系统的内部细节</a> ：</td><td> </td><td valign="top"><a href="#Mapping-J_002eT_002eW_002e-to-Java">将JTW映射到Java</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-boolean-arrays">布尔数组介绍</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-8-Accessing-functions-and-class-variables-from-another-class">教程8从另一个类访问函数和类变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-chars">字符介绍</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-class-variables">介绍类变量</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-6-Class-variables">教程6类变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-non_002dObject-arrays">引入非对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-single_002ddimensional-non_002dObject-arrays">引入一维非对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-the-superfor-construct">介绍superfor构造</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-the-System_002eout_002eprint-construct">介绍System.out.print构造</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-the-System_002eout_002eprintln-construct">介绍System.out.println构造</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Introducing-while-loops-do-_002e_002e_002e-while-loops">引入while循环做... while循环</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-4-Four-looping-constructs">教程4四个循环结构</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-J">Ĵ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-J_002eT_002eW_002e-_002d_003e-Java-mapping">JTW-> Java映射</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-J_002eT_002eW_002e-internal-details">JTW内部细节</a> ：</td><td> </td><td valign="top"><a href="#Mapping-J_002eT_002eW_002e-to-Java">将JTW映射到Java</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Javadoc_002c-harvesting-of-comments">Javadoc，收集评论</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jtw_002dmode_002eel-Davin_0027s-major-mode-for-editing-_002a_002ejtw-files">jtw-mode.el达文编辑* .jtw文件的主要模式</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linked-lists">链表</a> ：</td><td> </td><td valign="top"><a href="#J_002eT_002eW_002e-Tutorials">JTW教程</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linked-lists-1">链表</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-14-Linked-lists">指南14链接列表</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-main-function_002c-a-simple-syntax-for_002e">主要功能，简单语法。</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-build-X_002erun-to-build-and-run-a-class-file_002e">使build X.run生成并运行一个类文件。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Makefile-for-generating-_002a_002eclass-files-from-_002a_002ejtw-files">用于从* .jtw文件生成* .class文件的Makefile</a> ：</td><td> </td><td valign="top"><a href="#Makefile-for-building-_002a_002ejtw-into-_002a_002ejava-and-running-_002a_002eclass-files">用于将* .jtw构建到* .java并运行* .class文件的Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mapping-from-_002a_002ejtw-_002d_003e-_002a_002ejava">从* .jtw-> * .java映射</a> ：</td><td> </td><td valign="top"><a href="#Mapping-J_002eT_002eW_002e-to-Java">将JTW映射到Java</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mapping-from-class-variables-_002d_003e-instance-variables-_0028also-known-as-properties_0029">从类变量映射->实例变量（也称为属性）</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mapping-from-functions-_002d_003e-methods">从函数映射->方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mapping-from-J_002eT_002eW_002e-_002d_003e-Java">从JTW映射-> Java</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-method-construct">方法构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Methods-to-functions-and-vice_002dversa">功能方法，反之亦然</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Methods_002c-overloading">方法，重载</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-My-first-program">我的第一个程序</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-N">ñ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Non_002dObject-arrays_002c-single_002ddimensional">非对象数组，一维</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Non_002dObject-arrays_002c-two_002ddimensional">非对象数组，二维</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-value-for-references">引用的空值</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NullPointerException">NullPointerException</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Object-arrays">对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Object-arrays_002c-two_002ddimensional">二维对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Object-superclass-of-all-objects">所有对象的对象超类</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-or-construct-from-BASIC-and-C_002b_002b-in-J_002eT_002eW_002e">或在JTW中从BASIC和C ++构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Overloading-methods">重载方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Packages_002c-building">建筑包装</a> ：</td><td> </td><td valign="top"><a href="#How-to-build-a-collection-of-class-files-or-an-entire-package">如何构建类文件或整个包的集合</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Packages_002c-importing">包，进口</a> ：</td><td> </td><td valign="top"><a href="#Importing-a-package">导入包裹</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Packages_002c-moving-a-class-into-a-package">包，将类移到包中</a> ：</td><td> </td><td valign="top"><a href="#Moving-a-class-into-a-package">将类移到包中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pascal_002dstyle-begin-_002e_002e_002e-end-construct-versus-the-C_002dstyle-_007b-_002e_002e_002e-_007d-construct">Pascal风格的begin ... end构造与C风格的{...}构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Piping-the-output-of-javac-and-java">用管道输送javac和java的输出</a> ：</td><td> </td><td valign="top"><a href="#Piping-the-output-of-javac-and-java">用管道输送javac和java的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Polymorphism">多态性</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Polymorphism-versus-run_002dtime-type-inquiry">多态与运行时类型查询</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-private-properties_002c-public-constructor-and-public-getters_002c-a-common-design-pattern">私有财产，公共构造函数和公共吸气剂，一种常见的设计模式</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Problematic-J_002eT_002eW_002e-constructs_002c-trouble_002dshooting">有问题的JTW构造，故障排除</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-property-construct">财产构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Property-swapping">财产交换</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Relationships-between-different-classes_002e">不同阶级之间的关系。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-11-References-to-another-class">教程11对另一个类的引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Return-values">返回值</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Run_002dtime-type-inquiry-versus-Polymorphism">运行时类型查询与多态性</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Second-initialization-syntax-for-arrays-of-non_002dObjects">非对象数组的第二种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Second-initialization-syntax-for-arrays-of-Objects">对象数组的第二种初始化语法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Setter-and-getter-methods">设置和获取方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Setting-up-relationships-between-different-classes_002e">建立不同类之间的关系。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-11-References-to-another-class">教程11对另一个类的引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Single_002ddimensional-arrays-of-Objects">对象的一维数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-superfor-construct_002c-Introducing">superfor构造，介绍</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-superfor-looping-construct">superfor循环构造</a> ：</td><td> </td><td valign="top"><a href="#J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro">JTW概念验证＃1 superfor宏</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-superfor-macro">superfor宏</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Swapping-the-properties-of-two-objects">交换两个对象的属性</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-12-Overloading-methods">教程12重载方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-System_002eout_002eprint-construct_002c-introducing">System.out.print构造，引入</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-System_002eout_002eprintln-construct_002c-introducing">System.out.println构造，引入</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-3-superfor-loops-and-for-loops">教程3 superfor循环和for循环</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-System_002eout_002eprintln_0028_002f_002a-args-_002a_002f_0029_003b">System.out.println（/ *参数* /）;</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-best-of-the-four-looping-constructs-superfor_002c-for_002c-while-and-do-_002e_002e_002e-while">superfor，for，while和do ... while四个循环构造中最好的一个</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-4-Four-looping-constructs">教程4四个循环结构</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-Delphi_002fPascal_002fJavaScript-keyword-var-for-clearer-local-variables">Delphi / Pascal / JavaScript关键字var用于更清晰的局部变量</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-difference-between-_003d_003d-and-_003d">==和=之间的区别</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-Pascal_002fBASIC-keyword-then-for-clearer-if-statements">然后，使用Pascal / BASIC关键字可以使if语句更清晰</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-toString-method-and-its-usefulness-in-debugging_002e">toString方法及其在调试中的实用性。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-The-toString-method_002e">toString方法。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-then-for-clearer-if-statements">然后为了更清晰的if语句</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Three_002ddimensional-arrays-of-Objects">对象的三维数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Three_002ddimensional-non_002dObject-arrays">三维非对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-toLowerCase_0028_0029-of-the-String-class">String类的toLowerCase（）</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-toString-method_002e">toString方法。</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-toUpperCase_0028_0029-of-the-String-class">String类的toUpperCase（）</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-2-Introduction-to-programming-in-Java">教程2 Java编程简介</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trouble_002dshooting-problematic-J_002eT_002eW_002e-constructs">解决有问题的JTW构造</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Two_002ddimensional-arrays-of-Objects">对象的二维数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-10-Object-arrays">教程10对象数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Two_002ddimensional-non_002dObject-arrays">二维非对象数组</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-7-Non_002dObject-arrays">教程7非对象数组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-var-for-clearer-local-variables">var用于更清晰的局部变量</a> ：</td><td> </td><td valign="top"><a href="#About-GNU-Java-Training-Wheels">关于GNU Java培训轮</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-while-loop">while循环</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-4-Four-looping-constructs">教程4四个循环结构</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Why-it-is-better-to-use-polymorphism-rather-than-run_002dtime-type-inquiry">为什么使用多态性比运行时类型查询更好</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Why-the-toString-method-is-better-than-any-other-method-or-property-for-debugging-your-code">为什么toString方法比任何其他调试代码的方法或属性都要好</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Writing-your-own-classes">编写自己的课程</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-15-Introducing-inheritance">教程15继承介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Writing-your-own-classes-1">编写自己的课程</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-17-Arrays-inheritance-and-polymorphism">教程17数组的继承和多态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Writing-your-own-methods">编写自己的方法</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-9-Mapping-class-variables-to-instance-variables-_0028also-known-as-properties_0029-and-functions-to-methods">教程9将类变量映射到实例变量（也称为属性），并将函数映射到方法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Y">ÿ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Yertle-the-Turtle">龟龟</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-14-Linked-lists">指南14链接列表</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Your-first-J_002eT_002eW_002e-program">您的第一个JTW程序</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Your-first-program">您的第一个程序</a> ：</td><td> </td><td valign="top"><a href="#Tutorial-1-Your-first-program">教程1您的第一个程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Index_cp_symbol-1"><b>“</b></a> <a class="summary-letter" href="#Index_cp_symbol-2"><b>〜</b></a>
   
<br>
<a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a> <a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>

<hr>





</body></html>