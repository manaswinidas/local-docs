<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>I / O功能（《 GNU Awk用户指南》）</title>

<meta name="description" content="I/O Functions (The GNU Awk User’s Guide)">
<meta name="keywords" content="I/O Functions (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Built_002din.html#Built_002din" rel="up" title="Built-in">
<link href="Time-Functions.html#Time-Functions" rel="next" title="Time Functions">
<link href="Gory-Details.html#Gory-Details" rel="prev" title="Gory Details">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="I_002fO-Functions"></a>
<div class="header">
<p>下一篇： <a href="Time-Functions.html#Time-Functions" rel="next" accesskey="n">时间函数</a> ，上一篇： <a href="String-Functions.html#String-Functions" rel="prev" accesskey="p">字符串函数</a> ，上一篇： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Input_002fOutput-Functions"></a>
<h4 class="subsection">9.1.4输入/输出功能</h4>
<a name="index-input_002foutput-functions"></a>

<p>以下功能与输入/输出（I / O）有关。可选参数放在方括号（[]）中：</p>
<dl compact>
<dt><code>close(</code><var>filename</var> [ <code>,</code><var>how</var> ]<code>)</code></dt>
<dd><a name="index-close_0028_0029-function-1"></a>
<a name="index-files_002c-closing"></a>
<a name="index-close-file-or-coprocess"></a>
<p>关闭档案<var>filename</var>用于输入或输出。或者，该参数可以是用于创建协过程或用于重定向到管道或从管道重定向的shell命令。然后关闭协同处理或管道。有关更多信息，请参见“ <a href="Close-Files-And-Pipes.html#Close-Files-And-Pipes">关闭输入和输出重定向”</a>部分。
</p>
<p>当关闭协同处理时，偶尔先关闭双向管道的一端然后再关闭另一端很有用。这是通过提供第二个参数来完成的<code>close()</code> 。第二个论点（ <var>how</var> ）应该是两个字符串值之一<code>"to"</code>要么<code>"from"</code> ，指示要关闭管道的哪一端。字符串中的大小写无关紧要。请参阅“ <a href="Two_002dway-I_002fO.html#Two_002dway-I_002fO">与另一个进程进行双向通信”</a>部分，其中更详细地讨论了此功能并给出了示例。
</p>
<p>请注意，第二个参数<code>close()</code>是一个<code>gawk</code>延期;在兼容模式下不可用（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节）。
</p>
</dd>
<dt><code>fflush(</code> [ <var>filename</var> ]<code>)</code></dt>
<dd><a name="index-fflush_0028_0029-function"></a>
<a name="index-flush-buffered-output"></a>
<p>刷新与之关联的所有缓冲输出<var>filename</var> ，它可以是打开的用于写入的文件，也可以是用于将输出重定向到管道或协同进程的shell命令。
</p>
<a name="index-buffers_002c-flushing"></a>
<a name="index-output_002c-buffering"></a>
<p>许多实用程序会<em>缓冲</em>其输出（即，它们保存信息以将其写入磁盘文件或屏幕中，直到有足够的值将其发送到输出设备为止）。这通常比准备好每写入一点点信息更有效。但是，有时有必要强制程序<em>刷新</em>其缓冲区（即，即使缓冲区未满，也将信息写入其目的地）。这是目的<code>fflush()</code>功能- <code>gawk</code>还缓冲其输出，并且<code>fflush()</code>功能力量<code>gawk</code>刷新其缓冲区。
</p>
<a name="index-extensions_002c-common_002c-fflush_0028_0029-function"></a>
<a name="index-Brian-Kernighan_0027s-awk-13"></a>
<p>Brian Kernighan添加了<code>fflush()</code>给他的<code>awk</code>在1992年4月。二十年来，这是一个常见的扩展。在2012年12月，它被接受并包含在POSIX标准中。请参阅<a href="http://austingroupbugs.net/view.php?id=634">Austin Group网站</a> 。
</p>
<p>POSIX标准化<code>fflush()</code>如下所示：如果没有参数，或者参数为空字符串（ <code>""</code> <!-- /@w --> ），然后<code>awk</code>刷新<em>所有</em>打开的输出文件和管道的缓冲区。
</p>
<blockquote>
<p><b>注意：</b>在4.0.2版之前， <code>gawk</code>如果没有参数，则仅刷新标准输出，如果参数为空字符串，则刷新所有输出文件和管道。为了与Brian Kernighan的<code>awk</code> ，希望以后可以更轻松地在POSIX中标准化此功能（事实证明确实如此）。
</p>
<p>用<code>gawk</code> ， 您可以使用 ' <samp>fflush("/dev/stdout")</samp> '如果您只想刷新标准输出。
</p></blockquote>

<a name="index-troubleshooting_002c-fflush_0028_0029-function"></a>
<p><code>fflush()</code>如果成功刷新了缓冲区，则返回零；否则返回0。否则，它返回一个非零值。 （ <code>gawk</code>返回-1。）在刷新所有缓冲区的情况下，仅当成功刷新所有缓冲区时，返回值为零。否则为-1，并且<code>gawk</code>警告该问题<var>filename</var> 。
</p>
<p><code>gawk</code>如果您尝试刷新已打开以供读取的文件或管道（例如，使用<code>getline</code> ）， 或者如果<var>filename</var>不是打开的文件，管道或协同进程。在这种情况下， <code>fflush()</code>也返回-1。
</p>
</dd>
</dl>

<a name="index-sidebar_002c-Interactive-Versus-Noninteractive-Buffering"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<div align="center"><b>交互式与非交互式缓冲</b>
</div>

<a name="index-buffering_002c-interactive-vs_002e-noninteractive"></a>

<p>附带说明一下，如果您的程序是<em>交互式的</em> （即与坐在键盘上的用户进行通信），则缓冲问题可能会更加令人困惑。 <a name="DOCF50" href="#FOOT50"><sup>50</sup></a>
</p>
<p>交互式程序通常对输出进行<em>行缓冲</em> （即，它们写出每一行）。非交互式程序要等到它们具有完整的缓冲区（可能是多行输出）后，再进行操作。这是区别的示例：</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1 + $2 }'</kbd>
<kbd>1 1</kbd>
-| 2
<kbd>2 3</kbd>
-| 5
<kbd>Ctrl-d</kbd>
</pre></div>

<p>输出的每一行都会立即打印。将此行为与以下示例进行比较：</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1 + $2 }' | cat</kbd>
<kbd>1 1</kbd>
<kbd>2 3</kbd>
<kbd>Ctrl-d</kbd>
-| 2
-| 5
</pre></div>

<p>在这里，直到<kbd>Ctrl-d</kbd>输入，因为它全部被缓冲并通过管道发送到<code>cat</code>一枪。
</p></td></tr></tbody></table>

<dl compact>
<dt><code>system(<var>command</var>)</code></dt>
<dd><a name="index-system_0028_0029-function"></a>
<a name="index-invoke-shell-command"></a>
<a name="index-interacting-with-other-programs"></a>
<p>执行操作系统命令<var>command</var>然后返回<code>awk</code>程序。返回<var>command</var>的退出状态（详情请参见）。
</p>
<p>例如，如果将以下代码片段放入您的<code>awk</code>程序：</p>
<div class="example">
<pre class="example">END {
     system(&quot;date | mail -s 'awk run done' root&quot;)
}
</pre></div>

<p>当<code>awk</code>程序完成对输入的处理并开始其输入结束处理。
</p>
<p>请注意，重定向<code>print</code>要么<code>printf</code>放入管道通常足以完成您的任务。如果您需要运行许多命令，则将它们简单地打印到外壳的管道中会更有效：</p>
<div class="example">
<pre class="example">while (<var>more stuff to do</var>)
    print <var>command</var> | &quot;/bin/sh&quot;
close(&quot;/bin/sh&quot;)
</pre></div>

<p><a name="index-troubleshooting_002c-system_0028_0029-function"></a><a name="index-_002d_002dsandbox-option_002c-disabling-system_0028_0029-function"></a>但是，如果您<code>awk</code>程序是交互式的<code>system()</code>对于运行大型独立程序（例如Shell或编辑器）很有用。某些操作系统无法实现<code>system()</code>功能。
<code>system()</code>如果不支持，则会导致致命错误。
</p>
<blockquote>
<p><b>注意：</b>何时<samp>--sandbox</samp>指定， <code>system()</code>功能已禁用（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节）。
</p></blockquote>

<p>在POSIX系统上，命令的退出状态为16位数字。退出值传递给C <code>exit()</code>功能保持在高阶八位。低阶位指示进程是否被信号杀死（位7），如果是，则指示有罪信号号（位0-6）。
</p>
<p>传统上， <code>awk</code>的<code>system()</code>函数仅返回了退出状态值除以256。在正常情况下，这会给出退出状态，但在逐个信号死亡的情况下，会产生分数浮点值。 <a name="DOCF51" href="#FOOT51"><sup>51</sup></a> POSIX指出<code>awk</code>的<code>system()</code>应该返回完整的16位值。
</p>
<p><code>gawk</code>引导中间立场。返回值汇总在<a href="#table_002dsystem_002dreturn_002dvalues">表9.5中</a> 。
</p>
<div class="float"><a name="table_002dsystem_002dreturn_002dvalues"></a>

<table>
<thead><tr><th width="40%">情况</th><th width="60%">从返回值<code>system()</code></th></tr></thead>
<tbody><tr><td width="40%"><samp>--traditional</samp></td><td width="60%">C <code>system()</code>的值除以256</td></tr>
<tr><td width="40%"><samp>--posix</samp></td><td width="60%">C <code>system()</code>的价值</td></tr>
<tr><td width="40%">正常退出命令</td><td width="60%">命令的退出状态</td></tr>
<tr><td width="40%">通过命令信号死亡</td><td width="60%">256 +谋杀信号的数量</td></tr>
<tr><td width="40%">带有核心转储的命令信号导致死亡</td><td width="60%">512 +凶杀信号</td></tr>
<tr><td width="40%">某种错误</td><td width="60%">-1</td></tr>
</tbody></table>
<div class="float-caption"><p><strong>表9.5：</strong>来自的返回值<code>system()</code></p></div></div></dd>
</dl>

<p>截至2018年8月，BWK <code>awk</code>现在跟随<code>gawk</code>的返回值的行为<code>system()</code> 。
</p>
<a name="index-sidebar_002c-Controlling-Output-Buffering-with-system_0028_0029"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<div align="center"><b>通过控制输出缓冲<code>system()</code></b>
</div>

<a name="index-buffers_002c-flushing-1"></a>
<a name="index-buffering_002c-input_002foutput"></a>
<a name="index-output_002c-buffering-1"></a>

<p>的<code>fflush()</code>函数提供对单个文件和管道的输出缓冲的显式控制。但是，它的使用对于许多年长的人来说并不方便<code>awk</code>实现。刷新输出缓冲区的另一种方法是调用<code>system()</code>以空字符串作为参数：</p>
<div class="example">
<pre class="example">system(&quot;&quot;)   # flush output
</pre></div>

<p><code>gawk</code>对待这种使用<code>system()</code>作为一种特殊情况起作用，并且足够聪明，以至于无法使用空命令运行shell（或其他命令解释器）。因此， <code>gawk</code> ，这个习惯用法不仅有用，而且效率很高。尽管此方法应与其他方法一起使用<code>awk</code>的实现，并不一定避免启动不必要的shell。（其他实现可能只刷新与标准输出关联的缓冲区，而不一定刷新所有缓冲的输出。）
</p>
<p>如果您考虑程序员的期望，那很有意义<code>system()</code>应该刷新任何未决的输出。以下程序：</p>
<div class="example">
<pre class="example">BEGIN {
     print &quot;first print&quot;
     system(&quot;echo system echo&quot;)
     print &quot;second print&quot;
}
</pre></div>

<p>必须打印：</p>
<div class="example">
<pre class="example">first print
system echo
second print
</pre></div>

<p>并不是：</p>
<div class="example">
<pre class="example">system echo
first print
second print
</pre></div>

<p>如果<code>awk</code>在调用之前没有刷新其缓冲区<code>system()</code> ，您将看到后一个（不需要的）输出。
</p></td></tr></tbody></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT50" href="#DOCF50">（50）</a></h3>
<p>如果标准输出连接到终端设备，则程序是交互式的。在现代系统上，这意味着您的键盘和屏幕。</p>
<h3><a name="FOOT51" href="#DOCF51">（51）</a></h3>
<p>在私人通信中，克尼根（Kernighan）博士向我指出，这样做的方式可能是一个错误。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="Time-Functions.html#Time-Functions" rel="next" accesskey="n">时间函数</a> ，上一篇： <a href="String-Functions.html#String-Functions" rel="prev" accesskey="p">字符串函数</a> ，上一篇： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>