<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>控制数组遍历（《 GNU Awk用户指南》）</title>

<meta name="description" content="Controlling Array Traversal (The GNU Awk User’s Guide)">
<meta name="keywords" content="Controlling Array Traversal (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Array-Sorting.html#Array-Sorting" rel="up" title="Array Sorting">
<link href="Array-Sorting-Functions.html#Array-Sorting-Functions" rel="next" title="Array Sorting Functions">
<link href="Array-Sorting.html#Array-Sorting" rel="prev" title="Array Sorting">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Controlling-Array-Traversal"></a>
<div class="header">
<p>下一页： <a href="Array-Sorting-Functions.html#Array-Sorting-Functions" rel="next" accesskey="n">数组排序功能</a> ，最多： <a href="Array-Sorting.html#Array-Sorting" rel="up" accesskey="u">数组排序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Controlling-Array-Traversal-1"></a>
<h4 class="subsection">12.2.1控制数组遍历</h4>

<p>默认情况下，“ <samp>for (<var>indx</var> in <var>array</var>)</samp> '循环扫描未定义的数组；它通常基于内部数组的内部实现<code>awk</code> 。
</p>
<p>不过，通常希望能够以程序员（程序员）选择的特定顺序遍历元素。<code>gawk</code>让您做到这一点。
</p>
<p><a href="Controlling-Scanning.html#Controlling-Scanning">将预定义阵列扫描顺序与<code>gawk</code></a>描述了如何将特殊的预定义值分配给<code>PROCINFO["sorted_in"]</code>为了控制顺序<code>gawk</code>在一个数组中遍历数组<code>for</code>环。
</p>
<p>另外，价值<code>PROCINFO["sorted_in"]</code>可以是函数名称。 <a name="DOCF84" href="#FOOT84"><sup>84</sup></a>这使您可以基于任何自定义条件遍历数组。数组元素根据此函数的返回值排序。比较函数应至少定义四个参数：</p>
<div class="example">
<pre class="example">function comp_func(i1, v1, i2, v2)
{
    <var>compare elements 1 and 2 in some fashion</var>
    <var>return &lt; 0; 0; or &gt; 0</var>
}
</pre></div>

<p>这里， <code>i1</code>和<code>i2</code>是索引，并且<code>v1</code>和<code>v2</code>是要比较的两个元素的对应值。要么<code>v1</code>要么<code>v2</code>如果要遍历的数组包含子数组作为值，则或两者都可以是数组。（有关子<a href="Arrays-of-Arrays.html#Arrays-of-Arrays">数组</a>的更多信息，请参见“ <a href="Arrays-of-Arrays.html#Arrays-of-Arrays">数组的数组”</a>一节。）三种可能的返回值解释如下：</p>
<dl compact>
<dt><code>comp_func(i1, v1, i2, v2) < 0</code></dt>
<dd><p>指数<code>i1</code>在索引之前<code>i2</code>在循环遍历期间。
</p>
</dd>
<dt><code>comp_func(i1, v1, i2, v2) == 0</code></dt>
<dd><p>指标<code>i1</code>和<code>i2</code>在一起，但是相对的相对顺序是不确定的。
</p>
</dd>
<dt><code>comp_func(i1, v1, i2, v2) > 0</code></dt>
<dd><p>指数<code>i1</code>在索引之后<code>i2</code>在循环遍历期间。
</p></dd>
</dl>

<p>我们的第一个比较函数可用于按索引的数字顺序扫描数组：</p>
<div class="example">
<pre class="example">function cmp_num_idx(i1, v1, i2, v2)
{
     # numerical index comparison, ascending order
     return (i1 - i2)
}
</pre></div>

<p>我们的第二个函数基于元素值的字符串顺序而不是索引遍历数组：</p>
<div class="example">
<pre class="example">function cmp_str_val(i1, v1, i2, v2)
{
    # string value comparison, ascending order
    v1 = v1 &quot;&quot;
    v2 = v2 &quot;&quot;
    if (v1 &lt; v2)
        return -1
    return (v1 != v2)
}
</pre></div>

<p>第三个比较功能使所有数字以及没有任何前导或尾随空格的数字字符串在循环遍历期间首先出现：</p>
<div class="example">
<pre class="example">function cmp_num_str_val(i1, v1, i2, v2,   n1, n2)
{
     # numbers before string value comparison, ascending order
     n1 = v1 + 0
     n2 = v2 + 0
     if (n1 == v1)
         return (n2 == v2) ? (n1 - n2) : -1
     else if (n2 == v2)
         return 1
     return (v1 &lt; v2) ? -1 : (v1 != v2)
}
</pre></div>

<p>这是一个演示如何<code>gawk</code>使用前面的每个函数的行为：</p>
<div class="example">
<pre class="example">BEGIN {
    data[&quot;one&quot;] = 10
    data[&quot;two&quot;] = 20
    data[10] = &quot;one&quot;
    data[100] = 100
    data[20] = &quot;two&quot;

    f[1] = &quot;cmp_num_idx&quot;
    f[2] = &quot;cmp_str_val&quot;
    f[3] = &quot;cmp_num_str_val&quot;
    for (i = 1; i &lt;= 3; i++) {
        printf(&quot;Sort function: %s\n&quot;, f[i])
        PROCINFO[&quot;sorted_in&quot;] = f[i]
        for (j in data)
            printf(&quot;\tdata[%s] = %s\n&quot;, j, data[j])
        print &quot;&quot;
    }
}
</pre></div>

<p>这是程序运行时的结果：</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f compdemo.awk</kbd>
-| Sort function: cmp_num_idx      <i>Sort by numeric index</i>
-|     data[two] = 20
-|     data[one] = 10              <i>Both strings are numerically zero</i>
-|     data[10] = one
-|     data[20] = two
-|     data[100] = 100
-|
-| Sort function: cmp_str_val      <i>Sort by element values as strings</i>
-|     data[one] = 10
-|     data[100] = 100             <i>String 100 is less than string 20</i>
-|     data[two] = 20
-|     data[10] = one
-|     data[20] = two
-|
-| Sort function: cmp_num_str_val  <i>Sort all numeric values before all strings</i>
-|     data[one] = 10
-|     data[two] = 20
-|     data[100] = 100
-|     data[10] = one
-|     data[20] = two
</pre></div>

<p>考虑根据登录名对GNU / Linux系统密码文件的条目进行排序。以下程序按特定字段位置对记录进行排序，可用于此目的：</p>
<div class="example">
<pre class="example"># passwd-sort.awk --- simple program to sort by field position
# field position is specified by the global variable POS

function cmp_field(i1, v1, i2, v2)
{
    # comparison by value, as string, and ascending order
    return v1[POS] &lt; v2[POS] ? -1 : (v1[POS] != v2[POS])
}

{
    for (i = 1; i &lt;= NF; i++)
        a[NR][i] = $i
}

</pre><pre class="example">END {
    PROCINFO[&quot;sorted_in&quot;] = &quot;cmp_field&quot;
</pre><pre class="example">    if (POS &lt; 1 || POS &gt; NF)
        POS = 1

    for (i in a) {
        for (j = 1; j &lt;= NF; j++)
            printf(&quot;%s%c&quot;, a[i][j], j &lt; NF ? &quot;:&quot; : &quot;&quot;)
        print &quot;&quot;
    }
}
</pre></div>

<p>密码文件每个条目中的第一个字段是用户的登录名，并且各字段之间用冒号分隔。每个记录定义一个子数组，每个字段都作为子数组中的一个元素。运行程序将产生以下输出：</p>
<div class="example">
<pre class="example">$ <kbd>gawk -v POS=1 -F: -f sort.awk /etc/passwd</kbd>
-| adm:x:3:4:adm:/var/adm:/sbin/nologin
-| apache:x:48:48:Apache:/var/www:/sbin/nologin
-| avahi:x:70:70:Avahi daemon:/:/sbin/nologin
&hellip;
</pre></div>

<p>给定一对特定的数组元素作为参数时，比较通常应始终返回相同的值。如果返回不一致的结果，则顺序不确定。可以利用此行为将随机顺序引入其他看似有序的数据中：</p>
<div class="example">
<pre class="example">function cmp_randomize(i1, v1, i2, v2)
{
    # random order (caution: this may never terminate!)
    return (2 - 4 * rand())
}
</pre></div>

<p>如前所述，如果两个元素比较相等，则索引的顺序是任意的。通常这不是问题，但是让绑定的元素以任意顺序出现可能是个问题，尤其是在比较项目值时。如果将其他元素添加到数组中或从数组中删除，则下一次遍历数组时，相等元素的部分排序可能会更改。比较具有其他相等值的元素时解决联系的一种方法是将索引包括在比较规则中。请注意，这样做可能会降低循环遍历的效率，因此仅在必要时考虑它。以下比较函数强制执行确定性顺序，并且基于以下事实：两个元素的（字符串）索引永远不相等：</p>
<div class="example">
<pre class="example">function cmp_numeric(i1, v1, i2, v2)
{
    # numerical value (and index) comparison, descending order
    return (v1 != v2) ? (v2 - v1) : (i2 - i1)
}

</pre><pre class="example">function cmp_string(i1, v1, i2, v2)
{
    # string value (and index) comparison, descending order
    v1 = v1 i1
    v2 = v2 i2
    return (v1 &gt; v2) ? -1 : (v1 != v2)
}
</pre></div>


<p>定制比较功能通常可以简化有序循环遍历，而在设计此类功能时，实际上是有限制的。
</p>
<p>在排序过程中进行字符串比较时，对于其中一个或两个都不是数字的元素值，或者对于作为字符串处理的元素索引， <code>IGNORECASE</code> （请参阅“ <a href="Built_002din-Variables.html#Built_002din-Variables">预定义变量”</a>部分）控制比较是否将对应的大写和小写字母视为等同或不同。
</p>
<p>要记住的另一点是，在子数组的情况下，元素值本身可以是数组。生产比较功能应使用<code>isarray()</code>函数（请参阅“ <a href="Type-Functions.html#Type-Functions">获取类型信息”</a>部分）进行检查，并为子数组选择定义的排序顺序。
</p>
<p>所有排序基于<code>PROCINFO["sorted_in"]</code>在POSIX模式下被禁用，因为<code>PROCINFO</code>在这种情况下，数组并不特殊。
</p>
<p>附带说明一下，据报道在遍历数组之前对数组索引进行排序会增加15％到20％的执行时间， <code>awk</code>程式。由于这个原因，排序数组遍历不是默认的。
</p>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT84" href="#DOCF84">（84）</a></h3>
<p>这就是为什么预定义的排序顺序以“ <samp>@</samp> '字符，不能是标识符的一部分。</p>
</div>
<hr>
<div class="header">
<p>下一页： <a href="Array-Sorting-Functions.html#Array-Sorting-Functions" rel="next" accesskey="n">数组排序功能</a> ，最多： <a href="Array-Sorting.html#Array-Sorting" rel="up" accesskey="u">数组排序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>