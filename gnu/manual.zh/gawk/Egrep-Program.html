<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Egrep程序（《 GNU Awk用户指南》）</title>

<meta name="description" content="Egrep Program (The GNU Awk User’s Guide)">
<meta name="keywords" content="Egrep Program (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Clones.html#Clones" rel="up" title="Clones">
<link href="Id-Program.html#Id-Program" rel="next" title="Id Program">
<link href="Cut-Program.html#Cut-Program" rel="prev" title="Cut Program">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Egrep-Program"></a>
<div class="header">
<p>下一个： <a href="Id-Program.html#Id-Program" rel="next" accesskey="n">Id程序</a> ，上一个： <a href="Cut-Program.html#Cut-Program" rel="prev" accesskey="p">剪切程序</a> ，上一个： <a href="Clones.html#Clones" rel="up" accesskey="u">克隆</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Searching-for-Regular-Expressions-in-Files"></a>
<h4 class="subsection">11.2.2搜索文件中的正则表达式</h4>

<a name="index-regular-expressions_002c-searching-for"></a>
<a name="index-searching_002c-files-for-regular-expressions"></a>
<a name="index-files_002c-searching-for-regular-expressions"></a>
<a name="index-egrep-utility-1"></a>
<p>的<code>egrep</code>实用程序在文件中搜索模式。它使用的正则表达式几乎与<code>awk</code> （请参见<a href="Regexp.html#Regexp">正则表达式</a>部分）。您可以按以下方式调用它：</p>
<div class="display">
<pre class="display"><code>egrep</code> [<var>options</var>] <code>'<var>pattern</var>'</code> <var>files</var> &hellip;
</pre></div>

<p>的<var>pattern</var>是一个正则表达式。在典型用法中，用正则表达式引起来以防止Shell扩展任何特殊字符作为文件名通配符。一般， <code>egrep</code>打印匹配的行。如果在命令行上提供了多个文件名，则在每个输出行之前均会加上文件名和冒号。
</p>
<p>的选项<code>egrep</code>如下面所述：</p>
<dl compact>
<dt><code>-c</code></dt>
<dd><p>打印出与模式匹配的行数，而不是行本身。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>安静。没有产生任何输出，出口值指示图案是否匹配。
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>颠倒测试意识。 <code>egrep</code>打印与模式<em>不</em>匹配的行，如果模式不匹配，则成功退出。
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>忽略模式和输入数据中的大小写区别。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>仅打印（列出）匹配文件的名称，而不打印匹配的行。
</p>
</dd>
<dt><code>-e <var>pattern</var></code></dt>
<dd><p>使用<var>pattern</var>作为要匹配的正则表达式。目的<samp>-e</samp>选项是允许以“ <samp>-</samp> '。
</p></dd>
</dl>

<p>此版本使用<code>getopt()</code>库函数（请参阅“ <a href="Getopt-Function.html#Getopt-Function">处理命令行选项”一节</a> ）和文件转换库程序（请参见“ <a href="Filetrans-Function.html#Filetrans-Function">注意数据文件边界”</a>一节）。
</p>
<p>该程序以描述性注释开头，然后是<code>BEGIN</code>用来处理命令行参数的规则<code>getopt()</code> 。的<samp>-i</samp> （忽略大小写）选项特别容易<code>gawk</code> ;我们只是使用<code>IGNORECASE</code>预定义变量（请参阅<a href="Built_002din-Variables.html#Built_002din-Variables">预定义变量</a>部分）：</p>
<a name="index-egrep_002eawk-program"></a>
<div class="example">
<pre class="example"># egrep.awk --- simulate egrep in awk
#
# Options:
#    -c    count of lines
#    -s    silent - use exit value
#    -v    invert test, success if no match
#    -i    ignore case
#    -l    print filenames only
#    -e    argument is pattern
#
# Requires getopt and file transition library functions

BEGIN {
    while ((c = getopt(ARGC, ARGV, &quot;ce:svil&quot;)) != -1) {
        if (c == &quot;c&quot;)
            count_only++
        else if (c == &quot;s&quot;)
            no_print++
        else if (c == &quot;v&quot;)
            invert++
        else if (c == &quot;i&quot;)
            IGNORECASE = 1
        else if (c == &quot;l&quot;)
            filenames_only++
        else if (c == &quot;e&quot;)
            pattern = Optarg
        else
            usage()
    }
</pre></div>

<p>接下来是处理<code>egrep</code>特定的行为。如果没有提供图案<samp>-e</samp> ，使用命令行上的第一个非选项。的<code>awk</code>命令行参数<code>ARGV[Optind]</code>被清除，以便<code>awk</code>不会尝试将它们处理为文件。如果未指定文件，则使用标准输入，如果指定了多个文件，则请确保注意这一点，以便文件名可以在输出中的匹配行之前：</p>
<div class="example">
<pre class="example">    if (pattern == &quot;&quot;)
        pattern = ARGV[Optind++]

    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;
    if (Optind &gt;= ARGC) {
        ARGV[1] = &quot;-&quot;
        ARGC = 2
    } else if (ARGC - Optind &gt; 1)
        do_filenames++

#    if (IGNORECASE)
#        pattern = tolower(pattern)
}
</pre></div>

<p>最后两行已被注释掉，因为在<code>gawk</code> 。如果您必须使用其他版本的，请不要添加注释<code>awk</code> 。
</p>
<p>如果您不使用下一行，则应取消注释<code>gawk</code> 。如果输入法中的所有字符都转换为小写，则此规则<samp>-i</samp>指定了选项。 <a name="DOCF75" href="#FOOT75"><sup>75</sup></a>该规则已被注释掉，因为不需要<code>gawk</code> ：</p>
<div class="example">
<pre class="example">#{
#    if (IGNORECASE)
#        $0 = tolower($0)
#}
</pre></div>

<p>的<code>beginfile()</code>函数由规则在<samp>ftrans.awk</samp>处理每个新文件时。在这种情况下，这非常简单；它所做的就是初始化一个变量<code>fcount</code>归零。 <code>fcount</code>跟踪当前文件中与模式匹配的行数。命名参数<code>junk</code>表明我们知道<code>beginfile()</code>是通过参数调用的，但我们对其值不感兴趣：</p>
<div class="example">
<pre class="example">function beginfile(junk)
{
    fcount = 0
}
</pre></div>

<p>的<code>endfile()</code>处理完每个文件后，将调用函数。仅当用户想要计数匹配的行数时，它才会影响输出。 <code>no_print</code>仅在需要退出状态时为true。
<code>count_only</code>如果需要行数，则为true。<code>egrep</code>因此，仅在启用打印和计数的情况下才打印行数。必须根据要处理的文件数来调整输出格式。最后， <code>fcount</code>被添加到<code>total</code> ，这样我们就知道与模式匹配的总行数：</p>
<div class="example">
<pre class="example">function endfile(file)
{
    if (! no_print &amp;&amp; count_only) {
        if (do_filenames)
            print file &quot;:&quot; fcount
        else
            print fcount
    }

</pre><pre class="example">    total += fcount
}
</pre></div>

<p>的<code>BEGINFILE</code>和<code>ENDFILE</code>特殊模式（见<a href="BEGINFILE_002fENDFILE.html#BEGINFILE_002fENDFILE">的<code>BEGINFILE</code>和<code>ENDFILE</code></a>可以使用<a href="BEGINFILE_002fENDFILE.html#BEGINFILE_002fENDFILE">特殊模式</a> ），但是程序将是<code>gawk</code> -具体。此外，此示例之前<code>gawk</code>获得的<code>BEGINFILE</code>和<code>ENDFILE</code> 。
</p>
<p>以下规则完成了匹配行的大部分工作。变量<code>matches</code>如果线与模式匹配，则为true。如果用户想要的行不匹配，则感觉<code>matches</code>使用' <samp>!</samp> '运算符。 <code>fcount</code>用的值递增<code>matches</code> ，可以是一，也可以是零，具体取决于匹配成功与否。如果行不匹配，则<code>next</code>语句仅移至下一条记录。
</p>
<p>进行了许多其他测试，但是只有在我们不计算行数的情况下，它们才会完成。首先，如果用户只希望退出状态（ <code>no_print</code>是真实的），那么它足以知道，在这个文件<em>中</em>的一行匹配，我们可以跳过到下一个文件<code>nextfile</code> 。同样，如果仅打印文件名，则可以打印文件名，然后使用以下命令跳到下一个文件<code>nextfile</code> 。最后，每行都会打印出来，并带有前导文件名和冒号（如有必要）：</p>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021-operator-3"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021-operator-2"></a>
<div class="example">
<pre class="example">{
    matches = ($0 ~ pattern)
    if (invert)
        matches = ! matches

    fcount += matches    # 1 or 0

    if (! matches)
        next

    if (! count_only) {
        if (no_print)
            nextfile

        if (filenames_only) {
            print FILENAME
            nextfile
        }

        if (do_filenames)
            print FILENAME &quot;:&quot; $0
        else
            print
    }
}
</pre></div>

<p>的<code>END</code>规则负责产生正确的退出状态。如果没有匹配项，则退出状态为1；否则，退出状态为1。否则为零：</p>
<div class="example">
<pre class="example">END {
    exit (total == 0)
}
</pre></div>

<p>的<code>usage()</code>如果选项无效，函数将打印用法消息，然后退出：</p>
<div class="example">
<pre class="example">function usage()
{
    print(&quot;Usage: egrep [-csvil] [-e pat] [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    print(&quot;\n\tegrep [-csvil] pat [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>


<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT75" href="#DOCF75">（75）</a></h3>
<p>它还引入了一个细微的错误；如果发生匹配，我们将输出翻译后的行，而不是原始行。</p>
</div>
<hr>
<div class="header">
<p>下一个： <a href="Id-Program.html#Id-Program" rel="next" accesskey="n">Id程序</a> ，上一个： <a href="Cut-Program.html#Cut-Program" rel="prev" accesskey="p">剪切程序</a> ，上一个： <a href="Clones.html#Clones" rel="up" accesskey="u">克隆</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>