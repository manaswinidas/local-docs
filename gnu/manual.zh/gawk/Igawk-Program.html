<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Igawk程序（《 GNU Awk用户指南》）</title>

<meta name="description" content="Igawk Program (The GNU Awk User’s Guide)">
<meta name="keywords" content="Igawk Program (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Miscellaneous-Programs.html#Miscellaneous-Programs" rel="up" title="Miscellaneous Programs">
<link href="Anagram-Program.html#Anagram-Program" rel="next" title="Anagram Program">
<link href="Simple-Sed.html#Simple-Sed" rel="prev" title="Simple Sed">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Igawk-Program"></a>
<div class="header">
<p>下一篇： <a href="Anagram-Program.html#Anagram-Program" rel="next" accesskey="n">Anagram程序</a> ，上一篇： <a href="Simple-Sed.html#Simple-Sed" rel="prev" accesskey="p">Simple Sed</a> ，上一篇： <a href="Miscellaneous-Programs.html#Miscellaneous-Programs" rel="up" accesskey="u">其他程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="An-Easy-Way-to-Use-Library-Functions"></a>
<h4 class="subsection">11.3.9使用库函数的简便方法</h4>

<a name="index-libraries-of-awk-functions_002c-example-program-for-using"></a>
<a name="index-functions_002c-library_002c-example-program-for-using"></a>
<p>在将<a href="Include-Files.html#Include-Files">其他文件包含到您的程序中</a> ，我们看到了<code>gawk</code>提供内置的文件包含功能。但是，这是一个<code>gawk</code>延期。本节提供了使文件包含可用于标准的动机<code>awk</code> ，并展示了如何结合使用shell和<code>awk</code>编程。
</p>
<p>在中使用库函数<code>awk</code>可能非常有益。它鼓励代码重用和编写通用功能。程序较小，因此更清晰。但是，仅在编写时使用库函数很容易<code>awk</code>程式;运行它们时很痛苦，需要多个<samp>-f</samp>选项。如果<code>gawk</code>是不可用的，那么<code>AWKPATH</code>环境变量和放置的能力<code>awk</code>函数进入库目录（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节）。能够以以下方式编写程序会很好：</p>
<div class="example">
<pre class="example"># library functions
@include getopt.awk
@include join.awk
&hellip;

# main program
BEGIN {
    while ((c = getopt(ARGC, ARGV, &quot;a:b:cde&quot;)) != -1)
        &hellip;
    &hellip;
}
</pre></div>

<p>以下程序， <samp>igawk.sh</samp> ，提供此服务。它模拟<code>gawk</code>正在搜寻<code>AWKPATH</code>变量，并且还允许<em>嵌套</em>包含（例如， <code>@include</code>可以包含更多<code>@include</code>声明）。
<code>igawk</code>尽力只包含一次文件，以便嵌套包含不会意外地两次包含一个库函数。
</p>
<p><code>igawk</code>应该表现得像<code>gawk</code>在外部。这意味着它应该接受所有<code>gawk</code>的命令行参数，包括具有通过来指定多个源文件的功能<samp>-f</samp>以及混合命令行和库源文件的功能。
</p>
<p>该程序是使用POSIX Shell（ <code>sh</code> ）命令语言。 <a name="DOCF80" href="#FOOT80"><sup>80</sup></a>它的工作原理如下：</p>
<ol>
<li>循环遍历参数，保存不代表任何内容的内容<code>awk</code>以后运行扩展程序时的源代码。

</li><li>对于任何表示的参数<code>awk</code>文本，将参数放入将被扩展的shell变量中。有两种情况：<ol type="a" start="1">
<li>文字文字，随附<samp>-e</samp>要么<samp>--source</samp> 。该文本仅直接附加。

</li><li>源文件名，随附<samp>-f</samp> 。我们使用整洁的技巧并附加' <samp>@include <var>filename</var></samp> '到shell变量的内容。因为文件包含程序的工作方式<code>gawk</code>这样做，将在正确的位置获取程序中包含的文件的文本。
</li></ol>

</li><li>运行<code>awk</code>对shell变量的内容进行自然编程以扩展<code>@include</code>陈述。扩展程序放置在第二个shell变量中。

</li><li>使用以下命令运行扩展程序<code>gawk</code>以及用户提供的任何其他原始命令行参数（例如数据文件名）。
</li></ol>

<p>该程序广泛使用shell变量：用于存储命令行参数和<code>awk</code>用于扩展用户程序，用户原始程序和扩展程序的程序。这样做消除了一些潜在的问题，如果我们改为使用临时文件，则可能会增加脚本的复杂性。
</p>
<p>如果第一个参数是''，程序的初始部分将打开shell跟踪。 <samp>debug</samp> '。
</p>
<p>下一部分循环遍历所有命令行参数。有几种有趣的情况：</p>
<dl compact>
<dt><samp>--</samp></dt>
<dd><p>这样就结束了<code>igawk</code> 。其他任何内容都应传递给用户的<code>awk</code>程序而未进行评估。
</p>
</dd>
<dt><samp>-W</samp></dt>
<dd><p>这表明下一个选项特定于<code>gawk</code> 。为了简化参数处理， <samp>-W</samp>被添加到其余参数的最前面，循环继续进行。（这是一<code>sh</code>编程技巧。如果您不熟悉，不必担心<code>sh</code> ）
</p>
</dd>
<dt><samp>-v</samp> ，<samp>-F</samp></dt>
<dd><p>这些已保存并传递给<code>gawk</code> 。
</p>
</dd>
<dt><samp>-f</samp> ， <samp>--file</samp> ， <samp>--file=</samp> ，<samp>-Wfile=</samp></dt>
<dd><p>文件名被追加到shell变量<code>program</code>带着<code>@include</code>声明。的<code>expr</code>实用程序用于删除参数的前导选项部分（例如，“ <samp>--file=</samp> '）。（典型<code>sh</code>用法是使用<code>echo</code>和<code>sed</code>实用程序来完成这项工作。不幸的是，某些版本的<code>echo</code>计算其参数中的转义序列，可能会破坏程序文本。使用<code>expr</code>避免了这个问题。）
</p>
</dd>
<dt><samp>--source</samp> ， <samp>--source=</samp> ，<samp>-Wsource=</samp></dt>
<dd><p>源文本被附加到<code>program</code> 。
</p>
</dd>
<dt><samp>--version</samp> ，<samp>-Wversion</samp></dt>
<dd><p><code>igawk</code>打印其版本号，运行' <samp>gawk --version</samp> '得到<code>gawk</code>版本信息，然后退出。
</p></dd>
</dl>

<p>如果没有<samp>-f</samp> ， <samp>--file</samp> ， <samp>-Wfile</samp> ， <samp>--source</samp> ， 要么<samp>-Wsource</samp>提供了参数，则第一个非选项参数应为<code>awk</code>程序。如果没有命令行参数， <code>igawk</code>显示错误消息并退出。否则，第一个参数将附加到<code>program</code> 。无论如何，在处理完参数后，shell变量<code>program</code>包含原始内容的全文<code>awk</code>程序。
</p>
<p>该程序如下：</p>
<a name="index-igawk_002esh-program"></a>
<div class="example">
<pre class="example">#! /bin/sh
# igawk --- like gawk but do @include processing

if [ &quot;$1&quot; = debug ]
then
    set -x
    shift
fi

# A literal newline, so that program text is formatted correctly
n='
'

# Initialize variables to empty
program=
opts=

while [ $# -ne 0 ] # loop over arguments
do
    case $1 in
    --)     shift
            break ;;

    -W)     shift
            # The ${x?'message here'} construct prints a
            # diagnostic if $x is the null string
            set -- -W&quot;${@?'missing operand'}&quot;
            continue ;;

    -[vF])  opts=&quot;$opts $1 '${2?'missing operand'}'&quot;
            shift ;;

    -[vF]*) opts=&quot;$opts '$1'&quot; ;;

    -f)     program=&quot;$program$n@include ${2?'missing operand'}&quot;
            shift ;;

    -f*)    f=$(expr &quot;$1&quot; : '-f\(.*\)')
            program=&quot;$program$n@include $f&quot; ;;

    -[W-]file=*)
            f=$(expr &quot;$1&quot; : '-.file=\(.*\)')
            program=&quot;$program$n@include $f&quot; ;;

    -[W-]file)
            program=&quot;$program$n@include ${2?'missing operand'}&quot;
            shift ;;

    -[W-]source=*)
            t=$(expr &quot;$1&quot; : '-.source=\(.*\)')
            program=&quot;$program$n$t&quot; ;;

    -[W-]source)
            program=&quot;$program$n${2?'missing operand'}&quot;
            shift ;;

    -[W-]version)
            echo igawk: version 3.0 1&gt;&amp;2
            gawk --version
            exit 0 ;;

    -[W-]*) opts=&quot;$opts '$1'&quot; ;;

    *)      break ;;
    esac
    shift
done

if [ -z &quot;$program&quot; ]
then
     program=${1?'missing program'}
     shift
fi

# At this point, `program' has the program.
</pre></div>

<p>的<code>awk</code>程序处理<code>@include</code>指令存储在shell变量中<code>expand_prog</code> 。这样做可以使Shell脚本保持可读性。的<code>awk</code>程序使用以下命令一次读取一行用户的程序<code>getline</code> （请参阅<a href="Getline.html#Getline">使用<code>getline</code></a> ）。输入文件名和<code>@include</code>语句使用堆栈进行管理。作为每个<code>@include</code>遇到时，将当前文件名“推送”到堆栈上，并将文件名命名为<code>@include</code>指令成为当前文件名。完成每个文件后，将“弹出”堆栈，并且先前的输入文件将再次成为当前输入文件。通过使原始文件成为堆栈中的第一个文件来开始该过程。
</p>
<p>的<code>pathto()</code>函数执行查找文件的完整路径的工作。它模拟<code>gawk</code>搜索时的行为<code>AWKPATH</code>环境变量（见节<a href="AWKPATH-Variable.html#AWKPATH-Variable">的<code>AWKPATH</code>环境变量</a> ）。如果文件名带有“ <samp>/</samp> '，其中不进行路径搜索。同样，如果文件名是<code>"-"</code> ，则该字符串按原样使用。否则，文件名将与路径中每个目录的名称连接在一起，并尝试打开生成的文件名。测试文件是否可以读入的唯一方法<code>awk</code>是继续尝试阅读<code>getline</code> ;这是什么<code>pathto()</code>做。 <a name="DOCF81" href="#FOOT81"><sup>81</sup></a>如果可以读取文件，则将其关闭并返回文件名：</p>

<div class="example">
<pre class="example">expand_prog='

function pathto(file,    i, t, junk)
{
    if (index(file, &quot;/&quot;) != 0)
        return file

    if (file == &quot;-&quot;)
        return file

    for (i = 1; i &lt;= ndirs; i++) {
        t = (pathlist[i] &quot;/&quot; file)
</pre><pre class="example">        if ((getline junk &lt; t) &gt; 0) {
            # found it
            close(t)
            return t
        }
</pre><pre class="example">    }
    return &quot;&quot;
}
</pre></div>

<p>主程序包含在一个<code>BEGIN</code>规则。首先要做的是<code>pathlist</code>数组<code>pathto()</code>用途。在“ <samp>:</samp> '，将null元素替换为<code>"."</code> ，代表当前目录：</p>
<div class="example">
<pre class="example">BEGIN {
    path = ENVIRON[&quot;AWKPATH&quot;]
    ndirs = split(path, pathlist, &quot;:&quot;)
    for (i = 1; i &lt;= ndirs; i++) {
        if (pathlist[i] == &quot;&quot;)
            pathlist[i] = &quot;.&quot;
    }
</pre></div>

<p>堆栈初始化为<code>ARGV[1]</code> ，这将是<code>"/dev/stdin"</code> 。接下来是主循环。输入行是连续读取的。不以开头的行<code>@include</code>逐字印刷。如果该行确实以<code>@include</code> ，文件名在<code>$2</code> 。
<code>pathto()</code>被称为生成完整路径。如果不能，则程序将显示错误消息并继续。
</p>
<p>接下来要检查的是文件是否已包含在内。的<code>processed</code>数组由每个包含的文件的完整文件名索引，并为我们跟踪此信息。如果再次看到该文件，则会打印警告消息。否则，新文件名将被压入堆栈并继续处理。
</p>
<p>最后，当<code>getline</code>遇到输入文件的末尾，文件被关闭，堆栈被弹出。什么时候<code>stackptr</code>小于零，程序完成：</p>
<div class="example">
<pre class="example">    stackptr = 0
    input[stackptr] = ARGV[1] # ARGV[1] is first file

    for (; stackptr &gt;= 0; stackptr--) {
        while ((getline &lt; input[stackptr]) &gt; 0) {
            if (tolower($1) != &quot;@include&quot;) {
                print
                continue
            }
            fpath = pathto($2)
            if (fpath == &quot;&quot;) {
                printf(&quot;igawk: %s:%d: cannot find %s\n&quot;,
                    input[stackptr], FNR, $2) &gt; &quot;/dev/stderr&quot;
                continue
            }
            if (! (fpath in processed)) {
                processed[fpath] = input[stackptr]
                input[++stackptr] = fpath  # push onto stack
            } else
                print $2, &quot;included in&quot;, input[stackptr],
                    &quot;already included in&quot;,
                    processed[fpath] &gt; &quot;/dev/stderr&quot;
        }
        close(input[stackptr])
    }
}'  # close quote ends `expand_prog' variable

processed_program=$(gawk -- &quot;$expand_prog&quot; /dev/stdin &lt;&lt; EOF
$program
EOF
)
</pre></div>

<p>壳结构' <samp><var>command</var> << <var>marker</var></samp>称为<em>此处文档</em> 。Shell脚本中的所有内容，直至<var>marker</var>被喂给<var>command</var>作为输入。Shell处理here文档的内容以进行变量和命令替换（可能还有其他操作，具体取决于Shell）。
</p>
<p>壳结构' <samp>$(…)</samp> '称为<em>命令替换</em> 。括号内的命令输出将替换为命令行。由于结果用于变量分配中，因此即使结果包含空格也将其保存为单个字符串。
</p>
<p>展开的程序保存在变量中<code>processed_program</code> 。通过以下步骤完成：</p>
<ol>
<li>跑<code>gawk</code>与<code>@include</code> -处理程序（ <code>expand_prog</code> shell变量）读取标准输入。

</li><li>标准输入是来自shell变量的用户程序的内容<code>program</code> 。将其内容提供给<code>gawk</code>通过here文档。

</li><li>将此处理的结果保存在shell变量中<code>processed_program</code>通过使用命令替换。
</li></ol>

<p>最后一步是打电话<code>gawk</code>与扩展程序一起，以及用户提供的原始选项和命令行参数：</p>
<div class="example">
<pre class="example">eval gawk $opts -- '&quot;$processed_program&quot;' '&quot;$@&quot;'
</pre></div>

<p>的<code>eval</code> command是一个shell构造，可重新运行shell的解析过程。这样可以正确引用内容。
</p>
<p>这个版本的<code>igawk</code>表示该程序的第五个版本。有四个主要的简化可以使程序更好地工作：</p>
<ul>
<li>使用<code>@include</code>即使对于以命名的文件<samp>-f</samp>使建筑初步收集<code>awk</code>程序简单得多；所有的<code>@include</code>处理一次即可完成。

</li><li>不尝试保存读取的行<code>getline</code>在里面<code>pathto()</code>测试文件的可访问性以与主程序一起使用时，该函数可以大大简化操作。

</li><li>用一个<code>getline</code>循环<code>BEGIN</code>规则将所有事情都集中在一处。不必调出单独的循环来处理嵌套<code>@include</code>陈述。

</li><li>与其将展开的程序保存在临时文件中，不如将其放入外壳程序变量中可以避免某些潜在的安全问题。这样做的缺点是脚本依赖于脚本的更多功能。 <code>sh</code>语言，让那些不熟悉的人难以接受<code>sh</code> 。
</li></ul>

<p>另外，该程序说明通常值得结合<code>sh</code>和<code>awk</code>一起编程。通常，您可以完成很多工作，而不必求助于C或C ++的低级编程，并且使用shell进行某些类型的字符串和参数操作通常比在shell中更容易。 <code>awk</code> 。
</p>
<p>最后， <code>igawk</code>表明并非总是需要向程序中添加新功能；它们通常可以放在顶部。 <a name="DOCF82" href="#FOOT82"><sup>82</sup></a>
</p>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT80" href="#DOCF80">（80）</a></h3>
<p>充分说明<code>sh</code>语言超出了本书的范围。我们只提供一些基本的解释，但是如果您想更深入地了解这些内容，请参阅一本不错的Shell编程书。</p>
<h3><a name="FOOT81" href="#DOCF81">（81）</a></h3>
<p>在某些非常旧的版本中<code>awk</code> ， 考试 ' <samp>getline junk < t</samp>如果文件存在但为空，则可以永久循环。</p>
<h3><a name="FOOT82" href="#DOCF82">（82）</a></h3>
<p><code>gawk</code>确实<code>@include</code>处理自身以支持使用<code>awk</code>程序作为Web CGI脚本。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="Anagram-Program.html#Anagram-Program" rel="next" accesskey="n">Anagram程序</a> ，上一篇： <a href="Simple-Sed.html#Simple-Sed" rel="prev" accesskey="p">Simple Sed</a> ，上一篇： <a href="Miscellaneous-Programs.html#Miscellaneous-Programs" rel="up" accesskey="u">其他程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>