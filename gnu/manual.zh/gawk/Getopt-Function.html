<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Getopt函数（《 GNU Awk用户指南》）</title>

<meta name="description" content="Getopt Function (The GNU Awk User’s Guide)">
<meta name="keywords" content="Getopt Function (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Library-Functions.html#Library-Functions" rel="up" title="Library Functions">
<link href="Passwd-Functions.html#Passwd-Functions" rel="next" title="Passwd Functions">
<link href="Ignoring-Assigns.html#Ignoring-Assigns" rel="prev" title="Ignoring Assigns">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Getopt-Function"></a>
<div class="header">
<p>下一篇： <a href="Passwd-Functions.html#Passwd-Functions" rel="next" accesskey="n">Passwd函数</a> ，上一篇： <a href="Data-File-Management.html#Data-File-Management" rel="prev" accesskey="p">数据文件管理</a> ，上一篇： <a href="Library-Functions.html#Library-Functions" rel="up" accesskey="u">库函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Processing-Command_002dLine-Options"></a>
<h3 class="section">10.4处理命令行选项</h3>

<a name="index-libraries-of-awk-functions_002c-command_002dline-options"></a>
<a name="index-functions_002c-library_002c-command_002dline-options"></a>
<a name="index-command_002dline-options_002c-processing"></a>
<a name="index-options_002c-command_002dline_002c-processing"></a>
<a name="index-functions_002c-library_002c-C-library"></a>
<a name="index-arguments_002c-processing"></a>
<p>兼容POSIX的系统上的大多数实用程序都在命令行中使用选项，这些选项可用于更改程序的行为方式。
<code>awk</code>是此类程序的示例（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节）。选项通常带有<em>参数</em> （即程序需要正确服从命令行选项的数据）。例如， <code>awk</code>的<samp>-F</samp>选项需要使用字符串作为字段分隔符。在任一命令行上的第一次出现<samp>--</samp>或不以'开头的字符串<samp>-</samp> '结束选项。
</p>
<a name="index-getopt_0028_0029-function-_0028C-library_0029"></a>
<p>现代的Unix系统提供了一个名为<code>getopt()</code>用于处理命令行参数。程序员提供描述一个字母选项的字符串。如果选项需要参数，则在字符串后跟一个冒号。 <code>getopt()</code>还传递命令行参数的计数和值，并在循环中调用。
<code>getopt()</code>处理选项字母的命令行参数。每次循环时，它都会返回一个字符，表示找到的下一个选项字母，即' <samp>?</samp> '，如果发现无效的选项。当它返回-1时，命令行上没有剩余的选项。
</p>
<p>使用时<code>getopt()</code> ，不带参数的选项可以组合在一起。此外，带有参数的选项要求该参数存在。该参数可以紧随选项字母之后，也可以是单独的命令行参数。
</p>
<p>给定一个假设的程序，它需要三个命令行选项， <samp>-a</samp> ， <samp>-b</samp>和<samp>-c</samp> ，在哪里<samp>-b</samp>需要一个参数，以下所有都是调用程序的有效方法：</p>
<div class="example">
<pre class="example">prog -a -b foo -c data1 data2 data3
prog -ac -bfoo -- data1 data2 data3
prog -acbfoo data1 data2 data3
</pre></div>

<p>请注意，当参数与其选项组合在一起时，参数的其余部分将被视为选项的参数。在这个例子中<samp>-acbfoo</samp>表示所有<samp>-a</samp> ， <samp>-b</samp>和<samp>-c</samp>提供了选项，并且<samp>foo</samp> '是<samp>-b</samp>选项。
</p>
<p><code>getopt()</code>提供了四个可供程序员使用的外部变量：</p>
<dl compact>
<dt><code>optind</code></dt>
<dd><p>参数值数组中的索引（ <code>argv</code> ），可以找到第一个非选项命令行参数。
</p>
</dd>
<dt><code>optarg</code></dt>
<dd><p>选项参数的字符串值。
</p>
</dd>
<dt><code>opterr</code></dt>
<dd><p>通常<code>getopt()</code>发现无效选项时显示错误消息。设置<code>opterr</code>设置为零将禁用此功能。（应用程序可能要打印自己的错误消息。）
</p>
</dd>
<dt><code>optopt</code></dt>
<dd><p>代表命令行选项的字母。
</p></dd>
</dl>

<p>以下C片段显示了<code>getopt()</code>可能会处理以下命令行参数<code>awk</code> ：</p>
<div class="example">
<pre class="example">int
main(int argc, char *argv[])
{
    &hellip;
    /* print our own message */
    opterr = 0;
    while ((c = getopt(argc, argv, &quot;v:f:F:W:&quot;)) != -1) {
        switch (c) {
        case 'f':    /* file */
            &hellip;
            break;
        case 'F':    /* field separator */
            &hellip;
            break;
        case 'v':    /* variable assignment */
            &hellip;
            break;
        case 'W':    /* extension */
            &hellip;
            break;
        case '?':
        default:
            usage();
            break;
        }
    }
    &hellip;
}
</pre></div>

<p>附带一点， <code>gawk</code>实际使用GNU <code>getopt_long()</code>函数可同时处理普通和GNU样式的长选项（请参阅“ <a href="Options.html#Options">命令行选项”部分</a> ）。
</p>
<p>提供的抽象<code>getopt()</code>非常有用，非常方便<code>awk</code>程序。以下是一个<code>awk</code>版本<code>getopt()</code> 。此功能突出了以下方面的最大弱点之一<code>awk</code> ，这是因为它在处理单个字符方面非常差。反复打给<code>substr()</code>是访问单个字符所必需的（请参阅“ <a href="String-Functions.html#String-Functions">字符串操作函数”部分</a> ）。 <a name="DOCF72" href="#FOOT72"><sup>72</sup></a>
</p>
<p>接下来的讨论一次遍历代码：</p>
<a name="index-getopt_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># getopt.awk --- Do C library getopt(3) function in awk

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    &quot;?&quot;    for unrecognized option
#    &lt;c&gt;    a character representing the current option

# Private Data:
#    _opti  -- index in multiflag option, e.g., -abc
</pre></div>

<p>该函数从注释开始，该注释显示了它使用的全局变量，返回值是什么，它们的含义以及此库函数“私有”的任何全局变量的列表。对于任何程序，尤其是库功能，此类文档都是必不可少的。
</p>
<p>的<code>getopt()</code>函数首先检查它是否确实由一串选项调用（ <code>options</code>参数）。如果<code>options</code>长度为零<code>getopt()</code>立即返回-1：</p>
<a name="index-getopt_0028_0029-user_002ddefined-function-1"></a>
<div class="example">
<pre class="example">function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1

</pre><pre class="example">    if (argv[Optind] == &quot;--&quot;) {  # all done
        Optind++
        _opti = 0
        return -1
</pre><pre class="example">    } else if (argv[Optind] !~ /^-[^:[:space:]]/) {
        _opti = 0
        return -1
    }
</pre></div>

<p>接下来要检查的是选项的结尾。一种<samp>--</samp>结束命令行选项，以及所有不以'开头的命令行参数<samp>-</samp> '。 <code>Optind</code>用于单步执行命令行参数数组；它在致电期间保持其价值<code>getopt()</code> ，因为它是一个全局变量。
</p>
<p>使用的正则表达式， <code><span class="nolinebreak">/^-[^:[:space:]/</span>
<!-- /@w --></code> ，检查“ <samp>-</samp>后面跟着不是空格也不是冒号的任何内容。如果当前命令行参数与该模式不匹配，则它不是选项，并且结束选项处理。继续：</p>
<div class="example">
<pre class="example">    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf(&quot;%c -- invalid option\n&quot;, thisopt) &gt; &quot;/dev/stderr&quot;
        if (_opti &gt;= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return &quot;?&quot;
    }
</pre></div>

<p>的<code>_opti</code>变量跟踪当前命令行参数中的位置（ <code>argv[Optind]</code> ）。如果将多个选项与一个' <samp>-</samp> '（例如， <samp>-abx</samp> ），则必须一次将它们退还给用户。
</p>
<p>如果<code>_opti</code>等于零，将其设置为2，即下一个要查看的字符的字符串索引（我们跳过“ <samp>-</samp> '，位于第一个位置）。变量<code>thisopt</code>拥有通过<code>substr()</code> 。它保存在<code>Optopt</code>供主程序使用。
</p>
<p>如果<code>thisopt</code>不在<code>options</code>字符串，则它是无效的选项。如果<code>Opterr</code>不为零， <code>getopt()</code>在标准错误上显示一条错误消息，类似于来自C版本的错误消息<code>getopt()</code> 。
</p>
<p>由于该选项无效，因此有必要跳过该选项并转到下一个选项字符。如果<code>_opti</code>大于或等于当前命令行参数的长度，有必要继续执行下一个参数，因此<code>Optind</code>增加并<code>_opti</code>重置为零。除此以外， <code>Optind</code>独自一人<code>_opti</code>仅增加。
</p>
<p>无论如何，由于该选项无效， <code>getopt()</code>退货<code>"?"</code> 。主程序可以检查<code>Optopt</code>是否需要知道无效的选择信的真实含义。继续：</p>
<div class="example">
<pre class="example">    if (substr(options, i + 1, 1) == &quot;:&quot;) {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) &gt; 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = &quot;&quot;
</pre></div>

<p>如果选项需要一个参数，则选项字母后面应加一个冒号。 <code>options</code>串。如果当前命令行参数中剩余字符（ <code>argv[Optind]</code> ），然后将该字符串的其余部分分配给<code>Optarg</code> 。否则，使用下一个命令行参数（' <samp>-xFOO</samp> ' 与 ' <samp><span class="nolinebreak">-x</span> FOO
<!-- /@w --></samp> '）。在任一情况下， <code>_opti</code>重置为零，因为在当前的命令行参数中没有更多的字符需要检查。继续：</p>
<div class="example">
<pre class="example">    if (_opti == 0 || _opti &gt;= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}
</pre></div>

<p>最后，如果<code>_opti</code>为零或大于当前命令行参数的长度，这意味着该元素在<code>argv</code>是通过处理，所以<code>Optind</code>递增以指向中的下一个元素<code>argv</code> 。如果两个条件都不成立，则仅<code>_opti</code>递增，以便下次调用时可以处理下一个选项字母<code>getopt()</code> 。
</p>
<p>的<code>BEGIN</code>规则同时初始化<code>Opterr</code>和<code>Optind</code>到一个。
<code>Opterr</code>设置为1，因为默认行为是<code>getopt()</code>在看到无效的选项时打印诊断消息。<code>Optind</code>设置为1，因为没有理由查看程序名称，该名称位于<code>ARGV[0]</code> ：</p>
<div class="example">
<pre class="example">BEGIN {
    Opterr = 1    # default is to diagnose
    Optind = 1    # skip ARGV[0]

    # test program
    if (_getopt_test) {
        while ((_go_c = getopt(ARGC, ARGV, &quot;ab:cd&quot;)) != -1)
            printf(&quot;c = &lt;%c&gt;, Optarg = &lt;%s&gt;\n&quot;,
                                       _go_c, Optarg)
        printf(&quot;non-option arguments:\n&quot;)
        for (; Optind &lt; ARGC; Optind++)
            printf(&quot;\tARGV[%d] = &lt;%s&gt;\n&quot;,
                                    Optind, ARGV[Optind])
    }
}
</pre></div>

<p>剩下的<code>BEGIN</code>规则是一个简单的测试程序。这是测试程序的两次示例运行的结果：</p>
<div class="example">
<pre class="example">$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
-| c = &lt;c&gt;, Optarg = &lt;&gt;
-| c = &lt;b&gt;, Optarg = &lt;ARG&gt;
-| non-option arguments:
-|         ARGV[3] = &lt;bax&gt;
-|         ARGV[4] = &lt;-x&gt;

$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
error&rarr; x -- invalid option
-| c = &lt;?&gt;, Optarg = &lt;&gt;
-| non-option arguments:
-|         ARGV[4] = &lt;xyz&gt;
-|         ARGV[5] = &lt;abc&gt;
</pre></div>

<p>在两次运行中，第一次<samp>--</samp>终止以下参数<code>awk</code> ，这样它就不会尝试解释<samp>-a</samp>等等，作为自己的选择。
</p>
<blockquote>
<p><b>注意：</b>之后<code>getopt()</code>通过，用户级代码必须清除所有元素<code>ARGV</code>从1到<code>Optind</code> ， 以便<code>awk</code>不会尝试将命令行选项作为文件名处理。
</p></blockquote>

<p>使用“ <samp>#!</samp>与<samp>-E</samp>选项可能有助于避免程序的选项和<code>gawk</code>的选项，如<samp>-E</samp>原因<code>gawk</code>放弃其他选项的处理（请参阅“ <a href="Executable-Scripts.html#Executable-Scripts">可执行文件”</a>部分） <a href="Executable-Scripts.html#Executable-Scripts"><code>awk</code>程序</a> ，请参阅“ <a href="Options.html#Options">命令行选项”部分</a> ）。
</p>
<p><a href="Sample-Programs.html#Sample-Programs">实用</a>程序中提供了一些示例程序<a href="Sample-Programs.html#Sample-Programs"><code>awk</code>程序</a>使用<code>getopt()</code>处理他们的论点。
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT72" href="#DOCF72">（72）</a></h3>
<p>该函数之前写过<code>gawk</code>获得使用以下命令将字符串拆分为单个字符的功能<code>""</code>作为分隔符。我们已将其保留为<code>substr()</code>更便携。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="Passwd-Functions.html#Passwd-Functions" rel="next" accesskey="n">Passwd函数</a> ，上一篇： <a href="Data-File-Management.html#Data-File-Management" rel="prev" accesskey="p">数据文件管理</a> ，上一篇： <a href="Library-Functions.html#Library-Functions" rel="up" accesskey="u">库函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>