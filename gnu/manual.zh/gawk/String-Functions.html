<html ><head></head><body lang="zh-Hans" >﻿<!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>字符串函数（《 GNU Awk用户指南》）</title>

<meta name="description" content="String Functions (The GNU Awk User’s Guide)">
<meta name="keywords" content="String Functions (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Built_002din.html#Built_002din" rel="up" title="Built-in">
<link href="Gory-Details.html#Gory-Details" rel="next" title="Gory Details">
<link href="Numeric-Functions.html#Numeric-Functions" rel="prev" title="Numeric Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">





<a name="String-Functions"></a>
<div class="header">
<p>下一篇： <a href="I_002fO-Functions.html#I_002fO-Functions" rel="next" accesskey="n">I / O函数</a> ，上一篇： <a href="Numeric-Functions.html#Numeric-Functions" rel="prev" accesskey="p">数值函数</a> ，上一篇： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="String_002dManipulation-Functions"></a>
<h4 class="subsection">9.1.3字符串操作函数</h4>
<a name="index-string_002dmanipulation-functions"></a>

<p>本节中的功能查看或更改一个或多个字符串的文本。
</p>
<p><code>gawk</code>理解语言环境（请参见“ <a href="Locales.html#Locales">在哪里有所作为”一</a>节），并用<em>字符</em>而非<em>字节进行</em>所有字符串处理。对于一个字符可能由多个字节表示的语言环境，这一区别特别重要。因此，例如<code>length()</code>返回字符串中的字符数，而不是用于表示这些字符的字节数。同样， <code>index()</code>适用于字符索引，而不适用于字节索引。
</p>
<blockquote>
<p><b>注意：</b>许多函数将索引处理为字符串。对于这些功能，字符串的第一个字符位于位置（索引）一个。这不同于C及其衍生的语言，在C语言中第一个字符位于零位置。在进行索引计算时，需要记住这一点，特别是如果您习惯使用C。</p></blockquote>

<p>在下面的列表中，可选参数括在方括号（[]）中。<!-- /@w -->一些函数执行字符串替换；有关完整的讨论，请参见<code>sub()</code>功能，因为列表是按字母顺序显示的。
</p>
<p>那些特定于<code>gawk</code>都用英镑符号（' <samp>#</samp> '）。它们在兼容模式下不可用（请参阅“ <a href="Options.html#Options">命令行选项”部分</a> ）：</p>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="Gory-Details.html#Gory-Details" accesskey="1">血腥细节</a> ：</td><td>  </td><td align="left" valign="top">关于“您想了解的更多信息<samp>\</samp> '和' <samp>&</samp>与<code>sub()</code> ， <code>gsub()</code>和<code>gensub()</code> 。
</td></tr>
</tbody></table>

<dl compact>
<dt><code>asort(</code><var>source</var> [ <code>,</code><var>dest</var> [ <code>,</code><var>how</var> ]<code>) #</code></dt>
<dt><code>asorti(</code><var>source</var> [ <code>,</code><var>dest</var> [ <code>,</code><var>how</var> ]<code>) #</code></dt>
<dd><a name="index-asorti_0028_0029-function-_0028gawk_0029"></a>
<a name="index-sort-array"></a>
<a name="index-arrays_002c-elements_002c-retrieving-number-of"></a>
<a name="index-asort_0028_0029-function-_0028gawk_0029"></a>
<a name="index-sort-array-indices"></a>
<p>这两个功能在行为上相似，因此一起进行描述。
</p>
<blockquote>
<p><b>注意：</b>以下描述将忽略第三个参数， <var>how</var> ，因为它需要了解我们尚未讨论的功能。因此，这里的讨论是有意的简化。（我们稍后会提供所有详细信息；请参阅使用以下内容<a href="Array-Sorting-Functions.html#Array-Sorting-Functions">对数组值和索引进行排序： <code>gawk</code></a>有关完整的故事。）
</p></blockquote>

<p>这两个函数都返回数组中的元素数<var>source</var> 。对于<code>asort()</code> ， <code>gawk</code>排序的值<var>source</var>并替换的排序值的索引<var>source</var>以1开头的连续整数。如果是可选数组<var>dest</var>指定，然后<var>source</var>复制到<var>dest</var> 。<var>dest</var>然后排序，留下索引<var>source</var>不变。
</p>
<a name="index-gawk_002c-IGNORECASE-variable-in-3"></a>
<p>比较字符串时<code>IGNORECASE</code>影响排序（请参见“使用以下命令<a href="Array-Sorting-Functions.html#Array-Sorting-Functions">对数组值和索引进行排序” <code>gawk</code></a> ）。如果<var>source</var> array包含子数组作为值（请参见<a href="Arrays-of-Arrays.html#Arrays-of-Arrays">Arrays of Arrays</a>部分），在所有标量值之后，它们将排在最后。子数组<em>不是</em>递归排序的。
</p>
<p>例如，如果内容<code>a</code>如下面所述：</p>
<div class="example">
<pre class="example">a[&quot;last&quot;] = &quot;de&quot;
a[&quot;first&quot;] = &quot;sac&quot;
a[&quot;middle&quot;] = &quot;cul&quot;
</pre></div>

<p>致电<code>asort()</code> ：</p>
<div class="example">
<pre class="example">asort(a)
</pre></div>

<p>导致以下内容<code>a</code> ：</p>
<div class="example">
<pre class="example">a[1] = &quot;cul&quot;
a[2] = &quot;de&quot;
a[3] = &quot;sac&quot;
</pre></div>

<p>的<code>asorti()</code>功能类似于<code>asort()</code> ;但是， <em>索引</em>是排序的，而不是值。因此，在前面的示例中，从相同的索引和值初始集合开始<code>a</code> ，称为“ <samp>asorti(a)</samp> '将产生：</p>
<div class="example">
<pre class="example">a[1] = &quot;first&quot;
a[2] = &quot;last&quot;
a[3] = &quot;middle&quot;
</pre></div>

</dd>
<dt><code>gensub(<var>regexp</var>, <var>replacement</var>, <var>how</var></code> [ <code>, <var>target</var></code> ]<code>) #</code></dt>
<dd><a name="index-gensub_0028_0029-function-_0028gawk_0029-1"></a>
<a name="index-search-and-replace-in-strings"></a>
<a name="index-substitute-in-string"></a>
<p>搜索目标字符串<var>target</var>用于正则表达式的匹配<var>regexp</var> 。如果<var>how</var>是以'开头的字符串<samp>g</samp> ' 要么 ' <samp>G</samp> '（“全局”的缩写），然后替换的所有匹配项<var>regexp</var>与<var>replacement</var> 。否则请<var>how</var>作为表示哪个匹配项的数字<var>regexp</var>取代。将小于1的数值视为1。如果不<var>target</var>提供，使用<code>$0</code> 。返回修改后的字符串作为函数的结果。原始目标字符串<em>未</em>更改。
</p>
<p><code>gensub()</code>是通用替换函数。其目的是提供比标准更多的功能<code>sub()</code>和<code>gsub()</code>功能。
</p>
<p><code>gensub()</code>提供了其他功能所不具备的功能<code>sub()</code>要么<code>gsub()</code> ：能够在替换文本中指定正则表达式的组件。这是通过在正则表达式中使用括号标记组件，然后指定“ <samp>\<var>N</var></samp>在替换文字中， <var>N</var>是1到9之间的数字。例如：</p>
<div class="example">
<pre class="example">$ <kbd>gawk '</kbd>
&gt; <kbd>BEGIN {</kbd>
&gt;      <kbd>a = &quot;abc def&quot;</kbd>
&gt;      <kbd>b = gensub(/(.+) (.+)/, &quot;\\2 \\1&quot;, &quot;g&quot;, a)</kbd>
&gt;      <kbd>print b</kbd>
&gt; <kbd>}'</kbd>
-| def abc
</pre></div>

<p>与<code>sub()</code> ，您必须键入两个反斜杠才能将其添加到字符串中。在替换文字中，序列“ <samp>\0</samp> '代表整个匹配的文本，字符' <samp>&</samp> '。
</p>
<p>下面的示例说明如何使用第三个参数来控制应更改哪个regexp匹配项：</p>
<div class="example">
<pre class="example">$ <kbd>echo a b c a b c |</kbd>
&gt; <kbd>gawk '{ print gensub(/a/, &quot;AA&quot;, 2) }'</kbd>
-| a b c AA b c
</pre></div>

<p>在这种情况下， <code>$0</code>是默认的目标字符串。
<code>gensub()</code>返回新字符串作为其结果，并将其直接传递给<code>print</code>用于打印。
</p>
<p>如果<var>how</var>参数是不以'开头的字符串<samp>g</samp> ' 要么 ' <samp>G</samp> '，或者如果该数字小于或等于零，则仅执行一次替换。如果<var>how</var>是零<code>gawk</code>发出警告消息。
</p>
<p>如果<var>regexp</var>不匹配<var>target</var> ， <code>gensub()</code>的返回值是的原始不变值<var>target</var> 。
</p>
</dd>
<dt><code>gsub(<var>regexp</var>, <var>replacement</var></code> [ <code>, <var>target</var></code> ]<code>)</code></dt>
<dd><a name="index-gsub_0028_0029-function-1"></a>
<p>搜索<var>target</var>对于<em>所有</em>最长，最左边， <em>不重叠的</em>匹配子字符串，它可以找到并替换为<var>replacement</var> 。' <samp>g</samp>在<code>gsub()</code>代表“全球”，这意味着到处替换。例如：</p>
<div class="example">
<pre class="example">{ gsub(/Britain/, &quot;United Kingdom&quot;); print }
</pre></div>

<p>替换所有出现的字符串' <samp>Britain</samp>与“ <samp>United Kingdom</samp> '用于所有输入记录。
</p>
<p>的<code>gsub()</code>函数返回进行的替换次数。如果要搜索和更改的变量（ <var>target</var> ）省略，则整个输入记录（ <code>$0</code> ） 用来。如<code>sub()</code> ， 那些角色 ' <samp>&</samp> '和' <samp>\</samp> '是特殊的，第三个参数必须是可分配的。
</p>
</dd>
<dt><code>index(<var>in</var>, <var>find</var>)</code></dt>
<dd><a name="index-index_0028_0029-function"></a>
<a name="index-search-in-string"></a>
<a name="index-find-substring-in-string"></a>
<p>搜索字符串<var>in</var>对于字符串的第一次出现<var>find</var> ，并以字符开头的位置返回字符串中出现的位置<var>in</var> 。考虑以下示例：</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print index(&quot;peanut&quot;, &quot;an&quot;) }'</kbd>
-| 3
</pre></div>

<p>如果<var>find</var>找不到， <code>index()</code>返回零。
</p>
<a name="index-dark-corner_002c-regexp-as-second-argument-to-index_0028_0029"></a>
<p>与BWK <code>awk</code>和<code>gawk</code> ，使用regexp常量是一个致命错误<var>find</var> 。其他实现允许，只需将regexp常量视为表示“ <samp>$0 ~ /regexp/</samp> '。 （直流）
</p>
</dd>
<dt><code>length(</code> [ <var>string</var> ]<code>)</code></dt>
<dd><a name="index-length_0028_0029-function"></a>
<a name="index-string-length"></a>
<a name="index-length-of-string"></a>
<p>返回中的字符数<var>string</var> 。如果<var>string</var>是数字，则返回表示该数字的数字字符串的长度。例如， <code>length("abcde")</code>是五。相比之下， <code>length(15 * 35)</code>算出三。在此示例中，15 * 35 = 525，然后将525转换为字符串<code>"525"</code> ，其中包含三个字符。
</p>
<a name="index-length-of-input-record"></a>
<a name="index-input-record_002c-length-of"></a>
<p>如果未提供任何参数， <code>length()</code>返回的长度<code>$0</code> 。
</p>
<a name="index-portability_002c-length_0028_0029-function"></a>
<a name="index-POSIX-awk_002c-functions-and_002c-length_0028_0029"></a>
<blockquote>
<p><b>注意：</b>在旧版本中<code>awk</code> ， <code>length()</code>可以在没有任何括号的情况下调用该函数。尽管2008 POSIX标准明确允许这样做，但它被认为是不良做法，以支持历史做法。为了使程序具有最大的可移植性，请始终提供括号。
</p></blockquote>

<a name="index-dark-corner_002c-length_0028_0029-function"></a>
<p>如果<code>length()</code>用尚未使用的变量调用<code>gawk</code>强制变量为标量。其他实现<code>awk</code>保留变量没有类型。（直流）考虑：</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print length(x) ; x[1] = 1 }'</kbd>
-| 0
error&rarr; gawk: fatal: attempt to use scalar `x' as array

$ <kbd>nawk 'BEGIN { print length(x) ; x[1] = 1 }'</kbd>
-| 0
</pre></div>

<p>如果<samp>--lint</samp>已在命令行中指定， <code>gawk</code>对此发出警告。
</p>
<a name="index-common-extensions_002c-length_0028_0029-applied-to-an-array"></a>
<a name="index-extensions_002c-common_002c-length_0028_0029-applied-to-an-array"></a>
<a name="index-differences-in-awk-and-gawk_002c-length_0028_0029-function"></a>
<a name="index-number-of-array-elements"></a>
<a name="index-array_002c-number-of-elements"></a>
<p>用<code>gawk</code>和其他几个<code>awk</code>实现，当给定数组参数时， <code>length()</code>函数返回数组中元素的数量。 （ce）这比起初看起来没有用，因为不能保证将数组从一个索引到其中的元素数。如果<samp>--lint</samp>在命令行上提供（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节）， <code>gawk</code>警告传递数组参数是不可移植的。如果<samp>--posix</samp>是供给，使用数组参数是一个致命的错误（见<a href="Arrays.html#Arrays">阵列在<code>awk</code></a> ）。
</p>
</dd>
<dt><code>match(<var>string</var>, <var>regexp</var></code> [ <code>, <var>array</var></code> ]<code>)</code></dt>
<dd><a name="index-match_0028_0029-function"></a>
<a name="index-string_002c-regular-expression-match"></a>
<a name="index-match-regexp-in-string"></a>
<p>搜索<var>string</var>对于正则表达式匹配的最长，最左边的子字符串<var>regexp</var>并返回该子字符串开始的字符位置（索引）（如果从<var>string</var> ）。如果找不到匹配项，则返回零。
</p>
<p>的<var>regexp</var>参数可以是regexp常量（ <code>/</code> … <code>/</code> ）或字符串常量（ <code>"</code> … <code>"</code> ）。在后一种情况下，该字符串被视为要匹配的正则表达式。有关两种形式之间的差异以及正确编写程序的含义的讨论，请参阅“ <a href="Computed-Regexps.html#Computed-Regexps">使用动态正则表达式”</a>部分。
</p>
<p>前两个参数的顺序与使用正则表达式的大多数其他字符串函数相反，例如<code>sub()</code>和<code>gsub()</code> 。记住这一点可能会有所帮助<code>match()</code> ，顺序与“ <samp>~</samp>运算符： <samp><var>string</var> ~ <var>regexp</var></samp> '。
</p>
<a name="index-RSTART-variable_002c-match_0028_0029-function-and"></a>
<a name="index-RLENGTH-variable_002c-match_0028_0029-function-and"></a>
<a name="index-match_0028_0029-function_002c-RSTART_002fRLENGTH-variables"></a>
<p>的<code>match()</code>函数设置预定义变量<code>RSTART</code>索引。它还设置了预定义变量<code>RLENGTH</code>到匹配的子字符串的字符长度。如果找不到匹配项， <code>RSTART</code>设置为零，并且<code>RLENGTH</code>至-1。
</p>
<p>例如：</p>
<div class="example">
<pre class="example">{
    if ($1 == &quot;FIND&quot;)
        regex = $2
    else {
        where = match($0, regex)
        if (where != 0)
            print &quot;Match of&quot;, regex, &quot;found at&quot;, where, &quot;in&quot;, $0
       }
}
</pre></div>

<p>该程序查找与存储在变量中的正则表达式匹配的行<code>regex</code> 。此正则表达式可以更改。如果一行中的第一个单词是“ <samp>FIND</samp> '， <code>regex</code>更改为该行的第二个单词。因此，如果给出：</p>
<div class="example">
<pre class="example">FIND ru+n
My program runs
but not very quickly
FIND Melvin
JF+KM
This line is property of Reality Engineering Co.
Melvin was here.
</pre></div>

<p><code>awk</code>印刷品：</p>
<div class="example">
<pre class="example">Match of ru+n found at 12 in My program runs
Match of Melvin found at 1 in Melvin was here.
</pre></div>

<a name="index-differences-in-awk-and-gawk_002c-match_0028_0029-function"></a>
<p>如果<var>array</var>存在，将其清除，然后将<var>array</var>设置为<var>string</var>被匹配<var>regexp</var> 。如果<var>regexp</var>包含括号，即整数索引元素<var>array</var>设置为包含<var>string</var>匹配相应的带括号的子表达式。例如：</p>
<div class="example">
<pre class="example">$ <kbd>echo foooobazbarrrrr |</kbd>
&gt; <kbd>gawk '{ match($0, /(fo+).+(bar*)/, arr)</kbd>
&gt;         <kbd>print arr[1], arr[2] }'</kbd>
-| foooo barrrrr
</pre></div>

<p>此外，还提供了多维下标，提供了每个匹配子表达式的起始索引和长度：</p>
<div class="example">
<pre class="example">$ <kbd>echo foooobazbarrrrr |</kbd>
&gt; <kbd>gawk '{ match($0, /(fo+).+(bar*)/, arr)</kbd>
&gt;           <kbd>print arr[1], arr[2]</kbd>
&gt;           <kbd>print arr[1, &quot;start&quot;], arr[1, &quot;length&quot;]</kbd>
&gt;           <kbd>print arr[2, &quot;start&quot;], arr[2, &quot;length&quot;]</kbd>
&gt; <kbd>}'</kbd>
-| foooo barrrrr
-| 1 5
-| 9 7
</pre></div>

<p>可能没有每个带括号的子表达式的下标和下标，因为它们不一定都具有匹配的文本。因此，应使用<code>in</code>运算符（请参阅<a href="Reference-to-Elements.html#Reference-to-Elements">参考数组元素一节</a> ）。
</p>
<a name="index-troubleshooting_002c-match_0028_0029-function"></a>
<p>的<var>array</var>争论<code>match()</code>是一个<code>gawk</code>延期。在兼容模式下（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节），使用第三个参数是一个致命错误。
</p>
</dd>
<dt><code>patsplit(<var>string</var>, <var>array</var></code> [ <code>, <var>fieldpat</var></code> [ <code>, <var>seps</var></code> ]<code>) #</code></dt>
<dd><a name="index-patsplit_0028_0029-function-_0028gawk_0029"></a>
<a name="index-split-string-into-array"></a>
<p>划分<var>string</var>分为以下部分<var>fieldpat</var>并将它们存储在<var>array</var>和中的分隔符字符串<var>seps</var>数组。第一块存放在<code><var>array</var>[1]</code> ，第二个<code><var>array</var>[2]</code>等等。第三个论点， <var>fieldpat</var> ，是一个正则表达式，描述了<var>string</var> （就像<code>FPAT</code>是一个正则表达式，用于描述输入记录中的字段。它可以是正则表达式常量或字符串。如果<var>fieldpat</var>省略，值<code>FPAT</code>用来。
<code>patsplit()</code>返回创建的元素数。
<code><var>seps</var>[<var>i</var>]</code>是后面的可能为空的分隔符字符串<code><var>array</var>[<var>i</var>]</code> 。可能为空的前导分隔符将位于<code><var>seps</var>[0]</code> 。所以非空<var>string</var>与<var>n</var>领域将有<var>n+1</var>分隔符。空值<var>string</var>将既没有字段也没有分隔符。
</p>
<p>的<code>patsplit()</code>函数以类似于使用以下方式将输入行拆分为字段的方式将字符串拆分为段<code>FPAT</code> （请参阅<a href="Splitting-By-Content.html#Splitting-By-Content">“按内容定义字段”</a>部分）。
</p>
<p>在分割字符串之前， <code>patsplit()</code>删除数组中任何先前存在的元素<var>array</var>和<var>seps</var> 。
</p>
</dd>
<dt><code>split(<var>string</var>, <var>array</var></code> [ <code>, <var>fieldsep</var></code> [ <code>, <var>seps</var></code> ]<code>)</code></dt>
<dd><a name="index-split_0028_0029-function"></a>
<p>划分<var>string</var>分成几部分<var>fieldsep</var>并将它们存储在<var>array</var>和中的分隔符字符串<var>seps</var>数组。第一块存放在<code><var>array</var>[1]</code> ，第二个<code><var>array</var>[2]</code>等等。第三个参数的字符串值， <var>fieldsep</var> ，是描述要在哪里拆分的正则表达式<var>string</var> （一样多<code>FS</code>可以是一个正则表达式，用于描述在哪里拆分输入记录。如果<var>fieldsep</var>省略，值<code>FS</code>用来。
<code>split()</code>返回创建的元素数。
<var>seps</var>是一个<code>gawk</code>扩展名<code><var>seps</var>[<var>i</var>]</code>是之间的分隔符<code><var>array</var>[<var>i</var>]</code>和<code><var>array</var>[<var>i</var>+1]</code> 。如果<var>fieldsep</var>是一个空格，那么任何前导空格都会进入<code><var>seps</var>[0]</code>并且任何尾随空格都进入<code><var>seps</var>[<var>n</var>]</code> ，在哪里<var>n</var>是的返回值<code>split()</code> （即， <var>array</var> ）。
</p>
<p>的<code>split()</code>函数以将输入行拆分为字段的相同方式将字符串拆分为多个部分。例如：</p>
<div class="example">
<pre class="example">split(&quot;cul-de-sac&quot;, a, &quot;-&quot;, seps)
</pre></div>

<p><a name="index-strings-splitting_002c-example"></a>分割字符串<code>"cul-de-sac"</code>使用'分为三个字段<samp>-</samp> '作为分隔符。它设置数组的内容<code>a</code>如下：</p>
<div class="example">
<pre class="example">a[1] = &quot;cul&quot;
a[2] = &quot;de&quot;
a[3] = &quot;sac&quot;
</pre></div>

<p>并设置数组的内容<code>seps</code>如下：</p>
<div class="example">
<pre class="example">seps[1] = &quot;-&quot;
seps[2] = &quot;-&quot;
</pre></div>

<p>此调用返回的值<code>split()</code>是三。
</p>
<a name="index-differences-in-awk-and-gawk_002c-split_0028_0029-function"></a>
<p>与输入字段拆分一样，当<var>fieldsep</var>是<code>" "</code> <!-- /@w --> ，在分配给的元素的值中忽略前导和尾随空格<var>array</var>但不在<var>seps</var> ，并且元素之间用空格隔开。另外，与输入字段拆分一样，如果<var>fieldsep</var>是空字符串，该字符串中的每个单个字符都被拆分成自己的数组元素。（ce）此外，如果<var>fieldsep</var>是一个单字符字符串，即使该字符串的值是一个正则表达式元字符，该字符串也充当分隔符。
</p>
<p>但是请注意， <code>RS</code>对方式没有影响<code>split()</code>作品。即使 ' <samp>RS = ""</samp> '使换行符也成为输入字段分隔符，这不会影响<code>split()</code>分割字符串。
</p>
<a name="index-dark-corner_002c-split_0028_0029-function"></a>
<p>的现代实现<code>awk</code> ， 包含<code>gawk</code> ，允许第三个参数为regexp常量（ <code>/</code> … <code>/</code> <!-- /@w --> ）以及字符串。 （直流）POSIX标准也允许这样做。有关<a href="Computed-Regexps.html#Computed-Regexps">使用</a>字符串常量或regexp常量之间的区别以及正确编写程序的含义的讨论，请参阅“ <a href="Computed-Regexps.html#Computed-Regexps">使用动态Regexps”</a>部分。
</p>
<p>在分割字符串之前， <code>split()</code>删除数组中任何先前存在的元素<var>array</var>和<var>seps</var> 。
</p>
<p>如果<var>string</var>为null，该数组没有元素。（因此，这是一种使用一条语句删除整个数组的可移植方法。见节<a href="Delete.html#Delete">的<code>delete</code>声明</a> 。）
</p>
<p>如果<var>string</var>不匹配<var>fieldsep</var>根本（但不为null）， <var>array</var>仅具有一个元素。该元素的值是原始值<var>string</var> 。
</p>
<p>在POSIX模式下（请参阅“ <a href="Options.html#Options">命令行选项”</a>一节），不允许使用第四个参数。
</p>
</dd>
<dt><code>sprintf(<var>format</var>, <var>expression1</var>, …)</code></dt>
<dd><a name="index-sprintf_0028_0029-function-1"></a>
<a name="index-formatting-strings"></a>
<p>返回（不打印）的字符串<code>printf</code>会以相同的参数打印出来（请参阅<a href="Printf.html#Printf">使用<code>printf</code>特殊印刷声明</a> ）。例如：</p>
<div class="example">
<pre class="example">pival = sprintf(&quot;pi = %.2f (approx.)&quot;, 22/7)
</pre></div>

<p>分配字符串' <samp>pi = 3.14 (approx.)</samp> ' <!-- /@w -->到变量<code>pival</code> 。
</p>
<a name="index-strtonum_0028_0029-function-_0028gawk_0029"></a>
<a name="index-convert-string-to-number"></a>
</dd>
<dt><code>strtonum(<var>str</var>) #</code></dt>
<dd><p>检查<var>str</var>并返回其数值。如果<var>str</var>以领先的“ <samp>0</samp> '， <code>strtonum()</code>假设<var>str</var>是一个八进制数。如果<var>str</var>以领先的“ <samp>0x</samp> ' 要么 ' <samp>0X</samp> '， <code>strtonum()</code>假设<var>str</var>是十六进制数。例如：</p>
<div class="example">
<pre class="example">$ <kbd>echo 0x11 |</kbd>
&gt; <kbd>gawk '{ printf &quot;%d\n&quot;, strtonum($1) }'</kbd>
-| 17
</pre></div>

<p>使用<code>strtonum()</code>功能是<em>不</em>一样的添加零为字符串值;字符串自动强制转换为数字仅适用于十进制数据，不适用于八进制或十六进制。 <a name="DOCF46" href="#FOOT46"><sup>46</sup></a>
</p>
<p>另请注意<code>strtonum()</code>使用当前语言环境的小数点来识别数字（请参见<a href="Locales.html#Locales">“您在其中有所作为”</a>部分）。
</p>
</dd>
<dt><code>sub(<var>regexp</var>, <var>replacement</var></code> [ <code>, <var>target</var></code> ]<code>)</code></dt>
<dd><a name="index-sub_0028_0029-function-1"></a>
<a name="index-replace-in-string"></a>
<p>搜索<var>target</var> ，被视为字符串，用于与正则表达式匹配的最左边，最长的子字符串<var>regexp</var> 。通过将匹配的文本替换为来修改整个字符串<var>replacement</var> 。修改后的字符串成为的新值<var>target</var> 。返回进行替换的次数（零或一）。
</p>
<p>的<var>regexp</var>参数可以是regexp常量（ <code>/</code> … <code>/</code> ）或字符串常量（ <code>"</code> … <code>"</code> ）。在后一种情况下，该字符串被视为要匹配的正则表达式。有关两种形式之间的差异以及正确编写程序的含义的讨论，请参阅“ <a href="Computed-Regexps.html#Computed-Regexps">使用动态正则表达式”</a>部分。
</p>
<p>该功能是特殊的，因为<var>target</var>不是简单地用于计算值，也不只是任何表达式都可以—它必须是变量，字段或数组元素，以便<code>sub()</code>可以在那里存储修改后的值。如果省略此参数，则默认为使用和更改<code>$0</code> 。 <a name="DOCF47" href="#FOOT47"><sup>47</sup></a>例如：</p>
<div class="example">
<pre class="example">str = &quot;water, water, everywhere&quot;
sub(/at/, &quot;ith&quot;, str)
</pre></div>

<p>套<code>str</code>至 ' <samp>wither, water, everywhere</samp> “ <!-- /@w --> ，替换了最左侧的最长的出现时间<samp>at</samp>与“ <samp>ith</samp> '。
</p>
<p>如果特殊字符“ <samp>&</samp> '出现在<var>replacement</var> ，代表由匹配的精确子字符串<var>regexp</var> 。（如果正则表达式可以匹配多个字符串，则此精确子字符串可能会有所不同。）例如：</p>
<div class="example">
<pre class="example">{ sub(/candidate/, &quot;&amp; and his wife&quot;); print }
</pre></div>

<p>更改“ <samp>candidate</samp> ' 至 ' <samp>candidate and his wife</samp>在每个输入行上。这是另一个示例：</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;         <kbd>str = &quot;daabaaa&quot;</kbd>
&gt;         <kbd>sub(/a+/, &quot;C&amp;C&quot;, str)</kbd>
&gt;         <kbd>print str</kbd>
&gt; <kbd>}'</kbd>
-| dCaaCbaaa
</pre></div>

<p>这表明“ <samp>&</samp> '可以表示一个非恒定字符串，还说明了regexp匹配中的“最左，最长”规则（请参见<a href="Leftmost-Longest.html#Leftmost-Longest">“多少文本匹配？”部分</a> ）。
</p>
<p>此特殊字符的作用（' <samp>&</samp>可以通过在字符串中添加反斜杠来关闭'）。像往常一样，要在字符串中插入一个反斜杠，必须编写两个反斜杠。因此，写“ <samp>\\&</samp> '在包含常量的字符串常量中' <samp>&</samp>在更换。例如，下面显示了如何替换第一个“ <samp>|</samp>在每行上都带有' <samp>&</samp> '：</p>
<div class="example">
<pre class="example">{ sub(/\|/, &quot;\\&amp;&quot;); print }
</pre></div>

<a name="index-sub_0028_0029-function_002c-arguments-of"></a>
<a name="index-gsub_0028_0029-function_002c-arguments-of"></a>
<p>如前所述，第三个论点是<code>sub()</code>必须是变量，字段或数组元素。的某些版本<code>awk</code>允许第三个参数是不是左值的表达式。在这种情况下， <code>sub()</code>仍然会搜索该模式并返回零或一，但是替换的结果（如果有）被丢弃，因为没有放置它的位置。这样的版本<code>awk</code>接受如下表达式：</p>
<div class="example">
<pre class="example">sub(/USA/, &quot;United States&quot;, &quot;the USA and Canada&quot;)
</pre></div>

<p><a name="index-troubleshooting_002c-gsub_0028_0029_002fsub_0028_0029-functions"></a>为了历史兼容性， <code>gawk</code>接受这样的错误代码。但是，将任何其他不可更改的对象用作第三个参数会导致致命错误，并且您的程序将无法运行。
</p>
<p>最后，如果<var>regexp</var>不是regexp常量，它将转换为字符串，然后将该字符串的值视为要匹配的regexp。
</p>
</dd>
<dt><code>substr(<var>string</var>, <var>start</var></code> [ <code>, <var>length</var></code> ]<code>)</code></dt>
<dd><a name="index-substr_0028_0029-function"></a>
<a name="index-substring"></a>
<p>返回一个<var>length</var> -个字符长的子字符串<var>string</var> ，从字符编号开始<var>start</var> 。字符串的第一个字符是字符号一。 <a name="DOCF48" href="#FOOT48"><sup>48</sup></a>例如， <code>substr("washington", 5, 3)</code>退货<code>"ing"</code> 。
</p>
<p>如果<var>length</var>不存在， <code>substr()</code>返回的完整后缀<var>string</var>从字符编号开始<var>start</var> 。例如， <code>substr("washington", 5)</code>退货<code>"ington"</code> 。如果后缀也返回整个后缀<var>length</var>从字符开始计算，大于字符串中剩余的字符数<var>start</var> 。
</p>
<a name="index-Brian-Kernighan_0027s-awk-11"></a>
<p>如果<var>start</var>小于一， <code>substr()</code>像对待它一样对待它。（POSIX未指定在这种情况下的操作：BWK <code>awk</code>这样行事，因此<code>gawk</code>也是。）如果<var>start</var>大于字符串中的字符数， <code>substr()</code>返回空字符串。同样，如果<var>length</var>存在但小于或等于零，则返回空字符串。
</p>
<a name="index-troubleshooting_002c-substr_0028_0029-function"></a>
<p>传回的字串<code>substr()</code> <em>无法</em>分配。因此，尝试更改字符串的一部分是错误的，如下例所示：</p>
<div class="example">
<pre class="example">string = &quot;abcdef&quot;
# try to get &quot;abCDEf&quot;, won't work
substr(string, 3, 3) = &quot;CDE&quot;
</pre></div>

<p>使用也是错误的<code>substr()</code>作为第三个论点<code>sub()</code>要么<code>gsub()</code> ：</p>
<div class="example">
<pre class="example">gsub(/xyz/, &quot;pdq&quot;, substr($0, 5, 20))  # WRONG
</pre></div>

<a name="index-portability_002c-substr_0028_0029-function"></a>
<p>（某些商业版本<code>awk</code>对待<code>substr()</code>分配给您，但这样做不是可移植的。）
</p>
<p>如果您需要替换字符串的零碎部分，请结合使用<code>substr()</code>字符串串联的方式如下：</p>
<div class="example">
<pre class="example">string = &quot;abcdef&quot;
&hellip;
string = substr(string, 1, 2) &quot;CDE&quot; substr(string, 6)
</pre></div>

<a name="index-case-sensitivity_002c-converting-case"></a>
<a name="index-strings_002c-converting-letter-case"></a>
</dd>
<dt><code>tolower(<var>string</var>)</code></dt>
<dd><a name="index-tolower_0028_0029-function"></a>
<a name="index-convert-string-to-lower-case"></a>
<p>返回的副本<var>string</var> ，并将字符串中的每个大写字符替换为其对应的小写字符。非字母字符保持不变。例如， <code>tolower("MiXeD cAsE 123")</code>退货<code>"mixed case 123"</code> 。
</p>
</dd>
<dt><code>toupper(<var>string</var>)</code></dt>
<dd><a name="index-toupper_0028_0029-function"></a>
<a name="index-convert-string-to-upper-case"></a>
<p>返回的副本<var>string</var> ，并将字符串中的每个小写字符替换为其相应的大写字符。非字母字符保持不变。例如， <code>toupper("MiXeD cAsE 123")</code>退货<code>"MIXED CASE 123"</code> 。
</p></dd>
</dl>

<a name="index-sidebar_002c-Matching-the-Null-String"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<div align="center"><b>匹配空字符串</b>
</div>

<a name="index-matching_002c-null-strings"></a>
<a name="index-null-strings_002c-matching"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-null-strings_002c-matching"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-null-strings_002c-matching"></a>

<p>在<code>awk</code> ， <samp>*</samp> '运算符可以匹配空字符串。这对于<code>sub()</code> ， <code>gsub()</code>和<code>gensub()</code>功能。例如：</p>
<div class="example">
<pre class="example">$ <kbd>echo abc | awk '{ gsub(/m*/, &quot;X&quot;); print }'</kbd>
-| XaXbXcX
</pre></div>

<p>尽管这在一定程度上是有意义的，但这可能令人惊讶。
</p></td></tr></tbody></table>


<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT46" href="#DOCF46">（46）</a></h3>
<p>除非您使用<samp>--non-decimal-data</samp>选项，不建议使用。有关更多信息，请参见“ <a href="Nondecimal-Data.html#Nondecimal-Data">允许非十进制输入数据”</a>一节。</p>
<h3><a name="FOOT47" href="#DOCF47">（47）</a></h3>
<p>请注意，这意味着将首先使用的值重新生成记录。 <code>OFS</code>如果任何字段已更改，并且替换后这些字段也会更新，即使该操作是“无操作”，例如“ <samp>sub(/^/, "")</samp> '。</p>
<h3><a name="FOOT48" href="#DOCF48">（48）</a></h3>
<p>这与C和C ++不同，后者的第一个字符为数字零。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="I_002fO-Functions.html#I_002fO-Functions" rel="next" accesskey="n">I / O函数</a> ，上一篇： <a href="Numeric-Functions.html#Numeric-Functions" rel="prev" accesskey="p">数值函数</a> ，上一篇： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>