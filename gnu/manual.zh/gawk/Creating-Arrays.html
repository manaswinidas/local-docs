<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>创建数组（《 GNU Awk用户指南》）</title>

<meta name="description" content="Creating Arrays (The GNU Awk User’s Guide)">
<meta name="keywords" content="Creating Arrays (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Array-Manipulation.html#Array-Manipulation" rel="up" title="Array Manipulation">
<link href="Redirection-API.html#Redirection-API" rel="next" title="Redirection API">
<link href="Flattening-Arrays.html#Flattening-Arrays" rel="prev" title="Flattening Arrays">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Creating-Arrays"></a>
<div class="header">
<p>上一页：展<a href="Flattening-Arrays.html#Flattening-Arrays" rel="prev" accesskey="p">平数组</a> ，上<a href="Flattening-Arrays.html#Flattening-Arrays" rel="prev" accesskey="p">一篇</a> ： <a href="Array-Manipulation.html#Array-Manipulation" rel="up" accesskey="u">数组操作</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="How-To-Create-and-Populate-Arrays"></a>
<h4 class="subsubsection">17.4.11.4如何创建和填充数组</h4>

<p>除了使用由创建的数组<code>awk</code>代码，您可以创建数组并根据需要填充它们，然后<code>awk</code>代码可以访问它们并对其进行操作。
</p>
<p>从扩展代码创建数组有两个要点：</p>
<ul>
<li>您必须在其中安装新阵列<code>gawk</code>的符号表在创建后立即显示。完成此操作后，即可填充阵列。


<p>同样，如果将新阵列安装为现有阵列的子阵列，则必须先将新阵列添加到其父阵列，然后再向其添加任何元素。
</p>
<p>因此，构建数组的正确方法是“自上而下”。创建阵列，然后立即将其安装在<code>gawk</code>的符号表使用<code>sym_update()</code> ，或使用以下命令将其安装为先前存在的阵列中的元素<code>set_array_element()</code> 。我们不久将显示示例代码。
</p>
</li><li>由于<code>gawk</code>内部使用后<code>sym_update()</code>将阵列安装到<code>gawk</code> ，则必须从传入的值中检索数组cookie。 <code>sym_update()</code>在执行其他操作之前，如下所示：<div class="example">
<pre class="example">awk_value_t val;
awk_array_t new_array;

new_array = create_array();
val.val_type = AWK_ARRAY;
val.array_cookie = new_array;

/* install array in the symbol table */
sym_update(&quot;array&quot;, &amp; val);

new_array = val.array_cookie;    /* YOU MUST DO THIS */
</pre></div>

<p>如果将数组安装为子数组，则还必须在调用以下命令后检索数组cookie的值。 <code>set_element()</code> 。
</p></li></ul>

<p>以下C代码是一个简单的测试扩展，用于创建具有两个常规元素和一个子数组的数组。领先<code>#include</code>为了简洁起见，省略了伪指令和样板变量声明（请参见样板<a href="Extension-API-Boilerplate.html#Extension-API-Boilerplate">代码</a>部分）。第一步是创建一个新数组，然后将其安装在符号表中：</p>
<div class="example">
<pre class="example">/* create_new_array --- create a named array */

static void
create_new_array()
{
    awk_array_t a_cookie;
    awk_array_t subarray;
    awk_value_t index, value;

    a_cookie = create_array();
    value.val_type = AWK_ARRAY;
    value.array_cookie = a_cookie;

    if (! sym_update(&quot;new_array&quot;, &amp; value))
        printf(&quot;create_new_array: sym_update(\&quot;new_array\&quot;) failed!\n&quot;);
    a_cookie = value.array_cookie;
</pre></div>

<p>注意如何<code>a_cookie</code>从重置<code>array_cookie</code>中的字段<code>value</code>结构体。
</p>
<p>第二步是将两个常规值安装到<code>new_array</code> ：</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;hello&quot;, 5, &amp; index);
    (void) make_const_string(&quot;world&quot;, 5, &amp; value);
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }

    (void) make_const_string(&quot;answer&quot;, 6, &amp; index);
    (void) make_number(42.0, &amp; value);
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
</pre></div>

<p>第三步是创建子数组并安装它：</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;subarray&quot;, 8, &amp; index);
    subarray = create_array();
    value.val_type = AWK_ARRAY;
    value.array_cookie = subarray;
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
    subarray = value.array_cookie;
</pre></div>

<p>最后一步是用自己的元素填充子数组：</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;foo&quot;, 3, &amp; index);
    (void) make_const_string(&quot;bar&quot;, 3, &amp; value);
    if (! set_array_element(subarray, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
}
</pre></div>

<p>这是加载扩展名然后转储数组的示例脚本：</p>
<div class="example">
<pre class="example">@load &quot;subarray&quot;

function dumparray(name, array,     i)
{
    for (i in array)
        if (isarray(array[i]))
            dumparray(name &quot;[\&quot;&quot; i &quot;\&quot;]&quot;, array[i])
        else
            printf(&quot;%s[\&quot;%s\&quot;] = %s\n&quot;, name, i, array[i])
}

BEGIN {
    dumparray(&quot;new_array&quot;, new_array);
}
</pre></div>

<p>这是运行脚本的结果：</p>
<div class="example">
<pre class="example">$ <kbd>AWKLIBPATH=$PWD gawk -f subarray.awk</kbd>
-| new_array[&quot;subarray&quot;][&quot;foo&quot;] = bar
-| new_array[&quot;hello&quot;] = world
-| new_array[&quot;answer&quot;] = 42
</pre></div>

<p>（请参见<a href="Finding-Extensions.html#Finding-Extensions">如何<code>gawk</code>查找扩展</a>以获取有关以下内容的更多信息： <code>AWKLIBPATH</code>环境变量。）
</p>
<hr>
<div class="header">
<p>上一页：展<a href="Flattening-Arrays.html#Flattening-Arrays" rel="prev" accesskey="p">平数组</a> ，上<a href="Flattening-Arrays.html#Flattening-Arrays" rel="prev" accesskey="p">一篇</a> ： <a href="Array-Manipulation.html#Array-Manipulation" rel="up" accesskey="u">数组操作</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>