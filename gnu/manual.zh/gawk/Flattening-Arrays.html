<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>展平数组（《 GNU Awk用户指南》）</title>

<meta name="description" content="Flattening Arrays (The GNU Awk User’s Guide)">
<meta name="keywords" content="Flattening Arrays (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Array-Manipulation.html#Array-Manipulation" rel="up" title="Array Manipulation">
<link href="Creating-Arrays.html#Creating-Arrays" rel="next" title="Creating Arrays">
<link href="Array-Functions.html#Array-Functions" rel="prev" title="Array Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Flattening-Arrays"></a>
<div class="header">
<p>下一页： <a href="Creating-Arrays.html#Creating-Arrays" rel="next" accesskey="n">创建数组</a> ，上一篇： <a href="Array-Functions.html#Array-Functions" rel="prev" accesskey="p">数组函数</a> ，上一篇： <a href="Array-Manipulation.html#Array-Manipulation" rel="up" accesskey="u">数组操作</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Working-With-All-The-Elements-of-an-Array"></a>
<h4 class="subsubsection">17.4.11.3处理数组的所有元素</h4>

<p><em>展平</em>数组的方法是创建一种表示完整数组的结构，这种结构可以使C代码轻松遍历整个数组。中的一些代码<samp>extension/testext.c</samp>做到这一点，并且还作为展示如何使用API的一个很好的例子。</p>
<p>我们一次一步地遍历代码的这一部分。首先， <code>gawk</code>驱动测试扩展的脚本：</p>
<div class="example">
<pre class="example">@load &quot;testext&quot;
BEGIN {
    n = split(&quot;blacky rusty sophie raincloud lucky&quot;, pets)
    printf(&quot;pets has %d elements\n&quot;, length(pets))
    ret = dump_array_and_delete(&quot;pets&quot;, &quot;3&quot;)
    printf(&quot;dump_array_and_delete(pets) returned %d\n&quot;, ret)
    if (&quot;3&quot; in pets)
        printf(&quot;dump_array_and_delete() did NOT remove index \&quot;3\&quot;!\n&quot;)
    else
        printf(&quot;dump_array_and_delete() did remove index \&quot;3\&quot;!\n&quot;)
    print &quot;&quot;
}
</pre></div>

<p>这段代码创建了一个数组<code>split()</code> （请参阅“ <a href="String-Functions.html#String-Functions">字符串操作函数”部分</a> ），然后调用<code>dump_array_and_delete()</code> 。该函数查找名称作为第一个参数传递的数组，并删除第二个参数传递的索引处的元素。的<code>awk</code>然后，代码将打印返回值并检查元素是否确实被删除。这是实现的C代码<code>dump_array_and_delete()</code> 。已对其稍作编辑以进行演示。
</p>
<p>第一部分声明变量，在其中设置默认返回值<code>result</code> ，并检查是否使用正确数量的参数调用了该函数：</p>
<div class="example">
<pre class="example">static awk_value_t *
dump_array_and_delete(int nargs, awk_value_t *result)
{
    awk_value_t value, value2, value3;
    awk_flat_array_t *flat_array;
    size_t count;
    char *name;
    int i;

    assert(result != NULL);
    make_number(0.0, result);

    if (nargs != 2) {
        printf(&quot;dump_array_and_delete: nargs not right &quot;
               &quot;(%d should be 2)\n&quot;, nargs);
        goto out;
    }
</pre></div>

<p>然后，该功能按以下步骤进行。首先，获取作为第一个参数传递的数组名称，然后是数组本身。如果任何一个操作失败，则输出错误消息并返回：</p>
<div class="example">
<pre class="example">    /* get argument named array as flat array and print it */
    if (get_argument(0, AWK_STRING, &amp; value)) {
        name = value.str_value.str;
        if (sym_lookup(name, AWK_ARRAY, &amp; value2))
            printf(&quot;dump_array_and_delete: sym_lookup of %s passed\n&quot;,
                   name);
        else {
            printf(&quot;dump_array_and_delete: sym_lookup of %s failed\n&quot;,
                   name);
            goto out;
        }
    } else {
        printf(&quot;dump_array_and_delete: get_argument(0) failed\n&quot;);
        goto out;
    }
</pre></div>

<p>出于测试目的，并确保C代码看到的元素数量与<code>awk</code>代码，第二步是获取数组中元素的数量并打印：</p>
<div class="example">
<pre class="example">    if (! get_element_count(value2.array_cookie, &amp; count)) {
        printf(&quot;dump_array_and_delete: get_element_count failed\n&quot;);
        goto out;
    }

    printf(&quot;dump_array_and_delete: incoming size is %lu\n&quot;,
           (unsigned long) count);
</pre></div>

<p>第三步是实际展平数组，然后再次检查数组中的计数<code>awk_flat_array_t</code>与刚刚获取的计数相同：</p>
<div class="example">
<pre class="example">    if (! flatten_array_typed(value2.array_cookie, &amp; flat_array,
                              AWK_STRING, AWK_UNDEFINED)) {
        printf(&quot;dump_array_and_delete: could not flatten array\n&quot;);
        goto out;
    }

    if (flat_array-&gt;count != count) {
        printf(&quot;dump_array_and_delete: flat_array-&gt;count (%lu)&quot;
               &quot; != count (%lu)\n&quot;,
                (unsigned long) flat_array-&gt;count,
                (unsigned long) count);
        goto out;
    }
</pre></div>

<p>第四步是检索要删除的元素的索引，该索引作为第二个参数传递。请记住，参数传递给<code>get_argument()</code>从零开始，因此第二个参数编号为1：</p>
<div class="example">
<pre class="example">    if (! get_argument(1, AWK_STRING, &amp; value3)) {
        printf(&quot;dump_array_and_delete: get_argument(1) failed\n&quot;);
        goto out;
    }
</pre></div>

<p>第五步是完成“实际工作”的地方。该函数遍历数组中的每个元素，打印索引和元素值。此外，在找到具有应删除索引的元素后，该函数将设置<code>AWK_ELEMENT_DELETE</code>有点<code>flags</code>元素的字段。释放阵列后， <code>gawk</code>遍历展平的数组，并删除所有设置了此标志位的元素：</p>
<div class="example">
<pre class="example">    for (i = 0; i &lt; flat_array-&gt;count; i++) {
        printf(&quot;\t%s[\&quot;%.*s\&quot;] = %s\n&quot;,
            name,
            (int) flat_array-&gt;elements[i].index.str_value.len,
            flat_array-&gt;elements[i].index.str_value.str,
            valrep2str(&amp; flat_array-&gt;elements[i].value));

        if (strcmp(value3.str_value.str,
                   flat_array-&gt;elements[i].index.str_value.str) == 0) {
            flat_array-&gt;elements[i].flags |= AWK_ELEMENT_DELETE;
            printf(&quot;dump_array_and_delete: marking element \&quot;%s\&quot; &quot;
                   &quot;for deletion\n&quot;,
                flat_array-&gt;elements[i].index.str_value.str);
        }
    }
</pre></div>

<p>第六步是释放展平的数组。这说明<code>gawk</code>扩展名不再使用数组，并且应该删除所有标记为删除的元素。
<code>gawk</code>也会释放已分配的所有存储空间，因此您不应使用指针（ <code>flat_array</code>在此代码中） <code>release_flattened_array()</code> ：</p>
<div class="example">
<pre class="example">    if (! release_flattened_array(value2.array_cookie, flat_array)) {
        printf(&quot;dump_array_and_delete: could not release flattened array\n&quot;);
        goto out;
    }
</pre></div>

<p>最后，由于一切都成功，因此该函数将返回值设置为成功，并返回：</p>
<div class="example">
<pre class="example">    make_number(1.0, result);
out:
    return result;
}
</pre></div>

<p>这是运行此部分测试的输出：</p>
<div class="example">
<pre class="example">pets has 5 elements
dump_array_and_delete: sym_lookup of pets passed
dump_array_and_delete: incoming size is 5
        pets[&quot;1&quot;] = &quot;blacky&quot;
        pets[&quot;2&quot;] = &quot;rusty&quot;
        pets[&quot;3&quot;] = &quot;sophie&quot;
dump_array_and_delete: marking element &quot;3&quot; for deletion
        pets[&quot;4&quot;] = &quot;raincloud&quot;
        pets[&quot;5&quot;] = &quot;lucky&quot;
dump_array_and_delete(pets) returned 1
dump_array_and_delete() did remove index &quot;3&quot;!
</pre></div>

<hr>
<div class="header">
<p>下一页： <a href="Creating-Arrays.html#Creating-Arrays" rel="next" accesskey="n">创建数组</a> ，上一篇： <a href="Array-Functions.html#Array-Functions" rel="prev" accesskey="p">数组函数</a> ，上一篇： <a href="Array-Manipulation.html#Array-Manipulation" rel="up" accesskey="u">数组操作</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>