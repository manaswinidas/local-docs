<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>按位函数（《 GNU Awk用户指南》）</title>

<meta name="description" content="Bitwise Functions (The GNU Awk User’s Guide)">
<meta name="keywords" content="Bitwise Functions (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Built_002din.html#Built_002din" rel="up" title="Built-in">
<link href="Type-Functions.html#Type-Functions" rel="next" title="Type Functions">
<link href="Time-Functions.html#Time-Functions" rel="prev" title="Time Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Bitwise-Functions"></a>
<div class="header">
<p>下一个： <a href="Type-Functions.html#Type-Functions" rel="next" accesskey="n">类型函数</a> ，上一个： <a href="Time-Functions.html#Time-Functions" rel="prev" accesskey="p">时间函数</a> ，上： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Bit_002dManipulation-Functions"></a>
<h4 class="subsection">9.1.6位操作功能</h4>
<a name="index-bit_002dmanipulation-functions"></a>
<a name="index-bitwise_002c-operations"></a>
<a name="index-AND-bitwise-operation"></a>
<a name="index-OR-bitwise-operation"></a>
<a name="index-XOR-bitwise-operation"></a>
<a name="index-operations_002c-bitwise"></a>
<blockquote>
<p><i>我可以为您解释，但我无法为您理解。</i>
</p></blockquote>
<div align="center">- <em>匿名</em>
</div>
<p>许多语言都提供了对两个整数执行<em>按位</em>运算的功能。换句话说，对操作数中每个连续的位对执行操作。三种常见的运算是按位AND，OR和XOR。操作在<a href="#table_002dbitwise_002dops">表9.6</a>中描述。
</p>
<div class="float"><a name="table_002dbitwise_002dops"></a>

<pre class="verbatim">                Bit operator
          |  AND  |   OR  |  XOR
          |---+---+---+---+---+---
Operands  | 0 | 1 | 0 | 1 | 0 | 1
----------+---+---+---+---+---+---
    0     | 0   0 | 0   1 | 0   1
    1     | 0   1 | 1   1 | 1   0
</pre>
<div class="float-caption"><p><strong>表9.6：</strong>按位运算</p></div></div>
<a name="index-bitwise-complement"></a>
<a name="index-complement_002c-bitwise"></a>
<p>如您所见，仅当<em>两个</em>位均为1时，AND运算的结果才为1。如果<em>任</em>一位为1，则“或”运算的结果为1。如果任一位为1，则XOR运算的结果为1，但不是两个都为1。下一个操作是<em>补码</em> ; 1的补码为0，0的补码为1。因此，该操作“翻转”给定值的所有位。
</p>
<a name="index-bitwise_002c-shift"></a>
<a name="index-left-shift_002c-bitwise"></a>
<a name="index-right-shift_002c-bitwise"></a>
<a name="index-shift_002c-bitwise"></a>
<p>最后，另外两个常见的操作是将这些位向左或向右移位。例如，如果您有一个字符串' <samp>10111001</samp> '然后将其右移三位，最后得到' <samp>00010111</samp> '。 <a name="DOCF58" href="#FOOT58"><sup>58</sup></a>如果您再次以“ <samp>10111001</samp> '并将其向左移三位，最后得到' <samp>11001000</samp> '。以下列表描述<code>gawk</code>的可实现按位运算的内置函数。可选参数放在方括号（[]）中：</p>
<a name="index-gawk_002c-bitwise-operations-in"></a>
<dl compact>
<dd><a name="index-and_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-AND"></a>
</dd>
<dt><code>and(</code><var>v1</var><code>,</code><var>v2</var> [ <code>,</code> …]<code>)</code></dt>
<dd><p>返回参数的按位与。必须至少有两个。
</p>
<a name="index-compl_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-complement-1"></a>
</dd>
<dt><code>compl(<var>val</var>)</code></dt>
<dd><p>返回的按位补码<var>val</var> 。
</p>
<a name="index-lshift_0028_0029-function-_0028gawk_0029"></a>
<a name="index-left-shift"></a>
</dd>
<dt><code>lshift(<var>val</var>, <var>count</var>)</code></dt>
<dd><p>返回值<var>val</var> ，向左移动<var>count</var>位。
</p>
<a name="index-or_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-OR"></a>
</dd>
<dt><code>or(</code><var>v1</var><code>,</code><var>v2</var> [ <code>,</code> …]<code>)</code></dt>
<dd><p>返回参数的按位或。必须至少有两个。
</p>
<a name="index-rshift_0028_0029-function-_0028gawk_0029"></a>
<a name="index-right-shift"></a>
</dd>
<dt><code>rshift(<var>val</var>, <var>count</var>)</code></dt>
<dd><p>返回值<var>val</var> ，向右移动<var>count</var>位。
</p>
<a name="index-xor_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-XOR"></a>
</dd>
<dt><code>xor(</code><var>v1</var><code>,</code><var>v2</var> [ <code>,</code> …]<code>)</code></dt>
<dd><p>返回参数的按位XOR。必须至少有两个。
</p></dd>
</dl>

<blockquote>
<p><b>注意：</b>从开始<code>gawk</code>在4.2版中，任何这些函数均不允许使用负操作数。负操作数会产生致命错误。请参见侧栏“当心烟雾和镜子！”有关原因的更多信息。
</p></blockquote>

<p>这是一个用户定义的函数（请参阅“ <a href="User_002ddefined.html#User_002ddefined">用户定义的函数”</a>一节），说明了这些函数的用法：</p>
<a name="index-bits2str_0028_0029-user_002ddefined-function"></a>
<a name="index-testbits_002eawk-program"></a>
<div class="example">
<pre class="example"># bits2str --- turn an integer into readable ones and zeros

function bits2str(bits,        data, mask)
{
    if (bits == 0)
        return &quot;0&quot;

    mask = 1
    for (; bits != 0; bits = rshift(bits, 1))
        data = (and(bits, mask) ? &quot;1&quot; : &quot;0&quot;) data

    while ((length(data) % 8) != 0)
        data = &quot;0&quot; data

    return data
}
</pre><pre class="example">

BEGIN {
    printf &quot;123 = %s\n&quot;, bits2str(123)
    printf &quot;0123 = %s\n&quot;, bits2str(0123)
    printf &quot;0x99 = %s\n&quot;, bits2str(0x99)
    comp = compl(0x99)
    printf &quot;compl(0x99) = %#x = %s\n&quot;, comp, bits2str(comp)
    shift = lshift(0x99, 2)
    printf &quot;lshift(0x99, 2) = %#x = %s\n&quot;, shift, bits2str(shift)
    shift = rshift(0x99, 2)
    printf &quot;rshift(0x99, 2) = %#x = %s\n&quot;, shift, bits2str(shift)
}
</pre></div>

<p>该程序在运行时会产生以下输出：</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f testbits.awk</kbd>
-| 123 = 01111011
-| 0123 = 01010011
-| 0x99 = 10011001
-| compl(0x99) = 0x3fffffffffff66 =
-| 00111111111111111111111111111111111111111111111101100110
-| lshift(0x99, 2) = 0x264 = 0000001001100100
-| rshift(0x99, 2) = 0x26 = 00100110
</pre></div>

<a name="index-converting_002c-strings-to-numbers-1"></a>
<a name="index-strings_002c-converting-1"></a>
<a name="index-numbers_002c-converting-1"></a>
<a name="index-converting_002c-numbers-to-strings-1"></a>
<a name="index-numbers_002c-as-string-of-bits"></a>
<p>的<code>bits2str()</code>函数将二进制数转换为字符串。初始化中<code>mask</code>如果为1，则会创建一个二进制值，其中最右边的位设置为1。使用此掩码，该函数反复检查最右边的位。将掩码与该值进行“与”运算可表明最右边的位是否为1。如果是这样， <code>"1"</code>连接到字符串的前面。否则， <code>"0"</code>被添加。然后将值右移一位，然后循环继续直到不再有一位为止。
</p>
<p>如果初始值为零，则返回一个简单<code>"0"</code> 。否则，最后用零填充该值，以表示8位数量的倍数。这在现代计算机中很常见。
</p>
<p>中的主要代码<code>BEGIN</code>规则显示相同数字的十进制值和八进制值之间的差异（请参见“ <a href="Nondecimal_002dnumbers.html#Nondecimal_002dnumbers">八进制和十六进制数”部分</a> ），然后演示求和结果。 <code>compl()</code> ， <code>lshift()</code>和<code>rshift()</code>功能。
</p>
<a name="index-sidebar_002c-Beware-The-Smoke-and-Mirrors_0021"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<div align="center"><b>当心烟雾和镜子！</b>
</div>


<p>用其他语言，按位运算是对整数值而不是浮点值执行的。通常，对无符号整数执行此类操作时效果最佳。
</p>
<p><code>gawk</code>尝试将按位函数的参数视为无符号整数。因此，否定参数会产生致命错误。
</p>
<p>在正常操作中，对于所有这些功能，首先将双精度浮点值转换为最宽的C无符号整数类型，然后执行按位运算。如果结果不能完全表示为C <code>double</code> ，前导非零位将被一一删除，直到可以准确表示为止。然后将结果转换回C <code>double</code> 。 <a name="DOCF59" href="#FOOT59"><sup>59</sup></a>
</p>
<p>但是，当将任意精度算术与<samp>-M</samp>选项（请参见“ <a href="Arbitrary-Precision-Arithmetic.html#Arbitrary-Precision-Arithmetic">算术和任意精度算术与<code>gawk</code></a> ），结果可能会有所不同。这一点在<code>compl()</code>功能：</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print compl(42) }'</kbd>
-| 9007199254740949
$ <kbd>gawk -M 'BEGIN { print compl(42) }'</kbd>
-| -43
</pre></div>

<p>以十六进制打印结果时，发生的事情变得很清楚：</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { printf &quot;%#x\n&quot;, compl(42) }'</kbd>
-| 0x1fffffffffffd5
$ <kbd>gawk -M 'BEGIN { printf &quot;%#x\n&quot;, compl(42) }'</kbd>
-| 0xffffffffffffffd5
</pre></div>

<p>使用时<samp>-M</samp>选项，在引擎盖下<code>gawk</code>使用具有至少64位精度的GNU MP任意精度整数。不使用时<samp>-M</samp> ， <code>gawk</code>将整数值存储在规则的双精度浮点中，该浮点仅保持53位精度。此外，GNU MP库将（或至少似乎将）前导位视为符号位；因此结果<samp>-M</samp>在这种情况下为负数。
</p>
<p>简而言之，使用<code>gawk</code>对于除最简单的按位运算之外的任何运算，可能都不是个好主意。买者自负！
</p>
</td></tr></tbody></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT58" href="#DOCF58">（58）</a></h3>
<p>此示例显示零出现在左侧。对于<code>gawk</code> ，这始终是正确的，但在某些语言中，左侧可能会填充一个。</p>
<h3><a name="FOOT59" href="#DOCF59">（59）</a></h3>
<p>如果您不了解本段，那么结果就是<code>gawk</code>只能存储特定范围的整数值；超出该范围的数字将减少以适合该范围。</p>
</div>
<hr>
<div class="header">
<p>下一个： <a href="Type-Functions.html#Type-Functions" rel="next" accesskey="n">类型函数</a> ，上一个： <a href="Time-Functions.html#Time-Functions" rel="prev" accesskey="p">时间函数</a> ，上： <a href="Built_002din.html#Built_002din" rel="up" accesskey="u">内置</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>