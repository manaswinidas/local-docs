<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>剪切程序（《 GNU Awk用户指南》）</title>

<meta name="description" content="Cut Program (The GNU Awk User’s Guide)">
<meta name="keywords" content="Cut Program (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Clones.html#Clones" rel="up" title="Clones">
<link href="Egrep-Program.html#Egrep-Program" rel="next" title="Egrep Program">
<link href="Clones.html#Clones" rel="prev" title="Clones">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Cut-Program"></a>
<div class="header">
<p>下一篇： <a href="Egrep-Program.html#Egrep-Program" rel="next" accesskey="n">Egrep程序</a> ，上一篇： <a href="Clones.html#Clones" rel="up" accesskey="u">克隆</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Cutting-Out-Fields-and-Columns"></a>
<h4 class="subsection">11.2.1切出字段和列</h4>

<a name="index-cut-utility"></a>
<a name="index-cut-utility-1"></a>
<a name="index-fields_002c-cutting"></a>
<a name="index-columns_002c-cutting"></a>
<p>的<code>cut</code>实用程序从其标准输入中选择或“剪切”字符或字段，并将其发送到其标准输出。默认情况下，字段之间用TAB分隔，但您可以提供一个命令行选项来更改字段<em>定界符</em> （即，字段分隔符）。 <code>cut</code>的字段定义不如<code>awk</code>的。
</p>
<p>常用<code>cut</code>可能只是从的输出中拉出已登录用户的登录名<code>who</code> 。例如，以下管道生成已登录用户的排序后的唯一列表：</p>
<div class="example">
<pre class="example">who | cut -c1-8 | sort | uniq
</pre></div>

<p>的选项<code>cut</code>是：</p>
<dl compact>
<dt><code>-c <var>list</var></code></dt>
<dd><p>使用<var>list</var>作为要剪切的字符列表。列表中的项目可以用逗号分隔，字符范围可以用破折号分隔。列表 ' <samp>1-8,15,22-35</samp> '指定字符1至8、15和22至35。
</p>
</dd>
<dt><code>-f <var>list</var></code></dt>
<dd><p>使用<var>list</var>作为要剪切的字段列表。
</p>
</dd>
<dt><code>-d <var>delim</var></code></dt>
<dd><p>使用<var>delim</var>作为字段分隔符而不是TAB字符。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>禁止打印不包含字段定界符的行。
</p></dd>
</dl>

<p>的<code>awk</code>实施<code>cut</code>使用<code>getopt()</code>库函数（请参阅“ <a href="Getopt-Function.html#Getopt-Function">处理命令行选项”一节</a> ）和<code>join()</code>库函数（请参见<a href="Join-Function.html#Join-Function">将数组合并为String一节</a> ）。
</p>
<p>该程序以注释开头，描述选项，所需的库函数以及<code>usage()</code>打印出使用情况消息并退出的功能。 <code>usage()</code>如果提供了无效的参数，则调用：</p>
<a name="index-cut_002eawk-program"></a>
<div class="example">
<pre class="example"># cut.awk --- implement cut in awk

# Options:
#    -f list     Cut fields
#    -d c        Field delimiter character
#    -c list     Cut characters
#
#    -s          Suppress lines without the delimiter
#
# Requires getopt() and join() library functions

</pre><pre class="example">function usage()
{
    print(&quot;usage: cut [-f list] [-d c] [-s] [files...]&quot;) &gt; &quot;/dev/stderr&quot;
    print(&quot;usage: cut [-c list] [files...]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>

<a name="index-BEGIN-pattern_002c-running-awk-programs-and"></a>
<a name="index-FS-variable_002c-running-awk-programs-and"></a>
<p>接下来是<code>BEGIN</code>解析命令行选项的规则。它设置<code>FS</code>到一个TAB字符，因为那是<code>cut</code>的默认字段分隔符。然后，该规则将输出字段分隔符设置为与输入字段分隔符相同。循环使用<code>getopt()</code>逐步执行命令行选项。变量之一<code>by_fields</code>要么<code>by_chars</code>设置为true表示分别应按字段或按字符进行处理。按字符分割时，输出字段分隔符设置为空字符串：</p>
<div class="example">
<pre class="example">BEGIN {
    FS = &quot;\t&quot;    # default
    OFS = FS
    while ((c = getopt(ARGC, ARGV, &quot;sf:c:d:&quot;)) != -1) {
        if (c == &quot;f&quot;) {
            by_fields = 1
            fieldlist = Optarg
        } else if (c == &quot;c&quot;) {
            by_chars = 1
            fieldlist = Optarg
            OFS = &quot;&quot;
        } else if (c == &quot;d&quot;) {
            if (length(Optarg) &gt; 1) {
                printf(&quot;cut: using first character of %s&quot; \
                       &quot; for delimiter\n&quot;, Optarg) &gt; &quot;/dev/stderr&quot;
                Optarg = substr(Optarg, 1, 1)
            }
            fs = FS = Optarg
            OFS = FS
            if (FS == &quot; &quot;)    # defeat awk semantics
                FS = &quot;[ ]&quot;
        } else if (c == &quot;s&quot;)
            suppress = 1
        else
            usage()
    }

    # Clear out options
    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;
</pre></div>

<a name="index-field-separators_002c-spaces-as"></a>
<p>当字段定界符为空格时，代码必须格外小心。使用单个空格（ <code>" "
<!-- /@w --></code> ）的价值<code>FS</code>是不正确的- <code>awk</code>会用空格，TAB和/或换行符分隔字段，我们希望将它们与单个空格分开。为此，我们将原始空格字符保存在变量中<code>fs</code>供以后使用；设定后<code>FS</code>至<code>"[ ]"</code>我们不能直接使用它来查看字段分隔符是否在字符串中。
</p>
<p>还记得之后<code>getopt()</code>通过（如“ <a href="Getopt-Function.html#Getopt-Function">处理命令行选项”中所述</a> ），我们必须清除所有的元素<code>ARGV</code>从1到<code>Optind</code> ， 以便<code>awk</code>不会尝试将命令行选项作为文件名处理。
</p>
<p>处理完命令行选项后，程序将验证选项是否有意义。仅以下一项<samp>-c</samp>和<samp>-f</samp>应该使用，并且都需要一个字段列表。然后程序调用<code>set_fieldlist()</code>要么<code>set_charlist()</code>拆分字段或字符列表：</p>
<div class="example">
<pre class="example">    if (by_fields &amp;&amp; by_chars)
        usage()

    if (by_fields == 0 &amp;&amp; by_chars == 0)
        by_fields = 1    # default

</pre><pre class="example">    if (fieldlist == &quot;&quot;) {
        print &quot;cut: needs list for -c or -f&quot; &gt; &quot;/dev/stderr&quot;
        exit 1
    }
</pre><pre class="example">

    if (by_fields)
        set_fieldlist()
    else
        set_charlist()
}
</pre></div>

<p><code>set_fieldlist()</code>将字段列表以逗号分隔为一个数组。然后，对于数组的每个元素，它会查看该元素是否实际上是一个范围，如果是，则将其拆分。该功能检查范围以确保第一个数字小于第二个数字。列表中的每个数字都会添加到<code>flist</code>数组，仅列出将要打印的字段。使用常规字段拆分。该程序让<code>awk</code>处理进行字段拆分的工作：</p>
<div class="example">
<pre class="example">function set_fieldlist(        n, m, i, j, k, f, g)
{
    n = split(fieldlist, f, &quot;,&quot;)
    j = 1    # index in flist
    for (i = 1; i &lt;= n; i++) {
        if (index(f[i], &quot;-&quot;) != 0) { # a range
            m = split(f[i], g, &quot;-&quot;)
</pre><pre class="example">            if (m != 2 || g[1] &gt;= g[2]) {
                printf(&quot;cut: bad field list: %s\n&quot;,
                                  f[i]) &gt; &quot;/dev/stderr&quot;
                exit 1
            }
</pre><pre class="example">            for (k = g[1]; k &lt;= g[2]; k++)
                flist[j++] = k
        } else
            flist[j++] = f[i]
    }
    nfields = j - 1
}
</pre></div>

<p>的<code>set_charlist()</code>功能比<code>set_fieldlist()</code> 。这里的想法是使用<code>gawk</code>的<code>FIELDWIDTHS</code>变量（请参见<a href="Constant-Size.html#Constant-Size">读取固定宽度数据部分</a> ），该变量描述了恒定宽度的输入。使用字符列表时，这正是我们所拥有的。
</p>
<p>配置<code>FIELDWIDTHS</code>比仅列出需要打印的字段要复杂得多。我们必须跟踪要打印的字段以及必须跳过的中间字符。例如，假设您想要字符1到8、15和22到35。您将使用“ <samp>-c 1-8,15,22-35</samp> '。的必要值<code>FIELDWIDTHS</code>是<code>"8 6 1 6 14"
<!-- /@w --></code> 。这将产生五个字段，要打印的字段是<code>$1</code> ， <code>$3</code>和<code>$5</code> 。中间字段是<em>fill</em> ，填充在所需数据之间。
<code>flist</code>列出要打印的字段，以及<code>t</code>跟踪完整的字段列表，包括填充字段：</p>
<div class="example">
<pre class="example">function set_charlist(    field, i, j, f, g, n, m, t,
                          filler, last, len)
{
    field = 1   # count total fields
    n = split(fieldlist, f, &quot;,&quot;)
    j = 1       # index in flist
    for (i = 1; i &lt;= n; i++) {
        if (index(f[i], &quot;-&quot;) != 0) { # range
            m = split(f[i], g, &quot;-&quot;)
            if (m != 2 || g[1] &gt;= g[2]) {
                printf(&quot;cut: bad character list: %s\n&quot;,
                               f[i]) &gt; &quot;/dev/stderr&quot;
                exit 1
            }
            len = g[2] - g[1] + 1
            if (g[1] &gt; 1)  # compute length of filler
                filler = g[1] - last - 1
            else
                filler = 0
</pre><pre class="example">            if (filler)
                t[field++] = filler
</pre><pre class="example">            t[field++] = len  # length of field
            last = g[2]
            flist[j++] = field - 1
        } else {
            if (f[i] &gt; 1)
                filler = f[i] - last - 1
            else
                filler = 0
            if (filler)
                t[field++] = filler
            t[field++] = 1
            last = f[i]
            flist[j++] = field - 1
        }
    }
    FIELDWIDTHS = join(t, 1, field - 1)
    nfields = j - 1
}
</pre></div>

<p>接下来是处理数据的规则。如果<samp>-s</samp>给定选项，然后<code>suppress</code>是真的。首先<code>if</code>语句确保输入记录确实具有字段分隔符。如果<code>cut</code>正在处理字段， <code>suppress</code>为true，并且字段分隔符不在记录中，则跳过该记录。
</p>
<p>如果记录有效，则<code>gawk</code>已使用中的字符将数据拆分为字段<code>FS</code>或使用固定长度的字段和<code>FIELDWIDTHS</code> 。循环遍历应打印的字段列表。如果包含数据，则打印相应的字段。如果下一个字段也有数据，则在这些字段之间写出分隔符：</p>
<div class="example">
<pre class="example">{
    if (by_fields &amp;&amp; suppress &amp;&amp; index($0, fs) == 0)
        next

    for (i = 1; i &lt;= nfields; i++) {
        if ($flist[i] != &quot;&quot;) {
            printf &quot;%s&quot;, $flist[i]
            if (i &lt; nfields &amp;&amp; $flist[i+1] != &quot;&quot;)
                printf &quot;%s&quot;, OFS
        }
    }
    print &quot;&quot;
}
</pre></div>

<p>这个版本的<code>cut</code>依靠<code>gawk</code>的<code>FIELDWIDTHS</code>变量以执行基于字符的剪切。在其他可能<code>awk</code>使用的实现<code>substr()</code> （请参阅“ <a href="String-Functions.html#String-Functions">字符串操作函数”</a>一节），但这也非常痛苦。的<code>FIELDWIDTHS</code>变量为将输入行按字符分开的问题提供了一种很好的解决方案。
</p>

<hr>
<div class="header">
<p>下一篇： <a href="Egrep-Program.html#Egrep-Program" rel="next" accesskey="n">Egrep程序</a> ，上一篇： <a href="Clones.html#Clones" rel="up" accesskey="u">克隆</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>