<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>间接调用（《 GNU Awk用户指南》）</title>

<meta name="description" content="Indirect Calls (The GNU Awk User’s Guide)">
<meta name="keywords" content="Indirect Calls (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Functions.html#Functions" rel="up" title="Functions">
<link href="Functions-Summary.html#Functions-Summary" rel="next" title="Functions Summary">
<link href="Dynamic-Typing.html#Dynamic-Typing" rel="prev" title="Dynamic Typing">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Indirect-Calls"></a>
<div class="header">
<p>下一个： <a href="Functions-Summary.html#Functions-Summary" rel="next" accesskey="n">功能概要</a> ，上一个： <a href="User_002ddefined.html#User_002ddefined" rel="prev" accesskey="p">用户定义的</a> ，上级： <a href="Functions.html#Functions" rel="up" accesskey="u">函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Indirect-Function-Calls"></a>
<h3 class="section">9.3间接函数调用</h3>

<a name="index-indirect-function-calls"></a>
<a name="index-function-calls_002c-indirect"></a>
<a name="index-function-pointers"></a>
<a name="index-pointers-to-functions"></a>
<a name="index-differences-in-awk-and-gawk_002c-indirect-function-calls"></a>

<p>本节介绍高级<code>gawk</code>特定的扩展名。
</p>
<p>通常，您可能希望将要调用的函数的选择推迟到运行时。例如，您可能有不同种类的记录，每个记录应以不同的方式处理。
</p>
<p>通常，您必须使用一系列<code>if</code> -- <code>else</code>语句来决定要调用哪个函数。通过使用<em>间接</em>函数调用，可以将要调用的函数名称指定为字符串变量，然后调用该函数。让我们看一个例子。
</p>
<p>假设您有一个文件，其中包含要参加的课程的考试成绩，并且希望获得考试成绩的总和和平均值。第一个字段是类名称。以下字段是用于调用处理数据的函数，最多可以是“标记”字段' <samp>data:</samp> '。标记之后，是记录的结尾，是各种数字测试分数。
</p>
<p>这是初始文件：</p>
<div class="example">
<pre class="example">Biology_101 sum average data: 87.0 92.4 78.5 94.9
Chemistry_305 sum average data: 75.2 98.3 94.7 88.2
English_401 sum average data: 100.0 95.6 87.1 93.4
</pre></div>

<p>要处理数据，您可能最初会写：</p>
<div class="example">
<pre class="example">{
    class = $1
    for (i = 2; $i != &quot;data:&quot;; i++) {
        if ($i == &quot;sum&quot;)
            sum()   # processes the whole record
        else if ($i == &quot;average&quot;)
            average()
        &hellip;           # and so on
    }
}
</pre></div>

<p>这种编程风格有效，但是可能很尴尬。通过<em>间接</em>函数调用，您可以知道<code>gawk</code>使用变量的<em>值</em>作为要调用的函数的<em>名称</em> 。
</p>
<a name="index-_0040_002dnotation-for-indirect-function-calls"></a>
<a name="index-indirect-function-calls_002c-_0040_002dnotation"></a>
<a name="index-function-calls_002c-indirect_002c-_0040_002dnotation-for"></a>
<p>语法类似于常规函数调用的语法：标识符后紧跟一个左括号，任何参数，然后是一个右括号，并加上前导' <samp>@</samp> '字符：</p>
<div class="example">
<pre class="example">the_func = &quot;sum&quot;
result = @the_func()   # calls the sum() function
</pre></div>

<p>这是一个使用间接函数调用来处理先前显示的数据的完整程序：</p>
<div class="example">
<pre class="example"># indirectcall.awk --- Demonstrate indirect function calls

# average --- return the average of the values in fields $first - $last

function average(first, last,   sum, i)
{
    sum = 0;
    for (i = first; i &lt;= last; i++)
        sum += $i

    return sum / (last - first + 1)
}

# sum --- return the sum of the values in fields $first - $last

function sum(first, last,   ret, i)
{
    ret = 0;
    for (i = first; i &lt;= last; i++)
        ret += $i

    return ret
}
</pre></div>

<p>这两个功能有望在现场发挥作用。因此，参数<code>first</code>和<code>last</code>指示字段中开始和结束的位置。否则，它们将执行预期的计算并且并非异常：</p>
<div class="example">
<pre class="example"># For each record, print the class name and the requested statistics
{
    class_name = $1
    gsub(/_/, &quot; &quot;, class_name)  # Replace _ with spaces

    # find start
    for (i = 1; i &lt;= NF; i++) {
        if ($i == &quot;data:&quot;) {
            start = i + 1
            break
        }
    }

    printf(&quot;%s:\n&quot;, class_name)
    for (i = 2; $i != &quot;data:&quot;; i++) {
        the_function = $i
        printf(&quot;\t%s: &lt;%s&gt;\n&quot;, $i, @the_function(start, NF) &quot;&quot;)
    }
    print &quot;&quot;
}
</pre></div>

<p>这是每个记录的主要处理。它打印类名（下划线用空格替换）。然后找到实际数据的开始，并将其保存在<code>start</code> 。代码的最后部分循环遍历每个函数名称（从<code>$2</code>直到标记， <samp>data:</samp> '），调用由字段命名的函数。间接函数调用本身以参数形式出现在对<code>printf</code> 。（ <code>printf</code>格式字符串使用' <samp>%s</samp> '作为格式说明符，以便我们可以使用返回字符串和数字的函数。请注意，间接调用的结果与空字符串连接在一起，以强制其为字符串值。）
</p>
<p>这是运行程序的结果：</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f indirectcall.awk class_data1</kbd>
-| Biology 101:
-|     sum: &lt;352.8&gt;
-|     average: &lt;88.2&gt;
-|
-| Chemistry 305:
-|     sum: &lt;356.4&gt;
-|     average: &lt;89.1&gt;
-|
-| English 401:
-|     sum: &lt;376.1&gt;
-|     average: &lt;94.025&gt;
</pre></div>

<p>使用间接函数调用的功能比起初您想的要强大。C和C ++语言提供“函数指针”，这是一种用于在运行时调用所选函数的机制。C的最著名用途之一是C <code>qsort()</code>函数，该函数使用著名的“快速排序”算法对数组进行排序（有关更多信息，请参见<a href="https://en.wikipedia.org/wiki/Quicksort">Wikipedia文章</a> ）。要使用此功能，您需要提供一个指向比较功能的指针。这种机制允许您以任意方式对任意数据进行排序。
</p>
<p>我们可以使用<code>gawk</code> ， 像这样：</p>
<div class="example">
<pre class="example"># quicksort.awk --- Quicksort algorithm, with user-supplied
#                   comparison function

# quicksort --- C.A.R. Hoare's quicksort algorithm. See Wikipedia
#               or almost any algorithms or computer science text.

function quicksort(data, left, right, less_than,    i, last)
{
    if (left &gt;= right)  # do nothing if array contains fewer
        return          # than two elements

    quicksort_swap(data, left, int((left + right) / 2))
    last = left
    for (i = left + 1; i &lt;= right; i++)
        if (@less_than(data[i], data[left]))
            quicksort_swap(data, ++last, i)
    quicksort_swap(data, left, last)
    quicksort(data, left, last - 1, less_than)
    quicksort(data, last + 1, right, less_than)
}

# quicksort_swap --- helper function for quicksort, should really be inline

function quicksort_swap(data, i, j,      temp)
{
    temp = data[i]
    data[i] = data[j]
    data[j] = temp
}
</pre></div>

<p>的<code>quicksort()</code>功能接收<code>data</code>数组，要排序的开始索引和结束索引（ <code>left</code>和<code>right</code> ），以及执行“小于”比较的函数的名称。然后，它实现快速排序算法。
</p>
<p>为了使用排序功能，我们返回前面的示例。首先要做的是编写一些比较函数：</p>
<div class="example">
<pre class="example"># num_lt --- do a numeric less than comparison

function num_lt(left, right)
{
    return ((left + 0) &lt; (right + 0))
}
</pre><pre class="example">

# num_ge --- do a numeric greater than or equal to comparison

function num_ge(left, right)
{
    return ((left + 0) &gt;= (right + 0))
}
</pre></div>

<p>的<code>num_ge()</code>需要功能来执行降序排序；当用于执行“小于”测试时，它实际上执行相反的操作（大于或等于），从而产生按降序排序的数据。
</p>
<p>接下来是排序功能。使用开始和结束字段编号以及比较功能对其进行参数化。它使用数据和调用构建一个数组<code>quicksort()</code>适当地，然后将结果格式化为单个字符串：</p>
<div class="example">
<pre class="example"># do_sort --- sort the data according to `compare'
#             and return it as a string

function do_sort(first, last, compare,      data, i, retval)
{
    delete data
    for (i = 1; first &lt;= last; first++) {
        data[i] = $first
        i++
    }

    quicksort(data, 1, i-1, compare)

    retval = data[1]
    for (i = 2; i in data; i++)
        retval = retval &quot; &quot; data[i]

    return retval
}
</pre></div>

<p>最后，两个排序函数调用<code>do_sort()</code> ，传入两个比较函数的名称：</p>
<div class="example">
<pre class="example"># sort --- sort the data in ascending order and return it as a string

function sort(first, last)
{
    return do_sort(first, last, &quot;num_lt&quot;)
}
</pre><pre class="example">

</pre><pre class="example"># rsort --- sort the data in descending order and return it as a string

function rsort(first, last)
{
    return do_sort(first, last, &quot;num_ge&quot;)
}
</pre></div>

<p>这是数据文件的扩展版本：</p>
<div class="example">
<pre class="example">Biology_101 sum average sort rsort data: 87.0 92.4 78.5 94.9
Chemistry_305 sum average sort rsort data: 75.2 98.3 94.7 88.2
English_401 sum average sort rsort data: 100.0 95.6 87.1 93.4
</pre></div>

<p>最后，这是运行增强程序时的结果：</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f quicksort.awk -f indirectcall.awk class_data2</kbd>
-| Biology 101:
-|     sum: &lt;352.8&gt;
-|     average: &lt;88.2&gt;
-|     sort: &lt;78.5 87.0 92.4 94.9&gt;
-|     rsort: &lt;94.9 92.4 87.0 78.5&gt;
-|
-| Chemistry 305:
-|     sum: &lt;356.4&gt;
-|     average: &lt;89.1&gt;
-|     sort: &lt;75.2 88.2 94.7 98.3&gt;
-|     rsort: &lt;98.3 94.7 88.2 75.2&gt;
-|
-| English 401:
-|     sum: &lt;376.1&gt;
-|     average: &lt;94.025&gt;
-|     sort: &lt;87.1 93.4 95.6 100.0&gt;
-|     rsort: &lt;100.0 95.6 93.4 87.1&gt;
</pre></div>

<p>间接函数调用有用的另一个示例可以在处理数组中找到。在<a href="Walking-Arrays.html#Walking-Arrays">遍历数组中</a>对此进行了描述。
</p>
<p>请记住，您必须提供领先的“ <samp>@</samp>在间接函数调用之前。
</p>
<p>从4.1.2版开始<code>gawk</code> ，间接函数调用也可以与内置函数和扩展函数一起使用（请参见<a href="Dynamic-Extensions.html#Dynamic-Extensions">“为<code>gawk</code></a> ）。间接调用内置函数时有一些限制，如下所示。
</p>
<ul>
<li>您不能通过间接函数调用将正则表达式常量传递给内置函数。 <a name="DOCF63" href="#FOOT63"><sup>63</sup></a>这适用于<code>sub()</code> ， <code>gsub()</code> ， <code>gensub()</code> ， <code>match()</code> ， <code>split()</code>和<code>patsplit()</code>功能。

</li><li>如果打电话<code>sub()</code>要么<code>gsub()</code> ，您只能传递两个参数，因为这些函数不寻常，因为它们会更新第三个参数。这意味着<code>$0</code>将会被更新。
</li></ul>

<p><code>gawk</code>尽最大努力使间接函数调用高效。例如，在以下情况下：</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= n; i++)
    @the_func()
</pre></div>

<p><code>gawk</code>查找实际函数以仅调用一次。
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT63" href="#DOCF63">（63）</a></h3>
<p>这可能会在将来的版本中更改。重新检查您的的版本随附的文档<code>gawk</code>看看是否有。</p>
</div>
<hr>
<div class="header">
<p>下一个： <a href="Functions-Summary.html#Functions-Summary" rel="next" accesskey="n">功能概要</a> ，上一个： <a href="User_002ddefined.html#User_002ddefined" rel="prev" accesskey="p">用户定义的</a> ，上级： <a href="Functions.html#Functions" rel="up" accesskey="u">函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>