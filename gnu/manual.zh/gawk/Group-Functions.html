<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>组函数（《 GNU Awk用户指南》）</title>

<meta name="description" content="Group Functions (The GNU Awk User’s Guide)">
<meta name="keywords" content="Group Functions (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Library-Functions.html#Library-Functions" rel="up" title="Library Functions">
<link href="Walking-Arrays.html#Walking-Arrays" rel="next" title="Walking Arrays">
<link href="Passwd-Functions.html#Passwd-Functions" rel="prev" title="Passwd Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Group-Functions"></a>
<div class="header">
<p>下一篇： <a href="Walking-Arrays.html#Walking-Arrays" rel="next" accesskey="n">数组</a> ，上一篇： <a href="Passwd-Functions.html#Passwd-Functions" rel="prev" accesskey="p">Passwd函数</a> ，上一篇： <a href="Library-Functions.html#Library-Functions" rel="up" accesskey="u">库函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Reading-the-Group-Database"></a>
<h3 class="section">10.6读取组数据库</h3>

<a name="index-libraries-of-awk-functions_002c-group-database_002c-reading"></a>
<a name="index-functions_002c-library_002c-group-database_002c-reading"></a>
<a name="index-group-database_002c-reading"></a>
<a name="index-database_002c-group_002c-reading"></a>
<a name="index-PROCINFO-array_002c-group-membership-and"></a>
<a name="index-getgrent_0028_0029-function-_0028C-library_0029"></a>
<a name="index-getgrent_0028_0029-user_002ddefined-function"></a>
<a name="index-groups_002c-information-about"></a>
<a name="index-account-information-1"></a>
<a name="index-group-file"></a>
<a name="index-files_002c-group"></a>
<p><a href="Passwd-Functions.html#Passwd-Functions">阅读用户数据库中</a>提出的许多讨论同样适用于组数据库。尽管传统上有一个众所周知的文件（ <samp>/etc/group</samp> ）以一种众所周知的格式，POSIX标准仅提供了一组C库例程（ <code><grp.h></code>和<code>getgrent()</code> ）以访问信息。即使此文件可能存在，也可能没有完整的信息。因此，与用户数据库一样，必须有一个小的C程序来生成组数据库作为其输出。
<code>grcat</code> ，一个“捕获”组数据库的C程序，如下所示：</p>
<a name="index-grcat-program"></a>
<div class="example">
<pre class="example">/*
 * grcat.c
 *
 * Generate a printable version of the group database.
 */
#include &lt;stdio.h&gt;
#include &lt;grp.h&gt;

int
main(int argc, char **argv)
{
    struct group *g;
    int i;

    while ((g = getgrent()) != NULL) {
        printf(&quot;%s:%s:%ld:&quot;, g-&gt;gr_name, g-&gt;gr_passwd,
                                     (long) g-&gt;gr_gid);
        for (i = 0; g-&gt;gr_mem[i] != NULL; i++) {
            printf(&quot;%s&quot;, g-&gt;gr_mem[i]);
</pre><pre class="example">            if (g-&gt;gr_mem[i+1] != NULL)
                putchar(',');
        }
</pre><pre class="example">        putchar('\n');
    }
    endgrent();
    return 0;
}
</pre></div>

<p>组数据库中的每一行代表一个组。这些字段用冒号分隔，代表以下信息：</p>
<dl compact>
<dt>组名</dt>
<dd><p>群组的名称。
</p>
</dd>
<dt>组密码</dt>
<dd><p>该组的加密密码。实际上，从不使用该字段。通常为空或设置为“ <samp>*</samp> '。
</p>
</dd>
<dt>组ID号</dt>
<dd><p>组的数字组ID号；名称与数字的关联在文件中必须唯一。（在某些系统上，它是C <code>long</code> ，而不是<code>int</code> 。因此，我们将其转换为<code>long</code>对于所有情况。）
</p>
</dd>
<dt>组成员列表</dt>
<dd><p>以逗号分隔的用户名列表。这些用户是该组的成员。现代Unix系统允许用户同时成为多个组的成员。如果您的系统支持，那么其中有一些要素<code>"group1"</code>通过<code>"group<var>N</var>"</code>在<code>PROCINFO</code>这些组ID号。（注意<code>PROCINFO</code>是一个<code>gawk</code>延期;请参阅<a href="Built_002din-Variables.html#Built_002din-Variables">预定义变量</a>部分。）
</p></dd>
</dl>

<p>这是运行<code>grcat</code>可能会产生：</p>
<div class="example">
<pre class="example">$ <kbd>grcat</kbd>
-| wheel:*:0:arnold
-| nogroup:*:65534:
-| daemon:*:1:
-| kmem:*:2:
-| staff:*:10:arnold,miriam,andy
-| other:*:20:
&hellip;
</pre></div>

<p>这是从组数据库获取信息的功能。有几个，以相同名称的C库函数为模型：</p>
<a name="index-getline-command_002c-_005fgr_005finit_0028_0029-user_002ddefined-function"></a>
<a name="index-_005fgr_005finit_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># group.awk --- functions for dealing with the group file

BEGIN {
    # Change to suit your system
    _gr_awklib = &quot;/usr/local/libexec/awk/&quot;
}

function _gr_init(    oldfs, oldrs, olddol0, grcat,
                             using_fw, using_fpat, n, a, i)
{
    if (_gr_inited)
        return

    oldfs = FS
    oldrs = RS
    olddol0 = $0
    using_fw = (PROCINFO[&quot;FS&quot;] == &quot;FIELDWIDTHS&quot;)
    using_fpat = (PROCINFO[&quot;FS&quot;] == &quot;FPAT&quot;)
    FS = &quot;:&quot;
    RS = &quot;\n&quot;

    grcat = _gr_awklib &quot;grcat&quot;
    while ((grcat | getline) &gt; 0) {
        if ($1 in _gr_byname)
            _gr_byname[$1] = _gr_byname[$1] &quot;,&quot; $4
        else
            _gr_byname[$1] = $0
        if ($3 in _gr_bygid)
            _gr_bygid[$3] = _gr_bygid[$3] &quot;,&quot; $4
        else
            _gr_bygid[$3] = $0

        n = split($4, a, &quot;[ \t]*,[ \t]*&quot;)
        for (i = 1; i &lt;= n; i++)
            if (a[i] in _gr_groupsbyuser)
                _gr_groupsbyuser[a[i]] = _gr_groupsbyuser[a[i]] &quot; &quot; $1
            else
                _gr_groupsbyuser[a[i]] = $1

        _gr_bycount[++_gr_count] = $0
    }
    close(grcat)
    _gr_count = 0
    _gr_inited++
    FS = oldfs
    if (using_fw)
        FIELDWIDTHS = FIELDWIDTHS
    else if (using_fpat)
        FPAT = FPAT
    RS = oldrs
    $0 = olddol0
}
</pre></div>

<p>的<code>BEGIN</code>规则将私有变量设置到目录，其中<code>grcat</code>被储存了。因为它是用来帮助<code>awk</code>库例程，我们选择将其放入<samp>/usr/local/libexec/awk</samp> 。您可能希望它位于系统上的其他目录中。
</p>
<p>这些例程遵循与用户数据库例程相同的概述（请参阅<a href="Passwd-Functions.html#Passwd-Functions">阅读用户数据库部分</a> ）。的<code><span class="nolinebreak">_gr_inited</span>
<!-- /@w --></code>变量用于确保对数据库进行的扫描不超过一次。的<code><span class="nolinebreak">_gr_init()</span>
<!-- /@w --></code>功能先保存<code>FS</code> ， <code>RS</code>和<code>$0</code> ，然后设置<code>FS</code>和<code>RS</code>扫描组信息的正确值。还请注意是否<code>FIELDWIDTHS</code>要么<code>FPAT</code>被使用，并恢复适当的场分裂机制。
</p>
<p>组信息存储在几个关联数组中。数组按组名索引（ <code><span class="nolinebreak">_gr_byname</span>
<!-- /@w --></code> ），按组ID号（ <code><span class="nolinebreak">_gr_bygid</span>
<!-- /@w --></code> ），以及在数据库中的位置（ <code><span class="nolinebreak">_gr_bycount</span>
<!-- /@w --></code> ）。还有一个由用户名索引的附加数组（ <code><span class="nolinebreak">_gr_groupsbyuser</span>
<!-- /@w --></code> ），这是每个用户所属的组的空格分隔列表。
</p>
<p>与用户数据库不同，数据库中同一组可能有多个记录。当组中有大量成员时，这很常见。一对这样的条目可能如下所示：</p>
<div class="example">
<pre class="example">tvpeople:*:101:johnny,jay,arsenio
tvpeople:*:101:david,conan,tom,joan
</pre></div>

<p>为此原因， <code>_gr_init()</code>查看是否已经看到组名或组ID号。如果是这样，用户名将简单地连接到先前的用户列表中。 <a name="DOCF74" href="#FOOT74"><sup>74</sup></a>
</p>
<p>最后， <code>_gr_init()</code>关闭通往<code>grcat</code> ，还原<code>FS</code> （和<code>FIELDWIDTHS</code>要么<code>FPAT</code> ，如有必要）， <code>RS</code>和<code>$0</code> ，初始化<code>_gr_count</code>到零（稍后使用），并使<code>_gr_inited</code>非零。
</p>
<a name="index-getgrnam_0028_0029-function-_0028C-library_0029"></a>
<p>的<code>getgrnam()</code>函数将一个组名作为其参数，如果该组存在，则将其返回。否则，它将依赖对不存在的元素的数组引用来创建以空字符串作为其值的元素：</p>
<a name="index-getgrnam_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getgrnam(group)
{
    _gr_init()
    return _gr_byname[group]
}
</pre></div>

<a name="index-getgrgid_0028_0029-function-_0028C-library_0029"></a>
<p>的<code>getgrgid()</code>功能相似；它需要一个数字组ID，并查找与该组ID相关的信息：</p>
<a name="index-getgrgid_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getgrgid(gid)
{
    _gr_init()
    return _gr_bygid[gid]
}
</pre></div>

<a name="index-getgruser_0028_0029-function-_0028C-library_0029"></a>
<p>的<code>getgruser()</code>函数没有C对应项。它使用用户名并返回以用户为成员的组的列表：</p>
<a name="index-getgruser_0028_0029-function_002c-user_002ddefined"></a>
<div class="example">
<pre class="example">function getgruser(user)
{
    _gr_init()
    return _gr_groupsbyuser[user]
}
</pre></div>

<a name="index-getgrent_0028_0029-function-_0028C-library_0029-1"></a>
<p>的<code>getgrent()</code>函数一次遍历数据库一个条目。它用<code>_gr_count</code>跟踪其在列表中的位置：</p>
<a name="index-getgrent_0028_0029-user_002ddefined-function-1"></a>
<div class="example">
<pre class="example">function getgrent()
{
    _gr_init()
    if (++_gr_count in _gr_bycount)
        return _gr_bycount[_gr_count]
</pre><pre class="example">    return &quot;&quot;
}
</pre></div>

<a name="index-endgrent_0028_0029-function-_0028C-library_0029"></a>
<p>的<code>endgrent()</code>功能重置<code>_gr_count</code>归零<code>getgrent()</code>可以重新开始：</p>
<a name="index-endgrent_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function endgrent()
{
    _gr_count = 0
}
</pre></div>

<p>与用户数据库例程一样，每个函数调用<code>_gr_init()</code>初始化数组。这样做只会增加运行的额外开销<code>grcat</code>如果使用了这些功能（相对于移动<code>_gr_init()</code>变成一个<code>BEGIN</code>规则）。
</p>
<p>大多数工作是在扫描数据库并构建各种关联数组。用户调用的功能本身非常简单，依赖于<code>awk</code>的关联数组可以工作。
</p>
<p>的<code>id</code> <a href="Id-Program.html#Id-Program">打印出用户信息中的程序</a>使用这些功能。
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT74" href="#DOCF74">（74）</a></h3>
<p>刚刚提供的代码存在一个细微的问题。假设第一次没有名字。这段代码在名称前加上逗号。它还不会检查是否存在<code>$4</code> 。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="Walking-Arrays.html#Walking-Arrays" rel="next" accesskey="n">数组</a> ，上一篇： <a href="Passwd-Functions.html#Passwd-Functions" rel="prev" accesskey="p">Passwd函数</a> ，上一篇： <a href="Library-Functions.html#Library-Functions" rel="up" accesskey="u">库函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>