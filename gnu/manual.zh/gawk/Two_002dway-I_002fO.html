<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>双向I / O（GNU Awk用户指南）</title>

<meta name="description" content="Two-way I/O (The GNU Awk User’s Guide)">
<meta name="keywords" content="Two-way I/O (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Advanced-Features.html#Advanced-Features" rel="up" title="Advanced Features">
<link href="TCP_002fIP-Networking.html#TCP_002fIP-Networking" rel="next" title="TCP/IP Networking">
<link href="Array-Sorting-Functions.html#Array-Sorting-Functions" rel="prev" title="Array Sorting Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">


</head>

<body lang="zh-Hans" >
<a name="Two_002dway-I_002fO"></a>
<div class="header">
<p>下一篇： <a href="TCP_002fIP-Networking.html#TCP_002fIP-Networking" rel="next" accesskey="n">TCP / IP网络</a> ，上一篇： <a href="Array-Sorting.html#Array-Sorting" rel="prev" accesskey="p">数组排序</a> ，上一篇： <a href="Advanced-Features.html#Advanced-Features" rel="up" accesskey="u">高级功能</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Two_002dWay-Communications-with-Another-Process"></a>
<h3 class="section">12.3与另一个进程的双向通信</h3>


<a name="index-advanced-features_002c-processes_002c-communicating-with"></a>
<a name="index-processes_002c-two_002dway-communications-with"></a>
<p>能够将数据发送到单独的程序进行处理，然后读取结果通常很有用。始终可以使用临时文件来完成此操作：</p>
<div class="example">
<pre class="example"># Write the data for processing
tempfile = (&quot;mydata.&quot; PROCINFO[&quot;pid&quot;])
while (<var>not done with data</var>)
    print <var>data</var> | (&quot;subprogram &gt; &quot; tempfile)
close(&quot;subprogram &gt; &quot; tempfile)

# Read the results, remove tempfile when done
while ((getline newdata &lt; tempfile) &gt; 0)
    <var>process</var> newdata <var>appropriately</var>
close(tempfile)
system(&quot;rm &quot; tempfile)
</pre></div>

<p>这有效，但并不优雅。除其他事项外，它要求程序必须在无法在用户之间共享的目录中运行；例如， <samp>/tmp</samp>不会这样做，因为另一个用户可能正巧使用了具有相同名称的临时文件。 <a name="DOCF86" href="#FOOT86"><sup>86</sup></a> </p>
<a name="index-coprocesses-1"></a>
<a name="index-input_002foutput_002c-two_002dway"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-3"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029-2"></a>
<a name="index-csh-utility_002c-_007c_0026-operator_002c-comparison-with"></a>
<p>但是，随着<code>gawk</code> ，则可以打开通往另一个过程<em>的双向</em>管道。第二个过程称为<em>协同</em>过程，因为它与<code>gawk</code> 。双向连接是使用“ <samp>|&</samp> '运算符（从Korn shell借来， <code>ksh</code> ）： <a name="DOCF87" href="#FOOT87"><sup>87</sup></a>
</p>
<div class="example">
<pre class="example">do {
    print <var>data</var> |&amp; &quot;subprogram&quot;
    &quot;subprogram&quot; |&amp; getline results
} while (<var>data left to process</var>)
close(&quot;subprogram&quot;)
</pre></div>

<p>第一次使用' <samp>|&</samp> '运算符， <code>gawk</code>为运行其他程序的子进程创建双向管道。创建的输出<code>print</code>要么<code>printf</code>写入程序的标准输入，并且程序的标准输出的输出可以由程序读取<code>gawk</code>程序使用<code>getline</code> 。与以'开始的流程一样<samp>|</samp>子程序可以是可以由外壳启动的任何程序或程序管道。
</p>
<p>有一些注意事项：</p>
<ul>
<li>作为里面的代码<code>gawk</code>当前站立，协过程的标准错误到达与父进程相同的位置<code>gawk</code>的标准错误出现了。无法单独读取孩子的标准错误。

</li><li> <a name="index-deadlocks"></a><a name="index-buffering_002c-input_002foutput-1"></a><a name="index-getline-command_002c-deadlock-and"></a> I / O缓冲可能是个问题。 <code>gawk</code>自动将所有输出向下冲洗到协同处理的管道。但是，如果协同进程未刷新其输出， <code>gawk</code>可能会在挂起时挂起<code>getline</code>为了读取协同处理的结果。这可能导致称为<em>死锁</em>的情况，其中每个进程都在等待另一个进程做某事。
</li></ul>

<a name="index-close_0028_0029-function_002c-two_002dway-pipes-and"></a>
<p>通过向第二个管道提供第二个参数，可以将双向管道的仅一端封闭到协同处理中。 <code>close()</code>两者的功能<code>"to"</code>要么<code>"from"</code> （请参阅“ <a href="Close-Files-And-Pipes.html#Close-Files-And-Pipes">关闭输入和输出重定向”部分</a> ）。这些字符串告诉<code>gawk</code>关闭分别向协同处理发送数据的管道的末端或从协同处理读取数据的末端。
</p>
<a name="index-sort-utility_002c-coprocesses-and"></a>
<p>这对于使用系统特别必要<code>sort</code>公用程序作为协同过程的一部分； <code>sort</code>必须先读取其<em>所有</em>输入数据，然后才能产生任何输出。的<code>sort</code>程序直到收到文件结束指示<code>gawk</code>关闭管道的写端。
</p>
<p>完成数据写入后， <code>sort</code>实用程序，您可以关闭<code>"to"</code>管道的末端，然后开始通过读取排序的数据<code>getline</code> 。例如：</p>
<div class="example">
<pre class="example">BEGIN {
    command = &quot;LC_ALL=C sort&quot;
    n = split(&quot;abcdefghijklmnopqrstuvwxyz&quot;, a, &quot;&quot;)

    for (i = n; i &gt; 0; i--)
        print a[i] |&amp; command
    close(command, &quot;to&quot;)

    while ((command |&amp; getline line) &gt; 0)
        print &quot;got&quot;, line
    close(command)
}
</pre></div>

<p>该程序以相反的顺序（每行一个）沿双向管道向下写入字母，直到<code>sort</code> 。然后关闭管道的写端，以便<code>sort</code>收到文件结束指示。这导致<code>sort</code>排序数据并将排序后的数据写回到<code>gawk</code>程序。读取完所有数据后， <code>gawk</code>终止协同进程并退出。
</p>
<p>附带说明，作业“ <samp>LC_ALL=C</samp> ' 在里面<code>sort</code>该命令可确保从中进行传统的Unix（ASCII）排序<code>sort</code> 。在这里这不是严格必需的，但是知道如何执行此操作是很好的。
</p>
<p>关闭时要小心<code>"from"</code>双向管道的末端；在这种情况下<code>gawk</code>等待子进程退出，这可能会导致程序挂起。（因此，在实践中，此特定功能比能够关闭<code>"to"</code>结束。）
</p>
<blockquote>
<p><b>注意：</b>通常，写到<code>"to"</code>已关闭的双向管道的末端，并且从管道中读取也是致命错误<code>"from"</code>已关闭的双向管道的末端。
</p>
<p>你可以设置<code>PROCINFO["<var>command</var>", "NONFATAL"]</code>使此类操作变得致命。如果这样做，则需要检查<code>ERRNO</code>每次之后<code>print</code> ， <code>printf</code> ， 要么<code>getline</code> 。有关更多信息，请参见“ <a href="Nonfatal.html#Nonfatal">启用非致命输出”</a>部分。
</p></blockquote>

<a name="index-gawk_002c-PROCINFO-array-in-2"></a>
<a name="index-PROCINFO-array_002c-communications-via-ptys-and"></a>
<p>如果系统支持伪tty（pty），则也可以使用伪tty（pty）进行双向通信，而不是管道。这是在每个命令的基础上，通过在<code>PROCINFO</code>数组（请参阅<a href="Auto_002dset.html#Auto_002dset">传达信息的内置变量</a>部分），如下所示：</p>
<div class="example">
<pre class="example">command = &quot;sort -nr&quot;           # command, save in convenience variable
PROCINFO[command, &quot;pty&quot;] = 1   # update PROCINFO
print &hellip; |&amp; command           # start two-way pipe
&hellip;
</pre></div>

<p>如果您的系统没有pty，或者所有系统的pty都在使用中， <code>gawk</code>自动退回到使用常规管道。
</p>
<p>使用pty通常可以避免前面所述的缓冲区死锁问题，但会降低性能。这是因为tty驱动程序逐行缓冲并发送数据。在具有<code>stdbuf</code> （属于<a href="https://www.gnu.org/software/coreutils/coreutils.html">GNU Coreutils软件包的</a>一部分），您可以使用该程序代替ptys。
</p>
<p>还请注意，pty不是完全透明的。某些二进制控制代码，例如<kbd>Ctrl-d</kbd>对于文件末尾，由tty驱动程序解释并且不通过。
</p>
<blockquote>
<p><b>注意：</b>最后，协同进程打开了之间<em>死锁</em>的可能性<code>gawk</code>以及在协同进程中运行的程序。如果您在读回任何数据之前将“太多”的数据发送到协处理器，则会发生这种情况。每个进程都无法写入数据，没有人可以读取他们已经写入的内容。没有解决死锁的方法。需要仔细编程并了解协同过程的行为。
</p></blockquote>

<p>下面的例子归功于Andrew Schorr，它演示了如何使用ptys来帮助处理缓冲死锁。
</p>
<p>假设<code>gawk</code>无法添加数字。您可以使用协同处理来完成。这是为此目的编写的极其简单的程序：</p>
<div class="example">
<pre class="example">$ <kbd>cat add.c</kbd>
#include &lt;stdio.h&gt; 

int 
main(void) 
{ 
    int x, y; 
    while (scanf(&quot;%d %d&quot;, &amp; x, &amp; y) == 2) 
        printf(&quot;%d\n&quot;, x + y); 
    return 0; 
} 
$ <kbd>cc -O add.c -o add</kbd>	<i>Compile the program</i>
</pre></div>

<p>然后，您可以编写极其简单的内容<code>gawk</code>通过将数字传递给协同处理来添加数字的程序：</p>
<div class="example">
<pre class="example">$ <kbd>echo 1 2 |</kbd>
&gt; <kbd>gawk -v cmd=./add '{ print |&amp; cmd; cmd |&amp; getline x; print x }'</kbd>
</pre></div>

<p>它将陷入僵局，因为<samp>add.c</samp>不能打电话给' <samp>setlinebuf(stdout)</samp> '。的<code>add</code>程序冻结。
</p>
<p>现在改为尝试：</p>
<div class="example">
<pre class="example">$ <kbd>echo 1 2 |</kbd>
&gt; <kbd>gawk -v cmd=add 'BEGIN { PROCINFO[cmd, &quot;pty&quot;] = 1 }</kbd>
&gt; <kbd>                 { print |&amp; cmd; cmd |&amp; getline x; print x }'</kbd>
-| 3 
</pre></div>

<p>通过使用pty <code>gawk</code>愚弄标准I / O库以为它具有交互式会话，因此默认为行缓冲。现在，神奇地，它起作用了！
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT86" href="#DOCF86">（86）</a></h3>
<p>迈克尔·布伦南（Michael Brennan）建议使用<code>rand()</code>生成唯一的文件名。这是有道理的；但是，临时文件仍然比双向管道更难使用。</p>
<h3><a name="FOOT87" href="#DOCF87">（87）</a></h3>
<p>这与C Shell和Bash中的同一运算符有很大不同。</p>
</div>
<hr>
<div class="header">
<p>下一篇： <a href="TCP_002fIP-Networking.html#TCP_002fIP-Networking" rel="next" accesskey="n">TCP / IP网络</a> ，上一篇： <a href="Array-Sorting.html#Array-Sorting" rel="prev" accesskey="p">数组排序</a> ，上一篇： <a href="Advanced-Features.html#Advanced-Features" rel="up" accesskey="u">高级功能</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>