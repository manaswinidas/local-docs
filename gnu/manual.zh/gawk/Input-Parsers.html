<html ><!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2019 

Free Software Foundation, Inc.



This is Edition 5.0 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.0.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>输入解析器（《 GNU Awk用户指南》）</title>

<meta name="description" content="Input Parsers (The GNU Awk User’s Guide)">
<meta name="keywords" content="Input Parsers (The GNU Awk User’s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Registration-Functions.html#Registration-Functions" rel="up" title="Registration Functions">
<link href="Output-Wrappers.html#Output-Wrappers" rel="next" title="Output Wrappers">
<link href="Extension-Version-String.html#Extension-Version-String" rel="prev" title="Extension Version String">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="zh-Hans" >
<a name="Input-Parsers"></a>
<div class="header">
<p>下一页： <a href="Output-Wrappers.html#Output-Wrappers" rel="next" accesskey="n">输出包装器</a> ，上一页： <a href="Extension-Version-String.html#Extension-Version-String" rel="prev" accesskey="p">扩展版本字符串</a> ，向上： <a href="Registration-Functions.html#Registration-Functions" rel="up" accesskey="u">注册函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<a name="Customized-Input-Parsers"></a>
<h4 class="subsubsection">17.4.5.4定制的输入解析器</h4>
<a name="index-customized-input-parser"></a>

<p>默认， <code>gawk</code>读取文本文件作为输入。它使用的值<code>RS</code>查找记录的结尾，然后使用<code>FS</code> （要么<code>FIELDWIDTHS</code>要么<code>FPAT</code> ）将其拆分为多个字段（请参见<a href="Reading-Files.html#Reading-Files">读取输入文件</a>部分）。此外，它还设置了<code>RT</code> （请参阅<a href="Built_002din-Variables.html#Built_002din-Variables">预定义变量</a>部分）。
</p>
<p>如果需要，可以提供自己的自定义输入解析器。输入解析器的工作是将记录返回到<code>gawk</code>记录处理代码，以及用于数据的值和长度的指示符<code>RT</code> （如果有）。
</p>
<p>要提供输入解析器，您必须首先提供两个函数（其中<var>XXX</var>是扩展名的前缀名称）：</p>
<dl compact>
<dt><code>awk_bool_t <var>XXX</var>_can_take_file(const awk_input_buf_t *iobuf);</code></dt>
<dd><p>该功能检查以下信息<code>iobuf</code> （我们稍后将讨论）。根据那里的信息，它决定是否将输入解析器用于此文件。如果是这样，则应返回true。否则，它应该返回false。它不应在其内更改任何状态（变量值等） <code>gawk</code> 。
</p>
</dd>
<dt><code>awk_bool_t <var>XXX</var>_take_control_of(awk_input_buf_t *iobuf);</code></dt>
<dd><p>什么时候<code>gawk</code>决定将文件的控制权交给输入解析器，它调用此函数。反过来，此功能必须填写<code>awk_input_buf_t</code>结构并确保满足某些条件。然后应该返回true。如果发生某种错误，则不应填写任何字段，并且应返回false；然后<code>gawk</code>将不使用输入解析器。详细信息将在短期内介绍。
</p></dd>
</dl>

<p>您的扩展程序应将这些功能打包到<code>awk_input_parser_t</code> ，如下所示：</p>
<div class="example">
<pre class="example">typedef struct awk_input_parser {
    const char *name;   /* name of parser */
    awk_bool_t (*can_take_file)(const awk_input_buf_t *iobuf);
    awk_bool_t (*take_control_of)(awk_input_buf_t *iobuf);
    awk_const struct awk_input_parser *awk_const next;   /* for gawk */
} awk_input_parser_t;
</pre></div>

<p>字段是：</p>
<dl compact>
<dt><code>const char *name;</code></dt>
<dd><p>输入解析器的名称。这是一个常规的C字符串。
</p>
</dd>
<dt><code>awk_bool_t (*can_take_file)(const awk_input_buf_t *iobuf);</code></dt>
<dd><p>指向您的指针<code><var>XXX</var>_can_take_file()</code>功能。
</p>
</dd>
<dt><code>awk_bool_t (*take_control_of)(awk_input_buf_t *iobuf);</code></dt>
<dd><p>指向您的指针<code><var>XXX</var>_take_control_of()</code>功能。
</p>
</dd>
<dt><code>awk_const struct input_parser *awk_const next;</code></dt>
<dd><p>供...使用<code>gawk</code> ;因此它被标记<code>awk_const</code>因此扩展名无法对其进行修改。
</p></dd>
</dl>

<p>步骤如下：</p>
<ol>
<li>创建一个<code>static awk_input_parser_t</code>变量并适当地对其进行初始化。

</li><li>扩展程序加载后，向其中注册输入解析器<code>gawk</code>使用<code>register_input_parser()</code> API函数（下面介绍）。
</li></ol>

<p>一个<code>awk_input_buf_t</code>看起来像这样：</p>
<div class="example">
<pre class="example">typedef struct awk_input {
    const char *name;       /* filename */
    int fd;                 /* file descriptor */
#define INVALID_HANDLE (-1)
    void *opaque;           /* private data for input parsers */
    int (*get_record)(char **out, struct awk_input *iobuf,
                      int *errcode, char **rt_start, size_t *rt_len,
                      const awk_fieldwidth_info_t **field_width);
    ssize_t (*read_func)();
    void (*close_func)(struct awk_input *iobuf);
    struct stat sbuf;       /* stat buf */
} awk_input_buf_t;
</pre></div>

<p>这些字段可以分为两类：至少（最初）用于<code><var>XXX</var>_can_take_file()</code> ，以及供<code><var>XXX</var>_take_control_of()</code> 。第一组字段及其用途如下：</p>
<dl compact>
<dt><code>const char *name;</code></dt>
<dd><p>文件名。
</p>
</dd>
<dt><code>int fd;</code></dt>
<dd><p>文件的文件描述符。如果<code>gawk</code>能够打开文件，然后<code>fd</code> <em>不会</em>等于<code>INVALID_HANDLE</code> 。否则，它将。
</p>
</dd>
<dt><code>struct stat sbuf;</code></dt>
<dd><p>如果文件描述符有效，则<code>gawk</code>将通过调用来填充此结构<code>fstat()</code>系统调用。
</p></dd>
</dl>

<p>的<code><var>XXX</var>_can_take_file()</code>函数应该检查这些字段并确定是否应将输入解析器用于文件。该决定可以基于<code>gawk</code>状态（扩展名先前定义并由设置的变量的值<code>awk</code>代码），文件名，文件描述符是否有效， <code>struct stat</code> ，或这些因素的任意组合。
</p>
<p>一旦<code><var>XXX</var>_can_take_file()</code>已返回true，并且<code>gawk</code>已经决定使用您的输入解析器，它会调用<code><var>XXX</var>_take_control_of()</code> 。然后，该函数将填充<code>get_record</code>字段或<code>read_func</code>中的字段<code>awk_input_buf_t</code> 。它还必须确保<code>fd</code> <em>未</em>设置为<code>INVALID_HANDLE</code> 。以下列表描述了可能由<code><var>XXX</var>_take_control_of()</code> ：</p>
<dl compact>
<dt><code>void *opaque;</code></dt>
<dd><p>这用于保存此文件的输入解析器所需的任何状态信息。它是“不透明的” <code>gawk</code> 。输入解析器不需要使用此指针。
</p>
</dd>
<dt><code>int (*get_record)(char **out,</code></dt>
<dt><code>                  struct awk_input *iobuf,</code></dt>
<dt><code>                  int *errcode,</code></dt>
<dt><code>                  char **rt_start,</code></dt>
<dt><code>                  size_t *rt_len,</code></dt>
<dt><code>                  const awk_fieldwidth_info_t **field_width);</code></dt>
<dd><p>该函数指针应指向创建输入记录的函数。所述功能是输入解析器的核心。此列表后面的文本中描述了它的行为。
</p>
</dd>
<dt><code>ssize_t (*read_func)();</code></dt>
<dd><p>该函数指针应指向与标准POSIX具有相同行为的函数<code>read()</code>系统调用。它是<code>get_record</code>指针。此列表后面的文本中也描述了它的行为。
</p>
</dd>
<dt><code>void (*close_func)(struct awk_input *iobuf);</code></dt>
<dd><p>该函数指针应指向执行“拆卸”的函数。它应该释放由<code><var>XXX</var>_take_control_of()</code> 。它还可能会关闭文件。如果这样做，则应设置<code>fd</code>到<code>INVALID_HANDLE</code> 。
</p>
<p>如果<code>fd</code>仍然不是<code>INVALID_HANDLE</code>调用此函数后， <code>gawk</code>称常规<code>close()</code>系统调用。
</p>
<p>具有“拆解”功能是可选的。如果您的输入解析器不需要它，请不要设置此字段。然后， <code>gawk</code>称常规<code>close()</code>系统对文件描述符的调用，因此它应该有效。
</p></dd>
</dl>

<p>的<code><var>XXX</var>_get_record()</code>函数完成创建输入记录的工作。参数如下：</p>
<dl compact>
<dt><code>char **out</code></dt>
<dd><p>这是指向<code>char *</code>设置为指向记录的变量。 <code>gawk</code>制作自己的数据副本，因此扩展名必须管理此存储。
</p>
</dd>
<dt><code>struct awk_input *iobuf</code></dt>
<dd><p>这是<code>awk_input_buf_t</code>用于文件。这些字段应用于读取数据（ <code>fd</code> ）以及用于管理私有国家（ <code>opaque</code> ）（如果有）。
</p>
</dd>
<dt><code>int *errcode</code></dt>
<dd><p>如果发生错误， <code>*errcode</code>应该从<code><errno.h></code> 。
</p>
</dd>
<dt><code>char **rt_start</code></dt>
<dt><code>size_t *rt_len</code></dt>
<dd><p>如果“记录终止符”的概念有意义，那么<code>*rt_start</code>应该设置为指向要用于的数据<code>RT</code>和<code>*rt_len</code>应该设置为数据的长度。除此以外， <code>*rt_len</code>应该设置为零。
<code>gawk</code>自己制作此数据的副本，因此扩展名必须管理此存储。
</p>
</dd>
<dt><code>const awk_fieldwidth_info_t **field_width</code></dt>
<dd><p>如果<code>field_width</code>不是<code>NULL</code> ， 然后<code>*field_width</code>将被初始化为<code>NULL</code> ，并且函数可以将其设置为指向提供字段宽度信息的结构，以覆盖默认的字段解析机制。请注意，此结构不会被复制<code>gawk</code> ;它必须至少持续到下一次调用<code>get_record</code>要么<code>close_func</code> 。另请注意<code>field_width</code>是<code>NULL</code>什么时候<code>getline</code>将结果分配给变量，因此不需要字段解析。如果解析器设置<code>*field_width</code> ， 然后<code>gawk</code>使用此布局来解析输入记录，然后<code>PROCINFO["FS"]</code>价值将是<code>"API"</code>在此记录处于活动状态时<code>$0</code> 。的<code>awk_fieldwidth_info_t</code>数据结构描述如下。
</p></dd>
</dl>

<p>返回值是由指向的缓冲区的长度<code>*out</code> ， 要么<code>EOF</code>如果到达文件末尾或发生错误。
</p>
<p>保证<code>errcode</code>是有效的指针，因此无需测试<code>NULL</code>值。 <code>gawk</code>套<code>*errcode</code>设置为零，因此除非发生错误，否则无需将其设置为零。
</p>
<p>如果确实发生错误，该函数应返回<code>EOF</code>并设置<code>*errcode</code>大于零的值。在这种情况下<code>*errcode</code>不等于零， <code>gawk</code>自动更新<code>ERRNO</code>基于的值的变量<code>*errcode</code> 。（通常，将“ <samp>*errcode = errno</samp> '应该做正确的事。）
</p>
<p>作为提供返回输入记录的函数的替代方法，您可以提供仅读取字节的函数，然后让<code>gawk</code>将数据解析为记录。如果这样做，则应以当前语言环境的多字节编码返回数据。这样的功能应遵循与<code>read()</code>系统调用，然后填写<code>read_func</code>指针及其地址在<code>awk_input_buf_t</code>结构体。
</p>
<p>默认， <code>gawk</code>设置<code>read_func</code>指向的指针<code>read()</code>系统调用。因此，您的扩展程序无需显式设置此字段。
</p>
<blockquote>
<p><b>注意：</b>您必须选择一种方法或另一种：返回记录的函数或返回原始数据的函数。特别是，如果您提供获取记录的功能， <code>gawk</code>将调用它，并且永远不会调用原始读取函数。
</p></blockquote>

<p><code>gawk</code>附带一个示例扩展，该扩展读取目录，并返回目录中每个条目的记录（请参阅“ <a href="Extension-Sample-Readdir.html#Extension-Sample-Readdir">读取目录”</a>一节）。您可能希望使用该代码作为编写自己的输入解析器的指南。
</p>
<p>在编写输入解析器时，您应该考虑（并记录）它应如何与之交互<code>awk</code>码。您可能希望它始终被调用，并在适当的时候生效（如<code>readdir</code>扩展名）。或者您可能希望它根据<code>awk</code>变量，作为来自的XML扩展<code>gawkextlib</code>项目不（见<a href="gawkextlib.html#gawkextlib">的<code>gawkextlib</code>专案</a> ）。在后一种情况下， <code>BEGINFILE</code>规则可以看<code>FILENAME</code>和<code>ERRNO</code>以决定是否要激活的输入解析器（见<a href="BEGINFILE_002fENDFILE.html#BEGINFILE_002fENDFILE">的<code>BEGINFILE</code>和<code>ENDFILE</code>特殊模式</a> ）。
</p>
<p>您可以使用以下功能注册输入解析器：</p>
<dl compact>
<dt><code>void register_input_parser(awk_input_parser_t *input_parser);</code></dt>
<dd><p>注册由指向的输入解析器<code>input_parser</code>与<code>gawk</code> 。
</p></dd>
</dl>

<p>如果您想覆盖给定记录的默认字段解析机制，则必须填充一个<code>awk_fieldwidth_info_t</code>结构，如下所示：</p>
<div class="example">
<pre class="example">typedef struct {
        awk_bool_t     use_chars; /* false ==&gt; use bytes */
        size_t         nf;        /* number of fields in record (NF) */
        struct awk_field_info {
                size_t skip;      /* amount to skip before field starts */
                size_t len;       /* length of field */
        } fields[1];              /* actual dimension should be nf */
} awk_fieldwidth_info_t;
</pre></div>

<p>字段是：</p>
<dl compact>
<dt><code>awk_bool_t use_chars;</code></dt>
<dd><p>设置为<code>awk_true</code>如果字段长度是根据可能的多字节字符指定的，则将其设置为<code>awk_false</code>如果长度以字节为单位。如果按字节提供值，则性能会更好。
</p>
</dd>
<dt><code>size_t nf;</code></dt>
<dd><p>将其设置为输入记录中的字段数，即<code>NF</code> 。
</p>
</dd>
<dt><code>struct awk_field_info fields[nf];</code></dt>
<dd><p>这是一个可变长度的数组，其实际尺寸应为<code>nf</code> 。对于每个字段， <code>skip</code>元素应设置为字符数或字节数，由<code>use_chars</code>标志，在此字段开始之前跳过。的<code>len</code>元素提供字段的长度。中的值<code>fields[0]</code>提供以下信息<code>$1</code> ，依此类推<code>fields[nf-1]</code>包含有关信息的元素<code>$NF</code> 。
</p></dd>
</dl>

<p>便利宏<code>awk_fieldwidth_info_size(numfields)</code>提供用于计算可变长度的适当大小<code>awk_fieldwidth_info_t</code>结构包含<code>numfields</code>领域。这可以用作<code>malloc()</code>或通过联合来静态分配空间。请参考<code>readdir_test</code>示例扩展。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Output-Wrappers.html#Output-Wrappers" rel="next" accesskey="n">输出包装器</a> ，上一篇： <a href="Extension-Version-String.html#Extension-Version-String" rel="prev" accesskey="p">扩展版本字符串</a> ，上一篇： <a href="Registration-Functions.html#Registration-Functions" rel="up" accesskey="u">注册函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Index.html#Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>