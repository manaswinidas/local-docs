<html><head></head><body lang="zh-Hans" ><!-- This file documents the GNU make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.74, last updated 21 May 2016,
of The GNU Make Manual, for GNU make version 4.2.

Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007,
2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Free Software
Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being "A GNU Manual,"
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<title>GNU make</title>

<meta name="description" content="GNU make">
<meta name="keywords" content="GNU make">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#Concept-Index" rel="index" title="Concept Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="manual.css">





<h1 class="settitle" align="center">GNU<code>make</code></h1>









<a name="SEC_Overview"></a>
<h2 class="shortcontents-heading">简短目录</h2>

<div class="shortcontents">
<ul class="no-bullet">
<li><a name="stoc-Overview-of-make" href="#toc-Overview-of-make">1概述<code>make</code></a></li>
<li><a name="stoc-An-Introduction-to-Makefiles" href="#toc-An-Introduction-to-Makefiles">2 Makefile简介</a></li>
<li><a name="stoc-Writing-Makefiles" href="#toc-Writing-Makefiles">3编写Makefile</a></li>
<li><a name="stoc-Writing-Rules" href="#toc-Writing-Rules">4写作规则</a></li>
<li><a name="stoc-Writing-Recipes-in-Rules" href="#toc-Writing-Recipes-in-Rules">5在规则中编写食谱</a></li>
<li><a name="stoc-How-to-Use-Variables" href="#toc-How-to-Use-Variables">6如何使用变量</a></li>
<li><a name="stoc-Conditional-Parts-of-Makefiles" href="#toc-Conditional-Parts-of-Makefiles">Makefile的7个条件部分</a></li>
<li><a name="stoc-Functions-for-Transforming-Text" href="#toc-Functions-for-Transforming-Text">8种文本转换功能</a></li>
<li><a name="stoc-How-to-Run-make" href="#toc-How-to-Run-make">9如何跑步<code>make</code></a></li>
<li><a name="stoc-Using-Implicit-Rules" href="#toc-Using-Implicit-Rules">10使用隐式规则</a></li>
<li><a name="stoc-Using-make-to-Update-Archive-Files" href="#toc-Using-make-to-Update-Archive-Files">11使用<code>make</code>更新存档文件</a></li>
<li><a name="stoc-Extending-GNU-make" href="#toc-Extending-GNU-make">12扩展GNU<code>make</code></a></li>
<li><a name="stoc-Integrating-GNU-make" href="#toc-Integrating-GNU-make">13集成GNU<code>make</code></a></li>
<li><a name="stoc-Features-of-GNU-make" href="#toc-Features-of-GNU-make">GNU的14个功能<code>make</code></a></li>
<li><a name="stoc-Incompatibilities-and-Missing-Features" href="#toc-Incompatibilities-and-Missing-Features">15不兼容和功能缺失</a></li>
<li><a name="stoc-Makefile-Conventions-1" href="#toc-Makefile-Conventions-1">16个Makefile约定</a></li>
<li><a name="stoc-Quick-Reference-1" href="#toc-Quick-Reference-1">附录A快速参考</a></li>
<li><a name="stoc-Errors-Generated-by-Make" href="#toc-Errors-Generated-by-Make">附录B由Make生成的错误</a></li>
<li><a name="stoc-Complex-Makefile-Example" href="#toc-Complex-Makefile-Example">附录C复杂Makefile示例</a></li>
<li><a name="stoc-Index-of-Concepts" href="#toc-Index-of-Concepts">概念索引</a></li>
<li><a name="stoc-Index-of-Functions_002c-Variables_002c-_0026-Directives" href="#toc-Index-of-Functions_002c-Variables_002c-_0026-Directives">函数，变量和指令的索引</a></li>
</ul>
</div>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">目录</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Overview-of-make" href="#Overview">1概述<code>make</code></a>
  <ul class="no-bullet">
    <li><a name="toc-How-to-Read-This-Manual" href="#Reading">1.1如何阅读本手册</a></li>
    <li><a name="toc-Problems-and-Bugs" href="#Bugs">1.2问题与错误</a></li>
  </ul></li>
  <li><a name="toc-An-Introduction-to-Makefiles" href="#Introduction">2 Makefile简介</a>
  <ul class="no-bullet">
    <li><a name="toc-What-a-Rule-Looks-Like" href="#Rule-Introduction">2.1规则看起来像什么</a></li>
    <li><a name="toc-A-Simple-Makefile" href="#Simple-Makefile">2.2一个简单的Makefile</a></li>
    <li><a name="toc-How-make-Processes-a-Makefile" href="#How-Make-Works">2.3如何<code>make</code>处理一个Makefile</a></li>
    <li><a name="toc-Variables-Make-Makefiles-Simpler" href="#Variables-Simplify">2.4变量使Makefile更简单</a></li>
    <li><a name="toc-Letting-make-Deduce-the-Recipes" href="#make-Deduces">2.5出租<code>make</code>推导食谱</a></li>
    <li><a name="toc-Another-Style-of-Makefile" href="#Combine-By-Prerequisite">2.6 Makefile的另一种样式</a></li>
    <li><a name="toc-Rules-for-Cleaning-the-Directory" href="#Cleanup">2.7清理目录规则</a></li>
  </ul></li>
  <li><a name="toc-Writing-Makefiles" href="#Makefiles">3编写Makefile</a>
  <ul class="no-bullet">
    <li><a name="toc-What-Makefiles-Contain" href="#Makefile-Contents">3.1 Makefile包含什么</a>
    <ul class="no-bullet">
      <li><a name="toc-Splitting-Long-Lines" href="#Splitting-Lines">3.1.1分割长线</a></li>
    </ul></li>
    <li><a name="toc-What-Name-to-Give-Your-Makefile" href="#Makefile-Names">3.2给您的Makefile取什么名字</a></li>
    <li><a name="toc-Including-Other-Makefiles" href="#Include">3.3包含其他Makefile</a></li>
    <li><a name="toc-The-Variable-MAKEFILES" href="#MAKEFILES-Variable">3.4变量<code>MAKEFILES</code></a></li>
    <li><a name="toc-How-Makefiles-Are-Remade" href="#Remaking-Makefiles">3.5如何重新制作Makefile</a></li>
    <li><a name="toc-Overriding-Part-of-Another-Makefile" href="#Overriding-Makefiles">3.6覆盖另一个Makefile的一部分</a></li>
    <li><a name="toc-How-make-Reads-a-Makefile" href="#Reading-Makefiles">3.7如何<code>make</code>读取一个Makefile</a></li>
    <li><a name="toc-Secondary-Expansion-1" href="#Secondary-Expansion">3.8二次扩充</a></li>
  </ul></li>
  <li><a name="toc-Writing-Rules" href="#Rules">4写作规则</a>
  <ul class="no-bullet">
    <li><a name="toc-Rule-Example-1" href="#Rule-Example">4.1规则示例</a></li>
    <li><a name="toc-Rule-Syntax-1" href="#Rule-Syntax">4.2规则语法</a></li>
    <li><a name="toc-Types-of-Prerequisites" href="#Prerequisite-Types">4.3先决条件的类型</a></li>
    <li><a name="toc-Using-Wildcard-Characters-in-File-Names" href="#Wildcards">4.4在文件名中使用通配符</a>
    <ul class="no-bullet">
      <li><a name="toc-Wildcard-Examples-1" href="#Wildcard-Examples">4.4.1通配符示例</a></li>
      <li><a name="toc-Pitfalls-of-Using-Wildcards" href="#Wildcard-Pitfall">4.4.2使用通配符的陷阱</a></li>
      <li><a name="toc-The-Function-wildcard" href="#Wildcard-Function">4.4.3功能<code>wildcard</code></a></li>
    </ul></li>
    <li><a name="toc-Searching-Directories-for-Prerequisites" href="#Directory-Search">4.5搜索目录以查找先决条件</a>
    <ul class="no-bullet">
      <li><a name="toc-VPATH_003a-Search-Path-for-All-Prerequisites" href="#General-Search">4.5.1 <code>VPATH</code> ：所有先决条件的搜索路径</a></li>
      <li><a name="toc-The-vpath-Directive" href="#Selective-Search">4.5.2 <code>vpath</code>指示</a></li>
      <li><a name="toc-How-Directory-Searches-are-Performed" href="#Search-Algorithm">4.5.3如何执行目录搜索</a></li>
      <li><a name="toc-Writing-Recipes-with-Directory-Search" href="#Recipes_002fSearch">4.5.4使用目录搜索编写食谱</a></li>
      <li><a name="toc-Directory-Search-and-Implicit-Rules" href="#Implicit_002fSearch">4.5.5目录搜索和隐式规则</a></li>
      <li><a name="toc-Directory-Search-for-Link-Libraries" href="#Libraries_002fSearch">4.5.6目录搜索链接库</a></li>
    </ul></li>
    <li><a name="toc-Phony-Targets-1" href="#Phony-Targets">4.6伪装目标</a></li>
    <li><a name="toc-Rules-without-Recipes-or-Prerequisites" href="#Force-Targets">4.7没有配方或先决条件的规则</a></li>
    <li><a name="toc-Empty-Target-Files-to-Record-Events" href="#Empty-Targets">4.8清空目标文件以记录事件</a></li>
    <li><a name="toc-Special-Built_002din-Target-Names" href="#Special-Targets">4.9特殊的内置目标名称</a></li>
    <li><a name="toc-Multiple-Targets-in-a-Rule" href="#Multiple-Targets">4.10规则中的多个目标</a></li>
    <li><a name="toc-Multiple-Rules-for-One-Target" href="#Multiple-Rules">4.11一个目标的多个规则</a></li>
    <li><a name="toc-Static-Pattern-Rules" href="#Static-Pattern">4.12静态模式规则</a>
    <ul class="no-bullet">
      <li><a name="toc-Syntax-of-Static-Pattern-Rules" href="#Static-Usage">4.12.1静态模式规则的语法</a></li>
      <li><a name="toc-Static-Pattern-Rules-versus-Implicit-Rules" href="#Static-versus-Implicit">4.12.2静态模式规则与隐式规则</a></li>
    </ul></li>
    <li><a name="toc-Double_002dColon-Rules" href="#Double_002dColon">4.13双冒号规则</a></li>
    <li><a name="toc-Generating-Prerequisites-Automatically" href="#Automatic-Prerequisites">4.14自动生成前提条件</a></li>
  </ul></li>
  <li><a name="toc-Writing-Recipes-in-Rules" href="#Recipes">5在规则中编写食谱</a>
  <ul class="no-bullet">
    <li><a name="toc-Recipe-Syntax-1" href="#Recipe-Syntax">5.1配方语法</a>
    <ul class="no-bullet">
      <li><a name="toc-Splitting-Recipe-Lines-1" href="#Splitting-Recipe-Lines">5.1.1分割配方行</a></li>
      <li><a name="toc-Using-Variables-in-Recipes" href="#Variables-in-Recipes">5.1.2在配方中使用变量</a></li>
    </ul></li>
    <li><a name="toc-Recipe-Echoing" href="#Echoing">5.2配方回显</a></li>
    <li><a name="toc-Recipe-Execution" href="#Execution">5.3配方执行</a>
    <ul class="no-bullet">
      <li><a name="toc-Using-One-Shell" href="#One-Shell">5.3.1使用一个Shell</a></li>
      <li><a name="toc-Choosing-the-Shell-1" href="#Choosing-the-Shell">5.3.2选择外壳</a></li>
    </ul></li>
    <li><a name="toc-Parallel-Execution" href="#Parallel">5.4并行执行</a>
    <ul class="no-bullet">
      <li><a name="toc-Output-During-Parallel-Execution" href="#Parallel-Output">5.4.1并行执行时的输出</a></li>
      <li><a name="toc-Input-During-Parallel-Execution" href="#Parallel-Input">5.4.2并行执行时的输入</a></li>
    </ul></li>
    <li><a name="toc-Errors-in-Recipes" href="#Errors">5.5食谱中的错误</a></li>
    <li><a name="toc-Interrupting-or-Killing-make" href="#Interrupts">5.6干扰或杀死<code>make</code></a></li>
    <li><a name="toc-Recursive-Use-of-make" href="#Recursion">5.7递归使用<code>make</code></a>
    <ul class="no-bullet">
      <li><a name="toc-How-the-MAKE-Variable-Works" href="#MAKE-Variable">5.7.1如何<code>MAKE</code>可变作品</a></li>
      <li><a name="toc-Communicating-Variables-to-a-Sub_002dmake" href="#Variables_002fRecursion">5.7.2将变量传递给子对象<code>make</code></a></li>
      <li><a name="toc-Communicating-Options-to-a-Sub_002dmake" href="#Options_002fRecursion">5.7.3将选项传达给子<code>make</code></a></li>
      <li><a name="toc-The-_002d_002dprint_002ddirectory-Option" href="#g_t_002dw-Option">5.7.4' <samp>--print-directory</samp> ' 选项</a></li>
    </ul></li>
    <li><a name="toc-Defining-Canned-Recipes" href="#Canned-Recipes">5.8定义罐头食谱</a></li>
    <li><a name="toc-Using-Empty-Recipes" href="#Empty-Recipes">5.9使用空食谱</a></li>
  </ul></li>
  <li><a name="toc-How-to-Use-Variables" href="#Using-Variables">6如何使用变量</a>
  <ul class="no-bullet">
    <li><a name="toc-Basics-of-Variable-References" href="#Reference">6.1变量引用的基础</a></li>
    <li><a name="toc-The-Two-Flavors-of-Variables" href="#Flavors">6.2变量的两种风格</a></li>
    <li><a name="toc-Advanced-Features-for-Reference-to-Variables" href="#Advanced">6.3引用变量的高级功能</a>
    <ul class="no-bullet">
      <li><a name="toc-Substitution-References" href="#Substitution-Refs">6.3.1替代参考</a></li>
      <li><a name="toc-Computed-Variable-Names" href="#Computed-Names">6.3.2计算变量名</a></li>
    </ul></li>
    <li><a name="toc-How-Variables-Get-Their-Values" href="#Values">6.4变量如何获得价值</a></li>
    <li><a name="toc-Setting-Variables" href="#Setting">6.5设定变量</a></li>
    <li><a name="toc-Appending-More-Text-to-Variables" href="#Appending">6.6在变量中添加更多文本</a></li>
    <li><a name="toc-The-override-Directive" href="#Override-Directive">6.7 <code>override</code>指示</a></li>
    <li><a name="toc-Defining-Multi_002dLine-Variables" href="#Multi_002dLine">6.8定义多行变量</a></li>
    <li><a name="toc-Undefining-Variables" href="#Undefine-Directive">6.9定义变量</a></li>
    <li><a name="toc-Variables-from-the-Environment" href="#Environment">6.10环境变量</a></li>
    <li><a name="toc-Target_002dspecific-Variable-Values" href="#Target_002dspecific">6.11特定于目标的变量值</a></li>
    <li><a name="toc-Pattern_002dspecific-Variable-Values" href="#Pattern_002dspecific">6.12模式特定的变量值</a></li>
    <li><a name="toc-Suppressing-Inheritance-1" href="#Suppressing-Inheritance">6.13抑制继承</a></li>
    <li><a name="toc-Other-Special-Variables" href="#Special-Variables">6.14其他特殊变量</a></li>
  </ul></li>
  <li><a name="toc-Conditional-Parts-of-Makefiles" href="#Conditionals">Makefile的7个条件部分</a>
  <ul class="no-bullet">
    <li><a name="toc-Example-of-a-Conditional" href="#Conditional-Example">7.1有条件的例子</a></li>
    <li><a name="toc-Syntax-of-Conditionals" href="#Conditional-Syntax">7.2条件句法</a></li>
    <li><a name="toc-Conditionals-that-Test-Flags" href="#Testing-Flags">7.3测试标志的条件</a></li>
  </ul></li>
  <li><a name="toc-Functions-for-Transforming-Text" href="#Functions">8种文本转换功能</a>
  <ul class="no-bullet">
    <li><a name="toc-Function-Call-Syntax" href="#Syntax-of-Functions">8.1函数调用语法</a></li>
    <li><a name="toc-Functions-for-String-Substitution-and-Analysis" href="#Text-Functions">8.2字符串替换和分析的功能</a></li>
    <li><a name="toc-Functions-for-File-Names" href="#File-Name-Functions">8.3文件名功能</a></li>
    <li><a name="toc-Functions-for-Conditionals" href="#Conditional-Functions">8.4条件函数</a></li>
    <li><a name="toc-The-foreach-Function" href="#Foreach-Function">8.5的<code>foreach</code>功能</a></li>
    <li><a name="toc-The-file-Function" href="#File-Function">8.6的<code>file</code>功能</a></li>
    <li><a name="toc-The-call-Function" href="#Call-Function">8.7的<code>call</code>功能</a></li>
    <li><a name="toc-The-value-Function" href="#Value-Function">8.8的<code>value</code>功能</a></li>
    <li><a name="toc-The-eval-Function" href="#Eval-Function">8.9的<code>eval</code>功能</a></li>
    <li><a name="toc-The-origin-Function" href="#Origin-Function">8.10 <code>origin</code>功能</a></li>
    <li><a name="toc-The-flavor-Function" href="#Flavor-Function">8.11 <code>flavor</code>功能</a></li>
    <li><a name="toc-Functions-That-Control-Make" href="#Make-Control-Functions">8.12控制的功能</a></li>
    <li><a name="toc-The-shell-Function" href="#Shell-Function">8.13 <code>shell</code>功能</a></li>
    <li><a name="toc-The-guile-Function" href="#Guile-Function">8.14 <code>guile</code>功能</a></li>
  </ul></li>
  <li><a name="toc-How-to-Run-make" href="#Running">9如何跑步<code>make</code></a>
  <ul class="no-bullet">
    <li><a name="toc-Arguments-to-Specify-the-Makefile" href="#Makefile-Arguments">9.1指定Makefile的参数</a></li>
    <li><a name="toc-Arguments-to-Specify-the-Goals" href="#Goals">9.2指定目标的参数</a></li>
    <li><a name="toc-Instead-of-Executing-Recipes" href="#Instead-of-Execution">9.3代替执行配方</a></li>
    <li><a name="toc-Avoiding-Recompilation-of-Some-Files" href="#Avoiding-Compilation">9.4避免重新编译某些文件</a></li>
    <li><a name="toc-Overriding-Variables" href="#Overriding">9.5覆盖变量</a></li>
    <li><a name="toc-Testing-the-Compilation-of-a-Program" href="#Testing">9.6测试程序的编译</a></li>
    <li><a name="toc-Summary-of-Options" href="#Options-Summary">9.7选项摘要</a></li>
  </ul></li>
  <li><a name="toc-Using-Implicit-Rules" href="#Implicit-Rules">10使用隐式规则</a>
  <ul class="no-bullet">
    <li><a name="toc-Using-Implicit-Rules-1" href="#Using-Implicit">10.1使用隐式规则</a></li>
    <li><a name="toc-Catalogue-of-Built_002dIn-Rules" href="#Catalogue-of-Rules">10.2内置规则目录</a></li>
    <li><a name="toc-Variables-Used-by-Implicit-Rules" href="#Implicit-Variables">10.3隐式规则使用的变量</a></li>
    <li><a name="toc-Chains-of-Implicit-Rules" href="#Chained-Rules">10.4隐式规则链</a></li>
    <li><a name="toc-Defining-and-Redefining-Pattern-Rules" href="#Pattern-Rules">10.5定义和重新定义模式规则</a>
    <ul class="no-bullet">
      <li><a name="toc-Introduction-to-Pattern-Rules" href="#Pattern-Intro">10.5.1模式规则简介</a></li>
      <li><a name="toc-Pattern-Rule-Examples" href="#Pattern-Examples">10.5.2模式规则示例</a></li>
      <li><a name="toc-Automatic-Variables-1" href="#Automatic-Variables">10.5.3自动变量</a></li>
      <li><a name="toc-How-Patterns-Match" href="#Pattern-Match">10.5.4模式如何匹配</a></li>
      <li><a name="toc-Match_002dAnything-Pattern-Rules" href="#Match_002dAnything-Rules">10.5.5任何匹配模式规则</a></li>
      <li><a name="toc-Canceling-Implicit-Rules" href="#Canceling-Rules">10.5.6取消隐式规则</a></li>
    </ul></li>
    <li><a name="toc-Defining-Last_002dResort-Default-Rules" href="#Last-Resort">10.6定义最后一个默认规则</a></li>
    <li><a name="toc-Old_002dFashioned-Suffix-Rules" href="#Suffix-Rules">10.7老式的后缀规则</a></li>
    <li><a name="toc-Implicit-Rule-Search-Algorithm" href="#Implicit-Rule-Search">10.8隐式规则搜索算法</a></li>
  </ul></li>
  <li><a name="toc-Using-make-to-Update-Archive-Files" href="#Archives">11使用<code>make</code>更新存档文件</a>
  <ul class="no-bullet">
    <li><a name="toc-Archive-Members-as-Targets" href="#Archive-Members">11.1存档成员作为目标</a></li>
    <li><a name="toc-Implicit-Rule-for-Archive-Member-Targets" href="#Archive-Update">11.2存档成员目标的隐式规则</a>
    <ul class="no-bullet">
      <li><a name="toc-Updating-Archive-Symbol-Directories" href="#Archive-Symbols">11.2.1更新档案符号目录</a></li>
    </ul></li>
    <li><a name="toc-Dangers-When-Using-Archives" href="#Archive-Pitfalls">11.3使用档案时的危险</a></li>
    <li><a name="toc-Suffix-Rules-for-Archive-Files" href="#Archive-Suffix-Rules">11.4存档文件的后缀规则</a></li>
  </ul></li>
  <li><a name="toc-Extending-GNU-make" href="#Extending-make">12扩展GNU <code>make</code></a>
  <ul class="no-bullet">
    <li><a name="toc-GNU-Guile-Integration" href="#Guile-Integration">12.1 GNU Guile集成</a>
    <ul class="no-bullet">
      <li><a name="toc-Conversion-of-Guile-Types" href="#Guile-Types">12.1.1指导类型的转换</a></li>
      <li><a name="toc-Interfaces-from-Guile-to-make" href="#Guile-Interface">12.1.2从Guile到<code>make</code></a></li>
      <li><a name="toc-Example-Using-Guile-in-make" href="#Guile-Example">12.1.3使用Guile的示例<code>make</code></a></li>
    </ul></li>
    <li><a name="toc-Loading-Dynamic-Objects" href="#Loading-Objects">12.2加载动态对象</a>
    <ul class="no-bullet">
      <li><a name="toc-The-load-Directive" href="#load-Directive">12.2.1 <code>load</code>指示</a></li>
      <li><a name="toc-How-Loaded-Objects-Are-Remade" href="#Remaking-Loaded-Objects">12.2.2如何重载已加载的对象</a></li>
      <li><a name="toc-Loaded-Object-Interface" href="#Loaded-Object-API">12.2.3加载的对象接口</a></li>
      <li><a name="toc-Example-Loaded-Object" href="#Loaded-Object-Example">12.2.4示例加载对象</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Integrating-GNU-make" href="#Integrating-make">13集成GNU <code>make</code></a>
  <ul class="no-bullet">
    <li><a name="toc-Sharing-Job-Slots-with-GNU-make" href="#Job-Slots">13.1与GNU共享作业槽<code>make</code></a>
    <ul class="no-bullet">
      <li><a name="toc-POSIX-Jobserver-Interaction" href="#POSIX-Jobserver">13.1.1 POSIX Jobserver交互</a></li>
      <li><a name="toc-Windows-Jobserver-Interaction" href="#Windows-Jobserver">13.1.2 Windows Jobserver交互</a></li>
    </ul></li>
    <li><a name="toc-Synchronized-Terminal-Output" href="#Terminal-Output">13.2同步终端输出</a></li>
  </ul></li>
  <li><a name="toc-Features-of-GNU-make" href="#Features">GNU的14个功能<code>make</code></a></li>
  <li><a name="toc-Incompatibilities-and-Missing-Features" href="#Missing">15不兼容和功能缺失</a></li>
  <li><a name="toc-Makefile-Conventions-1" href="#Makefile-Conventions">16个Makefile约定</a>
  <ul class="no-bullet">
    <li><a name="toc-General-Conventions-for-Makefiles" href="#Makefile-Basics">16.1 Makefile的一般约定</a></li>
    <li><a name="toc-Utilities-in-Makefiles-1" href="#Utilities-in-Makefiles">16.2 Makefile中的实用程序</a></li>
    <li><a name="toc-Variables-for-Specifying-Commands" href="#Command-Variables">16.3用于指定命令的变量</a></li>
    <li><a name="toc-DESTDIR_003a-Support-for-Staged-Installs" href="#DESTDIR">16.4 <code>DESTDIR</code> ：支持分阶段安装</a></li>
    <li><a name="toc-Variables-for-Installation-Directories" href="#Directory-Variables">16.5安装目录的变量</a></li>
    <li><a name="toc-Standard-Targets-for-Users" href="#Standard-Targets">16.6用户的标准目标</a></li>
    <li><a name="toc-Install-Command-Categories-1" href="#Install-Command-Categories">16.7安装命令类别</a></li>
  </ul></li>
  <li><a name="toc-Quick-Reference-1" href="#Quick-Reference">附录A快速参考</a></li>
  <li><a name="toc-Errors-Generated-by-Make" href="#Error-Messages">附录B由Make生成的错误</a></li>
  <li><a name="toc-Complex-Makefile-Example" href="#Complex-Makefile">附录C复杂Makefile示例</a>
  <ul class="no-bullet">
    <li><a name="toc-GNU-Free-Documentation-License-1" href="#GNU-Free-Documentation-License">C.1 GNU免费文档许可证</a></li>
  </ul></li>
  <li><a name="toc-Index-of-Concepts" href="#Concept-Index">概念索引</a></li>
  <li><a name="toc-Index-of-Functions_002c-Variables_002c-_0026-Directives" href="#Name-Index">函数，变量和指令的索引</a></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>下一个： <a href="#Overview" rel="next" accesskey="n">概述</a> ，上一个： <a href="dir.html#Top" rel="prev" accesskey="p">（dir）</a> ，上一个： <a href="dir.html#Top" rel="up" accesskey="u">（dir）</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-make"></a>
<h1 class="top">GNU<code>make</code></h1>

<p>该文件记录了GNU <code>make</code>实用程序，它自动确定需要重新编译大型程序的哪些部分，并发出命令对其进行重新编译。
</p>
<p>这是适用于GNU的<cite>The GNU Make Manual的</cite>版本0.74，最后更新于2016年5月21日。 <code>make</code>版本4.2。
</p>
<p>版权所有©1988、1989、1990、1991、1992、1993、1994、1995、1996、1997、1998、1999、2000、2002、2003、2004、2005、2006、2007、2008、2009、2010、2011、2012， 2013、2014、2015、2016年自由软件基金会，Inc.</p>
<blockquote>
<p>根据GNU自由文档许可版本1.3或自由软件基金会发布的任何更高版本，授予复制，分发和/或修改本文档的权限；没有不变的部分，前盖文本为“ A GNU手册”，而后盖文本为以下（a）中的内容。许可证的副本包含在标题为“ GNU自由文档许可证”的部分中。
</p>
<p>（a）FSF的“后盖文本”是：“您可以自由复制和修改本GNU手册。从FSF购买副本可以支持它开发GNU和促进软件自由。”
</p></blockquote>


<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Overview" accesskey="1">概述</a> ：</td><td>  </td><td align="left" valign="top">大致的了解<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Introduction" accesskey="2">简介</a> ：</td><td>  </td><td align="left" valign="top">简介<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Makefiles" accesskey="3">Makefile</a> ：</td><td>  </td><td align="left" valign="top">生成文件告诉<code>make</code>该怎么办。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Rules" accesskey="4">规则</a> ：</td><td>  </td><td align="left" valign="top">规则描述何时必须重新制作文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Recipes" accesskey="5">食谱</a> ：</td><td>  </td><td align="left" valign="top">食谱说明如何重新制作文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Using-Variables" accesskey="6">使用变量</a> ：</td><td>  </td><td align="left" valign="top">您可以使用变量来避免重复。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditionals" accesskey="7">条件</a> ：</td><td>  </td><td align="left" valign="top">根据变量的值使用或忽略makefile的部分。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Functions" accesskey="8">功能</a> ：</td><td>  </td><td align="left" valign="top">许多强大的文本处理方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Running" accesskey="9">调用make</a> ：</td><td>  </td><td align="left" valign="top">如何调用<code>make</code>在命令行上。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit-Rules">隐式规则</a> ：</td><td>  </td><td align="left" valign="top">根据文件名，使用隐式规则来对待许多文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archives">档案</a> ：</td><td>  </td><td align="left" valign="top">怎么样<code>make</code>可以更新图书馆档案。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Extending-make">扩展品牌</a> ：</td><td>  </td><td align="left" valign="top">使用扩展<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Integrating-make">整合品牌</a> ：</td><td>  </td><td align="left" valign="top">整合<code>make</code>与其他工具。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Features">特点</a> ：</td><td>  </td><td align="left" valign="top">功能GNU <code>make</code>胜过其他<code>make</code> s。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Missing">遗失</a> ：</td><td>  </td><td align="left" valign="top">什么GNU <code>make</code>缺乏其他<code>make</code> s。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Makefile-Conventions">Makefile约定</a> ：</td><td>  </td><td align="left" valign="top">为GNU程序编写makefile的约定。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Quick-Reference">快速参考</a> ：</td><td>  </td><td align="left" valign="top">有经验的用户的快速参考。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Error-Messages">错误消息</a> ：</td><td>  </td><td align="left" valign="top">产生的常见错误列表<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Complex-Makefile">复杂的Makefile</a> ：</td><td>  </td><td align="left" valign="top">一个简单但简单的makefile的真实示例。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><td align="left" valign="top">• <a href="#GNU-Free-Documentation-License">GNU自由文档许可证</a> ：</td><td>  </td><td align="left" valign="top">复制本手册的许可。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Concept-Index">概念索引</a> ：</td><td>  </td><td align="left" valign="top">概念索引。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Name-Index">名称索引</a> ：</td><td>  </td><td align="left" valign="top">函数，变量和指令的索引。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment"> &mdash; The Detailed Node Listing &mdash;

Overview of <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Preparing">准备</a> ：</td><td>  </td><td align="left" valign="top">准备和运行<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reading">阅读</a> ：</td><td>  </td><td align="left" valign="top">在阅读本文时。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bugs">错误</a> ：</td><td>  </td><td align="left" valign="top">问题和错误。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

An Introduction to Makefiles

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Rule-Introduction">规则介绍</a> ：</td><td>  </td><td align="left" valign="top">规则是什么样的。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Simple-Makefile">简单的Makefile</a> ：</td><td>  </td><td align="left" valign="top">一个简单的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#How-Make-Works">如何运作</a> ：</td><td>  </td><td align="left" valign="top">怎么样<code>make</code>处理该makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables-Simplify">简化变量</a> ：</td><td>  </td><td align="left" valign="top">变量使makefile更简单。
</td></tr>
<tr><td align="left" valign="top">• <a href="#make-Deduces">推论</a> ：</td><td>  </td><td align="left" valign="top">出租<code>make</code>推论食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Combine-By-Prerequisite">按先决条件组合</a> ：</td><td>  </td><td align="left" valign="top">生成文件的另一种样式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Cleanup">清理</a> ：</td><td>  </td><td align="left" valign="top">清理目录的规则。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Writing Makefiles

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Makefile-Contents">Makefile内容</a> ：</td><td>  </td><td align="left" valign="top">Makefile包含哪些内容。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Makefile-Names">Makefile名称</a> ：</td><td>  </td><td align="left" valign="top">如何命名您的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Include">包括</a> ：</td><td>  </td><td align="left" valign="top">一个makefile如何使用另一个makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#MAKEFILES-Variable">MAKEFILES变量</a> ：</td><td>  </td><td align="left" valign="top">环境可以指定额外的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Remaking-Makefiles">重新制作Makefile</a> ：</td><td>  </td><td align="left" valign="top">Makefile如何重新制作。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Overriding-Makefiles">覆盖Makefile</a> ：</td><td>  </td><td align="left" valign="top">如何用另一个makefile覆盖一个makefile的一部分。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reading-Makefiles">读取Makefile</a> ：</td><td>  </td><td align="left" valign="top">Makefile的解析方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Secondary-Expansion">二次扩充</a> ：</td><td>  </td><td align="left" valign="top">如何以及何时执行二次扩展。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

What Makefiles Contain

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Splitting-Lines">分界线</a> ：</td><td>  </td><td align="left" valign="top">在makefile文件中分割长行</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Writing Rules

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Rule-Example">规则示例</a> ：</td><td>  </td><td align="left" valign="top">举例说明。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Rule-Syntax">规则语法</a> ：</td><td>  </td><td align="left" valign="top">通用语法说明。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Prerequisite-Types">先决条件类型</a> ：</td><td>  </td><td align="left" valign="top">有两种先决条件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcards">通配符</a> ：</td><td>  </td><td align="left" valign="top">使用通配符，例如“ *”。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Directory-Search">目录搜索</a> ：</td><td>  </td><td align="left" valign="top">在其他目录中搜索源文件。
</td></tr>
<tr><td align="left" valign="top">•电话<a href="#Phony-Targets">目标</a> ：</td><td>  </td><td align="left" valign="top">使用不是真实文件名的目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Force-Targets">部队目标</a> ：</td><td>  </td><td align="left" valign="top">您可以使用没有配方或先决条件的目标来将其他目标标记为虚假。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Empty-Targets">空目标</a> ：</td><td>  </td><td align="left" valign="top">当只有日期重要且文件为空时。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Targets">特殊目标</a> ：</td><td>  </td><td align="left" valign="top">具有特殊内置含义的目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multiple-Targets">多个目标</a> ：</td><td>  </td><td align="left" valign="top">何时在规则中使用多个目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multiple-Rules">多个规则</a> ：</td><td>  </td><td align="left" valign="top">如何对同一目标使用多个规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Static-Pattern">静态模式</a> ：</td><td>  </td><td align="left" valign="top">静态模式规则适用于多个目标，并且可以根据目标名称更改先决条件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Double_002dColon">双冒号</a> ：</td><td>  </td><td align="left" valign="top">如何使用一种特殊类型的规则为一个目标允许多个独立规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Automatic-Prerequisites">自动先决条件</a> ：</td><td>  </td><td align="left" valign="top">如何自动生成源文件本身提供先决条件的规则。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Using Wildcard Characters in File Names

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Wildcard-Examples">通配符示例</a> ：</td><td>  </td><td align="left" valign="top">几个例子。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcard-Pitfall">通配符陷阱</a> ：</td><td>  </td><td align="left" valign="top">要避免的问题。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcard-Function">通配符功能</a> ：</td><td>  </td><td align="left" valign="top">如何导致通配符扩展（通常不会发生）。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Searching Directories for Prerequisites

</pre></th></tr><tr><td align="left" valign="top">• <a href="#General-Search">常规搜索</a> ：</td><td>  </td><td align="left" valign="top">指定适用于每个先决条件的搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Selective-Search">选择性搜索</a> ：</td><td>  </td><td align="left" valign="top">为指定的名称类别指定搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Search-Algorithm">搜索算法</a> ：</td><td>  </td><td align="left" valign="top">何时以及如何应用搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Recipes_002fSearch">食谱/搜索</a> ：</td><td>  </td><td align="left" valign="top">如何编写与搜索路径配合使用的配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit_002fSearch">隐式/搜索</a> ：</td><td>  </td><td align="left" valign="top">搜索路径如何影响隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Libraries_002fSearch">图书馆/搜索</a> ：</td><td>  </td><td align="left" valign="top">目录搜索链接库。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Static Pattern Rules

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Static-Usage">静态用法</a> ：</td><td>  </td><td align="left" valign="top">静态模式规则的语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Static-versus-Implicit">静态与隐式</a> ：</td><td>  </td><td align="left" valign="top">什么时候比隐含规则更好？
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Writing Recipes in Rules

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Recipe-Syntax">配方语法</a> ：</td><td>  </td><td align="left" valign="top">配方语法功能和陷阱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Echoing">回声</a> ：</td><td>  </td><td align="left" valign="top">如何控制何时回传食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Execution">执行</a> ：</td><td>  </td><td align="left" valign="top">配方如何执行。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Parallel">平行</a> ：</td><td>  </td><td align="left" valign="top">如何并行执行配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Errors">错误</a> ：</td><td>  </td><td align="left" valign="top">配方执行错误后会发生什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Interrupts">中断</a> ：</td><td>  </td><td align="left" valign="top">配方中断时会发生什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Recursion">递归</a> ：</td><td>  </td><td align="left" valign="top">调用中<code>make</code>从makefile文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Canned-Recipes">罐装食谱</a> ：</td><td>  </td><td align="left" valign="top">定义罐头食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Empty-Recipes">空食谱</a> ：</td><td>  </td><td align="left" valign="top">定义有用的，无所事事的食谱。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Recipe Syntax

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Splitting-Recipe-Lines">分割配方行</a> ：</td><td>  </td><td align="left" valign="top">打破较长的配方行以提高可读性。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables-in-Recipes">配方中的变量</a> ：</td><td>  </td><td align="left" valign="top">使用<code>make</code>配方中的变量。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Recipe Execution

</pre></th></tr><tr><td align="left" valign="top">• <a href="#One-Shell">一壳</a> ：</td><td>  </td><td align="left" valign="top">配方中所有行的一个外壳。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Choosing-the-Shell">选择外壳</a> ：</td><td>  </td><td align="left" valign="top">怎么样<code>make</code>选择用于运行配方的外壳。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Parallel Execution

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Parallel-Output">并行输出</a> ：</td><td>  </td><td align="left" valign="top">在并行执行期间处理输出</td></tr>
<tr><td align="left" valign="top">• <a href="#Parallel-Input">并行输入</a> ：</td><td>  </td><td align="left" valign="top">在并行执行期间处理输入</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Recursive Use of <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">•制作<a href="#MAKE-Variable">变量</a> ：</td><td>  </td><td align="left" valign="top">使用'的特殊效果<samp>$(MAKE)</samp> '。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables_002fRecursion">变量/递归</a> ：</td><td>  </td><td align="left" valign="top">如何将变量传达给子<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Options_002fRecursion">选项/递归</a> ：</td><td>  </td><td align="left" valign="top">如何将选项传达给子<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#g_t_002dw-Option">-w选项</a> ：</td><td>  </td><td align="left" valign="top">如何<samp>-w</samp> ' 要么 ' <samp>--print-directory</samp> '选项有助于调试递归的使用<code>make</code>命令。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

How to Use Variables

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Reference">参考</a> ：</td><td>  </td><td align="left" valign="top">如何使用变量的值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Flavors">风味</a> ：</td><td>  </td><td align="left" valign="top">变量有两种形式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Advanced">高级</a> ：</td><td>  </td><td align="left" valign="top">引用变量的高级功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Values">价值观</a> ：</td><td>  </td><td align="left" valign="top">变量获取值的所有方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Setting">设置</a> ：</td><td>  </td><td align="left" valign="top">如何在makefile中设置变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Appending">追加</a> ：</td><td>  </td><td align="left" valign="top">如何将更多文本附加到变量的旧值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Override-Directive">覆盖指令</a> ：</td><td>  </td><td align="left" valign="top">即使用户已使用命令参数设置了变量，如何在makefile中设置变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multi_002dLine">多线</a> ：</td><td>  </td><td align="left" valign="top">将变量设置为多行字符串的另一种方法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Undefine-Directive">未定义指令</a> ：</td><td>  </td><td align="left" valign="top">如何取消定义变量，使其看起来好像从未设置过。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Environment">环境</a> ：</td><td>  </td><td align="left" valign="top">变量值可能来自环境。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Target_002dspecific">针对特定目标</a> ：</td><td>  </td><td align="left" valign="top">可以根据每个目标定义变量值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern_002dspecific">特定于模式</a> ：</td><td>  </td><td align="left" valign="top">特定于目标的变量值可以应用于与模式匹配的一组目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Suppressing-Inheritance">抑制继承</a> ：</td><td>  </td><td align="left" valign="top">禁止变量的继承。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Variables">特殊变量</a> ：</td><td>  </td><td align="left" valign="top">具有特殊含义或行为的变量。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Advanced Features for Reference to Variables

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Substitution-Refs">替代裁判</a> ：</td><td>  </td><td align="left" valign="top">引用变量，并在值上替换。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Computed-Names">计算名称</a> ：</td><td>  </td><td align="left" valign="top">计算要引用的变量的名称。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Conditional Parts of Makefiles

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Conditional-Example">条件示例</a> ：</td><td>  </td><td align="left" valign="top">有条件的例子</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditional-Syntax">条件句法</a> ：</td><td>  </td><td align="left" valign="top">条件句的语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Testing-Flags">测试标志</a> ：</td><td>  </td><td align="left" valign="top">测试标志的条件。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Functions for Transforming Text

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Syntax-of-Functions">函数语法</a> ：</td><td>  </td><td align="left" valign="top">如何编写函数调用。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Text-Functions">文字功能</a> ：</td><td>  </td><td align="left" valign="top">通用文本操作功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#File-Name-Functions">文件名功能</a> ：</td><td>  </td><td align="left" valign="top">处理文件名的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditional-Functions">条件函数</a> ：</td><td>  </td><td align="left" valign="top">实现条件的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Foreach-Function">Foreach函数</a> ：</td><td>  </td><td align="left" valign="top">重复一些带有受控变化的文本。
</td></tr>
<tr><td align="left" valign="top">• <a href="#File-Function">文件功能</a> ：</td><td>  </td><td align="left" valign="top">将文本写入文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Call-Function">通话功能</a> ：</td><td>  </td><td align="left" valign="top">展开用户定义的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Value-Function">价值功能</a> ：</td><td>  </td><td align="left" valign="top">返回变量的未扩展值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Eval-Function">评估功能</a> ：</td><td>  </td><td align="left" valign="top">将参数评估为makefile语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Origin-Function">原点功能</a> ：</td><td>  </td><td align="left" valign="top">查找变量在何处获得其值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Flavor-Function">风味功能</a> ：</td><td>  </td><td align="left" valign="top">找出变量的味道。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Make-Control-Functions">使控制功能</a> ：</td><td>  </td><td align="left" valign="top">控制make运行方式的函数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Function">Shell功能</a> ：</td><td>  </td><td align="left" valign="top">替换shell命令的输出。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Function">Guile功能</a> ：</td><td>  </td><td align="left" valign="top">使用GNU Guile嵌入式脚本语言。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

How to Run <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Makefile-Arguments">Makefile参数</a> ：</td><td>  </td><td align="left" valign="top">如何指定要使用的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Goals">目标</a> ：</td><td>  </td><td align="left" valign="top">如何使用目标参数指定要使用的Makefile的哪些部分。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Instead-of-Execution">代替执行</a> ：</td><td>  </td><td align="left" valign="top">如何使用模式标志来指定对makefile中的配方执行何种操作，而不是简单地执行它们。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Avoiding-Compilation">避免编译</a> ：</td><td>  </td><td align="left" valign="top">如何避免重新编译某些文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Overriding">覆盖</a> ：</td><td>  </td><td align="left" valign="top">如何重写变量以指定备用编译器等。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Testing">测试</a> ：</td><td>  </td><td align="left" valign="top">如何解决一些错误，以测试编译。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Options-Summary">选项摘要</a> ：</td><td>  </td><td align="left" valign="top">选项摘要</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Using Implicit Rules

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Using-Implicit">使用隐式</a> ：</td><td>  </td><td align="left" valign="top">如何使用现有的隐式规则获取更新文件的配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Catalogue-of-Rules">规则目录</a> ：</td><td>  </td><td align="left" valign="top">内置规则列表。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit-Variables">隐式变量</a> ：</td><td>  </td><td align="left" valign="top">如何更改预定义规则的作用。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Chained-Rules">链接规则</a> ：</td><td>  </td><td align="left" valign="top">如何使用隐式规则链。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Rules">模式规则</a> ：</td><td>  </td><td align="left" valign="top">如何定义新的隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Last-Resort">不得已</a> ：</td><td>  </td><td align="left" valign="top">如何为找不到规则的规则定义配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Suffix-Rules">后缀规则</a> ：</td><td>  </td><td align="left" valign="top">隐式规则的老式样式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit-Rule-Search">隐式规则搜索</a> ：</td><td>  </td><td align="left" valign="top">应用隐式规则的精确算法。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Defining and Redefining Pattern Rules

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Pattern-Intro">模式简介</a> ：</td><td>  </td><td align="left" valign="top">模式规则简介。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Examples">模式示例</a> ：</td><td>  </td><td align="left" valign="top">模式规则的示例。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Automatic-Variables">自动变量</a> ：</td><td>  </td><td align="left" valign="top">如何在隐式规则的配方中使用自动变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Match">模式匹配</a> ：</td><td>  </td><td align="left" valign="top">模式如何匹配。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Match_002dAnything-Rules">比赛规则</a> ：</td><td>  </td><td align="left" valign="top">在定义可以匹配任何目标文件的规则之前，应采取的预防措施。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Canceling-Rules">取消规则</a> ：</td><td>  </td><td align="left" valign="top">如何覆盖或取消内置规则。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Using <code>make</code> to Update Archive Files

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Archive-Members">存档成员</a> ：</td><td>  </td><td align="left" valign="top">将成员存档为目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Update">存档更新</a> ：</td><td>  </td><td align="left" valign="top">归档成员目标的隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Pitfalls">存档陷阱</a> ：</td><td>  </td><td align="left" valign="top">使用档案时要当心危险。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Suffix-Rules">存档后缀规则</a> ：</td><td>  </td><td align="left" valign="top">您可以编写一种特殊的后缀规则来更新档案。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Implicit Rule for Archive Member Targets

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Archive-Symbols">存档符号</a> ：</td><td>  </td><td align="left" valign="top">如何更新档案符号目录。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Extending GNU <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Guile-Integration">Guile集成</a> ：</td><td>  </td><td align="left" valign="top">使用Guile作为嵌入式脚本语言。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loading-Objects">加载对象</a> ：</td><td>  </td><td align="left" valign="top">加载动态对象作为扩展。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

GNU Guile Integration

</pre></th></tr><tr><td align="left" valign="top">•指南<a href="#Guile-Types">类型</a> ：</td><td>  </td><td align="left" valign="top">将Guile类型转换为<code>make</code>字符串。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Interface">Guile界面</a> ：</td><td>  </td><td align="left" valign="top">调用中<code>make</code>来自Guile的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Example">Guile示例</a> ：</td><td>  </td><td align="left" valign="top">在中使用Guile的示例<code>make</code> 。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Loading Dynamic Objects

</pre></th></tr><tr><td align="left" valign="top">• <a href="#load-Directive">负载指令</a> ：</td><td>  </td><td align="left" valign="top">加载动态对象作为扩展。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Remaking-Loaded-Objects">重建加载的对象</a> ：</td><td>  </td><td align="left" valign="top">如何重载已加载的对象。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loaded-Object-API">加载的对象API</a> ：</td><td>  </td><td align="left" valign="top">加载对象的程序接口。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loaded-Object-Example">加载对象示例</a> ：</td><td>  </td><td align="left" valign="top">加载对象的示例</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Integrating GNU <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">• <a href="#Job-Slots">职位空缺</a> ：</td><td>  </td><td align="left" valign="top">与GNU共享职位<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Terminal-Output">终端输出</a> ：</td><td>  </td><td align="left" valign="top">控制输出到端子。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Sharing Job Slots with GNU <code>make</code>

</pre></th></tr><tr><td align="left" valign="top">• <a href="#POSIX-Jobserver">POSIX作业服务器</a> ：</td><td>  </td><td align="left" valign="top">在POSIX系统上使用作业服务器。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Windows-Jobserver">Windows Jobserver</a> ：</td><td>  </td><td align="left" valign="top">在Windows系统上使用jobserver。
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></tbody></table>

<hr>
<a name="Overview"></a>
<div class="header">
<p>下一个： <a href="#Introduction" rel="next" accesskey="n">简介</a> ，上一个： <a href="#Top" rel="prev" accesskey="p">顶部</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Overview-of-make"></a>
<h2 class="chapter">1概述<code>make</code></h2>

<p>的<code>make</code>实用程序会自动确定大型程序的哪些部分需要重新编译，并发出命令来重新编译它们。本手册介绍了GNU <code>make</code>由Richard Stallman和Roland McGrath实施。Paul D. Smith处理了自3.76版以来的开发。
</p>
<p>GNU <code>make</code>符合<cite>IEEE标准1003.2-1992</cite> （POSIX.2）的6.2节。
<a name="index-POSIX"></a>
<a name="index-IEEE-Standard-1003_002e2"></a>
<a name="index-standards-conformance"></a>
</p>
<p>我们的示例展示了C程序，因为它们很常见，但是您可以使用<code>make</code>可以使用shell命令运行其编译器的任何编程语言。确实， <code>make</code>不限于程序。您可以使用它来描述任何任务，其中只要其他文件发生更改，某些文件必须自动从其他文件更新。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Preparing" accesskey="1">准备</a> ：</td><td>  </td><td align="left" valign="top">准备和运行<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reading" accesskey="2">阅读</a> ：</td><td>  </td><td align="left" valign="top">在阅读本文时。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Bugs" accesskey="3">错误</a> ：</td><td>  </td><td align="left" valign="top">问题和错误。
</td></tr>
</tbody></table>

<hr>
<a name="Preparing"></a>
<div class="header">
<p>下一篇： <a href="#Reading" rel="next" accesskey="n">阅读</a> ，上一篇： <a href="#Overview" rel="prev" accesskey="p">概述</a> ，上一篇： <a href="#Overview" rel="up" accesskey="u">概述</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<h4 class="node-heading">准备中</h4>
<a name="Preparing-and-Running-Make"></a>
<h3 class="heading">准备并运行Make</h3>

<p>准备使用<code>make</code> ，您必须编写一个名为<em>makefile的文件</em> ，该<em>文件</em>描述程序中文件之间的关系并提供用于更新每个文件的命令。通常，在程序中，可执行文件是从目标文件更新的，而目标文件又是通过编译源文件制成的。
</p>
<p>一旦存在合适的makefile，则每次更改一些源文件时，都会使用以下简单的shell命令：</p>
<div class="example">
<pre class="example">make
</pre></div>

<p>足以执行所有必要的重新编译。的<code>make</code>程序使用makefile数据库和文件的最后修改时间来确定需要更新的文件。对于这些文件中的每个文件，它都会发布记录在数据库中的配方。
</p>
<p>您可以提供命令行参数来<code>make</code>以控制应重新编译哪些文件，或如何重新编译。查看<a href="#Running">如何运行<code>make</code></a> 。
</p>
<hr>
<a name="Reading"></a>
<div class="header">
<p>下一篇： <a href="#Bugs" rel="next" accesskey="n">错误</a> ，上一篇： <a href="#Preparing" rel="prev" accesskey="p">准备中</a> ，上一篇： <a href="#Overview" rel="up" accesskey="u">概述</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-to-Read-This-Manual"></a>
<h3 class="section">1.1如何阅读本手册</h3>

<p>如果您是新手<code>make</code> ，或者正在寻找一般介绍，请阅读每章的前几节，而跳过后面的几节。在每一章中，前几节包含介绍性或一般性信息，后几节包含专门性或技术性信息。第二章是“ <a href="#Introduction">Makefiles简介”</a> ，这是唯一的例外，所有这些都是简介。
</p>
<p>如果您熟悉其他<code>make</code>程序，请参阅<a href="#Features">GNU功能<code>make</code></a> ，其中列出了GNU的增强功能<code>make</code>具有和<a href="#Missing">不兼容和缺少的功能</a> ，这解释了GNU的几件事<code>make</code>缺乏别人拥有的。
</p>
<p>有关快速摘要，请参阅“ <a href="#Options-Summary">选项摘要”</a> ，“ <a href="#Quick-Reference">快速参考</a> ”和“ <a href="#Special-Targets">特殊目标”</a> 。
</p>
<hr>
<a name="Bugs"></a>
<div class="header">
<p>上一页： <a href="#Reading" rel="prev" accesskey="p">阅读</a> ，向上： <a href="#Overview" rel="up" accesskey="u">概述</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Problems-and-Bugs"></a>
<h3 class="section">1.2问题与错误</h3>
<a name="index-reporting-bugs"></a>
<a name="index-bugs_002c-reporting"></a>
<a name="index-problems-and-bugs_002c-reporting"></a>

<p>如果您对GNU有问题<code>make</code>或认为您已发现错误，请向开发人员报告；我们不能保证做任何事情，但我们很可能希望对其进行修复。
</p>
<p>在报告错误之前，请确保您确实找到了一个真正的错误。仔细地重新阅读该文档，看看它是否确实表明您可以做您想做的事情。如果不清楚您是否应该做某事，请报告。这是文档中的错误！
</p>
<p>在报告错误或尝试自己修复错误之前，请尝试将其隔离到可重现该问题的最小生成文件中。然后发送给我们makefile文件和确切的结果<code>make</code>给了您，包括任何错误或警告消息。请不要解释这些消息：最好将它们剪切并粘贴到您的报告中。生成这个小的makefile时，请确保在您的配方中不要使用任何非免费或不寻常的工具：您几乎总是可以模仿这种工具使用简单的shell命令会执行的操作。最后，请务必说明您期望发生的事情；这将有助于我们确定问题是否确实存在于文档中。
</p>
<p>遇到精确问题后，可以采用以下两种方法之一进行报告。将电子邮件发送至：</p>
<div class="example">
<pre class="example">    bug-make@gnu.org
</pre></div>

<p>或使用我们的基于Web的项目管理工具，网址为：</p>
<div class="example">
<pre class="example">    http://savannah.gnu.org/projects/make/
</pre></div>

<p>除上述信息外，请注意包含以下内容的版本号： <code>make</code>您正在使用。您可以使用以下命令获取此信息： <samp>make --version</samp> '。确保还包括您使用的计算机和操作系统的类型。获取此信息的一种方法是查看命令“ <samp>make --help</samp> '。
</p>
<hr>
<a name="Introduction"></a>
<div class="header">
<p>下一篇： <a href="#Makefiles" rel="next" accesskey="n">Makefiles</a> ，上一篇： <a href="#Overview" rel="prev" accesskey="p">概述</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="An-Introduction-to-Makefiles"></a>
<h2 class="chapter">2 Makefile简介</h2>

<p>您需要一个名为<em>makefile的文件</em>来告诉<code>make</code>该怎么办。通常，makefile会告诉<code>make</code>如何编译和链接程序。
<a name="index-makefile"></a>
</p>
<p>在本章中，我们将讨论一个简单的makefile，该文件描述了如何编译和链接由八个C源文件和三个头文件组成的文本编辑器。Makefile也可以告诉<code>make</code>在明确询问时如何运行其他命令（例如，作为清理操作删除某些文件）。要查看makefile的更复杂的示例，请参见<a href="#Complex-Makefile">Complex Makefile</a> 。
</p>
<p>什么时候<code>make</code>重新编译编辑器，必须重新编译每个更改的C源文件。如果头文件已更改，则包含头文件的每个C源文件都必须重新编译以确保安全。每次编译都会产生一个与源文件相对应的目标文件。最后，如果已重新编译任何源文件，则必须将所有目标文件（无论是新创建的还是从先前的编译中保存）都链接在一起，以生成新的可执行编辑器。
<a name="index-recompilation"></a>
<a name="index-editor"></a>
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Rule-Introduction" accesskey="1">规则介绍</a> ：</td><td>  </td><td align="left" valign="top">规则是什么样的。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Simple-Makefile" accesskey="2">简单的Makefile</a> ：</td><td>  </td><td align="left" valign="top">一个简单的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#How-Make-Works" accesskey="3">如何运作</a> ：</td><td>  </td><td align="left" valign="top">怎么样<code>make</code>处理该makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables-Simplify" accesskey="4">简化变量</a> ：</td><td>  </td><td align="left" valign="top">变量使makefile更简单。
</td></tr>
<tr><td align="left" valign="top">• <a href="#make-Deduces" accesskey="5">推论</a> ：</td><td>  </td><td align="left" valign="top">出租<code>make</code>推论食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Combine-By-Prerequisite" accesskey="6">按先决条件组合</a> ：</td><td>  </td><td align="left" valign="top">生成文件的另一种样式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Cleanup" accesskey="7">清理</a> ：</td><td>  </td><td align="left" valign="top">清理目录的规则。
</td></tr>
</tbody></table>

<hr>
<a name="Rule-Introduction"></a>
<div class="header">
<p>下一篇： <a href="#Simple-Makefile" rel="next" accesskey="n">Simple Makefile</a> ，上一篇： <a href="#Introduction" rel="prev" accesskey="p">简介</a> ，上一篇： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-a-Rule-Looks-Like"></a>
<h3 class="section">2.1规则看起来像什么</h3>
<a name="index-rule_002c-introduction-to"></a>
<a name="index-makefile-rule-parts"></a>
<a name="index-parts-of-makefile-rule"></a>

<p>一个简单的makefile由具有以下形状的“规则”组成：</p>
<a name="index-targets_002c-introduction-to"></a>
<a name="index-prerequisites_002c-introduction-to"></a>
<a name="index-recipes_002c-introduction-to"></a>
<div class="example">
<pre class="example"><var>target</var> &hellip; : <var>prerequisites</var> &hellip;
        <var>recipe</var>
        &hellip;
        &hellip;
</pre></div>

<p><em>目标</em>通常是程序生成的文件的名称。目标的示例是可执行文件或目标文件。目标也可以是要执行的操作的名称，例如“ <samp>clean</samp> '（请参阅<a href="#Phony-Targets">Phony Targets</a> ）。
</p>
<p><em>前提条件</em>是文件将用作创建目标的输入。目标通常取决于多个文件。
</p>
<a name="index-tabs-in-rules"></a>
<p><em>食谱</em>是一种行动<code>make</code>带出来。配方可能在同一行或每行都具有多个命令。<strong>请注意：</strong>您需要在每个配方行的开头添加一个制表符！这是一个模糊的地方，引起了人们的注意。如果您希望在食谱中使用制表符以外的其他字符作为前缀，则可以设置<code>.RECIPEPREFIX</code>变量以替代字符（请参见<a href="#Special-Variables">特殊变量</a> ）。
</p>
<p>通常，配方在具有先决条件的规则中，并且如果任何先决条件发生更改，则可用于创建目标文件。但是，为目标指定配方的规则不需要先决条件。例如，包含与目标“ <samp>clean</samp> '没有先决条件。
</p>
<p>然后，一条<em>规则</em>说明了如何以及何时重新制作作为特定规则目标的某些文件。 <code>make</code>根据创建或更新目标的先决条件执行配方。规则还可以解释如何以及何时执行操作。请参阅<a href="#Rules">编写规则</a> 。
</p>
<p>一个makefile可能包含除规则之外的其他文本，但是一个简单的makefile只需要包含规则。规则看起来可能比此模板中显示的要复杂，但是所有规则或多或少都适合该模式。
</p>
<hr>
<a name="Simple-Makefile"></a>
<div class="header">
<p>下一篇： <a href="#How-Make-Works" rel="next" accesskey="n">如何工作</a> ，上一篇： <a href="#Rule-Introduction" rel="prev" accesskey="p">规则介绍</a> ，上一篇： <a href="#Introduction" rel="up" accesskey="u">介绍</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="A-Simple-Makefile"></a>
<h3 class="section">2.2一个简单的Makefile</h3>
<a name="index-simple-makefile"></a>
<a name="index-makefile_002c-simple"></a>

<p>这是一个简单的makefile，描述了可执行文件称为<code>edit</code>取决于八个目标文件，而目标文件又取决于八个C源代码和三个头文件。
</p>
<p>在此示例中，所有C文件都包含<samp>defs.h</samp> ，但只有那些定义编辑命令的命令才包括<samp>command.h</samp> ，并且只有更改编辑器缓冲区的低级文件包括<samp>buffer.h</samp> 。
</p>
<div class="example">
<pre class="example">edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
</pre></div>

<p>我们使用反斜杠/换行符将每条长行分成两行；这就像使用一条长线，但更易于阅读。请参阅<a href="#Splitting-Lines">分割长线</a> 。
<a name="index-continuation-lines"></a>
<a name="index-_005c-_0028backslash_0029_002c-for-continuation-lines"></a>
<a name="index-backslash-_0028_005c_0029_002c-for-continuation-lines"></a>
<a name="index-quoting-newline_002c-in-makefile"></a>
<a name="index-newline_002c-quoting_002c-in-makefile"></a>
</p>
<p>使用此makefile创建名为的可执行文件<samp>edit</samp> ，输入：</p>
<div class="example">
<pre class="example">make
</pre></div>

<p>要使用此makefile从目录中删除可执行文件和所有目标文件，请键入：</p>
<div class="example">
<pre class="example">make clean
</pre></div>

<p>在示例makefile中，目标包括可执行文件“ <samp>edit</samp> '，以及目标文件' <samp>main.o</samp> '和' <samp>kbd.o</samp> '。前提条件是诸如“ <samp>main.c</samp> '和' <samp>defs.h</samp> '。实际上，每个“ <samp>.o</samp>文件既是目标也是前提。食谱包括“ <samp>cc <span class="nolinebreak">-c</span> main.c</samp> ' <!-- /@w -->和' <samp>cc <span class="nolinebreak">-c</span> kbd.c</samp> ' <!-- /@w --> 。
</p>
<p>当目标是文件时，如果其任何先决条件发生变化，则需要重新编译或重新链接它。此外，应首先更新本身自动生成的任何先决条件。在这个例子中<samp>edit</samp>取决于八个目标文件中的每个；目标文件<samp>main.o</samp>取决于源文件<samp>main.c</samp>并在头文件上<samp>defs.h</samp> 。
</p>
<p>可能会在包含目标和前提条件的每一行之后写上一条食谱。这些食谱说明了如何更新目标文件。制表符（或制表符指定的任何字符） <code>.RECIPEPREFIX</code>变量;请参阅<a href="#Special-Variables">特殊变量</a> ）必须出现在配方中每一行的开头，以将配方与makefile中的其他行区分开。（请记住， <code>make</code>对食谱的工作一无所知。由您决定提供可以正确更新目标文件的配方。所有<code>make</code>是在需要更新目标文件时执行您指定的配方。）
<a name="index-recipe"></a>
</p>
<p>目标 ' <samp>clean</samp> '不是文件，而只是操作的名称。由于您通常不想执行此规则中的操作，因此“ <samp>clean</samp> '不是任何其他规则的先决条件。所以， <code>make</code>除非您明确指出，否则绝不对其进行任何操作。请注意，此规则不仅不是先决条件，而且也没有任何先决条件，因此该规则的唯一目的是运行指定的配方。不引用文件而只是动作的<em>目标</em>称为<em>虚假目标</em> 。有关此类目标的信息，请参见<a href="#Phony-Targets">Phony</a>目标。请参阅<a href="#Errors">食谱中的错误</a> ，以了解引起原因的方法<code>make</code>忽略来自<code>rm</code>或任何其他命令。
<a name="index-clean-target"></a>
<a name="index-rm-_0028shell-command_0029"></a>
</p>
<hr>
<a name="How-Make-Works"></a>
<div class="header">
<p>下一篇： <a href="#Variables-Simplify" rel="next" accesskey="n">变量简化</a> ，上一篇： <a href="#Simple-Makefile" rel="prev" accesskey="p">Simple Makefile</a> ，上一篇： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-make-Processes-a-Makefile"></a>
<h3 class="section">2.3如何<code>make</code>处理一个Makefile</h3>
<a name="index-processing-a-makefile"></a>
<a name="index-makefile_002c-how-make-processes"></a>

<p>默认， <code>make</code>以第一个目标开头（不是名称以' <samp>.</samp> '）。这称为<em>默认目标</em> 。（ <em>目标</em>是<code>make</code>努力最终进行更新。您可以使用命令行（请参见“ <a href="#Goals">指定目标的参数”</a> ）或使用<code>.DEFAULT_GOAL</code>特殊变量（请参见<a href="#Special-Variables">其他特殊变量</a> ）。
<a name="index-default-goal"></a>
<a name="index-goal_002c-default"></a>
<a name="index-goal"></a>
</p>
<p>在上一部分的简单示例中，默认目标是更新可执行程序<samp>edit</samp> ;因此，我们将该规则放在首位。
</p>
<p>因此，当您发出命令时：</p>
<div class="example">
<pre class="example">make
</pre></div>

<p><code>make</code>读取当前目录中的makefile，然后开始处理第一条规则。在示例中，此规则用于重新链接<samp>edit</samp> ;但是之前<code>make</code>可以完全处理此规则，它必须处理以下文件的规则<samp>edit</samp>取决于，在这种情况下是目标文件。这些文件中的每一个都根据其自己的规则进行处理。这些规则说要更新每个“ <samp>.o</samp>文件，方法是编译其源文件。如果源文件或任何称为先决条件的头文件比目标文件更新，或者如果目标文件不存在，则必须进行重新编译。
</p>
<p>处理其他规则是因为它们的目标显示为目标的先决条件。如果目标不依赖其他规则（或它所依赖的任何东西，等等），则除非您告知，否则不会处理该规则<code>make</code>为此（使用诸如<code>make clean</code> <!-- /@w --> ）。
</p>
<p>重新编译目标文件之前， <code>make</code>考虑更新其先决条件，即源文件和头文件。这个makefile并未指定要为他们做的任何事情- <samp>.c</samp> '和' <samp>.h</samp> '文件不是任何规则的目标-因此<code>make</code>对这些文件不执行任何操作。但<code>make</code>会根据自己的规则更新自动生成的C程序，例如Bison或Yacc制作的C程序。
</p>
<p>重新编译需要的任何目标文件后， <code>make</code>决定是否重新链接<samp>edit</samp> 。如果文件必须这样做<samp>edit</samp>不存在，或者任何目标文件比它新。如果只是重新编译了目标文件，则它现在比<samp>edit</samp> ，所以<samp>edit</samp>重新链接。
<a name="index-relinking"></a>
</p>
<p>因此，如果我们更改文件<samp>insert.c</samp>并运行<code>make</code> ， <code>make</code>将编译该文件以更新<samp>insert.o</samp> ，然后链接<samp>edit</samp> 。如果我们更改文件<samp>command.h</samp>并运行<code>make</code> ， <code>make</code>将重新编译目标文件<samp>kbd.o</samp> ， <samp>command.o</samp>和<samp>files.o</samp>然后链接文件<samp>edit</samp> 。
</p>
<hr>
<a name="Variables-Simplify"></a>
<div class="header">
<p>下一页： <a href="#make-Deduces" rel="next" accesskey="n">演绎</a> ，上一篇： <a href="#How-Make-Works" rel="prev" accesskey="p">如何制作</a> ，上一篇： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Variables-Make-Makefiles-Simpler"></a>
<h3 class="section">2.4变量使Makefile更简单</h3>
<a name="index-variables"></a>
<a name="index-simplifying-with-variables"></a>

<p>在我们的示例中，我们必须在以下规则中列出所有目标文件两次<samp>edit</samp> （此处重复）：</p>
<div class="example">
<pre class="example">edit : main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
</pre></div>

<a name="index-objects"></a>
<p>这样的重复容易出错。如果将新的目标文件添加到系统，我们可能会将其添加到一个列表中而忘记了另一个。通过使用变量，我们可以消除风险并简化Makefile。<em>变量</em>允许一次定义文本字符串，以后再在多个位置进行替换（请参阅<a href="#Using-Variables">如何使用变量</a> ）。
</p>
<a name="index-OBJECTS"></a>
<a name="index-objs"></a>
<a name="index-OBJS"></a>
<a name="index-obj"></a>
<a name="index-OBJ"></a>
<p>每个makefile都有一个名为<code>objects</code> ， <code>OBJECTS</code> ， <code>objs</code> ， <code>OBJS</code> ， <code>obj</code> ， 要么<code>OBJ</code>这是所有目标文件名的列表。我们将定义这样的变量<code>objects</code>在makefile中有这样一行：</p>
<div class="example">
<pre class="example">objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
</pre></div>

<p>然后，在每个我们要放置目标文件名列表的地方，我们可以通过写' <samp>$(objects)</samp> '（请参阅<a href="#Using-Variables">如何使用变量</a> ）。
</p>
<p>这是将变量用于目标文件时完整的简单makefile的外观：</p>
<div class="example">
<pre class="example">objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
</pre></div>

<hr>
<a name="make-Deduces"></a>
<div class="header">
<p>下一篇： <a href="#Combine-By-Prerequisite" rel="next" accesskey="n">按前提组合</a> ，上一篇： <a href="#Variables-Simplify" rel="prev" accesskey="p">简化变量</a> ，上一篇： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Letting-make-Deduce-the-Recipes"></a>
<h3 class="section">2.5出租<code>make</code>推导食谱</h3>
<a name="index-deducing-recipes-_0028implicit-rules_0029"></a>
<a name="index-implicit-rule_002c-introduction-to"></a>
<a name="index-rule_002c-implicit_002c-introduction-to"></a>

<p>无需拼写出用于编译单个C源文件的配方，因为<code>make</code>可以计算出来：它有用于更新的' <em>隐式规则</em> <samp>.o</samp> “来自相应名称的文件<samp>.c</samp>使用' <samp>cc -c</samp>命令。例如，它将使用配方“ <samp>cc -c main.c -o main.o</samp> ' 编译<samp>main.c</samp>进入<samp>main.o</samp> 。因此，我们可以从目标文件的规则中省略配方。请参阅<a href="#Implicit-Rules">使用隐式规则</a> 。
</p>
<p>当一个 ' <samp>.c</samp> '文件以这种方式自动使用，它也自动添加到先决条件列表中。因此，我们可以省略“ <samp>.c</samp>前提条件中的'文件，前提是我们省略了配方。
</p>
<p>这是整个示例，其中包含所有这些更改以及一个变量<code>objects</code>如上所述：</p>
<div class="example">
<pre class="example">objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
</pre></div>

<p>这就是我们在实际实践中编写makefile的方式。（与“ <samp>clean</samp>在其他地方有描述。请参阅<a href="#Phony-Targets">Phony目标</a>和<a href="#Errors">食谱中的错误</a> 。）
</p>
<p>因为隐式规则非常方便，所以它们很重要。您将看到它们经常使用。
</p>
<hr>
<a name="Combine-By-Prerequisite"></a>
<div class="header">
<p>下一篇： <a href="#Cleanup" rel="next" accesskey="n">清理</a> ，上一篇： <a href="#make-Deduces" rel="prev" accesskey="p">演绎</a> ，上<a href="#make-Deduces" rel="prev" accesskey="p">一篇</a> ： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Another-Style-of-Makefile"></a>
<h3 class="section">2.6 Makefile的另一种样式</h3>
<a name="index-combining-rules-by-prerequisite"></a>

<p>当仅通过隐式规则创建makefile的对象时，makefile的另一种样式是可能的。在这种makefile样式中，您按条目的先决条件而不是目标将它们分组。这是一个什么样子：</p>
<div class="example">
<pre class="example">objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
</pre></div>

<p>这里<samp>defs.h</samp>作为所有目标文件的先决条件； <samp>command.h</samp>和<samp>buffer.h</samp>是为其列出的特定对象文件的先决条件。
</p>
<p>这是否更好取决于口味：它更紧凑，但是有些人不喜欢它，因为他们发现将每个目标的所有信息放在一个地方更加清楚。
</p>
<hr>
<a name="Cleanup"></a>
<div class="header">
<p>上一页： <a href="#Combine-By-Prerequisite" rel="prev" accesskey="p">前提条件合并</a> ，上一页： <a href="#Introduction" rel="up" accesskey="u">简介</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Rules-for-Cleaning-the-Directory"></a>
<h3 class="section">2.7清理目录规则</h3>
<a name="index-cleaning-up"></a>
<a name="index-removing_002c-to-clean-up"></a>

<p>编写程序并不是您可能要为其编写规则的唯一内容。Makefile通常会告诉您除编译程序外还要做些其他事情：例如，如何删除所有目标文件和可执行文件，以便目录为“ <samp>clean</samp> '。
</p>
<a name="index-clean-target-1"></a>
<p>这是我们如何写一个<code>make</code>清理示例编辑器的规则：</p>
<div class="example">
<pre class="example">clean:
        rm edit $(objects)
</pre></div>

<p>在实践中，我们可能希望以某种更复杂的方式编写规则以处理意外情况。我们可以这样做：</p>
<div class="example">
<pre class="example">.PHONY : clean
clean :
        -rm edit $(objects)
</pre></div>

<p>这样可以防止<code>make</code>不会被称为<samp>clean</samp>并导致它继续运行，尽管出现以下错误： <code>rm</code> 。（请参阅<a href="#Phony-Targets">Phony目标</a>和<a href="#Errors">食谱中的错误</a> 。）
</p>
<p>诸如此类的规则不应放在makefile的开头，因为我们不希望它默认运行！因此，在示例makefile中，我们希望<code>edit</code> ，它将重新编译编辑器，以保留默认目标。
</p>
<p>以来<code>clean</code>不是...的先决条件<code>edit</code> ，如果我们给命令“ <samp>make</samp> '，不带任何参数。为了使规则运行，我们必须输入“ <samp>make clean</samp> '。查看<a href="#Running">如何运行<code>make</code></a> 。
</p>
<hr>
<a name="Makefiles"></a>
<div class="header">
<p>下一个： <a href="#Rules" rel="next" accesskey="n">规则</a> ，上一个： <a href="#Introduction" rel="prev" accesskey="p">简介</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Writing-Makefiles"></a>
<h2 class="chapter">3编写Makefile</h2>

<a name="index-makefile_002c-how-to-write"></a>
<p>告诉的信息<code>make</code>如何重新编译系统来自读取称为<em>makefile的数据库</em> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Makefile-Contents" accesskey="1">Makefile内容</a> ：</td><td>  </td><td align="left" valign="top">Makefile包含哪些内容。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Makefile-Names" accesskey="2">Makefile名称</a> ：</td><td>  </td><td align="left" valign="top">如何命名您的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Include" accesskey="3">包括</a> ：</td><td>  </td><td align="left" valign="top">一个makefile如何使用另一个makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#MAKEFILES-Variable" accesskey="4">MAKEFILES变量</a> ：</td><td>  </td><td align="left" valign="top">环境可以指定额外的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Remaking-Makefiles" accesskey="5">重新制作Makefile</a> ：</td><td>  </td><td align="left" valign="top">Makefile如何重新制作。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Overriding-Makefiles" accesskey="6">覆盖Makefile</a> ：</td><td>  </td><td align="left" valign="top">如何用另一个makefile覆盖一个makefile的一部分。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Reading-Makefiles" accesskey="7">读取Makefile</a> ：</td><td>  </td><td align="left" valign="top">Makefile的解析方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Secondary-Expansion" accesskey="8">二次扩充</a> ：</td><td>  </td><td align="left" valign="top">如何以及何时执行二次扩展。
</td></tr>
</tbody></table>

<hr>
<a name="Makefile-Contents"></a>
<div class="header">
<p>下一个： <a href="#Makefile-Names" rel="next" accesskey="n">Makefile名称</a> ，上一个： <a href="#Makefiles" rel="prev" accesskey="p">Makefiles</a> ，上一个： <a href="#Makefiles" rel="up" accesskey="u">Makefiles</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-Makefiles-Contain"></a>
<h3 class="section">3.1 Makefile包含什么</h3>

<p>Makefile包含五种内容： <em>显式规则</em> ， <em>隐式规则</em> ， <em>变量定义</em> ， <em>指令</em>和<em>注释</em> 。规则，变量和指令将在后面的章节中详细介绍。
</p>
<ul>
<li> <a name="index-rule_002c-explicit_002c-definition-of"></a><a name="index-explicit-rule_002c-definition-of"></a> <em>明确的规则</em>说明何时以及如何重新制作一个或多个文件，称为规则的<em>目标</em> 。它列出了目标所依赖的其他文件（称为目标的<em>先决条件）</em> ，并且还提供了用于创建或更新目标的方法。请参阅<a href="#Rules">编写规则</a> 。

</li><li> <a name="index-rule_002c-implicit_002c-definition-of"></a><a name="index-implicit-rule_002c-definition-of"></a> <em>隐式规则</em>表示何时以及如何基于文件名重制一类文件。它描述了目标如何依赖名称与目标相似的文件，并给出了创建或更新此类目标的方法。请参阅<a href="#Implicit-Rules">使用隐式规则</a> 。

</li><li> <a name="index-variable-definition"></a> <em>变量定义</em>是为<em>变量</em>指定文本字符串值的行，以后可以将其替换为文本。简单的makefile示例显示了一个变量定义<code>objects</code>作为所有目标文件的列表（请参见“ <a href="#Variables-Simplify">使Makefiles更简单的变量”</a> ）。

</li><li> <a name="index-directive"></a> <em>指令</em>是针对<code>make</code>在读取makefile时做一些特殊的事情。这些包括：<ul>
<li>读取另一个生成文件（请参阅“ <a href="#Include">包括其他生成文件”</a> ）。

</li><li>（基于变量的值）确定是使用还是忽略Makefile的一部分（请参阅<a href="#Conditionals">Makefile的条件部分</a> ）。

</li><li>从包含多行的逐字字符串中定义变量（请参见<a href="#Multi_002dLine">定义多行变量</a> ）。
</li></ul>

</li><li> <a name="index-comments_002c-in-makefile"></a><a name="index-_0023-_0028comments_0029_002c-in-makefile"></a> ' <samp>#</samp>在makefile的一行中开始<em>注释</em> 。它和该行的其余部分都将被忽略，除了没有被另一个反斜杠转义的尾部反斜杠将在多行中继续注释。仅包含注释（可能在其前面有空格）的行实际上是空白的，将被忽略。如果你想要一个文字<code>#</code> ，请使用反斜杠将其转义（例如， <code>\#</code> ）。尽管在某些情况下会特别注意注释，但注释可能会出现在makefile的任何行上。

<p>您不能在变量引用或函数调用中使用注释： <code>#</code>将在变量引用或函数调用中按字面意义（而不是作为注释的开头）对待。
</p>
<p>如同其他任何配方文本一样，配方中的注释将传递到外壳。Shell决定如何解释它：这是否是注释取决于Shell。
</p>
<p>在一个<code>define</code>指令，在变量定义期间不会忽略注释，而是在变量的值中保持原样。扩展变量后，它们将被视为<code>make</code>注释或作为配方文本，具体取决于评估变量的上下文。
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Splitting-Lines" accesskey="1">分界线</a> ：</td><td>  </td><td align="left" valign="top">在makefile文件中分割长行</td></tr>
</tbody></table>

<hr>
<a name="Splitting-Lines"></a>
<div class="header">
<p>上一页： <a href="#Makefile-Contents" rel="prev" accesskey="p">Makefile目录</a> ，上： <a href="#Makefile-Contents" rel="up" accesskey="u">Makefile目录</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Splitting-Long-Lines"></a>
<h4 class="subsection">3.1.1分割长线</h4>
<a name="index-splitting-long-lines"></a>
<a name="index-long-lines_002c-splitting"></a>
<a name="index-backslash-_0028_005c_0029_002c-to-quote-newlines"></a>

<p>Makefile使用“基于行”的语法，其中换行符是特殊字符并标记语句的结尾。GNU <code>make</code>语句行的长度没有限制，最大限制为计算机中的内存量。
</p>
<p>但是，难以读取太长而无法显示或不滚动的行。因此，您可以通过在语句中间添加换行符来设置makefile的格式以提高可读性：您可以使用反斜杠将内部换行符转义（ <code>\</code> ）字符。在需要区分的地方，我们将“物理线”称为以换行符结尾的单行（无论是否被转义），而“逻辑线”则是完整的语句，包括所有已转义的换行符，直到第一个非-转义的换行符。
</p>
<p>反斜杠/换行符组合的处理方式取决于该语句是配方行还是非配方行。稍后将讨论配方行中反斜杠/换行符的处理（请参见<a href="#Splitting-Recipe-Lines">分割配方行</a> ）。
</p>
<p>在配方行之外，反斜杠/换行符将转换为单个空格字符。完成此操作后，反斜杠/换行符周围的所有空格都将被压缩为一个空格：这包括反斜杠之前的所有空格，反斜杠/换行之后的行开头的所有空格以及任何连续的反斜杠/换行符的组合。
</p>
<p>如果<code>.POSIX</code>定义了特殊目标，然后略微修改了反斜杠/换行符处理以符合POSIX.2：首先，不删除反斜杠之前的空格，其次不压缩连续的反斜杠/换行符。
</p>
<hr>
<a name="Makefile-Names"></a>
<div class="header">
<p>下一个： <a href="#Include" rel="next" accesskey="n">包括</a> ，上一个： <a href="#Makefile-Contents" rel="prev" accesskey="p">Makefile目录</a> ，上一个： <a href="#Makefiles" rel="up" accesskey="u">Makefiles</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="What-Name-to-Give-Your-Makefile"></a>
<h3 class="section">3.2给您的Makefile取什么名字</h3>
<a name="index-makefile-name"></a>
<a name="index-name-of-makefile"></a>
<a name="index-default-makefile-name"></a>
<a name="index-file-name-of-makefile"></a>

<p>默认情况下，当<code>make</code>查找makefile，然后按顺序尝试以下名称： <samp>GNUmakefile</samp> ， <samp>makefile</samp>和<samp>Makefile</samp> 。
<a name="index-Makefile"></a>
<a name="index-GNUmakefile"></a>
<a name="index-makefile-1"></a>
</p>
<a name="index-README"></a>
<p>通常您应该调用您的makefile <samp>makefile</samp>要么<samp>Makefile</samp> 。（我们推荐<samp>Makefile</samp>因为它在目录列表的开头附近显眼，而在其他重要文件（如<samp>README</samp> ）名字检查了， <samp>GNUmakefile</samp> ，不建议用于大多数makefile。如果您有一个特定于GNU的makefile，则应使用此名称。 <code>make</code> ，而其他版本的<code>make</code> 。其他<code>make</code>程序寻找<samp>makefile</samp>和<samp>Makefile</samp> ， 但不是<samp>GNUmakefile</samp> 。
</p>
<p>如果<code>make</code>找不到这些名称，它不使用任何makefile。然后，您必须使用命令参数指定目标，并且<code>make</code>将尝试找出如何仅使用其内置的隐式规则对其进行重新制作。请参阅<a href="#Implicit-Rules">使用隐式规则</a> 。
</p>
<a name="index-_002df"></a>
<a name="index-_002d_002dfile"></a>
<a name="index-_002d_002dmakefile"></a>
<p>如果要为生成文件使用非标准名称，则可以使用“ <samp>-f</samp> ' 要么 ' <samp>--file</samp> ' 选项。论据' <samp><span class="nolinebreak">-f</span> <var>name</var></samp> ' <!-- /@w -->或' <samp><span class="nolinebreak">--file=</span><var>name</var></samp> ' <!-- /@w -->告诉<code>make</code>读取文件<var>name</var>作为makefile。如果您使用多个“ <samp>-f</samp> ' 要么 ' <samp>--file</samp> '选项，您可以指定几个makefile。所有makefile均按指定的顺序有效地连接在一起。默认的makefile名称<samp>GNUmakefile</samp> ， <samp>makefile</samp>和<samp>Makefile</samp>如果您指定“不会自动检查<samp>-f</samp> ' 要么 ' <samp>--file</samp> '。
<a name="index-specifying-makefile-name"></a>
<a name="index-makefile-name_002c-how-to-specify"></a>
<a name="index-name-of-makefile_002c-how-to-specify"></a>
<a name="index-file-name-of-makefile_002c-how-to-specify"></a>
</p>
<hr>
<a name="Include"></a>
<div class="header">
<p>下一个： <a href="#MAKEFILES-Variable" rel="next" accesskey="n">MAKEFILES变量</a> ，上一个： <a href="#Makefile-Names" rel="prev" accesskey="p">Makefile名称</a> ，上一个： <a href="#Makefiles" rel="up" accesskey="u">Makefiles</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Including-Other-Makefiles"></a>
<h3 class="section">3.3包含其他Makefile</h3>
<a name="index-including-other-makefiles"></a>
<a name="index-makefile_002c-including"></a>

<a name="index-include"></a>
<p>的<code>include</code>指令告诉<code>make</code>在继续操作之前暂停读取当前的makefile并读取一个或多个其他makefile。该指令是makefile中的一行，如下所示：</p>
<div class="example">
<pre class="example">include <var>filenames</var>&hellip;
</pre></div>

<p><var>filenames</var>可以包含外壳文件名称模式。如果<var>filenames</var>为空，不包含任何内容，也不会打印错误。
<a name="index-shell-file-name-pattern-_0028in-include_0029"></a>
<a name="index-shell-wildcards-_0028in-include_0029"></a>
<a name="index-wildcard_002c-in-include"></a>
</p>
<p>在行的开头，允许多余的空格并忽略它们，但是第一个字符不能为制表符（或<code>.RECIPEPREFIX</code> ）-如果该行以制表符开头，则将其视为配方行。之间必须有空格<code>include</code>和文件名，以及文件名之间；在指令的末尾以及该指令的末尾将忽略多余的空格。以'开头的评论<samp>#</samp> '允许在行尾。如果文件名包含任何变量或函数引用，则将其展开。请参阅<a href="#Using-Variables">如何使用变量</a> 。
</p>
<p>例如，如果您有三个<samp>.mk</samp>文件， <samp>a.mk</samp> ， <samp>b.mk</samp>和<samp>c.mk</samp>和<code>$(bar)</code>扩展到<code>bish bash</code> ，则以下表达式</p>
<div class="example">
<pre class="example">include foo *.mk $(bar)
</pre></div>

<p>相当于</p>
<div class="example">
<pre class="example">include foo a.mk b.mk c.mk bish bash
</pre></div>

<p>什么时候<code>make</code>处理一个<code>include</code>指令，它将暂停读取包含的makefile并依次从每个列出的文件中读取。完成后， <code>make</code>恢复读取出现该指令的makefile。
</p>
<p>一次使用<code>include</code>指令是指几个程序，这些程序由各个目录中的各个makefile处理，需要使用一组通用的变量定义（请参阅“ <a href="#Setting">设置变量”</a> ）或模式规则（请参见“ <a href="#Pattern-Rules">定义和重新定义模式规则”</a> ）。
</p>
<p>另一个此类情况是，您想从源文件自动生成先决条件。前提条件可以放在主makefile包含的文件中。这种做法通常比以某种方式将先决条件追加到主makefile末尾的做法更为清洁，就像传统上使用其他版本的<code>make</code> 。请参阅<a href="#Automatic-Prerequisites">自动先决条件</a> 。
<a name="index-prerequisites_002c-automatic-generation"></a>
<a name="index-automatic-generation-of-prerequisites"></a>
<a name="index-generating-prerequisites-automatically"></a>
</p>
<a name="index-_002dI"></a>
<a name="index-_002d_002dinclude_002ddir"></a>
<a name="index-included-makefiles_002c-default-directories"></a>
<a name="index-default-directories-for-included-makefiles"></a>
<a name="index-_002fusr_002fgnu_002finclude"></a>
<a name="index-_002fusr_002flocal_002finclude"></a>
<a name="index-_002fusr_002finclude"></a>
<p>如果指定的名称不是以斜杠开头，并且在当前目录中找不到该文件，则会搜索其他几个目录。首先，您使用' <samp>-I</samp> ' 要么 ' <samp>--include-dir</samp>搜索'选项（请参阅“选项<a href="#Options-Summary">摘要”</a> ）。然后按以下顺序搜索以下目录（如果存在）： <samp><var>prefix</var>/include</samp> （一般<samp>/usr/local/include</samp> <a name="DOCF1" href="#FOOT1"><sup>1</sup></a> ） <samp>/usr/gnu/include</samp> ， <samp>/usr/local/include</samp> ， <samp>/usr/include</samp> 。
</p>
<p>如果在这些目录中的任何一个目录中都找不到包含的makefile，则会生成警告消息，但这不是立即致命的错误。处理包含<code>include</code>继续。完成读取makefile文件后， <code>make</code>将尝试重新制作任何过期或不存在的内容。请参阅<a href="#Remaking-Makefiles">如何重新制作Makefile</a> 。只有尝试找到重新制作makefile的方法并失败后，它才会<code>make</code>将丢失的makefile诊断为致命错误。
</p>
<p>如果你想<code>make</code>要简单地忽略不存在或无法重新制作的makefile，并且没有错误消息，请使用<code><span class="nolinebreak">-include</span></code> <!-- /@w -->指令代替<code>include</code> ， 像这样：</p>
<div class="example">
<pre class="example">-include <var>filenames</var>&hellip;
</pre></div>

<p>这就像<code>include</code>除非有任何错误，否则没有任何错误（甚至没有警告） <var>filenames</var> （或任何<var>filenames</var> ）不存在或无法重制。
</p>
<p>为了与其他一些兼容<code>make</code>实现， <code>sinclude</code>是的另一个名字<code><span class="nolinebreak">-include</span></code> <!-- /@w --> 。
</p>
<hr>
<a name="MAKEFILES-Variable"></a>
<div class="header">
<p>下一篇： <a href="#Remaking-Makefiles" rel="next" accesskey="n">重新制作Makefile</a> ，上一篇： <a href="#Include" rel="prev" accesskey="p">包含</a> ，上一篇： <a href="#Makefiles" rel="up" accesskey="u">Makefile</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Variable-MAKEFILES"></a>
<h3 class="section">3.4变量<code>MAKEFILES</code></h3>
<a name="index-makefile_002c-and-MAKEFILES-variable"></a>
<a name="index-including-_0028MAKEFILES-variable_0029"></a>

<a name="index-MAKEFILES"></a>
<p>如果环境变量<code>MAKEFILES</code>被定义为， <code>make</code>将其值视为要在其他makefile之前读取的其他makefile的名称列表（由空格分隔）。这很像<code>include</code>指令：在各个目录中搜索那些文件（请参阅<a href="#Include">包括其他Makefiles</a> ）。此外，默认目标永远不会取自这些makefile之一（或它们包含的任何makefile），并且如果目标文件中列出的文件也不是错误， <code>MAKEFILES</code>找不到。
</p>
<a name="index-recursion_002c-and-MAKEFILES-variable"></a>
<p>主要用途<code>MAKEFILES</code>在递归调用之间进行通信<code>make</code> （请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。通常不希望在顶级调用之前设置环境变量<code>make</code> ，因为通常最好不要从外部弄乱makefile。但是，如果您正在跑步<code>make</code>没有特定的makefile，在<code>MAKEFILES</code>可以做一些有用的事情来帮助内置的隐式规则更好地工作，例如定义搜索路径（请参阅<a href="#Directory-Search">Directory Search</a> ）。
</p>
<p>有些用户很想设置<code>MAKEFILES</code>在环境中自动登录，并编写makefile文件以期望完成此操作。这是一个非常糟糕的主意，因为如果其他任何人运行此类makefile，它们将无法正常工作。最好写明确的<code>include</code>生成文件中的指令。请参阅<a href="#Include">包括其他Makefile</a> 。
</p>
<hr>
<a name="Remaking-Makefiles"></a>
<div class="header">
<p>下一个： <a href="#Overriding-Makefiles" rel="next" accesskey="n">覆盖Makefile</a> ，上一个： <a href="#MAKEFILES-Variable" rel="prev" accesskey="p">MAKEFILES变量</a> ，上： <a href="#Makefiles" rel="up" accesskey="u">Makefile</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-Makefiles-Are-Remade"></a>
<h3 class="section">3.5如何重新制作Makefile</h3>
<a name="index-updating-makefiles"></a>
<a name="index-remaking-makefiles"></a>
<a name="index-makefile_002c-remaking-of"></a>
<p>有时，可以使用其他文件（例如RCS或SCCS文件）重制makefile。如果可以从其他文件重新制作一个makefile，则可能需要<code>make</code>获取要读取的最新版本的makefile。
</p>
<p>为此，在读取所有makefile文件之后， <code>make</code>会将每个目标视为目标目标并尝试对其进行更新。如果一个makefile有一条规则说明如何更新它（在那个makefile或另一个makefile中找到），或者有一个隐式规则适用于它（请参见<a href="#Implicit-Rules">使用隐式规则</a> ），则将在必要时进行更新。在检查完所有makefile之后，如果实际上已进行了更改， <code>make</code>从干净的开始，然后重新读取所有makefile。（它还将尝试再次更新它们，但通常不会再次更改它们，因为它们已经是最新的。）
</p>
<p>如果您知道一个或多个生成文件无法重建，并且想要保留<code>make</code>可能出于效率原因而对它们执行隐式规则搜索，则可以使用任何常规方法来防止隐式规则查找。例如，您可以编写一个以makefile作为目标的明确规则，并编写一个空配方（请参阅<a href="#Empty-Recipes">使用空配方</a> ）。
</p>
<p>如果makefile文件指定了双冒号规则来重制带有配方但没有先决条件的文件，则将始终重制该文件（请参见<a href="#Double_002dColon">Double-Colon</a> ）。对于makefile文件，每次都有带有配方的双冒号规则但没有先决条件的makefile会被重新制作<code>make</code>运行，然后之后<code>make</code>重新开始并再次读取makefile。这将导致无限循环： <code>make</code>会不断地重新制作makefile，而从不做任何其他事情。因此，为避免这种情况， <code>make</code> <strong>不会</strong>尝试重新制作被指定为带有配方但没有先决条件的双冒号规则目标的makefile。
</p>
<p>如果您未指定任何要使用'读取的makefile <samp>-f</samp> ' 要么 ' <samp>--file</samp> '选项， <code>make</code>将尝试默认的makefile名称；请参阅<a href="#Makefile-Names">为您的Makefile命名</a> 。与使用'显式请求的makefiles不同<samp>-f</samp> ' 要么 ' <samp>--file</samp> '选项， <code>make</code>不确定这些makefile是否应该存在。但是，如果默认的makefile不存在，但是可以通过运行来创建<code>make</code>规则，您可能希望运行规则，以便可以使用makefile。
</p>
<p>因此，如果没有默认的makefile文件， <code>make</code>会尝试按照搜索它们的顺序来排列它们（请参阅<a href="#Makefile-Names">为您的Makefile命名</a> ），直到成功制作一个，或者用尽了所有的名称为止。请注意，如果<code>make</code>无法找到或创建任何makefile； makefile并非总是必需的。
</p>
<p>当您使用“ <samp>-t</samp> ' 要么 ' <samp>--touch</samp>选项（请参阅<a href="#Instead-of-Execution">代替执行食谱</a> ），您不想使用过时的Makefile来决定要触摸的目标。所以 ' <samp>-t</samp> '选项对更新makefile没有影响；即使“ <samp>-t</samp> '已指定。同样，“ <samp>-q</samp> ' （要么 ' <samp>--question</samp> '）和' <samp>-n</samp> ' （要么 ' <samp>--just-print</samp> '）不会阻止makefile的更新，因为过时的makefile会导致其他目标输出错误。因此， <samp>make -f mfile -n foo</samp>将会更新<samp>mfile</samp> ，读入，然后打印配方进行更新<samp>foo</samp>及其先决条件，而无需运行它。印刷的食谱<samp>foo</samp>将是在更新内容中指定的<samp>mfile</samp> 。
</p>
<p>但是，有时您可能实际上甚至希望阻止更新makefile。您可以通过在命令行中将makefile指定为目标并将它们指定为makefile来实现。当将makefile名称明确指定为目标时，选项' <samp>-t</samp> '等等确实适用于他们。
</p>
<p>因此， <samp>make -f mfile -n mfile foo</samp> '将读取makefile <samp>mfile</samp> ，在没有实际运行的情况下打印更新所需的配方，然后打印更新所需的配方<samp>foo</samp>不运行它。配方<samp>foo</samp>将是由现有内容指定的<samp>mfile</samp> 。
</p>
<hr>
<a name="Overriding-Makefiles"></a>
<div class="header">
<p>下一篇： <a href="#Reading-Makefiles" rel="next" accesskey="n">阅读Makefile文件</a> ，上一篇： <a href="#Remaking-Makefiles" rel="prev" accesskey="p">重建Makefile</a> <a href="#Reading-Makefiles" rel="next" accesskey="n">文件</a> ，上一篇： <a href="#Reading-Makefiles" rel="next" accesskey="n">Makefile</a> <a href="#Makefiles" rel="up" accesskey="u">文件</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Overriding-Part-of-Another-Makefile"></a>
<h3 class="section">3.6覆盖另一个Makefile的一部分</h3>

<a name="index-overriding-makefiles"></a>
<a name="index-makefile_002c-overriding"></a>
<p>有时，拥有一个与另一个makefile几乎一样的makefile很有用。您经常可以使用“ <samp>include</samp> '指令将另一个包含在内，并添加更多目标或变量定义。但是，两个makefile为同一目标提供不同的配方是无效的。但是还有另一种方式。
</p>
<a name="index-match_002danything-rule_002c-used-to-override"></a>
<p>在包含的生成文件（一个要包含另一个的文件）中，您可以使用任何匹配模式规则来说，要重新生成无法从包含的生成文件中的信息中建立的任何目标， <code>make</code>应该查看另一个makefile。有关<a href="#Pattern-Rules">模式规则</a>的更多信息，请参见<a href="#Pattern-Rules">模式</a>规则。
</p>
<p>例如，如果您有一个名为<samp>Makefile</samp>这说明了如何使目标“ <samp>foo</samp> '（和其他目标），您可以编写一个名为<samp>GNUmakefile</samp>包含：</p>
<div class="example">
<pre class="example">foo:
        frobnicate &gt; foo

%: force
        @$(MAKE) -f Makefile $@
force: ;
</pre></div>

<p>如果你说 ' <samp>make foo</samp> '， <code>make</code>会发现<samp>GNUmakefile</samp> ，阅读它，然后看做<samp>foo</samp> ，则需要运行配方“ <samp>frobnicate > foo</samp> '。如果你说 ' <samp>make bar</samp> '， <code>make</code>将找不到办法<samp>bar</samp>在<samp>GNUmakefile</samp> ，因此它将使用模式规则中的配方： <samp>make -f Makefile bar</samp> '。如果<samp>Makefile</samp>提供更新规则<samp>bar</samp> ， <code>make</code>将应用规则。同样对于任何其他目标<samp>GNUmakefile</samp>没有说怎么做。
</p>
<p>运作方式是模式规则的模式只有' <samp>%</samp> '，因此可以匹配任何目标。该规则指定了先决条件<samp>force</samp> ，以确保即使目标文件已经存在，配方也将运行。我们给<samp>force</samp>针对空食谱以防止<code>make</code>从搜索隐式规则来构建它-否则它将对所有内容应用相同的match-anything规则<samp>force</samp>本身，并创建一个前提循环！
</p>
<hr>
<a name="Reading-Makefiles"></a>
<div class="header">
<p>下一篇： <a href="#Secondary-Expansion" rel="next" accesskey="n">二级扩展</a> ，上一篇： <a href="#Overriding-Makefiles" rel="prev" accesskey="p">覆盖Makefile</a> ，上一篇： <a href="#Makefiles" rel="up" accesskey="u">Makefile</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-make-Reads-a-Makefile"></a>
<h3 class="section">3.7如何<code>make</code>读取一个Makefile</h3>
<a name="index-reading-makefiles"></a>
<a name="index-makefile_002c-parsing"></a>

<p>GNU <code>make</code>在两个不同的阶段进行工作。在第一个阶段，它读取所有makefile，包括的makefile等，并内化所有变量及其值，隐式和显式规则，并构造所有目标及其先决条件的依赖图。在第二阶段<code>make</code>使用这些内部结构来确定需要重建哪些目标并调用必要的规则。
</p>
<p>了解这种两阶段方法很重要，因为它直接影响变量和函数扩展的发生方式。编写makefile时，这通常会引起一些混乱。在这里，我们将概述makefile中不同结构进行扩展的阶段。我们说，如果在第一阶段发生扩展，则<em>立即生效</em> ：在这种情况下<code>make</code>将在解析makefile时扩展构造的该部分中的所有变量或函数。我们说如果不立即执行扩展，则<em>推迟</em>扩展。直到稍后在即时上下文中出现该构造或直到第二阶段，才执行延迟构造的扩展。
</p>
<p>您可能还不熟悉其中的某些构造。在以后的章节中，您可以参考本节内容。
</p>
<a name="Variable-Assignment"></a>
<h4 class="subheading">变量分配</h4>
<a name="index-_002b_003d_002c-expansion"></a>
<a name="index-_003d_002c-expansion"></a>
<a name="index-_003f_003d_002c-expansion"></a>
<a name="index-_002b_003d_002c-expansion-1"></a>
<a name="index-_0021_003d_002c-expansion"></a>
<a name="index-define_002c-expansion"></a>

<p>变量定义分析如下：</p>
<div class="example">
<pre class="example"><var>immediate</var> = <var>deferred</var>
<var>immediate</var> ?= <var>deferred</var>
<var>immediate</var> := <var>immediate</var>
<var>immediate</var> ::= <var>immediate</var>
<var>immediate</var> += <var>deferred</var> or <var>immediate</var>
<var>immediate</var> != <var>immediate</var>

define <var>immediate</var>
  <var>deferred</var>
endef

define <var>immediate</var> =
  <var>deferred</var>
endef

define <var>immediate</var> ?=
  <var>deferred</var>
endef

define <var>immediate</var> :=
  <var>immediate</var>
endef

define <var>immediate</var> ::=
  <var>immediate</var>
endef

define <var>immediate</var> +=
  <var>deferred</var> or <var>immediate</var>
endef

define <var>immediate</var> !=
  <var>immediate</var>
endef
</pre></div>

<p>对于追加操作符，“ <samp>+=</samp> '，如果先前已将变量设置为简单变量（' <samp>:=</samp> ' 要么 ' <samp>::=</samp> '），否则推迟。
</p>
<p>对于外壳程序赋值运算符，“ <samp>!=</samp> '，将立即评估右侧并将其移交给外壳。结果存储在左侧命名的变量中，该变量变为简单变量（因此将在每个引用上重新进行评估）。
</p>
<a name="Conditional-Directives"></a>
<h4 class="subheading">条件指令</h4>
<a name="index-ifdef_002c-expansion"></a>
<a name="index-ifeq_002c-expansion"></a>
<a name="index-ifndef_002c-expansion"></a>
<a name="index-ifneq_002c-expansion"></a>

<p>条件指令会立即进行解析。例如，这意味着不能在条件指令中使用自动变量，因为在调用该规则的配方之前不会设置自动变量。如果需要在条件指令中使用自动变量，则<em>必须</em>将条件移至配方中，而应使用shell条件语法。
</p>
<a name="Rule-Definition"></a>
<h4 class="subheading">规则定义</h4>
<a name="index-target_002c-expansion"></a>
<a name="index-prerequisite_002c-expansion"></a>
<a name="index-implicit-rule_002c-expansion"></a>
<a name="index-pattern-rule_002c-expansion"></a>
<a name="index-explicit-rule_002c-expansion"></a>

<p>无论采用哪种形式，规则总是以相同的方式扩展：</p>
<div class="example">
<pre class="example"><var>immediate</var> : <var>immediate</var> ; <var>deferred</var>
        <var>deferred</var>
</pre></div>

<p>也就是说，目标和先决条件部分将立即展开，并且始终延迟用于构造目标的方法。该通用规则适用于显式规则，模式规则，后缀规则，静态模式规则和简单的先决条件定义。
</p>
<hr>
<a name="Secondary-Expansion"></a>
<div class="header">
<p>上一页： <a href="#Reading-Makefiles" rel="prev" accesskey="p">读取Makefile</a> ，向上： <a href="#Makefiles" rel="up" accesskey="u">Makefile</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Secondary-Expansion-1"></a>
<h3 class="section">3.8二次扩充</h3>
<a name="index-secondary-expansion"></a>
<a name="index-expansion_002c-secondary"></a>

<a name="index-_002eSECONDEXPANSION"></a>
<p>在上一节中，我们了解到GNU <code>make</code>在两个不同的阶段工作：读入阶段和目标更新阶段（请参阅<a href="#Reading-Makefiles">如何<code>make</code>读取Makefile</a> ）。GNU make还具有为makefile中定义的某些或所有目标启用前提条件的<em>第二次扩展</em>的能力。为了进行第二次扩展，特殊目标<code>.SECONDEXPANSION</code>必须在使用此功能的第一个必备列表之前定义。
</p>
<p>如果该特殊目标是在两两相之间定义，那么上面提到的，在右侧的读入阶段，特殊目标之后定义的目标的所有先决条件被扩展的<em>第二时间</em>结束。在大多数情况下，这种二次扩展将不起作用，因为所有的变量和函数引用都将在makefile的初始解析过程中进行扩展。为了利用解析器的二次扩展阶段，必须在makefile中<em>转义</em>变量或函数引用。在这种情况下，第一个扩展只会取消转义引用，而不会扩展它，扩展会留给第二个扩展阶段。例如，考虑以下makefile：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:
ONEVAR = onefile
TWOVAR = twofile
myfile: $(ONEVAR) $$(TWOVAR)
</pre></div>

<p>在第一个扩展阶段之后， <samp>myfile</samp>目标将是<code>onefile</code>和<code>$(TWOVAR)</code> ;第一个（未转义的）变量引用<var>ONEVAR</var>展开，而第二个（转义的）变量引用只是不转义，而不被识别为变量引用。现在，在二次扩展过程中，第一个单词再次被扩展，但是由于它不包含任何变量或函数引用，因此它仍然是值<samp>onefile</samp> ，而第二个单词现在是对该变量的常规引用<var>TWOVAR</var> ，将其扩展为值<samp>twofile</samp> 。最终结果是有两个先决条件， <samp>onefile</samp>和<samp>twofile</samp> 。
</p>
<p>显然，这不是一个非常有趣的情况，因为只需将两个变量都显示在先决条件列表中，就可以轻松地获得相同的结果。如果将变量重置，则显而易见的是一种差异。考虑这个例子：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:
AVAR = top
onefile: $(AVAR)
twofile: $$(AVAR)
AVAR = bottom
</pre></div>

<p>这里的前提条件<samp>onefile</samp>将立即展开，并解析为该值<samp>top</samp> ，而前提是<samp>twofile</samp>在进行二次扩展并产生值之前，不会完全扩展<samp>bottom</samp> 。
</p>
<p>这在某种程度上更加令人兴奋，但是只有当您发现该目标的自动变量范围内总是发生二次扩展时，此功能的真正力量才变得显而易见。这意味着您可以使用诸如<code>$@</code> ， <code>$*</code>等在第二次扩展中，它们将具有其期望值，就像在配方中一样。您要做的就是通过转义来延迟扩展<code>$</code> 。同样，显式和隐式（模式）规则都会发生二次扩展。知道这一点，此功能的可能用途就大大增加了。例如：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:
main_OBJS := main.o try.o test.o
lib_OBJS := lib.o api.o

main lib: $$($$@_OBJS)
</pre></div>

<p>在此，初始扩展后，两个<samp>main</samp>和<samp>lib</samp>目标将是<code>$($@_OBJS)</code> 。在二次扩展期间， <code>$@</code>变量设置为目标的名称，因此扩展为<samp>main</samp>目标会产生<code>$(main_OBJS)</code> ， 要么<code>main.o try.o test.o</code> ，而对于<samp>lib</samp>目标会产生<code>$(lib_OBJS)</code> ， 要么<code>lib.o api.o</code> 。
</p>
<p>您也可以在这里混合使用函数，只要它们可以正确地转义即可：</p>
<div class="example">
<pre class="example">main_SRCS := main.c try.c test.c
lib_SRCS := lib.c api.c

.SECONDEXPANSION:
main lib: $$(patsubst %.c,%.o,$$($$@_SRCS))
</pre></div>

<p>此版本允许用户指定源文件而不是目标文件，但提供的结果先决条件列表与前面的示例相同。
</p>
<p>在二级扩展阶段评估自动变量，尤其是目标名称变量<code>$$@</code> ，其行为类似于配方中的评估。但是，对于不同类型的规则定义，有一些细微的差异和“关键案例”起作用<code>make</code>了解。下面介绍了使用不同自动变量的精妙之处。
</p>
<a name="Secondary-Expansion-of-Explicit-Rules"></a>
<h4 class="subheading">显式规则的二次扩展</h4>
<a name="index-secondary-expansion-and-explicit-rules"></a>
<a name="index-explicit-rules_002c-secondary-expansion-of"></a>

<p>在显式规则的二次扩展期间， <code>$$@</code>和<code>$$%</code>分别评估目标文件名和目标文件名（如果目标是存档成员）。的<code>$$<</code>变量计算得出该目标的第一个规则中的第一个前提条件。 <code>$$^</code>和<code>$$+</code>评估<em>已</em>针对同一目标<em>出现</em>的所有规则的先决条件列表（ <code>$$+</code>重复和<code>$$^</code>没有）。下面的示例将帮助说明这些行为：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:

foo: foo.1 bar.1 $$&lt; $$^ $$+    # line #1

foo: foo.2 bar.2 $$&lt; $$^ $$+    # line #2

foo: foo.3 bar.3 $$&lt; $$^ $$+    # line #3
</pre></div>

<p>在第一个先决条件列表中，所有三个变量（ <code>$$<</code> ， <code>$$^</code>和<code>$$+</code> ）扩展为空字符串。在第二个中，他们将具有价值<code>foo.1</code> ， <code>foo.1 bar.1</code>和<code>foo.1 bar.1</code>分别。第三，他们将有价值观<code>foo.1</code> ， <code>foo.1 bar.1 foo.2 bar.2</code>和<code>foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1</code>分别。
</p>
<p>规则按makefile顺序进行二次扩展，除了带有配方的规则总是在最后评估。
</p>
<p>变量<code>$$?</code>和<code>$$*</code>不可用，并扩展到空字符串。
</p>
<a name="Secondary-Expansion-of-Static-Pattern-Rules"></a>
<h4 class="subheading">静态模式规则的二次扩展</h4>
<a name="index-secondary-expansion-and-static-pattern-rules"></a>
<a name="index-static-pattern-rules_002c-secondary-expansion-of"></a>

<p>静态模式规则的二次扩展规则与上述显式规则的规则相同，但有一个例外：对于静态模式规则， <code>$$*</code>变量设置为模式词干。与明确的规则一样， <code>$$?</code>不可用，并扩展为空字符串。
</p>
<a name="Secondary-Expansion-of-Implicit-Rules"></a>
<h4 class="subheading">隐式规则的二次扩展</h4>
<a name="index-secondary-expansion-and-implicit-rules"></a>
<a name="index-implicit-rules_002c-secondary-expansion-of"></a>

<p>如<code>make</code>搜索隐式规则，它将替换词干，然后对具有匹配目标模式的每个规则执行二次扩展。自动变量的值以与静态模式规则相同的方式导出。举个例子：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:

foo: bar

foo foz: fo%: bo%

%oo: $$&lt; $$^ $$+ $$*
</pre></div>

<p>为目标尝试隐式规则时<samp>foo</samp> ， <code>$$<</code>扩展到<samp>bar</samp> ， <code>$$^</code>扩展到<samp>bar boo</samp> ， <code>$$+</code>也扩展到<samp>bar boo</samp>和<code>$$*</code>扩展到<samp>f</samp> 。
</p>
<p>请注意，如<a href="#Implicit-Rule-Search">隐式规则搜索算法中</a>所述，目录前缀（D）被附加（扩展后）到先决条件列表中的所有模式。举个例子：</p>
<div class="example">
<pre class="example">.SECONDEXPANSION:

/tmp/foo.o:

%.o: $$(addsuffix /%.c,foo bar) foo.h
        @echo $^
</pre></div>

<p>在二次扩展和目录前缀重建之后，打印的先决条件列表将是<samp>/tmp/foo/foo.c /tmp/bar/foo.c foo.h</samp> 。如果您对此重构不感兴趣，则可以使用<code>$$*</code>代替<code>%</code>在先决条件列表中。
</p>
<hr>
<a name="Rules"></a>
<div class="header">
<p>下一个： <a href="#Recipes" rel="next" accesskey="n">食谱</a> ，上一个： <a href="#Makefiles" rel="prev" accesskey="p">Makefiles</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Writing-Rules"></a>
<h2 class="chapter">4写作规则</h2>
<a name="index-writing-rules"></a>
<a name="index-rule_002c-how-to-write"></a>
<a name="index-target"></a>
<a name="index-prerequisite"></a>

<p><em>规则</em>出现在生成文件中，并说明何时以及如何重新生成某些文件，称为规则的<em>目标</em> （通常每个规则只有一个）。它列出了作为目标<em>先决条件</em>的其他文件，以及用于创建或更新目标的<em>配方</em> 。
</p>
<a name="index-default-goal-1"></a>
<a name="index-goal_002c-default-1"></a>
<p>规则的顺序并不重要，除了确定<em>默认目标</em> ： <code>make</code>如果没有另外指定，请考虑。默认目标是第一个生成文件中第一个规则的目标。如果第一个规则有多个目标，则仅第一个目标被用作默认目标。有两个例外：以句点开头的目标不是默认值，除非它包含一个或多个斜杠，“ <samp>/</samp> '，以及并且，定义模式规则的目标对默认目标无效。（请参阅<a href="#Pattern-Rules">定义和重新定义模式规则</a> 。）
</p>
<p>因此，我们通常将makefile编写为使第一个规则是用于编译整个程序或makefile描述的所有程序的规则（通常使用名为“ <samp>all</samp> '）。请参阅<a href="#Goals">指定目标的参数</a> 。</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Rule-Example" accesskey="1">规则示例</a> ：</td><td>  </td><td align="left" valign="top">举例说明。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Rule-Syntax" accesskey="2">规则语法</a> ：</td><td>  </td><td align="left" valign="top">通用语法说明。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Prerequisite-Types" accesskey="3">先决条件类型</a> ：</td><td>  </td><td align="left" valign="top">有两种先决条件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcards" accesskey="4">通配符</a> ：</td><td>  </td><td align="left" valign="top">使用通配符，例如“ *”。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Directory-Search" accesskey="5">目录搜索</a> ：</td><td>  </td><td align="left" valign="top">在其他目录中搜索源文件。
</td></tr>
<tr><td align="left" valign="top">•电话<a href="#Phony-Targets" accesskey="6">目标</a> ：</td><td>  </td><td align="left" valign="top">使用不是真实文件名的目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Force-Targets" accesskey="7">部队目标</a> ：</td><td>  </td><td align="left" valign="top">您可以使用没有配方或先决条件的目标来将其他目标标记为虚假。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Empty-Targets" accesskey="8">空目标</a> ：</td><td>  </td><td align="left" valign="top">当只有日期重要且文件为空时。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Targets" accesskey="9">特殊目标</a> ：</td><td>  </td><td align="left" valign="top">具有特殊内置含义的目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multiple-Targets">多个目标</a> ：</td><td>  </td><td align="left" valign="top">何时在规则中使用多个目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multiple-Rules">多个规则</a> ：</td><td>  </td><td align="left" valign="top">如何对同一目标使用多个规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Static-Pattern">静态模式</a> ：</td><td>  </td><td align="left" valign="top">静态模式规则适用于多个目标，并且可以根据目标名称更改先决条件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Double_002dColon">双冒号</a> ：</td><td>  </td><td align="left" valign="top">如何使用一种特殊类型的规则为一个目标允许多个独立规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Automatic-Prerequisites">自动先决条件</a> ：</td><td>  </td><td align="left" valign="top">如何自动生成源文件本身提供先决条件的规则。
</td></tr>
</tbody></table>

<hr>
<a name="Rule-Example"></a>
<div class="header">
<p>下一个： <a href="#Rule-Syntax" rel="next" accesskey="n">规则语法</a> ，上一个： <a href="#Rules" rel="prev" accesskey="p">规则</a> ，上一个： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Rule-Example-1"></a>
<h3 class="section">4.1规则示例</h3>

<p>这是规则的示例：</p>
<div class="example">
<pre class="example">foo.o : foo.c defs.h       # module for twiddling the frobs
        cc -c -g foo.c
</pre></div>

<p>其目标是<samp>foo.o</samp>它的前提是<samp>foo.c</samp>和<samp>defs.h</samp> 。在配方中有一个命令： <samp>cc -c -g foo.c</samp> '。配方以一个标签开头，以将其标识为配方。
</p>
<p>此规则说明两件事：</p>
<ul>
<li>如何决定是否<samp>foo.o</samp>过期：如果不存在，或者如果存在则过期<samp>foo.c</samp>要么<samp>defs.h</samp>比它更新。

</li><li>如何更新档案<samp>foo.o</samp> ：通过运行<code>cc</code>就像声明的那样。食谱没有明确提及<samp>defs.h</samp> ，但我们认为<samp>foo.c</samp>包括它，这就是为什么<samp>defs.h</samp>已添加到先决条件中。
</li></ul>

<hr>
<a name="Rule-Syntax"></a>
<div class="header">
<p>下一页： <a href="#Prerequisite-Types" rel="next" accesskey="n">先决条件类型</a> ，上一页： <a href="#Rule-Example" rel="prev" accesskey="p">规则示例</a> ，向上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Rule-Syntax-1"></a>
<h3 class="section">4.2规则语法</h3>

<a name="index-rule-syntax"></a>
<a name="index-syntax-of-rules"></a>
<p>通常，规则如下所示：</p>
<div class="example">
<pre class="example"><var>targets</var> : <var>prerequisites</var>
        <var>recipe</var>
        &hellip;
</pre></div>

<p>或像这样：</p>
<div class="example">
<pre class="example"><var>targets</var> : <var>prerequisites</var> ; <var>recipe</var>
        <var>recipe</var>
        &hellip;
</pre></div>

<a name="index-targets"></a>
<a name="index-rule-targets"></a>
<p>的<var>targets</var>是文件名，用空格分隔。可以<a href="#Wildcards">使用通配符</a> （请参阅<a href="#Wildcards">在文件名中使用通配符</a> ）和表单名称<samp><var>a</var>(<var>m</var>)</samp>代表会员<var>m</var>在存档文件中<var>a</var> （请参阅将<a href="#Archive-Members">存档成员作为目标</a> ）。通常，每个规则只有一个目标，但偶尔也有一个理由要更多（请参阅<a href="#Multiple-Targets">规则中的多个目标</a> ）。
</p>
<a name="index-recipes"></a>
<a name="index-tab-character-_0028in-commands_0029"></a>
<p>的<var>recipe</var>行以制表符（或制表符值的第一个字符）开头<code>.RECIPEPREFIX</code>变量;请参阅<a href="#Special-Variables">特殊变量</a> ）。第一条配方行可以在先决条件之后显示，并带有一个制表符，也可以在同一行显示，并使用分号。无论哪种方式，效果都是一样的。配方的语法还有其他差异。请参见<a href="#Recipes">在规则中编写食谱</a> 。
</p>
<a name="index-dollar-sign-_0028_0024_0029_002c-in-rules"></a>
<a name="index-_0024_002c-in-rules"></a>
<a name="index-rules_002c-and-_0024"></a>
<p>因为美元符号是用来开始的<code>make</code>变量引用，如果您确实希望在目标或前提条件中使用美元符号，则必须写两个， <samp>$$</samp> '（请参阅<a href="#Using-Variables">如何使用变量</a> ）。如果您启用了辅助扩展（请参阅<a href="#Secondary-Expansion">Secondary Expansion</a> ），并且想要在先决条件列表中使用美元符号，则实际上必须写<em>四个</em>美元符号（“ <samp>$$$$</samp> '）。
</p>
<p>您可以通过在反斜杠后插入换行符来分隔长行，但这不是必需的，因为<code>make</code>对makefile中一行的长度没有限制。
</p>
<p>一条规则告诉<code>make</code>两件事：目标过期时，以及在必要时如何更新目标。
</p>
<a name="index-prerequisites"></a>
<a name="index-rule-prerequisites"></a>
<p>过时的标准是根据<var>prerequisites</var> ，由用空格分隔的文件名组成。（此处也允许使用通配符和存档成员（请参阅<a href="#Archives">Archives</a> ）。）如果目标不存在，或者目标早于任何先决条件（通过比较上次修改时间），则该目标已过期。这个想法是，目标文件的内容是根据先决条件中的信息计算的，因此，如果任何先决条件发生更改，则现有目标文件的内容将不再有效。
</p>
<p>如何更新由指定<var>recipe</var> 。这是外壳程序要执行的一行或多行（通常是' <samp>sh</samp> '），但具有一些额外的功能（请参阅<a href="#Recipes">在规则中编写食谱</a> ）。
</p>
<hr>
<a name="Prerequisite-Types"></a>
<div class="header">
<p>下一页： <a href="#Wildcards" rel="next" accesskey="n">通配符</a> ，上一页： <a href="#Rule-Syntax" rel="prev" accesskey="p">规则语法</a> ，向上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Types-of-Prerequisites"></a>
<h3 class="section">4.3先决条件的类型</h3>
<a name="index-prerequisite-types"></a>
<a name="index-types-of-prerequisites"></a>

<a name="index-prerequisites_002c-normal"></a>
<a name="index-normal-prerequisites"></a>
<a name="index-prerequisites_002c-order_002donly"></a>
<a name="index-order_002donly-prerequisites"></a>
<p>GNU实际上理解了两种不同的先决条件<code>make</code> ：如上一节中所述的常规先决条件和<em>仅订购的</em>先决条件。正常的先决条件有两个声明：首先，它强加了调用配方的顺序：在运行目标的配方之前，将完成目标的所有先决条件的配方。其次，它强加了一个依赖关系：如果任何先决条件比目标新，则该目标被认为是过时的，必须重新构建。
</p>
<p>通常，这正是您想要的：如果目标的先决条件已更新，则目标也应更新。
</p>
<p>但是，有时候，您希望对要调用的规则施加特定的顺序，但如果执行了其中一个规则， <em>则不</em>强制更新目标。在这种情况下，您要定义<em>仅订购的</em>先决条件。可以通过放置管道符号来指定仅订购的先决条件（ <code>|</code> ）在先决条件列表中：管道符号左侧的所有先决条件都是正常的；右侧的任何先决条件仅适用于订购：</p>
<div class="example">
<pre class="example"><var>targets</var> : <var>normal-prerequisites</var> | <var>order-only-prerequisites</var>
</pre></div>

<p>正常的先决条件部分当然可以为空。同样，您仍然可以为同一目标声明多行先决条件：它们被适当地附加（正常先决条件被附加到正常先决条件列表中；仅订购先决条件被附加到仅订购先决条件列表中）。请注意，如果您将同一文件声明为普通和仅订购的前提条件，则以普通的前提条件为准（因为它们具有仅订购的前提条件的行为的严格超集）。
</p>
<p>考虑一个示例，其中将目标放置在单独的目录中，并且该目录之前可能不存在<code>make</code>运行。在这种情况下，您希望在放置任何目标之前先创建目录，但是由于目录的时间戳会在添加，删除或重命名文件时发生变化，因此我们当然不希望在创建目标时重新构建所有目标。目录的时间戳更改。解决此问题的一种方法是使用仅订购的先决条件：使目录成为所有目标上的仅订购的先决条件：</p>
<div class="example">
<pre class="example">OBJDIR := objdir
OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)

$(OBJDIR)/%.o : %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;

all: $(OBJS)

$(OBJS): | $(OBJDIR)

$(OBJDIR):
        mkdir $(OBJDIR)
</pre></div>

<p>现在创建规则<samp>objdir</samp>目录将在任何“ <samp>.o</samp> '已建立，但没有' <samp>.o</samp> '之所以建立，是因为<samp>objdir</samp>目录时间戳已更改。
</p>
<hr>
<a name="Wildcards"></a>
<div class="header">
<p>下一页： <a href="#Directory-Search" rel="next" accesskey="n">目录搜索</a> ，上一页： <a href="#Prerequisite-Types" rel="prev" accesskey="p">先决条件类型</a> ，上一页： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-Wildcard-Characters-in-File-Names"></a>
<h3 class="section">4.4在文件名中使用通配符</h3>
<a name="index-wildcard"></a>
<a name="index-file-name-with-wildcards"></a>
<a name="index-globbing-_0028wildcards_0029"></a>

<a name="index-_002a-_0028wildcard-character_0029"></a>
<a name="index-_003f-_0028wildcard-character_0029"></a>
<a name="index-_005b_2026_005d-_0028wildcard-characters_0029"></a>
<p>一个文件名可以使用<em>通配符</em>指定许多文件。中的通配符<code>make</code>是 ' <samp>*</samp> '，' <samp>?</samp> '和' <samp>[…]</samp> '，与Bourne外壳中的相同。例如， <samp>*.c</samp>指定名称以“。”结尾的所有文件（在工作目录中）的列表。 <samp>.c</samp> '。
</p>
<a name="index-_007e-_0028tilde_0029"></a>
<a name="index-tilde-_0028_007e_0029"></a>
<a name="index-home-directory"></a>
<p>性格 ' <samp>~</samp>文件名开头的'也具有特殊的意义。如果单独使用，或后跟斜杠，则表示您的主目录。例如<samp>~/bin</samp>扩展到<samp>/home/you/bin</samp> 。如果“ <samp>~</samp> '后跟一个单词，该字符串表示该单词命名的用户的主目录。例如<samp>~john/bin</samp>扩展到<samp>/home/john/bin</samp> 。在没有每个用户主目录的系统上（例如MS-DOS或MS-Windows），可以通过设置环境变量来模拟此功能。 <var>HOME</var> 。
</p>
<p>通配符扩展由<code>make</code>自动在目标和先决条件中。在配方中，外壳负责通配符扩展。在其他情况下，通配符扩展仅在您使用<code>wildcard</code>功能。
</p>
<p>通配符的特殊含义可以通过在其前面加上反斜杠来关闭。从而， <samp>foo\*bar</samp>将引用名称由“ <samp>foo</samp> '，一个星号和' <samp>bar</samp> '。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Wildcard-Examples" accesskey="1">通配符示例</a> ：</td><td>  </td><td align="left" valign="top">几个例子。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcard-Pitfall" accesskey="2">通配符陷阱</a> ：</td><td>  </td><td align="left" valign="top">要避免的问题。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Wildcard-Function" accesskey="3">通配符功能</a> ：</td><td>  </td><td align="left" valign="top">如何导致通配符扩展（通常不会发生）。
</td></tr>
</tbody></table>

<hr>
<a name="Wildcard-Examples"></a>
<div class="header">
<p>下一页： <a href="#Wildcard-Pitfall" rel="next" accesskey="n">通配符陷阱</a> ，上一篇： <a href="#Wildcards" rel="prev" accesskey="p">通配符</a> ，最多： <a href="#Wildcards" rel="up" accesskey="u">通配符</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Wildcard-Examples-1"></a>
<h4 class="subsection">4.4.1通配符示例</h4>

<p>通配符可以在规则的配方中使用，在通配符中通配符可以将它们扩展。例如，以下是删除所有目标文件的规则：</p>
<div class="example">
<pre class="example">clean:
        rm -f *.o
</pre></div>
<a name="index-rm-_0028shell-command_0029-1"></a>

<p>通配符在规则的先决条件中也很有用。根据makefile中的以下规则，“ <samp>make print</samp> '将打印所有' <samp>.c</samp>自上次打印以来已更改的文件：</p>
<div class="example">
<pre class="example">print: *.c
        lpr -p $?
        touch print
</pre></div>

<a name="index-print-target"></a>
<a name="index-lpr-_0028shell-command_0029"></a>
<a name="index-touch-_0028shell-command_0029"></a>
<p>该规则使用<samp>print</samp>作为一个空的目标文件；请参阅<a href="#Empty-Targets">清空目标文件以记录事件</a> 。（自动变量' <samp>$?</samp> '仅用于打印已更改的文件；请参阅<a href="#Automatic-Variables">自动变量</a> 。）
</p>
<p>定义变量时，不会发生通配符扩展。因此，如果您这样编写：</p>
<div class="example">
<pre class="example">objects = *.o
</pre></div>

<p>然后变量的值<code>objects</code>是实际的字符串' <samp>*.o</samp> '。但是，如果您使用<code>objects</code>在目标或先决条件下，将在此处进行通配符扩展。如果使用的值<code>objects</code>在配方中，当配方运行时，外壳程序可能会执行通配符扩展。设置<code>objects</code>扩展，而是使用：</p>
<div class="example">
<pre class="example">objects := $(wildcard *.o)
</pre></div>

<p>请参阅<a href="#Wildcard-Function">通配符函数</a> 。
</p>
<hr>
<a name="Wildcard-Pitfall"></a>
<div class="header">
<p>下一页： <a href="#Wildcard-Function" rel="next" accesskey="n">通配符功能</a> ，上一篇： <a href="#Wildcard-Examples" rel="prev" accesskey="p">通配符的例子</a> ，向上： <a href="#Wildcards" rel="up" accesskey="u">通配符</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Pitfalls-of-Using-Wildcards"></a>
<h4 class="subsection">4.4.2使用通配符的陷阱</h4>
<a name="index-wildcard-pitfalls"></a>
<a name="index-pitfalls-of-wildcards"></a>
<a name="index-mistakes-with-wildcards"></a>
<a name="index-errors-with-wildcards"></a>
<a name="index-problems-with-wildcards"></a>

<p>现在，这是一个使用通配符扩展的天真的方法的示例，该方法不能满足您的预期。假设您要说的是可执行文件<samp>foo</samp>由目录中的所有目标文件组成，您可以这样编写：</p>
<div class="example">
<pre class="example">objects = *.o

foo : $(objects)
        cc -o foo $(CFLAGS) $(objects)
</pre></div>

<p>的价值<code>objects</code>是实际的字符串' <samp>*.o</samp> '。通配符扩展发生在<samp>foo</samp> ，这样每个<em>现有</em>的<samp>.o</samp>档案已成为<samp>foo</samp>并将在必要时重新编译。
</p>
<p>但是，如果您删除所有“ <samp>.o</samp>文件？当通配符不匹配任何文件时，它保持原样，因此<samp>foo</samp>取决于名字奇异的文件<samp>*.o</samp> 。由于可能没有这样的文件， <code>make</code>会给你一个错误，说它无法弄清楚怎么做<samp>*.o</samp> 。这不是您想要的！
</p>
<p>实际上，通过通配符扩展可以获得期望的结果，但是您需要更复杂的技术，包括<code>wildcard</code>函数和字符串替换。见<a href="#Wildcard-Function">功能<code>wildcard</code></a> 。
</p>
<a name="index-wildcards-and-MS_002dDOS_002fMS_002dWindows-backslashes"></a>
<a name="index-backslashes-in-pathnames-and-wildcard-expansion"></a>

<p>Microsoft操作系统（MS-DOS和MS-Windows）使用反斜杠来分隔路径名中的目录，如下所示：</p>
<div class="example">
<pre class="example">  c:\foo\bar\baz.c
</pre></div>

<p>这等效于Unix风格<samp>c:/foo/bar/baz.c</samp> （ <samp>c:</samp>部分是所谓的驱动器号）。什么时候<code>make</code>在这些系统上运行，它支持反斜杠以及路径名中的Unix样式正斜杠。然而，这种支持<em>不</em>包括通配符扩展，其中反斜杠是一个引号字符。因此，在这种情况下， <em>必须</em>使用Unix样式的斜杠。
</p>

<hr>
<a name="Wildcard-Function"></a>
<div class="header">
<p>上<a href="#Wildcard-Pitfall" rel="prev" accesskey="p">一篇</a> ： <a href="#Wildcard-Pitfall" rel="prev" accesskey="p">通配符陷阱</a> ，上<a href="#Wildcard-Pitfall" rel="prev" accesskey="p">一篇</a> ： <a href="#Wildcards" rel="up" accesskey="u">通配符</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Function-wildcard"></a>
<h4 class="subsection">4.4.3功能<code>wildcard</code></h4>
<a name="index-wildcard-1"></a>

<p>通配符扩展在规则中自动发生。但是通配符扩展通常在设置变量或在函数的参数内时不会发生。如果要在此类位置进行通配符扩展，则需要使用<code>wildcard</code>功能，像这样：</p>
<div class="example">
<pre class="example">$(wildcard <var>pattern</var>&hellip;)
</pre></div>

<p>该字符串在makefile中的任何位置使用，由与给定文件名模式之一匹配的现有文件名的空格分隔列表代替。如果没有现有的文件名与模式匹配，则该模式将从输出中省略<code>wildcard</code>功能。请注意，这与不匹配的通配符在规则中的行为不同，在通配符中，逐字使用而不是忽略<a href="#Wildcard-Pitfall">通配符</a> （请参阅“ <a href="#Wildcard-Pitfall">通配符陷阱”</a> ）。
</p>
<p>一种用途<code>wildcard</code>功能是获取目录中所有C源文件的列表，如下所示：</p>
<div class="example">
<pre class="example">$(wildcard *.c)
</pre></div>

<p>我们可以将C源文件列表更改为目标文件列表，方法是替换为“ <samp>.c</samp> '的后缀<samp>.o</samp>结果如下：</p>
<div class="example">
<pre class="example">$(patsubst %.c,%.o,$(wildcard *.c))
</pre></div>

<p>（这里我们使用了另一个功能， <code>patsubst</code> 。请参阅<a href="#Text-Functions">字符串替换和分析的函数</a> 。）
</p>
<p>因此，可以编写如下的makefile来编译目录中的所有C源文件，然后将它们链接在一起：</p>
<div class="example">
<pre class="example">objects := $(patsubst %.c,%.o,$(wildcard *.c))

foo : $(objects)
        cc -o foo $(objects)
</pre></div>

<p>（这利用了编译C程序的隐式规则，因此无需编写用于编译文件的显式规则。请参阅<a href="#Flavors">变量的两种风格</a> ，以获取有关“ <samp>:=</samp> '，这是' <samp>=</samp> '。）
</p>
<hr>
<a name="Directory-Search"></a>
<div class="header">
<p>下一个： <a href="#Phony-Targets" rel="next" accesskey="n">Phony目标</a> ，上一个： <a href="#Wildcards" rel="prev" accesskey="p">通配符</a> ，向上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Searching-Directories-for-Prerequisites"></a>
<h3 class="section">4.5搜索目录以查找先决条件</h3>
<a name="index-VPATH"></a>
<a name="index-vpath-1"></a>
<a name="index-vpath"></a>
<a name="index-search-path-for-prerequisites-_0028VPATH_0029"></a>
<a name="index-directory-search-_0028VPATH_0029"></a>

<p>对于大型系统，通常希望将源文件与二进制文件放在单独的目录中。<em>目录搜索</em>功能<code>make</code>通过自动搜索几个目录以找到先决条件来简化此过程。当您在目录中重新分配文件时，无需更改单个规则，只需更改搜索路径。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#General-Search" accesskey="1">常规搜索</a> ：</td><td>  </td><td align="left" valign="top">指定适用于每个先决条件的搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Selective-Search" accesskey="2">选择性搜索</a> ：</td><td>  </td><td align="left" valign="top">为指定的名称类别指定搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Search-Algorithm" accesskey="3">搜索算法</a> ：</td><td>  </td><td align="left" valign="top">何时以及如何应用搜索路径。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Recipes_002fSearch" accesskey="4">食谱/搜索</a> ：</td><td>  </td><td align="left" valign="top">如何编写与搜索路径配合使用的配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit_002fSearch" accesskey="5">隐式/搜索</a> ：</td><td>  </td><td align="left" valign="top">搜索路径如何影响隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Libraries_002fSearch" accesskey="6">图书馆/搜索</a> ：</td><td>  </td><td align="left" valign="top">目录搜索链接库。
</td></tr>
</tbody></table>

<hr>
<a name="General-Search"></a>
<div class="header">
<p>下一个： <a href="#Selective-Search" rel="next" accesskey="n">选择性搜索</a> ，上一个： <a href="#Directory-Search" rel="prev" accesskey="p">目录搜索</a> ，上一个： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="VPATH_003a-Search-Path-for-All-Prerequisites"></a>
<h4 class="subsection">4.5.1 <code>VPATH</code> ：所有先决条件的搜索路径</h4>
<a name="index-VPATH-1"></a>

<p>的价值<code>make</code>变量<code>VPATH</code>指定目录列表<code>make</code>应该搜索。通常，目录应该包含当前目录中不存在的必备文件。然而， <code>make</code>用途<code>VPATH</code>作为前提条件和规则目标的搜索列表。
</p>
<p>因此，如果当前目录中不存在被列为目标或先决条件的文件， <code>make</code>搜索列出的目录<code>VPATH</code>具有该名称的文件。如果在其中一个文件中找到文件，则该文件可能成为必备文件（请参阅下文）。然后，规则可以在先决条件列表中指定文件名，就好像它们都存在于当前目录中一样。请参阅<a href="#Recipes_002fSearch">使用目录搜索编写食谱</a> 。
</p>
<p>在里面<code>VPATH</code>变量，目录名称用冒号或空格分隔。列出目录的顺序是以下顺序<code>make</code>在搜索中。（在MS-DOS和MS-Windows上，分号用作目录名称的分隔符<code>VPATH</code> ，因为可以在驱动器号后的路径名本身中使用冒号。）
</p>
<p>例如，</p>
<div class="example">
<pre class="example">VPATH = src:../headers
</pre></div>

<p>指定包含两个目录的路径， <samp>src</samp>和<samp>../headers</samp> ， 哪一个<code>make</code>按该顺序搜索。
</p>
<p>有了这个值<code>VPATH</code> ，以下规则，</p>
<div class="example">
<pre class="example">foo.o : foo.c
</pre></div>

<p>被解释为就像这样写：</p>
<div class="example">
<pre class="example">foo.o : src/foo.c
</pre></div>

<p>假设文件<samp>foo.c</samp>当前目录中不存在，但在目录中找到<samp>src</samp> 。
</p>
<hr>
<a name="Selective-Search"></a>
<div class="header">
<p>下一篇： <a href="#Search-Algorithm" rel="next" accesskey="n">搜索算法</a> ，上一篇： <a href="#General-Search" rel="prev" accesskey="p">常规搜索</a> ，上一篇： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-vpath-Directive"></a>
<h4 class="subsection">4.5.2 <code>vpath</code>指示</h4>
<a name="index-vpath-2"></a>

<p>类似于<code>VPATH</code>变量，但更具选择性的是<code>vpath</code>指令（注意小写），它使您可以为特定类别的文件名（与特定模式匹配的文件名）指定搜索路径。因此，您可以为一类文件名提供某些搜索目录，为其他文件名提供其他目录（或不提供）。
</p>
<p>有三种形式的<code>vpath</code>指示：</p>
<dl compact>
<dt><code>vpath <var>pattern</var> <var>directories</var></code></dt>
<dd><p>指定搜索路径<var>directories</var>用于匹配的文件名<var>pattern</var> 。
</p>
<p>搜索路径， <var>directories</var> ，是要搜索的目录列表，用冒号（MS-DOS和MS-Windows上的分号）或空格分隔，就像在目录中使用的搜索路径一样。 <code>VPATH</code>变量。
</p>
</dd>
<dt><code>vpath <var>pattern</var></code></dt>
<dd><p>清除与以下内容相关的搜索路径<var>pattern</var> 。
</p>
</dd>
<dt><code>vpath</code></dt>
<dd>
<p>清除以前用指定的所有搜索路径<code>vpath</code>指令。
</p></dd>
</dl>

<p>一种<code>vpath</code> pattern是包含' <samp>%</samp>字符。该字符串必须与要搜索的先决条件的文件名匹配，即“ <samp>%</samp> '字符与零个或多个字符的任何序列匹配（如模式规则；请参阅<a href="#Pattern-Rules">定义和重新定义模式规则</a> ）。例如， <code>%.h</code>匹配以结尾的文件<code>.h</code> 。（如果没有“ <samp>%</samp> '，该模式必须与先决条件完全匹配，这通常用处不大。）
</p>
<a name="index-_0025_002c-quoting-in-vpath"></a>
<a name="index-_0025_002c-quoting-with-_005c-_0028backslash_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-to-quote-_0025"></a>
<a name="index-backslash-_0028_005c_0029_002c-to-quote-_0025"></a>
<a name="index-quoting-_0025_002c-in-vpath"></a>
<p>' <samp>%</samp> '个字符<code>vpath</code>指令的模式可以用前面的反斜杠（' <samp>\</samp> '）。反斜杠原本会引用' <samp>%</samp> '字符可以加更多反斜杠。引号' <samp>%</samp>在与文件名进行比较之前，将从模式中删除'字符或其他反斜杠。没有反引号危险的反斜杠<samp>%</samp>人物毫不客气。
</p>
<p>当当前目录中不存在某个先决条件时，如果<var>pattern</var>在一个<code>vpath</code>指令与先决条件文件的名称匹配，然后<var>directories</var>在该指令中的搜索方式与（和之前） <code>VPATH</code>变量。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">vpath %.h ../headers
</pre></div>

<p>告诉<code>make</code>寻找名称以结尾的任何先决条件<samp>.h</samp>在目录中<samp>../headers</samp>如果在当前目录中找不到该文件。
</p>
<p>如果几个<code>vpath</code>模式匹配必备文件的名称，然后<code>make</code>处理每个匹配<code>vpath</code>指令一个接一个地搜索每个指令中提到的所有目录。<code>make</code>处理多个<code>vpath</code>指令以它们在Makefile中出现的顺序排列；具有相同模式的多个指令彼此独立。
</p>
<p>从而，</p>
<div class="example">
<pre class="example">vpath %.c foo
vpath %   blish
vpath %.c bar
</pre></div>

<p>将寻找以“ <samp>.c</samp>在<samp>foo</samp> ， 然后<samp>blish</samp> ， 然后<samp>bar</samp> ，而</p>
<div class="example">
<pre class="example">vpath %.c foo:bar
vpath %   blish
</pre></div>

<p>将寻找以“ <samp>.c</samp>在<samp>foo</samp> ， 然后<samp>bar</samp> ， 然后<samp>blish</samp> 。
</p>
<hr>
<a name="Search-Algorithm"></a>
<div class="header">
<p>下一篇： <a href="#Recipes_002fSearch" rel="next" accesskey="n">食谱/搜索</a> ，上一篇： <a href="#Selective-Search" rel="prev" accesskey="p">选择性搜索</a> ，上一篇： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-Directory-Searches-are-Performed"></a>
<h4 class="subsection">4.5.3如何执行目录搜索</h4>
<a name="index-algorithm-for-directory-search"></a>
<a name="index-directory-search-algorithm"></a>

<p>通过目录搜索找到先决条件时，无论类型（常规或选择性），路径名可能都不是<code>make</code>实际上在先决条件列表中为您提供了。有时，通过目录搜索发现的路径会被丢弃。
</p>
<p>算法<code>make</code>用于确定是保留还是放弃通过目录搜索找到的路径，如下所示：</p>
<ol>
<li>如果makefile中指定的路径上不存在目标文件，则执行目录搜索。

</li><li>如果目录搜索成功，则保留该路径，并将该文件暂定存储为目标。

</li><li>使用同一方法检查该目标的所有先决条件。

</li><li>在处理了前提条件之后，可能需要重建目标，也可能不需要重建目标：<ol>
<li>如果<em>不需要</em>目标确实要重建，该文件路径中的目录搜索使用含有这一目标的任何先决条件的列表中。简而言之，如果<code>make</code>不需要重建目标，则可以使用通过目录搜索找到的路径。

</li><li>如果<em>确实</em>需要重建目标（已过期），则将<em>丢弃</em>在目录搜索过程中找到的路径名，并使用makefile中指定的文件名重建目标。简而言之，如果<code>make</code>必须重建，然后在本地重建目标，而不是在通过目录搜索找到的目录中重建。
</li></ol>
</li></ol>

<p>该算法看似复杂，但实际上，它恰恰是您想要的。
</p>
<a name="index-traditional-directory-search-_0028GPATH_0029"></a>
<a name="index-directory-search_002c-traditional-_0028GPATH_0029"></a>
<p>其他版本<code>make</code>使用更简单的算法：如果文件不存在，并且可以通过目录搜索找到，则无论是否需要构建目标，始终使用该路径名。因此，如果重建目标，则会在目录搜索期间发现的路径名下创建目标。
</p>
<a name="index-GPATH"></a>
<p>实际上，如果这是您希望对部分或全部目录执行的操作，则可以使用<code>GPATH</code>变量来表明这一点<code>make</code> 。
</p>
<p><code>GPATH</code>具有与以下相同的语法和格式<code>VPATH</code> （即，路径名以空格或冒号分隔的列表）。如果通过目录搜索找到了过期的目标，则该目录还会出现在<code>GPATH</code> ，则不会丢弃该路径名。使用扩展路径重建目标。
</p>
<hr>
<a name="Recipes_002fSearch"></a>
<div class="header">
<p>下一篇： <a href="#Implicit_002fSearch" rel="next" accesskey="n">隐式/搜索</a> ，上一篇： <a href="#Search-Algorithm" rel="prev" accesskey="p">搜索算法</a> ，上一篇： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Writing-Recipes-with-Directory-Search"></a>
<h4 class="subsection">4.5.4使用目录搜索编写食谱</h4>
<a name="index-recipes_002c-and-directory-search"></a>
<a name="index-directory-search-_0028VPATH_0029_002c-and-recipes"></a>

<p>通过目录搜索在另一个目录中找到先决条件时，这不能更改规则的配方；他们将按书面规定执行。因此，必须谨慎编写配方，以便它将在以下目录中查找先决条件： <code>make</code>找到它。
</p>
<p>这是通过<em>自动变量（</em>例如' <samp>$^</samp> '（请参阅<a href="#Automatic-Variables">自动变量</a> ）。例如，“ <samp>$^</samp> '是规则的所有先决条件的列表，包括在其中找到它们的目录的名称以及' <samp>$@</samp> '是目标。从而：</p>
<div class="example">
<pre class="example">foo.o : foo.c
        cc -c $(CFLAGS) $^ -o $@
</pre></div>

<p>（变量<code>CFLAGS</code>存在，因此您可以通过隐式规则为C编译指定标志；我们在这里使用它是为了保持一致性，因此它将统一影响所有C编译；请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> 。）
</p>
<p>前提条件通常还包括头文件，您在配方中不想提到这些文件。自动变量' <samp>$<</samp> '只是第一个前提条件：</p>
<div class="example">
<pre class="example">VPATH = src:../headers
foo.o : foo.c defs.h hack.h
        cc -c $(CFLAGS) $&lt; -o $@
</pre></div>

<hr>
<a name="Implicit_002fSearch"></a>
<div class="header">
<p>下一篇： <a href="#Libraries_002fSearch" rel="next" accesskey="n">图书馆/搜索</a> ，上一篇： <a href="#Recipes_002fSearch" rel="prev" accesskey="p">食谱/搜索</a> ，上一篇： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Directory-Search-and-Implicit-Rules"></a>
<h4 class="subsection">4.5.5目录搜索和隐式规则</h4>
<a name="index-VPATH_002c-and-implicit-rules"></a>
<a name="index-directory-search-_0028VPATH_0029_002c-and-implicit-rules"></a>
<a name="index-search-path-for-prerequisites-_0028VPATH_0029_002c-and-implicit-rules"></a>
<a name="index-implicit-rule_002c-and-directory-search"></a>
<a name="index-implicit-rule_002c-and-VPATH"></a>
<a name="index-rule_002c-implicit_002c-and-directory-search"></a>
<a name="index-rule_002c-implicit_002c-and-VPATH"></a>

<p>搜索以下目录中指定的目录<code>VPATH</code>或搭配<code>vpath</code>在考虑隐式规则时也会发生这种情况（请参阅<a href="#Implicit-Rules">使用隐式规则</a> ）。
</p>
<p>例如，当一个文件<samp>foo.o</samp>没有明确的规则， <code>make</code>考虑隐式规则，例如要编译的内置规则<samp>foo.c</samp>如果该文件存在。如果当前目录中缺少这样的文件，则在适当的目录中搜索它。如果<samp>foo.c</samp>在任何目录中存在（或在makefile中提及）时，都会应用C编译的隐式规则。
</p>
<p>隐式规则的配方通常根据需要使用自动变量。因此，他们将毫不费力地使用目录搜索找到的文件名。
</p>
<hr>
<a name="Libraries_002fSearch"></a>
<div class="header">
<p>上一页： <a href="#Implicit_002fSearch" rel="prev" accesskey="p">隐式/搜索</a> ，向上： <a href="#Directory-Search" rel="up" accesskey="u">目录搜索</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Directory-Search-for-Link-Libraries"></a>
<h4 class="subsection">4.5.6目录搜索链接库</h4>
<a name="index-link-libraries_002c-and-directory-search"></a>
<a name="index-libraries-for-linking_002c-directory-search"></a>
<a name="index-directory-search-_0028VPATH_0029_002c-and-link-libraries"></a>
<a name="index-VPATH_002c-and-link-libraries"></a>
<a name="index-search-path-for-prerequisites-_0028VPATH_0029_002c-and-link-libraries"></a>
<a name="index-_002dl-_0028library-search_0029"></a>
<a name="index-link-libraries_002c-patterns-matching"></a>
<a name="index-_002eLIBPATTERNS_002c-and-link-libraries"></a>
<a name="index-_002eLIBPATTERNS"></a>

<p>目录搜索以特殊方式应用于链接器使用的库。当您编写名称格式为“ <samp>-l<var>name</var></samp> '。（您可以知道这里发生了一些奇怪的事情，因为前提条件通常是<em>文件名</em> ，而库的<em>文件名</em>通常看起来像<samp>lib<var>name</var>.a</samp> ， 不喜欢 ' <samp>-l<var>name</var></samp> '。）
</p>
<p>前提条件名称的格式为“ <samp>-l<var>name</var></samp> '， <code>make</code>通过搜索文件专门处理它<samp>lib<var>name</var>.so</samp> ，以及（如果找不到）该文件<samp>lib<var>name</var>.a</samp>在当前目录中，在通过匹配指定的目录中<code>vpath</code>搜索路径和<code>VPATH</code>搜索路径，然后在目录中<samp>/lib</samp> ， <samp>/usr/lib</samp>和<samp><var>prefix</var>/lib</samp> （一般<samp>/usr/local/lib</samp> ，但MS-DOS / MS-Windows版本<code>make</code>表现得像<var>prefix</var>被定义为DJGPP安装树的根）。
</p>
<p>例如，如果有一个<samp>/usr/lib/libcurses.a</samp>系统上的库（并且没有<samp>/usr/lib/libcurses.so</samp>文件），然后</p>
<div class="example">
<pre class="example">foo : foo.c -lcurses
        cc $^ -o $@
</pre></div>

<p>会导致命令“ <samp>cc foo.c /usr/lib/libcurses.a -o foo</samp> '何时执行<samp>foo</samp>比...大<samp>foo.c</samp>或比<samp>/usr/lib/libcurses.a</samp> 。
</p>
<p>尽管要搜索的默认文件集是<samp>lib<var>name</var>.so</samp>和<samp>lib<var>name</var>.a</samp> ，这可以通过<code>.LIBPATTERNS</code>变量。此变量的值中的每个单词都是一个模式字符串。当先决条件如“ <samp>-l<var>name</var></samp>看到了<code>make</code>会将列表中每个模式的百分比替换为<var>name</var>并使用每个库文件名执行上述目录搜索。
</p>
<p>的默认值<code>.LIBPATTERNS</code>是' <samp>lib%.so lib%.a</samp> '，它提供了上述默认行为。
</p>
<p>通过将此变量设置为空值，可以完全关闭链接库扩展。
</p>
<hr>
<a name="Phony-Targets"></a>
<div class="header">
<p>下一个： <a href="#Force-Targets" rel="next" accesskey="n">强制目标</a> ，上一个： <a href="#Directory-Search" rel="prev" accesskey="p">目录搜索</a> ，上一个： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Phony-Targets-1"></a>
<h3 class="section">4.6伪装目标</h3>
<a name="index-phony-targets"></a>
<a name="index-targets_002c-phony"></a>
<a name="index-targets-without-a-file"></a>

<p>虚假目标实际上不是文件名。而是仅当您提出明确请求时要执行的配方的名称。使用伪造目标的原因有两个：避免与同名文件发生冲突，并提高性能。
</p>
<p>如果编写的规则的配方不会创建目标文件，则每次重新制作目标时都会执行该配方。这是一个例子：</p>
<div class="example">
<pre class="example">clean:
        rm *.o temp
</pre></div>

<p>因为<code>rm</code>命令不会创建名为<samp>clean</samp> ，可能永远不会存在这样的文件。因此， <code>rm</code>每次您说“ <samp>make clean</samp> '。
<a name="index-rm-_0028shell-command_0029-2"></a>
</p>
<a name="index-_002ePHONY"></a>
<p>在此示例中， <samp>clean</samp>如果名为的文件，目标将无法正常工作<samp>clean</samp>是在此目录中创建的。由于没有先决条件， <samp>clean</samp>将始终被认为是最新的，并且不会执行其配方。为避免此问题，您可以通过使目标成为特殊目标的先决条件来明确声明目标为虚假<code>.PHONY</code> （请参阅<a href="#Special-Targets">特殊内置目标名称</a> ），如下所示：</p>
<div class="example">
<pre class="example">.PHONY: clean
clean:
        rm *.o temp
</pre></div>

<p>完成后， <samp>make clean</samp> '将运行配方，而不管是否有一个名为<samp>clean</samp> 。
</p>
<p>Phony目标也可与递归调用结合使用<code>make</code> （请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。在这种情况下，makefile通常会包含一个变量，该变量列出了要构建的多个子目录。一种简单的处理方法是用一个循环遍及子目录的配方定义一个规则，如下所示：</p>
<div class="example">
<pre class="example">SUBDIRS = foo bar baz

subdirs:
        for dir in $(SUBDIRS); do \
          $(MAKE) -C $$dir; \
        done
</pre></div>

<p>但是，此方法存在问题。首先，此规则将忽略在子品牌中检测到的任何错误，因此即使一个失败，它也将继续构建其余目录。可以通过添加shell命令来记录错误并退出来克服此问题，但是即使<code>make</code>与一起调用<code>-k</code>选项，这很不幸。其次，也许更重要的是，您无法利用<code>make</code>的能力，因为它只有一个规则，因此可以<a href="#Parallel">并行</a>构建目标（请参见<a href="#Parallel">并行执行</a> ）。
</p>
<p>通过将子目录声明为<code>.PHONY</code>目标（您必须执行此操作（因为子目录显然总是存在；否则将不会生成）），可以消除以下问题：</p>
<div class="example">
<pre class="example">SUBDIRS = foo bar baz

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

$(SUBDIRS):
        $(MAKE) -C $@

foo: baz
</pre></div>

<p>在这里，我们还声明了<samp>foo</samp>直到<samp>baz</samp>子目录完成；尝试并行构建时，这种关系声明特别重要。
</p>
<p>隐式规则搜索（请参阅<a href="#Implicit-Rules">隐式规则</a> ）被跳过<code>.PHONY</code>目标。这就是为什么将目标声明为<code>.PHONY</code>即使您不担心实际文件的存在，也可以提高性能。
</p>
<p>虚假目标不应成为真实目标文件的前提；如果是这样，它的配方将每次运行<code>make</code>去更新那个文件。只要伪造目标永远不是真实目标的先决条件，那么只有当伪造目标是指定目标时，才会执行伪造目标配方（请参阅“指定目标的<a href="#Goals">参数”</a> ）。
</p>
<p>伪装目标可以有先决条件。当一个目录包含多个程序时，最方便的是在一个makefile中描述所有程序<samp>./Makefile</samp> 。由于默认情况下重制的目标将是makefile中的第一个目标，因此通常将此目标命名为' <samp>all</samp>并以所有独立程序为前提。例如：</p>
<div class="example">
<pre class="example">all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

prog2 : prog2.o
        cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
</pre></div>

<p>现在您可以说“ <samp>make</samp> '重新制作所有三个程序，或指定要重新制作的程序作为参数（如' <samp>make prog1 prog3</samp> '）。发话不是继承的：发话目标的先决条件本身不是发话，除非明确声明是发话。
</p>
<p>当一个伪造目标是另一个伪造目标的先决条件时，它将作为另一个伪造目标的子例程。例如，在这里<samp>make cleanall</samp> '将删除目标文件，差异文件和文件<samp>program</samp> ：</p>
<div class="example">
<pre class="example">.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
</pre></div>

<hr>
<a name="Force-Targets"></a>
<div class="header">
<p>下一个： <a href="#Empty-Targets" rel="next" accesskey="n">空目标</a> ，上一个：电话<a href="#Phony-Targets" rel="prev" accesskey="p">目标</a> ，上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Rules-without-Recipes-or-Prerequisites"></a>
<h3 class="section">4.7没有配方或先决条件的规则</h3>
<a name="index-force-targets"></a>
<a name="index-targets_002c-force"></a>
<a name="index-FORCE"></a>
<a name="index-rule_002c-no-recipe-or-prerequisites"></a>

<p>如果规则没有先决条件或配方，并且该规则的目标是不存在的文件，则<code>make</code>假设此规则运行时，该目标已被更新。这意味着所有依赖于此目标的目标将始终运行其配方。
</p>
<p>一个例子将说明这一点：</p>
<div class="example">
<pre class="example">clean: FORCE
        rm $(objects)
FORCE:
</pre></div>

<p>目标在这里<samp>FORCE</samp> '满足特殊条件，所以目标<samp>clean</samp>取决于它被迫运行其配方。名称'没什么特别的<samp>FORCE</samp> '，但这是这种方式常用的名称。
</p>
<p>如您所见，使用“ <samp>FORCE</samp> '这种方式的结果与使用' <samp>.PHONY: clean</samp> '。
</p>
<p>使用“ <samp>.PHONY</samp>更明确，更有效。但是，其他版本的<code>make</code>不支持“ <samp>.PHONY</samp> ';因此， <samp>FORCE</samp> '出现在许多文件中。参见<a href="#Phony-Targets">Phony目标</a> 。
</p>
<hr>
<a name="Empty-Targets"></a>
<div class="header">
<p>下一个： <a href="#Special-Targets" rel="next" accesskey="n">特殊目标</a> ，上一个： <a href="#Force-Targets" rel="prev" accesskey="p">强制目标</a> ，上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Empty-Target-Files-to-Record-Events"></a>
<h3 class="section">4.8清空目标文件以记录事件</h3>
<a name="index-empty-targets"></a>
<a name="index-targets_002c-empty"></a>
<a name="index-recording-events-with-empty-targets"></a>

<p><em>空目标</em>是假目标的变体。它用于保存您不时明确请求的操作的配方。与伪造目标不同，该目标文件可以真正存在。但是文件的内容并不重要，通常为空。
</p>
<p>空目标文件的目的是记录上一次执行规则的配方及其最后修改时间。这样做是因为配方中的命令之一是<code>touch</code>命令以更新目标文件。
</p>
<p>空的目标文件应该具有一些先决条件（否则就没有意义）。当您要求重新制作空目标时，如果有任何先决条件比目标新，则执行配方；否则，将执行配方。换句话说，如果自上次重新设定目标以来前提条件已发生变化。这是一个例子：</p>
<div class="example">
<pre class="example">print: foo.c bar.c
        lpr -p $?
        touch print
</pre></div>
<a name="index-print-target-1"></a>
<a name="index-lpr-_0028shell-command_0029-1"></a>
<a name="index-touch-_0028shell-command_0029-1"></a>

<p>根据此规则，“ <samp>make print</samp> '将执行<code>lpr</code>如果自上一个' <samp>make print</samp> '。自动变量' <samp>$?</samp> '仅用于打印已更改的那些文件（请参阅<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<hr>
<a name="Special-Targets"></a>
<div class="header">
<p>下一个： <a href="#Multiple-Targets" rel="next" accesskey="n">多个目标</a> ，上一个： <a href="#Empty-Targets" rel="prev" accesskey="p">空目标</a> ，上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Special-Built_002din-Target-Names"></a>
<h3 class="section">4.9特殊的内置目标名称</h3>
<a name="index-special-targets"></a>
<a name="index-built_002din-special-targets"></a>
<a name="index-targets_002c-built_002din-special"></a>

<p>如果某些名称作为目标出现，则具有特殊含义。
</p>
<dl compact>
<dd><a name="index-_002ePHONY-1"></a>
</dd>
<dt><code>.PHONY</code></dt>
<dd>
<p>特别目标的先决条件<code>.PHONY</code>被视为假冒目标。当需要考虑这样的目标时， <code>make</code>它将无条件运行其配方，而不管该名称的文件是否存在或其最后修改时间是什么。参见<a href="#Phony-Targets">Phony目标</a> 。
</p>
<a name="index-_002eSUFFIXES"></a>
</dd>
<dt><code>.SUFFIXES</code></dt>
<dd>
<p>特别目标的先决条件<code>.SUFFIXES</code>是用于检查后缀规则的后缀列表。请参阅<a href="#Suffix-Rules">老式的后缀规则</a> 。
</p>
<a name="index-_002eDEFAULT"></a>
</dd>
<dt><code>.DEFAULT</code></dt>
<dd>
<p>指定的配方<code>.DEFAULT</code>用于任何未找到规则的目标（显式规则或隐式规则）。参见“ <a href="#Last-Resort">最后的手段”</a> 。如果一个<code>.DEFAULT</code>指定了配方，提到的每个文件都是先决条件，而不是规则中的目标，它将代表该配方执行。请参阅<a href="#Implicit-Rule-Search">隐式规则搜索算法</a> 。
</p>
<a name="index-_002ePRECIOUS"></a>
</dd>
<dt><code>.PRECIOUS</code></dt>
<dd><a name="index-precious-targets"></a>
<a name="index-preserving-with-_002ePRECIOUS"></a>

<p>的目标<code>.PRECIOUS</code>取决于以下特殊处理：如果<code>make</code>在执行其配方期间被杀死或中断，不会删除目标。请参阅<a href="#Interrupts">中断或杀死<code>make</code></a> 。同样，如果目标是中间文件，则不再需要它后就不会删除它，就像通常那样。请参阅<a href="#Chained-Rules">隐式规则链</a> 。在后者方面，它与<code>.SECONDARY</code>特殊目标。
</p>
<p>您还可以列出隐式规则的目标模式（例如“ <samp>%.o</samp> '）作为特殊目标的必备文件<code>.PRECIOUS</code>保留由规则创建的中间文件，这些规则的目标模式与该文件的名称匹配。
</p>
<a name="index-_002eINTERMEDIATE"></a>
</dd>
<dt><code>.INTERMEDIATE</code></dt>
<dd><a name="index-intermediate-targets_002c-explicit"></a>

<p>的目标<code>.INTERMEDIATE</code>取决于被视为中间文件。请参阅<a href="#Chained-Rules">隐式规则链</a> 。
<code>.INTERMEDIATE</code>没有先决条件没有效果。
</p>
<a name="index-_002eSECONDARY"></a>
</dd>
<dt><code>.SECONDARY</code></dt>
<dd><a name="index-secondary-targets"></a>
<a name="index-preserving-with-_002eSECONDARY"></a>

<p>的目标<code>.SECONDARY</code>取决于，它们将被视为中间文件，但它们绝不会自动删除。请参阅<a href="#Chained-Rules">隐式规则链</a> 。
</p>
<p><code>.SECONDARY</code>如果没有先决条件，则将所有目标都视为次要目标（即，不会删除任何目标，因为它被视为中间目标）。
</p>
<a name="index-_002eSECONDEXPANSION-1"></a>
</dd>
<dt><code>.SECONDEXPANSION</code></dt>
<dd>
<p>如果<code>.SECONDEXPANSION</code>在makefile中的任何位置都将其称为目标，那么在读取了所有makefile <em>之后</em> ，将<em>在</em>出现<em>之后</em>定义的所有必备列表再次进行扩展。请参阅<a href="#Secondary-Expansion">二次扩展</a> 。
</p>
<a name="index-_002eDELETE_005fON_005fERROR"></a>
</dd>
<dt><code>.DELETE_ON_ERROR</code></dt>
<dd><a name="index-removing-targets-on-failure"></a>

<p>如果<code>.DELETE_ON_ERROR</code>在makefile中的任何地方都被提及为目标，然后<code>make</code>如果规则目标已更改且其配方以非零退出状态退出，则它将删除该规则的目标，就像接收信号时一样。请参见<a href="#Errors">食谱中的错误</a> 。
</p>
<a name="index-_002eIGNORE"></a>
</dd>
<dt><code>.IGNORE</code></dt>
<dd>
<p>如果您指定了先决条件<code>.IGNORE</code> ， 然后<code>make</code>将忽略那些特定文件的配方执行错误。配方<code>.IGNORE</code> （如果有）被忽略。
</p>
<p>如果没有任何先决条件提到目标， <code>.IGNORE</code>表示忽略所有文件的配方执行错误。的这种用法<samp>.IGNORE</samp>仅出于历史兼容性支持。由于这会影响makefile中的每个配方，因此它不是很有用；我们建议您使用更具选择性的方法来忽略特定配方中的错误。请参见<a href="#Errors">食谱中的错误</a> 。
</p>
<a name="index-_002eLOW_005fRESOLUTION_005fTIME"></a>
</dd>
<dt><code>.LOW_RESOLUTION_TIME</code></dt>
<dd>
<p>如果您指定了先决条件<code>.LOW_RESOLUTION_TIME</code> ， <code>make</code>假定这些文件是由生成低分辨率时间戳的命令创建的。的食谱<code>.LOW_RESOLUTION_TIME</code>目标被忽略。
</p>
<p>许多现代文件系统的高分辨率文件时间戳减少了<code>make</code>错误地认为文件是最新的。不幸的是，某些主机没有提供设置高分辨率文件时间戳的方法，因此诸如“ <samp>cp -p</samp>明确设置文件时间戳记的'必须丢弃其次秒部分。如果文件是通过这样的命令创建的，则应将其列出为<code>.LOW_RESOLUTION_TIME</code>以便<code>make</code>不会错误地认为该文件已过期。例如：</p>
<div class="example">
<pre class="example">.LOW_RESOLUTION_TIME: dst
dst: src
        cp -p src dst
</pre></div>

<p>由于“ <samp>cp -p</samp> '丢弃的次秒部分<samp>src</samp>的时间戳， <samp>dst</samp>通常比<samp>src</samp>即使它是最新的。的<code>.LOW_RESOLUTION_TIME</code>线路原因<code>make</code>考虑<samp>dst</samp>如果它的时间戳记在与<samp>src</samp>的时间戳在。
</p>
<p>由于存档格式的限制，存档成员时间戳始终是低分辨率的。您无需列出存档成员作为以下内容的先决条件<code>.LOW_RESOLUTION_TIME</code> ，作为<code>make</code>自动执行此操作。
</p>
<a name="index-_002eSILENT"></a>
</dd>
<dt><code>.SILENT</code></dt>
<dd>
<p>如果您指定了先决条件<code>.SILENT</code> ， 然后<code>make</code>在执行之前，不会打印用于重新制作这些特定文件的配方。配方<code>.SILENT</code>被忽略。
</p>
<p>如果没有任何先决条件提到目标， <code>.SILENT</code>说不要在执行之前打印任何配方。的这种用法<samp>.SILENT</samp>仅出于历史兼容性支持。我们建议您使用更具选择性的方法来使特定配方静音。请参见<a href="#Echoing">配方回显</a> 。如果您想使特定配方的所有配方静音<code>make</code> ， 使用 ' <samp>-s</samp> ' 要么 ' <samp><span class="nolinebreak">--silent</span></samp> ' <!-- /@w -->选项（请参阅<a href="#Options-Summary">选项摘要</a> ）。
</p>
<a name="index-_002eEXPORT_005fALL_005fVARIABLES"></a>
</dd>
<dt><code>.EXPORT_ALL_VARIABLES</code></dt>
<dd>
<p>只是被提及为目标，这说明<code>make</code>默认情况下将所有变量导出到子进程。请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> 。
</p>
<a name="index-_002eNOTPARALLEL"></a>
</dd>
<dt><code>.NOTPARALLEL</code></dt>
<dd><a name="index-parallel-execution_002c-overriding"></a>

<p>如果<code>.NOTPARALLEL</code>被提及为目标，然后调用<code>make</code>将连续运行，即使“ <samp>-j</samp> '选项。任何递归调用<code>make</code>该命令仍将并行运行配方（除非其makefile也包含此目标）。此目标上的所有先决条件都将被忽略。
</p>
<a name="index-_002eONESHELL"></a>
</dd>
<dt><code>.ONESHELL</code></dt>
<dd><a name="index-recipe-execution_002c-single-invocation"></a>

<p>如果<code>.ONESHELL</code>提到作为目标时，则在构建目标时，配方的所有行都将被赋予外壳的单个调用，而不是被单独调用的每一行（请参见<a href="#Execution">Recipe Execution</a> ）。
</p>
<a name="index-_002ePOSIX"></a>
</dd>
<dt><code>.POSIX</code></dt>
<dd><a name="index-POSIX_002dconforming-mode_002c-setting"></a>

<p>如果<code>.POSIX</code>如果将“。”作为目标，则将分析makefile并在符合POSIX的模式下运行。这<em>并不</em>意味着只有符合POSIX标准的makefile将被接受：所有先进的GNU <code>make</code>功能仍然可用。相反，此目标导致<code>make</code>在以下方面，按照POSIX的要求行事<code>make</code>的默认行为有所不同。
</p>
<p>特别是，如果提到了此目标，则将调用配方，就像外壳已通过<code>-e</code>标志：配方中的第一个失败命令将导致配方立即失败。
</p></dd>
</dl>

<p>如果任何定义的隐式规则后缀作为目标出现，则也算作特殊目标，两个后缀的串联也是如此，例如' <samp>.c.o</samp> '。这些目标是后缀规则，这是定义隐式规则的一种过时方法（但仍被广泛使用）。原则上，如果将目标名称一分为二并将这两个名称都添加到后缀列表中，则任何目标名称都可以采用这种特殊方式。实际上，后缀通常以' <samp>.</samp> '，因此这些特殊目标名称也以' <samp>.</samp> '。请参阅<a href="#Suffix-Rules">老式的后缀规则</a> 。
</p>
<hr>
<a name="Multiple-Targets"></a>
<div class="header">
<p>下一页： <a href="#Multiple-Rules" rel="next" accesskey="n">多个规则</a> ，上一页： <a href="#Special-Targets" rel="prev" accesskey="p">特殊目标</a> ，向上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Multiple-Targets-in-a-Rule"></a>
<h3 class="section">4.10规则中的多个目标</h3>
<a name="index-multiple-targets"></a>
<a name="index-several-targets-in-a-rule"></a>
<a name="index-targets_002c-multiple"></a>
<a name="index-rule_002c-with-multiple-targets"></a>

<p>具有多个目标的规则等同于编写许多规则，每个规则都有一个目标，除此之外，所有规则都相同。相同的配方适用于所有目标，但是其效果可能会有所不同，因为您可以使用“ <samp>$@</samp> '。该规则还为所有目标提供了相同的前提条件。
</p>
<p>这在两种情况下很有用。
</p>
<ul>
<li>您只需要先决条件，而不需要任何配方。例如：<div class="example">
<pre class="example">kbd.o command.o files.o: command.h
</pre></div>

<p>为提到的三个目标文件分别提供了一个前提条件。
</p>
</li><li>类似的配方适用于所有目标。配方不必完全相同，因为自动变量' <samp>$@</samp>可以用于将要重制的特定目标替换为命令（请参见<a href="#Automatic-Variables">自动变量</a> ）。例如：<div class="example">
<pre class="example">bigoutput littleoutput : text.g
        generate text.g -$(subst output,,$@) &gt; $@
</pre></div>
<a name="index-subst"></a>

<p>相当于</p>
<div class="example">
<pre class="example">bigoutput : text.g
        generate text.g -big &gt; bigoutput
littleoutput : text.g
        generate text.g -little &gt; littleoutput
</pre></div>

<p>这里我们假设假设的程序<code>generate</code>产生两种类型的输出，如果给出' <samp>-big</samp> '和一个给定的' <samp>-little</samp> '。有关<a href="#Text-Functions">字符串</a>的解释，请参见<a href="#Text-Functions">字符串替换和分析函数。</a> <code>subst</code>功能。
</p></li></ul>

<p>假设您想根据目标来改变前提条件，就像变量' <samp>$@</samp> '可让您改变配方。您不能使用普通规则对多个目标执行此操作，但是可以使用<em>静态模式规则进行此操作</em> 。请参阅<a href="#Static-Pattern">静态模式规则</a> 。
</p>
<hr>
<a name="Multiple-Rules"></a>
<div class="header">
<p>下一页： <a href="#Static-Pattern" rel="next" accesskey="n">静态模式</a> ，上一页： <a href="#Multiple-Targets" rel="prev" accesskey="p">多个目标</a> ，上一页： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Multiple-Rules-for-One-Target"></a>
<h3 class="section">4.11一个目标的多个规则</h3>
<a name="index-multiple-rules-for-one-target"></a>
<a name="index-several-rules-for-one-target"></a>
<a name="index-rule_002c-multiple-for-one-target"></a>
<a name="index-target_002c-multiple-rules-for-one"></a>

<p>一个文件可以成为多个规则的目标。所有规则中提到的所有先决条件都被合并到目标的先决条件列表中。如果目标比任何规则中的任何先决条件都旧，则执行配方。
</p>
<p>一个文件只能执行一个配方。如果有多个规则为同一文件提供配方， <code>make</code>使用给定的最后一个并打印错误消息。（在特殊情况下，如果文件名以点开头，则不会打印错误消息。这种奇怪的行为仅是为了与的其他实现兼容<code>make</code> …您应避免使用它）。有时，让同一个目标调用在makefile的不同部分中定义的多个配方很有用；您可以为此使用<em>双冒号规则</em> （请参见<a href="#Double_002dColon">Double-Colon</a> ）。
</p>
<p>仅具有先决条件的额外规则可用于一次为多个文件提供一些额外的先决条件。例如，makefile通常包含一个变量，例如<code>objects</code> ，其中包含正在制作的系统中所有编译器输出文件的列表。简单地说，如果<samp>config.h</samp>变化是写以下内容：</p>
<div class="example">
<pre class="example">objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
</pre></div>

<p>可以在不更改真正指定如何制作目标文件的规则的情况下插入或取出该文件，如果希望间歇性添加其他先决条件，则可以轻松地使用它。
</p>
<p>另一个难题是，可以使用您通过命令行参数设置的变量来指定其他先决条件。 <code>make</code> （请参阅<a href="#Overriding">覆盖变量</a> ）。例如，</p>
<div class="example">
<pre class="example">extradeps=
$(objects) : $(extradeps)
</pre></div>

<p>表示命令“ <samp>make extradeps=foo.h</samp> ' 会考虑<samp>foo.h</samp>作为每个目标文件的先决条件，但普通的' <samp>make</samp> ' 将不会。
</p>
<p>如果目标的任何明确规则都没有配方，则<code>make</code>搜索适用的隐式规则以找到一个<a href="#Implicit-Rules">规则（</a>请参阅<a href="#Implicit-Rules">使用隐式规则</a> ）。
</p>
<hr>
<a name="Static-Pattern"></a>
<div class="header">
<p>下一篇： <a href="#Double_002dColon" rel="next" accesskey="n">双冒号</a> ，上一篇： <a href="#Multiple-Rules" rel="prev" accesskey="p">多个规则</a> ，上一篇： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Static-Pattern-Rules"></a>
<h3 class="section">4.12静态模式规则</h3>
<a name="index-static-pattern-rule"></a>
<a name="index-rule_002c-static-pattern"></a>
<a name="index-pattern-rules_002c-static-_0028not-implicit_0029"></a>
<a name="index-varying-prerequisites"></a>
<a name="index-prerequisites_002c-varying-_0028static-pattern_0029"></a>

<p><em>静态模式规则</em>是指定多个目标并根据目标名称构造每个目标的必备名称的规则。它们比具有多个目标的普通规则更具通用性，因为目标不必具有相同的先决条件。它们的前提条件必须<em>相似</em> ，但不一定<em>相同</em> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Static-Usage" accesskey="1">静态用法</a> ：</td><td>  </td><td align="left" valign="top">静态模式规则的语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Static-versus-Implicit" accesskey="2">静态与隐式</a> ：</td><td>  </td><td align="left" valign="top">什么时候比隐含规则更好？
</td></tr>
</tbody></table>

<hr>
<a name="Static-Usage"></a>
<div class="header">
<p>下一篇： <a href="#Static-versus-Implicit" rel="next" accesskey="n">静态与隐式</a> ，上一篇： <a href="#Static-versus-Implicit" rel="next" accesskey="n">静态</a> <a href="#Static-Pattern" rel="prev" accesskey="p">模式</a> ，上一篇： <a href="#Static-versus-Implicit" rel="next" accesskey="n">静态</a> <a href="#Static-Pattern" rel="up" accesskey="u">模式</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Syntax-of-Static-Pattern-Rules"></a>
<h4 class="subsection">4.12.1静态模式规则的语法</h4>
<a name="index-static-pattern-rule_002c-syntax-of"></a>
<a name="index-pattern-rules_002c-static_002c-syntax-of"></a>

<p>这是静态模式规则的语法：</p>
<div class="example">
<pre class="example"><var>targets</var> &hellip;: <var>target-pattern</var>: <var>prereq-patterns</var> &hellip;
        <var>recipe</var>
        &hellip;
</pre></div>

<p>的<var>targets</var>列表指定规则适用的目标。目标可以包含通配符，就像普通规则的目标一样（请参阅<a href="#Wildcards">在文件名中使用通配符</a> ）。
</p>
<a name="index-target-pattern_002c-static-_0028not-implicit_0029"></a>
<a name="index-stem"></a>
<p>的<var>target-pattern</var>和<var>prereq-patterns</var>说出如何计算每个目标的前提条件。每个目标都与<var>target-pattern</var>提取目标名称的一部分，称为<em>stem</em> 。将此茎替换为每个<var>prereq-patterns</var>做出必要的名称（每个名称一个<var>prereq-pattern</var> ）。
</p>
<p>每个模式通常都包含字符' <samp>%</samp> ' 就一次。当。。。的时候<var>target-pattern</var>匹配目标，即“ <samp>%</samp> '可以匹配目标名称的任何部分；这部分称为<em>茎</em> 。模式的其余部分必须完全匹配。例如目标<samp>foo.o</samp>匹配模式“ <samp>%.o</samp> '，加上' <samp>foo</samp> '作为词干。目标<samp>foo.c</samp>和<samp>foo.out</samp>与该模式不匹配。
</p>
<a name="index-prerequisite-pattern_002c-static-_0028not-implicit_0029"></a>
<p>每个目标的先决条件名称是用词干替换“ <samp>%</samp>在每个先决条件模式中。例如，如果一种先决条件模式是<samp>%.c</samp> ，然后替换词根' <samp>foo</samp> '给出了必要的名称<samp>foo.c</samp> 。编写不包含“ <samp>%</samp> ';那么此前提对于所有目标都是相同的。
</p>
<a name="index-_0025_002c-quoting-in-static-pattern"></a>
<a name="index-_0025_002c-quoting-with-_005c-_0028backslash_0029-1"></a>
<a name="index-_005c-_0028backslash_0029_002c-to-quote-_0025-1"></a>
<a name="index-backslash-_0028_005c_0029_002c-to-quote-_0025-1"></a>
<a name="index-quoting-_0025_002c-in-static-pattern"></a>
<p>' <samp>%</samp> '模式规则中的字符可以用前面的反斜杠（' <samp>\</samp> '）。反斜杠原本会引用' <samp>%</samp> '字符可以加更多反斜杠。引号' <samp>%</samp>将'字符或其他反斜杠从模式中删除之前，先将其与文件名进行比较，或者将其替换为词干。没有反引号危险的反斜杠<samp>%</samp>人物毫不客气。例如图案<samp>the\%weird\\%pattern\\</samp>拥有 ' <samp>the%weird\</samp> “在手术人员之前” <samp>%</samp> “字符和” <samp>pattern\\</samp> '跟随它。最后两个反斜杠不受影响，因为它们不会影响任何“ <samp>%</samp>字符。
</p>
<p>这是一个示例，它将每个<samp>foo.o</samp>和<samp>bar.o</samp>从相应的<samp>.c</samp>文件：</p>
<div class="example">
<pre class="example">objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $&lt; -o $@
</pre></div>

<p>这里 ' <samp>$<</samp> '是保存先决条件名称的自动变量，并且' <samp>$@</samp> '是保存目标名称的自动变量；请参阅<a href="#Automatic-Variables">自动变量</a> 。
</p>
<p>指定的每个目标必须匹配目标模式；将为每个没有发出的目标发出警告。如果您有文件列表，只有其中一部分与该模式匹配，则可以使用<code>filter</code>用于删除不匹配文件名的<a href="#Text-Functions">函数</a> （请参阅<a href="#Text-Functions">用于字符串替换和分析的函数</a> ）：</p>
<div class="example">
<pre class="example">files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $&lt; -o $@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $&lt;
</pre></div>

<p>在此示例中，“ <samp>$(filter %.o,$(files))</samp> '是<samp>bar.o lose.o</samp> ，并且第一个静态模式规则使这些目标文件中的每一个都可以通过编译相应的C源文件来进行更新。的结果 ' <samp>$(filter %.elc,$(files))</samp> ' <!-- /@w -->是<samp>foo.elc</samp> ，因此该文件是从<samp>foo.el</samp> 。
</p>
<p>另一个例子展示了如何使用<code>$*</code>在静态模式规则中： <a name="index-_0024_002a_002c-and-static-pattern"></a>
</p>
<div class="example">
<pre class="example">bigoutput littleoutput : %output : text.g
        generate text.g -$* &gt; $@
</pre></div>

<p>当。。。的时候<code>generate</code>命令运行<code>$*</code>将扩展到词根，要么<samp>big</samp> ' 要么 ' <samp>little</samp> '。
</p>
<hr>
<a name="Static-versus-Implicit"></a>
<div class="header">
<p>上一篇： <a href="#Static-Usage" rel="prev" accesskey="p">静态用法</a> ，上一篇： <a href="#Static-Pattern" rel="up" accesskey="u">静态模式</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Static-Pattern-Rules-versus-Implicit-Rules"></a>
<h4 class="subsection">4.12.2静态模式规则与隐式规则</h4>
<a name="index-rule_002c-static-pattern-versus-implicit"></a>
<a name="index-static-pattern-rule_002c-versus-implicit"></a>

<p>静态模式规则与定义为模式规则的隐式规则有很多共同点（请参阅<a href="#Pattern-Rules">定义和重新定义模式规则</a> ）。两者都有目标的模式和构造先决条件名称的模式。不同之处在于<code>make</code>决定<em>何时</em>应用规则。
</p>
<p>的隐含规则<em>可以</em>应用到它的模式匹配的目标，但<em>它</em>仅适用于当目标没有配方另有规定，只有当可发现的先决条件。如果出现多个不适用的隐含规则，则仅适用一个。选择取决于规则的顺序。
</p>
<p>相反，静态模式规则适用于您在规则中指定的精确目标列表。它不能应用于任何其他目标，并且总是适用于指定的每个目标。如果两个冲突的规则适用，并且都有配方，那就是错误的。
</p>
<p>由于以下原因，静态模式规则可能比隐式规则更好：</p>
<ul>
<li>您可能希望对一些名称无法按语法分类但可以在显式列表中给出的文件覆盖通常的隐式规则。

</li><li>如果您不确定所使用目录的确切内容，则可能不确定哪些其他不相关的文件可能导致<code>make</code>使用错误的隐式规则。该选择可能取决于隐式规则搜索完成的顺序。使用静态模式规则，没有不确定性：每个规则都精确地应用于指定的目标。
</li></ul>

<hr>
<a name="Double_002dColon"></a>
<div class="header">
<p>下一页： <a href="#Automatic-Prerequisites" rel="next" accesskey="n">自动必备软件</a> ，上一页： <a href="#Static-Pattern" rel="prev" accesskey="p">静态模式</a> ，上一页： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Double_002dColon-Rules"></a>
<h3 class="section">4.13双冒号规则</h3>
<a name="index-double_002dcolon-rules"></a>
<a name="index-rule_002c-double_002dcolon-_0028_003a_003a_0029"></a>
<a name="index-multiple-rules-for-one-target-_0028_003a_003a_0029"></a>
<a name="index-_003a_003a-rules-_0028double_002dcolon_0029"></a>

<p><em>双冒号</em>规则是用' <samp>::</samp> ' 代替 ' <samp>:</samp> '在目标名称之后。当同一目标出现在多个规则中时，它们的处理方式与普通规则不同。具有双冒号的模式规则具有完全不同的含义（请参阅<a href="#Match_002dAnything-Rules">Match-Anything Rules</a> ）。
</p>
<p>当一个目标出现在多个规则中时，所有规则必须为同一类型：全部为普通或全部为双冒号。如果它们是双冒号，则它们彼此独立。如果目标早于该规则的任何先决条件，则执行每个双冒号规则的配方。如果该规则没有先决条件，则始终执行其配方（即使目标已经存在）。这可能导致不执行，不执行或执行所有双冒号规则。
</p>
<p>具有相同目标的双冒号规则实际上是彼此完全分开的。每个双冒号规则都将单独处理，就像处理具有不同目标的规则一样。
</p>
<p>目标的双冒号规则按照它们在makefile中出现的顺序执行。但是，双冒号规则真正有意义的情况是执行配方的顺序无关紧要的情况。
</p>
<p>双冒号规则有些晦涩难懂，通常不是很有用。它们提供了一种机制，在这种情况下，用于更新目标的方法根据导致更新的先决条件文件而有所不同，而这种情况很少见。
</p>
<p>每个双冒号规则都应指定一个配方；如果不适用，则将应用一个隐式规则。请参阅<a href="#Implicit-Rules">使用隐式规则</a> 。
</p>
<hr>
<a name="Automatic-Prerequisites"></a>
<div class="header">
<p>上一页： <a href="#Double_002dColon" rel="prev" accesskey="p">双冒号</a> ，上： <a href="#Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Generating-Prerequisites-Automatically"></a>
<h3 class="section">4.14自动生成前提条件</h3>
<a name="index-prerequisites_002c-automatic-generation-1"></a>
<a name="index-automatic-generation-of-prerequisites-1"></a>
<a name="index-generating-prerequisites-automatically-1"></a>

<p>在程序的makefile中，您需要编写的许多规则通常只说某些目标文件取决于某些头文件。例如，如果<samp>main.c</samp>用途<samp>defs.h</samp>通过一个<code>#include</code> ，您会这样写：</p>
<div class="example">
<pre class="example">main.o: defs.h
</pre></div>

<p>您需要此规则，以便<code>make</code>知道它必须重制<samp>main.o</samp>每当<samp>defs.h</samp>变化。您会看到，对于大型程序，您将不得不在makefile中编写许多此类规则。并且，每次添加或删除文件时，必须始终非常小心地更新makefile。 <code>#include</code> 。
<a name="index-_0023include"></a>
</p>
<a name="index-_002dM-_0028to-compiler_0029"></a>
<p>为了避免这种麻烦，大多数现代C编译器可以通过查看以下内容为您编写这些规则： <code>#include</code>源文件中的行。通常，这是通过“ <samp>-M</samp> '编译器的选项。例如，命令：</p>
<div class="example">
<pre class="example">cc -M main.c
</pre></div>

<p>生成输出：</p>
<div class="example">
<pre class="example">main.o : main.c defs.h
</pre></div>

<p>因此，您不再需要自己编写所有这些规则。编译器将为您完成此任务。
</p>
<p>请注意，这样的规则构成了<samp>main.o</samp>在makefile中，因此它不能被隐式规则搜索视为中间文件。这意味着<code>make</code>使用后永远不会删除该文件；参见<a href="#Chained-Rules">内隐规则链</a> 。
</p>
<a name="index-make-depend"></a>
<p>与旧<code>make</code>程序中，传统做法是使用此编译器功能通过“ <samp>make depend</samp> '。该命令将创建一个文件<samp>depend</samp>包含所有自动生成的前提条件；那么makefile可以使用<code>include</code>阅读它们（请参阅<a href="#Include">Include</a> ）。
</p>
<p>在GNU中<code>make</code> ，重新制作makefile的功能使这种做法过时了-您无需告诉<code>make</code>明确地重新生成先决条件，因为它总是重新生成任何过时的makefile。请参阅<a href="#Remaking-Makefiles">重新制作Makefile</a> 。
</p>
<p>我们建议自动生成先决条件的做法是有一个与每个源文件相对应的makefile。对于每个源文件<samp><var>name</var>.c</samp>有一个makefile <samp><var>name</var>.d</samp>列出目标文件的文件<samp><var>name</var>.o</samp>依赖于取决于。这样，只需要重新扫描已更改的源文件即可产生新的先决条件。
</p>
<p>这是用于生成前提条件文件（即makefile）的模式规则<samp><var>name</var>.d</samp>从一个名为<samp><var>name</var>.c</samp> ：</p>
<div class="smallexample">
<pre class="smallexample">%.d: %.c
        @set -e; rm -f $@; \
         $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
         sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
         rm -f $@.$$$$
</pre></div>

<p>有关定义模式规则的信息，请参见<a href="#Pattern-Rules">模式</a>规则。' <samp>-e</samp>如果外壳上的'标志使外壳立即退出<code>$(CC)</code>命令（或任何其他命令）失败（状态为非零退出）。
<a name="index-_002de-_0028shell-flag_0029"></a>
</p>
<a name="index-_002dMM-_0028to-GNU-compiler_0029"></a>
<p>对于GNU C编译器，您可能希望使用' <samp>-MM</samp> '标志代替' <samp>-M</samp> '。这省略了系统头文件的先决条件。有关详细信息，请参见《 <cite>使用GNU CC》中的“</cite> <a href="http://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html#Preprocessor-Options">控制预处理器的选项”</a> 。
</p>
<a name="index-sed-_0028shell-command_0029"></a>
<p>目的<code>sed</code>命令是翻译（例如）：</p>
<div class="example">
<pre class="example">main.o : main.c defs.h
</pre></div>

<p>变成：</p>
<div class="example">
<pre class="example">main.o main.d : main.c defs.h
</pre></div>

<p><a name="index-_002ed"></a>这使得每个<samp>.d</samp> '文件取决于与之对应的所有源文件和头文件。 <samp>.o</samp> '文件取决于。 <code>make</code>然后知道只要任何源文件或头文件发生更改，它都必须重新生成先决条件。
</p>
<p>定义规则后，重新制作“ <samp>.d</samp> '文件，然后使用<code>include</code>指令以全部读取它们。请参阅<a href="#Include">包括</a> 。例如：</p>
<div class="example">
<pre class="example">sources = foo.c bar.c

include $(sources:.c=.d)
</pre></div>

<p>（本示例使用替代变量引用来翻译源文件列表' <samp>foo.c bar.c</samp> “到必备的makefile列表中，” <samp>foo.d bar.d</samp> '。有关<a href="#Substitution-Refs">替代参考</a>的完整信息，请参见<a href="#Substitution-Refs">替代</a>参考。）自“ <samp>.d</samp> '文件是与其他文件一样的makefile， <code>make</code>将根据需要重新制作它们，而无需您进行进一步的工作。请参阅<a href="#Remaking-Makefiles">重新制作Makefile</a> 。
</p>
<p>请注意， <samp>.d</samp> '文件包含目标定义；您应该确保将<code>include</code>指令<em>在</em> makefile中的第一个默认目标<em>之后</em> ，否则有使随机目标文件成为默认目标的风险。请参阅<a href="#How-Make-Works">制作方法</a> 。
</p>
<hr>
<a name="Recipes"></a>
<div class="header">
<p>下一篇： <a href="#Using-Variables" rel="next" accesskey="n">使用变量</a> ，上一篇： <a href="#Rules" rel="prev" accesskey="p">规则</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Writing-Recipes-in-Rules"></a>
<h2 class="chapter">5在规则中编写食谱</h2>
<a name="index-recipes-1"></a>
<a name="index-recipes_002c-how-to-write"></a>
<a name="index-writing-recipes"></a>

<p>规则的配方由一个或多个要执行的Shell命令行组成，一次按它们出现的顺序执行。通常，执行这些命令的结果是使规则的目标保持最新状态。
</p>
<p>用户使用许多不同的Shell程序，但makefile中的配方始终由<samp>/bin/sh</samp>除非makefile另行指定。请参见<a href="#Execution">配方执行</a> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Recipe-Syntax" accesskey="1">配方语法</a> ：</td><td>  </td><td align="left" valign="top">配方语法功能和陷阱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Echoing" accesskey="2">回声</a> ：</td><td>  </td><td align="left" valign="top">如何控制何时回传食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Execution" accesskey="3">执行</a> ：</td><td>  </td><td align="left" valign="top">配方如何执行。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Parallel" accesskey="4">平行</a> ：</td><td>  </td><td align="left" valign="top">如何并行执行配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Errors" accesskey="5">错误</a> ：</td><td>  </td><td align="left" valign="top">配方执行错误后会发生什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Interrupts" accesskey="6">中断</a> ：</td><td>  </td><td align="left" valign="top">配方中断时会发生什么。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Recursion" accesskey="7">递归</a> ：</td><td>  </td><td align="left" valign="top">调用中<code>make</code>从makefile文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Canned-Recipes" accesskey="8">罐装食谱</a> ：</td><td>  </td><td align="left" valign="top">定义罐头食谱。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Empty-Recipes" accesskey="9">空食谱</a> ：</td><td>  </td><td align="left" valign="top">定义有用的，无所事事的食谱。
</td></tr>
</tbody></table>

<hr>
<a name="Recipe-Syntax"></a>
<div class="header">
<p>下一页： <a href="#Echoing" rel="next" accesskey="n">相呼应</a> ，上一篇： <a href="#Recipes" rel="prev" accesskey="p">食谱</a> ，向上： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Recipe-Syntax-1"></a>
<h3 class="section">5.1配方语法</h3>
<a name="index-recipe-syntax"></a>
<a name="index-syntax-of-recipe"></a>

<p>Makefile具有不寻常的属性，即一个文件中实际上有两种不同的语法。大多数makefile使用<code>make</code>语法（请参阅<a href="#Makefiles">编写Makefile</a> ）。但是，配方是由Shell解释的，因此它们是使用Shell语法编写的。的<code>make</code>程序不会尝试理解Shell语法：在将配方交给Shell之前，它仅对配方内容执行很少的特定翻译。
</p>
<p>配方中的每一行必须以制表符（或<code>.RECIPEPREFIX</code>变量;请参阅“ <a href="#Special-Variables">特殊变量”</a> ），不同之处在于第一条配方行可以附加到目标和前提条件行，中间用分号隔开。makefile中以制表符开头并出现在“规则上下文”中的<em>任何</em>行（即，在规则启动后直到另一条规则或变量定义）都将被视为该规则的配方的一部分。空白行和仅注释行可能会出现在配方行之间；他们被忽略了。
</p>
<p>这些规则的一些后果包括：</p>
<ul>
<li>以制表符开头的空白行不为空白：这是一个空配方（请参见<a href="#Empty-Recipes">空配方</a> ）。

</li><li> <a name="index-comments_002c-in-recipes"></a><a name="index-recipes_002c-comments-in"></a><a name="index-_0023-_0028comments_0029_002c-in-recipes"></a>食谱中的评论不是<code>make</code>评论;它将按原样传递到外壳。shell是否将其视为注释取决于您的shell。

</li><li>由制表符缩进的“规则上下文”中的变量定义作为该行的第一个字符，将被视为配方的一部分，而不是<code>make</code>变量定义，并传递给外壳。

</li><li>条件表达式（ <code>ifdef</code> ， <code>ifeq</code>等看<a href="#Conditional-Syntax">条件语句的语法</a> ），其中由标签就行的第一个字符缩进一个“规则上下文”，将被认为是一个配方的一部分，并且被传递到外壳。

</li></ul>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Splitting-Recipe-Lines" accesskey="1">分割配方行</a> ：</td><td>  </td><td align="left" valign="top">打破较长的配方行以提高可读性。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables-in-Recipes" accesskey="2">配方中的变量</a> ：</td><td>  </td><td align="left" valign="top">使用<code>make</code>配方中的变量。
</td></tr>
</tbody></table>

<hr>
<a name="Splitting-Recipe-Lines"></a>
<div class="header">
<p>下一篇： <a href="#Variables-in-Recipes" rel="next" accesskey="n">食谱中的变量</a> ，上一篇： <a href="#Recipe-Syntax" rel="prev" accesskey="p">食谱语法</a> ，上一篇： <a href="#Recipe-Syntax" rel="up" accesskey="u">食谱语法</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Splitting-Recipe-Lines-1"></a>
<h4 class="subsection">5.1.1分割配方行</h4>
<a name="index-recipes_002c-splitting"></a>
<a name="index-splitting-recipes"></a>
<a name="index-recipes_002c-backslash-_0028_005c_0029-in"></a>
<a name="index-recipes_002c-quoting-newlines-in"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-recipes"></a>
<a name="index-_005c-_0028backslash_0029_002c-in-recipes"></a>
<a name="index-quoting-newline_002c-in-recipes"></a>
<a name="index-newline_002c-quoting_002c-in-recipes"></a>

<p>几种方法之一<code>make</code>解释配方是否在换行符之前检查反斜杠。与普通的makefile语法一样，可以通过在每个换行符之前放置一个反斜杠，将单个逻辑配方行拆分为makefile中的多个物理行。像这样的一系列行被视为单个配方行，并且将调用shell的一个实例来运行它。
</p>
<p>但是，与在makefile中的其他位置处理它们的方式相反（请参见<a href="#Splitting-Lines">分割长行</a> ），反斜杠/换行符对<em>不会</em>从配方中删除。反斜杠和换行符都将保留并传递到外壳。反斜杠/换行符的解释方式取决于您的shell。如果反斜杠/换行符之后的下一行的第一个字符是配方前缀字符（默认为制表符；请参见<a href="#Special-Variables">特殊变量</a> ），则该字符（仅该字符）将被删除。绝不会将空格添加到配方中。
</p>
<p>例如，此makefile中所有目标的配方：</p>
<div class="example">
<pre class="example">all :
        @echo no\
space
        @echo no\
        space
        @echo one \
        space
        @echo one\
         space
</pre></div>

<p>由四个单独的shell命令组成，其中输出为：</p>
<div class="example">
<pre class="example">nospace
nospace
one space
one space
</pre></div>

<p>作为一个更复杂的示例，此makefile：</p>
<div class="example">
<pre class="example">all : ; @echo 'hello \
        world' ; echo &quot;hello \
    world&quot;
</pre></div>

<p>将使用以下命令调用一个shell：</p>
<div class="example">
<pre class="example">echo 'hello \
world' ; echo &quot;hello \
    world&quot;
</pre></div>

<p>根据shell引用规则，将产生以下输出：</p>
<div class="example">
<pre class="example">hello \
world
hello     world
</pre></div>

<p>请注意，如何在双引号引起来的字符串内删除反斜杠/换行符对（ <code>"…"</code> ），但不是用单引号引起来的字符串（ <code>'…'</code> ）。这是默认shell（ <samp>/bin/sh</samp> ）处理反斜杠/换行符对。如果您在makefile文件中指定了不同的shell，则可能会对其有所不同。
</p>
<p>有时，您希望在单引号内拆分一长行，但又不希望反斜杠/换行符出现在加引号的内容中。当将脚本传递给Perl等语言时，通常会出现这种情况，其中脚本内部多余的反斜杠可能会改变其含义，甚至可能是语法错误。一种简单的处理方法是将加引号的字符串甚至整个命令放入一个<code>make</code>变量，然后在配方中使用变量。在这种情况下，将使用makefile的换行符引用规则，并且将删除反斜杠/换行符。如果我们使用此方法重写上面的示例：</p>
<div class="example">
<pre class="example">HELLO = 'hello \
world'

all : ; @echo $(HELLO)
</pre></div>

<p>我们将获得如下输出：</p>
<div class="example">
<pre class="example">hello world
</pre></div>

<p>如果愿意，还可以使用特定于目标的变量（请参阅<a href="#Target_002dspecific">特定</a>于<a href="#Target_002dspecific">目标的变量值</a> ）在变量和使用它的配方之间获得更紧密的对应关系。
</p>
<hr>
<a name="Variables-in-Recipes"></a>
<div class="header">
<p>上一页： <a href="#Splitting-Recipe-Lines" rel="prev" accesskey="p">拆分配方行</a> ，向上： <a href="#Recipe-Syntax" rel="up" accesskey="u">配方语法</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-Variables-in-Recipes"></a>
<h4 class="subsection">5.1.2在配方中使用变量</h4>
<a name="index-variable-references-in-recipes"></a>
<a name="index-recipes_002c-using-variables-in"></a>

<p>另一种方式<code>make</code>通过扩展配方中的任何变量引用来处理配方（请参见<a href="#Reference">变量引用基础</a> ）。这是在make完成读取所有makefile并确定目标已过时之后才发生的。因此，不会重建未重建目标的配方。
</p>
<p>配方中的变量和函数引用与makefile中其他位置的引用具有相同的语法和语义。它们的报价规则也相同：如果您希望食谱中出现美元符号，则必须将其加倍（' <samp>$$</samp> '）。对于使用美元符号引入变量的默认外壳之类的外壳，务必牢记要引用的变量是否为<code>make</code>变量（使用单个美元符号）或外壳变量（使用两个美元符号）。例如：</p>
<div class="example">
<pre class="example">LIST = one two three
all:
        for i in $(LIST); do \
            echo $$i; \
        done
</pre></div>

<p>导致以下命令传递到外壳程序：</p>
<div class="example">
<pre class="example">for i in one two three; do \
    echo $i; \
done
</pre></div>

<p>产生预期的结果：</p>
<div class="example">
<pre class="example">one
two
three
</pre></div>

<hr>
<a name="Echoing"></a>
<div class="header">
<p>下一个： <a href="#Execution" rel="next" accesskey="n">执行</a> ，上一个： <a href="#Recipe-Syntax" rel="prev" accesskey="p">配方语法</a> ，上： <a href="#Recipes" rel="up" accesskey="u">配方</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Recipe-Echoing"></a>
<h3 class="section">5.2配方回显</h3>
<a name="index-echoing-of-recipes"></a>
<a name="index-silent-operation"></a>
<a name="index-_0040-_0028in-recipes_0029"></a>
<a name="index-recipes_002c-echoing"></a>
<a name="index-printing-of-recipes"></a>

<p>一般<code>make</code>在执行之前打印配方的每一行。我们之所以称呼它为<em>回声，</em>是因为它看起来像您自己在键入行。
</p>
<p>当一行以“ <samp>@</samp> '，该行的回声被抑制。' <samp>@</samp>在将行传递到外壳之前将'丢弃。通常，您会将此命令用于唯一的效果是打印某些内容的命令，例如<code>echo</code>通过makefile指示进度的命令：</p>
<div class="example">
<pre class="example">@echo About to make distribution files
</pre></div>

<a name="index-_002dn"></a>
<a name="index-_002d_002djust_002dprint"></a>
<a name="index-_002d_002ddry_002drun"></a>
<a name="index-_002d_002drecon"></a>
<p>什么时候<code>make</code>被赋予标志' <samp>-n</samp> ' 要么 ' <samp>--just-print</samp> '它仅回显大多数配方，而不执行它们。请参阅<a href="#Options-Summary">选项摘要</a> 。在这种情况下，即使配方行也以“ <samp>@</samp> '被打印。此标志对于找出哪些食谱很有用<code>make</code>认为有必要而无需实际进行。
</p>
<a name="index-_002ds"></a>
<a name="index-_002d_002dsilent"></a>
<a name="index-_002d_002dquiet"></a>
<a name="index-_002eSILENT-1"></a>
<p>' <samp>-s</samp> ' 要么 ' <samp>--silent</samp>标记为<code>make</code>防止所有回声，就像所有食谱都以“ <samp>@</samp> '。makefile中用于特殊目标的规则<code>.SILENT</code>没有先决条件的效果相同（请参阅<a href="#Special-Targets">特殊内置目标名称</a> ）。
<code>.SILENT</code>由于' <samp>@</samp> '更加灵活。
</p>
<hr>
<a name="Execution"></a>
<div class="header">
<p>下一篇： <a href="#Parallel" rel="next" accesskey="n">并行</a> ，上一篇： <a href="#Echoing" rel="prev" accesskey="p">回声</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Recipe-Execution"></a>
<h3 class="section">5.3配方执行</h3>
<a name="index-recipe_002c-execution"></a>
<a name="index-execution_002c-of-recipes"></a>
<a name="index-SHELL-_0028recipe-execution_0029"></a>

<p>当需要执行配方来更新目标时，可以通过为配方的每一行调用一个新的子外壳来执行它们，除非<code>.ONESHELL</code>有效的特殊目标（请参阅<a href="#One-Shell">使用一个外壳</a> ）（实际上， <code>make</code>可能会采用不影响结果的快捷方式。）
</p>
<a name="index-cd-_0028shell-command_0029"></a>
<a name="index-shell-variables_002c-setting-in-recipes"></a>
<a name="index-recipes-setting-shell-variables"></a>
<p><strong>请注意：</strong>这意味着设置shell变量并调用shell命令，例如<code>cd</code>为每个过程设置本地上下文不会影响配方中的以下行。 <a name="DOCF2" href="#FOOT2"><sup>2</sup></a>如果要使用<code>cd</code>为了影响下一条语句，请将两个语句放在一个配方行中。然后<code>make</code>将调用一个shell来运行整行，并且shell将按顺序执行语句。例如：</p>
<div class="example">
<pre class="example">foo : bar/lose
        cd $(@D) &amp;&amp; gobble $(@F) &gt; ../$@
</pre></div>

<p>在这里我们使用shell AND运算符（ <code>&&</code> ），以便<code>cd</code>命令失败，脚本将失败，而无需尝试调用<code>gobble</code>命令在错误的目录中，这可能会导致问题（在这种情况下，它肯定会导致<samp>../foo</samp>至少被截断）。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#One-Shell" accesskey="1">一壳</a> ：</td><td>  </td><td align="left" valign="top">配方中所有行的一个外壳。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Choosing-the-Shell" accesskey="2">选择外壳</a> ：</td><td>  </td><td align="left" valign="top">怎么样<code>make</code>选择用于运行配方的外壳。
</td></tr>
</tbody></table>

<hr>
<a name="One-Shell"></a>
<div class="header">
<p>下一篇： <a href="#Choosing-the-Shell" rel="next" accesskey="n">选择外壳</a> ，上一篇： <a href="#Execution" rel="prev" accesskey="p">执行</a> ，上一篇： <a href="#Execution" rel="up" accesskey="u">执行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-One-Shell"></a>
<h4 class="subsection">5.3.1使用一个Shell</h4>
<a name="index-recipe-lines_002c-single-shell"></a>
<a name="index-_002eONESHELL_002c-use-of"></a>
<a name="index-_002eONESHELL-1"></a>

<p>有时，您希望将配方中的所有行都传递给shell的单个调用。通常在两种情况下这很有用：首先，它可以通过避免额外的过程来提高配方由许多命令行组成的makefile中的性能。其次，您可能希望将换行符包含在配方命令中（例如，也许您使用的解释器与众不同） <code>SHELL</code> ）。如果<code>.ONESHELL</code>特殊目标出现在makefile中的任何位置，然后将为每个目标提供每个目标的<em>所有</em>配方行。配方行之间的换行符将保留。例如：</p>
<div class="example">
<pre class="example">.ONESHELL:
foo : bar/lose
        cd $(@D)
        gobble $(@F) &gt; ../$@
</pre></div>

<p>即使命令位于不同的配方行，现在也可以按预期工作。
</p>
<p>如果<code>.ONESHELL</code>提供，则仅检查食谱的第一行以查找特殊的前缀字符（“ <samp>@</samp> '，' <samp>-</samp> '和' <samp>+</samp> '）。后续行将在配方行中包含特殊字符， <code>SHELL</code>被调用。如果您希望食谱以这些特殊字符之一开头，则可能需要添加注释或类似内容，以使其不成为第一行中的第一个字符。例如，这将是Perl中的语法错误，因为第一个“ <samp>@</samp> '由make删除：</p>
<div class="example">
<pre class="example">.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        @f = qw(a b c);
        print &quot;@f\n&quot;;
</pre></div>

<p>但是，这些替代方法都可以正常工作：</p>
<div class="example">
<pre class="example">.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        # Make sure &quot;@&quot; is not the first character on the first line
        @f = qw(a b c);
        print &quot;@f\n&quot;;
</pre></div>

<p>要么</p>
<div class="example">
<pre class="example">.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        my @f = qw(a b c);
        print &quot;@f\n&quot;;
</pre></div>

<p>作为一项特殊功能，如果<code>SHELL</code>如果确定是POSIX样式的外壳，则在处理配方之前，“内部”配方行中的特殊前缀字符将<em>被删除</em> 。此功能旨在允许现有的makefile添加<code>.ONESHELL</code>特殊目标，并且无需大量修改即可正常运行。由于特殊前缀字符在POSIX Shell脚本中的行首不合法，因此这不会损失功能。例如，这按预期工作：</p>
<div class="example">
<pre class="example">.ONESHELL:
foo : bar/lose
        @cd $(@D)
        @gobble $(@F) &gt; ../$@
</pre></div>

<p>即使具有此特殊功能，makefile仍具有<code>.ONESHELL</code>会以明显的方式表现不同。例如，通常，如果配方中的任何行失败，则将导致规则失败，并且不再处理任何配方行。下<code>.ONESHELL</code>除了最终配方行以外的任何故障都不会被以下人员注意到<code>make</code> 。您可以修改<code>.SHELLFLAGS</code>添加<code>-e</code> Shell选项，它将导致命令行中任何地方的任何故障都将导致Shell失败，但这本身可能会导致您的配方行为不同。最终，您可能需要加强配方行以使它们可以使用<code>.ONESHELL</code> 。
</p>
<hr>
<a name="Choosing-the-Shell"></a>
<div class="header">
<p>上一页： <a href="#One-Shell" rel="prev" accesskey="p">一个外壳</a> ，向上： <a href="#Execution" rel="up" accesskey="u">执行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Choosing-the-Shell-1"></a>
<h4 class="subsection">5.3.2选择外壳</h4>
<a name="index-shell_002c-choosing-the"></a>
<a name="index-SHELL_002c-value-of"></a>
<a name="index-_002eSHELLFLAGS_002c-value-of"></a>

<a name="index-SHELL"></a>
<a name="index-_002eSHELLFLAGS"></a>
<p>用作外壳的程序取自变量<code>SHELL</code> 。如果您的makefile中未设置此变量，则程序<samp>/bin/sh</samp>用作外壳。传递给外壳的参数是从变量中获取的<code>.SHELLFLAGS</code> 。的默认值<code>.SHELLFLAGS</code>是<code>-c</code>通常，或者<code>-ec</code>在符合POSIX的模式下。
</p>
<a name="index-environment_002c-SHELL-in"></a>
<p>与大多数变量不同，变量<code>SHELL</code>永远不会受到环境的影响。这是因为<code>SHELL</code>环境变量用于指定您对交互式使用的shell程序的个人选择。这样的个人选择会影响makefile的功能，这将是非常糟糕的。请参阅<a href="#Environment">环境变量</a> 。
</p>
<p>此外，当您设置<code>SHELL</code>在您的makefile中，该值<em>不会</em>在环境中导出到配方行<code>make</code>调用。相反，将从用户环境继承的值（如果有）导出。您可以通过显式导出来覆盖此行为<code>SHELL</code> （请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> ），强制将其在环境中传递到配方行。
</p>
<a name="index-MAKESHELL-_0028MS_002dDOS-alternative-to-SHELL_0029"></a>
<p>但是，在MS-DOS和MS-Windows上， <code>SHELL</code>使用环境<strong>中的</strong>变量，因为在这些系统上大多数用户都未设置此变量，因此很有可能将其专门设置为由<code>make</code> 。在MS-DOS上，如果设置<code>SHELL</code>不适合<code>make</code> ，您可以设置变量<code>MAKESHELL</code>到壳<code>make</code>应该使用；如果设置，它将用作外壳，而不是值<code>SHELL</code> 。
</p>
<a name="Choosing-a-Shell-in-DOS-and-Windows"></a>
<h4 class="subsubheading">在DOS和Windows中选择Shell</h4>
<a name="index-shell_002c-in-DOS-and-Windows"></a>
<a name="index-DOS_002c-choosing-a-shell-in"></a>
<a name="index-Windows_002c-choosing-a-shell-in"></a>

<p>与其他系统相比，在MS-DOS和MS-Windows中选择外壳要复杂得多。
</p>
<a name="index-COMSPEC"></a>
<p>在MS-DOS上，如果<code>SHELL</code>未设置，变量的值<code>COMSPEC</code> （始终设置）（代替）。
</p>
<a name="index-SHELL_002c-MS_002dDOS-specifics"></a>
<p>设置变量的行的处理<code>SHELL</code> Makefile中的内容在MS-DOS上是不同的。库存壳<samp>command.com</samp> ，其功能受到可笑的限制，并且许多用户<code>make</code>倾向于安装替换壳。因此，在MS-DOS上， <code>make</code>检查的价值<code>SHELL</code> ，并根据指向Unix风格还是DOS风格的外壳来更改其行为。即使有<code>SHELL</code>指着<samp>command.com</samp> 。
</p>
<p>如果<code>SHELL</code>指向Unix风格的shell， <code>make</code>在MS-DOS上还检查是否确实可以找到该外壳程序；如果不是，它将忽略设置的行<code>SHELL</code> 。在MS-DOS，GNU <code>make</code>在以下位置搜索shell：</p>
<ol>
<li>在精确值所指向的位置<code>SHELL</code> 。例如，如果makefile指定“ <samp>SHELL = /bin/sh</samp> '， <code>make</code>将在目录中查找<samp>/bin</samp>在当前驱动器上。

</li><li>在当前目录中。

</li><li>在每个目录中<code>PATH</code>变量，按顺序。

</li></ol>

<p>在每个目录中， <code>make</code>首先将查找特定文件（ <samp>sh</samp>在上面的示例中）。如果找不到此文件，它还将在该目录中查找具有识别可执行文件的已知扩展名之一的文件。例如<samp>.exe</samp> ， <samp>.com</samp> ， <samp>.bat</samp> ， <samp>.btm</samp> ， <samp>.sh</samp> ，以及其他一些。
</p>
<p>如果这些尝试中的任何一个成功，则<code>SHELL</code>将设置为找到的外壳程序的完整路径名。但是，如果未找到这些值，则<code>SHELL</code>不会更改，因此设置该行的行将被有效忽略。就是这样<code>make</code>仅在Unix风格的shell实际安装在以下系统上时才支持该功能： <code>make</code>运行。
</p>
<p>请注意，对shell的这种扩展搜索仅限于以下情况： <code>SHELL</code>是从Makefile设置的；如果是在环境或命令行中设置的，则应将其设置为shell的完整路径名，就像在Unix上一样。
</p>
<p>上述特定于DOS的处理的结果是，一个包含' <samp>SHELL = /bin/sh</samp> '（就像许多Unix makefile一样），如果您有以下要求，它将在MS-DOS上保持不变<samp>sh.exe</samp>安装在您的某个目录中<code>PATH</code> 。
</p>
<a name="index-SHELL-1"></a>
<a name="index-_002eSHELLFLAGS-1"></a>

<hr>
<a name="Parallel"></a>
<div class="header">
<p>下一个： <a href="#Errors" rel="next" accesskey="n">错误</a> ，上一个： <a href="#Execution" rel="prev" accesskey="p">执行</a> ，上一个： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Parallel-Execution"></a>
<h3 class="section">5.4并行执行</h3>
<a name="index-recipes_002c-execution-in-parallel"></a>
<a name="index-parallel-execution"></a>
<a name="index-execution_002c-in-parallel"></a>
<a name="index-job-slots"></a>
<a name="index-_002dj"></a>
<a name="index-_002d_002djobs"></a>

<p>GNU <code>make</code>知道如何一次执行多个配方。一般， <code>make</code>一次只能执行一个配方，等待完成后再执行下一个。然而 ' <samp>-j</samp> ' 要么 ' <samp>--jobs</samp> '选项告诉<code>make</code>同时执行许多配方您可以使用<code>.NOTPARALLEL</code>伪目标（请参阅<a href="#Special-Targets">特殊内置目标名称</a> ）。
</p>
<p>在MS-DOS上， <samp>-j</samp> '选项无效，因为该系统不支持多处理。
</p>
<p>如果“ <samp>-j</samp> '选项后跟一个整数，这是一次执行的配方数；这称为<em>作业插槽数</em> 。如果在'之后没有看起来像整数的东西<samp>-j</samp> '选项，对作业位置的数量没有限制。作业插槽的默认数量是1，这意味着串行执行（一次执行一次）。
</p>
<p>处理递归<code>make</code>调用会引发并行执行的问题。有关此信息，请参阅将<a href="#Options_002fRecursion">选项传达给<code>make</code></a> 。
</p>
<p>如果某个配方失败（被信号杀死或以非零状态退出），并且该配方的错误不会被忽略（请参见<a href="#Errors">“</a>配方中的<a href="#Errors">错误”</a> ），那么将不会运行用于重新制作相同目标的其余配方行。如果配方失败，并且“ <samp>-k</samp> ' 要么 ' <samp>--keep-going</samp> '未提供选项（请参阅“选项<a href="#Options-Summary">摘要”</a> ）， <code>make</code>中止执行。如果make在子进程正在运行时由于任何原因（包括信号）终止，它将等待它们完成后才实际退出。
</p>
<a name="index-load-average"></a>
<a name="index-limiting-jobs-based-on-load"></a>
<a name="index-jobs_002c-limiting-based-on-load"></a>
<a name="index-_002dl-_0028load-average_0029"></a>
<a name="index-_002d_002dmax_002dload"></a>
<a name="index-_002d_002dload_002daverage"></a>
<p>当系统负载很重时，您可能要比轻负载时运行更少的作业。您可以使用“ <samp>-l</samp> '选项告诉<code>make</code>根据平均负载来限制一次运行的作业数。' <samp>-l</samp> ' 要么 ' <samp>--max-load</samp> '选项后跟浮点数。例如，</p>
<div class="example">
<pre class="example">-l 2.5
</pre></div>

<p>不会让<code>make</code>如果平均负载高于2.5，则开始一项以上的工作。' <samp>-l</samp>如果后面没有数字，则不带数字的选项将删除负载限制<samp>-l</samp> ' 选项。
</p>
<p>更确切地说，何时<code>make</code>开始一项作业，并且它已经至少有一项作业正在运行，它会检查当前的平均负载；如果不低于' <samp>-l</samp> '， <code>make</code>等待，直到平均负载低于该限制，或者直到所有其他作业完成。
</p>
<p>默认情况下，没有负载限制。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Parallel-Output" accesskey="1">并行输出</a> ：</td><td>  </td><td align="left" valign="top">在并行执行期间处理输出</td></tr>
<tr><td align="left" valign="top">• <a href="#Parallel-Input" accesskey="2">并行输入</a> ：</td><td>  </td><td align="left" valign="top">在并行执行期间处理输入</td></tr>
</tbody></table>

<hr>
<a name="Parallel-Output"></a>
<div class="header">
<p>下一个： <a href="#Parallel-Input" rel="next" accesskey="n">并行输入</a> ，上一个： <a href="#Parallel" rel="prev" accesskey="p">并行</a> ，上一个： <a href="#Parallel" rel="up" accesskey="u">并行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Output-During-Parallel-Execution"></a>
<h4 class="subsection">5.4.1并行执行时的输出</h4>
<a name="index-output-during-parallel-execution"></a>
<a name="index-parallel-execution_002c-output-during"></a>

<p>当并行运行多个配方时，每个配方的输出都会在生成后立即出现，结果可能会散布来自不同配方的消息，有时甚至出现在同一行上。这会使读取输出变得非常困难。
</p>
<a name="index-_002d_002doutput_002dsync"></a>
<a name="index-_002dO"></a>
<p>为避免这种情况，您可以使用“ <samp>--output-sync</samp> '（' <samp>-O</samp> '） 选项。该选项指示<code>make</code>保存命令调用的输出，并在命令完成后立即打印所有输出。此外，如果有多个递归<code>make</code>调用并行运行时，它们将进行通信，以便一次只有一个生成输出。
</p>
<p>如果启用了工作目录打印（请参阅<a href="#g_t_002dw-Option">“ <samp>--print-directory</samp> '选项</a> ），在每个输出分组周围打印输入/离开消息。如果您不想看到这些消息，请添加“ <samp>--no-print-directory</samp> '选项<code>MAKEFLAGS</code> 。
</p>
<p>同步输出时，粒度分为四个级别，具体方法是为该选项提供参数（例如，“ <samp>-Oline</samp> ' 要么 ' <samp>--output-sync=recurse</samp> '）。
</p>
<dl compact>
<dt><code>none</code></dt>
<dd><p>这是默认设置：所有输出在生成时都直接发送，并且不执行同步。
</p>
</dd>
<dt><code>line</code></dt>
<dd><p>配方的每一行的输出都会被分组并在该行完成后立即打印。如果一个配方由多行组成，则它们可能散布着其他配方中的行。
</p>
</dd>
<dt><code>target</code></dt>
<dd><p>目标完成后，每个目标的整个配方的输出将分组并打印。如果<code>--output-sync</code>要么<code>-O</code>选项不带参数。
</p>
</dd>
<dt><code>recurse</code></dt>
<dd><p>每次递归调用的输出<code>make</code>递归调用完成后，将分组并打印。
</p>
</dd>
</dl>

<p>无论选择哪种模式，总的构建时间都是相同的。唯一的区别在于输出的显示方式。
</p>
<p>' <samp>target</samp> '和' <samp>recurse</samp>模式既可以收集目标的整个配方的输出，也可以在配方完成时不间断地显示输出。它们之间的区别在于包含以下内容的递归调用的配方<code>make</code>已处理（请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。对于所有没有递归行的配方，“ <samp>target</samp> '和' <samp>recurse</samp> '模式的行为相同。
</p>
<p>如果“ <samp>recurse</samp> '模式被选择，包含递归的配方<code>make</code>调用与其他目标的处理方式相同：配方的输出，包括递归的输出<code>make</code>整个配方完成后，将保存并打印。这样可以确保给定递归构建的所有目标的输出<code>make</code>实例组合在一起，这可能会使输出更易于理解。但是，这还会在构建期间导致较长的时间，导致看不到任何输出，随后是大量的输出突发。如果您不是在继续进行构建，而是在事后查看构建日志，那么这可能是您的最佳选择。
</p>
<p>如果您正在观看输出，则在构建期间的长时间空白可能会令人沮丧。' <samp>target</samp> '输出同步模式检测何时<code>make</code>将使用标准方法递归调用，并且不会同步这些行的输出。递归<code>make</code>将对其目标执行同步，并且每个目标的输出将在完成时立即显示。请注意，配方的递归行的输出未同步（例如，如果递归行在运行前打印了一条消息， <code>make</code> ，则该消息将不会同步）。
</p>
<p>' <samp>line</samp> '模式对于正在监视输出的前端很有用<code>make</code>跟踪何时开始和完成配方。
</p>
<p>一些程序被调用<code>make</code>如果他们确定将输出写入到终端而不是文件（通常称为“交互”与“非交互”模式），它们的行为可能会有所不同。例如，许多可以显示彩色输出的程序在确定未写入终端时不会这样做。如果您的makefile调用了这样的程序，则使用输出同步选项将使该程序相信它正在“非交互式”模式下运行，即使输出最终将到达终端。
</p>
<hr>
<a name="Parallel-Input"></a>
<div class="header">
<p>上一篇： <a href="#Parallel-Output" rel="prev" accesskey="p">并行输出</a> ，上一篇： <a href="#Parallel" rel="up" accesskey="u">并行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Input-During-Parallel-Execution"></a>
<h4 class="subsection">5.4.2并行执行时的输入</h4>
<a name="index-input-during-parallel-execution"></a>
<a name="index-parallel-execution_002c-input-during"></a>
<a name="index-standard-input"></a>

<p>两个进程不能同时从同一设备获取输入。为了确保只有一个配方尝试一次从终端接收输入， <code>make</code>将使除一个运行配方外的所有配方的标准输入流无效。如果其他配方尝试从标准输入中读取内容，则通常会导致致命错误（“ <samp>Broken pipe</samp>信号）。
<a name="index-broken-pipe"></a>
</p>
<p>无法预测哪个配方将具有有效的标准输入流（它将来自终端，或者无论您重定向到哪个标准输入<code>make</code> ）。第一次运行配方将始终优先处理该操作，完成后开始的第一个配方将处理该操作，依此类推。
</p>
<p>我们将改变这方面的<code>make</code>如果我们找到更好的选择，它会起作用。同时，如果使用并行执行功能，则完全不应依赖使用标准输入的任何配方。但是如果您不使用此功能，则标准输入在所有配方中均正常工作。
</p>
<hr>
<a name="Errors"></a>
<div class="header">
<p>下一篇： <a href="#Interrupts" rel="next" accesskey="n">中断</a> ，上一篇： <a href="#Parallel" rel="prev" accesskey="p">并行</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Errors-in-Recipes"></a>
<h3 class="section">5.5食谱中的错误</h3>
<a name="index-errors-_0028in-recipes_0029"></a>
<a name="index-recipes_002c-errors-in"></a>
<a name="index-exit-status-_0028errors_0029"></a>

<p>每次shell调用返回后， <code>make</code>查看其退出状态。如果外壳程序成功完成（退出状态为零），则在新外壳程序中执行配方中的下一行；最后一行完成后，规则完成。
</p>
<p>如果有错误（退出状态为非零）， <code>make</code>放弃当前的规则，也许放弃所有规则。
</p>
<p>有时某个配方行的失败并不表示有问题。例如，您可以使用<code>mkdir</code>命令以确保目录存在。如果目录已经存在， <code>mkdir</code>将报告错误，但您可能想要<code>make</code>继续不管。
</p>
<a name="index-_002d-_0028in-recipes_0029"></a>
<p>要忽略配方行中的错误，请写一个“ <samp>-</samp>在该行文本的开头（在初始标签之后）。' <samp>-</samp>在将行传递到外壳程序之前，将'丢弃。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">clean:
        -rm -f *.o
</pre></div>
<a name="index-rm-_0028shell-command_0029-3"></a>

<p>这导致<code>make</code>即使<code>rm</code>无法删除文件。
</p>
<a name="index-_002di"></a>
<a name="index-_002d_002dignore_002derrors"></a>
<a name="index-_002eIGNORE-1"></a>
<p>当你跑步<code>make</code>与“ <samp>-i</samp> ' 要么 ' <samp>--ignore-errors</samp> '标志，所有规则的所有配方中的错误都将被忽略。makefile中用于特殊目标的规则<code>.IGNORE</code>如果没有先决条件，则效果相同。这些忽略错误的方法已经过时，因为“ <samp>-</samp> '更加灵活。
</p>
<p>当错误被忽略时，由于“ <samp>-</samp> ' 或者 ' <samp>-i</samp> '标志， <code>make</code>将错误返回与成功一样对待，除了它会输出一条消息，告诉您退出shell的状态代码，并指出错误已被忽略之外。
</p>
<p>当发生错误时<code>make</code>没有被告知要忽略它，这意味着不能正确地重制当前目标，并且任何直接或间接依赖它的目标也不能正确地进行重造。由于尚未达到其前提条件，因此将不再针对这些目标执行任何配方。
</p>

<a name="index-_002dk"></a>
<a name="index-_002d_002dkeep_002dgoing"></a>
<p>一般<code>make</code>在这种情况下立即放弃，返回非零状态。但是，如果“ <samp>-k</samp> ' 要么 ' <samp>--keep-going</samp> '标志已指定， <code>make</code>继续考虑挂起目标的其他先决条件，如有必要，在放弃并返回非零状态之前对其进行重新制作。例如，在编译一个目标文件时出错后，“ <samp>make -k</samp> ”将继续编译其他目标文件，即使它已经知道不可能链接它们。请参阅<a href="#Options-Summary">选项摘要</a> 。
</p>
<p>通常的行为是假设您的目的是使指定的目标保持最新。一旦<code>make</code>了解到这是不可能的，因此不妨立即报告故障。' <samp>-k</samp> '选项说，真正的目的是测试程序中所做的尽可能多的更改，也许是找到几个独立的问题，以便您可以在下次尝试编译之前将它们全部纠正。这就是为什么Emacs <code>compile</code>命令传递' <samp>-k</samp> '标记为默认值。
<a name="index-Emacs-_0028M_002dx-compile_0029"></a>
</p>
<a name="index-_002eDELETE_005fON_005fERROR-1"></a>
<a name="index-deletion-of-target-files"></a>
<a name="index-removal-of-target-files"></a>
<a name="index-target_002c-deleting-on-error"></a>
<p>通常，当配方行失败时，如果它根本改变了目标文件，则该文件已损坏且无法使用-或至少没有完全更新。但是文件的时间戳表明它是最新的，因此下一次<code>make</code>运行，它将不会尝试更新该文件。这种情况与外壳被信号杀死时的情况相同。请参见<a href="#Interrupts">中断</a> 。因此，通常的正确做法是，如果在开始更改文件后配方失败，则删除目标文件。 <code>make</code>如果这样做<code>.DELETE_ON_ERROR</code>出现为目标。这几乎总是您想要的<code>make</code>这样做，但这不是历史惯例；因此，为了兼容，您必须明确要求它。
</p>
<hr>
<a name="Interrupts"></a>
<div class="header">
<p>下一篇： <a href="#Recursion" rel="next" accesskey="n">递归</a> ，上一篇： <a href="#Errors" rel="prev" accesskey="p">错误</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Interrupting-or-Killing-make"></a>
<h3 class="section">5.6干扰或杀死<code>make</code></h3>
<a name="index-interrupt"></a>
<a name="index-signal"></a>
<a name="index-deletion-of-target-files-1"></a>
<a name="index-removal-of-target-files-1"></a>
<a name="index-target_002c-deleting-on-interrupt"></a>
<a name="index-killing-_0028interruption_0029"></a>

<p>如果<code>make</code>在执行Shell时收到致命信号，它可能会删除本应更新配方的目标文件。如果目标文件的上次修改时间自<code>make</code>首先检查它。
</p>
<p>删除目标的目的是确保在重新构建目标时重新创建目标<code>make</code>下一次运行。为什么是这样？假设您输入<kbd>Ctrl-c</kbd>当编译器正在运行时，它已经开始写入目标文件<samp>foo.o</samp> 。的<kbd>Ctrl-c</kbd>杀死编译器，导致文件不完整，其最后修改时间比源文件新<samp>foo.c</samp> 。但<code>make</code>也收到<kbd>Ctrl-c</kbd>信号并删除此不完整的文件。如果<code>make</code>没有这样做，下次调用<code>make</code>会认为<samp>foo.o</samp>不需要更新-当链接器尝试链接缺少一半的目标文件时，会导致来自链接器的奇怪错误消息。
</p>
<a name="index-_002ePRECIOUS-1"></a>
<p>您可以通过设置特殊目标来防止删除目标文件<code>.PRECIOUS</code>依靠它。在重新制定目标之前， <code>make</code>检查以查看它是否出现在<code>.PRECIOUS</code> ，从而确定如果发生信号是否应删除目标。可能要执行此操作的某些原因是，目标已以某种原子方式进行更新，或者仅存在以记录修改时间（其内容无关紧要），或者必须始终存在以防止其他类型的麻烦。
</p>
<hr>
<a name="Recursion"></a>
<div class="header">
<p>下一篇： <a href="#Canned-Recipes" rel="next" accesskey="n">罐装食谱</a> ，上一篇： <a href="#Interrupts" rel="prev" accesskey="p">中断</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Recursive-Use-of-make"></a>
<h3 class="section">5.7递归使用<code>make</code></h3>
<a name="index-recursion"></a>
<a name="index-subdirectories_002c-recursion-for"></a>

<p>递归使用<code>make</code>意味着使用<code>make</code>作为makefile中的命令。当您需要组成大型系统的各个子系统的单独makefile时，此技术很有用。例如，假设您有一个子目录<samp>subdir</samp>它有自己的makefile，并且您希望运行包含目录的makefile <code>make</code>在子目录上。您可以这样编写：</p>
<div class="example">
<pre class="example">subsystem:
        cd subdir &amp;&amp; $(MAKE)
</pre></div>

<p>或等效地，这（请参阅<a href="#Options-Summary">“选项摘要”</a> ）：</p>
<div class="example">
<pre class="example">subsystem:
        $(MAKE) -C subdir
</pre></div>
<a name="index-_002dC"></a>
<a name="index-_002d_002ddirectory"></a>

<p>您可以编写递归<code>make</code>仅通过复制此示例来命令，但是关于它们的工作原理，原因以及子菜单如何操作，还有很多事情要知道<code>make</code>与顶层有关<code>make</code> 。您可能还会发现声明调用递归的目标很有用<code>make</code>命令为<samp>.PHONY</samp> ”（有关何时有用的更多讨论，请参见<a href="#Phony-Targets">Phony Targets</a> ）。
</p>
<a name="index-CURDIR"></a>
<p>为了您的方便，当GNU <code>make</code>开始（处理完任何<code>-C</code>选项）设置变量<code>CURDIR</code>到当前工作目录的路径名。永远不会触动这个价值<code>make</code>再次：特别注意，如果您包含其他目录中的文件，则<code>CURDIR</code>不会改变。该值具有与在makefile中设置的优先级相同的优先级（默认情况下，环境变量<code>CURDIR</code>不会覆盖此值）。请注意，设置此变量不会影响<code>make</code> （这不会导致<code>make</code>例如，更改其工作目录）。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">•制作<a href="#MAKE-Variable" accesskey="1">变量</a> ：</td><td>  </td><td align="left" valign="top">使用'的特殊效果<samp>$(MAKE)</samp> '。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Variables_002fRecursion" accesskey="2">变量/递归</a> ：</td><td>  </td><td align="left" valign="top">如何将变量传达给子<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Options_002fRecursion" accesskey="3">选项/递归</a> ：</td><td>  </td><td align="left" valign="top">如何将选项传达给子<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#g_t_002dw-Option" accesskey="4">-w选项</a> ：</td><td>  </td><td align="left" valign="top">如何<samp>-w</samp> ' 要么 ' <samp>--print-directory</samp> '选项有助于调试递归的使用<code>make</code>命令。
</td></tr>
</tbody></table>

<hr>
<a name="MAKE-Variable"></a>
<div class="header">
<p>下一页： <a href="#Variables_002fRecursion" rel="next" accesskey="n">变量/递归</a> ，上一篇： <a href="#Recursion" rel="prev" accesskey="p">递归</a> ，向上： <a href="#Recursion" rel="up" accesskey="u">递归</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-the-MAKE-Variable-Works"></a>
<h4 class="subsection">5.7.1如何<code>MAKE</code>可变作品</h4>
<a name="index-MAKE"></a>
<a name="index-recursion_002c-and-MAKE-variable"></a>

<p>递归的<code>make</code>命令应始终使用变量<code>MAKE</code> ，而不是显式命令名称' <samp>make</samp> '，如下所示：</p>
<div class="example">
<pre class="example">subsystem:
        cd subdir &amp;&amp; $(MAKE)
</pre></div>

<p>该变量的值是文件名， <code>make</code>被调用。如果此文件名是<samp>/bin/make</samp> ，则执行的配方为“ <samp>cd subdir && /bin/make</samp> '。如果您使用特殊版本的<code>make</code>要运行顶层makefile，将为递归调用执行相同的特殊版本。
<a name="index-cd-_0028shell-command_0029-1"></a>
</p>
<a name="index-_002b_002c-and-recipes"></a>
<p>作为一项特殊功能，使用变量<code>MAKE</code>在规则的配方中会更改“ <samp>-t</samp> '（' <samp>--touch</samp> '），' <samp>-n</samp> '（' <samp>--just-print</samp> '）， 要么 ' <samp>-q</samp> '（' <samp><span class="nolinebreak">--question</span></samp> ' <!-- /@w --> ）选项。使用<code>MAKE</code>变量与使用' <samp>+</samp>配方行开头的'字符。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。仅在以下情况下启用此特殊功能： <code>MAKE</code>变量直接显示在配方中：如果<code>MAKE</code>通过扩展另一个变量来引用该变量。在后一种情况下，您必须使用“ <samp>+</samp>获得这些特殊效果的令牌。
</p>
<p>考虑命令“ <samp>make -t</samp>在上述示例中。（“ <samp>-t</samp> '选项将目标标记为最新，而无需实际运行任何配方；请参见<a href="#Instead-of-Execution">代替执行</a> 。）遵循“ <samp>-t</samp> '， 一种 ' <samp>make -t</samp>示例中的'命令将创建一个名为<samp>subsystem</samp>什么也别做。您真正想要的是运行“ <samp>cd subdir &&
<!-- /@w --> make <span class="nolinebreak">-t</span>
<!-- /@w --></samp> ';但这需要执行配方，并且' <samp>-t</samp> '说不执行食谱。
<a name="index-_002dt_002c-and-recursion"></a>
<a name="index-recursion_002c-and-_002dt"></a>
<a name="index-_002d_002dtouch_002c-and-recursion"></a>
</p>
<p>特殊功能使它可以执行您想要的操作：每当规则的配方行包含变量时<code>MAKE</code> ，旗帜<samp>-t</samp> '，' <samp>-n</samp> '和' <samp>-q</samp> '不适用于该行。配方行包含<code>MAKE</code>尽管存在导致大多数配方无法运行的标志，但它们仍可正常执行。通常<code>MAKEFLAGS</code>机制将标志传递给子<code>make</code> （请参阅将<a href="#Options_002fRecursion">选项传达给<code>make</code></a> ），因此您触摸文件或打印配方的请求会传播到子系统。
</p>
<hr>
<a name="Variables_002fRecursion"></a>
<div class="header">
<p>下一个： <a href="#Options_002fRecursion" rel="next" accesskey="n">选项/递归</a> ，上一个： <a href="#MAKE-Variable" rel="prev" accesskey="p">MAKE变量</a> ，上： <a href="#Recursion" rel="up" accesskey="u">递归</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Communicating-Variables-to-a-Sub_002dmake"></a>
<h4 class="subsection">5.7.2将变量传递给子对象<code>make</code></h4>
<a name="index-sub_002dmake"></a>
<a name="index-environment_002c-and-recursion"></a>
<a name="index-exporting-variables"></a>
<a name="index-variables_002c-environment"></a>
<a name="index-variables_002c-exporting"></a>
<a name="index-recursion_002c-and-environment"></a>
<a name="index-recursion_002c-and-variables"></a>

<p>顶层的变量值<code>make</code>可以传递给子<code>make</code>通过环境的明确要求。这些变量在子目录中定义<code>make</code>作为默认值，但它们不会覆盖子文件使用的makefile中定义的变量， <code>make</code>除非您使用“ <samp>-e</samp> '开关（请参阅<a href="#Options-Summary">“选项摘要”</a> ）。
</p>
<p>要传递或<em>导出</em>变量， <code>make</code>将变量及其值添加到用于运行配方每一行的环境中。子<code>make</code>依次使用环境初始化其变量值表。请参阅<a href="#Environment">环境变量</a> 。
</p>
<p>除明确要求外， <code>make</code>仅当变量是在环境中初始定义或在命令行上设置且其名称仅由字母，数字和下划线组成时，才导出变量。某些外壳无法处理由字母，数字和下划线以外的字符组成的环境变量名称。
</p>
<a name="index-SHELL_002c-exported-value"></a>
<p>的价值<code>make</code>变量<code>SHELL</code>不导出。相反， <code>SHELL</code>调用环境中的变量传递到子<code>make</code> 。你可以强迫<code>make</code>出口其价值<code>SHELL</code>通过使用<code>export</code>指令，如下所述。请参阅<a href="#Choosing-the-Shell">选择外壳</a> 。
</p>
<p>特殊变量<code>MAKEFLAGS</code>总是被导出（除非您取消导出）。 <code>MAKEFILES</code>如果将其设置为任何内容，则将导出。
</p>
<p><code>make</code>通过将命令行中定义的变量值放到<code>MAKEFLAGS</code>变量。请参阅<a href="#Options_002fRecursion">选项/递归</a> 。
</p>
<p>如果默认情况下创建变量，则通常<em>不会</em>传递这些变量<code>make</code> （请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> ）。子<code>make</code>将自己定义这些。
</p>
<a name="index-export"></a>
<p>如果要将特定变量导出到子目录， <code>make</code> ， 使用<code>export</code>指令，如下所示：</p>
<div class="example">
<pre class="example">export <var>variable</var> &hellip;
</pre></div>

<p><a name="index-unexport"></a>如果要<em>防止</em>导出变量，请使用<code>unexport</code>指令，如下所示：</p>
<div class="example">
<pre class="example">unexport <var>variable</var> &hellip;
</pre></div>

<p>在这两种形式中， <code>export</code>和<code>unexport</code>进行了扩展，因此变量或函数也可以扩展为要（未）导出的变量名（列表）。
</p>
<p>为了方便起见，您可以通过执行以下操作来定义变量并同时将其导出：</p>
<div class="example">
<pre class="example">export <var>variable</var> = value
</pre></div>

<p>具有与以下相同的结果：</p>
<div class="example">
<pre class="example"><var>variable</var> = value
export <var>variable</var>
</pre></div>

<p>和</p>
<div class="example">
<pre class="example">export <var>variable</var> := value
</pre></div>

<p>具有与以下相同的结果：</p>
<div class="example">
<pre class="example"><var>variable</var> := value
export <var>variable</var>
</pre></div>

<p>同样</p>
<div class="example">
<pre class="example">export <var>variable</var> += value
</pre></div>

<p>就像：</p>
<div class="example">
<pre class="example"><var>variable</var> += value
export <var>variable</var>
</pre></div>

<p>请参见<a href="#Appending">在变量中添加更多文本</a> 。
</p>
<p>您可能会注意到<code>export</code>和<code>unexport</code>指令在<code>make</code>就像它们在外壳中工作一样<code>sh</code> 。
</p>
<p>如果要默认导出所有变量，则可以使用<code>export</code>通过它自己：</p>
<div class="example">
<pre class="example">export
</pre></div>

<p>这说明<code>make</code>没有明确提到的变量<code>export</code>要么<code>unexport</code>指令应该被导出。变量中给定的任何变量<code>unexport</code>指令仍<em>不会</em>导出。如果您使用<code>export</code>本身会默认导出变量，除非其名称中包含字母数字和下划线以外的字符，否则不会导出变量。 <code>export</code>指示。
</p>
<a name="index-_002eEXPORT_005fALL_005fVARIABLES-1"></a>
<p>由某人引起的行为<code>export</code>指令本身是旧版GNU中的默认设置<code>make</code> 。如果您的makefile依赖于此行为，并且您希望与旧版本的<code>make</code> ，您可以为特殊目标编写规则<code>.EXPORT_ALL_VARIABLES</code>而不是使用<code>export</code>指示。这将被旧的忽略<code>make</code> s，而<code>export</code>指令将导致语法错误。
<a name="index-compatibility-in-exporting"></a>
</p>
<p>同样，您可以使用<code>unexport</code>自己告诉<code>make</code>默认情况下<em>不</em>导出变量。由于这是默认行为，因此仅在以下情况下才需要这样做<code>export</code>以前已经被自己使用过（也许在包含的makefile中）。你<strong>不能</strong>使用<code>export</code>和<code>unexport</code>自己将变量导出为某些配方而不是其他配方。最后<code>export</code>要么<code>unexport</code>本身出现的指令决定了整个过程的行为<code>make</code> 。
</p>
<a name="index-MAKELEVEL"></a>
<a name="index-recursion_002c-level-of"></a>
<p>作为一项特殊功能，变量<code>MAKELEVEL</code>逐级向下传递时更改。该变量的值是一个字符串，它是级别的深度（以十进制数字表示）。该值为“ <samp>0</samp> '代表顶层<code>make</code> ; ' <samp>1</samp> '为子<code>make</code> ，' <samp>2</samp> '为子子<code>make</code> ， 等等。增量发生在<code>make</code>为配方设置环境。
</p>
<p>主要用途<code>MAKELEVEL</code>将在条件指令中对其进行测试（请参见<a href="#Conditionals">Makefile的条件部分</a> ）；这样，您可以编写一个makefile，如果递归运行该makefile则表现为一种方式，而如果您直接运行该makefile则表现为另一种方式。
</p>
<a name="index-MAKEFILES-1"></a>
<p>您可以使用变量<code>MAKEFILES</code>导致所有子<code>make</code>使用其他生成文件的命令。的价值<code>MAKEFILES</code>是由空格分隔的文件名列表。如果在外部生成文件中定义了此变量，则该变量将通过环境传递；然后将其作为该子目录的额外makefile列表<code>make</code>在通常或指定的阅读之前阅读。见<a href="#MAKEFILES-Variable">变量<code>MAKEFILES</code></a> 。
</p>
<hr>
<a name="Options_002fRecursion"></a>
<div class="header">
<p>下一篇： <a href="#g_t_002dw-Option" rel="next" accesskey="n">-w选项</a> ，上一篇： <a href="#Variables_002fRecursion" rel="prev" accesskey="p">变量/递归</a> ，上一篇： <a href="#Recursion" rel="up" accesskey="u">递归</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Communicating-Options-to-a-Sub_002dmake"></a>
<h4 class="subsection">5.7.3将选项传达给子<code>make</code></h4>
<a name="index-options_002c-and-recursion"></a>
<a name="index-recursion_002c-and-options"></a>

<a name="index-MAKEFLAGS"></a>
<p>诸如“ <samp>-s</samp> '和' <samp>-k</samp> '会自动传递给<code>make</code>通过变量<code>MAKEFLAGS</code> 。此变量由以下用户自动设置<code>make</code>包含标志字母<code>make</code>收到。因此，如果您<samp>make <span class="nolinebreak">-ks</span></samp> ' <!-- /@w -->然后<code>MAKEFLAGS</code>获得价值' <samp>ks</samp> '。
</p>
<p>因此，每个子<code>make</code>获得价值<code>MAKEFLAGS</code>在其环境中。作为响应，它从该值中获取标志并对其进行处理，就像将它们作为参数给出一样。请参阅<a href="#Options-Summary">选项摘要</a> 。
</p>
<a name="index-command-line-variable-definitions_002c-and-recursion"></a>
<a name="index-variables_002c-command-line_002c-and-recursion"></a>
<a name="index-recursion_002c-and-command-line-variable-definitions"></a>
<p>同样，在命令行上定义的变量也会传递给子<code>make</code>通过<code>MAKEFLAGS</code> 。字的价值<code>MAKEFLAGS</code>包含“ <samp>=</samp> '， <code>make</code>将其视为变量定义，就像它们出现在命令行中一样。请参阅<a href="#Overriding">覆盖变量</a> 。
</p>
<a name="index-_002dC_002c-and-recursion"></a>
<a name="index-_002df_002c-and-recursion"></a>
<a name="index-_002do_002c-and-recursion"></a>
<a name="index-_002dW_002c-and-recursion"></a>
<a name="index-_002d_002ddirectory_002c-and-recursion"></a>
<a name="index-_002d_002dfile_002c-and-recursion"></a>
<a name="index-_002d_002dold_002dfile_002c-and-recursion"></a>
<a name="index-_002d_002dassume_002dold_002c-and-recursion"></a>
<a name="index-_002d_002dassume_002dnew_002c-and-recursion"></a>
<a name="index-_002d_002dnew_002dfile_002c-and-recursion"></a>
<a name="index-recursion_002c-and-_002dC"></a>
<a name="index-recursion_002c-and-_002df"></a>
<a name="index-recursion_002c-and-_002do"></a>
<a name="index-recursion_002c-and-_002dW"></a>
<p>选项“ <samp>-C</samp> '，' <samp>-f</samp> '，' <samp>-o</samp> '和' <samp>-W</samp> '不放入<code>MAKEFLAGS</code> ;这些选项不会传递。
</p>
<a name="index-_002dj_002c-and-recursion"></a>
<a name="index-_002d_002djobs_002c-and-recursion"></a>
<a name="index-recursion_002c-and-_002dj"></a>
<a name="index-job-slots_002c-and-recursion"></a>
<p>' <samp>-j</samp> '选项是一种特殊情况（请参阅<a href="#Parallel">并行执行</a> ）。如果您将其设置为某个数字值， <samp>N</samp> '，并且您的操作系统支持它（大多数UNIX系统都支持；其他系统通常不支持）， <code>make</code>以及所有子<code>make</code>会进行沟通以确保只有“ <samp>N</samp>作业在它们之间同时运行。请注意，任何标记为递归的作业（请参见<a href="#Instead-of-Execution">代替执行配方</a> ）均不会计入总作业数（否则我们可以得到“ <samp>N</samp> '子<code>make</code>正在运行，没有剩余的插槽可用于任何实际工作！）
</p>
<p>如果您的操作系统不支持以上通信，则“ <samp>-j</samp> '已添加到<code>MAKEFLAGS</code> ，这样子<code>make</code>在非并行模式下运行。如果“ <samp><span class="nolinebreak">-j</span></samp> ' <!-- /@w -->选项向下传递给<code>make</code> s，您并行执行的作业将超出您的要求。如果您给“ <samp>-j</samp> '没有数字参数，意味着可以并行运行尽可能多的作业，由于多个无限多于一个，因此将其向下传递。
</p>
<p>如果不想向下传递其他标志，则必须更改<code>MAKEFLAGS</code> ， 像这样：</p>
<div class="example">
<pre class="example">subsystem:
        cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=
</pre></div>

<a name="index-MAKEOVERRIDES"></a>
<p>命令行变量定义确实出现在变量中<code>MAKEOVERRIDES</code>和<code>MAKEFLAGS</code>包含对此变量的引用。如果您确实希望正常传递标志，但又不想传递命令行变量定义，则可以重置<code>MAKEOVERRIDES</code>清空，像这样：</p>
<div class="example">
<pre class="example">MAKEOVERRIDES =
</pre></div>

<p><a name="index-Arg-list-too-long"></a><a name="index-E2BIG"></a>这通常没有用。但是，某些系统对环境的大小有一个小的固定限制，并且会将大量信息放入<code>MAKEFLAGS</code>可以超过它。如果看到错误消息“ <samp>Arg list too long</samp> '，这可能是问题所在。
<a name="index-_002ePOSIX-1"></a><a name="index-POSIX-1"></a> （为了严格遵守POSIX.2， <code>MAKEOVERRIDES</code>不影响<code>MAKEFLAGS</code>如果特殊目标是<samp>.POSIX</samp> '出现在makefile中。您可能对此并不在意。）
</p>
<a name="index-MFLAGS"></a>
<p>一个类似的变量<code>MFLAGS</code>为了历史兼容性也存在。具有与<code>MAKEFLAGS</code>除非它不包含命令行变量定义，并且它始终以连字符开头，除非为空（ <code>MAKEFLAGS</code>仅当它以没有单字母版本的选项开头时，才以连字符开头，例如“ <samp>--warn-undefined-variables</samp> '）。 <code>MFLAGS</code>传统上在递归中明确使用<code>make</code>命令，如下所示：</p>
<div class="example">
<pre class="example">subsystem:
        cd subdir &amp;&amp; $(MAKE) $(MFLAGS)
</pre></div>

<p>但现在<code>MAKEFLAGS</code>使此用法多余。如果您希望makefile与旧版本兼容<code>make</code>程序，使用此技术；它将与更现代的设备一起工作<code>make</code>版本。
</p>
<a name="index-setting-options-from-environment"></a>
<a name="index-options_002c-setting-from-environment"></a>
<a name="index-setting-options-in-makefiles"></a>
<a name="index-options_002c-setting-in-makefiles"></a>
<p>的<code>MAKEFLAGS</code>如果您要使用某些选项（例如“ <samp>-k</samp> '（请参阅<a href="#Options-Summary">“选项摘要”</a> ），在每次运行时进行设置<code>make</code> 。您只需为<code>MAKEFLAGS</code>在您的环境中。您也可以设定<code>MAKEFLAGS</code>在makefile中，以指定对于该makefile也应生效的其他标志。（请注意，您不能使用<code>MFLAGS</code>这条路。设置该变量仅是为了兼容性。 <code>make</code>不会以任何方式解释您为其设置的值。）
</p>
<p>什么时候<code>make</code>解释了<code>MAKEFLAGS</code> （无论是来自环境还是来自makefile），如果该值尚未以1开头，则它会先加一个连字符。然后，它将值切成用空格分隔的单词，并解析这些单词，就好像它们是命令行中给出的选项一样（除了' <samp>-C</samp> '，' <samp>-f</samp> '，' <samp>-h</samp> '，' <samp>-o</samp> '，' <samp>-W</samp> '，其长名版本将被忽略；并且无效选项没有错误）。
</p>
<p>如果你放<code>MAKEFLAGS</code>在您的环境中，您应确保不包括任何会严重影响以下人员的行为的选项： <code>make</code>并破坏了makefile和<code>make</code>本身。例如，“ <samp>-t</samp> '，' <samp>-n</samp> '和' <samp>-q</samp>如果将这些选项放在这些变量之一中，可能会造成灾难性的后果，并且肯定会产生至少令人惊讶且可能令人讨厌的影响。
</p>
<p>如果您想运行其他实现<code>make</code>除了GNU <code>make</code> ，因此不想添加GNU <code>make</code>的特定标志<code>MAKEFLAGS</code>变量，您可以将它们添加到<code>GNUMAKEFLAGS</code>变量。该变量在之前被解析<code>MAKEFLAGS</code> ， 在相同的方式<code>MAKEFLAGS</code> 。什么时候<code>make</code>结构体<code>MAKEFLAGS</code>传递给递归<code>make</code>它将包括所有标志，甚至包括那些从<code>GNUMAKEFLAGS</code> 。结果，解析后<code>GNUMAKEFLAGS</code> GNU <code>make</code>将此变量设置为空字符串，以避免在递归过程中重复标记。
</p>
<p>最好用<code>GNUMAKEFLAGS</code>仅带有不会实质改变makefile行为的标志。如果您的生成文件仍然需要GNU make，则只需使用<code>MAKEFLAGS</code> 。诸如“ <samp>--no-print-directory</samp> ' 要么 ' <samp>--output-sync</samp> '可能适合<code>GNUMAKEFLAGS</code> 。
</p>
<hr>
<a name="g_t_002dw-Option"></a>
<div class="header">
<p>上一页： <a href="#Options_002fRecursion" rel="prev" accesskey="p">选项/递归</a> ，向上： <a href="#Recursion" rel="up" accesskey="u">递归</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-_002d_002dprint_002ddirectory-Option"></a>
<h4 class="subsection">5.7.4' <samp>--print-directory</samp> ' 选项</h4>
<a name="index-directories_002c-printing-them"></a>
<a name="index-printing-directories"></a>
<a name="index-recursion_002c-and-printing-directories"></a>

<p>如果您使用多个级别的递归<code>make</code>调用， <samp>-w</samp> ' 要么 ' <samp><span class="nolinebreak">--print-directory</span></samp> ' <!-- /@w -->选项可以通过将每个目录显示为以下内容使输出更容易理解<code>make</code>开始处理它，并作为<code>make</code>完成处理。例如，如果“ <samp>make -w</samp>在目录中运行<samp>/u/gnu/make</samp> ， <code>make</code>将打印以下形式的一行：</p>
<div class="example">
<pre class="example">make: Entering directory `/u/gnu/make'.
</pre></div>

<p>在做其他事情之前，先做一下表格：</p>
<div class="example">
<pre class="example">make: Leaving directory `/u/gnu/make'.
</pre></div>

<p>处理完成时。
</p>
<a name="index-_002dC_002c-and-_002dw"></a>
<a name="index-_002d_002ddirectory_002c-and-_002d_002dprint_002ddirectory"></a>
<a name="index-recursion_002c-and-_002dw"></a>
<a name="index-_002dw_002c-and-_002dC"></a>
<a name="index-_002dw_002c-and-recursion"></a>
<a name="index-_002d_002dprint_002ddirectory_002c-and-_002d_002ddirectory"></a>
<a name="index-_002d_002dprint_002ddirectory_002c-and-recursion"></a>
<a name="index-_002d_002dno_002dprint_002ddirectory"></a>
<a name="index-_002d_002dprint_002ddirectory_002c-disabling"></a>
<a name="index-_002dw_002c-disabling"></a>
<p>通常，您无需指定此选项，因为“ <samp>make</samp> '为您做到了：' <samp>-w</samp>当您使用' <samp>-C</samp> '选项，然后在<code>make</code> s。 <code>make</code>不会自动打开“ <samp>-w</samp> '如果您还使用' <samp>-s</samp> '，表示保持沉默，或者如果您使用' <samp>--no-print-directory</samp>以明确禁用它。
</p>
<hr>
<a name="Canned-Recipes"></a>
<div class="header">
<p>下一篇： <a href="#Empty-Recipes" rel="next" accesskey="n">空食谱</a> ，上一篇： <a href="#Recursion" rel="prev" accesskey="p">递归</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Defining-Canned-Recipes"></a>
<h3 class="section">5.8定义罐头食谱</h3>
<a name="index-canned-recipes"></a>
<a name="index-recipes_002c-canned"></a>
<a name="index-sequences-of-commands"></a>
<a name="index-commands_002c-sequences-of"></a>

<p>当相同的命令序列可用于创建各种目标时，可以使用以下命令将其定义为固定序列<code>define</code>指令，并从配方中引用这些目标的固定顺序。固定序列实际上是一个变量，因此名称不得与其他变量名称冲突。
</p>
<p>这是定义罐装食谱的示例：</p>
<div class="example">
<pre class="example">define run-yacc =
yacc $(firstword $^)
mv y.tab.c $@
endef
</pre></div>
<a name="index-yacc"></a>

<p>这里<code>run-yacc</code>是要定义的变量的名称； <code>endef</code>标记定义的结尾；中间的行是命令。的<code>define</code>指令不会按固定顺序扩展变量引用和函数调用； ' <samp>$</samp> '字符，括号，变量名等都将成为您定义的变量值的一部分。有关的完整说明，请参见<a href="#Multi_002dLine">定义多行变量</a> 。 <code>define</code> 。
</p>
<p>此示例中的第一个命令在使用固定序列的任何规则的第一个前提下运行Yacc。Yacc的输出文件总是命名为<samp>y.tab.c</samp> 。第二条命令将输出移至规则的目标文件名。
</p>
<p>要使用固定顺序，请将变量替换为规则的配方。您可以像其他任何变量一样替换它（请参见<a href="#Reference">变量参考基础</a> ）。因为变量由<code>define</code>是递归扩展的变量，您在其中写入的所有变量引用<code>define</code>现在扩展了。例如：</p>
<div class="example">
<pre class="example">foo.c : foo.y
        $(run-yacc)
</pre></div>

<p>' <samp>foo.y</samp> '将代替变量' <samp>$^</samp> '发生在<code>run-yacc</code>的价值，以及<samp>foo.c</samp> “为” <samp>$@</samp> '。
</p>
<p>这是一个现实的示例，但实际上不需要此特定示例，因为<code>make</code>有一个隐式规则根据所涉及的文件名找出这些命令（请参阅<a href="#Implicit-Rules">使用隐式规则</a> ）。
</p>
<a name="index-_0040_002c-and-define"></a>
<a name="index-_002d_002c-and-define"></a>
<a name="index-_002b_002c-and-define"></a>
<p>在配方执行中，固定顺序的每一行都被视为就像该行在规则中单独出现一样，并以制表符开头。特别是， <code>make</code>为每行调用一个单独的子外壳。您可以使用影响命令行的特殊前缀字符（' <samp>@</samp> '，' <samp>-</samp> '和' <samp>+</samp> '）在固定顺序的每一行上。请参见<a href="#Recipes">在规则中编写食谱</a> 。例如，使用以下固定顺序：</p>
<div class="example">
<pre class="example">define frobnicate =
@echo &quot;frobnicating target $@&quot;
frob-step-1 $&lt; -o $@-step-1
frob-step-2 $@-step-1 -o $@
endef
</pre></div>

<p><code>make</code>不会回显第一行， <code>echo</code>命令。但是， <em>这</em>呼应了以下两个配方行。
</p>
<p>另一方面，在配方行上引用固定序列的前缀字符适用于序列中的每一行。所以规则：</p>
<div class="example">
<pre class="example">frob.out: frob.in
        @$(frobnicate)
</pre></div>

<p>不回显<em>任何</em>配方行。（见<a href="#Echoing">配方相呼应</a> ，为一个完整的解释“ <samp>@</samp> '。）
</p>
<hr>
<a name="Empty-Recipes"></a>
<div class="header">
<p>上一页： <a href="#Canned-Recipes" rel="prev" accesskey="p">罐头食谱</a> ，上一篇： <a href="#Recipes" rel="up" accesskey="u">食谱</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-Empty-Recipes"></a>
<h3 class="section">5.9使用空食谱</h3>
<a name="index-empty-recipes"></a>
<a name="index-recipes_002c-empty"></a>

<p>定义不起作用的配方有时很有用。只需给出一个仅包含空格的配方即可完成此操作。例如：</p>
<div class="example">
<pre class="example">target: ;
</pre></div>

<p>定义一个空配方<samp>target</samp> 。您也可以使用以配方前缀字符开头的行来定义空配方，但这会造成混淆，因为这样的行看起来是空的。
</p>
<a name="index-_002eDEFAULT_002c-and-empty-recipes"></a>
<p>您可能想知道为什么要定义什么都不做的配方。有用的原因之一是防止目标获取隐式配方（从隐式规则或<code>.DEFAULT</code>特殊目标；请参阅<a href="#Implicit-Rules">隐式规则</a> ，请参阅<a href="#Last-Resort">定义最后一个默认规则</a> ）。
</p>
<p>空配方也可以用来避免由于另一个配方的副作用而产生的目标错误：如果目标不存在，则空配方可确保<code>make</code>不会抱怨它不知道如何建立目标，并且<code>make</code>将假定目标已过期。
</p>
<p>您可能倾向于为不是实际文件而是仅存在的目标定义空配方，以便可以重新定义其先决条件。但是，这不是最佳方法，因为如果目标文件确实存在，则可能无法正确地重新创建前提条件。有关更好的方法，请参见<a href="#Phony-Targets">Phony Targets</a> 。
</p>
<hr>
<a name="Using-Variables"></a>
<div class="header">
<p>下一个： <a href="#Conditionals" rel="next" accesskey="n">条件式</a> ，上一个： <a href="#Recipes" rel="prev" accesskey="p">食谱</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-to-Use-Variables"></a>
<h2 class="chapter">6如何使用变量</h2>
<a name="index-variable"></a>
<a name="index-value"></a>
<a name="index-recursive-variable-expansion"></a>
<a name="index-simple-variable-expansion"></a>

<p><em>变量</em>是在makefile中定义的名称，用来表示文本字符串，称为变量的<em>value</em> 。这些值被显式请求替换为目标，先决条件，配方和makefile的其他部分。（在其他版本的<code>make</code> ，变量称为<em>宏</em> 。）
<a name="index-macro"></a>
</p>
<p>读取时，makefile的所有部分中的变量和函数都会扩展，但在配方中，变量定义的右侧使用' <samp>=</samp> '，以及使用<code>define</code>指示。
</p>
<p>变量可以表示文件名列表，传递给编译器的选项，要运行的程序，要查找源文件的目录，要在其中写入输出的目录或您可以想象的任何其他内容。
</p>
<p>变量名可以是不包含'的任何字符序列<samp>:</samp> '，' <samp>#</samp> '，' <samp>=</samp>或空白。但是，应谨慎考虑包含字母，数字和下划线以外的字符的变量名，因为在某些shell中，它们不能通过环境传递给子目录， <code>make</code> （请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> ）。以'开头的变量名<samp>.</samp> '，并且在以后的版本中，大写字母可能有特殊含义<code>make</code> 。
</p>
<p>变量名称区分大小写。名字 ' <samp>foo</samp> '，' <samp>FOO</samp> '和' <samp>Foo</samp>都是指不同的变量。
</p>
<p>传统上在变量名中使用大写字母，但是我们建议对于在makefile中用于内部目的的变量名使用小写字母，并为控制隐式规则的参数或用户应使用命令覆盖的参数保留大写字母选项（请参阅<a href="#Overriding">覆盖变量</a> ）。
</p>
<p>一些变量的名称是单个标点字符或仅几个字符。这些是<em>自动变量</em> ，它们具有特定的特殊用途。请参阅<a href="#Automatic-Variables">自动变量</a> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Reference" accesskey="1">参考</a> ：</td><td>  </td><td align="left" valign="top">如何使用变量的值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Flavors" accesskey="2">风味</a> ：</td><td>  </td><td align="left" valign="top">变量有两种形式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Advanced" accesskey="3">高级</a> ：</td><td>  </td><td align="left" valign="top">引用变量的高级功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Values" accesskey="4">价值观</a> ：</td><td>  </td><td align="left" valign="top">变量获取值的所有方式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Setting" accesskey="5">设置</a> ：</td><td>  </td><td align="left" valign="top">如何在makefile中设置变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Appending" accesskey="6">追加</a> ：</td><td>  </td><td align="left" valign="top">如何将更多文本附加到变量的旧值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Override-Directive" accesskey="7">覆盖指令</a> ：</td><td>  </td><td align="left" valign="top">即使用户已使用命令参数设置了变量，如何在makefile中设置变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Multi_002dLine" accesskey="8">多线</a> ：</td><td>  </td><td align="left" valign="top">将变量设置为多行字符串的另一种方法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Undefine-Directive" accesskey="9">未定义指令</a> ：</td><td>  </td><td align="left" valign="top">如何取消定义变量，使其看起来好像从未设置过。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Environment">环境</a> ：</td><td>  </td><td align="left" valign="top">变量值可能来自环境。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Target_002dspecific">针对特定目标</a> ：</td><td>  </td><td align="left" valign="top">可以根据每个目标定义变量值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern_002dspecific">特定于模式</a> ：</td><td>  </td><td align="left" valign="top">特定于目标的变量值可以应用于与模式匹配的一组目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Suppressing-Inheritance">抑制继承</a> ：</td><td>  </td><td align="left" valign="top">禁止变量的继承。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Special-Variables">特殊变量</a> ：</td><td>  </td><td align="left" valign="top">具有特殊含义或行为的变量。
</td></tr>
</tbody></table>

<hr>
<a name="Reference"></a>
<div class="header">
<p>下一页： <a href="#Flavors" rel="next" accesskey="n">风味</a> ，上一篇： <a href="#Using-Variables" rel="prev" accesskey="p">使用变量</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Basics-of-Variable-References"></a>
<h3 class="section">6.1变量引用的基础</h3>
<a name="index-variables_002c-how-to-reference"></a>
<a name="index-reference-to-variables"></a>
<a name="index-_0024_002c-in-variable-reference"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-in-variable-reference"></a>

<p>要替换变量的值，请在括号或大括号内写一个美元符号，后跟该变量的名称： <samp>$(foo)</samp> ' 要么 ' <samp>${foo}</samp> '是对变量的有效引用<code>foo</code> 。'的特殊意义<samp>$</samp> '这就是为什么你必须写' <samp>$$</samp>以使文件名或配方中的单个美元符号有效。
</p>
<p>变量引用可以在任何上下文中使用：目标，前提条件，配方，大多数指令和新变量值。这是一个常见情况的示例，其中变量保存程序中所有目标文件的名称：</p>
<div class="example">
<pre class="example">objects = program.o foo.o utils.o
program : $(objects)
        cc -o program $(objects)

$(objects) : defs.h
</pre></div>

<p>变量引用通过严格的文本替换来工作。因此，规则</p>
<div class="example">
<pre class="example">foo = c
prog.o : prog.$(foo)
        $(foo)$(foo) -$(foo) prog.$(foo)
</pre></div>

<p>可用于编译C程序<samp>prog.c</samp> 。由于在变量分配中变量值之前的空格会被忽略，因此<code>foo</code>恰恰是' <samp>c</samp> '。（实际上不要这样写您的makefile！）
</p>
<p>一个美元符号后跟一个除美元符号之外的其他字符，左括号或右括号，将单个字符视为变量名。因此，您可以引用变量<code>x</code>与“ <samp>$x</samp> '。但是，强烈建议不要使用这种做法，除非是自动变量（请参阅<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<hr>
<a name="Flavors"></a>
<div class="header">
<p>下一个： <a href="#Advanced" rel="next" accesskey="n">高级</a> ，上一个： <a href="#Reference" rel="prev" accesskey="p">参考</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-Two-Flavors-of-Variables"></a>
<h3 class="section">6.2变量的两种风格</h3>
<a name="index-flavors-of-variables"></a>
<a name="index-recursive-variable-expansion-1"></a>
<a name="index-variables_002c-flavors"></a>
<a name="index-recursively-expanded-variables"></a>
<a name="index-variables_002c-recursively-expanded"></a>

<p>GNU中的变量有两种方式<code>make</code>可以有一个价值；我们称它们为变量的两种<em>风格</em> 。两种口味的区别在于定义方式和扩展方式。
</p>
<a name="index-_003d"></a>
<p>变量的第一种形式是<em>递归扩展</em>变量。此类变量是使用' <samp>=</samp> '（请参阅<a href="#Setting">设置变量</a> ）或按<code>define</code>指令（请参阅<a href="#Multi_002dLine">定义多行变量</a> ）。您指定的值是逐字安装的；如果它包含对其他变量的引用，则只要替换此变量（在扩展其他字符串的过程中），这些引用就会被扩展。发生这种情况时，称为<em>递归扩展</em> 。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)
</pre></div>

<p>会回声<samp>Huh?</samp> '：' <samp>$(foo)</samp> '扩展为' <samp>$(bar)</samp> '扩展为' <samp>$(ugh)</samp> '最终扩展为' <samp>Huh?</samp> '。
</p>
<p>这类变量是大多数其他版本的<code>make</code> 。它有其优点和缺点。一个优点（大多数人会说）是：</p>
<div class="example">
<pre class="example">CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
</pre></div>

<p>将执行预期的操作：何时“ <samp>CFLAGS</samp> '在配方中扩展，它将扩展为' <samp>-Ifoo -Ibar -O</samp> '。一个主要的缺点是您不能在变量末尾附加一些内容，例如</p>
<div class="example">
<pre class="example">CFLAGS = $(CFLAGS) -O
</pre></div>

<p>因为它将导致变量扩展中的无限循环。（其实<code>make</code>检测到无限循环并报告错误。）
<a name="index-loops-in-variable-expansion"></a>
<a name="index-variables_002c-loops-in-expansion"></a>
</p>
<p>另一个缺点是，每次扩展变量时，都会执行定义中引用的任何函数（请参见<a href="#Functions">转换文本的函数</a> ）。这使得<code>make</code>跑慢一点更糟的是，它导致<code>wildcard</code>和<code>shell</code>函数会产生不可预测的结果，因为您无法轻松控制它们的调用时间，甚至调用次数。
</p>
<p>为了避免递归扩展变量的所有问题和不便，还有另一种方式：简单地扩展变量。
</p>
<a name="index-simply-expanded-variables"></a>
<a name="index-variables_002c-simply-expanded"></a>
<a name="index-_003a_003d"></a>
<a name="index-_003a_003a_003d"></a>
<p><em>简单扩展的变量</em>由使用' <samp>:=</samp> ' 要么 ' <samp>::=</samp> '（请参阅<a href="#Setting">设置变量</a> ）。两种形式在GNU中是等效的<code>make</code> ;但是只有“ <samp>::=</samp> '格式由POSIX标准描述（支持' <samp>::=</samp> ”已于2012年添加到POSIX标准中，因此旧版本的<code>make</code>也不会接受此表格）。
</p>
<p>定义变量后，将彻底扫描简单扩展的变量的值，从而扩展对其他变量和函数的任何引用。简单扩展变量的实际值是扩展您编写的文本的结果。它不包含对其他变量的任何引用；它包含了<em>定义此变量时</em>的值。因此，</p>
<div class="example">
<pre class="example">x := foo
y := $(x) bar
x := later
</pre></div>

<p>相当于</p>
<div class="example">
<pre class="example">y := foo bar
x := later
</pre></div>

<p>当引用简单扩展的变量时，其值逐字替换。
</p>
<p>这是一个更复杂的示例，说明了“ <samp>:=</samp> '与<code>shell</code>功能。（见<a href="#Shell-Function">的<code>shell</code>功能</a> 。）此示例还显示了变量的使用<code>MAKELEVEL</code> ，在逐级传递时会更改。（请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> ，有关的信息<code>MAKELEVEL</code> ）
</p>
<a name="index-MAKELEVEL-1"></a>
<a name="index-MAKE-1"></a>
<div class="example">
<pre class="example">ifeq (0,${MAKELEVEL})
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif
</pre></div>

<p>使用' <samp>:=</samp>是一个典型的“降序进入目录”菜谱，如下所示：</p>
<div class="example">
<pre class="example">${subdirs}:
        ${MAKE} -C $@ all
</pre></div>

<p>简单扩展的变量通常使复杂的makefile编程更可预测，因为它们在大多数编程语言中都像变量一样工作。它们使您可以使用变量自己的值（或通过扩展功能之一对其进行处理的值）来重新定义变量，并且可以更有效地使用扩展功能（请参见<a href="#Functions">转换文本的功能</a> ）。
</p>
<a name="index-spaces_002c-in-variable-values"></a>
<a name="index-whitespace_002c-in-variable-values"></a>
<a name="index-variables_002c-spaces-in-values"></a>
<p>您还可以使用它们将受控的前导空白引入变量值。在替换变量引用和函数调用之前，会将前导空格字符从输入中删除；这意味着您可以通过使用变量引用对其进行保护，从而在变量值中包含前导空格，如下所示：</p>
<div class="example">
<pre class="example">nullstring :=
space := $(nullstring) # end of the line
</pre></div>

<p>这里的变量值<code>space</code>恰好是一个空间。评论“ <samp># end of the line</samp>为了清楚起见，此处包含<!-- /@w --> 。由于<em>未</em>从变量值中删除尾随空格字符，因此仅在行尾添加空格会产生相同的效果（但很难读取）。如果将空格放在变量值的末尾，则最好在该行的末尾添加类似的注释，以使意图清晰。相反，如果您<em>不</em>希望变量值的末尾有任何空格字符，则必须记住不要在某些空格后的行末尾添加随机注释，例如：</p>
<div class="example">
<pre class="example">dir := /foo/bar    # directory to put the frobs in
</pre></div>

<p>这里的变量值<code>dir</code>是' <samp>/foo/bar    </samp> ' <!-- /@w --> （带有四个尾随空格），这可能不是故意的。（想象一下类似“ <samp>$(dir)/file</samp> ' <!-- /@w -->具有此定义！）
</p>
<a name="index-conditional-variable-assignment"></a>
<a name="index-variables_002c-conditional-assignment"></a>
<a name="index-_003f_003d"></a>
<p>还有另一个变量赋值运算符，“ <samp>?=</samp> '。这被称为条件变量赋值运算符，因为它仅在尚未定义变量的情况下才起作用。这个说法：</p>
<div class="example">
<pre class="example">FOO ?= bar
</pre></div>

<p>完全等同于本（见<a href="#Origin-Function">的<code>origin</code>函数</a> ）：</p>
<div class="example">
<pre class="example">ifeq ($(origin FOO), undefined)
  FOO = bar
endif
</pre></div>

<p>请注意，仍会定义设置为空值的变量，因此“ <samp>?=</samp> '不会设置该变量。
</p>
<hr>
<a name="Advanced"></a>
<div class="header">
<p>下一个： <a href="#Values" rel="next" accesskey="n">值</a> ，上一个： <a href="#Flavors" rel="prev" accesskey="p">风味</a> ，上： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Advanced-Features-for-Reference-to-Variables"></a>
<h3 class="section">6.3引用变量的高级功能</h3>
<a name="index-reference-to-variables-1"></a>

<p>本节介绍一些高级功能，您可以使用这些功能以更灵活的方式引用变量。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Substitution-Refs" accesskey="1">替代裁判</a> ：</td><td>  </td><td align="left" valign="top">引用变量，并在值上替换。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Computed-Names" accesskey="2">计算名称</a> ：</td><td>  </td><td align="left" valign="top">计算要引用的变量的名称。
</td></tr>
</tbody></table>

<hr>
<a name="Substitution-Refs"></a>
<div class="header">
<p>下一页： <a href="#Computed-Names" rel="next" accesskey="n">计算名称</a> ，上一篇： <a href="#Advanced" rel="prev" accesskey="p">高级</a> ，上一篇： <a href="#Advanced" rel="up" accesskey="u">高级</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Substitution-References"></a>
<h4 class="subsection">6.3.1替代参考</h4>
<a name="index-modified-variable-reference"></a>
<a name="index-substitution-variable-reference"></a>
<a name="index-variables_002c-modified-reference"></a>
<a name="index-variables_002c-substitution-reference"></a>

<a name="index-variables_002c-substituting-suffix-in"></a>
<a name="index-suffix_002c-substituting-in-variables"></a>
<p><em>替换引用</em>用您指定的更改替换变量的值。它的格式为“ <samp>$(<var>var</var>:<var>a</var>=<var>b</var>)</samp> ' （要么 ' <samp>${<var>var</var>:<var>a</var>=<var>b</var>}</samp> '），其含义是取变量的值<var>var</var> ，更换所有<var>a</var>在一个词的结尾<var>b</var>值，然后替换结果字符串。
</p>
<p>当我们说“一个词的结尾”时，是指<var>a</var>必须替换为空格；必须在空格后或空格的末尾显示该空格；其他事件<var>a</var>值不变。例如：</p>
<div class="example">
<pre class="example">foo := a.o b.o c.o
bar := $(foo:.o=.c)
</pre></div>

<p>设置“ <samp>bar</samp> ' 至 ' <samp>a.c b.c c.c</samp> '。请参阅<a href="#Setting">设置变量</a> 。
</p>
<p>替代参考实际上是使用的缩写。 <code>patsubst</code>扩展函数（请参阅<a href="#Text-Functions">字符串替换和分析函数</a> ）。我们提供替代参考以及<code>patsubst</code>与其他实现兼容<code>make</code> 。
</p>
<a name="index-patsubst"></a>
<p>另一种替代参考可以让您充分利用<code>patsubst</code>功能。它具有相同的形式' <samp>$(<var>var</var>:<var>a</var>=<var>b</var>)</samp>除了上述内容， <var>a</var>必须包含一个' <samp>%</samp>字符。这种情况相当于“ <samp>$(patsubst <var>a</var>,<var>b</var>,$(<var>var</var>))</samp> '。有关<a href="#Text-Functions">字符串</a>的描述，请参见<a href="#Text-Functions">字符串替换和分析函数。</a> <code>patsubst</code>功能。
</p>
<div class="example">
<pre class="example">For example:
</pre><pre class="example">

foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
</pre></div>

<p>设置“ <samp>bar</samp> ' 至 ' <samp>a.c b.c c.c</samp> '。
</p>
<hr>
<a name="Computed-Names"></a>
<div class="header">
<p>上一页： <a href="#Substitution-Refs" rel="prev" accesskey="p">替代裁判</a> ，上<a href="#Substitution-Refs" rel="prev" accesskey="p">一篇</a> ： <a href="#Advanced" rel="up" accesskey="u">高级</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Computed-Variable-Names"></a>
<h4 class="subsection">6.3.2计算变量名</h4>
<a name="index-nested-variable-reference"></a>
<a name="index-computed-variable-name"></a>
<a name="index-variables_002c-computed-names"></a>
<a name="index-variables_002c-nested-references"></a>
<a name="index-variables_002c-_0024-in-name"></a>
<a name="index-_0024_002c-in-variable-name"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-in-variable-name"></a>

<p>计算变量名是只有复杂的makefile编程才需要的复杂概念。对于大多数目的，您不需要考虑它们，除非知道使用名称中带有美元符号的变量可能会产生奇怪的结果。但是，如果您是那种想了解一切的人，或者您实际上对他们的工作感兴趣，请继续阅读。
</p>
<p>变量名称内可以引用变量。这称为<em>计算变量名</em>或<em>嵌套变量引用</em> 。例如，</p>
<div class="example">
<pre class="example">x = y
y = z
a := $($(x))
</pre></div>

<p>定义<code>a</code>作为“ <samp>z</samp> '：' <samp>$(x)</samp>里面<samp>$($(x))</samp> '扩展为' <samp>y</samp> '，所以' <samp>$($(x))</samp> '扩展为' <samp>$(y)</samp> '反过来扩展为' <samp>z</samp> '。这里没有明确指出要引用的变量的名称；它是通过扩展' <samp>$(x)</samp> '。参考资料 ' <samp>$(x)</samp> '此处嵌套在外部变量引用中。
</p>
<p>前面的示例显示了两个嵌套级别，但是任何数量的级别都是可以的。例如，这是三个级别：</p>
<div class="example">
<pre class="example">x = y
y = z
z = u
a := $($($(x)))
</pre></div>

<p>这里最里面的<samp>$(x)</samp> '扩展为' <samp>y</samp> '，所以' <samp>$($(x))</samp> '扩展为' <samp>$(y)</samp> '反过来扩展为' <samp>z</samp> ';现在我们有<samp>$(z)</samp> '，即成为' <samp>u</samp> '。
</p>
<p>对变量名称中递归扩展变量的引用以通常的方式重新扩展。例如：</p>
<div class="example">
<pre class="example">x = $(y)
y = z
z = Hello
a := $($(x))
</pre></div>

<p>定义<code>a</code>作为“ <samp>Hello</samp> '：' <samp>$($(x))</samp> '变成' <samp>$($(y))</samp> '变成' <samp>$(z)</samp> '变成' <samp>Hello</samp> '。
</p>
<p>嵌套变量引用也可以包含修改后的引用和函数调用（请参见<a href="#Functions">用于转换文本的函数</a> ），就像其他任何引用一样。例如，使用<code>subst</code>函数（请参阅<a href="#Text-Functions">用于字符串替换和分析的函数</a> ）：</p>
<div class="example">
<pre class="example">x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))
</pre></div>

<p>最终定义<code>a</code>作为“ <samp>Hello</samp> '。令人怀疑的是，是否有人想编写像这样复杂的嵌套引用，但它的工作原理是： <samp>$($($(z)))</samp> '扩展为' <samp>$($(y))</samp> '变成' <samp>$($(subst 1,2,$(x)))</samp> '。这得到的价值是<samp>variable1</samp>来自<code>x</code>并通过替换为' <samp>variable2</samp> '，这样整个字符串就变成了' <samp>$(variable2)</samp> '，一个简单的变量引用，其值为' <samp>Hello</samp> '。
</p>
<p>计算变量名称不必完全由单个变量引用组成。它可以包含多个变量引用以及一些不变的文本。例如，</p>
<div class="example">
<pre class="example">a_dirs := dira dirb
1_dirs := dir1 dir2
</pre><pre class="example">

</pre><pre class="example">a_files := filea fileb
1_files := file1 file2
</pre><pre class="example">

</pre><pre class="example">ifeq &quot;$(use_a)&quot; &quot;yes&quot;
a1 := a
else
a1 := 1
endif
</pre><pre class="example">

</pre><pre class="example">ifeq &quot;$(use_dirs)&quot; &quot;yes&quot;
df := dirs
else
df := files
endif

dirs := $($(a1)_$(df))
</pre></div>

<p>会给<code>dirs</code>与...相同的值<code>a_dirs</code> ， <code>1_dirs</code> ， <code>a_files</code>要么<code>1_files</code>取决于<code>use_a</code>和<code>use_dirs</code> 。
</p>
<p>计算出的变量名称也可以用于替代引用中：</p>
<div class="example">
<pre class="example">a_objects := a.o b.o c.o
1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
</pre></div>

<p>定义<code>sources</code>作为“ <samp>a.c b.c c.c</samp> ' 要么 ' <samp>1.c 2.c 3.c</samp> '，具体取决于<code>a1</code> 。
</p>
<p>这种使用嵌套变量引用的唯一限制是它们不能指定要调用的函数名称的一部分。这是因为对可识别函数名称的测试是在扩展嵌套引用之前完成的。例如，</p>
<div class="example">
<pre class="example">ifdef do_sort
func := sort
else
func := strip
endif
</pre><pre class="example">

</pre><pre class="example">bar := a d b g q c
</pre><pre class="example">

</pre><pre class="example">foo := $($(func) $(bar))
</pre></div>

<p>尝试给予“ <samp>foo</samp> '变量的值' <samp>sort a d b g q c</samp> ' 要么 ' <samp>strip a d b g q c</samp> '，而不是给予' <samp>a d b g q c</samp> '作为<code>sort</code>或者<code>strip</code>功能。如果该更改被证明是一个好主意，那么将来可以取消此限制。
</p>
<p>您也可以在变量赋值的左侧或<code>define</code>指令，如：</p>
<div class="example">
<pre class="example">dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print =
lpr $($(dir)_sources)
endef
</pre></div>

<p>本示例定义了变量' <samp>dir</samp> '，' <samp>foo_sources</samp> '和' <samp>foo_print</samp> '。
</p>
<p>请注意， <em>嵌套变量引用</em>与<em>递归扩展变量</em> （请参见<em>变量</em> <a href="#Flavors">的两种风格</a> ）有很大不同，尽管在进行makefile编程时，它们以复杂的方式一起使用。
</p>
<hr>
<a name="Values"></a>
<div class="header">
<p>下一页： <a href="#Setting" rel="next" accesskey="n">设置</a> ，上一页： <a href="#Advanced" rel="prev" accesskey="p">高级</a> ，上一页： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-Variables-Get-Their-Values"></a>
<h3 class="section">6.4变量如何获得价值</h3>
<a name="index-variables_002c-how-they-get-their-values"></a>
<a name="index-value_002c-how-a-variable-gets-it"></a>

<p>变量可以通过几种不同的方式获取值：</p>
<ul>
<li>您可以在运行时指定一个覆盖值<code>make</code> 。请参阅<a href="#Overriding">覆盖变量</a> 。

</li><li>您可以在makefile中指定一个值，可以使用赋值（请参阅“ <a href="#Setting">设置变量”</a> ）或逐字定义（请参见“ <a href="#Multi_002dLine">定义多行变量”</a> ）。

</li><li>环境中的变量变为<code>make</code>变量。请参阅<a href="#Environment">环境变量</a> 。

</li><li>每个规则都会为几个<em>自动</em>变量赋予新值。这些中的每一个具有单个常规用途。请参阅<a href="#Automatic-Variables">自动变量</a> 。

</li><li>几个变量具有恒定的初始值。请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> 。
</li></ul>

<hr>
<a name="Setting"></a>
<div class="header">
<p>下一个： <a href="#Appending" rel="next" accesskey="n">追加</a> ，上一个： <a href="#Values" rel="prev" accesskey="p">值</a> ，上： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Setting-Variables"></a>
<h3 class="section">6.5设定变量</h3>
<a name="index-setting-variables"></a>
<a name="index-variables_002c-setting"></a>
<a name="index-_003d-1"></a>
<a name="index-_003a_003d-1"></a>
<a name="index-_003a_003a_003d-1"></a>
<a name="index-_003f_003d-1"></a>
<a name="index-_0021_003d"></a>

<p>要从makefile设置变量，请写一个以变量名开头的行，后跟' <samp>=</samp> '，' <samp>:=</samp> '， 要么 ' <samp>::=</samp> '。遵循“ <samp>=</samp> '，' <samp>:=</samp> '， 要么 ' <samp>::=</samp> '成为值。例如，</p>
<div class="example">
<pre class="example">objects = main.o foo.o bar.o utils.o
</pre></div>

<p>定义一个名为<code>objects</code> 。变量名称周围的空格，并且紧跟在' <samp>=</samp> '被忽略。
</p>
<p>用'定义的变量<samp>=</samp>是<em>递归扩展的</em>变量。用'定义的变量<samp>:=</samp> ' 要么 ' <samp>::=</samp> ' <em>只是简单的扩展</em>变量；这些定义可以包含变量引用，这些变量引用将在定义之前扩展。请参见<a href="#Flavors">变量的两种风格</a> 。
</p>
<p>变量名可以包含函数和变量引用，当读取该行以查找要使用的实际变量名时，它们会被扩展。
</p>
<p>除计算机上的内存量外，变量值的长度没有限制。您可以将变量的值拆分为多条物理行以提高可读性（请参阅<a href="#Splitting-Lines">拆分长行</a> ）。
</p>
<p>如果从未设置过大多数变量名，则认为它们具有空字符串作为值。多个变量具有不为空的内置初始值，但是您可以按常规方式设置它们（请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> ）。每个规则会自动将几个特殊变量设置为一个新值。这些称为<em>自动</em>变量（请参阅<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<p>如果希望仅在尚未设置变量的情况下将其设置为值，则可以使用简写运算符“ <samp>?=</samp> ' 代替 ' <samp>=</samp> '。这两个变量的设置<samp>FOO</samp> '是相同的（见<a href="#Origin-Function">该<code>origin</code>函数</a> ）：</p>
<div class="example">
<pre class="example">FOO ?= bar
</pre></div>

<p>和</p>
<div class="example">
<pre class="example">ifeq ($(origin FOO), undefined)
FOO = bar
endif
</pre></div>

<p>外壳程序赋值运算符' <samp>!=</samp> '可用于执行Shell脚本并将变量设置为其输出。该运算符首先评估右侧，然后将该结果传递给Shell以执行。如果执行的结果以换行符结尾，则删除该换行符；否则，将删除该换行符。所有其他换行符均替换为空格。然后，将结果字符串放入命名的递归扩展变量中。例如：</p>
<div class="example">
<pre class="example">hash != printf '\043'
file_list != find . -name '*.c'
</pre></div>

<p>如果执行结果可以产生一个<code>$</code> ，并且您不打算将随后的内容解释为make变量或函数引用，则必须替换每个<code>$</code>与<code>$$</code>作为执行的一部分。或者，您可以使用以下命令将简单扩展的变量设置为运行程序的结果<code>shell</code>函数调用。查看<a href="#Shell-Function">该<code>shell</code>功能</a> 。例如：</p>
<div class="example">
<pre class="example">hash := $(shell printf '\043')
var := $(shell find . -name &quot;*.c&quot;)
</pre></div>

<p>与<code>shell</code>函数，刚调用的shell脚本的退出状态存储在<code>.SHELLSTATUS</code>变量。
</p>

<hr>
<a name="Appending"></a>
<div class="header">
<p>下一篇： <a href="#Override-Directive" rel="next" accesskey="n">覆盖指令</a> ，上一篇： <a href="#Setting" rel="prev" accesskey="p">设置</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Appending-More-Text-to-Variables"></a>
<h3 class="section">6.6在变量中添加更多文本</h3>
<a name="index-_002b_003d"></a>
<a name="index-appending-to-variables"></a>
<a name="index-variables_002c-appending-to"></a>

<p>通常，将更多的文本添加到已定义的变量的值中很有用。您可以使用包含“ <samp>+=</samp> '， 像这样：</p>
<div class="example">
<pre class="example">objects += another.o
</pre></div>

<p>这取变量的值<code>objects</code> ，并添加文字“ <samp>another.o</samp> '（以单个空格开头）。从而：</p>
<div class="example">
<pre class="example">objects = main.o foo.o bar.o utils.o
objects += another.o
</pre></div>

<p>套<code>objects</code>至 ' <samp>main.o foo.o bar.o utils.o another.o</samp> '。
</p>
<p>使用“ <samp>+=</samp> ' 类似于：</p>
<div class="example">
<pre class="example">objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
</pre></div>

<p>但是在使用更复杂的值时变得重要的方式不同。
</p>
<p>如果之前未定义相关变量，则“ <samp>+=</samp> '行为就像平常一样' <samp>=</samp> '：它定义了一个递归扩展的变量。然而，当<em>有</em>以前的定义，正是“ <samp>+=</samp>的确取决于您最初定义的变量的样式。有关<a href="#Flavors">变量</a>的两种类型的说明，请参见<a href="#Flavors">变量</a>的两种类型。
</p>
<p>当您使用'添加到变量的值时<samp>+=</samp> '， <code>make</code>基本上就像您在变量的初始定义中包括多余的文本一样。如果您首先使用“ <samp>:=</samp> ' 要么 ' <samp>::=</samp> '，使其成为简单扩展的变量，' <samp>+=</samp> '将添加到该简单扩展的定义，并在将新文本附加到旧值之前对其进行扩展，就像' <samp>:=</samp>确实（请参阅<a href="#Setting">设置变量</a> ，以获取有关'的完整说明<samp>:=</samp> ' 要么 ' <samp>::=</samp> '）。事实上，</p>
<div class="example">
<pre class="example">variable := value
variable += more
</pre></div>

<p>完全等同于：</p>
<div class="example">
<pre class="example">variable := value
variable := $(variable) more
</pre></div>

<p>另一方面，当您使用“ <samp>+=</samp> '，其中包含您首先定义为使用纯'进行递归扩展的变量<samp>=</samp> '， <code>make</code>有所不同。回想一下，当您定义一个递归扩展变量时， <code>make</code>不会立即扩展为变量和函数引用设置的值。相反，它存储了逐字记录的文本，并保存了这些变量和函数引用，以便在以后引用新变量时进行扩展（请参阅变量<a href="#Flavors">的两种风格</a> ）。当您使用“ <samp>+=</samp> '在递归展开的变量上，正是该未展开的文本<code>make</code>追加您指定的新文本。
</p>
<div class="example">
<pre class="example">variable = value
variable += more
</pre></div>

<p>大致相当于：</p>
<div class="example">
<pre class="example">temp = value
variable = $(temp) more
</pre></div>

<p>当然除了它永远不会定义一个名为<code>temp</code> 。当变量的旧值包含变量引用时，这很重要。举个常见的例子：</p>
<div class="example">
<pre class="example">CFLAGS = $(includes) -O
&hellip;
CFLAGS += -pg # enable profiling
</pre></div>

<p>第一行定义了<code>CFLAGS</code>参考另一个变量的变量， <code>includes</code> 。 （ <code>CFLAGS</code>由C编译规则使用；请参阅<a href="#Catalogue-of-Rules">内置规则目录</a> 。）使用“ <samp>=</samp> '的定义使<code>CFLAGS</code>递归扩展变量，表示“ <samp>$(includes) <span class="nolinebreak">-O</span></samp>在以下情况下，' <!-- /@w --> <em>不</em>展开<code>make</code>处理...的定义<code>CFLAGS</code> 。从而， <code>includes</code>尚未定义其值即可生效。它只需要在任何引用之前定义<code>CFLAGS</code> 。如果我们尝试附加到的值<code>CFLAGS</code>不使用' <samp>+=</samp> '，我们可以这样做：</p>
<div class="example">
<pre class="example">CFLAGS := $(CFLAGS) -pg # enable profiling
</pre></div>

<p>这很接近，但不是我们想要的。使用“ <samp>:=</samp>重新定义<code>CFLAGS</code>作为简单扩展的变量；这意味着<code>make</code>展开文字' <samp>$(CFLAGS) <span class="nolinebreak">-pg</span></samp> ' <!-- /@w -->设置变量之前。如果<code>includes</code>尚未定义，我们得到“ <samp> <span class="nolinebreak">-O</span> <span class="nolinebreak">-pg</span></samp> ' <!-- /@w -->和更高版本的<code>includes</code>不会有任何效果。相反，使用' <samp>+=</samp> ' 我们设置<code>CFLAGS</code>到<em>未展开的</em>值' <samp>$(includes) <span class="nolinebreak">-O</span> <span class="nolinebreak">-pg</span></samp> ' <!-- /@w --> 。因此，我们保留了对<code>includes</code> ，因此，如果以后再定义该变量，则使用类似“ <samp>$(CFLAGS)</samp> '仍会使用其价值。
</p>
<hr>
<a name="Override-Directive"></a>
<div class="header">
<p>下一个： <a href="#Multi_002dLine" rel="next" accesskey="n">多行</a> ，上一个： <a href="#Appending" rel="prev" accesskey="p">追加</a> ，上： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-override-Directive"></a>
<h3 class="section">6.7 <code>override</code>指示</h3>
<a name="index-override"></a>
<a name="index-overriding-with-override"></a>
<a name="index-variables_002c-overriding"></a>

<p>如果已经使用命令参数设置了变量（请参见<a href="#Overriding">覆盖变量</a> ），那么将忽略makefile中的普通分配。即使您已使用命令参数设置了变量，但仍要在makefile中设置变量，则可以使用<code>override</code>指令，该行如下所示：</p>
<div class="example">
<pre class="example">override <var>variable</var> = <var>value</var>
</pre></div>

<p>要么</p>
<div class="example">
<pre class="example">override <var>variable</var> := <var>value</var>
</pre></div>

<p>要将更多文本附加到命令行上定义的变量，请使用：</p>
<div class="example">
<pre class="example">override <var>variable</var> += <var>more text</var>
</pre></div>

<p>请参见<a href="#Appending">在变量中添加更多文本</a> 。
</p>
<p>变量分配标有<code>override</code>该标志的优先级高于所有其他分配，除了另一个<code>override</code> 。此变量的后续分配或附加未标记<code>override</code>将被忽略。
</p>
<p>的<code>override</code>指令不是为在makefile和命令参数之间的战争中升级而发明的。它是发明的，因此您可以更改并添加到用户使用命令参数指定的值。
</p>
<p>例如，假设您一直想要“ <samp>-g</samp>当您运行C编译器时，使用'switch，但是您希望允许用户像往常一样使用命令参数指定其他开关。你可以用这个<code>override</code>指示：</p>
<div class="example">
<pre class="example">override CFLAGS += -g
</pre></div>

<p>您也可以使用<code>override</code>指令与<code>define</code>指令。如您所料，此操作已完成：</p>
<div class="example">
<pre class="example">override define foo =
bar
endef
</pre></div>

<p>请参阅<a href="#Multi_002dLine">定义多行变量</a> 。
</p>
<hr>
<a name="Multi_002dLine"></a>
<div class="header">
<p>下一个： <a href="#Undefine-Directive" rel="next" accesskey="n">未定义指令</a> ，上一个： <a href="#Override-Directive" rel="prev" accesskey="p">覆盖指令</a> ，上： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Defining-Multi_002dLine-Variables"></a>
<h3 class="section">6.8定义多行变量</h3>
<a name="index-define"></a>
<a name="index-endef"></a>
<a name="index-multi_002dline-variable-definition"></a>
<a name="index-variables_002c-multi_002dline"></a>
<a name="index-verbatim-variable-definition"></a>
<a name="index-defining-variables-verbatim"></a>
<a name="index-variables_002c-defining-verbatim"></a>

<p>设置变量值的另一种方法是使用<code>define</code>指示。该指令具有不寻常的语法，该语法允许将换行符包含在值中，这便于定义命令的固定序列（请参见<a href="#Canned-Recipes">定义固定食谱</a> ），以及与makefile语法一起使用的部分<code>eval</code> （请参阅<a href="#Eval-Function">评估函数</a> ）。
</p>
<p>的<code>define</code>指令在同一行后跟定义的变量名称和（可选）赋值运算符，仅此而已。赋予变量的值出现在以下几行中。值的结尾用仅包含单词的行标记<code>endef</code> 。除了语法上的差异之外， <code>define</code>就像其他变量定义一样工作。变量名可以包含函数和变量引用，在读取指令以查找要使用的实际变量名时会对其进行扩展。
</p>
<p>如果愿意，可以省略变量赋值运算符。如果省略， <code>make</code>假设它是“ <samp>=</samp> ”，然后创建一个递归扩展的变量（请参见变量<a href="#Flavors">的两种风格</a> ）。使用“ <samp>+=</samp> '运算符，该值会像其他任何附加操作一样被附加到先前的值上：用一个空格分隔新旧值。
</p>
<p>你可能会筑巢<code>define</code>指令： <code>make</code>将跟踪嵌套指令并报告错误，如果它们未全部正确关闭<code>endef</code> 。请注意，以食谱前缀字符开头的行被视为食谱的一部分，因此任何<code>define</code>要么<code>endef</code>出现在这样一行上的字符串将不被考虑<code>make</code>指令。
</p>
<div class="example">
<pre class="example">define two-lines =
echo foo
echo $(bar)
endef
</pre></div>

<p>普通分配中的值不能包含换行符；但是换行符将值中的各行分开<code>define</code>成为变量值的一部分（除了换行符之前的最后换行符<code>endef</code>并且不被视为价值的一部分）。
</p>
<p>在配方中使用时，前面的示例在功能上与此等效：</p>
<div class="example">
<pre class="example">two-lines = echo foo; echo $(bar)
</pre></div>

<p>因为用分号分隔的两个命令的行为很像两个独立的shell命令。但是请注意，使用两条单独的线表示<code>make</code>将两次调用外壳程序，并为每行运行一个独立的子外壳程序。请参见<a href="#Execution">配方执行</a> 。
</p>
<p>如果您想使用<code>define</code>要优先于命令行变量定义，可以使用<code>override</code>指令与<code>define</code> ：</p>
<div class="example">
<pre class="example">override define two-lines =
foo
$(bar)
endef
</pre></div>

<p>查看<a href="#Override-Directive">该<code>override</code>指令</a> 。
</p>
<hr>
<a name="Undefine-Directive"></a>
<div class="header">
<p>下一篇： <a href="#Environment" rel="next" accesskey="n">环境</a> ，上一篇： <a href="#Multi_002dLine" rel="prev" accesskey="p">多行</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Undefining-Variables"></a>
<h3 class="section">6.9定义变量</h3>
<a name="index-undefine"></a>
<a name="index-undefining-variable"></a>

<p>如果要清除变量，通常将其值设置为空即可。扩展此类变量将产生相同的结果（空字符串），无论是否设置了该变量。但是，如果您使用的是<code>flavor</code> （请参见<a href="#Flavor-Function">风味功能</a> ）和<code>origin</code> （请参阅<a href="#Origin-Function">Origin函数</a> ）函数，从未设置的变量和具有空值的变量之间存在差异。在这种情况下，您可能需要使用<code>undefine</code>指令使变量看起来好像从未设置过。例如：</p>
<div class="example">
<pre class="example">foo := foo
bar = bar

undefine foo
undefine bar

$(info $(origin foo))
$(info $(flavor bar))
</pre></div>

<p>本示例将为两个变量打印“ undefined”。
</p>
<p>如果要取消定义命令行变量定义，则可以使用<code>override</code>指令与<code>undefine</code> ，类似于对变量定义执行的操作：</p>
<div class="example">
<pre class="example">override undefine CFLAGS
</pre></div>

<hr>
<a name="Environment"></a>
<div class="header">
<p>下一篇： <a href="#Target_002dspecific" rel="next" accesskey="n">特定于目标</a> ，上一篇： <a href="#Undefine-Directive" rel="prev" accesskey="p">未定义指令</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Variables-from-the-Environment"></a>
<h3 class="section">6.10环境变量</h3>

<a name="index-variables_002c-environment-1"></a>
<a name="index-environment"></a>
<p>中的变量<code>make</code>可能来自于<code>make</code>运行。每个环境变量<code>make</code>看到它何时启动转化为<code>make</code>具有相同名称和值的变量。但是，makefile中的显式分配或使用命令参数会覆盖环境。（如果“ <samp>-e</samp>指定'标志，然后来自环境的值将覆盖makefile中的分配。请参阅<a href="#Options-Summary">选项摘要</a> 。但这不是推荐的做法。）
</p>
<p>因此，通过设置变量<code>CFLAGS</code>在您的环境中，可以使大多数makefile中的所有C编译使用您喜欢的编译器开关。这对于具有标准或常规含义的变量是安全的，因为您知道没有makefile会将其用于其他用途。（请注意，这并不完全可靠；有些makefile已设置<code>CFLAGS</code>明确地表示，因此不受环境值的影响。）
</p>
<p>什么时候<code>make</code>运行一个配方，将makefile中定义的变量放入每个shell的环境中。这使您可以将值传递给<code>make</code>调用（请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。默认情况下，仅将来自环境或命令行的变量传递给递归调用。您可以使用<code>export</code>指令以传递其他变量。请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> ，以获取完整的详细信息。
</p>
<p>不建议将环境变量用于其他用途。使makefile依赖于其控制之外设置的环境变量的功能是不明智的，因为这会导致不同的用户从同一个makefile获得不同的结果。这与大多数makefile的全部目的背道而驰。
</p>
<a name="index-SHELL_002c-import-from-environment"></a>
<p>此类问题尤其可能与变量有关<code>SHELL</code> ，通常存在于环境中以指定用户对交互式外壳的选择。这种选择会影响到它是非常不希望的<code>make</code> ;所以， <code>make</code>处理<code>SHELL</code>以特殊方式更改环境变量；请参阅<a href="#Choosing-the-Shell">选择外壳</a> 。
</p>
<hr>
<a name="Target_002dspecific"></a>
<div class="header">
<p>下一页： <a href="#Pattern_002dspecific" rel="next" accesskey="n">特定于模式</a> ，上一页： <a href="#Environment" rel="prev" accesskey="p">环境</a> ，上一页： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Target_002dspecific-Variable-Values"></a>
<h3 class="section">6.11特定于目标的变量值</h3>
<a name="index-target_002dspecific-variables"></a>
<a name="index-variables_002c-target_002dspecific"></a>

<p>中的变量值<code>make</code>通常是全球性的；也就是说，无论在何处进行评估，它们都是相同的（当然，除非对其进行重置）。自动变量是一种例外（请参阅<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<p>另一个例外是<em>特定于目标的变量值</em> 。使用此功能，您可以基于以下目标为同一变量定义不同的值： <code>make</code>目前正在建造中。与自动变量一样，这些值仅在目标配方的上下文中可用（以及在其他特定于目标的分配中）。
</p>
<p>设置目标特定的变量值，如下所示：</p>
<div class="example">
<pre class="example"><var>target</var> &hellip; : <var>variable-assignment</var>
</pre></div>

<p>目标特定的变量分配可以以任何或所有特殊关键字作为前缀<code>export</code> ， <code>override</code> ， 要么<code>private</code> ;它们仅将正常行为应用于此变量实例。
</p>
<p>多<var>target</var>值分别为目标列表的每个成员创建特定于目标的变量值。
</p>
<p>的<var>variable-assignment</var>可以是任何有效的分配形式；递归（' <samp>=</samp> '），简单（' <samp>:=</samp> ' 要么 ' <samp>::=</samp> '），附加（' <samp>+=</samp> '）或有条件的（' <samp>?=</samp> '）。出现在<var>variable-assignment</var>在目标的上下文中进行评估：因此，任何先前定义的特定于目标的变量值将生效。请注意，此变量实际上与任何“全局”值都不同：两个变量不必具有相同的风格（递归与简单）。
</p>
<p>特定于目标的变量具有与其他任何makefile变量相同的优先级。在命令行上（以及在环境中，如果' <samp>-e</samp> '选项有效）将优先。指定<code>override</code>指令将允许使用特定于目标的变量值。
</p>
<p>目标特定变量的另一个特殊功能：定义目标特定变量时，变量值也对该目标的所有先决条件及其所有先决条件等有效（除非这些先决条件用其变量覆盖该变量自己特定于目标的变量值）。因此，例如，如下语句：</p>
<div class="example">
<pre class="example">prog : CFLAGS = -g
prog : prog.o foo.o bar.o
</pre></div>

<p>将设置<code>CFLAGS</code>至 ' <samp>-g</samp>在食谱中<samp>prog</samp> ，但也会设置<code>CFLAGS</code>至 ' <samp>-g</samp>在创建的食谱中<samp>prog.o</samp> ， <samp>foo.o</samp>和<samp>bar.o</samp> ，以及创建其先决条件的所有食谱。
</p>
<p>请注意，给定的前提条件最多只能在每次make调用时构建一次。如果同一个文件是多个目标的先决条件，并且每个目标对于相同的目标特定变量具有不同的值，则要构建的第一个目标将导致先决条件被构建，并且先决条件将继承目标-来自第一个目标的具体价值。它将忽略任何其他目标的特定于目标的值。
</p>
<hr>
<a name="Pattern_002dspecific"></a>
<div class="header">
<p>下一篇： <a href="#Suppressing-Inheritance" rel="next" accesskey="n">抑制继承</a> ，上一篇： <a href="#Target_002dspecific" rel="prev" accesskey="p">特定于目标</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Pattern_002dspecific-Variable-Values"></a>
<h3 class="section">6.12模式特定的变量值</h3>
<a name="index-pattern_002dspecific-variables"></a>
<a name="index-variables_002c-pattern_002dspecific"></a>

<p>除了特定于目标的变量值（请参阅特定于目标的<a href="#Target_002dspecific">变量值</a> ）之外，GNU <code>make</code>支持特定于模式的变量值。在这种形式下，将为与指定模式匹配的任何目标定义变量。
</p>
<p>设置特定于模式的变量值，如下所示：</p>
<div class="example">
<pre class="example"><var>pattern</var> &hellip; : <var>variable-assignment</var>
</pre></div>
<p>哪里<var>pattern</var>是％模式。与特定于目标的变量值一样，多个<var>pattern</var>值分别为每个模式创建特定于模式的变量值。的<var>variable-assignment</var>可以是任何有效的分配形式。除非任何命令行变量设置优先，否则<code>override</code>已指定。
</p>
<p>例如：</p>
<div class="example">
<pre class="example">%.o : CFLAGS = -O
</pre></div>

<p>将分配<code>CFLAGS</code>的价值 ' <samp>-O</samp> '用于与模式匹配的所有目标<code>%.o</code> 。
</p>
<p>如果目标匹配多个模式，则首先解释具有更长词干的匹配模式特定变量。这导致更具体的变量优先于更通用的变量，例如：</p>
<div class="example">
<pre class="example">%.o: %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@

lib/%.o: CFLAGS := -fPIC -g
%.o: CFLAGS := -g

all: foo.o lib/bar.o
</pre></div>

<p>在此示例中， <code>CFLAGS</code>变量将用于更新<samp>lib/bar.o</samp>即使第二个也适用于此目标。导致杆长度相同的模式特定变量按照在makefile中定义的顺序进行考虑。
</p>
<p>在为该目标显式定义的任何目标特定变量之后，在为父目标定义的目标特定变量之前，搜索模式特定的变量。
</p>
<hr>
<a name="Suppressing-Inheritance"></a>
<div class="header">
<p>下一篇： <a href="#Special-Variables" rel="next" accesskey="n">特殊变量</a> ，上一篇： <a href="#Special-Variables" rel="next" accesskey="n">特定于</a> <a href="#Pattern_002dspecific" rel="prev" accesskey="p">模式</a> ，上一篇： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Suppressing-Inheritance-1"></a>
<h3 class="section">6.13抑制继承</h3>
<a name="index-private"></a>
<a name="index-suppressing-inheritance"></a>
<a name="index-inheritance_002c-suppressing"></a>

<p>如前几节所述， <code>make</code>变量由先决条件继承。此功能使您可以根据导致重建先决条件的目标来修改先决条件的行为。例如，您可以在<code>debug</code>目标，然后运行“ <samp>make debug</samp> '将导致该变量被以下所有先决条件继承<code>debug</code> ，而只是在运行' <samp>make all</samp> '（例如）将没有该分配。
</p>
<p>但是，有时您可能不希望继承变量。对于这些情况， <code>make</code>提供<code>private</code>修饰符。尽管此修饰符可与任何变量分配一起使用，但对于目标和模式特定的变量，它最有意义。任何标记的变量<code>private</code>对于其本地目标将是可见的，但不会被该目标的先决条件继承。标记为全局变量<code>private</code>将在全局范围内可见，但不会被任何目标继承，因此在任何配方中都不可见。
</p>
<p>例如，考虑以下makefile：</p><div class="example">
<pre class="example">EXTRA_CFLAGS =

prog: private EXTRA_CFLAGS = -L/usr/local/lib
prog: a.o b.o
</pre></div>

<p>因为<code>private</code>修饰符<code>a.o</code>和<code>b.o</code>不会继承<code>EXTRA_CFLAGS</code>来自的变量赋值<code>prog</code>目标。
</p>
<hr>
<a name="Special-Variables"></a>
<div class="header">
<p>上一页： <a href="#Suppressing-Inheritance" rel="prev" accesskey="p">抑制继承</a> ，向上： <a href="#Using-Variables" rel="up" accesskey="u">使用变量</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Other-Special-Variables"></a>
<h3 class="section">6.14其他特殊变量</h3>
<a name="index-makefiles_002c-and-special-variables"></a>
<a name="index-special-variables"></a>

<p>GNU <code>make</code>支持一些具有特殊属性的变量。
</p>
<dl compact>
<dd>
<a name="index-MAKEFILE_005fLIST-_0028list-of-parsed-makefiles_0029"></a>
<a name="index-makefiles_002c-and-MAKEFILE_005fLIST-variable"></a>
<a name="index-including-_0028MAKEFILE_005fLIST-variable_0029"></a>
</dd>
<dt><code>MAKEFILE_LIST</code></dt>
<dd><p>包含由解析的每个makefile的名称<code>make</code> ，按解析顺序进行。名称被附加在之前<code>make</code>开始解析makefile。因此，如果makefile要做的第一件事是检查此变量中的最后一个单词，它将是当前makefile的名称。一旦使用了当前的makefile <code>include</code> ，但是最后一个单词将是刚刚包含的makefile。
</p>
<p>如果一个名为<code>Makefile</code>具有以下内容：</p>
<div class="example">
<pre class="example">name1 := $(lastword $(MAKEFILE_LIST))

include inc.mk

name2 := $(lastword $(MAKEFILE_LIST))

all:
        @echo name1 = $(name1)
        @echo name2 = $(name2)
</pre></div>

<p>那么您将期望看到以下输出：</p>
<div class="example">
<pre class="example">name1 = Makefile
name2 = inc.mk
</pre></div>

<a name="index-_002eDEFAULT_005fGOAL-_0028define-default-goal_0029"></a>
</dd>
<dt><code>.DEFAULT_GOAL</code></dt>
<dd><p>设置在命令行上未指定目标的情况下要使用的默认目标（请参阅“ <a href="#Goals">指定目标的参数”</a> ）。的<code>.DEFAULT_GOAL</code>变量可让您发现当前的默认目标，通过清除其值重新启动默认的目标选择算法，或显式设置默认目标。以下示例说明了这些情况：</p>
<div class="example">
<pre class="example"># Query the default goal.
ifeq ($(.DEFAULT_GOAL),)
  $(warning no default goal is set)
endif

.PHONY: foo
foo: ; @echo $@

$(warning default goal is $(.DEFAULT_GOAL))

# Reset the default goal.
.DEFAULT_GOAL :=

.PHONY: bar
bar: ; @echo $@

$(warning default goal is $(.DEFAULT_GOAL))

# Set our own.
.DEFAULT_GOAL := foo
</pre></div>

<p>此makefile打印：</p>
<div class="example">
<pre class="example">no default goal is set
default goal is foo
default goal is bar
foo
</pre></div>

<p>请注意，将多个目标名称分配给<code>.DEFAULT_GOAL</code>无效，将导致错误。
</p>
<a name="index-MAKE_005fRESTARTS-_0028number-of-times-make-has-restarted_0029"></a>
</dd>
<dt><code>MAKE_RESTARTS</code></dt>
<dd><p>仅在以下情况下设置此变量： <code>make</code>已重新启动（请参见<a href="#Remaking-Makefiles">如何</a>重新制作<a href="#Remaking-Makefiles">Makefile</a> ）：它将包含此实例已重新启动的次数。请注意，这与递归不同（由<code>MAKELEVEL</code>变量）。您不应设置，修改或导出此变量。
</p>
<a name="index-MAKE_005fTERMOUT-_0028whether-stdout-is-a-terminal_0029"></a>
<a name="index-MAKE_005fTERMERR-_0028whether-stderr-is-a-terminal_0029"></a>
</dd>
<dt><code>MAKE_TERMOUT</code></dt>
<dt><code>MAKE_TERMERR</code></dt>
<dd><p>什么时候<code>make</code>启动时，将检查stdout和stderr是否在终端上显示其输出。如果是这样，它将设置<code>MAKE_TERMOUT</code>和<code>MAKE_TERMERR</code>分别为终端设备的名称（或<code>true</code>如果无法确定）。如果设置，这些变量将被标记为导出。这些变量不会被更改<code>make</code>如果已设置，则不会被修改。
</p>
<p>可以使用这些值（特别是与输出同步结合使用（请参阅<a href="#Parallel-Output">并行执行期间的输出</a> ））来确定是否<code>make</code>本身正在写入终端；例如，可以测试它们以确定是否强制配方命令生成彩色输出。
</p>
<p>如果您调用子<code>make</code>并重定向其stdout或stderr，如果您的makefile文件依赖于它们，则您有责任重置或取消导出这些变量。
</p>
<a name="index-_002eRECIPEPREFIX-_0028change-the-recipe-prefix-character_0029"></a>
</dd>
<dt><code>.RECIPEPREFIX</code></dt>
<dd><p>该变量值的第一个字符用作make假定正在引入配方行的字符。如果变量为空（默认情况下为空），则该字符为标准制表符。例如，这是一个有效的makefile：</p>
<div class="example">
<pre class="example">.RECIPEPREFIX = &gt;
all:
&gt; @echo Hello, world
</pre></div>

<p>的价值<code>.RECIPEPREFIX</code>可以多次更改；设置后，它对所有解析的规则均保持有效，直到被修改。
</p>
<a name="index-_002eVARIABLES-_0028list-of-variables_0029"></a>
</dd>
<dt><code>.VARIABLES</code></dt>
<dd><p>扩展到到目前为止定义的所有全局变量的<em>名称</em>列表。这包括具有空值的变量以及内置变量（请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> ），但不包括仅在特定于目标的上下文中定义的任何变量。请注意，您分配给该变量的任何值都将被忽略；它将始终返回其特殊值。
</p>

<a name="index-_002eFEATURES-_0028list-of-supported-features_0029"></a>
</dd>
<dt><code>.FEATURES</code></dt>
<dd><p>扩展到此版本的版本支持的特殊功能列表<code>make</code> 。可能的值包括但不限于：</p>
<dl compact>
<dt>' <samp>archives</samp> '</dt>
<dd><p>支持<code>ar</code> （存档）文件，使用特殊的文件名语法。请参阅<a href="#Archives">使用<code>make</code>更新存档文件</a> 。
</p>
</dd>
<dt>' <samp>check-symlink</samp> '</dt>
<dd><p>支持<code>-L</code> （ <code>--check-symlink-times</code> ）标志。请参阅<a href="#Options-Summary">选项摘要</a> 。
</p>
</dd>
<dt>' <samp>else-if</samp> '</dt>
<dd><p>支持“ else if”非嵌套条件。请参阅<a href="#Conditional-Syntax">条件句法</a> 。
</p>
</dd>
<dt>' <samp>jobserver</samp> '</dt>
<dd><p>支持“作业服务器”增强的并行构建。请参阅<a href="#Parallel">并行执行</a> 。
</p>
</dd>
<dt>' <samp>oneshell</samp> '</dt>
<dd><p>支持<code>.ONESHELL</code>特殊目标。请参阅<a href="#One-Shell">使用一个外壳</a> 。
</p>
</dd>
<dt>' <samp>order-only</samp> '</dt>
<dd><p>支持仅订购的先决条件。请参阅<a href="#Prerequisite-Types">先决条件类型</a> 。
</p>
</dd>
<dt>' <samp>second-expansion</samp> '</dt>
<dd><p>支持先决条件列表的二次扩展。
</p>
</dd>
<dt>' <samp>shortest-stem</samp> '</dt>
<dd><p>使用“最短茎”方法选择将使用的多个适用选项中的哪个模式。请参阅<a href="#Pattern-Match">模式匹配</a> 。
</p>
</dd>
<dt>' <samp>target-specific</samp> '</dt>
<dd><p>支持特定于目标和特定于模式的变量分配。请参阅<a href="#Target_002dspecific">特定于目标的变量值</a> 。
</p>
</dd>
<dt>' <samp>undefine</samp> '</dt>
<dd><p>支持<code>undefine</code>指示。请参阅<a href="#Undefine-Directive">未定义指令</a> 。
</p>
</dd>
<dt>' <samp>guile</samp> '</dt>
<dd><p>已将GNU Guile用作嵌入式扩展语言。参见<a href="#Guile-Integration">GNU Guile集成</a> 。
</p>
</dd>
<dt>' <samp>load</samp> '</dt>
<dd><p>支持可动态加载的对象以创建自定义扩展。请参阅<a href="#Loading-Objects">加载动态对象</a> 。
</p></dd>
</dl>

<a name="index-_002eINCLUDE_005fDIRS-_0028list-of-include-directories_0029"></a>
</dd>
<dt><code>.INCLUDE_DIRS</code></dt>
<dd><p>扩展到目录列表<code>make</code>搜索包含的makefile（请参阅“ <a href="#Include">包含其他makefile”</a> ）。
</p>
</dd>
</dl>

<hr>
<a name="Conditionals"></a>
<div class="header">
<p>下一页： <a href="#Functions" rel="next" accesskey="n">函数</a> ，上一篇： <a href="#Using-Variables" rel="prev" accesskey="p">使用变量</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Conditional-Parts-of-Makefiles"></a>
<h2 class="chapter">Makefile的7个条件部分</h2>

<a name="index-conditionals"></a>
<p><em>条件</em>指令根据变量的值使makefile的一部分被服从或忽略。条件变量可以将一个变量的值与另一个变量的值进行比较，或者将变量的值与常量字符串进行比较。条件控制什么<code>make</code>实际上在makefile中“看到”，因此在执行时<em>不能</em>将其用于控制配方。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Conditional-Example" accesskey="1">条件示例</a> ：</td><td>  </td><td align="left" valign="top">有条件的例子</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditional-Syntax" accesskey="2">条件句法</a> ：</td><td>  </td><td align="left" valign="top">条件句的语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Testing-Flags" accesskey="3">测试标志</a> ：</td><td>  </td><td align="left" valign="top">测试标志的条件。
</td></tr>
</tbody></table>

<hr>
<a name="Conditional-Example"></a>
<div class="header">
<p>下一篇： <a href="#Conditional-Syntax" rel="next" accesskey="n">条件语法</a> ，上一篇： <a href="#Conditional-Syntax" rel="next" accesskey="n">条件句</a> ，上： <a href="#Conditionals" rel="prev" accesskey="p">条件</a> <a href="#Conditionals" rel="up" accesskey="u">句</a> [ <a href="#SEC_Contents" title="目录" rel="contents">Contents</a> ] [ <a href="#Concept-Index" title="指数" rel="index">Index</a> ]</p>
</div>
<a name="Example-of-a-Conditional"></a>
<h3 class="section">7.1有条件的例子</h3>

<p>以下示例说明了条件<code>make</code>使用一组库，如果<code>CC</code>变量是“ <samp>gcc</samp> ”，否则使用另一组库。它通过控制将使用两条配方行中的哪一条来工作。结果是“ <samp>CC=gcc</samp> '作为对<code>make</code>不仅更改了使用哪个编译器，还更改了链接的库。
</p>
<div class="example">
<pre class="example">libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif
</pre></div>

<p>此条件使用三个指令：一个<code>ifeq</code>一<code>else</code>还有一个<code>endif</code> 。
</p>
<p>的<code>ifeq</code>指令开始条件，并指定条件。它包含两个参数，用逗号分隔并用括号括起来。对两个参数都执行变量替换，然后将它们进行比较。makefile之后的行<code>ifeq</code>如果两个参数匹配，则服从；否则，它们将被忽略。
</p>
<p>的<code>else</code>如果先前的条件失败，则伪指令将导致遵循以下几行。在上面的示例中，这意味着只要不使用第一种替代方法，就使用第二种替代链接命令。有一个可选的<code>else</code>有条件的。
</p>
<p>的<code>endif</code>指令结束条件。每个条件必须以<code>endif</code> 。随后是无条件的makefile文本。
</p>
<p>如本示例所示，条件语句在文本级别起作用：根据条件，条件语句的行被视为makefile的一部分，或被忽略。这就是为什么makefile的较大句法单元（例如规则）可能会跨越条件句的开始或结尾的原因。
</p>
<p>当变量<code>CC</code>具有价值' <samp>gcc</samp> '，以上示例具有以下效果：</p>
<div class="example">
<pre class="example">foo: $(objects)
        $(CC) -o foo $(objects) $(libs_for_gcc)
</pre></div>

<p>当变量<code>CC</code>具有任何其他值，效果是这样的：</p>
<div class="example">
<pre class="example">foo: $(objects)
        $(CC) -o foo $(objects) $(normal_libs)
</pre></div>

<p>通过条件化变量赋值然后无条件使用变量，可以通过另一种方式获得等效结果：</p>
<div class="example">
<pre class="example">libs_for_gcc = -lgnu
normal_libs =

ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif

foo: $(objects)
        $(CC) -o foo $(objects) $(libs)
</pre></div>

<hr>
<a name="Conditional-Syntax"></a>
<div class="header">
<p>下一篇： <a href="#Testing-Flags" rel="next" accesskey="n">测试标志</a> ，上一篇： <a href="#Conditional-Example" rel="prev" accesskey="p">有条件的示例</a> ，上一篇： <a href="#Conditionals" rel="up" accesskey="u">有条件的</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Syntax-of-Conditionals"></a>
<h3 class="section">7.2条件句法</h3>
<a name="index-ifdef"></a>
<a name="index-ifeq"></a>
<a name="index-ifndef"></a>
<a name="index-ifneq"></a>
<a name="index-else"></a>
<a name="index-endif"></a>

<p>不带条件的简单条件的语法<code>else</code>如下：</p>
<div class="example">
<pre class="example"><var>conditional-directive</var>
<var>text-if-true</var>
endif
</pre></div>

<p>的<var>text-if-true</var>可以是任何文本行，如果条件为真，则应被视为makefile的一部分。如果条件为假，则不使用任何文本。
</p>
<p>复杂条件的语法如下：</p>
<div class="example">
<pre class="example"><var>conditional-directive</var>
<var>text-if-true</var>
else
<var>text-if-false</var>
endif
</pre></div>

<p>要么：</p>
<div class="example">
<pre class="example"><var>conditional-directive-one</var>
<var>text-if-one-is-true</var>
else <var>conditional-directive-two</var>
<var>text-if-two-is-true</var>
else
<var>text-if-one-and-two-are-false</var>
endif
</pre></div>

<p>可以有很多“ <code>else</code><var>conditional-directive</var> ”子句。一旦给定条件成立， <var>text-if-true</var>使用并且不使用其他子句；如果没有条件成立，那么<var>text-if-false</var>用来。的<var>text-if-true</var>和<var>text-if-false</var>可以是任意数量的文本行。
</p>
<p>的语法<var>conditional-directive</var>条件是简单还是复杂都是相同的；之后<code>else</code>或不。有四种不同的指令可以测试不同的条件。这是它们的表：</p>
<dl compact>
<dt><code>ifeq (<var>arg1</var>, <var>arg2</var>)</code></dt>
<dt><code>ifeq '<var>arg1</var>' '<var>arg2</var>'</code></dt>
<dt><code>ifeq "<var>arg1</var>" "<var>arg2</var>"</code></dt>
<dt><code>ifeq "<var>arg1</var>" '<var>arg2</var>'</code></dt>
<dt><code>ifeq '<var>arg1</var>' "<var>arg2</var>"</code></dt>
<dd><p>展开中的所有变量引用<var>arg1</var>和<var>arg2</var>并比较它们。如果它们相同，则<var>text-if-true</var>是有效的;否则， <var>text-if-false</var> （如果有）是有效的。
</p>
<p>通常，您想测试变量是否具有非空值。当值由变量和函数的复杂扩展产生时，您认为为空的扩展实际上可能包含空格字符，因此不会被视为空。但是，您可以使用<code>strip</code>函数（请参见“ <a href="#Text-Functions">文本函数”</a> ）以避免将空格解释为非空值。例如：</p>
<div class="example">
<pre class="example">ifeq ($(strip $(foo)),)
<var>text-if-empty</var>
endif
</pre></div>

<p>将评估<var>text-if-empty</var>即使扩张<code>$(foo)</code>包含空格字符。
</p>
</dd>
<dt><code>ifneq (<var>arg1</var>, <var>arg2</var>)</code></dt>
<dt><code>ifneq '<var>arg1</var>' '<var>arg2</var>'</code></dt>
<dt><code>ifneq "<var>arg1</var>" "<var>arg2</var>"</code></dt>
<dt><code>ifneq "<var>arg1</var>" '<var>arg2</var>'</code></dt>
<dt><code>ifneq '<var>arg1</var>' "<var>arg2</var>"</code></dt>
<dd><p>展开中的所有变量引用<var>arg1</var>和<var>arg2</var>并比较它们。如果它们不同，则<var>text-if-true</var>是有效的;否则， <var>text-if-false</var> （如果有）是有效的。
</p>
</dd>
<dt><code>ifdef <var>variable-name</var></code></dt>
<dd><p>的<code>ifdef</code>形式采用可变作为它的参数，而不是一个变量的引用<em>名</em> 。如果该变量的值具有非空值，则<var>text-if-true</var>是有效的;否则， <var>text-if-false</var> （如果有）是有效的。从未定义的变量的值为空。文本<var>variable-name</var>被扩展，因此它可以是变量或扩展为变量名的函数。例如：</p>
<div class="example">
<pre class="example">bar = true
foo = bar
ifdef $(foo)
frobozz = yes
endif
</pre></div>

<p>变量参考<code>$(foo)</code>扩大，屈服<code>bar</code> ，它被认为是变量的名称。变量<code>bar</code>不扩展，但检查其值以确定其是否为非空。
</p>
<p>注意<code>ifdef</code>仅测试变量是否具有值。它不会扩展变量以查看该值是否为非空。因此，使用<code>ifdef</code>除以下定义外，所有定义均返回true <code>foo =</code> 。要测试一个空值，请使用<code>ifeq ($(foo),)</code> <!-- /@w --> 。例如，</p>
<div class="example">
<pre class="example">bar =
foo = $(bar)
ifdef foo
frobozz = yes
else
frobozz = no
endif
</pre></div>

<p>设置“ <samp>frobozz</samp> ' 至 ' <samp>yes</samp> '，而：</p>
<div class="example">
<pre class="example">foo =
ifdef foo
frobozz = yes
else
frobozz = no
endif
</pre></div>

<p>设置“ <samp>frobozz</samp> ' 至 ' <samp>no</samp> '。
</p>
</dd>
<dt><code>ifndef <var>variable-name</var></code></dt>
<dd><p>如果变量<var>variable-name</var>有一个空值， <var>text-if-true</var>是有效的;否则， <var>text-if-false</var> （如果有）是有效的。扩展和测试规则<var>variable-name</var>与...相同<code>ifdef</code>指示。
</p></dd>
</dl>

<p>条件指令行的开头允许多余的空格，但忽略这些空格，但是不允许使用制表符。（如果该行以标签开头，则将其视为规则配方的一部分。）除此以外，多余的空格或制表符可能会插入，除非在伪指令名称内或在参数内，否则在任何地方都无效。以'开头的评论<samp>#</samp> '可能会出现在行尾。
</p>
<p>在条件中起作用的其他两个指令是<code>else</code>和<code>endif</code> 。这些指令中的每一个都写成一个单词，没有参数。在行的开头，允许多余的空格，忽略它们，在行的结尾，空格或制表符。以'开头的评论<samp>#</samp> '可能会出现在行尾。
</p>
<p>条件影响makefile的哪几行<code>make</code>用途。如果条件为真， <code>make</code>读取行的<var>text-if-true</var>作为makefile的一部分；如果条件为假， <code>make</code>完全忽略这些行。随之而来的是，makefile的句法单元（例如规则）可以安全地分割在条件的开头或结尾。
</p>
<p><code>make</code>读取makefile时评估条件语句。因此，您不能在条件测试中使用自动变量，因为只有在运行配方之前才定义它们（请参见<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<p>为避免令人无法忍受的混乱，不允许在一个makefile中启动条件文件，而在另一个makefile中结束条件文件。但是，您可以编写一个<code>include</code>条件指令中的指令，前提是您不尝试在包含文件中终止条件指令。
</p>
<hr>
<a name="Testing-Flags"></a>
<div class="header">
<p>上一页： <a href="#Conditional-Syntax" rel="prev" accesskey="p">条件句法</a> ，上： <a href="#Conditionals" rel="up" accesskey="u">条件句</a> [ <a href="#SEC_Contents" title="目录" rel="contents">Contents</a> ] [ <a href="#Concept-Index" title="指数" rel="index">Index</a> ]</p>
</div>
<a name="Conditionals-that-Test-Flags"></a>
<h3 class="section">7.3测试标志的条件</h3>

<p>您可以编写一个条件来测试<code>make</code>命令标记，例如' <samp>-t</samp> '通过使用变量<code>MAKEFLAGS</code>与<code>findstring</code>函数（请参见<a href="#Text-Functions">用于字符串替换和分析的函数</a> ）。这在以下情况下很有用<code>touch</code>不足以使文件显示为最新。
</p>
<p>的<code>findstring</code>函数确定一个字符串是否显示为另一字符串的子字符串。如果您要测试“ <samp>-t</samp> '标志，使用' <samp>t</samp> '作为第一个字符串和<code>MAKEFLAGS</code>和其他一样。
</p>
<p>例如，这是如何安排使用“ <samp>ranlib -t</samp> '完成标记最新的存档文件：</p>
<div class="example">
<pre class="example">archive.a: &hellip;
ifneq (,$(findstring t,$(MAKEFLAGS)))
        +touch archive.a
        +ranlib -t archive.a
else
        ranlib archive.a
endif
</pre></div>

<p>' <samp>+</samp> '前缀将这些配方行标记为“递归”，因此即使使用了' <samp>-t</samp>的标志。请参阅<a href="#Recursion">递归使用<code>make</code></a> 。
</p>
<hr>
<a name="Functions"></a>
<div class="header">
<p>下一个： <a href="#Running" rel="next" accesskey="n">跑步</a> ，上一个： <a href="#Conditionals" rel="prev" accesskey="p">有条件的</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Functions-for-Transforming-Text"></a>
<h2 class="chapter">8种文本转换功能</h2>
<a name="index-functions"></a>

<p><em>函数</em>使您可以在makefile中进行文本处理，以计算要操作的文件或在配方中使用的命令。您可以在<em>函数调用</em>中使用<em>函数</em> ，在其中给出函数的名称和一些文本（ <em>参数</em> ），以使函数可以进行操作。函数的处理结果在调用时被替换到makefile中，就像变量可能被替换一样。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Syntax-of-Functions" accesskey="1">函数语法</a> ：</td><td>  </td><td align="left" valign="top">如何编写函数调用。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Text-Functions" accesskey="2">文字功能</a> ：</td><td>  </td><td align="left" valign="top">通用文本操作功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#File-Name-Functions" accesskey="3">文件名功能</a> ：</td><td>  </td><td align="left" valign="top">处理文件名的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Conditional-Functions" accesskey="4">条件函数</a> ：</td><td>  </td><td align="left" valign="top">实现条件的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Foreach-Function" accesskey="5">Foreach函数</a> ：</td><td>  </td><td align="left" valign="top">重复一些带有受控变化的文本。
</td></tr>
<tr><td align="left" valign="top">• <a href="#File-Function" accesskey="6">文件功能</a> ：</td><td>  </td><td align="left" valign="top">将文本写入文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Call-Function" accesskey="7">通话功能</a> ：</td><td>  </td><td align="left" valign="top">展开用户定义的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Value-Function" accesskey="8">价值功能</a> ：</td><td>  </td><td align="left" valign="top">返回变量的未扩展值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Eval-Function" accesskey="9">评估功能</a> ：</td><td>  </td><td align="left" valign="top">将参数评估为makefile语法。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Origin-Function">原点功能</a> ：</td><td>  </td><td align="left" valign="top">查找变量在何处获得其值。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Flavor-Function">风味功能</a> ：</td><td>  </td><td align="left" valign="top">找出变量的味道。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Make-Control-Functions">使控制功能</a> ：</td><td>  </td><td align="left" valign="top">控制make运行方式的函数。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Shell-Function">Shell功能</a> ：</td><td>  </td><td align="left" valign="top">替换shell命令的输出。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Function">Guile功能</a> ：</td><td>  </td><td align="left" valign="top">使用GNU Guile嵌入式脚本语言。
</td></tr>
</tbody></table>

<hr>
<a name="Syntax-of-Functions"></a>
<div class="header">
<p>下一个： <a href="#Text-Functions" rel="next" accesskey="n">文本函数</a> ，上一个： <a href="#Functions" rel="prev" accesskey="p">函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Function-Call-Syntax"></a>
<h3 class="section">8.1函数调用语法</h3>
<a name="index-_0024_002c-in-function-call"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-in-function-call"></a>
<a name="index-arguments-of-functions"></a>
<a name="index-functions_002c-syntax-of"></a>

<p>函数调用类似于变量引用。它可以出现在变量引用可以出现的任何位置，并使用与变量引用相同的规则进行扩展。函数调用如下所示：</p>
<div class="example">
<pre class="example">$(<var>function</var> <var>arguments</var>)
</pre></div>

<p>或像这样：</p>
<div class="example">
<pre class="example">${<var>function</var> <var>arguments</var>}
</pre></div>

<p>这里<var>function</var>是函数名称；属于的名称的简短列表之一<code>make</code> 。您也可以使用<code>call</code>内置功能。
</p>
<p>的<var>arguments</var>是该函数的参数。它们与函数名称之间用一个或多个空格或制表符分隔，并且如果有多个自变量，则它们之间用逗号分隔。这样的空格和逗号不是参数值的一部分。用于包围函数调用的定界符（无论是括号还是大括号）只能在匹配对中出现在参数中。另一种定界符可能会单独出现。如果参数本身包含其他函数调用或变量引用，则对所有引用使用相同类型的分隔符是最明智的；写' <samp>$(subst a,b,$(x))</samp> ' <!-- /@w --> ，不是' <samp>$(subst a,b,${x})</samp> ' <!-- /@w --> 。这是因为它更清楚，并且因为仅匹配一种定界符才能找到引用的末尾。
</p>
<p>通过替换变量和函数调用来处理为每个自变量编写的文本，以产生自变量值，即函数所作用的文本。替换按照参数出现的顺序进行。
</p>
<p>逗号和不匹配的括号或大括号不能出现在所写参数的文本中；如前所述，前导空格不能出现在第一个参数的文本中。可以通过变量替换将这些字符放入参数值。首先定义变量<code>comma</code>和<code>space</code>其值是孤立的逗号和空格字符，然后在需要此类字符的地方替换这些变量，如下所示：</p>
<div class="example">
<pre class="example">comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
# <span class="roman">bar is now &lsquo;a,b,c&rsquo;.</span>
</pre></div>

<p>在这里<code>subst</code>函数通过的值用逗号替换每个空格<code>foo</code> ，并替换结果。
</p>
<hr>
<a name="Text-Functions"></a>
<div class="header">
<p>下一页： <a href="#File-Name-Functions" rel="next" accesskey="n">文件名函数</a> ，上一篇： <a href="#File-Name-Functions" rel="next" accesskey="n">函数</a> <a href="#Syntax-of-Functions" rel="prev" accesskey="p">语法</a> ，上一篇： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Functions-for-String-Substitution-and-Analysis"></a>
<h3 class="section">8.2字符串替换和分析的功能</h3>
<a name="index-functions_002c-for-text"></a>

<p>以下是一些对字符串进行操作的函数：</p>
<dl compact>
<dt><code>$(subst <var>from</var>,<var>to</var>,<var>text</var>)</code></dt>
<dd><a name="index-subst-1"></a>
<p>对文本执行文本替换<var>text</var> ：每次出现<var>from</var>被替换为<var>to</var> 。结果将替换为函数调用。例如，</p>
<div class="example">
<pre class="example">$(subst ee,EE,feet on the street)
</pre></div>

<p>替换字符串' <samp>fEEt on the strEEt</samp> '。
</p>
</dd>
<dt><code>$(patsubst <var>pattern</var>,<var>replacement</var>,<var>text</var>)</code></dt>
<dd><a name="index-patsubst-1"></a>
<p>查找中用空格分隔的单词<var>text</var>那个匹配<var>pattern</var>并替换为<var>replacement</var> 。这里<var>pattern</var>可能包含“ <samp>%</samp> '，用作通配符，匹配单词中任意数量的任何字符。如果<var>replacement</var>还包含一个“ <samp>%</samp> '，' <samp>%</samp> '替换为与' <samp>%</samp>在<var>pattern</var> 。只有第一个<samp>%</samp> ' 在里面<var>pattern</var>和<var>replacement</var>被这样对待；任何后续的“ <samp>%</samp> '不变。
</p>
<a name="index-_0025_002c-quoting-in-patsubst"></a>
<a name="index-_0025_002c-quoting-with-_005c-_0028backslash_0029-2"></a>
<a name="index-_005c-_0028backslash_0029_002c-to-quote-_0025-2"></a>
<a name="index-backslash-_0028_005c_0029_002c-to-quote-_0025-2"></a>
<a name="index-quoting-_0025_002c-in-patsubst"></a>
<p>' <samp>%</samp> '个字符<code>patsubst</code>函数调用可以用前面的反斜杠（' <samp>\</samp> '）。反斜杠原本会引用' <samp>%</samp> '字符可以加更多反斜杠。引号' <samp>%</samp>在比较文件名或替换词干之前，将从字符中删除'字符或其他反斜杠。没有反引号危险的反斜杠<samp>%</samp>人物毫不客气。例如图案<samp>the\%weird\\%pattern\\</samp>拥有 ' <samp>the%weird\</samp> “在手术人员之前” <samp>%</samp> “字符和” <samp>pattern\\</samp> '跟随它。最后两个反斜杠不受影响，因为它们不会影响任何“ <samp>%</samp>字符。
</p>
<p>单词之间的空格被折叠成单个空格字符；前导和尾随空白将被丢弃。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">$(patsubst %.c,%.o,x.c.c bar.c)
</pre></div>

<p>产生价值' <samp>x.c.o bar.o</samp> '。
</p>
<p>替代参考（请参见<a href="#Substitution-Refs">替代参考</a> ）是一种获得效果的更简单方法。 <code>patsubst</code>功能：</p>
<div class="example">
<pre class="example">$(<var>var</var>:<var>pattern</var>=<var>replacement</var>)
</pre></div>

<p>相当于</p>
<div class="example">
<pre class="example">$(patsubst <var>pattern</var>,<var>replacement</var>,$(<var>var</var>))
</pre></div>

<p>第二个速记简化了以下最常见的用法之一<code>patsubst</code> ：替换文件名末尾的后缀。
</p>
<div class="example">
<pre class="example">$(<var>var</var>:<var>suffix</var>=<var>replacement</var>)
</pre></div>

<p>相当于</p>
<div class="example">
<pre class="example">$(patsubst %<var>suffix</var>,%<var>replacement</var>,$(<var>var</var>))
</pre></div>

<p>例如，您可能有一个目标文件列表：</p>
<div class="example">
<pre class="example">objects = foo.o bar.o baz.o
</pre></div>

<p>要获取相应源文件的列表，您可以简单地编写：</p>
<div class="example">
<pre class="example">$(objects:.o=.c)
</pre></div>

<p>而不是使用一般形式：</p>
<div class="example">
<pre class="example">$(patsubst %.o,%.c,$(objects))
</pre></div>

</dd>
<dt><code>$(strip <var>string</var>)</code></dt>
<dd><a name="index-stripping-whitespace"></a>
<a name="index-whitespace_002c-stripping"></a>
<a name="index-spaces_002c-stripping"></a>
<a name="index-strip"></a>
<p>从中删除前导和尾随空格<var>string</var>并将一个或多个空格字符的每个内部序列替换为一个空格。因此， <samp>$(strip a b c )</samp> ' 结果是 ' <samp>a b c</samp> ' <!-- /@w --> 。
</p>
<p>功能<code>strip</code>与条件条件一起使用时，可能会非常有用。比较带有空字符串的内容时' <samp></samp>使用<code>ifeq</code>要么<code>ifneq</code> ，您通常希望仅一个空格的字符串与空字符串匹配（请参阅<a href="#Conditionals">Conditionals</a> ）。
</p>
<p>因此，以下内容可能无法获得预期的结果：</p>
<div class="example">
<pre class="example">.PHONY: all
ifneq   &quot;$(needs_made)&quot; &quot;&quot;
all: $(needs_made)
else
all:;@echo 'Nothing to make!'
endif
</pre></div>

<p>替换变量引用<samp><span class="nolinebreak">$(needs_made)</span></samp> ' <!-- /@w -->与功能调用' <samp>$(strip <span class="nolinebreak">$(needs_made))</span></samp> ' <!-- /@w --> <code>ifneq</code>指令将使其更强大。
</p>
</dd>
<dt><code>$(findstring <var>find</var>,<var>in</var>)</code></dt>
<dd><a name="index-findstring"></a>
<a name="index-searching-for-strings"></a>
<a name="index-finding-strings"></a>
<a name="index-strings_002c-searching-for"></a>
<p>搜索次数<var>in</var>发生<var>find</var> 。如果发生，则值为<var>find</var> ;否则，该值为空。您可以在有条件的情况下使用此函数来测试给定字符串中是否存在特定子字符串。因此，这两个例子</p>
<div class="example">
<pre class="example">$(findstring a,a b c)
$(findstring a,b c)
</pre></div>

<p>产生值' <samp>a</samp> '和' <samp></samp> '（空字符串）。有关的实际应用，请参见<a href="#Testing-Flags">测试标志</a> 。 <code>findstring</code> 。
</p>
<a name="index-filter"></a>
<a name="index-filtering-words"></a>
<a name="index-words_002c-filtering"></a>
</dd>
<dt><code>$(filter <var>pattern</var>…,<var>text</var>)</code></dt>
<dd><p>返回所有用空格分隔的单词<var>text</var> <em>确实</em>与任何<var>pattern</var>单词，删除所有<em>不</em>匹配的单词。模式使用' <samp>%</samp>就像在<code>patsubst</code>上面的功能。
</p>
<p>的<code>filter</code>函数可用于分隔变量中不同类型的字符串（例如文件名）。例如：</p>
<div class="example">
<pre class="example">sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
        cc $(filter %.c %.s,$(sources)) -o foo
</pre></div>

<p>说<samp>foo</samp>取决于<samp>foo.c</samp> ， <samp>bar.c</samp> ， <samp>baz.s</samp>和<samp>ugh.h</samp>但是只有<samp>foo.c</samp> ， <samp>bar.c</samp>和<samp>baz.s</samp>应该在给编译器的命令中指定。
</p>
</dd>
<dt><code>$(filter-out <var>pattern</var>…,<var>text</var>)</code></dt>
<dd><a name="index-filter_002dout"></a>
<a name="index-filtering-out-words"></a>
<a name="index-words_002c-filtering-out"></a>
<p>返回所有用空格分隔的单词<var>text</var> <em>不</em>符合任何<var>pattern</var>也就是说，除去<em>那些</em>匹配一个或多个单词。这与<code>filter</code>功能。
</p>
<p>例如，给定：</p>
<div class="example">
<pre class="example">objects=main1.o foo.o main2.o bar.o
mains=main1.o main2.o
</pre></div>

<p>以下内容将生成一个列表，其中包含所有不在' <samp>mains</samp> '：</p>
<div class="example">
<pre class="example">$(filter-out $(mains),$(objects))
</pre></div>

<a name="index-sort"></a>
<a name="index-sorting-words"></a>
</dd>
<dt><code>$(sort <var>list</var>)</code></dt>
<dd><p>排序的词<var>list</var>以词汇顺序删除重复的单词。输出是由单个空格分隔的单词列表。从而，</p>
<div class="example">
<pre class="example">$(sort foo bar lose)
</pre></div>

<p>返回值' <samp>bar foo lose</samp> '。
</p>
<a name="index-removing-duplicate-words"></a>
<a name="index-duplicate-words_002c-removing"></a>
<a name="index-words_002c-removing-duplicates"></a>
<p>顺便说一句<code>sort</code>删除重复的单词，即使您不关心排序顺序，也可以将其用于此目的。
</p>
</dd>
<dt><code>$(word <var>n</var>,<var>text</var>)</code></dt>
<dd><a name="index-word"></a>
<a name="index-word_002c-selecting-a"></a>
<a name="index-selecting-a-word"></a>
<p>返回<var>n</var>的词<var>text</var> 。的合法价值<var>n</var>从1开始如果<var>n</var>大于中的字数<var>text</var> ，该值为空。例如，</p>
<div class="example">
<pre class="example">$(word 2, foo bar baz)
</pre></div>

<p>返回“ <samp>bar</samp> '。
</p>
</dd>
<dt><code>$(wordlist <var>s</var>,<var>e</var>,<var>text</var>)</code></dt>
<dd><a name="index-wordlist"></a>
<a name="index-words_002c-selecting-lists-of"></a>
<a name="index-selecting-word-lists"></a>
<p>返回中的单词列表<var>text</var>以词开头<var>s</var>并以单词结尾<var>e</var> （包括的）。的合法价值<var>s</var>从1开始； <var>e</var>可以从0开始。如果<var>s</var>大于中的字数<var>text</var> ，该值为空。如果<var>e</var>大于中的字数<var>text</var> ，直到字尾<var>text</var>返回。如果<var>s</var>大于<var>e</var> ，则不会返回任何内容。例如，</p>
<div class="example">
<pre class="example">$(wordlist 2, 3, foo bar baz)
</pre></div>

<p>返回“ <samp>bar baz</samp> '。
</p>
</dd>
<dt><code>$(words <var>text</var>)</code></dt>
<dd><a name="index-words"></a>
<a name="index-words_002c-finding-number"></a>
<p>返回中的单词数<var>text</var> 。因此， <var>text</var>是<code>$(word $(words <var>text</var>),<var>text</var>)</code> <!-- /@w --> 。
</p>
</dd>
<dt><code>$(firstword <var>names</var>…)</code></dt>
<dd><a name="index-firstword"></a>
<a name="index-words_002c-extracting-first"></a>
<p>争论<var>names</var>被视为由空格分隔的一系列名称。该值是系列中的名字。其余名称将被忽略。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">$(firstword foo bar)
</pre></div>

<p>产生结果<samp>foo</samp> '。虽然<code>$(firstword <var>text</var>)</code>是相同的<code>$(word 1,<var>text</var>)</code> ， <code>firstword</code>为了简单起见，保留了该功能。
</p>

</dd>
<dt><code>$(lastword <var>names</var>…)</code></dt>
<dd><a name="index-lastword"></a>
<a name="index-words_002c-extracting-last"></a>
<p>争论<var>names</var>被视为由空格分隔的一系列名称。该值是系列中的姓氏。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">$(lastword foo bar)
</pre></div>

<p>产生结果<samp>bar</samp> '。虽然<code>$(lastword <var>text</var>)</code>是相同的<code>$(word $(words <var>text</var>),<var>text</var>)</code> ， <code>lastword</code>添加了功能，以简化操作并提高性能。
</p></dd>
</dl>


<p>这是使用<code>subst</code>和<code>patsubst</code> 。假设一个makefile使用<code>VPATH</code>用于指定目录列表的变量<code>make</code>应该搜索必备文件（请参阅<a href="#General-Search"><code>VPATH</code>搜索所有先决条件的路径</a> ）。本示例说明如何告诉C编译器在同一目录列表中搜索头文件。
</p>
<p>的价值<code>VPATH</code>是用冒号分隔的目录列表，例如“ <samp>src:../headers</samp> '。首先， <code>subst</code>函数用于将冒号更改为空格：</p>
<div class="example">
<pre class="example">$(subst :, ,$(VPATH))
</pre></div>

<p>这会产生“ <samp>src ../headers</samp> '。然后<code>patsubst</code>用于将每个目录名称转换为“ <samp>-I</samp>的标志。这些可以添加到变量的值中<code>CFLAGS</code> ，它会自动传递给C编译器，如下所示：</p>
<div class="example">
<pre class="example">override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
</pre></div>

<p>效果是将文本“ <samp>-Isrc -I../headers</samp> '至先前给定的值<code>CFLAGS</code> 。的<code>override</code>使用伪指令，以便分配新值，即使之前的值<code>CFLAGS</code>用的命令参数中指定（见<a href="#Override-Directive">的<code>override</code>指令</a> ）。
</p>
<hr>
<a name="File-Name-Functions"></a>
<div class="header">
<p>下一篇： <a href="#Conditional-Functions" rel="next" accesskey="n">条件函数</a> ，上一篇： <a href="#Text-Functions" rel="prev" accesskey="p">文本函数</a> ，上一篇： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Functions-for-File-Names"></a>
<h3 class="section">8.3文件名功能</h3>
<a name="index-functions_002c-for-file-names"></a>
<a name="index-file-name-functions"></a>

<p>某些内置扩展功能专门涉及拆分文件名或文件名列表。
</p>
<p>以下每个功能都会对文件名执行特定的转换。该函数的参数被视为一系列文件名，用空格分隔。（前导空格和尾随空格将被忽略。）系列中的每个文件名都以相同的方式转换，并且结果之间用单个空格连接在一起。
</p>
<dl compact>
<dt><code>$(dir <var>names</var>…)</code></dt>
<dd><a name="index-dir"></a>
<a name="index-directory-part"></a>
<a name="index-file-name_002c-directory-part"></a>
<p>提取每个文件名的目录部分<var>names</var> 。文件名的目录部分是直到（包括）最后一个斜杠为止的所有内容。如果文件名不包含斜杠，则目录部分为字符串' <samp>./</samp> '。例如，</p>
<div class="example">
<pre class="example">$(dir src/foo.c hacks)
</pre></div>

<p>产生结果<samp>src/ ./</samp> '。
</p>
</dd>
<dt><code>$(notdir <var>names</var>…)</code></dt>
<dd><a name="index-notdir"></a>
<a name="index-file-name_002c-nondirectory-part"></a>
<a name="index-nondirectory-part"></a>
<p>提取每个文件名中除目录部分以外的所有内容<var>names</var> 。如果文件名不包含斜杠，则保持不变。否则，将删除最后一个斜杠中的所有内容。
</p>
<p>以斜杠结尾的文件名将成为一个空字符串。这很不幸，因为这意味着结果并不总是具有与参数相同数量的空格分隔的文件名。但我们看不到任何其他有效的选择。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">$(notdir src/foo.c hacks)
</pre></div>

<p>产生结果<samp>foo.c hacks</samp> '。
</p>
</dd>
<dt><code>$(suffix <var>names</var>…)</code></dt>
<dd><a name="index-suffix"></a>
<a name="index-suffix_002c-function-to-find"></a>
<a name="index-file-name-suffix"></a>
<p>提取每个文件名的后缀<var>names</var> 。如果文件名包含句点，则后缀是从最后一个句点开始的所有内容。否则，后缀为空字符串。这通常意味着结果将在以下情况下为空： <var>names</var>不是，如果<var>names</var>包含多个文件名，结果可能包含较少的文件名。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">$(suffix src/foo.c src-1.0/bar.c hacks)
</pre></div>

<p>产生结果<samp>.c .c</samp> '。
</p>
</dd>
<dt><code>$(basename <var>names</var>…)</code></dt>
<dd><a name="index-basename-1"></a>
<a name="index-basename"></a>
<a name="index-file-name_002c-basename-of"></a>
<p>提取每个文件名的后缀以外的所有字符<var>names</var> 。如果文件名包含句点，则基本名是从最后一个句点开始（且不包括最后一个句点）的所有内容。目录部分中的句点将被忽略。如果没有句点，则基本名称是整个文件名。例如，</p>
<div class="example">
<pre class="example">$(basename src/foo.c src-1.0/bar hacks)
</pre></div>

<p>产生结果<samp>src/foo src-1.0/bar hacks</samp> '。
</p>
</dd>
<dt><code>$(addsuffix <var>suffix</var>,<var>names</var>…)</code></dt>
<dd><a name="index-addsuffix"></a>
<a name="index-suffix_002c-adding"></a>
<a name="index-file-name-suffix_002c-adding"></a>
<p>争论<var>names</var>被视为由空格分隔的一系列名称； <var>suffix</var>用作单位。的价值<var>suffix</var>会附加在每个单独名称的末尾，并且将较大的名称串联在一起，并在它们之间使用单个空格。例如，</p>
<div class="example">
<pre class="example">$(addsuffix .c,foo bar)
</pre></div>

<p>产生结果<samp>foo.c bar.c</samp> '。
</p>
</dd>
<dt><code>$(addprefix <var>prefix</var>,<var>names</var>…)</code></dt>
<dd><a name="index-addprefix"></a>
<a name="index-prefix_002c-adding"></a>
<a name="index-file-name-prefix_002c-adding"></a>
<p>争论<var>names</var>被视为由空格分隔的一系列名称； <var>prefix</var>用作单位。的价值<var>prefix</var>在每个单独名称的前面加上，然后将较大的名称串联在一起，并在它们之间使用单个空格。例如，</p>
<div class="example">
<pre class="example">$(addprefix src/,foo bar)
</pre></div>

<p>产生结果<samp>src/foo src/bar</samp> '。
</p>
</dd>
<dt><code>$(join <var>list1</var>,<var>list2</var>)</code></dt>
<dd><a name="index-join"></a>
<a name="index-joining-lists-of-words"></a>
<a name="index-words_002c-joining-lists"></a>
<p>将两个自变量逐字连接：两个第一个单词（每个自变量中的一个）串联在一起，形成结果的第一个单词，两个第二个单词构成结果的第二个单词，依此类推。所以<var>n</var>结果的词来自<var>n</var>每个论点的单词。如果一个参数包含比另一个参数更多的单词，则多余的单词将原样复制到结果中。
</p>
<p>例如， ' <samp>$(join a b,.c .o)</samp> '产生' <samp>a.c b.o</samp> '。
</p>
<p>列表中单词之间的空白不保留；它被替换为单个空格。
</p>
<p>此功能可以合并<code>dir</code>和<code>notdir</code>函数，以生成提供给这两个函数的原始文件列表。
</p>
</dd>
<dt><code>$(wildcard <var>pattern</var>)</code></dt>
<dd><a name="index-wildcard-2"></a>
<a name="index-wildcard_002c-function"></a>
<p>争论<var>pattern</var>是文件名模式，通常包含通配符（如外壳文件名模式一样）。的结果<code>wildcard</code>是用空格分隔的与模式匹配的现有文件名称的列表。请参见<a href="#Wildcards">在文件名中使用通配符</a> 。
</p>
</dd>
<dt><code>$(realpath <var>names</var>…)</code></dt>
<dd><a name="index-realpath-1"></a>
<a name="index-realpath"></a>
<a name="index-file-name_002c-realpath-of"></a>
<p>对于中的每个文件名<var>names</var>返回规范的绝对名称。规范名称不包含任何<code>.</code>要么<code>..</code>组件，也没有任何重复的路径分隔符（ <code>/</code> ）或符号链接。如果失败，则返回空字符串。咨询<code>realpath(3)</code>有关可能的故障原因列表的文档。
</p>
</dd>
<dt><code>$(abspath <var>names</var>…)</code></dt>
<dd><a name="index-abspath-1"></a>
<a name="index-abspath"></a>
<a name="index-file-name_002c-abspath-of"></a>
<p>对于中的每个文件名<var>names</var>返回不包含任何绝对名称的绝对名称<code>.</code>要么<code>..</code>组件，也没有任何重复的路径分隔符（ <code>/</code> ）。请注意，与<code>realpath</code>功能， <code>abspath</code>不会解析符号链接，并且不需要文件名来引用现有文件或目录。使用<code>wildcard</code>测试存在性的功能。
</p></dd>
</dl>

<hr>
<a name="Conditional-Functions"></a>
<div class="header">
<p>下一个： <a href="#Foreach-Function" rel="next" accesskey="n">Foreach函数</a> ，上一个： <a href="#File-Name-Functions" rel="prev" accesskey="p">文件名函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Functions-for-Conditionals"></a>
<h3 class="section">8.4条件函数</h3>
<a name="index-if"></a>
<a name="index-conditional-expansion"></a>
<p>提供条件扩展的三个函数。这些功能的一个关键方面是，并非所有参数最初都会扩展。仅那些需要扩展的参数将被扩展。
</p>
<dl compact>
<dt><code>$(if <var>condition</var>,<var>then-part</var>[,<var>else-part</var>])</code></dt>
<dd><a name="index-if-1"></a>
<p>的<code>if</code>函数提供对功能上下文中条件扩展的支持（与GNU相反<code>make</code> makefile条件，例如<code>ifeq</code> （请参阅<a href="#Conditional-Syntax">条件语法</a> ）。
</p>
<p>第一个论点， <var>condition</var> ，首先删除所有前面和结尾的空白，然后扩展。如果将其扩展为任何非空字符串，则认为该条件为true。如果将其扩展为空字符串，则认为该条件为假。
</p>
<p>如果条件为true，则第二个参数为<var>then-part</var>进行评估，并将其用作整个评估的结果<code>if</code>功能。
</p>
<p>如果条件为假，则第三个参数， <var>else-part</var>被评估，这是<code>if</code>功能。如果没有第三个参数，则<code>if</code>函数的结果为空（空字符串）。
</p>
<p>请注意，只有<var>then-part</var>或者<var>else-part</var>将被评估，永远不会两者都被评估。因此，任何一个都可能包含副作用（例如<code>shell</code>函数调用等）
</p>
</dd>
<dt><code>$(or <var>condition1</var>[,<var>condition2</var>[,<var>condition3</var>…]])</code></dt>
<dd><a name="index-or"></a>
<p>的<code>or</code>功能提供“短路”或操作。每个参数按顺序扩展。如果参数扩展为非空字符串，则处理停止，扩展结果为该字符串。如果在扩展所有参数之后，所有参数都为false（空），则扩展的结果为空字符串。
</p>
</dd>
<dt><code>$(and <var>condition1</var>[,<var>condition2</var>[,<var>condition3</var>…]])</code></dt>
<dd><a name="index-and"></a>
<p>的<code>and</code>该功能提供“短路” AND操作。每个参数按顺序扩展。如果参数扩展为空字符串，则处理停止，扩展结果为空字符串。如果所有参数都扩展为非空字符串，则扩展的结果为最后一个参数的扩展。
</p>
</dd>
</dl>

<hr>
<a name="Foreach-Function"></a>
<div class="header">
<p>下一个： <a href="#File-Function" rel="next" accesskey="n">文件功能</a> ，上一个： <a href="#Conditional-Functions" rel="prev" accesskey="p">条件函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-foreach-Function"></a>
<h3 class="section">8.5的<code>foreach</code>功能</h3>
<a name="index-foreach"></a>
<a name="index-words_002c-iterating-over"></a>

<p>的<code>foreach</code>功能与其他功能有很大的不同。它会导致重复使用一段文本，每次都对其执行不同的替换。它类似于<code>for</code>外壳中的命令<code>sh</code>和<code>foreach</code> C-shell中的命令<code>csh</code> 。
</p>
<p>的语法<code>foreach</code>功能是：</p>
<div class="example">
<pre class="example">$(foreach <var>var</var>,<var>list</var>,<var>text</var>)
</pre></div>

<p>前两个参数， <var>var</var>和<var>list</var> ，先展开，再进行其他操作；注意最后一个参数， <var>text</var> ， <strong>不会同时</strong>展开。然后对于每个词的扩展值<var>list</var> ，以的扩展值命名的变量<var>var</var>设置为该单词，并且<var>text</var>被扩展。想必<var>text</var>包含对该变量的引用，因此每次的扩展都会不同。
</p>
<p>结果是<var>text</var>的扩展次数是，其中有空格分隔的单词<var>list</var> 。的多重扩展<var>text</var>连接在一起，它们之间有空格，以使<code>foreach</code> 。
</p>
<p>这个简单的示例将变量“ <samp>files</samp> '到列表中目录中所有文件的列表' <samp>dirs</samp> '：</p>
<div class="example">
<pre class="example">dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
</pre></div>

<p>这里<var>text</var>是' <samp>$(wildcard $(dir)/*)</samp> '。第一次重复发现值' <samp>a</samp>为<code>dir</code> ，因此产生的结果与“ <samp>$(wildcard a/*)</samp> ';第二次重复产生“ <samp>$(wildcard b/*)</samp> ';第三，是“ <samp>$(wildcard c/*)</samp> '。
</p>
<p>此示例具有相同的结果（除了设置“ <samp>dirs</samp> '），例如以下示例：</p>
<div class="example">
<pre class="example">files := $(wildcard a/* b/* c/* d/*)
</pre></div>

<p>什么时候<var>text</var>这很复杂，您可以通过给它起一个名字以及一个附加变量来提高可读性：</p>
<div class="example">
<pre class="example">find_files = $(wildcard $(dir)/*)
dirs := a b c d
files := $(foreach dir,$(dirs),$(find_files))
</pre></div>

<p>在这里我们使用变量<code>find_files</code>这条路。我们使用普通的' <samp>=</samp> '定义一个递归扩展变量，以便其值包含一个实际的函数调用，该调用将在的控制下重新扩展<code>foreach</code> ;简单扩展的变量将不起作用，因为<code>wildcard</code>在定义时只会被调用一次<code>find_files</code> 。
</p>
<p>的<code>foreach</code>函数对变量没有永久性影响<var>var</var> ;其价值和风味后<code>foreach</code>函数调用与之前相同。其他取自<var>list</var>在执行期间仅暂时有效<code>foreach</code> 。变量<var>var</var>是执行以下操作时的简单扩展变量<code>foreach</code> 。如果<var>var</var>在之前未定义<code>foreach</code>函数调用，调用后未定义。请参见<a href="#Flavors">变量的两种风格</a> 。
</p>
<p>使用产生变量名的复杂变量表达式时必须小心，因为许多奇怪的事情都是有效的变量名，但可能不是您想要的。例如，</p>
<div class="smallexample">
<pre class="smallexample">files := $(foreach Esta-escrito-en-espanol!,b c ch,$(find_files))
</pre></div>

<p>如果...的值可能有用<code>find_files</code>引用名称为“ <samp>Esta-escrito-en-espanol!</samp> （（es un nombre bastante largo，不是吗？），但这很可能是一个错误。
</p>
<hr>
<a name="File-Function"></a>
<div class="header">
<p>下一个： <a href="#Call-Function" rel="next" accesskey="n">调用函数</a> ，上一个： <a href="#Foreach-Function" rel="prev" accesskey="p">Foreach函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-file-Function"></a>
<h3 class="section">8.6的<code>file</code>功能</h3>
<a name="index-file"></a>
<a name="index-writing-to-a-file"></a>
<a name="index-file_002c-writing-to"></a>
<a name="index-reading-from-a-file"></a>
<a name="index-file_002c-reading-from"></a>

<p>的<code>file</code>函数允许makefile写入文件或从文件读取。支持两种写入方式：覆盖（将文本写入文件的开头而所有现有内容都丢失）和附加（追加），其中将文本写入文件的末尾，以保留现有内容。在这两种情况下，如果文件都不存在，则会创建该文件。如果无法打开文件进行写入或写入操作失败，则是致命错误。的<code>file</code>写入文件时，函数扩展为空字符串。
</p>
<p>从文件读取时， <code>file</code>函数将扩展为文件的逐字内容，但最后的换行符（如果有的话）将被剥离。尝试从不存在的文件读取将扩展为空字符串。
</p>
<p>的语法<code>file</code>功能是：</p>
<div class="example">
<pre class="example">$(file <var>op</var> <var>filename</var>[,<var>text</var>])
</pre></div>

<p>当。。。的时候<code>file</code>首先评估函数的所有参数，然后扩展由表示的文件<var>filename</var>将以以下方式打开<var>op</var> 。
</p>
<p>运营商<var>op</var>可<code>></code>表示文件将被新内容覆盖， <code>>></code>指示文件的当前内容将被附加到，或<code><</code>表示将读取文件的内容。的<var>filename</var>指定要写入或读取的文件。运算符和文件名之间可以有空白。
</p>
<p>读取文件时，提供一个错误<var>text</var>值。
</p>
<p>写入文件时<var>text</var>将被写入文件。如果<var>text</var>尚未以换行符结尾，将写入最终换行符（即使<var>text</var>是空字符串）。如果<var>text</var>根本没有给出任何论点，将不会编写任何内容。
</p>
<p>例如， <code>file</code>如果构建系统的命令行大小有限并且配方运行的命令也可以接受文件中的参数，则此功能很有用。许多命令使用以下约定： <code>@</code>指定包含更多参数的文件。然后，您可以通过以下方式编写食谱：</p>
<div class="example">
<pre class="example">program: $(OBJECTS)
        $(file &gt;$@.in,$^)
        $(CMD) $(CMDFLAGS) @$@.in
        @rm $@.in
</pre></div>

<p>如果命令要求每个参数都在输入文件的单独行中，则可以这样编写配方：</p>
<div class="example">
<pre class="example">program: $(OBJECTS)
        $(file &gt;$@.in) $(foreach O,$^,$(file &gt;&gt;$@.in,$O))
        $(CMD) $(CMDFLAGS) @$@.in
        @rm $@.in
</pre></div>

<hr>
<a name="Call-Function"></a>
<div class="header">
<p>下一个： <a href="#Value-Function" rel="next" accesskey="n">值函数</a> ，上一个： <a href="#File-Function" rel="prev" accesskey="p">文件函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-call-Function"></a>
<h3 class="section">8.7的<code>call</code>功能</h3>
<a name="index-call"></a>
<a name="index-functions_002c-user-defined"></a>
<a name="index-user-defined-functions"></a>

<p>的<code>call</code>函数是唯一的，因为它可用于创建新的参数化函数。您可以将复杂的表达式编写为变量的值，然后使用<code>call</code>用不同的值扩展它。
</p>
<p>的语法<code>call</code>功能是：</p>
<div class="example">
<pre class="example">$(call <var>variable</var>,<var>param</var>,<var>param</var>,&hellip;)
</pre></div>

<p>什么时候<code>make</code>扩展此功能，它分配每个<var>param</var>临时变量<code>$(1)</code> ， <code>$(2)</code>等变量<code>$(0)</code>将包含<var>variable</var> 。没有最大数量的参数参数。也没有最低要求，但是使用没有意义<code>call</code>没有参数。
</p>
<p>然后<var>variable</var>扩展为<code>make</code>这些临时分配中的变量。因此，任何提及<code>$(1)</code>的价值<var>variable</var>将解决第一个<var>param</var>在调用<code>call</code> 。
</p>
<p>注意<var>variable</var>是变量的<em>名称</em> ，而不是对该变量的<em>引用</em> 。因此，您通常不会使用“ <samp>$</samp> '或在编写时加上括号。（但是，如果您希望名称不是常量，则可以在名称中使用变量引用。）
</p>
<p>如果<var>variable</var>是内置函数的名称，始终会调用内置函数（即使<code>make</code>该名称的变量也存在）。
</p>
<p>的<code>call</code>功能扩展<var>param</var>参数分配给临时变量之前。这意味着<var>variable</var>包含对具有特殊扩展规则的内置函数的引用的值，例如<code>foreach</code>要么<code>if</code> ，可能无法按预期工作。
</p>
<p>一些示例可能使这一点更加清楚。
</p>
<p>这个宏简单地颠倒了它的参数：</p>
<div class="smallexample">
<pre class="smallexample">reverse = $(2) $(1)

foo = $(call reverse,a,b)
</pre></div>

<p>这里<var>foo</var>将包含“ <samp>b a</samp> '。
</p>
<p>这个稍微有趣一点：它定义了一个宏来搜索程序中的第一个实例<code>PATH</code> ：</p>
<div class="smallexample">
<pre class="smallexample">pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

LS := $(call pathsearch,ls)
</pre></div>

<p>现在变量LS包含<code>/bin/ls</code>或类似。
</p>
<p>的<code>call</code>函数可以嵌套。每个递归调用都有其自己的局部值<code>$(1)</code>等掩盖了更高级别的值<code>call</code> 。例如，这是<em>map</em>函数的实现：</p>
<div class="smallexample">
<pre class="smallexample">map = $(foreach a,$(2),$(call $(1),$(a)))
</pre></div>

<p>现在你可以<var>map</var>通常只接受一个参数的函数，例如<code>origin</code> ，只需一步即可将其转换为多个值：</p>
<div class="smallexample">
<pre class="smallexample">o = $(call map,origin,o map MAKE)
</pre></div>

<p>并以<var>o</var>包含类似“ <samp>file file default</samp> '。
</p>
<p>最后的警告：在将空白添加到参数时要小心<code>call</code> 。与其他函数一样，第二个及后续参数中包含的所有空格都将保留；这可能会导致奇怪的后果。提供参数时，通常最安全的方法是删除所有多余的空格<code>call</code> 。
</p>
<hr>
<a name="Value-Function"></a>
<div class="header">
<p>下一个： <a href="#Eval-Function" rel="next" accesskey="n">评估函数</a> ，上一个： <a href="#Call-Function" rel="prev" accesskey="p">调用函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-value-Function"></a>
<h3 class="section">8.8的<code>value</code>功能</h3>
<a name="index-value-1"></a>
<a name="index-variables_002c-unexpanded-value"></a>

<p>的<code>value</code>函数为您提供了一种在<em>不</em>扩展变量的<em>情况下</em>使用其值的方法。请注意，这不会撤消已经发生的扩展；例如，如果您创建一个简单的扩展变量，则其值将在定义期间扩展；在那种情况下<code>value</code>函数将返回与直接使用变量相同的结果。
</p>
<p>的语法<code>value</code>功能是：</p>
<div class="example">
<pre class="example">$(value <var>variable</var>)
</pre></div>

<p>注意<var>variable</var>是变量的<em>名称</em> ，而不是对该变量的<em>引用</em> 。因此，您通常不会使用“ <samp>$</samp> '或在编写时加上括号。（但是，如果您希望名称不是常量，则可以在名称中使用变量引用。）
</p>
<p>该函数的结果是一个字符串，其中包含<var>variable</var> ，而不会发生任何扩展。例如，在此makefile中：</p>
<div class="example">
<pre class="example">FOO = $PATH

all:
        @echo $(FOO)
        @echo $(value FOO)
</pre></div>

<p>第一条输出线是<code>ATH</code> ，因为“ $ P”将扩展为<code>make</code>变量，而第二行输出将是您的当前值<code>$PATH</code>环境变量，因为<code>value</code>功能避免了扩展。
</p>
<p>的<code>value</code>函数最常与<code>eval</code>函数（请参阅<a href="#Eval-Function">评估函数</a> ）。
</p>
<hr>
<a name="Eval-Function"></a>
<div class="header">
<p>下一个： <a href="#Origin-Function" rel="next" accesskey="n">原始函数</a> ，上一个： <a href="#Value-Function" rel="prev" accesskey="p">值函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-eval-Function"></a>
<h3 class="section">8.9的<code>eval</code>功能</h3>
<a name="index-eval"></a>
<a name="index-evaluating-makefile-syntax"></a>
<a name="index-makefile-syntax_002c-evaluating"></a>

<p>的<code>eval</code>函数非常特殊：它允许您定义非恒定的新makefile结构；这是评估其他变量和函数的结果。的论点<code>eval</code>函数被扩展，然后将该扩展的结果解析为makefile语法。扩展结果可以定义新的<code>make</code>变量，目标，隐式或显式规则等。</p>
<p>结果<code>eval</code>函数始终是空字符串；因此，它几乎可以放在makefile中的任何位置，而不会引起语法错误。
</p>
<p>重要的是要意识到<code>eval</code>争论被扩大了<em>两次</em> ;首先由<code>eval</code>函数，然后将扩展结果解析为makefile语法时再次扩展。这意味着您在使用时可能需要为“ $”字符提供额外的转义级别<code>eval</code> 。的<code>value</code>函数（请参阅<a href="#Value-Function">值函数</a> ）有时在这些情况下很有用，可以避免不必要的扩展。
</p>
<p>这是一个例子<code>eval</code>可以使用该示例结合了许多概念和其他功能。尽管使用起来似乎过于复杂<code>eval</code>在此示例中，不只是写出规则，而是考虑两件事：首先，模板定义（在<code>PROGRAM_template</code> ）可能需要比这里复杂得多；其次，您可以将本示例中复杂的“通用”部分放入另一个makefile中，然后将其包含在所有单独的makefile中。现在，您的单个makefile非常简单。
</p>
<div class="example">
<pre class="example">PROGRAMS    = server client

server_OBJS = server.o server_priv.o server_access.o
server_LIBS = priv protocol

client_OBJS = client.o client_api.o client_mem.o
client_LIBS = protocol

# Everything after this is generic

.PHONY: all
all: $(PROGRAMS)

define PROGRAM_template =
 $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
 ALL_OBJS   += $$($(1)_OBJS)
endef

$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))

$(PROGRAMS):
        $(LINK.o) $^ $(LDLIBS) -o $@

clean:
        rm -f $(ALL_OBJS) $(PROGRAMS)
</pre></div>

<hr>
<a name="Origin-Function"></a>
<div class="header">
<p>下一个： <a href="#Flavor-Function" rel="next" accesskey="n">风味函数</a> ，上一个： <a href="#Eval-Function" rel="prev" accesskey="p">评估函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-origin-Function"></a>
<h3 class="section">8.10 <code>origin</code>功能</h3>
<a name="index-origin"></a>
<a name="index-variables_002c-origin-of"></a>
<a name="index-origin-of-variable"></a>

<p>的<code>origin</code>函数不同于其他大多数函数，因为它不对变量的值进行操作；它告诉您<em>有关</em>变量的一些<em>信息</em> 。具体来说，它告诉您它的来源。
</p>
<p>的语法<code>origin</code>功能是：</p>
<div class="example">
<pre class="example">$(origin <var>variable</var>)
</pre></div>

<p>注意<var>variable</var>是要查询的变量的<em>名称</em> ，而不是对该变量的<em>引用</em> 。因此，您通常不会使用“ <samp>$</samp> '或在编写时加上括号。（但是，如果您希望名称不是常量，则可以在名称中使用变量引用。）
</p>
<p>该函数的结果是一个字符串，告诉您变量如何<var>variable</var>被定义为：</p>
<dl compact>
<dt>' <samp>undefined</samp> '</dt>
<dd>
<p>如果<var>variable</var>从来没有定义。
</p>
</dd>
<dt>' <samp>default</samp> '</dt>
<dd>
<p>如果<var>variable</var>具有默认定义，就像通常<code>CC</code>等等。请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> 。请注意，如果您重新定义了默认变量， <code>origin</code>函数将返回后面定义的来源。
</p>
</dd>
<dt>' <samp>environment</samp> '</dt>
<dd>
<p>如果<var>variable</var>继承自提供给<code>make</code> 。
</p>
</dd>
<dt>' <samp>environment override</samp> '</dt>
<dd>
<p>如果<var>variable</var>继承自提供给<code>make</code> ，并覆盖的设置<var>variable</var>由于' <samp><span class="nolinebreak">-e</span></samp> ' <!-- /@w -->选项（请参阅<a href="#Options-Summary">选项摘要</a> ）。
</p>
</dd>
<dt>' <samp>file</samp> '</dt>
<dd>
<p>如果<var>variable</var>在makefile中定义。
</p>
</dd>
<dt>' <samp>command line</samp> '</dt>
<dd>
<p>如果<var>variable</var>是在命令行上定义的。
</p>
</dd>
<dt>' <samp>override</samp> '</dt>
<dd>
<p>如果<var>variable</var>用一个定义<code>override</code>指令在makefile（见<a href="#Override-Directive">的<code>override</code>指令</a> ）。
</p>
</dd>
<dt>' <samp>automatic</samp> '</dt>
<dd>
<p>如果<var>variable</var>是为每个规则的配方执行定义的自动变量（请参见<a href="#Automatic-Variables">自动变量</a> ）。
</p></dd>
</dl>

<p>该信息主要用于确定您是否想相信变量的值（不是出于好奇）。例如，假设您有一个makefile <samp>foo</samp>包括另一个makefile <samp>bar</samp> 。你想要一个变量<code>bletch</code>定义在<samp>bar</samp>如果您运行命令“ <samp>make <span class="nolinebreak">-f</span> bar</samp> ' <!-- /@w --> ，即使环境包含以下内容的定义： <code>bletch</code> 。但是，如果<samp>foo</samp>定义的<code>bletch</code>包括之前<samp>bar</samp> ，您不想覆盖该定义。这可以通过使用<code>override</code>指令中<samp>foo</samp> ，赋予该定义优先于后面的定义<samp>bar</samp> ;不幸的是， <code>override</code>指令还将覆盖任何命令行定义。所以， <samp>bar</samp>可能包括：</p>
<div class="example">
<pre class="example">ifdef bletch
ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;
bletch = barf, gag, etc.
endif
endif
</pre></div>

<p>如果<code>bletch</code>已从环境中定义，这将重新定义它。
</p>
<p>如果要覆盖以前的定义<code>bletch</code>如果来自环境，即使在“ <samp>-e</samp> '，您可以改写：</p>
<div class="example">
<pre class="example">ifneq &quot;$(findstring environment,$(origin bletch))&quot; &quot;&quot;
bletch = barf, gag, etc.
endif
</pre></div>

<p>如果“ <samp>$(origin bletch)</samp> '返回' <samp>environment</samp> ' 要么 ' <samp>environment override</samp> '。请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
<hr>
<a name="Flavor-Function"></a>
<div class="header">
<p>下一个： <a href="#Make-Control-Functions" rel="next" accesskey="n">制作控制功能</a> ，上一个： <a href="#Origin-Function" rel="prev" accesskey="p">原始功能</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">功能</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-flavor-Function"></a>
<h3 class="section">8.11 <code>flavor</code>功能</h3>
<a name="index-flavor"></a>
<a name="index-variables_002c-flavor-of"></a>
<a name="index-flavor-of-variable"></a>

<p>的<code>flavor</code>功能，就像<code>origin</code>函数，不对变量的值进行运算，而是告诉您<em>有关</em>变量的信息。具体来说，它告诉您变量的风格（请参阅变量<a href="#Flavors">的两种</a>风格）。
</p>
<p>的语法<code>flavor</code>功能是：</p>
<div class="example">
<pre class="example">$(flavor <var>variable</var>)
</pre></div>

<p>注意<var>variable</var>是要查询的变量的<em>名称</em> ，而不是对该变量的<em>引用</em> 。因此，您通常不会使用“ <samp>$</samp> '或在编写时加上括号。（但是，如果您希望名称不是常量，则可以在名称中使用变量引用。）
</p>
<p>该函数的结果是一个字符串，用于标识变量的样式<var>variable</var> ：</p>
<dl compact>
<dt>' <samp>undefined</samp> '</dt>
<dd>
<p>如果<var>variable</var>从来没有定义。
</p>
</dd>
<dt>' <samp>recursive</samp> '</dt>
<dd>
<p>如果<var>variable</var>是递归扩展的变量。
</p>
</dd>
<dt>' <samp>simple</samp> '</dt>
<dd>
<p>如果<var>variable</var>是一个简单的扩展变量。
</p>
</dd>
</dl>

<hr>
<a name="Make-Control-Functions"></a>
<div class="header">
<p>下一个： <a href="#Shell-Function" rel="next" accesskey="n">Shell函数</a> ，上一个： <a href="#Flavor-Function" rel="prev" accesskey="p">风味函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Functions-That-Control-Make"></a>
<h3 class="section">8.12控制的功能</h3>
<a name="index-functions_002c-for-controlling-make"></a>
<a name="index-controlling-make"></a>

<p>这些功能控制着运行方式。通常，它们用于向makefile的用户提供信息，或者在检测到某种环境错误时使make停止。
</p>
<dl compact>
<dt><code>$(error <var>text</var>…)</code></dt>
<dd><a name="index-error"></a>
<a name="index-error_002c-stopping-on"></a>
<a name="index-stopping-make"></a>
<p>生成致命错误，消息是<var>text</var> 。请注意，每当评估此功能时都会产生错误。因此，如果将其放在配方中或递归变量赋值的右侧，则要等到以后再进行评估。的<var>text</var>将在产生错误之前进行扩展。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">ifdef ERROR1
$(error error is $(ERROR1))
endif
</pre></div>

<p>如果读取makefile，将在生成makefile时产生致命错误。 <code>make</code>变量<code>ERROR1</code>被定义为。要么，</p>
<div class="example">
<pre class="example">ERR = $(error found an error!)

.PHONY: err
err: ; $(ERR)
</pre></div>

<p>会产生致命错误，而<code>make</code>正在运行，如果<code>err</code>目标被调用。
</p>
</dd>
<dt><code>$(warning <var>text</var>…)</code></dt>
<dd><a name="index-warning"></a>
<a name="index-warnings_002c-printing"></a>
<a name="index-printing-user-warnings"></a>
<p>此功能与<code>error</code>上面的功能，除了<code>make</code>不会退出。代替， <var>text</var>展开并显示结果消息，但继续处理makefile。
</p>
<p>该函数扩展的结果是空字符串。
</p>
</dd>
<dt><code>$(info <var>text</var>…)</code></dt>
<dd><a name="index-info"></a>
<a name="index-printing-messages"></a>
<p>此函数只不过将其（扩展的）参数打印到标准输出即可。没有添加makefile名称或行号。该函数扩展的结果是空字符串。
</p></dd>
</dl>

<hr>
<a name="Shell-Function"></a>
<div class="header">
<p>下一个： <a href="#Guile-Function" rel="next" accesskey="n">Guile函数</a> ，上一个： <a href="#Make-Control-Functions" rel="prev" accesskey="p">使控制函数</a> ，上一个： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-shell-Function"></a>
<h3 class="section">8.13 <code>shell</code>功能</h3>
<a name="index-shell"></a>
<a name="index-command-expansion"></a>
<a name="index-backquotes"></a>
<a name="index-shell-command_002c-function-for"></a>

<p>的<code>shell</code>功能不同于除<code>wildcard</code>功能（请参见<a href="#Wildcard-Function">功能<code>wildcard</code></a> ），因为它与世界以外的世界交流<code>make</code> 。
</p>
<p>的<code>shell</code>函数执行与反引号（' <samp>`</samp> '）在大多数shell中执行：它执行<em>命令扩展</em> 。这意味着它将shell命令作为参数并求值到命令的输出。唯一的处理<code>make</code>结果是将每个换行符（或回车符/换行符对）转换为一个空格。如果有尾随（回车和）换行符，它将被删除。
</p>
<p>这些命令通过调用<code>shell</code>在扩展函数调用时运行该函数（请参见<a href="#Reading-Makefiles">如何<code>make</code>读取Makefile</a> ）。由于此功能涉及生成新的外壳程序，因此您应仔细考虑使用<code>shell</code>递归扩展变量与简单扩展变量之间的函数（请参见变量<a href="#Flavors">的两种风格</a> ）。
</p>
<a name="index-_002eSHELLSTATUS"></a>
<p>之后<code>shell</code>功能或' <samp>!=</samp>使用赋值运算符，其退出状态位于<code>.SHELLSTATUS</code>变量。
</p>
<p>以下是一些使用<code>shell</code>功能：</p>
<div class="example">
<pre class="example">contents := $(shell cat foo)
</pre></div>

<p>套<code>contents</code>到文件的内容<samp>foo</samp> ，每行之间用空格（而不是换行符）隔开。
</p>
<div class="example">
<pre class="example">files := $(shell echo *.c)
</pre></div>

<p>套<code>files</code>扩展到“ <samp>*.c</samp> '。除非<code>make</code>使用的外壳非常奇怪，其结果与“ <samp>$(wildcard *.c)</samp> ' <!-- /@w --> （只要至少一个' <samp>.c</samp> ' 文件已存在）。
</p>
<hr>
<a name="Guile-Function"></a>
<div class="header">
<p>上一篇： <a href="#Shell-Function" rel="prev" accesskey="p">Shell函数</a> ，上一篇： <a href="#Functions" rel="up" accesskey="u">函数</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-guile-Function"></a>
<h3 class="section">8.14 <code>guile</code>功能</h3>
<a name="index-guile"></a>
<a name="index-Guile"></a>

<p>如果是GNU <code>make</code>内置了对GNU Guile的支持，并将其作为嵌入式扩展语言，然后<code>guile</code>功能将可用。的<code>guile</code>函数采用一个参数，该参数首先由<code>make</code>然后以常规方式传递给GNU Guile评估员。求值器的结果转换为字符串，并用作扩展<code>guile</code>在makefile中的功能。有关编写扩展的详细信息，请参见<a href="#Guile-Integration">GNU Guile集成</a> 。 <code>make</code>在桂尔。
</p>
<p>您可以通过检查以下内容来确定GNU Guile支持是否可用： <code>.FEATURES</code>这个词的变量<var>guile</var> 。
</p>
<hr>
<a name="Running"></a>
<div class="header">
<p>下一页： <a href="#Implicit-Rules" rel="next" accesskey="n">隐式规则</a> ，上一页： <a href="#Functions" rel="prev" accesskey="p">函数</a> ，上一页： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-to-Run-make"></a>
<h2 class="chapter">9如何跑步<code>make</code></h2>

<p>可以用多种方式使用说明如何重新编译程序的makefile。最简单的用法是重新编译每个过期的文件。通常，会写入makefile，以便在运行时<code>make</code>没有参数，它就是这样做的。
</p>
<p>但是您可能只想更新一些文件；您可能要使用其他编译器或不同的编译器选项；您可能只想找出哪些文件已过时而不更改它们。
</p>
<p>通过在运行时提供参数<code>make</code> ，您可以做任何其他事情，也可以做很多其他事情。
</p>
<a name="index-exit-status-of-make"></a>
<p>的退出状态<code>make</code>始终是以下三个值之一：</p><dl compact>
<dt><code>0</code></dt>
<dd><p>如果退出状态为零<code>make</code>是成功的。
</p></dd>
<dt><code>2</code></dt>
<dd><p>退出状态为两个，如果<code>make</code>遇到任何错误。它将打印描述特定错误的消息。
</p></dd>
<dt><code>1</code></dt>
<dd><p>如果您使用“ <samp>-q</samp> '标志和<code>make</code>确定某些目标尚未更新。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。
</p></dd>
</dl>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Makefile-Arguments" accesskey="1">Makefile参数</a> ：</td><td>  </td><td align="left" valign="top">如何指定要使用的makefile。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Goals" accesskey="2">目标</a> ：</td><td>  </td><td align="left" valign="top">如何使用目标参数指定要使用的Makefile的哪些部分。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Instead-of-Execution" accesskey="3">代替执行</a> ：</td><td>  </td><td align="left" valign="top">如何使用模式标志来指定对makefile中的配方执行何种操作，而不是简单地执行它们。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Avoiding-Compilation" accesskey="4">避免编译</a> ：</td><td>  </td><td align="left" valign="top">如何避免重新编译某些文件。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Overriding" accesskey="5">覆盖</a> ：</td><td>  </td><td align="left" valign="top">如何重写变量以指定备用编译器等。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Testing" accesskey="6">测试</a> ：</td><td>  </td><td align="left" valign="top">如何解决一些错误，以测试编译。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Options-Summary" accesskey="7">选项摘要</a> ：</td><td>  </td><td align="left" valign="top">选项摘要</td></tr>
</tbody></table>

<hr>
<a name="Makefile-Arguments"></a>
<div class="header">
<p>下一个： <a href="#Goals" rel="next" accesskey="n">目标</a> ，上一个： <a href="#Running" rel="prev" accesskey="p">运行</a> ，上一个： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Arguments-to-Specify-the-Makefile"></a>
<h3 class="section">9.1指定Makefile的参数</h3>
<a name="index-_002d_002dfile-1"></a>
<a name="index-_002d_002dmakefile-1"></a>
<a name="index-_002df-1"></a>

<p>指定makefile名称的方法是使用' <samp>-f</samp> ' 要么 ' <samp>--file</samp> ' 选项 （' <samp>--makefile</samp>也可以）。例如， ' <samp>-f altmake</samp> '说使用文件<samp>altmake</samp>作为makefile。
</p>
<p>如果您使用“ <samp>-f</samp> '标记几次，并跟随每个' <samp>-f</samp> '带有参数，所有指定的文件一起用作makefile。
</p>
<p>如果您不使用“ <samp>-f</samp> ' 要么 ' <samp>--file</samp> '标志，默认是尝试<samp>GNUmakefile</samp> ， <samp>makefile</samp>和<samp>Makefile</samp> ，然后按顺序使用这三个存在的或可以创建的第一个（请参见<a href="#Makefiles">编写Makefiles</a> ）。
</p>
<hr>
<a name="Goals"></a>
<div class="header">
<p>下一个： <a href="#Instead-of-Execution" rel="next" accesskey="n">代替执行</a> ，上一个： <a href="#Makefile-Arguments" rel="prev" accesskey="p">Makefile参数</a> ，上一个： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">Contents</a> ] [ <a href="#Concept-Index" title="指数" rel="index">Index</a> ]</p>
</div>
<a name="Arguments-to-Specify-the-Goals"></a>
<h3 class="section">9.2指定目标的参数</h3>
<a name="index-goal_002c-how-to-specify"></a>

<p><em>目标</em>是<code>make</code>应该努力最终进行更新。如果其他目标显示为目标的先决条件或目标的先决条件等，则它们也会更新。</p>
<p>默认情况下，目标是makefile中的第一个目标（不计算以句点开头的目标）。因此，通常编写makefile，以便第一个目标是编译它们描述的整个程序。如果makefile中的第一个规则有多个目标，则只有规则中的第一个目标成为默认目标，而不是整个列表。您可以使用以下命令从生成文件中管理对默认目标的选择： <code>.DEFAULT_GOAL</code>变量（请参阅<a href="#Special-Variables">其他特殊变量</a> ）。
</p>
<p>您还可以使用以下命令行参数指定其他目标<code>make</code> 。使用目标名称作为参数。如果您指定多个目标， <code>make</code>按照您命名的顺序依次处理它们。
</p>
<p>可以将makefile中的任何目标指定为目标（除非它以“ <samp>-</samp> '或包含' <samp>=</samp> '，在这种情况下，它将分别解析为开关或变量定义）。甚至可以指定makefile中没有的目标，如果<code>make</code>可以找到说明如何制作的隐式规则。
</p>
<a name="index-MAKECMDGOALS"></a>
<p><code>Make</code>将设置特殊变量<code>MAKECMDGOALS</code>到您在命令行上指定的目标列表。如果在命令行上没有给出目标，则此变量为空。请注意，仅在特殊情况下才应使用此变量。
</p>
<p>适当使用的一个示例是避免包含<samp>.d</samp>文件在<code>clean</code>规则（请参阅<a href="#Automatic-Prerequisites">自动先决条件</a> ），因此<code>make</code>不会只是立即将其再次删除而创建它们：</p>
<div class="example">
<pre class="example">sources = foo.c bar.c

ifneq ($(MAKECMDGOALS),clean)
include $(sources:.c=.d)
endif
</pre></div>

<p>指定目标的一种用法是只编译程序的一部分，还是只编译几个程序之一。将您希望重制的每个文件指定为目标。例如，考虑一个包含几个程序的目录，该目录的makefile如下所示：</p>
<div class="example">
<pre class="example">.PHONY: all
all: size nm ld ar as
</pre></div>

<p>如果您正在开发程序<code>size</code> ，您可能想说“ <samp>make size</samp> ' <!-- /@w -->以便仅重新编译该程序的文件。
</p>
<p>指定目标的另一种用法是制作通常不会制作的文件。例如，可能有一个调试输出文件，或者是专门为测试而编译的程序版本，该文件在makefile中有一个规则，但不是默认目标的先决条件。
</p>
<p>指定目标的另一种用法是运行与假目标（请参阅<a href="#Phony-Targets">Phony目标</a> ）或空目标（请参见“ <a href="#Empty-Targets">空目标文件以记录事件”</a> ）关联的配方。许多makefile包含一个名为“ phony”的目标<samp>clean</samp>它将删除除源文件以外的所有内容。当然，只有在您明确要求使用“ <samp>make clean</samp> ' <!-- /@w --> 。以下是典型的虚假和空目标名称的列表。有关GNU软件包使用的所有标准目标名称的详细列表，请参见<a href="#Standard-Targets">Standard Targets</a> 。
</p>
<dl compact>
<dt><samp>all</samp></dt>
<dd><a name="index-all-_0028standard-target_0029"></a>
<p>使makefile知道的所有顶级目标。
</p>
</dd>
<dt><samp>clean</samp></dt>
<dd><a name="index-clean-_0028standard-target_0029"></a>
<p>删除通常通过运行创建的所有文件<code>make</code> 。
</p>
</dd>
<dt><samp>mostlyclean</samp></dt>
<dd><a name="index-mostlyclean-_0028standard-target_0029"></a>
<p>喜欢 ' <samp>clean</samp> ”，但可能会删除一些人们通常不想重新编译的文件。例如，“ <samp>mostlyclean</samp> 'GCC的目标不会删除<samp>libgcc.a</samp> ，因为重新编译几乎没有必要，而且会花费很多时间。
</p>
</dd>
<dt><samp>distclean</samp></dt>
<dd><a name="index-distclean-_0028standard-target_0029"></a>
</dd>
<dt><samp>realclean</samp></dt>
<dd><a name="index-realclean-_0028standard-target_0029"></a>
</dd>
<dt><samp>clobber</samp></dt>
<dd><a name="index-clobber-_0028standard-target_0029"></a>
<p>所有这些目标可能会被定义为删除超过“ <em>更多的</em>文件<samp>clean</samp>确实。例如，即使makefile本身无法创建这些文件，这也会删除通常为编译准备而创建的配置文件或链接。
</p>
</dd>
<dt><samp>install</samp></dt>
<dd><a name="index-install-_0028standard-target_0029"></a>
<p>将可执行文件复制到用户通常搜索命令的目录中；将可执行文件使用的所有辅助文件复制到将在其中查找它们的目录中。
</p>
</dd>
<dt><samp>print</samp></dt>
<dd><a name="index-print-_0028standard-target_0029"></a>
<p>打印已更改的源文件的列表。
</p>
</dd>
<dt><samp>tar</samp></dt>
<dd><a name="index-tar-_0028standard-target_0029"></a>
<p>创建源文件的tar文件。
</p>
</dd>
<dt><samp>shar</samp></dt>
<dd><a name="index-shar-_0028standard-target_0029"></a>
<p>创建源文件的Shell归档文件（shar文件）。
</p>
</dd>
<dt><samp>dist</samp></dt>
<dd><a name="index-dist-_0028standard-target_0029"></a>
<p>创建源文件的分发文件。这可能是tar文件或shar文件，或者是上述文件之一的压缩版本，甚至是以上文件中的一个以上。
</p>
</dd>
<dt><samp>TAGS</samp></dt>
<dd><a name="index-TAGS-_0028standard-target_0029"></a>
<p>更新此程序的标签表。
</p>
</dd>
<dt><samp>check</samp></dt>
<dd><a name="index-check-_0028standard-target_0029"></a>
</dd>
<dt><samp>test</samp></dt>
<dd><a name="index-test-_0028standard-target_0029"></a>
<p>在此makefile构建的程序上执行自检。
</p></dd>
</dl>

<hr>
<a name="Instead-of-Execution"></a>
<div class="header">
<p>下一篇： <a href="#Avoiding-Compilation" rel="next" accesskey="n">避免编译</a> ，上一篇： <a href="#Goals" rel="prev" accesskey="p">目标</a> ，上一篇： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Instead-of-Executing-Recipes"></a>
<h3 class="section">9.3代替执行配方</h3>
<a name="index-execution_002c-instead-of"></a>
<a name="index-recipes_002c-instead-of-executing"></a>

<p>生成文件告诉<code>make</code>如何判断目标是否最新，以及如何更新每个目标。但是更新目标并不总是您想要的。某些选项指定了其他活动<code>make</code> 。
</p>
<dl compact>
<dt>' <samp>-n</samp> '</dt>
<dt>' <samp>--just-print</samp> '</dt>
<dt>' <samp>--dry-run</samp> '</dt>
<dt>' <samp>--recon</samp> '</dt>
<dd><a name="index-_002d_002djust_002dprint-1"></a>
<a name="index-_002d_002ddry_002drun-1"></a>
<a name="index-_002d_002drecon-1"></a>
<a name="index-_002dn-1"></a>

<p>“无操作”。原因<code>make</code>打印出使目标保持最新状态所需的配方，但实际上并未执行它们。需要注意的是一些食谱仍然执行，即使有这样的标志（请参阅<a href="#MAKE-Variable">如何<code>MAKE</code>可变作品</a> ）。同样，仍然需要执行更新所包含的Makefile所需的任何配方（请参见<a href="#Remaking-Makefiles">如何重新制作Makefile</a> ）。
</p>
</dd>
<dt>' <samp>-t</samp> '</dt>
<dt>' <samp>--touch</samp> '</dt>
<dd><a name="index-_002d_002dtouch"></a>
<a name="index-touching-files"></a>
<a name="index-target_002c-touching"></a>
<a name="index-_002dt"></a>

<p>“触摸”。将目标标记为最新，而不实际对其进行更改。换一种说法， <code>make</code>假装更新目标，但并未真正更改其内容；而是仅更新其修改时间。
</p>
</dd>
<dt>' <samp>-q</samp> '</dt>
<dt>' <samp>--question</samp> '</dt>
<dd><a name="index-_002d_002dquestion"></a>
<a name="index-_002dq"></a>
<a name="index-question-mode"></a>

<p>“题”。静默检查目标是否最新，但不执行配方；退出代码显示是否需要任何更新。
</p>
</dd>
<dt>' <samp>-W <var>file</var></samp> '</dt>
<dt>' <samp>--what-if=<var>file</var></samp> '</dt>
<dt>' <samp>--assume-new=<var>file</var></samp> '</dt>
<dt>' <samp>--new-file=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dwhat_002dif"></a>
<a name="index-_002dW"></a>
<a name="index-_002d_002dassume_002dnew"></a>
<a name="index-_002d_002dnew_002dfile"></a>
<a name="index-what-if"></a>
<a name="index-files_002c-assuming-new"></a>

<p>“如果”。每个' <samp>-W</samp> '标志后跟一个文件名。给定文件的修改时间记录为<code>make</code>尽管实际修改时间保持不变，但与当前时间相同。您可以使用“ <samp>-W</samp> '标志与' <samp>-n</samp> '标志以查看如果要修改特定文件会发生什么。
</p></dd>
</dl>

<p>与“ <samp>-n</samp> '标志， <code>make</code>打印通常可以执行但通常不执行的配方。
</p>
<p>与“ <samp>-t</samp> '标志， <code>make</code>忽略规则中的配方并使用（实际上）命令<code>touch</code>对于每个需要重做的目标。的<code>touch</code>命令也会被打印，除非' <samp>-s</samp> ' 要么<code>.SILENT</code>用来。为了速度<code>make</code>实际上没有调用程序<code>touch</code> 。它直接完成工作。
</p>
<p>与“ <samp>-q</samp> '标志， <code>make</code>不打印任何内容且不执行任何配方，但是当且仅当要考虑的目标已经是最新的时，它返回的退出状态代码为零。如果退出状态为1，则需要进行一些更新。如果<code>make</code>遇到错误，退出状态为2，因此您可以将错误与不是最新的目标区分开。
</p>
<p>在相同的调用中使用这三个标志中的多个标志是错误的<code>make</code> 。
</p>
<a name="index-_002b_002c-and-recipe-execution"></a>
<p>' <samp>-n</samp> '，' <samp>-t</samp> '和' <samp>-q</samp> '选项不会影响以'开头的配方行<samp>+</samp> '字符或包含字符串' <samp>$(MAKE)</samp> ' 要么 ' <samp>${MAKE}</samp> '。请注意，只有包含“ <samp>+</samp> “字符或字符串” <samp>$(MAKE)</samp> ' 要么 ' <samp>${MAKE}</samp>无论这些选项如何，都可以运行'。除非它们也以'开头，否则不会运行同一规则中的其他行<samp>+</samp> “或包含” <samp>$(MAKE)</samp> ' 要么 ' <samp>${MAKE}</samp> “（请参阅<a href="#MAKE-Variable">如何<code>MAKE</code>可变作品</a> 。）
</p>
<a name="index-phony-targets-and-recipe-execution"></a>
<p>' <samp>-t</samp> '标志可防止伪造目标（请参见<a href="#Phony-Targets">Phony目标</a> ）被更新，除非有以'开头的配方行<samp>+</samp> “或包含” <samp>$(MAKE)</samp> ' 要么 ' <samp>${MAKE}</samp> '。
</p>
<p>' <samp>-W</samp> '标志提供两个功能：</p>
<ul>
<li>如果您还使用“ <samp>-n</samp> ' 要么 ' <samp>-q</samp> '标志，您可以看到<code>make</code>如果您要修改某些文件，该操作会执行。

</li><li>没有“ <samp>-n</samp> ' 要么 ' <samp>-q</samp> '标志，何时<code>make</code>实际上是在执行配方， <samp>-W</samp> '标志可以直接<code>make</code>就像某些文件已被修改一样，而无需实际运行这些文件的配方。
</li></ul>

<p>请注意，选项“ <samp>-p</samp> '和' <samp>-v</samp> '让您获得有关<code>make</code>或有关正在使用的makefile（请参阅<a href="#Options-Summary">“选项摘要”</a> ）。
</p>
<hr>
<a name="Avoiding-Compilation"></a>
<div class="header">
<p>下一个： <a href="#Overriding" rel="next" accesskey="n">覆盖</a> ，上一个： <a href="#Instead-of-Execution" rel="prev" accesskey="p">代替执行</a> ，上一个： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">Contents</a> ] [ <a href="#Concept-Index" title="指数" rel="index">Index</a> ]</p>
</div>
<a name="Avoiding-Recompilation-of-Some-Files"></a>
<h3 class="section">9.4避免重新编译某些文件</h3>
<a name="index-_002do"></a>
<a name="index-_002d_002dold_002dfile"></a>
<a name="index-_002d_002dassume_002dold"></a>
<a name="index-files_002c-assuming-old"></a>
<a name="index-files_002c-avoiding-recompilation-of"></a>
<a name="index-recompilation_002c-avoiding"></a>

<p>有时您可能已经更改了源文件，但是您不想重新编译依赖该文件的所有文件。例如，假设您将宏或声明添加到许多其他文件所依赖的头文件中。保守一点<code>make</code>假定头文件中的任何更改都需要重新编译所有相关文件，但是您知道它们不需要重新编译，因此您不希望浪费时间等待它们进行编译。
</p>
<p>如果您在更改头文件之前就预料到了问题，可以使用“ <samp>-t</samp>的标志。这个标志告诉<code>make</code>不是在规则中运行配方，而是通过更改目标的上次修改日期来标记目标为最新。您将遵循以下过程：</p>
<ol>
<li>使用命令“ <samp>make</samp>以重新编译确实需要重新编译的源文件，确保在开始之前目标文件是最新的。

</li><li>在头文件中进行更改。

</li><li>使用命令“ <samp>make -t</samp> '将所有目标文件标记为最新。下次您运行<code>make</code> ，头文件中的更改将不会导致任何重新编译。
</li></ol>

<p>如果您在某些文件确实需要重新编译的时候已经更改了头文件，则现在为时已晚。相反，您可以使用“ <samp><span class="nolinebreak">-o</span> <var>file</var></samp> ' <!-- /@w -->标志，该标志将指定的文件标记为“旧”（请参阅<a href="#Options-Summary">“选项摘要”</a> ）。这意味着该文件本身将不会被重制，并且不会对其帐户进行任何其他重制。请遵循以下步骤：</p>
<ol>
<li>重新编译需要编译的源文件，其原因与特定的头文件无关，请使用' <samp>make -o <var>headerfile</var></samp> '。如果涉及多个头文件，请使用单独的“ <samp>-o</samp>每个头文件的'选项。

</li><li>用'触摸所有目标文件<samp>make -t</samp> '。
</li></ol>

<hr>
<a name="Overriding"></a>
<div class="header">
<p>下一篇： <a href="#Testing" rel="next" accesskey="n">测试</a> ，上一篇： <a href="#Avoiding-Compilation" rel="prev" accesskey="p">避免编译</a> ，上一篇： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Overriding-Variables"></a>
<h3 class="section">9.5覆盖变量</h3>
<a name="index-overriding-variables-with-arguments"></a>
<a name="index-variables_002c-overriding-with-arguments"></a>
<a name="index-command-line-variables"></a>
<a name="index-variables_002c-command-line"></a>

<p>包含“ <samp>=</samp> '指定变量的值：' <samp><var>v</var>=<var>x</var></samp> '设置变量的值<var>v</var>至<var>x</var> 。如果以这种方式指定值，则将忽略makefile中相同变量的所有普通分配；否则，将忽略所有普通赋值。我们说它们已被命令行参数<em>覆盖</em> 。
</p>
<p>使用此功能的最常见方法是将额外的标志传递给编译器。例如，在正确编写的makefile中，变量<code>CFLAGS</code>包含在运行C编译器的每个配方中，因此一个文件<samp>foo.c</samp>将被编译成这样：</p>
<div class="example">
<pre class="example">cc -c $(CFLAGS) foo.c
</pre></div>

<p>因此，无论您设置什么值<code>CFLAGS</code>影响发生的每个编译。makefile可能会指定通常的值<code>CFLAGS</code> ， 像这样：</p>
<div class="example">
<pre class="example">CFLAGS=-g
</pre></div>

<p>每次跑步<code>make</code> ，您可以根据需要覆盖此值。例如，如果您说“ <samp>make CFLAGS='-g -O'</samp> '，每个C编译将以' <samp>cc -c -g -O</samp> '。（这也说明了在覆盖变量时，如何在外壳中使用引号将空格和其他特殊字符括起来）。
</p>
<p>变量<code>CFLAGS</code>只是存在的许多标准变量之一，因此您可以通过这种方式进行更改。有关完整列表，请参见<a href="#Implicit-Variables">隐式规则使用的变量</a> 。
</p>
<p>您还可以对makefile进行编程以查看自己的其他变量，从而使用户能够通过更改变量来控制makefile的其他方面。
</p>
<p>当使用命令行参数覆盖变量时，可以定义递归扩展变量或简单扩展变量。上面显示的示例制作了一个递归扩展的变量；做一个简单扩展的变量，写' <samp>:=</samp> ' 要么 ' <samp>::=</samp> ' 代替 ' <samp>=</samp> '。但是，除非要在指定的<em>值</em>中包含变量引用或函数调用，否则创建哪种类型的变量都没有区别。
</p>
<p>生成文件可以通过一种方式更改您已覆盖的变量。这是为了使用<code>override</code>指令，如下所示： <samp>override <var>variable</var> = <var>value</var></samp> “（见<a href="#Override-Directive">本<code>override</code>指令</a> ）。
</p>
<hr>
<a name="Testing"></a>
<div class="header">
<p>下一页： <a href="#Options-Summary" rel="next" accesskey="n">选项摘要</a> ，上一篇： <a href="#Overriding" rel="prev" accesskey="p">覆盖</a> ，上一篇： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Testing-the-Compilation-of-a-Program"></a>
<h3 class="section">9.6测试程序的编译</h3>
<a name="index-testing-compilation"></a>
<a name="index-compilation_002c-testing"></a>

<p>通常，当执行Shell命令时发生错误时， <code>make</code>立即放弃，返回非零状态。没有为任何目标执行更多配方。该错误表示无法正确地重制目标，并且<code>make</code>知道后立即报告。
</p>
<p>当您编译刚更改的程序时，这不是您想要的。相反，您宁愿<code>make</code>尝试编译每个可以尝试的文件，以向您显示尽可能多的编译错误。
</p>
<a name="index-_002dk-1"></a>
<a name="index-_002d_002dkeep_002dgoing-1"></a>
<p>在这种情况下，您应该使用“ <samp>-k</samp> ' 要么 ' <samp>--keep-going</samp>的标志。这说明<code>make</code>继续考虑挂起目标的其他先决条件，如有必要，在放弃并返回非零状态之前对其进行重新制作。例如，在编译一个目标文件时出错后，“ <samp>make -k</samp> ”将继续编译其他目标文件，即使它已经知道不可能链接它们。除了在失败的shell命令之后继续执行之外，' <samp>make -k</samp>在发现它不知道如何制作目标文件或必备文件后，它将继续执行。这将始终导致错误消息，但没有' <samp>-k</samp> '，这是一个致命错误（请参阅<a href="#Options-Summary">“选项摘要”</a> ）。
</p>
<p>通常的行为<code>make</code>假设您的目的是使目标保持最新状态；一旦<code>make</code>了解到这是不可能的，因此不妨立即报告故障。' <samp>-k</samp> 'flag表示，真正的目的是尽可能多地测试程序中所做的更改，也许是找到几个独立的问题，以便您可以在下次尝试编译之前将其全部纠正。这就是为什么Emacs <kbd>M-x compile</kbd>命令传递' <samp>-k</samp> '标记为默认值。
</p>
<hr>
<a name="Options-Summary"></a>
<div class="header">
<p>上一篇： <a href="#Testing" rel="prev" accesskey="p">测试</a> ，上一篇： <a href="#Running" rel="up" accesskey="u">运行</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Summary-of-Options"></a>
<h3 class="section">9.7选项摘要</h3>
<a name="index-options"></a>
<a name="index-flags"></a>
<a name="index-switches"></a>

<p>这是所有选项的表格<code>make</code>了解：</p>
<dl compact>
<dt>' <samp>-b</samp> '</dt>
<dd><a name="index-_002db"></a>
</dd>
<dt>' <samp>-m</samp> '</dt>
<dd><a name="index-_002dm"></a>
<p>忽略这些选项是为了与其他版本的<code>make</code> 。
</p>
</dd>
<dt>' <samp>-B</samp> '</dt>
<dd><a name="index-_002dB"></a>
</dd>
<dt>' <samp>--always-make</samp> '</dt>
<dd><a name="index-_002d_002dalways_002dmake"></a>
<p>考虑所有过时的目标。GNU <code>make</code>继续使用正常算法来考虑目标及其先决条件；但是，无论考虑的先决条件如何，所有考虑的目标都会始终进行重新制作。为了避免无限递归，如果<code>MAKE_RESTARTS</code> （请参阅<a href="#Special-Variables">其他特殊变量</a> ）设置为大于0的数字时，在考虑是否重新制作makefile时，将禁用此选项（请参阅<a href="#Remaking-Makefiles">如何</a>重新制作<a href="#Remaking-Makefiles">Makefile</a> ）。
</p>
</dd>
<dt>' <samp>-C <var>dir</var></samp> '</dt>
<dd><a name="index-_002dC-1"></a>
</dd>
<dt>' <samp>--directory=<var>dir</var></samp> '</dt>
<dd><a name="index-_002d_002ddirectory-1"></a>
<p>转到目录<var>dir</var>在读取makefile之前。如果多个<samp>-C</samp> '指定了选项，每个选项都相对于前一个选项进行解释：' <samp>-C / -C etc</samp> '等价于' <samp>-C /etc</samp> '。通常与递归调用一起使用<code>make</code> （请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。
</p>
</dd>
<dt>' <samp>-d</samp> '</dt>
<dd><a name="index-_002dd"></a>

<p>除正常处理外，还打印调试信息。调试信息表明正在考虑重新制作哪些文件，正在比较哪些文件时间以及哪些结果，实际上需要重新制作哪些文件，考虑哪些隐式规则以及应用了哪些文件–关于如何进行的所有有趣操作<code>make</code>决定做什么。的<code>-d</code>选项等同于' <samp>--debug=a</samp> ' （见下文）。
</p>
</dd>
<dt>' <samp>--debug[=<var>options</var>]</samp> '</dt>
<dd><a name="index-_002d_002ddebug"></a>

<p>除正常处理外，还打印调试信息。可以选择各种级别和类型的输出。不带任何参数，输出调试的“基本”级别。可能的参数如下：仅考虑第一个字符，并且值必须用逗号或空格分隔。
</p>
<dl compact>
<dt><code>a (<i>all</i>)</code></dt>
<dd><p>启用所有类型的调试输出。这等效于使用' <samp>-d</samp> '。
</p>
</dd>
<dt><code>b (<i>basic</i>)</code></dt>
<dd><p>基本调试将打印发现已过期的每个目标以及构建是否成功。
</p>
</dd>
<dt><code>v (<i>verbose</i>)</code></dt>
<dd><p>高于' <samp>basic</samp> ';包括有关已解析哪些makefile，不需要重建的先决条件等消息。此选项还启用了“ <samp>basic</samp>的消息。
</p>
</dd>
<dt><code>i (<i>implicit</i>)</code></dt>
<dd><p>打印描述每个目标的隐式规则搜索的消息。此选项还启用了“ <samp>basic</samp>的消息。
</p>
</dd>
<dt><code>j (<i>jobs</i>)</code></dt>
<dd><p>打印消息，提供有关特定子命令调用的详细信息。
</p>
</dd>
<dt><code>m (<i>makefile</i>)</code></dt>
<dd><p>默认情况下，尝试重新制作makefile时不启用上述消息。此选项还可以在重建makefile时启用消息。请注意， <samp>all</samp> '选项会启用此选项。此选项还启用了“ <samp>basic</samp>的消息。
</p>
</dd>
<dt><code>n (<i>none</i>)</code></dt>
<dd><p>禁用当前启用的所有调试。如果此后遇到其他调试标志，它们仍将生效。
</p></dd>
</dl>

</dd>
<dt>' <samp>-e</samp> '</dt>
<dd><a name="index-_002de"></a>
</dd>
<dt>' <samp>--environment-overrides</samp> '</dt>
<dd><a name="index-_002d_002denvironment_002doverrides"></a>
<p>赋予从环境优先级获取的变量优先于makefile的变量。请参阅<a href="#Environment">环境变量</a> 。
</p>
</dd>
<dt>' <samp>--eval=<var>string</var></samp> '</dt>
<dd><a name="index-_002d_002deval"></a>

<p>评估<var>string</var>作为makefile语法。这是<code>eval</code>函数（请参阅<a href="#Eval-Function">评估函数</a> ）。在定义了默认规则和变量之后但在读取任何makefile之前执行评估。
</p>
</dd>
<dt>' <samp>-f <var>file</var></samp> '</dt>
<dd><a name="index-_002df-2"></a>
</dd>
<dt>' <samp>--file=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dfile-2"></a>
</dd>
<dt>' <samp>--makefile=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dmakefile-2"></a>
<p>读取名为<var>file</var>作为makefile。请参阅<a href="#Makefiles">编写Makefile</a> 。
</p>
</dd>
<dt>' <samp>-h</samp> '</dt>
<dd><a name="index-_002dh"></a>
</dd>
<dt>' <samp>--help</samp> '</dt>
<dd><a name="index-_002d_002dhelp"></a>

<p>提醒您以下选择<code>make</code>了解然后退出。
</p>
</dd>
<dt>' <samp>-i</samp> '</dt>
<dd><a name="index-_002di-1"></a>
</dd>
<dt>' <samp>--ignore-errors</samp> '</dt>
<dd><a name="index-_002d_002dignore_002derrors-1"></a>
<p>忽略执行重制文件的配方中的所有错误。请参见<a href="#Errors">食谱中的错误</a> 。
</p>
</dd>
<dt>' <samp>-I <var>dir</var></samp> '</dt>
<dd><a name="index-_002dI-1"></a>
</dd>
<dt>' <samp>--include-dir=<var>dir</var></samp> '</dt>
<dd><a name="index-_002d_002dinclude_002ddir-1"></a>
<p>指定目录<var>dir</var>搜索包含的makefile。请参阅<a href="#Include">包括其他Makefile</a> 。如果几个<samp>-I</samp> '选项用于指定多个目录，将按照指定的顺序搜索目录。
</p>
</dd>
<dt>' <samp>-j [<var>jobs</var>]</samp> '</dt>
<dd><a name="index-_002dj-1"></a>
</dd>
<dt>' <samp>--jobs[=<var>jobs</var>]</samp> '</dt>
<dd><a name="index-_002d_002djobs-1"></a>
<p>指定要同时运行的配方（作业）的数量。毫无争议<code>make</code>同时运行尽可能多的配方。如果不止一个' <samp>-j</samp> '选项，最后一个有效。有关如何运行配方的更多信息，请参见<a href="#Parallel">并行执行</a> 。请注意，在MS-DOS上将忽略此选项。</p>
</dd>
<dt>' <samp>-k</samp> '</dt>
<dd><a name="index-_002dk-2"></a>
</dd>
<dt>' <samp>--keep-going</samp> '</dt>
<dd><a name="index-_002d_002dkeep_002dgoing-2"></a>
<p>发生错误后，请尽可能继续。虽然无法重建失败的目标以及依赖于此的目标，但可以完全处理这些目标的其他先决条件。请参阅<a href="#Testing">测试程序的编译</a> 。
</p>
</dd>
<dt>' <samp>-l [<var>load</var>]</samp> '</dt>
<dd><a name="index-_002dl"></a>
</dd>
<dt>' <samp>--load-average[=<var>load</var>]</samp> '</dt>
<dd><a name="index-_002d_002dload_002daverage-1"></a>
</dd>
<dt>' <samp>--max-load[=<var>load</var>]</samp> '</dt>
<dd><a name="index-_002d_002dmax_002dload-1"></a>
<p>指定如果正在运行其他配方并且平均负载至少为，则不应启动任何新配方<var>load</var> （一个浮点数）。不带参数时，删除先前的负载限制。请参阅<a href="#Parallel">并行执行</a> 。
</p>
</dd>
<dt>' <samp>-L</samp> '</dt>
<dd><a name="index-_002dL"></a>
</dd>
<dt>' <samp>--check-symlink-times</samp> '</dt>
<dd><a name="index-_002d_002dcheck_002dsymlink_002dtimes"></a>
<p>在支持符号链接的系统上，此选项会导致<code>make</code>除了这些链接引用的文件上的时间戳之外，还要考虑任何符号链接上的时间戳。提供此选项后，文件和符号链接之间的最新时间戳将用作此目标文件的修改时间。
</p>
</dd>
<dt>' <samp>-n</samp> '</dt>
<dd><a name="index-_002dn-2"></a>
</dd>
<dt>' <samp>--just-print</samp> '</dt>
<dd><a name="index-_002d_002djust_002dprint-2"></a>
</dd>
<dt>' <samp>--dry-run</samp> '</dt>
<dd><a name="index-_002d_002ddry_002drun-2"></a>
</dd>
<dt>' <samp>--recon</samp> '</dt>
<dd><a name="index-_002d_002drecon-2"></a>

<p>打印将要执行的配方，但不要执行（在某些情况下除外）。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。
</p>
</dd>
<dt>' <samp>-o <var>file</var></samp> '</dt>
<dd><a name="index-_002do-1"></a>
</dd>
<dt>' <samp>--old-file=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dold_002dfile-1"></a>
</dd>
<dt>' <samp>--assume-old=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dassume_002dold-1"></a>
<p>不要重新制作文件<var>file</var>即使它比其先决条件还旧，也不要因为<var>file</var> 。本质上，该文件被视为非常旧，并且其规则被忽略。请参阅<a href="#Avoiding-Compilation">避免重新编译某些文件</a> 。
</p>
</dd>
<dt>' <samp>-O[<var>type</var>]</samp> '</dt>
<dd><a name="index-_002dO-1"></a>
</dd>
<dt>' <samp>--output-sync[=<var>type</var>]</samp> '</dt>
<dd><a name="index-_002d_002doutput_002dsync-1"></a>
<a name="index-output-during-parallel-execution-1"></a>
<a name="index-parallel-execution_002c-output-during-1"></a>
<p>确保每个配方的完整输出以不间断的顺序打印。仅当使用<code>--jobs</code>选项以同时运行多个配方（请参见<a href="#Parallel">并行执行</a> ）如果没有此选项，将显示由配方生成的输出。
</p>
<p>没有类型或没有类型' <samp>target</samp> '，则将每个目标的整个配方的输出分组在一起。与类型“ <samp>line</samp> '，则配方中每一行的输出都分组在一起。与类型“ <samp>recurse</samp> '，则将整个递归make的输出分组在一起。与类型“ <samp>none</samp> '，不执行输出同步。请参见<a href="#Parallel-Output">并行执行期间的输出</a> 。
</p>
</dd>
<dt>' <samp>-p</samp> '</dt>
<dd><a name="index-_002dp"></a>
</dd>
<dt>' <samp>--print-data-base</samp> '</dt>
<dd><a name="index-_002d_002dprint_002ddata_002dbase"></a>
<a name="index-data-base-of-make-rules"></a>
<a name="index-predefined-rules-and-variables_002c-printing"></a>
<p>打印由于读取makefile而产生的数据库（规则和变量值）；然后照常执行或按照其他规定执行。这还会打印“ <samp>-v</samp> '开关（请参见下文）。要打印数据库而不尝试重新制作任何文件，请使用' <samp>make <span class="nolinebreak">-qp</span></samp> ' <!-- /@w --> 。要打印预定义规则和变量的数据库，请使用' <samp>make <span class="nolinebreak">-p</span> <span class="nolinebreak">-f</span> /dev/null</samp> ' <!-- /@w --> 。数据库输出包含配方和变量定义的文件名和行号信息，因此它在复杂的环境中可能是有用的调试工具。
</p>
</dd>
<dt>' <samp>-q</samp> '</dt>
<dd><a name="index-_002dq-1"></a>
</dd>
<dt>' <samp>--question</samp> '</dt>
<dd><a name="index-_002d_002dquestion-1"></a>
<p>“问题模式”。不要运行任何配方或打印任何东西；如果指定的目标已经是最新的，则仅返回退出状态，退出状态为零；如果需要重新构建，则返回一个退出状态；如果遇到错误，则返回两个状态。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。
</p>
</dd>
<dt>' <samp>-r</samp> '</dt>
<dd><a name="index-_002dr"></a>
</dd>
<dt>' <samp>--no-builtin-rules</samp> '</dt>
<dd><a name="index-_002d_002dno_002dbuiltin_002drules"></a>
<p>消除对内置隐式规则的<a href="#Implicit-Rules">使用</a> （请参阅<a href="#Implicit-Rules">使用隐式规则</a> ）。您仍然可以通过编写模式规则来定义自己的规则（请参阅<a href="#Pattern-Rules">定义和重新定义模式规则</a> ）。' <samp>-r</samp> '选项还会清除后缀规则的默认后缀列表（请参阅<a href="#Suffix-Rules">老式后缀规则</a> ）。但是您仍然可以使用以下规则定义自己的后缀<code>.SUFFIXES</code> ，然后定义自己的后缀规则。请注意，只有<em>规则</em>受<code>-r</code>选项;默认变量保持有效（请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> ）；看到“ <samp>-R</samp> '选项。
</p>
</dd>
<dt>' <samp>-R</samp> '</dt>
<dd><a name="index-_002dR"></a>
</dd>
<dt>' <samp>--no-builtin-variables</samp> '</dt>
<dd><a name="index-_002d_002dno_002dbuiltin_002dvariables"></a>
<p>消除对特定于规则的内置<a href="#Implicit-Variables">变量的使用</a> （请参阅<a href="#Implicit-Variables">隐式规则使用的变量</a> ）。当然，您仍然可以定义自己的。' <samp>-R</samp> '选项还会自动启用' <samp>-r</samp> '选项（请参见上文），因为没有隐式规则而对它们使用的变量没有任何定义是没有意义的。
</p>
</dd>
<dt>' <samp>-s</samp> '</dt>
<dd><a name="index-_002ds-1"></a>
</dd>
<dt>' <samp>--silent</samp> '</dt>
<dd><a name="index-_002d_002dsilent-1"></a>
</dd>
<dt>' <samp>--quiet</samp> '</dt>
<dd><a name="index-_002d_002dquiet-1"></a>

<p>静音操作；执行时不要打印配方。请参见<a href="#Echoing">配方回显</a> 。
</p>
</dd>
<dt>' <samp>-S</samp> '</dt>
<dd><a name="index-_002dS"></a>
</dd>
<dt>' <samp>--no-keep-going</samp> '</dt>
<dd><a name="index-_002d_002dno_002dkeep_002dgoing"></a>
</dd>
<dt>' <samp>--stop</samp> '</dt>
<dd><a name="index-_002d_002dstop"></a>

<p>取消“ <samp>-k</samp> ' 选项。除非在递归中，否则永远不需要<code>make</code>在哪里<samp>-k</samp> '可能是从顶级继承的<code>make</code>通过<code>MAKEFLAGS</code> （请参阅<a href="#Recursion">递归使用<code>make</code></a> ），或者如果您设置了“ <samp>-k</samp>在<code>MAKEFLAGS</code>在您的环境中。
</p>
</dd>
<dt>' <samp>-t</samp> '</dt>
<dd><a name="index-_002dt-1"></a>
</dd>
<dt>' <samp>--touch</samp> '</dt>
<dd><a name="index-_002d_002dtouch-1"></a>

<p>触摸文件（在不进行实际更改的情况下将它们标记为最新文件），而不是运行其食谱。这是为了假装配方已完成，以欺骗以后的调用<code>make</code> 。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。
</p>
</dd>
<dt>' <samp>--trace</samp> '</dt>
<dd><a name="index-_002d_002dtrace"></a>
<p>显示有关的跟踪信息<code>make</code>执行。打印整个要执行的配方，即使对于通常是静音的配方（由于<code>.SILENT</code>要么 ' <samp>@</samp> '）。还打印定义配方的makefile名称和行号，以及有关为何重建目标的信息。
</p>
</dd>
<dt>' <samp>-v</samp> '</dt>
<dd><a name="index-_002dv"></a>
</dd>
<dt>' <samp>--version</samp> '</dt>
<dd><a name="index-_002d_002dversion"></a>
<p>打印版本<code>make</code>程序，版权，作者列表以及无保证的声明；然后退出。
</p>
</dd>
<dt>' <samp>-w</samp> '</dt>
<dd><a name="index-_002dw"></a>
</dd>
<dt>' <samp>--print-directory</samp> '</dt>
<dd><a name="index-_002d_002dprint_002ddirectory"></a>
<p>在执行makefile之前和之后都打印一条包含工作目录的消息。这对于跟踪复杂的递归嵌套中的错误可能很有用<code>make</code>命令。请参阅<a href="#Recursion">递归使用<code>make</code></a> 。（实际上，您很少需要指定此选项，因为“ <samp>make</samp> '为你做；参见<a href="#g_t_002dw-Option">“ <samp>--print-directory</samp> '选项</a> 。）
</p>
</dd>
<dt>' <samp>--no-print-directory</samp> '</dt>
<dd><a name="index-_002d_002dno_002dprint_002ddirectory-1"></a>
<p>禁止在以下目录中打印工作目录<code>-w</code> 。该选项在以下情况下很有用<code>-w</code>会自动打开，但您不想看到多余的消息。参见<a href="#g_t_002dw-Option">“ <samp>--print-directory</samp>选项</a> 。
</p>
</dd>
<dt>' <samp>-W <var>file</var></samp> '</dt>
<dd><a name="index-_002dW-1"></a>
</dd>
<dt>' <samp>--what-if=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dwhat_002dif-1"></a>
</dd>
<dt>' <samp>--new-file=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dnew_002dfile-1"></a>
</dd>
<dt>' <samp>--assume-new=<var>file</var></samp> '</dt>
<dd><a name="index-_002d_002dassume_002dnew-1"></a>
<p>假装目标<var>file</var>刚刚被修改。与“ <samp>-n</samp> '标志，它显示了如果您修改该文件将会发生什么。没有' <samp>-n</samp> '，这几乎与运行<code>touch</code>在运行之前对给定文件执行命令<code>make</code> ，但修改时间仅在<code>make</code> 。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。
</p>
</dd>
<dt>' <samp>--warn-undefined-variables</samp> '</dt>
<dd><a name="index-_002d_002dwarn_002dundefined_002dvariables"></a>
<a name="index-variables_002c-warning-for-undefined"></a>
<a name="index-undefined-variables_002c-warning-message"></a>
<p>每当发出警告消息<code>make</code>看到对未定义变量的引用。当您尝试调试以复杂方式使用变量的makefile时，这将很有帮助。
</p></dd>
</dl>

<hr>
<a name="Implicit-Rules"></a>
<div class="header">
<p>下一篇： <a href="#Archives" rel="next" accesskey="n">存档</a> ，上一篇： <a href="#Running" rel="prev" accesskey="p">运行中</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-Implicit-Rules"></a>
<h2 class="chapter">10使用隐式规则</h2>
<a name="index-implicit-rule"></a>
<a name="index-rule_002c-implicit"></a>

<p>重建目标文件的某些标准方法非常常用。例如，一种常见的制作目标文件的方法是使用C编译器从C源文件中获取文件， <code>cc</code> 。
</p>
<p><em>内隐规则</em>告诉<code>make</code>如何使用惯用技术，以便您在要使用它们时不必详细指定它们。例如，对于C编译有一个隐式规则。文件名确定运行哪些隐式规则。例如，C编译通常需要一个<samp>.c</samp>文件并制作一个<samp>.o</samp>文件。所以<code>make</code>当看到文件名结尾的这种组合时，将隐式规则应用于C编译。
</p>
<p>一连串的隐含规则可以依次应用；例如， <code>make</code>将重制<samp>.o</samp>来自的文件<samp>.y</samp>通过一个文件<samp>.c</samp>文件。
</p>
<p>内置隐式规则在其配方中使用了几个变量，因此，通过更改变量的值，您可以更改隐式规则的工作方式。例如，变量<code>CFLAGS</code>控制隐式规则为C编译器提供给C编译器的标志。
</p>
<p>您可以通过编写<em>模式规则</em>来定义自己的隐式<em>规则</em> 。
</p>
<p><em>后缀规则</em>是定义隐式规则的更有限的方法。模式规则更为通用和清晰，但保留了后缀规则以实现兼容性。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Using-Implicit" accesskey="1">使用隐式</a> ：</td><td>  </td><td align="left" valign="top">如何使用现有的隐式规则获取更新文件的配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Catalogue-of-Rules" accesskey="2">规则目录</a> ：</td><td>  </td><td align="left" valign="top">内置规则列表。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit-Variables" accesskey="3">隐式变量</a> ：</td><td>  </td><td align="left" valign="top">如何更改预定义规则的作用。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Chained-Rules" accesskey="4">链接规则</a> ：</td><td>  </td><td align="left" valign="top">如何使用隐式规则链。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Rules" accesskey="5">模式规则</a> ：</td><td>  </td><td align="left" valign="top">如何定义新的隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Last-Resort" accesskey="6">不得已</a> ：</td><td>  </td><td align="left" valign="top">如何为找不到规则的规则定义配方。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Suffix-Rules" accesskey="7">后缀规则</a> ：</td><td>  </td><td align="left" valign="top">隐式规则的老式样式。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Implicit-Rule-Search" accesskey="8">隐式规则搜索</a> ：</td><td>  </td><td align="left" valign="top">应用隐式规则的精确算法。
</td></tr>
</tbody></table>

<hr>
<a name="Using-Implicit"></a>
<div class="header">
<p>下一篇： <a href="#Catalogue-of-Rules" rel="next" accesskey="n">规则目录</a> ，上一篇： <a href="#Implicit-Rules" rel="prev" accesskey="p">隐式规则</a> ，上一篇： <a href="#Implicit-Rules" rel="prev" accesskey="p">隐</a> <a href="#Implicit-Rules" rel="up" accesskey="u">式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-Implicit-Rules-1"></a>
<h3 class="section">10.1使用隐式规则</h3>
<a name="index-implicit-rule_002c-how-to-use"></a>
<a name="index-rule_002c-implicit_002c-how-to-use"></a>

<p>允许<code>make</code>要找到更新目标文件的惯用方法，您要做的就是避免自己指定配方。要么写一条没有配方的规则，要么根本不写一条规则。然后<code>make</code>将根据存在或可以制定哪种源文件来确定要使用哪种隐式规则。
</p>
<p>例如，假设makefile如下所示：</p>
<div class="example">
<pre class="example">foo : foo.o bar.o
        cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
</pre></div>

<p>因为你提到<samp>foo.o</samp>但不要为此规定<code>make</code>会自动寻找一个隐性规则，以告诉您如何更新它。无论文件是否发生这种情况<samp>foo.o</samp>目前存在。
</p>
<p>如果找到隐式规则，则它可以提供一个配方以及一个或多个先决条件（源文件）。您可能想为<samp>foo.o</samp>如果您需要指定隐式规则无法提供的其他先决条件（例如头文件），则不使用任何配方。
</p>
<p>每个隐式规则都有一个目标模式和先决条件模式。可能有许多具有相同目标模式的隐式规则。例如，许多规则使“ <samp>.o</samp> '文件：一个，来自' <samp>.c</samp>使用C编译器的文件；另一个，来自“ <samp>.p</samp>带有Pascal编译器的文件；等等。实际适用的规则是存在或可以制定前提条件的规则。所以，如果你有一个文件<samp>foo.c</samp> ， <code>make</code>将运行C编译器；否则，如果您有文件<samp>foo.p</samp> ， <code>make</code>将运行Pascal编译器；等等。
</p>
<p>当然，在编写makefile时，您知道要使用哪个隐式规则<code>make</code>使用，并且您知道它会选择该文件，因为您知道应该存在哪些可能的必备文件。有关所有预定义隐式规则的目录，请参见<a href="#Catalogue-of-Rules">内置规则</a>目录。
</p>
<p>上面，我们说过，如果所需的前提条件“存在或可以实现”，则隐含规则适用。如果在makefile文件中明确提及该文件为目标或先决条件，或者可以递归地找到隐式规则以创建文件，则可以“创建”文件。当隐式先决条件是另一个隐式规则的结果时，我们说<em>链接</em>正在发生。请参阅<a href="#Chained-Rules">隐式规则链</a> 。
</p>
<p>一般来说， <code>make</code>为每个目标和每个没有配方的双冒号规则搜索隐式规则。仅作为前提条件提及的文件被视为目标，其规则未指定任何内容，因此会对其进行隐式规则搜索。有关如何完成搜索的详细信息，请参见<a href="#Implicit-Rule-Search">隐式规则搜索算法</a> 。
</p>
<p>请注意，显式前提条件不影响隐式规则搜索。例如，考虑以下明确规则：</p>
<div class="example">
<pre class="example">foo.o: foo.p
</pre></div>

<p>前提条件<samp>foo.p</samp>并不一定意味着<code>make</code>将重制<samp>foo.o</samp>根据隐式规则制作目标文件， <samp>.o</samp> Pascal源文件中的文件<samp>.p</samp>文件。例如，如果<samp>foo.c</samp>同样也存在，而是使用从C源文件创建目标文件的隐式规则，因为它出现在预定义的隐式规则列表中的Pascal规则之前（请参阅<a href="#Catalogue-of-Rules">内置</a>规则<a href="#Catalogue-of-Rules">目录</a> ）。
</p>
<p>如果您不希望将隐式规则用于没有配方的目标，则可以通过写分号为该目标提供空配方（请参见<a href="#Empty-Recipes">定义空配方</a> ）。
</p>
<hr>
<a name="Catalogue-of-Rules"></a>
<div class="header">
<p>下一页： <a href="#Implicit-Variables" rel="next" accesskey="n">隐式变量</a> ，上一篇： <a href="#Using-Implicit" rel="prev" accesskey="p">使用隐式</a> ，上一篇： <a href="#Implicit-Variables" rel="next" accesskey="n">隐</a> <a href="#Implicit-Rules" rel="up" accesskey="u">式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Catalogue-of-Built_002dIn-Rules"></a>
<h3 class="section">10.2内置规则目录</h3>
<a name="index-implicit-rule_002c-predefined"></a>
<a name="index-rule_002c-implicit_002c-predefined"></a>

<p>这是预定义的隐式规则的目录，除非makefile显式覆盖或取消它们，否则它们始终可用。有关<a href="#Canceling-Rules">取消</a>或覆盖隐式规则的信息，请参见<a href="#Canceling-Rules">取消隐</a>式规则。' <samp>-r</samp> ' 要么 ' <samp>--no-builtin-rules</samp> '选项将取消所有预定义规则。
</p>
<p>本手册仅记录了基于POSIX的操作系统上可用的默认规则。其他操作系统，例如VMS，Windows，OS / 2等，可能具有不同的默认规则集。要查看您的GNU版本中可用的默认规则和变量的完整列表<code>make</code> ， 跑 ' <samp>make -p</samp>在没有makefile的目录中。
</p>
<p>并非所有这些规则都将始终被定义，即使“ <samp>-r</samp> '选项未给出。许多预定义的隐式规则在<code>make</code>作为后缀规则，因此将定义哪些规则取决于<em>后缀列表</em> （特殊目标的先决条件列表） <code>.SUFFIXES</code> ）。默认后缀列表为： <code>.out</code> ， <code>.a</code> ， <code>.ln</code> ， <code>.o</code> ， <code>.c</code> ， <code>.cc</code> ， <code>.C</code> ， <code>.cpp</code> ， <code>.p</code> ， <code>.f</code> ， <code>.F</code> ， <code>.m</code> ， <code>.r</code> ， <code>.y</code> ， <code>.l</code> ， <code>.ym</code> ， <code>.lm</code> ， <code>.s</code> ， <code>.S</code> ， <code>.mod</code> ， <code>.sym</code> ， <code>.def</code> ， <code>.h</code> ， <code>.info</code> ， <code>.dvi</code> ， <code>.tex</code> ， <code>.texinfo</code> ， <code>.texi</code> ， <code>.txinfo</code> ， <code>.w</code> ， <code>.ch</code><code>.web</code> ， <code>.sh</code> ， <code>.elc</code> ， <code>.el</code> 。下文描述的所有先决条件都具有这些后缀之一的隐式规则实际上是后缀规则。如果您修改后缀列表，则唯一有效的预定义后缀规则将是由您指定的列表中的一个或两个后缀命名的规则。后缀未在列表中的规则被禁用。有关<a href="#Suffix-Rules">后缀规则</a>的完整详细信息，请参见<a href="#Suffix-Rules">老式</a>后缀规则。
</p>
<dl compact>
<dt>编译C程序</dt>
<dd><a name="index-C_002c-rule-to-compile"></a>
<a name="index-cc"></a>
<a name="index-gcc"></a>
<a name="index-_002eo"></a>
<a name="index-_002ec"></a>
<p><samp><var>n</var>.o</samp>是从<samp><var>n</var>.c</samp>带有“ <samp>$(CC) $(CPPFLAGS) $(CFLAGS) -c</samp> '。
</p>
</dd>
<dt>编译C ++程序</dt>
<dd><a name="index-C_002b_002b_002c-rule-to-compile"></a>
<a name="index-g_002b_002b"></a>
<a name="index-_002ecc"></a>
<a name="index-_002ecpp"></a>
<a name="index-_002eC"></a>
<p><samp><var>n</var>.o</samp>是从<samp><var>n</var>.cc</samp> ， <samp><var>n</var>.cpp</samp> ， 要么<samp><var>n</var>.C</samp>带有“ <samp>$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c</samp> '。我们建议您使用后缀' <samp>.cc</samp> '用于C ++源文件，而不是' <samp>.C</samp> '。
</p>
</dd>
<dt>编译Pascal程序</dt>
<dd><a name="index-Pascal_002c-rule-to-compile"></a>
<a name="index-pc"></a>
<a name="index-_002ep"></a>
<p><samp><var>n</var>.o</samp>是从<samp><var>n</var>.p</samp>搭配食谱<samp>$(PC) $(PFLAGS) -c</samp> '。
</p>
</dd>
<dt>编译Fortran和Ratfor程序</dt>
<dd><a name="index-Fortran_002c-rule-to-compile"></a>
<a name="index-Ratfor_002c-rule-to-compile"></a>
<a name="index-f77"></a>
<a name="index-_002ef"></a>
<a name="index-_002er"></a>
<a name="index-_002eF"></a>
<p><samp><var>n</var>.o</samp>是从<samp><var>n</var>.r</samp> ， <samp><var>n</var>.F</samp>要么<samp><var>n</var>.f</samp>通过运行Fortran编译器。使用的精确配方如下：</p>
<dl compact>
<dt>' <samp>.f</samp> '</dt>
<dd><p>' <samp>$(FC) $(FFLAGS) -c</samp> '。
</p></dd>
<dt>' <samp>.F</samp> '</dt>
<dd><p>' <samp>$(FC) $(FFLAGS) $(CPPFLAGS) -c</samp> '。
</p></dd>
<dt>' <samp>.r</samp> '</dt>
<dd><p>' <samp>$(FC) $(FFLAGS) $(RFLAGS) -c</samp> '。
</p></dd>
</dl>

</dd>
<dt>预处理Fortran和Ratfor程序</dt>
<dd><p><samp><var>n</var>.f</samp>是从<samp><var>n</var>.r</samp>要么<samp><var>n</var>.F</samp> 。该规则仅运行预处理器，以将Ratfor或可预处理的Fortran程序转换为严格的Fortran程序。使用的精确配方如下：</p>
<dl compact>
<dt>' <samp>.F</samp> '</dt>
<dd><p>' <samp>$(FC) $(CPPFLAGS) $(FFLAGS) -F</samp> '。
</p></dd>
<dt>' <samp>.r</samp> '</dt>
<dd><p>' <samp>$(FC) $(FFLAGS) $(RFLAGS) -F</samp> '。
</p></dd>
</dl>

</dd>
<dt>编译Modula-2程序</dt>
<dd><a name="index-Modula_002d2_002c-rule-to-compile"></a>
<a name="index-m2c"></a>
<a name="index-_002esym"></a>
<a name="index-_002edef"></a>
<a name="index-_002emod"></a>
<p><samp><var>n</var>.sym</samp>由...制成<samp><var>n</var>.def</samp>带有“ <samp>$(M2C) $(M2FLAGS) $(DEFFLAGS)</samp> '。<samp><var>n</var>.o</samp>由...制成<samp><var>n</var>.mod</samp> ;形式为：“ <samp>$(M2C) $(M2FLAGS) $(MODFLAGS)</samp> ' <!-- /@w --> 。
</p>
</dd>
<dt>汇编和预处理汇编程序</dt>
<dd><a name="index-assembly_002c-rule-to-compile"></a>
<a name="index-as"></a>
<a name="index-_002es"></a>
<p><samp><var>n</var>.o</samp>是从<samp><var>n</var>.s</samp>通过运行汇编器， <code>as</code> 。确切的配方是<samp>$(AS) $(ASFLAGS)</samp> '。
</p>
<a name="index-_002eS"></a>
<p><samp><var>n</var>.s</samp>是从<samp><var>n</var>.S</samp>通过运行C预处理程序， <code>cpp</code> 。确切的配方是<samp>$(CPP) $(CPPFLAGS)</samp> ' <!-- /@w --> 。
</p>
</dd>
<dt>链接单个目标文件</dt>
<dd><a name="index-linking_002c-predefined-rule-for"></a>
<a name="index-ld"></a>
<a name="index-_002eo-1"></a>
<p><samp><var>n</var></samp>是从<samp><var>n</var>.o</samp>通过运行链接器（通常称为<code>ld</code> ）通过C编译器。使用的精确配方是“ <samp>$(CC) $(LDFLAGS) <var>n</var>.o $(LOADLIBES) $(LDLIBS)</samp> ' <!-- /@w --> 。
</p>
<p>对于只有一个源文件的简单程序，此规则可以正确执行操作。如果有多个目标文件（可能来自其他各种源文件），其中一个文件的名称与可执行文件的名称匹配，那么它也会做正确的事情。从而，</p>
<div class="example">
<pre class="example">x: y.o z.o
</pre></div>

<p>什么时候<samp>x.c</samp> ， <samp>y.c</samp>和<samp>z.c</samp>全部存在将执行：</p>
<div class="example">
<pre class="example">cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
</pre></div>

<p>在更复杂的情况下，例如当没有目标文件的名称来源于可执行文件的名称时，必须编写一个明确的配方来进行链接。
</p>
<p>各种文件自动制作成“ <samp>.o</samp> '目标文件将通过使用编译器自动链接（' <samp>$(CC)</samp> '，' <samp>$(FC)</samp> ' 要么 ' <samp>$(PC)</samp> '; C编译器<samp>$(CC)</samp> '用于组装' <samp>.s</samp> '个文件）而没有' <samp>-c</samp> ' 选项。这可以通过使用“ <samp>.o</samp>对象文件作为中间文件，但是一步完成编译和链接速度更快，因此就是这样。
</p>
</dd>
<dt>Yacc C程序</dt>
<dd><a name="index-yacc-1"></a>
<a name="index-Yacc_002c-rule-to-run"></a>
<a name="index-_002ey"></a>
<p><samp><var>n</var>.c</samp>是从<samp><var>n</var>.y</samp>通过使用配方运行Yacc' <samp>$(YACC) $(YFLAGS)</samp> '。
</p>
</dd>
<dt>Lex for C程序</dt>
<dd><a name="index-lex"></a>
<a name="index-Lex_002c-rule-to-run"></a>
<a name="index-_002el"></a>
<p><samp><var>n</var>.c</samp>是从<samp><var>n</var>.l</samp>通过运行Lex。实际的配方是<samp>$(LEX) $(LFLAGS)</samp> '。
</p>
</dd>
<dt>Lex for Ratfor计划</dt>
<dd><p><samp><var>n</var>.r</samp>是从<samp><var>n</var>.l</samp>通过运行Lex。实际的配方是<samp>$(LEX) $(LFLAGS)</samp> '。
</p>
<p>使用相同后缀的约定<samp>.l</samp>对于所有Lex文件，无论它们生成C代码还是Ratfor代码，都无法<code>make</code>以确定在任何特定情况下您正在使用两种语言中的哪一种。如果<code>make</code>被要求从“ <samp>.l</samp> '文件，它必须猜测要使用哪个编译器。它将猜测为C编译器，因为这更常见。如果您使用的是Ratfor，请确保<code>make</code>通过提及知道这一点<samp><var>n</var>.r</samp>在makefile中。或者，如果您仅使用Ratfor且没有C文件，请删除“ <samp>.c</samp>隐式规则后缀列表中的'具有：</p>
<div class="example">
<pre class="example">.SUFFIXES:
.SUFFIXES: .o .r .f .l &hellip;
</pre></div>

</dd>
<dt>从C，Yacc或Lex程序制作Lint库</dt>
<dd><a name="index-lint"></a>
<a name="index-lint_002c-rule-to-run"></a>
<a name="index-_002eln"></a>
<p><samp><var>n</var>.ln</samp>由...制成<samp><var>n</var>.c</samp>通过运行<code>lint</code> 。确切的配方是<samp>$(LINT) $(LINTFLAGS) $(CPPFLAGS) <span class="nolinebreak">-i</span></samp> ' <!-- /@w --> 。在以下代码产生的C代码上使用相同的配方<samp><var>n</var>.y</samp>要么<samp><var>n</var>.l</samp> 。
</p>
</dd>
<dt>TeX和Web</dt>
<dd><a name="index-TeX_002c-rule-to-run"></a>
<a name="index-Web_002c-rule-to-run"></a>
<a name="index-tex"></a>
<a name="index-cweave"></a>
<a name="index-weave"></a>
<a name="index-tangle"></a>
<a name="index-ctangle"></a>
<a name="index-_002edvi"></a>
<a name="index-_002etex"></a>
<a name="index-_002eweb"></a>
<a name="index-_002ew"></a>
<a name="index-_002ech"></a>
<p><samp><var>n</var>.dvi</samp>由...制成<samp><var>n</var>.tex</samp>搭配食谱<samp>$(TEX)</samp> '。 <samp><var>n</var>.tex</samp>由...制成<samp><var>n</var>.web</samp>与“ <samp>$(WEAVE)</samp> '，或来自<samp><var>n</var>.w</samp> （和来自<samp><var>n</var>.ch</samp>如果存在或可以制作），则使用“ <samp>$(CWEAVE)</samp> '。 <samp><var>n</var>.p</samp>由...制成<samp><var>n</var>.web</samp>与“ <samp>$(TANGLE)</samp> '和<samp><var>n</var>.c</samp>由...制成<samp><var>n</var>.w</samp> （和来自<samp><var>n</var>.ch</samp>如果存在或可以制作），则使用“ <samp>$(CTANGLE)</samp> '。
</p>
</dd>
<dt>Texinfo和信息</dt>
<dd><a name="index-Texinfo_002c-rule-to-format"></a>
<a name="index-Info_002c-rule-to-format"></a>
<a name="index-texi2dvi"></a>
<a name="index-makeinfo"></a>
<a name="index-_002etexinfo"></a>
<a name="index-_002einfo"></a>
<a name="index-_002etexi"></a>
<a name="index-_002etxinfo"></a>
<p><samp><var>n</var>.dvi</samp>由...制成<samp><var>n</var>.texinfo</samp> ， <samp><var>n</var>.texi</samp> ， 要么<samp><var>n</var>.txinfo</samp> ，搭配食谱“ <samp>$(TEXI2DVI) <span class="nolinebreak">$(TEXI2DVI_FLAGS)</span></samp> ' <!-- /@w --> 。 <samp><var>n</var>.info</samp>由...制成<samp><var>n</var>.texinfo</samp> ， <samp><var>n</var>.texi</samp> ， 要么<samp><var>n</var>.txinfo</samp> ，搭配食谱“ <samp>$(MAKEINFO) <span class="nolinebreak">$(MAKEINFO_FLAGS)</span></samp> ' <!-- /@w --> 。
</p>
</dd>
<dt>RCS</dt>
<dd><a name="index-RCS_002c-rule-to-extract-from"></a>
<a name="index-co"></a>
<a name="index-_002cv-_0028RCS-file-extension_0029"></a>
<p>任何档案<samp><var>n</var></samp>如有必要，从名为RCS的RCS文件中提取<samp><var>n</var>,v</samp>要么<samp>RCS/<var>n</var>,v</samp> 。使用的精确配方是“ <samp>$(CO) $(COFLAGS)</samp> ' <!-- /@w --> 。 <samp><var>n</var></samp>即使RCS文件较新，也不会从RCS中提取该文件（如果已存在）。RCS的规则是终端规则（请参阅“ <a href="#Match_002dAnything-Rules">匹配模式规则”</a> ），因此无法从其他来源生成RCS文件。它们必须确实存在。
</p>
</dd>
<dt>SCCS</dt>
<dd><a name="index-SCCS_002c-rule-to-extract-from"></a>
<a name="index-get"></a>
<a name="index-s_002e-_0028SCCS-file-prefix_0029"></a>
<p>任何档案<samp><var>n</var></samp>如有必要，从名为的SCCS文件中提取<samp>s.<var>n</var></samp>要么<samp>SCCS/s.<var>n</var></samp> 。使用的精确配方是“ <samp>$(GET) $(GFLAGS)</samp> ' <!-- /@w --> 。SCCS的规则是终端规则（请参阅“ <a href="#Match_002dAnything-Rules">匹配任何内容的规则”</a> ），因此无法从其他来源生成SCCS文件。它们必须确实存在。
</p>
<a name="index-_002esh"></a>
<p>为了SCCS的利益，一个文件<samp><var>n</var></samp>从复制<samp><var>n</var>.sh</samp>并使其成为可执行文件（所有人）。这适用于签入SCCS的Shell脚本。由于RCS保留了文件的执行权限，因此您无需在RCS中使用此功能。</p>
<p>我们建议您避免使用SCCS。RCS被广泛认为是高级的，而且也是免费的。通过选择自由软件代替类似（或劣等）的专有软件，您将支持自由软件运动。
</p></dd>
</dl>

<p>通常，您只想更改上表中列出的变量，这些变量将在下一节中介绍。
</p>
<p>但是，内置隐式规则中的配方实际上使用诸如<code>COMPILE.c</code> ， <code>LINK.p</code>和<code>PREPROCESS.S</code> ，其值包含上面列出的配方。
</p>
<p><code>make</code>遵循以下规则：编译规则<samp>.<var>x</var></samp>源文件使用变量<code>COMPILE.<var>x</var></code> 。同样，从<samp>.<var>x</var></samp>文件用途<code>LINK.<var>x</var></code> ;和预处理规则<samp>.<var>x</var></samp>文件用途<code>PREPROCESS.<var>x</var></code> 。
</p>
<a name="index-OUTPUT_005fOPTION"></a>
<p>每个产生目标文件的规则都使用变量<code>OUTPUT_OPTION</code> 。 <code>make</code>定义此变量以包含' <samp>-o $@</samp> '，或者为空，具体取决于编译时选项。您需要“ <samp>-o</samp> '选项，以确保当源文件位于其他目录中时（例如，使用<code>VPATH</code> （请参阅<a href="#Directory-Search">目录搜索</a> ）。但是，某些系统上的编译器不接受“ <samp>-o</samp> '切换目标文件。如果使用这样的系统，并使用<code>VPATH</code> ，某些编译会将其输出放在错误的位置。解决此问题的一种可能的方法是给出<code>OUTPUT_OPTION</code>价值 ' <samp>; mv $*.o $@</samp> ' <!-- /@w --> 。
</p>
<hr>
<a name="Implicit-Variables"></a>
<div class="header">
<p>下一篇： <a href="#Chained-Rules" rel="next" accesskey="n">链接规则</a> ，上一篇： <a href="#Chained-Rules" rel="next" accesskey="n">规则</a> <a href="#Catalogue-of-Rules" rel="prev" accesskey="p">目录</a> ，上一篇： <a href="#Implicit-Rules" rel="up" accesskey="u">隐式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Variables-Used-by-Implicit-Rules"></a>
<h3 class="section">10.3隐式规则使用的变量</h3>
<a name="index-flags-for-compilers"></a>

<p>内置隐式规则中的配方自由使用某些预定义变量。您可以使用以下参数更改makefile中这些变量的值： <code>make</code> ，或在环境中更改隐式规则的工作方式而无需重新定义规则本身。您可以使用'取消隐式规则使用的所有变量<samp>-R</samp> ' 要么 ' <samp>--no-builtin-variables</samp> ' 选项。
</p>
<p>例如，用于编译C源文件的配方实际上显示为“ <samp>$(CC) -c $(CFLAGS) $(CPPFLAGS)</samp> '。使用的变量的默认值为' <samp>cc</samp> '什么也没有，导致命令' <samp>cc -c</samp> '。通过重新定义“ <samp>CC</samp> ' 至 ' <samp>ncc</samp> '，您可能会导致' <samp>ncc</samp>用于隐式规则执行的所有C编译。通过重新定义“ <samp>CFLAGS</samp> ' 成为 ' <samp>-g</samp> '，您可以通过' <samp>-g</samp> ”选项。<em>所有</em>执行C编译的隐式规则都使用' <samp>$(CC)</samp> '以获取编译器的程序名称，并且<em>都</em>包含' <samp>$(CFLAGS)</samp>在提供给编译器的参数中。
</p>
<p>隐式规则中使用的变量分为两类：那些是程序名称（例如<code>CC</code> ）以及包含程序参数的变量（例如<code>CFLAGS</code> ）。（“程序名称”可能还包含一些命令参数，但必须以实际的可执行程序名称开头。）如果一个变量值包含多个参数，请用空格分隔它们。
</p>
<p>下表描述了一些更常用的预定义变量。此列表并不详尽，此处显示的默认值可能不是<code>make</code>选择适合您的环境。查看GNU实例的预定义变量的完整列表<code>make</code>你可以跑<samp>make -p</samp> '在没有makefile的目录中。
</p>
<p>下表列出了一些更常见的变量，它们用作内置规则中的程序名称：</p>
<dl compact>
<dt><code>AR</code></dt>
<dd><a name="index-AR"></a>
<p>档案维护程序；默认' <samp>ar</samp> '。
<a name="index-ar"></a>
</p>
</dd>
<dt><code>AS</code></dt>
<dd><a name="index-AS"></a>
<p>汇编文件程序；默认' <samp>as</samp> '。
<a name="index-as-1"></a>
</p>
</dd>
<dt><code>CC</code></dt>
<dd><a name="index-CC"></a>
<p>用于编译C程序的程序；默认' <samp>cc</samp> '。
<a name="index-cc-1"></a>
</p>
</dd>
<dt><code>CXX</code></dt>
<dd><a name="index-CXX"></a>
<p>用于编译C ++程序的程序；默认' <samp>g++</samp> '。
<a name="index-g_002b_002b-1"></a>
</p>
</dd>
<dt><code>CPP</code></dt>
<dd><a name="index-CPP"></a>
<p>用于运行C预处理程序的程序，结果输出到标准输出；默认' <samp>$(CC) -E</samp> '。
</p>
</dd>
<dt><code>FC</code></dt>
<dd><a name="index-FC"></a>
<p>用于编译或预处理Fortran和Ratfor程序的程序；默认' <samp>f77</samp> '。
<a name="index-f77-1"></a>
</p>
</dd>
<dt><code>M2C</code></dt>
<dd><a name="index-M2C"></a>
<p>用于编译Modula-2源代码的程序；默认' <samp>m2c</samp> '。
<a name="index-m2c-1"></a>
</p>
</dd>
<dt><code>PC</code></dt>
<dd><a name="index-PC"></a>
<p>用于编译Pascal程序的程序；默认' <samp>pc</samp> '。
<a name="index-pc-1"></a>
</p>
</dd>
<dt><code>CO</code></dt>
<dd><a name="index-CO"></a>
<p>从RCS中提取文件的程序；默认' <samp>co</samp> '。
<a name="index-co-1"></a>
</p>
</dd>
<dt><code>GET</code></dt>
<dd><a name="index-GET"></a>
<p>从SCCS提取文件的程序；默认' <samp>get</samp> '。
<a name="index-get-1"></a>
</p>
</dd>
<dt><code>LEX</code></dt>
<dd><a name="index-LEX"></a>
<p>用于将Lex语法转换为源代码的程序；默认' <samp>lex</samp> '。
<a name="index-lex-1"></a>
</p>
</dd>
<dt><code>YACC</code></dt>
<dd><a name="index-YACC"></a>
<p>用于将Yacc语法转换为源代码的程序；默认' <samp>yacc</samp> '。
<a name="index-yacc-2"></a>
</p>
</dd>
<dt><code>LINT</code></dt>
<dd><a name="index-LINT"></a>
<p>用于在源代码上运行lint的程序；默认' <samp>lint</samp> '。
<a name="index-lint-1"></a>
</p>
</dd>
<dt><code>MAKEINFO</code></dt>
<dd><a name="index-MAKEINFO"></a>
<p>将Texinfo源文件转换为Info文件的程序；默认' <samp>makeinfo</samp> '。
<a name="index-makeinfo-1"></a>
</p>
</dd>
<dt><code>TEX</code></dt>
<dd><a name="index-TEX"></a>
<p>从TeX源制作TeX <small>DVI</small>文件的程序；默认' <samp>tex</samp> '。
<a name="index-tex-1"></a>
</p>
</dd>
<dt><code>TEXI2DVI</code></dt>
<dd><a name="index-TEXI2DVI"></a>
<p>从Texinfo源制作TeX <small>DVI</small>文件的程序；默认' <samp>texi2dvi</samp> '。
<a name="index-texi2dvi-1"></a>
</p>
</dd>
<dt><code>WEAVE</code></dt>
<dd><a name="index-WEAVE"></a>
<p>将Web转换为TeX的程序；默认' <samp>weave</samp> '。
<a name="index-weave-1"></a>
</p>
</dd>
<dt><code>CWEAVE</code></dt>
<dd><a name="index-CWEAVE"></a>
<p>将C Web转换为TeX的程序；默认' <samp>cweave</samp> '。
<a name="index-cweave-1"></a>
</p>
</dd>
<dt><code>TANGLE</code></dt>
<dd><a name="index-TANGLE"></a>
<p>将Web转换为Pascal的程序；默认' <samp>tangle</samp> '。
<a name="index-tangle-1"></a>
</p>
</dd>
<dt><code>CTANGLE</code></dt>
<dd><a name="index-CTANGLE"></a>
<p>将C Web转换为C的程序；默认' <samp>ctangle</samp> '。
<a name="index-ctangle-1"></a>
</p>
</dd>
<dt><code>RM</code></dt>
<dd><a name="index-RM"></a>
<p>删除文件的命令；默认' <samp>rm -f</samp> '。
<a name="index-rm"></a>
</p></dd>
</dl>

<p>这是一个变量表，其值是上述程序的附加参数。除非另有说明，否则所有这些的默认值为空字符串。
</p>
<dl compact>
<dt><code>ARFLAGS</code></dt>
<dd><a name="index-ARFLAGS"></a>
<p>提供存档维护程序的标志；默认' <samp>rv</samp> '。
</p>
</dd>
<dt><code>ASFLAGS</code></dt>
<dd><a name="index-ASFLAGS"></a>
<p>提供给汇编程序的额外标志（在' <samp>.s</samp> ' 要么 ' <samp>.S</samp> '文件）。
</p>
</dd>
<dt><code>CFLAGS</code></dt>
<dd><a name="index-CFLAGS"></a>
<p>提供给C编译器的额外标志。
</p>
</dd>
<dt><code>CXXFLAGS</code></dt>
<dd><a name="index-CXXFLAGS"></a>
<p>提供给C ++编译器的额外标志。
</p>
</dd>
<dt><code>COFLAGS</code></dt>
<dd><a name="index-COFLAGS"></a>
<p>提供给RCS的额外标志<code>co</code>程序。
</p>
</dd>
<dt><code>CPPFLAGS</code></dt>
<dd><a name="index-CPPFLAGS"></a>
<p>额外的标志提供给C预处理程序和使用它的程序（C和Fortran编译器）。
</p>
</dd>
<dt><code>FFLAGS</code></dt>
<dd><a name="index-FFLAGS"></a>
<p>提供给Fortran编译器的额外标志。
</p>
</dd>
<dt><code>GFLAGS</code></dt>
<dd><a name="index-GFLAGS"></a>
<p>提供给SCCS的额外标志<code>get</code>程序。
</p>
</dd>
<dt><code>LDFLAGS</code></dt>
<dd><a name="index-LDFLAGS"></a>
<p>当编译器应该调用链接器时，会给它们额外的标志，“ <samp>ld</samp> '， 如<code>-L</code> 。图书馆（ <code>-lfoo</code> ）应该添加到<code>LDLIBS</code>变量。
</p>
</dd>
<dt><code>LDLIBS</code></dt>
<dd><a name="index-LDLIBS"></a>
<a name="index-LOADLIBES"></a>
<p>库标志或应在调用链接程序时赋予编译器的名称， <samp>ld</samp> '。 <code>LOADLIBES</code>是不推荐使用（但仍受支持）的替代<code>LDLIBS</code> 。非库链接程序标志，例如<code>-L</code> ，应该放在<code>LDFLAGS</code>变量。
</p>
</dd>
<dt><code>LFLAGS</code></dt>
<dd><a name="index-LFLAGS"></a>
<p>额外的标志给Lex。
</p>
</dd>
<dt><code>YFLAGS</code></dt>
<dd><a name="index-YFLAGS"></a>
<p>额外的标志给予Yacc。
</p>
</dd>
<dt><code>PFLAGS</code></dt>
<dd><a name="index-PFLAGS"></a>
<p>提供给Pascal编译器的额外标志。
</p>
</dd>
<dt><code>RFLAGS</code></dt>
<dd><a name="index-RFLAGS"></a>
<p>额外的标志提供给用于Ratfor程序的Fortran编译器。
</p>
</dd>
<dt><code>LINTFLAGS</code></dt>
<dd><a name="index-LINTFLAGS"></a>
<p>额外的标志给皮棉。
</p></dd>
</dl>

<hr>
<a name="Chained-Rules"></a>
<div class="header">
<p>下一个： <a href="#Pattern-Rules" rel="next" accesskey="n">模式规则</a> ，上一个： <a href="#Implicit-Variables" rel="prev" accesskey="p">隐式变量</a> ，上一个： <a href="#Implicit-Rules" rel="up" accesskey="u">隐式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Chains-of-Implicit-Rules"></a>
<h3 class="section">10.4隐式规则链</h3>

<a name="index-chains-of-rules"></a>
<a name="index-rule_002c-implicit_002c-chains-of"></a>
<p>有时，可以通过一系列隐式规则来创建文件。例如，一个文件<samp><var>n</var>.o</samp>可以由<samp><var>n</var>.y</samp>首先运行Yacc，然后<code>cc</code> 。这样的序列称为<em>链</em> 。
</p>
<p>如果文件<samp><var>n</var>.c</samp>存在或在makefile中提及，不需要特殊搜索： <code>make</code>发现可以通过C编译从以下位置创建目标文件<samp><var>n</var>.c</samp> ;以后，在考虑如何制作时<samp><var>n</var>.c</samp> ，则使用运行Yacc的规则。最终两者<samp><var>n</var>.c</samp>和<samp><var>n</var>.o</samp>已更新。
</p>
<a name="index-intermediate-files"></a>
<a name="index-files_002c-intermediate"></a>
<p>但是，即使<samp><var>n</var>.c</samp>不存在，没有被提及， <code>make</code>知道如何将其设想为之间缺少的链接<samp><var>n</var>.o</samp>和<samp><var>n</var>.y</samp> ！在这种情况下， <samp><var>n</var>.c</samp>被称为<em>中间文件</em> 。一旦<code>make</code>已决定使用中间文件，就像在makefile中已提到的那样，将其输入数据库，并附带说明如何创建中间文件的隐式规则。
</p>
<p>就像所有其他文件一样，使用其规则重新制作中间文件。但是中间文件在两种方式上有不同的对待。
</p>
<p>第一个区别是如果中间文件不存在会发生什么。如果是普通文件<var>b</var>不存在，并且<code>make</code>认为目标取决于<var>b</var> ，它总是会创建<var>b</var>然后从更新目标<var>b</var> 。但是如果<var>b</var>是一个中间文件，然后<code>make</code>可以独自离开它不会打扰更新<var>b</var>或最终目标，除非满足以下条件<var>b</var>比该目标更新，或者有其他原因更新该目标。
</p>
<p>第二个区别是，如果<code>make</code> <em>确实</em>创造<var>b</var>为了更新其他内容，它删除了<var>b</var>以后不再需要它。因此，以前没有的中间文件<code>make</code>以后也不存在<code>make</code> 。
<code>make</code>通过打印“ <samp>rm -f</samp> '命令显示要删除的文件。
</p>
<p>通常，如果文件在makefile中被提及为目标或先决条件，则该文件不能为中间文件。但是，您可以通过将文件列出为特殊目标的先决条件来将其明确标记为中间文件<code>.INTERMEDIATE</code> 。即使以其他方式显式提及该文件，此操作也会生效。
</p>
<a name="index-intermediate-files_002c-preserving"></a>
<a name="index-preserving-intermediate-files"></a>
<a name="index-secondary-files"></a>
<p>您可以通过将中间文件标记为<em>辅助</em>文件来防止其自动删除。为此，请将其列为特殊目标的先决条件<code>.SECONDARY</code> 。当文件是辅助文件时， <code>make</code>不会仅仅因为它不存在而创建文件，而是<code>make</code>不会自动删除文件。将文件标记为辅助文件也将其标记为中间文件。
</p>
<p>您可以列出隐式规则的目标模式（例如“ <samp>%.o</samp> '）作为特殊目标的前提<code>.PRECIOUS</code>保留由隐式规则创建的中间文件，这些文件的目标模式与该文件的名称匹配；请参见<a href="#Interrupts">中断</a> 。
<a name="index-preserving-with-_002ePRECIOUS-1"></a>
<a name="index-_002ePRECIOUS-intermediate-files"></a>
</p>
<p>一条链可以包含两个以上的隐式规则。例如，可以制作一个文件<samp>foo</samp>从<samp>RCS/foo.y,v</samp>通过运行RCS，Yacc和<code>cc</code> 。然后两者<samp>foo.y</samp>和<samp>foo.c</samp>是中间文件，最后将其删除。
</p>
<p>一条隐式规则在一个链中最多只能出现一次。这意味着<code>make</code>甚至不会认为这样的荒谬<samp>foo</samp>从<samp>foo.o.o</samp>通过运行链接器两次。此约束具有防止在搜索隐式规则链时出现任何无限循环的附加好处。
</p>
<p>有一些特殊的隐式规则可以优化某些情况，否则规则链会处理这些情况。例如，制作<samp>foo</samp>从<samp>foo.c</samp>可以通过使用以下方法编译和链接单独的链接规则来处理<samp>foo.o</samp>作为中间文件。但是实际上发生的是，这种情况的特殊规则是编译和链接单个<code>cc</code>命令。优化规则优先于分步链使用，因为它在规则排序中排在较早的位置。
</p>
<hr>
<a name="Pattern-Rules"></a>
<div class="header">
<p>下一页： <a href="#Last-Resort" rel="next" accesskey="n">最后一招</a> ，上一篇： <a href="#Chained-Rules" rel="prev" accesskey="p">链式规则</a> ，最多： <a href="#Implicit-Rules" rel="up" accesskey="u">隐含规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Defining-and-Redefining-Pattern-Rules"></a>
<h3 class="section">10.5定义和重新定义模式规则</h3>

<p>您可以通过编写<em>模式规则来</em>定义隐式<em>规则</em> 。模式规则看起来像一条普通规则，只是它的目标包含字符' <samp>%</samp> '（恰好是其中之一）。目标被认为是匹配文件名的模式。 ' <samp>%</samp> '可以匹配任何非空子字符串，而其他字符只能匹配它们自己。前提条件同样使用' <samp>%</samp>以显示其名称与目标名称的关系。
</p>
<p>因此，模式规则“ <samp>%.o : %.c</samp> '说如何制作任何文件<samp><var>stem</var>.o</samp>从另一个文件<samp><var>stem</var>.c</samp> 。
</p>
<p>请注意，使用' <samp>%</samp>模式规则中的'发生<strong>在</strong>任何变量或函数扩展之后，扩展发生在读取makefile时。请参见<a href="#Using-Variables">如何使用变量</a>和<a href="#Functions">函数来转换文本</a> 。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Pattern-Intro" accesskey="1">模式简介</a> ：</td><td>  </td><td align="left" valign="top">模式规则简介。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Examples" accesskey="2">模式示例</a> ：</td><td>  </td><td align="left" valign="top">模式规则的示例。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Automatic-Variables" accesskey="3">自动变量</a> ：</td><td>  </td><td align="left" valign="top">如何在隐式规则的配方中使用自动变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Pattern-Match" accesskey="4">模式匹配</a> ：</td><td>  </td><td align="left" valign="top">模式如何匹配。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Match_002dAnything-Rules" accesskey="5">比赛规则</a> ：</td><td>  </td><td align="left" valign="top">在定义可以匹配任何目标文件的规则之前，应采取的预防措施。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Canceling-Rules" accesskey="6">取消规则</a> ：</td><td>  </td><td align="left" valign="top">如何覆盖或取消内置规则。
</td></tr>
</tbody></table>

<hr>
<a name="Pattern-Intro"></a>
<div class="header">
<p>下一页： <a href="#Pattern-Examples" rel="next" accesskey="n">模式示例</a> ，上一篇： <a href="#Pattern-Examples" rel="next" accesskey="n">模式</a> <a href="#Pattern-Rules" rel="prev" accesskey="p">规则</a> ，上一篇： <a href="#Pattern-Examples" rel="next" accesskey="n">模式</a> <a href="#Pattern-Rules" rel="up" accesskey="u">规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Introduction-to-Pattern-Rules"></a>
<h4 class="subsection">10.5.1模式规则简介</h4>
<a name="index-pattern-rule"></a>
<a name="index-rule_002c-pattern"></a>

<p>模式规则包含字符“ <samp>%</samp> '（恰好是其中之一）在目标中；否则，它看起来就像一条普通规则。目标是用于匹配文件名的模式； ' <samp>%</samp> '与任何非空子字符串匹配，而其他字符仅与它们自己匹配。
<a name="index-target-pattern_002c-implicit"></a>
<a name="index-_0025_002c-in-pattern-rules"></a>
</p>
<p>例如， ' <samp>%.c</samp> '作为模式匹配以'结尾的任何文件名<samp>.c</samp> '。 ' <samp>s.%.c</samp> '作为模式匹配与以'开头的任何文件名<samp>s.</samp> '，以'结尾<samp>.c</samp> '，并且至少五个字符。（必须至少有一个字符才能与' <samp>%</samp> '。）“ <samp>%</samp>比赛被称为<em>茎</em> 。
</p>
<p>' <samp>%</samp> '在模式规则的前提下，代表与'相匹配的词干<samp>%</samp>在目标中。为了应用模式规则，其目标模式必须与所考虑的文件名匹配，并且其所有先决条件（在模式替换之后）必须命名存在的或可以创建的文件。这些文件成为目标的先决条件。
<a name="index-prerequisite-pattern_002c-implicit"></a>
</p>
<p>因此，形式规则</p>
<div class="example">
<pre class="example">%.o : %.c ; <var>recipe</var>&hellip;
</pre></div>

<p>指定如何制作文件<samp><var>n</var>.o</samp> ，以及另一个文件<samp><var>n</var>.c</samp>作为前提，前提是<samp><var>n</var>.c</samp>存在或可以制造。
</p>
<p>可能还存在一些不使用“ <samp>%</samp> ';这样的先决条件会附加到此模式规则生成的每个文件中。这些不变的前提条件有时会有用。
</p>
<p>模式规则不必具有包含“ <samp>%</samp> ”，或者实际上没有任何先决条件。这样的规则实际上是通用通配符。它提供了一种制作与目标模式匹配的文件的方法。参见“ <a href="#Last-Resort">最后的手段”</a> 。
</p>
<p>可能有多个模式规则与目标匹配。在这种情况下<code>make</code>将选择“最适合”规则。请参阅<a href="#Pattern-Match">模式匹配</a> 。
</p>
<p>模式规则可能有多个目标。与普通规则不同，这不会像具有相同先决条件和配方的许多不同规则一样起作用。如果模式规则有多个目标， <code>make</code>知道规则的配方负责制定所有目标。配方仅执行一次即可构成所有目标。当搜索与目标匹配的模式规则时，除与需要规则的目标匹配的规则以外，其他规则的目标模式是偶然的： <code>make</code>仅担心为当前存在问题的文件提供配方和前提条件。但是，当运行该文件的配方时，其他目标将被标记为自身已更新。
<a name="index-multiple-targets_002c-in-pattern-rule"></a>
<a name="index-target_002c-multiple-in-pattern-rule"></a>
</p>
<hr>
<a name="Pattern-Examples"></a>
<div class="header">
<p>下一篇： <a href="#Automatic-Variables" rel="next" accesskey="n">自动变量</a> ，上一篇： <a href="#Pattern-Intro" rel="prev" accesskey="p">模式介绍</a> ，上一篇： <a href="#Pattern-Rules" rel="up" accesskey="u">模式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Pattern-Rule-Examples"></a>
<h4 class="subsection">10.5.2模式规则示例</h4>

<p>这是实际上在<code>make</code> 。首先，编译“ <samp>.c</samp>将文件“ <samp>.o</samp> '个文件：</p>
<div class="example">
<pre class="example">%.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</pre></div>

<p>定义可以制作任何文件的规则<samp><var>x</var>.o</samp>从<samp><var>x</var>.c</samp> 。配方使用自动变量' <samp>$@</samp> '和' <samp>$<</samp> '，以在适用规则的每种情况下替换目标文件和源文件的名称（请参见<a href="#Automatic-Variables">自动变量</a> ）。
</p>
<p>这是第二条内置规则：</p>
<div class="example">
<pre class="example">% :: RCS/%,v
        $(CO) $(COFLAGS) $&lt;
</pre></div>

<p>定义可以制作任何文件的规则<samp><var>x</var></samp>来自相应文件的任何内容<samp><var>x</var>,v</samp>在子目录中<samp>RCS</samp> 。由于目标是<samp>%</samp> '，只要存在适当的先决条件文件，此规则将适用于任何文件。双冒号使规则成为<em>终端</em> ，这意味着其前提条件可能不是中间文件（请参阅“ <a href="#Match_002dAnything-Rules">匹配任何样式规则”</a> ）。
</p>
<p>该模式规则有两个目标：</p>
<div class="example">
<pre class="example">%.tab.c %.tab.h: %.y
        bison -d $&lt;
</pre></div>

<p>这说明<code>make</code>那个食谱<samp>bison -d <var>x</var>.y</samp> '将使<samp><var>x</var>.tab.c</samp>和<samp><var>x</var>.tab.h</samp> 。如果文件<samp>foo</samp>取决于文件<samp>parse.tab.o</samp>和<samp>scan.o</samp>和文件<samp>scan.o</samp>取决于文件<samp>parse.tab.h</samp> ， 什么时候<samp>parse.y</samp>改变了，食谱“ <samp>bison -d parse.y</samp> '将仅执行一次，并且两者的先决条件<samp>parse.tab.o</samp>和<samp>scan.o</samp>会满意的。（大概是文件<samp>parse.tab.o</samp>将重新编译<samp>parse.tab.c</samp>和文件<samp>scan.o</samp>从<samp>scan.c</samp> ，而<samp>foo</samp>从链接<samp>parse.tab.o</samp> ， <samp>scan.o</samp> ，以及它的其他先决条件，此后它就会愉快地执行。）
</p>
<hr>
<a name="Automatic-Variables"></a>
<div class="header">
<p>下一个： <a href="#Pattern-Match" rel="next" accesskey="n">模式匹配</a> ，上一个： <a href="#Pattern-Examples" rel="prev" accesskey="p">模式示例</a> ，上一个： <a href="#Pattern-Rules" rel="up" accesskey="u">模式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Automatic-Variables-1"></a>
<h4 class="subsection">10.5.3自动变量</h4>
<a name="index-automatic-variables"></a>
<a name="index-variables_002c-automatic"></a>
<a name="index-variables_002c-and-implicit-rule"></a>

<p>假设您正在编写模式规则来编译“ <samp>.c</samp>将文件“ <samp>.o</samp> '文件：您如何编写' <samp>cc</samp>命令，以使其在正确的源文件名上运行？您不能在配方中写入名称，因为每次应用隐式规则时名称都会不同。
</p>
<p>您要做的是使用以下功能<code>make</code> ， <em>自动变量</em> 。这些变量具有根据规则的目标和前提条件为所执行的每个规则重新计算的值。在此示例中，您将使用“ <samp>$@</samp> '为目标文件名，' <samp>$<</samp> '作为源文件名。
</p>
<a name="index-automatic-variables-in-prerequisites"></a>
<a name="index-prerequisites_002c-and-automatic-variables"></a>
<p>认识到自动变量值可用的有限范围非常重要：它们仅在配方中具有值。特别是，您不能在规则的目标列表中的任何位置使用它们。它们在那里没有值，并将扩展为空字符串。同样，不能在规则的先决条件列表中直接访问它们。常见的错误是尝试使用<code>$@</code>在先决条件列表中；这是行不通的。但是，GNU有一个特殊功能<code>make</code> ，辅助扩展（请参阅<a href="#Secondary-Expansion">Secondary Expansion</a> ），这将允许在先决条件列表中使用自动变量值。
</p>
<p>这是一个自动变量表：</p>
<dl compact>
<dd><a name="index-_0024_0040"></a>
<a name="index-_0040-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$@</code></dt>
<dd><p>规则目标的文件名。如果目标是存档成员，则“ <samp>$@</samp> '是存档文件的名称。在具有多个目标的模式规则中（请参见<a href="#Pattern-Intro">模式规则简介</a> ），“ <samp>$@</samp> '是导致运行规则配方的任何目标的名称。
</p>
<a name="index-_0024_0025"></a>
<a name="index-_0025-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$%</code></dt>
<dd><p>当目标是存档成员时，目标成员名称。参见<a href="#Archives">档案</a> 。例如，如果目标是<samp>foo.a(bar.o)</samp>然后 ' <samp>$%</samp> '是<samp>bar.o</samp>和' <samp>$@</samp> '是<samp>foo.a</samp> 。 ' <samp>$%</samp>如果目标不是存档成员，则'为空。
</p>
<a name="index-_0024_003c"></a>
<a name="index-_003c-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$<</code></dt>
<dd><p>第一个先决条件的名称。如果目标从隐式规则中获取其配方，这将是隐式规则添加的第一个先决条件（请参见<a href="#Implicit-Rules">隐式规则</a> ）。
</p>
<a name="index-_0024_003f"></a>
<a name="index-_003f-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$?</code></dt>
<dd><p>比目标更新的所有先决条件的名称，它们之间有空格。对于作为存档成员的先决条件，仅使用命名成员（请参见<a href="#Archives">Archives</a> ）。
<a name="index-prerequisites_002c-list-of-changed"></a>
<a name="index-list-of-changed-prerequisites"></a>
</p>
<a name="index-_0024_005e"></a>
<a name="index-_005e-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$^</code></dt>
<dd><p>所有先决条件的名称，它们之间有空格。对于作为存档成员的先决条件，仅使用命名成员（请参见<a href="#Archives">Archives</a> ）。一个目标对它依赖的每个其他文件只有一个先决条件，无论每个文件被列为先决条件的次数是多少。因此，如果您多次列出目标的先决条件，则<code>$^</code>仅包含该名称的一个副本。此列表<strong>不</strong>包含任何订单仅先决条件;对于那些看到' <samp>$|</samp> '变量，如下所示。
<a name="index-prerequisites_002c-list-of-all"></a>
<a name="index-list-of-all-prerequisites"></a>
</p>
<a name="index-_0024_002b"></a>
<a name="index-_002b-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$+</code></dt>
<dd><p>这就像<samp>$^</samp> '，但多次列出的先决条件按照在makefile中列出的顺序重复。这对于在链接命令时很有用，在链接命令中有必要按特定顺序重复库文件名。
</p>
<a name="index-_0024_007c"></a>
<a name="index-_007c-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$|</code></dt>
<dd><p>所有仅订购先决条件的名称，它们之间有空格。
</p>
<a name="index-_0024_002a"></a>
<a name="index-_002a-_0028automatic-variable_0029"></a>
</dd>
<dt><code>$*</code></dt>
<dd><p>隐式规则与之匹配的词干（请参见<a href="#Pattern-Match">模式匹配</a> ）。如果目标是<samp>dir/a.foo.b</samp>而目标模式是<samp>a.%.b</samp>那么词干是<samp>dir/foo</samp> 。茎对于构造相关文件的名称很有用。
<a name="index-stem_002c-variable-for"></a>
</p>
<p>在静态模式规则中，词干是与“ <samp>%</samp>在目标模式中。
</p>
<p>在明确的规则中，没有词干；所以<samp>$*</samp>无法以这种方式确定。相反，如果目标名称以公认的后缀结尾（请参见“ <a href="#Suffix-Rules">老式后缀规则”</a> ），则“ <samp>$*</samp> '设置为目标名称减去后缀。例如，如果目标名称是“ <samp>foo.c</samp> '， 然后 ' <samp>$*</samp> ' 被设定为 ' <samp>foo</samp> '，因为' <samp>.c</samp> '是后缀。GNU <code>make</code>这样做仅仅是为了与其他实现兼容<code>make</code> 。您通常应该避免使用' <samp>$*</samp> '，但隐式规则或静态模式规则除外。
</p>
<p>如果显式规则中的目标名称未以公认的后缀结尾，则“ <samp>$*</samp> '设置为该规则的空字符串。
</p></dd>
</dl>

<p>' <samp>$?</samp>当您只希望对已更改的先决条件进行操作时，即使在显式规则中也很有用。例如，假设有一个名为<samp>lib</samp>应该包含几个目标文件的副本。此规则仅将更改后的目标文件复制到存档中：</p>
<div class="example">
<pre class="example">lib: foo.o bar.o lose.o win.o
        ar r lib $?
</pre></div>

<p>在上面列出的变量中，四个具有作为单个文件名的值，三个具有作为文件名列表的值。这七个变量具有仅获取文件目录名称或仅获取目录内文件名称的变体。变体变量的名称通过附加' <samp>D</samp> ' 要么 ' <samp>F</samp> '， 分别。这些变体在GNU中已经过时<code>make</code>由于职能<code>dir</code>和<code>notdir</code>可以用来获得类似的效果（请参阅<a href="#File-Name-Functions">文件名的功能</a> ）。不过请注意， <samp>D</samp> '变体都省略了总是在<code>dir</code>功能。这是变体表：</p>
<dl compact>
<dd><a name="index-_0024_0028_0040D_0029"></a>
<a name="index-_0040D-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(@D)</samp> '</dt>
<dd><p>目标文件名的目录部分，除去了斜杠。如果' <samp>$@</samp> '是<samp>dir/foo.o</samp>然后 ' <samp>$(@D)</samp> '是<samp>dir</samp> 。这个值是<samp>.</samp>如果<samp>$@</samp> '不包含斜线。
</p>
<a name="index-_0024_0028_0040F_0029"></a>
<a name="index-_0040F-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(@F)</samp> '</dt>
<dd><p>目标文件名的目录中文件部分。如果' <samp>$@</samp> '是<samp>dir/foo.o</samp>然后 ' <samp>$(@F)</samp> '是<samp>foo.o</samp> 。 ' <samp>$(@F)</samp> '等价于' <samp>$(notdir $@)</samp> '。
</p>
<a name="index-_0024_0028_002aD_0029"></a>
<a name="index-_002aD-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(*D)</samp> '</dt>
<dd><a name="index-_0024_0028_002aF_0029"></a>
<a name="index-_002aF-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(*F)</samp> '</dt>
<dd><p>主干的目录部分和目录内文件部分； <samp>dir</samp>和<samp>foo</samp>在这个例子中。
</p>
<a name="index-_0024_0028_0025D_0029"></a>
<a name="index-_0025D-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(%D)</samp> '</dt>
<dd><a name="index-_0024_0028_0025F_0029"></a>
<a name="index-_0025F-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(%F)</samp> '</dt>
<dd><p>目标归档成员名称的目录部分和目录内文件部分。这仅对表单的存档成员目标有意义<samp><var>archive</var>(<var>member</var>)</samp>并且仅在以下情况下有用<var>member</var>可能包含目录名称。（请参阅将<a href="#Archive-Members">存档成员作为目标</a> 。）
</p>
<a name="index-_0024_0028_003cD_0029"></a>
<a name="index-_003cD-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(<D)</samp> '</dt>
<dd><a name="index-_0024_0028_003cF_0029"></a>
<a name="index-_003cF-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(<F)</samp> '</dt>
<dd><p>第一个先决条件的目录部分和目录内文件部分。
</p>
<a name="index-_0024_0028_005eD_0029"></a>
<a name="index-_005eD-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(^D)</samp> '</dt>
<dd><a name="index-_0024_0028_005eF_0029"></a>
<a name="index-_005eF-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(^F)</samp> '</dt>
<dd><p>所有先决条件的目录部分和目录中文件的列表。
</p>
<a name="index-_0024_0028_002bD_0029"></a>
<a name="index-_002bD-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(+D)</samp> '</dt>
<dd><a name="index-_0024_0028_002bF_0029"></a>
<a name="index-_002bF-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(+F)</samp> '</dt>
<dd><p>所有必备组件的目录部分和目录内文件部分的列表，包括重复的必备组件的多个实例。
</p>
<a name="index-_0024_0028_003fD_0029"></a>
<a name="index-_003fD-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(?D)</samp> '</dt>
<dd><a name="index-_0024_0028_003fF_0029"></a>
<a name="index-_003fF-_0028automatic-variable_0029"></a>
</dd>
<dt>' <samp>$(?F)</samp> '</dt>
<dd><p>比目标更新的所有先决条件的目录部分和目录中文件的列表。
</p></dd>
</dl>

<p>请注意，在讨论这些自动变量时，我们使用特殊的样式约定。我们写“的价值<samp>$<</samp> '”，而不是“变量<code><</code> ” <!-- /@w -->就像我们为普通变量（例如<code>objects</code>和<code>CFLAGS</code> 。我们认为这种约定在这种特殊情况下看起来更加自然。请不要认为它具有深远的意义； ' <samp>$<</samp> '指代名为<code><</code>就像 ' <samp>$(CFLAGS)</samp> '指代名为<code>CFLAGS</code> 。您也可以使用' <samp>$(<)</samp>代替<samp>$<</samp> '。
</p>
<hr>
<a name="Pattern-Match"></a>
<div class="header">
<p>下一篇： <a href="#Match_002dAnything-Rules" rel="next" accesskey="n">匹配规则</a> ，上一篇： <a href="#Automatic-Variables" rel="prev" accesskey="p">自动变量</a> ，上一篇： <a href="#Pattern-Rules" rel="up" accesskey="u">模式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-Patterns-Match"></a>
<h4 class="subsection">10.5.4模式如何匹配</h4>

<a name="index-stem-1"></a>
<p>目标模式由“ <samp>%</samp>在前缀和后缀之间，两者之一或两者都可以为空。仅当文件名以前缀开头和后缀（无重叠）时，该模式才与文件名匹配。前缀和后缀之间的文本称为<em>茎</em> 。因此，当模式“ <samp>%.o</samp> '与文件名匹配<samp>test.o</samp> ，词干是“ <samp>test</samp> '。通过将词干替换为字符'，将模式规则先决条件转换为实际文件名<samp>%</samp> '。因此，如果在同一示例中，前提条件之一写为“ <samp>%.c</samp> '，它扩展为' <samp>test.c</samp> '。
</p>
<p>如果目标模式不包含斜杠（通常不包含斜杠），则在将文件名中的目录名与目标前缀和后缀进行比较之前，将从文件名中删除该目录名。在将文件名与目标模式进行比较之后，将目录名以及以它们结尾的斜杠添加到根据模式规则的先决条件模式和文件名生成的先决条件文件名上。仅出于查找要使用的隐式规则的目的而忽略目录，而不是在该规则的应用程序中忽略目录。因此， <samp>e%t</samp> '与文件名匹配<samp>src/eat</samp> ，带有“ <samp>src/a</samp> '作为词干。将先决条件转换为文件名后，词干中的目录将添加到最前面，而词干的其余部分将替换为' <samp>%</samp> '。茎' <samp>src/a</samp> '具有先决条件模式' <samp>c%r</samp> '给出文件名<samp>src/car</samp> 。
</p>
<a name="index-pattern-rules_002c-order-of"></a>
<a name="index-order-of-pattern-rules"></a>
<p>仅当存在与文件名匹配的目标模式<em>并且</em>该规则中的所有必备条件都存在或可以构建时，才可以使用模式规则来构建给定文件。您编写的规则优先于内置规则。但是，请注意，其先决条件实际上存在或被提及的规则始终比具有必须通过链接其他隐式规则来制定的先决条件的规则优先。
</p>
<a name="index-stem_002c-shortest"></a>
<p>一个以上的模式规则可能会满足这些条件。在这种情况下， <code>make</code>将选择词干最短的规则（即最匹配的模式）。如果多个规则规则的词干最短， <code>make</code>将选择在makefile中找到的第一个。
</p>
<p>这种算法导致更具体的规则比更通用的规则更可取。例如：</p>
<div class="example">
<pre class="example">%.o: %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@

%.o : %.f
        $(COMPILE.F) $(OUTPUT_OPTION) $&lt;

lib/%.o: lib/%.c
        $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</pre></div>

<p>给出这些规则并要求建立<samp>bar.o</samp>两者都<samp>bar.c</samp>和<samp>bar.f</samp>存在， <code>make</code>将选择第一个规则并进行编译<samp>bar.c</samp>进入<samp>bar.o</samp> 。在相同情况下<samp>bar.c</samp>不存在，那么<code>make</code>将选择第二条规则并进行编译<samp>bar.f</samp>进入<samp>bar.o</samp> 。
</p>
<p>如果<code>make</code>被要求建造<samp>lib/bar.o</samp>和两者<samp>lib/bar.c</samp>和<samp>lib/bar.f</samp>存在，则将选择第三条规则，因为该规则的词干（' <samp>bar</samp> '）比第一个规则的茎短（' <samp>lib/bar</samp> '）。如果<samp>lib/bar.c</samp>如果不存在，则即使主干较长，也将不符合第三条规则，并且将使用第二条规则。
</p>
<hr>
<a name="Match_002dAnything-Rules"></a>
<div class="header">
<p>下一个： <a href="#Canceling-Rules" rel="next" accesskey="n">取消规则</a> ，上一个： <a href="#Pattern-Match" rel="prev" accesskey="p">模式匹配</a> ，上一个： <a href="#Pattern-Rules" rel="up" accesskey="u">模式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Match_002dAnything-Pattern-Rules"></a>
<h4 class="subsection">10.5.5任何匹配模式规则</h4>

<a name="index-match_002danything-rule"></a>
<a name="index-terminal-rule"></a>
<p>当模式规则的目标只是“ <samp>%</samp> '，它匹配任何文件名。我们称这些规则<em>为“任何条件都匹配”</em> 。它们非常有用，但是可能要花很多时间<code>make</code>考虑一下，因为它必须针对列出的每个文件名（作为目标或先决条件）考虑所有此类规则。
</p>
<p>假设makefile提到<samp>foo.c</samp> 。对于这个目标， <code>make</code>将不得不考虑通过链接目标文件来实现<samp>foo.c.o</samp> ，或者通过C编译和链接从<samp>foo.c.c</samp> ，或通过Pascal编译链接<samp>foo.c.p</samp> ，以及许多其他可能性。
</p>
<p>我们知道这些可能性是荒谬的，因为<samp>foo.c</samp>是C源文件，不是可执行文件。如果<code>make</code>确实考虑了这些可能性，最终将拒绝它们，因为诸如<samp>foo.c.o</samp>和<samp>foo.c.p</samp>将不存在。但是这些可能性是如此之多，以至于<code>make</code>如果必须考虑它们，它将运行非常缓慢。
</p>
<p>为了提高速度，我们在道路上设置了各种约束<code>make</code>考虑任何匹配规则。可以应用两种不同的约束，并且每次定义任何匹配规则时，都必须为该规则选择一个或另一个。
</p>
<p>一种选择是通过用双冒号定义任何匹配项规则将其标记为<em>终止</em> 。当规则为终止规则时，除非其先决条件确实存在，否则该规则将不适用。其他隐式规则可能会产生的前提条件还不够好。换句话说，不允许超出最终规则的进一步链接。
</p>
<p>例如，用于从RCS和SCCS文件提取源的内置隐式规则是终端；结果，如果文件<samp>foo.c,v</samp>不存在， <code>make</code>甚至不会考虑尝试将其作为来自<samp>foo.c,v.o</samp>或来自<samp>RCS/SCCS/s.foo.c,v</samp> 。RCS和SCCS文件通常是最终的源文件，不应从任何其他文件中复制它们。因此， <code>make</code>无需寻找重新制作的方法，可以节省时间。
</p>
<p>如果未将任何匹配规则标记为终止，则该规则为非终止。非终结符匹配规则不能应用于指示特定数据类型的文件名。如果某些不匹配的隐式规则目标与之匹配，则文件名指示特定的数据类型。
</p>
<p>例如，文件名<samp>foo.c</samp>匹配模式规则的目标' <samp>%.c : %.y</samp> '（运行Yacc的规则）。无论此规则是否实际适用（仅当存在文件时才会发生<samp>foo.y</samp> ），则其目标匹配项足以防止考虑该文件的任何非最终匹配项-任何规则<samp>foo.c</samp> 。从而， <code>make</code>甚至不会考虑尝试<samp>foo.c</samp>作为来自的可执行文件<samp>foo.c.o</samp> ， <samp>foo.c.c</samp> ， <samp>foo.c.p</samp>等</p>
<p>产生这种约束的动机是，使用非终端匹配规则来制作包含特定类型数据的文件（例如可执行文件），并且带有识别后缀的文件名表示其他特定类型的数据（例如C源文件）。
</p>
<p>专门提供了内置的虚拟模式规则，以仅识别某些文件名，因此将不考虑任何非终端匹配规则。这些虚拟规则没有先决条件和配方，并且出于所有其他目的而被忽略。例如，内置隐式规则</p>
<div class="example">
<pre class="example">%.p :
</pre></div>

<p>存在以确保Pascal源文件如<samp>foo.p</samp>匹配特定的目标模式，从而避免浪费时间寻找<samp>foo.p.o</samp>要么<samp>foo.p.c</samp> 。
</p>
<p>虚拟图案规则，例如“ <samp>%.p</samp>对于列出的在后缀规则中有效使用的所有后缀（请参见“ <a href="#Suffix-Rules">老式后缀规则”</a> ）进行。
</p>
<hr>
<a name="Canceling-Rules"></a>
<div class="header">
<p>上一篇： <a href="#Match_002dAnything-Rules" rel="prev" accesskey="p">比赛规则</a> ，上一篇： <a href="#Pattern-Rules" rel="up" accesskey="u">模式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Canceling-Implicit-Rules"></a>
<h4 class="subsection">10.5.6取消隐式规则</h4>

<p>您可以通过定义具有相同目标和先决条件但配方不同的新模式规则来覆盖内置的隐式规则（或您自己定义的隐式规则）。定义新规则后，将替换内置规则。新规则在隐式规则序列中的位置由编写新规则的位置确定。
</p>
<p>您可以通过定义具有相同目标和先决条件但没有配方的模式规则来取消内置的隐式规则。例如，以下将取消运行汇编程序的规则：</p>
<div class="example">
<pre class="example">%.o : %.s
</pre></div>

<hr>
<a name="Last-Resort"></a>
<div class="header">
<p>下一个： <a href="#Suffix-Rules" rel="next" accesskey="n">后缀规则</a> ，上一个： <a href="#Pattern-Rules" rel="prev" accesskey="p">模式规则</a> ，上一个： <a href="#Implicit-Rules" rel="up" accesskey="u">隐式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Defining-Last_002dResort-Default-Rules"></a>
<h3 class="section">10.6定义最后一个默认规则</h3>
<a name="index-last_002dresort-default-rules"></a>
<a name="index-default-rules_002c-last_002dresort"></a>

<p>您可以通过编写没有任何先决条件的终端“任何条件<a href="#Match_002dAnything-Rules">匹配”</a>模式规则来定义最后一种隐式规则（请参阅“任何条件<a href="#Match_002dAnything-Rules">匹配规则”</a> ）。就像其他任何模式规则一样；唯一的特别之处在于它将匹配任何目标。因此，此类规则的配方可用于所有没有自己的配方且不适用其他隐式规则的目标和先决条件。
</p>
<p>例如，在测试Makefile时，您可能并不在意源文件是否包含真实数据，而仅包含真实数据。然后，您可以这样做：</p>
<div class="example">
<pre class="example">%::
        touch $@
</pre></div>

<p>使所有需要的源文件（作为先决条件）自动创建。
</p>
<a name="index-_002eDEFAULT-1"></a>
<p>相反，您可以定义要用于完全没有规则的目标的配方，甚至没有指定配方的目标。您可以通过为目标编写规则来做到这一点<code>.DEFAULT</code> 。此类规则的配方用于所有前提条件，这些前提条件在任何显式规则中均不显示为目标，并且不适用任何隐含规则。自然地，没有<code>.DEFAULT</code>除非你写一个。
</p>
<p>如果您使用<code>.DEFAULT</code>没有配方或先决条件：</p>
<div class="example">
<pre class="example">.DEFAULT:
</pre></div>

<p>先前存储的配方<code>.DEFAULT</code>已清除。然后<code>make</code>就像您从未定义过的一样<code>.DEFAULT</code>完全没有
</p>
<p>如果您不希望目标从任何匹配模式规则中获取配方，或者<code>.DEFAULT</code> ，但您也不想为目标运行任何配方，可以给它一个空配方（请参阅<a href="#Empty-Recipes">定义空配方</a> ）。
</p>
<p>您可以使用last-resort规则来覆盖另一个makefile的一部分。请参见<a href="#Overriding-Makefiles">覆盖另一个Makefile的一部分</a> 。
</p>
<hr>
<a name="Suffix-Rules"></a>
<div class="header">
<p>下一页： <a href="#Implicit-Rule-Search" rel="next" accesskey="n">隐含规则搜寻</a> ，上一篇： <a href="#Last-Resort" rel="prev" accesskey="p">最后手段</a> ，最多： <a href="#Implicit-Rules" rel="up" accesskey="u">隐含规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Old_002dFashioned-Suffix-Rules"></a>
<h3 class="section">10.7老式的后缀规则</h3>
<a name="index-old_002dfashioned-suffix-rules"></a>
<a name="index-suffix-rule"></a>

<p><em>后缀规则</em>是为以下项定义隐式规则的老式方法<code>make</code> 。后缀规则已过时，因为模式规则更加通用和清晰。它们在GNU中受支持<code>make</code>与旧的makefile兼容。它们有两种： <em>双后缀</em>和<em>单后缀</em> 。
</p>
<p>双后缀规则由一对后缀定义：目标后缀和源后缀。它匹配名称以目标后缀结尾的任何文件。相应的隐式先决条件是通过在文件名中用源后缀替换目标后缀。目标和源后缀为'的两个后缀规则<samp>.o</samp> '和' <samp>.c</samp> '等同于模式规则' <samp>%.o : %.c</samp> '。
</p>
<p>一个后缀规则由一个后缀定义，即源后缀。它与任何文件名匹配，并且通过附加源后缀来创建相应的隐式先决条件名称。源后缀为'的单后缀规则<samp>.c</samp> '等同于模式规则' <samp>% : %.c</samp> '。
</p>
<p>通过将每个规则的目标与已定义的已知后缀列表进行比较，可以识别后缀规则定义。什么时候<code>make</code>看到目标是已知后缀的规则，该规则被视为单后缀规则。什么时候<code>make</code>看到目标是两个已知后缀串联的规则，该规则被视为双后缀规则。
</p>
<p>例如， ' <samp>.c</samp> '和' <samp>.o</samp>都在已知后缀的默认列表中。因此，如果您定义的目标是“ <samp>.c.o</samp> '， <code>make</code>将其作为带有源后缀'的双后缀规则<samp>.c</samp> '和目标后缀' <samp>.o</samp> '。这是定义用于编译C源文件的规则的老式方法：</p>
<div class="example">
<pre class="example">.c.o:
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</pre></div>

<p>后缀规则不能具有任何先决条件。如果有的话，它们将被视为带有有趣名称的普通文件，而不是后缀规则。因此，规则：</p>
<div class="example">
<pre class="example">.c.o: foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</pre></div>

<p>告诉如何制作文件<samp>.c.o</samp>从必备文件中<samp>foo.h</samp> ，根本不像模式规则：</p>
<div class="example">
<pre class="example">%.o: %.c foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</pre></div>

<p>告诉您如何制作“ <samp>.o</samp>来自“的文件<samp>.c</samp> “文件，然后全部” <samp>.o</samp>使用此模式规则的文件也取决于<samp>foo.h</samp> 。
</p>
<p>没有配方的后缀规则也没有意义。它们不会像没有规则的模式规则一样删除先前的规则（请参阅<a href="#Canceling-Rules">取消隐式规则</a> ）。他们只需输入在数据库中串联为目标的后缀或后缀对。
</p>
<a name="index-_002eSUFFIXES-1"></a>
<p>已知的后缀只是特殊目标的先决条件的名称<code>.SUFFIXES</code> 。您可以通过编写以下规则来添加自己的后缀<code>.SUFFIXES</code>这增加了更多先决条件，例如：</p>
<div class="example">
<pre class="example">.SUFFIXES: .hack .win
</pre></div>

<p>其中添加了“ <samp>.hack</samp> '和' <samp>.win</samp> '到后缀列表的末尾。
</p>
<p>如果您想消除默认的已知后缀而不是仅添加默认后缀，请为<code>.SUFFIXES</code>没有任何先决条件。通过特殊分配，这消除了所有现有的前提条件<code>.SUFFIXES</code> 。然后，您可以编写另一个规则以添加所需的后缀。例如，</p>
<div class="example">
<pre class="example">.SUFFIXES:            # <span class="roman">Delete the default suffixes</span>
.SUFFIXES: .c .o .h   # <span class="roman">Define our suffix list</span>
</pre></div>

<p>' <samp>-r</samp> ' 要么 ' <samp>--no-builtin-rules</samp> '标志使默认的后缀列表为空。
</p>
<a name="index-SUFFIXES"></a>
<p>变量<code>SUFFIXES</code>定义为默认的后缀列表<code>make</code>读取任何makefile。您可以使用特殊目标的规则更改后缀列表<code>.SUFFIXES</code> ，但这不会更改此变量。
</p>
<hr>
<a name="Implicit-Rule-Search"></a>
<div class="header">
<p>上一页： <a href="#Suffix-Rules" rel="prev" accesskey="p">后缀规则</a> ，向上： <a href="#Implicit-Rules" rel="up" accesskey="u">隐式规则</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Implicit-Rule-Search-Algorithm"></a>
<h3 class="section">10.8隐式规则搜索算法</h3>
<a name="index-implicit-rule_002c-search-algorithm"></a>
<a name="index-search-algorithm_002c-implicit-rule"></a>

<p>这是程序<code>make</code>用于搜索目标的隐式规则<var>t</var> 。对于没有配方的每个双冒号规则，没有配方的普通规则的每个目标以及不是任何规则的目标的每个先决条件，都遵循此过程。在搜索规则链时，它还会递归地遵循来自隐式规则的先决条件。
</p>
<p>后缀规则未在此算法中提及，因为一旦读入了makefile，后缀规则就会转换为等效的模式规则。
</p>
<p>对于“ <samp><var>archive</var>(<var>member</var>)</samp> '，以下算法将运行两次，首先使用整个目标名称<var>t</var> ，然后使用' <samp>(<var>member</var>)</samp>以目标为准<var>t</var>如果第一次运行没有规则。
</p>
<ol>
<li>分裂<var>t</var>进入目录部分，称为<var>d</var> ，其余的称为<var>n</var> 。例如，如果<var>t</var>是' <samp>src/foo.o</samp> '， 然后<var>d</var>是' <samp>src/</samp> '和<var>n</var>是' <samp>foo.o</samp> '。

</li><li>列出其目标之一与之匹配的所有模式规则的列表<var>t</var>要么<var>n</var> 。如果目标模式包含斜线，则将其与<var>t</var> ;否则，反对<var>n</var> 。

</li><li>如果该列表中的任何规则<em>都不</em>是任何匹配规则，则从列表中删除所有非终端匹配任何规则。

</li><li>从列表中删除所有没有配方的规则。

</li><li>对于列表中的每个模式规则：<ol>
<li>找到茎<var>s</var> ，这是的非空部分<var>t</var>要么<var>n</var>与“ <samp>%</samp>在目标模式中。

</li><li>通过代入计算先决条件名称<var>s</var>为<samp>%</samp> ';如果目标模式不包含斜杠，请追加<var>d</var>每个先决条件名称的前面。

</li><li>测试所有先决条件是否存在或应该存在。（如果在makefile中提到文件名作为目标或明确的前提条件，那么我们说它应该存在。）

<p>如果所有先决条件都存在或应该存在，或者没有先决条件，则此规则适用。
</p></li></ol>

</li><li>如果到目前为止尚未找到任何模式规则，请再努力一点。对于列表中的每个模式规则：<ol>
<li>如果该规则是终止规则，请忽略它并继续执行下一个规则。

</li><li>与以前一样计算先决条件名称。

</li><li>测试所有先决条件是否存在或应该存在。

</li><li>对于不存在的每个前提条件，请递归遵循此算法，以查看前提条件是否可以由隐式规则进行。

</li><li>如果所有先决条件都存在，应该存在或可以由隐式规则来满足，则此规则适用。
</li></ol>

</li><li>如果没有适用的隐式规则，则用于<code>.DEFAULT</code> （如果有）适用。在这种情况下，给<var>t</var>相同的食谱<code>.DEFAULT</code>拥有。否则，没有配方<var>t</var> 。
</li></ol>

<p>找到适用的规则后，针对该规则的每个目标模式（不匹配的模式） <var>t</var>要么<var>n</var> ， <samp>%</samp>模式中的'被替换为<var>s</var>并存储结果文件名，直到重新制作目标文件的配方为止<var>t</var>被执行。执行配方后，将这些存储的文件名中的每一个输入数据库，并标记为已更新并具有与文件相同的更新状态<var>t</var> 。
</p>
<p>当执行模式规则的配方时<var>t</var> ，将根据目标和先决条件设置自动变量。请参阅<a href="#Automatic-Variables">自动变量</a> 。
</p>
<hr>
<a name="Archives"></a>
<div class="header">
<p>下一篇： <a href="#Extending-make" rel="next" accesskey="n">扩展make</a> ，上一篇： <a href="#Implicit-Rules" rel="prev" accesskey="p">隐式规则</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Using-make-to-Update-Archive-Files"></a>
<h2 class="chapter">11使用<code>make</code>更新存档文件</h2>
<a name="index-archive"></a>

<p><em>存档文件</em>是包含称为<em>成员的</em>命名子文件的文件。它们与程序一起维护<code>ar</code>它们的主要用途是作为链接的子例程库。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Archive-Members" accesskey="1">存档成员</a> ：</td><td>  </td><td align="left" valign="top">将成员存档为目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Update" accesskey="2">存档更新</a> ：</td><td>  </td><td align="left" valign="top">归档成员目标的隐式规则。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Pitfalls" accesskey="3">存档陷阱</a> ：</td><td>  </td><td align="left" valign="top">使用档案时要当心危险。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Archive-Suffix-Rules" accesskey="4">存档后缀规则</a> ：</td><td>  </td><td align="left" valign="top">您可以编写一种特殊的后缀规则来更新档案。
</td></tr>
</tbody></table>

<hr>
<a name="Archive-Members"></a>
<div class="header">
<p>下一页： <a href="#Archive-Update" rel="next" accesskey="n">归档更新</a> ，上一篇： <a href="#Archives" rel="prev" accesskey="p">档案馆</a> ，向上： <a href="#Archives" rel="up" accesskey="u">档案</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Archive-Members-as-Targets"></a>
<h3 class="section">11.1存档成员作为目标</h3>
<a name="index-archive-member-targets"></a>

<p>归档文件的单个成员可以用作以下目标或先决条件： <code>make</code> 。您指定名为<var>member</var>在存档文件中<var>archive</var>如下：</p>
<div class="example">
<pre class="example"><var>archive</var>(<var>member</var>)
</pre></div>

<p>此构造仅在目标和先决条件中可用，而在配方中不可用！您可能在配方中使用的大多数程序均不支持此语法，并且不能直接对归档成员起作用。只要<code>ar</code>其他专门设计用于存档的程序也可以这样做。因此，可能必须使用有效配方来更新归档成员目标<code>ar</code> 。例如，此规则说要创建一个成员<samp>hack.o</samp>存档中<samp>foolib</samp>通过复制文件<samp>hack.o</samp> ：</p>
<div class="example">
<pre class="example">foolib(hack.o) : hack.o
        ar cr foolib hack.o
</pre></div>

<p>实际上，几乎所有存档成员目标都是以这种方式更新的，并且有一个隐式规则为您完成。<strong>请注意：</strong> <samp>c</samp>标记为<code>ar</code>如果归档文件尚不存在，则为必需。
</p>
<p>要在同一档案中指定多个成员，可以将所有成员名称一起写在括号之间。例如：</p>
<div class="example">
<pre class="example">foolib(hack.o kludge.o)
</pre></div>

<p>等效于：</p>
<div class="example">
<pre class="example">foolib(hack.o) foolib(kludge.o)
</pre></div>

<a name="index-wildcard_002c-in-archive-member"></a>
<p>您也可以在存档成员参考中使用外壳样式通配符。请参见<a href="#Wildcards">在文件名中使用通配符</a> 。例如， ' <samp>foolib(*.o)</samp> ' <!-- /@w -->扩展为<samp>foolib</samp>档案名称以' <samp>.o</samp> ';也许 ' <samp>foolib(hack.o)
<!-- /@w --> foolib(kludge.o)
<!-- /@w --></samp> '。
</p>
<hr>
<a name="Archive-Update"></a>
<div class="header">
<p>下一页： <a href="#Archive-Pitfalls" rel="next" accesskey="n">存档陷阱</a> ，上一篇： <a href="#Archive-Members" rel="prev" accesskey="p">归档成员</a> ，最多： <a href="#Archives" rel="up" accesskey="u">档案</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Implicit-Rule-for-Archive-Member-Targets"></a>
<h3 class="section">11.2存档成员目标的隐式规则</h3>

<p>回想一下看起来像<samp><var>a</var>(<var>m</var>)</samp>代表名为的成员<var>m</var>在存档文件中<var>a</var> 。
</p>
<p>什么时候<code>make</code>查找此类目标的隐式规则，作为一项特殊功能，它认为匹配的隐式规则<samp>(<var>m</var>)</samp>以及与实际目标匹配的那些<samp><var>a</var>(<var>m</var>)</samp> 。
</p>
<p>这导致了一个特殊的规则，其目标是<samp>(%)</samp>匹配。此规则更新目标<samp><var>a</var>(<var>m</var>)</samp>通过复制文件<var>m</var>进入档案。例如，它将更新存档成员目标<samp>foo.a(bar.o)</samp>通过复制<em>文件</em> <samp>bar.o</samp>进入档案<samp>foo.a</samp>作为命名<em>成员</em> <samp>bar.o</samp> 。
</p>
<p>当此规则与其他规则联系在一起时，结果将非常有用。因此， <samp>make "foo.a(bar.o)"</samp> '（需要使用引号保护' <samp>(</samp> '和' <samp>)</samp> '（由外壳程序专门解释）在存在文件的情况下<samp>bar.c</samp>即使没有makefile也足以运行以下配方：</p>
<div class="example">
<pre class="example">cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
</pre></div>

<p>这里<code>make</code>预想了文件<samp>bar.o</samp>作为中间文件。请参阅<a href="#Chained-Rules">隐式规则链</a> 。
</p>
<p>诸如此类的隐式规则是使用自动变量' <samp>$%</samp> '。请参阅<a href="#Automatic-Variables">自动变量</a> 。
</p>
<p>归档文件中的归档文件成员名称不能包含目录名，但是在makefile中假装确实是有用的。如果您编写存档成员目标<samp>foo.a(dir/file.o)</samp> ， <code>make</code>将使用此配方执行自动更新：</p>
<div class="example">
<pre class="example">ar r foo.a dir/file.o
</pre></div>

<p>具有复制文件的效果<samp>dir/file.o</samp>成为一个名为<samp>file.o</samp> 。结合这种用法，自动变量<code>%D</code>和<code>%F</code>可能有用。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Archive-Symbols" accesskey="1">存档符号</a> ：</td><td>  </td><td align="left" valign="top">如何更新档案符号目录。
</td></tr>
</tbody></table>

<hr>
<a name="Archive-Symbols"></a>
<div class="header">
<p>上一篇： <a href="#Archive-Update" rel="prev" accesskey="p">存档更新</a> ，上一篇： <a href="#Archive-Update" rel="up" accesskey="u">存档更新</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Updating-Archive-Symbol-Directories"></a>
<h4 class="subsection">11.2.1更新档案符号目录</h4>
<a name="index-_005f_005f_002eSYMDEF"></a>
<a name="index-updating-archive-symbol-directories"></a>
<a name="index-archive-symbol-directory-updating"></a>
<a name="index-symbol-directories_002c-updating-archive"></a>
<a name="index-directories_002c-updating-archive-symbol"></a>

<p>用作库的存档文件通常包含一个名为<samp>__.SYMDEF</samp>其中包含由所有其他成员定义的外部符号名称的目录。更新任何其他成员后，您需要更新<samp>__.SYMDEF</samp>这样才能正确总结其他成员。这是通过运行<code>ranlib</code>程序：</p>
<div class="example">
<pre class="example">ranlib <var>archivefile</var>
</pre></div>

<p>通常，您会将此命令放在存档文件的规则中，并使存档文件的所有成员成为该规则的先决条件。例如，</p>
<div class="example">
<pre class="example">libfoo.a: libfoo.a(x.o) libfoo.a(y.o) &hellip;
        ranlib libfoo.a
</pre></div>

<p>这样的效果是更新存档成员<samp>x.o</samp> ， <samp>y.o</samp>等等，然后更新符号目录成员<samp>__.SYMDEF</samp>通过运行<code>ranlib</code> 。这里没有显示更新成员的规则；您很有可能可以忽略它们，并使用隐式规则将文件复制到存档中，如上一节所述。
</p>
<p>使用GNU时这不是必需的<code>ar</code>程序，它会更新<samp>__.SYMDEF</samp>自动成为会员。
</p>
<hr>
<a name="Archive-Pitfalls"></a>
<div class="header">
<p>下一页： <a href="#Archive-Suffix-Rules" rel="next" accesskey="n">存档后缀规则</a> ，上一篇： <a href="#Archive-Update" rel="prev" accesskey="p">归档更新</a> ，最多： <a href="#Archives" rel="up" accesskey="u">档案</a> [ <a href="#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Dangers-When-Using-Archives"></a>
<h3 class="section">11.3使用档案时的危险</h3>
<a name="index-archive_002c-and-parallel-execution"></a>
<a name="index-parallel-execution_002c-and-archive-update"></a>
<a name="index-archive_002c-and-_002dj"></a>
<a name="index-_002dj_002c-and-archive-update"></a>

<p>使用并行执行时，请务必小心（ <code>-j</code>开关;请参见<a href="#Parallel">并行执行</a> ）和存档。如果多个<code>ar</code>命令在同一存档文件上同时运行，它们彼此之间将不会相互了解，并可能损坏文件。
</p>
<p>可能是的未来版本<code>make</code>通过序列化对同一归档文件进行操作的所有配方，将提供一种机制来解决此问题。但是暂时，您必须编写makefile来以其他方式避免此问题，或者不使用<code>-j</code> 。
</p>
<hr>
<a name="Archive-Suffix-Rules"></a>
<div class="header">
<p>上一页： <a href="#Archive-Pitfalls" rel="prev" accesskey="p">存档的陷阱</a> ，向上： <a href="#Archives" rel="up" accesskey="u">存档</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Suffix-Rules-for-Archive-Files"></a>
<h3 class="section">11.4存档文件的后缀规则</h3>
<a name="index-suffix-rule_002c-for-archive"></a>
<a name="index-archive_002c-suffix-rule-for"></a>
<a name="index-library-archive_002c-suffix-rule-for"></a>
<a name="index-_002ea-_0028archives_0029"></a>

<p>您可以编写一种特殊的后缀规则来处理存档文件。有关<a href="#Suffix-Rules">后缀规则</a>的完整说明，请参见后缀规则。归档后缀规则在GNU中已过时<code>make</code> ，因为归档的模式规则是一种更通用的机制（请参见<a href="#Archive-Update">Archive Update</a> ）。但是保留它们是为了与其他产品兼容<code>make</code> s。
</p>
<p>要为归档文件编写后缀规则，只需使用目标后缀' <samp>.a</samp> '（存档文件的通常后缀）。例如，这是从C源文件更新库归档文件的老式后缀规则：</p>
<div class="example">
<pre class="example">.c.a:
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o
        $(AR) r $@ $*.o
        $(RM) $*.o
</pre></div>

<p>就像您编写了模式规则一样，它的工作原理如下：</p>
<div class="example">
<pre class="example">(%.o): %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o
        $(AR) r $@ $*.o
        $(RM) $*.o
</pre></div>

<p>实际上，这就是<code>make</code>看到带有“ <samp>.a</samp> '作为目标后缀。任何双后缀规则' <samp>.<var>x</var>.a</samp> ' <!-- /@w -->被转换为具有目标图案的图案规则' <samp>(%.o)</samp> ”和“ <samp>%.<var>x</var></samp> '。
</p>
<p>由于您可能想使用“ <samp>.a</samp> '作为其他类型文件的后缀， <code>make</code>还可以按常规方式将存档后缀规则转换为模式规则（请参阅<a href="#Suffix-Rules">后缀规则</a> ）。因此，双后缀规则“ <samp>.<var>x</var>.a</samp> ' <!-- /@w -->产生两个模式规则：' <samp>(%.o):
<!-- /@w --> %.<var>x</var>
<!-- /@w --></samp> '和' <samp>%.a
<!-- /@w -->: %.<var>x</var>
<!-- /@w --></samp> '。
</p>
<hr>
<a name="Extending-make"></a>
<div class="header">
<p>下一篇： <a href="#Integrating-make" rel="next" accesskey="n">集成make</a> ，上一篇： <a href="#Archives" rel="prev" accesskey="p">存档</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Extending-GNU-make"></a>
<h2 class="chapter">12扩展GNU<code>make</code></h2>
<a name="index-make-extensions"></a>

<p>GNU <code>make</code>提供许多高级功能，包括许多有用的功能。但是，它不包含完整的编程语言，因此具有局限性。有时可以通过使用<code>shell</code>函数来调用一个单独的程序，尽管这样做可能效率低下。
</p>
<p>如果GNU的内置功能<code>make</code>不足以满足您的要求，有两种扩展选择<code>make</code> 。在提供它的系统上，您可以将GNU Guile用作嵌入式脚本语言（请参阅<a href="#Guile-Integration">GNU Guile集成</a> ）。在支持动态加载的对象系统，你可以写在任何语言（可以编译成这样的对象）自己的分机并加载它提供扩展能力（见<a href="#load-Directive">的<code>load</code>指令</a> ）。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Guile-Integration" accesskey="1">Guile集成</a> ：</td><td>  </td><td align="left" valign="top">使用Guile作为嵌入式脚本语言。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loading-Objects" accesskey="2">加载对象</a> ：</td><td>  </td><td align="left" valign="top">加载动态对象作为扩展。
</td></tr>
</tbody></table>

<hr>
<a name="Guile-Integration"></a>
<div class="header">
<p>下一篇： <a href="#Loading-Objects" rel="next" accesskey="n">加载对象</a> ，上一篇： <a href="#Extending-make" rel="prev" accesskey="p">扩展make</a> ，上一篇： <a href="#Extending-make" rel="up" accesskey="u">扩展make</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Guile-Integration"></a>
<h3 class="section">12.1 GNU Guile集成</h3>
<a name="index-Guile-1"></a>
<a name="index-extensions_002c-Guile"></a>

<p>GNU <code>make</code>可以通过支持GNU Guile作为嵌入式扩展语言来构建。Guile实施Scheme语言。对GNU Guile和Scheme语言及其功能的审查不在本手册的范围之内：请参阅GNU Guile和Scheme的文档。
</p>
<p>您可以确定<code>make</code>通过检查<code>.FEATURES</code>变量;它会包含单词<var>guile</var>如果有Guile支持。
</p>
<p>Guile集成提供了一项新功能<code>make</code>功能： <code>guile</code> 。的<code>guile</code>函数采用一个参数，该参数首先由<code>make</code>然后以常规方式传递给GNU Guile评估员。求值器的结果转换为字符串，并用作扩展<code>guile</code>在makefile中的功能。
</p>
<p>另外，GNU <code>make</code>公开了在Guile脚本中使用的Guile过程。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">•指南<a href="#Guile-Types" accesskey="1">类型</a> ：</td><td>  </td><td align="left" valign="top">将Guile类型转换为<code>make</code>字符串。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Interface" accesskey="2">Guile界面</a> ：</td><td>  </td><td align="left" valign="top">调用中<code>make</code>来自Guile的功能。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Guile-Example" accesskey="3">Guile示例</a> ：</td><td>  </td><td align="left" valign="top">在中使用Guile的示例<code>make</code> 。
</td></tr>
</tbody></table>

<hr>
<a name="Guile-Types"></a>
<div class="header">
<p>下一篇： <a href="#Guile-Interface" rel="next" accesskey="n">Guile界面</a> ，上一篇： <a href="#Guile-Interface" rel="next" accesskey="n">Guile</a> <a href="#Guile-Integration" rel="prev" accesskey="p">集成</a> ，上一篇： <a href="#Guile-Interface" rel="next" accesskey="n">Guile</a> <a href="#Guile-Integration" rel="up" accesskey="u">集成</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Conversion-of-Guile-Types"></a>
<h4 class="subsection">12.1.1指导类型的转换</h4>
<a name="index-convert-guile-types"></a>
<a name="index-guile_002c-conversion-of-types"></a>
<a name="index-types_002c-conversion-of"></a>

<p>在其中只有一种“数据类型” <code>make</code> ：一个字符串。另一方面，GNU Guile提供了多种不同的数据类型。界面之间的重要方面<code>make</code> GNU Guile是将Guile数据类型转换为<code>make</code>字符串。
</p>
<p>此转换在两个地方相关：当makefile调用<code>guile</code>函数来评估Guile表达式，该评估的结果必须转换为make字符串，以便可以通过以下方式进一步评估<code>make</code> 。其次，当Guile脚本调用由<code>make</code>提供给过程的参数必须转换为字符串。
</p>
<p>将Guile类型转换为<code>make</code>字符串如下：</p>
<dl compact>
<dt><code>#f</code></dt>
<dd><p>False转换为空字符串：in <code>make</code>有条件的空字符串被认为是假的。
</p>
</dd>
<dt><code>#t</code></dt>
<dd><p>True转换为字符串' <samp>#t</samp> '：在<code>make</code>有条件的将任何非空字符串视为true。
</p>
</dd>
<dt><code>symbol</code></dt>
<dt><code>number</code></dt>
<dd><p>符号或数字将转换为该符号或数字的字符串表示形式。
</p>
</dd>
<dt><code>character</code></dt>
<dd><p>可打印字符将转换为相同字符。
</p>
</dd>
<dt><code>string</code></dt>
<dd><p>仅包含可打印字符的字符串将转换为相同的字符串。
</p>
</dd>
<dt><code>list</code></dt>
<dd><p>根据上述规则递归转换列表。这意味着任何结构化列表都将被展平（即，“ <samp>'(a b (c d) e)</samp> '将转换为<code>make</code>字符串' <samp>a b c d e</samp> '）。
</p>
</dd>
<dt><code>other</code></dt>
<dd><p>任何其他Guile类型都会导致错误。在未来的版本中<code>make</code> ，其他Guile类型可能会被转换。
</p>
</dd>
</dl>

<p>的翻译<samp>#f</samp> '（到空字符串）和' <samp>#t</samp> '（到非空字符串' <samp>#t</samp> '）旨在允许您将Guile布尔结果直接用作<code>make</code>布尔条件。例如：</p>
<div class="example">
<pre class="example">$(if $(guile (access? &quot;myfile&quot; R_OK)),$(info myfile exists))
</pre></div>

<p>由于这些转换规则，您必须考虑Guile脚本的结果，因为该结果将转换为字符串并由<code>make</code> 。如果该脚本没有自然的结果（也就是说，该脚本仅出于其副作用而存在），则应添加“ <samp>#f</samp> '作为最终表达式，以避免makefile中的语法错误。
</p>
<hr>
<a name="Guile-Interface"></a>
<div class="header">
<p>下一篇： <a href="#Guile-Example" rel="next" accesskey="n">Guile示例</a> ，上一篇： <a href="#Guile-Example" rel="next" accesskey="n">Guile</a> <a href="#Guile-Types" rel="prev" accesskey="p">类型</a> ，上一篇： <a href="#Guile-Example" rel="next" accesskey="n">Guile</a> <a href="#Guile-Integration" rel="up" accesskey="u">集成</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Interfaces-from-Guile-to-make"></a>
<h4 class="subsection">12.1.2从Guile到<code>make</code></h4>
<a name="index-make-interface-to-guile"></a>
<a name="index-make-procedures-in-guile"></a>

<p>除了<code>guile</code> makefile中可用的功能， <code>make</code>公开了一些在Guile脚本中使用的过程。在启动时<code>make</code>创建一个新的Guile模块， <code>gnu make</code> ，并将这些过程作为该模块的公共接口导出：</p>
<dl compact>
<dt><code>gmk-expand</code></dt>
<dd><a name="index-gmk_002dexpand"></a>
<p>此过程采用单个参数，该参数将转换为字符串。字符串被扩展为<code>make</code>使用普通<code>make</code>扩展规则。扩展结果将转换为Guile字符串，并作为该过程的结果提供。
</p>
</dd>
<dt><code>gmk-eval</code></dt>
<dd><a name="index-gmk_002deval"></a>
<p>此过程采用单个参数，该参数将转换为字符串。该字符串由<code>make</code>好像它是一个makefile。这与通过<code>eval</code>函数（请参阅<a href="#Eval-Function">评估函数</a> ）。结果<code>gmk-eval</code>过程始终为空字符串。
</p>
<p>注意<code>gmk-eval</code>与使用不太一样<code>gmk-expand</code>与<code>eval</code>函数：在后一种情况下，求值字符串将扩展<em>两次</em> ；首先<code>gmk-expand</code> ，然后再按一次<code>eval</code>功能。
</p>
</dd>
</dl>

<hr>
<a name="Guile-Example"></a>
<div class="header">
<p>上一页： <a href="#Guile-Interface" rel="prev" accesskey="p">Guile界面</a> ，上： <a href="#Guile-Integration" rel="up" accesskey="u">Guile集成</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Example-Using-Guile-in-make"></a>
<h4 class="subsection">12.1.3使用Guile的示例<code>make</code></h4>
<a name="index-Guile-example"></a>
<a name="index-example-using-Guile"></a>

<p>这是一个使用GNU Guile管理写入文件的非常简单的示例。这些Guile过程仅打开文件，允许写入文件（每行一个字符串），然后关闭文件。请注意，因为我们无法将复杂的值（例如Guile端口）存储在<code>make</code>变量，我们将在Guile解释器中将端口保留为全局变量。
</p>
<p>您可以使用以下命令轻松创建Guile函数<code>define</code> / <code>endef</code>创建一个Guile脚本，然后使用<code>guile</code>将其内部化的功能：</p>
<div class="example">
<pre class="example">define GUILEIO
;; A simple Guile IO library for GNU make

(define MKPORT #f)

(define (mkopen name mode)
  (set! MKPORT (open-file name mode))
  #f)

(define (mkwrite s)
  (display s MKPORT)
  (newline MKPORT)
  #f)

(define (mkclose)
  (close-port MKPORT)
  #f)

#f
endef

# Internalize the Guile IO functions
$(guile $(GUILEIO))
</pre></div>

<p>如果您有大量的Guile支持代码，则可以考虑将其保存在其他文件中（例如， <samp>guileio.scm</samp> ），然后使用<code>guile</code>功能：</p>
<div class="example">
<pre class="example">$(guile (load &quot;guileio.scm&quot;))
</pre></div>

<p>这种方法的优点是编辑时<samp>guileio.scm</samp> ，您的编辑器将理解此文件包含Scheme语法而不是makefile语法。
</p>
<p>现在，您可以使用这些Guile函数来创建文件。假设您需要对一个很大的列表进行操作，该列表不能在命令行上显示，但是您使用的实用程序也接受该列表作为输入：</p>
<div class="example">
<pre class="example">prog: $(PREREQS)
        @$(guile (mkopen &quot;tmp.out&quot; &quot;w&quot;)) \
         $(foreach X,$^,$(guile (mkwrite &quot;$(X)&quot;))) \
         $(guile (mkclose))
        $(LINK) &lt; tmp.out
</pre></div>

<p>当然，可以使用一套更全面的文件操作程序。例如，您可以同时维护多个输出文件，方法是为每个输出文件选择一个符号，并将其用作哈希表的键，该哈希表的值是端口，然后返回要存储在文件中的符号。 <code>make</code>变量。
</p>
<hr>
<a name="Loading-Objects"></a>
<div class="header">
<p>上<a href="#Guile-Integration" rel="prev" accesskey="p">一篇</a> ： <a href="#Guile-Integration" rel="prev" accesskey="p">Guile集成</a> ，上<a href="#Guile-Integration" rel="prev" accesskey="p">一篇</a> ： <a href="#Extending-make" rel="up" accesskey="u">扩展make</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Loading-Dynamic-Objects"></a>
<h3 class="section">12.2加载动态对象</h3>
<a name="index-loaded-objects"></a>
<a name="index-objects_002c-loaded"></a>
<a name="index-extensions_002c-loading"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<blockquote>
<p><b>警告：</b> <code>load</code>指令和扩展功能在此GNU make版本中被视为“技术预览”。我们鼓励您尝试使用此功能，并感谢您提供任何反馈。但是，我们不能保证在下一版本中保持向后兼容。考虑使用GNU狡诈，而不是延长使用GNU make（见<a href="#Guile-Function">的<code>guile</code>功能</a> ）。
</p></blockquote>
</td></tr></tbody></table>

<p>许多操作系统提供了用于动态加载编译对象的工具。如果您的系统提供此功能，则GNU <code>make</code>可以利用它在运行时加载动态对象，从而提供新功能，然后可以由您的makefile调用。
</p>
<p>的<code>load</code>指令用于加载动态对象。加载对象后，将调用“设置”功能以允许对象初始化自身并向GNU注册新功能<code>make</code> 。动态对象可能包括新的<code>make</code>例如，“ setup”功能会将其注册到GNU <code>make</code>的功能处理系统。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#load-Directive" accesskey="1">负载指令</a> ：</td><td>  </td><td align="left" valign="top">加载动态对象作为扩展。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Remaking-Loaded-Objects" accesskey="2">重建加载的对象</a> ：</td><td>  </td><td align="left" valign="top">如何重载已加载的对象。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loaded-Object-API" accesskey="3">加载的对象API</a> ：</td><td>  </td><td align="left" valign="top">加载对象的程序接口。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Loaded-Object-Example" accesskey="4">加载对象示例</a> ：</td><td>  </td><td align="left" valign="top">加载对象的示例</td></tr>
</tbody></table>

<hr>
<a name="load-Directive"></a>
<div class="header">
<p>下一页： <a href="#Remaking-Loaded-Objects" rel="next" accesskey="n">重新制作已加载的对象</a> ，上<a href="#Remaking-Loaded-Objects" rel="next" accesskey="n">一步</a> ： <a href="#Loading-Objects" rel="prev" accesskey="p">加载对象</a> ，向上： <a href="#Loading-Objects" rel="up" accesskey="u">加载对象</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="The-load-Directive"></a>
<h4 class="subsection">12.2.1 <code>load</code>指示</h4>
<a name="index-load-directive"></a>
<a name="index-extensions_002c-load-directive"></a>

<p>对象被加载到GNU <code>make</code>通过放置<code>load</code>指令放入您的makefile中。的语法<code>load</code>指令如下：</p>
<a name="index-load"></a>
<div class="example">
<pre class="example">load <var>object-file</var> &hellip;
</pre></div>

<p>要么：</p>
<div class="example">
<pre class="example">load <var>object-file</var>(<var>symbol-name</var>) &hellip;
</pre></div>

<p>文件<var>object-file</var>由GNU动态加载<code>make</code> 。如果<var>object-file</var>不包含目录路径，则首先在当前目录中查找它。如果在此处找不到它，或者包含目录路径，则将搜索系统特定的路径。如果加载由于任何原因而失败， <code>make</code>将打印一条消息并退出。
</p>
<p>如果加载成功<code>make</code>将调用初始化函数。
</p>
<p>如果<var>symbol-name</var>提供，它将用作初始化函数的名称。
</p>
<p>如果不<var>symbol-name</var>提供时，通过使用的基本文件名创建初始化函数名称<var>object-file</var> ，直到第一个不是有效符号名称字符的字符（字母数字和下划线是有效符号名称字符）。在此前缀之后将附加后缀<code>_gmk_setup</code> 。
</p>
<p>一个目标文件可以装载多个目标文件<code>load</code>指令，以及两种形式<code>load</code>参数可以在同一指令中使用。
</p>
<p>初始化函数将提供调用的文件名和行号<code>load</code>操作。它应该返回一个类型的值<code>int</code> ，必须是<code>0</code>在失败和非<code>0</code>成功。如果返回值为<code>-1</code> ，那么GNU make将<em>不会</em>尝试重建目标文件（请参见<a href="#Remaking-Loaded-Objects">如何重载已加载的对象</a> ）。
</p>
<p>例如：</p>
<div class="example">
<pre class="example">load ../mk_funcs.so
</pre></div>

<p>将加载动态对象<samp>../mk_funcs.so</samp> 。加载对象后， <code>make</code>将调用该函数（假设由共享库定义） <code>mk_funcs_gmk_setup</code> 。
</p>
<p>另一方面：</p>
<div class="example">
<pre class="example">load ../mk_funcs.so(init_mk_func)
</pre></div>

<p>将加载动态对象<samp>../mk_funcs.so</samp> 。加载对象后， <code>make</code>将调用该函数<code>init_mk_func</code> 。
</p>
<p>无论目标文件出现在目标文件中多少次<code>load</code>指令，则只会加载一次（并且只会调用其设置函数）。
</p>
<a name="index-_002eLOADED"></a>
<p>成功加载对象后，其文件名将附加到<code>.LOADED</code>变量。
</p>
<a name="index-_002dload"></a>
<p>如果您希望加载动态对象失败不会被报告为错误，则可以使用<code>-load</code>指令代替<code>load</code> 。GNU <code>make</code>如果对象加载失败，将不会失败，也不会生成任何消息。失败的对象未添加到<code>.LOADED</code>变量，然后可以通过该变量确定加载是否成功。
</p>
<hr>
<a name="Remaking-Loaded-Objects"></a>
<div class="header">
<p>下一篇： <a href="#Loaded-Object-API" rel="next" accesskey="n">加载对象API</a> ，上一篇： <a href="#Loaded-Object-API" rel="next" accesskey="n">加载</a> <a href="#load-Directive" rel="prev" accesskey="p">指令</a> ，上一篇： <a href="#Loaded-Object-API" rel="next" accesskey="n">加载</a> <a href="#Loading-Objects" rel="up" accesskey="u">对象</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="How-Loaded-Objects-Are-Remade"></a>
<h4 class="subsection">12.2.2如何重载已加载的对象</h4>
<a name="index-updating-loaded-objects"></a>
<a name="index-remaking-loaded-objects"></a>
<a name="index-loaded-objects_002c-remaking-of"></a>

<p>装入的对象与makefile经历相同的重新制作过程（请参见<a href="#Remaking-Makefiles">如何</a>重新制作<a href="#Remaking-Makefiles">Makefile</a> ）。如果重新创建了任何加载的对象，则<code>make</code>将从头开始，重新读取所有makefile，然后再次重新加载目标文件。加载的对象不必执行任何特殊操作即可支持此操作。
</p>
<p>由makefile作者提供重新构建已加载对象所需的规则。
</p>
<hr>
<a name="Loaded-Object-API"></a>
<div class="header">
<p>下一个： <a href="#Loaded-Object-Example" rel="next" accesskey="n">加载的对象示例</a> ，上一个： <a href="#Remaking-Loaded-Objects" rel="prev" accesskey="p">重建加载的对象</a> ，上： <a href="#Loading-Objects" rel="up" accesskey="u">加载对象</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Loaded-Object-Interface"></a>
<h4 class="subsection">12.2.3加载的对象接口</h4>
<a name="index-loaded-object-API"></a>
<a name="index-interface-for-loaded-objects"></a>

<table class="cartouche" border="1"><tbody><tr><td>
<blockquote>
<p><b>警告：</b>为使此功能有用，您的扩展将需要调用GNU内部的各种功能<code>make</code> 。此发行版中提供的编程接口不应被认为是稳定的：在将来的GNU版本中，可以添加，删除或更改函数的调用签名或实现。 <code>make</code> 。
</p></blockquote>
</td></tr></tbody></table>

<p>为了有用，加载的对象必须能够与GNU交互<code>make</code> 。此交互既包括已加载对象提供给makefile的接口，也包括接口<code>make</code>提供给加载的对象进行操作<code>make</code>的操作。
</p>
<p>加载的对象和<code>make</code>由<samp>gnumake.h</samp> C头文件。用C编写的所有已加载对象都应包含此头文件。任何未用C编写的已加载对象都需要实现此头文件中定义的接口。
</p>
<p>通常，已加载的对象将注册一个或多个新的GNU <code>make</code>使用的功能<code>gmk_add_function</code>设置功能中的常规程序。这些的实现<code>make</code>功能可以利用<code>gmk_expand</code>和<code>gmk_eval</code>例程执行其任务，然后可选地返回一个字符串，作为函数扩展的结果。
</p>
<a name="Loaded-Object-Licensing"></a>
<h4 class="subsubheading">加载的对象许可</h4>
<a name="index-loaded-object-licensing"></a>
<a name="index-plugin_005fis_005fGPL_005fcompatible"></a>

<p>每个动态扩展都应定义全局符号<code>plugin_is_GPL_compatible</code>断言它已获得GPL兼容许可证的许可。如果该符号不存在， <code>make</code>发出致命错误，并在尝试加载您的扩展程序时退出。
</p>
<p>符号的声明类型应为<code>int</code> 。但是，它不必位于任何已分配的部分中。该代码仅断言该符号存在于全局范围内。像这样的东西就足够了：</p>
<div class="example">
<pre class="example">int plugin_is_GPL_compatible;
</pre></div>

<a name="Data-Structures"></a>
<h4 class="subsubheading">数据结构</h4>

<dl compact>
<dt><code>gmk_floc</code></dt>
<dd><p>此结构表示文件名/位置对。它是在定义项目时提供的，因此GNU <code>make</code>必要时可以稍后通知用户定义的定义位置。
</p></dd>
</dl>

<a name="Registering-Functions"></a>
<h4 class="subsubheading">注册功能</h4>
<a name="index-gmk_005fadd_005ffunction"></a>

<p>当前，makefile有一种方法来调用已加载对象提供的操作：通过<code>make</code>函数调用界面。加载的对象可以注册一个或多个新功能，然后可以与其他功能相同的方式从makefile中调用该功能。
</p>
<p>使用<code>gmk_add_function</code>创建一个新的<code>make</code>功能。其参数如下：</p>
<dl compact>
<dt><code>name</code></dt>
<dd><p>函数名称。这是makefile用来调用函数的内容。名称长度必须介于1到255个字符之间，并且只能包含字母数字，句点（' <samp>.</samp> '），连字符（' <samp>-</samp> '）和下划线（' <samp>_</samp> '）个字符。它可能不会以句号开头。
</p>
</dd>
<dt><code>func_ptr</code></dt>
<dd><p>指向函数的指针<code>make</code>在扩展Makefile中的函数时将调用。此功能必须由加载的对象定义。
</p>
</dd>
<dt><code>min_args</code></dt>
<dd><p>函数将接受的最少参数数量。必须在0到255之间。GNU <code>make</code>将检查此内容并在调用之前失败<code>func_ptr</code>如果函数调用的参数太少。
</p>
</dd>
<dt><code>max_args</code></dt>
<dd><p>函数将接受的最大参数数量。必须在0到255之间。GNU <code>make</code>将检查此内容并在调用之前失败<code>func_ptr</code>如果函数调用的参数太少。如果值为0，则接受任意数量的参数。如果该值大于0，则必须大于或等于<code>min_args</code> 。
</p>
</dd>
<dt><code>flags</code></dt>
<dd><p>指定此功能如何运行的标志；所需的标志应进行“或”运算。如果<code>GMK_FUNC_NOEXPAND</code>给出标志，则在调用函数之前不会扩展函数参数；否则将首先进行扩展。
</p></dd>
</dl>

<a name="Registered-Function-Interface"></a>
<h4 class="subsubheading">注册功能界面</h4>
<a name="index-gmk_005ffunc_005fptr"></a>

<p>注册了功能<code>make</code>必须与<code>gmk_func_ptr</code>类型。将使用三个参数来调用它： <code>name</code> （函数的名称）， <code>argc</code> （该函数的参数数量），以及<code>argv</code> （指向函数参数的指针数组）。最后一个指针（即， <code>argv[argc]</code> ）为空（ <code>0</code> ）。
</p>
<p>函数的返回值是扩展函数的结果。如果函数扩展为空，则返回值可能为null。否则，它必须是指向使用以下命令创建的字符串的指针<code>gmk_alloc</code> 。函数返回后， <code>make</code>拥有此字符串，并在适当时将其释放；加载的对象无法访问它。
</p>
<a name="GNU-make-Facilities"></a>
<h4 class="subsubheading">GNU <code>make</code>设备</h4>

<p>GNU导出了一些设施<code>make</code>供加载的对象使用。通常，这些操作将从设置功能和/或通过以下功能注册的功能中运行<code>gmk_add_function</code> ，以检索或修改数据<code>make</code>与。
</p>
<dl compact>
<dt><code>gmk_expand</code></dt>
<dd><a name="index-gmk_005fexpand"></a>
<p>该函数接受一个字符串，并使用扩展它<code>make</code>扩展规则。扩展结果返回到一个以nil结尾的字符串缓冲区。呼叫者负责呼叫<code>gmk_free</code>完成时使用指向返回缓冲区的指针。
</p>
</dd>
<dt><code>gmk_eval</code></dt>
<dd><a name="index-gmk_005feval"></a>
<p>此函数采用一个缓冲区，并将其评估为makefile语法的一部分。此函数可用于定义新变量，新规则等。等同于使用<code>eval</code><code>make</code>功能。
</p></dd>
</dl>

<p>请注意， <code>gmk_eval</code>并打电话<code>gmk_expand</code>用一个字符串<code>eval</code>功能：在后一种情况下，字符串将被扩展<em>两次</em> ；一次<code>gmk_expand</code>然后再由<code>eval</code>功能。使用<code>gmk_eval</code>缓冲区最多只能扩展一次（因为它是由<code>make</code>解析器）。
</p>
<a name="Memory-Management"></a>
<h4 class="subsubheading">内存管理</h4>

<p>一些系统允许使用不同的内存管理方案。因此，永远不要传递直接分配给任何内存的内存<code>make</code>函数，也不应该尝试直接释放任何人返回给您的任何内存<code>make</code>功能。而是使用<code>gmk_alloc</code>和<code>gmk_free</code>功能。
</p>
<p>特别是，字符串返回到<code>make</code>通过使用注册的功能<code>gmk_add_function</code> <em>必须</em>使用<code>gmk_alloc</code> ，以及从返回的字符串<code>make</code><code>gmk_expand</code> <em>必须</em>使用以下命令释放函数（不再需要时） <code>gmk_free</code> 。
</p>
<dl compact>
<dt><code>gmk_alloc</code></dt>
<dd><a name="index-gmk_005falloc"></a>
<p>返回一个指向新分配的缓冲区的指针。该函数将始终返回有效的指针。如果没有足够的可用内存<code>make</code>将退出。
</p>
</dd>
<dt><code>gmk_free</code></dt>
<dd><a name="index-gmk_005ffree"></a>
<p>释放一个缓冲区，该缓冲区由<code>make</code> 。一旦<code>gmk_free</code>函数返回的字符串将不再有效。
</p></dd>
</dl>

<hr>
<a name="Loaded-Object-Example"></a>
<div class="header">
<p>上<a href="#Loaded-Object-API" rel="prev" accesskey="p">一篇</a> ： <a href="#Loaded-Object-API" rel="prev" accesskey="p">加载对象API</a> ，上一篇： <a href="#Loading-Objects" rel="up" accesskey="u">加载对象</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Example-Loaded-Object"></a>
<h4 class="subsection">12.2.4示例加载对象</h4>
<a name="index-loaded-object-example"></a>
<a name="index-example-of-loaded-objects"></a>

<p>假设我们想编写一个新的GNU <code>make</code>该函数将创建一个临时文件并返回其名称。我们希望函数以前缀作为参数。首先我们可以将函数写入文件<samp>mk_temp.c</samp> ：</p>
<div class="example">
<pre class="example">#include &lt;stdlib.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

#include &lt;gnumake.h&gt;

int plugin_is_GPL_compatible;

char *
gen_tmpfile(const char *nm, int argc, char **argv)
{
  int fd;

  /* Compute the size of the filename and allocate space for it.  */
  int len = strlen (argv[0]) + 6 + 1;
  char *buf = gmk_alloc (len);

  strcpy (buf, argv[0]);
  strcat (buf, &quot;XXXXXX&quot;);

  fd = mkstemp(buf);
  if (fd &gt;= 0)
    {
      /* Don't leak the file descriptor.  */
      close (fd);
      return buf;
    }

  /* Failure.  */
  fprintf (stderr, &quot;mkstemp(%s) failed: %s\n&quot;, buf, strerror (errno));
  gmk_free (buf);
  return NULL;
}

int
mk_temp_gmk_setup ()
{
  /* Register the function with make name &quot;mk-temp&quot;.  */
  gmk_add_function (&quot;mk-temp&quot;, gen_tmpfile, 1, 1, 1);
  return 1;
}
</pre></div>

<p>接下来，我们将编写一个可以构建此共享库，加载并使用它的makefile：</p>
<div class="example">
<pre class="example">all:
        @echo Temporary file: $(mk-temp tmpfile.)

load mk_temp.so

mk_temp.so: mk_temp.c
        $(CC) -shared -fPIC -o $&nbsp;$&lt;
</pre></div>

<p>在MS-Windows上，由于生成共享对象的方式的特殊性，编译器需要扫描在构建时生成的<em>导入库</em> <code>make</code> ，通常称为<samp>libgnumake-<var>version</var>.dll.a</samp> ，在哪里<var>version</var>是加载对象API的版本。因此，产生共享对象的配方将在Windows上看起来像这样（假设API版本为1）：</p>
<div class="example">
<pre class="example">mk_temp.dll: mk_temp.c
        $(CC) -shared -o $&nbsp;$&lt; -lgnumake-1
</pre></div>

<p>现在当你跑步<code>make</code>您会看到类似以下内容：</p>
<div class="example">
<pre class="example">$ make
cc -shared -fPIC -o mk_temp.so mk_temp.c
Temporary filename: tmpfile.A7JEwd
</pre></div>

<hr>
<a name="Integrating-make"></a>
<div class="header">
<p>下一个： <a href="#Features" rel="next" accesskey="n">功能</a> ，上一个： <a href="#Extending-make" rel="prev" accesskey="p">扩展make</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Integrating-GNU-make"></a>
<h2 class="chapter">13集成GNU<code>make</code></h2>
<a name="index-make-integration"></a>

<p>GNU <code>make</code>通常是大型工具系统（包括集成开发环境，编译器工具链等）中的一个组件。的作用<code>make</code>是启动命令并确定命令是否成功：不需要特殊的集成即可完成命令。但是，有时绑定很方便<code>make</code>与系统的其他部分更紧密地结合在一起，两者都更高层次（ <code>make</code> ）和较低级别的（ <code>make</code>调用）。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Job-Slots" accesskey="1">职位空缺</a> ：</td><td>  </td><td align="left" valign="top">与GNU共享职位<code>make</code> 。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Terminal-Output" accesskey="2">终端输出</a> ：</td><td>  </td><td align="left" valign="top">控制输出到端子。
</td></tr>
</tbody></table>

<hr>
<a name="Job-Slots"></a>
<div class="header">
<p>下一篇： <a href="#Terminal-Output" rel="next" accesskey="n">终端输出</a> ，上一篇： <a href="#Integrating-make" rel="prev" accesskey="p">集成make</a> ，上一篇： <a href="#Integrating-make" rel="up" accesskey="u">集成make</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Sharing-Job-Slots-with-GNU-make"></a>
<h3 class="section">13.1与GNU共享作业槽<code>make</code></h3>
<a name="index-job-slots_002c-sharing"></a>
<a name="index-tools_002c-sharing-job-slots"></a>

<p>GNU <code>make</code>能够并行运行多个配方（请参见<a href="#Parallel">并行执行</a> ），并且即使在以下情况的递归调用中也可以限制并行作业的总数<code>make</code> （请参阅将<a href="#Options_002fRecursion">选项传达给<code>make</code></a> ）。工具<code>make</code>可以增强使用多个线程或多个进程并行运行多个操作的调用，以参与GNU <code>make</code>的作业管理工具，可确保系统上运行的活动线程/进程的总数不超过提供给GNU的最大插槽数<code>make</code> 。
</p>
<a name="index-jobserver"></a>
<p>GNU <code>make</code>使用一种称为“作业服务器”的方法来控制递归调用中活动作业的数量。作业服务器的实际实现在不同的操作系统上有所不同，但是某些基本方面始终是正确的。
</p>
<p>首先，只有命令行<code>make</code>理解为是递归调用<code>make</code> （请参阅<a href="#MAKE-Variable">如何<code>MAKE</code> Variable Works</a> ）将有权访问作业服务器。编写makefile时，必须确保将命令标记为递归（最常见的做法是在命令行前面加上<code>+</code>指标（请参阅<a href="#Recursion">递归使用<code>make</code></a> ）。
</p>
<p>第二， <code>make</code>将通过环境向其子级提供访问作业服务器所需的信息， <code>MAKEFLAGS</code>环境变量。想要参与jobserver协议的工具将需要解析此环境变量，如后续部分中所述。
</p>
<p>第三，每条命令<code>make</code> start在启动之前为其保留了一个隐式作业槽。任何想要参与作业服务器协议的工具都应该假定它可以始终运行一项作业，而无需联系作业服务器。
</p>
<p>最后，至关重要的是，参与作业服务器协议的工具即使在错误情况下，也要在退出之前将从作业服务器获得的插槽的确切数量返回到作业服务器。请记住，隐工作插槽<strong>不</strong>应该回到jobserver！返回的插槽太少意味着这些插槽将在其余的构建过程中丢失；返回太多的插槽意味着额外的插槽将可用。顶层<code>make</code>如果在作业服务器中检测到错误数量的可用插槽，则该命令将在构建结束时输出一条错误消息。
</p>
<p>例如，假设您正在实现一个提供多线程操作的链接器。您想增强链接器，以便它由GNU调用<code>make</code>它可以参与jobserver协议以控制链接期间使用了多少个线程。首先，您需要修改链接器以确定是否<code>MAKEFLAGS</code>环境变量已设置。接下来，您将需要解析该变量的值，以确定作业服务器是否可用以及如何访问它。如果可用，则可以访问它以获取作业位，以控制工具可以使用多少并行度。完成后，您的工具必须将这些作业插槽返回给作业服务器。
</p>
<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#POSIX-Jobserver" accesskey="1">POSIX作业服务器</a> ：</td><td>  </td><td align="left" valign="top">在POSIX系统上使用作业服务器。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Windows-Jobserver" accesskey="2">Windows Jobserver</a> ：</td><td>  </td><td align="left" valign="top">在Windows系统上使用jobserver。
</td></tr>
</tbody></table>

<hr>
<a name="POSIX-Jobserver"></a>
<div class="header">
<p>下一篇： <a href="#Windows-Jobserver" rel="next" accesskey="n">Windows Jobserver</a> ，上一篇： <a href="#Job-Slots" rel="prev" accesskey="p">作业槽</a> ，上： <a href="#Job-Slots" rel="up" accesskey="u">作业槽</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="POSIX-Jobserver-Interaction"></a>
<h4 class="subsection">13.1.1 POSIX Jobserver交互</h4>
<a name="index-jobserver-on-POSIX"></a>

<p>在POSIX系统上，作业服务器被实现为简单的UNIX管道。对于每个可用作业，该管道将预加载一个单字符令牌。要获得额外的插槽，必须从jobserver管道读取单个字符；要释放插槽，必须将单个字符写回到jobserver管道中。
</p>
<p>要访问管道，您必须解析<code>MAKEFLAGS</code>变量并查找参数字符串<code>--jobserver-auth=R,W</code>在哪里<samp>R</samp> '和' <samp>W</samp> '是表示文件描述符的非负整数：' <samp>R</samp> '是读取的文件描述符，而' <samp>W</samp> '是写文件描述符。
</p>
<p>释放作业插槽时，请回写从该插槽的管道中读取的相同字符，这一点很重要。不要假设所有标记都是相同的字符；不同的字符对GNU可能具有不同的含义<code>make</code> 。顺序并不重要，因为<code>make</code>不知道工作将以什么顺序完成。
</p>
<p>您必须考虑各种错误条件，以确保您的实现是可靠的：</p>
<ul>
<li>通常，您将有一个命令行参数来控制工具的并行操作。考虑您的工具是否应该检测同时指定jobserver和命令行参数的情况，以及应该如何反应。

</li><li>如果您的工具确定<code>--jobserver-auth</code>该选项在<code>MAKEFLAGS</code>但是指定的文件描述符已关闭，这意味着调用<code>make</code>过程不认为您的工具是递归的<code>make</code>调用（例如，命令行没有前缀<code>+</code>字符）。您应将这种情况通知您的用户。

</li><li>您的工具还应该检查<code>MAKEFLAGS</code>变量并查找字符<code>n</code> 。如果存在此字符，则<code>make</code>被用' <samp>-n</samp> '选项，则您的工具应停止而不执行任何操作。

</li><li>即使在错误情况下，您的工具也应确保写回读取的令牌。这不仅包括您的工具中的错误，还包括诸如中断（ <code>SIGINT</code> ）等您可能需要安装信号处理程序来管理此写回。
</li></ul>

<hr>
<a name="Windows-Jobserver"></a>
<div class="header">
<p>上一页： <a href="#POSIX-Jobserver" rel="prev" accesskey="p">POSIX作业服务器</a> ，上： <a href="#Job-Slots" rel="up" accesskey="u">作业槽</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Windows-Jobserver-Interaction"></a>
<h4 class="subsection">13.1.2 Windows Jobserver交互</h4>
<a name="index-jobserver-on-Windows"></a>

<p>在Windows系统上，作业服务器被实现为命名信号量。信号量将设置为具有等于可用插槽数的初始计数。要获得插槽，您必须等待信号量（有或没有超时）。要释放插槽，请释放信号灯。
</p>
<p>要访问信号量，您必须解析<code>MAKEFLAGS</code>变量并查找参数字符串<code>--jobserver-auth=NAME</code>在哪里<samp>NAME</samp> '是已命名信号量的名称。将此名称与<code>OpenSemaphore</code>创建信号量的句柄。
</p>
<p>您必须考虑各种错误条件，以确保您的实现是可靠的：</p>
<ul>
<li>通常，您将有一个命令行参数来控制工具的并行操作。考虑您的工具是否应该检测同时指定jobserver和命令行参数的情况，以及应该如何反应。

</li><li>即使在错误情况下，您的工具也应确保释放其读取的令牌的信号量。这不仅包括您的工具中的错误，还包括诸如中断（ <code>SIGINT</code> ）等您可能需要安装信号处理程序来管理此写回。
</li></ul>

<hr>
<a name="Terminal-Output"></a>
<div class="header">
<p>上<a href="#Job-Slots" rel="prev" accesskey="p">一篇</a> ： <a href="#Job-Slots" rel="prev" accesskey="p">职位空缺</a> ，上一篇： <a href="#Integrating-make" rel="up" accesskey="u">整合make</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Synchronized-Terminal-Output"></a>
<h3 class="section">13.2同步终端输出</h3>
<a name="index-parallel-output-to-terminal"></a>
<a name="index-terminal_002c-output-to"></a>

<p>通常是GNU <code>make</code>将调用所有具有相同标准和错误输出访问权限的命令<code>make</code>本身开始。许多工具将检测输出是终端还是非终端，并使用此信息来更改输出样式。例如，如果输出到终端，则该工具可以添加设置颜色的控制字符，甚至更改光标的位置。如果输出未发送到终端，则不会发出这些特殊控制字符，以使它们不会损坏日志文件等。</p>
<p>的<code>--output-sync</code> （请参见<a href="#Parallel-Output">并行输出期间的输出</a> ）选项将使端子检测失败。启用输出同步后，GNU <code>make</code>安排将所有命令输出写入文件，以便其输出可以作为一个块写入而不受其他命令的干扰。这意味着，所有由<code>make</code>会相信他们的输出不会显示在终端上，即使它会显示在终端上也是如此（因为<code>make</code>命令完成后将显示在此处）。
</p>
<p>为了方便那些想要确定其输出是否将显示在终端上的工具，GNU <code>make</code>将设置<code>MAKE_TERMOUT</code>和<code>MAKE_TERMERR</code>调用任何命令之前的环境变量。想要确定分别在终端上显示标准输出还是错误输出的工具可以检查这些环境变量，以确定它们是否存在并包含非空值。如果是这样，该工具可以假定输出（最终）将显示在终端上。如果未设置变量或变量为空，则该工具应退回到其正常方法来检测输出是否将输出到终端。
</p>
<p>可以解析变量的内容以确定将用于显示输出的终端类型。
</p>
<p>同样，调用<code>make</code>并且想要捕获输出并最终将其显示在终端上（或某些可以解释终端控制字符的显示器），可以在调用之前设置这些变量<code>make</code> 。GNU <code>make</code>如果启动时这些环境变量已经存在，则不会对其进行修改。
</p>
<hr>
<a name="Features"></a>
<div class="header">
<p>下一个： <a href="#Missing" rel="next" accesskey="n">缺失</a> ，上一个： <a href="#Integrating-make" rel="prev" accesskey="p">集成make</a> ，上一个： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Features-of-GNU-make"></a>
<h2 class="chapter">GNU的14个功能<code>make</code></h2>
<a name="index-features-of-GNU-make"></a>
<a name="index-portability"></a>
<a name="index-compatibility"></a>

<p>这是GNU功能的摘要<code>make</code> ，以便与其他版本的内容进行比较并归功于<code>make</code> 。我们考虑以下特征<code>make</code>以4.2 BSD系统为基准。如果您要编写可移植的makefile文件，则不应使用以下功能： <code>make</code>此处列出的内容，也没有“ <a href="#Missing">失踪”中</a>列出的内容。
</p>
<p>许多功能来自的版本<code>make</code>在系统V中。</p>
<ul>
<li>的<code>VPATH</code>变量及其特殊含义。请参阅在<a href="#Directory-Search">目录中搜索前提条件</a> 。系统V中存在此功能<code>make</code> ，但未记录。它记录在4.3 BSD中<code>make</code> （它说它模仿了系统V的<code>VPATH</code>特征）。

</li><li>包含的makefile。请参阅<a href="#Include">包括其他Makefile</a> 。单个指令允许包含多个文件是GNU扩展。

</li><li>从环境中读取变量并通过环境进行通信。请参阅<a href="#Environment">环境变量</a> 。

</li><li>通过变量传递的选项<code>MAKEFLAGS</code>的递归调用<code>make</code> 。请参阅将<a href="#Options_002fRecursion">选项传达给子网站<code>make</code></a> 。

</li><li>自动变量<code>$%</code>在存档参考中设置为成员名称。请参阅<a href="#Automatic-Variables">自动变量</a> 。

</li><li>自动变量<code>$@</code> ， <code>$*</code> ， <code>$<</code> ， <code>$%</code>和<code>$?</code>具有相应的形式，例如<code>$(@F)</code>和<code>$(@D)</code> 。我们将其概括为<code>$^</code>作为一个明显的扩展。请参阅<a href="#Automatic-Variables">自动变量</a> 。

</li><li>替代变量引用。请参见<a href="#Reference">变量引用的基础</a> 。

</li><li>命令行选项<samp>-b</samp> '和' <samp>-m</samp> '，接受并忽略。在系统V中<code>make</code> ，这些选项实际上会有所作为。

</li><li>执行递归命令以运行<code>make</code>通过变量<code>MAKE</code>即使 ' <samp>-n</samp> '，' <samp>-q</samp> ' 要么 ' <samp>-t</samp> '已指定。请参阅<a href="#Recursion">递归使用<code>make</code></a> 。

</li><li>支持后缀' <samp>.a</samp>在后缀规则中。请参阅<a href="#Archive-Suffix-Rules">存档后缀规则</a> 。该功能在GNU中已过时<code>make</code> ，因为规则链接的一般功能（请参阅<a href="#Chained-Rules">隐式规则链</a> ）允许使用一种模式规则来在存档中安装成员（请参见<a href="#Archive-Update">Archive Update</a> ）就足够了。

</li><li>在打印配方时，将保留配方中的行和反斜杠/换行符组合的排列，因此，它们会像在makefile中一样显示，除了剥离初始空白。
</li></ul>

<p>以下功能受其他各种版本的启发<code>make</code> 。在某些情况下，尚不清楚究竟哪个版本启发了其他版本。
</p>
<ul>
<li>使用'的模式规则<samp>%</samp> '。这已在多个版本的<code>make</code> 。我们不确定是谁首先发明了它，但是它已经散布了一些。请参阅<a href="#Pattern-Rules">定义和重新定义模式规则</a> 。

</li><li>规则链和隐式中间文件。这是由Stu Feldman在他的版本中实现的<code>make</code> AT＆T第八版研究Unix，后来由AT＆T贝尔实验室的安德鲁·休姆（Andrew Hume） <code>mk</code>程序（他称之为“传递闭包”）。我们真的不知道我们是从他们两个人那里得到的，还是同时想出自己的想法。请参阅<a href="#Chained-Rules">隐式规则链</a> 。

</li><li>自动变量<code>$^</code>包含当前目标的所有先决条件的列表。我们没有发明这个，但是我们不知道是谁做的。请参阅<a href="#Automatic-Variables">自动变量</a> 。自动变量<code>$+</code>是...的简单扩展<code>$^</code> 。

</li><li>“假设”标志（' <samp>-W</samp>在GNU中<code>make</code> ）（据我们所知）是安德鲁·休姆（Andrew Hume）在<code>mk</code> 。请参见<a href="#Instead-of-Execution">代替执行食谱</a> 。

</li><li>一次做几件事（并行性）的概念存在于<code>make</code>和类似的程序，尽管不在System V或BSD实现中。请参见<a href="#Execution">配方执行</a> 。

</li><li>许多支持并行性的构建工具还支持收集输出并显示为单个块。请参见<a href="#Parallel-Output">并行执行期间的输出</a> 。

</li><li>使用模式替换的修改后的变量引用来自SunOS 4。请参见<a href="#Reference">变量引用的基础</a> 。此功能在GNU中提供<code>make</code>由<code>patsubst</code>为了实现与SunOS 4的兼容性，在实现备用语法之前必须先使用该函数。自GNU以来，尚不清楚是谁启发了谁<code>make</code>有<code>patsubst</code>在SunOS 4发布之前。

</li><li>'的特殊意义<samp>+</samp> <cite>IEEE标准1003.2-1992</cite> （POSIX.2）要求在食谱行之前添加'字符（请参阅<a href="#Instead-of-Execution">代替执行食谱</a> ）。

</li><li>' <samp>+=</samp>附加到变量值的语法来自SunOS 4 <code>make</code> 。请参见<a href="#Appending">在变量中添加更多文本</a> 。

</li><li>语法' <samp><var>archive</var>(<var>mem1</var> <var>mem2</var>…)</samp> ' <!-- /@w -->在单个归档文件中列出多个成员来自SunOS 4 <code>make</code> 。请参阅<a href="#Archive-Members">存档成员</a> 。

</li><li>的<code>-include</code>包含不存在任何错误的makefile的指令来自SunOS 4 <code>make</code> 。（但请注意，SunOS 4 <code>make</code>不允许在一个文件中指定多个makefile <code>-include</code>指示。）出现具有相同功能的名称<code>sinclude</code>在SGI中<code>make</code>也许还有其他。

</li><li>的<code>!=</code> shell赋值运算符存在于许多BSD中<code>make</code>并在此有意实现，使其行为与那些实现相同。

</li><li>使用诸如Perl或Python之类的脚本语言来实现各种构建管理工具，从而提供类似于GNU的自然嵌入式脚本语言。 <code>make</code>的GNU Guile集成。
</li></ul>

<p>其余功能是GNU中的新发明<code>make</code> ：</p>
<ul>
<li>使用 ' <samp>-v</samp> ' 要么 ' <samp>--version</samp> '选项以打印版本和版权信息。

</li><li>使用 ' <samp>-h</samp> ' 要么 ' <samp>--help</samp> '选项，总结了<code>make</code> 。

</li><li>简单扩展的变量。请参见<a href="#Flavors">变量的两种风格</a> 。

</li><li>自动通过变量传递命令行变量分配<code>MAKE</code>递归<code>make</code>调用。请参阅<a href="#Recursion">递归使用<code>make</code></a> 。

</li><li>使用 ' <samp>-C</samp> ' 要么 ' <samp>--directory</samp> '命令选项以更改目录。请参阅<a href="#Options-Summary">选项摘要</a> 。

</li><li>使用以下命令进行逐字变量定义<code>define</code> 。请参阅<a href="#Multi_002dLine">定义多行变量</a> 。

</li><li>用特殊目标声明伪造目标<code>.PHONY</code> 。

<p>AT＆T贝尔实验室的安德鲁·休姆（Andrew Hume）实现了类似的功能，但语法不同<code>mk</code>程序。这似乎是并行发现的情况。参见<a href="#Phony-Targets">Phony目标</a> 。
</p>
</li><li>通过调用函数来处理文本。请参见<a href="#Functions">转换文本的功能</a> 。

</li><li>使用 ' <samp>-o</samp> ' 要么 ' <samp>--old-file</samp>假装文件修改时间的选项已过时。请参阅<a href="#Avoiding-Compilation">避免重新编译某些文件</a> 。

</li><li>有条件的执行。

<p>此功能已在各种版本的<code>make</code> ;它似乎是C预处理器和类似宏语言的功能所衍生的自然扩展，而不是一个革命性的概念。请参见<a href="#Conditionals">Makefile的条件部分</a> 。
</p>
</li><li>指定包含的makefile的搜索路径。请参阅<a href="#Include">包括其他Makefile</a> 。

</li><li>指定额外的makefile以与环境变量一起读取。见<a href="#MAKEFILES-Variable">变量<code>MAKEFILES</code></a> 。

</li><li>去除'的前导序列<samp>./</samp> '，来自文件名<samp>./<var>file</var></samp>和<samp><var>file</var></samp>被视为同一文件。

</li><li>使用特殊的搜索方法搜索以“ <samp>-l<var>name</var></samp> '。请参阅<a href="#Libraries_002fSearch">目录搜索链接库</a> 。

</li><li>允许后缀规则的后缀（请参阅<a href="#Suffix-Rules">老式后缀规则</a> ）包含任何字符。在其他版本中<code>make</code> ，它们必须以“ <samp>.</samp>且不包含任何“ <samp>/</samp> '个字符。

</li><li>跟踪当前的水平<code>make</code>使用变量进行递归<code>MAKELEVEL</code> 。请参阅<a href="#Recursion">递归使用<code>make</code></a> 。

</li><li>在变量中提供命令行上给出的任何目标<code>MAKECMDGOALS</code> 。请参阅<a href="#Goals">指定目标的参数</a> 。</li><li>指定静态模式规则。请参阅<a href="#Static-Pattern">静态模式规则</a> 。

</li><li>提供选择性<code>vpath</code>搜索。请参阅在<a href="#Directory-Search">目录中搜索前提条件</a> 。

</li><li>提供计算变量引用。请参见<a href="#Reference">变量引用的基础</a> 。

</li><li>更新makefile。请参阅<a href="#Remaking-Makefiles">如何重新制作Makefile</a> 。系统V <code>make</code>该功能的形式非常非常有限，因为它将检出SCCS文件中的makefile。

</li><li>各种新的内置隐式规则。请参阅<a href="#Catalogue-of-Rules">内置规则目录</a> 。

</li><li>加载可以修改行为的动态对象<code>make</code> 。请参阅<a href="#Loading-Objects">加载动态对象</a> 。
</li></ul>

<hr>
<a name="Missing"></a>
<div class="header">
<p>下一篇： <a href="#Makefile-Conventions" rel="next" accesskey="n">Makefile约定</a> ，上一篇： <a href="#Features" rel="prev" accesskey="p">功能</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Incompatibilities-and-Missing-Features"></a>
<h2 class="chapter">15不兼容和功能缺失</h2>
<a name="index-incompatibilities"></a>
<a name="index-missing-features"></a>
<a name="index-features_002c-missing"></a>

<p>的<code>make</code>其他各种系统中的程序支持一些GNU中未实现的功能<code>make</code> 。POSIX.2标准（ <cite>IEEE标准1003.2-1992</cite> ）规定<code>make</code>不需要任何这些功能。
</p>
<ul>
<li>形式为“ <samp><var>file</var>((<var>entry</var>))</samp> '代表存档文件的成员<var>file</var> 。选择成员的方式不是通过名称而是通过定义链接器符号的目标文件来选择<var>entry</var> 。

<p>此功能未放入GNU中<code>make</code>因为将知识投入的非模块化<code>make</code>归档文件符号表的内部格式。请参阅<a href="#Archive-Symbols">更新存档符号目录</a> 。
</p>
</li><li>以字符'结尾的后缀（用于后缀规则） <samp>~</samp> '对系统V有特殊含义<code>make</code> ;他们指的是SCCS文件，该文件对应的文件不带“ <samp>~</samp> '。例如，后缀规则“ <samp>.c~.o</samp> '将使文件<samp><var>n</var>.o</samp>从SCCS文件<samp>s.<var>n</var>.c</samp> 。为了完整覆盖，需要一整套此类后缀规则。请参阅<a href="#Suffix-Rules">老式的后缀规则</a> 。

<p>在GNU中<code>make</code> ，这一系列案件都是由两个模式规则处理的，这些规则从SCCS中提取，并结合了规则链的一般功能。请参阅<a href="#Chained-Rules">隐式规则链</a> 。
</p>
</li><li>在System V和4.3 BSD中<code>make</code> ，找到的文件<code>VPATH</code>搜索（请参阅在<a href="#Directory-Search">目录中搜索前提条件</a> ）的名称在配方中已更改。我们认为始终使用自动变量会变得更干净，从而使此功能过时。

</li><li>在某些Unix中<code>make</code> s，自动变量<code>$*</code>出现在规则先决条件中的功能具有扩展到该<em>规则目标</em>的全名的惊人的奇怪“功能”。我们无法想象Unix发生了什么<code>make</code>开发人员可以做到这一点；它完全与的正常定义不一致<code>$*</code> 。
<a name="index-_002a-_0028automatic-variable_0029_002c-unsupported-bizarre-usage"></a>

</li><li>在某些Unix中<code>make</code> s，显然对<em>所有</em>目标（而不只是那些没有配方的目标）执行了隐式规则搜索（请参阅<a href="#Implicit-Rules">使用隐式规则</a> ）。这意味着您可以：<div class="example">
<pre class="example">foo.o:
        cc -c foo.c
</pre></div>

<p>和Unix <code>make</code>会直觉<samp>foo.o</samp>依赖于取决于<samp>foo.c</samp> 。
</p>
<p>我们认为这种用法已被破坏。的先决条件属性<code>make</code>定义明确（对于GNU <code>make</code> ，至少），而这样做根本不适合模型。
</p>
</li><li>GNU <code>make</code>不包括用于编译或预处理EFL程序的任何内置隐式规则。如果我们听到有人在使用EFL，我们将很乐意添加他们。

</li><li>看来在SVR4中<code>make</code> ，可以不使用任何配方指定后缀规则，并且将其视为具有空配方（请参阅“ <a href="#Empty-Recipes">空配方”</a> ）。例如：<div class="example">
<pre class="example">.c.a:
</pre></div>

<p>将覆盖内置<samp>.c.a</samp>后缀规则。
</p>
<p>我们认为，对于没有配方的规则而言，总是简单地将其添加到目标的先决条件列表中是更清洁的方法。可以很容易地重写上面的示例，以在GNU中获得所需的行为<code>make</code> ：</p>
<div class="example">
<pre class="example">.c.a: ;
</pre></div>

</li><li>的某些版本<code>make</code>用'调用外壳<samp>-e</samp> '标志，'下除外<samp>-k</samp> '（请参阅<a href="#Testing">测试程序的编译</a> ）。' <samp>-e</samp> '标志告诉shell只要运行的任何程序返回非零状态就退出。我们认为将食谱的每一行写成自己的样子是比较干净的，不需要这种特殊处理。
</li></ul>


<hr>
<a name="Makefile-Conventions"></a>
<div class="header">
<p>下一篇： <a href="#Quick-Reference" rel="next" accesskey="n">快速参考</a> ，上一篇： <a href="#Missing" rel="prev" accesskey="p">缺少</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Makefile-Conventions-1"></a>
<h2 class="chapter">16个Makefile约定</h2>
<a name="index-makefile_002c-conventions-for"></a>
<a name="index-conventions-for-makefiles"></a>
<a name="index-standards-for-makefiles"></a>


<p>这描述了为GNU程序编写Makefile的约定。使用Automake将帮助您编写遵循这些约定的Makefile。有关可移植Makefile的更多信息，请参见<small>POSIX</small>和<cite>Autoconf中的</cite> <a href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Portable-Make">可移植Make编程</a> 。
</p>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="#Makefile-Basics" accesskey="1">Makefile基础</a> ：</td><td>  </td><td align="left" valign="top">Makefile的常规约定。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Utilities-in-Makefiles" accesskey="2">Makefile中的实用程序</a> ：</td><td>  </td><td align="left" valign="top">Makefile中使用的实用程序。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Command-Variables" accesskey="3">命令变量</a> ：</td><td>  </td><td align="left" valign="top">用于指定命令的变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#DESTDIR" accesskey="4">DESTDIR</a> ：</td><td>  </td><td align="left" valign="top">支持分阶段安装。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Directory-Variables" accesskey="5">目录变量</a> ：</td><td>  </td><td align="left" valign="top">安装目录的变量。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Standard-Targets" accesskey="6">标准目标</a> ：</td><td>  </td><td align="left" valign="top">用户的标准目标。
</td></tr>
<tr><td align="left" valign="top">• <a href="#Install-Command-Categories" accesskey="7">安装命令类别</a> ：</td><td>  </td><td align="left" valign="top">“ <samp>install</samp>规则：正常，安装前和安装后。
</td></tr>
</tbody></table>

<hr>
<a name="Makefile-Basics"></a>
<div class="header">
<p>下一页： <a href="#Utilities-in-Makefiles" rel="next" accesskey="n">Makefile中的实用程序</a> ，上： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="General-Conventions-for-Makefiles"></a>
<h3 class="section">16.1 Makefile的一般约定</h3>

<p>每个Makefile应该包含以下行：</p>
<div class="example">
<pre class="example">SHELL = /bin/sh
</pre></div>

<p>避免在<code>SHELL</code>变量可能是从环境继承的。（这对GNU来说从来都不是问题。 <code>make</code> ）
</p>
<p>不同<code>make</code>程序具有不兼容的后缀列表和隐式规则，这有时会造成混乱或行为异常。因此，最好仅使用特定Makefile中所需的后缀来显式设置后缀列表，如下所示：</p>
<div class="example">
<pre class="example">.SUFFIXES:
.SUFFIXES: .c .o
</pre></div>

<p>第一行清除了后缀列表，第二行介绍了所有可能受此Makefile中隐式规则约束的后缀。
</p>
<p>不要以为<samp>.</samp>在命令执行路径中。在制作过程中需要运行作为软件包一部分的程序时，请确保使用<samp>./</samp>如果程序是作为make的一部分构建的，或者<samp>$(srcdir)/</samp>如果文件是源代码的不变部分。如果没有这些前缀之一，则使用当前搜索路径。
</p>
<p>两者之间的区别<samp>./</samp> （ <em>构建目录</em> ）和<samp>$(srcdir)/</samp> （ <em>源目录</em> ）很重要，因为用户可以使用' <samp>--srcdir</samp> '选项<samp>configure</samp> 。形式规则：</p>
<div class="smallexample">
<pre class="smallexample">foo.1 : foo.man sedscript
        sed -f sedscript foo.man &gt; foo.1
</pre></div>

<p>当构建目录不是源目录时将失败，因为<samp>foo.man</samp>和<samp>sedscript</samp>在源目录中。
</p>
<p>使用GNU时<code>make</code> ， 依靠 ' <samp>VPATH</samp>查找源文件将在只有一个依赖文件的情况下起作用，因为<code>make</code>自动变量<samp>$<</samp> '会在任何位置代表源文件。（许多版本<code>make</code>设置“ <samp>$<</samp> '仅适用于隐式规则。）一个Makefile目标，例如</p>
<div class="smallexample">
<pre class="smallexample">foo.o : bar.c
        $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o
</pre></div>

<p>应该改为</p>
<div class="smallexample">
<pre class="smallexample">foo.o : bar.c
        $(CC) -I. -I$(srcdir) $(CFLAGS) -c $&lt; -o $@
</pre></div>

<p>为了允许“ <samp>VPATH</samp>以正常工作。当目标具有多个依赖项时，请使用显式的' <samp>$(srcdir)</samp> '是使规则正常运行的最简单方法。例如，上面的目标<samp>foo.1</samp>最好写成：</p>
<div class="smallexample">
<pre class="smallexample">foo.1 : foo.man sedscript
        sed -f $(srcdir)/sedscript $(srcdir)/foo.man &gt; $@
</pre></div>

<p>GNU发行版通常包含一些不是源文件的文件，例如Info文件，以及Autoconf，Automake，Bison或Flex的输出。由于这些文件通常显示在源目录中，因此它们应始终显示在源目录中，而不是在构建目录中。因此，用于更新它们的Makefile规则应将更新后的文件放在源目录中。
</p>
<p>但是，如果文件没有出现在发行版中，则Makefile不应将其放在源目录中，因为在通常情况下构建程序不应以任何方式修改源目录。
</p>
<p>尝试使构建和安装目标（至少所有子目标）与并行目标一起正常工作<code>make</code> 。
</p>
<hr>
<a name="Utilities-in-Makefiles"></a>
<div class="header">
<p>下一篇： <a href="#Command-Variables" rel="next" accesskey="n">命令变量</a> ，上一篇： <a href="#Makefile-Basics" rel="prev" accesskey="p">Makefile基础知识</a> ，上一篇： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Utilities-in-Makefiles-1"></a>
<h3 class="section">16.2 Makefile中的实用程序</h3>

<p>编写Makefile命令（以及任何shell脚本，例如<code>configure</code> ）在<code>sh</code> （传统的Bourne外壳和<small>POSIX</small>外壳）， <code>csh</code> 。不要使用的任何特殊功能<code>ksh</code>要么<code>bash</code> ，或传统Bourne不广泛支持的<small>POSIX</small>功能<code>sh</code> 。
</p>
<p>的<code>configure</code>脚本和用于构建和安装的Makefile规则不应直接使用任何实用程序，但以下情况除外：</p>

<div class="example">
<pre class="example">awk cat cmp cp diff echo egrep expr false grep install-info ln ls
mkdir mv printf pwd rm rmdir sed sleep sort tar test touch tr true
</pre></div>

<p>压缩程序，例如<code>gzip</code>可以用在<code>dist</code>规则。
</p>
<p>通常，坚持使用这些程序的广泛支持（通常是<small>POSIX指定</small> ）的选项和功能。例如，请勿使用“ <samp>mkdir -p</samp> ”，这可能很方便，因为一些系统根本不支持它，而其他系统根本不支持它，因此并行执行并不安全。有关已知不兼容性的列表，请参见<cite>Autoconf中的</cite> <a href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Portable-Shell">Portable Shell Programming</a> 。
</p>

<p>最好避免在makefile中创建符号链接，因为一些文件系统不支持它们。
</p>
<p>用于构建和安装的Makefile规则也可以使用编译器和相关程序，但应通过以下方式使用<code>make</code>变量，以便用户可以替代替代方案。以下是我们指的一些程序：</p>
<div class="example">
<pre class="example">ar bison cc flex install ld ldconfig lex
make makeinfo ranlib texi2dvi yacc
</pre></div>

<p>使用以下<code>make</code>运行这些程序的变量：</p>
<div class="example">
<pre class="example">$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
$(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)
</pre></div>

<p>使用时<code>ranlib</code>要么<code>ldconfig</code> ，如果系统没有相关程序，则应确保不会发生任何不良情况。安排忽略该命令中的错误，并在命令前打印一条消息以告知用户该命令的失败并不意味着有问题。（Autoconf' <samp>AC_PROG_RANLIB</samp> '宏可以帮助解决这个问题。）
</p>
<p>如果使用符号链接，则应为没有符号链接的系统实施后备。
</p>
<p>可以通过Make变量使用的其他实用程序是：</p>
<div class="example">
<pre class="example">chgrp chmod chown mknod
</pre></div>

<p>可以在Makefile部分（或脚本）中使用仅适用于您知道这些实用程序存在的特定系统的其他实用程序。
</p>
<hr>
<a name="Command-Variables"></a>
<div class="header">
<p>下一篇： <a href="#DESTDIR" rel="next" accesskey="n">DESTDIR</a> ，上一篇： <a href="#Utilities-in-Makefiles" rel="prev" accesskey="p">Makefile中的实用程序</a> ，上一篇： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Variables-for-Specifying-Commands"></a>
<h3 class="section">16.3用于指定命令的变量</h3>

<p>Makefile文件应提供用于覆盖某些命令，选项等的变量。
</p>
<p>特别是，您应该通过变量运行大多数实用程序。因此，如果您使用Bison，则有一个名为<code>BISON</code>其默认值设置为' <samp>BISON = bison</samp> '，并用<code>$(BISON)</code>每当您需要使用Bison时。
</p>
<p>文件管理实用程序，例如<code>ln</code> ， <code>rm</code> ， <code>mv</code> ，等等，不需要通过变量来引用，因为用户不需要用其他程序替换它们。
</p>
<p>每个程序名变量都应该带有一个选项变量，该变量用于为程序提供选项。附加' <samp>FLAGS</samp> '到程序名变量名，以获取选项变量名-例如， <code>BISONFLAGS</code> 。（名字<code>CFLAGS</code>对于C编译器， <code>YFLAGS</code> yacc，以及<code>LFLAGS</code>对于lex，是此规则的例外，但我们保留它们是因为它们是标准的。）使用<code>CPPFLAGS</code>在任何运行预处理器的编译命令中使用<code>LDFLAGS</code>在进行链接的任何编译命令中以及在直接使用<code>ld</code> 。
</p>
<p>如果<em>必须</em>使用C编译器选项来正确编译某些文件，请不要将它们包括在<code>CFLAGS</code> 。用户希望能够指定<code>CFLAGS</code>自己自由地。而是安排独立于C编译器传递必要的选项<code>CFLAGS</code> ，通过在编译命令中显式地编写它们或通过定义隐式规则，例如：</p>
<div class="smallexample">
<pre class="smallexample">CFLAGS = -g
ALL_CFLAGS = -I. $(CFLAGS)
.c.o:
        $(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $&lt;
</pre></div>

<p>包括“ <samp>-g</samp> '选项<code>CFLAGS</code> ，因为正确编译并不<em>需</em>要这样做。您可以将其视为仅推荐的默认设置。如果该软件包已设置为在默认情况下使用GCC进行编译，则您最好添加“ <samp>-O</samp> '为默认值<code>CFLAGS</code>也一样
</p>
<p>放<code>CFLAGS</code>在编译命令的最后，在其他包含编译器选项的变量之后，因此用户可以使用<code>CFLAGS</code>超越其他。
</p>
<p><code>CFLAGS</code>应该在C编译器的每次调用中使用，无论是进行编译的还是进行链接的。
</p>
<p>每个Makefile都应定义变量<code>INSTALL</code> ，这是将文件安装到系统中的基本命令。
</p>
<p>每个Makefile还应该定义变量<code>INSTALL_PROGRAM</code>和<code>INSTALL_DATA</code> 。（默认为<code>INSTALL_PROGRAM</code>应该<code>$(INSTALL)</code> ;默认的<code>INSTALL_DATA</code>应该<code>${INSTALL} -m 644</code> ）然后，它应将这些变量用作实际安装的命令，分别用于可执行文件和非可执行文件。最少使用这些变量如下：</p>
<div class="example">
<pre class="example">$(INSTALL_PROGRAM) foo $(bindir)/foo
$(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a
</pre></div>

<p>但是，最好支持<code>DESTDIR</code>目标文件上的前缀，如下一节所述。
</p>
<p>在一个命令中安装多个文件是可以接受的，但不是必需的，最后一个参数是目录，如：</p>
<div class="example">
<pre class="example">$(INSTALL_PROGRAM) foo bar baz $(bindir)
</pre></div>


<hr>
<a name="DESTDIR"></a>
<div class="header">
<p>下一个： <a href="#Directory-Variables" rel="next" accesskey="n">目录变量</a> ，上一个： <a href="#Command-Variables" rel="prev" accesskey="p">命令变量</a> ，上： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="DESTDIR_003a-Support-for-Staged-Installs"></a>
<h3 class="section">16.4 <code>DESTDIR</code> ：支持分阶段安装</h3>

<a name="index-DESTDIR"></a>
<a name="index-staged-installs"></a>
<a name="index-installations_002c-staged"></a>

<p><code>DESTDIR</code>是在每个已安装的目标文件之前添加的变量，如下所示：</p>
<div class="example">
<pre class="example">$(INSTALL_PROGRAM) foo $(DESTDIR)$(bindir)/foo
$(INSTALL_DATA) libfoo.a $(DESTDIR)$(libdir)/libfoo.a
</pre></div>

<p>的<code>DESTDIR</code>变量由用户在<code>make</code>命令行作为绝对文件名。例如：</p>
<div class="example">
<pre class="example">make DESTDIR=/tmp/stage install
</pre></div>

<p><code>DESTDIR</code>应该仅在<code>install*</code>和<code>uninstall*</code>目标，因为这些是唯一有用的目标。
</p>
<p>如果您的安装步骤可以正常安装<samp>/usr/local/bin/foo</samp>和<samp>/usr/local/lib/libfoo.a</samp> ，则如上例中所示的安装将被安装<samp>/tmp/stage/usr/local/bin/foo</samp>和<samp>/tmp/stage/usr/local/lib/libfoo.a</samp>代替。
</p>
<p>在变量前<code>DESTDIR</code>以此方式为每个目标提供了<em>阶段安装</em> ，其中已安装的文件未直接放置在其预期位置，而是被复制到一个临时位置（ <code>DESTDIR</code> ）。但是，已安装的文件将保持其相对目录结构，并且不会修改任何嵌入的文件名。
</p>
<p>您不应该设置<code>DESTDIR</code>在你的<samp>Makefile</samp>根本然后默认情况下将文件安装到它们的预期位置。另外，指定<code>DESTDIR</code>不应以任何方式更改软件的操作，因此其值不应包含在任何文件内容中。
</p>
<p><code>DESTDIR</code>支持通常在包创建中使用。对于希望了解给定软件包将在何处安装的用户，以及使通常没有权限安装到受保护区域的用户在获得这些权限之前进行构建和安装，这也很有帮助。最后，它可以与以下工具一起使用，例如<code>stow</code> ，其中代码安装在一个位置，但是使用符号链接或特殊的安装操作使其看起来好像安装在其他位置。因此，我们强烈建议您支持GNU软件包<code>DESTDIR</code> ，尽管这不是绝对要求。
</p>

<hr>
<a name="Directory-Variables"></a>
<div class="header">
<p>下一页： <a href="#Standard-Targets" rel="next" accesskey="n">标准目标</a> ，上一篇： <a href="#DESTDIR" rel="prev" accesskey="p">DESTDIR</a> ，上一篇： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Variables-for-Installation-Directories"></a>
<h3 class="section">16.5安装目录的变量</h3>

<p>安装目录应始终由变量命名，因此很容易在非标准位置安装。这些变量的标准名称及其在GNU软件包中应具有的值如下所述。它们基于标准的文件系统布局；它的变体用于GNU / Linux和其他现代操作系统。
</p>
<p>要求安装程序在调用时覆盖这些值<code>make</code> （例如， <kbd>make prefix=/usr install</kbd> ） 要么<code>configure</code> （例如， <kbd>configure --prefix=/usr</kbd> ）。GNU软件包不应该尝试猜测哪个值应该适合将它们安装到的系统上的这些变量：使用此处指定的默认设置，以便所有GNU软件包的行为相同，从而使安装程序可以实现任何所需的布局。
</p>
<a name="index-directories_002c-creating-installation"></a>
<a name="index-installation-directories_002c-creating"></a>
<p>在安装所有安装目录及其父目录之前，应先创建它们（如有必要）。
</p>
<p>前两个变量设置安装的根目录。所有其他安装目录应该是这两个目录之一的子目录，并且不应将任何内容直接安装到这两个目录中。
</p>
<dl compact>
<dt><code>prefix</code></dt>
<dd><a name="index-prefix"></a>
<p>用于构造下面列出的变量的默认值的前缀。的默认值<code>prefix</code>应该<samp>/usr/local</samp> 。构建完整的GNU系统时，前缀为空，并且<samp>/usr</samp>将是一个符号链接<samp>/</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@prefix@</samp> '。）
</p>
<p>运行“ <samp>make install</samp> '具有不同的值<code>prefix</code>从用于构建程序<em>不</em>应该重新编译程序中的一个。
</p>
</dd>
<dt><code>exec_prefix</code></dt>
<dd><a name="index-exec_005fprefix"></a>
<p>用于构造下面列出的某些变量的默认值的前缀。的默认值<code>exec_prefix</code>应该<code>$(prefix)</code> 。（如果您使用的是Autoconf，请将其写为' <samp>@exec_prefix@</samp> '。）
</p>
<p>通常， <code>$(exec_prefix)</code>用于包含机器特定文件（例如可执行文件和子例程库）的目录，而<code>$(prefix)</code>直接用于其他目录。
</p>
<p>运行“ <samp>make install</samp> '具有不同的值<code>exec_prefix</code>从用于构建程序<em>不</em>应该重新编译程序中的一个。
</p></dd>
</dl>

<p>可执行程序安装在以下目录之一中。
</p>
<dl compact>
<dt><code>bindir</code></dt>
<dd><a name="index-bindir"></a>
<p>用于安装用户可以运行的可执行程序的目录。通常应该是<samp>/usr/local/bin</samp> ，但是写成<samp>$(exec_prefix)/bin</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@bindir@</samp> '。）
</p>
</dd>
<dt><code>sbindir</code></dt>
<dd><a name="index-sbindir"></a>
<p>用于安装可以从外壳运行的可执行程序的目录，但是通常仅对系统管理员有用。通常应该是<samp>/usr/local/sbin</samp> ，但是写成<samp>$(exec_prefix)/sbin</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@sbindir@</samp> '。）
</p>
</dd>
<dt><code>libexecdir</code></dt>
<dd><a name="index-libexecdir"></a>
<p>用于安装要由其他程序而非用户运行的可执行程序的目录。该目录通常应为<samp>/usr/local/libexec</samp> ，但是写成<samp>$(exec_prefix)/libexec</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@libexecdir@</samp> '。）
</p>
<p>'的定义<samp>libexecdir</samp>所有包都相同，因此您应该将数据安装在其子目录中。大多数软件包将其数据安装在<samp>$(libexecdir)/<var>package-name</var>/</samp> ，可能在其其他子目录中，例如<samp>$(libexecdir)/<var>package-name</var>/<var>machine</var>/<var>version</var></samp> 。
</p></dd>
</dl>

<p>程序在执行过程中使用的数据文件通过两种方式分为几类。
</p>
<ul>
<li>有些文件通常是由程序修改的；其他的则通常不会修改（尽管用户可以编辑其中的一些）。

</li><li>某些文件与体系结构无关，并且可以由站点上的所有计算机共享。有些依赖于体系结构，并且只能由相同类型和操作系统的机器共享；其他机器可能永远不会在两台机器之间共享。
</li></ul>

<p>这带来了六种不同的可能性。但是，除了目标文件和库之外，我们不鼓励使用依赖于体系结构的文件。使其他数据文件独立于体系结构要干净得多，而且通常也不难。
</p>
<p>以下是Makefiles用于指定目录的变量，以将各种文件放入其中：</p>
<dl compact>
<dt>' <samp>datarootdir</samp> '</dt>
<dd><p>只读的与体系结构无关的数据文件的目录树的根。通常应该是<samp>/usr/local/share</samp> ，但是写成<samp>$(prefix)/share</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@datarootdir@</samp> '。）' <samp>datadir</samp>的默认值基于此变量；也是如此<samp>infodir</samp> '，' <samp>mandir</samp> '， 和别的。
</p>
</dd>
<dt>' <samp>datadir</samp> '</dt>
<dd><p>用于为该程序安装特殊的，与体系结构无关的只读数据文件的目录。通常与“ <samp>datarootdir</samp> '，但我们使用两个单独的变量，因此您可以移动这些程序特定的文件，而无需更改Info文件，手册页等的位置。</p>
<p>通常应该是<samp>/usr/local/share</samp> ，但是写成<samp>$(datarootdir)</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@datadir@</samp> '。）
</p>
<p>'的定义<samp>datadir</samp>所有包都相同，因此您应该将数据安装在其子目录中。大多数软件包将其数据安装在<samp>$(datadir)/<var>package-name</var>/</samp> 。
</p>
</dd>
<dt>' <samp>sysconfdir</samp> '</dt>
<dd><p>用于安装与一台计算机有关的只读数据文件的目录，即用于配置主机的文件。邮件程序和网络配置文件， <samp>/etc/passwd</samp> ，依此类推。此目录中的所有文件应为普通ASCII文本文件。该目录通常应为<samp>/usr/local/etc</samp> ，但是写成<samp>$(prefix)/etc</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@sysconfdir@</samp> '。）
</p>
<p>不要在此目录中安装可执行文件（它们可能属于<samp>$(libexecdir)</samp>要么<samp>$(sbindir)</samp> ）。也不要安装在正常使用过程中修改过的文件（排除旨在改变系统配置的程序）。那些可能属于<samp>$(localstatedir)</samp> 。
</p>
</dd>
<dt>' <samp>sharedstatedir</samp> '</dt>
<dd><p>用于安装与体系结构无关的数据文件的目录，程序在运行时会对其进行修改。通常应该是<samp>/usr/local/com</samp> ，但是写成<samp>$(prefix)/com</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@sharedstatedir@</samp> '。）
</p>
</dd>
<dt>' <samp>localstatedir</samp> '</dt>
<dd><p>程序运行时会修改的，与一台特定计算机有关的数据文件的安装目录。用户永远不需要修改此目录中的文件来配置程序包的操作。将此类配置信息放入单独的文件中<samp>$(datadir)</samp>要么<samp>$(sysconfdir)</samp> 。<samp>$(localstatedir)</samp>通常应该是<samp>/usr/local/var</samp> ，但是写成<samp>$(prefix)/var</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@localstatedir@</samp> '。）
</p>
</dd>
<dt>' <samp>runstatedir</samp> '</dt>
<dd><p>程序运行时会修改的，用于安装数据文件的目录，该目录与一台特定计算机有关，并且其保存时间不必长于程序的执行时间，例如，通常是长期存在的，直到下一次重新启动。系统守护程序的PID文件是一种典型用法。此外，除非重新启动，否则不应清除此目录，而一般情况下， <samp>/tmp</samp> （ <code>TMPDIR</code> ）可以任意清洗。通常应该是<samp>/var/run</samp> ，但是写成<samp>$(localstatedir)/run</samp> 。将其作为单独的变量可以使用<samp>/run</samp>例如，如果需要的话。（如果您使用的是Autoconf 2.70或更高版本，则将其写为' <samp>@runstatedir@</samp> '。）
</p></dd>
</dl>

<p>这些变量指定用于安装某些特定类型文件的目录（如果您的程序具有它们的话）。每个GNU软件包都应该有Info文件，因此每个程序都需要<samp>infodir</samp> '，但并非所有人都需要' <samp>libdir</samp> ' 要么 ' <samp>lispdir</samp> '。
</p>
<dl compact>
<dt>' <samp>includedir</samp> '</dt>
<dd><p>用于安装头文件的目录，该头文件将由C包含在用户程序中<samp>#include</samp> ' 预处理程序指令。通常应该是<samp>/usr/local/include</samp> ，但是写成<samp>$(prefix)/include</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@includedir@</samp> '。）
</p>
<p>除GCC以外的大多数编译器不在目录中查找头文件<samp>/usr/local/include</samp> 。因此，以这种方式安装头文件仅对GCC有用。有时这不是问题，因为某些库仅旨在与GCC一起使用。但是某些库旨在与其他编译器一起使用。他们应该将头文件安装在两个位置，其中一个由<code>includedir</code>和一个由<code>oldincludedir</code> 。
</p>
</dd>
<dt>' <samp>oldincludedir</samp> '</dt>
<dd><p>安装目录<samp>#include</samp> '与GCC以外的编译器一起使用的头文件。通常应该是<samp>/usr/include</samp> 。（如果您使用的是Autoconf，则可以将其写为“ <samp>@oldincludedir@</samp> '。）
</p>
<p>Makefile命令应检查是否将<code>oldincludedir</code>是空的。如果是这样的话，他们不应该尝试使用它。他们应该取消头文件的第二次安装。
</p>
<p>除非标题来自同一软件包，否则软件包不应替换此目录中的现有标题。因此，如果您的Foo软件包提供了头文件<samp>foo.h</samp> ，则应将头文件安装在<code>oldincludedir</code>目录，如果其中一个（1）没有<samp>foo.h</samp>在那里或（2） <samp>foo.h</samp>存在于Foo包中。
</p>
<p>告诉是否<samp>foo.h</samp>来自Foo包，在文件中放入一个魔术字符串（注释的一部分），然后<code>grep</code>该字符串。
</p>
</dd>
<dt>' <samp>docdir</samp> '</dt>
<dd><p>用于安装此软件包的文档文件（Info除外）的目录。默认情况下，它应该是<samp>/usr/local/share/doc/<var>yourpkg</var></samp> ，但应写为<samp>$(datarootdir)/doc/<var>yourpkg</var></samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@docdir@</samp> '。）的<var>yourpkg</var>子目录（可能包含版本号）可防止具有共同名称的文件之间发生冲突，例如<samp>README</samp> 。
</p>
</dd>
<dt>' <samp>infodir</samp> '</dt>
<dd><p>用于安装此软件包的Info文件的目录。默认情况下，它应该是<samp>/usr/local/share/info</samp> ，但应写为<samp>$(datarootdir)/info</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@infodir@</samp> '。） <code>infodir</code>与...分开<code>docdir</code>与现有实践兼容。
</p>
</dd>
<dt>' <samp>htmldir</samp> '</dt>
<dt>' <samp>dvidir</samp> '</dt>
<dt>' <samp>pdfdir</samp> '</dt>
<dt>' <samp>psdir</samp> '</dt>
<dd><p>用于以特定格式安装文档文件的目录。它们都应该设置为<code>$(docdir)</code>默认。（如果您使用的是Autoconf，请将其写为' <samp>@htmldir@</samp> '，' <samp>@dvidir@</samp> '等）提供了几种文档翻译版本的软件包应将其安装在“ <samp>$(htmldir)/</samp> ' <var>ll</var> ，' <samp>$(pdfdir)/</samp> ' <var>ll</var>等<var>ll</var>是语言环境的缩写，例如“ <samp>en</samp> ' 要么 ' <samp>pt_BR</samp> '。
</p>
</dd>
<dt>' <samp>libdir</samp> '</dt>
<dd><p>目标文件和目标代码库的目录。不要在此处安装可执行文件，它们可能应该放入<samp>$(libexecdir)</samp>代替。的价值<code>libdir</code>通常应该是<samp>/usr/local/lib</samp> ，但是写成<samp>$(exec_prefix)/lib</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@libdir@</samp> '。）
</p>
</dd>
<dt>' <samp>lispdir</samp> '</dt>
<dd><p>该软件包中用于安装任何Emacs Lisp文件的目录。默认情况下，它应该是<samp>/usr/local/share/emacs/site-lisp</samp> ，但应写为<samp>$(datarootdir)/emacs/site-lisp</samp> 。
</p>
<p>如果您使用的是Autoconf，则将默认值写为“ <samp>@lispdir@</samp> '。为了要做 ' <samp>@lispdir@</samp>工作，您需要在以下几行中<samp>configure.ac</samp>文件：</p>
<div class="example">
<pre class="example">lispdir='${datarootdir}/emacs/site-lisp'
AC_SUBST(lispdir)
</pre></div>

</dd>
<dt>' <samp>localedir</samp> '</dt>
<dd><p>用于为此程序包安装特定于语言环境的消息目录的目录。默认情况下，它应该是<samp>/usr/local/share/locale</samp> ，但应写为<samp>$(datarootdir)/locale</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@localedir@</samp> '。）该目录通常每个语言环境都有一个子目录。
</p></dd>
</dl>

<p>Unix样式的手册页安装在以下其中之一中：</p>
<dl compact>
<dt>' <samp>mandir</samp> '</dt>
<dd><p>用于安装此软件包的手册页（如果有）的顶级目录。通常是<samp>/usr/local/share/man</samp> ，但您应将其写为<samp>$(datarootdir)/man</samp> 。（如果您使用的是Autoconf，请将其写为' <samp>@mandir@</samp> '。）
</p>
</dd>
<dt>' <samp>man1dir</samp> '</dt>
<dd><p>第1节手册页的安装目录。写成<samp>$(mandir)/man1</samp> 。
</p></dd>
<dt>' <samp>man2dir</samp> '</dt>
<dd><p>用于安装第2节手册页的目录。写成<samp>$(mandir)/man2</samp>
</p></dd>
<dt>' <samp>…</samp> '</dt>
<dd>
<p><strong>不要使任何GNU软件的主要文档成为手册页。而是在Texinfo中编写手册。手册页只是为了使人们在Unix上运行GNU软件而已，Unix仅是辅助应用程序。</strong>
</p>
</dd>
<dt>' <samp>manext</samp> '</dt>
<dd><p>已安装手册页的文件扩展名。它应包含一个句点，后跟适当的数字；通常应该是<samp>.1</samp> '。
</p>
</dd>
<dt>' <samp>man1ext</samp> '</dt>
<dd><p>已安装的第1节手册页的文件扩展名。
</p></dd>
<dt>' <samp>man2ext</samp> '</dt>
<dd><p>已安装的第2节手册页的文件扩展名。
</p></dd>
<dt>' <samp>…</samp> '</dt>
<dd><p>使用这些名称代替“ <samp>manext</samp> '如果软件包需要在手册的多个部分中安装手册页。
</p></dd>
</dl>

<p>最后，您应该设置以下变量：</p>
<dl compact>
<dt>' <samp>srcdir</samp> '</dt>
<dd><p>正在编译的源的目录。此变量的值通常由<code>configure</code>外壳脚本。（如果您使用的是Autoconf，请使用“ <samp>srcdir = @srcdir@</samp> '。）
</p></dd>
</dl>

<p>例如：</p>
<div class="smallexample">
<pre class="smallexample"># Common prefix for installation directories.
# NOTE: This directory must exist when you start the install.
prefix = /usr/local
datarootdir = $(prefix)/share
datadir = $(datarootdir)
exec_prefix = $(prefix)
# Where to put the executable for the command 'gcc'.
bindir = $(exec_prefix)/bin
# Where to put the directories used by the compiler.
libexecdir = $(exec_prefix)/libexec
# Where to put the Info files.
infodir = $(datarootdir)/info
</pre></div>

<p>如果您的程序将大量文件安装到标准的用户指定目录之一中，则将它们分组到该程序特有的子目录中可能会很有用。如果执行此操作，则应编写<code>install</code>创建这些子目录的规则。
</p>
<p>不要期望用户在上面列出的任何变量的值中包含子目录名称。为安装目录使用统一的变量名集的想法是使用户能够为几个不同的GNU软件包指定完全相同的值。为了使此功能有用，必须设计所有软件包，以便在用户这样做时可以合理地工作。
</p>
<p>有时，并非所有这些变量都可以在当前版本的Autoconf和/或Automake中实现。但是从Autoconf 2.60开始，我们相信所有这些都是。如果缺少任何内容，此处的描述将作为Autoconf将要实现的内容的规范。作为程序员，您可以使用Autoconf的开发版本，也可以避免使用这些变量，直到发布了一个支持它们的稳定版本为止。
</p>

<hr>
<a name="Standard-Targets"></a>
<div class="header">
<p>下一页： <a href="#Install-Command-Categories" rel="next" accesskey="n">安装命令类别</a> ，上一页： <a href="#Directory-Variables" rel="prev" accesskey="p">目录变量</a> ，向上： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Standard-Targets-for-Users"></a>
<h3 class="section">16.6用户的标准目标</h3>

<p>所有GNU程序的Makefile中都应具有以下目标：</p>
<dl compact>
<dt>' <samp>all</samp> '</dt>
<dd><p>编译整个程序。这应该是默认目标。该目标无需重建任何文档文件；信息文件通常应包含在发行版中，并且仅在明确要求时才制作DVI（和其他文档格式）文件。
</p>
<p>默认情况下，Make规则应编译并与“ <samp>-g</samp> '，以便可执行程序具有调试符号。否则，面对崩溃，您本质上是无能为力的，并且通常很难通过全新的版本进行复制。
</p>
</dd>
<dt>' <samp>install</samp> '</dt>
<dd><p>编译程序，然后将可执行文件，库等复制到实际应使用的文件名中。如果有一个简单的测试可以验证程序是否已正确安装，则此目标应运行该测试。</p>
<p>安装可执行文件时，请勿剥离它们。这有助于以后可能需要进行最终调试，并且如今磁盘空间很便宜，动态加载程序通常可确保在正常执行期间不加载调试段。需要剥离二进制文件的用户可以调用<code>install-strip</code>目标做到这一点。
</p>
<p>如果可能的话，写上<code>install</code>目标规则，以便它不会修改程序生成目录中的任何内容，前提是“ <samp>make all</samp>刚刚完成。这对于使用一个用户名构建程序并使用另一个用户名进行安装很方便。
</p>
<p>如果文件尚不存在，这些命令应创建所有要在其中安装文件的目录。这包括指定为变量值的目录<code>prefix</code>和<code>exec_prefix</code> ，以及所需的所有子目录。一种方法是通过<code>installdirs</code>目标如下所述。
</p>
<p>使用 ' <samp>-</samp> '在安装手册页的任何命令之前，这样<code>make</code>将忽略任何错误。这是在某些系统未安装Unix手册页文档系统的情况下。
</p>
<p>安装信息文件的方法是将它们复制到<samp>$(infodir)</samp>与<code>$(INSTALL_DATA)</code> （请参阅<a href="#Command-Variables">命令变量</a> ），然后运行<code>install-info</code>程序（如果存在）。<code>install-info</code>是一个编辑信息的程序<samp>dir</samp>用于添加或更新给定信息文件的菜单项的文件；它是Texinfo软件包的一部分。
</p>
<p>这是安装信息文件的示例规则，该文件还尝试处理一些其他情况，例如<code>install-info</code>不存在。
</p>
<div class="smallexample">
<pre class="smallexample">do-install-info: foo.info installdirs
        $(NORMAL_INSTALL)
# Prefer an info file in . to one in srcdir.
        if test -f foo.info; then d=.; \
         else d=&quot;$(srcdir)&quot;; fi; \
        $(INSTALL_DATA) $$d/foo.info \
          &quot;$(DESTDIR)$(infodir)/foo.info&quot;
# Run install-info only if it exists.
# Use 'if' instead of just prepending '-' to the
# line so we notice real errors from install-info.
# Use '$(SHELL) -c' because some shells do not
# fail gracefully when there is an unknown command.
        $(POST_INSTALL)
        if $(SHELL) -c 'install-info --version' \
           &gt;/dev/null 2&gt;&amp;1; then \
          install-info --dir-file=&quot;$(DESTDIR)$(infodir)/dir&quot; \
                       &quot;$(DESTDIR)$(infodir)/foo.info&quot;; \
        else true; fi
</pre></div>

<p>当写<code>install</code>目标，您必须将所有命令分为三类：普通命令， <em>安装前</em>命令和<em>安装后</em>命令。请参阅<a href="#Install-Command-Categories">安装命令类别</a> 。
</p>
</dd>
<dt>' <samp>install-html</samp> '</dt>
<dt>' <samp>install-dvi</samp> '</dt>
<dt>' <samp>install-pdf</samp> '</dt>
<dt>' <samp>install-ps</samp> '</dt>
<dd><p>这些目标以非Info格式安装文档。如果需要该格式，则打算由安装软件包的人员显式调用它们。GNU更喜欢Info文件，因此这些文件必须由<code>install</code>目标。
</p>
<p>当您要安装许多文档文件时，建议您安排这些目标安装在相应安装目录的子目录中，以免发生冲突和混乱。 <code>htmldir</code> 。举一个例子，如果您的软件包有多本手册，并且您希望安装包含许多文件的HTML文档（例如， <code>makeinfo --html</code> ），您肯定会想使用子目录，否则，不同手册中的两个具有相同名称的节点将相互覆盖。
</p>
<p>请做这些<code>install-<var>format</var></code>目标调用命令<var>format</var>目标，例如，通过<var>format</var>依赖性。
</p>
</dd>
<dt>' <samp>uninstall</samp> '</dt>
<dd><p>删除所有已安装的文件，即“ <samp>install</samp> '和' <samp>install-*</samp>目标创建。
</p>
<p>该规则不应修改完成编译的目录，而只能修改安装文件的目录。
</p>
<p>与安装命令一样，卸载命令也分为三类。请参阅<a href="#Install-Command-Categories">安装命令类别</a> 。
</p>
</dd>
<dt>' <samp>install-strip</samp> '</dt>
<dd><p>喜欢<code>install</code> ，但是在安装可执行文件时将其剥离。在简单的情况下，此目标可以使用<code>install</code>定位的方法很简单：</p>
<div class="smallexample">
<pre class="smallexample">install-strip:
        $(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
                install
</pre></div>

<p>但是，如果该软件包安装了脚本以及实际的可执行文件，则<code>install-strip</code>目标不能只是参考<code>install</code>目标;它必须剥离可执行文件，而不是脚本。
</p>
<p><code>install-strip</code>不应在构建目录中删除要复制以安装的可执行文件。它应该只剥离已安装的副本。
</p>
<p>通常，除非您确定程序没有错误，否则我们建议您不要剥离可执行文件。但是，如果有错误，则安装剥离的可执行文件以实际执行，同时将未剥离的可执行文件保存在其他位置可能是合理的。
</p>
</dd>
<dt>' <samp>clean</samp> '</dt>
<dd><p>删除当前目录中通常通过构建程序创建的所有文件。如果此makefile创建了其他目录中的文件，也请删除它们。但是，请勿删除记录配置的文件。还保留可以通过构建生成的文件，但通常不是因为发行版附带了这些文件。无需删除使用'创建的父目录<samp>mkdir -p</samp> ”，因为它们本来可以存在的。
</p>
<p>删除<samp>.dvi</samp>文件，如果它们不是分发的一部分。
</p>
</dd>
<dt>' <samp>distclean</samp> '</dt>
<dd><p>删除当前目录中（或由此Makefile创建的）通过配置或构建程序创建的所有文件。如果您解压缩了源文件并构建了程序而未创建任何其他文件，则“ <samp>make distclean</samp> '应该只保留分发中的文件。但是，无需删除使用“ <samp>mkdir -p</samp> ”，因为它们本来可以存在的。
</p>
</dd>
<dt>' <samp>mostlyclean</samp> '</dt>
<dd><p>喜欢 ' <samp>clean</samp> ”，但可能会删除一些人们通常不想重新编译的文件。例如，“ <samp>mostlyclean</samp> 'GCC的目标不会删除<samp>libgcc.a</samp> ，因为重新编译几乎没有必要，而且会花费很多时间。
</p>
</dd>
<dt>' <samp>maintainer-clean</samp> '</dt>
<dd><p>删除几乎可以使用此Makefile重建的所有内容。通常包括被删除的所有内容<code>distclean</code>以及更多内容：Bison生成的C源文件，标签表，信息文件等。
</p>
<p>我们说“几乎所有内容”的原因是运行命令“ <samp>make maintainer-clean</samp> '不应删除<samp>configure</samp>即使<samp>configure</samp>可以使用Makefile中的规则重新制作。更普遍， ' <samp>make maintainer-clean</samp> '不应删除运行所需的任何内容<samp>configure</samp>然后开始构建程序。另外，也无需删除使用“ <samp>mkdir -p</samp> ”，因为它们本来可以存在的。这些是唯一的例外。 <code>maintainer-clean</code>应该删除所有其他可以重建的内容。
</p>
<p>' <samp>maintainer-clean</samp>目标仅供软件包的维护者使用，而不是普通用户使用。您可能需要特殊的工具来重构某些“ <samp>make maintainer-clean</samp>删除。由于这些文件通常包含在发行版中，因此我们不小心使其易于重构。如果您发现需要重新打包整个发行版，请不要怪我们。
</p>
<p>为了帮助用户意识到这一点，特殊命令<code>maintainer-clean</code>目标应从以下两个开始：</p>
<div class="smallexample">
<pre class="smallexample">@echo 'This command is intended for maintainers to use; it'
@echo 'deletes files that may need special tools to rebuild.'
</pre></div>

</dd>
<dt>' <samp>TAGS</samp> '</dt>
<dd><p>更新此程序的标签表。
</p>
</dd>
<dt>' <samp>info</samp> '</dt>
<dd><p>生成所需的任何信息文件。编写规则的最佳方法如下：</p>
<div class="smallexample">
<pre class="smallexample">info: foo.info

foo.info: foo.texi chap1.texi chap2.texi
        $(MAKEINFO) $(srcdir)/foo.texi
</pre></div>

<p>您必须定义变量<code>MAKEINFO</code>在Makefile中。它应该运行<code>makeinfo</code>程序，它是Texinfo发行版的一部分。
</p>
<p>通常，GNU发行版随Info文件一起提供，这意味着Info文件位于源目录中。因此，信息文件的制作规则应在源目录中对其进行更新。用户生成软件包时，通常Make不会更新Info文件，因为它们已经是最新的了。
</p>
</dd>
<dt>' <samp>dvi</samp> '</dt>
<dt>' <samp>html</samp> '</dt>
<dt>' <samp>pdf</samp> '</dt>
<dt>' <samp>ps</samp> '</dt>
<dd><p>生成给定格式的文档文件。这些目标应始终存在，但如果无法生成给定的输出格式，则任何目标或所有目标都可以是空操作。这些目标不应是<code>all</code>目标;用户必须手动调用它们。
</p>
<p>这是从Texinfo生成DVI文件的示例规则：</p>
<div class="smallexample">
<pre class="smallexample">dvi: foo.dvi

foo.dvi: foo.texi chap1.texi chap2.texi
        $(TEXI2DVI) $(srcdir)/foo.texi
</pre></div>

<p>您必须定义变量<code>TEXI2DVI</code>在Makefile中。它应该运行程序<code>texi2dvi</code> ，它是Texinfo发行版的一部分。 （ <code>texi2dvi</code>使用TeX进行格式化的实际工作。TeX不随Texinfo一起分发。）或者，仅编写依赖项，并允许GNU <code>make</code>提供命令。
</p>
<p>这是另一个示例，该示例用于从Texinfo生成HTML：</p>
<div class="smallexample">
<pre class="smallexample">html: foo.html

foo.html: foo.texi chap1.texi chap2.texi
        $(TEXI2HTML) $(srcdir)/foo.texi
</pre></div>

<p>同样，您将定义变量<code>TEXI2HTML</code>在Makefile中；例如，它可能会运行<code>makeinfo --no-split --html</code> （ <code>makeinfo</code>是Texinfo发行版的一部分）。
</p>
</dd>
<dt>' <samp>dist</samp> '</dt>
<dd><p>为此程序创建一个分发tar文件。应该设置tar文件，以便tar文件中的文件名以子目录名开头，该子目录名是其分发包的名称。此名称可以包含版本号。
</p>
<p>例如，GCC版本1.40的发行版tar文件解压缩到名为的子目录中<samp>gcc-1.40</samp> 。
</p>
<p>最简单的方法是创建一个适当命名的子目录，使用<code>ln</code>要么<code>cp</code>在其中安装适当的文件，然后<code>tar</code>该子目录。
</p>
<p>用以下命令压缩tar文件<code>gzip</code> 。例如，名为GCC 1.40的实际分发文件称为<samp>gcc-1.40.tar.gz</samp> 。还可以支持其他免费压缩格式。
</p>
<p>的<code>dist</code>目标应明确依赖分发中的所有非源文件，以确保它们在分发中是最新的。请参阅在<cite>GNU编码标准中</cite> <a href="http://www.gnu.org/prep/standards/standards.html#Releases">发布版本</a> 。
</p>
</dd>
<dt>' <samp>check</samp> '</dt>
<dd><p>执行自检（如果有）。用户必须在运行测试之前构建程序，但无需安装该程序。您应该编写自检程序，以便在构建程序但未安装程序时它们可以工作。
</p></dd>
</dl>

<p>对于有用的程序，建议将以下目标用作常规名称。
</p>
<dl compact>
<dt><code>installcheck</code></dt>
<dd><p>执行安装测试（如果有）。用户必须在运行测试之前构建并安装程序。你不应该认为<samp>$(bindir)</samp>在搜索路径中。
</p>
</dd>
<dt><code>installdirs</code></dt>
<dd><p>添加名为“ <samp>installdirs</samp> '创建安装文件的目录及其父目录。有一个脚本叫做<samp>mkinstalldirs</samp>这很方便；您可以在Gnulib包中找到它。您可以使用如下规则：</p>
<div class="smallexample">
<pre class="smallexample"># Make sure all installation directories (e.g. $(bindir))
# actually exist by making them if necessary.
installdirs: mkinstalldirs
        $(srcdir)/mkinstalldirs $(bindir) $(datadir) \
                                $(libdir) $(infodir) \
                                $(mandir)
</pre></div>

<p>或者，如果您希望支持<code>DESTDIR</code> （强烈建议），</p>
<div class="smallexample">
<pre class="smallexample"># Make sure all installation directories (e.g. $(bindir))
# actually exist by making them if necessary.
installdirs: mkinstalldirs
        $(srcdir)/mkinstalldirs \
            $(DESTDIR)$(bindir) $(DESTDIR)$(datadir) \
            $(DESTDIR)$(libdir) $(DESTDIR)$(infodir) \
            $(DESTDIR)$(mandir)
</pre></div>

<p>该规则不应修改完成编译的目录。它除了创建安装目录外什么都不做。
</p></dd>
</dl>

<hr>
<a name="Install-Command-Categories"></a>
<div class="header">
<p>上一篇： <a href="#Standard-Targets" rel="prev" accesskey="p">标准目标</a> ，上一篇： <a href="#Makefile-Conventions" rel="up" accesskey="u">Makefile约定</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Install-Command-Categories-1"></a>
<h3 class="section">16.7安装命令类别</h3>

<a name="index-pre_002dinstallation-commands"></a>
<a name="index-post_002dinstallation-commands"></a>
<p>当写<code>install</code>目标，您必须将所有命令分为三类：普通命令， <em>安装前</em>命令和<em>安装后</em>命令。
</p>
<p>普通命令将文件移至适当位置，并设置其模式。除了完全来自其所属软件包的文件以外，他们不得更改任何文件。
</p>
<p>安装前和安装后命令可能会更改其他文件；特别是，他们可以编辑全局配置文件或数据库。
</p>
<p>安装前命令通常在常规命令之前执行，安装后命令通常在常规命令之后运行。
</p>
<p>安装后命令最常见的用途是运行<code>install-info</code> 。用普通命令无法完成此操作，因为它会更改文件（信息目录），该文件并非完全来自安装的软件包。这是安装后的命令，因为它需要在安装软件包的Info文件的普通命令之后执行。
</p>
<p>大多数程序不需要任何预安装命令，但是我们有此功能，以防万一。
</p>
<p>要对命令进行分类<code>install</code>规则分为这三个类别，在其中插入<em>类别行</em> 。类别行指定后续命令的类别。
</p>
<p>类别行由一个选项卡和对特殊Make变量的引用以及最后的可选注释组成。您可以使用三个变量，每个变量一个。变量名称指定类别。在常规执行中，类别行是无操作的，因为这三个Make变量通常是未定义的（并且您<em>不应该</em>在makefile中定义它们）。
</p>
<p>这是三个可能的类别行，每个类别行都有一个注释，解释其含义：</p>
<div class="smallexample">
<pre class="smallexample">        $(PRE_INSTALL)     # <span class="roman">Pre-install commands follow.</span>
        $(POST_INSTALL)    # <span class="roman">Post-install commands follow.</span>
        $(NORMAL_INSTALL)  # <span class="roman">Normal commands follow.</span>
</pre></div>

<p>如果您在开始时不使用类别行<code>install</code>规则，直到第一个类别行，所有命令都被归类为普通命令。如果您不使用任何类别行，则所有命令均被归类为普通命令。
</p>
<p>这些是类别的行<code>uninstall</code> ：</p>
<div class="smallexample">
<pre class="smallexample">        $(PRE_UNINSTALL)     # <span class="roman">Pre-uninstall commands follow.</span>
        $(POST_UNINSTALL)    # <span class="roman">Post-uninstall commands follow.</span>
        $(NORMAL_UNINSTALL)  # <span class="roman">Normal commands follow.</span>
</pre></div>

<p>通常，将使用pre-uninstall命令从Info目录中删除条目。
</p>
<p>如果<code>install</code>要么<code>uninstall</code>目标具有作为安装子例程的任何依赖项，那么您应该以类别行开头<em>每个</em>依赖项的命令，并以类别行开头主要目标的命令。这样，您可以确保将每个命令放置在正确的类别中，而与实际运行的依赖项无关。
</p>
<p>除以下内容外，安装前和安装后命令不应运行任何程序：</p>
<div class="example">
<pre class="example">[ basename bash cat chgrp chmod chown cmp cp dd diff echo
egrep expand expr false fgrep find getopt grep gunzip gzip
hostname install install-info kill ldconfig ln ls md5sum
mkdir mkfifo mknod mv printenv pwd rm rmdir sed sort tee
test touch true uname xargs yes
</pre></div>

<a name="index-binary-packages"></a>
<p>以这种方式区分命令的原因是为了制作二进制软件包。通常，二进制软件包包含所有需要安装的可执行文件和其他文件，并且具有自己的安装方法-因此，它不需要运行常规的安装命令。但是，安装二进制软件包确实需要执行安装前和安装后命令。
</p>
<p>生成二进制软件包的程序通过提取安装前和安装后命令来工作。这是提取预安装命令的一种方法（ <samp>-s</samp>选择<code>make</code>需要使有关输入子目录的消息静音）：</p>
<div class="smallexample">
<pre class="smallexample">make -s -n install -o all \
      PRE_INSTALL=pre-install \
      POST_INSTALL=post-install \
      NORMAL_INSTALL=normal-install \
  | gawk -f pre-install.awk
</pre></div>

<p>文件在哪里<samp>pre-install.awk</samp>可能包含以下内容：</p>
<div class="smallexample">
<pre class="smallexample">$0 ~ /^(normal-install|post-install)[ \t]*$/ {on = 0}
on {print $0}
$0 ~ /^pre-install[ \t]*$/ {on = 1}
</pre></div>

<hr>
<a name="Quick-Reference"></a>
<div class="header">
<p>下一页： <a href="#Error-Messages" rel="next" accesskey="n">错误消息</a> ，上一页： <a href="#Makefile-Conventions" rel="prev" accesskey="p">Makefile约定</a> ，上一页： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Quick-Reference-1"></a>
<h2 class="appendix">附录A快速参考</h2>

<p>本附录总结了GNU的指令，文本操作函数和特殊变量<code>make</code>了解。有关其他摘要，请参见<a href="#Special-Targets">特殊目标</a> ， <a href="#Catalogue-of-Rules">内置规则目录</a>和<a href="#Options-Summary">选项</a>摘要。
</p>
<p>这是指令GNU的摘要<code>make</code>认识到：</p>
<dl compact>
<dt><code>define <var>variable</var></code></dt>
<dt><code>define <var>variable</var> =</code></dt>
<dt><code>define <var>variable</var> :=</code></dt>
<dt><code>define <var>variable</var> ::=</code></dt>
<dt><code>define <var>variable</var> +=</code></dt>
<dt><code>define <var>variable</var> ?=</code></dt>
<dt><code>endef</code></dt>
<dd><p>定义多行变量。<br>请参阅<a href="#Multi_002dLine">多行</a> 。
</p>
</dd>
<dt><code>undefine <var>variable</var></code></dt>
<dd><p>未定义变量。<br>请参阅<a href="#Undefine-Directive">未定义指令</a> 。
</p>
</dd>
<dt><code>ifdef <var>variable</var></code></dt>
<dt><code>ifndef <var>variable</var></code></dt>
<dt><code>ifeq (<var>a</var>,<var>b</var>)</code></dt>
<dt><code>ifeq "<var>a</var>" "<var>b</var>"</code></dt>
<dt><code>ifeq '<var>a</var>' '<var>b</var>'</code></dt>
<dt><code>ifneq (<var>a</var>,<var>b</var>)</code></dt>
<dt><code>ifneq "<var>a</var>" "<var>b</var>"</code></dt>
<dt><code>ifneq '<var>a</var>' '<var>b</var>'</code></dt>
<dt><code>else</code></dt>
<dt><code>endif</code></dt>
<dd><p>有条件地评估部分makefile。<br>请参阅<a href="#Conditionals">条件句</a> 。
</p>
</dd>
<dt><code>include <var>file</var></code></dt>
<dt><code>-include <var>file</var></code></dt>
<dt><code>sinclude <var>file</var></code></dt>
<dd><p>包括另一个makefile。<br>请参阅<a href="#Include">包括其他Makefile</a> 。
</p>
</dd>
<dt><code>override <var>variable-assignment</var></code></dt>
<dd><p>定义一个变量，覆盖任何先前的定义，甚至覆盖命令行中的任何一个。<br>查看<a href="#Override-Directive">该<code>override</code>指令</a> 。
</p>
</dd>
<dt><code>export</code></dt>
<dd><p>告诉<code>make</code>默认情况下将所有变量导出到子进程。<br>请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> 。
</p>
</dd>
<dt><code>export <var>variable</var></code></dt>
<dt><code>export <var>variable-assignment</var></code></dt>
<dt><code>unexport <var>variable</var></code></dt>
<dd><p>告诉<code>make</code>是否将特定变量导出到子进程。<br>请参见将<a href="#Variables_002fRecursion">变量传达给<code>make</code></a> 。
</p>
</dd>
<dt><code>private <var>variable-assignment</var></code></dt>
<dd><p>不允许先决条件继承此变量分配。<br>请参见<a href="#Suppressing-Inheritance">抑制继承</a> 。
</p>
</dd>
<dt><code>vpath <var>pattern</var> <var>path</var></code></dt>
<dd><p>指定与“ <samp>%</samp>模式。<br>查看<a href="#Selective-Search">该<code>vpath</code>指令</a> 。
</p>
</dd>
<dt><code>vpath <var>pattern</var></code></dt>
<dd><p>删除先前为所指定的所有搜索路径<var>pattern</var> 。
</p>
</dd>
<dt><code>vpath</code></dt>
<dd><p>删除所有以前指定的所有搜索路径<code>vpath</code>指示。
</p></dd>
</dl>

<p>这是内置函数的摘要（请参见<a href="#Functions">Functions</a> ）：</p>
<dl compact>
<dt><code>$(subst <var>from</var>,<var>to</var>,<var>text</var>)</code></dt>
<dd><p>更换<var>from</var>与<var>to</var>在<var>text</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(patsubst <var>pattern</var>,<var>replacement</var>,<var>text</var>)</code></dt>
<dd><p>替换单词匹配<var>pattern</var>与<var>replacement</var>在<var>text</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(strip <var>string</var>)</code></dt>
<dd><p>从中删除多余的空白字符<var>string</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(findstring <var>find</var>,<var>text</var>)</code></dt>
<dd><p>定位<var>find</var>在<var>text</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(filter <var>pattern</var>…,<var>text</var>)</code></dt>
<dd><p>在中选择单词<var>text</var>匹配其中之一<var>pattern</var>话。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(filter-out <var>pattern</var>…,<var>text</var>)</code></dt>
<dd><p>在中选择单词<var>text</var> <em>不</em>符合任何<var>pattern</var>话。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(sort <var>list</var>)</code></dt>
<dd><p>排序中的单词<var>list</var>从字典上看，删除重复项。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(word <var>n</var>,<var>text</var>)</code></dt>
<dd><p>提取<var>n</var>的第一个字（起源） <var>text</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(words <var>text</var>)</code></dt>
<dd><p>计算中的单词数<var>text</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(wordlist <var>s</var>,<var>e</var>,<var>text</var>)</code></dt>
<dd><p>返回中的单词列表<var>text</var>从<var>s</var>至<var>e</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(firstword <var>names</var>…)</code></dt>
<dd><p>提取的第一个单词<var>names</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(lastword <var>names</var>…)</code></dt>
<dd><p>提取的最后一句话<var>names</var> 。<br>请参见<a href="#Text-Functions">字符串替换和分析的函数</a> 。
</p>
</dd>
<dt><code>$(dir <var>names</var>…)</code></dt>
<dd><p>提取每个文件名的目录部分。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(notdir <var>names</var>…)</code></dt>
<dd><p>提取每个文件名的非目录部分。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(suffix <var>names</var>…)</code></dt>
<dd><p>提取后缀（最后一个' <samp>.</samp> '和后面的字符）。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(basename <var>names</var>…)</code></dt>
<dd><p>提取每个文件名的基本名称（不带后缀的名称）。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(addsuffix <var>suffix</var>,<var>names</var>…)</code></dt>
<dd><p>附加<var>suffix</var>到每个字<var>names</var> 。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(addprefix <var>prefix</var>,<var>names</var>…)</code></dt>
<dd><p>前置<var>prefix</var>到每个字<var>names</var> 。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(join <var>list1</var>,<var>list2</var>)</code></dt>
<dd><p>连接两个平行的单词列表。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(wildcard <var>pattern</var>…)</code></dt>
<dd><p>查找与Shell文件名模式匹配的文件名（ <em>而不是</em> ' <samp>%</samp>模式）。<br>见<a href="#Wildcard-Function">功能<code>wildcard</code></a> 。
</p>
</dd>
<dt><code>$(realpath <var>names</var>…)</code></dt>
<dd><p>对于中的每个文件名<var>names</var> ，扩展为不包含任何绝对名称的绝对名称<code>.</code> ， <code>..</code> ，也没有符号链接。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(abspath <var>names</var>…)</code></dt>
<dd><p>对于中的每个文件名<var>names</var> ，扩展为不包含任何绝对名称的绝对名称<code>.</code>要么<code>..</code>组件，但保留符号链接。<br>请参见<a href="#File-Name-Functions">文件名功能</a> 。
</p>
</dd>
<dt><code>$(error <var>text</var>…)</code></dt>
<dd><p>评估此功能后， <code>make</code>生成致命错误消息<var>text</var> 。<br>请参见<a href="#Make-Control-Functions">控制Make的函数</a> 。
</p>
</dd>
<dt><code>$(warning <var>text</var>…)</code></dt>
<dd><p>评估此功能后， <code>make</code>生成警告消息<var>text</var> 。<br>请参见<a href="#Make-Control-Functions">控制Make的函数</a> 。
</p>
</dd>
<dt><code>$(shell <var>command</var>)</code></dt>
<dd><p>执行一个shell命令并返回其输出。<br>查看<a href="#Shell-Function">该<code>shell</code>功能</a> 。
</p>
</dd>
<dt><code>$(origin <var>variable</var>)</code></dt>
<dd><p>返回描述如何<code>make</code>变量<var>variable</var>被定义。<br>查看<a href="#Origin-Function">该<code>origin</code>功能</a> 。
</p>
</dd>
<dt><code>$(flavor <var>variable</var>)</code></dt>
<dd><p>返回描述风味的字符串<code>make</code>变量<var>variable</var> 。<br>查看<a href="#Flavor-Function">该<code>flavor</code>功能</a> 。
</p>
</dd>
<dt><code>$(foreach <var>var</var>,<var>words</var>,<var>text</var>)</code></dt>
<dd><p>评估<var>text</var>与<var>var</var>绑定到每个单词<var>words</var> ，并连接结果。<br>查看<a href="#Foreach-Function">该<code>foreach</code>功能</a> 。
</p>
</dd>
<dt><code>$(if <var>condition</var>,<var>then-part</var>[,<var>else-part</var>])</code></dt>
<dd><p>评估条件<var>condition</var> ;如果它是非空的，则替换扩展<var>then-part</var>否则替代扩展<var>else-part</var> 。<br>请参阅<a href="#Conditional-Functions">条件函数</a> 。
</p>
</dd>
<dt><code>$(or <var>condition1</var>[,<var>condition2</var>[,<var>condition3</var>…]])</code></dt>
<dd><p>评估每个条件<var>conditionN</var>一次一个;替代第一个非空扩展。如果所有扩展均为空，则替换为空字符串。<br>请参阅<a href="#Conditional-Functions">条件函数</a> 。
</p>
</dd>
<dt><code>$(and <var>condition1</var>[,<var>condition2</var>[,<var>condition3</var>…]])</code></dt>
<dd><p>评估每个条件<var>conditionN</var>一次一个;如果有任何扩展导致用空字符串替换空字符串。如果所有扩展均产生非空字符串，请替换最后一个扩展<var>condition</var> 。<br>请参阅<a href="#Conditional-Functions">条件函数</a> 。
</p>
</dd>
<dt><code>$(call <var>var</var>,<var>param</var>,…)</code></dt>
<dd><p>评估变量<var>var</var>替换任何对<code>$(1)</code> ， <code>$(2)</code>与第一，第二，等等。 <var>param</var>价值观。<br>查看<a href="#Call-Function">该<code>call</code>功能</a> 。
</p>
</dd>
<dt><code>$(eval <var>text</var>)</code></dt>
<dd><p>评估<var>text</var>然后将结果读取为makefile命令。扩展为空字符串。<br>查看<a href="#Eval-Function">该<code>eval</code>功能</a> 。
</p>
</dd>
<dt><code>$(file <var>op</var> <var>filename</var>,<var>text</var>)</code></dt>
<dd><p>展开参数，然后打开文件<var>filename</var>使用方式<var>op</var>和写<var>text</var>到该文件。<br>查看<a href="#File-Function">该<code>file</code>功能</a> 。
</p>
</dd>
<dt><code>$(value <var>var</var>)</code></dt>
<dd><p>评估变量的内容<var>var</var> ，没有对其执行扩展。<br>查看<a href="#Value-Function">该<code>value</code>功能</a> 。
</p></dd>
</dl>

<p>这是自动变量的摘要。有关完整信息，请参见<a href="#Automatic-Variables">自动变量</a> 。
</p>
<dl compact>
<dt><code>$@</code></dt>
<dd><p>目标的文件名。
</p>
</dd>
<dt><code>$%</code></dt>
<dd><p>当目标是存档成员时，目标成员名称。
</p>
</dd>
<dt><code>$<</code></dt>
<dd><p>第一个先决条件的名称。
</p>
</dd>
<dt><code>$?</code></dt>
<dd><p>比目标更新的所有先决条件的名称，它们之间有空格。对于作为存档成员的先决条件，仅使用命名成员（请参见<a href="#Archives">Archives</a> ）。
</p>
</dd>
<dt><code>$^</code></dt>
<dt><code>$+</code></dt>
<dd><p>所有先决条件的名称，它们之间有空格。对于作为存档成员的先决条件，仅使用命名成员（请参见<a href="#Archives">Archives</a> ）。的价值<code>$^</code>省略重复的先决条件，而<code>$+</code>保留它们并保留其顺序。
</p>
</dd>
<dt><code>$*</code></dt>
<dd><p>隐式规则与之匹配的词干（请参见<a href="#Pattern-Match">模式匹配</a> ）。
</p>
</dd>
<dt><code>$(@D)</code></dt>
<dt><code>$(@F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$@</code> 。
</p>
</dd>
<dt><code>$(*D)</code></dt>
<dt><code>$(*F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$*</code> 。
</p>
</dd>
<dt><code>$(%D)</code></dt>
<dt><code>$(%F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$%</code> 。
</p>
</dd>
<dt><code>$(<D)</code></dt>
<dt><code>$(<F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$<</code> 。
</p>
</dd>
<dt><code>$(^D)</code></dt>
<dt><code>$(^F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$^</code> 。
</p>
</dd>
<dt><code>$(+D)</code></dt>
<dt><code>$(+F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$+</code> 。
</p>
</dd>
<dt><code>$(?D)</code></dt>
<dt><code>$(?F)</code></dt>
<dd><p>目录部分和目录中文件部分<code>$?</code> 。
</p></dd>
</dl>

<p>这些变量由GNU专门使用<code>make</code> ：</p>
<dl compact>
<dt><code>MAKEFILES</code></dt>
<dd>
<p>每次调用都会读取的Makefile <code>make</code> 。<br>见<a href="#MAKEFILES-Variable">变量<code>MAKEFILES</code></a> 。
</p>
</dd>
<dt><code>VPATH</code></dt>
<dd>
<p>在当前目录中找不到文件的目录搜索路径。<br>看到<a href="#General-Search"><code>VPATH</code>所有先决条件的搜索路径</a> 。
</p>
</dd>
<dt><code>SHELL</code></dt>
<dd>
<p>系统默认命令解释器的名称，通常<samp>/bin/sh</samp> 。你可以设定<code>SHELL</code>在makefile中更改用于运行配方的shell。请参见<a href="#Execution">配方执行</a> 。的<code>SHELL</code>从环境导入和导出到环境时，将特别处理变量。请参阅<a href="#Choosing-the-Shell">选择外壳</a> 。
</p>
</dd>
<dt><code>MAKESHELL</code></dt>
<dd>
<p>仅在MS-DOS上，由所使用的命令解释器的名称<code>make</code> 。此值优先于的值<code>SHELL</code> 。请参阅<a href="#Execution">MAKESHELL变量</a> 。
</p>
</dd>
<dt><code>MAKE</code></dt>
<dd>
<p>用哪个名字<code>make</code>被调用。在配方中使用此变量具有特殊含义。看看<a href="#MAKE-Variable">如何<code>MAKE</code>可变作品</a> 。
</p>
</dd>
<dt><code>MAKE_VERSION</code></dt>
<dd>
<p>内置变量“ <samp>MAKE_VERSION</samp> '扩展为GNU的版本号<code>make</code>程序。
<a name="index-MAKE_005fVERSION"></a>
</p>
</dd>
<dt><code>MAKE_HOST</code></dt>
<dd>
<p>内置变量“ <samp>MAKE_HOST</samp> '扩展为代表GNU主机的字符串<code>make</code>可以继续运行。
<a name="index-MAKE_005fHOST"></a>
</p>
</dd>
<dt><code>MAKELEVEL</code></dt>
<dd>
<p>递归级别数（ <code>make</code> s）。<br>请参阅<a href="#Variables_002fRecursion">变量/递归</a> 。
</p>
</dd>
<dt><code>MAKEFLAGS</code></dt>
<dd>
<p>给予的标志<code>make</code> 。您可以在环境中或在makefile中设置它来设置标志。<br>请参阅将<a href="#Options_002fRecursion">选项传达给子网站<code>make</code></a> 。
</p>
<p><em>永远不</em>适合使用<code>MAKEFLAGS</code>直接在配方行中：其内容可能未正确引用以在shell中使用。始终允许递归<code>make</code>可以通过环境从其父级获取这些值。
</p>
</dd>
<dt><code>GNUMAKEFLAGS</code></dt>
<dd>
<p>其他标志由解析<code>make</code> 。您可以在环境中设置此文件，也可以在生成文件中设置<code>make</code>命令行标志。GNU <code>make</code>从不设置此变量本身。仅当您要设置GNU时才需要此变量<code>make</code>兼容POSIX的makefile中的特定标志。该变量将由GNU看到<code>make</code>被其他人忽略<code>make</code>实现。如果仅使用GNU，则不需要<code>make</code> ;只是使用<code>MAKEFLAGS</code>直。请参阅将<a href="#Options_002fRecursion">选项传达给子网站<code>make</code></a> 。
</p>
</dd>
<dt><code>MAKECMDGOALS</code></dt>
<dd>
<p>给予的目标<code>make</code>在命令行上。设置此变量不会影响<code>make</code> 。<br>请参阅<a href="#Goals">指定目标的参数</a> 。</p>
</dd>
<dt><code>CURDIR</code></dt>
<dd>
<p>设置为当前工作目录的绝对路径名（毕竟<code>-C</code>选项已处理）。设置此变量不会影响<code>make</code> 。<br>请参阅<a href="#Recursion">递归使用<code>make</code></a> 。
</p>
</dd>
<dt><code>SUFFIXES</code></dt>
<dd>
<p>之前的默认后缀列表<code>make</code>读取任何makefile。
</p>
</dd>
<dt><code>.LIBPATTERNS</code></dt>
<dd><p>定义库的命名<code>make</code>搜索及其顺序。<br>请参阅<a href="#Libraries_002fSearch">目录搜索链接库</a> 。
</p></dd>
</dl>

<hr>
<a name="Error-Messages"></a>
<div class="header">
<p>下一页： <a href="#Complex-Makefile" rel="next" accesskey="n">复杂Makefile</a> ，上一篇： <a href="#Quick-Reference" rel="prev" accesskey="p">快速参考</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Errors-Generated-by-Make"></a>
<h2 class="appendix">附录B由Make生成的错误</h2>

<p>这是您可能会看到的由生成的更常见错误的列表<code>make</code> ，以及有关其含义以及解决方法的一些信息。
</p>
<p>有时<code>make</code>错误不是致命的，特别是在存在<code>-</code>配方行上的前缀，或<code>-k</code>命令行选项。致命错误以字符串开头<code>***</code> 。
</p>
<p>错误消息全都带有程序名称的前缀（通常是“ <samp>make</samp> '），或者，如果在makefile中发现错误，则包含该问题的文件名和行号。
</p>
<p>在下表中，保留了这些常用前缀。
</p>
<dl compact>
<dt>' <samp>[<var>foo</var>] Error <var>NN</var></samp> '</dt>
<dt>' <samp>[<var>foo</var>] <var>signal description</var></samp> '</dt>
<dd><p>这些错误不是真的<code>make</code>根本没有错误。他们的意思是说<code>make</code>作为配方的一部分调用时，返回了非0的错误代码（' <samp>Error <var>NN</var></samp> '）， 哪一个<code>make</code>解释为故障，或者以其他异常方式退出（带有某种类型的信号）。请参见<a href="#Errors">食谱中的错误</a> 。
</p>
<p>如果不<code>***</code>附加到消息，则子进程失败，但makefile中的规则以<code>-</code>特殊字符，所以<code>make</code>忽略了错误。
</p>
</dd>
<dt>' <samp>missing separator. Stop.</samp> '</dt>
<dt>' <samp>missing separator (did you mean TAB instead of 8 spaces?). Stop.</samp> '</dt>
<dd><p>这意味着<code>make</code>无法理解有关它刚刚读取的makefile行的任何信息。GNU <code>make</code>寻找各种分隔符（ <code>:</code> ， <code>=</code> ，配方前缀字符等）来指示其解析的行类型。此消息表示找不到有效的消息。
</p>
<p>出现此消息的最常见原因之一是，您（或者您的非常有用的编辑器，如许多MS-Windows编辑器的情况）试图使配方行缩进而不是空格，而不是使用制表符。在这种情况下， <code>make</code>将使用上述错误的第二种形式。请记住，配方中的每一行都必须以制表符开头（除非您设置了<code>.RECIPEPREFIX</code> ;请参阅<a href="#Special-Variables">特殊变量</a> ）。八个空格不计算在内。请参阅<a href="#Rule-Syntax">规则语法</a> 。
</p>
</dd>
<dt>' <samp>recipe commences before first target. Stop.</samp> '</dt>
<dt>' <samp>missing rule before recipe. Stop.</samp> '</dt>
<dd><p>这意味着makefile中的第一件事似乎是食谱的一部分：它以食谱前缀字符开头，似乎不合法<code>make</code>指令（例如变量赋值）。配方必须始终与目标关联。
</p>
<p>如果该行以分号作为第一个非空白字符，则生成第二种形式；否则，将生成第二种形式。 <code>make</code>将此解释为意味着您省略了规则的“目标：先决条件”部分。请参阅<a href="#Rule-Syntax">规则语法</a> 。
</p>
</dd>
<dt>' <samp>No rule to make target `<var>xxx</var>'.</samp> '</dt>
<dt>' <samp>No rule to make target `<var>xxx</var>', needed by `<var>yyy</var>'.</samp> '</dt>
<dd><p>这意味着<code>make</code>决定需要构建一个目标，但是随后在makefile中找不到有关如何执行此操作的任何指令，无论是显式的还是隐式的（包括在默认规则数据库中）。
</p>
<p>如果要构建该文件，则需要在生成文件中添加一条规则来描述如何构建目标。此问题的其他可能原因是makefile中的拼写错误（如果该文件名错误）或源树已损坏（如果不应构建该文件，而仅是前提条件）。
</p>
</dd>
<dt>' <samp>No targets specified and no makefile found. Stop.</samp> '</dt>
<dt>' <samp>No targets. Stop.</samp> '</dt>
<dd><p>前者意味着您没有在命令行上提供任何要构建的目标，并且<code>make</code>找不到任何要读取的makefile。后者意味着找到了一些makefile，但它不包含任何默认目标，并且在命令行中未提供任何目标。GNU <code>make</code>在这些情况下没有任何关系。请参阅<a href="#Makefile-Arguments">指定Makefile的参数</a> 。
</p>
</dd>
<dt>' <samp>Makefile `<var>xxx</var>' was not found.</samp> '</dt>
<dt>' <samp>Included makefile `<var>xxx</var>' was not found.</samp> '</dt>
<dd><p>找不到在命令行（第一种形式）或包含的（第二种形式）指定的makefile。
</p>
</dd>
<dt>' <samp>warning: overriding recipe for target `<var>xxx</var>'</samp> '</dt>
<dt>' <samp>warning: ignoring old recipe for target `<var>xxx</var>'</samp> '</dt>
<dd><p>GNU <code>make</code>每个目标只能指定一个配方（双冒号规则除外）。如果为已经定义为具有一个目标的目标提供配方，则会发出此警告，并且第二个配方将覆盖第一个配方。请参阅<a href="#Multiple-Rules">针对一个目标的多个规则</a> 。
</p>
</dd>
<dt>' <samp>Circular <var>xxx</var> <- <var>yyy</var> dependency dropped.</samp> '</dt>
<dd><p>这意味着<code>make</code>在依赖关系图中检测到循环：在跟踪先决条件之后<var>yyy</var>目标<var>xxx</var> ，及其先决条件等，其中之一取决于<var>xxx</var>再次。
</p>
</dd>
<dt>' <samp>Recursive variable `<var>xxx</var>' references itself (eventually). Stop.</samp> '</dt>
<dd><p>这意味着您已经定义了普通（递归） <code>make</code>变量<var>xxx</var>展开时会引用自身（ <var>xxx</var> ）。这是不允许的；要么使用简单扩展的变量（' <samp>:=</samp> ' 要么 ' <samp>::=</samp> '）或使用append运算符（' <samp>+=</samp> '）。请参阅<a href="#Using-Variables">如何使用变量</a> 。
</p>
</dd>
<dt>' <samp>Unterminated variable reference. Stop.</samp> '</dt>
<dd><p>这意味着您忘记在变量或函数引用中提供正确的右括号或大括号。
</p>
</dd>
<dt>' <samp>insufficient arguments to function `<var>xxx</var>'. Stop.</samp> '</dt>
<dd><p>这意味着您尚未为此函数提供必要数量的参数。有关其参数的描述，请参见该函数的文档。请参见<a href="#Functions">转换文本的功能</a> 。
</p>
</dd>
<dt>' <samp>missing target pattern. Stop.</samp> '</dt>
<dt>' <samp>multiple target patterns. Stop.</samp> '</dt>
<dt>' <samp>target pattern contains no `%'. Stop.</samp> '</dt>
<dt>' <samp>mixed implicit and static pattern rules. Stop.</samp> '</dt>
<dd><p>这些是为格式错误的静态模式规则生成的。第一种意味着规则的目标部分没有模式；第二种意味着目标部分中有多种模式；第三个表示目标不包含模式字符（ <code>%</code> ）;第四个表示静态模式规则的所有三个部分都包含模式字符（ <code>%</code> ）–只有前两个部分应该。如果看到这些错误，并且不想创建静态模式规则，请检查目标列表和先决条件列表中所有变量的值，以确保它们不包含冒号。请参见<a href="#Static-Usage">静态模式规则的语法</a> 。
</p>
</dd>
<dt>' <samp>warning: -jN forced in submake: disabling jobserver mode.</samp> '</dt>
<dd><p>如果出现此警告和下一个警告<code>make</code>在与子程序有关的系统上检测与并行处理有关的错误情况<code>make</code>可以进行通信（请参阅<a href="#Options_002fRecursion">与子项目通信选项<code>make</code></a> ）。如果递归调用<code>make</code>过程被迫具有<samp>-j<var>N</var></samp>在其参数列表（其中<var>N</var>大于一）。例如，如果您将<code>MAKE</code>环境变量为' <samp>make -j2</samp> '。在这种情况下， <code>make</code>不与其他人交流<code>make</code>流程，并且会假装它有两个工作。
</p>
</dd>
<dt>' <samp>warning: jobserver unavailable: using -j1. Add `+' to parent make rule.</samp> '</dt>
<dd><p>为了<code>make</code>在沟通过程中，父母将信息传递给孩子。如果子进程实际上不是一个子进程，则可能会导致问题<code>make</code> ，只有在认为孩子是孩子的时候，父母才会这样做<code>make</code> 。父用正常的算法来确定这一点（见<a href="#MAKE-Variable">如何<code>MAKE</code>可变作品</a> ）。如果makefile的构造使父级不知道子级是<code>make</code>过程中，那么孩子将仅接收必要信息的一部分。在这种情况下，孩子将生成此警告消息并按顺序进行构建。
</p>
</dd>
</dl>

<hr>
<a name="Complex-Makefile"></a>
<div class="header">
<p>下一篇： <a href="#GNU-Free-Documentation-License" rel="next" accesskey="n">GNU自由文档许可证</a> ，上一篇： <a href="#Error-Messages" rel="prev" accesskey="p">错误消息</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Complex-Makefile-Example"></a>
<h2 class="appendix">附录C复杂Makefile示例</h2>

<p>这是GNU的makefile <code>tar</code>程序。这是一个中等复杂的makefile。第一行使用<code>#!</code>设置以允许直接执行makefile。
</p>
<p>因为它是第一个目标，所以默认目标是“ <samp>all</samp> '。这个makefile的一个有趣的功能是<samp>testpad.h</samp>是由<code>testpad</code>程序，其本身是从<samp>testpad.c</samp> 。
</p>
<p>如果您输入“ <samp>make</samp> ' 要么 ' <samp>make all</samp> '， 然后<code>make</code>创建<samp>tar</samp>可执行文件<samp>rmt</samp>提供远程磁带访问的守护程序，以及<samp>tar.info</samp>信息文件。
</p>
<p>如果您输入“ <samp>make install</samp> '， 然后<code>make</code>不仅创造<samp>tar</samp> ， <samp>rmt</samp>和<samp>tar.info</samp> ，但还会安装它们。
</p>
<p>如果您输入“ <samp>make clean</samp> '， 然后<code>make</code>删除“ <samp>.o</samp> '文件，以及<samp>tar</samp> ， <samp>rmt</samp> ， <samp>testpad</samp> ， <samp>testpad.h</samp>和<samp>core</samp>文件。
</p>
<p>如果您输入“ <samp>make distclean</samp> '， 然后<code>make</code>不仅删除与“ <samp>make clean</samp> '而且<samp>TAGS</samp> ， <samp>Makefile</samp>和<samp>config.status</samp>文件。（尽管不明显，该makefile（和<samp>config.status</samp> ）是由用户使用<code>configure</code>程序，该程序在<code>tar</code>分布，但此处未显示。）
</p>
<p>如果您输入“ <samp>make realclean</samp> '， 然后<code>make</code>删除与“ <samp>make distclean</samp> '，并删除从<samp>tar.texinfo</samp> 。
</p>
<p>另外，还有目标<code>shar</code>和<code>dist</code>创建分发工具包。
</p>
<div class="example">
<pre class="example">#!/usr/bin/make -f
# Generated automatically from Makefile.in by configure.
# Un*x Makefile for GNU tar program.
# Copyright (C) 1991 Free Software Foundation, Inc.
</pre><pre class="example">

</pre><pre class="example"># This program is free software; you can redistribute
# it and/or modify it under the terms of the GNU
# General Public License &hellip;
&hellip;
&hellip;
</pre><pre class="example">

SHELL = /bin/sh

#### Start of system configuration section. ####

srcdir = .

</pre><pre class="example"># If you use gcc, you should either run the
# fixincludes script that comes with it or else use
# gcc with the -traditional option.  Otherwise ioctl
# calls will be compiled incorrectly on some systems.
CC = gcc -O
YACC = bison -y
INSTALL = /usr/local/bin/install -c
INSTALLDATA = /usr/local/bin/install -c -m 644
</pre><pre class="example">

# Things you might add to DEFS:
# -DSTDC_HEADERS        If you have ANSI C headers and
#                       libraries.
# -DPOSIX               If you have POSIX.1 headers and
#                       libraries.
# -DBSD42               If you have sys/dir.h (unless
#                       you use -DPOSIX), sys/file.h,
#                       and st_blocks in `struct stat'.
# -DUSG                 If you have System V/ANSI C
#                       string and memory functions
#                       and headers, sys/sysmacros.h,
#                       fcntl.h, getcwd, no valloc,
#                       and ndir.h (unless
#                       you use -DDIRENT).
# -DNO_MEMORY_H         If USG or STDC_HEADERS but do not
#                       include memory.h.
# -DDIRENT              If USG and you have dirent.h
#                       instead of ndir.h.
# -DSIGTYPE=int         If your signal handlers
#                       return int, not void.
# -DNO_MTIO             If you lack sys/mtio.h
#                       (magtape ioctls).
# -DNO_REMOTE           If you do not have a remote shell
#                       or rexec.
# -DUSE_REXEC           To use rexec for remote tape
#                       operations instead of
#                       forking rsh or remsh.
# -DVPRINTF_MISSING     If you lack vprintf function
#                       (but have _doprnt).
# -DDOPRNT_MISSING      If you lack _doprnt function.
#                       Also need to define
#                       -DVPRINTF_MISSING.
# -DFTIME_MISSING       If you lack ftime system call.
# -DSTRSTR_MISSING      If you lack strstr function.
# -DVALLOC_MISSING      If you lack valloc function.
# -DMKDIR_MISSING       If you lack mkdir and
#                       rmdir system calls.
# -DRENAME_MISSING      If you lack rename system call.
# -DFTRUNCATE_MISSING   If you lack ftruncate
#                       system call.
# -DV7                  On Version 7 Unix (not
#                       tested in a long time).
# -DEMUL_OPEN3          If you lack a 3-argument version
#                       of open, and want to emulate it
#                       with system calls you do have.
# -DNO_OPEN3            If you lack the 3-argument open
#                       and want to disable the tar -k
#                       option instead of emulating open.
# -DXENIX               If you have sys/inode.h
#                       and need it 94 to be included.

DEFS =  -DSIGTYPE=int -DDIRENT -DSTRSTR_MISSING \
        -DVPRINTF_MISSING -DBSD42
# Set this to rtapelib.o unless you defined NO_REMOTE,
# in which case make it empty.
RTAPELIB = rtapelib.o
LIBS =
DEF_AR_FILE = /dev/rmt8
DEFBLOCKING = 20

</pre><pre class="example">CDEBUG = -g
CFLAGS = $(CDEBUG) -I. -I$(srcdir) $(DEFS) \
        -DDEF_AR_FILE=\&quot;$(DEF_AR_FILE)\&quot; \
        -DDEFBLOCKING=$(DEFBLOCKING)
LDFLAGS = -g
</pre><pre class="example">

</pre><pre class="example">prefix = /usr/local
# Prefix for each installed program,
# normally empty or `g'.
binprefix =

# The directory to install tar in.
bindir = $(prefix)/bin

# The directory to install the info files in.
infodir = $(prefix)/info
</pre><pre class="example">

#### End of system configuration section. ####

</pre><pre class="example">SRCS_C  = tar.c create.c extract.c buffer.c   \
          getoldopt.c update.c gnu.c mangle.c \
          version.c list.c names.c diffarch.c \
          port.c wildmat.c getopt.c getopt1.c \
          regex.c
SRCS_Y  = getdate.y
SRCS    = $(SRCS_C) $(SRCS_Y)
OBJS    = $(SRCS_C:.c=.o) $(SRCS_Y:.y=.o) $(RTAPELIB)
</pre><pre class="example">AUX =   README COPYING ChangeLog Makefile.in  \
        makefile.pc configure configure.in \
        tar.texinfo tar.info* texinfo.tex \
        tar.h port.h open3.h getopt.h regex.h \
        rmt.h rmt.c rtapelib.c alloca.c \
        msd_dir.h msd_dir.c tcexparg.c \
        level-0 level-1 backup-specs testpad.c
</pre><pre class="example">

.PHONY: all
all:    tar rmt tar.info

</pre><pre class="example">tar:    $(OBJS)
        $(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
</pre><pre class="example">

</pre><pre class="example">rmt:    rmt.c
        $(CC) $(CFLAGS) $(LDFLAGS) -o $@ rmt.c
</pre><pre class="example">

</pre><pre class="example">tar.info: tar.texinfo
        makeinfo tar.texinfo
</pre><pre class="example">

</pre><pre class="example">.PHONY: install
install: all
        $(INSTALL) tar $(bindir)/$(binprefix)tar
        -test ! -f rmt || $(INSTALL) rmt /etc/rmt
        $(INSTALLDATA) $(srcdir)/tar.info* $(infodir)
</pre><pre class="example">

</pre><pre class="example">$(OBJS): tar.h port.h testpad.h
regex.o buffer.o tar.o: regex.h
# getdate.y has 8 shift/reduce conflicts.
</pre><pre class="example">

</pre><pre class="example">testpad.h: testpad
        ./testpad
</pre><pre class="example">

</pre><pre class="example">testpad: testpad.o
        $(CC) -o $@ testpad.o
</pre><pre class="example">

</pre><pre class="example">TAGS:   $(SRCS)
        etags $(SRCS)
</pre><pre class="example">

</pre><pre class="example">.PHONY: clean
clean:
        rm -f *.o tar rmt testpad testpad.h core
</pre><pre class="example">

</pre><pre class="example">.PHONY: distclean
distclean: clean
        rm -f TAGS Makefile config.status
</pre><pre class="example">

</pre><pre class="example">.PHONY: realclean
realclean: distclean
        rm -f tar.info*
</pre><pre class="example">

</pre><pre class="example">.PHONY: shar
shar: $(SRCS) $(AUX)
        shar $(SRCS) $(AUX) | compress \
          &gt; tar-`sed -e '/version_string/!d' \
                     -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
                     -e q
                     version.c`.shar.Z
</pre><pre class="example">

</pre><pre class="example">.PHONY: dist
dist: $(SRCS) $(AUX)
        echo tar-`sed \
             -e '/version_string/!d' \
             -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
             -e q
             version.c` &gt; .fname
        -rm -rf `cat .fname`
        mkdir `cat .fname`
        ln $(SRCS) $(AUX) `cat .fname`
        tar chZf `cat .fname`.tar.Z `cat .fname`
        -rm -rf `cat .fname` .fname
</pre><pre class="example">

</pre><pre class="example">tar.zoo: $(SRCS) $(AUX)
        -rm -rf tmp.dir
        -mkdir tmp.dir
        -rm tar.zoo
        for X in $(SRCS) $(AUX) ; do \
            echo $$X ; \
            sed 's/$$/^M/' $$X \
            &gt; tmp.dir/$$X ; done
        cd tmp.dir ; zoo aM ../tar.zoo *
        -rm -rf tmp.dir
</pre></div>

<hr>
<a name="GNU-Free-Documentation-License"></a>
<div class="header">
<p>下一篇： <a href="#Concept-Index" rel="next" accesskey="n">概念索引</a> ，上一篇： <a href="#Complex-Makefile" rel="prev" accesskey="p">复杂Makefile</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="GNU-Free-Documentation-License-1"></a>
<h3 class="appendixsec">C.1 GNU免费文档许可证</h3>
<a name="index-FDL_002c-GNU-Free-Documentation-License"></a>
<div align="center">1.3版，2008年11月3日</div>

<div class="display">
<pre class="display">Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<a href="http://fsf.org/">http://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol>
<li>前言<p>本许可的目的是免费提供手册，教科书或其他实用且有用的文档： <em>自由</em> ，以确保每个人都有有效的自由，无论是否进行商业或非商业修改，都可以对其进行复制和重新分发。其次，本许可证为作者和出版商保留了一种因其作品而获得好评的方式，同时不被视为对他人所做的修改负责。
</p>
<p>该许可是一种“版权所有”，这意味着该文档的衍生作品本身必须在相同意义上是免费的。它是GNU通用公共许可证的补充，GNU通用公共许可证是专为自由软件设计的Copyleft许可证。
</p>
<p>我们设计此许可证是为了将其用于免费软件的手册，因为免费软件需要免费的文档：免费程序应随附手册，以提供与软件相同的自由。但是本许可不限于软件手册；它可以用于任何文本作品，而无论其主题是什么，或者它是否作为印刷书籍出版。我们建议您将此许可证主要用于目的是作为指导或参考的作品。
</p>
</li><li>适用性和定义<p>本许可适用于任何形式的任何手册或其他作品，其中包含版权所有者发布的声明，声明其可以根据本许可的条款进行分发。此类通知授予了全球范围内的免版税使用许可，期限不限，可以在此处所述的条件下使用该作品。下面的“文档”是指任何此类手册或作品。任何公众人士都是被许可人，称呼为“您”。如果您按照版权法要求许可的方式复制，修改或分发作品，则您接受许可。
</p>
<p>文档的“修改版本”是指包含文档或文档一部分的任何作品，无论是逐字复制还是经过修改和/或翻译成另一种语言。
</p>
<p>“第二部分”是本文档的命名附录或最重要的部分，专门处理本文档的出版者或作者与本文档的整体主题（或相关事宜）之间的关系，不包含任何可能直接涉及的内容。在整个主题范围内。（因此，如果该文档部分是一本数学教科书，那么第二部分可能不会解释任何数学。）这种关系可以是与主题或相关问题的历史联系，也可以是关于它们的法律，商业，哲学，伦理或政治立场。
</p>
<p>“不变部分”是某些二级部分，在其声明中指出，该文件的标题与不变部分的标题相同，即该文件是根据本许可发布的。如果某个部分不符合上面对“辅助”的定义，则不允许将其指定为“不变式”。该文档可能包含零个不变部分。如果文档未标识任何不变节，则没有任何不变节。
</p>
<p>“封面文字”是某些简短的文本段落，在声明中指出该文档是根据本许可发布的，这些文字作为“封面文字”或“封面文字”列出。“封面文本”最多可以包含5个字，“封面文本”最多可以包含25个字。
</p>
<p>文档的“透明”副本是指一种机器可读的副本，以其规格可供大众使用的格式表示，适用于使用通用文本编辑器或（对于由像素组成的图像）通用颜料进行直接修改的文档程序或（用于绘图的）一些广泛使用的绘图编辑器，并且适合于输入文本格式化程序或自动转换为适合输入到文本格式化程序的多种格式。以其他方式透明的文件格式制作的副本，其标记或没有标记的安排，可以阻止或阻止读者的后续修改，则该副本不是透明的。如果用于大量文本，则图像格式不是“透明”的。非“透明”的副本称为“不透明”。
</p>
<p>适用于透明副本的格式的示例包括不带标记的纯ASCII，Texinfo输入格式，LaTeX输入格式，使用公开可用的DTD的SGML或XML，以及设计用于人工修改的符合标准的简单HTML，PostScript或PDF。透明图像格式的示例包括PNG，XCF和JPG。不透明格式包括只能由专有文字处理器，SGML或XML读取和编辑的专有格式，而SGML或XML通常不提供DTD和/或处理工具，以及某些文字处理器为某些文字处理器生成的机器生成的HTML，PostScript或PDF仅用于输出目的。
</p>
<p>“标题页”对于印刷书籍而言，是指标题页本身，以及以下用于保持本许可证要求在标题页中显示的材料的以下页面。对于没有此类标题页的格式的作品，“标题页”是指在文本正文开头之前，靠近作品标题最突出外观的文本。
</p>
<p>“发布者”是指向公众分发文档副本的任何个人或实体。
</p>
<p>“标题为XYZ”一节是指文档的命名子单元，其标题恰好是XYZ或在括号中包含XYZ的文字，后面是将XYZ转换为另一种语言的文字。（此处XYZ代表以下提到的特定部分名称，例如“致谢”，“奉献”，“认可”或“历史记录”。）在修改文档时，要“保留此部分的标题”，则意味着根据此定义，该部分仍为“已命名的XYZ”部分。
</p>
<p>该文件的声明旁边可能包含“免责声明”，该声明指出本许可适用于该文件。这些保修免责声明被视为已包含在本许可中，但仅用于免责声明：这些保修免责声明可能具有的任何其他暗示都是无效的，并且对本许可的含义没有任何影响。
</p>
</li><li>VERBATIM复制<p>您可以在任何媒介中以商业或非商业方式复制和分发本文档，但前提是本许可，版权声明和声明本许可适用于本文档的许可声明均以所有副本形式复制，并且您不添加任何其他条件符合本许可的规定。您不得使用技术措施来阻碍或控制您复制或分发的副本的阅读或进一步复制。但是，您可以接受赔偿以换取副本。如果分发足够多的副本，则还必须遵循第3节中的条件。
</p>
<p>您还可以在上述相同条件下出借副本，并可以公开展示副本。
</p>
</li><li>大量复制<p>如果您发布文档的印刷副本（或通常具有印刷封面的介质副本），且编号超过100，并且文档的许可通知书要求包含封面文字，则必须将这些副本随附在清晰可见的所有文档中封面文字：封面上的封面文字和封底上的封面文字。两种封面都必须清楚，清楚地标识您是这些副本的发行者。封面必须显示完整的标题，标题中的所有单词均应同样醒目且可见。您还可以在封面上添加其他材料。只要封面保留了文档标题并满足这些条件，则仅对封面进行更改即可在其他方面被视为逐字复印。
</p>
<p>如果任何一个封面所需的文本量太大，无法清晰地容纳，则应将列出的第一个（合理合理的数量）放在实际的封面上，然后将其余部分继续放在相邻的页面上。
</p>
<p>如果您发布或分发的Opaque文档副本数量超过100，则必须在每份Opaque副本中包含机器可读的透明副本，或者在每份Opaque副本中或其中声明一个计算机网络位置，通用网络将从该位置开始使用public可以使用公共标准网络协议下载完整的文档透明副本，而无需添加任何材料。如果使用后一种选项，则在开始批量分发不透明副本时，必须采取合理的审慎步骤，以确保该透明副本将在指定位置保持可访问的状态，直到您上一次分发不透明副本至少一年之后。该版本的不透明副本（直接或通过您的代理商或零售商）向公众发布。
</p>
<p>要求（但不是必须）在重新分发大量副本之前，与文档作者保持良好联系，以便他们有机会为您提供文档的更新版本。
</p>
</li><li>修改方式<p>您可以在上述第2节和第3节的条件下复制和分发本文档的修改版本，前提是您严格按照本许可协议发布修改版本，而修改版本则充当文档的角色，从而许可对本文档的分发和修改拥有副本的修改版本。此外，您必须在修改后的版本中执行以下操作：</p>
<ol>
<li>在标题页（和封面，如果有的话）中使用与本文档以及先前版本（如果有的话，应在文档的“历史记录”部分中列出）不同的标题。如果该版本的原始发行者给予许可，则可以使用与先前版本相同的标题。

</li><li>在标题页上列出作者，一个或多个负责修改版本著作权的作者或实体，以及至少五名文档的主要作者（所有主要作者，如果少于五），除非他们使您脱离此要求。

</li><li>在“标题”页面上声明修改版本的发布者的名称，作为发布者。

</li><li>保留文档的所有版权声明。

</li><li>在其他版权声明旁边添加用于修改的适当版权声明。

</li><li>在版权声明之后，立即包含一个许可声明，以下面的附录中所示的形式，向公众授予根据本许可条款使用修改版的许可。

</li><li>在该许可证声明中保留不可变部分的完整列表以及文档的许可证声明中提供的必需封面文字。

</li><li>随附本许可证的未更改副本。

</li><li>保留标题为“历史”的部分，保留其标题，并在其上添加至少说明标题页上给出的修改版本的标题，年份，新作者和发行者的项目。如果文档中没有标题为“历史记录”的部分，请在其标题页上创建一个说明文档的标题，年份，作者和出版者的内容，然后添加一项描述上一句中所述的修改版本。

</li><li>保留文档中给出的网络位置（如果有），以供公众访问文档的透明副本，同样，保留文档中给出的基于其以前版本的网络位置。这些可以放在“历史记录”部分中。对于在文档本身之前至少四年出版的作品，或者如果其所指版本的原始发行者给予许可，您可以省略其网络位置。

</li><li>对于标题为“致谢”或“奉献”的任何部分，请保留本部分的标题，并在本部分中保留其中给出的每个贡献者致谢和/或奉献的所有内容和基调。

</li><li>保留文档的所有不变部分，其文本和标题保持不变。章节编号或同等编号不视为章节标题的一部分。

</li><li>删除任何标题为“背书”的部分。这样的部分可能不包含在修改版本中。

</li><li>请勿将任何现有部分的标题重命名为“背书”，或与任何不变部分的标题冲突。

</li><li>保留所有保修免责声明。
</li></ol>

<p>如果修改后的版本包括新的前节或附录，这些节或附录符合第二节的规定，并且不包含从文档中复制的材料，则可以选择将其中的部分或全部指定为不变的。为此，请将其标题添加到“修改版本”许可声明中的“不变部分”列表中。这些标题必须与任何其他节标题不同。
</p>
<p>您可以添加标题为“背书”的部分，但其中仅包含各方对您的修改版本的背书，例如，同行评审声明或该文本已被组织批准为标准的权威定义。
</p>
<p>您可以在修改版本的封面文本列表的末尾添加最多5个单词的段落作为“封面文本”，以及最多25个单词的段落作为“封面文本”。任何一个实体（或通过它们的安排）都只能添加“封面文字”和“封面文字”中的一个段落。如果文档已经包含同一封面的封面文字，该文字是您先前添加的或由您代表的同一实体做出的安排而添加的，则不得添加其他文字；但是您可以在添加了旧版本的以前的发布者的明确许可下替换旧版本。
</p>
<p>本文档的作者和发行者未获得本许可证的许可，不得使用其名称进行宣传或主张或暗示认可任何修改版本。
</p>
</li><li>合并文件<p>您可以根据上文第4节中针对修改版本定义的条款，将文档与根据本许可发布的其他文档进行组合，但前提是您必须将所有未经修改的原始文档的所有不变部分都包含在其中，并列出所有这些文档作为您许可协议中合并工作的不变部分，并保留其所有保修免责声明。
</p>
<p>合并后的作品仅包含此许可的一个副本，并且多个相同的不变部分可用一个副本代替。如果存在多个具有相同名称但内容不同的不变部分，请在该部分的末尾加上括号，在该部分的末尾添加原始作者或发布者的名称（如果已知），以使每个此类的标题唯一。唯一编号。对合并作品的许可声明中不变部分列表中的部分标题进行相同的调整。
</p>
<p>在组合中，必须将各种原始文档中标题为“ History”的任何部分组合在一起，组成一个标题为“ History”的部分；同样，将标题为“致谢”的所有部分以及标题为“奉献”的任何部分组合在一起。您必须删除所有标题为“背书”的部分。
</p>
</li><li>文件收集<p>您可以收集由本许可协议下发布的文档和其他文档组成的集合，并在该文档中将其替换为各个文档中包含的单个副本，前提是您遵守本许可协议的规定。在所有其他方面逐字逐字复印。
</p>
<p>您可以从此类集合中提取单个文档，并根据本许可证单独分发它，前提是您将本许可证的副本插入提取的文档中，并且在与该文档的逐字复制有关的所有其他方面遵守本许可证。
</p>
</li><li>独立工作的集合<p>如果文件或衍生产品的版权不用于限制合法权利，则该文件或其衍生物与其他单独或独立的文件或作品在存储或分发介质中或在其上的汇编将被称为“汇总”。汇编用户的数量超出了个人作品的许可范围。当文档包含在汇总中时，本许可不适用于汇总中的其他作品，而这些作品本身不是文档的衍生作品。
</p>
<p>如果第3节的封面文字要求适用于本文档的这些副本，则如果该文档少于全部汇总的一半，则可以将文档的封面文字放在汇总中将文档括起来的封面上，或者如果文档为电子形式，则具有等同的封面电子形式。否则，它们必须出现在将整个集合括起来的印刷封面上。
</p>
</li><li>翻译<p>翻译被视为一种修改，因此您可以根据第4节的条款分发文档的翻译。用翻译替换不变部分需要其版权所有者的特殊许可，但是除了这些不变部分的原始版本之外，您还可以包括部分或全部不变部分的翻译。您可以在本文档以及所有保修免责声明中包括本许可，所有许可声明的翻译，但前提是您还包括本许可的原始英文版本以及这些声明和免责声明的原始版本。如果本许可的翻译版本与原始版本或声明或免责声明之间存在分歧，则以原始版本为准。
</p>
<p>如果文档中某节的标题为“致谢”，“奉献”或“历史记录”，则保留其标题（第1节）的要求（第4节）通常需要更改实际标题。
</p>
</li><li>终止<p>除非本许可明确规定，否则您不得复制，修改，再许可或分发文档。否则，任何尝试复制，修改，再许可或分发的尝试均无效，并且将自动终止您在本许可下的权利。
</p>
<p>但是，如果您停止所有对本许可的违反，则（a）临时恢复特定版权持有者的许可，除非且直到版权持有者明确终止并最终终止您的许可为止；以及（b）如果版权持有者失败，则永久地在停止交易发生后的60天之内通过某种合理的方式通知您违规行为。
</p>
<p>此外，如果版权所有者以某种合理的方式通知您有关侵权的信息，那么该版权所有者的许可将被永久恢复，这是您第一次从该版权所有者那里收到针对任何作品的违反本许可的通知，并且您会在收到通知后的30天内纠正违规行为。
</p>
<p>根据本节终止您的权利并不会终止根据本许可从您那里收到副本或权利的各方的许可。如果您的权利已被终止且未永久恢复，则收到部分或全部相同材料的副本将不会赋予您使用该材料的任何权利。
</p>
</li><li>本许可证的未来修订<p>自由软件基金会可能会不时发布GNU自由文档许可证的新修订版。这样的新版本将在本质上与当前版本相似，但是可能在细节上有所不同以解决新问题或疑虑。参见<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a> 。</p>
<p>许可证的每个版本都有一个不同的版本号。如果文档指定适用于此许可的特定编号版本“或任何更高版本”，则您可以选择遵循该指定版本或已发布的任何更高版本的条款和条件（不作为草稿）由自由软件基金会提供。如果文档未指定此许可的版本号，则可以选择自由软件基金会曾经发布的任何版本（而不是草稿）。如果文档指定代理可以决定可以使用此许可证的将来版本，则该代理对版本的公开接受声明将永久授权您为文档选择该版本。
</p>
</li><li>许可<p>“大型多作者协作网站”（或“ MMC网站”）是指发布版权作品并为任何人提供编辑这些作品的重要便利的任何万维网服务器。任何人都可以编辑的公共Wiki是此类服务器的示例。网站中包含的“大型多作者合作”（或“ MMC”）是指在MMC网站上发布的任何受版权保护的作品集。
</p>
<p>“ CC-BY-SA”指由知识共享公司发行的知识共享署名-相同方式共享3.0许可，该公司是一家非营利性公司，主要营业地点位于加利福尼亚州旧金山，并且该版本的未来copyleft版本该组织发布的许可。
</p>
<p>“合并”是指作为另一文档的一部分全部或部分发布或重新发布文档。
</p>
<p>如果MMC已根据本许可获得许可，并且所有根据该许可在MMC以外的其他地方首次发行并随后全部或部分合并到MMC中的作品，则该MMC是“有资格获得许可的”，（1）没有封面文字或不变部分，因此（2）在2008年11月1日之前合并。
</p>
<p>MMC站点的运营商可以在2009年8月1日之前的任何时间在CC-BY-SA之下的同一站点上重新发布该站点中包含的MMC，前提是该MMC有资格获得许可。
</p>
</li></ol>

<a name="ADDENDUM_003a-How-to-use-this-License-for-your-documents"></a>
<h3 class="heading">附录：如何对您的文档使用此许可证</h3>

<p>要在您编写的文档中使用此许可，请在该文档中包括一个许可副本，并在标题页后放置以下版权和许可声明：</p>
<div class="smallexample">
<pre class="smallexample">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>如果您有不变的部分，封面文本和封面文本，则将“ with…Texts。”行替换为：</p>
<div class="smallexample">
<pre class="smallexample">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>如果您有不带封面文本的不变部分，或这三个部分的其他组合，请合并这两种选择以适应情况。
</p>
<p>如果您的文档包含不平凡的程序代码示例，我们建议您根据自由软件许可（例如GNU通用公共许可）的选择，并行发布这些示例，以允许它们在自由软件中使用。
</p>

<hr>
<a name="Concept-Index"></a>
<div class="header">
<p>下一篇： <a href="#Name-Index" rel="next" accesskey="n">名称索引</a> ，上一篇： <a href="#GNU-Free-Documentation-License" rel="prev" accesskey="p">GNU自由文档许可证</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Index-of-Concepts"></a>
<h2 class="unnumbered">概念索引</h2>

<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Concept-Index_cp_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-2"><b>＃</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-3"><b>$</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-4"><b>％</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-5"><b>*</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-6"><b>+</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-7"><b>，</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-8"><b>-</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-9"><b>。</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-10"><b>：</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-11"><b>=</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-12"><b>？</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-13"><b>@</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-14"><b>[</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-15"><b>\</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-16"><b>_</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-17"><b>〜</b></a>
   
<br>
<a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>
<table class="index-cp" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-1">！</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021_003d">！=</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021_003d_002c-expansion">！=，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-2">＃</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023-_0028comments_0029_002c-in-makefile"><code>#</code> （注释），在makefile中</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023-_0028comments_0029_002c-in-recipes"><code>#</code> （评论），在食谱中</a> ：</td><td> </td><td valign="top"><a href="#Recipe-Syntax">配方语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023include"><code>#include</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-3">$</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002c-in-function-call"><code>$</code> ，在函数调用中</a> ：</td><td> </td><td valign="top"><a href="#Syntax-of-Functions">函数语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002c-in-rules"><code>$</code> ，在规则中</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002c-in-variable-name"><code>$</code> ，名称为变量</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002c-in-variable-reference"><code>$</code> ，在可变参考中</a> ：</td><td> </td><td valign="top"><a href="#Reference">参考</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-4">％</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-in-pattern-rules"><code>%</code> ，在模式规则中</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-in-patsubst"><code>%</code> ，引用<code>patsubst</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-in-static-pattern"><code>%</code> ，以静态模式引用</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-in-vpath"><code>%</code> ，引用<code>vpath</code></a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-with-_005c-_0028backslash_0029"><code>%</code> ，引用为<code>\</code> （反斜杠）</a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-with-_005c-_0028backslash_0029-1"><code>%</code> ，引用为<code>\</code> （反斜杠）</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002c-quoting-with-_005c-_0028backslash_0029-2"><code>%</code> ，引用为<code>\</code> （反斜杠）</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-5">*</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028wildcard-character_0029"><code>*</code> （通配符）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-6">+</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_002c-and-define">+和<code>define</code></a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_002c-and-recipe-execution">+，以及配方执行</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_002c-and-recipes">+和食谱</a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_003d">+ =</a> ：</td><td> </td><td valign="top"><a href="#Appending">追加中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_003d_002c-expansion">+ =，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b_003d_002c-expansion-1">+ =，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-7">，</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002cv-_0028RCS-file-extension_0029"><code>,v <span class="roman">(RCS file extension)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-8">--</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028in-recipes_0029"><code>-</code> （在食谱中）</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002c-and-define">-和<code>define</code></a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dalways_002dmake"><code>--always-make</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dnew"><code>--assume-new</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dnew-1"><code>--assume-new</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dnew_002c-and-recursion"><code>--assume-new</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dold"><code>--assume-old</code></a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dold-1"><code>--assume-old</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassume_002dold_002c-and-recursion"><code>--assume-old</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dcheck_002dsymlink_002dtimes"><code>--check-symlink-times</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddebug"><code>--debug</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddirectory"><code>--directory</code></a> ：</td><td> </td><td valign="top"><a href="#Recursion">递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddirectory-1"><code>--directory</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddirectory_002c-and-_002d_002dprint_002ddirectory"><code>--directory</code>和<code>--print-directory</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddirectory_002c-and-recursion"><code>--directory</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddry_002drun"><code>--dry-run</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddry_002drun-1"><code>--dry-run</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddry_002drun-2"><code>--dry-run</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002denvironment_002doverrides"><code>--environment-overrides</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002deval"><code>--eval</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfile"><code>--file</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfile-1"><code>--file</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Arguments">Makefile参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfile-2"><code>--file</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfile_002c-and-recursion"><code>--file</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dhelp"><code>--help</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dignore_002derrors"><code>--ignore-errors</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dignore_002derrors-1"><code>--ignore-errors</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dinclude_002ddir"><code>--include-dir</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dinclude_002ddir-1"><code>--include-dir</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djobs"><code>--jobs</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djobs-1"><code>--jobs</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djobs_002c-and-recursion"><code>--jobs</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djust_002dprint"><code>--just-print</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djust_002dprint-1"><code>--just-print</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002djust_002dprint-2"><code>--just-print</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dkeep_002dgoing"><code>--keep-going</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dkeep_002dgoing-1"><code>--keep-going</code></a> ：</td><td> </td><td valign="top"><a href="#Testing">测试中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dkeep_002dgoing-2"><code>--keep-going</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dload_002daverage"><code>--load-average</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dload_002daverage-1"><code>--load-average</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dmakefile"><code>--makefile</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dmakefile-1"><code>--makefile</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Arguments">Makefile参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dmakefile-2"><code>--makefile</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dmax_002dload"><code>--max-load</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dmax_002dload-1"><code>--max-load</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnew_002dfile"><code>--new-file</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnew_002dfile-1"><code>--new-file</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnew_002dfile_002c-and-recursion"><code>--new-file</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dno_002dbuiltin_002drules"><code>--no-builtin-rules</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dno_002dbuiltin_002dvariables"><code>--no-builtin-variables</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dno_002dkeep_002dgoing"><code>--no-keep-going</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dno_002dprint_002ddirectory"><code>--no-print-directory</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dno_002dprint_002ddirectory-1"><code>--no-print-directory</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dold_002dfile"><code>--old-file</code></a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dold_002dfile-1"><code>--old-file</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dold_002dfile_002c-and-recursion"><code>--old-file</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002doutput_002dsync"><code>--output-sync</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel-Output">平行输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002doutput_002dsync-1"><code>--output-sync</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprint_002ddata_002dbase"><code>--print-data-base</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprint_002ddirectory"><code>--print-directory</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprint_002ddirectory_002c-and-_002d_002ddirectory"><code>--print-directory</code>和<code>--directory</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprint_002ddirectory_002c-and-recursion"><code>--print-directory</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprint_002ddirectory_002c-disabling"><code>--print-directory</code> ，禁用</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dquestion"><code>--question</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dquestion-1"><code>--question</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dquiet"><code>--quiet</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dquiet-1"><code>--quiet</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002drecon"><code>--recon</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002drecon-1"><code>--recon</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002drecon-2"><code>--recon</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsilent"><code>--silent</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsilent-1"><code>--silent</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dstop"><code>--stop</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtouch"><code>--touch</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtouch-1"><code>--touch</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtouch_002c-and-recursion"><code>--touch</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtrace"><code>--trace</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dversion"><code>--version</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dwarn_002dundefined_002dvariables"><code>--warn-undefined-variables</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dwhat_002dif"><code>--what-if</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dwhat_002dif-1"><code>--what-if</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002db"><code>-b</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dB"><code>-B</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dC"><code>-C</code></a> ：</td><td> </td><td valign="top"><a href="#Recursion">递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dC-1"><code>-C</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dC_002c-and-_002dw"><code>-C</code>和<code>-w</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dC_002c-and-recursion"><code>-C</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dd"><code>-d</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002de"><code>-e</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002de-_0028shell-flag_0029"><code>-e</code> （shell标志）</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df"><code>-f</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df-1"><code>-f</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Arguments">Makefile参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df-2"><code>-f</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df_002c-and-recursion"><code>-f</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dh"><code>-h</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dI"><code>-I</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002di"><code>-i</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002di-1"><code>-i</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dI-1"><code>-I</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dj"><code>-j</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dj-1"><code>-j</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dj_002c-and-archive-update"><code>-j</code>和存档更新</a> ：</td><td> </td><td valign="top"><a href="#Archive-Pitfalls">存档陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dj_002c-and-recursion"><code>-j</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dk"><code>-k</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dk-1"><code>-k</code></a> ：</td><td> </td><td valign="top"><a href="#Testing">测试中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dk-2"><code>-k</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dl"><code>-l</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dL"><code>-L</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dl-_0028library-search_0029"><code>-l</code> （图书馆搜索）</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dl-_0028load-average_0029"><code>-l</code> （平均负载）</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dm"><code>-m</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dM-_0028to-compiler_0029"><code>-M</code> （至编译器）</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dMM-_0028to-GNU-compiler_0029"><code>-MM</code> （到GNU编译器）</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dn"><code>-n</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dn-1"><code>-n</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dn-2"><code>-n</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dO"><code>-O</code></a> ：</td><td> </td><td valign="top"><a href="#Parallel-Output">平行输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002do"><code>-o</code></a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002do-1"><code>-o</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dO-1"><code>-O</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002do_002c-and-recursion"><code>-o</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dp"><code>-p</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dq"><code>-q</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dq-1"><code>-q</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dr"><code>-r</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dR"><code>-R</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ds"><code>-s</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ds-1"><code>-s</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dS"><code>-S</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dt"><code>-t</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dt-1"><code>-t</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dt_002c-and-recursion"><code>-t</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dv"><code>-v</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dW"><code>-W</code></a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dw"><code>-w</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dW-1"><code>-W</code></a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dw_002c-and-_002dC"><code>-w</code>和<code>-C</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dW_002c-and-recursion"><code>-W</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dw_002c-and-recursion"><code>-w</code>和递归</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dw_002c-disabling"><code>-w</code> ，禁用</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-9">。</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ea-_0028archives_0029"><code>.a</code> （档案）</a> ：</td><td> </td><td valign="top"><a href="#Archive-Suffix-Rules">存档后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ec"><code>.c</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eC"><code>.C</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ecc"><code>.cc</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ech"><code>.ch</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ecpp"><code>.cpp</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ed"><code>.d</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002edef"><code>.def</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002edvi"><code>.dvi</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ef"><code>.f</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eF"><code>.F</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002einfo"><code>.info</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002el"><code>.l</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eLIBPATTERNS_002c-and-link-libraries"><code>.LIBPATTERNS</code>和链接库</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eln"><code>.ln</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002emod"><code>.mod</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eo"><code>.o</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eo-1"><code>.o</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eONESHELL_002c-use-of"><code>.ONESHELL</code> ，用途</a> ：</td><td> </td><td valign="top"><a href="#One-Shell">一壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ep"><code>.p</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePRECIOUS-intermediate-files"><code>.PRECIOUS</code>中间文件</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002er"><code>.r</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002es"><code>.s</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eS"><code>.S</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002esh"><code>.sh</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSHELLFLAGS_002c-value-of"><code>.SHELLFLAGS</code> ，值</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002esym"><code>.sym</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002etex"><code>.tex</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002etexi"><code>.texi</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002etexinfo"><code>.texinfo</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002etxinfo"><code>.txinfo</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ew"><code>.w</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eweb"><code>.web</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ey"><code>.y</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-10">：</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003a-rules-_0028double_002dcolon_0029"><code>::</code>规则（双冒号）</a> ：</td><td> </td><td valign="top"><a href="#Double_002dColon">双冒号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003a_003d">:: =</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003a_003d-1">:: =</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003d">：=</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003d-1">：=</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-11">=</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d">=</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d-1">=</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d_002c-expansion">=，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-12">？</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f-_0028wildcard-character_0029"><code>?</code> （通配符）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f_003d">？=</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f_003d-1">？=</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f_003d_002c-expansion">？=，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-13">@</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040-_0028in-recipes_0029"><code>@</code> （在食谱中）</a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002c-and-define">@和<code>define</code></a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-14">[</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_2026_005d-_0028wildcard-characters_0029"><code>[…]</code> （通配符）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-15">\</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-for-continuation-lines"><code>\</code> （反斜杠），用于续行</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-recipes"><code>\</code> （反斜杠），在配方中</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-to-quote-_0025"><code>\</code> （反斜杠），引用<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-to-quote-_0025-1"><code>\</code> （反斜杠），引用<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-to-quote-_0025-2"><code>\</code> （反斜杠），引用<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-16">_</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005f_005f_002eSYMDEF"><code>__.SYMDEF</code></a> ：</td><td> </td><td valign="top"><a href="#Archive-Symbols">存档符号</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_symbol-17">〜</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029"><code>~</code> （波浪号）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abspath">抽象</a></td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-algorithm-for-directory-search">目录搜索算法</a> ：</td><td> </td><td valign="top"><a href="#Search-Algorithm">搜索算法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-all-_0028standard-target_0029"><code>all</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-appending-to-variables">附加到变量</a> ：</td><td> </td><td valign="top"><a href="#Appending">追加中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ar"><code>ar</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive">存档</a> ：</td><td> </td><td valign="top"><a href="#Archives">档案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive-member-targets">存档成员目标</a> ：</td><td> </td><td valign="top"><a href="#Archive-Members">存档成员</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive-symbol-directory-updating">归档符号目录更新</a> ：</td><td> </td><td valign="top"><a href="#Archive-Symbols">存档符号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive_002c-and-_002dj">存档，以及<code>-j</code></a> ：</td><td> </td><td valign="top"><a href="#Archive-Pitfalls">存档陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive_002c-and-parallel-execution">存档和并行执行</a> ：</td><td> </td><td valign="top"><a href="#Archive-Pitfalls">存档陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archive_002c-suffix-rule-for">存档，后缀规则为</a> ：</td><td> </td><td valign="top"><a href="#Archive-Suffix-Rules">存档后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arg-list-too-long">Arg列表过长</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments-of-functions">函数参数</a> ：</td><td> </td><td valign="top"><a href="#Syntax-of-Functions">函数语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-as"><code>as</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-as-1"><code>as</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assembly_002c-rule-to-compile">汇编，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-automatic-generation-of-prerequisites">自动生成先决条件</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-automatic-generation-of-prerequisites-1">自动生成先决条件</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-automatic-variables">自动变量</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-automatic-variables-in-prerequisites">前提条件中的自动变量</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-backquotes">反引号</a> ：</td><td> </td><td valign="top"><a href="#Shell-Function">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-for-continuation-lines">反斜线（ <code>\</code> ），对于续行</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-recipes">反斜线（ <code>\</code> ），在食谱中</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-to-quote-_0025">反斜线（ <code>\</code> ）， 报价<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-to-quote-_0025-1">反斜线（ <code>\</code> ）， 报价<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-to-quote-_0025-2">反斜线（ <code>\</code> ）， 报价<code>%</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-to-quote-newlines">反斜线（ <code>\</code> ），引用换行符</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Lines">分割线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslashes-in-pathnames-and-wildcard-expansion">路径名中的反斜杠和通配符扩展</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-basename">基本名称</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binary-packages">二进制包</a> ：</td><td> </td><td valign="top"><a href="#Install-Command-Categories">安装命令类别</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-broken-pipe">断管</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Input">并行输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bugs_002c-reporting">错误，报告</a> ：</td><td> </td><td valign="top"><a href="#Bugs">虫子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-built_002din-special-targets">内置特殊目标</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-C_002b_002b_002c-rule-to-compile">C ++，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-C_002c-rule-to-compile">C，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-canned-recipes">罐头食谱</a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cc"><code>cc</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cc-1"><code>cc</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cd-_0028shell-command_0029"><code>cd</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cd-_0028shell-command_0029-1"><code>cd</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chains-of-rules">规则链</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-check-_0028standard-target_0029"><code>check</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clean-_0028standard-target_0029"><code>clean</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clean-target"><code>clean</code>目标</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clean-target-1"><code>clean</code>目标</a> ：</td><td> </td><td valign="top"><a href="#Cleanup">清理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cleaning-up">清理</a> ：</td><td> </td><td valign="top"><a href="#Cleanup">清理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clobber-_0028standard-target_0029"><code>clobber</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-co"><code>co</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-co-1"><code>co</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-combining-rules-by-prerequisite">通过先决条件组合规则</a> ：</td><td> </td><td valign="top"><a href="#Combine-By-Prerequisite">按先决条件合并</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-expansion">命令扩展</a> ：</td><td> </td><td valign="top"><a href="#Shell-Function">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line-variable-definitions_002c-and-recursion">命令行变量定义和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line-variables">命令行变量</a> ：</td><td> </td><td valign="top"><a href="#Overriding">覆写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands_002c-sequences-of">命令，序列</a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comments_002c-in-makefile">注释，在makefile中</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comments_002c-in-recipes">评论，在食谱中</a> ：</td><td> </td><td valign="top"><a href="#Recipe-Syntax">配方语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility">相容性</a> ：</td><td> </td><td valign="top"><a href="#Features">特征</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-in-exporting">出口兼容性</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compilation_002c-testing">编译，测试</a> ：</td><td> </td><td valign="top"><a href="#Testing">测试中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-computed-variable-name">计算变量名称</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conditional-expansion">有条件扩展</a> ：</td><td> </td><td valign="top"><a href="#Conditional-Functions">条件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conditional-variable-assignment">条件变量赋值</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conditionals">有条件的</a> ：</td><td> </td><td valign="top"><a href="#Conditionals">有条件的</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuation-lines">续行</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-controlling-make">控制品牌</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conventions-for-makefiles">makefile的约定</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Conventions">Makefile约定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert-guile-types">转换guile类型</a> ：</td><td> </td><td valign="top"><a href="#Guile-Types">引导类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctangle"><code>ctangle</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctangle-1"><code>ctangle</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cweave"><code>cweave</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cweave-1"><code>cweave</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-data-base-of-make-rules">的数据库<code>make</code>规则</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deducing-recipes-_0028implicit-rules_0029">推导配方（内隐规则）</a> ：</td><td> </td><td valign="top"><a href="#make-Deduces">做出演绎</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-directories-for-included-makefiles">包含的makefile的默认目录</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-goal">默认目标</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-goal-1">默认目标</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-makefile-name">默认makefile名称</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-rules_002c-last_002dresort">默认规则，最后手段</a> ：</td><td> </td><td valign="top"><a href="#Last-Resort">最后一招</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define_002c-expansion">定义，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defining-variables-verbatim">逐字定义变量</a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deletion-of-target-files">删除目标文件</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deletion-of-target-files-1">删除目标文件</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directive">指令</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-creating-installation">目录，创建安装</a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-printing-them">目录，打印它们</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-updating-archive-symbol">目录，更新档案符号</a> ：</td><td> </td><td valign="top"><a href="#Archive-Symbols">存档符号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-part">目录部分</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search-_0028VPATH_0029">目录搜索（ <code>VPATH</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Directory-Search">目录搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search-_0028VPATH_0029_002c-and-implicit-rules">目录搜索（ <code>VPATH</code> ）以及隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search-_0028VPATH_0029_002c-and-link-libraries">目录搜索（ <code>VPATH</code> ），以及链接库</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search-_0028VPATH_0029_002c-and-recipes">目录搜索（ <code>VPATH</code> ）和食谱</a> ：</td><td> </td><td valign="top"><a href="#Recipes_002fSearch">食谱/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search-algorithm">目录搜索算法</a> ：</td><td> </td><td valign="top"><a href="#Search-Algorithm">搜索算法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directory-search_002c-traditional-_0028GPATH_0029">传统目录搜索（GPATH）</a> ：</td><td> </td><td valign="top"><a href="#Search-Algorithm">搜索算法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dist-_0028standard-target_0029"><code>dist</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-distclean-_0028standard-target_0029"><code>distclean</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-in-function-call">美元符号 （ <code>$</code> ），在函数调用中</a> ：</td><td> </td><td valign="top"><a href="#Syntax-of-Functions">函数语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-in-rules">美元符号 （ <code>$</code> ），在规则中</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-in-variable-name">美元符号 （ <code>$</code> ），以变量名形式</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-in-variable-reference">美元符号 （ <code>$</code> ），在变量引用中</a> ：</td><td> </td><td valign="top"><a href="#Reference">参考</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DOS_002c-choosing-a-shell-in">DOS，在</a>以下位置<a href="#index-DOS_002c-choosing-a-shell-in">选择一个外壳</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-double_002dcolon-rules">双冒号规则</a> ：</td><td> </td><td valign="top"><a href="#Double_002dColon">双冒号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-duplicate-words_002c-removing">重复的单词，删除</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-E2BIG">E2BIG</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-echoing-of-recipes">配方的呼应</a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-editor">编辑</a> ：</td><td> </td><td valign="top"><a href="#Introduction">介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Emacs-_0028M_002dx-compile_0029">Emacs（ <code>M-x compile</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-recipes">空食谱</a> ：</td><td> </td><td valign="top"><a href="#Empty-Recipes">空食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-targets">空目标</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment">环境</a> ：</td><td> </td><td valign="top"><a href="#Environment">环境</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment_002c-and-recursion">环境和递归</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment_002c-SHELL-in">环境， <code>SHELL</code>在</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error_002c-stopping-on">错误，停止于</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-errors-_0028in-recipes_0029">错误（在配方中）</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-errors-with-wildcards">通配符错误</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluating-makefile-syntax">评估makefile语法</a> ：</td><td> </td><td valign="top"><a href="#Eval-Function">评估功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-example-of-loaded-objects">加载对象的示例</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-Example">加载对象示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-example-using-Guile">使用Guile的示例</a> ：</td><td> </td><td valign="top"><a href="#Guile-Example">指导例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-execution_002c-in-parallel">并行执行</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-execution_002c-instead-of">执行，而不是</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-execution_002c-of-recipes">配方的执行</a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status-_0028errors_0029">退出状态（错误）</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status-of-make">make的退出状态</a> ：</td><td> </td><td valign="top"><a href="#Running">跑步</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expansion_002c-secondary">次要扩展</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-explicit-rule_002c-definition-of">明确规则，定义</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-explicit-rule_002c-expansion">显式规则，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-explicit-rules_002c-secondary-expansion-of">明确的规则，二次扩展</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exporting-variables">导出变量</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-Guile">扩展名，Guile</a> ：</td><td> </td><td valign="top"><a href="#Guile-Integration">指导整合</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-load-directive">扩展，负载指令</a> ：</td><td> </td><td valign="top"><a href="#load-Directive">负荷指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-loading">扩展程序，正在加载</a> ：</td><td> </td><td valign="top"><a href="#Loading-Objects">载入物件</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-f77"><code>f77</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-f77-1"><code>f77</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FDL_002c-GNU-Free-Documentation-License">FDL，GNU免费文档许可证</a> ：</td><td> </td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU免费文档许可证</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-features-of-GNU-make">GNU的功能<code>make</code></a> ：</td><td> </td><td valign="top"><a href="#Features">特征</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-features_002c-missing">功能，缺少</a> ：</td><td> </td><td valign="top"><a href="#Missing">失踪</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-functions">文件名功能</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-of-makefile">makefile的文件名</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-of-makefile_002c-how-to-specify">makefile的文件名，如何指定</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-prefix_002c-adding">文件名前缀，添加</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-suffix">文件名后缀</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-suffix_002c-adding">文件名后缀，添加</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name-with-wildcards">带通配符的文件名</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name_002c-abspath-of">文件名，abspath</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name_002c-basename-of">文件名，基名</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name_002c-directory-part">文件名，目录部分</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name_002c-nondirectory-part">文件名，非目录部分</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-name_002c-realpath-of">文件名，realpath</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file_002c-reading-from">文件，读取自</a> ：</td><td> </td><td valign="top"><a href="#File-Function">文件功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file_002c-writing-to">文件，写入</a> ：</td><td> </td><td valign="top"><a href="#File-Function">文件功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-assuming-new">文件，假设是新的</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-assuming-old">文件，假定为旧</a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-avoiding-recompilation-of">文件，避免重新编译</a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-intermediate">中间文件</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filtering-out-words">过滤掉单词</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filtering-words">过滤词</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-finding-strings">查找字符串</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flags">标志</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flags-for-compilers">编译器标志</a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flavor-of-variable">变量的味道</a> ：</td><td> </td><td valign="top"><a href="#Flavor-Function">风味功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flavors-of-variables">变量风格</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FORCE"><code>FORCE</code></a> ：</td><td> </td><td valign="top"><a href="#Force-Targets">强制目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-force-targets">强制目标</a> ：</td><td> </td><td valign="top"><a href="#Force-Targets">强制目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fortran_002c-rule-to-compile">Fortran，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions">功能</a> ：</td><td> </td><td valign="top"><a href="#Functions">功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-for-controlling-make">用于控制make的功能</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-for-file-names">函数，用于文件名</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-for-text">文字功能</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-syntax-of">函数，语法</a> ：</td><td> </td><td valign="top"><a href="#Syntax-of-Functions">函数语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user-defined">用户定义的功能</a> ：</td><td> </td><td valign="top"><a href="#Call-Function">通话功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-g_002b_002b"><code>g++</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-g_002b_002b-1"><code>g++</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gcc"><code>gcc</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-generating-prerequisites-automatically">自动生成先决条件</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-generating-prerequisites-automatically-1">自动生成先决条件</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-get"><code>get</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-get-1"><code>get</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-globbing-_0028wildcards_0029">遍历（通配符）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-goal">目标</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-goal_002c-default">目标，默认</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-goal_002c-default-1">目标，默认</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-goal_002c-how-to-specify">目标，如何指定</a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Guile">桂乐</a></td><td> </td><td valign="top"><a href="#Guile-Function">引导功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Guile-1">桂乐</a></td><td> </td><td valign="top"><a href="#Guile-Integration">指导整合</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Guile-example">指导示例</a> ：</td><td> </td><td valign="top"><a href="#Guile-Example">指导例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-guile_002c-conversion-of-types">狡猾，类型转换</a> ：</td><td> </td><td valign="top"><a href="#Guile-Types">引导类型</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-home-directory">主目录</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-IEEE-Standard-1003_002e2">IEEE标准1003.2</a> ：</td><td> </td><td valign="top"><a href="#Overview">总览</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifdef_002c-expansion">ifdef，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifeq_002c-expansion">ifeq，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifndef_002c-expansion">ifndef，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifneq_002c-expansion">ifneq，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule">隐含规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit-Rules">隐式规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-and-directory-search">隐式规则和目录搜索</a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-and-VPATH">隐含规则，以及<code>VPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-definition-of">隐式规则，定义</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-expansion">隐式规则，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-how-to-use">隐式规则，如何使用</a> ：</td><td> </td><td valign="top"><a href="#Using-Implicit">使用隐式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-introduction-to">隐式规则，简介</a> ：</td><td> </td><td valign="top"><a href="#make-Deduces">做出演绎</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-predefined">隐式规则，预定义</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rule_002c-search-algorithm">隐式规则，搜索算法</a> ：</td><td> </td><td valign="top"><a href="#Implicit-Rule-Search">隐式规则搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-rules_002c-secondary-expansion-of">隐式规则，二次扩展</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-included-makefiles_002c-default-directories">包含的makefile，默认目录</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-including-_0028MAKEFILES-variable_0029">包含 （ <code>MAKEFILES</code>变量）</a> ：</td><td> </td><td valign="top"><a href="#MAKEFILES-Variable">MAKEFILES变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-including-_0028MAKEFILE_005fLIST-variable_0029">包含 （ <code>MAKEFILE_LIST</code>变量）</a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-including-other-makefiles">包括其他makefile</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-incompatibilities">不兼容</a> ：</td><td> </td><td valign="top"><a href="#Missing">失踪</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Info_002c-rule-to-format">信息，格式规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inheritance_002c-suppressing">继承，抑制</a> ：</td><td> </td><td valign="top"><a href="#Suppressing-Inheritance">抑制继承</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-during-parallel-execution">并行执行期间的输入</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Input">并行输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-install-_0028standard-target_0029"><code>install</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installation-directories_002c-creating">安装目录，创建</a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installations_002c-staged">进行的装置</a> ：</td><td> </td><td valign="top"><a href="#DESTDIR">DESTDIR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interface-for-loaded-objects">加载对象的接口</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-intermediate-files">中间文件</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-intermediate-files_002c-preserving">中间文件，保留</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-intermediate-targets_002c-explicit">中间目标，明确的</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interrupt">中断</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-J">Ĵ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-job-slots">职位空缺</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-job-slots_002c-and-recursion">职位空缺和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-job-slots_002c-sharing">职位空缺，共享</a> ：</td><td> </td><td valign="top"><a href="#Job-Slots">职位空缺</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jobs_002c-limiting-based-on-load">作业，基于负载的限制</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jobserver">作业服务器</a> ：</td><td> </td><td valign="top"><a href="#Job-Slots">职位空缺</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jobserver-on-POSIX">POSIX上的作业服务器</a> ：</td><td> </td><td valign="top"><a href="#POSIX-Jobserver">POSIX作业服务器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jobserver-on-Windows">Windows上的作业服务器</a> ：</td><td> </td><td valign="top"><a href="#Windows-Jobserver">Windows作业服务器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-joining-lists-of-words">连接词表</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-K">ķ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-killing-_0028interruption_0029">杀死（中断）</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-last_002dresort-default-rules">上一个默认规则</a> ：</td><td> </td><td valign="top"><a href="#Last-Resort">最后一招</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ld"><code>ld</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lex"><code>lex</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lex-1"><code>lex</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lex_002c-rule-to-run">Lex，运行规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-for-linking_002c-directory-search">用于链接，目录搜索的库</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-library-archive_002c-suffix-rule-for">图书馆档案，后缀规则为</a> ：</td><td> </td><td valign="top"><a href="#Archive-Suffix-Rules">存档后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-limiting-jobs-based-on-load">根据负载限制作业</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-link-libraries_002c-and-directory-search">链接库和目录搜索</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-link-libraries_002c-patterns-matching">链接库，模式匹配</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-linking_002c-predefined-rule-for">链接的预定义规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint"><code>lint</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-1"><code>lint</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint_002c-rule-to-run"><code>lint</code> ，运行规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list-of-all-prerequisites">所有先决条件列表</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list-of-changed-prerequisites">已更改的先决条件列表</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load-average">平均负载</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load-directive">负载指令</a> ：</td><td> </td><td valign="top"><a href="#load-Directive">负荷指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loaded-object-API">加载的对象API</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loaded-object-example">加载的对象示例</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-Example">加载对象示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loaded-object-licensing">加载对象许可</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loaded-objects">加载的对象</a> ：</td><td> </td><td valign="top"><a href="#Loading-Objects">载入物件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loaded-objects_002c-remaking-of">加载的对象，对</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Loaded-Objects">重建加载的对象</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-long-lines_002c-splitting">长行，分裂</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Lines">分割线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops-in-variable-expansion">循环进行变量扩展</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lpr-_0028shell-command_0029"><code>lpr</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Examples">通配符示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lpr-_0028shell-command_0029-1"><code>lpr</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-m2c"><code>m2c</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-m2c-1"><code>m2c</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-macro">宏</a> ：</td><td> </td><td valign="top"><a href="#Using-Variables">使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-depend"><code>make depend</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-extensions">扩展</a> ：</td><td> </td><td valign="top"><a href="#Extending-make">扩展make</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-integration">进行整合</a> ：</td><td> </td><td valign="top"><a href="#Integrating-make">整合制造</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-interface-to-guile">使接口与guile</a> ：</td><td> </td><td valign="top"><a href="#Guile-Interface">引导界面</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make-procedures-in-guile">使程序变得狡猾</a> ：</td><td> </td><td valign="top"><a href="#Guile-Interface">引导界面</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile">生成文件</a> ：</td><td> </td><td valign="top"><a href="#Introduction">介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile-name">生成文件名</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile-name_002c-how-to-specify">生成文件名，如何指定</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile-rule-parts">Makefile规则部分</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile-syntax_002c-evaluating">makefile语法，评估</a> ：</td><td> </td><td valign="top"><a href="#Eval-Function">评估功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-and-MAKEFILES-variable">生成文件，以及<code>MAKEFILES</code>变量</a> ：</td><td> </td><td valign="top"><a href="#MAKEFILES-Variable">MAKEFILES变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-conventions-for">makefile，约定</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Conventions">Makefile约定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-how-make-processes">makefile，如何<code>make</code>流程</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-how-to-write">makefile，怎么写</a> ：</td><td> </td><td valign="top"><a href="#Makefiles">制作文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-including">makefile，包括</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-overriding">makefile，覆盖</a> ：</td><td> </td><td valign="top"><a href="#Overriding-Makefiles">覆盖Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-parsing">makefile，解析</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-remaking-of">makefile，重制</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Makefiles">重新制作Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile_002c-simple">makefile，简单</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefiles_002c-and-MAKEFILE_005fLIST-variable">生成文件，以及<code>MAKEFILE_LIST</code>变量</a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefiles_002c-and-special-variables">makefile和特殊变量</a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makeinfo"><code>makeinfo</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makeinfo-1"><code>makeinfo</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match_002danything-rule">任何匹配规则</a> ：</td><td> </td><td valign="top"><a href="#Match_002dAnything-Rules">比赛规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match_002danything-rule_002c-used-to-override">匹配任何规则，用于覆盖</a> ：</td><td> </td><td valign="top"><a href="#Overriding-Makefiles">覆盖Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-missing-features">缺少的功能</a> ：</td><td> </td><td valign="top"><a href="#Missing">失踪</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mistakes-with-wildcards">通配符错误</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-modified-variable-reference">修改后的变量参考</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Modula_002d2_002c-rule-to-compile">Modula-2，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mostlyclean-_0028standard-target_0029"><code>mostlyclean</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multi_002dline-variable-definition">多行变量定义</a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple-rules-for-one-target">一个目标有多个规则</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Rules">多个规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple-rules-for-one-target-_0028_003a_003a_0029">一个目标有多个规则（ <code>::</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Double_002dColon">双冒号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple-targets">多个目标</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Targets">多个目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple-targets_002c-in-pattern-rule">在模式规则中有多个目标</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-N">ñ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-name-of-makefile">makefile的名称</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-name-of-makefile_002c-how-to-specify">Makefile的名称，如何指定</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nested-variable-reference">嵌套变量参考</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newline_002c-quoting_002c-in-makefile">换行符，在makefile中引用</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newline_002c-quoting_002c-in-recipes">在食谱中引用换行符</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nondirectory-part">非目录部分</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-normal-prerequisites">正常先决条件</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-obj"><code>obj</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OBJ"><code>OBJ</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-objects"><code>objects</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OBJECTS"><code>OBJECTS</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-objects_002c-loaded">加载的对象</a> ：</td><td> </td><td valign="top"><a href="#Loading-Objects">载入物件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-objs"><code>objs</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OBJS"><code>OBJS</code></a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-old_002dfashioned-suffix-rules">老式的后缀规则</a> ：</td><td> </td><td valign="top"><a href="#Suffix-Rules">后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options">选项</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-and-recursion">选项和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-setting-from-environment">选项，从环境设置</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-setting-in-makefiles">选项，在makefiles中设置</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order-of-pattern-rules">模式规则的顺序</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Match">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order_002donly-prerequisites">仅订购的先决条件</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-origin-of-variable">变量的来源</a> ：</td><td> </td><td valign="top"><a href="#Origin-Function">原点功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-during-parallel-execution">并行执行期间的输出</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Output">平行输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-during-parallel-execution-1">并行执行期间的输出</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-overriding-makefiles">覆盖makefile</a> ：</td><td> </td><td valign="top"><a href="#Overriding-Makefiles">覆盖Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-overriding-variables-with-arguments">用参数覆盖变量</a> ：</td><td> </td><td valign="top"><a href="#Overriding">覆写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-overriding-with-override">覆盖<code>override</code></a> ：</td><td> </td><td valign="top"><a href="#Override-Directive">覆盖指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution">并行执行</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution_002c-and-archive-update">并行执行和存档更新</a> ：</td><td> </td><td valign="top"><a href="#Archive-Pitfalls">存档陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution_002c-input-during">并行执行，在以下期间输入</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Input">并行输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution_002c-output-during">并行执行，在以下期间输出</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Output">平行输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution_002c-output-during-1">并行执行，在以下期间输出</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-execution_002c-overriding">并行执行，覆盖</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parallel-output-to-terminal">并行输出至端子</a> ：</td><td> </td><td valign="top"><a href="#Terminal-Output">终端输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parts-of-makefile-rule">Makefile规则的一部分</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pascal_002c-rule-to-compile">Pascal，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-rule">模式规则</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-rule_002c-expansion">模式规则，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-rules_002c-order-of">模式规则，顺序</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Match">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-rules_002c-static-_0028not-implicit_0029">模式规则，静态（非隐式）</a> ：</td><td> </td><td valign="top"><a href="#Static-Pattern">静态图案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern-rules_002c-static_002c-syntax-of">模式规则，静态，语法</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pattern_002dspecific-variables">模式特定的变量</a> ：</td><td> </td><td valign="top"><a href="#Pattern_002dspecific">模式特定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pc"><code>pc</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pc-1"><code>pc</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-phony-targets">虚假目标</a> ：</td><td> </td><td valign="top"><a href="#Phony-Targets">假冒目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-phony-targets-and-recipe-execution">虚假目标和配方执行</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pitfalls-of-wildcards">通配符的陷阱</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plugin_005fis_005fGPL_005fcompatible">plugin_is_GPL_compatible</a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability">便携性</a> ：</td><td> </td><td valign="top"><a href="#Features">特征</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX">POSIX</a> ：</td><td> </td><td valign="top"><a href="#Overview">总览</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-1">POSIX</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX_002dconforming-mode_002c-setting">符合POSIX的模式，设置</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-post_002dinstallation-commands">安装后命令</a> ：</td><td> </td><td valign="top"><a href="#Install-Command-Categories">安装命令类别</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pre_002dinstallation-commands">预安装命令</a> ：</td><td> </td><td valign="top"><a href="#Install-Command-Categories">安装命令类别</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-precious-targets">宝贵的目标</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predefined-rules-and-variables_002c-printing">预定义的规则和变量，打印</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix_002c-adding">前缀，添加</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisite">先决条件</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisite-pattern_002c-implicit">先决条件模式，隐式</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisite-pattern_002c-static-_0028not-implicit_0029">必备模式，静态（非隐式）</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisite-types">先决条件类型</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisite_002c-expansion">前提条件，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites">先决条件</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-and-automatic-variables">先决条件和自动变量</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-automatic-generation">先决条件，自动生成</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-automatic-generation-1">先决条件，自动生成</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-introduction-to">先决条件，简介</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-list-of-all">先决条件，所有清单</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-list-of-changed">先决条件，已更改列表</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-normal">先决条件，正常</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-order_002donly">先决条件，仅可订购</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prerequisites_002c-varying-_0028static-pattern_0029">先决条件，各不相同（静态模式）</a> ：</td><td> </td><td valign="top"><a href="#Static-Pattern">静态图案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-preserving-intermediate-files">保留中间文件</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-preserving-with-_002ePRECIOUS">与...保持<code>.PRECIOUS</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-preserving-with-_002ePRECIOUS-1">与...保持<code>.PRECIOUS</code></a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-preserving-with-_002eSECONDARY">与...保持<code>.SECONDARY</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-_0028standard-target_0029"><code>print</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-target"><code>print</code>目标</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Examples">通配符示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-target-1"><code>print</code>目标</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing-directories">打印目录</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing-messages">打印消息</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing-of-recipes">食谱印刷</a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing-user-warnings">打印用户警告</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-problems-and-bugs_002c-reporting">问题和错误，报告</a> ：</td><td> </td><td valign="top"><a href="#Bugs">虫子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-problems-with-wildcards">通配符问题</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-processing-a-makefile">处理一个makefile文件</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-Q">问</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-question-mode">问题模式</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-_0025_002c-in-patsubst">报价<code>%</code> ，在<code>patsubst</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-_0025_002c-in-static-pattern">报价<code>%</code> ，以静态模式显示</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-_0025_002c-in-vpath">报价<code>%</code> ，在<code>vpath</code></a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-newline_002c-in-makefile">在makefile中引用换行符</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-newline_002c-in-recipes">在食谱中引用换行符</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ratfor_002c-rule-to-compile">Ratfor，编译规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RCS_002c-rule-to-extract-from">RCS，提取规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reading-from-a-file">从文件读取</a> ：</td><td> </td><td valign="top"><a href="#File-Function">文件功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reading-makefiles">读取makefile</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-README"><code>README</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-realclean-_0028standard-target_0029"><code>realclean</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-realpath">realpath</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe">配方</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe-execution_002c-single-invocation">配方执行，单次调用</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe-lines_002c-single-shell">配方线，单壳</a> ：</td><td> </td><td valign="top"><a href="#One-Shell">一壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe-syntax">配方语法</a> ：</td><td> </td><td valign="top"><a href="#Recipe-Syntax">配方语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe_002c-execution">配方，执行</a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes">食谱</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes-1">食谱</a> ：</td><td> </td><td valign="top"><a href="#Recipes">菜谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes-setting-shell-variables">设置外壳变量的配方</a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-and-directory-search">食谱和目录搜索</a> ：</td><td> </td><td valign="top"><a href="#Recipes_002fSearch">食谱/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-backslash-_0028_005c_0029-in">食谱，反斜线（ <code>\</code> ）在</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-canned">罐头食谱</a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-comments-in">食谱，评论</a> ：</td><td> </td><td valign="top"><a href="#Recipe-Syntax">配方语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-echoing">食谱，呼应</a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-empty">食谱，空的</a> ：</td><td> </td><td valign="top"><a href="#Empty-Recipes">空食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-errors-in">食谱，错误</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-execution-in-parallel">配方，并行执行</a> ：</td><td> </td><td valign="top"><a href="#Parallel">平行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-how-to-write">食谱，怎么写</a> ：</td><td> </td><td valign="top"><a href="#Recipes">菜谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-instead-of-executing">配方，而不是执行</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-introduction-to">食谱，简介</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-quoting-newlines-in">食谱，并在中引用换行符</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-splitting">食谱，分裂</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipes_002c-using-variables-in">配方，使用变量</a> ：</td><td> </td><td valign="top"><a href="#Variables-in-Recipes">配方中的变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recompilation">重新编译</a> ：</td><td> </td><td valign="top"><a href="#Introduction">介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recompilation_002c-avoiding">重新编译，避免</a> ：</td><td> </td><td valign="top"><a href="#Avoiding-Compilation">避免编译</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recording-events-with-empty-targets">记录目标为空的事件</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion">递归</a> ：</td><td> </td><td valign="top"><a href="#Recursion">递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002dC">递归<code>-C</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002df">递归<code>-f</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002dj">递归<code>-j</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002do">递归<code>-o</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002dt">递归<code>-t</code></a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002dW">递归<code>-W</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-_002dw">递归<code>-w</code></a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-command-line-variable-definitions">递归和命令行变量定义</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-environment">递归和环境</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-MAKE-variable">递归<code>MAKE</code>变量</a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-MAKEFILES-variable">递归<code>MAKEFILES</code>变量</a> ：</td><td> </td><td valign="top"><a href="#MAKEFILES-Variable">MAKEFILES变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-options">递归和选项</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-printing-directories">递归并打印目录</a> ：</td><td> </td><td valign="top"><a href="#g_t_002dw-Option">-w选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-and-variables">递归和变量</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursion_002c-level-of">递归，级别</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursive-variable-expansion">递归变量扩展</a> ：</td><td> </td><td valign="top"><a href="#Using-Variables">使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursive-variable-expansion-1">递归变量扩展</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursively-expanded-variables">递归扩展变量</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reference-to-variables">引用变量</a> ：</td><td> </td><td valign="top"><a href="#Reference">参考</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reference-to-variables-1">引用变量</a> ：</td><td> </td><td valign="top"><a href="#Advanced">高级</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-relinking">重新连结</a> ：</td><td> </td><td valign="top"><a href="#How-Make-Works">如何运作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-remaking-loaded-objects">重建加载的对象</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Loaded-Objects">重建加载的对象</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-remaking-makefiles">重建makefile</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Makefiles">重新制作Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-removal-of-target-files">删除目标文件</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-removal-of-target-files-1">删除目标文件</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-removing-duplicate-words">删除重复的单词</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-removing-targets-on-failure">排除故障目标</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-removing_002c-to-clean-up">去除，清理</a> ：</td><td> </td><td valign="top"><a href="#Cleanup">清理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reporting-bugs">报告错误</a> ：</td><td> </td><td valign="top"><a href="#Bugs">虫子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm"><code>rm</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm-_0028shell-command_0029"><code>rm</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm-_0028shell-command_0029-1"><code>rm</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Examples">通配符示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm-_0028shell-command_0029-2"><code>rm</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Phony-Targets">假冒目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm-_0028shell-command_0029-3"><code>rm</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-prerequisites">规则先决条件</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-syntax">规则语法</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-targets">规则目标</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-double_002dcolon-_0028_003a_003a_0029">规则，双冒号（ <code>::</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Double_002dColon">双冒号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-explicit_002c-definition-of">规则，明确的定义</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-how-to-write">规则，怎么写</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit">隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit-Rules">隐式规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-and-directory-search">规则，隐式和目录搜索</a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-and-VPATH">规则，隐式和<code>VPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-chains-of">规则，隐式，链的</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-definition-of">规则，隐式，定义</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-how-to-use">规则，隐式，如何使用</a> ：</td><td> </td><td valign="top"><a href="#Using-Implicit">使用隐式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-introduction-to">规则，隐式，介绍</a> ：</td><td> </td><td valign="top"><a href="#make-Deduces">做出演绎</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-implicit_002c-predefined">规则，隐式，预定义的</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-introduction-to">规则，介绍</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-multiple-for-one-target">规则，一个目标为多个</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Rules">多个规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-no-recipe-or-prerequisites">规则，没有配方或先决条件</a> ：</td><td> </td><td valign="top"><a href="#Force-Targets">强制目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-pattern">规则，模式</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-static-pattern">规则，静态模式</a> ：</td><td> </td><td valign="top"><a href="#Static-Pattern">静态图案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-static-pattern-versus-implicit">规则，静态模式与隐式模式</a> ：</td><td> </td><td valign="top"><a href="#Static-versus-Implicit">静态与隐式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-with-multiple-targets">规则，有多个目标</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Targets">多个目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rules_002c-and-_0024">规则，以及<code>$</code></a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-s_002e-_0028SCCS-file-prefix_0029"><code>s. <span class="roman">(SCCS file prefix)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SCCS_002c-rule-to-extract-from">SCCS，提取规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-algorithm_002c-implicit-rule">搜索算法，隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit-Rule-Search">隐式规则搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-path-for-prerequisites-_0028VPATH_0029">搜索先决条件的路径（ <code>VPATH</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Directory-Search">目录搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-path-for-prerequisites-_0028VPATH_0029_002c-and-implicit-rules">搜索先决条件的路径（ <code>VPATH</code> ）以及隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-path-for-prerequisites-_0028VPATH_0029_002c-and-link-libraries">搜索先决条件的路径（ <code>VPATH</code> ），以及链接库</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-searching-for-strings">搜索字符串</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-expansion">二次扩展</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-expansion-and-explicit-rules">二次扩展和明确的规则</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-expansion-and-implicit-rules">二次扩展和隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-expansion-and-static-pattern-rules">二次扩展和静态模式规则</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-files">辅助文件</a> ：</td><td> </td><td valign="top"><a href="#Chained-Rules">链接规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-secondary-targets">次要目标</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sed-_0028shell-command_0029"><code>sed</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Prerequisites">自动先决条件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-selecting-a-word">选择一个词</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-selecting-word-lists">选择单词列表</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sequences-of-commands">命令顺序</a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-setting-options-from-environment">从环境设置选项</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-setting-options-in-makefiles">在makefiles中设置选项</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-setting-variables">设置变量</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-several-rules-for-one-target">一个目标的几条规则</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Rules">多个规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-several-targets-in-a-rule">规则中的几个目标</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Targets">多个目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shar-_0028standard-target_0029"><code>shar</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-command_002c-function-for">shell命令，功能适用于</a> ：</td><td> </td><td valign="top"><a href="#Shell-Function">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-file-name-pattern-_0028in-include_0029">Shell文件名模式（在<code>include</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-variables_002c-setting-in-recipes">shell变量，在配方中设置</a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-wildcards-_0028in-include_0029">外壳通配符（在<code>include</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002c-choosing-the">外壳，选择</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL_002c-exported-value">外壳，出口价值</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL_002c-import-from-environment">外壳，从环境导入</a> ：</td><td> </td><td valign="top"><a href="#Environment">环境</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell_002c-in-DOS-and-Windows">Shell，在DOS和Windows中</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL_002c-MS_002dDOS-specifics"><code>SHELL</code> ，MS-DOS的详细信息</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL_002c-value-of"><code>SHELL</code> ，值</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signal">信号</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-silent-operation">静音操作</a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-simple-makefile">简单的makefile</a> ：</td><td> </td><td valign="top"><a href="#Simple-Makefile">简单的makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-simple-variable-expansion">简单变量扩展</a> ：</td><td> </td><td valign="top"><a href="#Using-Variables">使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-simplifying-with-variables">用变量简化</a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-simply-expanded-variables">简单扩展变量</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sorting-words">排序词</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-spaces_002c-in-variable-values">空格，可变值</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-spaces_002c-stripping">空格，剥离</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-special-targets">特殊目标</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-special-variables">特殊变量</a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-specifying-makefile-name">指定makefile名称</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-splitting-long-lines">分割长行</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Lines">分割线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-splitting-recipes">分割食谱</a> ：</td><td> </td><td valign="top"><a href="#Splitting-Recipe-Lines">分割配方线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-staged-installs">分阶段安装</a> ：</td><td> </td><td valign="top"><a href="#DESTDIR">DESTDIR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standard-input">标准输入</a> ：</td><td> </td><td valign="top"><a href="#Parallel-Input">并行输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standards-conformance">标准符合性</a> ：</td><td> </td><td valign="top"><a href="#Overview">总览</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standards-for-makefiles">Makefile的标准</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Conventions">Makefile约定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-static-pattern-rule">静态模式规则</a> ：</td><td> </td><td valign="top"><a href="#Static-Pattern">静态图案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-static-pattern-rule_002c-syntax-of">静态模式规则，语法为</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-static-pattern-rule_002c-versus-implicit">静态模式规则与隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Static-versus-Implicit">静态与隐式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-static-pattern-rules_002c-secondary-expansion-of">静态模式规则，二次扩展</a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stem">茎</a></td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stem-1">茎</a></td><td> </td><td valign="top"><a href="#Pattern-Match">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stem_002c-shortest">茎，最短</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Match">模式匹配</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stem_002c-variable-for">茎，变量为</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stopping-make">停止使</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-searching-for">字符串，搜索</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stripping-whitespace">去除空格</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sub_002dmake">子<code>make</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subdirectories_002c-recursion-for">子目录，递归为</a> ：</td><td> </td><td valign="top"><a href="#Recursion">递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-substitution-variable-reference">替代变量参考</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix-rule">后缀规则</a> ：</td><td> </td><td valign="top"><a href="#Suffix-Rules">后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix-rule_002c-for-archive">后缀规则，用于存档</a> ：</td><td> </td><td valign="top"><a href="#Archive-Suffix-Rules">存档后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix_002c-adding">后缀，添加</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix_002c-function-to-find">后缀，函数查找</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix_002c-substituting-in-variables">后缀，代替变量</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suppressing-inheritance">抑制继承</a> ：</td><td> </td><td valign="top"><a href="#Suppressing-Inheritance">抑制继承</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-switches">开关</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol-directories_002c-updating-archive">符号目录，更新档案</a> ：</td><td> </td><td valign="top"><a href="#Archive-Symbols">存档符号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-syntax-of-recipe">配方语法</a> ：</td><td> </td><td valign="top"><a href="#Recipe-Syntax">配方语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-syntax-of-rules">规则语法</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-tab-character-_0028in-commands_0029">制表符（在命令中）</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tabs-in-rules">规则中的标签</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TAGS-_0028standard-target_0029"><code>TAGS</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tangle"><code>tangle</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tangle-1"><code>tangle</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tar-_0028standard-target_0029"><code>tar</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target">目标</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target-pattern_002c-implicit">目标模式，隐式</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target-pattern_002c-static-_0028not-implicit_0029">目标模式，静态（非隐式）</a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-deleting-on-error">目标，删除时出错</a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-deleting-on-interrupt">目标，在中断时删除</a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-expansion">目标，扩展</a> ：</td><td> </td><td valign="top"><a href="#Reading-Makefiles">读取Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-multiple-in-pattern-rule">目标，多个模式规则</a> ：</td><td> </td><td valign="top"><a href="#Pattern-Intro">模式介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-multiple-rules-for-one">目标，针对一个的多个规则</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Rules">多个规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002c-touching">目标，接触</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-target_002dspecific-variables">目标特定的变量</a> ：</td><td> </td><td valign="top"><a href="#Target_002dspecific">目标特定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets">目标</a> ：</td><td> </td><td valign="top"><a href="#Rule-Syntax">规则语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets-without-a-file">没有文件的目标</a> ：</td><td> </td><td valign="top"><a href="#Phony-Targets">假冒目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-built_002din-special">目标，内置特殊功能</a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-empty">空目标</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-force">目标，力量</a> ：</td><td> </td><td valign="top"><a href="#Force-Targets">强制目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-introduction-to">目标，介绍</a> ：</td><td> </td><td valign="top"><a href="#Rule-Introduction">规则介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-multiple">目标，多个</a> ：</td><td> </td><td valign="top"><a href="#Multiple-Targets">多个目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-targets_002c-phony">目标，虚假</a> ：</td><td> </td><td valign="top"><a href="#Phony-Targets">假冒目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-terminal-rule">最终规则</a> ：</td><td> </td><td valign="top"><a href="#Match_002dAnything-Rules">比赛规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-terminal_002c-output-to">终端，输出到</a> ：</td><td> </td><td valign="top"><a href="#Terminal-Output">终端输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-test-_0028standard-target_0029"><code>test</code> <span class="roman">（标准目标）</span></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-testing-compilation">测试编译</a> ：</td><td> </td><td valign="top"><a href="#Testing">测试中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tex"><code>tex</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tex-1"><code>tex</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TeX_002c-rule-to-run">TeX，运行规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-texi2dvi"><code>texi2dvi</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-texi2dvi-1"><code>texi2dvi</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo_002c-rule-to-format">Texinfo，格式规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029">波浪号（ <code>~</code> ）</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tools_002c-sharing-job-slots">工具，共享工作位置</a> ：</td><td> </td><td valign="top"><a href="#Job-Slots">职位空缺</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-touch-_0028shell-command_0029"><code>touch</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Examples">通配符示例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-touch-_0028shell-command_0029-1"><code>touch</code> （shell命令）</a> ：</td><td> </td><td valign="top"><a href="#Empty-Targets">空目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-touching-files">接触文件</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-traditional-directory-search-_0028GPATH_0029">传统目录搜索（GPATH）</a> ：</td><td> </td><td valign="top"><a href="#Search-Algorithm">搜索算法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-types-of-prerequisites">先决条件类型</a> ：</td><td> </td><td valign="top"><a href="#Prerequisite-Types">先决条件类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-types_002c-conversion-of">类型，转换</a> ：</td><td> </td><td valign="top"><a href="#Guile-Types">引导类型</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-undefined-variables_002c-warning-message">未定义的变量，警告消息</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undefining-variable">未定义变量</a> ：</td><td> </td><td valign="top"><a href="#Undefine-Directive">未定义指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-updating-archive-symbol-directories">更新档案符号目录</a> ：</td><td> </td><td valign="top"><a href="#Archive-Symbols">存档符号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-updating-loaded-objects">更新加载的对象</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Loaded-Objects">重建加载的对象</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-updating-makefiles">更新makefile文件</a> ：</td><td> </td><td valign="top"><a href="#Remaking-Makefiles">重新制作Makefile</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user-defined-functions">用户定义的功能</a> ：</td><td> </td><td valign="top"><a href="#Call-Function">通话功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-value">值</a> ：</td><td> </td><td valign="top"><a href="#Using-Variables">使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-value_002c-how-a-variable-gets-it">值，变量如何获取它</a> ：</td><td> </td><td valign="top"><a href="#Values">价值观</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable">变量</a> ：</td><td> </td><td valign="top"><a href="#Using-Variables">使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable-definition">变量定义</a> ：</td><td> </td><td valign="top"><a href="#Makefile-Contents">Makefile内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable-references-in-recipes">配方中的变量引用</a> ：</td><td> </td><td valign="top"><a href="#Variables-in-Recipes">配方中的变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables">变量</a> ：</td><td> </td><td valign="top"><a href="#Variables-Simplify">变量简化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-_0024-in-name">变量， <samp>$</samp> '的名称</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-and-implicit-rule">变量和隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-appending-to">附加到的变量</a> ：</td><td> </td><td valign="top"><a href="#Appending">追加中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-automatic">自动变量</a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-command-line">变量，命令行</a> ：</td><td> </td><td valign="top"><a href="#Overriding">覆写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-command-line_002c-and-recursion">变量，命令行和递归</a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-computed-names">变量，计算名称</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-conditional-assignment">变量，条件赋值</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-defining-verbatim">变量，逐字定义</a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-environment">变量，环境</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-environment-1">变量，环境</a> ：</td><td> </td><td valign="top"><a href="#Environment">环境</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-exporting">变量，导出</a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-flavor-of">变量，风味</a> ：</td><td> </td><td valign="top"><a href="#Flavor-Function">风味功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-flavors">变量，风味</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-how-they-get-their-values">变量，它们如何获得其值</a> ：</td><td> </td><td valign="top"><a href="#Values">价值观</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-how-to-reference">变量，如何引用</a> ：</td><td> </td><td valign="top"><a href="#Reference">参考</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-loops-in-expansion">变量，扩展循环</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-modified-reference">变量，修改后的参考</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-multi_002dline">变量，多行</a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-nested-references">变量，嵌套引用</a> ：</td><td> </td><td valign="top"><a href="#Computed-Names">计算名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-origin-of">变量，起源</a> ：</td><td> </td><td valign="top"><a href="#Origin-Function">原点功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-overriding">变量，覆盖</a> ：</td><td> </td><td valign="top"><a href="#Override-Directive">覆盖指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-overriding-with-arguments">变量，用参数覆盖</a> ：</td><td> </td><td valign="top"><a href="#Overriding">覆写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-pattern_002dspecific">变量，特定于模式</a> ：</td><td> </td><td valign="top"><a href="#Pattern_002dspecific">模式特定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-recursively-expanded">变量，递归扩展</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-setting">变量，设置</a> ：</td><td> </td><td valign="top"><a href="#Setting">设置</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-simply-expanded">变量，只需扩展</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-spaces-in-values">变量，值中的空格</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-substituting-suffix-in">变量，将后缀替换为</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-substitution-reference">变量，替代参考</a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-target_002dspecific">特定于目标的变量</a> ：</td><td> </td><td valign="top"><a href="#Target_002dspecific">目标特定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-unexpanded-value">变量，未扩展值</a> ：</td><td> </td><td valign="top"><a href="#Value-Function">价值功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-warning-for-undefined">变量，警告未定义</a> ：</td><td> </td><td valign="top"><a href="#Options-Summary">选项摘要</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-varying-prerequisites">各种前提条件</a> ：</td><td> </td><td valign="top"><a href="#Static-Pattern">静态图案</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-verbatim-variable-definition">逐字变量定义</a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vpath">vpath</a> ：</td><td> </td><td valign="top"><a href="#Directory-Search">目录搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-VPATH_002c-and-implicit-rules"><code>VPATH</code>以及隐式规则</a> ：</td><td> </td><td valign="top"><a href="#Implicit_002fSearch">隐式/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-VPATH_002c-and-link-libraries"><code>VPATH</code>和链接库</a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-warnings_002c-printing">警告，印刷</a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-weave"><code>weave</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-weave-1"><code>weave</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Web_002c-rule-to-run">Web，运行规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-what-if">如果</a> ：</td><td> </td><td valign="top"><a href="#Instead-of-Execution">代替执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-whitespace_002c-in-variable-values">空格，可变值</a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-whitespace_002c-stripping">空格，剥离</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard">通配符</a> ：</td><td> </td><td valign="top"><a href="#Wildcards">通配符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard-pitfalls">通配符陷阱</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard_002c-function">通配符，功能</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard_002c-in-archive-member">通配符，在存档成员中</a> ：</td><td> </td><td valign="top"><a href="#Archive-Members">存档成员</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard_002c-in-include">通配符，在<code>include</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcards-and-MS_002dDOS_002fMS_002dWindows-backslashes">通配符和MS-DOS / MS-Windows反斜杠</a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Pitfall">通配符陷阱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Windows_002c-choosing-a-shell-in">Windows，在</a>以下位置<a href="#index-Windows_002c-choosing-a-shell-in">选择一个外壳</a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word_002c-selecting-a">单词，选择一个</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-extracting-first">单词，首先提取</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-extracting-last">单词，最后提取</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-filtering">单词，过滤</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-filtering-out">单词，过滤掉</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-finding-number">字，找到数字</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-iterating-over">话，遍历</a> ：</td><td> </td><td valign="top"><a href="#Foreach-Function">Foreach功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-joining-lists">单词，加入列表</a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-removing-duplicates">单词，删除重复项</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-selecting-lists-of">单词，选择以下列表</a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-writing-recipes">写食谱</a> ：</td><td> </td><td valign="top"><a href="#Recipes">菜谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-writing-rules">写作规则</a> ：</td><td> </td><td valign="top"><a href="#Rules">规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-writing-to-a-file">写入文件</a> ：</td><td> </td><td valign="top"><a href="#File-Function">文件功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-Y">ÿ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-yacc-1"><code>yacc</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yacc-2"><code>yacc</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-yacc"><code>yacc</code></a> ：</td><td> </td><td valign="top"><a href="#Canned-Recipes">罐装食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Yacc_002c-rule-to-run">Yacc，运行规则</a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Concept-Index_cp_symbol-1"><b>！</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-2"><b>＃</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-3"><b>$</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-4"><b>％</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-5"><b>*</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-6"><b>+</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-7"><b>，</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-8"><b>-</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-9"><b>。</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-10"><b>：</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-11"><b>=</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-12"><b>？</b></a>
   
<a class="summary-letter" href="#Concept-Index_cp_symbol-13"><b>@</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-14"><b>[</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-15"><b>\</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-16"><b>_</b></a> <a class="summary-letter" href="#Concept-Index_cp_symbol-17"><b>〜</b></a>
   
<br>
<a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-J"><b>J</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a> <a class="summary-letter" href="#Concept-Index_cp_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>

<hr>
<a name="Name-Index"></a>
<div class="header">
<p>上一篇： <a href="#Concept-Index" rel="prev" accesskey="p">概念索引</a> ，上一篇： <a href="#Top" rel="up" accesskey="u">顶部</a> [ <a href="#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<a name="Index-of-Functions_002c-Variables_002c-_0026-Directives"></a>
<h2 class="unnumbered">函数，变量和指令的索引</h2>

<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Name-Index_fn_symbol-1"><b>$</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-2"><b>％</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-3"><b>*</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-4"><b>+</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-5"><b>-</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-6"><b>。</b></a>
   
<a class="summary-letter" href="#Name-Index_fn_symbol-7"><b>/</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-8"><b><</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-9"><b>？</b></a>
   
<a class="summary-letter" href="#Name-Index_fn_symbol-10"><b>@</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-11"><b>^</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-12"><b>|</b></a>
   
<br>
<a class="summary-letter" href="#Name-Index_fn_letter-A"><b>A</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-B"><b>B</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-C"><b>C</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-D"><b>D</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-E"><b>E</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-F"><b>F</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-G"><b>G</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-I"><b>I</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-J"><b>J</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-L"><b>L</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-M"><b>M</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-N"><b>N</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-O"><b>O</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-P"><b>P</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-R"><b>R</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-S"><b>S</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-T"><b>T</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-U"><b>U</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-V"><b>V</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-W"><b>W</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>
<table class="index-fn" border="0">
<tbody><tr><td></td><th align="left">索引输入</th><td> </td><th align="left">部分</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-1">$</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0025"><code>$%</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_0025D_0029"><code>$(%D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_0025F_0029"><code>$(%F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_002aD_0029"><code>$(*D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_002aF_0029"><code>$(*F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_002bD_0029"><code>$(+D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_002bF_0029"><code>$(+F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_003cD_0029"><code>$(<D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_003cF_0029"><code>$(<F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_003fD_0029"><code>$(?D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_003fF_0029"><code>$(?F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_0040D_0029"><code>$(@D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_0040F_0029"><code>$(@F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_005eD_0029"><code>$(^D)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0028_005eF_0029"><code>$(^F)</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002a"><code>$*</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002a_002c-and-static-pattern"><code>$*<span class="roman">, and static pattern</span></code></a> ：</td><td> </td><td valign="top"><a href="#Static-Usage">静态用法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_002b"><code>$+</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_003c"><code>$<</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_003f"><code>$?</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_0040"><code>$@</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_005e"><code>$^</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024_007c"><code>$|</code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-2">％</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025-_0028automatic-variable_0029"><code>% <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025D-_0028automatic-variable_0029"><code>%D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025F-_0028automatic-variable_0029"><code>%F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-3">*</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028automatic-variable_0029"><code>* <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028automatic-variable_0029_002c-unsupported-bizarre-usage"><code>* <span class="roman">(automatic variable), unsupported bizarre usage</span></code></a> ：</td><td> </td><td valign="top"><a href="#Missing">失踪</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002aD-_0028automatic-variable_0029"><code>*D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002aF-_0028automatic-variable_0029"><code>*F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-4">+</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028automatic-variable_0029"><code>+ <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002bD-_0028automatic-variable_0029"><code>+D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002bF-_0028automatic-variable_0029"><code>+F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-5">--</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dload"><code>-load</code></a> ：</td><td> </td><td valign="top"><a href="#load-Directive">负荷指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-6">。</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDEFAULT"><code>.DEFAULT</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDEFAULT-1"><code>.DEFAULT</code></a> ：</td><td> </td><td valign="top"><a href="#Last-Resort">最后一招</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDEFAULT_002c-and-empty-recipes"><code>.DEFAULT<span class="roman">, and empty recipes</span></code></a> ：</td><td> </td><td valign="top"><a href="#Empty-Recipes">空食谱</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDEFAULT_005fGOAL-_0028define-default-goal_0029"><code>.DEFAULT_GOAL <span class="roman">(define default goal)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDELETE_005fON_005fERROR"><code>.DELETE_ON_ERROR</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eDELETE_005fON_005fERROR-1"><code>.DELETE_ON_ERROR</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eEXPORT_005fALL_005fVARIABLES"><code>.EXPORT_ALL_VARIABLES</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eEXPORT_005fALL_005fVARIABLES-1"><code>.EXPORT_ALL_VARIABLES</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eFEATURES-_0028list-of-supported-features_0029"><code>.FEATURES <span class="roman">(list of supported features)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eIGNORE"><code>.IGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eIGNORE-1"><code>.IGNORE</code></a> ：</td><td> </td><td valign="top"><a href="#Errors">失误</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eINCLUDE_005fDIRS-_0028list-of-include-directories_0029"><code>.INCLUDE_DIRS <span class="roman">(list of include directories)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eINTERMEDIATE"><code>.INTERMEDIATE</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eLIBPATTERNS"><code>.LIBPATTERNS</code></a> ：</td><td> </td><td valign="top"><a href="#Libraries_002fSearch">图书馆/搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eLOADED"><code>.LOADED</code></a> ：</td><td> </td><td valign="top"><a href="#load-Directive">负荷指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eLOW_005fRESOLUTION_005fTIME"><code>.LOW_RESOLUTION_TIME</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eNOTPARALLEL"><code>.NOTPARALLEL</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eONESHELL"><code>.ONESHELL</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eONESHELL-1"><code>.ONESHELL</code></a> ：</td><td> </td><td valign="top"><a href="#One-Shell">一壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePHONY"><code>.PHONY</code></a> ：</td><td> </td><td valign="top"><a href="#Phony-Targets">假冒目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePHONY-1"><code>.PHONY</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePOSIX"><code>.POSIX</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePOSIX-1"><code>.POSIX</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePRECIOUS"><code>.PRECIOUS</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002ePRECIOUS-1"><code>.PRECIOUS</code></a> ：</td><td> </td><td valign="top"><a href="#Interrupts">中断</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eRECIPEPREFIX-_0028change-the-recipe-prefix-character_0029"><code>.RECIPEPREFIX <span class="roman">(change the recipe prefix character)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSECONDARY"><code>.SECONDARY</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSECONDEXPANSION"><code>.SECONDEXPANSION</code></a> ：</td><td> </td><td valign="top"><a href="#Secondary-Expansion">二次扩张</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSECONDEXPANSION-1"><code>.SECONDEXPANSION</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSHELLFLAGS"><code>.SHELLFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSHELLFLAGS-1"><code>.SHELLFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSHELLSTATUS"><code>.SHELLSTATUS</code></a> ：</td><td> </td><td valign="top"><a href="#Shell-Function">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSILENT"><code>.SILENT</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSILENT-1"><code>.SILENT</code></a> ：</td><td> </td><td valign="top"><a href="#Echoing">回声</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSUFFIXES"><code>.SUFFIXES</code></a> ：</td><td> </td><td valign="top"><a href="#Special-Targets">特殊目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eSUFFIXES-1"><code>.SUFFIXES</code></a> ：</td><td> </td><td valign="top"><a href="#Suffix-Rules">后缀规则</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eVARIABLES-_0028list-of-variables_0029"><code>.VARIABLES <span class="roman">(list of variables)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-7">/</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002fusr_002fgnu_002finclude"><code>/usr/gnu/include</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002fusr_002finclude"><code>/usr/include</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002fusr_002flocal_002finclude"><code>/usr/local/include</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-8"><</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028automatic-variable_0029"><code>< <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003cD-_0028automatic-variable_0029"><code><D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003cF-_0028automatic-variable_0029"><code><F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-9">？</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f-_0028automatic-variable_0029"><code>? <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003fD-_0028automatic-variable_0029"><code>?D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003fF-_0028automatic-variable_0029"><code>?F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-10">@</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040-_0028automatic-variable_0029"><code>@ <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040D-_0028automatic-variable_0029"><code>@D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040F-_0028automatic-variable_0029"><code>@F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-11">^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028automatic-variable_0029"><code>^ <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005eD-_0028automatic-variable_0029"><code>^D <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005eF-_0028automatic-variable_0029"><code>^F <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_symbol-12">|</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028automatic-variable_0029"><code>| <span class="roman">(automatic variable)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Automatic-Variables">自动变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-A">一种</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abspath-1"><code>abspath</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-addprefix"><code>addprefix</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-addsuffix"><code>addsuffix</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-and"><code>and</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Functions">条件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AR"><code>AR</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARFLAGS"><code>ARFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AS"><code>AS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ASFLAGS"><code>ASFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-B">乙</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-basename-1"><code>basename</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bindir"><code>bindir</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-call"><code>call</code></a> ：</td><td> </td><td valign="top"><a href="#Call-Function">通话功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CC"><code>CC</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CFLAGS"><code>CFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CO"><code>CO</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COFLAGS"><code>COFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-COMSPEC"><code>COMSPEC</code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CPP"><code>CPP</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CPPFLAGS"><code>CPPFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTANGLE"><code>CTANGLE</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CURDIR"><code><code>CURDIR</code></code></a> ：</td><td> </td><td valign="top"><a href="#Recursion">递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CWEAVE"><code>CWEAVE</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CXX"><code>CXX</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CXXFLAGS"><code>CXXFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-D">d</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-define"><code>define</code></a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DESTDIR"><code>DESTDIR</code></a> ：</td><td> </td><td valign="top"><a href="#DESTDIR">DESTDIR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dir"><code>dir</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-E">Ë</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-else"><code>else</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endef"><code>endef</code></a> ：</td><td> </td><td valign="top"><a href="#Multi_002dLine">多线</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endif"><code>endif</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error"><code>error</code></a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eval"><code>eval</code></a> ：</td><td> </td><td valign="top"><a href="#Eval-Function">评估功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exec_005fprefix"><code>exec_prefix</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-export"><code>export</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-FC"><code>FC</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FFLAGS"><code>FFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file"><code>file</code></a> ：</td><td> </td><td valign="top"><a href="#File-Function">文件功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filter"><code>filter</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filter_002dout"><code>filter-out</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-findstring"><code>findstring</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-firstword"><code>firstword</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flavor"><code>flavor</code></a> ：</td><td> </td><td valign="top"><a href="#Flavor-Function">风味功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreach"><code>foreach</code></a> ：</td><td> </td><td valign="top"><a href="#Foreach-Function">Foreach功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-GET"><code>GET</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GFLAGS"><code>GFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_002deval"><code>gmk-eval</code></a> ：</td><td> </td><td valign="top"><a href="#Guile-Interface">引导界面</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_002dexpand"><code>gmk-expand</code></a> ：</td><td> </td><td valign="top"><a href="#Guile-Interface">引导界面</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005fadd_005ffunction"><code>gmk_add_function</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005falloc"><code>gmk_alloc</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005feval"><code>gmk_eval</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005fexpand"><code>gmk_expand</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005ffree"><code>gmk_free</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gmk_005ffunc_005fptr"><code>gmk_func_ptr</code></a> ：</td><td> </td><td valign="top"><a href="#Loaded-Object-API">加载的对象API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNUmakefile"><code>GNUmakefile</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GPATH"><code>GPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Search-Algorithm">搜索算法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-guile"><code>guile</code></a> ：</td><td> </td><td valign="top"><a href="#Guile-Function">引导功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-I">一世</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-if"><code>if</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Functions">条件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if-1"><code>if</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Functions">条件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifdef"><code>ifdef</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifeq"><code>ifeq</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifndef"><code>ifndef</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifneq"><code>ifneq</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Syntax">条件句法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-include"><code>include</code></a> ：</td><td> </td><td valign="top"><a href="#Include">包括</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-info"><code>info</code></a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-J">Ĵ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-join"><code>join</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-L">大号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-lastword"><code>lastword</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LDFLAGS"><code>LDFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LDLIBS"><code>LDLIBS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LEX"><code>LEX</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LFLAGS"><code>LFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libexecdir"><code>libexecdir</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LINT"><code>LINT</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LINTFLAGS"><code>LINTFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load"><code>load</code></a> ：</td><td> </td><td valign="top"><a href="#load-Directive">负荷指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LOADLIBES"><code>LOADLIBES</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-M">中号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-M2C"><code>M2C</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE"><code>MAKE</code></a> ：</td><td> </td><td valign="top"><a href="#MAKE-Variable">使变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE-1"><code>MAKE</code></a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKECMDGOALS"><code>MAKECMDGOALS</code></a> ：</td><td> </td><td valign="top"><a href="#Goals">目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Makefile"><code>Makefile</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-makefile-1"><code>makefile</code></a> ：</td><td> </td><td valign="top"><a href="#Makefile-Names">生成文件名称</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEFILES"><code>MAKEFILES</code></a> ：</td><td> </td><td valign="top"><a href="#MAKEFILES-Variable">MAKEFILES变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEFILES-1"><code>MAKEFILES</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEFILE_005fLIST-_0028list-of-parsed-makefiles_0029"><code>MAKEFILE_LIST <span class="roman">(list of parsed makefiles)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEFLAGS"><code>MAKEFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEINFO"><code>MAKEINFO</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKELEVEL"><code>MAKELEVEL</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKELEVEL-1"><code>MAKELEVEL</code></a> ：</td><td> </td><td valign="top"><a href="#Flavors">香精</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKEOVERRIDES"><code>MAKEOVERRIDES</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKESHELL-_0028MS_002dDOS-alternative-to-SHELL_0029"><code><code>MAKESHELL</code> <span class="roman">(MS-DOS alternative to <code>SHELL</code>)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE_005fHOST"><code>MAKE_HOST</code></a> ：</td><td> </td><td valign="top"><a href="#Quick-Reference">快速参考</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE_005fRESTARTS-_0028number-of-times-make-has-restarted_0029"><code>MAKE_RESTARTS <span class="roman">(number of times <code>make</code> has restarted)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE_005fTERMERR-_0028whether-stderr-is-a-terminal_0029"><code>MAKE_TERMERR <span class="roman">(whether stderr is a terminal)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE_005fTERMOUT-_0028whether-stdout-is-a-terminal_0029"><code>MAKE_TERMOUT <span class="roman">(whether stdout is a terminal)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Special-Variables">特殊变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAKE_005fVERSION"><code>MAKE_VERSION</code></a> ：</td><td> </td><td valign="top"><a href="#Quick-Reference">快速参考</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MFLAGS"><code>MFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Options_002fRecursion">选项/递归</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-N">ñ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-notdir"><code>notdir</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-O">Ø</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-or"><code>or</code></a> ：</td><td> </td><td valign="top"><a href="#Conditional-Functions">条件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-origin"><code>origin</code></a> ：</td><td> </td><td valign="top"><a href="#Origin-Function">原点功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OUTPUT_005fOPTION"><code>OUTPUT_OPTION</code></a> ：</td><td> </td><td valign="top"><a href="#Catalogue-of-Rules">规则目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-override"><code>override</code></a> ：</td><td> </td><td valign="top"><a href="#Override-Directive">覆盖指令</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-patsubst"><code>patsubst</code></a> ：</td><td> </td><td valign="top"><a href="#Substitution-Refs">替代裁判</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patsubst-1"><code>patsubst</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PC"><code>PC</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PFLAGS"><code>PFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix"><code>prefix</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-private"><code>private</code></a> ：</td><td> </td><td valign="top"><a href="#Suppressing-Inheritance">抑制继承</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-R">[R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-realpath-1"><code>realpath</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RFLAGS"><code>RFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RM"><code>RM</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-S">小号</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-sbindir"><code>sbindir</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Variables">目录变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL"><code>SHELL</code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL-1"><code>SHELL</code></a> ：</td><td> </td><td valign="top"><a href="#Choosing-the-Shell">选择外壳</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell"><code>shell</code></a> ：</td><td> </td><td valign="top"><a href="#Shell-Function">外壳功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SHELL-_0028recipe-execution_0029"><code><code>SHELL</code> <span class="roman">(recipe execution)</span></code></a> ：</td><td> </td><td valign="top"><a href="#Execution">执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort"><code>sort</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strip"><code>strip</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subst"><code>subst</code></a> ：</td><td> </td><td valign="top"><a href="#Multiple-Targets">多个目标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subst-1"><code>subst</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-suffix"><code>suffix</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SUFFIXES"><code>SUFFIXES</code></a> ：</td><td> </td><td valign="top"><a href="#Suffix-Rules">后缀规则</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-T">Ť</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-TANGLE"><code>TANGLE</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEX"><code>TEX</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXI2DVI"><code>TEXI2DVI</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-U">ü</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-undefine"><code>undefine</code></a> ：</td><td> </td><td valign="top"><a href="#Undefine-Directive">未定义指令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unexport"><code>unexport</code></a> ：</td><td> </td><td valign="top"><a href="#Variables_002fRecursion">变量/递归</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-value-1"><code>value</code></a> ：</td><td> </td><td valign="top"><a href="#Value-Function">价值功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-VPATH"><code>VPATH</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Search">目录搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-VPATH-1"><code>VPATH</code></a> ：</td><td> </td><td valign="top"><a href="#General-Search">一般搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vpath-1"><code>vpath</code></a> ：</td><td> </td><td valign="top"><a href="#Directory-Search">目录搜寻</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vpath-2"><code>vpath</code></a> ：</td><td> </td><td valign="top"><a href="#Selective-Search">选择性搜寻</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-W">w ^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-warning"><code>warning</code></a> ：</td><td> </td><td valign="top"><a href="#Make-Control-Functions">使控制功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WEAVE"><code>WEAVE</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard-1"><code>wildcard</code></a> ：</td><td> </td><td valign="top"><a href="#Wildcard-Function">通配符功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wildcard-2"><code>wildcard</code></a> ：</td><td> </td><td valign="top"><a href="#File-Name-Functions">文件名功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word"><code>word</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wordlist"><code>wordlist</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words"><code>words</code></a> ：</td><td> </td><td valign="top"><a href="#Text-Functions">文字功能</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Name-Index_fn_letter-Y">ÿ</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-YACC"><code>YACC</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-YFLAGS"><code>YFLAGS</code></a> ：</td><td> </td><td valign="top"><a href="#Implicit-Variables">隐式变量</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">跳到：</th><td><a class="summary-letter" href="#Name-Index_fn_symbol-1"><b>$</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-2"><b>％</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-3"><b>*</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-4"><b>+</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-5"><b>-</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-6"><b>。</b></a>
   
<a class="summary-letter" href="#Name-Index_fn_symbol-7"><b>/</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-8"><b><</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-9"><b>？</b></a>
   
<a class="summary-letter" href="#Name-Index_fn_symbol-10"><b>@</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-11"><b>^</b></a> <a class="summary-letter" href="#Name-Index_fn_symbol-12"><b>|</b></a>
   
<br>
<a class="summary-letter" href="#Name-Index_fn_letter-A"><b>A</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-B"><b>B</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-C"><b>C</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-D"><b>D</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-E"><b>E</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-F"><b>F</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-G"><b>G</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-I"><b>I</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-J"><b>J</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-L"><b>L</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-M"><b>M</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-N"><b>N</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-O"><b>O</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-P"><b>P</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-R"><b>R</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-S"><b>S</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-T"><b>T</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-U"><b>U</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-V"><b>V</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-W"><b>W</b></a> <a class="summary-letter" href="#Name-Index_fn_letter-Y"><b>Y</b></a>
   
</td></tr></tbody></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">脚注</h4>

<h3><a name="FOOT1" href="#DOCF1">（1）</a></h3>
<p>为MS-DOS和MS-Windows编译的GNU Make的行为就像<var>prefix</var>已被定义为DJGPP树层次结构的根。</p>
<h3><a name="FOOT2" href="#DOCF2">（2）</a></h3>
<p>在MS-DOS上，当前工作目录的值为<strong>global</strong> ，因此对其进行更改<em>将</em>影响这些系统上的以下配方行。</p>
</div>
<hr>





</body></html>