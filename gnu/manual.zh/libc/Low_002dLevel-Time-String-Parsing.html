<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>低级时间字符串解析（GNU C库）</title>

<meta name="description" content="Low-Level Time String Parsing (The GNU C Library)">
<meta name="keywords" content="Low-Level Time String Parsing (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="up" title="Parsing Date and Time">
<link href="General-Time-String-Parsing.html#General-Time-String-Parsing" rel="next" title="General Time String Parsing">
<link href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="prev" title="Parsing Date and Time">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Low_002dLevel-Time-String-Parsing"></span><div class="header">
<p>下一页： <a href="General-Time-String-Parsing.html#General-Time-String-Parsing" rel="next" accesskey="n">常规时间字符串解析</a> ，上<a href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="up" accesskey="u">一步</a> ： <a href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="up" accesskey="u">解析日期和时间</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Interpret-string-according-to-given-format"></span><h4 class="subsubsection">21.4.6.1根据给定格式解释字符串</h4>

<p>第一个功能相当低级。但是，由于它是众所周知的，因此经常在软件中使用。它的接口和实现在很大程度上受到<code>getdate</code>函数，该函数根据对的调用进行定义和实现<code>strptime</code> 。
</p>
<dl>
<dt id="index-strptime">函数： <em>char *</em> <strong>strptime</strong> <em>（const char * <var>s</var> ，const char * <var>fmt</var> ，struct tm * <var>tp</var> ）</em></dt>
<dd>
<p>初步： MT安全环境语言环境| AS不安全堆锁| AC不安全锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strptime</code>函数解析输入字符串<var>s</var>根据格式字符串<var>fmt</var>并将其结果存储在结构中<var>tp</var> 。
</p>
<p>输入字符串可以由<code>strftime</code>致电或获得任何其他方式。它不必采用人类可识别的格式；例如，日期作为<code>"02:1999:9"</code>即使没有上下文，它也是模棱两可的。只要格式字符串<var>fmt</var>匹配输入字符串，函数将成功。
</p>
<p>但是，用户必须确保可以以明确的方式解析输入。字符串<code>"1999112"</code>可以使用以下格式解析<code>"%Y%m%d"</code>例如1999-1-12、1999-11-2甚至19991-1-2。有必要添加适当的分隔符以可靠地获得结果。
</p>
<p>格式字符串由与<code>strftime</code>功能。唯一的区别是标志<code>_</code> ， <code>-</code> ， <code>0</code>和<code>^</code>不允许。几种不同的格式<code>strftime</code>在做同样的工作<code>strptime</code>因为像输入大小写这样的差异并不重要。但是出于对称的原因，所有格式都受支持。
</p>
<p>修饰符<code>E</code>和<code>O</code>也被允许到处<code>strftime</code>功能允许他们。
</p>
<p>格式为：</p>
<dl compact>
<dt><code>%a</code></dt>
<dt><code>%A</code></dt>
<dd><p>根据当前语言环境的星期几名称（缩写形式或全名）。
</p>
</dd>
<dt><code>%b</code></dt>
<dt><code>%B</code></dt>
<dt><code>%h</code></dt>
<dd><p>根据当前语言环境的月份名称。所有三个指定者将识别缩写名称和完整月份的名称。如果语言环境提供了两种不同的月份名称语法形式，则所有三个指定者都将识别两种形式。
</p>
<p>作为GNU扩展， <code>O</code>修饰符可与这些说明符一起使用；它没有作用，因为可以识别两种语法形式的月份名称。
</p>
</dd>
<dt><code>%c</code></dt>
<dd><p>当前语言环境的日期和时间表示。
</p>
</dd>
<dt><code>%Ec</code></dt>
<dd><p>喜欢<code>%c</code>但是使用了语言环境的替代日期和时间格式。
</p>
</dd>
<dt><code>%C</code></dt>
<dd><p>一年的世纪。
</p>
<p>仅当格式字符串还包含<code>%y</code>格式。
</p>
</dd>
<dt><code>%EC</code></dt>
<dd><p>时间段的语言环境表示。
</p>
<p>不像<code>%C</code>有时使用这种格式是有意义的，因为某些文化代表的是相对于时代开始的年份，而不是使用公历年份。
</p>
</dd>
<dt><code>%d</code></dt>
<dt><code>%e</code></dt>
<dd><p>以十进制数字表示的月份中的日期（范围<code>1</code>通过<code>31</code> ）。前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%Od</code></dt>
<dt><code>%Oe</code></dt>
<dd><p>和...一样<code>%d</code>但要使用语言环境的替代数字符号。
</p>
<p>前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%D</code></dt>
<dd><p>相当于<code>%m/%d/%y</code> 。
</p>
</dd>
<dt><code>%F</code></dt>
<dd><p>相当于<code>%Y-%m-%d</code> ，这是ISO 8601 <!-- /@w --> 。
</p>
<p>这是GNU扩展，遵循ISO C99 <!-- /@w -->扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%g</code></dt>
<dd><p>对应于ISO周号的年份，但没有世纪（范围<code>00</code>通过<code>99</code> ）。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
<p>此格式是GNU扩展的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%G</code></dt>
<dd><p>对应于ISO周编号的年份。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
<p>此格式是GNU扩展的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%H</code></dt>
<dt><code>%k</code></dt>
<dd><p>使用24小时制（范围为小数点的小时） <code>00</code>通过<code>23</code> ）。
</p>
<p><code>%k</code>是GNU扩展的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%OH</code></dt>
<dd><p>和...一样<code>%H</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%I</code></dt>
<dt><code>%l</code></dt>
<dd><p>以12小时制（范围为小时）的十进制数字表示的小时<code>01</code>通过<code>12</code> ）。
</p>
<p><code>%l</code>是GNU扩展的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%OI</code></dt>
<dd><p>和...一样<code>%I</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%j</code></dt>
<dd><p>一年中的天，以十进制数字表示（范围<code>1</code>通过<code>366</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%m</code></dt>
<dd><p>以十进制数表示的月份（范围<code>1</code>通过<code>12</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%Om</code></dt>
<dd><p>和...一样<code>%m</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%M</code></dt>
<dd><p>分钟为十进制数字（范围<code>0</code>通过<code>59</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%OM</code></dt>
<dd><p>和...一样<code>%M</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%n</code></dt>
<dt><code>%t</code></dt>
<dd><p>匹配任何空格。
</p>
</dd>
<dt><code>%p</code></dt>
<dt><code>%P</code></dt>
<dd><p>与语言环境相关的等价于' <samp>AM</samp> ' 要么 ' <samp>PM</samp> '。
</p>
<p>除非以下格式，否则此格式无用<code>%I</code>要么<code>%l</code>也被使用。另一个麻烦是，语言环境可能根本不会定义这些值，因此转换失败。
</p>
<p><code>%P</code>是在GNU扩展之后的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%r</code></dt>
<dd><p>使用当前语言环境的AM / PM格式的完整时间。
</p>
<p>麻烦的是，语言环境可能根本没有定义此格式，因此转换失败。
</p>
</dd>
<dt><code>%R</code></dt>
<dd><p>使用格式的十进制小时和分钟<code>%H:%M</code> 。
</p>
<p><code>%R</code>是在GNU扩展之后的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%s</code></dt>
<dd><p>自该纪元以来的秒数，即自1970-01-01 00:00:00 UTC。除非获得leap秒支持，否则不计算秒。
</p>
<p><code>%s</code>是在GNU扩展之后的GNU扩展<code>strftime</code> 。
</p>
</dd>
<dt><code>%S</code></dt>
<dd><p>秒数（十进制数）（范围<code>0</code>通过<code>60</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p><strong>注意：</strong> Unix规范说此值的上限是<code>61</code> ，是允许两次allow秒的决定的结果。您将看不到价值<code>61</code>因为没有一分钟超过一秒，但是神话依然存在。
</p>
</dd>
<dt><code>%OS</code></dt>
<dd><p>和...一样<code>%S</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%T</code></dt>
<dd><p>相当于使用<code>%H:%M:%S</code>在这个地方。
</p>
</dd>
<dt><code>%u</code></dt>
<dd><p>星期几作为十进制数字（范围<code>1</code>通过<code>7</code> ），星期一是<code>1</code> 。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
</dd>
<dt><code>%U</code></dt>
<dd><p>当前年份的星期数，以十进制数表示（范围<code>0</code>通过<code>53</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
</dd>
<dt><code>%OU</code></dt>
<dd><p>和...一样<code>%U</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%V</code></dt>
<dd><p>ISO 8601：1988 <!-- /@w -->周编号为十进制数字（范围<code>1</code>通过<code>53</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
</dd>
<dt><code>%w</code></dt>
<dd><p>星期几作为十进制数字（范围<code>0</code>通过<code>6</code> ），星期日是<code>0</code> 。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
</dd>
<dt><code>%Ow</code></dt>
<dd><p>和...一样<code>%w</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%W</code></dt>
<dd><p>当前年份的星期数，以十进制数表示（范围<code>0</code>通过<code>53</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
</dd>
<dt><code>%OW</code></dt>
<dd><p>和...一样<code>%W</code>但要使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%x</code></dt>
<dd><p>使用语言环境的日期格式的日期。
</p>
</dd>
<dt><code>%Ex</code></dt>
<dd><p>喜欢<code>%x</code>但是使用了语言环境的替代数据表示形式。
</p>
</dd>
<dt><code>%X</code></dt>
<dd><p>使用语言环境的时间格式的时间。
</p>
</dd>
<dt><code>%EX</code></dt>
<dd><p>喜欢<code>%X</code>但使用语言环境的替代时间表示形式。
</p>
</dd>
<dt><code>%y</code></dt>
<dd><p>没有世纪的年份作为十进制数字（范围<code>0</code>通过<code>99</code> ）。
</p>
<p>前导零是允许的，但不是必需的。
</p>
<p>请注意，在不使用<code>%C</code>格式。的<code>strptime</code>函数确实将范围在<em>68</em>到<em>99之间的</em>输入值视为<em>1969年</em>至<em>1999年</em> ，将值<em>0</em>到<em>68之间的</em>输入值视为<em>2000年</em>至<em>2068年</em> 。但是对于某些输入数据，这种启发式方法可能会失败。
</p>
<p>因此最好避免<code>%y</code>完全使用<code>%Y</code>代替。
</p>
</dd>
<dt><code>%Ey</code></dt>
<dd><p>相对于<code>%EC</code>在语言环境的替代表示形式中。
</p>
</dd>
<dt><code>%Oy</code></dt>
<dd><p>年份的偏移量（从<code>%C</code> ）使用语言环境的替代数字符号。
</p>
</dd>
<dt><code>%Y</code></dt>
<dd><p>使用公历的十进制数字形式的年份。
</p>
</dd>
<dt><code>%EY</code></dt>
<dd><p>替代年份的完整代表。
</p>
</dd>
<dt><code>%z</code></dt>
<dd><p>与ISO 8601 <!-- /@w --> / RFC822格式的GMT偏移量。
</p>
</dd>
<dt><code>%Z</code></dt>
<dd><p>时区名称。
</p>
<p><em>注意：</em>目前，这尚未完全实现。格式被识别，输入被使用，但没有字段<var>tm</var>被设置。
</p>
</dd>
<dt><code>%%</code></dt>
<dd><p>文字' <samp>%</samp>字符。
</p></dd>
</dl>

<p>格式字符串中的所有其他字符在输入字符串中必须具有匹配的字符。输入字符串中的空格例外，可以与格式字符串中的零个或多个空格字符匹配。
</p>
<p><strong>可移植性注意：</strong> XPG标准建议应用程序至少使用一个空格字符（由<code>isspace</code> ）或任意两个转换规范之间的其他非字母数字字符。GNU C库没有此限制，但是其他库可能无法解析格式，例如<code>"%d%m%Y%H%M%S"</code> 。
</p>
<p>的<code>strptime</code>函数从右到左处理输入字符串。三个可能的输入元素（空格，文字或格式）中的每一个都一个接一个地处理。如果输入不能与格式字符串匹配，则函数停止。其余格式和输入字符串未处理。
</p>
<p>该函数返回一个指针，指向无法处理的第一个字符。如果输入字符串包含的字符超出了格式字符串的要求，则返回值将指向最后使用的输入字符之后。如果整个输入字符串被消耗，则返回值将指向<code>NULL</code>字符串末尾的字节。如果发生错误，即<code>strptime</code>未能匹配所有格式字符串，函数将返回<code>NULL</code> 。
</p></dd></dl>

<p>XPG标准中的功能规范相当模糊，遗漏了一些重要的信息。最重要的是，它没有指定<var>tm</var>这些不是由不同格式直接初始化的。不同Unix系统上的实现在这里有所不同。
</p>
<p>GNU C库实现不涉及那些未直接初始化的字段。例外是<code>tm_wday</code>和<code>tm_yday</code>元素，如果更改了年，月或日的任何元素，则将重新计算这些元素。这有两个含义：</p>
<ul>
<li>致电之前<code>strptime</code>新输入字符串的函数，您应该准备<var>tm</var>您通过的结构。通常，这意味着将所有值初始化为零。或者，您可以将所有字段设置为类似<code>INT_MAX</code> ，使您可以确定函数调用设置了哪些元素。零在这里不起作用，因为它对于许多字段都是有效值。

<p>如果要查找是否在特定字段中进行了仔细的初始化是必要的<var>tm</var>由函数调用初始化。
</p>
</li><li>您可以构造一个<code>struct tm</code>连续几个值<code>strptime</code>电话。这的一个有用应用是例如解析两个单独的字符串，其中一个包含日期信息，另一个包含时间信息。通过一个接一个地解析而不清除它们之间的结构，您可以构建一个完整的分解时间。
</li></ul>

<p>下面的示例显示一个函数，该函数解析包含日期格式为美式或ISO 8601 <!-- /@w -->格式的日期信息的字符串：</p>
<div class="example">
<pre class="example">const char *
parse_date (const char *input, struct tm *tm)
{
  const char *cp;

  /* <span class="roman">First clear the result structure.</span>  */
  memset (tm, '\0', sizeof (*tm));

  /* <span class="roman">Try the ISO format first.</span>  */
  cp = strptime (input, &quot;%F&quot;, tm);
  if (cp == NULL)
    {
      /* <span class="roman">Does not match.  Try the US form.</span>  */
      cp = strptime (input, &quot;%D&quot;, tm);
    }

  return cp;
}
</pre></div>

<hr>
<div class="header">
<p>下一页： <a href="General-Time-String-Parsing.html#General-Time-String-Parsing" rel="next" accesskey="n">常规时间字符串解析</a> ，上<a href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="up" accesskey="u">一步</a> ： <a href="Parsing-Date-and-Time.html#Parsing-Date-and-Time" rel="up" accesskey="u">解析日期和时间</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>