<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>合并信号（GNU C库）</title>

<meta name="description" content="Merged Signals (The GNU C Library)">
<meta name="keywords" content="Merged Signals (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Defining-Handlers.html#Defining-Handlers" rel="up" title="Defining Handlers">
<link href="Nonreentrancy.html#Nonreentrancy" rel="next" title="Nonreentrancy">
<link href="Signals-in-Handler.html#Signals-in-Handler" rel="prev" title="Signals in Handler">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Merged-Signals"></span><div class="header">
<p>下一篇： <a href="Nonreentrancy.html#Nonreentrancy" rel="next" accesskey="n">Nonreentrancy</a> ，上一篇： <a href="Signals-in-Handler.html#Signals-in-Handler" rel="prev" accesskey="p">处理</a> <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">程序中的</a> <a href="Signals-in-Handler.html#Signals-in-Handler" rel="prev" accesskey="p">信号</a> ，上一篇： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">定义处理程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Signals-Close-Together-Merge-into-One"></span><h4 class="subsection">24.4.5信号紧密合并为一个</h4>
<span id="index-handling-multiple-signals"></span>
<span id="index-successive-signals"></span>
<span id="index-merging-of-signals"></span>

<p>如果在信号处理程序完全没有机会被调用之前将多个相同类型的信号传递到您的进程，则该处理程序只能被调用一次，就好像只有一个信号到达一样。实际上，信号合并为一个。当信号被阻塞时，或者在信号传递时系统正忙于运行其他进程的多处理环境中，可能会出现这种情况。例如，这意味着您不能可靠地使用信号处理程序对信号进行计数。您可以可靠地做出的唯一区分是，从过去的给定时间开始是否至少有一个信号到达。
</p>
<p>这是一个处理程序的示例<code>SIGCHLD</code>这弥补了以下事实：接收到的信号数量可能不等于产生它们的子进程数量。假定程序使用一系列结构跟踪所有子进程，如下所示：</p>
<div class="example">
<pre class="example">struct process
{
  struct process *next;
  /* <span class="roman">The process ID of this child.</span>  */
  int pid;
  /* <span class="roman">The descriptor of the pipe or pseudo terminal</span>
     <span class="roman">on which output comes from this child.</span>  */
  int input_descriptor;
  /* <span class="roman">Nonzero if this process has stopped or terminated.</span>  */
  sig_atomic_t have_status;
  /* <span class="roman">The status of this child; 0 if running,</span>
     <span class="roman">otherwise a status value from <code>waitpid</code>.</span>  */
  int status;
};

struct process *process_list;
</pre></div>

<p>此示例还使用一个标志来指示信号是否从过去的某个时间到达（程序最后一次将其清零时）。
</p>
<div class="example">
<pre class="example">/* <span class="roman">Nonzero means some child&rsquo;s status has changed</span>
   <span class="roman">so look at <code>process_list</code> for the details.</span>  */
int process_status_change;
</pre></div>

<p>这是处理程序本身：</p>
<div class="example">
<pre class="example">void
sigchld_handler (int signo)
{
  int old_errno = errno;

  while (1) {
    register int pid;
    int w;
    struct process *p;

    /* <span class="roman">Keep asking for a status until we get a definitive result.</span>  */
    do
      {
        errno = 0;
        pid = waitpid (WAIT_ANY, &amp;w, WNOHANG | WUNTRACED);
      }
    while (pid &lt;= 0 &amp;&amp; errno == EINTR);

    if (pid &lt;= 0) {
      /* <span class="roman">A real failure means there are no more</span>
         <span class="roman">stopped or terminated child processes, so return.</span>  */
      errno = old_errno;
      return;
    }

    /* <span class="roman">Find the process that signaled us, and record its status.</span>  */

    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;pid == pid) {
        p-&gt;status = w;
        /* <span class="roman">Indicate that the <code>status</code> field</span>
           <span class="roman">has data to look at.  We do this only after storing it.</span>  */
        p-&gt;have_status = 1;

        /* <span class="roman">If process has terminated, stop waiting for its output.</span>  */
        if (WIFSIGNALED (w) || WIFEXITED (w))
          if (p-&gt;input_descriptor)
            FD_CLR (p-&gt;input_descriptor, &amp;input_wait_mask);

        /* <span class="roman">The program should check this flag from time to time</span>
           <span class="roman">to see if there is any news in <code>process_list</code>.</span>  */
        ++process_status_change;
      }

    /* <span class="roman">Loop around to handle all the processes</span>
       <span class="roman">that have something to tell us.</span>  */
  }
}
</pre></div>

<p>这是检查标志的正确方法<code>process_status_change</code> ：</p>
<div class="example">
<pre class="example">if (process_status_change) {
  struct process *p;
  process_status_change = 0;
  for (p = process_list; p; p = p-&gt;next)
    if (p-&gt;have_status) {
      &hellip; <span class="roman">Examine <code>p-&gt;status</code></span> &hellip;
    }
}
</pre></div>

<p>在检查列表之前清除标志至关重要。否则，如果信号刚好在清除标志之前以及在检查了过程列表的相应元素之后才发出，则状态更改将不会被注意，直到下一个信号到达以再次设置标志为止。您当然可以通过在扫描列表时阻止信号来避免此问题，但是通过按正确的顺序进行操作来保证正确性要优雅得多。
</p>
<p>检查过程状态的循环避免检查<code>p->status</code>直到看到状态已被有效存储。这是为了确保状态在访问过程中不会更改。一旦<code>p->have_status</code>设置为1表示子进程已停止或终止，在任何一种情况下，它都无法再次停止或终止，直到程序注意到此为止。有关在变量访问期间应对中断的更多信息，请参见<a href="Atomic-Usage.html#Atomic-Usage">Atomic Usage</a> 。
</p>
<p>这是测试自上次检查以来处理程序是否已运行的另一种方法。该技术使用一个在处理程序之外永远不会更改的计数器。该程序不会清除计数，而是会记住先前的值，并查看自从先前的检查以来它是否已更改。这种方法的优点是程序的不同部分可以独立检查，每个部分检查自从上次检查该部分以来是否有信号。
</p>
<div class="example">
<pre class="example">sig_atomic_t process_status_change;

sig_atomic_t last_process_status_change;

&hellip;
{
  sig_atomic_t prev = last_process_status_change;
  last_process_status_change = process_status_change;
  if (last_process_status_change != prev) {
    struct process *p;
    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;have_status) {
        &hellip; <span class="roman">Examine <code>p-&gt;status</code></span> &hellip;
      }
  }
}
</pre></div>

<hr>
<div class="header">
<p>下一篇： <a href="Nonreentrancy.html#Nonreentrancy" rel="next" accesskey="n">Nonreentrancy</a> ，上一篇： <a href="Signals-in-Handler.html#Signals-in-Handler" rel="prev" accesskey="p">处理</a> <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">程序中的</a> <a href="Signals-in-Handler.html#Signals-in-Handler" rel="prev" accesskey="p">信号</a> ，上一篇： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">定义处理程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>