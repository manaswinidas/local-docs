<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>在字符串中查找令牌（GNU C库）</title>

<meta name="description" content="Finding Tokens in a String (The GNU C Library)">
<meta name="keywords" content="Finding Tokens in a String (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Erasing-Sensitive-Data.html#Erasing-Sensitive-Data" rel="next" title="Erasing Sensitive Data">
<link href="Search-Functions.html#Search-Functions" rel="prev" title="Search Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Finding-Tokens-in-a-String"></span><div class="header">
<p>下一篇： <a href="Erasing-Sensitive-Data.html#Erasing-Sensitive-Data" rel="next" accesskey="n">删除敏感数据</a> ，上一篇： <a href="Search-Functions.html#Search-Functions" rel="prev" accesskey="p">搜索函数</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Finding-Tokens-in-a-String-1"></span><h3 class="section">5.10在字符串中查找令牌</h3>

<span id="index-tokenizing-strings"></span>
<span id="index-breaking-a-string-into-tokens"></span>
<span id="index-parsing-tokens-from-a-string"></span>
<p>对于程序而言，需要进行一些简单的词法分析和解析是很普遍的，例如将命令字符串拆分为标记。您可以使用<code>strtok</code>函数，在头文件中声明<samp>string.h</samp> 。
<span id="index-string_002eh-6"></span>
</p>
<dl>
<dt id="index-strtok">功能： <em>char *</em> <strong>strtok</strong> <em>（char *限制<var>newstring</var> ，const char *限制<var>delimiters</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：strtok | AS不安全|交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>通过对函数进行一系列调用，可以将字符串拆分为标记<code>strtok</code> 。
</p>
<p>要拆分的字符串作为<var>newstring</var>仅在第一次调用时有一个参数。的<code>strtok</code>函数使用它来设置一些内部状态信息。后续调用从同一字符串中获取其他令牌是通过传递空指针作为<var>newstring</var>论点。呼唤<code>strtok</code>与另一个非空<var>newstring</var>参数重新初始化状态信息。确保没有其他库函数调用过<code>strtok</code>背后（这会弄乱这些内部状态信息）。
</p>
<p>的<var>delimiters</var>参数是一个字符串，它指定一组定界符，这些定界符可以包围要提取的令牌。属于此集合的所有初始字节都将被丢弃。<em>不是</em>该定界符集的成员的第一个字节标记下一个标记的开始。通过查找作为定界符集成员的下一个字节，可以找到令牌的末尾。原始字符串中的此字节<var>newstring</var>被一个空字节覆盖，并且指向令牌开头的指针<var>newstring</var>返回。
</p>
<p>在下一个通话至<code>strtok</code> ，则搜索从标记前一个令牌结尾的字节之后的下一个字节开始。请注意，定界符集<var>delimiters</var>在的一系列呼叫中，每个呼叫不必相同<code>strtok</code> 。
</p>
<p>如果字符串结尾<var>newstring</var>达到，或者如果字符串的其余部分仅由定界符字节组成， <code>strtok</code>返回一个空指针。
</p>
<p>在多字节字符串中，由多个字节组成的字符不会被视为单个实体。每个字节分别处理。该函数不依赖于语言环境。
</p></dd></dl>

<dl>
<dt id="index-wcstok">函数： <em>wchar_t *</em> <strong>wcstok</strong> <em>（wchar_t * <var>newstring</var> ，const wchar_t * <var>delimiters</var> ，wchar_t ** <var>save_ptr</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>通过对函数进行一系列调用，可以将字符串拆分为标记<code>wcstok</code> 。
</p>
<p>要拆分的字符串作为<var>newstring</var>仅在第一次调用时有一个参数。的<code>wcstok</code>函数使用它来设置一些内部状态信息。通过传递一个空指针作为<var>newstring</var>参数，它导致指针先前存储在<var>save_ptr</var>代替使用。
</p>
<p>的<var>delimiters</var>参数是一个宽字符串，它指定一组定界符，这些定界符可以包围要提取的令牌。属于此集合的所有初始宽字符都将被丢弃。<em>不</em>属于此定界符集合的第一个宽字符标记下一个标记的开始。通过查找作为定界符集成员的下一个宽字符，可以找到令牌的末尾。原始宽字符串中的宽字符<var>newstring</var>被一个空的宽字符覆盖，超过该覆盖的宽字符的指针被保存在<var>save_ptr</var> ，以及指向令牌开头的指针<var>newstring</var>返回。
</p>
<p>在下一个通话至<code>wcstok</code> ，则搜索从标记上一个标记结尾处的下一个宽字符开始。请注意，定界符集<var>delimiters</var>在的一系列呼叫中，每个呼叫不必相同<code>wcstok</code> 。
</p>
<p>如果宽字符串结尾<var>newstring</var>达到，或者如果字符串的其余部分仅由定界符宽字符组成， <code>wcstok</code>返回一个空指针。
</p></dd></dl>

<p><strong>警告：</strong>由于<code>strtok</code>和<code>wcstok</code>更改他们正在解析的字符串，您应该始终在将字符串解析之前将其复制到临时缓冲区<code>strtok</code> / <code>wcstok</code> （请参阅<a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays">复制字符串和数组</a> ）。如果允许的话<code>strtok</code>要么<code>wcstok</code>要修改来自程序另一部分的字符串，您就麻烦了；该字符串可能在以后用于其他目的<code>strtok</code>要么<code>wcstok</code>已对其进行修改，并且不会具有预期值。
</p>
<p>您正在操作的字符串甚至可能是一个常量。然后当<code>strtok</code>要么<code>wcstok</code>尝试对其进行修改，您的程序将在写入只读存储器时收到致命信号。请参阅<a href="Program-Error-Signals.html#Program-Error-Signals">程序错误信号</a> 。即使操作<code>strtok</code>要么<code>wcstok</code>不需要修改字符串（例如，如果有一个正确的标记），就可以（并且在GNU C库的情况下）修改字符串。
</p>
<p>这是一般原则的一种特例：如果程序的一部分没有特定数据结构的修改作为目的，那么临时修改数据结构是容易出错的。
</p>
<p>功能<code>strtok</code>不是可重入的，而<code>wcstok</code>是。请参阅<a href="Nonreentrancy.html#Nonreentrancy">Nonreentrancy</a> ，以了解在何处以及为何重新进入很重要。
</p>
<p>这是一个简单的示例，显示了<code>strtok</code> 。
</p>
<div class="example">
<pre class="example">#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

&hellip;

const char string[] = &quot;words separated by spaces -- and, punctuation!&quot;;
const char delimiters[] = &quot; .,;:!-&quot;;
char *token, *cp;

&hellip;

cp = strdupa (string);                /* Make writable copy.  */
token = strtok (cp, delimiters);      /* token =&gt; &quot;words&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; &quot;separated&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; &quot;by&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; &quot;spaces&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; &quot;and&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; &quot;punctuation&quot; */
token = strtok (NULL, delimiters);    /* token =&gt; NULL */
</pre></div>

<p>GNU C库包含两个用于标记字符串的函数，这些函数克服了不可重入的限制。它们不适用于宽字符串。
</p>
<dl>
<dt id="index-strtok_005fr">函数： <em>char *</em> <strong>strtok_r</strong> <em>（char * <var>newstring</var> ，const char * <var>delimiters</var> ，字符** <var>save_ptr</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>就像<code>strtok</code> ，此函数将字符串分成几个令牌，可以通过连续调用来访问<code>strtok_r</code> 。区别在于<code>wcstok</code> ，有关下一个令牌的信息存储在第三个参数所指向的空间中， <var>save_ptr</var> ，它是指向字符串指针的指针。呼唤<code>strtok_r</code>用一个空指针<var>newstring</var>然后离开<var>save_ptr</var>在两次通话之间保持不变不会影响重入。
</p>
<p>此功能在POSIX.1中定义，可以在许多支持多线程的系统上找到。
</p></dd></dl>

<dl>
<dt id="index-strsep">功能： <em>char *</em> <strong>strsep</strong> <em>（char ** <var>string_ptr</var> ，const char * <var>delimiter</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能具有与以下功能相似的功能<code>strtok_r</code>与<var>newstring</var>参数替换为<var>save_ptr</var>论点。移动指针的初始化必须由用户完成。连续致电<code>strsep</code>沿着由分隔的令牌移动指针<var>delimiter</var> ，返回下一个令牌的地址并更新<var>string_ptr</var>指向下一个标记的开头。
</p>
<p>两者之间的区别<code>strsep</code>和<code>strtok_r</code>是如果输入字符串包含一个以上的字节<var>delimiter</var>连续<code>strsep</code>为来自的每对字节返回一个空字符串<var>delimiter</var> 。这意味着程序通常应测试<code>strsep</code>在处理之前返回一个空字符串。
</p>
<p>此功能在4.3BSD中引入，因此可以广泛使用。
</p></dd></dl>

<p>这是上面的示例在以下情况下的样子<code>strsep</code>用来。
</p>
<div class="example">
<pre class="example">#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

&hellip;

const char string[] = &quot;words separated by spaces -- and, punctuation!&quot;;
const char delimiters[] = &quot; .,;:!-&quot;;
char *running;
char *token;

&hellip;

running = strdupa (string);
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;words&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;separated&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;by&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;spaces&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;and&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;punctuation&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; &quot;&quot; */
token = strsep (&amp;running, delimiters);    /* token =&gt; NULL */
</pre></div>

<dl>
<dt id="index-basename">函数： <em>char *</em> <strong>基本名称</strong> <em>（const char * <var>filename</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>GNU版本的<code>basename</code>函数返回路径的最后一部分<var>filename</var> 。该函数是首选用法，因为它不会修改参数， <var>filename</var> ，并遵守斜杠。的原型<code>basename</code>可以在<samp>string.h</samp> 。请注意，此功能已被XPG版本覆盖，如果<samp>libgen.h</samp>已经包括了。
</p>
<p>使用GNU的示例<code>basename</code> ：</p>
<div class="example">
<pre class="example">#include &lt;string.h&gt;

int
main (int argc, char *argv[])
{
  char *prog = basename (argv[0]);

  if (argc &lt; 2)
    {
      fprintf (stderr, &quot;Usage %s &lt;arg&gt;\n&quot;, prog);
      exit (1);
    }

  &hellip;
}
</pre></div>

<p><strong>可移植性注意：</strong>此功能可能在不同的系统上产生不同的结果。
</p>
</dd></dl>

<dl>
<dt id="index-basename-1">函数： <em>char *</em> <strong>basename</strong> <em>（字符* <var>path</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这是定义的标准XPG <code>basename</code> 。它的实质与GNU版本相似，但可以修改<var>path</var>通过删除尾随的“ /”字节。如果<var>path</var>完全由“ /”字节组成，则将返回“ /”。另外，如果<var>path</var>是<code>NULL</code>或一个空字符串，然后是“。”返回。XPG版本的原型可以在以下位置找到<samp>libgen.h</samp> 。
</p>
<p>使用XPG的示例<code>basename</code> ：</p>
<div class="example">
<pre class="example">#include &lt;libgen.h&gt;

int
main (int argc, char *argv[])
{
  char *prog;
  char *path = strdupa (argv[0]);

  prog = basename (path);

  if (argc &lt; 2)
    {
      fprintf (stderr, &quot;Usage %s &lt;arg&gt;\n&quot;, prog);
      exit (1);
    }

  &hellip;

}
</pre></div>
</dd></dl>

<dl>
<dt id="index-dirname">函数： <em>char *</em> <strong>dirname</strong> <em>（字符* <var>path</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>dirname</code>功能是对XPG版本的补充<code>basename</code> 。它返回由指定的文件的父目录<var>path</var> 。如果<var>path</var>是<code>NULL</code> ，一个空字符串或不包含'/'字节，然后是“。”返回。该功能的原型可以在下面找到<samp>libgen.h</samp> 。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Erasing-Sensitive-Data.html#Erasing-Sensitive-Data" rel="next" accesskey="n">删除敏感数据</a> ，上一篇： <a href="Search-Functions.html#Search-Functions" rel="prev" accesskey="p">搜索函数</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>