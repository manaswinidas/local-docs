<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>搜索功能（GNU C库）</title>

<meta name="description" content="Search Functions (The GNU C Library)">
<meta name="keywords" content="Search Functions (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="next" title="Finding Tokens in a String">
<link href="Collation-Functions.html#Collation-Functions" rel="prev" title="Collation Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Search-Functions"></span><div class="header">
<p>下一篇： <a href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="next" accesskey="n">在字符串中查找令牌，上一篇</a> ： <a href="Collation-Functions.html#Collation-Functions" rel="prev" accesskey="p">排序函数</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Search-Functions-1"></span><h3 class="section">5.9搜索功能</h3>

<p>本节介绍对字符串和数组执行各种搜索操作的库函数。这些函数在头文件中声明<samp>string.h</samp> 。
<span id="index-string_002eh-5"></span>
<span id="index-search-functions-_0028for-strings_0029"></span>
<span id="index-string-search-functions"></span>
</p>
<dl>
<dt id="index-memchr">函数： <em>void *</em> <strong>memchr</strong> <em>（常量void * <var>block</var> ，int <var>c</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数查找字节的第一个匹配项<var>c</var> （转换为<code>unsigned char</code> ）开头<var>size</var>对象的字节开始于<var>block</var> 。返回值是指向所定位字节的指针，如果找不到匹配项，则返回空指针。
</p></dd></dl>

<dl>
<dt id="index-wmemchr">函数： <em>wchar_t *</em> <strong>wmemchr</strong> <em>（const wchar_t * <var>block</var> ，wchar_t <var>wc</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数查找宽字符的首次出现<var>wc</var>在最初<var>size</var>对象的宽字符开始于<var>block</var> 。返回值是指向所定位的宽字符的指针，如果找不到匹配项，则返回空指针。
</p></dd></dl>

<dl>
<dt id="index-rawmemchr">函数： <em>void *</em> <strong>rawmemchr</strong> <em>（常量void * <var>block</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>通常<code>memchr</code>在知道字节的情况下使用函数<var>c</var>在参数指定的存储块中可用。但这意味着<var>size</var>参数并不是真正需要的参数，也不需要在运行时使用该参数执行的测试（以检查是否到达块的末尾）。
</p>
<p>的<code>rawmemchr</code>仅对于这种情况就存在这种功能，这种情况出奇的频繁。界面类似于<code>memchr</code>除了<var>size</var>参数丢失。该函数的外观将超出所指向的块的末尾<var>block</var>如果程序员在假设该字节出错时出错<var>c</var>存在于区块中。在这种情况下，结果是不确定的。否则，返回值是指向所定位字节的指针。
</p>
<p>查找字符串的结尾时，此功能特别有用。由于所有字符串都以空字节结尾，因此调用</p>
<div class="example">
<pre class="example">   rawmemchr (str, '\0')
</pre></div>

<p>永远不会超出字符串的末尾。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-memrchr">函数： <em>void *</em> <strong>memrchr</strong> <em>（常量void * <var>block</var> ，int <var>c</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>memrchr</code>就好像<code>memchr</code> ，除了它从由定义的块的末尾向后搜索<var>block</var>和<var>size</var> （而不是从前方向前）。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-strchr">函数： <em>char *</em> <strong>strchr</strong> <em>（const char * <var>string</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strchr</code>函数查找字节的第一个匹配项<var>c</var> （转换为<code>char</code> ）在开头的字符串中<var>string</var> 。返回值是指向所定位字节的指针，如果找不到匹配项，则返回空指针。
</p>
<p>例如，</p><div class="example">
<pre class="example">strchr (&quot;hello, world&quot;, 'l')
    &rArr; &quot;llo, world&quot;
strchr (&quot;hello, world&quot;, '?')
    &rArr; NULL
</pre></div>

<p>终止的空字节被认为是字符串的一部分，因此您可以使用此函数通过将零指定为字符串的值来获取指向字符串末尾的指针。 <var>c</var>论点。
</p>
<p>什么时候<code>strchr</code>返回一个空指针，它不会让您知道找到的终止空字节的位置。如果您需要这些信息，则最好使用（但不便于携带） <code>strchrnul</code>而不是第二次搜索。
</p></dd></dl>

<dl>
<dt id="index-wcschr">功能： <em>wchar_t *</em> <strong>wcschr</strong> <em>（const wchar_t * <var>wstring</var> ，int <var>wc</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcschr</code>函数查找宽字符的第一个匹配项<var>wc</var>在开始于<var>wstring</var> 。返回值是指向所定位的宽字符的指针，如果找不到匹配项，则返回空指针。
</p>
<p>终止的空宽字符被认为是宽字符串的一部分，因此您可以使用此函数通过将空宽字符指定为宽字符串的值来获取指向宽字符串末尾的指针。 <var>wc</var>论点。使用会更好（但便携性较差） <code>wcschrnul</code>在这种情况下，
</p></dd></dl>

<dl>
<dt id="index-strchrnul">函数： <em>char *</em> <strong>strchrnul</strong> <em>（const char * <var>string</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>strchrnul</code>是相同的<code>strchr</code>除了如果找不到该字节，它会返回一个指向字符串终止空字节的指针，而不是一个空指针。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-wcschrnul">函数： <em>wchar_t *</em> <strong>wcschrnul</strong> <em>（const wchar_t * <var>wstring</var> ，wchar_t <var>wc</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>wcschrnul</code>是相同的<code>wcschr</code>除非它找不到宽字符，否则它将返回指向宽字符串终止的空宽字符的指针，而不是空指针。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<p>一种有用的但不寻常的使用<code>strchr</code>函数是当您想要一个指针指向终止字符串的空字节时。这通常是这样写的：</p>
<div class="example">
<pre class="example">  s += strlen (s);
</pre></div>

<p>这几乎是最佳选择，但是加法运算重复了已经在<code>strlen</code>功能。更好的解决方案是：</p>
<div class="example">
<pre class="example">  s = strchr (s, '\0');
</pre></div>

<p>对第二个参数没有限制<code>strchr</code>因此也很可能为零。那些对此进行认真思考的读者现在可能会指出， <code>strchr</code>功能比<code>strlen</code>功能，因为我们有两个中止条件。这是正确的。但是在GNU C库中的实现<code>strchr</code>以特殊方式进行了优化，以便<code>strchr</code>实际上更快。
</p>
<dl>
<dt id="index-strrchr">函数： <em>char *</em> <strong>strrchr</strong> <em>（const char * <var>string</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>strrchr</code>就好像<code>strchr</code> ，除了它从字符串的末尾向后搜索<var>string</var> （而不是从前方向前）。
</p>
<p>例如，</p><div class="example">
<pre class="example">strrchr (&quot;hello, world&quot;, 'l')
    &rArr; &quot;ld&quot;
</pre></div>
</dd></dl>

<dl>
<dt id="index-wcsrchr">函数： <em>wchar_t *</em> <strong>wcsrchr</strong> <em>（常量wchar_t * <var>wstring</var> ，wchar_t <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>wcsrchr</code>就好像<code>wcschr</code> ，除了它从字符串的末尾向后搜索<var>wstring</var> （而不是从前方向前）。
</p></dd></dl>

<dl>
<dt id="index-strstr">功能： <em>char *</em> <strong>strstr</strong> <em>（const char * <var>haystack</var> ，const char * <var>needle</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>就像<code>strchr</code> ，除了它会搜索<var>haystack</var>对于一个子串<var>needle</var>而不是一个字节。它返回一个指针到字符串<var>haystack</var>这是子字符串的第一个字节，如果找不到匹配项，则为空指针。如果<var>needle</var>是一个空字符串，该函数返回<var>haystack</var> 。
</p>
<p>例如，</p><div class="example">
<pre class="example">strstr (&quot;hello, world&quot;, &quot;l&quot;)
    &rArr; &quot;llo, world&quot;
strstr (&quot;hello, world&quot;, &quot;wo&quot;)
    &rArr; &quot;world&quot;
</pre></div>
</dd></dl>

<dl>
<dt id="index-wcsstr">函数： <em>wchar_t *</em> <strong>wcsstr</strong> <em>（常量wchar_t * <var>haystack</var> ，const wchar_t * <var>needle</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>就像<code>wcschr</code> ，除了它会搜索<var>haystack</var>对于一个子串<var>needle</var>而不是一个宽字符。它返回一个指针到字符串<var>haystack</var>那是子字符串的第一个宽字符，如果找不到匹配项，则为空指针。如果<var>needle</var>是一个空字符串，该函数返回<var>haystack</var> 。
</p></dd></dl>

<dl>
<dt id="index-wcswcs">函数： <em>wchar_t *</em> <strong>wcswcs</strong> <em>（常量wchar_t * <var>haystack</var> ，const wchar_t * <var>needle</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>wcswcs</code>是已弃用的别名<code>wcsstr</code> 。这是在X / Open可移植性指南中最初使用的名称，在此之前发布了对ISO C90 <!-- /@w -->的修订1 <!-- /@w --> 。
</p></dd></dl>


<dl>
<dt id="index-strcasestr">函数： <em>char *</em> <strong>strcasestr</strong> <em>（const char * <var>haystack</var> ，const char * <var>needle</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>就像<code>strstr</code> ，除了在搜索子字符串时忽略大小写。喜欢<code>strcasecmp</code> ，取决于语言环境，大小写字符之间的关系如何，参数是多字节字符串。
</p>

<p>例如，</p><div class="example">
<pre class="example">strcasestr (&quot;hello, world&quot;, &quot;L&quot;)
    &rArr; &quot;llo, world&quot;
strcasestr (&quot;hello, World&quot;, &quot;wo&quot;)
    &rArr; &quot;World&quot;
</pre></div>
</dd></dl>


<dl>
<dt id="index-memmem">函数： <em>void *</em> <strong>memmem</strong> <em>（常量void * <var>haystack</var> ，size_t <var>haystack-len</var> ，<br>const void * <var>needle</var> ，size_t <var>needle-len</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>就像<code>strstr</code> ，但是<var>needle</var>和<var>haystack</var>是字节数组而不是字符串。 <var>needle-len</var>是的长度<var>needle</var>和<var>haystack-len</var>是的长度<var>haystack</var> 。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-strspn">功能： <em>size_t</em> <strong>strspn</strong> <em>（const char * <var>string</var> ，const char * <var>skipset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strspn</code> （“字符串范围”）函数返回的初始子字符串的长度<var>string</var>它完全由字节组成，这些字节是字符串指定的集合的成员<var>skipset</var> 。字节顺序<var>skipset</var>并不重要。
</p>
<p>例如，</p><div class="example">
<pre class="example">strspn (&quot;hello, world&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;)
    &rArr; 5
</pre></div>

<p>在多字节字符串中，由多个字节组成的字符不会被视为单个实体。每个字节分别处理。该函数不依赖于语言环境。
</p></dd></dl>

<dl>
<dt id="index-wcsspn">功能： <em>size_t</em> <strong>wcsspn</strong> <em>（const wchar_t * <var>wstring</var> ，const wchar_t * <var>skipset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcsspn</code> （“宽字符串范围”）函数返回的初始子字符串的长度<var>wstring</var>完全由宽字符组成，它们是字符串指定的集合的成员<var>skipset</var> 。宽字符的顺序<var>skipset</var>并不重要。
</p></dd></dl>

<dl>
<dt id="index-strcspn">功能： <em>size_t</em> <strong>strcspn</strong> <em>（const char * <var>string</var> ，const char * <var>stopset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strcspn</code> （“字符串补码跨度”）函数返回的初始子字符串的长度<var>string</var>完全由<em>不</em>属于字符串指定集合的成员的字节组成<var>stopset</var> 。（换句话说，它返回第一个字节的偏移量<var>string</var>是集合的成员<var>stopset</var> ）
</p>
<p>例如，</p><div class="example">
<pre class="example">strcspn (&quot;hello, world&quot;, &quot; \t\n,.;!?&quot;)
    &rArr; 5
</pre></div>

<p>在多字节字符串中，由多个字节组成的字符不会被视为单个实体。每个字节分别处理。该函数不依赖于语言环境。
</p></dd></dl>

<dl>
<dt id="index-wcscspn">功能： <em>size_t</em> <strong>wcscspn</strong> <em>（const wchar_t * <var>wstring</var> ，const wchar_t * <var>stopset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcscspn</code> （“宽字符串补码跨度”）函数返回的初始子字符串的长度<var>wstring</var>完全由宽字符组成，这些字符<em>不是</em>字符串指定的集合的成员<var>stopset</var> 。（换句话说，它返回第一个宽字符的偏移量<var>string</var>是集合的成员<var>stopset</var> ）
</p></dd></dl>

<dl>
<dt id="index-strpbrk">函数： <em>char *</em> <strong>strpbrk</strong> <em>（const char * <var>string</var> ，const char * <var>stopset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strpbrk</code> （“字符串指针中断”）功能与<code>strcspn</code> ，除了它返回指向第一个字节的指针<var>string</var>是集合的成员<var>stopset</var>而不是初始子字符串的长度。如果没有这样的字节，它将返回一个空指针<var>stopset</var>被发现。
</p>
<p>例如，</p>
<div class="example">
<pre class="example">strpbrk (&quot;hello, world&quot;, &quot; \t\n,.;!?&quot;)
    &rArr; &quot;, world&quot;
</pre></div>

<p>在多字节字符串中，由多个字节组成的字符不会被视为单个实体。每个字节分别处理。该函数不依赖于语言环境。
</p></dd></dl>

<dl>
<dt id="index-wcspbrk">功能： <em>wchar_t *</em> <strong>wcspbrk</strong> <em>（const wchar_t * <var>wstring</var> ，const wchar_t * <var>stopset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcspbrk</code> （“宽字符串指针中断”）功能与<code>wcscspn</code> ，除了它返回指向第一个宽字符的指针<var>wstring</var>是集合的成员<var>stopset</var>而不是初始子字符串的长度。如果没有这样的宽字符，它将返回一个空指针<var>stopset</var>被发现。
</p></dd></dl>


<span id="Compatibility-String-Search-Functions"></span><h4 class="subsection">5.9.1兼容性字符串搜索功能</h4>

<dl>
<dt id="index-index">函数： <em>char *</em> <strong>索引</strong> <em>（const char * <var>string</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>index</code>是的另一个名字<code>strchr</code> ;他们是完全一样的。新代码应始终使用<code>strchr</code>因为此名称是在ISO C <!-- /@w -->定义的，而<code>index</code>是BSD的一项发明，从未在System V <!-- /@w -->派生的系统上使用。
</p></dd></dl>

<dl>
<dt id="index-rindex">函数： <em>char *</em> <strong>rindex</strong> <em>（const char * <var>string</var> ，int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>rindex</code>是的另一个名字<code>strrchr</code> ;他们是完全一样的。新代码应始终使用<code>strrchr</code>因为此名称是在ISO C <!-- /@w -->定义的，而<code>rindex</code>是BSD的一项发明，在System V <!-- /@w -->派生系统上从未有过。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="next" accesskey="n">在字符串中查找令牌，上一篇</a> ： <a href="Collation-Functions.html#Collation-Functions" rel="prev" accesskey="p">排序函数</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>