<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>流和线程（GNU C库）</title>

<meta name="description" content="Streams and Threads (The GNU C Library)">
<meta name="keywords" content="Streams and Threads (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" title="I/O on Streams">
<link href="Streams-and-I18N.html#Streams-and-I18N" rel="next" title="Streams and I18N">
<link href="Closing-Streams.html#Closing-Streams" rel="prev" title="Closing Streams">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Streams-and-Threads"></span><div class="header">
<p>下一篇： <a href="Streams-and-I18N.html#Streams-and-I18N" rel="next" accesskey="n">Streams和I18N</a> ，上一篇： <a href="Closing-Streams.html#Closing-Streams" rel="prev" accesskey="p">关闭流</a> ，上一篇： <a href="Streams-and-I18N.html#Streams-and-I18N" rel="next" accesskey="n">Streams</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Streams-and-Threads-1"></span><h3 class="section">12.5流和线程</h3>

<span id="index-threads"></span>
<span id="index-multi_002dthreaded-application"></span>
<p>流可以在多线程应用程序中使用，就像在单线程应用程序中使用流一样。但是程序员必须意识到可能的复杂性。同样重要的是，也要知道程序编写者是否从未使用过线程，因为许多流函数的设计和实现在很大程度上受多线程编程添加的要求的影响。
</p>
<p>POSIX标准要求默认情况下流操作是原子的。即，同时在两个线程中为同一流发出两个流操作将导致这些操作被执行，就好像它们是顺序发出的一样。防止在读取或写入时执行的缓冲区操作受到同一流的其他使用。为此，每个流都有一个内部锁定对象，在完成任何工作之前必须（隐式）获取该对象。
</p>
<p>但是在某些情况下这还远远不够，在某些情况下也不希望这样做。如果程序需要原子调用多个流函数，则隐式锁定是不够的。一个示例是，如果程序要生成的输出行是通过多个函数调用创建的。函数本身将仅确保其自身操作的原子性，而不确保所有函数调用的原子性。为此，有必要在应用程序代码中执行流锁定。
</p>
<dl>
<dt id="index-flockfile">功能： <em>无效的</em> <strong>flockfile</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>flockfile</code>函数获取与流关联的内部锁定对象<var>stream</var> 。这样可以确保没有其他线程可以显式地通过<code>flockfile</code> / <code>ftrylockfile</code>或通过调用流函数隐式锁定流。线程将阻塞，直到获得锁为止。明确呼叫<code>funlockfile</code>必须用于释放锁。
</p></dd></dl>

<dl>
<dt id="index-ftrylockfile">函数： <em>int</em> <strong>ftrylockfile</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>ftrylockfile</code>函数尝试获取与流关联的内部锁定对象<var>stream</var>就像<code>flockfile</code> 。但是不像<code>flockfile</code>如果锁不可用，此功能不会阻止。 <code>ftrylockfile</code>如果成功获取了锁，则返回零。否则，该流将被另一个线程锁定。
</p></dd></dl>

<dl>
<dt id="index-funlockfile">功能： <em>void</em> <strong>funlockfile</strong> <em>（文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>funlockfile</code>函数释放流的内部锁定对象<var>stream</var> 。该流必须已通过调用之前被锁定<code>flockfile</code>或成功致电<code>ftrylockfile</code> 。流操作执行的隐式锁定不计算在内。的<code>funlockfile</code>函数不会返回错误状态，并且未定义当前线程未锁定的流的调用行为。
</p></dd></dl>

<p>以下示例显示了即使在多线程应用程序中，上述函数也可用于自动生成输出行的方法（是的，使用一个函数即可完成相同的工作<code>fprintf</code>致电，但有时是不可能的）：</p>
<div class="example">
<pre class="example">FILE *fp;
{
   &hellip;
   flockfile (fp);
   fputs (&quot;This is test number &quot;, fp);
   fprintf (fp, &quot;%d\n&quot;, test);
   funlockfile (fp)
}
</pre></div>

<p>如果没有显式锁定，则另一个线程可能会使用该流<var>fp</var>之后<code>fputs</code>回电及之前<code>fprintf</code>被调用，结果是数字不跟单词“ <samp>number</samp> '。
</p>
<p>根据此描述，可能已经很清楚，流中的锁定对象不是简单的互斥体。由于允许在同一线程中两次锁定同一流，因此锁定对象必须等效于递归互斥体。这些互斥锁跟踪所有者和获得锁的次数。相同数量<code>funlockfile</code>要完全解锁流，必须由同一线程进行调用。例如：</p>
<div class="example">
<pre class="example">void
foo (FILE *fp)
{
  ftrylockfile (fp);
  fputs (&quot;in foo\n&quot;, fp);
  /* <span class="roman">This is very wrong!!!</span>  */
  funlockfile (fp);
}
</pre></div>

<p>在此重要的是<code>funlockfile</code>仅当<code>ftrylockfile</code>函数成功锁定了流。因此，忽略以下结果总是错误的<code>ftrylockfile</code> 。这是没有意义的，因为否则会使用<code>flockfile</code> 。上面的代码的结果是<code>funlockfile</code>尝试释放尚未被当前线程锁定的流，或者它过早地释放了该流。该代码应如下所示：</p>
<div class="example">
<pre class="example">void
foo (FILE *fp)
{
  if (ftrylockfile (fp) == 0)
    {
      fputs (&quot;in foo\n&quot;, fp);
      funlockfile (fp);
    }
}
</pre></div>

<p>既然我们已经说明了为什么需要进行锁定，那么有必要讨论不需要锁定的情况以及可以做什么。锁定操作（显式或隐式）不是免费提供的。即使不使用锁，费用也不为零。必须执行的操作需要在多处理器环境中安全的内存操作。由于此类系统涉及许多本地缓存，因此这是非常昂贵的。因此，最好避免完全不需要的锁定-因为所讨论的代码永远不会在两个或多个线程可能一次使用一个流的上下文中使用。多数情况下，这可以通过应用程序代码确定。对于可以在许多情况下使用的库代码，应该默认为保守的并使用锁定。
</p>
<p>有两种避免锁定的基本机制。首先是使用<code>_unlocked</code>流操作的变体。POSIX标准定义了很多这样的内容，而GNU C库又添加了更多内容。这些函数的变体的行为与名称不带后缀的函数的行为相同，只是它们不锁定流。非常希望使用这些功能，因为它们可能更快。这不仅是因为避免了锁定操作本身。更重要的是，像<code>putc</code>和<code>getc</code>非常简单，传统上（在引入线程之前）被实现为宏，如果缓冲区不为空，它们将非常快。随着锁定要求的增加，这些功能不再实现为宏，因为它们会扩展为太多的代码。但是这些宏仍然可以使用新名称的相同功能<code>putc_unlocked</code>和<code>getc_unlocked</code> 。速度可能存在巨大差异，这也建议您使用<code>_unlocked</code>即使需要锁定也能正常工作。不同之处在于，随后必须在程序中执行锁定：</p>
<div class="example">
<pre class="example">void
foo (FILE *fp, char *buf)
{
  flockfile (fp);
  while (*buf != '/')
    putc_unlocked (*buf++, fp);
  funlockfile (fp);
}
</pre></div>

<p>如果在此示例中<code>putc</code>函数将被使用，显式锁定将丢失<code>putc</code>函数必须在每次调用中获取锁定，这可能取决于循环何时终止而多次获取。用上面说明的方式编写它可以<code>putc_unlocked</code>要使用的宏，这意味着没有锁定和直接操作流的缓冲区。
</p>
<p>避免锁定的第二种方法是使用Solaris中引入的非标准函数，该函数也在GNU C库中可用。
</p>
<dl>
<dt id="index-_005f_005ffsetlocking">功能： <em>int</em> <strong>__fsetlocking</strong> <em>（FILE * <var>stream</var> ，int <var>type</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：流| AS不安全锁|交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>__fsetlocking</code>函数可用于选择流操作是否将隐式获取流的锁定对象<var>stream</var> 。默认情况下，此操作已完成，但是可以使用此功能禁用并恢复它。为此，定义了三个值<var>type</var>参数。
</p>
<dl compact>
<dt><code>FSETLOCKING_INTERNAL</code>
<span id="index-FSETLOCKING_005fINTERNAL"></span>
</dt>
<dd><p>流<code>stream</code>从现在开始将使用默认的内部锁定。每个流操作，除了<code>_unlocked</code>变体将隐式锁定流。
</p>
</dd>
<dt><code>FSETLOCKING_BYCALLER</code>
<span id="index-FSETLOCKING_005fBYCALLER"></span>
</dt>
<dd><p>之后<code>__fsetlocking</code>函数返回时，用户负责锁定流。在状态重新设置为之前，所有流操作都不会隐式执行此操作。 <code>FSETLOCKING_INTERNAL</code> 。
</p>
</dd>
<dt><code>FSETLOCKING_QUERY</code>
<span id="index-FSETLOCKING_005fQUERY"></span>
</dt>
<dd><p><code>__fsetlocking</code>仅查询流的当前锁定状态。返回值将是<code>FSETLOCKING_INTERNAL</code>要么<code>FSETLOCKING_BYCALLER</code>根据状态。
</p></dd>
</dl>

<p>的返回值<code>__fsetlocking</code>或者是<code>FSETLOCKING_INTERNAL</code>要么<code>FSETLOCKING_BYCALLER</code>取决于调用之前流的状态。
</p>
<p>此函数和<var>type</var>参数在<samp>stdio_ext.h</samp> 。
</p></dd></dl>

<p>当必须使用程序代码而又不了解程序代码时，此功能特别有用。 <code>_unlocked</code>函数（或者程序员懒得使用它们）。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Streams-and-I18N.html#Streams-and-I18N" rel="next" accesskey="n">Streams和I18N</a> ，上一篇： <a href="Closing-Streams.html#Closing-Streams" rel="prev" accesskey="p">关闭流</a> ，上一篇： <a href="Streams-and-I18N.html#Streams-and-I18N" rel="next" accesskey="n">Streams</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>