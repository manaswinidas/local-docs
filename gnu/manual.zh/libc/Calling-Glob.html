<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Calling Glob（GNU C库）</title>

<meta name="description" content="Calling Glob (The GNU C Library)">
<meta name="keywords" content="Calling Glob (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Globbing.html#Globbing" rel="up" title="Globbing">
<link href="Flags-for-Globbing.html#Flags-for-Globbing" rel="next" title="Flags for Globbing">
<link href="Globbing.html#Globbing" rel="prev" title="Globbing">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Calling-Glob"></span><div class="header">
<p>下一页： <a href="Flags-for-Globbing.html#Flags-for-Globbing" rel="next" accesskey="n">标志的通配</a> ，最多： <a href="Globbing.html#Globbing" rel="up" accesskey="u">通配符</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Calling-glob"></span><h4 class="subsection">10.2.1呼叫<code>glob</code></h4>

<p>遍历的结果是文件名（字符串）的向量。要返回此向量， <code>glob</code>使用特殊的数据类型<code>glob_t</code> ，这是一个结构。你过关了<code>glob</code>结构的地址，它会填充结构的字段以告知您有关结果的信息。
</p>
<dl>
<dt id="index-glob_005ft">资料类型： <strong>glob_t</strong></dt>
<dd>
<p>此数据类型保存一个指向单词向量的指针。更准确地说，它同时记录了单词向量的地址及其大小。GNU实现包含更多的字段，这些字段是非标准扩展。
</p>
<dl compact>
<dt><code>gl_pathc</code></dt>
<dd><p>向量中的元素数量，如果使用GLOB_DOOFFS标志，则不包括初始空条目（请参见下面的gl_offs）。
</p>
</dd>
<dt><code>gl_pathv</code></dt>
<dd><p>向量的地址。该字段具有类型<code>char **</code> <!-- /@w --> 。
</p>
</dd>
<dt><code>gl_offs</code></dt>
<dd><p>向量的第一个实数元素从其标称地址的偏移量<code>gl_pathv</code>领域。与其他字段不同，这始终是<code>glob</code> ，而不是它的输出。
</p>
<p>如果使用非零偏移量，则向量开始处的许多元素将保留为空。（ <code>glob</code>函数用空指针填充它们。）
</p>
<p>的<code>gl_offs</code>仅当您使用<code>GLOB_DOOFFS</code>旗。否则，无论此字段中的内容为何，偏移量始终为零，并且第一个实数元素位于向量的开头。
</p>
</dd>
<dt><code>gl_closedir</code></dt>
<dd><p>替代实现的地址<code>closedir</code>功能。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>void (*) (void *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_readdir</code></dt>
<dd><p>替代实现的地址<code>readdir</code>用于读取目录内容的函数。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>struct dirent *(*) (void *)</code> <!-- /@w --> 。
</p>
<p>一个实现<code>gl_readdir</code>需要初始化以下成员<code>struct dirent</code>宾语：</p>
<dl compact>
<dt><code>d_type</code></dt>
<dd><p>如果已知该成员，则应将其设置为条目的文件类型。否则，值<code>DT_UNKNOWN</code>可以使用。的<code>glob</code>函数可以使用指定的文件类型来避免在文件类型指示不需要数据的情况下进行回调。
</p>
</dd>
<dt><code>d_ino</code></dt>
<dd><p>该成员必须为非零值，否则<code>glob</code>可能会跳过当前条目并调用<code>gl_readdir</code>再次使用回调函数来检索另一个条目。
</p>
</dd>
<dt><code>d_name</code></dt>
<dd><p>该成员必须设置为条目的名称。它必须为空终止。
</p></dd>
</dl>

<p>以下示例显示了如何分配<code>struct dirent</code>包含给定名称的对象。
</p>
<div class="example">
<pre class="example">

#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct dirent *
mkdirent (const char *name)
{
  size_t dirent_size = offsetof (struct dirent, d_name) + 1;
  size_t name_length = strlen (name);
  size_t total_size = dirent_size + name_length;
  if (total_size &lt; dirent_size)
    {
      errno = ENOMEM;
      return NULL;
    }
  struct dirent *result = malloc (total_size);
  if (result == NULL)
    return NULL;
  result-&gt;d_type = DT_UNKNOWN;
  result-&gt;d_ino = 1;            /* <span class="roman">Do not skip this entry.</span> */
  memcpy (result-&gt;d_name, name, name_length + 1);
  return result;
}
</pre></div>

<p>的<code>glob</code>函数读取<code>struct dirent</code>上面列出的成员，并在<code>d_name</code>成员之后<code>gl_readdir</code>回调函数返回。将来任何回调函数的调用都可以释放或重用缓冲区。这是来电者的责任<code>glob</code>围绕调用分配和取消分配缓冲区的函数<code>glob</code>或使用回调函数。例如，应用程序可以在<code>gl_readdir</code>回调函数，并在<code>gl_closedir</code>回调函数。
</p>
<p>的<code>gl_readdir</code>成员是GNU扩展。
</p>
</dd>
<dt><code>gl_opendir</code></dt>
<dd><p>替代实现的地址<code>opendir</code>功能。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>void *(*) (const char *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_stat</code></dt>
<dd><p>替代实现的地址<code>stat</code>函数获取有关文件系统中对象的信息。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>int (*) (const char *, struct stat *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_lstat</code></dt>
<dd><p>替代实现的地址<code>lstat</code>函数获取有关文件系统中对象的信息，而不是遵循符号链接。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>int (*) (const char *,
<!-- /@w --> struct stat *)
<!-- /@w --></code> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_flags</code></dt>
<dd><p>在以下情况下使用的标志<code>glob</code>被称为。此外， <code>GLOB_MAGCHAR</code>可能会被设置。有关更多详细信息，请参见通配<a href="Flags-for-Globbing.html#Flags-for-Globbing">标记</a> 。
</p>
<p>这是一个GNU扩展。
</p></dd>
</dl>
</dd></dl>

<p>用于<code>glob64</code>功能<samp>glob.h</samp>包含另一个非常相似类型的定义。 <code>glob64_t</code>不同于<code>glob_t</code>仅在成员类型中<code>gl_readdir</code> ， <code>gl_stat</code>和<code>gl_lstat</code> 。
</p>
<dl>
<dt id="index-glob64_005ft">资料类型： <strong>glob64_t</strong></dt>
<dd>
<p>此数据类型保存一个指向单词向量的指针。更准确地说，它同时记录了单词向量的地址及其大小。GNU实现包含更多的字段，这些字段是非标准扩展。
</p>
<dl compact>
<dt><code>gl_pathc</code></dt>
<dd><p>向量中的元素数量，如果使用GLOB_DOOFFS标志，则不包括初始空条目（请参见下面的gl_offs）。
</p>
</dd>
<dt><code>gl_pathv</code></dt>
<dd><p>向量的地址。该字段具有类型<code>char **</code> <!-- /@w --> 。
</p>
</dd>
<dt><code>gl_offs</code></dt>
<dd><p>向量的第一个实数元素从其标称地址的偏移量<code>gl_pathv</code>领域。与其他字段不同，这始终是<code>glob</code> ，而不是它的输出。
</p>
<p>如果使用非零偏移量，则向量开始处的许多元素将保留为空。（ <code>glob</code>函数用空指针填充它们。）
</p>
<p>的<code>gl_offs</code>仅当您使用<code>GLOB_DOOFFS</code>旗。否则，无论此字段中的内容为何，偏移量始终为零，并且第一个实数元素位于向量的开头。
</p>
</dd>
<dt><code>gl_closedir</code></dt>
<dd><p>替代实现的地址<code>closedir</code>功能。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>void (*) (void *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_readdir</code></dt>
<dd><p>替代实现的地址<code>readdir64</code>用于读取目录内容的函数。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>struct dirent64 *(*) (void *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_opendir</code></dt>
<dd><p>替代实现的地址<code>opendir</code>功能。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>void *(*) (const char *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_stat</code></dt>
<dd><p>替代实现的地址<code>stat64</code>函数获取有关文件系统中对象的信息。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>int (*) (const char *, struct stat64 *)</code> <!-- /@w --> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_lstat</code></dt>
<dd><p>替代实现的地址<code>lstat64</code>函数获取有关文件系统中对象的信息，而不是遵循符号链接。如果<code>GLOB_ALTDIRFUNC</code>在flag参数中设置该位。该字段的类型是<code>int (*) (const char *,
<!-- /@w --> struct stat64 *)
<!-- /@w --></code> 。
</p>
<p>这是一个GNU扩展。
</p>
</dd>
<dt><code>gl_flags</code></dt>
<dd><p>在以下情况下使用的标志<code>glob</code>被称为。此外， <code>GLOB_MAGCHAR</code>可能会被设置。有关更多详细信息，请参见通配<a href="Flags-for-Globbing.html#Flags-for-Globbing">标记</a> 。
</p>
<p>这是一个GNU扩展。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-glob">函数： <em>int</em> <strong>glob</strong> <em>（const char * <var>pattern</var> ，int <var>flags</var> ，int（* <var>errfunc</var> ）（const char * <var>filename</var> ，int <var>error-code</var> ），glob_t * <var>vector-ptr</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急环境sig：ALRM计时器语言环境| AS-Unsafe dlopen插件损坏了堆锁AC不安全损坏的锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>glob</code>是否使用模式<var>pattern</var>在当前目录中。它将结果放入新分配的向量中，并将该向量的大小和地址存储到<code>*<var>vector-ptr</var></code> 。争论<var>flags</var>是位标志的组合；有关<a href="Flags-for-Globbing.html#Flags-for-Globbing">标志的</a>详细信息，请参见“通配标志”。
</p>
<p>遍历的结果是一系列文件名。功能<code>glob</code>为每个结果单词分配一个字符串，然后分配一个类型为vector的向量<code>char **</code>存储这些字符串的地址。向量的最后一个元素是空指针。此向量称为<em>单词向量</em> 。
</p>
<p>要返回此向量， <code>glob</code>将其地址及其长度（元素数，不计算终止的空指针）存储到<code>*<var>vector-ptr</var></code> 。
</p>
<p>一般， <code>glob</code>在返回文件名之前，对文件名按字母顺序排序。您可以使用标志将其关闭<code>GLOB_NOSORT</code>如果您想尽快获得信息。通常，让<code>glob</code>对它们进行排序-如果您按字母顺序处理文件，则用户会感觉到应用程序的进度。
</p>
<p>如果<code>glob</code>成功，则返回0。否则，它将返回以下错误代码之一：</p>
<dl compact>
<dt><code>GLOB_ABORTED</code>
<span id="index-GLOB_005fABORTED"></span>
</dt>
<dd>
<p>打开目录时出错，您使用了标志<code>GLOB_ERR</code>或您指定的<var>errfunc</var>返回非零值。对于的解释<code>GLOB_ERR</code>标记和<var>errfunc</var> 。
</p>
</dd>
<dt><code>GLOB_NOMATCH</code>
<span id="index-GLOB_005fNOMATCH"></span>
</dt>
<dd>
<p>该模式与任何现有文件都不匹配。如果您使用<code>GLOB_NOCHECK</code>标志，那么您永远不会得到此错误代码，因为该标志告诉您<code>glob</code> <em>假装</em>该模式至少匹配了一个文件。
</p>
</dd>
<dt><code>GLOB_NOSPACE</code>
<span id="index-GLOB_005fNOSPACE"></span>
</dt>
<dd>
<p>不可能分配内存来保存结果。
</p></dd>
</dl>

<p>如果发生错误， <code>glob</code>将信息存储在<code>*<var>vector-ptr</var></code>到目前为止找到的所有比赛。
</p>
<p>请务必注意， <code>glob</code>如果遇到没有LFS接口无法处理的目录或文件，该函数将不会失败。实施<code>glob</code>应该在内部使用这些功能。这至少是Unix标准所做的假设。GNU扩展，允许用户提供自己的目录处理和<code>stat</code>函数会使事情复杂一些。如果使用这些回调函数并且遇到大文件或目录<code>glob</code> <em>会</em>失败。
</p></dd></dl>

<dl>
<dt id="index-glob64">功能： <em>int</em> <strong>glob64</strong> <em>（const char * <var>pattern</var> ，int <var>flags</var> ，int（* <var>errfunc</var> ）（const char * <var>filename</var> ，int <var>error-code</var> ），glob64_t * <var>vector-ptr</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急环境sig：ALRM计时器语言环境| AS不安全的dlopen损坏的堆锁| AC不安全损坏的锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>glob64</code>该功能是作为大文件峰会扩展的一部分而添加的，但不是原始LFS提议的一部分。这样做的原因很简单：没有必要。一个的必要性<code>glob64</code> GNU扩展添加了功能<code>glob</code>允许用户提供自己的目录处理和<code>stat</code>功能。的<code>readdir</code>和<code>stat</code>功能确实取决于选择<code>_FILE_OFFSET_BITS</code>由于类型的定义<code>struct dirent</code>和<code>struct stat</code>会根据选择而改变。
</p>
<p>除了这种差异， <code>glob64</code>就像<code>glob</code>在各个方面。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<hr>
<div class="header">
<p>下一页： <a href="Flags-for-Globbing.html#Flags-for-Globbing" rel="next" accesskey="n">标志的通配</a> ，最多： <a href="Globbing.html#Globbing" rel="up" accesskey="u">通配符</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>