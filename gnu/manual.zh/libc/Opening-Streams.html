<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>打开流（GNU C库）</title>

<meta name="description" content="Opening Streams (The GNU C Library)">
<meta name="keywords" content="Opening Streams (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" title="I/O on Streams">
<link href="Closing-Streams.html#Closing-Streams" rel="next" title="Closing Streams">
<link href="Standard-Streams.html#Standard-Streams" rel="prev" title="Standard Streams">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Opening-Streams"></span><div class="header">
<p>下一个： <a href="Closing-Streams.html#Closing-Streams" rel="next" accesskey="n">关闭流</a> ，上一个： <a href="Standard-Streams.html#Standard-Streams" rel="prev" accesskey="p">标准流</a> ，上： <a href="Standard-Streams.html#Standard-Streams" rel="prev" accesskey="p">流</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Opening-Streams-1"></span><h3 class="section">12.3打开流</h3>

<span id="index-opening-a-stream"></span>
<p>使用打开文件<code>fopen</code>函数创建一个新的流，并在流和文件之间建立连接。这可能涉及创建一个新文件。
</p>
<span id="index-stdio_002eh-2"></span>
<p>本节中描述的所有内容都在头文件中声明<samp>stdio.h</samp> 。
</p>
<dl>
<dt id="index-fopen">功能： <em>FILE *</em> <strong>fopen</strong> <em>（const char * <var>filename</var> ，const char * <var>opentype</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆锁| AC不安全的内存fd锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>fopen</code>函数为文件的I / O打开流<var>filename</var> ，并返回指向该流的指针。
</p>
<p>的<var>opentype</var>参数是一个字符串，用于控制如何打开文件并指定结果流的属性。它必须以下列字符序列之一开头：</p>
<dl compact>
<dt>' <samp>r</samp> '</dt>
<dd><p>打开一个现有文件，仅供读取。
</p>
</dd>
<dt>' <samp>w</samp> '</dt>
<dd><p>打开该文件仅用于写入。如果文件已存在，则将其截断为零长度。否则，将创建一个新文件。
</p>
</dd>
<dt>' <samp>a</samp> '</dt>
<dd><p>打开文件进行追加访问；也就是说，仅在文件末尾写入。如果文件已经存在，则其初始内容将保持不变，并且流的输出将附加到文件末尾。否则，将创建一个新的空文件。
</p>
</dd>
<dt>' <samp>r+</samp> '</dt>
<dd><p>打开现有文件以进行读取和写入。文件的初始内容保持不变，并且文件的初始位置位于文件的开头。
</p>
</dd>
<dt>' <samp>w+</samp> '</dt>
<dd><p>打开一个文件进行读取和写入。如果文件已存在，则将其截断为零长度。否则，将创建一个新文件。
</p>
</dd>
<dt>' <samp>a+</samp> '</dt>
<dd><p>打开或创建文件以进行读取和追加。如果文件存在，则其初始内容不变。否则，将创建一个新文件。读取的初始文件位置在文件的开头，但输出始终附加在文件的末尾。
</p></dd>
</dl>

<p>如你看到的， ' <samp>+</samp> '请求可以同时进行输入和输出的流。使用此类流时，必须调用<code>fflush</code> （请参阅<a href="Stream-Buffering.html#Stream-Buffering">流缓冲</a> ）或文件定位功能，例如<code>fseek</code> （请参阅<a href="File-Positioning.html#File-Positioning">文件定位</a> ），从阅读切换为书写，反之亦然。否则，内部缓冲区可能无法正确清空。
</p>
<p>这些后面可能会出现其他字符，以指定呼叫标志。一律设为[ <samp>r</samp> '，' <samp>w+</samp> '等）。那是您保证唯一的部分将被所有系统理解。
</p>
<p>GNU C库定义了用于<var>opentype</var> ：</p>
<dl compact>
<dt>' <samp>c</samp> '</dt>
<dd><p>在禁用I / O功能的取消状态下打开文件。
</p>
</dd>
<dt>' <samp>e</samp> '</dt>
<dd><p>如果您使用以下任何一种<code>exec…</code>功能（请参阅<a href="Executing-a-File.html#Executing-a-File">执行文件</a> ）。（这相当于设置了<code>FD_CLOEXEC</code>在那个描述符上。请参阅<a href="Descriptor-Flags.html#Descriptor-Flags">描述符标志</a> 。）
</p>
</dd>
<dt>' <samp>m</samp> '</dt>
<dd><p>该文件打开并使用<code>mmap</code> 。只有打开供读取的文件才支持此功能。
</p>
</dd>
<dt>' <samp>x</samp> '</dt>
<dd><p>坚持创建新文件（如果有文件） <var>filename</var>已经存在， <code>fopen</code>失败而不是打开它。如果您使用“ <samp>x</samp> '确保您不会破坏现有文件。这相当于<code>O_EXCL</code>选项<code>open</code>功能（请参阅<a href="Opening-and-Closing-Files.html#Opening-and-Closing-Files">打开和关闭文件</a> ）。
</p>
<p>' <samp>x</samp> '修饰符是ISO C11 <!-- /@w -->一部分。
</p></dd>
</dl>

<p>性格 ' <samp>b</samp>在<var>opentype</var>具有标准含义；它请求二进制流而不是文本流。但这在POSIX系统（包括GNU系统）中没有区别。如果两个都<samp>+</samp> '和' <samp>b</samp>指定为'，它们可以按任意顺序出现。请参阅<a href="Binary-Streams.html#Binary-Streams">二进制流</a> 。
</p>
<span id="index-stream-orientation"></span>
<span id="index-orientation_002c-stream"></span>
<p>如果<var>opentype</var>字符串包含序列<code>,ccs=<var>STRING</var></code>然后<var>STRING</var>被用作编码字符集的名称，并且<code>fopen</code>将使用适当的转换功能将流标记为面向广泛的流，以在字符集之间进行转换<var>STRING</var> 。最初以未定向的方式打开任何其他流，并通过第一个文件操作确定定向。如果第一个操作是宽字符操作，则不仅将流标记为面向宽字符，还将加载要转换为用于当前语言环境的编码字符集的转换函数。从那时起，即使选择了<code>LC_CTYPE</code>类别已更改。
</p>
<p>中的其他任何字符<var>opentype</var>只是被忽略。它们在其他系统中可能是有意义的。
</p>
<p>如果打开失败<code>fopen</code>返回一个空指针。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能实际上是<code>fopen64</code>因为LFS接口透明地替换了旧接口。
</p></dd></dl>

<p>您可以具有多个流（或文件描述符），这些流同时指向同一文件。如果仅输入，则可直接使用，但是如果包含任何输出流，则必须小心。请参阅<a href="Stream_002fDescriptor-Precautions.html#Stream_002fDescriptor-Precautions">流/描述符注意事项</a> 。无论流是在一个程序中（不常见）还是在多个程序中（这很容易发生），都同样如此。使用文件锁定功能来避免同时访问可能是有利的。请参阅<a href="File-Locks.html#File-Locks">文件锁</a> 。
</p>
<dl>
<dt id="index-fopen64">功能： <em>FILE *</em> <strong>fopen64</strong> <em>（const char * <var>filename</var> ，const char * <var>opentype</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆锁| AC不安全的内存fd锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>fopen</code>但是它返回一个指针的流使用<code>open64</code> 。因此，即使在32位计算机上大于2 ^ 31字节的文件中也可以使用此流。
</p>
<p>请注意，返回类型仍为<code>FILE *</code> 。没有特别的<code>FILE</code> LFS接口的类型。
</p>
<p>如果源使用<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能在名称下可用<code>fopen</code>因此透明地替换了旧界面。
</p></dd></dl>

<dl>
<dt id="index-FOPEN_005fMAX">巨集： <em>int</em> <strong>FOPEN_MAX</strong></dt>
<dd>
<p>该宏的值是一个整数常量表达式，表示实现保证可以同时打开的最小流数。您可能可以打开的流数量不止这些，但是不能保证。该常数的值至少为8，其中包括三个标准流<code>stdin</code> ， <code>stdout</code>和<code>stderr</code> 。在POSIX.1系统中，此值由<code>OPEN_MAX</code>参数;请参阅<a href="General-Limits.html#General-Limits">一般限制</a> 。在BSD和GNU中，它由<code>RLIMIT_NOFILE</code>资源限制；请参阅<a href="Limits-on-Resources.html#Limits-on-Resources">资源限制</a> 。
</p></dd></dl>

<dl>
<dt id="index-freopen">功能： <em>FILE *</em> <strong>freopen</strong> <em>（const char * <var>filename</var> ，const char * <var>opentype</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全损坏的fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能就像是<code>fclose</code>和<code>fopen</code> 。首先关闭由引用的流<var>stream</var> ，而忽略该过程中检测到的任何错误。（由于忽略了错误，因此不应使用<code>freopen</code>在输出流上（如果您实际上已经使用该流完成了任何输出）。）然后将文件命名为<var>filename</var>用模式打开<var>opentype</var>至于<code>fopen</code> ，并与同一个流对象关联<var>stream</var> 。
</p>
<p>如果操作失败，则返回空指针。除此以外， <code>freopen</code>退货<var>stream</var> 。在Linux上， <code>freopen</code>可能也会失败并设置<code>errno</code>至<code>EBUSY</code>当旧文件描述符的内核结构未在之前完全初始化时<code>freopen</code>被称为。只有在两个线程竞相分配相同的文件描述符编号时，这才可能在多线程程序中发生。为避免这场比赛的可能性，请勿使用<code>close</code>关闭基础文件描述符<code>FILE</code> ;要么使用<code>freopen</code>在文件仍然打开或使用时<code>open</code>然后<code>dup2</code>安装新的文件描述符。
</p>
<p><code>freopen</code>传统上已用于连接标准流，例如<code>stdin</code>与您自己选择的文件。这在对出于某些目的而使用标准流进行硬编码的程序中很有用。在GNU C库中，您只需关闭标准流并使用以下命令打开新的流<code>fopen</code> 。但是其他系统缺乏此功能，因此使用<code>freopen</code>更便携。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能实际上是<code>freopen64</code>因为LFS接口透明地替换了旧接口。
</p></dd></dl>

<dl>
<dt id="index-freopen64">功能： <em>FILE *</em> <strong>freopen64</strong> <em>（const char * <var>filename</var> ，const char * <var>opentype</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全损坏的fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>freopen</code> 。唯一的区别是，在32位计算机上，返回的流能够读取超出普通接口施加的2 ^ 31字节限制。应当指出的是， <var>stream</var>不需要使用打开<code>fopen64</code>要么<code>freopen64</code>因为它的模式对于此功能并不重要。
</p>
<p>如果源使用<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能在名称下可用<code>freopen</code>因此透明地替换了旧界面。
</p></dd></dl>

<p>在某些情况下，了解给定的流是否可用于读取或写入非常有用。该信息通常不可用，必须单独记住。Solaris引入了一些函数来从流描述符中获取此信息，并且GNU C库中也提供了这些函数。
</p>
<dl>
<dt id="index-_005f_005ffreadable">函数： <em>int</em> <strong>__fread</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>__freadable</code>函数确定流是否<var>stream</var>被打开以允许阅读。在这种情况下，返回值为非零。对于只写流，该函数返回零。
</p>
<p>该函数在<samp>stdio_ext.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-_005f_005ffwritable">函数： <em>int</em> <strong>__fwritable</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>__fwritable</code>函数确定流是否<var>stream</var>打开以允许写作。在这种情况下，返回值为非零。对于只读流，该函数返回零。
</p>
<p>该函数在<samp>stdio_ext.h</samp> 。
</p></dd></dl>

<p>对于稍有不同的问题，还有两个功能。它们提供了更细粒度的信息。
</p>
<dl>
<dt id="index-_005f_005ffreading">函数： <em>int</em> <strong>__freading</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>__freading</code>函数确定流是否<var>stream</var>上次读取的日期或是否以只读方式打开。在这种情况下，返回值为非零，否则为零。确定开放用于读写的流是否最后一次用于写入，可以得出有关缓冲区内容的结论。
</p>
<p>该函数在<samp>stdio_ext.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-_005f_005ffwriting">功能： <em>int</em> <strong>__fwriting</strong> <em>（FILE * <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>__fwriting</code>函数确定流是否<var>stream</var>上次写入或是否以只读方式打开。在这种情况下，返回值为非零，否则为零。
</p>
<p>该函数在<samp>stdio_ext.h</samp> 。
</p></dd></dl>


<hr>
<div class="header">
<p>下一个： <a href="Closing-Streams.html#Closing-Streams" rel="next" accesskey="n">关闭流</a> ，上一个： <a href="Standard-Streams.html#Standard-Streams" rel="prev" accesskey="p">标准流</a> ，上： <a href="Standard-Streams.html#Standard-Streams" rel="prev" accesskey="p">流</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>