<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>字符串/数组比较（GNU C库）</title>

<meta name="description" content="String/Array Comparison (The GNU C Library)">
<meta name="keywords" content="String/Array Comparison (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Collation-Functions.html#Collation-Functions" rel="next" title="Collation Functions">
<link href="Truncating-Strings.html#Truncating-Strings" rel="prev" title="Truncating Strings">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="String_002fArray-Comparison"></span><div class="header">
<p>下一页： <a href="Collation-Functions.html#Collation-Functions" rel="next" accesskey="n">整理函数</a> ，上一篇： <a href="Truncating-Strings.html#Truncating-Strings" rel="prev" accesskey="p">截断字符串</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="String_002fArray-Comparison-1"></span><h3 class="section">5.7字符串/数组比较</h3>
<span id="index-comparing-strings-and-arrays"></span>
<span id="index-string-comparison-functions"></span>
<span id="index-array-comparison-functions"></span>
<span id="index-predicates-on-strings"></span>
<span id="index-predicates-on-arrays"></span>

<p>您可以使用本节中的函数对字符串和数组的内容进行比较。除了检查是否相等之外，这些功能还可以用作排序操作的排序功能。有关此示例，请参见“ <a href="Searching-and-Sorting.html#Searching-and-Sorting">搜索和排序”</a> 。
</p>
<p>与C中的大多数比较操作不同，字符串比较函数如果字符串<em>不</em>相等而<em>不是</em>相等，则返回非零值。值的符号表示不相等的字符串的第一部分的相对顺序：负值表示第一个字符串“小于”第二个字符串，而正值表示第一个字符串“大于” 。
</p>
<p>这些功能最常见的用途是仅检查是否相等。可以使用“ <samp>! strcmp (s1, s2)</samp> ' <!-- /@w --> 。
</p>
<p>所有这些功能都在头文件中声明<samp>string.h</samp> 。
<span id="index-string_002eh-3"></span>
</p>
<dl>
<dt id="index-memcmp">功能： <em>int</em> <strong>memcmp</strong> <em>（const void * <var>a1</var> ，const void * <var>a2</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>memcmp</code>比较<var>size</var>始于的内存字节<var>a1</var>反对这<var>size</var>始于的内存字节<var>a2</var> 。返回的值与第一个不同的字节对之间的差异具有相同的符号（解释为<code>unsigned char</code>对象，然后提升为<code>int</code> ）。
</p>
<p>如果两个块的内容相等， <code>memcmp</code>退货<code>0</code> 。
</p></dd></dl>

<dl>
<dt id="index-wmemcmp">函数： <em>int</em> <strong>wmemcmp</strong> <em>（const wchar_t * <var>a1</var> ，const wchar_t * <var>a2</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>wmemcmp</code>比较<var>size</var>宽字符开始于<var>a1</var>反对这<var>size</var>宽字符开始于<var>a2</var> 。返回的值是小于还是大于零，具体取决于第一个不同的宽字符是否为<var>a1</var>小于或大于中对应的宽字符<var>a2</var> 。
</p>
<p>如果两个块的内容相等， <code>wmemcmp</code>退货<code>0</code> 。
</p></dd></dl>

<p>在任意数组上， <code>memcmp</code>函数对于测试相等性最有用。对字节以外的其他事物进行按字节顺序的比较通常是没有意义的。例如，对组成浮点数的字节进行逐字节比较可能不会告诉您有关浮点数值之间的关系的任何信息。
</p>
<p><code>wmemcmp</code>实际上仅对比较类型的数组有用<code>wchar_t</code>因为该功能着眼于<code>sizeof (wchar_t)</code>一次一次的字节数，此字节数取决于系统。
</p>
<p>您还应该注意使用<code>memcmp</code>比较可能包含“空洞”的对象，例如，插入结构对象中以强制执行对齐要求的填充，并集末尾的额外空间以及长度小于其分配大小的字符串末尾的额外字节。这些“漏洞”的内容不确定，在执行字节比较时可能会导致奇怪的行为。为了获得更可预测的结果，请执行显式的逐项比较。
</p>
<p>例如，给定的结构类型定义如下：</p>
<div class="example">
<pre class="example">struct foo
  {
    unsigned char tag;
    union
      {
        double f;
        long i;
        char *p;
      } value;
  };
</pre></div>

<p>您最好编写一个专门的比较功能来进行比较<code>struct foo</code>对象，而不是将它们与<code>memcmp</code> 。
</p>
<dl>
<dt id="index-strcmp">函数： <em>int</em> <strong>strcmp</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strcmp</code>函数比较字符串<var>s1</var>反对<var>s2</var> ，返回的值与第一个不同的字节对之间的区别具有相同的符号（解释为<code>unsigned char</code>对象，然后提升为<code>int</code> ）。
</p>
<p>如果两个字符串相等， <code>strcmp</code>退货<code>0</code> 。
</p>
<p>排序所使用的结果<code>strcmp</code>是如果<var>s1</var>是的初始子串<var>s2</var> ， 然后<var>s1</var>被认为是“小于” <var>s2</var> 。
</p>
<p><code>strcmp</code>不考虑将字符串写入的语言的排序约定。要获得那个必须使用<code>strcoll</code> 。
</p></dd></dl>

<dl>
<dt id="index-wcscmp">函数： <em>int</em> <strong>wcscmp</strong> <em>（const wchar_t * <var>ws1</var> ，const wchar_t * <var>ws2</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>wcscmp</code>函数比较宽字符串<var>ws1</var>反对<var>ws2</var> 。返回的值是小于还是大于零，具体取决于第一个不同的宽字符是否为<var>ws1</var>小于或大于中对应的宽字符<var>ws2</var> 。
</p>
<p>如果两个字符串相等， <code>wcscmp</code>退货<code>0</code> 。
</p>
<p>排序所使用的结果<code>wcscmp</code>是如果<var>ws1</var>是的初始子串<var>ws2</var> ， 然后<var>ws1</var>被认为是“小于” <var>ws2</var> 。
</p>
<p><code>wcscmp</code>不考虑将字符串写入的语言的排序约定。要获得那个必须使用<code>wcscoll</code> 。
</p></dd></dl>

<dl>
<dt id="index-strcasecmp">函数： <em>int</em> <strong>strcasecmp</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>strcmp</code> ，除了大小写差异会被忽略，并且其参数必须是多字节字符串。大写和小写字符之间的关系由当前选择的语言环境决定。在标准<code>"C"</code>在语言环境中，字符Ä和ä不匹配，但是在将这些字符视为它们匹配的字母的一部分的语言环境中。
</p>
<p><code>strcasecmp</code>源自BSD。</p></dd></dl>

<dl>
<dt id="index-wcscasecmp">函数： <em>int</em> <strong>wcscasecmp</strong> <em>（const wchar_t * <var>ws1</var> ，const wchar_t * <var>ws2</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>wcscmp</code> ，但大小写差异会被忽略。大写和小写字符之间的关系由当前选择的语言环境决定。在标准<code>"C"</code>在语言环境中，字符Ä和ä不匹配，但是在将这些字符视为它们匹配的字母的一部分的语言环境中。
</p>
<p><code>wcscasecmp</code>是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-strncmp">函数： <em>int</em> <strong>strncmp</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>strcmp</code> ，但不超过<var>size</var>比较字节。换句话说，如果两个字符串的第一个相同<var>size</var>个字节，返回值为零。
</p></dd></dl>

<dl>
<dt id="index-wcsncmp">函数： <em>int</em> <strong>wcsncmp</strong> <em>（const wchar_t * <var>ws1</var> ，const wchar_t * <var>ws2</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>wcscmp</code> ，但不超过<var>size</var>比较宽字符。换句话说，如果两个字符串的第一个相同<var>size</var>宽字符，返回值为零。
</p></dd></dl>

<dl>
<dt id="index-strncasecmp">函数： <em>int</em> <strong>strncasecmp</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ，size_t <var>n</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>strncmp</code> ，只是忽略大小写差异，并且参数的比较部分应由有效的多字节字符组成。喜欢<code>strcasecmp</code> ，取决于语言环境，大小写字符之间的关系。
</p>
<p><code>strncasecmp</code>是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-wcsncasecmp">函数： <em>int</em> <strong>wcsncasecmp</strong> <em>（const wchar_t * <var>ws1</var> ，const wchar_t * <var>s2</var> ，size_t <var>n</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>wcsncmp</code> ，但大小写差异会被忽略。喜欢<code>wcscasecmp</code> ，取决于语言环境，大小写字符之间的关系。
</p>
<p><code>wcsncasecmp</code>是GNU扩展。
</p></dd></dl>

<p>以下是一些示例，显示了<code>strcmp</code>和<code>strncmp</code> （可以为宽字符功能构造等效的示例）。这些示例假定使用ASCII字符集。（如果改用其他字符集（例如EBCDIC），则字形与不同的数字代码关联，并且返回值和顺序可能不同。）
</p>
<div class="example">
<pre class="example">strcmp (&quot;hello&quot;, &quot;hello&quot;)
    &rArr; 0    /* <span class="roman">These two strings are the same.</span> */
strcmp (&quot;hello&quot;, &quot;Hello&quot;)
    &rArr; 32   /* <span class="roman">Comparisons are case-sensitive.</span> */
strcmp (&quot;hello&quot;, &quot;world&quot;)
    &rArr; -15  /* <span class="roman">The byte <code>'h'</code> comes before <code>'w'</code>.</span> */
strcmp (&quot;hello&quot;, &quot;hello, world&quot;)
    &rArr; -44  /* <span class="roman">Comparing a null byte against a comma.</span> */
strncmp (&quot;hello&quot;, &quot;hello, world&quot;, 5)
    &rArr; 0    /* <span class="roman">The initial 5 bytes are the same.</span> */
strncmp (&quot;hello, world&quot;, &quot;hello, stupid world!!!&quot;, 5)
    &rArr; 0    /* <span class="roman">The initial 5 bytes are the same.</span> */
</pre></div>

<dl>
<dt id="index-strverscmp">函数： <em>int</em> <strong>strverscmp</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strverscmp</code>函数比较字符串<var>s1</var>反对<var>s2</var> ，将其视为保存索引/版本号。返回值遵循与<code>strcmp</code>功能。实际上，如果<var>s1</var>和<var>s2</var>不包含数字， <code>strverscmp</code>表现像<code>strcmp</code> （从某种意义上说，结果的符号相同）。
</p>
<p>比较算法<code>strverscmp</code>函数实现与其他版本比较算法略有不同。该实现基于有限状态机，其行为近似如下。
</p>
<ul>
<li>输入字符串分别分为非数字和数字的序列。这些序列在字符串的开头和结尾可以为空。数字由<code>isdigit</code>功能，因此受当前语言环境的约束。

</li><li>比较从（可能为空）非数字序列开始。非数字或数字的第一个非相等序列确定比较的结果。

</li><li>如果两个字符串中对应的非数字序列的长度相等，则按字典顺序进行比较。如果长度不同，则较短的非数字序列将紧随其后的输入字符串字符（可能是空终止符）进行扩展，另一个序列被截断为相同（扩展）长度，并且这两个序列分别为从字典上比较。在最后一种情况下，序列比较确定函数的结果，因为扩展字符（或扩展字符之前的某个字符）必须不同于其他输入字符串中相同偏移量的字符。

</li><li>对于两个数字序列，计数前导零的数目（可以为零）。如果计数不同，则认为数字序列中前导零更多的字符串比其他字符串小。

</li><li>如果两个数字序列没有前导零，则将它们作为整数进行比较，即，具有较长数字序列的字符串被视为较大，并且如果两个序列的长度相等，则按字典顺序进行比较。

</li><li>如果两个数字序列均以零开头且前导零的数目相等，则如果它们的长度相同，则按字典顺序进行比较。如果长度不同，则较短的序列将在其输入字符串中扩展为下一个字符，而另一个序列将被截短为相同的长度，并且按字典顺序比较两个序列（类似于上述非数字序列的情况）。
</li></ul>

<p>前导零和打破平局的扩展字符（实际上跨非数字/数字序列边界传播）的处理方式与其他版本比较算法不同。
</p>
<div class="example">
<pre class="example">strverscmp (&quot;no digit&quot;, &quot;no digit&quot;)
    &rArr; 0    /* <span class="roman">same behavior as strcmp.</span> */
strverscmp (&quot;item#99&quot;, &quot;item#100&quot;)
    &rArr; &lt;0   /* <span class="roman">same prefix, but 99 &lt; 100.</span> */
strverscmp (&quot;alpha1&quot;, &quot;alpha001&quot;)
    &rArr; &gt;0   /* <span class="roman">different number of leading zeros (0 and 2).</span> */
strverscmp (&quot;part1_f012&quot;, &quot;part1_f01&quot;)
    &rArr; &gt;0   /* <span class="roman">lexicographical comparison with leading zeros.</span> */
strverscmp (&quot;foo.009&quot;, &quot;foo.0&quot;)
    &rArr; &lt;0   /* <span class="roman">different number of leading zeros (2 and 1).</span> */
</pre></div>

<p><code>strverscmp</code>是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-bcmp">功能： <em>int</em> <strong>bcmp</strong> <em>（const void * <var>a1</var> ，const void * <var>a2</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这是一个过时的别名<code>memcmp</code> ，源自BSD。</p></dd></dl>

<hr>
<div class="header">
<p>下一页： <a href="Collation-Functions.html#Collation-Functions" rel="next" accesskey="n">整理函数</a> ，上一篇： <a href="Truncating-Strings.html#Truncating-Strings" rel="prev" accesskey="p">截断字符串</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>