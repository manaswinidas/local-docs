<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>记住信号（GNU C库）</title>

<meta name="description" content="Remembering a Signal (The GNU C Library)">
<meta name="keywords" content="Remembering a Signal (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Blocking-Signals.html#Blocking-Signals" rel="up" title="Blocking Signals">
<link href="Waiting-for-a-Signal.html#Waiting-for-a-Signal" rel="next" title="Waiting for a Signal">
<link href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="prev" title="Checking for Pending Signals">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Remembering-a-Signal"></span><div class="header">
<p>上一页： <a href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="prev" accesskey="p">检查待处理信号</a> ，向上： <a href="Blocking-Signals.html#Blocking-Signals" rel="up" accesskey="u">阻止信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Remembering-a-Signal-to-Act-On-Later"></span><h4 class="subsection">24.7.7记住以后要采取行动的信号</h4>

<p>您可以通过使处理程序设置一个标记以供以后在“取消阻止”时进行测试，来获得几乎相同的结果，而无需使用库工具来阻止信号。这是一个例子：</p>
<div class="example">
<pre class="example">/* <span class="roman">If this flag is nonzero, don&rsquo;t handle the signal right away.</span> */
volatile sig_atomic_t signal_pending;

/* <span class="roman">This is nonzero if a signal arrived and was not handled.</span> */
volatile sig_atomic_t defer_signal;

void
handler (int signum)
{
  if (defer_signal)
    signal_pending = signum;
  else
    &hellip; /* <span class="roman">&ldquo;Really&rdquo; handle the signal.</span> */
}

&hellip;

void
update_mumble (int frob)
{
  /* <span class="roman">Prevent signals from having immediate effect.</span> */
  defer_signal++;
  /* <span class="roman">Now update <code>mumble</code>, without worrying about interruption.</span> */
  mumble.a = 1;
  mumble.b = hack ();
  mumble.c = frob;
  /* <span class="roman">We have updated <code>mumble</code>.  Handle any signal that came in.</span> */
  defer_signal--;
  if (defer_signal == 0 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
}
</pre></div>

<p>注意到达的特定信号如何存储在<code>signal_pending</code> 。这样，我们可以使用相同的机制处理多种类型的不便信号。
</p>
<p>我们增加和减少<code>defer_signal</code>这样嵌套的关键部分才能正常工作；因此，如果<code>update_mumble</code>被称为<code>signal_pending</code>已经非零，信号将不仅在<code>update_mumble</code> ，而且在调用方内部。这也是为什么我们不检查<code>signal_pending</code>如果<code>defer_signal</code>仍非零。
</p>
<p>的递增和递减<code>defer_signal</code>每个都需要一个以上的指令；信号可能在中间发生。但这不会造成任何问题。如果信号发生得足够早，以至于无法看到增量或减量之前的值，则这等同于增量或减量开始之前的信号，这种情况可以正常工作。
</p>
<p>减量绝对至关重要<code>defer_signal</code>测试之前<code>signal_pending</code> ，因为这样可以避免出现细微的错误。如果我们按其他顺序执行这些操作，</p>
<div class="example">
<pre class="example">  if (defer_signal == 1 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
  defer_signal--;
</pre></div>

<p>然后一个信号到达<code>if</code>陈述和减量将在不确定的时间内有效地“丢失”。处理程序只会设置<code>defer_signal</code> ，但是程序已经测试了该变量，则不会再次测试该变量。
</p>
<span id="index-timing-error-in-signal-handling"></span>
<p>这样的<em>错误</em>称为<em>计时错误</em> 。它们之所以特别糟糕，是因为它们很少发生并且几乎不可能复制。您不可能期望通过调试器找到它们，因为会发现可重现的错误。因此，值得特别注意避免它们。
</p>
<p>（鉴于使用了以下代码，您不会尝试以此顺序编写代码<code>defer_signal</code>作为必须与之一起测试的计数器<code>signal_pending</code> 。毕竟，测试零比测试一更干净。但是如果你不使用<code>defer_signal</code>作为一个计数器，并为其赋值为零且只有一个，那么这两个顺序似乎同样简单。将计数器用于<code>defer_signal</code> ：这将减少您以错误的顺序编写代码并创建细微错误的机会。）
</p>
<hr>
<div class="header">
<p>上一页： <a href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="prev" accesskey="p">检查待处理信号</a> ，向上： <a href="Blocking-Signals.html#Blocking-Signals" rel="up" accesskey="u">阻止信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>