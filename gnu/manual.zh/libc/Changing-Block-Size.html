<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>更改块大小（GNU C库）</title>

<meta name="description" content="Changing Block Size (The GNU C Library)">
<meta name="keywords" content="Changing Block Size (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" title="Unconstrained Allocation">
<link href="Allocating-Cleared-Space.html#Allocating-Cleared-Space" rel="next" title="Allocating Cleared Space">
<link href="Freeing-after-Malloc.html#Freeing-after-Malloc" rel="prev" title="Freeing after Malloc">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Changing-Block-Size"></span><div class="header">
<p>下一个： <a href="Allocating-Cleared-Space.html#Allocating-Cleared-Space" rel="next" accesskey="n">分配清除空间</a> ，上一个： <a href="Freeing-after-Malloc.html#Freeing-after-Malloc" rel="prev" accesskey="p">在Malloc之后释放</a> ，向上： <a href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" accesskey="u">不受限制的分配</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Changing-the-Size-of-a-Block"></span><h4 class="subsubsection">3.2.3.4更改块的大小</h4>
<span id="index-changing-the-size-of-a-block-_0028malloc_0029"></span>

<p>通常，您不确定在必须开始使用该块时最终需要多少块。例如，该块可能是一个缓冲区，用于保存从文件中读取的行；不管您最初创建缓冲区多长时间，都可能会遇到更长的行。
</p>
<p>您可以通过致电延长屏蔽时间<code>realloc</code>要么<code>reallocarray</code> 。这些函数在中声明<samp>stdlib.h</samp> 。
<span id="index-stdlib_002eh-2"></span>
</p>
<dl>
<dt id="index-realloc">功能： <em>void *</em> <strong>realloc</strong> <em>（void * <var>ptr</var> ，size_t <var>newsize</var> ）</em></dt>
<dd>

<p>初步： MT安全| AS不安全锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>



<p>的<code>realloc</code>函数更改其地址为的块的大小<var>ptr</var>成为<var>newsize</var> 。
</p>
<p>由于可能要使用块末尾的空格， <code>realloc</code>可能会发现有必要将块复制到具有更多可用空间的新地址。的价值<code>realloc</code>是该块的新地址。如果需要移动方块， <code>realloc</code>复制旧内容。
</p>
<p>如果您传递一个空指针<var>ptr</var> ， <code>realloc</code>表现就像<samp>malloc (<var>newsize</var>)</samp> '。这可能很方便，但是请注意，较旧的实现（在ISO C <!-- /@w -->之前）可能不支持此行为，并且可能在崩溃时崩溃<code>realloc</code>传递了一个空指针。
</p></dd></dl>

<dl>
<dt id="index-reallocarray">函数： <em>void *</em> <strong>reallocarray</strong> <em>（void * <var>ptr</var> ，size_t <var>nmemb</var> ，size_t <var>size</var> ）</em></dt>
<dd>

<p>初步： MT安全| AS不安全锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>reallocarray</code>函数更改其地址为的块的大小<var>ptr</var>足够长以包含一个向量<var>nmemb</var>元素，每个大小<var>size</var> 。等同于“ <samp>realloc (<var>ptr</var>, <var>nmemb</var> * <var>size</var>)</samp> '， 除了那个<code>reallocarray</code>如果乘法溢出，则通过设置安全地失败<code>errno</code>至<code>ENOMEM</code> ，返回空指针，并保持原始块不变。
</p>
<p><code>reallocarray</code>应该代替<code>realloc</code>当分配的块的新大小是可能会溢出的乘法结果时。
</p>
<p><strong>可移植性注意：</strong>此功能不是任何标准的一部分。它是在OpenBSD 5.6中首次引入的。
</p></dd></dl>

<p>喜欢<code>malloc</code> ， <code>realloc</code>和<code>reallocarray</code>如果没有可用的内存空间来增大该块，则可能返回空指针。发生这种情况时，原始块将保持不变。它尚未被修改或重新定位。
</p>
<p>在大多数情况下，当<code>realloc</code>失败，因为应用程序在内存不足时无法继续，并且唯一要做的就是给出致命错误消息。通常，编写和使用子例程通常很方便， <code>xrealloc</code> ，将错误消息视为<code>xmalloc</code>为<code>malloc</code> ：</p>
<div class="example">
<pre class="example">void *
xrealloc (void *ptr, size_t size)
{
  void *value = realloc (ptr, size);
  if (value == 0)
    fatal (&quot;Virtual memory exhausted&quot;);
  return value;
}
</pre></div>

<p>您也可以使用<code>realloc</code>要么<code>reallocarray</code>使块更小。您这样做的原因是为了避免在只需要少量内存的情况下占用大量内存空间。在几种分配实现中，减小块有时需要复制它，因此，如果没有其他可用空间，它可能会失败。
</p>
<p>如果您指定的新尺寸与旧尺寸相同， <code>realloc</code>和<code>reallocarray</code>保证不做任何更改并返回您提供的相同地址。
</p>
<hr>
<div class="header">
<p>下一个： <a href="Allocating-Cleared-Space.html#Allocating-Cleared-Space" rel="next" accesskey="n">分配清除空间</a> ，上一个： <a href="Freeing-after-Malloc.html#Freeing-after-Malloc" rel="prev" accesskey="p">在Malloc之后释放</a> ，向上： <a href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" accesskey="u">不受限制的分配</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>