<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>删除敏感数据（GNU C库）</title>

<meta name="description" content="Erasing Sensitive Data (The GNU C Library)">
<meta name="keywords" content="Erasing Sensitive Data (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Shuffling-Bytes.html#Shuffling-Bytes" rel="next" title="Shuffling Bytes">
<link href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="prev" title="Finding Tokens in a String">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Erasing-Sensitive-Data"></span><div class="header">
<p>下一篇： <a href="Shuffling-Bytes.html#Shuffling-Bytes" rel="next" accesskey="n">改组字节</a> ，上一篇： <a href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="prev" accesskey="p">在字符串中查找令牌，上一篇</a> ： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Erasing-Sensitive-Data-1"></span><h3 class="section">5.11删除敏感数据</h3>

<p>使用后，应从内存中删除诸如密钥之类的敏感数据，以减少错误将其暴露给外界的风险。但是，编译器优化可能会确定擦除操作是“不必要的”，并将其从生成的代码中删除，因为在释放敏感数据之后，没有<em>正确的</em>程序可以访问包含敏感数据的变量或堆对象。由于擦除是防止错误的预防措施，因此此优化是不合适的。
</p>
<p>功能<code>explicit_bzero</code>擦除内存块，并保证编译器不会将擦除操作删除为“不必要的”。
</p>
<div class="example">
<pre class="example">#include &lt;string.h&gt;

extern void encrypt (const char *key, const char *in,
                     char *out, size_t n);
extern void genkey (const char *phrase, char *key);

void encrypt_with_phrase (const char *phrase, const char *in,
                          char *out, size_t n)
{
  char key[16];
  genkey (phrase, key);
  encrypt (key, in, out, n);
  explicit_bzero (key, 16);
}
</pre></div>

<p>在这个例子中，如果<code>memset</code> ， <code>bzero</code> ，或者使用了手写循环，则编译器可能会将它们删除为“不必要的”。
</p>
<p><strong>警告：</strong> <code>explicit_bzero</code>不保证从计算机内存中<em>完全</em>删除敏感数据。临时存储区中可能有副本，例如寄存器和“临时”堆栈空间。由于这些对源代码不可见，因此库函数无法擦除它们。
</p>
<p>也， <code>explicit_bzero</code>仅在RAM上运行。如果一个敏感的数据对象只需要调用就无需获取其地址<code>explicit_bzero</code> ，它可能会完全存储在CPU寄存器中， <em>直到</em>调用<code>explicit_bzero</code> 。然后将其复制到RAM中，副本将被删除，并且原件将保持原样。与寄存器中的数据相比，RAM中的数据更容易被错误暴露，因此，这会创建一个简短的窗口，与程序完全不尝试擦除数据相比，数据暴露的风险更大。
</p>
<p>将敏感变量声明为<code>volatile</code>将使上述两个问题<em>变得更糟</em> ;一种<code>volatile</code>变量将在整个生命周期内存储在内存中，并且编译器将为其复制<em>更多</em>副本。试图通过手动“擦除”普通变量<code>volatile</code>限定的指针根本不起作用-因为变量本身不起作用<code>volatile</code> ，某些编译器将忽略指针的限定条件，并始终删除擦除。
</p>
<p>说了这么多，在大多数情况下，使用<code>explicit_bzero</code>总比不使用它好。当前，要做更彻底的工作的唯一方法是用汇编语言编写整个敏感操作。我们期望未来的编译器会识别对<code>explicit_bzero</code>并采取适当的步骤删除受影响数据的所有副本，无论它们位于何处。
</p>
<dl>
<dt id="index-explicit_005fbzero">函数<em>：void</em> <em><strong>explicit_bzero（</strong>无效* <var>block</var> ，size_t <var>len</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>explicit_bzero</code>将零写入<var>len</var>始于的内存字节<var>block</var> ， 就像<code>bzero</code>将。即使编译器可以确定零是“不必要的”，也总是写入零，因为没有正确的程序可以将它们读回。
</p>
<p><strong>注意：</strong> <em>唯一的</em>优化是<code>explicit_bzero</code> disables是删除对内存的“不必要的”写入。编译器可以执行调用它可能执行的所有其他优化。 <code>memset</code> 。例如，它可以用内联内存写替换函数调用，并且可以假定<var>block</var>不能为空指针。
</p>
<p><strong>可移植性注意：</strong>此功能最早出现在OpenBSD 5.5中，尚未标准化。其他系统可能以不同的名称提供相同的功能，例如<code>explicit_memset</code> ， <code>memset_s</code> ， 要么<code>SecureZeroMemory</code> 。
</p>
<p>GNU C库在中声明了此函数<samp>string.h</samp> ，但在其他系统上<samp>strings.h</samp>代替。
</p></dd></dl>


<hr>
<div class="header">
<p>下一篇： <a href="Shuffling-Bytes.html#Shuffling-Bytes" rel="next" accesskey="n">改组字节</a> ，上一篇： <a href="Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String" rel="prev" accesskey="p">在字符串中查找令牌，上一篇</a> ： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>