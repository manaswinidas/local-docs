<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Argp特殊键（GNU C库）</title>

<meta name="description" content="Argp Special Keys (The GNU C Library)">
<meta name="keywords" content="Argp Special Keys (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="up" title="Argp Parser Functions">
<link href="Argp-Parsing-State.html#Argp-Parsing-State" rel="next" title="Argp Parsing State">
<link href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="prev" title="Argp Parser Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Argp-Special-Keys"></span><div class="header">
<p>下一篇： <a href="Argp-Parsing-State.html#Argp-Parsing-State" rel="next" accesskey="n">Argp解析状态</a> ，上<a href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="up" accesskey="u">一篇</a> ： <a href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="up" accesskey="u">Argp解析器功能</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Special-Keys-for-Argp-Parser-Functions"></span><h4 class="subsubsection">25.3.5.1 Argp解析器功能的特殊键</h4>

<p>除了与用户选项相对应的键值外， <var>key</var> argp解析器函数的参数可能具有许多其他特殊值。在下面的例子中<var>arg</var>和<var>state</var>请参阅解析器函数参数。请参阅<a href="Argp-Parser-Functions.html#Argp-Parser-Functions">Argp分析器函数</a> 。
</p>
<dl compact>
<dt><code>ARGP_KEY_ARG</code>
<span id="index-ARGP_005fKEY_005fARG"></span>
</dt>
<dd>
<p>这根本不是一个选项，而是一个命令行参数，其值由<var>arg</var> 。
</p>
<p>当由于argp解析器被组合而有多个解析器函数在起作用时，就不可能知道哪个将处理特定的参数。每次调用直到一个返回0或除<code>ARGP_ERR_UNKNOWN</code> ;如果不处理参数， <code>argp_parse</code>立即返回成功，而无需解析任何其他参数。
</p>
<p>解析器函数为此键返回成功后，将记录该事实，并且<code>ARGP_KEY_NO_ARGS</code>情况下将不会使用。<em>但是</em> ，如果在处理参数时解析器函数减小<code>next</code>其领域<var>state</var>参数，该选项将不被视为已处理；这是允许您实际修改参数，也许将其修改为选项，然后再次进行处理。
</p>
</dd>
<dt><code>ARGP_KEY_ARGS</code>
<span id="index-ARGP_005fKEY_005fARGS"></span>
</dt>
<dd>
<p>如果解析器函数返回<code>ARGP_ERR_UNKNOWN</code>对于<code>ARGP_KEY_ARG</code> ，立即使用键再次调用<code>ARGP_KEY_ARGS</code> ，其含义类似，但是使用所有剩余的参数稍微方便些。 <var>arg</var>为0，则参数向量的尾部可能位于<code><var>state</var>->argv + <var>state</var>->next</code> 。如果此键返回成功，并且<code><var>state</var>->next</code>保持不变，则所有剩余参数都被视为已消耗。否则，金额<code><var>state</var>->next</code>已调整，指示使用了多少。这是将两个参数都用于不同参数的示例：</p>

<div class="example">
<pre class="example">&hellip;
case ARGP_KEY_ARG:
  if (<var>state</var>-&gt;arg_num == 0)
    /* First argument */
    first_arg = <var>arg</var>;
  else
    /* Let the next case parse it.  */
    return ARGP_KEY_UNKNOWN;
  break;
case ARGP_KEY_ARGS:
  remaining_args = <var>state</var>-&gt;argv + <var>state</var>-&gt;next;
  num_remaining_args = <var>state</var>-&gt;argc - <var>state</var>-&gt;next;
  break;
</pre></div>

</dd>
<dt><code>ARGP_KEY_END</code>
<span id="index-ARGP_005fKEY_005fEND"></span>
</dt>
<dd>
<p>这表明没有更多的命令行参数。解析器函数的调用顺序不同，首先是子级。这允许每个解析器为父级清理其状态。
</p>
</dd>
<dt><code>ARGP_KEY_NO_ARGS</code>
<span id="index-ARGP_005fKEY_005fNO_005fARGS"></span>
</dt>
<dd>
<p>因为如果没有任何非选项参数，通常会进行一些特殊处理，所以如果解析器函数未成功处理任何非选项参数，则使用此键调用解析器函数。这叫做之前<code>ARGP_KEY_END</code> ，对先前解析的参数进行更一般的有效性检查。
</p>
</dd>
<dt><code>ARGP_KEY_INIT</code>
<span id="index-ARGP_005fKEY_005fINIT"></span>
</dt>
<dd>
<p>在进行任何解析之前，将其传入。然后，将<code>child_input</code>现场<var>state</var> （如果有）被复制到每个孩子的州作为州的初始值<code>input</code>当<em>他们的</em>解析器被调用时。
</p>
</dd>
<dt><code>ARGP_KEY_SUCCESS</code>
<span id="index-ARGP_005fKEY_005fSUCCESS"></span>
</dt>
<dd>
<p>解析成功完成时传递，即使保留参数也是如此。
</p>
</dd>
<dt><code>ARGP_KEY_ERROR</code>
<span id="index-ARGP_005fKEY_005fERROR"></span>
</dt>
<dd>
<p>如果发生错误并且解析终止，则传入。在这种情况下，按键为<code>ARGP_KEY_SUCCESS</code>永远不会。
</p>
</dd>
<dt><code>ARGP_KEY_FINI</code>
<span id="index-ARGP_005fKEY_005fFINI"></span>
</dt>
<dd>
<p>任何解析器都可以看到的最终密钥，即使在<code>ARGP_KEY_SUCCESS</code>和<code>ARGP_KEY_ERROR</code> 。分配的任何资源<code>ARGP_KEY_INIT</code>可能在这里被释放。有时，成功解析后，某些分配的资源将返回给调用方。在这种情况下，可以在<code>ARGP_KEY_ERROR</code>案件。
</p></dd>
</dl>

<p>在所有情况下， <code>ARGP_KEY_INIT</code>是解析器功能看到的第一个键，并且<code>ARGP_KEY_FINI</code>最后一个，除非解析器返回了错误<code>ARGP_KEY_INIT</code> 。其他键可以按以下顺序之一发生。 <var>opt</var>指任意选项键：</p>
<dl compact>
<dt><var>opt</var> … <code>ARGP_KEY_NO_ARGS</code><code>ARGP_KEY_END</code> <code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>解析的参数不包含任何非选项参数。
</p>
</dd>
<dt>（ <var>opt</var> | <code>ARGP_KEY_ARG</code> ）… <code>ARGP_KEY_END</code> <code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>所有非选项参数均已由解析器函数成功处理。如果将多个argp解析器组合在一起，则可能有多个解析器功能。
</p>
</dd>
<dt>（ <var>opt</var> | <code>ARGP_KEY_ARG</code> ）…<code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>一些非期权的论点无法得到认可。
</p>
<p>当每个解析器函数返回时，就会发生这种情况<code>ARGP_KEY_UNKNOWN</code>对于一个参数，在这种情况下，如果<var>arg_index</var>是一个空指针。否则会发生错误。
</p></dd>
</dl>

<p>在所有情况下，如果<var>arg_index</var>被传递给<code>argp_parse</code> ，则第一个未解析的命令行参数的索引将以该值传递回。
</p>
<p>如果发生错误并且被argp检测到，或者因为解析器函数返回了错误值，则使用<code>ARGP_KEY_ERROR</code> 。不会再打任何电话，除了最后一个电话<code>ARGP_KEY_FINI</code> 。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Argp-Parsing-State.html#Argp-Parsing-State" rel="next" accesskey="n">Argp解析状态</a> ，上<a href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="up" accesskey="u">一篇</a> ： <a href="Argp-Parser-Functions.html#Argp-Parser-Functions" rel="up" accesskey="u">Argp解析器功能</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>