<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>内存概念（GNU C库）</title>

<meta name="description" content="Memory Concepts (The GNU C Library)">
<meta name="keywords" content="Memory Concepts (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Memory.html#Memory" rel="up" title="Memory">
<link href="Memory-Allocation.html#Memory-Allocation" rel="next" title="Memory Allocation">
<link href="Memory.html#Memory" rel="prev" title="Memory">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Memory-Concepts"></span><div class="header">
<p>下一页： <a href="Memory-Allocation.html#Memory-Allocation" rel="next" accesskey="n">内存分配</a> ，最多： <a href="Memory.html#Memory" rel="up" accesskey="u">内存</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Process-Memory-Concepts"></span><h3 class="section">3.1进程存储器概念</h3>

<p>进程可以使用的最基本的资源之一就是内存。系统组织内存的方式有很多，但是在典型的情况下，每个进程都有一个线性虚拟地址空间，地址从零到最大。它不必是连续的；也就是说，并非所有这些地址实际上都可以用于存储数据。
</p>
<p>虚拟内存分为几页（典型值为4 KB）。支持虚拟内存的每一页的是实际内存（称为<em>frame</em> ）或某些辅助存储（通常是磁盘空间）的页面。磁盘空间可能是交换空间，也可能只是一些普通的磁盘文件。实际上，全零的页面有时根本没有任何支持它–只有一个标志说全为零。
<span id="index-page-frame"></span>
<span id="index-frame_002c-real-memory"></span>
<span id="index-swap-space"></span>
<span id="index-page_002c-virtual-memory"></span>
</p>
<p>实存储器或后备存储的同一帧可以备份属于多个进程的多个虚拟页。例如，对于GNU C库代码占用的虚拟内存，通常是这种情况。同一实内存帧包含<code>printf</code>函数会在每个现有进程中备份一个具有<code>printf</code>调用其程序。
</p>
<p>为了使程序能够访问虚拟页面的任何部分，该页面此时必须由真实框架（“连接到”）进行备份。但是由于虚拟内存通常比真实内存要多得多，因此页面必须定期在真实内存和后备存储之间来回移动，当进程需要访问它们时将其放入真实内存，然后在不再需要时退回到后备存储。此动作称为<em>分页</em> 。
</p>
<p>当程序尝试访问当时没有实内存支持的<em>页面时</em> ，这称为<em>页面错误</em> 。当发生页面错误时，内核将挂起进程，将页面放入真实的页面框架（这称为“分页”或“故障进入”），然后继续执行该过程，以便从进程的角度来看，页面一直在真实内存中。实际上，在此过程中，所有页面似乎始终在真实内存中。除了一件事：一条指令的执行时间通常是几纳秒，突然变得长得多，长得多（因为内核通常必须执行I / O才能完成分页）。对于敏感的程序，“ <a href="Locking-Pages.html#Locking-Pages">锁定页面”中</a>描述的功能可以控制它。
<span id="index-page-fault"></span>
<span id="index-paging"></span>
</p>
<p>在每个虚拟地址空间内，一个进程必须跟踪什么地址，该进程称为内存分配。分配通常会让人想起稀缺的资源，但是对于虚拟内存来说，这并不是主要目标，因为虚拟内存通常比任何人都需要更多。进程内的内存分配主要只是确保不使用相同的内存字节来存储两个不同的事物。
</p>
<p>进程以两种主要方式分配内存：通过exec和以编程方式。实际上，分叉是第三种方法，但这不是很有趣。请参阅<a href="Creating-a-Process.html#Creating-a-Process">创建流程</a> 。
</p>
<p>Exec是为进程创建虚拟地址空间，将其基本程序加载到其中并执行程序的操作。这是由“ exec”功能族（例如<code>execl</code> ）。该操作获取程序文件（可执行文件），它分配空间以将所有数据加载到可执行文件中，然后将其加载，并将控制权转移给该可执行文件。该数据最明显地是程序的指令（ <em>文本</em> ），也是程序中的文字和常量，甚至是一些变量：具有静态存储类的C变量（请参阅<a href="Memory-Allocation-and-C.html#Memory-Allocation-and-C">内存分配和C</a> ）。
<span id="index-executable"></span>
<span id="index-literals"></span>
<span id="index-constants"></span>
</p>
<p>该程序开始执行后，将使用程序分配来获取更多内存。在带有GNU C库的C程序中，有两种编程分配：自动分配和动态分配。请参阅<a href="Memory-Allocation-and-C.html#Memory-Allocation-and-C">内存分配和C。</a></p>
<p>内存映射的I / O是动态虚拟内存分配的另一种形式。将内存映射到文件意味着声明某个进程地址的特定范围的内容应与指定常规文件的内容相同。系统使虚拟内存最初包含文件的内容，如果您修改了内存，则系统会将相同的修改写入文件。请注意，由于虚拟内存和页面错误的魔力，在程序访问虚拟内存之前，系统没有理由让I / O读取文件或为其内容分配实际内存。请参阅<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存映射的I / O。</a> <span id="index-memory-mapped-I_002fO"></span><span id="index-memory-mapped-file"></span><span id="index-files_002c-accessing"></span>
</p>
<p>就像它以编程方式分配内存一样，程序也可以以编程方式释放（ <em>释放</em> ）它。您无法释放exec分配的内存。当程序退出或执行时，您可能会说它的所有内存都被释放了，但是由于在两种情况下地址空间都不再存在，所以这一点确实没有意义。请参阅<a href="Program-Termination.html#Program-Termination">程序终止</a> 。
<span id="index-execing-a-program"></span>
<span id="index-freeing-memory"></span>
<span id="index-exiting-a-program"></span>
</p>
<p>进程的虚拟地址空间分为多个部分。段是虚拟地址的连续范围。三个重要的部分是：</p>
<ul>
<li><em>文本段</em>包含程序的指令，文字和静态常量。它由exec分配，并且在虚拟地址空间的生存期内保持不变。

</li><li><em>数据段</em>正在为程序工作。它可以由exec进行预分配和预加载，并且进程可以通过调用函数来扩展或收缩它，如参见<a href="Resizing-the-Data-Segment.html#Resizing-the-Data-Segment">调整数据段的大小中所述</a> 。它的下端是固定的。

</li><li><em>堆栈段</em>包含一个程序堆栈。它随着堆栈的增长而增长，但是当堆栈收缩时不会收缩。

</li></ul>



<hr>
<div class="header">
<p>下一页： <a href="Memory-Allocation.html#Memory-Allocation" rel="next" accesskey="n">内存分配</a> ，最多： <a href="Memory.html#Memory" rel="up" accesskey="u">内存</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>