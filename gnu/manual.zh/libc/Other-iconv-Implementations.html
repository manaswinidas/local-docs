<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>其他iconv实现（GNU C库）</title>

<meta name="description" content="Other iconv Implementations (The GNU C Library)">
<meta name="keywords" content="Other iconv Implementations (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" title="Generic Charset Conversion">
<link href="glibc-iconv-Implementation.html#glibc-iconv-Implementation" rel="next" title="glibc iconv Implementation">
<link href="iconv-Examples.html#iconv-Examples" rel="prev" title="iconv Examples">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Other-iconv-Implementations"></span><div class="header">
<p>下一篇： <a href="glibc-iconv-Implementation.html#glibc-iconv-Implementation" rel="next" accesskey="n">glibc iconv实现</a> ，上一篇： <a href="iconv-Examples.html#iconv-Examples" rel="prev" accesskey="p">iconv示例</a> ，上一篇： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Some-Details-about-other-iconv-Implementations"></span><h4 class="subsection">6.5.3关于其他的一些细节<code>iconv</code>实作</h4>

<p>这不是真正讨论的地方<code>iconv</code>其他系统的实现，但有必要了解一些有关编写便携式程序的信息。规范的上述问题<code>iconv</code>功能可能导致可移植性问题。
</p>
<p>首先要注意的是，由于使用了大量字符集，因此直接在C库中对转换进行编码无疑是不实际的。因此，转换信息必须来自C库之外的文件。通常通过以下一种或两种方式完成此操作：</p>
<ul>
<li>C库包含一组通用转换函数，这些函数可以从数据文件中读取所需的转换表和其他信息。必要时将加载这些文件。

<p>该解决方案是有问题的，因为它需要付出很大的努力才能应用于所有字符集（可能是无限集）。不同字符集的结构差异如此之大，以至于必须开发表处理功能的许多不同变体。此外，这些功能的通用性使其比专门实现的功能慢。
</p>
</li><li>C库仅包含一个可以动态加载目标文件并执行其中包含的转换功能的框架。

<p>该解决方案提供了更大的灵活性。C库本身仅包含很少的代码，因此减少了总体内存占用。同样，通过C库和可加载模块之间的文档接口，第三方可以扩展可用转换模块的集合。该解决方案的缺点是动态加载必须可用。
</p></li></ul>

<p>商业Unices中的某些实现将这些可能性混合在一起。多数仅实施第二种解决方案。使用可加载模块将代码移出库本身，并为扩展和改进打开了方便之门，但是这种设计在某些平台上也受到限制，因为没有太多平台支持静态链接程序中的动态加载。因此，在没有此功能的平台上，无法在静态链接的程序中使用此接口。在ELF平台上，GNU C库在这些情况下没有动态加载问题。因此，这一点尚无定论。危险是人们熟悉这种情况，而忘记了对其他系统的限制。
</p>
<p>要知道的第二件事<code>iconv</code>实施方案是可用转换的数量通常非常有限。在标准版本（不是特殊的国际版本或开发人员版本）中，某些实现最多提供100到200个转换可能性。这并不意味着支持200个不同的字符集。例如，从一个字符集到一组其他10个字符的转换可能算作10次转换。连同另一个方向，这使一个字符集用尽了20种转换可能性。可以想象这些平台提供的覆盖范围很广。一些Unix供应商甚至只提供了很少的转换，这使得它们几乎不能用于所有用途。
</p>
<p>这直接导致了第三点，也可能是最有问题的一点。的方式<code>iconv</code>转换函数在所有已知的Unix系统上实现，并且从字符集<em>A</em>到<em>B</em>以及从<em>B</em>到<em>C</em>的转换功能的可用性<em>并不</em>意味着从<em>A</em>到<em>C</em>的转换可用。
</p>
<p>乍一看，这似乎并不合理且有问题，但是这是一个很大的问题，因为您在遇到该问题后会很快注意到。为了显示该问题，我们假设编写了一个必须从<em>A</em>转换为<em>C的程序</em> 。像这样的电话</p>
<div class="example">
<pre class="example">cd = iconv_open (&quot;<em>C</em>&quot;, &quot;<em>A</em>&quot;);
</pre></div>

<p>根据上述假设失败。但是程序现在做什么？转换是必要的；因此，仅仅放弃是不可行的。
</p>
<p>这很麻烦。的<code>iconv</code>功能应注意这一点。但是，程序应该如何从这里开始？如果它尝试转换为字符集<em>B</em> ，则首先输入两个<code>iconv_open</code>来电</p>
<div class="example">
<pre class="example">cd1 = iconv_open (&quot;<em>B</em>&quot;, &quot;<em>A</em>&quot;);
</pre></div>

<p>和</p>
<div class="example">
<pre class="example">cd2 = iconv_open (&quot;<em>C</em>&quot;, &quot;<em>B</em>&quot;);
</pre></div>

<p>会成功，但是如何找到<em>B</em>呢？
</p>
<p>不幸的是，答案是：没有通用的解决方案。在某些系统上，猜测可能会有所帮助。在这些系统上，大多数字符集都可以与UTF-8编码的ISO 10646 <!-- /@w -->或Unicode文本相互转换。除此之外，只有一些非常特定于系统的方法可以提供帮助。由于转换功能来自可加载模块，并且这些模块必须存储在文件系统中的某个位置，因此<em>可以</em>尝试找到它们并从可用文件中确定哪些转换可用，以及是否存在从<em>A</em>到<em>C</em>的间接路由。</p>
<p>此示例显示了以下设计错误之一<code>iconv</code>上文提到的。至少应以编程方式确定可用转化的列表，以便<code>iconv_open</code>表示没有这种转换，可以确保间接路由也是如此。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="glibc-iconv-Implementation.html#glibc-iconv-Implementation" rel="next" accesskey="n">glibc iconv实现</a> ，上一篇： <a href="iconv-Examples.html#iconv-Examples" rel="prev" accesskey="p">iconv示例</a> ，上一篇： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>