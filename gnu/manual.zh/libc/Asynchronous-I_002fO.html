<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>异步I / O（GNU C库）</title>

<meta name="description" content="Asynchronous I/O (The GNU C Library)">
<meta name="keywords" content="Asynchronous I/O (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" title="Low-Level I/O">
<link href="Asynchronous-Reads_002fWrites.html#Asynchronous-Reads_002fWrites" rel="next" title="Asynchronous Reads/Writes">
<link href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="prev" title="Synchronizing I/O">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Asynchronous-I_002fO"></span><div class="header">
<p>下一篇： <a href="Control-Operations.html#Control-Operations" rel="next" accesskey="n">控制操作</a> ，上一篇： <a href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="prev" accesskey="p">同步I / O</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Perform-I_002fO-Operations-in-Parallel"></span><h3 class="section">13.11并行执行I / O操作</h3>

<p>POSIX.1b标准定义了一组新的I / O操作，可以显着减少应用程序等待I / O所花费的时间。新功能允许程序启动一个或多个I / O操作，然后在并行执行I / O操作时立即恢复正常工作。如果<samp>unistd.h</samp>文件定义符号<code>_POSIX_ASYNCHRONOUS_IO</code> 。
</p>
<p>这些函数是库的一部分，实时函数名为<samp>librt</samp> 。它们实际上不是<samp>libc</samp>二进制可以使用内核中的支持（如果有）或使用基于用户级别线程的实现来完成这些功能的实现。在后一种情况下，可能有必要将应用程序与线程库链接<samp>libpthread</samp>此外<samp>librt</samp> 。
</p>
<p>所有AIO操作都对先前打开的文件进行操作。一个文件可能有许多操作在运行。异步I / O操作使用名为<code>struct aiocb</code> （ <em>AIO控制块</em> ）。它在<samp>aio.h</samp>如下。
</p>
<dl>
<dt id="index-struct-aiocb">数据类型： <strong>struct aiocb</strong></dt>
<dd>
<p>POSIX.1b标准要求<code>struct aiocb</code>结构至少包含下表中描述的成员。该实现可能会使用更多元素，但是取决于这些元素，这些元素不可移植并且不建议使用。
</p>
<dl compact>
<dt><code>int aio_fildes</code></dt>
<dd><p>该元素指定用于操作的文件描述符。它必须是合法的描述符，否则操作将失败。
</p>
<p>在其上打开文件的设备必须允许搜索操作。即，无法在终端等设备上使用任何AIO操作<code>lseek</code>调用会导致错误。
</p>
</dd>
<dt><code>off_t aio_offset</code></dt>
<dd><p>该元素指定文件中执行操作（输入或输出）的偏移量。由于这些操作是以任意顺序执行的，并且可以为一个文件描述符启动一个以上的操作，因此无法期望文件描述符的当前读取/写入位置。
</p>
</dd>
<dt><code>volatile void *aio_buf</code></dt>
<dd><p>这是指向要写入数据的缓冲区或读取数据存储位置的指针。
</p>
</dd>
<dt><code>size_t aio_nbytes</code></dt>
<dd><p>此元素指定由指向的缓冲区的长度<code>aio_buf</code> 。
</p>
</dd>
<dt><code>int aio_reqprio</code></dt>
<dd><p>如果平台已经定义<code>_POSIX_PRIORITIZED_IO</code>和<code>_POSIX_PRIORITY_SCHEDULING</code> ，则根据当前的调度优先级处理AIO请求。的<code>aio_reqprio</code>然后可以使用元素降低AIO操作的优先级。
</p>
</dd>
<dt><code>struct sigevent aio_sigevent</code></dt>
<dd><p>该元素指定操作终止后如何通知调用过程。如果<code>sigev_notify</code>元素是<code>SIGEV_NONE</code> ，不发送通知。如果是<code>SIGEV_SIGNAL</code> ，由<code>sigev_signo</code>已发送。除此以外， <code>sigev_notify</code>一定是<code>SIGEV_THREAD</code> 。在这种情况下，将创建一个线程，该线程开始执行由指向的功能<code>sigev_notify_function</code> 。
</p>
</dd>
<dt><code>int aio_lio_opcode</code></dt>
<dd><p>此元素仅由<code>lio_listio</code>和<code>lio_listio64</code>功能。由于这些功能允许立即开始任意数量的操作，并且可以输入或输出每个操作（或不输入任何内容），因此信息必须存储在控制块中。可能的值为：</p>
<dl compact>
<dt><code>LIO_READ</code>
<span id="index-LIO_005fREAD"></span>
</dt>
<dd><p>开始读取操作。从位置读取文件<code>aio_offset</code>并存储下一个<code>aio_nbytes</code>指向的缓冲区中的字节<code>aio_buf</code> 。
</p>
</dd>
<dt><code>LIO_WRITE</code>
<span id="index-LIO_005fWRITE"></span>
</dt>
<dd><p>开始写操作。写<code>aio_nbytes</code>字节起始于<code>aio_buf</code>从位置开始到文件中<code>aio_offset</code> 。
</p>
</dd>
<dt><code>LIO_NOP</code>
<span id="index-LIO_005fNOP"></span>
</dt>
<dd><p>对此控制块不执行任何操作。有时，当<code>struct aiocb</code>值包含孔，即，尽管整个数组都呈现给<code>lio_listio</code>功能。
</p></dd>
</dl>
</dd>
</dl>

<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，这种类型实际上是<code>struct aiocb64</code> ，因为LFS接口透明地替换了<code>struct aiocb</code>定义。
</p></dd></dl>

<p>为了与LFS中定义的AIO功能一起使用，定义了一个相似的类型，该类型将较大的类型替换了适当的成员的类型，但等效于<code>struct aiocb</code> 。特别是，所有成员名称都相同。
</p>
<dl>
<dt id="index-struct-aiocb64">数据类型： <strong>struct aiocb64</strong></dt>
<dd>
<dl compact>
<dt><code>int aio_fildes</code></dt>
<dd><p>该元素指定用于操作的文件描述符。它必须是合法的描述符，因为否则操作由于明显的原因而失败。
</p>
<p>在其上打开文件的设备必须允许搜索操作。即，无法在终端等设备上使用任何AIO操作<code>lseek</code>调用会导致错误。
</p>
</dd>
<dt><code>off64_t aio_offset</code></dt>
<dd><p>该元素指定执行文件（输入或输出）的偏移量。由于该操作以任意顺序进行，并且可以启动一个文件描述符的多个操作，因此无法期望文件描述符的当前读取/写入位置。
</p>
</dd>
<dt><code>volatile void *aio_buf</code></dt>
<dd><p>这是指向要写入数据的缓冲区或读取数据存储位置的指针。
</p>
</dd>
<dt><code>size_t aio_nbytes</code></dt>
<dd><p>此元素指定由指向的缓冲区的长度<code>aio_buf</code> 。
</p>
</dd>
<dt><code>int aio_reqprio</code></dt>
<dd><p>如果用于平台<code>_POSIX_PRIORITIZED_IO</code>和<code>_POSIX_PRIORITY_SCHEDULING</code>定义基于当前调度优先级处理AIO请求。的<code>aio_reqprio</code>然后可以使用元素降低AIO操作的优先级。
</p>
</dd>
<dt><code>struct sigevent aio_sigevent</code></dt>
<dd><p>该元素指定操作终止后如何通知调用过程。如果<code>sigev_notify</code>元素是<code>SIGEV_NONE</code>没有发送通知。如果是<code>SIGEV_SIGNAL</code> ，由<code>sigev_signo</code>已发送。除此以外， <code>sigev_notify</code>一定是<code>SIGEV_THREAD</code>在这种情况下，将创建一个线程，该线程开始执行由指向的功能<code>sigev_notify_function</code> 。
</p>
</dd>
<dt><code>int aio_lio_opcode</code></dt>
<dd><p>此元素仅由<code>lio_listio</code>和<code>lio_listio64</code>功能。由于这些功能允许立即开始任意数量的操作，并且由于可以输入或输出每个操作（或不进行任何操作），因此信息必须存储在控制块中。参见说明<code>struct aiocb</code>用于描述可能的值。
</p></dd>
</dl>

<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，该类型的名称为<code>struct aiocb64</code> ，因为LFS透明地替换了旧界面。
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tbody><tr><td align="left" valign="top">• <a href="Asynchronous-Reads_002fWrites.html#Asynchronous-Reads_002fWrites" accesskey="1">异步读/写</a></td><td>  </td><td align="left" valign="top">异步读写操作。
</td></tr>
<tr><td align="left" valign="top">• <a href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" accesskey="2">AIO运营状况</a></td><td>  </td><td align="left" valign="top">获取AIO操作的状态。
</td></tr>
<tr><td align="left" valign="top">• <a href="Synchronizing-AIO-Operations.html#Synchronizing-AIO-Operations" accesskey="3">同步AIO操作</a></td><td>  </td><td align="left" valign="top">进入一致状态。
</td></tr>
<tr><td align="left" valign="top">• <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" accesskey="4">取消AIO操作</a></td><td>  </td><td align="left" valign="top">取消AIO操作。
</td></tr>
<tr><td align="left" valign="top">• <a href="Configuration-of-AIO.html#Configuration-of-AIO" accesskey="5">AIO的配置</a></td><td>  </td><td align="left" valign="top">如何优化AIO实施。
</td></tr>
</tbody></table>

<hr>
<div class="header">
<p>下一篇： <a href="Control-Operations.html#Control-Operations" rel="next" accesskey="n">控制操作</a> ，上一篇： <a href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="prev" accesskey="p">同步I / O</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>