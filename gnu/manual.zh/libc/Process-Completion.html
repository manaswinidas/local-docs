<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>流程完成（GNU C库）</title>

<meta name="description" content="Process Completion (The GNU C Library)">
<meta name="keywords" content="Process Completion (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Processes.html#Processes" rel="up" title="Processes">
<link href="Process-Completion-Status.html#Process-Completion-Status" rel="next" title="Process Completion Status">
<link href="Executing-a-File.html#Executing-a-File" rel="prev" title="Executing a File">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Process-Completion"></span><div class="header">
<p>下一页： <a href="Process-Completion-Status.html#Process-Completion-Status" rel="next" accesskey="n">进程完成状态</a> ，上一页： <a href="Executing-a-File.html#Executing-a-File" rel="prev" accesskey="p">执行文件</a> ，上一页： <a href="Processes.html#Processes" rel="up" accesskey="u">处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Process-Completion-1"></span><h3 class="section">26.6工艺完成</h3>
<span id="index-process-completion"></span>
<span id="index-waiting-for-completion-of-child-process"></span>
<span id="index-testing-exit-status-of-child-process"></span>

<p>本节中描述的功能用于等待子进程终止或停止并确定其状态。这些函数在头文件中声明<samp>sys/wait.h</samp> 。
<span id="index-sys_002fwait_002eh"></span>
</p>
<dl>
<dt id="index-waitpid">函数： <em>pid_t</em> <strong>waitpid</strong> <em>（pid_t <var>pid</var> ，int * <var>status-ptr</var> ，int <var>options</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>waitpid</code>函数用于从子进程请求状态信息，该子进程的进程ID为<var>pid</var> 。通常，调用过程将被挂起，直到子进程通过终止使状态信息可用为止。
</p>
<p>的其他值<var>pid</var>论点有特殊的解释。值<code>-1</code>要么<code>WAIT_ANY</code>请求任何子进程的状态信息；的值<code>0</code>要么<code>WAIT_MYPGRP</code>向与调用进程相同的进程组中的任何子进程请求信息；以及其他任何负值- <var>pgid</var>请求任何有关其进程组ID为<var>pgid</var> 。
</p>
<p>如果子进程的状态信息立即可用，则此函数无需等待即可立即返回。如果多个合格的子进程具有可用的状态信息，则将随机选择其中之一，并立即返回其状态。要从其他合格的子进程中获取状态，您需要致电<code>waitpid</code>再次。
</p>
<p>的<var>options</var>参数是一个掩码。其值应为按位或（即' <samp>|</samp> '运算符）的零个或多个<code>WNOHANG</code>和<code>WUNTRACED</code>标志。您可以使用<code>WNOHANG</code>指示父进程不应等待的标志；和<code>WUNTRACED</code>标志以从停止的进程以及已终止的进程请求状态信息。
</p>
<p>来自子进程的状态信息存储在以下对象中<var>status-ptr</var>指向，除非<var>status-ptr</var>是一个空指针。
</p>
<p>此功能是多线程程序中的取消点。如果线程当时分配了一些资源（例如内存，文件描述符，信号量或其他内容），这将是一个问题<code>waitpid</code>叫做。如果线程被取消，这些资源将保持分配状态，直到程序结束。为了避免这种情况<code>waitpid</code>应该使用取消处理程序进行保护。
</p>
<p>返回值通常是报告其状态的子进程的进程ID。如果有子进程，但是没有一个子进程等待被注意， <code>waitpid</code>将阻止，直到一个。但是，如果<code>WNOHANG</code>指定了选项<code>waitpid</code>将返回零而不是阻塞。
</p>
<p>如果给一个特定的PID等待<code>waitpid</code> ，它将忽略所有其他子项（如果有）。因此，如果有孩子等待被注意，但指定PID的孩子不是其中之一， <code>waitpid</code>将如上所述阻止或返回零。
</p>
<p>值<code>-1</code>发生错误时返回。下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EINTR</code></dt>
<dd><p>通过向调用进程传递信号中断了该功能。请参阅<a href="Interrupted-Primitives.html#Interrupted-Primitives">中断的基元</a> 。
</p>
</dd>
<dt><code>ECHILD</code></dt>
<dd><p>没有等待的子进程，或者指定了<var>pid</var>不是调用过程的子级。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>为以下内容提供了无效的值： <var>options</var>论点。
</p></dd>
</dl>
</dd></dl>

<p>这些符号常量被定义为<var>pid</var>争论<code>waitpid</code>功能。
</p>
<dl compact>
<dt><code>WAIT_ANY</code>
<span id="index-WAIT_005fANY"></span>
</dt>
<dd>
<p>此常量宏（其值为<code>-1</code> ）指定<code>waitpid</code>应该返回有关任何子进程的状态信息。
</p>

</dd>
<dt><code>WAIT_MYPGRP</code>
<span id="index-WAIT_005fMYPGRP"></span>
</dt>
<dd><p>这个常数（带有值<code>0</code> ）指定<code>waitpid</code>应该返回与调用进程相同的进程组中任何子进程的状态信息。
</p></dd>
</dl>

<p>这些符号常量被定义为<var>options</var>争论<code>waitpid</code>功能。您可以将标志按位进行“或”运算，以获取用作参数的值。
</p>
<dl compact>
<dt><code>WNOHANG</code>
<span id="index-WNOHANG"></span>
</dt>
<dd>
<p>该标志指定<code>waitpid</code>如果没有子流程准备就绪，应该立即返回而不是等待。
</p>
</dd>
<dt><code>WUNTRACED</code>
<span id="index-WUNTRACED"></span>
</dt>
<dd>
<p>该标志指定<code>waitpid</code>应该报告已停止以及已终止的所有子进程的状态。
</p></dd>
</dl>

<dl>
<dt id="index-wait">函数： <em>pid_t</em> <strong>wait</strong> <em>（int * <var>status-ptr</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这是的简化版本<code>waitpid</code> ，用于等待任何一个子进程终止。电话：</p>
<div class="example">
<pre class="example">wait (&amp;status)
</pre></div>

<p>完全等同于：</p>
<div class="example">
<pre class="example">waitpid (-1, &amp;status, 0)
</pre></div>

<p>此功能是多线程程序中的取消点。如果线程当时分配了一些资源（例如内存，文件描述符，信号量或其他内容），这将是一个问题<code>wait</code>叫做。如果线程被取消，这些资源将保持分配状态，直到程序结束。为了避免这种情况<code>wait</code>应该使用取消处理程序进行保护。
</p></dd></dl>

<dl>
<dt id="index-wait4">函数： <em>pid_t</em> <strong>wait4</strong> <em>（pid_t <var>pid</var> ，int * <var>status-ptr</var> ，int <var>options</var> ，struct rusage * <var>usage</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>如果<var>usage</var>是一个空指针， <code>wait4</code>相当于<code>waitpid (<var>pid</var>, <var>status-ptr</var>, <var>options</var>)</code> 。
</p>
<p>如果<var>usage</var>不为空， <code>wait4</code>将子进程的使用情况数据存储在<code>*<var>rusage</var></code> （但仅当孩子终止时，才停止）。请参阅<a href="Resource-Usage.html#Resource-Usage">资源使用情况</a> 。
</p>
<p>此功能是BSD扩展。
</p></dd></dl>

<p>这是一个使用方法的例子<code>waitpid</code>从所有已终止的子进程中获取状态，而无需等待。此功能旨在作为以下内容的处理程序<code>SIGCHLD</code> ，表示至少一个子进程已终止的信号。
</p>
<div class="example">
<pre class="example">void
sigchld_handler (int signum)
{
  int pid, status, serrno;
  serrno = errno;
  while (1)
    {
      pid = waitpid (WAIT_ANY, &amp;status, WNOHANG);
      if (pid &lt; 0)
        {
          perror (&quot;waitpid&quot;);
          break;
        }
      if (pid == 0)
        break;
      notice_termination (pid, status);
    }
  errno = serrno;
}
</pre></div>

<hr>
<div class="header">
<p>下一页： <a href="Process-Completion-Status.html#Process-Completion-Status" rel="next" accesskey="n">进程完成状态</a> ，上一页： <a href="Executing-a-File.html#Executing-a-File" rel="prev" accesskey="p">执行文件</a> ，上一页： <a href="Processes.html#Processes" rel="up" accesskey="u">处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>