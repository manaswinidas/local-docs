<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>程序错误信号（GNU C库）</title>

<meta name="description" content="Program Error Signals (The GNU C Library)">
<meta name="keywords" content="Program Error Signals (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Standard-Signals.html#Standard-Signals" rel="up" title="Standard Signals">
<link href="Termination-Signals.html#Termination-Signals" rel="next" title="Termination Signals">
<link href="Standard-Signals.html#Standard-Signals" rel="prev" title="Standard Signals">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Program-Error-Signals"></span><div class="header">
<p>下一篇： <a href="Termination-Signals.html#Termination-Signals" rel="next" accesskey="n">终端信号</a> ，上一篇： <a href="Standard-Signals.html#Standard-Signals" rel="up" accesskey="u">标准信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Program-Error-Signals-1"></span><h4 class="subsection">24.2.1程序错误信号</h4>
<span id="index-program-error-signals"></span>

<p>当操作系统或计算机本身检测到严重的程序错误时，将生成以下信号。通常，所有这些信号都表明您的程序在某种程度上已严重损坏，并且通常无法继续进行遇到错误的计算。
</p>
<p>有些程序处理程序错误信号是为了在终止之前进行整理。例如，关闭终端输入回波的程序应处理程序错误信号，以便重新打开回波。处理程序应首先为发生的信号指定默认操作，然后重新引发它。这将导致程序以该信号终止，就好像它没有处理程序一样。（请参阅<a href="Termination-in-Handler.html#Termination-in-Handler">处理程序中的终止</a> 。）
</p>
<p>终止是大多数程序中程序错误的明智最终结果。但是，即使用户程序产生错误，诸如Lisp之类的可以加载已编译用户程序的编程系统也可能需要继续执行。这些程序的处理程序使用<code>longjmp</code>将控制返回到命令级别。
</p>
<p>所有这些信号的默认操作是导致进程终止。如果您阻止或忽略这些信号或为正常返回的信号建立处理程序，则当此类信号发生时，程序可能会严重中断，除非它们是由以下人员生成的<code>raise</code>要么<code>kill</code>而不是真正的错误。
</p>
<span id="index-COREFILE"></span>
<p>当这些程序错误信号之一终止进程时，它还会写入一个<em>核心转储文件</em> ，该<em>文件</em>记录终止时进程的状态。核心转储文件名为<samp>core</samp>并写入当时该进程中当前的任何目录。（在GNU / Hurd系统上，您可以使用环境变量为核心转储指定文件名<code>COREFILE</code> ）核心转储文件的目的是使您可以使用调试器检查它们，以调查导致错误的原因。
</p>
<dl>
<dt id="index-SIGFPE">巨集： <em>int</em> <strong>SIGFPE</strong></dt>
<dd>
<p>的<code>SIGFPE</code>信号报告致命的算术错误。尽管名称源自“浮点异常”，但该信号实际上涵盖了所有算术错误，包括零除和溢出。如果程序将整数数据存储在随后用于浮点运算的位置，则这通常会导致“无效运算”异常，因为处理器无法将数据识别为浮点数。
<span id="index-exception-1"></span>
<span id="index-floating_002dpoint-exception"></span>
</p>
<p>实际的浮点异常是一个复杂的主题，因为有许多类型的异常含义各不相同，并且<code>SIGFPE</code>信号无法区分它们。<cite>IEEE二进制浮点算术标准（ANSI / IEEE Std 754-1985和ANSI / IEEE Std 854-1987）</cite>定义了各种浮点异常，并要求合格的计算机系统报告它们的出现。但是，该标准未指定如何报告异常，也不指定操作系统可以为程序员提供什么样的处理和控制。
</p></dd></dl>

<p>BSD系统提供<code>SIGFPE</code>处理程序，带有一个额外的参数，可以区分导致异常的各种原因。为了访问此参数，必须定义处理程序以接受两个参数，这意味着必须将其强制转换为一个参数的函数类型才能建立处理程序。GNU C库确实提供了这个额外的参数，但是该值仅在提供信息的操作系统（BSD系统和GNU系统）上有意义。
</p>
<dl compact>
<dt><code>FPE_INTOVF_TRAP</code>
<span id="index-FPE_005fINTOVF_005fTRAP"></span>
</dt>
<dd>
<p>整数溢出（除非您以特定于硬件的方式启用溢出陷阱，否则在C程序中是不可能的）。
</p></dd>
<dt><code>FPE_INTDIV_TRAP</code>
<span id="index-FPE_005fINTDIV_005fTRAP"></span>
</dt>
<dd>
<p>整数除以零。
</p></dd>
<dt><code>FPE_SUBRNG_TRAP</code>
<span id="index-FPE_005fSUBRNG_005fTRAP"></span>
</dt>
<dd>
<p>下标范围（C程序从不检查的范围）。
</p></dd>
<dt><code>FPE_FLTOVF_TRAP</code>
<span id="index-FPE_005fFLTOVF_005fTRAP"></span>
</dt>
<dd>
<p>浮动溢出陷阱。
</p></dd>
<dt><code>FPE_FLTDIV_TRAP</code>
<span id="index-FPE_005fFLTDIV_005fTRAP"></span>
</dt>
<dd>
<p>浮动/小数除以零。
</p></dd>
<dt><code>FPE_FLTUND_TRAP</code>
<span id="index-FPE_005fFLTUND_005fTRAP"></span>
</dt>
<dd>
<p>浮动下溢阱。（通常不启用对浮动下溢的陷阱。）
</p></dd>
<dt><code>FPE_DECOVF_TRAP</code>
<span id="index-FPE_005fDECOVF_005fTRAP"></span>
</dt>
<dd>
<p>十进制溢出陷阱。（只有少数几台机器使用十进制算术，而C从未使用过。）
</p></dd>
</dl>

<dl>
<dt id="index-SIGILL">巨集： <em>int</em> <strong>SIGILL</strong></dt>
<dd>
<p>该信号的名称源自“非法指令”；这通常意味着您的程序正在尝试执行垃圾回收或特权指令。由于C编译器仅生成有效指令， <code>SIGILL</code>通常表示可执行文件已损坏，或者您正在尝试执行数据。进入后一种情况的一些常见方法是，传递一个预期要指向函数的指针的无效对象，或者将其写入自动数组的末尾（或指向自动变量的指针的类似问题），然后破坏该数组上的其他数据。堆栈，例如堆栈帧的返回地址。
</p>
<p><code>SIGILL</code>当堆栈溢出时，或者系统在运行信号处理程序时遇到问题时，也会生成。
</p></dd></dl>
<span id="index-illegal-instruction"></span>

<dl>
<dt id="index-SIGSEGV">巨集： <em>int</em> <strong>SIGSEGV</strong></dt>
<dd>
<span id="index-segmentation-violation"></span>
<p>当程序尝试在为其分配的内存之外进行读取或写入时，或仅可读取的内存中写入时，将生成此信号。（实际上，只有当程序移到足够远的距离以至于无法被系统的内存保护机制检测到时，才会出现信号。）该名称是“违反分段”的缩写。
</p>
<p>常见的获取方式<code>SIGSEGV</code>条件包括取消引用空指针或未初始化的指针，或者使用指针单步访问数组但无法检查数组结尾的条件。在不同系统之间是否会取消引用空指针<code>SIGSEGV</code>要么<code>SIGBUS</code> 。
</p></dd></dl>

<dl>
<dt id="index-SIGBUS">巨集： <em>int</em> <strong>SIGBUS</strong></dt>
<dd>
<p>当取消引用无效的指针时，将生成此信号。喜欢<code>SIGSEGV</code> ，此信号通常是取消引用未初始化指针的结果。两者之间的区别在于<code>SIGSEGV</code>表示对有效内存的无效访问，而<code>SIGBUS</code>表示对无效地址的访问。特别是， <code>SIGBUS</code>信号通常是由于取消引用未对齐的指针而导致的，例如，引用不被4整除的地址中的四字整数。（每种计算机对地址对齐都有自己的要求。）
</p>
<p>该信号的名称是“总线错误”的缩写。
</p></dd></dl>
<span id="index-bus-error"></span>

<dl>
<dt id="index-SIGABRT">巨集： <em>int</em> <strong>SIGABRT</strong></dt>
<dd>
<span id="index-abort-signal"></span>
<p>该信号表示程序本身检测到错误，并通过调用报告<code>abort</code> 。请参阅<a href="Aborting-a-Program.html#Aborting-a-Program">中止程序</a> 。
</p></dd></dl>

<dl>
<dt id="index-SIGIOT">巨集： <em>int</em> <strong>SIGIOT</strong></dt>
<dd>
<p>由PDP-11“ iot”指令生成。在大多数机器上，这只是<code>SIGABRT</code> 。
</p></dd></dl>

<dl>
<dt id="index-SIGTRAP">巨集： <em>int</em> <strong>SIGTRAP</strong></dt>
<dd>
<p>由计算机的断点指令以及可能的其他陷阱指令生成。该信号由调试器使用。您的程序可能只会看到<code>SIGTRAP</code>如果以某种方式执行错误的指令。
</p></dd></dl>

<dl>
<dt id="index-SIGEMT">巨集： <em>int</em> <strong>SIGEMT</strong></dt>
<dd>
<p>仿真器陷阱；这是由于某些未实现的指令（可能在软件中进行了仿真）或操作系统未能正确地对其进行仿真而导致的。
</p></dd></dl>

<dl>
<dt id="index-SIGSYS">巨集： <em>int</em> <strong>SIGSYS</strong></dt>
<dd>
<p>系统调用错误；也就是说，执行了捕获到操作系统的指令，但是系统调用要执行的代码号无效。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Termination-Signals.html#Termination-Signals" rel="next" accesskey="n">终端信号</a> ，上一篇： <a href="Standard-Signals.html#Standard-Signals" rel="up" accesskey="u">标准信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>