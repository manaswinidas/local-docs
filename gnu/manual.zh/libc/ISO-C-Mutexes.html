<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ISO C互斥体（GNU C库）</title>

<meta name="description" content="ISO C Mutexes (The GNU C Library)">
<meta name="keywords" content="ISO C Mutexes (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="ISO-C-Threads.html#ISO-C-Threads" rel="up" title="ISO C Threads">
<link href="ISO-C-Condition-Variables.html#ISO-C-Condition-Variables" rel="next" title="ISO C Condition Variables">
<link href="Call-Once.html#Call-Once" rel="prev" title="Call Once">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="ISO-C-Mutexes"></span><div class="header">
<p>下一篇： <a href="ISO-C-Condition-Variables.html#ISO-C-Condition-Variables" rel="next" accesskey="n">ISO C条件变量</a> ，上一篇： <a href="Call-Once.html#Call-Once" rel="prev" accesskey="p">调用一次</a> ，上一篇： <a href="ISO-C-Condition-Variables.html#ISO-C-Condition-Variables" rel="next" accesskey="n">ISO C</a> <a href="ISO-C-Threads.html#ISO-C-Threads" rel="up" accesskey="u">线程</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Mutexes"></span><h4 class="subsection">35.1.4互斥</h4>
<span id="index-mutex"></span>
<span id="index-mutual-exclusion"></span>

<p>为了更好地控制资源以及线程如何访问它们，GNU C库实现了一个<em>互斥</em>对象，这可以帮助避免竞争条件和其他并发问题。术语“互斥体”是指相互排斥。
</p>
<p>互斥锁的基本数据类型是<code>mtx_t</code> ：</p>
<dl>
<dt id="index-mtx_005ft">数据类型： <strong>mtx_t</strong></dt>
<dd>
<p>的<code>mtx_t</code>数据类型唯一地标识一个互斥对象。
</p></dd></dl>

<p>ISO C标准定义了几种互斥类型。它们由以下符号常量表示：</p>
<dl compact>
<dt><code>mtx_plain</code>
<span id="index-mtx_005fplain"></span>
</dt>
<dd>
<p>不支持超时或测试并返回的互斥量。
</p>
</dd>
<dt><code>mtx_recursive</code>
<span id="index-mtx_005frecursive"></span>
</dt>
<dd>
<p>一个支持递归锁定的互斥锁，这意味着拥有线程可以多次锁定它而不会导致死锁。
</p>
</dd>
<dt><code>mtx_timed</code>
<span id="index-mtx_005ftimed"></span>
</dt>
<dd>
<p>支持超时的互斥锁。
</p></dd>
</dl>

<p>以下功能用于处理互斥锁：</p>
<dl>
<dt id="index-mtx_005finit">函数： <em>int</em> <strong>mtx_init</strong> <em>（mtx_t * <var>mutex</var> ，int <var>type</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_init</code>用类型创建一个新的互斥对象<var>type</var> 。指向的对象<var>mutex</var>设置为新创建的互斥锁的标识符。
</p>
<p>并非互斥体类型的所有组合都对<code>type</code>论点。有效使用互斥锁类型<code>type</code>参数是：</p>
<dl compact>
<dt><code>mtx_plain</code></dt>
<dd><p>一种不支持超时的非递归互斥体。
</p>
</dd>
<dt><code>mtx_timed</code></dt>
<dd><p>一种不支持超时的非递归互斥体。
</p>
</dd>
<dt><code>mtx_plain | mtx_recursive</code></dt>
<dd><p>不支持超时的递归互斥体。
</p>
</dd>
<dt><code>mtx_timed | mtx_recursive</code></dt>
<dd><p>一个不支持超时的递归互斥体。
</p></dd>
</dl>

<p>该函数返回<code>thrd_success</code>要么<code>thrd_error</code> 。
</p></dd></dl>

<dl>
<dt id="index-mtx_005flock">函数： <em>int</em> <strong>mtx_lock</strong> <em>（mtx_t * <var>mutex</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_lock</code>阻塞当前线程，直到由指向的互斥锁为止<var>mutex</var>被锁住了。如果当前线程已经锁定了互斥锁并且该互斥锁不是递归的，则该行为是不确定的。
</p>
<p>事先致电<code>mtx_unlock</code>在同一互斥锁上与该操作同步（如果此操作成功），并且任何给定互斥锁上的所有锁定/解锁操作都形成一个总顺序（类似于原子的修改顺序）。
</p>
<p>该函数返回<code>thrd_success</code>要么<code>thrd_error</code> 。
</p></dd></dl>

<dl>
<dt id="index-mtx_005ftimedlock">函数： <em>int</em> <strong>mtx_timedlock</strong> <em>（mtx_t * restrict <var>mutex</var> ，const struct timespec * restrict <var>time_point</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_timedlock</code>阻塞当前线程，直到由指向的互斥锁为止<var>mutex</var>已锁定或直到由指向的日历时间<var>time_point</var>已经达到。由于此功能需要绝对时间，因此如果需要持续时间，则必须手动计算日历时间。请参阅<a href="Time-Basics.html#Time-Basics">时间基础</a>和<a href="Calendar-Time.html#Calendar-Time">日历时间</a> 。
</p>
<p>如果当前线程已经锁定了互斥锁，并且该互斥锁不是递归的，或者如果该互斥锁不支持超时，则此函数的行为是不确定的。
</p>
<p>事先致电<code>mtx_unlock</code>在同一互斥锁上与该操作同步（如果此操作成功），并且任何给定互斥锁上的所有锁定/解锁操作都形成一个总顺序（类似于原子的修改顺序）。
</p>
<p>该函数返回<code>thrd_success</code>要么<code>thrd_error</code> 。
</p></dd></dl>

<dl>
<dt id="index-mtx_005ftrylock">函数： <em>int</em> <strong>mtx_trylock</strong> <em>（mtx_t * <var>mutex</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_trylock</code>尝试锁定由指向的互斥锁<var>mutex</var>没有阻碍。如果互斥锁已被锁定，它将立即返回。
</p>
<p>事先致电<code>mtx_unlock</code>在同一互斥锁上与该操作同步（如果此操作成功），并且任何给定互斥锁上的所有锁定/解锁操作都形成一个总顺序（类似于原子的修改顺序）。
</p>
<p>该函数返回<code>thrd_success</code>如果获得了锁， <code>thrd_busy</code>如果互斥锁已经被锁定，并且<code>thrd_error</code>失败。
</p></dd></dl>

<dl>
<dt id="index-mtx_005funlock">函数： <em>int</em> <strong>mtx_unlock</strong> <em>（mtx_t * <var>mutex</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_unlock</code>解锁由指向的互斥锁<var>mutex</var> 。如果互斥对象未被调用线程锁定，则该行为是不确定的。
</p>
<p>此功能与后续同步<code>mtx_lock</code> ， <code>mtx_trylock</code>和<code>mtx_timedlock</code>调用同一个互斥锁。任何给定互斥锁上的所有锁定/解锁操作都形成一个总顺序（类似于原子的修改顺序）。
</p>
<p>该函数返回<code>thrd_success</code>要么<code>thrd_error</code> 。
</p></dd></dl>

<dl>
<dt id="index-mtx_005fdestroy">函数： <em>void</em> <strong>mtx_destroy</strong> <em>（mtx_t * <var>mutex</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>mtx_destroy</code>销毁由指向的互斥锁<var>mutex</var> 。如果互斥锁上有任何线程在等待，则行为是不确定的。
</p></dd></dl>


<hr>
<div class="header">
<p>下一篇： <a href="ISO-C-Condition-Variables.html#ISO-C-Condition-Variables" rel="next" accesskey="n">ISO C条件变量</a> ，上一篇： <a href="Call-Once.html#Call-Once" rel="prev" accesskey="p">调用一次</a> ，上一篇： <a href="ISO-C-Condition-Variables.html#ISO-C-Condition-Variables" rel="next" accesskey="n">ISO C</a> <a href="ISO-C-Threads.html#ISO-C-Threads" rel="up" accesskey="u">线程</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>