<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>文件大小（GNU C库）</title>

<meta name="description" content="File Size (The GNU C Library)">
<meta name="keywords" content="File Size (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="File-Attributes.html#File-Attributes" rel="up" title="File Attributes">
<link href="Storage-Allocation.html#Storage-Allocation" rel="next" title="Storage Allocation">
<link href="File-Times.html#File-Times" rel="prev" title="File Times">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="File-Size"></span><div class="header">
<p>下一个： <a href="Storage-Allocation.html#Storage-Allocation" rel="next" accesskey="n">存储分配</a> ，上一个： <a href="File-Times.html#File-Times" rel="prev" accesskey="p">文件时间</a> ，上： <a href="File-Attributes.html#File-Attributes" rel="up" accesskey="u">文件属性</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="File-Size-1"></span><h4 class="subsection">14.9.10文件大小</h4>

<p>通常，文件大小是自动维护的。文件以<em>0</em>开头，写入数据超过末尾时会自动扩展。也可以用<code>open</code>要么<code>fopen</code>呼叫。
</p>
<p>但是，有时有必要<em>减小</em>文件的大小。这可以通过<code>truncate</code>和<code>ftruncate</code>功能。它们是在BSD Unix中引入的。 <code>ftruncate</code>后来被添加到POSIX.1中。
</p>
<p>某些系统允许您使用这些功能扩展文件（创建孔）。当使用内存映射的I / O（请参阅<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存映射的I / O</a> ）时，该功能不会自动扩展文件。但是，它不是可移植的，但必须在以下情况下实现<code>mmap</code>允许映射文件（即， <code>_POSIX_MAPPED_FILES</code>被定义为）。
</p>
<p>在常规文件以外的任何其他文件上使用这些功能会产生<em>不确定的</em>结果。在许多系统上，这样的调用似乎会成功完成，而实际上并没有完成任何事情。
</p>
<dl>
<dt id="index-truncate">函数： <em>int</em> <strong>truncate</strong> <em>（const char * <var>filename</var> ，off_t <var>length</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>truncate</code>函数更改大小<var>filename</var>至<var>length</var> 。如果<var>length</var>小于先前的长度，最后的数据将丢失。用户必须可写该文件才能执行此操作。
</p>
<p>如果<var>length</var>更长，孔将被添加到末端。但是，某些系统不支持此功能，因此文件将保持不变。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>truncate</code>功能其实<code>truncate64</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值为<em>0（</em>表示成功）或<em>-1</em> （表示错误）。除了通常的文件名错误外，还可能发生以下错误：</p>
<dl compact>
<dt><code>EACCES</code></dt>
<dd><p>该文件是目录或不可写。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>length</var>是负面的。
</p>
</dd>
<dt><code>EFBIG</code></dt>
<dd><p>该操作会将文件扩展到操作系统的限制之外。
</p>
</dd>
<dt><code>EIO</code></dt>
<dd><p>发生硬件I / O错误。
</p>
</dd>
<dt><code>EPERM</code></dt>
<dd><p>该文件是“仅追加”或“不可变的”。
</p>
</dd>
<dt><code>EINTR</code></dt>
<dd><p>该操作被信号中断。
</p>
</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-truncate64">函数： <em>int</em> <strong>truncate64</strong> <em>（const char * <var>name</var> ，off64_t <var>length</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>truncate</code>功能。区别在于<var>length</var>参数即使在32位计算机上也为64位宽，这允许处理最大2 ^ 63字节的文件。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能实际上在名称下可用<code>truncate</code>因此透明地替换了32位接口。
</p></dd></dl>

<dl>
<dt id="index-ftruncate">函数： <em>int</em> <strong>ftruncate</strong> <em>（int <var>fd</var> ，off_t <var>length</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>就像<code>truncate</code> ，但它适用于文件描述符<var>fd</var>用于打开的文件而不是用于标识对象的文件名。必须打开文件进行写入，才能成功执行操作。
</p>
<p>POSIX标准让其实现定义了如果指定新<var>length</var>文件的大小大于原始大小。的<code>ftruncate</code>函数可能会简单地将文件保留而不做任何事情，或者可能会将文件大小增加到所需的大小。在此后一种情况下，扩展区域应为零填充。所以用<code>ftruncate</code>这不是增加文件大小的可靠方法，但如果可能的话，这可能是最快的方法。如果这些是由系统实现的，该功能还可以在POSIX共享内存段上运行。
</p>
<p><code>ftruncate</code>与结合使用特别有用<code>mmap</code> 。由于映射的区域必须具有固定的大小，因此无法通过写入超出最后一个映射页面的内容来扩大文件。相反，必须先放大文件本身，然后以新的大小重新映射文件。下面的示例显示了它是如何工作的。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>ftruncate</code>功能其实<code>ftruncate64</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值为<em>0（</em>表示成功）或<em>-1</em> （表示错误）。可能会发生以下错误：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p><var>fd</var>与打开的文件不对应。
</p>
</dd>
<dt><code>EACCES</code></dt>
<dd><p><var>fd</var>是目录或未打开以供写入。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>length</var>是负面的。
</p>
</dd>
<dt><code>EFBIG</code></dt>
<dd><p>该操作会将文件扩展到操作系统的限制之外。
</p>
</dd>
<dt><code>EIO</code></dt>
<dd><p>发生硬件I / O错误。
</p>
</dd>
<dt><code>EPERM</code></dt>
<dd><p>该文件是“仅追加”或“不可变的”。
</p>
</dd>
<dt><code>EINTR</code></dt>
<dd><p>该操作被信号中断。
</p>

</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-ftruncate64">函数： <em>int</em> <strong>ftruncate64</strong> <em>（int <var>id</var> ，off64_t <var>length</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>ftruncate</code>功能。区别在于<var>length</var>即使在32位计算机上，参数也是64位宽，这允许处理最大2 ^ 63字节的文件。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，此功能实际上在名称下可用<code>ftruncate</code>因此透明地替换了32位接口。
</p></dd></dl>

<p>正如这里所宣布的，这是一个如何使用的小例子<code>ftruncate</code>与...结合<code>mmap</code> ：</p>
<div class="example">
<pre class="example">int fd;
void *start;
size_t len;

int
add (off_t at, void *block, size_t size)
{
  if (at + size &gt; len)
    {
      /* Resize the file and remap.  */
      size_t ps = sysconf (_SC_PAGESIZE);
      size_t ns = (at + size + ps - 1) &amp; ~(ps - 1);
      void *np;
      if (ftruncate (fd, ns) &lt; 0)
        return -1;
      np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
      if (np == MAP_FAILED)
        return -1;
      start = np;
      len = ns;
    }
  memcpy ((char *) start + at, block, size);
  return 0;
}
</pre></div>

<p>功能<code>add</code>在文件中的任意位置写入一个内存块。如果文件的当前大小太小，则将其扩展。请注意，它扩展了整个页面数。这是一个要求<code>mmap</code> 。该程序必须跟踪实际大小，以及何时完成最终<code>ftruncate</code>调用应设置文件的实际大小。
</p>
<hr>
<div class="header">
<p>下一个： <a href="Storage-Allocation.html#Storage-Allocation" rel="next" accesskey="n">存储分配</a> ，上一个： <a href="File-Times.html#File-Times" rel="prev" accesskey="p">文件时间</a> ，上： <a href="File-Attributes.html#File-Attributes" rel="up" accesskey="u">文件属性</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>