<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>绝对优先级（GNU C库）</title>

<meta name="description" content="Absolute Priority (The GNU C Library)">
<meta name="keywords" content="Absolute Priority (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Priority.html#Priority" rel="up" title="Priority">
<link href="Realtime-Scheduling.html#Realtime-Scheduling" rel="next" title="Realtime Scheduling">
<link href="Priority.html#Priority" rel="prev" title="Priority">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Absolute-Priority"></span><div class="header">
<p>下一篇： <a href="Realtime-Scheduling.html#Realtime-Scheduling" rel="next" accesskey="n">实时计划</a> ，上一篇： <a href="Priority.html#Priority" rel="up" accesskey="u">优先级</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Absolute-Priority-1"></span><h4 class="subsection">22.3.1绝对优先级</h4>
<span id="index-absolute-priority"></span>
<span id="index-priority_002c-absolute"></span>

<p>每个进程都具有绝对优先级，并且由数字表示。数字越高，绝对优先级越高。
</p>
<span id="index-realtime-CPU-scheduling"></span>
<p>在过去的系统和当今的大多数系统上，所有进程的绝对优先级均为0，因此本节无关紧要。在这种情况下，请参阅<a href="Traditional-Scheduling.html#Traditional-Scheduling">传统计划</a> 。发明了绝对优先级以适应实时系统，其中至关重要的是某些进程能够实时响应外部事件，这意味着它们无法等待其他进程<em>想要</em>等待但又<em>不需要</em>运行占用CPU。</p>
<span id="index-ready-to-run"></span>
<span id="index-preemptive-scheduling"></span>
<p>当有两个进程争夺在任何时候使用CPU时，绝对优先级较高的进程总是会得到它。即使具有较低优先级的进程已经在使用CPU（即，调度是抢占式的），也是如此。当然，我们只是在谈论正在运行或“准备运行”的流程，这意味着它们已准备好立即执行指令。当一个进程阻塞等待诸如I / O之类的东西时，它的绝对优先级是无关紧要的。
</p>
<span id="index-runnable-process"></span>
<p><strong>注意：</strong> “可运行”一词是“准备运行”的同义词。
</p>
<p>当两个进程正在运行或准备运行并且都具有相同的绝对优先级时，这会更有趣。在那种情况下，谁获取CPU由调度策略决定。如果进程具有绝对的优先权0中描述的传统的调度策略<a href="Traditional-Scheduling.html#Traditional-Scheduling">传统的调度</a>应用。否则，将应用“ <a href="Realtime-Scheduling.html#Realtime-Scheduling">实时调度”中</a>描述的策略。
</p>
<p>通常，您只将绝对优先级设置为大于0的绝对优先级，否则该进程可以被信任不占用CPU。此类进程旨在在较短的CPU运行后阻塞（或终止）。
</p>
<p>进程以与其父进程相同的绝对优先级开始生命。<a href="Basic-Scheduling-Functions.html#Basic-Scheduling-Functions">基本计划</a>功能中描述的<a href="Basic-Scheduling-Functions.html#Basic-Scheduling-Functions">功能</a>可以对其进行更改。
</p>
<p>只有特权进程才能将进程的绝对优先级更改为除<code>0</code> 。只有特权进程或目标进程的所有者才能更改其绝对优先级。
</p>
<p>POSIX要求与实时调度策略一起使用的绝对优先级值必须连续，且范围至少为32。在Linux上，它们是1到99。功能<code>sched_get_priority_max</code>和<code>sched_set_priority_min</code>可移植地告诉您特定系统上的范围。
</p>

<span id="Using-Absolute-Priority"></span><h4 class="subsubsection">22.3.1.1使用绝对优先级</h4>

<p>设计实时应用程序时必须牢记的一件事是，绝对优先级比任何其他进程都要高，这不能保证该进程可以连续运行。可能破坏良好CPU运行的两件事是中断和页面错误。
</p>
<p>中断处理程序处于进程之间的困境中。CPU正在执行指令，但它们不是任何进程的一部分。中断甚至将停止最高优先级的进程。因此，您必须允许稍有延迟，并确保系统中没有任何设备具有中断处理程序，该中断处理程序可能会导致处理指令之间的延迟过长。
</p>
<p>同样，页面错误会导致看起来很简单的指令序列花费很长时间。页面错误进入时其他进程可以运行的事实无关紧要，因为一旦I / O完成，较高优先级的进程将把它们踢出并再次运行，但是等待I / O本身可能是个问题。要消除这种威胁，请使用<code>mlock</code>要么<code>mlockall</code> 。
</p>
<p>在选择设置优先级时以及在运行具有绝对优先级高的程序时，需要牢记此优先级在单CPU系统上的绝对性。考虑一个绝对优先级高于系统中其他任何进程的进程，由于其程序中的错误，该进程陷入了无限循环。它永远不会让出CPU。您无法运行命令将其杀死，因为您的命令需要获得CPU才能运行。错误的程序完全受控。它控制垂直，它控制水平。
</p>
<p>有两种方法可以避免这种情况：1）使外壳运行在具有更高绝对优先级的位置，或者2）使控制终端连接到高优先级进程组。如果您按Control-C，则世界上所有优先级都不会阻止中断处理程序运行并向该进程传递信号。</p>
<p>一些系统使用绝对优先级作为将固定百分比的CPU时间分配给进程的一种方式。为此，超高优先级特权进程会不断监视进程的CPU使用率，并在进程未获得其授权份额时提高其绝对优先级，并在进程超出其优先级时降低其绝对优先级。
</p>
<p><strong>注意：</strong>绝对优先级有时称为“静态优先级”。我们在本手册中不使用该术语，因为它错过了绝对优先级的最重要特征：绝对性。
</p>

<hr>
<div class="header">
<p>下一篇： <a href="Realtime-Scheduling.html#Realtime-Scheduling" rel="next" accesskey="n">实时计划</a> ，上一篇： <a href="Priority.html#Priority" rel="up" accesskey="u">优先级</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>