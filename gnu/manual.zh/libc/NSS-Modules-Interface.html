<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>NSS模块接口（GNU C库）</title>

<meta name="description" content="NSS Modules Interface (The GNU C Library)">
<meta name="keywords" content="NSS Modules Interface (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="NSS-Module-Internals.html#NSS-Module-Internals" rel="up" title="NSS Module Internals">
<link href="Extending-NSS.html#Extending-NSS" rel="next" title="Extending NSS">
<link href="NSS-Module-Names.html#NSS-Module-Names" rel="prev" title="NSS Module Names">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="NSS-Modules-Interface"></span><div class="header">
<p>上一页： <a href="NSS-Module-Names.html#NSS-Module-Names" rel="prev" accesskey="p">NSS模块名称</a> ，向上： <a href="NSS-Module-Internals.html#NSS-Module-Internals" rel="up" accesskey="u">NSS模块内部</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="The-Interface-of-the-Function-in-NSS-Modules"></span><h4 class="subsection">29.3.2 NSS模块中功能的接口</h4>

<p>现在我们知道了模块中包含的功能。现在是时候描述类型了。当我们提到上述函数的可重入版本时，这意味着还有一些其他参数（与标准的非可重入版本相比）。上述函数的非可重入和可重入版本的原型为：</p>
<div class="example">
<pre class="example">struct hostent *gethostbyname (const char *name)

int gethostbyname_r (const char *name, struct hostent *result_buf,
                     char *buf, size_t buflen, struct hostent **result,
                     int *h_errnop)
</pre></div>

<p>在这种情况下，NSS模块中功能的实际原型为</p>
<div class="example">
<pre class="example">enum nss_status _nss_files_gethostbyname_r (const char *name,
                                            struct hostent *result_buf,
                                            char *buf, size_t buflen,
                                            int *errnop, int *h_errnop)
</pre></div>

<p>即，接口函数实际上是可重入函数，它具有返回值的更改，而省略了<var>result</var>参数，以及<var>errnop</var>参数。当用户级别的函数返回指向结果的指针时，可重入函数返回一个<code>enum nss_status</code>值：</p>
<dl compact>
<dt><code>NSS_STATUS_TRYAGAIN</code>
<span id="index-NSS_005fSTATUS_005fTRYAGAIN"></span>
</dt>
<dd><p>数值<code>-2</code>
</p>
</dd>
<dt><code>NSS_STATUS_UNAVAIL</code>
<span id="index-NSS_005fSTATUS_005fUNAVAIL"></span>
</dt>
<dd><p>数值<code>-1</code>
</p>
</dd>
<dt><code>NSS_STATUS_NOTFOUND</code>
<span id="index-NSS_005fSTATUS_005fNOTFOUND"></span>
</dt>
<dd><p>数值<code>0</code>
</p>
</dd>
<dt><code>NSS_STATUS_SUCCESS</code>
<span id="index-NSS_005fSTATUS_005fSUCCESS"></span>
</dt>
<dd><p>数值<code>1</code>
</p></dd>
</dl>

<p>现在您将看到<samp>/etc/nsswitch.conf</samp>文件被使用。
</p>
<p>如果您研究源代码，则会发现第五个值： <code>NSS_STATUS_RETURN</code> 。这是仅供内部使用的值，在无法使用上述值的地方，一些功能使用了该值。如有必要，应检查源代码以了解详细信息。
</p>
<p>如果接口函数必须返回错误，则必须在其中存储正确的错误代码，这一点很重要<code>*<var>errnop</var></code> 。一些返回状态值只有一个关联的错误代码，而其他的则有更多。
</p>
<table>
<tbody><tr><td width="30%"><code>NSS_STATUS_TRYAGAIN</code></td><td width="20%"><code>EAGAIN</code></td><td width="50%">使用的功能之一暂时资源不足或服务当前不可用。</td></tr>
<tr><td width="30%"></td><td width="20%"><code>ERANGE</code></td><td width="50%">提供的缓冲区不够大。应该使用更大的缓冲区再次调用该函数。</td></tr>
<tr><td width="30%"><code>NSS_STATUS_UNAVAIL</code></td><td width="20%"><code>ENOENT</code></td><td width="50%">找不到必要的输入文件。</td></tr>
<tr><td width="30%"><code>NSS_STATUS_NOTFOUND</code></td><td width="20%"><code>ENOENT</code></td><td width="50%">请求的条目不可用。</td></tr>
<tr><td width="30%"><code>NSS_STATUS_NOTFOUND</code></td><td width="20%"><code>SUCCESS</code></td><td width="50%">没有条目。使用此选项可避免返回非活动服务的错误，该错误可能在以后启用。这与暂时不可用的服务不同。</td></tr>
</tbody></table>

<p>这些是建议值。可能还有其他错误代码，并且所描述的错误代码可能具有不同的含义。<strong>有一个例外：</strong>返回时<code>NSS_STATUS_TRYAGAIN</code>错误代码<code>ERANGE</code> <em>必须</em>表示用户提供的缓冲区太小。其他所有都不重要。
</p>
<p>在静态链接程序中，主应用程序和NSS模块不共享相同的线程局部变量<code>errno</code> ，这就是为什么有一个明确的<var>errnop</var>函数参数。
</p>
<p>上面的功能有一些特殊之处，几乎所有其他模块功能都缺少。有一个争论<var>h_errnop</var> 。这指向一个变量，如果由于某种原因该函数执行失败，该变量将填充有错误代码。（在静态链接程序中，线程局部变量<code>h_errno</code>与主应用程序不共享。）
</p>
<p>的<code>get<var>XXX</var>by<var>YYY</var></code>功能是NSS模块中最重要的功能。但是还有其他实现其他方式访问系统数据库的方法（例如，对于用户数据库， <code>setpwent</code> ， <code>getpwent</code>和<code>endpwent</code> ）。这些将在后面更详细地描述。在这里，我们给出确定模块功能签名的一般方法：</p>
<ul>
<li>返回值是<code>enum nss_status</code> ;</li><li>名称（请参阅<a href="NSS-Module-Names.html#NSS-Module-Names">NSS模块名称</a> ）；</li><li>第一个参数与非可重入函数的参数相同；</li><li>接下来的四个参数是：<dl compact>
<dt><code>STRUCT_TYPE *result_buf</code></dt>
<dd><p>指向存储结果的缓冲区的指针。 <code>STRUCT_TYPE</code>通常是对应于数据库的结构。
</p></dd>
<dt><code>char *buffer</code></dt>
<dd><p>指向缓冲区的指针，函数可以在其中存储结果的其他数据等。</p></dd>
<dt><code>size_t buflen</code></dt>
<dd><p>指向的缓冲区的长度<var>buffer</var> 。
</p></dd>
<dt><code>int *errnop</code></dt>
<dd><p>低级错误代码以返回到应用程序。如果返回值不是<code>NSS_STATUS_SUCCESS</code> ， <code>*<var>errnop</var></code>需要设置为非零值。NSS模块绝不能设置<code>*<var>errnop</var></code>归零。价值<code>ERANGE</code>如上所述，它是特殊的。
</p></dd>
</dl>

</li><li>可能是最后一个争论<var>h_errnop</var> ，用于主机名和网络名称查找功能。如果返回值不是<code>NSS_STATUS_SUCCESS</code> ， <code>*<var>h_errnop</var></code>需要设置为非零值。通用错误代码是<code>NETDB_INTERNAL</code> ，指示呼叫者进行检查<code>*<var>errnop</var></code>有关更多详细信息。（这包括<code>ERANGE</code>特殊情况。）
</li></ul>

<p>该表适用于所有功能，但<code>set…ent</code>和<code>end…ent</code>功能。
</p>

<hr>
<div class="header">
<p>上一页： <a href="NSS-Module-Names.html#NSS-Module-Names" rel="prev" accesskey="p">NSS模块名称</a> ，向上： <a href="NSS-Module-Internals.html#NSS-Module-Internals" rel="up" accesskey="u">NSS模块内部</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>