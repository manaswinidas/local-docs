<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>内存分配探针（GNU C库）</title>

<meta name="description" content="Memory Allocation Probes (The GNU C Library)">
<meta name="keywords" content="Memory Allocation Probes (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Internal-Probes.html#Internal-Probes" rel="up" title="Internal Probes">
<link href="Mathematical-Function-Probes.html#Mathematical-Function-Probes" rel="next" title="Mathematical Function Probes">
<link href="Internal-Probes.html#Internal-Probes" rel="prev" title="Internal Probes">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Memory-Allocation-Probes"></span><div class="header">
<p>下一篇： <a href="Mathematical-Function-Probes.html#Mathematical-Function-Probes" rel="next" accesskey="n">数学函数探针</a> ，上一篇： <a href="Internal-Probes.html#Internal-Probes" rel="up" accesskey="u">内部探针</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Memory-Allocation-Probes-1"></span><h3 class="section">36.1内存分配探针</h3>

<p>这些探针旨在指示GNU C库的虚拟内存子系统中相对不寻常的情况。
</p>
<dl>
<dt id="index-memory_005fsbrk_005fmore">探针： <strong>memory_sbrk_more</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>通过调用扩展主竞技场后触发此探测<code>sbrk</code> 。争论<var>$arg1</var>是要求的额外尺寸<code>sbrk</code>和<var>$arg2</var>是标记结束的指针<code>sbrk</code>区域，以响应请求返回。</p></dd></dl>

<dl>
<dt id="index-memory_005fsbrk_005fless">探针： <strong>memory_sbrk_less</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>通过调用以下方法减小主舞台的大小后触发此探测<code>sbrk</code> 。争论<var>$arg1</var>是由释放的尺寸<code>sbrk</code> （正值，而不是传递给<code>sbrk</code> ），以及<var>$arg2</var>是标记结束的指针<code>sbrk</code>区域，以响应请求返回。</p></dd></dl>

<dl>
<dt id="index-memory_005fheap_005fnew">探测： <strong>memory_heap_new</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>在新堆被触发后触发此探针<code>mmap</code> ed。争论<var>$arg1</var>是指向存储区底部的指针， <code>heap_info</code>保持数据结构，并且<var>$arg2</var>是堆的大小。
</p></dd></dl>

<dl>
<dt id="index-memory_005fheap_005ffree">探测： <strong>memory_heap_free</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>此探针是<em>在</em>通过以下方式完全删除堆<em>之前</em>触发的（与其他sbrk和堆探针不同） <code>munmap</code> 。争论<var>$arg1</var>是指向堆的指针，并且<var>$arg2</var>是堆的大小。
</p></dd></dl>

<dl>
<dt id="index-memory_005fheap_005fmore">探测： <strong>memory_heap_more</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>探测的尾部部分<code>mmap</code> ed堆已扩展。争论<var>$arg1</var>是指向堆的指针，并且<var>$arg2</var>是堆的新大小。
</p></dd></dl>

<dl>
<dt id="index-memory_005fheap_005fless">探针： <strong>memory_heap_less</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>探测的尾部部分<code>mmap</code> ed堆被释放。争论<var>$arg1</var>是指向堆的指针，并且<var>$arg2</var>是堆的新大小。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmalloc_005fretry">探针： <strong>memory_malloc_retry</strong> <em>（size_t <var>$arg1</var> ）</em></dt>
<dt id="index-memory_005frealloc_005fretry">探针： <strong>memory_realloc_retry</strong> <em>（size_t <var>$arg1</var> ，无效* <var>$arg2</var> ）</em></dt>
<dt id="index-memory_005fmemalign_005fretry">探针： <strong>memory_memalign_retry</strong> <em>（size_t <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dt id="index-memory_005fcalloc_005fretry">探针： <strong>memory_calloc_retry</strong> <em>（size_t <var>$arg1</var> ）</em></dt>
<dd><p>当相应的函数在调用之前无法从正在使用的竞技场获取请求的内存量时，将触发这些探针<code>arena_get_retry</code>选择要在其中重试分配的备用区域。争论<var>$arg1</var>是用户请求的内存量；在里面<code>calloc</code>情况，这是从两个函数参数计算得出的总大小。在里面<code>realloc</code>案件， <var>$arg2</var>是指向要调整大小的内存区域的指针。在里面<code>memalign</code>案件， <var>$arg2</var>是用于请求的对齐方式，它可能比传递给的值更严格<code>memalign</code>功能。一种<code>memalign</code>探针也被功能使用<code>posix_memalign, valloc</code>和<code>pvalloc</code> 。
</p>
<p>请注意，参数顺序<em>不</em>匹配的相应两个参数的函数，因此，在所有这些探头的用户请求的分配大小为<var>$arg1</var> 。
</p></dd></dl>

<dl>
<dt id="index-memory_005farena_005fretry">探针： <strong>memory_arena_retry</strong> <em>（size_t <var>$arg1</var> ，无效* <var>$arg2</var> ）</em></dt>
<dd><p>该探测在<code>arena_get_retry</code> （在选择备用区域之前）（调用此功能以选择在第一次尝试中重试失败的分配的备用区域）。该探针是多余的，但在确定各种内存分配函数中的哪一个在第一次尝试时未能分配失败并不重要时，使用起来会容易得多。争论<var>$arg1</var>与功能特定的探针相同，除了必须确保更严格对齐的功能所带来的额外填充空间。争论<var>$arg2</var>是分配失败的场所。
</p></dd></dl>

<dl>
<dt id="index-memory_005farena_005fnew">探测： <strong>memory_arena_new</strong> <em>（无效* <var>$arg1</var> ，size_t <var>$arg2</var> ）</em></dt>
<dd><p>该探针在以下情况下触发<code>malloc</code>分配并初始化一个附加的竞技场（不是主竞技场），但是在将竞技场分配给正在运行的线程或插入竞技场的内部链接列表之前。竞技场的<code>malloc_state</code>内部数据结构位于<var>$arg1</var> ，其大小应足以容纳至少一个新分配的堆中<var>$arg2</var>个字节。
</p></dd></dl>

<dl>
<dt id="index-memory_005farena_005freuse">探测： <strong>memory_arena_reuse</strong> <em>（无效* <var>$arg1</var> ，无效* <var>$arg2</var> ）</em></dt>
<dd><p>该探针在以下情况下触发<code>malloc</code>刚刚选择了一个现有的竞技场以供重用，并（暂时）将其保留供专有使用。争论<var>$arg1</var>是指向新选择的竞技场的指针，并且<var>$arg2</var>是指向该线程先前使用的竞技场的指针。
</p>
<p>这发生在<code>reused_arena</code> ，在探针中提到的互斥锁之后<code>memory_arena_reuse_wait</code>获得；论点<var>$arg1</var>将指向同一个竞技场。在这种配置下，每个线程通常只会发生一次。唯一的例外是，当线程首先选择主竞技场，但随后的分配失败时：只有在那时，我们才能切换到另一个竞技场重试该分配，并在该线程内进行进一步的分配。
</p></dd></dl>

<dl>
<dt id="index-memory_005farena_005freuse_005fwait">探测： <strong>memory_arena_reuse_wait</strong> <em>（无效* <var>$arg1</var> ，无效* <var>$arg2</var> ，无效* <var>$arg3</var> ）</em></dt>
<dd><p>该探针在以下情况下触发<code>malloc</code>即将等待竞技场可供重用。争论<var>$arg1</var>持有指向线程要等待的互斥的指针， <var>$arg2</var>是指向要重新使用的新选择竞技场的指针，并且<var>$arg3</var>是指向该线程先前使用的竞技场的指针。
</p>
<p>这发生在<code>reused_arena</code> ，当线程首先尝试分配内存或在无法从主区域分配内存后需要重试时，则没有任何可用区域，达到了最大区域数量，并选择了一个现有区域进行重用，但是它的互斥体无法立即获得。互斥中<var>$arg1</var>是所选区域的互斥量。
</p></dd></dl>

<dl>
<dt id="index-memory_005farena_005freuse_005ffree_005flist">探测： <strong>memory_arena_reuse_free_list</strong> <em>（无效* <var>$arg1</var> ）</em></dt>
<dd><p>该探针在以下情况下触发<code>malloc</code>已在空闲列表中选择了一个竞技场，供线程使用， <code>get_free_list</code>功能。争论<var>$arg1</var>持有指向所选竞技场的指针。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt">探针： <strong>memory_mallopt</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探针在功能启动时触发<code>mallopt</code>被称为改变<code>malloc</code>内部配置参数，然后再进行任何参数更改。论点<var>$arg1</var>和<var>$arg2</var>是那些传递给<code>mallopt</code>功能。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005fmxfast">探针： <strong>memory_mallopt_mxfast</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_MXFAST</code> ，并且请求的值在可接受的范围内。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是这个的先前值<code>malloc</code>参数。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005ftrim_005fthreshold">探针： <strong>memory_mallopt_trim_threshold</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ，int <var>$arg3</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_TRIM_THRESHOLD</code> 。争论<var>$arg1</var>是要求的值， <var>$arg2</var>是这个的先前值<code>malloc</code>参数，以及<var>$arg3</var>如果动态阈值调整已被禁用，则为非零。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005ftop_005fpad">探针： <strong>memory_mallopt_top_pad</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ，int <var>$arg3</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_TOP_PAD</code> 。争论<var>$arg1</var>是要求的值， <var>$arg2</var>是这个的先前值<code>malloc</code>参数，以及<var>$arg3</var>如果动态阈值调整已被禁用，则为非零。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005fmmap_005fthreshold">探针： <strong>memory_mallopt_mmap_threshold</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ，int <var>$arg3</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_MMAP_THRESHOLD</code> ，并且请求的值在可接受的范围内。争论<var>$arg1</var>是要求的值， <var>$arg2</var>是这个的先前值<code>malloc</code>参数，以及<var>$arg3</var>如果动态阈值调整已被禁用，则为非零。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005fmmap_005fmax">探针： <strong>memory_mallopt_mmap_max</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ，int <var>$arg3</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_MMAP_MAX</code> 。争论<var>$arg1</var>是要求的值， <var>$arg2</var>是这个的先前值<code>malloc</code>参数，以及<var>$arg3</var>如果动态阈值调整已被禁用，则为非零。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005fperturb">探针： <strong>memory_mallopt_perturb</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_PERTURB</code> 。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是这个的先前值<code>malloc</code>参数。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005farena_005ftest">探针： <strong>memory_mallopt_arena_test</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_ARENA_TEST</code> ，并且请求的值在可接受的范围内。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是这个的先前值<code>malloc</code>参数。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005farena_005fmax">探针： <strong>memory_mallopt_arena_max</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探测在<code>memory_mallopt</code>探头，当要更改的参数为<code>M_ARENA_MAX</code> ，并且请求的值在可接受的范围内。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是这个的先前值<code>malloc</code>参数。
</p></dd></dl>

<dl>
<dt id="index-memory_005fmallopt_005ffree_005fdyn_005fthresholds">探针： <strong>memory_mallopt_free_dyn_thresholds</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探针在功能启动时触发<code>free</code>决定调整动态brk / mmap阈值。争论<var>$arg1</var>和<var>$arg2</var>分别是调整后的mmap和修整阈值。
</p></dd></dl>

<dl>
<dt id="index-memory_005ftunable_005ftcache_005fmax_005fbytes">探针： <strong>memory_tunable_tcache_max_bytes</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>当<code>glibc.malloc.tcache_max</code>可调参数已设置。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是此可调参数的先前值。
</p></dd></dl>

<dl>
<dt id="index-memory_005ftunable_005ftcache_005fcount">探针： <strong>memory_tunable_tcache_count</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>当<code>glibc.malloc.tcache_count</code>可调参数已设置。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是此可调参数的先前值。
</p></dd></dl>

<dl>
<dt id="index-memory_005ftunable_005ftcache_005funsorted_005flimit">探针： <strong>memory_tunable_tcache_unsorted_limit</strong> <em>（int <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>当<code>glibc.malloc.tcache_unsorted_limit</code>可调参数已设置。争论<var>$arg1</var>是请求的值，并且<var>$arg2</var>是此可调参数的先前值。
</p></dd></dl>

<dl>
<dt id="index-memory_005ftcache_005fdouble_005ffree">探测： <strong>memory_tcache_double_free</strong> <em>（无效* <var>$arg1</var> ，int <var>$arg2</var> ）</em></dt>
<dd><p>该探针在以下情况下触发<code>free</code>确定正在释放的内存可能已经被释放，并且驻留在每个线程缓存中。请注意，由于分配的内存中剩余的随机有效负载数据与用于检测两次释放的密钥相匹配，因此触发此探测的可能性极小。该探测实际上表明发生了对tcache的昂贵的线性搜索，以寻找double free。争论<var>$arg1</var>是传递给的内存位置<code>free</code> ，参数<var>$arg2</var>是它所在的tcache容器。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Mathematical-Function-Probes.html#Mathematical-Function-Probes" rel="next" accesskey="n">数学函数探针</a> ，上一篇： <a href="Internal-Probes.html#Internal-Probes" rel="up" accesskey="u">内部探针</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>