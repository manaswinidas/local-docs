<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>启动作业（GNU C库）</title>

<meta name="description" content="Launching Jobs (The GNU C Library)">
<meta name="keywords" content="Launching Jobs (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Implementing-a-Shell.html#Implementing-a-Shell" rel="up" title="Implementing a Shell">
<link href="Foreground-and-Background.html#Foreground-and-Background" rel="next" title="Foreground and Background">
<link href="Initializing-the-Shell.html#Initializing-the-Shell" rel="prev" title="Initializing the Shell">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Launching-Jobs"></span><div class="header">
<p>下一篇： <a href="Foreground-and-Background.html#Foreground-and-Background" rel="next" accesskey="n">前景和背景</a>上一篇： <a href="Initializing-the-Shell.html#Initializing-the-Shell" rel="prev" accesskey="p">初始化Shell</a> ，上<a href="Implementing-a-Shell.html#Implementing-a-Shell" rel="up" accesskey="u">一篇</a> ： <a href="Implementing-a-Shell.html#Implementing-a-Shell" rel="up" accesskey="u">实现Shell</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Launching-Jobs-1"></span><h4 class="subsection">28.5.3启动作业</h4>
<span id="index-launching-jobs"></span>

<p>一旦外壳负责在其控制终端上执行作业控制，外壳便可以响应用户键入的命令启动作业。
</p>
<p>要在流程组中创建流程，请使用相同的<code>fork</code>和<code>exec</code> <a href="Process-Creation-Concepts.html#Process-Creation-Concepts">过程创建概念中</a>描述的功能。但是，由于涉及多个子进程，因此事情有些复杂，您必须小心以正确的顺序进行操作。否则，可能导致恶劣的比赛条件。
</p>
<p>对于如何构造流程之间的父子关系树，您有两种选择。您可以使进程组中的所有进程成为Shell进程的子进程，也可以使组中的一个进程成为该组中所有其他进程的祖先。本章中介绍的示例Shell程序使用第一种方法，因为它使记账更为简单。
</p>
<span id="index-process-group-leader"></span>
<span id="index-process-group-ID"></span>
<p>在分叉每个进程时，应通过调用以下命令将其置于新进程组中<code>setpgid</code> ;请参阅<a href="Process-Group-Functions.html#Process-Group-Functions">过程组功能</a> 。新组中的第一个流程成为其<em>流程组负责人</em> ，其流程ID成为该<em>组</em>的<em>流程组ID</em> 。
</p>
<span id="index-race-conditions_002c-relating-to-job-control"></span>
<p>该外壳还应该调用<code>setpgid</code>将其每个子流程放入新的流程组中。这是因为存在潜在的计时问题：每个子进程必须在开始执行新程序之前被放入进程组中，并且Shell依赖于该组中的所有子进程才能继续执行。如果子进程和外壳程序都调用<code>setpgid</code> ，这可以确保正确的事情发生，无论首先进入哪个过程。
</p>
<p>如果将作业作为前台作业启动，则还需要使用以下命令将新的过程组放在控制终端上的前台<code>tcsetpgrp</code> 。同样，这应该由外壳及其每个子进程完成，以避免出现竞争情况。
</p>
<p>每个子进程应该做的下一件事是重置其信号操作。
</p>
<p>在初始化期间，shell进程将其自身设置为忽略作业控制信号。请参阅<a href="Initializing-the-Shell.html#Initializing-the-Shell">初始化Shell</a> 。结果，它创建的任何子进程也会通过继承忽略这些信号。这绝对是不可取的，因此每个子进程都应将这些信号的操作明确设置为<code>SIG_DFL</code>分叉之后。
</p>
<p>由于外壳程序遵循此约定，因此应用程序可以假定它们继承了父进程对这些信号的正确处理。但是每个应用程序都有责任不弄乱停止信号的处理。禁用SUSP字符的常规解释的应用程序应为用户提供其他某种机制来停止工作。当用户调用此机制时，程序应发送一个<code>SIGTSTP</code>向流程的流程组发出信号，而不仅仅是向流程本身发出信号。请参阅发<a href="Signaling-Another-Process.html#Signaling-Another-Process">信号通知另一个进程</a> 。
</p>
<p>最后，每个子进程都应调用<code>exec</code>以正常方式。这也是应该处理标准输入和输出通道重定向的地方。有关如何执行此操作的<a href="Duplicating-Descriptors.html#Duplicating-Descriptors">说明</a> ，请参见<a href="Duplicating-Descriptors.html#Duplicating-Descriptors">复制描述符</a> 。
</p>
<p>这是示例外壳程序中负责启动程序的功能。该函数在被shell分叉后立即由每个子进程执行，并且永不返回。
</p>
<div class="example">
<pre class="example">void
launch_process (process *p, pid_t pgid,
                int infile, int outfile, int errfile,
                int foreground)
{
  pid_t pid;

  if (shell_is_interactive)
    {
      /* <span class="roman">Put the process into the process group and give the process group</span>
         <span class="roman">the terminal, if appropriate.</span>
         <span class="roman">This has to be done both by the shell and in the individual</span>
         <span class="roman">child processes because of potential race conditions.</span>  */
      pid = getpid ();
      if (pgid == 0) pgid = pid;
      setpgid (pid, pgid);
      if (foreground)
        tcsetpgrp (shell_terminal, pgid);

      /* <span class="roman">Set the handling for job control signals back to the default.</span>  */
      signal (SIGINT, SIG_DFL);
      signal (SIGQUIT, SIG_DFL);
      signal (SIGTSTP, SIG_DFL);
      signal (SIGTTIN, SIG_DFL);
      signal (SIGTTOU, SIG_DFL);
      signal (SIGCHLD, SIG_DFL);
    }

  /* <span class="roman">Set the standard input/output channels of the new process.</span>  */
  if (infile != STDIN_FILENO)
    {
      dup2 (infile, STDIN_FILENO);
      close (infile);
    }
  if (outfile != STDOUT_FILENO)
    {
      dup2 (outfile, STDOUT_FILENO);
      close (outfile);
    }
  if (errfile != STDERR_FILENO)
    {
      dup2 (errfile, STDERR_FILENO);
      close (errfile);
    }

  /* <span class="roman">Exec the new process.  Make sure we exit.</span>  */
  execvp (p-&gt;argv[0], p-&gt;argv);
  perror (&quot;execvp&quot;);
  exit (1);
}
</pre></div>

<p>如果外壳程序不是交互运行的，则此功能对进程组或信号不起作用。请记住，不执行作业控制的外壳程序必须将其所有子进程与外壳程序保持在同一进程组中。
</p>
<p>接下来，这是实际上启动完整作业的功能。创建子进程后，此函数将调用其他一些函数以将新创建的作业置于前台或后台。这些将在“ <a href="Foreground-and-Background.html#Foreground-and-Background">前景”和“背景”中</a>进行讨论。
</p>
<div class="example">
<pre class="example">void
launch_job (job *j, int foreground)
{
  process *p;
  pid_t pid;
  int mypipe[2], infile, outfile;

  infile = j-&gt;stdin;
  for (p = j-&gt;first_process; p; p = p-&gt;next)
    {
      /* <span class="roman">Set up pipes, if necessary.</span>  */
      if (p-&gt;next)
        {
          if (pipe (mypipe) &lt; 0)
            {
              perror (&quot;pipe&quot;);
              exit (1);
            }
          outfile = mypipe[1];
        }
      else
        outfile = j-&gt;stdout;

      /* <span class="roman">Fork the child processes.</span>  */
      pid = fork ();
      if (pid == 0)
        /* <span class="roman">This is the child process.</span>  */
        launch_process (p, j-&gt;pgid, infile,
                        outfile, j-&gt;stderr, foreground);
      else if (pid &lt; 0)
        {
          /* <span class="roman">The fork failed.</span>  */
          perror (&quot;fork&quot;);
          exit (1);
        }
      else
        {
          /* <span class="roman">This is the parent process.</span>  */
          p-&gt;pid = pid;
          if (shell_is_interactive)
            {
              if (!j-&gt;pgid)
                j-&gt;pgid = pid;
              setpgid (pid, j-&gt;pgid);
            }
        }

      /* <span class="roman">Clean up after pipes.</span>  */
      if (infile != j-&gt;stdin)
        close (infile);
      if (outfile != j-&gt;stdout)
        close (outfile);
      infile = mypipe[0];
    }

  format_job_info (j, &quot;launched&quot;);

  if (!shell_is_interactive)
    wait_for_job (j);
  else if (foreground)
    put_job_in_foreground (j, 0);
  else
    put_job_in_background (j, 0);
}
</pre></div>


<hr>
<div class="header">
<p>下一篇： <a href="Foreground-and-Background.html#Foreground-and-Background" rel="next" accesskey="n">前景和背景</a>上一篇： <a href="Initializing-the-Shell.html#Initializing-the-Shell" rel="prev" accesskey="p">初始化Shell</a> ，上<a href="Implementing-a-Shell.html#Implementing-a-Shell" rel="up" accesskey="u">一篇</a> ： <a href="Implementing-a-Shell.html#Implementing-a-Shell" rel="up" accesskey="u">实现Shell</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>