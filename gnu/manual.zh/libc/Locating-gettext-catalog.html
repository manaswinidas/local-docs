<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>查找gettext目录（GNU C库）</title>

<meta name="description" content="Locating gettext catalog (The GNU C Library)">
<meta name="keywords" content="Locating gettext catalog (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" title="Message catalogs with gettext">
<link href="Advanced-gettext-functions.html#Advanced-gettext-functions" rel="next" title="Advanced gettext functions">
<link href="Translation-with-gettext.html#Translation-with-gettext" rel="prev" title="Translation with gettext">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Locating-gettext-catalog"></span><div class="header">
<p>下一篇： <a href="Advanced-gettext-functions.html#Advanced-gettext-functions" rel="next" accesskey="n">先进的gettext函数</a> ，上一篇： <a href="Translation-with-gettext.html#Translation-with-gettext" rel="prev" accesskey="p">使用gettext进行翻译</a> ，上一篇： <a href="Translation-with-gettext.html#Translation-with-gettext" rel="prev" accesskey="p">使用gettext的</a> <a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">消息目录</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="How-to-determine-which-catalog-to-be-used"></span><h4 class="subsubsection">8.2.1.2如何确定要使用的目录</h4>

<p>检索给定消息的翻译的功能具有出色的简单界面。但是，要为程序用户提供仍然可以准确选择所需翻译的机会，并为程序员提供影响定位目录文件搜索方式的可能性，有一个相当复杂的底层机制可以控制所有这些工作。代码复杂，使用容易。
</p>
<p>基本上，我们要执行两个不同的任务，这些任务也可以由<code>catgets</code>功能：</p>
<ol>
<li>找到消息目录集。该软件包包含许多不同语言的文件。通常它们都存储在某个目录下的文件系统中。

<p>可以任意安装许多软件包，并且它们可以遵循不同的准则放置文件。
</p>
</li><li>相对于软件包指定的位置，必须根据用户的意愿搜索实际的翻译文件。即，对于用户选择的每种语言，程序都应该能够找到适当的文件。
</li></ol>

<p>这是规范要求的功能<code>gettext</code>这也是<code>catgets</code>功能是可以做到的。但是有一些问题尚未解决：</p>
<ul>
<li>可以使用几种不同的方式指定要使用的语言。对此没有普遍接受的标准，并且用户始终希望程序理解他/她的意思。例如，要选择德语翻译，可以写<code>de</code> ， <code>german</code> ， 要么<code>deutsch</code>该程序应始终做出相同反应。

</li><li>有时，用户的规格过于详细。例如，如果她/他指定<code>de_DE.ISO-8859-1</code>这表示使用ISO <span class="nolinebreak">8859-1</span> <!-- /@w -->字符集进行编码的德语（德语）可能无法提供与之完全匹配的消息目录。但是可能有一个目录匹配<code>de</code>并且如果机器上使用的字符集始终是ISO <span class="nolinebreak">8859-1</span> <!-- /@w --> ，则没有理由不应该使用此更高版本的消息目录。（我们将此<em>消息</em>称为<em>继承</em> 。）

</li><li>如果没有所需语言的目录，则它不一定总是依靠开发人员的语言而不会翻译任何消息的第二最佳选择。取而代之的是，用户可能能够更好地阅读另一种语言的消息，因此程序的用户应该能够定义语言的优先顺序。
</li></ul>

<p>我们可以将配置操作分为两部分：一个由程序员执行，另一个由用户执行。我们将从程序员可以使用的功能开始，因为用户配置将基于此。
</p>
<p>正如前面各节所述的功能，可以通过<em>域名</em>选择单独的消息集。这是一个简单的字符串，对于使用单独域的每个程序部分来说应该是唯一的。可以在一个程序中同时使用多个域。例如，GNU C库本身使用一个名为<code>libc</code>而使用C库的程序可以使用名为<code>foo</code> 。重要的一点是，在任何时候，只有一个域处于活动状态。通过以下功能控制。
</p>
<dl>
<dt id="index-textdomain">函数： <em>char *</em> <strong>textdomain</strong> <em>（const char * <var>domainname</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>textdomain</code>函数设置默认域，该域将在以后使用<code>gettext</code>打电话给<var>domainname</var> 。请注意<code>dgettext</code>和<code>dcgettext</code>如果<var>domainname</var>这些函数的参数不是空指针。
</p>
<p>首次致电之前<code>textdomain</code>默认域是<code>messages</code> 。这是在规范中指定的名称<code>gettext</code> API。该名称与其他任何名称一样好。任何程序都不能真正使用具有该名称的域，因为这只会导致问题。
</p>
<p>该函数返回从现在开始的值作为默认域。如果系统内存不足，则返回值为<code>NULL</code>和全局变量<code>errno</code>被设定为<code>ENOMEM</code> 。尽管返回值类型是<code>char *</code>返回字符串不得更改。它是由内部分配的<code>textdomain</code>功能。
</p>
<p>如果<var>domainname</var>参数是空指针，未设置新的默认域。而是返回当前选择的默认域。
</p>
<p>如果<var>domainname</var>参数是空字符串，默认域被重置为其初始值，该域的名称为<code>messages</code> 。由于该域使用这种可能性值得怀疑<code>messages</code>真的不应该使用。
</p></dd></dl>

<dl>
<dt id="index-bindtextdomain">函数： <em>char *</em> <strong>bindtextdomain</strong> <em>（const char * <var>domainname</var> ，const char * <var>dirname</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>bindtextdomain</code>函数可用于指定包含域消息目录的目录<var>domainname</var>不同的语言。正确地说，这是目录层次结构所在的目录。详细说明如下。
</p>
<p>对于程序员来说，重要的是要注意，程序随附的翻译必须放在目录层次结构中，例如， <samp>/foo/bar</samp> 。然后程序应该<code>bindtextdomain</code>调用以将当前程序的域绑定到此目录。因此，请确保找到目录。正确运行的程序不取决于用户设置环境变量。
</p>
<p>的<code>bindtextdomain</code>该功能可以使用多次，如果<var>domainname</var>参数是不同的，以前绑定的域不会被覆盖。
</p>
<p>如果要使用哪个程序<code>bindtextdomain</code>在某些时候使用<code>chdir</code>更改当前工作目录的功能，重要的是<var>dirname</var>字符串应为绝对路径名。否则，寻址目录可能会随时间变化。
</p>
<p>如果<var>dirname</var>参数是空指针<code>bindtextdomain</code>返回名称为该域的当前所选目录<var>domainname</var> 。
</p>
<p>的<code>bindtextdomain</code>函数返回一个指向包含所选目录名称名称的字符串的指针。字符串是在函数内部分配的，用户不能更改。如果系统在执行过程中超出核心<code>bindtextdomain</code>返回值是<code>NULL</code>和全局变量<code>errno</code>被相应地设置。
</p></dd></dl>


<hr>
<div class="header">
<p>下一篇： <a href="Advanced-gettext-functions.html#Advanced-gettext-functions" rel="next" accesskey="n">先进的gettext函数</a> ，上一篇： <a href="Translation-with-gettext.html#Translation-with-gettext" rel="prev" accesskey="p">使用gettext进行翻译</a> ，上一篇： <a href="Translation-with-gettext.html#Translation-with-gettext" rel="prev" accesskey="p">使用gettext的</a> <a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">消息目录</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>