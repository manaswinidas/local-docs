<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>操作数据库（GNU C库）</title>

<meta name="description" content="Manipulating the Database (The GNU C Library)">
<meta name="keywords" content="Manipulating the Database (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="User-Accounting-Database.html#User-Accounting-Database" rel="up" title="User Accounting Database">
<link href="XPG-Functions.html#XPG-Functions" rel="next" title="XPG Functions">
<link href="User-Accounting-Database.html#User-Accounting-Database" rel="prev" title="User Accounting Database">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Manipulating-the-Database"></span><div class="header">
<p>下一页： <a href="XPG-Functions.html#XPG-Functions" rel="next" accesskey="n">XPG功能</a> ，向上： <a href="User-Accounting-Database.html#User-Accounting-Database" rel="up" accesskey="u">用户记帐数据库</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Manipulating-the-User-Accounting-Database"></span><h4 class="subsection">30.12.1操作用户计费数据库</h4>

<p>这些函数和相应的数据结构在头文件中声明<samp>utmp.h</samp> 。
<span id="index-utmp_002eh"></span>
</p>
<dl>
<dt id="index-struct-exit_005fstatus">数据类型： <strong>struct exit_status</strong></dt>
<dd>
<p>的<code>exit_status</code>数据结构用于保存有关标记为的进程的退出状态的信息<code>DEAD_PROCESS</code>在用户计费数据库中。
</p>
<dl compact>
<dt><code>short int e_termination</code></dt>
<dd><p>进程的退出状态。
</p>
</dd>
<dt><code>short int e_exit</code></dt>
<dd><p>进程的退出状态。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-struct-utmp">数据类型： <strong>struct utmp</strong></dt>
<dd><p>的<code>utmp</code>数据结构用于保存有关用户计费数据库中条目的信息。在GNU系统上，它具有以下成员：</p>
<dl compact>
<dt><code>short int ut_type</code></dt>
<dd><p>指定登录类型；之一<code>EMPTY</code> ， <code>RUN_LVL</code> ， <code>BOOT_TIME</code> ， <code>OLD_TIME</code> ， <code>NEW_TIME</code> ， <code>INIT_PROCESS</code> ， <code>LOGIN_PROCESS</code> ， <code>USER_PROCESS</code> ， <code>DEAD_PROCESS</code>要么<code>ACCOUNTING</code> 。
</p>
</dd>
<dt><code>pid_t ut_pid</code></dt>
<dd><p>登录进程的进程ID号。
</p>
</dd>
<dt><code>char ut_line[]</code></dt>
<dd><p>tty的设备名称（不包含<samp>/dev/</samp> ）。
</p>
</dd>
<dt><code>char ut_id[]</code></dt>
<dd><p>进程的inittab ID。
</p>
</dd>
<dt><code>char ut_user[]</code></dt>
<dd><p>用户的登录名。
</p>
</dd>
<dt><code>char ut_host[]</code></dt>
<dd><p>用户登录主机的名称。
</p>
</dd>
<dt><code>struct exit_status ut_exit</code></dt>
<dd><p>标记为的进程的退出状态<code>DEAD_PROCESS</code> 。
</p>
</dd>
<dt><code>long ut_session</code></dt>
<dd><p>会话ID，用于开窗。
</p>
</dd>
<dt><code>struct timeval ut_tv</code></dt>
<dd><p>输入时间。对于类型的条目<code>OLD_TIME</code>这是系统时钟更改的时间，对于类型为<code>NEW_TIME</code>这是系统时钟设置的时间。
</p>
</dd>
<dt><code>int32_t ut_addr_v6[4]</code></dt>
<dd><p>远程主机的Internet地址。
</p></dd>
</dl>
</dd></dl>

<p>的<code>ut_type</code> ， <code>ut_pid</code> ， <code>ut_id</code> ， <code>ut_tv</code>和<code>ut_host</code>字段并非在所有系统上都可用。因此，应为这些情况准备便携式应用程序。为了帮助做到这一点<samp>utmp.h</samp>标头提供宏<code>_HAVE_UT_TYPE</code> ， <code>_HAVE_UT_PID</code> ， <code>_HAVE_UT_ID</code> ， <code>_HAVE_UT_TV</code>和<code>_HAVE_UT_HOST</code>如果相应字段可用。程序员可以通过使用以下方式处理情况<code>#ifdef</code>在程序代码中。
</p>
<p>定义了以下宏，以用作<code>ut_type</code>的成员<code>utmp</code>结构体。值是整数常量。
</p>
<dl compact>
<dt><code>EMPTY</code>
<span id="index-EMPTY"></span>
</dt>
<dd>
<p>此宏用于指示该条目不包含有效的用户记帐信息。
</p>
</dd>
<dt><code>RUN_LVL</code>
<span id="index-RUN_005fLVL"></span>
</dt>
<dd>
<p>此宏用于标识系统的运行级别。
</p>
</dd>
<dt><code>BOOT_TIME</code>
<span id="index-BOOT_005fTIME"></span>
</dt>
<dd>
<p>此宏用于标识系统启动时间。
</p>
</dd>
<dt><code>OLD_TIME</code>
<span id="index-OLD_005fTIME"></span>
</dt>
<dd>
<p>此宏用于标识系统时钟更改的时间。
</p>
</dd>
<dt><code>NEW_TIME</code>
<span id="index-NEW_005fTIME"></span>
</dt>
<dd>
<p>此宏用于标识更改系统时钟后的时间。
</p>
</dd>
<dt><code>INIT_PROCESS</code>
<span id="index-INIT_005fPROCESS"></span>
</dt>
<dd>
<p>此宏用于标识由init进程产生的进程。
</p>
</dd>
<dt><code>LOGIN_PROCESS</code>
<span id="index-LOGIN_005fPROCESS"></span>
</dt>
<dd>
<p>此宏用于标识已登录用户的会话负责人。
</p>
</dd>
<dt><code>USER_PROCESS</code>
<span id="index-USER_005fPROCESS"></span>
</dt>
<dd>
<p>此宏用于标识用户进程。
</p>
</dd>
<dt><code>DEAD_PROCESS</code>
<span id="index-DEAD_005fPROCESS"></span>
</dt>
<dd>
<p>此宏用于标识终止的进程。
</p>
</dd>
<dt><code>ACCOUNTING</code>
<span id="index-ACCOUNTING"></span>
</dt>
<dd>
<p>???
</p></dd>
</dl>

<p>的大小<code>ut_line</code> ， <code>ut_id</code> ， <code>ut_user</code>和<code>ut_host</code>数组可以使用<code>sizeof</code>操作员。
</p>
<p>许多较旧的系统具有<code>ut_tv</code>成员，一个<code>ut_time</code>成员，通常为<code>time_t</code> ，用于表示与条目关联的时间。因此，仅出于向后兼容的目的， <samp>utmp.h</samp>定义<code>ut_time</code>作为别名<code>ut_tv.tv_sec</code> 。
</p>
<dl>
<dt id="index-setutent">功能： <em>无效</em> <strong>设置</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT不安全种族：紧急情况| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能将打开用户计费数据库以开始对其进行扫描。然后你可以打电话<code>getutent</code> ， <code>getutid</code>要么<code>getutline</code>阅读条目和<code>pututline</code>写条目。
</p>
<p>如果数据库已经打开，则将输入重置为数据库的开头。
</p></dd></dl>

<dl>
<dt id="index-getutent">函数： <em>struct utmp *</em> <strong>getutent</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT不安全初始化竞赛：utent竞赛：utentbuf sig：ALRM计时器| AS不安全堆锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>getutent</code>函数从用户计费数据库中读取下一个条目。它返回指向该条目的指针，该指针是静态分配的，并且可能会被后续的调用覆盖<code>getutent</code> 。如果您想保存信息，则必须复制结构的内容，或者可以使用<code>getutent_r</code>该函数将数据存储在用户提供的缓冲区中。
</p>
<p>如果没有其他可用的条目，则返回一个空指针。
</p></dd></dl>

<dl>
<dt id="index-endutent">功能： <em>虚无</em> <strong>力</strong> <em>（void）</em></dt>
<dd>
<p>初步： MT不安全种族：紧急情况| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能关闭用户计费数据库。
</p></dd></dl>

<dl>
<dt id="index-getutid">功能： <em>struct utmp *</em> <strong>getutid</strong> <em>（const struct utmp * <var>id</var> ）</em></dt>
<dd>
<p>初步： MT不安全初始化竞赛：当前信号：ALRM计时器| AS不安全锁堆| AC不安全锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数从数据库中的当前点向前搜索匹配的条目<var>id</var> 。如果<code>ut_type</code>的成员<var>id</var>结构是其中之一<code>RUN_LVL</code> ， <code>BOOT_TIME</code> ， <code>OLD_TIME</code>要么<code>NEW_TIME</code>如果<code>ut_type</code>成员是相同的。如果<code>ut_type</code>的成员<var>id</var>结构是<code>INIT_PROCESS</code> ， <code>LOGIN_PROCESS</code> ， <code>USER_PROCESS</code>要么<code>DEAD_PROCESS</code> ，如果<code>ut_type</code>从数据库读取的条目的成员是这四个之一，并且<code>ut_id</code>成员匹配。但是，如果<code>ut_id</code>任一成员<var>id</var>结构或从数据库读取的条目为空，它检查是否<code>ut_line</code>成员匹配。如果找到匹配的条目， <code>getutid</code>返回指向该条目的指针，该指针是静态分配的，并且可能由随后的调用覆盖<code>getutent</code> ， <code>getutid</code>要么<code>getutline</code> 。如果要保存信息，则必须复制结构的内容。
</p>
<p>如果到达数据库末尾而没有匹配项，则返回空指针。
</p>
<p>的<code>getutid</code>函数可能会缓存最后读取的条目。因此，如果您正在使用<code>getutid</code>要搜索多次出现，必须在每次调用后将静态数据清零。除此以外<code>getutid</code>可以一次又一次地返回指向相同条目的指针。
</p></dd></dl>

<dl>
<dt id="index-getutline">功能： <em>struct utmp *</em> <strong>getutline</strong> <em>（const struct utmp * <var>line</var> ）</em></dt>
<dd>
<p>初步： MT不安全初始化竞赛：当前信号：ALRM计时器| AS不安全堆锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数从数据库中的当前点向前搜索，直到找到其条目<code>ut_type</code>值是<code>LOGIN_PROCESS</code>要么<code>USER_PROCESS</code> ，以及<code>ut_line</code>成员与<code>ut_line</code>的成员<var>line</var>结构体。如果找到这样的条目，则它将返回指向该条目的指针，该指针是静态分配的，并且可能被后续的对<code>getutent</code> ， <code>getutid</code>要么<code>getutline</code> 。如果要保存信息，则必须复制结构的内容。
</p>
<p>如果到达数据库末尾而没有匹配项，则返回空指针。
</p>
<p>的<code>getutline</code>函数可能会缓存最后读取的条目。因此，如果您使用<code>getutline</code>要搜索多次出现，必须在每次调用后将静态数据清零。除此以外<code>getutline</code>可以一次又一次地返回指向相同条目的指针。
</p></dd></dl>

<dl>
<dt id="index-pututline">功能： <em>struct utmp *</em> <strong>pututline</strong> <em>（const struct utmp * <var>utmp</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急信号：ALRM计时器| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>pututline</code>函数插入条目<code>*<var>utmp</var></code>在用户会计数据库中的适当位置。如果发现它不在数据库中的正确位置，则使用<code>getutid</code>搜索要插入条目的位置，但是这不会修改由返回的静态结构<code>getutent</code> ， <code>getutid</code>和<code>getutline</code> 。如果此搜索失败，则该条目将附加到数据库。
</p>
<p>的<code>pututline</code>函数将返回指向插入到用户记帐数据库中的条目副本的指针，如果无法添加该条目，则返回空指针。下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EPERM</code></dt>
<dd><p>该进程没有适当的特权；您不能修改用户计费数据库。
</p></dd>
</dl>
</dd></dl>

<p>所有的<code>get*</code>前面提到的函数将它们返回的信息存储在静态缓冲区中。在多线程程序中这可能是一个问题，因为为该请求返回的数据被另一个线程中的返回值数据覆盖。因此，GNU C库提供了三个扩展功能，这些功能可以将数据返回到用户提供的缓冲区中。
</p>
<dl>
<dt id="index-getutent_005fr">函数： <em>int</em> <strong>getutent_r</strong> <em>（结构utmp * <var>buffer</var> ，结构utmp ** <var>result</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急信号：ALRM计时器| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>getutent_r</code>相当于<code>getutent</code>功能。它从数据库返回下一个条目。但是，不是将信息存储在静态缓冲区中，而是将其存储在参数所指向的缓冲区中<var>buffer</var> 。
</p>
<p>如果调用成功，则函数返回<code>0</code>和参数所指向的指针变量<var>result</var>包含一个指向包含结果的缓冲区的指针（这很可能与该值相同<var>buffer</var> ）。如果在执行过程中出现问题<code>getutent_r</code>函数返回<code>-1</code> 。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-getutid_005fr">函数： <em>int</em> <strong>getutid_r</strong> <em>（const struct utmp * <var>id</var> ，struct utmp * <var>buffer</var> ，结构utmp ** <var>result</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急信号：ALRM计时器| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该函数检索就像<code>getutid</code>下一个与存储在其中的信息匹配的条目<var>id</var> 。但是结果存储在参数所指向的缓冲区中<var>buffer</var> 。
</p>
<p>如果成功，函数返回<code>0</code>和参数所指向的指针变量<var>result</var>包含指向结果缓冲区的指针（可能与结果相同<var>result</var> 。如果不成功，函数返回<code>-1</code> 。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-getutline_005fr">函数： <em>int</em> <strong>getutline_r</strong> <em>（const struct utmp * <var>line</var> ，struct utmp * <var>buffer</var> ，结构utmp ** <var>result</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：紧急信号：ALRM计时器| AS不安全锁| AC不安全锁fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该函数检索就像<code>getutline</code>下一个与存储在其中的信息匹配的条目<var>line</var> 。但是结果存储在参数所指向的缓冲区中<var>buffer</var> 。
</p>
<p>如果成功，函数返回<code>0</code>和参数所指向的指针变量<var>result</var>包含指向结果缓冲区的指针（可能与结果相同<var>result</var> 。如果不成功，函数返回<code>-1</code> 。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>


<p>除了用户计费数据库外，大多数系统还保留许多类似的数据库。例如，大多数系统会保留一个包含所有先前登录信息的日志文件（通常位于<samp>/etc/wtmp</samp>要么<samp>/var/log/wtmp</samp> ）。
</p>
<p>为了指定要检查的数据库，应使用以下功能。
</p>
<dl>
<dt id="index-utmpname">函数： <em>int</em> <strong>utmpname</strong> <em>（const char * <var>file</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：紧急情况| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>utmpname</code>函数将要检查的数据库的名称更改为<var>file</var> ，并关闭任何以前打开的数据库。默认<code>getutent</code> ， <code>getutid</code> ， <code>getutline</code>和<code>pututline</code>从用户记帐数据库读取和写入。
</p>
<p>以下宏定义为用作<var>file</var>参数：</p>
<dl>
<dt id="index-_005fPATH_005fUTMP">巨集： <em>char *</em> <strong>_PATH_UTMP</strong></dt>
<dd><p>此宏用于指定用户计费数据库。
</p></dd></dl>

<dl>
<dt id="index-_005fPATH_005fWTMP">巨集： <em>char *</em> <strong>_PATH_WTMP</strong></dt>
<dd><p>此宏用于指定用户记帐日志文件。
</p></dd></dl>

<p>的<code>utmpname</code>函数返回值<code>0</code>如果新名称已成功存储，并且值为<code>-1</code>表示错误。注意<code>utmpname</code>不会尝试打开数据库，因此返回值不会说明数据库是否可以成功打开。
</p></dd></dl>

<p>为了维护类似日志的数据库，GNU C库提供了以下功能：</p>
<dl>
<dt id="index-updwtmp">功能： <em>void</em> <strong>updwtmp</strong> <em>（const char * <var>wtmp_file</var> ，const struct utmp * <var>utmp</var> ）</em></dt>
<dd>
<p>初步： MT-unsafe sig：ALRM计时器| AS不安全| AC不安全fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>updwtmp</code>函数追加条目* <var>utmp</var>到由指定的数据库<var>wtmp_file</var> 。对于可能的值<var>wtmp_file</var>论点见<code>utmpname</code>功能。
</p></dd></dl>

<p><strong>可移植性注意：</strong>尽管许多操作系统提供了这些功能的子集，但它们尚未标准化。返回类型通常会有细微的差异，并且各种定义之间也存在相当大的差异<code>struct utmp</code> 。为GNU C库编程时，最好坚持使用本节中描述的功能。但是，如果您希望程序具有可移植性，请考虑使用XPG功能中所述的<a href="XPG-Functions.html#XPG-Functions">XPG功能</a> ，或者在<a href="Logging-In-and-Out.html#Logging-In-and-Out">Logging In and Out中</a>查看与BSD兼容的功能。
</p>

<hr>
<div class="header">
<p>下一页： <a href="XPG-Functions.html#XPG-Functions" rel="next" accesskey="n">XPG功能</a> ，向上： <a href="User-Accounting-Database.html#User-Accounting-Database" rel="up" accesskey="u">用户记帐数据库</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>