<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>iconv示例（GNU C库）</title>

<meta name="description" content="iconv Examples (The GNU C Library)">
<meta name="keywords" content="iconv Examples (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" title="Generic Charset Conversion">
<link href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="next" title="Other iconv Implementations">
<link href="Generic-Conversion-Interface.html#Generic-Conversion-Interface" rel="prev" title="Generic Conversion Interface">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="iconv-Examples"></span><div class="header">
<p>下一篇： <a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="next" accesskey="n">其他iconv实现</a> ，上一篇： <a href="Generic-Conversion-Interface.html#Generic-Conversion-Interface" rel="prev" accesskey="p">通用转换接口</a> ，上一篇： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="A-complete-iconv-example"></span><h4 class="subsection">6.5.2完整<code>iconv</code>例</h4>

<p>下面的示例提供了针对常见问题的解决方案。假定您知道系统用于以下目的的内部编码<code>wchar_t</code>字符串，通常可以从文件中读取文本并将其存储在宽字符缓冲区中。一个人可以做到这一点<code>mbsrtowcs</code> ，但随后我们遇到了上面讨论的问题。
</p>
<div class="example">
<pre class="example">int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open (&quot;WCHAR_T&quot;, charset);
  if (cd == (iconv_t) -1)
    {
      /* <span class="roman">Something went wrong.</span>  */
      if (errno == EINVAL)
        error (0, 0, &quot;conversion from '%s' to wchar_t not available&quot;,
               charset);
      else
        perror (&quot;iconv_open&quot;);

      /* <span class="roman">Terminate the output string.</span>  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail &gt; 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* <span class="roman">Read more input.</span>  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* <span class="roman">When we come here the file is completely read.</span>
             <span class="roman">This still could mean there are some unused</span>
             <span class="roman">characters in the <code>inbuf</code>.  Put them back.</span>  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;

          /* <span class="roman">Now write out the byte sequence to get into the</span>
             <span class="roman">initial state if this is necessary.</span>  */
          iconv (cd, NULL, NULL, &amp;wrptr, &amp;avail);

          break;
        }
      insize += nread;

      /* <span class="roman">Do the conversion.</span>  */
      nconv = iconv (cd, &amp;inptr, &amp;insize, &amp;wrptr, &amp;avail);
      if (nconv == (size_t) -1)
        {
          /* <span class="roman">Not everything went right.  It might only be</span>
             <span class="roman">an unfinished byte sequence at the end of the</span>
             <span class="roman">buffer.  Or it is a real problem.</span>  */
          if (errno == EINVAL)
            /* <span class="roman">This is harmless.  Simply move the unused</span>
               <span class="roman">bytes to the beginning of the buffer so that</span>
               <span class="roman">they can be used in the next round.</span>  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* <span class="roman">It is a real problem.  Maybe we ran out of</span>
                 <span class="roman">space in the output buffer or we have invalid</span>
                 <span class="roman">input.  In any case back the file pointer to</span>
                 <span class="roman">the position of the last processed byte.</span>  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* <span class="roman">Terminate the output string.</span>  */
  if (avail &gt;= sizeof (wchar_t))
    *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror (&quot;iconv_close&quot;);

  return (wchar_t *) wrptr - outbuf;
}
</pre></div>

<span id="index-stateful-4"></span>
<p>此示例显示了使用<code>iconv</code>功能。它显示了如何连续调用<code>iconv</code>可用于转换大量文本。用户不必关心状态编码，因为函数可以处理所有事情。
</p>
<p>有趣的是<code>iconv</code>返回一个错误， <code>errno</code>被设定为<code>EINVAL</code> 。这实际上不是转换中的错误。每当输入字符集包含多个字符的一个以上字节序列的字节序列并且文本没有被一起处理时，就会发生这种情况。在这种情况下，有可能会剪切多字节序列。然后，调用者可以简单地读取剩余的片段，并将有问题的字节与新字符一起从输入中输入到<code>iconv</code>并继续工作。在发生这样的事件后，描述符中保持的内部状态<em>不是</em>未指定的，就像来自ISO C <!-- /@w -->标准的转换函数一样。
</p>
<p>该示例还显示了将宽字符串与<code>iconv</code> 。如说明中所述<code>iconv</code>上面的函数，该函数始终将指针指向<code>char</code>数组，可用空间以字节为单位。在示例中，输出缓冲区是宽字符缓冲区；因此，我们使用局部变量<var>wrptr</var>类型的<code>char *</code> ，用于<code>iconv</code>电话。
</p>
<p>这看起来很无辜，但会导致对对齐方式严格限制的平台出现问题。因此，呼叫者<code>iconv</code>必须确保传递的指针适合访问适当字符集中的字符。由于在上述情况下，该函数的输入参数为<code>wchar_t</code>指针，就是这种情况（除非用户在计算参数时违反对齐方式）。但是在其他情况下，尤其是在编写通用函数时，如果不知道一个人使用哪种类型的字符集，因此将文本视为一个字节序列，这可能会变得棘手。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="next" accesskey="n">其他iconv实现</a> ，上一篇： <a href="Generic-Conversion-Interface.html#Generic-Conversion-Interface" rel="prev" accesskey="p">通用转换接口</a> ，上一篇： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>