<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>散点图收集（GNU C库）</title>

<meta name="description" content="Scatter-Gather (The GNU C Library)">
<meta name="keywords" content="Scatter-Gather (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" title="Low-Level I/O">
<link href="Copying-File-Data.html#Copying-File-Data" rel="next" title="Copying File Data">
<link href="Cleaning-Streams.html#Cleaning-Streams" rel="prev" title="Cleaning Streams">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Scatter_002dGather"></span><div class="header">
<p>下一页： <a href="Copying-File-Data.html#Copying-File-Data" rel="next" accesskey="n">复制文件数据</a> ，上一页： <a href="Stream_002fDescriptor-Precautions.html#Stream_002fDescriptor-Precautions" rel="prev" accesskey="p">流/描述符预防措施</a> ，向上： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Fast-Scatter_002dGather-I_002fO"></span><h3 class="section">13.6快速分散/聚集I / O</h3>
<span id="index-scatter_002dgather"></span>

<p>一些应用程序可能需要将数据读取或写入多个缓冲区，这些缓冲区在内存中分开。尽管可以通过多次调用来轻松完成此操作<code>read</code>和<code>write</code> ，因此效率低下，因为每个内核调用都存在开销。
</p>
<p>取而代之的是，许多平台都提供了特殊的高速原语，以在单个内核调用中执行这些<em>分散-收集</em>操作。GNU C库将在缺少这些原语的任何系统上提供仿真，因此它们不是可移植性威胁。它们在<code>sys/uio.h</code> 。
</p>
<p>这些功能由数组控制<code>iovec</code>结构，描述每个缓冲区的位置和大小。
</p>
<dl>
<dt id="index-struct-iovec">数据类型： <strong>struct iovec</strong></dt>
<dd>

<p>的<code>iovec</code>结构描述了一个缓冲区。它包含两个字段：</p>
<dl compact>
<dt><code>void *iov_base</code></dt>
<dd><p>包含缓冲区的地址。
</p>
</dd>
<dt><code>size_t iov_len</code></dt>
<dd><p>包含缓冲区的长度。
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt id="index-readv">功能<em>：ssize_t供</em> <em><strong>readv（INT</strong> <var>filedes</var> ，const struct iovec * <var>vector</var> ，int <var>count</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>readv</code>函数从中读取数据<var>filedes</var>并将其分散到<var>vector</var> ，这被认为是<var>count</var>结构长。随着每个缓冲区的填充，数据将发送到下一个缓冲区。
</p>
<p>注意<code>readv</code>不能保证填充所有缓冲区。由于相同的原因，它可能会随时停止<code>read</code>将。
</p>
<p>返回值是读取的字节数（ <em>不是</em>缓冲区）， <em>0</em>表示文件结束，或<em>-1</em>表示错误。可能的错误与中的相同<code>read</code> 。
</p>
</dd></dl>

<dl>
<dt id="index-writev">函数： <em>ssize_t</em> <strong>writev</strong> <em>（int <var>filedes</var> ，const struct iovec * <var>vector</var> ，int <var>count</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>writev</code>函数从描述的缓冲区中收集数据<var>vector</var> ，这被认为是<var>count</var>结构很长，并将其写入<code>filedes</code> 。写入每个缓冲区时，它将继续前进到下一个缓冲区。
</p>
<p>喜欢<code>readv</code> ， <code>writev</code>在相同条件下可能会中途停止<code>write</code>将。
</p>
<p>返回值是写入的字节数，或<em>-1</em>表示错误。可能的错误与中的相同<code>write</code> 。
</p>
</dd></dl>

<dl>
<dt id="index-preadv">函数： <em>ssize_t</em> <strong>preadv</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>readv</code>功能，不同之处在于它增加了额外的功能<var>offset</var>类型参数<code>off_t</code>相似<code>pread</code> 。数据从位置开始写入文件<var>offset</var> 。文件描述符本身的位置不受操作影响。该值与调用之前的值相同。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>preadv</code>功能其实<code>preadv64</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值是读取的字节数（ <em>不是</em>缓冲区）， <em>0</em>表示文件结束，或<em>-1</em>表示错误。可能的错误与中的相同<code>readv</code>和<code>pread</code> 。
</p></dd></dl>

<dl>
<dt id="index-preadv64">功能： <em>ssize_t</em> <strong>preadv64</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off64_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>preadv</code>功能的不同之处在于<var>offset</var>参数的类型<code>off64_t</code>代替<code>off_t</code> 。它使得在32位计算机上可以寻址大于2 ^ 31字节且最大为2 ^ 63字节的文件。文件描述符<code>filedes</code>必须使用<code>open64</code>因为否则可能会产生较大的偏移量<code>off64_t</code>在小文件模式下将导致描述符错误。
</p>
<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，该功能实际上可以在名称下使用<code>preadv</code>因此透明地替换了32位接口。
</p></dd></dl>

<dl>
<dt id="index-pwritev">函数： <em>ssize_t</em> <strong>pwritev</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>writev</code>功能，不同之处在于它增加了额外的功能<var>offset</var>类型参数<code>off_t</code>相似<code>pwrite</code> 。数据从位置开始写入文件<var>offset</var> 。文件描述符本身的位置不受操作影响。该值与调用之前的值相同。
</p>
<p>但是，在Linux上，如果使用<code>O_APPEND</code> ， <code>pwrite</code>不管数据的值如何，都将数据追加到文件末尾<code>offset</code> 。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>pwritev</code>功能其实<code>pwritev64</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值是写入的字节数（ <em>不是</em>缓冲区）， <em>0</em>表示文件结束，或<em>-1</em>表示错误。可能的错误与中的相同<code>writev</code>和<code>pwrite</code> 。
</p></dd></dl>

<dl>
<dt id="index-pwritev64">函数： <em>ssize_t</em> <strong>pwritev64</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off64_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>pwritev</code>功能的不同之处在于<var>offset</var>参数的类型<code>off64_t</code>代替<code>off_t</code> 。它使得在32位计算机上可以寻址大于2 ^ 31字节且最大为2 ^ 63字节的文件。文件描述符<code>filedes</code>必须使用<code>open64</code>因为否则可能会产生较大的偏移量<code>off64_t</code>在小文件模式下将导致描述符错误。
</p>
<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，该功能实际上可以在名称下使用<code>pwritev</code>因此透明地替换了32位接口。
</p></dd></dl>

<dl>
<dt id="index-preadv2">函数： <em>ssize_t</em> <strong>preadv2</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off_t <var>offset</var> ，int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>preadv</code>功能，不同之处在于它增加了额外的功能<var>flags</var>类型参数<code>int</code> 。此外，如果<var>offset</var>是<em>-1</em> ，将使用和更新当前文件位置（例如<code>readv</code>功能）。
</p>
<p>支持的<var>flags</var>取决于基础系统。对于Linux，它支持：</p>
<dl compact>
<dt><code>RWF_HIPRI</code>
<span id="index-RWF_005fHIPRI"></span>
</dt>
<dd><p>高优先级请求。这将添加一个标志，该标志告诉文件系统这是一个高优先级请求，值得对其进行轮询。该标志纯粹是建议性的，如果不支持，则可以忽略。的<var>fd</var>必须使用<code>O_DIRECT</code> 。
</p>
</dd>
<dt><code>RWF_DSYNC</code>
<span id="index-RWF_005fDSYNC"></span>
</dt>
<dd><p>按IO同步，就好像使用<code>O_DSYNC</code>旗。
</p>
</dd>
<dt><code>RWF_SYNC</code>
<span id="index-RWF_005fSYNC"></span>
</dt>
<dd><p>按IO同步，就好像使用<code>O_SYNC</code>旗。
</p>
</dd>
<dt><code>RWF_NOWAIT</code>
<span id="index-RWF_005fNOWAIT"></span>
</dt>
<dd><p>使用非阻塞模式进行此操作；也就是说，此调用<code>preadv2</code>将失败并设置<code>errno</code>至<code>EAGAIN</code>如果操作将阻止。
</p>
</dd>
<dt><code>RWF_APPEND</code>
<span id="index-RWF_005fAPPEND"></span>
</dt>
<dd><p>按IO同步，就好像使用<code>O_APPEND</code>旗。
</p></dd>
</dl>

<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>preadv2</code>功能其实<code>preadv64v2</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值是读取的字节数（ <em>不是</em>缓冲区）， <em>0</em>表示文件结束，或<em>-1</em>表示错误。可能的错误与中的相同<code>preadv</code>加上以下内容：</p>
<dl compact>
<dt><code>EOPNOTSUPP</code></dt>
<dd>
<p>不支持的<var>flags</var>被使用了。
</p>
</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-preadv64v2">功能： <em>ssize_t</em> <strong>preadv64v2</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off64_t <var>offset</var> ，int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>preadv2</code>功能的不同之处在于<var>offset</var>参数的类型<code>off64_t</code>代替<code>off_t</code> 。它使得在32位计算机上可以寻址大于2 ^ 31字节且最大为2 ^ 63字节的文件。文件描述符<code>filedes</code>必须使用<code>open64</code>因为否则可能会产生较大的偏移量<code>off64_t</code>在小文件模式下将导致描述符错误。
</p>
<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，该功能实际上可以在名称下使用<code>preadv2</code>因此透明地替换了32位接口。
</p></dd></dl>


<dl>
<dt id="index-pwritev2">函数： <em>ssize_t</em> <strong>pwritev2</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off_t <var>offset</var> ，int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>pwritev</code>功能，不同之处在于它增加了额外的功能<var>flags</var>类型参数<code>int</code> 。此外，如果<var>offset</var>是<em>-1</em> ，应使用和更新当前文件位置（例如<code>writev</code>功能）。
</p>
<p>支持的<var>flags</var>取决于基础系统。对于Linux，支持的标志与针对<code>preadv2</code> 。
</p>
<p>使用以下命令编译源文件时<code>_FILE_OFFSET_BITS == 64</code>的<code>pwritev2</code>功能其实<code>pwritev64v2</code>和类型<code>off_t</code>具有64位，这使得可以处理最大2 ^ 63字节的文件。
</p>
<p>返回值是写入的字节数（ <em>不是</em>缓冲区）， <em>0</em>表示文件结束，或<em>-1</em>表示错误。可能的错误与中的相同<code>preadv2</code> 。
</p></dd></dl>

<dl>
<dt id="index-pwritev64v2">功能： <em>ssize_t</em> <strong>pwritev64v2</strong> <em>（int <var>fd</var> ，const struct iovec * <var>iov</var> ，int <var>iovcnt</var> ，off64_t <var>offset</var> ，int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能类似于<code>pwritev2</code>功能的不同之处在于<var>offset</var>参数的类型<code>off64_t</code>代替<code>off_t</code> 。它使得在32位计算机上可以寻址大于2 ^ 31字节且最大为2 ^ 63字节的文件。文件描述符<code>filedes</code>必须使用<code>open64</code>因为否则可能会产生较大的偏移量<code>off64_t</code>在小文件模式下将导致描述符错误。
</p>
<p>使用编译源文件时<code>_FILE_OFFSET_BITS == 64</code>在32位计算机上，该功能实际上可以在名称下使用<code>pwritev2</code>因此透明地替换了32位接口。
</p></dd></dl>

<hr>
<div class="header">
<p>下一页： <a href="Copying-File-Data.html#Copying-File-Data" rel="next" accesskey="n">复制文件数据</a> ，上一页： <a href="Stream_002fDescriptor-Precautions.html#Stream_002fDescriptor-Precautions" rel="prev" accesskey="p">流/描述符预防措施</a> ，向上： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>