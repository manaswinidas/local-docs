<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Malloc的挂钩（GNU C库）</title>

<meta name="description" content="Hooks for Malloc (The GNU C Library)">
<meta name="keywords" content="Hooks for Malloc (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" title="Unconstrained Allocation">
<link href="Statistics-of-Malloc.html#Statistics-of-Malloc" rel="next" title="Statistics of Malloc">
<link href="Heap-Consistency-Checking.html#Heap-Consistency-Checking" rel="prev" title="Heap Consistency Checking">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Hooks-for-Malloc"></span><div class="header">
<p>下一篇： <a href="Statistics-of-Malloc.html#Statistics-of-Malloc" rel="next" accesskey="n">Malloc的统计信息</a> ，上一篇： <a href="Heap-Consistency-Checking.html#Heap-Consistency-Checking" rel="prev" accesskey="p">堆一致性检查</a> ，上一篇： <a href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" accesskey="u">无限制分配</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Memory-Allocation-Hooks"></span><h4 class="subsubsection">3.2.3.9内存分配挂钩</h4>
<span id="index-allocation-hooks_002c-for-malloc"></span>

<p>GNU C库可让您修改以下行为<code>malloc</code> ， <code>realloc</code>和<code>free</code>通过指定适当的挂钩函数。例如，您可以使用这些挂钩来帮助调试使用动态内存分配的程序。
</p>
<p>钩子变量在<samp>malloc.h</samp> 。
<span id="index-malloc_002eh-1"></span>
</p>
<dl>
<dt id="index-_005f_005fmalloc_005fhook">变量： <strong>__ malloc_hook</strong></dt>
<dd>
<p>该变量的值是指向该函数的指针<code>malloc</code>在调用时使用。您应该定义此函数看起来像<code>malloc</code> ;也就是说，就像：</p>
<div class="example">
<pre class="example">void *<var>function</var> (size_t <var>size</var>, const void *<var>caller</var>)
</pre></div>

<p>的价值<var>caller</var>是当栈中找到的返回地址<code>malloc</code>函数被调用。此值使您可以跟踪程序的内存消耗。
</p></dd></dl>

<dl>
<dt id="index-_005f_005frealloc_005fhook">变量： <strong>__ realloc_hook</strong></dt>
<dd>
<p>该变量的值是指向<code>realloc</code>在调用时使用。您应该定义此函数看起来像<code>realloc</code> ;也就是说，就像：</p>
<div class="example">
<pre class="example">void *<var>function</var> (void *<var>ptr</var>, size_t <var>size</var>, const void *<var>caller</var>)
</pre></div>

<p>的价值<var>caller</var>是当栈中找到的返回地址<code>realloc</code>函数被调用。此值使您可以跟踪程序的内存消耗。
</p></dd></dl>

<dl>
<dt id="index-_005f_005ffree_005fhook">变量： <strong>__ free_hook</strong></dt>
<dd>
<p>该变量的值是指向<code>free</code>在调用时使用。您应该定义此函数看起来像<code>free</code> ;也就是说，就像：</p>
<div class="example">
<pre class="example">void <var>function</var> (void *<var>ptr</var>, const void *<var>caller</var>)
</pre></div>

<p>的价值<var>caller</var>是当栈中找到的返回地址<code>free</code>函数被调用。此值使您可以跟踪程序的内存消耗。
</p></dd></dl>

<dl>
<dt id="index-_005f_005fmemalign_005fhook">变量： <strong>__ memalign_hook</strong></dt>
<dd>
<p>该变量的值是指向<code>aligned_alloc</code> ， <code>memalign</code> ， <code>posix_memalign</code>和<code>valloc</code>每当调用它们时使用。您应该定义此函数看起来像<code>aligned_alloc</code> ;也就是说，就像：</p>
<div class="example">
<pre class="example">void *<var>function</var> (size_t <var>alignment</var>, size_t <var>size</var>, const void *<var>caller</var>)
</pre></div>

<p>的价值<var>caller</var>是当栈中找到的返回地址<code>aligned_alloc</code> ， <code>memalign</code> ， <code>posix_memalign</code>要么<code>valloc</code>函数被调用。此值使您可以跟踪程序的内存消耗。
</p></dd></dl>

<p>您必须确保在不首先恢复钩子的旧值的情况下，作为这些函数之一的钩子安装的函数不会递归调用该函数！否则，您的程序将陷入无限递归中。在递归地调用该函数之前，应确保将所有的钩子恢复到其先前的值。从递归调用返回时，应重新保存所有挂钩，因为挂钩可能会自行修改。
</p>
<p>需要注意的一个问题是何时可以安全地安装malloc挂钩函数。如果钩子函数以递归方式调用与malloc相关的函数，则必须在以下情况时malloc已正确初始化自身： <code>__malloc_hook</code>等分配给。另一方面，如果钩子函数提供了它们自己的完整的malloc实现，那么将钩子分配给第一个钩子<em>之前</em> ，至关重要的是<code>malloc</code>调用已完成，因为否则将从普通的未经挂钩的malloc获得的块稍后可能会传递给<code>__free_hook</code> ， 例如。
</p>
<p>这是显示如何使用的示例<code>__malloc_hook</code>和<code>__free_hook</code>正确地。它安装了一个每次都打印出信息的功能<code>malloc</code>要么<code>free</code>叫做。我们在这里假设<code>realloc</code>和<code>memalign</code>在我们的程序中没有使用。
</p>
<div class="example">
<pre class="example">/* Prototypes for __malloc_hook, __free_hook */
#include &lt;malloc.h&gt;

/* Prototypes for our hooks.  */
static void my_init_hook (void);
static void *my_malloc_hook (size_t, const void *);
static void my_free_hook (void*, const void *);

static void
my_init (void)
{
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

static void *
my_malloc_hook (size_t size, const void *caller)
{
  void *result;
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  result = malloc (size);
  /* Save underlying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <span class="roman"><code>printf</code> might call <code>malloc</code>, so protect it too.</span> */
  printf (&quot;malloc (%u) returns %p\n&quot;, (unsigned int) size, result);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
  return result;
}

static void
my_free_hook (void *ptr, const void *caller)
{
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  free (ptr);
  /* Save underlying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <span class="roman"><code>printf</code> might call <code>free</code>, so protect it too.</span> */
  printf (&quot;freed pointer %p\n&quot;, ptr);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

main ()
{
  my_init ();
  &hellip;
}
</pre></div>

<p>的<code>mcheck</code>功能（请参阅<a href="Heap-Consistency-Checking.html#Heap-Consistency-Checking">堆一致性检查</a> ）通过安装此类钩子来工作。
</p>

<hr>
<div class="header">
<p>下一篇： <a href="Statistics-of-Malloc.html#Statistics-of-Malloc" rel="next" accesskey="n">Malloc的统计信息</a> ，上一篇： <a href="Heap-Consistency-Checking.html#Heap-Consistency-Checking" rel="prev" accesskey="p">堆一致性检查</a> ，上一篇： <a href="Unconstrained-Allocation.html#Unconstrained-Allocation" rel="up" accesskey="u">无限制分配</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>