<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>常用用法（GNU C库）</title>

<meta name="description" content="Common Usage (The GNU C Library)">
<meta name="keywords" content="Common Usage (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Message-catalogs-a-la-X_002fOpen.html#Message-catalogs-a-la-X_002fOpen" rel="up" title="Message catalogs a la X/Open">
<link href="The-Uniforum-approach.html#The-Uniforum-approach" rel="next" title="The Uniforum approach">
<link href="The-gencat-program.html#The-gencat-program" rel="prev" title="The gencat program">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Common-Usage"></span><div class="header">
<p>上一个： <a href="The-gencat-program.html#The-gencat-program" rel="prev" accesskey="p">gencat程序</a> ，上一个： <a href="Message-catalogs-a-la-X_002fOpen.html#Message-catalogs-a-la-X_002fOpen" rel="up" accesskey="u">消息分类为X / Open</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="How-to-use-the-catgets-interface"></span><h4 class="subsection">8.1.4如何使用<code>catgets</code>接口</h4>

<p>的<code>catgets</code>函数可以两种不同的方式使用。严格遵循X / Open规范，而不依赖于扩展，而使用GNU扩展。我们将首先看一下前一种方法，以了解扩展的好处。
</p>
<span id="Not-using-symbolic-names"></span><h4 class="subsubsection">8.1.4.1不使用符号名称</h4>

<p>由于消息目录文件的X / Open格式不允许使用符号名称，因此我们必须始终使用数字。当我们开始编写程序时，我们必须将所有可翻译字符串的外观替换为类似</p>
<div class="example">
<pre class="example">catgets (catdesc, set, msg, &quot;string&quot;)
</pre></div>

<p><var>catgets</var>从对的调用中检索<code>catopen</code>通常在程序启动时执行一次。的<code>"string"</code>是我们要翻译的字符串。问题始于电话号码和消息号。
</p>
<p>在一个更大的程序中，通常有几个程序员同时在一个程序上工作，因此协调编号分配至关重要。尽管没有两个不同的字符串必须由相同的数字元组索引，但是非常需要将数字重复用于具有相同翻译的相等字符串（请注意，由于上下文的不同，可能存在一种语言相同但具有不同翻译的字符串） ）。
</p>
<p>对于程序的不同部分，可以通过不同的设置编号稍微放松分配过程。因此，可以减少必须协调分配的开发人员的数量。但是，仍然必须使用列表来跟踪分配情况，并且很容易发生错误。这些错误无法由编译器或<code>catgets</code>功能。仅该程序的用户可能会看到打印错误的消息。在最坏的情况下，消息是如此令人讨厌，以至于无法将其识别为错误消息。考虑一下翻译<code>"true"</code>和<code>"false"</code>被交换。这可能会导致灾难。
</p>

<span id="Using-symbolic-names"></span><h4 class="subsubsection">8.1.4.2使用符号名称</h4>

<p>上一节提到的问题源于以下事实：</p>
<ol>
<li>号码分配一次，由于可能会频繁使用，因此以后很难更改号码。
</li><li>数字不允许猜测有关字符串的任何内容，因此很容易发生冲突。
</li></ol>

<p>通过不断使用符号名并提供一种将字符串内容映射到符号名的方法（无论如何都会发生），可以避免上述两个问题。这样做的代价是程序员在编写程序本身时必须编写一个完整的消息目录文件。
</p>
<p>这是必需的，因为在编译程序源之前，必须将符号名映射为数字。在上一节中，描述了如何生成包含名称映射的标头。例如，对于上一节中给出的示例消息文件，我们可以称其为<code>gencat</code>程序如下（假设<samp>ex.msg</samp>包含来源）。
</p>
<div class="example">
<pre class="example">gencat -H ex.h -o ex.cat ex.msg
</pre></div>

<p>这将生成具有以下内容的头文件：</p>
<div class="example">
<pre class="example">#define SetTwoSet 0x2   /* ex.msg:8 */

#define SetOneSet 0x1   /* ex.msg:4 */
#define SetOnetwo 0x2   /* ex.msg:6 */
</pre></div>

<p>可以看出，源文件中给出的各种符号都经过修饰以生成唯一的标识符，并且这些标识符获得分配的编号。读取源文件并了解规则将允许预测头文件的内容（确定性的），但这不是必需的。的<code>gencat</code>程序可以照顾一切。程序员要做的就是将生成的头文件放入其项目的源文件的依赖项列表中，并添加一条规则以在任何输入文件发生更改时重新生成头。
</p>
<p>关于符号乱码的一句话。每个符号由两部分组成：消息集的名称加上消息的名称或特殊字符串<code>Set</code> 。所以<code>SetOnetwo</code>表示此宏可用于访问带有标识符的翻译<code>two</code>在消息集中<code>SetOne</code> 。
</p>
<p>其他名称表示消息集的名称。特殊字符串<code>Set</code>用于代替消息标识符。
</p>
<p>如果在代码中第二个字符串集<code>SetOne</code>使用的C代码应如下所示：</p>
<div class="example">
<pre class="example">catgets (catdesc, SetOneSet, SetOnetwo,
         &quot;   Message with ID \&quot;two\&quot;, which gets the value 2 assigned&quot;)
</pre></div>

<p>以这种方式编写函数将允许更改消息号甚至设置号，而无需更改C源代码。（字符串的文本通常是不同的；这仅用于此示例。）
</p>

<span id="How-does-to-this-allow-to-develop"></span><h4 class="subsubsection">8.1.4.3如何做到这一点</h4>

<p>为了说明使用符号版本号的常用方法，这里是一个小例子。假设我们要编写非常复杂且著名的问候程序。我们首先像往常一样编写代码：</p>
<div class="example">
<pre class="example">#include &lt;stdio.h&gt;
int
main (void)
{
  printf (&quot;Hello, world!\n&quot;);
  return 0;
}
</pre></div>

<p>现在我们要使消息国际化，因此用用户想要的内容替换消息。
</p>
<div class="example">
<pre class="example">#include &lt;nl_types.h&gt;
#include &lt;stdio.h&gt;
#include &quot;msgnrs.h&quot;
int
main (void)
{
  nl_catd catdesc = catopen (&quot;hello.cat&quot;, NL_CAT_LOCALE);
  printf (catgets (catdesc, SetMainSet, SetMainHello,
                   &quot;Hello, world!\n&quot;));
  catclose (catdesc);
  return 0;
}
</pre></div>

<p>我们将看到如何打开目录对象，以及如何在其他函数调用中使用返回的描述符。确实没有必要检查任何功能的故障，因为即使在这些情况下，这些功能也会表现合理。他们只是将返回翻译。
</p>
<p>这里仍未指定的是常量<code>SetMainSet</code>和<code>SetMainHello</code> 。这些是描述消息的符号名称。为了获得与目录文件中的信息相匹配的实际定义，我们必须创建消息目录源文件并使用<code>gencat</code>程序。
</p>
<div class="example">
<pre class="example">$ Messages for the famous greeting program.
$quote &quot;

$set Main
Hello &quot;Hallo, Welt!\n&quot;
</pre></div>

<p>现在我们可以开始构建程序（假设消息目录源文件名为<samp>hello.msg</samp>和程序源文件<samp>hello.c</samp> ）：</p>
<div class="example">
<pre class="example">% gencat -H msgnrs.h -o hello.cat hello.msg
% cat msgnrs.h
#define MainSet 0x1     /* hello.msg:4 */
#define MainHello 0x1   /* hello.msg:5 */
% gcc -o hello hello.c -I.
% cp hello.cat /usr/share/locale/de/LC_MESSAGES
% echo $LC_ALL
de
% ./hello
Hallo, Welt!
%
</pre></div>

<p>的呼唤<code>gencat</code>程序创建丢失的头文件<samp>msgnrs.h</samp>以及消息目录二进制文件。前者用于编译<samp>hello.c</samp>而后者放在一个目录中<code>catopen</code>函数将尝试找到它。请检查<code>LC_ALL</code>环境变量和默认路径<code>catopen</code>在上面的描述中给出。
</p>

<hr>
<div class="header">
<p>上一个： <a href="The-gencat-program.html#The-gencat-program" rel="prev" accesskey="p">gencat程序</a> ，上一个： <a href="Message-catalogs-a-la-X_002fOpen.html#Message-catalogs-a-la-X_002fOpen" rel="up" accesskey="u">消息分类为X / Open</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>