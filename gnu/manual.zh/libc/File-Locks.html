<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>文件锁（GNU C库）</title>

<meta name="description" content="File Locks (The GNU C Library)">
<meta name="keywords" content="File Locks (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" title="Low-Level I/O">
<link href="Open-File-Description-Locks.html#Open-File-Description-Locks" rel="next" title="Open File Description Locks">
<link href="Getting-File-Status-Flags.html#Getting-File-Status-Flags" rel="prev" title="Getting File Status Flags">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="File-Locks"></span><div class="header">
<p>下一个： <a href="Open-File-Description-Locks.html#Open-File-Description-Locks" rel="next" accesskey="n">打开文件描述锁</a> ，上一个： <a href="File-Status-Flags.html#File-Status-Flags" rel="prev" accesskey="p">文件状态标志</a> ，上一个： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="File-Locks-1"></span><h3 class="section">13.16文件锁</h3>

<span id="index-file-locks"></span>
<span id="index-record-locking"></span>
<p>本节介绍与流程关联的记录锁。还有一种与打开文件描述（而不是过程）相关联的记录锁定类型。请参阅<a href="Open-File-Description-Locks.html#Open-File-Description-Locks">打开文件描述锁</a> 。
</p>
<p>剩余的<code>fcntl</code>命令用于支持<em>记录锁定</em> ，该<em>记录锁定</em>允许多个相互协作的程序防止彼此以容易出错的方式同时访问文件的各个部分。
</p>
<span id="index-exclusive-lock"></span>
<span id="index-write-lock"></span>
<p><em>互斥</em>锁或<em>写</em>锁为进程提供了对文件的指定部分进行写操作的互斥访问。设置写锁定后，没有其他进程可以锁定文件的该部分。
</p>
<span id="index-shared-lock"></span>
<span id="index-read-lock"></span>
<p><em>共享</em>或<em>读取</em>锁定禁止任何其他进程在文件的指定部分上请求写入锁定。但是，其他进程可以请求读取锁。
</p>
<p>的<code>read</code>和<code>write</code>函数实际上不会检查是否有任何锁定。如果要为多个进程共享的文件实现锁定协议，则您的应用程序必须明确<code>fcntl</code>在适当的位置调用请求并清除锁。
</p>
<p>锁与进程关联。进程只能为给定文件的每个字节设置一种锁。当该进程关闭该文件的任何文件描述符时，该进程对该文件持有的所有锁都会被释放，即使这些锁是使用其他保持打开状态的描述符进行的。同样，锁在进程退出时释放，并且不会被使用创建的子进程继承<code>fork</code> （请参阅<a href="Creating-a-Process.html#Creating-a-Process">创建流程</a> ）。
</p>
<p>进行锁定时，请使用<code>struct flock</code>指定哪种锁以及在何处。该数据类型以及与之关联的宏<code>fcntl</code>函数在头文件中声明<samp>fcntl.h</samp> 。
<span id="index-fcntl_002eh-6"></span>
</p>
<dl>
<dt id="index-struct-flock">数据类型： <strong>struct flock</strong></dt>
<dd>
<p>此结构与<code>fcntl</code>函数描述文件锁定。它具有以下成员：</p>
<dl compact>
<dt><code>short int l_type</code></dt>
<dd><p>指定锁的类型；之一<code>F_RDLCK</code> ， <code>F_WRLCK</code> ， 要么<code>F_UNLCK</code> 。
</p>
</dd>
<dt><code>short int l_whence</code></dt>
<dd><p>这对应于<var>whence</var>争论<code>fseek</code>要么<code>lseek</code> ，并指定相对偏移量。它的值可以是以下之一<code>SEEK_SET</code> ， <code>SEEK_CUR</code> ， 要么<code>SEEK_END</code> 。
</p>
</dd>
<dt><code>off_t l_start</code></dt>
<dd><p>这指定了锁所适用的区域的起始位置的偏移量，以字节为单位，相对于由锁指定的点<code>l_whence</code>会员。
</p>
</dd>
<dt><code>off_t l_len</code></dt>
<dd><p>这指定了要锁定的区域的长度。值<code>0</code>被特殊对待；这意味着该区域扩展到文件的末尾。
</p>
</dd>
<dt><code>pid_t l_pid</code></dt>
<dd><p>该字段是持有锁的进程的进程ID（请参阅“ <a href="Process-Creation-Concepts.html#Process-Creation-Concepts">进程创建概念”</a> ）。通过调用填写<code>fcntl</code>与<code>F_GETLK</code>命令，但在进行锁定时将被忽略。如果冲突的锁是打开文件描述锁（请参阅<a href="Open-File-Description-Locks.html#Open-File-Description-Locks">打开文件描述锁</a> ），则此字段将设置为<em>-1</em> 。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-F_005fGETLK-1">巨集： <em>int</em> <strong>F_GETLK</strong></dt>
<dd>
<p>此宏用作<var>command</var>争论<code>fcntl</code> ，以指定它应获取有关锁的信息。此命令需要类型的第三个参数<code>struct flock *</code> <!-- /@w -->传递给<code>fcntl</code> ，因此调用的形式为：</p>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_GETLK, <var>lockp</var>)
</pre></div>

<p>如果已经有一个锁，它将阻塞<var>lockp</var>参数，有关该锁的信息将覆盖<code>*<var>lockp</var></code> 。如果现有锁与按指定进行新锁兼容，则不会报告这些锁。因此，您应该指定一种锁定类型<code>F_WRLCK</code>如果您想了解读和写锁，或者<code>F_RDLCK</code>如果您只想了解写锁定。
</p>
<p>可能有一个以上的锁影响到由<var>lockp</var>争论，但是<code>fcntl</code>仅返回有关其中之一的信息。的<code>l_whence</code>的成员<var>lockp</var>结构设置为<code>SEEK_SET</code>和<code>l_start</code>和<code>l_len</code>设置为标识锁定区域的字段。
</p>
<p>如果没有锁，则唯一更改为<var>lockp</var>结构是更新<code>l_type</code>值<code>F_UNLCK</code> 。
</p>
<p>的正常返回值<code>fcntl</code>该命令的值是<em>-1</em>以外的未指定值，保留该值以指示错误。下列<code>errno</code>为该命令定义了错误条件：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p>的<var>filedes</var>参数无效。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>要么<var>lockp</var>参数未指定有效的锁定信息或与之关联的文件<var>filedes</var>不支持锁。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-F_005fSETLK-1">巨集： <em>int</em> <strong>F_SETLK</strong></dt>
<dd>
<p>此宏用作<var>command</var>争论<code>fcntl</code> ，以指定应设置或清除锁定。此命令需要类型的第三个参数<code>struct flock *</code> <!-- /@w -->传递给<code>fcntl</code> ，因此调用的形式为：</p>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_SETLK, <var>lockp</var>)
</pre></div>

<p>如果该进程已在区域的任何部分上具有锁，则该部分上的旧锁将替换为新锁。您可以通过指定以下类型的锁来删除锁： <code>F_UNLCK</code> 。
</p>
<p>如果无法设置锁定， <code>fcntl</code>立即返回值<em>-1</em> 。等待其他进程释放锁时，此功能不会阻止。如果<code>fcntl</code>成功，它将返回非<em>-1</em>的值。
</p>
<p>下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dt><code>EACCES</code></dt>
<dd><p>无法设置该锁定，因为该锁定已被文件上的现有锁定阻止。一些系统使用<code>EAGAIN</code>在这种情况下，其他系统使用<code>EACCES</code> ;您的程序应该在以后<code>F_SETLK</code> 。（GNU / Linux和GNU / Hurd系统始终使用<code>EAGAIN</code> ）
</p>
</dd>
<dt><code>EBADF</code></dt>
<dd><p>要么： <var>filedes</var>参数无效；您请求了读锁，但是<var>filedes</var>未开放读取访问权限；或者，您请求写锁定，但是<var>filedes</var>未打开以进行写访问。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>要么<var>lockp</var>参数未指定有效的锁定信息或与之关联的文件<var>filedes</var>不支持锁。
</p>
</dd>
<dt><code>ENOLCK</code></dt>
<dd><p>系统已用完文件锁定资源；已经有太多的文件锁。
</p>
<p>设计良好的文件系统永远不会报告此错误，因为它们对锁的数量没有限制。但是，您仍然必须考虑此错误的可能性，因为它可能是由于网络访问另一台计算机上的文件系统而导致的。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-F_005fSETLKW-1">巨集： <em>int</em> <strong>F_SETLKW</strong></dt>
<dd>
<p>此宏用作<var>command</var>争论<code>fcntl</code> ，以指定应设置或清除锁定。就像<code>F_SETLK</code>命令，但会导致进程阻塞（或等待），直到可以指定请求为止。
</p>
<p>此命令需要类型的第三个参数<code>struct flock *</code> ，至于<code>F_SETLK</code>命令。
</p>
<p>的<code>fcntl</code>返回值和错误与<code>F_SETLK</code>命令，但这些额外<code>errno</code>为该命令定义了错误条件：</p>
<dl compact>
<dt><code>EINTR</code></dt>
<dd><p>该函数在等待时被信号中断。
See <a href="Interrupted-Primitives.html#Interrupted-Primitives">Interrupted Primitives</a>.
</p>
</dd>
<dt><code>EDEADLK</code></dt>
<dd><p>The specified region is being locked by another process.  But that
process is waiting to lock a region which the current process has
locked, so waiting for the lock would result in deadlock.  The system
does not guarantee that it will detect all such conditions, but it lets
you know if it notices one.
</p></dd>
</dl>
</dd></dl>


<p>The following macros are defined for use as values for the <code>l_type</code>
member of the <code>flock</code> structure.  The values are integer constants.
</p>
<dl compact>
<dt><code>F_RDLCK</code>
<span id="index-F_005fRDLCK"></span>
</dt>
<dd>
<p>This macro is used to specify a read (or shared) lock.
</p>
</dd>
<dt><code>F_WRLCK</code>
<span id="index-F_005fWRLCK"></span>
</dt>
<dd>
<p>This macro is used to specify a write (or exclusive) lock.
</p>
</dd>
<dt><code>F_UNLCK</code>
<span id="index-F_005fUNLCK"></span>
</dt>
<dd>
<p>This macro is used to specify that the region is unlocked.
</p></dd>
</dl>

<p>As an example of a situation where file locking is useful, consider a
program that can be run simultaneously by several different users, that
logs status information to a common file.  One example of such a program
might be a game that uses a file to keep track of high scores.  Another
example might be a program that records usage or accounting information
for billing purposes.
</p>
<p>Having multiple copies of the program simultaneously writing to the
file could cause the contents of the file to become mixed up.  But
you can prevent this kind of problem by setting a write lock on the
file before actually writing to the file.
</p>
<p>If the program also needs to read the file and wants to make sure that
the contents of the file are in a consistent state, then it can also use
a read lock.  While the read lock is set, no other process can lock
that part of the file for writing.
</p>

<p>Remember that file locks are only an <em>advisory</em> protocol for
controlling access to a file.  There is still potential for access to
the file by programs that don’t use the lock protocol.
</p>
<hr>
<div class="header">
<p>
Next: <a href="Open-File-Description-Locks.html#Open-File-Description-Locks" rel="next" accesskey="n">Open File Description Locks</a>, Previous: <a href="File-Status-Flags.html#File-Status-Flags" rel="prev" accesskey="p">File Status Flags</a>, Up: <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">Low-Level I/O</a>   [<a href="index.html#SEC_Contents" title="目录" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="指数" rel="index">Index</a>]</p>
</div>





</body></html>