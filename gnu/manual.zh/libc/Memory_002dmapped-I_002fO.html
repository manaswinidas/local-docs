<html ><head></head><body lang="zh-Hans" >﻿<!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>内存映射的I / O（GNU C库）</title>

<meta name="description" content="Memory-mapped I/O (The GNU C Library)">
<meta name="keywords" content="Memory-mapped I/O (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" title="Low-Level I/O">
<link href="Waiting-for-I_002fO.html#Waiting-for-I_002fO" rel="next" title="Waiting for I/O">
<link href="Copying-File-Data.html#Copying-File-Data" rel="prev" title="Copying File Data">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>





<span id="Memory_002dmapped-I_002fO"></span><div class="header">
<p>下一篇： <a href="Waiting-for-I_002fO.html#Waiting-for-I_002fO" rel="next" accesskey="n">等待I / O</a> ，上一篇： <a href="Copying-File-Data.html#Copying-File-Data" rel="prev" accesskey="p">复制文件数据</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Memory_002dmapped-I_002fO-1"></span><h3 class="section">13.8内存映射的I / O</h3>

<p>在现代的操作系统，可以针对<em>mmap（</em>发音为“EM-图”）的文件的内存区域。完成此操作后，就可以像访问程序中的数组一样访问文件了。
</p>
<p>这比<code>read</code>要么<code>write</code> ，因为仅加载程序实际访问的文件区域。对mapped区域尚未加载的部分的访问以与换出页面相同的方式处理。
</p>
<p>由于在物理内存不足时可以将映射的页面存储回其文件中，因此可以将文件映射到比物理内存<em>和</em>交换空间大几个数量级的文件。唯一的限制是地址空间。在32位计算机上，理论上的限制是4GB-但是，实际的限制会更小，因为某些区域将保留用于其他用途。如果使用LFS接口，则32位系统上的文件大小不限于2GB（对偏移量进行了签名，这将4GB的可寻址区域减小了一半）；例如，完整的64位可用。
</p>
<p>内存映射仅适用于整个内存页面。因此，用于映射的地址必须页面对齐，并且长度值将四舍五入。要确定机器使用的页面的默认大小，应使用：</p>
<span id="index-_005fSC_005fPAGESIZE"></span>
<div class="example">
<pre class="example">size_t page_size = (size_t) sysconf (_SC_PAGESIZE);
</pre></div>

<p>在某些系统上，映射可以为某些文件使用更大的页面大小，应用程序也可以为匿名映射请求更大的页面大小（请参阅<code>MAP_HUGETLB</code>下方的标志）。
</p>
<p>声明以下功能<samp>sys/mman.h</samp> ：</p>
<dl>
<dt id="index-mmap">功能： <em>void *</em> <strong>mmap</strong> <em>（void * <var>address</var> ，size_t <var>length</var> ，int <var>protect</var> ，int <var>flags</var> ，int <var>filedes</var> ，off_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>mmap</code>函数创建一个新的映射，并连接到字节（ <var>offset</var> ） 至 （ <var>offset</var> + <var>length</var> -1）在文件上打开<var>filedes</var> 。由指定的文件的新参考<var>filedes</var>被创建，不会通过关闭文件来删除。
</p>
<p><var>address</var>给出映射的首选起始地址。
<code>NULL</code>不表示偏好。该地址以前的所有映射都将自动删除。您提供的地址可能仍会更改，除非您使用<code>MAP_FIXED</code>旗。
</p>
<p><var>protect</var>包含控制允许访问类型的标志。它们包括<code>PROT_READ</code> ， <code>PROT_WRITE</code>和<code>PROT_EXEC</code> 。特殊标志<code>PROT_NONE</code>保留地址空间区域以供将来使用。的<code>mprotect</code>功能可用于更改保护标志。请参阅<a href="Memory-Protection.html#Memory-Protection">内存保护</a> 。
</p>
<p><var>flags</var>包含控制地图性质的标志。之一<code>MAP_SHARED</code>要么<code>MAP_PRIVATE</code>必须指定。
</p>
<p>它们包括：</p>
<dl compact>
<dt><code>MAP_PRIVATE</code>
<span id="index-MAP_005fPRIVATE"></span>
</dt>
<dd><p>这指定对区域的写操作永远不要写回附件。而是为该过程创建一个副本，如果内存不足，该区域将正常交换。没有其他进程会看到更改。
</p>
<p>由于私有映射在写入时会有效地还原为普通内存，因此，如果您将此模式与<code>PROT_WRITE</code> 。
</p>
</dd>
<dt><code>MAP_SHARED</code>
<span id="index-MAP_005fSHARED"></span>
</dt>
<dd><p>这指定对区域的写操作将被写回到文件中。所做的更改将立即与映射同一文件的其他进程共享。
</p>
<p>请注意，实际书写可能随时发生。您需要使用<code>msync</code> ，如下所述，如果使用常规I / O的其他进程获得文件的一致视图很重要。
</p>
</dd>
<dt><code>MAP_FIXED</code>
<span id="index-MAP_005fFIXED"></span>
</dt>
<dd><p>这迫使系统使用在中指定的确切映射地址。 <var>address</var>失败了就失败了
</p>
</dd>
<dt><code>MAP_ANONYMOUS</code>
<span id="index-MAP_005fANONYMOUS"></span>
</dt>
<dt><code>MAP_ANON</code>
<span id="index-MAP_005fANON"></span>
</dt>
<dd><p>该标志告诉系统创建未连接到文件的匿名映射。 <var>filedes</var>和<var>offset</var>将被忽略，并使用零初始化该区域。
</p>
<p>匿名映射被用作在某些系统上扩展堆的基本原语。它们对于在不创建文件的情况下在多个任务之间共享数据也很有用。
</p>
<p>在某些系统上使用私有匿名mmap比使用匿名更有效<code>malloc</code>对于大块。这不是GNU C库的问题，因为它包含<code>malloc</code>自动使用<code>mmap</code>在适当情况下。
</p>
</dd>
<dt><code>MAP_HUGETLB</code>
<span id="index-MAP_005fHUGETLB"></span>
</dt>
<dd>
<p>这要求系统使用替代页面大小，该页面大小大于映射的默认页面大小。对于某些工作负载，增加大型映射的页面大小可提高性能，因为系统需要处理的页面要少得多。对于需要在存储设备或不同节点之间频繁转移页面的其他工作负载，由于增加的页面大小和更大的转移，减小的页面粒度可能会导致性能问题。
</p>
<p>为了创建映射，系统需要在物理上连续的内存，其大小已增加到页面大小。结果是， <code>MAP_HUGETLB</code>映射受内存碎片影响，即使系统中有足够的内存，它们的创建也可能失败。
</p>
<p>并非所有文件系统都支持页面大小增加的映射。
</p>
<p>的<code>MAP_HUGETLB</code>标志特定于Linux。
</p>


</dd>
</dl>

<p><code>mmap</code>返回新映射的地址，或<code>MAP_FAILED</code>错误。
</p>
<p>可能的错误包括：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd>
<p>要么<var>address</var>无法使用（因为它不是适用页面大小的倍数）或不一致<var>flags</var>被给予。
</p>
<p>如果<code>MAP_HUGETLB</code>指定为文件或系统不支持大页面大小。
</p>
</dd>
<dt><code>EACCES</code></dt>
<dd>
<p><var>filedes</var>未针对中指定的访问类型打开<var>protect</var> 。
</p>
</dd>
<dt><code>ENOMEM</code></dt>
<dd>
<p>没有足够的内存来进行操作，或者进程空间不足。
</p>
</dd>
<dt><code>ENODEV</code></dt>
<dd>
<p>此文件的类型不支持映射。
</p>
</dd>
<dt><code>ENOEXEC</code></dt>
<dd>
<p>该文件位于不支持映射的文件系统上。
</p>

</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-mmap64">功能： <em>void *</em> <strong>mmap64</strong> <em>（void * <var>address</var> ，size_t <var>length</var> ，int <var>protect</var> ，int <var>flags</var> ，int <var>filedes</var> ，off64_t <var>offset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>mmap64</code>功能相当于<code>mmap</code>功能但<var>offset</var>参数的类型<code>off64_t</code> 。在32位系统上，这允许与<var>filedes</var>描述符大于2GB。 <var>filedes</var>必须是从调用返回的描述符<code>open64</code>要么<code>fopen64</code>和<code>freopen64</code>在其中检索描述符的位置<code>fileno</code> 。
</p>
<p>当源翻译成<code>_FILE_OFFSET_BITS == 64</code>该功能实际上在名称下可用<code>mmap</code> 。也就是说，使用64位文件大小和偏移量的新扩展API透明地替换了旧API。</p></dd></dl>

<dl>
<dt id="index-munmap">函数： <em>int</em> <strong>munmap</strong> <em>（无效* <var>addr</var> ，size_t <var>length</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>munmap</code>从（删除所有内存映射<var>addr</var> ） 至 （ <var>addr</var> + <var>length</var> ）。 <var>length</var>应该是映射的长度。
</p>
<p>在一个命令中取消映射多个映射或在范围中包含未映射的空间是安全的。也可以仅取消映射现有映射的一部分。但是，只能删除整个页面。如果<var>length</var>如果页数不是偶数，则会四舍五入。
</p>
<p>返回<em>0</em>表示成功，返回<em>-1</em>表示错误。
</p>
<p>可能出现一个错误：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>给定的内存范围超出了用户的mmap范围，或者页面未对齐。
</p>
</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-msync">函数： <em>int</em> <strong>msync</strong> <em>（无效* <var>address</var> ，size_t <var>length</var> ，int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>使用共享映射时，内核可以在删除映射之前的任何时间写入文件。要确定某些数据实际上已写入文件中并且可以被非内存映射的I / O访问，则必须使用此功能。
</p>
<p>它在该地区运营<var>address</var>至 （ <var>address</var> + <var>length</var> ）。它可以在一个映射或多个映射的一部分上使用，但是给定的区域不应包含任何未映射的空间。
</p>
<p><var>flags</var>可以包含一些选项：</p>
<dl compact>
<dt><code>MS_SYNC</code>
<span id="index-MS_005fSYNC"></span>
</dt>
<dd>
<p>此标志可确保将数据实际写入<em>磁盘</em> 。一般<code>msync</code>仅确保对具有常规I / O的文件的访问反映了最近的更改。
</p>
</dd>
<dt><code>MS_ASYNC</code>
<span id="index-MS_005fASYNC"></span>
</dt>
<dd>
<p>这说明<code>msync</code>开始同步，但不等待同步完成。
</p>

</dd>
</dl>

<p><code>msync</code>返回<em>0</em>表示成功， <em>-1</em>表示错误。错误包括：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>提供了无效的区域，或者<var>flags</var>是无效的。
</p>
</dd>
<dt><code>EFAULT</code></dt>
<dd><p>在给定区域的至少一部分中没有现有的映射。
</p>
</dd>
</dl>

</dd></dl>

<dl>
<dt id="index-mremap">功能： <em>void *</em> <strong>mremap</strong> <em>（void * <var>address</var> ，size_t <var>length</var> ，size_t <var>new_length</var> ，int <var>flag</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能可用于更改现有存储区的大小。 <var>address</var>和<var>length</var>必须覆盖完全相同的区域<code>mmap</code>声明。具有相同特征的新映射将返回长度<var>new_length</var> 。
</p>
<p>一种选择是可能的， <code>MREMAP_MAYMOVE</code> 。如果在<var>flags</var> ，系统可能会删除现有的映射，并在另一位置创建所需长度的新映射。
</p>
<p>返回结果映射的地址，或<em>-1</em> 。可能的错误代码包括：</p>
<dl compact>
<dt><code>EFAULT</code></dt>
<dd><p>在原始区域的至少一部分中没有现有的映射，或者该区域覆盖了两个或多个不同的映射。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>给定的地址未对齐或不合适。
</p>
</dd>
<dt><code>EAGAIN</code></dt>
<dd><p>该区域的页面已锁定，如果扩展，它将超过该进程对锁定页面的资源限制。请参阅<a href="Limits-on-Resources.html#Limits-on-Resources">资源限制</a> 。
</p>
</dd>
<dt><code>ENOMEM</code></dt>
<dd><p>该区域是私有可写的，并且没有足够的虚拟内存来扩展它。另外，如果发生此错误<code>MREMAP_MAYMOVE</code>没有给出，并且扩展名将与另一个映射的区域冲突。
</p>
</dd>
</dl>
</dd></dl>

<p>此功能仅在少数系统上可用。除了执行可选的优化之外，不应依赖此功能。
</p>
<p>并非所有文件描述符都可以映射。套接字，管道和大多数设备仅允许顺序访问，并且不适合映射抽象。此外，某些常规文件可能不可映射，而较早的内核可能根本不支持映射。因此，程序使用<code>mmap</code>如果失败，应该使用备用方法。请参阅<cite>GNU编码标准中的</cite> <a href="https://www.gnu.org/prep/standards/html_node/Mmap.html#Mmap">Mmap</a> 。
</p>
<dl>
<dt id="index-madvise">函数： <em>int</em> <strong>madvise</strong> <em>（无效* <var>addr</var> ，size_t <var>length</var> ，int <var>advice</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能可用于为系统提供<var>advice</var>关于存储区域的预期使用模式，从<var>addr</var>并扩展<var>length</var>个字节。
</p>
<p>的有效BSD值<var>advice</var>是：</p>
<dl compact>
<dt><code>MADV_NORMAL</code>
<span id="index-MADV_005fNORMAL"></span>
</dt>
<dd><p>该地区不应再接受任何特殊待遇。
</p>
</dd>
<dt><code>MADV_RANDOM</code>
<span id="index-MADV_005fRANDOM"></span>
</dt>
<dd><p>该区域将通过随机页面引用进行访问。内核应为每个页面错误分页最少数量的页面。
</p>
</dd>
<dt><code>MADV_SEQUENTIAL</code>
<span id="index-MADV_005fSEQUENTIAL"></span>
</dt>
<dd><p>该区域将通过顺序页面引用进行访问。这可能会导致内核主动预读，从而导致该区域内发生任何页面错误之后都需要进一步的顺序引用。
</p>
</dd>
<dt><code>MADV_WILLNEED</code>
<span id="index-MADV_005fWILLNEED"></span>
</dt>
<dd><p>该区域将是必需的。该区域内的页面可能已由内核预故障。
</p>
</dd>
<dt><code>MADV_DONTNEED</code>
<span id="index-MADV_005fDONTNEED"></span>
</dt>
<dd><p>不再需要该区域。内核可能会释放这些页面，从而导致对页面的任何更改都丢失，并且换出的页面将被丢弃。
</p>
</dd>
<dt><code>MADV_HUGEPAGE</code>
<span id="index-MADV_005fHUGEPAGE"></span>
</dt>
<dd>
<p>表示增加此映射的页面大小是有益的。这可以提高大型映射的性能，因为系统需要处理的页面要少得多。但是，如果映射的某些部分在存储或不同节点之间频繁传输，则性能可能会受到影响，因为由于页面大小的增加，各个传输可能会变得非常大。
</p>
<p>该标志特定于Linux。
</p>
</dd>
<dt><code>MADV_NOHUGEPAGE</code>
<span id="index-MADV_005fNOHUGEPAGE"></span>
</dt>
<dd><p>撤消先前的效果<code>MADV_HUGEPAGE</code>建议。该标志特定于Linux。
</p>
</dd>
</dl>

<p>POSIX名称略有不同，但含义相同：</p>
<dl compact>
<dt><code>POSIX_MADV_NORMAL</code>
<span id="index-POSIX_005fMADV_005fNORMAL"></span>
</dt>
<dd><p>这与BSD的<code>MADV_NORMAL</code> 。
</p>
</dd>
<dt><code>POSIX_MADV_RANDOM</code>
<span id="index-POSIX_005fMADV_005fRANDOM"></span>
</dt>
<dd><p>这与BSD的<code>MADV_RANDOM</code> 。
</p>
</dd>
<dt><code>POSIX_MADV_SEQUENTIAL</code>
<span id="index-POSIX_005fMADV_005fSEQUENTIAL"></span>
</dt>
<dd><p>这与BSD的<code>MADV_SEQUENTIAL</code> 。
</p>
</dd>
<dt><code>POSIX_MADV_WILLNEED</code>
<span id="index-POSIX_005fMADV_005fWILLNEED"></span>
</dt>
<dd><p>这与BSD的<code>MADV_WILLNEED</code> 。
</p>
</dd>
<dt><code>POSIX_MADV_DONTNEED</code>
<span id="index-POSIX_005fMADV_005fDONTNEED"></span>
</dt>
<dd><p>这与BSD的<code>MADV_DONTNEED</code> 。
</p>
</dd>
</dl>

<p><code>madvise</code>返回<em>0</em>表示成功， <em>-1</em>表示错误。错误包括：</p><dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>提供了无效的区域，或者<var>advice</var>无效。
</p>
</dd>
<dt><code>EFAULT</code></dt>
<dd><p>在给定区域的至少一部分中没有现有的映射。
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt id="index-shm_005fopen">功能： <em>int</em> <strong>shm_open</strong> <em>（const char * <var>name</var> ，int <var>oflag</var> ，mode_t <var>mode</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全初始化堆锁| AC不安全锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>该函数返回一个文件描述符，该文件描述符可用于通过mmap分配共享内存。不相关的流程可以使用相同的流程<var>name</var>创建或打开现有的共享内存对象。
</p>
<p>一种<var>name</var>参数指定要打开的共享内存对象。在GNU C库中，它的字符串必须小于<code>NAME_MAX</code>以可选斜杠开头但不包含其他斜杠的字节。
</p>
<p>的语义<var>oflag</var>和<var>mode</var>参数与中相同<code>open</code> 。
</p>
<p><code>shm_open</code>如果成功则返回文件描述符，如果错误则返回<em>-1</em> 。失败时<code>errno</code>被设置。
</p></dd></dl>

<dl>
<dt id="index-shm_005funlink">函数： <em>int</em> <strong>shm_unlink</strong> <em>（const char * <var>name</var> ）</em></dt>
<dd><p>初步： MT安全区域| AS不安全初始化堆锁| AC不安全锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数是<code>shm_open</code>并删除给定的对象<var>name</var>先前由<code>shm_open</code> 。
</p>
<p><code>shm_unlink</code>成功返回<em>0</em> ，错误返回<em>-1</em> 。失败时<code>errno</code>被设置。
</p></dd></dl>

<dl>
<dt id="index-memfd_005fcreate">函数： <em>int</em> <strong>memfd_create</strong> <em>（const char * <var>name</var> ，unsigned int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>memfd_create</code>函数返回一个文件描述符，该文件描述符可用于使用<code>mmap</code>功能。它类似于<code>shm_open</code>从某种意义上说，这些映射不受实际文件的支持。但是，描述符由<code>memfd_create</code>不对应于命名对象；的<var>name</var>参数仅用于调试目的（例如，将出现在<samp>/proc</samp> ），并分别调用<code>memfd_create</code>一样的<var>name</var>不会返回相同内存区域的描述符。描述符也可用于在同一过程中创建别名映射。
</p>
<p>描述符最初是指零长度的文件。在创建由内存支持的映射之前，需要使用以下命令增加文件大小： <code>ftruncate</code>功能。请参阅<a href="File-Size.html#File-Size">文件大小</a> 。
</p>
<p>的<var>flags</var>参数可以是以下标志的组合：</p>
<dl compact>
<dt><code>MFD_CLOEXEC</code>
<span id="index-MFD_005fCLOEXEC"></span>
</dt>
<dd>
<p>描述符是使用<code>O_CLOEXEC</code>旗。
</p>
</dd>
<dt><code>MFD_ALLOW_SEALING</code>
<span id="index-MFD_005fALLOW_005fSEALING"></span>
</dt>
<dd>
<p>描述符支持使用<code>fcntl</code>功能。
</p>
</dd>
<dt><code>MFD_HUGETLB</code>
<span id="index-MFD_005fHUGETLB"></span>
</dt>
<dd>
<p>这要求使用返回的文件描述符创建的映射使用更大的页面大小。看到<code>MAP_HUGETLB</code>上面有详细信息。
</p>
<p>该标志与<code>MFD_ALLOW_SEALING</code> 。
</p></dd>
</dl>

<p><code>memfd_create</code>成功返回文件描述符，失败返回<em>-1</em> 。
</p>
<p>下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>在中指定了无效的组合<var>flags</var> ， 要么<var>name</var>太长。
</p>
</dd>
<dt><code>EFAULT</code></dt>
<dd><p>的<var>name</var>参数不指向字符串。
</p>
</dd>
<dt><code>EMFILE</code></dt>
<dd><p>该操作将超出此过程的文件描述符限制。
</p>
</dd>
<dt><code>ENFILE</code></dt>
<dd><p>该操作将超出系统范围的文件描述符限制。
</p>
</dd>
<dt><code>ENOMEM</code></dt>
<dd><p>没有足够的内存用于该操作。
</p></dd>
</dl>
</dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Waiting-for-I_002fO.html#Waiting-for-I_002fO" rel="next" accesskey="n">等待I / O</a> ，上一篇： <a href="Copying-File-Data.html#Copying-File-Data" rel="prev" accesskey="p">复制文件数据</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>