<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>页面锁定功能（GNU C库）</title>

<meta name="description" content="Page Lock Functions (The GNU C Library)">
<meta name="keywords" content="Page Lock Functions (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Locking-Pages.html#Locking-Pages" rel="up" title="Locking Pages">
<link href="Character-Handling.html#Character-Handling" rel="next" title="Character Handling">
<link href="Locked-Memory-Details.html#Locked-Memory-Details" rel="prev" title="Locked Memory Details">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Page-Lock-Functions"></span><div class="header">
<p>上一页： <a href="Locked-Memory-Details.html#Locked-Memory-Details" rel="prev" accesskey="p">锁定内存的详细信息</a> ，向上： <a href="Locking-Pages.html#Locking-Pages" rel="up" accesskey="u">锁定页面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Functions-To-Lock-And-Unlock-Pages"></span><h4 class="subsection">3.5.3锁定和解锁页面的功能</h4>

<p>本节中的符号在<samp>sys/mman.h</samp> 。这些功能由POSIX.1b定义，但是其可用性取决于您的内核。如果您的内核不允许使用这些功能，则它们存在但始终会失败。<em>它们</em>可与Linux内核。
</p>
<p><strong>可移植性注意：</strong> POSIX.1b要求当<code>mlock</code>和<code>munlock</code>功能可用，文件<samp>unistd.h</samp>定义宏<code>_POSIX_MEMLOCK_RANGE</code>和文件<code>limits.h</code>定义宏<code>PAGESIZE</code>为内存页面的大小（以字节为单位）。它要求当<code>mlockall</code>和<code>munlockall</code>功能可用， <samp>unistd.h</samp>文件定义宏<code>_POSIX_MEMLOCK</code> 。GNU C库符合此要求。
</p>
<dl>
<dt id="index-mlock">功能： <em>int</em> <strong>mlock</strong> <em>（const void * <var>addr</var> ，size_t <var>len</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>mlock</code>锁定一系列调用进程的虚拟页面。
</p>
<p>内存范围从地址开始<var>addr</var>并且是<var>len</var>个字节长。实际上，由于必须锁定整个页面，因此页面范围包括指定范围的任何部分。
</p>
<p>当函数成功返回时，这些页面中的每一个都由一个真实框架（驻留）支持（连接）并标记为保持这种状态。这意味着该功能可能会导致分页并且必须等待它们。
</p>
<p>该功能失败时，不会影响任何页面的锁定状态。
</p>
<p>如果函数成功，则返回值为零。不然是<code>-1</code>和<code>errno</code>被相应地设置。 <code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>ENOMEM</code></dt>
<dd><ul>
<li>调用过程的虚拟地址空间中至少不存在某些指定的地址范围。
</li><li>锁定将导致进程超过其锁定的页面限制。
</li></ul>

</dd>
<dt><code>EPERM</code></dt>
<dd><p>调用过程不是超级用户。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>len</var>是不积极的。
</p>
</dd>
<dt><code>ENOSYS</code></dt>
<dd><p>内核不提供<code>mlock</code>能力。
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt id="index-mlock2">功能： <em>int</em> <strong>mlock2</strong> <em>（const void * <var>addr</var> ，size_t <var>len</var> ，unsigned int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>该功能类似于<code>mlock</code> 。如果<var>flags</var>为零，调用<code>mlock2</code>的行为与对的等效调用完全相同<code>mlock</code> 。
</p>
<p>的<var>flags</var>参数必须是零个或多个以下标志的组合：</p>
<dl compact>
<dt><code>MLOCK_ONFAULT</code>
<span id="index-MLOCK_005fONFAULT"></span>
</dt>
<dd>
<p>只有在指定地址范围内已在内存中的那些页面才被立即锁定。如果出现页面错误和内存分配，该范围内的其他页面将自动锁定。
</p></dd>
</dl>

<p>喜欢<code>mlock</code> ， <code>mlock2</code>成功返回零，并且<code>-1</code>失败时，设置<code>errno</code>相应地。额外<code>errno</code>为以下定义的值<code>mlock2</code>是：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>指定（非零） <var>flags</var>系统不支持该参数。
</p></dd>
</dl>
</dd></dl>

<p>您可以使用以下命令锁定<em>所有</em>进程的内存<code>mlockall</code> 。您可以通过以下方式解锁内存<code>munlock</code>要么<code>munlockall</code> 。
</p>
<p>为了避免C程序中的所有页面错误，您必须使用<code>mlockall</code> ，因为程序使用的某些内存已从C代码中隐藏，例如堆栈和自动变量，并且您不知道要告诉什么地址<code>mlock</code> 。
</p>
<dl>
<dt id="index-munlock">函数： <em>int</em> <strong>munlock</strong> <em>（const void * <var>addr</var> ，size_t <var>len</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>munlock</code>解锁一系列调用进程的虚拟页面。
</p>
<p><code>munlock</code>是...的逆<code>mlock</code>并完全类似于<code>mlock</code> ，除了没有<code>EPERM</code>失败。
</p>
</dd></dl>

<dl>
<dt id="index-mlockall">函数： <em>int</em> <strong>mlockall</strong> <em>（int <var>flags</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>mlockall</code>锁定进程的虚拟内存地址空间中的所有页面，和/或将来添加到该页面的任何页面。这包括代码，数据和堆栈段的页面，以及共享库，用户空间内核数据，共享内存和内存映射文件。
</p>
<p><var>flags</var>是由以下宏表示的单个位标志的字符串。他们告诉<code>mlockall</code>您想要哪个功能。所有其他位必须为零。
</p>
<dl compact>
<dt><code>MCL_CURRENT</code>
<span id="index-MCL_005fCURRENT"></span>
</dt>
<dd><p>锁定当前在调用进程的虚拟地址空间中存在的所有页面。
</p>
</dd>
<dt><code>MCL_FUTURE</code>
<span id="index-MCL_005fFUTURE"></span>
</dt>
<dd><p>设置一种模式，以防止将来添加到该进程的虚拟地址空间的任何页面被锁定。此模式不会影响同一进程将来拥有的地址空间，因此exec（它将替换进程的地址空间）将清除掉<code>MCL_FUTURE</code> 。请参阅<a href="Executing-a-File.html#Executing-a-File">执行文件</a> 。
</p>
</dd>
</dl>

<p>函数成功返回后，您指定了<code>MCL_CURRENT</code> ，所有流程的页面均以（连接到）真实框架（它们驻留）为后盾，并被标记为保持这种方式。这意味着该功能可能会导致分页并且必须等待它们。
</p>
<p>当过程进行中<code>MCL_FUTURE</code>模式，因为它成功执行了此功能并指定了<code>MCL_CURRENT</code> ，该进程要求将空间添加到其虚拟地址空间的任何系统调用都会失败<code>errno</code> = <code>ENOMEM</code>如果锁定额外的空间将导致该进程超出其锁定的页面限制。如果无法容纳的地址空间增加是堆栈扩展，则堆栈扩展将失败并且内核将发送一个<code>SIGSEGV</code>向过程发出信号。
</p>
<p>该功能失败时，它不会影响任何页面的锁定状态或将来的锁定模式。
</p>
<p>如果函数成功，则返回值为零。不然是<code>-1</code>和<code>errno</code>被相应地设置。 <code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>ENOMEM</code></dt>
<dd><ul>
<li>调用过程的虚拟地址空间中至少不存在某些指定的地址范围。
</li><li>锁定将导致进程超过其锁定的页面限制。
</li></ul>

</dd>
<dt><code>EPERM</code></dt>
<dd><p>调用过程不是超级用户。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>中的未定义位<var>flags</var>不为零。
</p>
</dd>
<dt><code>ENOSYS</code></dt>
<dd><p>内核不提供<code>mlockall</code>能力。
</p>
</dd>
</dl>

<p>您可以仅锁定特定页面<code>mlock</code> 。您可以使用来解锁页面<code>munlockall</code>和<code>munlock</code> 。
</p>
</dd></dl>


<dl>
<dt id="index-munlockall">函数： <em>int</em> <strong>munlockall</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p><code>munlockall</code>解锁调用进程的虚拟地址空间中的每个页面并关闭<code>MCL_FUTURE</code>将来的锁定模式。
</p>
<p>如果函数成功，则返回值为零。不然是<code>-1</code>和<code>errno</code>被相应地设置。此函数失败的唯一方法是出于通用原因，即所有函数和系统调用都可能失败，因此没有特定的<code>errno</code>价值观。
</p>
</dd></dl>








<hr>
<div class="header">
<p>上一页： <a href="Locked-Memory-Details.html#Locked-Memory-Details" rel="prev" accesskey="p">锁定内存的详细信息</a> ，向上： <a href="Locking-Pages.html#Locking-Pages" rel="up" accesskey="u">锁定页面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>