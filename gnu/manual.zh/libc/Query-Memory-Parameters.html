<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>查询内存参数（GNU C库）</title>

<meta name="description" content="Query Memory Parameters (The GNU C Library)">
<meta name="keywords" content="Query Memory Parameters (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Memory-Resources.html#Memory-Resources" rel="up" title="Memory Resources">
<link href="Processor-Resources.html#Processor-Resources" rel="next" title="Processor Resources">
<link href="Memory-Subsystem.html#Memory-Subsystem" rel="prev" title="Memory Subsystem">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Query-Memory-Parameters"></span><div class="header">
<p>上一篇： <a href="Memory-Subsystem.html#Memory-Subsystem" rel="prev" accesskey="p">内存子系统</a> ，上一篇： <a href="Memory-Resources.html#Memory-Resources" rel="up" accesskey="u">内存资源</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="How-to-get-information-about-the-memory-subsystem_003f"></span><h4 class="subsection">22.4.2如何获取有关内存子系统的信息？</h4>

<p>在几种情况下，了解进程所看到的虚拟内存的页面大小至关重要。一些编程接口（例如， <code>mmap</code> ，请参阅<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存映射I / O</a> ），要求用户提供根据页面大小调整的信息。如果是<code>mmap</code>必须提供一个长度参数，该参数是页面大小的倍数。关于页面大小的知识有用的另一个地方是内存分配。如果将内存分配为较大的块，然后再由应用程序代码细分，则将较大块的大小调整为页面大小将很有用。如果该块的总内存需求接近（但不大于）页面大小的倍数，则内核的内存处理可以更有效地工作，因为它只需要分配已完全使用的内存页面。（要进行此优化，有必要了解一些有关内存分配器的知识，这将需要为每个块本身分配一些内存，并且此开销不得使总大小超过页面大小的倍数。）
</p>
<p>传统上，页面大小是编译时间常数。但是处理器的最新发展改变了这一情况。现在，处理器支持不同的页面大小，并且它们甚至可能在同一系统上的不同进程之间有所不同。因此，应在运行时向系统查询当前页面大小，并且不做任何假设（除非假设是2的幂）。
</p>
<span id="index-_005fSC_005fPAGESIZE-1"></span>
<p>查询页面大小的正确界面是<code>sysconf</code> （请参阅<a href="Sysconf-Definition.html#Sysconf-Definition">Sysconf定义</a> ）与参数<code>_SC_PAGESIZE</code> 。还有一个更老的界面。
</p>
<dl>
<dt id="index-getpagesize">函数： <em>int</em> <strong>getpagesize</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>getpagesize</code>函数返回进程的页面大小。该值在流程的运行时是固定的，但在应用程序的不同运行中可能会有所不同。
</p>
<p>该函数在<samp>unistd.h</samp> 。
</p></dd></dl>

<p>在系统V <!-- /@w -->派生的系统上可广泛使用的一种方法是获取有关系统所具有的物理内存的信息。通话</p>
<span id="index-_005fSC_005fPHYS_005fPAGES"></span>
<span id="index-sysconf"></span>
<div class="example">
<pre class="example">  sysconf (_SC_PHYS_PAGES)
</pre></div>

<p>返回系统具有的物理内存的总页数。这并不意味着所有这些内存都可用。可以使用以下信息找到此信息</p>
<span id="index-_005fSC_005fAVPHYS_005fPAGES"></span>
<span id="index-sysconf-1"></span>
<div class="example">
<pre class="example">  sysconf (_SC_AVPHYS_PAGES)
</pre></div>

<p>这两个值有助于优化应用程序。返回的值<code>_SC_AVPHYS_PAGES</code>是应用程序可以使用而不会妨碍任何其他进程的内存量（假设没有其他进程会增加其内存使用量）。返回的值<code>_SC_PHYS_PAGES</code>是工作集的一个硬性限制。如果所有应用程序在一起使用的内存总是超过该数量，则系统将出现问题。
</p>
<p>除了这些已经描述的方式之外，GNU C库还提供了获取该信息的两个功能。它们在文件中声明<samp>sys/sysinfo.h</samp> 。程序员应该更喜欢使用<code>sysconf</code>上述方法。
</p>
<dl>
<dt id="index-get_005fphys_005fpages">函数： <em>long int</em> <strong>get_phys_pages</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>get_phys_pages</code>函数返回系统拥有的物理内存的总页数。要获得内存量，必须将该数字乘以页面大小。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-get_005favphys_005fpages">函数： <em>long int</em> <strong>get_avphys_pages</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆锁| AC不安全锁fd mem |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>get_avphys_pages</code>函数返回系统具有的物理内存的可用页数。要获得内存量，必须将该数字乘以页面大小。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<hr>
<div class="header">
<p>上一篇： <a href="Memory-Subsystem.html#Memory-Subsystem" rel="prev" accesskey="p">内存子系统</a> ，上一篇： <a href="Memory-Resources.html#Memory-Resources" rel="up" accesskey="u">内存资源</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>