<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>64位时间符号处理（GNU C库）</title>

<meta name="description" content="64-bit time symbol handling (The GNU C Library)">
<meta name="keywords" content="64-bit time symbol handling (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Symbol-handling.html#Symbol-handling" rel="up" title="Symbol handling">
<link href="Porting.html#Porting" rel="next" title="Porting">
<link href="Symbol-handling.html#Symbol-handling" rel="prev" title="Symbol handling">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="g_t64_002dbit-time-symbol-handling"></span><div class="header">
<p>上一篇： <a href="Symbol-handling.html#Symbol-handling" rel="up" accesskey="u">符号处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="g_t64_002dbit-time-symbol-handling-in-the-GNU-C-Library"></span><h4 class="appendixsubsec">D.2.1 GNU C库中的64位时间符号处理</h4>

<p>关于时间处理，GNU C库配置根据其值分为两类。 <code>__TIMESIZE</code> ：</p>
<dl compact>
<dt><code><code>__TIMESIZE == 32</code></code></dt>
<dd>
<p>这些<em>双重时间</em>配置具有32位和64位时间支持。 32位时间支持提供类型<code>time_t</code>并且无法处理<em>Y2038之后的</em>日期。 64位时间支持提供了类型<code>__time64_t</code>并且可以处理<em>Y2038之后的</em>日期。
</p>
<p>在这些配置中，与时间相关的类型有两个声明，一个是64位，一个是32位。与时间相关的函数通常有两个定义：一个64位定义和一个32位定义，后者是前者的包装。因此，对于每个<code>time_t</code>相关符号，有一个对应的<code>__time64_t</code>相关的符号，其名称通常是带有32位符号的名称<code>__</code> （双下划线）和<code>64</code>附加。例如，64位时间对应<code>clock_gettime</code>是<code>__clock_gettime64</code> 。
</p>
</dd>
<dt><code><code>__TIMESIZE == 64</code></code></dt>
<dd>
<p>这些<em>一次性</em>配置仅具有64位<code>time_t</code>和相关功能，可以处理2038-01-19 03:14:07之后的日期（又名<em>Y2038</em> ）。
</p>
<p>在这些配置中，与时间相关的类型仅具有64位声明。与时间相关的函数只有一个64位定义。但是，对于每个<code>time_t</code>相关符号，有一个对应的<code>__time64_t</code> -与宏相关的宏，其名称是在双重配置情况下派生的，并且扩展为符号的名称。例如，宏<code>__clock_gettime64</code>扩展到<code>clock_gettime</code> 。
</p>
<p>这些宏纯粹在GNU C库内部，并且仅存在，因此可以在单次和双重时间配置中使用64位时间函数的单个定义，并且glibc代码可以自由调用64位时间函数。位在所有配置中都在内部起作用。
</p>
</dd>
</dl>


<p>注意：目前，双时间配置中的64位时间支持仍在进行中，因此对于这些配置，公共API仅使32位时间支持可用。在以后的更改中，公共API将允许用户代码选择给定编译单元的时间大小。
</p>
<p>为所有配置定义了与时间相关的类型或功能的64位变体，并使用64位时间符号名称（对于双时间配置）或宏（对于单时间配置）。
</p>
<p>与时间相关的类型或功能的32位变体仅针对双重时间配置进行定义。
</p>
<p>这是一个例子<code>localtime</code> ：</p>
<p>功能<code>localtime</code>在中声明<samp>time/time.h</samp>如</p><div class="example">
<pre class="example">extern struct tm *localtime (const time_t *__timer) __THROW;
libc_hidden_proto (localtime)
</pre></div>

<p>对于一次性配置， <code>__localtime64</code>是一个宏，其计算结果为<code>localtime</code> ;对于双重时间配置， <code>__localtime64</code>是类似于<code>localtime</code>除了使用Y2038认证类型：</p><div class="example">
<pre class="example">#if __TIMESIZE == 64
# define __localtime64 localtime
#else
extern struct tm *__localtime64 (const __time64_t *__timer) __THROW;
libc_hidden_proto (__localtime64)
#endif
</pre></div>

<p>（注意：类型<code>time_t</code>被替换为<code>__time64_t</code>因为<code>time_t</code>不是Y2038认证的，但是<code>struct tm</code>未更换，因为它已经过Y2038认证。）
</p>
<p>64位时间的实现<code>localtime</code>编写如下，并针对双重时间配置类和单一时间配置类进行了编译。
</p>
<div class="example">
<pre class="example">struct tm *
__localtime64 (const __time64_t *t)
{
  return __tz_convert (*t, 1, &amp;_tmbuf);
}
libc_hidden_def (__localtime64)
</pre></div>

<p>32位时间的实现是包装程序，仅针对双时间配置进行编译：</p>
<div class="example">
<pre class="example">#if __TIMESIZE != 64

struct tm *
localtime (const time_t *t)
{
  __time64_t t64 = *t;
  return __localtime64 (&amp;t64);
}
libc_hidden_def (localtime)

#endif
</pre></div>

<hr>
<div class="header">
<p>上一篇： <a href="Symbol-handling.html#Symbol-handling" rel="up" accesskey="u">符号处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>