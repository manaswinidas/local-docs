<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>复制字符串和数组（GNU C库）</title>

<meta name="description" content="Copying Strings and Arrays (The GNU C Library)">
<meta name="keywords" content="Copying Strings and Arrays (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Concatenating-Strings.html#Concatenating-Strings" rel="next" title="Concatenating Strings">
<link href="String-Length.html#String-Length" rel="prev" title="String Length">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Copying-Strings-and-Arrays"></span><div class="header">
<p>下一页： <a href="Concatenating-Strings.html#Concatenating-Strings" rel="next" accesskey="n">串联字符串</a> ，上一页： <a href="String-Length.html#String-Length" rel="prev" accesskey="p">字符串长度</a> ，向上： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Copying-Strings-and-Arrays-1"></span><h3 class="section">5.4复制字符串和数组</h3>

<p>您可以使用本节中描述的功能来复制字符串，宽字符串和数组的内容。' <samp>str</samp> '和' <samp>mem</samp> '函数在<samp>string.h</samp>而“ <samp>w</samp> '函数在<samp>wchar.h</samp> 。
<span id="index-string_002eh-1"></span>
<span id="index-wchar_002eh"></span>
<span id="index-copying-strings-and-arrays"></span>
<span id="index-string-copy-functions"></span>
<span id="index-array-copy-functions"></span>
<span id="index-concatenating-strings"></span>
<span id="index-string-concatenation-functions"></span>
</p>
<p>记住本节中函数参数的顺序的一种有用方法是，它与赋值表达式相对应，目标数组指定在源数组的左侧。这些函数中的大多数都返回目标数组的地址。一些返回目标的终止null的地址，或者刚刚返回目标的地址。
</p>
<p>如果源阵列和目标阵列重叠，则大多数这些功能将无法正常工作。例如，如果目标数组的开头与源数组的结尾重叠，则源数组的该部分的原始内容在被复制之前可能会被覆盖。更糟糕的是，在使用字符串函数的情况下，可能会丢失标记字符串结尾的空字节，并且复制函数可能会陷入循环中，从而浪费分配给程序的所有内存。
</p>
<p>本手册中明确指出了在重叠数组之间复制时遇到问题的所有函数。除了本节中的功能外，还有一些其他功能，例如<code>sprintf</code> （请参见<a href="Formatted-Output-Functions.html#Formatted-Output-Functions">格式化输出函数</a> ）和<code>scanf</code> （请参阅<a href="Formatted-Input-Functions.html#Formatted-Input-Functions">格式化的输入函数</a> ）。
</p>
<dl>
<dt id="index-memcpy">函数： <em>void *</em> <strong>memcpy</strong> <em>（无效* restrict <var>to</var> ，const void *限制<var>from</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>memcpy</code>功能副本<var>size</var>从对象开始的字节数<var>from</var>进入对象开始于<var>to</var> 。如果两个数组，此函数的行为是不确定的<var>to</var>和<var>from</var>交叠;使用<code>memmove</code>相反，如果有可能重叠。
</p>
<p>传回的值<code>memcpy</code>是...的价值<var>to</var> 。
</p>
<p>这是您可能如何使用的示例<code>memcpy</code>复制数组的内容：</p>
<div class="example">
<pre class="example">struct foo *oldarray, *newarray;
int arraysize;
&hellip;
memcpy (new, old, arraysize * sizeof (struct foo));
</pre></div>
</dd></dl>

<dl>
<dt id="index-wmemcpy">函数： <em>wchar_t *</em> <strong>wmemcpy</strong> <em>（wchar_t *限制<var>wto</var> ，const wchar_t *限制<var>wfrom</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wmemcpy</code>功能副本<var>size</var>从对象开始的宽字符<var>wfrom</var>进入对象开始于<var>wto</var> 。如果两个数组，此函数的行为是不确定的<var>wto</var>和<var>wfrom</var>交叠;使用<code>wmemmove</code>相反，如果有可能重叠。
</p>
<p>以下是可能的实现<code>wmemcpy</code>但还有更多优化的可能。
</p>
<div class="example">
<pre class="example">wchar_t *
wmemcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
         size_t size)
{
  return (wchar_t *) memcpy (wto, wfrom, size * sizeof (wchar_t));
}
</pre></div>

<p>传回的值<code>wmemcpy</code>是...的价值<var>wto</var> 。
</p>
<p>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入了此功能。
</p></dd></dl>

<dl>
<dt id="index-mempcpy">函数： <em>void *</em> <strong>mempcpy</strong> <em>（无效* restrict <var>to</var> ，const void *限制<var>from</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>mempcpy</code>功能几乎与<code>memcpy</code>功能。它复制<var>size</var>从对象开始的字节数<code>from</code>进入由指向的对象<var>to</var> 。但是与其返回值<var>to</var>它返回一个指向对象中最后一个写入字节之后的字节的指针，该字节始于<var>to</var> 。即，值是<code>((void *) ((char *) <var>to</var> + <var>size</var>))</code> 。
</p>
<p>在将多个对象复制到连续存储位置的情况下，此功能很有用。
</p>
<div class="example">
<pre class="example">void *
combine (void *o1, size_t s1, void *o2, size_t s2)
{
  void *result = malloc (s1 + s2);
  if (result != NULL)
    mempcpy (mempcpy (result, o1, s1), o2, s2);
  return result;
}
</pre></div>

<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-wmempcpy">函数： <em>wchar_t *</em> <strong>wmempcpy</strong> <em>（wchar_t *限制<var>wto</var> ，const wchar_t *限制<var>wfrom</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wmempcpy</code>功能几乎与<code>wmemcpy</code>功能。它复制<var>size</var>从对象开始的宽字符<code>wfrom</code>进入由指向的对象<var>wto</var> 。但是与其返回值<var>wto</var>它返回指针，该指针指向对象中最后一个写入的宽字符之后的宽字符，从<var>wto</var> 。即，值是<code><var>wto</var> + <var>size</var></code> 。
</p>
<p>在将多个对象复制到连续存储位置的情况下，此功能很有用。
</p>
<p>以下是可能的实现<code>wmemcpy</code>但还有更多优化的可能。
</p>
<div class="example">
<pre class="example">wchar_t *
wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
          size_t size)
{
  return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
}
</pre></div>

<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-memmove">函数： <em>void *</em> <strong>memmove</strong> <em>（void * <var>to</var> ，const void * <var>from</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>memmove</code>复制<var>size</var>的字节数<var>from</var>进入<var>size</var>的字节数<var>to</var> ，即使这两个空间块重叠。在重叠的情况下， <code>memmove</code>小心复制块中字节的原始值<var>from</var> ，包括那些也属于块的字节<var>to</var> 。
</p>
<p>传回的值<code>memmove</code>是...的价值<var>to</var> 。
</p></dd></dl>

<dl>
<dt id="index-wmemmove">函数： <em>wchar_t *</em> <strong>wmemmove</strong> <em>（wchar_t * <var>wto</var> ，const wchar_t * <var>wfrom</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>wmemmove</code>复制<var>size</var>宽字符<var>wfrom</var>进入<var>size</var>宽字符<var>wto</var> ，即使这两个空间块重叠。在重叠的情况下， <code>wmemmove</code>小心复制块中宽字符的原始值<var>wfrom</var> ，包括那些也属于块的宽字符<var>wto</var> 。
</p>
<p>以下是可能的实现<code>wmemcpy</code>但还有更多优化的可能。
</p>
<div class="example">
<pre class="example">wchar_t *
wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
          size_t size)
{
  return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
}
</pre></div>

<p>传回的值<code>wmemmove</code>是...的价值<var>wto</var> 。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-memccpy">函数： <em>void *</em> <strong>memccpy</strong> <em>（无效* restrict <var>to</var> ，const void *限制<var>from</var> ，int <var>c</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能复制不超过<var>size</var>来自的字节<var>from</var>至<var>to</var> ，如果字节匹配则停止<var>c</var>被发现。返回值是一个指向<var>to</var>过去一个字节<var>c</var>复制，如果没有字节匹配，则返回空指针<var>c</var>出现在第一个<var>size</var>个字节<var>from</var> 。
</p></dd></dl>

<dl>
<dt id="index-memset">功能： <em>void *</em> <strong>memset</strong> <em>（void * <var>block</var> ，int <var>c</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数复制值<var>c</var> （转换为<code>unsigned char</code> ）进入第一个<var>size</var>对象的字节开始于<var>block</var> 。它返回的值<var>block</var> 。
</p></dd></dl>

<dl>
<dt id="index-wmemset">函数： <em>wchar_t *</em> <strong>wmemset</strong> <em>（wchar_t * <var>block</var> ，wchar_t <var>wc</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数复制值<var>wc</var>进入第一个<var>size</var>对象的宽字符开始于<var>block</var> 。它返回的值<var>block</var> 。
</p></dd></dl>

<dl>
<dt id="index-strcpy">函数： <em>char *</em> <strong>strcpy</strong> <em>（char *限制<var>to</var> ，const char *限制<var>from</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这将从字符串中复制字节<var>from</var> （直到并包括终止空字节）到字符串中<var>to</var> 。喜欢<code>memcpy</code> ，如果字符串重叠，则此函数的结果不确定。返回值是<var>to</var> 。
</p></dd></dl>

<dl>
<dt id="index-wcscpy">功能： <em>wchar_t *</em> <strong>wcscpy</strong> <em>（wchar_t * restrict <var>wto</var> ，const wchar_t *限制<var>wfrom</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这将从宽字符串中复制宽字符<var>wfrom</var> （直到并包括终止的空宽字符）到字符串中<var>wto</var> 。喜欢<code>wmemcpy</code> ，如果字符串重叠，则此函数的结果不确定。返回值是<var>wto</var> 。
</p></dd></dl>

<dl>
<dt id="index-strdup">函数： <em>char *</em> <strong>strdup</strong> <em>（const char * <var>s</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数复制字符串<var>s</var>放入新分配的字符串中。该字符串使用<code>malloc</code> ;请参阅<a href="Unconstrained-Allocation.html#Unconstrained-Allocation">无限制分配</a> 。如果<code>malloc</code>无法为新字符串分配空间， <code>strdup</code>返回一个空指针。否则，它将返回指向新字符串的指针。
</p></dd></dl>

<dl>
<dt id="index-wcsdup">函数： <em>wchar_t *</em> <strong>wcsdup</strong> <em>（常量wchar_t * <var>ws</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数复制宽字符串<var>ws</var>放入新分配的字符串中。该字符串使用<code>malloc</code> ;请参阅<a href="Unconstrained-Allocation.html#Unconstrained-Allocation">无限制分配</a> 。如果<code>malloc</code>无法为新字符串分配空间， <code>wcsdup</code>返回一个空指针。否则，它将返回一个指向新宽字符串的指针。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-stpcpy">函数： <em>char *</em> <strong>stpcpy</strong> <em>（char *限制<var>to</var> ，const char *限制<var>from</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>strcpy</code> ，除了它返回指向字符串末尾的指针<var>to</var> （即终止空字节的地址<code>to + strlen (from)</code> ），而不是开始。
</p>
<p>例如，该程序使用<code>stpcpy</code>串联' <samp>foo</samp> '和' <samp>bar</samp> ' 生产 ' <samp>foobar</samp> '，然后打印出来。
</p>
<div class="example">
<pre class="example">

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int
main (void)
{
  char buffer[10];
  char *to = buffer;
  to = stpcpy (to, &quot;foo&quot;);
  to = stpcpy (to, &quot;bar&quot;);
  puts (buffer);
  return 0;
}
</pre></div>

<p>此功能是POSIX.1-2008及更高版本的一部分，但在标准化之前很久就已在GNU C库和其他系统中使用。
</p>
<p>如果字符串重叠，则其行为是不确定的。该函数在<samp>string.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-wcpcpy">函数： <em>wchar_t *</em> <strong>wcpcpy</strong> <em>（wchar_t *限制<var>wto</var> ，const wchar_t *限制<var>wfrom</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>wcscpy</code> ，除了它返回指向字符串末尾的指针<var>wto</var> （即终止的空宽字符的地址<code>wto + wcslen (wfrom)</code> ），而不是开始。
</p>
<p>该函数不是ISO或POSIX的一部分，但是在开发GNU C库本身时发现有用。
</p>
<p>的行为<code>wcpcpy</code>如果字符串重叠，则未定义。
</p>
<p><code>wcpcpy</code>是GNU扩展，在中声明<samp>wchar.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-strdupa">巨集： <em>char *</em> <strong>strdupa</strong> <em>（const char * <var>s</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个宏类似于<code>strdup</code>但使用分配新字符串<code>alloca</code>代替<code>malloc</code> （请参阅<a href="Variable-Size-Automatic.html#Variable-Size-Automatic">自动可变尺寸</a> ）。这当然意味着返回的字符串与使用以下方法分配的任何内存块具有相同的限制<code>alloca</code> 。
</p>
<p>由于明显的原因<code>strdupa</code>仅作为宏实现；您无法获得此函数的地址。尽管有此限制，它还是有用的功能。以下代码显示了使用<code>malloc</code>会贵很多。
</p>
<div class="example">
<pre class="example">

#include &lt;paths.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

const char path[] = _PATH_STDPATH;

int
main (void)
{
  char *wr_path = strdupa (path);
  char *cp = strtok (wr_path, &quot;:&quot;);

  while (cp != NULL)
    {
      puts (cp);
      cp = strtok (NULL, &quot;:&quot;);
    }
  return 0;
}
</pre></div>

<p>请注意，致电<code>strtok</code>使用<var>path</var>直接无效。也不允许打电话<code>strdupa</code>在的参数列表中<code>strtok</code>以来<code>strdupa</code>用途<code>alloca</code> （请参阅<a href="Variable-Size-Automatic.html#Variable-Size-Automatic">可变大小自动</a> ）可能会干扰参数传递。
</p>
<p>仅当使用GNU CC时，此功能才可用。
</p></dd></dl>

<dl>
<dt id="index-bcopy">函数： <em>void</em> <strong>bcopy</strong> <em>（常量void * <var>from</var> ，无效* <var>to</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这是部分过时的替代方案<code>memmove</code> ，源自BSD。请注意，它并不完全等同于<code>memmove</code> ，因为参数的顺序不同，并且没有返回值。
</p></dd></dl>

<dl>
<dt id="index-bzero">函数： <em>void</em> <strong>bzero</strong> <em>（无效* <var>block</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这是部分过时的替代方案<code>memset</code> ，源自BSD。请注意，它不如一般<code>memset</code> ，因为它只能存储零值。
</p></dd></dl>

<hr>
<div class="header">
<p>下一页： <a href="Concatenating-Strings.html#Concatenating-Strings" rel="next" accesskey="n">串联字符串</a> ，上一页： <a href="String-Length.html#String-Length" rel="prev" accesskey="p">字符串长度</a> ，向上： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>