<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>等待I / O（GNU C库）</title>

<meta name="description" content="Waiting for I/O (The GNU C Library)">
<meta name="keywords" content="Waiting for I/O (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" title="Low-Level I/O">
<link href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="next" title="Synchronizing I/O">
<link href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO" rel="prev" title="Memory-mapped I/O">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Waiting-for-I_002fO"></span><div class="header">
<p>下一篇： <a href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="next" accesskey="n">同步I / O</a> ，上一篇： <a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO" rel="prev" accesskey="p">内存映射的I / O</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Waiting-for-Input-or-Output"></span><h3 class="section">13.9等待输入或输出</h3>
<span id="index-waiting-for-input-or-output"></span>
<span id="index-multiplexing-input"></span>
<span id="index-input-from-multiple-files"></span>

<p>有时，只要输入到达，程序就需要在多个输入通道上接受输入。例如，某些工作站可能具有通过常规异步串行接口连接的设备，例如数字化平板电脑，功能按钮盒或拨号盒。好的用户界面风格要求立即响应任何设备上的输入。另一个示例是一个程序，它通过管道或套接字充当其他几个进程的服务器。
</p>
<p>您通常无法使用<code>read</code>为此，因为这会阻塞程序，直到在一个特定文件描述符上有可用的输入为止；其他频道上的输入不会唤醒它。您可以设置非阻塞模式并依次轮询每个文件描述符，但这效率很低。
</p>
<p>更好的解决方案是使用<code>select</code>功能。这将阻塞程序，直到在指定的文件描述符集上准备好输入或输出，或者直到计时器到期为止（以先到者为准）。该功能在头文件中声明<samp>sys/types.h</samp> 。
<span id="index-sys_002ftypes_002eh"></span>
</p>
<p>对于服务器套接字（请参阅<a href="Listening.html#Listening">侦听</a> ），我们说当有待接受的挂起连接时（请参见“ <a href="Accepting-Connections.html#Accepting-Connections">接受连接”</a> ），“输入”可用。 <code>accept</code>用于服务器套接字块并与之交互<code>select</code>就像<code>read</code>正常输入。
</p>
<span id="index-file-descriptor-sets_002c-for-select"></span>
<p>文件描述符设置为<code>select</code>功能指定为<code>fd_set</code>对象。这是数据类型和一些用于操纵这些对象的宏的描述。
</p>
<dl>
<dt id="index-fd_005fset">数据类型： <strong>fd_set</strong></dt>
<dd>
<p>的<code>fd_set</code>数据类型表示文件描述符集<code>select</code>功能。它实际上是一个位数组。
</p></dd></dl>

<dl>
<dt id="index-FD_005fSETSIZE">巨集： <em>int</em> <strong>FD_SETSIZE</strong></dt>
<dd>
<p>此宏的值是<code>fd_set</code>对象可以保存有关的信息。在固定最大数量的系统上， <code>FD_SETSIZE</code>至少是那个数字。在某些系统（包括GNU）上，打开的描述符数量没有绝对限制，但是此宏仍具有一个常量值，该值控制一个描述符中的位数。 <code>fd_set</code> ;如果您获得的文件描述符的值高达<code>FD_SETSIZE</code> ，则无法将该描述符放入<code>fd_set</code> 。
</p></dd></dl>

<dl>
<dt id="index-FD_005fZERO">巨集： <em>无效</em> <strong>FD_ZERO</strong> <em>（fd_set * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：设置| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该宏初始化文件描述符集<var>set</var>成为空集。
</p></dd></dl>

<dl>
<dt id="index-FD_005fSET">巨集： <em>无效</em> <strong>FD_SET</strong> <em>（int <var>filedes</var> ，fd_set * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：设置| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该宏添加<var>filedes</var>到文件描述符集<var>set</var> 。
</p>
<p>的<var>filedes</var>参数不能有副作用，因为它被评估了多次。
</p></dd></dl>

<dl>
<dt id="index-FD_005fCLR">巨集： <em>void</em> <strong>FD_CLR</strong> <em>（int <var>filedes</var> ，fd_set * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：设置| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该宏删除<var>filedes</var>从文件描述符集中<var>set</var> 。
</p>
<p>的<var>filedes</var>参数不能有副作用，因为它被评估了多次。
</p></dd></dl>

<dl>
<dt id="index-FD_005fISSET">巨集： <em>int</em> <strong>FD_ISSET</strong> <em>（int <var>filedes</var> ，const fd_set * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：设置| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>如果此宏返回一个非零值（true） <var>filedes</var>是文件描述符集的成员<var>set</var> ，否则为零（假）。
</p>
<p>的<var>filedes</var>参数不应该有副作用，因为它被评估了多次。
</p></dd></dl>

<p>接下来，这里是对<code>select</code>功能本身。
</p>
<dl>
<dt id="index-select">函数： <em>int</em> <strong>select</strong> <em>（int <var>nfds</var> ，fd_set * <var>read-fds</var> ，fd_set * <var>write-fds</var> ，fd_set * <var>except-fds</var> ，struct timeval * <var>timeout</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：read-fds竞赛：write-fds竞赛：except-fds | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>select</code>函数将阻止调用过程，直到在任何指定的文件描述符集上有活动，或者直到超时时间到期为止。
</p>
<p>由...指定的文件描述符<var>read-fds</var>检查参数以查看是否准备好阅读；的<var>write-fds</var>检查文件描述符，看它们是否准备好写入；和<var>except-fds</var>检查文件描述符是否存在异常情况。如果您不想检查这种情况，则可以为这些参数中的任何一个传递一个空指针。
</p>
<p>如果一个文件描述符被认为可以读取<code>read</code>通话不会阻塞。这通常包括读取偏移量位于文件末尾或报告错误。如果存在可以接受的未决连接，则认为服务器套接字已准备就绪，可以读取<code>accept</code> ;请参阅<a href="Accepting-Connections.html#Accepting-Connections">接受连接</a> 。完全建立连接后，客户端套接字就可以进行写操作了；请参阅<a href="Connecting.html#Connecting">连接</a> 。
</p>
<p>“异常情况”并不意味着错误-错误消息在执行错误的系统调用时立即报告，并且不构成描述符的状态。而是，它们包括诸如套接字上出现紧急消息之类的条件。（有关紧急消息的信息，请参阅<a href="Sockets.html#Sockets">Sockets</a> 。）
</p>
<p>的<code>select</code>功能仅检查第一个<var>nfds</var>文件描述符。通常的事情是通过<code>FD_SETSIZE</code>作为此参数的值。
</p>
<p>的<var>timeout</var>指定等待的最长时间。如果为该参数传递一个空指针，则意味着无限期地阻塞直到文件描述符之一准备就绪。否则，您应该提供时间<code>struct timeval</code>格式;请参阅<a href="High_002dResolution-Calendar.html#High_002dResolution-Calendar">高分辨率日历</a> 。指定零作为时间（ <code>struct timeval</code>包含所有零），如果您想找出哪些描述符已准备就绪，而无需等待所有描述符都未准备就绪。
</p>
<p>的正常返回值<code>select</code>是所有集合中就绪文件描述符的总数。每个参数集都会被有关准备好进行相应操作的描述符的信息覆盖。因此，看看是否有特定的描述符<var>desc</var>有输入，使用<code>FD_ISSET (<var>desc</var>, <var>read-fds</var>)</code>后<code>select</code>返回。
</p>
<p>如果<code>select</code>由于超时期限已过期而返回，因此返回值为零。
</p>
<p>任何信号都会导致<code>select</code>立即返回。因此，如果您的程序使用信号，则不能依赖<code>select</code>一直等待指定的时间。如果要确保等待特定的时间，则必须检查<code>EINTR</code>并重复<code>select</code>根据当前时间重新计算的超时时间。请参见下面的示例。另请参见<a href="Interrupted-Primitives.html#Interrupted-Primitives">中断基元</a> 。
</p>
<p>如果发生错误， <code>select</code>退货<code>-1</code>并且不会修改参数文件描述符集。下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p>文件描述符集之一指定了无效的文件描述符。
</p>
</dd>
<dt><code>EINTR</code></dt>
<dd><p>该操作被信号中断。请参阅<a href="Interrupted-Primitives.html#Interrupted-Primitives">中断的基元</a> 。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<var>timeout</var>参数无效；成分之一为负数或太大。
</p></dd>
</dl>
</dd></dl>

<p><strong>便携性注：</strong> <code>select</code> function是BSD Unix的功能。
</p>
<p>这是显示如何使用的示例<code>select</code>建立从文件描述符读取的超时时间。的<code>input_timeout</code>函数将阻止调用过程，直到文件描述符上有可用的输入或超时期限到期为止。
</p>
<div class="example">
<pre class="example">

</pre><pre class="example">#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
</pre><pre class="example">

</pre><pre class="example">int
input_timeout (int filedes, unsigned int seconds)
{
  fd_set set;
  struct timeval timeout;
</pre><pre class="example">

  /* <span class="roman">Initialize the file descriptor set.</span> */
  FD_ZERO (&amp;set);
  FD_SET (filedes, &amp;set);

  /* <span class="roman">Initialize the timeout data structure.</span> */
  timeout.tv_sec = seconds;
  timeout.tv_usec = 0;

</pre><pre class="example">  /* <span class="roman"><code>select</code> returns 0 if timeout, 1 if input available, -1 if error.</span> */
  return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                     &amp;set, NULL, NULL,
                                     &amp;timeout));
}
</pre><pre class="example">

</pre><pre class="example">int
main (void)
{
  fprintf (stderr, &quot;select returned %d.\n&quot;,
           input_timeout (STDIN_FILENO, 5));
  return 0;
}
</pre></div>

<p>还有另一个例子显示了<code>select</code>在<a href="Server-Example.html#Server-Example">Server示例中</a>多路复用来自多个套接字的输入。
</p>

<hr>
<div class="header">
<p>下一篇： <a href="Synchronizing-I_002fO.html#Synchronizing-I_002fO" rel="next" accesskey="n">同步I / O</a> ，上一篇： <a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO" rel="prev" accesskey="p">内存映射的I / O</a> ，上一篇： <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" rel="up" accesskey="u">低级I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>