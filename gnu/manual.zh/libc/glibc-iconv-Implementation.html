<html><head></head><body lang="zh-Hans" ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>glibc iconv实现（GNU C库）</title>

<meta name="description" content="glibc iconv Implementation (The GNU C Library)">
<meta name="keywords" content="glibc iconv Implementation (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" title="Generic Charset Conversion">
<link href="Locales.html#Locales" rel="next" title="Locales">
<link href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" title="Other iconv Implementations">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>





<span id="glibc-iconv-Implementation"></span><div class="header">
<p>上<a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">一篇</a> ： <a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">其他iconv实现</a> ，上<a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">一篇</a> ： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="The-iconv-Implementation-in-the-GNU-C-Library"></span><h4 class="subsection">6.5.4 <code>iconv</code>在GNU C库中的实现</h4>

<p>看完后的问题<code>iconv</code>在上一节的实现中，一定要很好地注意到GNU C库中的实现没有上述任何问题。接下来是对以上各点的逐步分析。评估基于发展的当前状态（截至1999年1月）。的发展<code>iconv</code>功能还不完整，但是基本功能已经固化。
</p>
<p>GNU C库的<code>iconv</code>实现使用共享的可加载模块来实现转换。库本身内置了很少的转换，但是这些转换只是微不足道的。
</p>
<p>可装载模块的所有好处都可以在GNU C库实现中获得。这是特别吸引人的，因为该接口有充分的文档记录（请参见下文），因此易于编写新的转换模块。至少在ELF系统上，使用可加载对象的缺点在GNU C库中不是问题。由于该库即使在静态链接的二进制文件中也能够加载共享的对象，因此如果要使用静态链接，则不必禁止静态链接<code>iconv</code> 。
</p>
<p>提到的第二个问题是受支持的转换数。当前，GNU C库支持150多个字符集。设计实现方式的方式，支持的转换数大于22350（ <em>150</em>乘以<em>149</em> ）。如果缺少字符集之间的任何转换，则可以轻松添加。
</p>
<p>这个数字之所以令人印象深刻，是因为GNU C库的实现<code>iconv</code>没有上面提到的第三个问题（即，无论何时从字符集<em>A</em>到<em>B</em>以及从<em>B</em>到<em>C的</em>转换，总是可以直接从<em>A</em>到<em>C的</em>转换）。如果<code>iconv_open</code>返回错误并设置<code>errno</code>至<code>EINVAL</code> ，没有直接或间接执行所需转换的已知方法。
</p>
<span id="index-triangulation"></span>
<p>通过为每个字符集提供从UCS-4编码到ISO 10646 <!-- /@w -->的转换，可以实现三角剖分。使用ISO 10646 <!-- /@w -->作为中间表示，可以进行<em>三角剖分</em> （即，使用中间表示进行转换）。
</p>
<p>没有固有的要求为新字符集提供到ISO 10646 <!-- /@w -->的转换，也可以在源字符集和目标字符集都不是ISO 10646 <!-- /@w -->情况下提供其他转换。现有的一组转换只是为了覆盖所有可能感兴趣的转换。</p>
<span id="index-ISO_002d2022_002dJP"></span>
<span id="index-EUC_002dJP"></span>
<p>当前所有可用的转换都使用上面的三角剖分方法，从而使转换运行不必要地变慢。例如，如果某人经常需要从ISO-2022-JP到EUC-JP的转换，则更快的解决方案将涉及两个字符集之间的直接转换，首先跳过对ISO 10646 <!-- /@w -->的输入。与ISO 10646 <!-- /@w -->相比，这两个感兴趣的字符集彼此更为相似。
</p>
<p>在这种情况下，您可以轻松地编写新的转换并将其作为更好的选择。GNU C库<code>iconv</code>如果指定执行效率更高，则实现会自动使用实现转换的模块。
</p>
<span id="Format-of-gconv_002dmodules-files"></span><h4 class="subsubsection">6.5.4.1格式<samp>gconv-modules</samp>档案</h4>

<p>有关可用转换的所有信息均来自名为的文件<samp>gconv-modules</samp> ，可以在该目录的任何目录中找到<code>GCONV_PATH</code> 。的<samp>gconv-modules</samp>文件是面向行的文本文件，其中每一行具有以下格式之一：</p>
<ul>
<li>如果第一个非空白字符是<kbd>#</kbd>该行仅包含注释，将被忽略。

</li><li>开头的行<code>alias</code>为字符集定义别名。预计还会有两个字。第一个单词定义别名，第二个单词定义字符集的原始名称。效果是可以在<var>fromset</var>要么<var>toset</var>的参数<code>iconv_open</code>并获得与使用真实字符集名称相同的结果。

<p>这非常重要，因为字符集通常具有许多不同的名称。通常有一个官方名称，但这不必与最受欢迎的名称相对应。除此之外，许多字符集还具有以某种方式构造的特殊名称。例如，ISO指定的所有字符集都具有以下格式的别名： <code>ISO-IR-<var>nnn</var></code>哪里<var>nnn</var>是注册号。这使知道注册号的程序可以构造字符集名称，并将其用于<code>iconv_open</code>电话。以下是有关可用名称和别名的更多信息。
</p>
</li><li>开头的行<code>module</code>介绍一个可用的转换模块。这些行必须包含三个或四个以上的单词。

<p>第一个单词指定源字符集，第二个单词指定在此模块中实现的转换目标字符集，第三个单词是可加载模块的名称。文件名是通过附加通常的共享对象后缀（通常是<samp>.so</samp> ），然后应该在同一目录中找到该文件。 <samp>gconv-modules</samp>文件已放入。该行的最后一个单词是可选的，它是一个表示转换成本的数值。如果缺少该单词，则假定成本为<em>1</em> 。数值本身并没有多大关系；什么是所有可能的转化路径的费用总和的相对值。以下是使用成本值的更精确描述。
</p></li></ul>

<p>回到上面的示例，其中已经编写了一个模块，可以直接从ISO-2022-JP转换为EUC-JP并返回。所有要做的就是将新模块放在目录中，并将其名称命名为ISO2022JP-EUCJP.so。 <samp>gconv-modules</samp>在同一目录中具有以下内容：</p>
<div class="example">
<pre class="example">module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
</pre></div>

<p>要了解为什么这足够了，有必要了解<code>iconv</code> （并在描述符中描述）被选中。解决此问题的方法非常简单。
</p>
<p>在第一个电话<code>iconv_open</code>该程序读取所有可用功能<samp>gconv-modules</samp>文件并建立两个表：一个表包含所有已知的别名，另一个表包含有关转换的信息以及哪个共享对象实现了这些转换。
</p>
<span id="Finding-the-conversion-path-in-iconv"></span><h4 class="subsubsection">6.5.4.2在中查找转换路径<code>iconv</code></h4>

<p>可用转换的集合形成具有加权边的有向图。边缘上的权重是<samp>gconv-modules</samp>文件。的<code>iconv_open</code>函数使用适合于在此类图中搜索最佳路径的算法，因此构造了必须连续执行的转换列表，才能获得从源字符到目标字符集的转换。
</p>
<p>解释以上原因<samp>gconv-modules</samp>文件允许<code>iconv</code>解决方案是将特定的ISO-2022-JP转换为EUC-JP转换模块，而不是库本身附带的转换。由于后一种转换需要两个步骤（从ISO-2022-JP到ISO 10646 <!-- /@w --> ，然后从ISO 10646 <!-- /@w -->到EUC-JP），因此成本为<em>1 + 1 = 2</em> 。以上<samp>gconv-modules</samp>但是，文件指定新的转换模块仅需花费<em>1</em>即可执行此转换。
</p>
<p>关于<samp>gconv-modules</samp>上面的文件（以及GNU C库附带的文件）是在<code>module</code>线。为什么几乎所有名称都以结尾<code>//</code> ？这还不是全部：名称实际上可以是正则表达式。在这个时间点上，除非您拥有相关的法术铸造材料，否则不应该揭开这个谜团：原始DOS 6.2 <!-- /@w -->启动盘上的灰烬被烧成雕像，圣埃马克斯（St. Emacs）祝福的耶稣受难像，来自中美洲的各种草药根，宿雾的沙子等抱歉!<strong>使用此功能的实现部分尚未完成。现在，请仅遵循现有示例。它将变得更加清晰。 –drepper</strong>
</p>
<p>最后一句话<samp>gconv-modules</samp>关于不以结尾结尾的名字<code>//</code> 。名为的字符集<code>INTERNAL</code>经常被提及。从上面的讨论和所选的名称中，应该清楚地知道这是在三角剖分的中间步骤中使用的表示形式的名称。我们已经说过这是UCS-4，但实际上这不太正确。UCS-4规范还包括所用字节顺序的规范。由于UCS-4值由四个字节组成，因此存储的值受字节顺序影响。内部表示是<em>不</em>一样的UCS-4的情况下，处理器的字节顺序（或至少运行过程中）是不一样的，作为UCS-4所要求的一个。这样做是出于性能方面的考虑，因为如果不想对UCS-4中的实际结果感兴趣的人不希望执行不必要的字节交换操作。为避免出现字节序麻烦，内部表示形式始终命名为<code>INTERNAL</code>即使在表示相同的big-endian系统上。
</p>
<span id="iconv-module-data-structures"></span><h4 class="subsubsection">6.5.4.3 <code>iconv</code>模块数据结构</h4>

<p>到目前为止，本节已经描述了如何定位和考虑使用模块。剩下要描述的是模块的接口，以便人们可以编写新的模块。本节介绍了1999年1月使用的接口。界面将来会有所变化，但幸运的是，只能以向上兼容的方式进行。
</p>
<p>编写新模块所需的定义可在非标准标头中公开获得<samp>gconv.h</samp> 。因此，以下文本描述了此头文件中的定义。但是首先，有必要进行概述。
</p>
<p>从用户的角度<code>iconv</code>界面非常简单： <code>iconv_open</code>函数返回一个可以在调用中使用的句柄<code>iconv</code> ，最后通过调用释放句柄<code>iconv_close</code> 。问题在于，句柄必须能够表示可能很长的转换步骤序列，并且还必须表示每次转换的状态，因为句柄是所有传递给变量的内容。 <code>iconv</code>功能。因此，数据结构实际上是理解实现所必需的元素。
</p>
<p>我们需要两种不同的数据结构。第一个描述转换，第二个描述状态等。确实有两个这样的类型定义<samp>gconv.h</samp> 。
<span id="index-gconv_002eh"></span>
</p>
<dl>
<dt id="index-struct-_005f_005fgconv_005fstep">数据类型： <strong>struct __gconv_step</strong></dt>
<dd>
<p>此数据结构描述了模块可以执行的一种转换。对于已加载的具有转换功能的模块中的每个功能，只有一个这种类型的对象。转换的所有用户都共享此对象（即，该对象不包含与实际转换相对应的任何信息；它仅描述转换本身）。
</p>
<dl compact>
<dt><code>struct __gconv_loaded_object *__shlib_handle</code></dt>
<dt><code>const char *__modname</code></dt>
<dt><code>int __counter</code></dt>
<dd><p>结构的所有这些元素都在C库内部使用，以协调共享对象的加载和卸载。一定不要期望任何其他元素可用或被初始化。
</p>
</dd>
<dt><code>const char *__from_name</code></dt>
<dt><code>const char *__to_name</code></dt>
<dd><p><code>__from_name</code>和<code>__to_name</code>包含源字符集和目标字符集的名称。由于一个模块可能对多个字符集和/或方向进行转换，因此它们可用于标识要执行的实际转换。
</p>
</dd>
<dt><code>gconv_fct __fct</code></dt>
<dt><code>gconv_init_fct __init_fct</code></dt>
<dt><code>gconv_end_fct __end_fct</code></dt>
<dd><p>这些元素包含指向可加载模块中功能的指针。界面将在下面说明。
</p>
</dd>
<dt><code>int __min_needed_from</code></dt>
<dt><code>int __max_needed_from</code></dt>
<dt><code>int __min_needed_to</code></dt>
<dt><code>int __max_needed_to;</code></dt>
<dd><p>这些值必须在模块的init函数中提供。的<code>__min_needed_from</code>值指定源字符集的字符至少需要多少个字节。的<code>__max_needed_from</code>指定最大值，该最大值还包括可能的移位序列。
</p>
<p>的<code>__min_needed_to</code>和<code>__max_needed_to</code>价值观与<code>__min_needed_from</code>和<code>__max_needed_from</code>但这一次是目标字符集。
</p>
<p>这些值的准确性至关重要，因为否则转换功能将出现问题或根本无法工作。
</p>
</dd>
<dt><code>int __stateful</code></dt>
<dd><p>此元素还必须由init函数初始化。
<code>int __stateful</code>如果源字符集是有状态的，则为非零。否则为零。
</p>
</dd>
<dt><code>void *__data</code></dt>
<dd><p>该元素可由模块中的转换功能自由使用。 <code>void *__data</code>可用于将更多信息从一个呼叫传递到另一个呼叫。 <code>void *__data</code>如果根本不需要，则不需要初始化。如果<code>void *__data</code>元素被分配了一个指向动态分配的内存的指针（大概在init函数中），必须确保end函数释放了内存。否则，应用程序将泄漏内存。
</p>
<p>重要的是要知道，此规范转换的所有用户都共享此数据结构，因此<code>__data</code>元素不得包含特定于转换功能一种特定用途的数据。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-struct-_005f_005fgconv_005fstep_005fdata">数据类型： <strong>struct __gconv_step_data</strong></dt>
<dd>
<p>这是一种数据结构，其中包含特定于转换功能每次使用的信息。
</p>

<dl compact>
<dt><code>char *__outbuf</code></dt>
<dt><code>char *__outbufend</code></dt>
<dd><p>这些元素指定转换步骤的输出缓冲区。的<code>__outbuf</code>元素指向缓冲区的开头，并且<code>__outbufend</code>指向缓冲区中最后一个字节之后的字节。转换函数不得假定任何有关缓冲区大小的信息，但可以安全地假定输出缓冲区中至少有一个完整字符的空间。
</p>
<p>转换完成后，如果转换是最后一步，则<code>__outbuf</code>必须修改元素以指向写入缓冲区的最后一个字节之后，以指示有多少可用输出。如果此转换步骤不是最后一步，则不得修改该元素。的<code>__outbufend</code>元素不得修改。
</p>
</dd>
<dt><code>int __is_last</code></dt>
<dd><p>如果此转换步骤是最后一个，则此元素为非零。此信息对于递归是必需的。请参阅下面的转换函数内部说明。绝对不能修改此元素。
</p>
</dd>
<dt><code>int __invocation_counter</code></dt>
<dd><p>转换函数可以使用此元素来查看已经发生了多少次转换函数调用。某些字符集在生成输出时需要一定的序言，并且通过将该值与零进行比较，可以发现这是否是第一个调用以及是否应该发出序言。绝对不能修改此元素。
</p>
</dd>
<dt><code>int __internal_use</code></dt>
<dd><p>此元素是另一个很少使用但在某些情况下需要的元素。如果使用转换函数来实现，则为它分配一个非零值<code>mbsrtowcs</code>等（即，该功能不能直接通过<code>iconv</code>接口）。
</p>
<p>有时这会有所作为，因为预计<code>iconv</code>函数用于翻译整个文本，而<code>mbsrtowcs</code>函数通常仅用于转换单个字符串，并且可以多次用于转换整个文本。
</p>
<p>但是在这种情况下，我们将无法遵守字符集规范的某些规则。某些字符集需要序言，对于整个文本，序言必须恰好出现一次。如果数量<code>mbsrtowcs</code>调用用于转换文本，只有第一个调用必须添加序言。但是，由于的不同呼叫之间没有通信<code>mbsrtowcs</code> ，转换函数无法找出答案。对于以下顺序，情况有所不同<code>iconv</code>调用，因为该句柄允许访问所需的信息。
</p>
<p>的<code>int __internal_use</code>元素通常与<code>__invocation_counter</code>如下：</p>
<div class="example">
<pre class="example">if (!data-&gt;__internal_use
     &amp;&amp; data-&gt;__invocation_counter == 0)
  /* <span class="roman">Emit prolog.</span>  */
  &hellip;
</pre></div>

<p>绝对不能修改此元素。
</p>
</dd>
<dt><code>mbstate_t *__statep</code></dt>
<dd><p>的<code>__statep</code>元素指向类型的对象<code>mbstate_t</code> （请参阅<a href="Keeping-the-state.html#Keeping-the-state">保持状态</a> ）。有状态字符集的转换必须使用由指向的对象<code>__statep</code>存储有关转换状态的信息。的<code>__statep</code>元素本身绝不能修改。
</p>
</dd>
<dt><code>mbstate_t __state</code></dt>
<dd><p><em>绝对</em>不能直接使用此元素。分配所需的空间只是该结构的一部分。
</p></dd>
</dl>
</dd></dl>

<span id="iconv-module-interfaces"></span><h4 class="subsubsection">6.5.4.4 <code>iconv</code>模块接口</h4>

<p>有了有关数据结构的知识，我们现在可以描述转换函数本身。要了解该接口，需要对C库中用于通过转换加载对象的功能有一些了解。
</p>
<p>通常，一次转换使用不止一次（例如，多次转换<code>iconv_open</code>在一个程序运行期间调用相同的字符集）。的<code>mbsrtowcs</code>等GNU C库中的函数也使用<code>iconv</code>功能，甚至更多地增加了使用相同功能的次数。
</p>
<p>由于多次使用转换，因此模块不会只为一次转换加载。相反，加载后的模块可以由任意数量的模块使用<code>iconv</code>要么<code>mbsrtowcs</code>同时通话。信息在特定于转换功能的信息和转换数据之间的分割使之成为可能。最后一部分显示了用于执行此操作的两个数据结构。
</p>
<p>当然，这也反映在模块必须提供的功能的接口和语义中。三个函数必须具有以下名称：</p>
<dl compact>
<dt><code>gconv_init</code></dt>
<dd><p>的<code>gconv_init</code>函数初始化转换函数特定的数据结构。使用此转换的所有转换都共享同一对象，因此，不必在此存储有关转换本身的状态信息。如果某个模块实现了多个转换，则<code>gconv_init</code>函数将被多次调用。
</p>
</dd>
<dt><code>gconv_end</code></dt>
<dd><p>的<code>gconv_end</code>函数负责释放由<code>gconv_init</code>功能。如果无事可做，此功能可能会丢失。如果模块执行了多个转换，并且<code>gconv_init</code>函数不会为所有转化分配相同的资源。
</p>
</dd>
<dt><code>gconv</code></dt>
<dd><p>这是实际的转换功能。它被称为转换一个文本块。它传递了由初始化的转换步骤信息<code>gconv_init</code>以及转换数据，专门用于此转换函数。
</p></dd>
</dl>

<p>为这三个模块接口功能定义了三种数据类型，它们定义了接口。
</p>
<dl>
<dt id="index-_0028_002a_005f_005fgconv_005finit_005ffct_0029">数据类型： <em>int</em> <strong>（* __ gconv_init_fct）</strong> <em>（结构__gconv_step *）</em></dt>
<dd>
<p>这指定了模块初始化功能的接口。对于模块实现的每次转换，它仅被调用一次。
</p>
<p>如说明中所述<code>struct __gconv_step</code>初始化函数上方的数据结构必须对其部分进行初始化。
</p>
<dl compact>
<dt><code>__min_needed_from</code></dt>
<dt><code>__max_needed_from</code></dt>
<dt><code>__min_needed_to</code></dt>
<dt><code>__max_needed_to</code></dt>
<dd><p>必须将这些元素初始化为源字符集和目标字符集中的一个字符分别使用的最小和最大字节数的确切数字。如果所有字符的大小相同，则最小值和最大值相同。
</p>
</dd>
<dt><code>__stateful</code></dt>
<dd><p>如果源字符集是有状态的，则必须将此元素初始化为非零值。否则必须为零。
</p></dd>
</dl>

<p>如果初始化功能需要将一些信息传达给转换功能，则可以使用<code>__data</code>的元素<code>__gconv_step</code>结构体。但是，由于所有转换都共享此数据，因此转换功能不得修改它。下面的示例显示了如何使用它。
</p>
<div class="example">
<pre class="example">#define MIN_NEEDED_FROM         1
#define MAX_NEEDED_FROM         4
#define MIN_NEEDED_TO           4
#define MAX_NEEDED_TO           4

int
gconv_init (struct __gconv_step *step)
{
  /* <span class="roman">Determine which direction.</span>  */
  struct iso2022jp_data *new_data;
  enum direction dir = illegal_dir;
  enum variant var = illegal_var;
  int result;

  if (__strcasecmp (step-&gt;__from_name, &quot;ISO-2022-JP//&quot;) == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__to_name, &quot;ISO-2022-JP//&quot;) == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__from_name, &quot;ISO-2022-JP-2//&quot;) == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp2;
    }
  else if (__strcasecmp (step-&gt;__to_name, &quot;ISO-2022-JP-2//&quot;) == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp2;
    }

  result = __GCONV_NOCONV;
  if (dir != illegal_dir)
    {
      new_data = (struct iso2022jp_data *)
        malloc (sizeof (struct iso2022jp_data));

      result = __GCONV_NOMEM;
      if (new_data != NULL)
        {
          new_data-&gt;dir = dir;
          new_data-&gt;var = var;
          step-&gt;__data = new_data;

          if (dir == from_iso2022jp)
            {
              step-&gt;__min_needed_from = MIN_NEEDED_FROM;
              step-&gt;__max_needed_from = MAX_NEEDED_FROM;
              step-&gt;__min_needed_to = MIN_NEEDED_TO;
              step-&gt;__max_needed_to = MAX_NEEDED_TO;
            }
          else
            {
              step-&gt;__min_needed_from = MIN_NEEDED_TO;
              step-&gt;__max_needed_from = MAX_NEEDED_TO;
              step-&gt;__min_needed_to = MIN_NEEDED_FROM;
              step-&gt;__max_needed_to = MAX_NEEDED_FROM + 2;
            }

          /* <span class="roman">Yes, this is a stateful encoding.</span>  */
          step-&gt;__stateful = 1;

          result = __GCONV_OK;
        }
    }

  return result;
}
</pre></div>

<p>该函数首先检查需要进行哪些转换。使用此功能的模块执行四种不同的转换；可以通过比较名称来确定选择哪一个。比较应始终在不关注案例的情况下进行。
</p>
<p>接下来，分配一个数据结构，该数据结构包含有关选择哪种转换的必要信息。数据结构<code>struct iso2022jp_data</code>是本地定义的，因为在模块外部根本不使用此数据。请注意，如果请求此模块支持的所有四个转换，则有四个数据块。
</p>
<p>一件有趣的事是<code>__min_</code>和<code>__max_</code>步骤数据对象的元素。一个ISO-2022-JP字符可以包含1-4个字节。因此<code>MIN_NEEDED_FROM</code>和<code>MAX_NEEDED_FROM</code>宏是通过这种方式定义的。输出始终是<code>INTERNAL</code>字符集（又名UCS-4），因此每个字符正好由四个字节组成。对于从<code>INTERNAL</code>根据ISO-2022-JP，我们必须考虑到转换字符集可能需要使用转义序列。因此<code>__max_needed_to</code>分配了该方向的元素<code>MAX_NEEDED_FROM + 2</code> 。这考虑了转义序列发出切换信号所需的两个字节。可以很容易地解释两个方向的最大值的不对称性：读取ISO-2022-JP文本时，可以单独处理转义序列（即，不必处理真实字符，因为转义序列的效果可以被记录在状态信息中）。另一个方向的情况则不同。由于通常不知道接下来是哪个字符，因此无法发出转义序列来提前更改状态。这意味着必须将转义序列与下一个字符一起发出。因此，一个人需要的空间不仅仅是角色本身。
</p>
<p>初始化函数的可能返回值为：</p>
<dl compact>
<dt><code>__GCONV_OK</code></dt>
<dd><p>初始化成功</p></dd>
<dt><code>__GCONV_NOCONV</code></dt>
<dd><p>该模块不支持请求的转换。如果<samp>gconv-modules</samp>文件有错误。
</p></dd>
<dt><code>__GCONV_NOMEM</code></dt>
<dd><p>无法分配存储其他信息所需的内存。
</p></dd>
</dl>
</dd></dl>

<p>卸载模块之前调用的函数非常容易。它通常根本无事可做。在这种情况下，可以完全忽略它。
</p>
<dl>
<dt id="index-_0028_002a_005f_005fgconv_005fend_005ffct_0029">数据类型： <em>void</em> <strong>（* __ gconv_end_fct）</strong> <em>（结构gconv_step *）</em></dt>
<dd>
<p>该功能的任务是释放初始化功能中分配的所有资源。因此，只有<code>__data</code>参数所指向的对象的元素是感兴趣的。从初始化函数继续示例，终结函数看起来像这样：</p>
<div class="example">
<pre class="example">void
gconv_end (struct __gconv_step *data)
{
  free (data-&gt;__data);
}
</pre></div>
</dd></dl>

<p>最重要的功能是转换功能本身，对于复杂的字符集，它可能会变得非常复杂。但是，由于这里没有兴趣，我们将仅描述转换函数的可能框架。
</p>
<dl>
<dt id="index-_0028_002a_005f_005fgconv_005ffct_0029">数据类型： <em>int</em> <strong>（* __ gconv_fct）</strong> <em>（结构__gconv_step *，结构__gconv_step_data *，const char **，const char *，size_t *，int）</em></dt>
<dd>
<p>可以出于两个基本原因调用转换函数：转换文本或重置状态。从描述<code>iconv</code>可以看出为什么需要冲洗模式。选择哪种模式由第六个参数（整数）确定。此参数为非零表示已选择刷新。
</p>
<p>这两种模式的共同点是可以找到输出缓冲区。有关此缓冲区的信息存储在转换步骤数据中。指向此信息的指针作为该函数的第二个参数传递。的描述<code>struct __gconv_step_data</code>结构具有有关转换步骤数据的更多信息。
</p>
<span id="index-stateful-5"></span>
<p>刷新必须执行的操作取决于源字符集。如果源字符集不是有状态的，则无需执行任何操作。否则，该函数必须发出一个字节序列以使状态对象进入初始状态。一旦所有这些都发生了，转化链中的其他转化模块就必须获得相同的机会。可以从<code>__is_last</code>第一个参数指向的步数据结构的元素。
</p>
<p>更为有趣的模式是必须转换实际文本时。在这种情况下，第一步是从输入缓冲区转换尽可能多的文本，并将结果存储在输出缓冲区中。输入缓冲区的起点由第三个参数确定，该参数是指向引用缓冲区起点的指针变量的指针。第四个参数是指向缓冲区最后一个字节之后的字节的指针。
</p>
<p>如果字符集是有状态的，则必须根据当前状态执行转换。状态存储在对象指向的对象中<code>__statep</code>步骤数据的元素（第二个参数）。一旦输入缓冲区为空或输出缓冲区已满，转换就会停止。此时，第三个参数引用的指针变量必须指向最后处理的字节之后的字节（即，如果所有输入都被消耗，则该指针和第四个参数具有相同的值）。
</p>
<p>现在发生的情况取决于这一步骤是否是最后一步。如果这是最后一步，那么唯一要做的就是更新<code>__outbuf</code>步骤数据结构的元素指向最后写入的字节之后。此更新为调用者提供了有关输出缓冲区中有多少文本可用的信息。此外，第五个参数指向的变量类型为<code>size_t</code>必须以不可逆方式转换的字符数（ <em>不是字节</em> ）增加。然后，该函数可以返回。
</p>
<p>如果步骤不是最后一步，则后面的转换函数必须有机会来完成工作。因此，必须调用适当的转换函数。有关功能的信息存储在转换数据结构中，作为第一个参数传递。此信息和步骤数据存储在数组中，因此两种情况下的下一个元素都可以通过简单的指针算法找到：</p>
<div class="example">
<pre class="example">int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  &hellip;
</pre></div>

<p>的<code>next_step</code>指针引用下一步信息，并且<code>next_data</code>下一条数据记录。因此，下一个函数的调用将类似于以下内容：</p>
<div class="example">
<pre class="example">  next_step-&gt;__fct (next_step, next_data, &amp;outerr, outbuf,
                    written, 0)
</pre></div>

<p>但这还不是全部。一旦函数调用返回，转换函数可能还有更多工作要做。如果函数的返回值为<code>__GCONV_EMPTY_INPUT</code> ，输出缓冲区中有更多可用空间。除非输入缓冲区为空，否则转换功能将重新开始并处理其余的输入缓冲区。如果返回值不是<code>__GCONV_EMPTY_INPUT</code> ，出现了问题，我们必须从中恢复。
</p>
<p>转换函数的要求是输入缓冲区指针（第三个参数）始终指向以转换形式放入输出缓冲区的最后一个字符。在当前步骤中执行转换后，情况确实如此，但是如果转换功能在更深的下游过早停止，则不会消耗掉输出缓冲区中的所有字符，因此必须将输入缓冲区指针回退到正确的位置。
</p>
<p>如果输入和输出字符集的所有字符的宽度都固定，则校正输入缓冲区很容易。在这种情况下，我们可以计算输出缓冲区中还剩下多少个字符，因此可以使用类似的计算适当地校正输入缓冲区指针。如果任何一个字符集都有用可变长度字节序列表示的字符，事情就会变得棘手，如果转换必须照顾到状态，则情况变得更加复杂。在这些情况下，必须从初始转换之前的已知状态再次执行转换（即，如有必要，必须重置转换状态，并且必须再次执行转换循环）。现在的区别是，已知必须创建多少输入，并且转换可以在转换第一个未使用的字符之前停止。完成此操作后，必须再次更新输入缓冲区指针，然后函数才能返回。
</p>
<p>最后一件事应该被提及。如果转换有必要知道它是否是第一次调用（如果必须发出序言），则转换函数应递增<code>__invocation_counter</code>返回到调用者之前步骤数据结构的元素。参见说明<code>struct __gconv_step_data</code>上面的结构以获取有关如何使用它的更多信息。
</p>
<p>返回值必须是以下值之一：</p>
<dl compact>
<dt><code>__GCONV_EMPTY_INPUT</code></dt>
<dd><p>所有输入已消耗完，输出缓冲区中还有剩余空间。
</p></dd>
<dt><code>__GCONV_FULL_OUTPUT</code></dt>
<dd><p>输出缓冲区中没有更多空间了。如果这不是最后一步，则此值将从链中下一个转换函数的调用向下传播。
</p></dd>
<dt><code>__GCONV_INCOMPLETE_INPUT</code></dt>
<dd><p>输入缓冲区不完整为空，因为它包含不完整的字符序列。
</p></dd>
</dl>

<p>以下示例提供了转换函数的框架。如果必须编写新的转换，则必须填充此实现中的漏洞。
</p>
<div class="example">
<pre class="example">int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  gconv_fct fct = next_step-&gt;__fct;
  int status;

  /* <span class="roman">If the function is called with no input this means we have</span>
     <span class="roman">to reset to the initial state.  The possibly partly</span>
     <span class="roman">converted input is dropped.</span>  */
  if (do_flush)
    {
      status = __GCONV_OK;

      /* <span class="roman">Possible emit a byte sequence which put the state object</span>
         <span class="roman">into the initial state.</span>  */

      /* <span class="roman">Call the steps down the chain if there are any but only</span>
         <span class="roman">if we successfully emitted the escape sequence.</span>  */
      if (status == __GCONV_OK &amp;&amp; ! data-&gt;__is_last)
        status = fct (next_step, next_data, NULL, NULL,
                      written, 1);
    }
  else
    {
      /* <span class="roman">We preserve the initial values of the pointer variables.</span>  */
      const char *inptr = *inbuf;
      char *outbuf = data-&gt;__outbuf;
      char *outend = data-&gt;__outbufend;
      char *outptr;

      do
        {
          /* <span class="roman">Remember the start value for this round.</span>  */
          inptr = *inbuf;
          /* <span class="roman">The outbuf buffer is empty.</span>  */
          outptr = outbuf;

          /* <span class="roman">For stateful encodings the state must be safe here.</span>  */

          /* <span class="roman">Run the conversion loop.  <code>status</code> is set</span>
             <span class="roman">appropriately afterwards.</span>  */

          /* <span class="roman">If this is the last step, leave the loop.  There is</span>
             <span class="roman">nothing we can do.</span>  */
          if (data-&gt;__is_last)
            {
              /* <span class="roman">Store information about how many bytes are</span>
                 <span class="roman">available.</span>  */
              data-&gt;__outbuf = outbuf;

             /* <span class="roman">If any non-reversible conversions were performed,</span>
                <span class="roman">add the number to <code>*written</code>.</span>  */

             break;
           }

          /* <span class="roman">Write out all output that was produced.</span>  */
          if (outbuf &gt; outptr)
            {
              const char *outerr = data-&gt;__outbuf;
              int result;

              result = fct (next_step, next_data, &amp;outerr,
                            outbuf, written, 0);

              if (result != __GCONV_EMPTY_INPUT)
                {
                  if (outerr != outbuf)
                    {
                      /* <span class="roman">Reset the input buffer pointer.  We</span>
                         <span class="roman">document here the complex case.</span>  */
                      size_t nstatus;

                      /* <span class="roman">Reload the pointers.</span>  */
                      *inbuf = inptr;
                      outbuf = outptr;

                      /* <span class="roman">Possibly reset the state.</span>  */

                      /* <span class="roman">Redo the conversion, but this time</span>
                         <span class="roman">the end of the output buffer is at</span>
                         <span class="roman"><code>outerr</code>.</span>  */
                    }

                  /* <span class="roman">Change the status.</span>  */
                  status = result;
                }
              else
                /* <span class="roman">All the output is consumed, we can make</span>
                   <span class="roman"> another run if everything was ok.</span>  */
                if (status == __GCONV_FULL_OUTPUT)
                  status = __GCONV_OK;
           }
        }
      while (status == __GCONV_OK);

      /* <span class="roman">We finished one use of this step.</span>  */
      ++data-&gt;__invocation_counter;
    }

  return status;
}
</pre></div>
</dd></dl>

<p>该信息应足以编写新模块。任何这样做的人也应该看看GNU C库源代码中的可用源代码。它包含许多工作和优化模块的示例。
</p>
<hr>
<div class="header">
<p>上<a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">一篇</a> ： <a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">其他iconv实现</a> ，上<a href="Other-iconv-Implementations.html#Other-iconv-Implementations" rel="prev" accesskey="p">一篇</a> ： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>