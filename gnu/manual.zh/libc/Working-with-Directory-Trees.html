<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>使用目录树（GNU C库）</title>

<meta name="description" content="Working with Directory Trees (The GNU C Library)">
<meta name="keywords" content="Working with Directory Trees (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="File-System-Interface.html#File-System-Interface" rel="up" title="File System Interface">
<link href="Hard-Links.html#Hard-Links" rel="next" title="Hard Links">
<link href="Low_002dlevel-Directory-Access.html#Low_002dlevel-Directory-Access" rel="prev" title="Low-level Directory Access">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Working-with-Directory-Trees"></span><div class="header">
<p>下一篇： <a href="Hard-Links.html#Hard-Links" rel="next" accesskey="n">硬链接</a> ，上一篇： <a href="Accessing-Directories.html#Accessing-Directories" rel="prev" accesskey="p">访问目录</a> ，上一篇： <a href="File-System-Interface.html#File-System-Interface" rel="up" accesskey="u">文件系统界面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Working-with-Directory-Trees-1"></span><h3 class="section">14.3使用目录树</h3>
<span id="index-directory-hierarchy"></span>
<span id="index-hierarchy_002c-directory"></span>
<span id="index-tree_002c-directory"></span>

<p>到目前为止，描述的用于处理目录中文件的功能使您可以一点一点地检索信息，或者将所有文件作为一个组进行处理（请参见<code>scandir</code> ）。有时，处理目录及其包含的文件的整个层次结构很有用。X / Open规范定义了两个功能来执行此操作。更简单的形式来自System V <!-- /@w -->系统中的早期定义，因此此功能在SVID派生的系统上可用。原型和所需的定义可以在<samp>ftw.h</samp>标头。
</p>
<p>该系列有四个功能： <code>ftw</code> ， <code>nftw</code>和他们的64位对应物<code>ftw64</code>和<code>nftw64</code> 。这些函数将指向适当类型的回调函数的指针作为其参数之一。
</p>
<dl>
<dt id="index-_005f_005fftw_005ffunc_005ft">数据类型： <strong>__ftw_func_t</strong></dt>
<dd>

<div class="example">
<pre class="example">int (*) (const char *, const struct stat *, int)
</pre></div>

<p>提供给的回调函数类型<code>ftw</code>功能。第一个参数指向文件名，第二个参数指向类型的对象<code>struct stat</code>这是第一个参数中命名的文件的内容。
</p>
<p>最后一个参数是一个标志，提供有关当前文件的更多信息。它可以具有以下值：</p>
<dl compact>
<dt><code>FTW_F</code>
<span id="index-FTW_005fF"></span>
</dt>
<dd><p>该项目是普通文件或不属于以下类别之一的文件。这可能是特殊文件，套接字等。</p></dd>
<dt><code>FTW_D</code>
<span id="index-FTW_005fD"></span>
</dt>
<dd><p>该项目是一个目录。
</p></dd>
<dt><code>FTW_NS</code>
<span id="index-FTW_005fNS"></span>
</dt>
<dd><p>的<code>stat</code>调用失败，因此第二个参数指向的信息无效。
</p></dd>
<dt><code>FTW_DNR</code>
<span id="index-FTW_005fDNR"></span>
</dt>
<dd><p>该项目是无法读取的目录。
</p></dd>
<dt><code>FTW_SL</code>
<span id="index-FTW_005fSL"></span>
</dt>
<dd><p>该项目是一个符号链接。由于通常会跟随符号链接，因此在<code>ftw</code>回调函数表示引用的文件不存在。情况<code>nftw</code>是不同的。
</p>
<p>仅当使用以下命令编译程序时，此值才可用<code>_XOPEN_EXTENDED</code>在包含第一个标头之前定义。原始SVID系统没有符号链接。
</p></dd>
</dl>

<p>如果源使用<code>_FILE_OFFSET_BITS == 64</code>这种类型实际上是<code>__ftw64_func_t</code>因为这个模式改变了<code>struct stat</code>成为<code>struct stat64</code> 。
</p></dd></dl>

<p>对于LFS接口和在功能中使用<code>ftw64</code> ，标题<samp>ftw.h</samp>定义另一个函数类型。
</p>
<dl>
<dt id="index-_005f_005fftw64_005ffunc_005ft">数据类型： <strong>__ftw64_func_t</strong></dt>
<dd>

<div class="example">
<pre class="example">int (*) (const char *, const struct stat64 *, int)
</pre></div>

<p>这种类型的用法就像<code>__ftw_func_t</code>用于回调函数，但这一次是从<code>ftw64</code> 。该函数的第二个参数是指向类型变量的指针<code>struct stat64</code>能够代表更大的值。
</p></dd></dl>

<dl>
<dt id="index-_005f_005fnftw_005ffunc_005ft">数据类型： <strong>__ nftw_func_t</strong></dt>
<dd>

<div class="example">
<pre class="example">int (*) (const char *, const struct stat *, int, struct FTW *)
</pre></div>

<p>前三个参数与<code>__ftw_func_t</code>类型。但是，对于第三个参数，定义了一些附加值以允许进行更好的区分：</p><dl compact>
<dt><code>FTW_DP</code>
<span id="index-FTW_005fDP"></span>
</dt>
<dd><p>当前项目是目录，并且所有子目录都已被访问和报告。返回此标志而不是<code>FTW_D</code>如果<code>FTW_DEPTH</code>标志传递给<code>nftw</code> （见下文）。
</p></dd>
<dt><code>FTW_SLN</code>
<span id="index-FTW_005fSLN"></span>
</dt>
<dd><p>当前项目是一个陈旧的符号链接。它指向的文件不存在。
</p></dd>
</dl>

<p>回调函数的最后一个参数是指向具有一些额外信息的结构的指针，如下所述。
</p>
<p>如果源使用<code>_FILE_OFFSET_BITS == 64</code>这种类型实际上是<code>__nftw64_func_t</code>因为这个模式改变了<code>struct stat</code>成为<code>struct stat64</code> 。
</p></dd></dl>

<p>对于LFS接口，还可以使用此数据类型的变体，该变体必须与<code>nftw64</code>功能。
</p>
<dl>
<dt id="index-_005f_005fnftw64_005ffunc_005ft">数据类型： <strong>__ nftw64_func_t</strong></dt>
<dd>

<div class="example">
<pre class="example">int (*) (const char *, const struct stat64 *, int, struct FTW *)
</pre></div>

<p>这种类型的用法就像<code>__nftw_func_t</code>用于回调函数，但这一次是从<code>nftw64</code> 。该函数的第二个参数这次是指向类型变量的指针<code>struct stat64</code>能够代表更大的值。
</p></dd></dl>

<dl>
<dt id="index-struct-FTW">数据类型： <strong>struct FTW</strong></dt>
<dd>
<p>此结构中包含的信息有助于解释name参数，并提供一些有关目录层次结构遍历的当前状态的信息。
</p>
<dl compact>
<dt><code>int base</code></dt>
<dd><p>该值是第一个参数传递给文件名开头的回调函数的字符串偏移量。字符串的其余部分是文件的路径。如果<code>FTW_CHDIR</code>通话中设置了标志<code>nftw</code>从那以后，当前目录就是找到当前项目的目录。
</p></dd>
<dt><code>int level</code></dt>
<dd><p>在处理过程中，代码跟踪查找当前文件所需的目录数。对于初始目录中的文件，此嵌套级别从<em>0</em>开始（如果传递了文件，则对于初始文件为0）。
</p></dd>
</dl>
</dd></dl>


<dl>
<dt id="index-ftw">函数： <em>int</em> <strong>ftw</strong> <em>（const char * <var>filename</var> ，__ftw_func_t <var>func</var> ，int <var>descriptors</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>ftw</code>函数调用参数中给定的回调函数<var>func</var>对于在指定目录中找到的每个项目<var>filename</var>以及下面的所有目录。如果需要，该函数将遵循符号链接，但不会两次处理项目。如果<var>filename</var>不是目录，则它本身是返回回调函数的唯一对象。
</p>
<p>传递给回调函数的文件名是通过以下方式构造的： <var>filename</var>参数，并附加所有传递的目录的名称，然后附加本地文件名。因此，回调函数可以使用此参数来访问文件。 <code>ftw</code>也打电话<code>stat</code>文件，然后将该信息传递给回调函数。如果这<code>stat</code>调用不成功，通过将回调函数的第三个参数设置为来指示失败<code>FTW_NS</code> 。否则，根据帐户中给出的描述进行设置<code>__ftw_func_t</code>以上。
</p>
<p>回调函数应返回<em>0，</em>以指示没有错误发生，并且处理应继续。如果在回调函数中发生错误或它想要<code>ftw</code>要立即返回，回调函数可以返回<em>0</em>以外的<em>值</em> 。这是停止该功能的唯一正确方法。该程序不得使用<code>setjmp</code>或类似技术从另一个地方继续。这将使资源分配给<code>ftw</code>功能未释放。
</p>
<p>的<var>descriptors</var>参数<code>ftw</code>指定允许使用多少个文件描述符。该函数可以使用的描述符越多，运行速度越快。对于目录层次结构中的每个级别，最多使用一个描述符，但是对于非常深的描述符，则可能会超出进程或系统的打开文件描述符的任何限制。此外，多线程程序中的文件描述符限制以组的形式应用于所有线程，因此，对打开的描述符数量提供合理的限制是一个好主意。
</p>
<p>的返回值<code>ftw</code>函数是<em>0，</em>如果所有的回调函数调用返回<em>0，</em>所有的动作被执行<code>ftw</code>成功了。如果函数调用失败（除了调用<code>stat</code>在某项上），该函数返回<em>-1</em> 。如果回调函数返回的值不是<em>0，则</em>将该值作为返回值返回。 <code>ftw</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位系统上，该功能实际上是<code>ftw64</code> ，即LFS接口透明地替换了旧接口。
</p></dd></dl>

<dl>
<dt id="index-ftw64">功能： <em>int</em> <strong>ftw64</strong> <em>（const char * <var>filename</var> ，__ftw64_func_t <var>func</var> ，int <var>descriptors</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>ftw</code>但是它可以在具有大文件的文件系统上工作。使用类型为变量的文件报告文件信息<code>struct stat64</code>通过引用传递给回调函数。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位系统上，该功能在名称下可用<code>ftw</code>并透明地取代了旧的实现。
</p></dd></dl>

<dl>
<dt id="index-nftw">函数： <em>int</em> <strong>nftw</strong> <em>（const char * <var>filename</var> ，__nftw_func_t <var>func</var> ，int <var>descriptors</var> ，int <var>flag</var> ）</em></dt>
<dd>
<p>初步： MT-Safe CWD | AS不安全堆| AC不安全的内存fd cwd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>nftw</code>功能像<code>ftw</code>功能。他们调用回调函数<var>func</var>对于目录中找到的所有项目<var>filename</var>及以下。最多<var>descriptors</var>文件描述符在<code>nftw</code>呼叫。
</p>
<p>一个区别是回调函数的类型不同。它是类型<code>struct FTW *</code> <!-- /@w -->并为回调函数提供上述额外信息。
</p>
<p>第二个区别是<code>nftw</code>接受第四个参数，该参数为<em>0</em>或以下任意值的按位“或”组合。
</p>
<dl compact>
<dt><code>FTW_PHYS</code>
<span id="index-FTW_005fPHYS"></span>
</dt>
<dd><p>在遍历目录时，不遵循符号链接。而是使用<code>FTW_SL</code>回调函数的type参数的值。如果符号链接引用的文件不存在<code>FTW_SLN</code>而是返回。
</p></dd>
<dt><code>FTW_MOUNT</code>
<span id="index-FTW_005fMOUNT"></span>
</dt>
<dd><p>仅对与由目录库指定的目录位于同一挂载文件系统上的项目调用回调函数。 <var>filename</var>参数<code>nftw</code> 。
</p></dd>
<dt><code>FTW_CHDIR</code>
<span id="index-FTW_005fCHDIR"></span>
</dt>
<dd><p>如果指定了此标志，则在调用回调函数之前，当前工作目录将更改为所报告对象的目录。什么时候<code>ntfw</code>最后返回当前目录，还原为原始值。
</p></dd>
<dt><code>FTW_DEPTH</code>
<span id="index-FTW_005fDEPTH"></span>
</dt>
<dd><p>如果指定了此选项，则在处理顶层目录本身之前（深度优先处理），将处理其中的所有子目录和文件。这也意味着赋予回调函数的类型标志是<code>FTW_DP</code>并不是<code>FTW_D</code> 。
</p></dd>
<dt><code>FTW_ACTIONRETVAL</code>
<span id="index-FTW_005fACTIONRETVAL"></span>
</dt>
<dd><p>如果指定了此选项，则对回调的返回值进行不同的处理。如果回调返回<code>FTW_CONTINUE</code> ，行走正常继续。 <code>FTW_STOP</code>意味着步行停下来， <code>FTW_STOP</code>返回给呼叫者。如果<code>FTW_SKIP_SUBTREE</code>由回调返回<code>FTW_D</code>参数，将跳过子树，并继续进行目录的下一个同级操作。如果<code>FTW_SKIP_SIBLINGS</code>由回调返回，则当前条目的所有同级都将被跳过，并且在其父级中继续行走。如果设置了此选项，则不应从回调中返回其他任何返回值。此选项是GNU扩展。
</p></dd>
</dl>

<p>返回值的计算方式与<code>ftw</code> 。
<code>nftw</code>返回<em>0，</em>如果没有故障发生，所有的回调函数返回<em>0。</em>如果发生内部错误（例如内存问题），则返回值为<em>-1，</em>并且<code>errno</code>被相应地设置。如果回调调用的返回值不为零，则返回该值。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位系统上，该功能实际上是<code>nftw64</code> ，即LFS接口透明地替换了旧接口。
</p></dd></dl>

<dl>
<dt id="index-nftw64">功能： <em>int</em> <strong>nftw64</strong> <em>（const char * <var>filename</var> ，__nftw64_func_t <var>func</var> ，int <var>descriptors</var> ，int <var>flag</var> ）</em></dt>
<dd>
<p>初步： MT-Safe CWD | AS不安全堆| AC不安全的内存fd cwd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>nftw</code>但是它可以在具有大文件的文件系统上工作。使用类型为变量的文件报告文件信息<code>struct stat64</code>通过引用传递给回调函数。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>在32位系统上，该功能在名称下可用<code>nftw</code>并透明地取代了旧的实现。
</p></dd></dl>


<hr>
<div class="header">
<p>下一篇： <a href="Hard-Links.html#Hard-Links" rel="next" accesskey="n">硬链接</a> ，上一篇： <a href="Accessing-Directories.html#Accessing-Directories" rel="prev" accesskey="p">访问目录</a> ，上一篇： <a href="File-System-Interface.html#File-System-Interface" rel="up" accesskey="u">文件系统界面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>