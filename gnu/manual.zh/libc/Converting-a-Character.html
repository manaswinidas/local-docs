<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>转换字符（GNU C库）</title>

<meta name="description" content="Converting a Character (The GNU C Library)">
<meta name="keywords" content="Converting a Character (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" title="Restartable multibyte conversion">
<link href="Converting-Strings.html#Converting-Strings" rel="next" title="Converting Strings">
<link href="Keeping-the-state.html#Keeping-the-state" rel="prev" title="Keeping the state">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Converting-a-Character"></span><div class="header">
<p>下一篇： <a href="Converting-Strings.html#Converting-Strings" rel="next" accesskey="n">转换字符串</a> ，上一篇： <a href="Keeping-the-state.html#Keeping-the-state" rel="prev" accesskey="p">保持状态</a> ，上一篇： <a href="Converting-Strings.html#Converting-Strings" rel="next" accesskey="n">可</a> <a href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" accesskey="u">重新启动的多字节转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Converting-Single-Characters"></span><h4 class="subsection">6.3.3转换单个字符</h4>

<p>转换函数中最基本的是那些处理单个字符的函数。请注意，这并不总是意味着单个字节。但是，由于通常多字节字符集的一个子集由单字节序列组成，因此有一些函数可以帮助转换字节。通常，ASCII是多字节字符集的子集。在这种情况下，每个ASCII字符代表其自身，而所有其他字符至少具有一个第一字节，该字节超出了<em>0</em>到<em>127</em>的范围。
</p>
<dl>
<dt id="index-btowc">函数： <em>wint_t</em> <strong>btowc</strong> <em>（int <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>btowc</code>函数（“字节到宽字符”）转换有效的单字节字符<var>c</var>使用从当前选择的语言环境的转换规则将初始移位状态转换为等效的宽字符<code>LC_CTYPE</code>类别。
</p>
<p>如果<code>(unsigned char) <var>c</var></code>不是有效的单字节多字节字符，或者<var>c</var>是<code>EOF</code> ，函数返回<code>WEOF</code> 。
</p>
<p>请注意以下限制<var>c</var>仅在初始换档状态下进行有效性测试。没有<code>mbstate_t</code>使用对象获取状态信息，该函数也不使用任何静态。
</p>
<span id="index-wchar_002eh-7"></span>
<p>的<code>btowc</code>函数是在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入的，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>尽管局限性在于始终在初始状态下解释单字节值，但实际上该功能在大多数时间都是有用的。大多数字符要么完全是单字节字符集，要么是ASCII的扩展。但是然后可以编写这样的代码（不是这个特定的示例非常有用）：</p>
<div class="example">
<pre class="example">wchar_t *
itow (unsigned long int val)
{
  static wchar_t buf[30];
  wchar_t *wcp = &amp;buf[29];
  *wcp = L'\0';
  while (val != 0)
    {
      *--wcp = btowc ('0' + val % 10);
      val /= 10;
    }
  if (wcp == &amp;buf[29])
    *--wcp = L'0';
  return wcp;
}
</pre></div>

<p>为什么需要使用如此复杂的实现而不是简单地强制转换<code>'0' + val % 10</code>宽广的性格？答案是不能保证可以对用于以下字符集的字符执行这种算法<code>wchar_t</code>表示。在其他情况下，字节在编译时不是恒定的，因此编译器无法完成工作。在这种情况下，使用<code>btowc</code>是必须的。
</p>
<p>还有一个用于向另一个方向转换的功能。
</p>
<dl>
<dt id="index-wctob">函数： <em>int</em> <strong>wctob</strong> <em>（wint_t <var>c</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wctob</code>函数（“宽字符到字节”）将有效的宽字符作为参数。如果此字符在初始状态下的多字节表示形式正好是一个字节长，则此函数的返回值为该字符。否则返回值为<code>EOF</code> 。
</p>
<span id="index-wchar_002eh-8"></span>
<p><code>wctob</code>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>还有更多通用功能可将单个字符从多字节表示形式转换为宽字符，反之亦然。这些函数对多字节表示的长度没有限制，并且也不需要它处于初始状态。
</p>
<dl>
<dt id="index-mbrtowc">函数： <em>size_t</em> <strong>mbrtowc</strong> <em>（wchar_t *限制<var>pwc</var> ，const char *限制<var>s</var> ，size_t <var>n</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：mbrtowc /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<span id="index-stateful-1"></span>
<p>的<code>mbrtowc</code>函数（“多字节可重新启动为宽字符”）转换由指向的字符串中的下一个多字节字符<var>s</var>变成一个宽字符并将其存储在指向的位置<var>pwc</var> 。转换是根据当前为<code>LC_CTYPE</code>类别。如果在语言环境中对字符集进行的转换需要状态，则多字节字符串将在由指向的对象表示的状态下解释<var>ps</var> 。如果<var>ps</var>是一个空指针，是一个静态的内部状态变量，仅由<code>mbrtowc</code>使用功能。
</p>
<p>如果下一个多字节字符与空宽字符相对应，则函数的返回值为<em>0</em> ，并且状态对象此后处于初始状态。如果下<var>n</var>或更少的字节组成一个正确的多字节字符，返回值是从以下位置开始的字节数<var>s</var>形成多字节字符。根据转换中消耗的字节更新转换状态。在这两种情况下，宽字符（ <code>L'\0'</code>或在转换中找到的那个）存储在由指向的字符串中<var>pwc</var>如果<var>pwc</var>不为空。
</p>
<p>如果先<var>n</var>多字节字符串的字节可能构成有效的多字节字符，但有多个<var>n</var>完成它所需的字节，该函数的返回值为<code>(size_t) -2</code>并且没有值存储在<code>*<var>pwc</var></code> 。转换状态已更新，所有<var>n</var>输入字节已消耗，不应再次提交。请注意，即使<var>n</var>的值大于或等于<code>MB_CUR_MAX</code>因为输入可能包含多余的移位序列。
</p>
<p>如果先<code>n</code>多字节字符串的字节不能构成有效的多字节字符，不存储任何值，全局变量<code>errno</code>设置为值<code>EILSEQ</code> ，然后函数返回<code>(size_t) -1</code> 。此后转换状态是不确定的。
</p>
<p>按照规定， <code>mbrtowc</code>函数可以处理包含嵌入式空字节的多字节序列（在Unicode编码（例如UTF-16）中发生），但是GNU C库不支持这种多字节编码。当遇到空输入字节时，该函数将返回零或返回<code>(size_t) -1)</code>并报告一个<code>EILSEQ</code>错误。的<code>iconv</code>函数可用于在任意编码之间进行转换。请参阅<a href="Generic-Conversion-Interface.html#Generic-Conversion-Interface">通用转换接口</a> 。
</p>
<span id="index-wchar_002eh-9"></span>
<p><code>mbrtowc</code>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>一个将多字节字符串复制为宽字符串，同时将所有小写字母转换为大写字母的函数可能如下所示：</p>
<div class="example">
<pre class="example">wchar_t *
mbstouwcs (const char *s)
{
  /* <span class="roman">Include the null terminator in the conversion.</span> */
  size_t len = strlen (s) + 1;
  wchar_t *result = reallocarray (NULL, len, sizeof (wchar_t));
  if (result == NULL)
    return NULL;

  wchar_t *wcp = result;
  mbstate_t state;
  memset (&amp;state, '\0', sizeof (state));

  while (true)
    {
      wchar_t wc;
      size_t nbytes = mbrtowc (&amp;wc, s, len, &amp;state);
      if (nbytes == 0)
        {
          /* <span class="roman">Terminate the result string.</span> */
          *wcp = L'\0';
          break;
        }
      else if (nbytes == (size_t) -2)
        {
          /* <span class="roman">Truncated input string.</span> */
          errno = EILSEQ;
          free (result);
          return NULL;
        }
      else if (nbytes == (size_t) -1)
        {
          /* <span class="roman">Some other error (including EILSEQ).</span> */
          free (result);
          return NULL;
        }
      else
        {
          /* <span class="roman">A character was converted.</span> */
          *wcp++ = towupper (wc);
          len -= nbytes;
          s += nbytes;
        }
    }
  return result;
}
</pre></div>

<p>在内部循环中，单个宽字符存储在<code>wc</code> ，并且已使用的字节数存储在变量中<code>nbytes</code> 。如果转换成功，则宽字符的大写变体将存储在<code>result</code>数组和指向输入字符串的指针以及可用字节数进行调整。如果<code>mbrtowc</code>函数返回零，空输入字节尚未转换，因此必须将其显式存储在结果中。
</p>
<p>上面的代码使用了这样一个事实，即转换后的结果中的宽字符永远不会比多字节输入字符串中的字节多。此方法对结果的大小产生悲观的猜测，如果必须以这种方式构造许多宽字符串，或者如果字符串较长，则由于输入字符串包含多字节字符而需要分配的额外内存可能很大。可以在返回之前将分配的内存块调整为正确的大小，但是更好的解决方案可能是立即为结果分配正确的空间量。不幸的是，没有函数直接从多字节字符串中计算宽字符串的长度。但是，有一个功能可以完成部分工作。
</p>
<dl>
<dt id="index-mbrlen">功能： <em>size_t</em> <strong>mbrlen</strong> <em>（const char * restrict <var>s</var> ，size_t <var>n</var> ，mbstate_t * <var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：mbrlen /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>mbrlen</code>函数（“多字节可重新启动长度”）计算最多<var>n</var>字节起始于<var>s</var> ，形成下一个有效且完整的多字节字符。
</p>
<p>如果下一个多字节字符对应于NUL宽字符，则返回值为<em>0</em> 。如果下<var>n</var>个字节组成有效的多字节字符，则返回属于该多字节字符字节序列的字节数。
</p>
<p>如果先<var>n</var>个字节可能构成一个有效的多字节字符，但该字符不完整，返回值为<code>(size_t) -2</code> 。否则，多字节字符序列无效，返回值为<code>(size_t) -1</code> 。
</p>
<p>多字节序列在由指向的对象表示的状态下解释<var>ps</var> 。如果<var>ps</var>是空指针，是本地的状态对象<code>mbrlen</code>用来。
</p>
<span id="index-wchar_002eh-10"></span>
<p><code>mbrlen</code>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>现在，细心的读者会注意到<code>mbrlen</code>可以实现为</p>
<div class="example">
<pre class="example">mbrtowc (NULL, s, n, ps != NULL ? ps : &amp;internal)
</pre></div>

<p>这是正确的，实际上是在官方规范中提到的。如何使用此函数确定由多字节字符串创建的宽字符串的长度？它不是直接可用的，但是我们可以定义一个函数<code>mbslen</code>使用它：</p>
<div class="example">
<pre class="example">size_t
mbslen (const char *s)
{
  mbstate_t state;
  size_t result = 0;
  size_t nbytes;
  memset (&amp;state, '\0', sizeof (state));
  while ((nbytes = mbrlen (s, MB_LEN_MAX, &amp;state)) &gt; 0)
    {
      if (nbytes &gt;= (size_t) -2)
        /* <span class="roman">Something is wrong.</span>  */
        return (size_t) -1;
      s += nbytes;
      ++result;
    }
  return result;
}
</pre></div>

<p>该函数简单地调用<code>mbrlen</code>字符串中的每个多字节字符，并计算函数调用的次数。请注意，我们在这里使用<code>MB_LEN_MAX</code>作为大小参数<code>mbrlen</code>呼叫。这是可以接受的，因为a）该值大于最长的多字节字符序列的长度，并且b）我们知道字符串<var>s</var>以NUL字节结尾，该字节不能是任何其他多字节字符序列的一部分，只能代表NUL宽字符。因此， <code>mbrlen</code>函数将永远不会读取无效的内存。
</p>
<p>既然可以使用此功能（为了清楚起见，此功能<em>不</em>属于GNU C库），我们可以计算存储转换后的多字节字符串所需的宽字符数<var>s</var>使用</p>
<div class="example">
<pre class="example">wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
</pre></div>

<p>请注意<code>mbslen</code>功能相当低效。实施<code>mbstouwcs</code>与<code>mbslen</code>将不得不两次执行多字节字符输入字符串的转换，并且这种转换可能会非常昂贵。因此，有必要在进行两次工作之前考虑使用更简单但不精确的方法的后果。
</p>
<dl>
<dt id="index-wcrtomb">功能： <em>size_t</em> <strong>wcrtomb</strong> <em>（字符*限制<var>s</var> ，wchar_t <var>wc</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：wcrtomb /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcrtomb</code>函数（“可重新启动到多字节的宽字符”）将单个宽字符转换为对应于该宽字符的多字节字符串。
</p>
<p>如果<var>s</var>是一个空指针，该函数重置存储在由指向的对象中的状态<var>ps</var> （或内部<code>mbstate_t</code>对象）到初始状态。也可以通过这样的调用来实现：</p>
<div class="example">
<pre class="example">wcrtombs (temp_buf, L'\0', ps)
</pre></div>

<p>因为，如果<var>s</var>是一个空指针， <code>wcrtomb</code>就像写入一个内部缓冲区一样，该缓冲区保证足够大。
</p>
<p>如果<var>wc</var>是NUL宽字符， <code>wcrtomb</code>发出必要的移位序列以获取状态<var>ps</var>进入初始状态，后跟单个NUL字节，该字节存储在字符串中<var>s</var> 。
</p>
<p>否则，将字节序列（可能包括移位序列）写入字符串<var>s</var> 。仅当<var>wc</var>是有效的宽字符（即，在由字符集的语言环境选择的字符集中具有多字节表示形式） <code>LC_CTYPE</code>类别）。如果<var>wc</var>不是有效的宽字符，字符串中没有存储任何内容<var>s</var> ， <code>errno</code>被设定为<code>EILSEQ</code> ，转换状态为<var>ps</var>未定义，返回值为<code>(size_t) -1</code> 。
</p>
<p>如果未发生错误，则函数返回存储在字符串中的字节数<var>s</var> 。这包括代表移位序列的所有字节。
</p>
<p>关于函数接口的一句话：没有参数指定数组的长度<var>s</var> 。相反，该函数假定至少有<code>MB_CUR_MAX</code>可用的字节数，因为这是代表单个字符的任何字节序列的最大长度。因此，调用方必须确保有足够的可用空间，否则缓冲区溢出可能会发生。
</p>
<span id="index-wchar_002eh-11"></span>
<p><code>wcrtomb</code>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>使用<code>wcrtomb</code>就像使用一样容易<code>mbrtowc</code> 。下面的示例将宽字符串追加到多字节字符串。同样，该代码并不是真正有用（或正确）的代码，仅在此处演示使用和一些问题。
</p>
<div class="example">
<pre class="example">char *
mbscatwcs (char *s, size_t len, const wchar_t *ws)
{
  mbstate_t state;
  /* <span class="roman">Find the end of the existing string.</span>  */
  char *wp = strchr (s, '\0');
  len -= wp - s;
  memset (&amp;state, '\0', sizeof (state));
  do
    {
      size_t nbytes;
      if (len &lt; MB_CUR_LEN)
        {
          /* <span class="roman">We cannot guarantee that the next</span>
             <span class="roman">character fits into the buffer, so</span>
             <span class="roman">return an error.</span>  */
          errno = E2BIG;
          return NULL;
        }
      nbytes = wcrtomb (wp, *ws, &amp;state);
      if (nbytes == (size_t) -1)
        /* <span class="roman">Error in the conversion.</span>  */
        return NULL;
      len -= nbytes;
      wp += nbytes;
    }
  while (*ws++ != L'\0');
  return s;
}
</pre></div>

<p>首先，该函数必须找到当前数组中字符串的结尾<var>s</var> 。的<code>strchr</code> call非常有效地执行了此操作，因为对多字节字符表示的要求是，绝不使用NUL字节来表示自身（在这种情况下为字符串的结尾）。
</p>
<p>初始化状态对象后，进入循环，第一个任务是确保数组中有足够的空间<var>s</var> 。如果没有至少我们放弃<code>MB_CUR_LEN</code>可用字节。这并不总是最佳的，但是我们别无选择。我们可能少于<code>MB_CUR_LEN</code>可用字节，但下一个多字节字符也可能只有一个字节长。当时<code>wcrtomb</code>调用返回，现在判断缓冲区是否足够大为时已晚。如果此解决方案不合适，则有一个非常慢但更准确的解决方案。
</p>
<div class="example">
<pre class="example">  &hellip;
  if (len &lt; MB_CUR_LEN)
    {
      mbstate_t temp_state;
      memcpy (&amp;temp_state, &amp;state, sizeof (state));
      if (wcrtomb (NULL, *ws, &amp;temp_state) &gt; len)
        {
          /* <span class="roman">We cannot guarantee that the next</span>
             <span class="roman">character fits into the buffer, so</span>
             <span class="roman">return an error.</span>  */
          errno = E2BIG;
          return NULL;
        }
    }
  &hellip;
</pre></div>

<p>在这里，我们执行可能会使缓冲区溢出的转换，以便我们以后可以对缓冲区的大小做出准确的决定。请注意<code>NULL</code>新目标缓冲区的参数<code>wcrtomb</code>呼叫;由于此时我们对转换后的文本不感兴趣，因此这是表达此信息的好方法。这段代码最不寻常的事情当然是转换状态对象的复制，但是如果需要改变状态以发出下一个多字节字符，我们希望在真实转换中执行相同的移位状态更改。因此，我们必须保留初始变速状态信息。
</p>
<p>对于这个问题，肯定有更多甚至更好的解决方案。本示例仅用于教育目的。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Converting-Strings.html#Converting-Strings" rel="next" accesskey="n">转换字符串</a> ，上一篇： <a href="Keeping-the-state.html#Keeping-the-state" rel="prev" accesskey="p">保持状态</a> ，上一篇： <a href="Converting-Strings.html#Converting-Strings" rel="next" accesskey="n">可</a> <a href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" accesskey="u">重新启动的多字节转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>