<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>整数解析（GNU C库）</title>

<meta name="description" content="Parsing of Integers (The GNU C Library)">
<meta name="keywords" content="Parsing of Integers (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-of-Numbers.html#Parsing-of-Numbers" rel="up" title="Parsing of Numbers">
<link href="Parsing-of-Floats.html#Parsing-of-Floats" rel="next" title="Parsing of Floats">
<link href="Parsing-of-Numbers.html#Parsing-of-Numbers" rel="prev" title="Parsing of Numbers">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Parsing-of-Integers"></span><div class="header">
<p>下一页： <a href="Parsing-of-Floats.html#Parsing-of-Floats" rel="next" accesskey="n">浮点数解析</a> ，上： <a href="Parsing-of-Numbers.html#Parsing-of-Numbers" rel="up" accesskey="u">数字解析</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Parsing-of-Integers-1"></span><h4 class="subsection">20.11.1解析整数</h4>

<span id="index-stdlib_002eh-17"></span>
<span id="index-wchar_002eh-16"></span>
<p>' <samp>str</samp> '函数在<samp>stdlib.h</samp>那些以“ <samp>wcs</samp> '在<samp>wchar.h</samp> 。有人可能会怀疑<code>restrict</code>在本节功能的原型中。它似乎没有用，但是ISO C <!-- /@w -->标准使用了它（用于那里定义的功能），因此我们也必须这样做。
</p>
<dl>
<dt id="index-strtol">函数： <em>long int</em> <strong>strtol</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtol</code> （“字符串到长整数”）函数转换<var>string</var>到有符号整数，该整数作为类型的值返回<code>long int</code> 。
</p>
<p>该函数试图分解<var>string</var>如下：</p>
<ul>
<li>空格字符序列（可能为空）。哪些字符是空格取决于<code>isspace</code>功能（请参阅<a href="Classification-of-Characters.html#Classification-of-Characters">字符分类</a> ）。这些被丢弃。

</li><li>可选的正负号（' <samp>+</samp> ' 要么 ' <samp>-</samp> '）。

</li><li>由指定的基数的非空数字序列<var>base</var> 。

<p>如果<var>base</var>为零，除非十进制数以'开始，否则假定为十进制基数<samp>0</samp> '（指定八进制基数），或' <samp>0x</samp> ' 要么 ' <samp>0X</samp> '（指定十六进制基数）；换句话说，C语言中用于整数常量的语法相同。</p>
<p>除此以外<var>base</var>必须具有介于<code>2</code>和<code>36</code> 。如果<var>base</var>是<code>16</code> ，数字可以可选地以' <samp>0x</samp> ' 要么 ' <samp>0X</samp> '。如果base没有法律价值，则返回的值为<code>0l</code>和全局变量<code>errno</code>被设定为<code>EINVAL</code> 。
</p>
</li><li>字符串中所有剩余的字符。如果<var>tailptr</var>不是空指针， <code>strtol</code>存储指向该尾巴的指针<code>*<var>tailptr</var></code> 。
</li></ul>

<p>如果字符串为空，仅包含空格或不包含初始子字符串，该子字符串具有指定整数中预期整数的语法<var>base</var> ，不执行任何转换。在这种情况下， <code>strtol</code>返回零值，并将该值存储在<code>*<var>tailptr</var></code>是...的价值<var>string</var> 。
</p>
<p>在标准以外的语言环境中<code>"C"</code>在语言环境中，此函数可能会识别其他与实现相关的语法。
</p>
<p>如果该字符串具有整数的有效语法，但由于溢出而无法表示该值， <code>strtol</code>返回<code>LONG_MAX</code>要么<code>LONG_MIN</code> （请参见<a href="Range-of-Type.html#Range-of-Type">类型范围</a> ），以适合值的符号。它还设置<code>errno</code>至<code>ERANGE</code>表示有溢出。
</p>
<p>您不应通过检查的返回值来检查错误<code>strtol</code> ，因为该字符串可能是的有效表示形式<code>0l</code> ， <code>LONG_MAX</code> ， 要么<code>LONG_MIN</code> 。相反，请检查是否<var>tailptr</var>指向数字后的期望值（例如， <code>'\0'</code>如果字符串应在数字后结束）。您还需要清除<code>errno</code>通话前请先检查一下，以防溢出。
</p>
<p>本节末尾有一个示例。
</p></dd></dl>

<dl>
<dt id="index-wcstol">函数： <em>long int</em> <strong>wcstol</strong> <em>（const wchar_t *限制<var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstol</code>功能相当于<code>strtol</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstol</code> ISO C90 <!-- /@w -->修订1 <!-- /@w -->中引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-strtoul">函数： <em>unsigned long int</em> <strong>strtoul</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtoul</code> （“ string-to-unsigned-long”）函数就像<code>strtol</code>除了它转换为<code>unsigned long int</code>值。语法与上述相同<code>strtol</code> 。溢出返回的值是<code>ULONG_MAX</code> （请参阅<a href="Range-of-Type.html#Range-of-Type">类型范围</a> ）。
</p>
<p>如果<var>string</var>描述一个负数， <code>strtoul</code>行为与<var>strtol</var>但将结果转换为无符号整数。例如，这意味着<code>strtoul</code>上<code>"-1"</code>退货<code>ULONG_MAX</code>而输入比<code>LONG_MIN</code>返回（ <code>ULONG_MAX</code> +1）/ 2。
</p>
<p><code>strtoul</code>套<code>errno</code>至<code>EINVAL</code>如果<var>base</var>超出范围，或<code>ERANGE</code>在溢出。
</p></dd></dl>

<dl>
<dt id="index-wcstoul">函数： <em>unsigned long int</em> <strong>wcstoul</strong> <em>（const wchar_t * restrict <var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoul</code>功能相当于<code>strtoul</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoul</code> ISO C90 <!-- /@w -->修订1 <!-- /@w -->中引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-strtoll">函数： <em>long long int</em> <strong>strtoll</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtoll</code>功能就像<code>strtol</code>除了它返回一个<code>long long int</code>值，并接受范围更大的数字。
</p>
<p>如果该字符串具有整数的有效语法，但由于溢出而无法表示该值， <code>strtoll</code>返回<code>LLONG_MAX</code>要么<code>LLONG_MIN</code> （请参见<a href="Range-of-Type.html#Range-of-Type">类型范围</a> ），以适合值的符号。它还设置<code>errno</code>至<code>ERANGE</code>表示有溢出。
</p>
<p>的<code>strtoll</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-wcstoll">函数： <em>long long int</em> <strong>wcstoll</strong> <em>（const wchar_t * restrict <var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoll</code>功能相当于<code>strtoll</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoll</code> ISO C90 <!-- /@w -->修订1 <!-- /@w -->中引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-strtoq">函数： <em>long long int</em> <strong>strtoq</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>strtoq</code> （“字符串到四字”）是BSD的名称<code>strtoll</code> 。
</p></dd></dl>

<dl>
<dt id="index-wcstoq">函数： <em>long long int</em> <strong>wcstoq</strong> <em>（const wchar_t *限制<var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoq</code>功能相当于<code>strtoq</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoq</code>函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-strtoull">函数： <em>unsigned long long int</em> <strong>strtoull</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtoull</code>功能与<code>strtoll</code>以同样的方式<code>strtoul</code>与有关<code>strtol</code> 。
</p>
<p>的<code>strtoull</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-wcstoull">函数： <em>unsigned long long int</em> <strong>wcstoull</strong> <em>（const wchar_t * restrict <var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoull</code>功能相当于<code>strtoull</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoull</code> ISO C90 <!-- /@w -->修订1 <!-- /@w -->中引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-strtouq">函数： <em>unsigned long long int</em> <strong>strtouq</strong> <em>（const char *限制<var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p><code>strtouq</code>是BSD名称<code>strtoull</code> 。
</p></dd></dl>

<dl>
<dt id="index-wcstouq">函数： <em>unsigned long long int</em> <strong>wcstouq</strong> <em>（const wchar_t *限制<var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstouq</code>功能相当于<code>strtouq</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstouq</code>函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-strtoimax">函数： <em>intmax_t</em> <strong>strtoimax</strong> <em>（const char * restrict <var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtoimax</code>功能就像<code>strtol</code>除了它返回一个<code>intmax_t</code>值，并接受相应范围的数字。
</p>
<p>如果该字符串具有整数的有效语法，但由于溢出而无法表示该值， <code>strtoimax</code>返回<code>INTMAX_MAX</code>要么<code>INTMAX_MIN</code> （请参阅<a href="Integers.html#Integers">Integers</a> ），以适合值的符号。它还设置<code>errno</code>至<code>ERANGE</code>表示有溢出。
</p>
<p>有关<a href="Integers.html#Integers">整数</a>的说明，请参见<a href="Integers.html#Integers">整数</a> 。 <code>intmax_t</code>类型。的<code>strtoimax</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-wcstoimax">函数： <em>intmax_t</em> <strong>wcstoimax</strong> <em>（const wchar_t * restrict <var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoimax</code>功能相当于<code>strtoimax</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoimax</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-strtoumax">功能： <em>uintmax_t</em> <strong>strtoumax</strong> <em>（const char * restrict <var>string</var> ，char ** restrict <var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strtoumax</code>功能与<code>strtoimax</code>同样的方式<code>strtoul</code>与有关<code>strtol</code> 。
</p>
<p>有关<a href="Integers.html#Integers">整数</a>的说明，请参见<a href="Integers.html#Integers">整数</a> 。 <code>intmax_t</code>类型。的<code>strtoumax</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-wcstoumax">功能： <em>uintmax_t</em> <strong>wcstoumax</strong> <em>（const wchar_t * restrict <var>string</var> ，wchar_t **限制<var>tailptr</var> ，int <var>base</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcstoumax</code>功能相当于<code>strtoumax</code>几乎在所有方面都可以起作用，但可以处理宽字符串。
</p>
<p>的<code>wcstoumax</code> ISO C99 <!-- /@w -->引入了该函数。
</p></dd></dl>

<dl>
<dt id="index-atol">功能： <em>long int</em> <strong>atol</strong> <em>（const char * <var>string</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>strtol</code>具有功能<var>base</var>的论点<code>10</code> ，除了不需要检测溢出错误。的<code>atol</code>提供功能主要是为了与现有代码兼容；使用<code>strtol</code>更强大。
</p></dd></dl>

<dl>
<dt id="index-atoi">函数： <em>int</em> <strong>atoi</strong> <em>（const char * <var>string</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>atol</code> ，除了它返回一个<code>int</code> 。的<code>atoi</code>功能也被认为已经过时；使用<code>strtol</code>代替。
</p></dd></dl>

<dl>
<dt id="index-atoll">功能： <em>long long int</em> <strong>环礁</strong> <em>（const char * <var>string</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>atol</code> ，除了它返回一个<code>long long int</code> 。
</p>
<p>的<code>atoll</code> ISO C99 <!-- /@w -->引入了该函数。它也已经过时了（尽管刚刚添加了）；使用<code>strtoll</code>代替。
</p></dd></dl>

<p>到目前为止，本节中提到的所有功能都无法处理语言环境数据中描述的字符的替代表示形式。一些语言环境指定了千位分隔符以及必须使用的分隔符，这有助于使大量数字更具可读性。要读取此类数字，必须使用<code>scanf</code>与' <samp>'</samp>的标志。
</p>
<p>这是一个将字符串解析为整数序列并返回它们之和的函数：</p>
<div class="example">
<pre class="example">int
sum_ints_from_string (char *string)
{
  int sum = 0;

  while (1) {
    char *tail;
    int next;

    /* <span class="roman">Skip whitespace by hand, to detect the end.</span>  */
    while (isspace (*string)) string++;
    if (*string == 0)
      break;

    /* <span class="roman">There is more nonwhitespace,</span>  */
    /* <span class="roman">so it ought to be another number.</span>  */
    errno = 0;
    /* <span class="roman">Parse it.</span>  */
    next = strtol (string, &amp;tail, 0);
    /* <span class="roman">Add it in, if not overflow.</span>  */
    if (errno)
      printf (&quot;Overflow\n&quot;);
    else
      sum += next;
    /* <span class="roman">Advance past it.</span>  */
    string = tail;
  }

  return sum;
}
</pre></div>

<hr>
<div class="header">
<p>下一页： <a href="Parsing-of-Floats.html#Parsing-of-Floats" rel="next" accesskey="n">浮点数解析</a> ，上： <a href="Parsing-of-Numbers.html#Parsing-of-Numbers" rel="up" accesskey="u">数字解析</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>