<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>基本计划功能（GNU C库）</title>

<meta name="description" content="Basic Scheduling Functions (The GNU C Library)">
<meta name="keywords" content="Basic Scheduling Functions (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Priority.html#Priority" rel="up" title="Priority">
<link href="Traditional-Scheduling.html#Traditional-Scheduling" rel="next" title="Traditional Scheduling">
<link href="Realtime-Scheduling.html#Realtime-Scheduling" rel="prev" title="Realtime Scheduling">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Basic-Scheduling-Functions"></span><div class="header">
<p>下一个： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="next" accesskey="n">传统计划</a> ，上一个： <a href="Realtime-Scheduling.html#Realtime-Scheduling" rel="prev" accesskey="p">实时计划</a> ，上： <a href="Priority.html#Priority" rel="up" accesskey="u">优先级</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Basic-Scheduling-Functions-1"></span><h4 class="subsection">22.3.3基本调度功能</h4>

<p>本节描述GNU C库中用于设置进程的绝对优先级和调度策略的函数。
</p>
<p><strong>可移植性注意：</strong>在具有本节功能的系统上，宏_POSIX_PRIORITY_SCHEDULING定义于<samp><unistd.h></samp> 。
</p>
<p>对于调度策略是传统调度的情况下，更多的功能，以微调的调度是在<a href="Traditional-Scheduling.html#Traditional-Scheduling">传统调度</a> 。
</p>
<p>不要试图从这些函数的命名和结构上做太多。它们不符合本手册中描述的概念，因为功能是由POSIX.1b定义的，但是在使用GNU C库的系统上的实现与POSIX结构的构想相反。POSIX方案假定主要调度参数是调度策略，并且优先级值（如果有）是调度策略的参数。但是，在实现中，优先级值为“王”，而调度策略（如果有）仅微调该优先级的效果。
</p>
<p>本节中的符号通过包含文件来声明<samp>sched.h</samp> 。
</p>
<p><strong>可移植性注意：</strong>在POSIX中， <code>pid_t</code>以下函数的参数引用进程ID。在Linux上，它们实际上是线程ID，并控制如何针对整个系统调度特定线程。产生的行为不符合POSIX。这就是为什么以下描述引用任务和任务ID，而不是进程和进程ID的原因。
</p>
<dl>
<dt id="index-struct-sched_005fparam">数据类型： <strong>struct sched_param</strong></dt>
<dd>
<p>此结构描述了绝对优先级。
</p><dl compact>
<dt><code>int sched_priority</code></dt>
<dd><p>绝对优先级值</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-sched_005fsetscheduler">函数： <em>int</em> <strong>sched_setscheduler</strong> <em>（pid_t <var>pid</var> ，int <var>policy</var> ，const struct sched_param * <var>param</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能为任务设置绝对优先级和调度策略。
</p>
<p>分配由给出的绝对优先级值<var>param</var>和调度策略<var>policy</var>带ID的任务<var>pid</var> ，或者调用任务，如果<var>pid</var>是零。如果<var>policy</var>是负面的<code>sched_setscheduler</code>保留现有的调度策略。
</p>
<p>以下宏代表以下内容的有效值： <var>policy</var> ：</p>
<dl compact>
<dt><code>SCHED_OTHER</code>
<span id="index-SCHED_005fOTHER"></span>
</dt>
<dd><p>传统排程</p></dd>
<dt><code>SCHED_FIFO</code>
<span id="index-SCHED_005fFIFO"></span>
</dt>
<dd><p>先进先出</p></dd>
<dt><code>SCHED_RR</code>
<span id="index-SCHED_005fRR"></span>
</dt>
<dd><p>循环赛</p></dd>
</dl>


<p>成功时，返回值为<code>0</code> 。不然是<code>-1</code>和<code>ERRNO</code>被相应地设置。的<code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>EPERM</code></dt>
<dd><ul>
<li>调用任务没有<code>CAP_SYS_NICE</code>许可和<var>policy</var>不是<code>SCHED_OTHER</code> （或者它是负面的，而现有的政策不是<code>SCHED_OTHER</code> 。

</li><li>调用任务没有<code>CAP_SYS_NICE</code>权限，并且其所有者不是目标任务的所有者。即，调用任务的有效uid既不是任务的有效uid，也不是任务的实际uid。 <var>pid</var> 。
</li></ul>

</dd>
<dt><code>ESRCH</code></dt>
<dd><p>pid没有任务<var>pid</var>和<var>pid</var>不为零。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><ul>
<li> <var>policy</var>无法识别现有的调度策略。

</li><li>由*标识的绝对优先级值<var>param</var>超出了调度策略的有效范围<var>policy</var> （或现有的计划政策，如果<var>policy</var>是负数）或<var>param</var>一片空白。 <code>sched_get_priority_max</code>和<code>sched_get_priority_min</code>告诉你有效范围是多少。

</li><li> <var>pid</var>是负面的。
</li></ul>
</dd>
</dl>

</dd></dl>


<dl>
<dt id="index-sched_005fgetscheduler">函数： <em>int</em> <strong>sched_getscheduler</strong> <em>（pid_t <var>pid</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数返回分配给ID为任务的计划策略<var>pid</var> ，或者调用任务，如果<var>pid</var>是零。
</p>
<p>返回值是调度策略。看到<code>sched_setscheduler</code>为可能的值。
</p>
<p>如果函数失败，则返回值改为<code>-1</code>和<code>errno</code>被相应地设置。
</p>
<p>的<code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>ESRCH</code></dt>
<dd><p>pid没有任务<var>pid</var>它不为零。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>pid</var>是负面的。
</p>
</dd>
</dl>

<p>请注意，此功能并非与<code>sched_setscheduler</code>因为虽然该函数设置了调度策略和绝对优先级，但是该函数仅获取调度策略。要获得绝对优先级，请使用<code>sched_getparam</code> 。
</p>
</dd></dl>


<dl>
<dt id="index-sched_005fsetparam">函数： <em>int</em> <strong>sched_setparam</strong> <em>（pid_t <var>pid</var> ，const struct sched_param * <var>param</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能设置任务的绝对优先级。
</p>
<p>它在功能上与<code>sched_setscheduler</code>与<var>policy</var> = <code>-1</code> 。
</p>

</dd></dl>

<dl>
<dt id="index-sched_005fgetparam">函数： <em>int</em> <strong>sched_getparam</strong> <em>（pid_t <var>pid</var> ，结构sched_param * <var>param</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数返回任务的绝对优先级。
</p>
<p><var>pid</var>是您要知道其绝对优先级的任务的任务ID。
</p>
<p><var>param</var>是指向结构的指针，该函数在其中存储任务的绝对优先级。
</p>
<p>成功时，返回值为<code>0</code> 。不然是<code>-1</code>和<code>errno</code>被相应地设置。的<code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>ESRCH</code></dt>
<dd><p>没有ID为的任务<var>pid</var>它不为零。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>pid</var>是负面的。
</p>
</dd>
</dl>

</dd></dl>


<dl>
<dt id="index-sched_005fget_005fpriority_005fmin">函数： <em>int</em> <strong>sched_get_priority_min</strong> <em>（int <var>policy</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数返回具有计划策略的任务所允许的最低绝对优先级值<var>policy</var> 。
</p>
<p>在Linux上，SCHED_OTHER的值为0，其他所有的值为1。
</p>
<p>成功时，返回值为<code>0</code> 。不然是<code>-1</code>和<code>ERRNO</code>被相应地设置。的<code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p><var>policy</var>无法识别现有的调度策略。
</p></dd>
</dl>

</dd></dl>

<dl>
<dt id="index-sched_005fget_005fpriority_005fmax">函数： <em>int</em> <strong>sched_get_priority_max</strong> <em>（int <var>policy</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数返回具有调度策略的任务所允许的最高绝对优先级值<var>policy</var> 。
</p>
<p>在Linux上，SCHED_OTHER的值为0，其他所有值为99。
</p>
<p>成功时，返回值为<code>0</code> 。不然是<code>-1</code>和<code>ERRNO</code>被相应地设置。的<code>errno</code>特定于此功能的值是：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p><var>policy</var>无法识别现有的调度策略。
</p></dd>
</dl>

</dd></dl>

<dl>
<dt id="index-sched_005frr_005fget_005finterval">函数： <em>int</em> <strong>sched_rr_get_interval</strong> <em>（pid_t <var>pid</var> ，struct timespec * <var>interval</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数返回具有循环ID的任务的任务的轮询（时间片）长度（如果使用了循环调度策略） <var>pid</var> 。
</p>
<p>它返回的时间长度为<var>interval</var> 。
</p>
<p>对于Linux内核，循环时间片始终为150微秒，并且<var>pid</var>甚至不必是真正的pid。
</p>
<p>返回值为<code>0</code>如果成功，并且在失败的病理情况下，返回值为<code>-1</code>和<code>errno</code>被相应地设置。此功能没有特定的错误，因此没有特定的错误<code>errno</code>价值观。
</p>
</dd></dl>

<dl>
<dt id="index-sched_005fyield">函数： <em>int</em> <strong>sched_yield</strong> <em>（无效）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能自动放弃任务对CPU的要求。</p>
<p>从技术上讲<code>sched_yield</code>使调用任务立即准备好运行（而不是之前运行的运行）。这意味着，如果它的绝对优先级高于0，它将被推到共享其绝对优先级并准备运行的任务队列的末尾，并且它将在下一个回合到达时再次运行。如果其绝对优先级为0，则更为复杂，但仍具有使CPU承担其他任务的作用。
</p>
<p>如果没有其他任务共享调用任务的绝对优先级，则此功能无效。
</p>
<p>如果所包含的程序不了解系统中的其他进程在做什么以及其执行速度如何，则此功能显示为无操作。
</p>
<p>返回值为<code>0</code>如果成功，并且在失败的病理情况下，返回值为<code>-1</code>和<code>errno</code>被相应地设置。此功能没有特定的错误，因此没有特定的错误<code>errno</code>价值观。
</p>
</dd></dl>

<hr>
<div class="header">
<p>下一个： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="next" accesskey="n">传统计划</a> ，上一个： <a href="Realtime-Scheduling.html#Realtime-Scheduling" rel="prev" accesskey="p">实时计划</a> ，上： <a href="Priority.html#Priority" rel="up" accesskey="u">优先级</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>