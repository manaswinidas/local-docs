<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>使用gettextized软件（GNU C库）</title>

<meta name="description" content="Using gettextized software (The GNU C Library)">
<meta name="keywords" content="Using gettextized software (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" title="Message catalogs with gettext">
<link href="Helper-programs-for-gettext.html#Helper-programs-for-gettext" rel="next" title="Helper programs for gettext">
<link href="GUI-program-problems.html#GUI-program-problems" rel="prev" title="GUI program problems">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Using-gettextized-software"></span><div class="header">
<p>上一篇： <a href="GUI-program-problems.html#GUI-program-problems" rel="prev" accesskey="p">GUI程序问题</a> ，上<a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">一篇</a> ： <a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">带有gettext的消息目录</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="User-influence-on-gettext"></span><h4 class="subsubsection">8.2.1.6用户对<code>gettext</code></h4>

<p>最后几节描述了程序员可以做什么以使程序消息国际化。但是最终由用户选择他/她希望看到的消息。他/他必须了解他们。
</p>
<p>POSIX语言环境模型使用环境变量<code>LC_COLLATE</code> ， <code>LC_CTYPE</code> ， <code>LC_MESSAGES</code> ， <code>LC_MONETARY</code> ， <code>LC_NUMERIC</code>和<code>LC_TIME</code>选择要使用的语言环境。这样，用户可以影响许多功能。如上所述， <code>gettext</code>功能也可以利用这一点。
</p>
<p>要了解这种情况是如何发生的，有必要查看文件名的各个组成部分，这些文件名经过计算可以找到消息目录。它的组成如下：</p>
<div class="example">
<pre class="example"><var>dir_name</var>/<var>locale</var>/LC_<var>category</var>/<var>domain_name</var>.mo
</pre></div>

<p>的默认值<var>dir_name</var>是系统特定的。它是在配置C库时从作为前缀给出的值计算得出的。该值通常是<samp>/usr</samp>要么<samp>/</samp> 。对于前者完整<var>dir_name</var>是：</p>
<div class="example">
<pre class="example">/usr/share/locale
</pre></div>

<p>我们可以用<samp>/usr/share</samp>自从<samp>.mo</samp>包含消息目录的文件是独立于系统的，因此所有系统都可以使用相同的文件。如果程序执行了<code>bindtextdomain</code>当前正在处理的消息域的功能<code>dir_name</code> component正是作为第二个参数提供给函数的值。即<code>bindtextdomain</code>允许覆盖唯一的与系统相关的固定值，从而可以对文件系统中任何位置的文件进行寻址。
</p>
<p>的<var>category</var>是在程序代码中选择的语言环境类别的名称。对于<code>gettext</code>和<code>dgettext</code>这总是<code>LC_MESSAGES</code> ，对于<code>dcgettext</code>这是由第三个参数的值选择的。如上所述，应避免使用除<code>LC_MESSAGES</code> 。
</p>
<p>的<var>locale</var>组件根据使用的类别进行计算。就像<code>setlocale</code>此处的功能使用户可以选择播放。将按固定顺序检查某些环境变量，并且第一个环境变量集确定查找过程的返回值。详细地，对于类别<code>LC_xxx</code>将按以下顺序检查以下变量：</p>
<dl compact>
<dt><code>LANGUAGE</code></dt>
<dt><code>LC_ALL</code></dt>
<dt><code>LC_xxx</code></dt>
<dt><code>LANG</code></dt>
</dl>

<p>这看起来很熟悉。除了<code>LANGUAGE</code>环境变量，这正是查找顺序<code>setlocale</code>功能用途。但是为什么要介绍<code>LANGUAGE</code>变量？
</p>
<p>原因是这些变量可以具有的值的语法与<code>setlocale</code>功能。如果我们设置<code>LC_ALL</code>遵循扩展语法的值，这意味着<code>setlocale</code>函数将永远无法使用此变量的值。另外一个变量消除了这个问题，我们可以独立于语言环境设置选择语言，这有时很有用。
</p>
<p>而对于<code>LC_xxx</code>该变量的值应仅由一个语言环境的规范组成<code>LANGUAGE</code>变量的值可以包含由冒号分隔的区域名称列表。细心的读者会意识到，这是我们设法实现上述其他要求之一的方式：我们希望能够指定语言的有序列表。
</p>
<p>回到构造的文件名，我们只缺少一个组件。的<var>domain_name</var>部分是使用<code>textdomain</code>功能或给予<code>dgettext</code>要么<code>dcgettext</code>作为第一个参数。现在很明显，程序代码中域名的一个不错的选择是与程序/程序包名称密切相关的字符串。例如，对于GNU C库，域名为<code>libc</code> 。
</p>
<p>有限的示例代码应显示程序应如何工作：</p>
<div class="example">
<pre class="example">{
  setlocale (LC_ALL, &quot;&quot;);
  textdomain (&quot;test-package&quot;);
  bindtextdomain (&quot;test-package&quot;, &quot;/usr/local/share/locale&quot;);
  puts (gettext (&quot;Hello, world!&quot;));
}
</pre></div>

<p>在程序启动时，默认域为<code>messages</code> ，默认语言环境为“ C”。的<code>setlocale</code>调用根据用户的环境变量设置语言环境；记住正确的功能<code>gettext</code>依靠正确的设置<code>LC_MESSAGES</code>语言环境（用于查找消息目录）和<code>LC_CTYPE</code>语言环境（用于字符集转换）。的<code>textdomain</code>调用将默认域更改为<code>test-package</code> 。的<code>bindtextdomain</code>调用指定域的消息目录<code>test-package</code>可以在目录下找到<samp>/usr/local/share/locale</samp> 。
</p>
<p>如果用户在他/他的环境中设置变量<code>LANGUAGE</code>至<code>de</code>的<code>gettext</code>函数将尝试使用文件中的翻译</p>
<div class="example">
<pre class="example">/usr/local/share/locale/de/LC_MESSAGES/test-package.mo
</pre></div>

<p>根据上面的描述，应该清楚此文件名的哪个组件由哪个源确定。
</p>
<p>在上面的示例中，我们假设<code>LANGUAGE</code>环境变量为<code>de</code> 。这可能是一个适当的选择，但是如果用户想使用该怎么办<code>LC_ALL</code>由于具有更广泛的可用性，此处所需的值是<code>de_DE.ISO-8859-1</code> ？上面我们已经提到，这种情况很少发生。例如，一个人可能更喜欢读方言，而如果该方言无法使用，请改用标准语言。
</p>
<p>的<code>gettext</code>函数了解这种情况并可以正常处理。这些函数识别环境变量的值的格式。它可以将值分割为不同的部分，并且通过省略唯一或其他部分可以构造新值。当然，这是以可预测的方式发生的。要了解这一点，必须知道环境变量值的格式。有一种或多或少的标准化形式，最初来自X / Open规范：</p>
<p><code>language[_territory[.codeset]][@modifier]</code>
</p>
<p>较不具体的语言环境名称将按照以下列表的顺序删除：</p>
<ol>
<li> <code>codeset</code>
</li><li> <code>normalized codeset</code>
</li><li> <code>territory</code>
</li><li> <code>modifier</code>
</li></ol>

<p>的<code>language</code>字段永远不会因为明显的原因而被丢弃。
</p>
<p>唯一的新事物是<code>normalized codeset</code>条目。这是另一个好东西，旨在帮助减少由于人们无法标准化字符集名称而引起的混乱。相反<span class="nolinebreak">，ISO-8859-1</span>的<!-- /@w -->经常可以看到<span class="nolinebreak">8859</span> <!-- /@w --> ，88591 <!-- /@w --> <span class="nolinebreak">，ISO8859-1</span> <!-- /@w --> ，或<span class="nolinebreak">ISO_8859-1</span> <!-- /@w --> 。的<code>normalized codeset</code>通过应用以下规则从用户提供的字符集名称生成值：</p>
<ol>
<li>删除除数字和字母外的所有字符。
</li><li>将字母折成小写。
</li><li>如果仅包含数字，则在字符串前面<code>"iso"</code> 。
</li></ol>

<p>因此，上述所有名称都将标准化为<code>iso88591</code> 。这使程序用户在选择语言环境名称时有更大的自由度。
</p>
<p>即使这个扩展功能仍然无法解决以下问题：可以使用完全不同的名称来表示相同的语言环境（例如， <code>de</code>和<code>german</code> ）。为了在这种情况下对本地化实施以及<code>gettext</code>函数了解别名。
</p>
<p>文件<samp>/usr/share/locale/locale.alias</samp> （更换<samp>/usr</samp>以及用于配置C库的任何前缀）包含备用名称到更常规名称的映射。系统管理员可以自由添加新条目来满足自己的需求。将从环境中选择的语言环境与该文件第一列中的条目进行比较（忽略大小写）。如果它们匹配，则将第二列的值用于进一步处理。
</p>
<p>在描述环境变量的格式时，我们已经提到字符集是选择消息目录时要考虑的因素。实际上，只能使用包含使用系统/程序的字符集编写的文本的目录（直接；这一天会有解决方案）。对于用户而言，这意味着他/她将始终必须照顾这一点。如果在消息目录的集合中有相同语言的文件，但使用不同字符集编码，则用户必须小心。
</p>

<hr>
<div class="header">
<p>上一篇： <a href="GUI-program-problems.html#GUI-program-problems" rel="prev" accesskey="p">GUI程序问题</a> ，上<a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">一篇</a> ： <a href="Message-catalogs-with-gettext.html#Message-catalogs-with-gettext" rel="up" accesskey="u">带有gettext的消息目录</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>