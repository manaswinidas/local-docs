<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>通用转换接口（GNU C库）</title>

<meta name="description" content="Generic Conversion Interface (The GNU C Library)">
<meta name="keywords" content="Generic Conversion Interface (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" title="Generic Charset Conversion">
<link href="iconv-Examples.html#iconv-Examples" rel="next" title="iconv Examples">
<link href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="prev" title="Generic Charset Conversion">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Generic-Conversion-Interface"></span><div class="header">
<p>下一页： <a href="iconv-Examples.html#iconv-Examples" rel="next" accesskey="n">iconv示例</a> ，上： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Generic-Character-Set-Conversion-Interface"></span><h4 class="subsection">6.5.1通用字符集转换接口</h4>

<p>这组功能遵循使用资源的传统循环：打开，使用，关闭。该界面包含三个功能，每个功能都实现一个步骤。
</p>
<p>在描述接口之前，有必要引入一种数据类型。就像其他打开-关闭接口一样，此处介绍的功能也可以使用手柄和<samp>iconv.h</samp>标头为使用的句柄定义一种特殊类型。
</p>
<dl>
<dt id="index-iconv_005ft">数据类型： <strong>iconv_t</strong></dt>
<dd>
<p>此数据类型是在中定义的抽象类型<samp>iconv.h</samp> 。用户不得假设有关此类型的定义的任何信息；它必须完全不透明。
</p>
<p>可以使用来为此类对象分配转换的句柄<code>iconv</code>功能。对象本身不需要释放，但是必须代表句柄的转换。
</p></dd></dl>

<p>第一步是创建句柄的功能。
</p>
<dl>
<dt id="index-iconv_005fopen">功能： <em>iconv_t</em> <strong>iconv_open</strong> <em>（const char * <var>tocode</var> ，const char * <var>fromcode</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>iconv_open</code>开始转换之前必须使用函数。该函数采用的两个参数确定转换的源字符集和目标字符集，如果实现有可能执行这种转换，则该函数返回一个句柄。
</p>
<p>如果所需的转换不可用，则<code>iconv_open</code>函数返回<code>(iconv_t) -1</code> 。在这种情况下，全局变量<code>errno</code>可以具有以下值：</p>
<dl compact>
<dt><code>EMFILE</code></dt>
<dd><p>该过程已经有<code>OPEN_MAX</code>文件描述符打开。
</p></dd>
<dt><code>ENFILE</code></dt>
<dd><p>已达到打开文件的系统限制。
</p></dd>
<dt><code>ENOMEM</code></dt>
<dd><p>没有足够的内存来执行该操作。
</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>来自的转换<var>fromcode</var>至<var>tocode</var>不支持。
</p></dd>
</dl>

<p>在不同的线程中不能使用相同的描述符来执行独立的转换。与描述符关联的数据结构包括有关转换状态的信息。不能通过在不同的转换中使用它来弄乱它。
</p>
<p>一个<code>iconv</code>描述符就像文件描述符一样，每次使用时都必须创建一个新的描述符。描述符并不代表来自的所有转换<var>fromset</var>至<var>toset</var> 。
</p>
<p>GNU C库的实现<code>iconv_open</code>对其他实现有一个重要的扩展。为了简化一组可用转换的扩展，该实现允许将必要的文件以及数据和代码存储在任意数量的目录中。下面将说明如何编写此扩展名（请参见<a href="glibc-iconv-Implementation.html#glibc-iconv-Implementation">glibc iconv实现</a> ）。在这里只重要的一点是要说<code>GCONV_PATH</code>仅当环境变量包含文件时，才考虑环境变量<samp>gconv-modules</samp> 。这些目录不必由系统管理员创建。实际上，引入此扩展是为了帮助用户编写和使用自己的新转换。当然，出于安全原因，这在SUID二进制文件中不起作用。在这种情况下，只考虑系统目录，通常是<samp><var>prefix</var>/lib/gconv</samp> 。的<code>GCONV_PATH</code>第一次调用时，环境变量将被精确检查一次<code>iconv_open</code>功能。变量的后续修改无效。
</p>
<span id="index-iconv_002eh"></span>
<p>的<code>iconv_open</code> X / Open可移植性指南，版本2 <!-- /@w -->早期介绍了该函数。所有商业Unices都支持它，这是Unix品牌所必需的。但是，实施的质量和完整性差异很大。的<code>iconv_open</code>函数在<samp>iconv.h</samp> 。
</p></dd></dl>

<p>的<code>iconv</code>实现可以将大型数据结构与由返回的句柄相关联<code>iconv_open</code> 。因此，至关重要的是，一旦执行了所有转换并且不再需要转换，则释放所有资源。
</p>
<dl>
<dt id="index-iconv_005fclose">函数： <em>int</em> <strong>iconv_close</strong> <em>（iconv_t <var>cd</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>iconv_close</code>函数释放与句柄关联的所有资源<var>cd</var> ，必须通过成功调用来返回<code>iconv_open</code>功能。
</p>
<p>如果函数调用成功，则返回值为<em>0</em> 。否则为<em>-1</em> ， <code>errno</code>设置适当。定义的错误是：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p>转换描述符无效。
</p></dd>
</dl>

<span id="index-iconv_002eh-1"></span>
<p>的<code>iconv_close</code>功能与其余的功能一起引入<code>iconv</code>在XPG2中起作用，并在中声明<samp>iconv.h</samp> 。
</p></dd></dl>

<p>该标准仅定义了一个实际的转换函数。因此，它具有最通用的接口：它允许从一个缓冲区转换为另一缓冲区。从文件到缓冲区的转换，反之亦然，甚至文件到文件的转换都可以在此之上实现。
</p>
<dl>
<dt id="index-iconv-1">功能： <em>size_t</em> <strong>iconv</strong> <em>（iconv_t <var>cd</var> ，字符** <var>inbuf</var> ，size_t * <var>inbytesleft</var> ，字符** <var>outbuf</var> ，size_t * <var>outbytesleft</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：cd | AS安全AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<span id="index-stateful-3"></span>
<p>的<code>iconv</code>函数根据与描述符关联的规则转换输入缓冲区中的文本<var>cd</var>并将结果存储在输出缓冲区中。可以连续多次对同一文本调用该函数，因为对于有状态字符集，必要的状态信息将保留在与描述符关联的数据结构中。
</p>
<p>输入缓冲区由指定<code>*<var>inbuf</var></code>它包含<code>*<var>inbytesleft</var></code>个字节。为了将使用的输入传递回呼叫者，需要额外的间接调用（请参阅下文）。重要的是要注意缓冲区指针的类型<code>char</code>即使输入文本用宽字符编码，长度也以字节为单位。
</p>
<p>以类似的方式指定输出缓冲区。<code>*<var>outbuf</var></code>至少指向缓冲区的开头<code>*<var>outbytesleft</var></code>结果的字节空间。缓冲区指针再次是类型<code>char</code>长度以字节为单位。如果<var>outbuf</var>要么<code>*<var>outbuf</var></code>如果为空指针，则执行转换，但没有输出可用。
</p>
<p>如果<var>inbuf</var>是一个空指针， <code>iconv</code>函数执行必要的操作以将转换状态转换为初始状态。对于无状态编码，这显然是无操作的，但是，如果编码具有状态，则此类函数调用可能会在输出缓冲区中放置一些字节序列，从而执行必要的状态更改。下次通话<var>inbuf</var>不是空指针，则从初始状态继续进行下去。程序员切勿对转换是否必须处理状态做出任何假设，这一点很重要。即使输入和输出字符集不是有状态的，实现也可能必须保留状态。这是由于为GNU C库选择了如下所述的实现。因此， <code>iconv</code>如果某些协议要求对输出文本进行此操作，则应始终执行重置状态的调用。
</p>
<p>转换由于以下三个原因之一而停止。首先是将输入缓冲区中的所有字符都转换。这实际上可能意味着两件事：要么消耗了输入缓冲区中的所有字节，要么缓冲区的末尾有一些字节可能构成完整字符，但输入不完整。停止的第二个原因是输出缓冲区已满。第三个原因是输入包含无效字符。
</p>
<p>在所有这些情况下，最后一次成功转换后的输入和输出缓冲区的缓冲区指针都存储在<var>inbuf</var>和<var>outbuf</var> ，每个缓冲区中的可用空间存储在<var>inbytesleft</var>和<var>outbytesleft</var> 。
</p>
<p>由于在<code>iconv_open</code>调用几乎是任意的，在某些情况下，输入缓冲区包含有效字符，这些字符在输出字符集中没有相同的表示形式。在这种情况下的行为是不确定的。在这种情况下，GNU C库的<em>当前</em>行为是立即返回错误。当然，这不是最理想的解决方案。因此，将来的版本将提供更好的版本，但尚未完成。
</p>
<p>如果来自输入缓冲区的所有输入都已成功转换并存储在输出缓冲区中，则该函数将返回执行的不可逆转换的次数。在所有其他情况下，返回值为<code>(size_t) -1</code>和<code>errno</code>设置适当。在这种情况下， <var>inbytesleft</var>不为零。
</p>
<dl compact>
<dt><code>EILSEQ</code></dt>
<dd><p>由于输入中的字节序列无效，转换停止。通话结束后<code>*<var>inbuf</var></code>指向无效字节序列的第一个字节。
</p>
</dd>
<dt><code>E2BIG</code></dt>
<dd><p>转换停止，因为它耗尽了输出缓冲区中的空间。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>由于输入缓冲区末尾的字节序列不完整，转换停止了。
</p>
</dd>
<dt><code>EBADF</code></dt>
<dd><p>的<var>cd</var>参数无效。
</p></dd>
</dl>

<span id="index-iconv_002eh-2"></span>
<p>的<code>iconv</code>函数在XPG2标准中引入，并在<samp>iconv.h</samp>标头。
</p></dd></dl>

<p>的定义<code>iconv</code>总体功能还不错。它提供了相当灵活的功能。唯一的问题在于边界情况，边界情况是输入缓冲区末尾的字节序列不完整以及无效的输入。第三个问题（实际上并不是设计问题）是转换的选择方式。该标准未对合法名称进行任何说明，仅提供少量可用转换。我们将看到这如何对其他实现产生负面影响，如下所示。
</p>
<hr>
<div class="header">
<p>下一页： <a href="iconv-Examples.html#iconv-Examples" rel="next" accesskey="n">iconv示例</a> ，上： <a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion" rel="up" accesskey="u">通用字符集转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>