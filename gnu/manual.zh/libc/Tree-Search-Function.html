<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>树搜索功能（GNU C库）</title>

<meta name="description" content="Tree Search Function (The GNU C Library)">
<meta name="keywords" content="Tree Search Function (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Searching-and-Sorting.html#Searching-and-Sorting" rel="up" title="Searching and Sorting">
<link href="Pattern-Matching.html#Pattern-Matching" rel="next" title="Pattern Matching">
<link href="Hash-Search-Function.html#Hash-Search-Function" rel="prev" title="Hash Search Function">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Tree-Search-Function"></span><div class="header">
<p>上一页： <a href="Hash-Search-Function.html#Hash-Search-Function" rel="prev" accesskey="p">哈希搜索功能</a> ，向上： <a href="Searching-and-Sorting.html#Searching-and-Sorting" rel="up" accesskey="u">搜索和排序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="The-tsearch-function_002e"></span><h3 class="section">9.6的<code>tsearch</code>功能。</h3>

<p>组织数据以进行有效搜索的另一种常见形式是使用树。的<code>tsearch</code>函数族通过提供与元素数量的对数成正比的平均访问时间，为函数提供了一个不错的接口来组织可能的大量数据。GNU C库的实现甚至保证即使对于简单的二叉树实现会引起问题的输入数据，也绝不会超出该范围。
</p>
<p>本章中描述的功能均在System V <!-- /@w -->和X / Open规范中进行了描述，因此具有很高的可移植性。
</p>
<p>与之相反<code>hsearch</code>功能<code>tsearch</code>函数可用于任意数据，而不仅限于零终止的字符串。
</p>
<p>的<code>tsearch</code>函数的优点是不需要初始化数据结构的函数。类型的简单指针<code>void *</code>初始化为<code>NULL</code>是有效的树，可以扩展或搜索。这些函数的原型可以在头文件中找到<samp>search.h</samp> 。
</p>
<dl>
<dt id="index-tsearch">函数： <em>void *</em> <strong>tsearch</strong> <em>（常量void * <var>key</var>无效** <var>rootp</var> ，comparison_fn_t <var>compar</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：rootp | AS不安全堆| AC不安全的损坏的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>tsearch</code>函数在由指向的树中搜索<code>*<var>rootp</var></code>用于元素匹配<var>key</var> 。所指向的功能<var>compar</var>用于确定两个元素是否匹配。有关可用于以下功能的功能的说明，请参见<a href="Comparison-Functions.html#Comparison-Functions">比较功能</a> 。 <var>compar</var>参数。
</p>
<p>如果树不包含匹配条目，则<var>key</var>值将添加到树中。 <code>tsearch</code>不复制由指向的对象<var>key</var> （由于大小未知，怎么可能）。相反，它添加了对此对象的引用，这意味着只要使用树数据结构，该对象就必须可用。
</p>
<p>由于有时需要更改树的根节点，因此该树由指向指针的指针表示。因此，不能假定由指向的变量<var>rootp</var>通话后的值相同。这也表明，调用<code>tsearch</code>使用同一棵树同时执行多个功能。在不同的树上一次运行一次以上没有问题。
</p>
<p>返回值是指向树中匹配元素的指针。如果创建了新元素，则指针指向新数据（实际上是<var>key</var> ）。如果必须创建一个条目并且程序空间不足<code>NULL</code>返回。
</p></dd></dl>

<dl>
<dt id="index-tfind">函数： <em>void *</em> <strong>tfind</strong> <em>（常量void * <var>key</var>无效* const * <var>rootp</var> ，comparison_fn_t <var>compar</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：rootp | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>tfind</code>功能类似于<code>tsearch</code>功能。它找到与所指向的元素匹配的元素<var>key</var>并返回指向该元素的指针。但是，如果没有匹配的元素可用，则不会输入新元素（请注意， <var>rootp</var>参数指向常量指针）。相反，函数返回<code>NULL</code> 。
</p></dd></dl>

<p>的另一个优势<code>tsearch</code>功能与<code>hsearch</code>功能是有一种简单的方法来删除元素。
</p>
<dl>
<dt id="index-tdelete">函数： <em>void *</em> <strong>tdelete</strong> <em>（const void * <var>key</var>无效** <var>rootp</var> ，comparison_fn_t <var>compar</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：rootp | AS不安全堆| AC不安全的损坏的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>删除特定元素匹配<var>key</var>从树上<code>tdelete</code>可以使用。它使用与<code>tfind</code> 。然后删除相应的元素，并且该函数返回指向已删除节点的父节点的指针。如果树中没有匹配的条目，则无法删除任何内容，并且该函数返回<code>NULL</code> 。如果树的根被删除<code>tdelete</code>返回一些不等于的未指定值<code>NULL</code> 。
</p></dd></dl>

<dl>
<dt id="index-tdestroy">函数： <em>void</em> <strong>tdestroy</strong> <em>（无效* <var>vroot</var> ，__free_fn_t <var>freefct</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>如果必须删除整个搜索树，则可以使用<code>tdestroy</code> 。它将释放由服务器分配的所有资源。 <code>tsearch</code>函数生成由指向的树<var>vroot</var> 。
</p>
<p>对于每个树节点中的数据，该函数<var>freefct</var>叫做。指向数据的指针作为函数的参数传递。如果不需要这样的工作<var>freefct</var>必须指向不执行任何操作的函数。在任何情况下都称为。
</p>
<p>该函数是GNU扩展，不属于System V <!-- /@w -->或X / Open规范。
</p></dd></dl>

<p>除了创建和销毁树数据结构的功能外，还有另一个功能允许您将功能应用于树的所有元素。该函数必须具有以下类型：</p>
<div class="example">
<pre class="example">void __action_fn_t (const void *nodep, VISIT value, int level);
</pre></div>

<p>的<var>nodep</var>是当前节点的数据值（一旦指定为<var>key</var>争论<code>tsearch</code> ）。 <var>level</var>是一个数值，对应于树中当前节点的深度。根节点的深度为<em>0</em> ，其子节点的深度为<em>1</em> ，依此类推。的<code>VISIT</code> type是一个枚举类型。
</p>
<dl>
<dt id="index-VISIT">资料类型： <strong>VISIT</strong></dt>
<dd><p>的<code>VISIT</code> value指示树中当前节点的状态以及该函数的调用方式。节点的状态为“叶”或“内部节点”。对于每个叶节点，该函数仅被调用一次，对于每个内部节点，将被调用三次：在处理第一个孩子之前，在处理第一个孩子之后以及两个孩子都被处理之后。这使得处理树遍历的所有三种方法（甚至是它们的组合）成为可能。
</p>
<dl compact>
<dt><code>preorder</code>
<span id="index-preorder"></span>
</dt>
<dd><p>当前节点是一个内部节点，在处理第一个子节点之前调用该函数。
</p></dd>
<dt><code>postorder</code>
<span id="index-postorder"></span>
</dt>
<dd><p>当前节点是内部节点，并且在处理第一个子节点之后调用该函数。
</p></dd>
<dt><code>endorder</code>
<span id="index-endorder"></span>
</dt>
<dd><p>当前节点是内部节点，并且在处理第二个子节点之后调用该函数。
</p></dd>
<dt><code>leaf</code>
<span id="index-leaf"></span>
</dt>
<dd><p>当前节点是叶子。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-twalk">函数： <em>void</em> <strong>twalk</strong> <em>（常量void * <var>root</var> ，__action_fn_t <var>action</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：root | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>对于树中每个节点所指向的节点<var>root</var> ， <code>twalk</code>函数调用参数提供的函数<var>action</var> 。对于叶节点，该函数仅被调用一次<var>value</var>调成<code>leaf</code> 。对于内部节点，该函数被调用三次，设置<var>value</var>参数或<var>action</var>到适当的值。的<var>level</var>的论点<var>action</var>函数的计算是在下降树的过程中，通过向子节点的每个后代将值增加1，从根节点的值<em>0</em>开始。
</p>
<p>由于用于<var>action</var>参数<code>twalk</code>一定不要修改树数据，可以安全运行<code>twalk</code>在同一棵树上同时运行多个线程。打电话也很安全<code>tfind</code>在平行下。禁止使用修改树的函数，否则行为未定义。但是，如果不求助于全局变量（和线程安全性问题），就很难将树外部的数据传递给回调函数。 <code>twalk_r</code>功能如下。
</p></dd></dl>

<dl>
<dt id="index-twalk_005fr">函数： <em>void</em> <strong>twalk_r</strong> <em>（const void * <var>root</var> ，无效（* <var>action</var> ）（const void * <var>key</var> ，访问<var>which</var> ，无效* <var>closure</var> ），无效* <var>closure</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：root | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>对于树中每个节点所指向的节点<var>root</var> ， <code>twalk_r</code>函数调用参数提供的函数<var>action</var> 。对于叶节点，该函数仅被调用一次<var>which</var>调成<code>leaf</code> 。对于内部节点，该函数被调用三次，设置<var>which</var>的参数<var>action</var>到适当的值。的<var>closure</var>参数向下传递给的每个调用<var>action</var>功能，未修改。
</p>
<p>可以实施<code>twalk</code>功能之上<code>twalk_r</code>函数，这就是为什么没有单独的级别参数的原因。
</p>
<div class="example">
<pre class="example">

#include &lt;search.h&gt;

struct twalk_with_twalk_r_closure
{
  void (*action) (const void *, VISIT, int);
  int depth;
};

static void
twalk_with_twalk_r_action (const void *nodep, VISIT which, void *closure0)
{
  struct twalk_with_twalk_r_closure *closure = closure0;

  switch (which)
    {
    case leaf:
      closure-&gt;action (nodep, which, closure-&gt;depth);
      break;
    case preorder:
      closure-&gt;action (nodep, which, closure-&gt;depth);
      ++closure-&gt;depth;
      break;
    case postorder:
      /* <span class="roman">The preorder action incremented the depth.</span> */
      closure-&gt;action (nodep, which, closure-&gt;depth - 1);
      break;
    case endorder:
      --closure-&gt;depth;
      closure-&gt;action (nodep, which, closure-&gt;depth);
      break;
    }
}

void
twalk (const void *root, void (*action) (const void *, VISIT, int))
{
  struct twalk_with_twalk_r_closure closure = { action, 0 };
  twalk_r (root, twalk_with_twalk_r_action, &amp;closure);
}
</pre></div>
</dd></dl>
<hr>
<div class="header">
<p>上一页： <a href="Hash-Search-Function.html#Hash-Search-Function" rel="prev" accesskey="p">哈希搜索功能</a> ，向上： <a href="Searching-and-Sorting.html#Searching-and-Sorting" rel="up" accesskey="u">搜索和排序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>