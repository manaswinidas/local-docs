<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>行输入（GNU C库）</title>

<meta name="description" content="Line Input (The GNU C Library)">
<meta name="keywords" content="Line Input (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" title="I/O on Streams">
<link href="Unreading.html#Unreading" rel="next" title="Unreading">
<link href="Character-Input.html#Character-Input" rel="prev" title="Character Input">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Line-Input"></span><div class="header">
<p>下一个：未<a href="Unreading.html#Unreading" rel="next" accesskey="n">读</a> ，上一个： <a href="Character-Input.html#Character-Input" rel="prev" accesskey="p">字符输入</a> ，上： <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">流</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Line_002dOriented-Input"></span><h3 class="section">12.9线路输入</h3>

<p>由于许多程序根据行来解释输入，因此具有从流中读取一行文本的功能很方便。
</p>
<p>标准C具有执行此操作的功能，但是它们不是很安全：空字符甚至（对于<code>gets</code> ）长行可能会使他们感到困惑。因此，GNU C库提供了非标准<code>getline</code>该功能使轻松可靠地读取行变得容易。
</p>
<p>另一个GNU扩展， <code>getdelim</code> ，概括<code>getline</code> 。它读取定界记录，该定界记录定义为下次出现指定定界符时所发生的所有事情。
</p>
<p>所有这些功能都在中声明<samp>stdio.h</samp> 。
</p>
<dl>
<dt id="index-getline">函数： <em>ssize_t</em> <strong>getline</strong> <em>（char ** <var>lineptr</var> ，size_t * <var>n</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全的损坏堆| AC不安全锁损坏了内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该函数从中读取整行<var>stream</var> ，将文本（包括换行符和终止的空字符）存储在缓冲区中，并将缓冲区地址存储在<code>*<var>lineptr</var></code> 。
</p>
<p>致电之前<code>getline</code> ，您应该放置在<code>*<var>lineptr</var></code>缓冲区的地址<code>*<var>n</var></code>字节长，分配有<code>malloc</code> 。如果此缓冲区足够长以容纳该行， <code>getline</code>将行存储在此缓冲区中。除此以外， <code>getline</code>使用更大的缓冲区<code>realloc</code> ，将新的缓冲区地址存储回<code>*<var>lineptr</var></code>然后增加尺寸<code>*<var>n</var></code> 。请参阅<a href="Unconstrained-Allocation.html#Unconstrained-Allocation">无限制分配</a> 。
</p>
<p>如果您设定<code>*<var>lineptr</var></code>指向空指针，并且<code>*<var>n</var></code>到零，在通话之前，然后<code>getline</code>通过调用为您分配初始缓冲区<code>malloc</code> 。即使即使<code>getline</code>遇到错误，无法读取任何字节。
</p>
<p>无论哪种情况， <code>getline</code>返回， <code>*<var>lineptr</var></code>是一个<code>char *</code>指向该行的文本。
</p>
<p>什么时候<code>getline</code>如果成功，则返回读取的字符数（包括换行符，但不包括终止null）。使用此值，您可以将行中的空字符与作为终止符插入的空字符区分开。
</p>
<p>此函数是GNU扩展，但建议从流中读取行。替代的标准功能不可靠。
</p>
<p>如果发生错误或到达文件末尾而未读取任何字节， <code>getline</code>退货<code>-1</code> 。
</p></dd></dl>

<dl>
<dt id="index-getdelim">函数： <em>ssize_t</em> <strong>getdelim</strong> <em>（char ** <var>lineptr</var> ，size_t * <var>n</var> ，int <var>delimiter</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全的损坏堆| AC不安全锁损坏了内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>这个功能就像<code>getline</code>告诉它停止阅读的字符不一定是换行符。争论<var>delimiter</var>指定分隔符； <code>getdelim</code>继续阅读，直到看到该字符（或文件结尾）为止。
</p>
<p>文本存储在<var>lineptr</var> ，包括定界符和终止null。喜欢<code>getline</code> ， <code>getdelim</code>使<var>lineptr</var>如果不够大，则更大。
</p>
<p><code>getline</code>实际上是根据<code>getdelim</code> ， 像这样：</p>
<div class="example">
<pre class="example">ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
  return getdelim (lineptr, n, '\n', stream);
}
</pre></div>
</dd></dl>

<dl>
<dt id="index-fgets">函数： <em>char *</em> <strong>fgets</strong> <em>（字符* <var>s</var> ，int <var>count</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全锁损坏|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>fgets</code>函数从流中读取字符<var>stream</var>最多包含换行符并将其存储在字符串中<var>s</var> ，添加一个空字符以标记字符串的结尾。您必须提供<var>count</var>字符价值的空间<var>s</var> ，但最多读取的字符数<var>count</var> -1。多余的字符空间用于在字符串末尾保留空字符。
</p>
<p>如果系统在调用时已经在文件末尾<code>fgets</code> ，然后是数组的内容<var>s</var>保持不变，并返回空指针。如果发生读取错误，还将返回空指针。否则，返回值是指针<var>s</var> 。
</p>
<p><strong>警告：</strong>如果输入数据为空字符，则无法分辨。所以不要使用<code>fgets</code>除非您知道数据不能包含null。不要使用它来读取用户编辑的文件，因为如果用户插入一个空字符，则应该正确处理它或打印一条清晰的错误消息。我们建议使用<code>getline</code>代替<code>fgets</code> 。
</p></dd></dl>

<dl>
<dt id="index-fgetws">函数： <em>wchar_t *</em> <strong>fgetws</strong> <em>（wchar_t * <var>ws</var> ，int <var>count</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全锁损坏|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>fgetws</code>函数从流中读取宽字符<var>stream</var>最多包含换行符并将其存储在字符串中<var>ws</var> ，添加一个null宽字符来标记字符串的结尾。您必须提供<var>count</var>字符空间很大<var>ws</var> ，但最多读取的字符数<var>count</var> -1。多余的字符空间用于在字符串末尾保留null宽字符。
</p>
<p>如果系统在调用时已经在文件末尾<code>fgetws</code> ，然后是数组的内容<var>ws</var>保持不变，并返回空指针。如果发生读取错误，还将返回空指针。否则，返回值是指针<var>ws</var> 。
</p>
<p><strong>警告：</strong>如果输入数据的宽度为空（在输入流中为空字节），则无法分辨。所以不要使用<code>fgetws</code>除非您知道数据不能包含null。不要使用它来读取用户编辑的文件，因为如果用户插入一个空字符，则应该正确处理它或打印一条清晰的错误消息。
</p></dd></dl>

<dl>
<dt id="index-fgets_005funlocked">函数： <em>char *</em> <strong>fgets_unlocked</strong> <em>（char * <var>s</var> ，int <var>count</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：流|不安全AS损坏| AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>fgets_unlocked</code>功能相当于<code>fgets</code>函数，但它不会隐式锁定流。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-fgetws_005funlocked">函数： <em>wchar_t *</em> <strong>fgetws_unlocked</strong> <em>（wchar_t * <var>ws</var> ，int <var>count</var> ，文件* <var>stream</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：流|不安全AS损坏| AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>fgetws_unlocked</code>功能相当于<code>fgetws</code>函数，但它不会隐式锁定流。
</p>
<p>此函数是GNU扩展。
</p></dd></dl>

<dl>
<dt id="index-gets">不推荐使用的功能： <em>char *</em> <strong>gets</strong> <em>（char * <var>s</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全锁损坏|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>gets</code>从流中读取字符<code>stdin</code>直到下一个换行符，并将它们存储在字符串中<var>s</var> 。换行符将被丢弃（请注意，这与<code>fgets</code> ，它将换行符复制到字符串中）。如果<code>gets</code>遇到读取错误或文件结束时，它返回空指针；否则返回<var>s</var> 。
</p>
<p><strong>警告：</strong> <code>gets</code>该函数<strong>非常危险，</strong>因为它无法防止字符串溢出<var>s</var> 。GNU C库包含它仅出于兼容性考虑。你应该<strong>经常</strong>使用<code>fgets</code>要么<code>getline</code>代替。为了提醒您，链接器（如果使用GNU <code>ld</code> ）会在您每次使用时发出警告<code>gets</code> 。
</p></dd></dl>

<hr>
<div class="header">
<p>下一个：未<a href="Unreading.html#Unreading" rel="next" accesskey="n">读</a> ，上一个： <a href="Character-Input.html#Character-Input" rel="prev" accesskey="p">字符输入</a> ，上： <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">流</a>上的<a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>