<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>符号链接（GNU C库）</title>

<meta name="description" content="Symbolic Links (The GNU C Library)">
<meta name="keywords" content="Symbolic Links (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="File-System-Interface.html#File-System-Interface" rel="up" title="File System Interface">
<link href="Deleting-Files.html#Deleting-Files" rel="next" title="Deleting Files">
<link href="Hard-Links.html#Hard-Links" rel="prev" title="Hard Links">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Symbolic-Links"></span><div class="header">
<p>下一篇： <a href="Deleting-Files.html#Deleting-Files" rel="next" accesskey="n">删除文件</a> ，上一篇： <a href="Hard-Links.html#Hard-Links" rel="prev" accesskey="p">硬链接</a> ，上一篇： <a href="File-System-Interface.html#File-System-Interface" rel="up" accesskey="u">文件系统界面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Symbolic-Links-1"></span><h3 class="section">14.5符号链接</h3>
<span id="index-soft-link"></span>
<span id="index-link_002c-soft"></span>
<span id="index-symbolic-link"></span>
<span id="index-link_002c-symbolic"></span>

<p>GNU系统支持<em>软链接</em>或<em>符号链接</em> 。这是一种“文件”，本质上是指向另一个文件名的指针。与硬链接不同，符号链接可以无限制地指向目录或跨文件系统。您也可以建立符号链接到一个名称，该名称不是任何文件的名称。（在创建具有该名称的文件之前，打开此链接将失败。）同样，如果符号链接指向一个现有文件，该文件随后将被删除，则即使该名称不再为任何文件命名，该符号链接也会继续指向相同的文件名。
</p>
<p>符号链接按其方式工作的原因是，当您尝试打开链接时会发生特殊的事情。的<code>open</code>该函数将实现您已指定链接的名称，读取链接中包含的文件名，然后打开该文件名。的<code>stat</code>函数同样对符号链接指向的文件起作用，而不是对链接本身起作用。
</p>
<p>相反，其他操作（例如删除或重命名文件）在链接本身上进行。功能<code>readlink</code>和<code>lstat</code>也不要遵循符号链接，因为它们的目的是获得有关链接的信息。 <code>link</code> ，建立硬链接的功能也执行。它使人们很难链接到符号链接。
</p>
<p>对于某些在文件上运行的功能，某些系统对解析路径名时遵循的符号链接数有限制。如果存在限制，则将其发布在<samp>sys/param.h</samp>头文件。
</p>
<dl>
<dt id="index-MAXSYMLINKS">巨集： <em>int</em> <strong>MAXSYMLINKS</strong></dt>
<dd>

<p>宏<code>MAXSYMLINKS</code>指定在返回之前某个函数将跟随多少符号链接<code>ELOOP</code> 。并非所有函数的行为都相同，并且此值与返回的值不同<code>_SC_SYMLOOP</code>通过<code>sysconf</code> 。实际上， <code>sysconf</code>结果可以表明没有固定的限制，尽管<code>MAXSYMLINKS</code>存在并具有有限值。
</p></dd></dl>

<p>本节中列出的大多数功能的原型都在<samp>unistd.h</samp> 。
<span id="index-unistd_002eh-6"></span>
</p>
<dl>
<dt id="index-symlink">函数： <em>int</em> <strong>symlink</strong> <em>（const char * <var>oldname</var> ，const char * <var>newname</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>symlink</code>函数建立符号链接<var>oldname</var>命名<var>newname</var> 。
</p>
<p>的正常返回值<code>symlink</code>是<code>0</code> 。返回值为<code>-1</code>表示错误。除了常见的文件名语法错误（请参阅<a href="File-Name-Errors.html#File-Name-Errors">文件名错误</a> ）之外，以下内容<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EEXIST</code></dt>
<dd><p>已经存在一个名为<var>newname</var> 。
</p>
</dd>
<dt><code>EROFS</code></dt>
<dd><p>文件<var>newname</var>将存在于只读文件系统上。
</p>
</dd>
<dt><code>ENOSPC</code></dt>
<dd><p>目录或文件系统无法扩展以建立新链接。
</p>
</dd>
<dt><code>EIO</code></dt>
<dd><p>在磁盘上读取或写入数据时发生硬件错误。
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt id="index-readlink">函数： <em>ssize_t</em> <strong>readlink</strong> <em>（const char * <var>filename</var> ，字符* <var>buffer</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>readlink</code>函数获取符号链接的值<var>filename</var> 。链接指向的文件名被复制到<var>buffer</var> 。该文件名字符串<em>不以</em>空值结尾； <code>readlink</code>通常返回复制的字符数。的<var>size</var>参数指定要复制的最大字符数，通常为<var>buffer</var> 。
</p>
<p>如果返回值等于<var>size</var> ，您无法判断是否有返回全名的空间。因此，请设置更大的缓冲区并调用<code>readlink</code>再次。这是一个例子：</p>
<div class="example">
<pre class="example">char *
readlink_malloc (const char *filename)
{
  int size = 100;
  char *buffer = NULL;

  while (1)
    {
      buffer = (char *) xrealloc (buffer, size);
      int nchars = readlink (filename, buffer, size);
      if (nchars &lt; 0)
        {
          free (buffer);
          return NULL;
        }
      if (nchars &lt; size)
        return buffer;
      size *= 2;
    }
}
</pre></div>

<p>值<code>-1</code>发生错误时返回。除了常见的文件名错误（请参阅<a href="File-Name-Errors.html#File-Name-Errors">文件名错误</a> ）之外，以下内容<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>命名文件不是符号链接。
</p>
</dd>
<dt><code>EIO</code></dt>
<dd><p>在磁盘上读取或写入数据时发生硬件错误。
</p></dd>
</dl>
</dd></dl>

<p>在某些情况下，需要解析所有符号链接以获得文件的真实名称，其中没有前缀命名符号链接，并且后面没有符号名<code>.</code>要么<code>..</code> 。例如，如果必须比较文件，则这是理想的，在这种情况下，不同的名称可以引用相同的inode。
</p>
<dl>
<dt id="index-canonicalize_005ffile_005fname">函数： <em>char *</em> <strong>canonicalize_file_name</strong> <em>（const char * <var>name</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>canonicalize_file_name</code>函数返回由命名的文件的绝对名称<var>name</var>其中不包含<code>.</code> ， <code>..</code>组件或任何重复的路径分隔符（ <code>/</code> ）或符号链接。结果作为函数的返回值传回给分配有以下内容的内存块中： <code>malloc</code> 。如果结果不再使用，则应通过以下方式释放内存： <code>free</code> 。
</p>
<p>如果缺少任何路径组件，则该函数将返回NULL指针。如果路径长度达到或超过此长度，也会返回此内容<code>PATH_MAX</code>字符。任何状况之下<code>errno</code>被相应地设置。
</p>
<dl compact>
<dt><code>ENAMETOOLONG</code></dt>
<dd><p>结果路径太长。仅在文件名长度受限制的系统上才会发生此错误。
</p>
</dd>
<dt><code>EACCES</code></dt>
<dd><p>路径组件中的至少一个是不可读的。
</p>
</dd>
<dt><code>ENOENT</code></dt>
<dd><p>输入文件名为空。
</p>
</dd>
<dt><code>ENOENT</code></dt>
<dd><p>路径组件中至少有一个不存在。
</p>
</dd>
<dt><code>ELOOP</code></dt>
<dd><p>多于<code>MAXSYMLINKS</code>许多符号链接已被遵循。
</p></dd>
</dl>

<p>此函数是GNU扩展，在中声明<samp>stdlib.h</samp> 。
</p></dd></dl>

<p>Unix标准包含一个类似的功能，与<code>canonicalize_file_name</code>用户必须提供放置结果的缓冲区。
</p>
<dl>
<dt id="index-realpath">函数： <em>char *</em> <strong>realpath</strong> <em>（const char * restrict <var>name</var> ，char *限制<var>resolved</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全堆| AC不安全的内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>致电<code>realpath</code>在哪里<var>resolved</var>参数是<code>NULL</code>表现完全像<code>canonicalize_file_name</code> 。该函数为文件名分配一个缓冲区，并返回一个指向它的指针。如果<var>resolved</var>不是<code>NULL</code>它指向将结果复制到的缓冲区。分配足够大的缓冲区是调用者的责任。在定义<code>PATH_MAX</code>这意味着对于此大小的路径名，缓冲区必须足够大。对于不受路径名长度限制的系统，将无法满足要求，并且不应调用程序<code>realpath</code>除了什么<code>NULL</code>第二个参数。
</p>
<p>另一个不同之处是缓冲区<var>resolved</var> （如果非零）将包含路径组件中不存在或如果函数返回不可读的部分<code>NULL</code>和<code>errno</code>被设定为<code>EACCES</code>要么<code>ENOENT</code> 。
</p>
<p>该函数在<samp>stdlib.h</samp> 。
</p></dd></dl>

<p>使用此功能的优点是可以更广泛地使用它。缺点是，它会报告文件名长度没有限制的系统上的长路径失败。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Deleting-Files.html#Deleting-Files" rel="next" accesskey="n">删除文件</a> ，上一篇： <a href="Hard-Links.html#Hard-Links" rel="prev" accesskey="p">硬链接</a> ，上一篇： <a href="File-System-Interface.html#File-System-Interface" rel="up" accesskey="u">文件系统界面</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>