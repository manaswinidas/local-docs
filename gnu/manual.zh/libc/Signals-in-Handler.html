<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>处理程序中的信号（GNU C库）</title>

<meta name="description" content="Signals in Handler (The GNU C Library)">
<meta name="keywords" content="Signals in Handler (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Defining-Handlers.html#Defining-Handlers" rel="up" title="Defining Handlers">
<link href="Merged-Signals.html#Merged-Signals" rel="next" title="Merged Signals">
<link href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" title="Longjmp in Handler">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Signals-in-Handler"></span><div class="header">
<p>下一篇： <a href="Merged-Signals.html#Merged-Signals" rel="next" accesskey="n">合并信号</a> ，上<a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">一篇</a> ： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">处理程序中的</a> <a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">Longjmp</a> ，上<a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">一篇</a> ： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">定义处理程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Signals-Arriving-While-a-Handler-Runs"></span><h4 class="subsection">24.4.4处理程序运行时信号到达</h4>
<span id="index-race-conditions_002c-relating-to-signals"></span>

<p>如果在您的信号处理程序功能运行时另一个信号到达会怎样？
</p>
<p>调用特定信号的处理程序时，该信号将自动被阻止，直到处理程序返回为止。这意味着，如果两个相同类型的信号靠近在一起，则将保持第二个信号，直到处理完第一个信号为止。（处理程序可以使用<code>sigprocmask</code> ，如果您想允许更多此类信号进入；参见<a href="Process-Signal-Mask.html#Process-Signal-Mask">过程信号屏蔽</a> 。）
</p>
<p>但是，您的处理程序仍然可以通过传递另一种信号来中断。为避免这种情况，您可以使用<code>sa_mask</code>动作结构的成员传递给<code>sigaction</code>明确指定在信号处理程序运行时应阻止哪些信号。这些信号是调用了处理程序的信号以及进程通常阻止的其他任何信号的补充。请参阅<a href="Blocking-for-Handler.html#Blocking-for-Handler">为处理程序阻塞</a> 。
</p>
<p>当处理程序返回时，被阻止的信号集将恢复为处理程序运行之前的值。所以用<code>sigprocmask</code>处理程序内部的内容仅影响在处理程序本身执行期间可以到达的信号，而不会影响处理程序返回时可以到达的信号。
</p>
<p><strong>便携性注意事项：</strong>始终使用<code>sigaction</code>如果希望程序在System V Unix上正常运行，则为期望异步接收的信号建立处理程序。在此系统上，处理其处理程序已建立的信号<code>signal</code>自动将信号的动作设置回<code>SIG_DFL</code> ，并且处理程序每次运行时都必须重新建立自身。这种做法虽然不方便，但在信号无法连续到达时确实起作用。但是，如果另一个信号可以立即到达，则它可能在处理程序重新建立自身之前到达。然后，第二个信号将接收默认处理，这可能会终止该过程。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Merged-Signals.html#Merged-Signals" rel="next" accesskey="n">合并信号</a> ，上<a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">一篇</a> ： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">处理程序中的</a> <a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">Longjmp</a> ，上<a href="Longjmp-in-Handler.html#Longjmp-in-Handler" rel="prev" accesskey="p">一篇</a> ： <a href="Defining-Handlers.html#Defining-Handlers" rel="up" accesskey="u">定义处理程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>