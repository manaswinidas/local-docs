<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>内存保护（GNU C库）</title>

<meta name="description" content="Memory Protection (The GNU C Library)">
<meta name="keywords" content="Memory Protection (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Memory.html#Memory" rel="up" title="Memory">
<link href="Locking-Pages.html#Locking-Pages" rel="next" title="Locking Pages">
<link href="Resizing-the-Data-Segment.html#Resizing-the-Data-Segment" rel="prev" title="Resizing the Data Segment">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Memory-Protection"></span><div class="header">
<p>下一个： <a href="Locking-Pages.html#Locking-Pages" rel="next" accesskey="n">锁定页面</a> ，上一个： <a href="Resizing-the-Data-Segment.html#Resizing-the-Data-Segment" rel="prev" accesskey="p">调整数据段大小</a> ，上一个： <a href="Memory.html#Memory" rel="up" accesskey="u">内存</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Memory-Protection-1"></span><h3 class="section">3.4内存保护</h3>
<span id="index-memory-protection"></span>
<span id="index-page-protection"></span>
<span id="index-protection-flags"></span>

<p>使用映射页面时<code>mmap</code> ，可以使用保护标志参数指定页面保护标志。请参阅<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存映射的I / O。</a></p>
<p>以下标志可用：</p>
<dl compact>
<dt><code>PROT_WRITE</code>
<span id="index-PROT_005fWRITE"></span>
</dt>
<dd>
<p>可以写入内存。
</p>
</dd>
<dt><code>PROT_READ</code>
<span id="index-PROT_005fREAD"></span>
</dt>
<dd>
<p>可以读取内存。在某些体系结构上，此标志表示也可以执行内存（好像<code>PROT_EXEC</code>已同时指定）。
</p>
</dd>
<dt><code>PROT_EXEC</code>
<span id="index-PROT_005fEXEC"></span>
</dt>
<dd>
<p>存储器可用于存储随后可以执行的指令。在大多数架构上，此标志表示可以读取内存（好像<code>PROT_READ</code>已指定）。
</p>
</dd>
<dt><code>PROT_NONE</code>
<span id="index-PROT_005fNONE"></span>
</dt>
<dd>
<p>该标志必须自己指定。
</p>
<p>内存已保留，但无法读取，写入或执行。如果在调用中指定了此标志<code>mmap</code> ，将留出一个虚拟内存区域供以后在此过程中使用，并且<code>mmap</code>没有的通话<code>MAP_FIXED</code>标志不会将其用于后续分配。对于匿名映射，内核在创建映射时将不会为该分配保留任何物理内存。
</p></dd>
</dl>

<p>即使底层硬件出于访问检查的目的将它们视为相同，操作系统也可能会分别跟踪这些标志。 <code>PROT_READ</code>和<code>PROT_EXEC</code>在某些平台上）。在GNU系统上， <code>PROT_EXEC</code>总是暗示<code>PROT_READ</code> ，以便用户可以查看在其系统上执行的机器代码。
</p>
<p>不当访问将导致段<a href="Program-Error-Signals.html#Program-Error-Signals">错误</a> （请参阅<a href="Program-Error-Signals.html#Program-Error-Signals">程序错误信号</a> ）。
</p>
<p>分配后，可以使用<code>mprotect</code>功能。
</p>
<dl>
<dt id="index-mprotect">函数： <em>int</em> <strong>mprotect</strong> <em>（无效* <var>address</var> ，size_t <var>length</var> ，int <var>protection</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>成功致电<code>mprotect</code>功能至少更改了保护标志<var>length</var>内存字节，从<var>address</var> 。
</p>
<p><var>address</var>必须与映射的页面大小对齐。可以通过调用获得系统页面大小<code>sysconf</code>与<code>_SC_PAGESIZE</code>参数（请参阅<a href="Sysconf-Definition.html#Sysconf-Definition">Sysconf定义</a> ）。系统页面大小是可以更改匿名内存映射和大多数文件映射的页面保护的粒度。从特殊文件或设备映射的内存可能具有比系统页面大小更大的页面粒度，并且可能需要更大的对齐方式。
</p>
<p><var>length</var>是必须更改其保护标志的字节数。它会自动舍入为系统页面大小的下一个倍数。
</p>
<p><var>protection</var>是<code>PROT_*</code>上述标志。
</p>
<p>的<code>mprotect</code>函数成功返回<em>0</em> ，失败返回<em>-1</em> 。
</p>
<p>下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>ENOMEM</code></dt>
<dd><p>系统无法分配资源来满足请求。如果系统中没有足够的物理内存来分配后备存储，则会发生这种情况。如果新的保护标志将导致内存区域与其邻居分离，并且超出了此类不同内存区域数量的处理限制，也会发生错误。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p><var>address</var>与映射的页面边界未正确对齐，或者<var>length</var> （四舍五入到系统页面大小后）不是映射所适用页面大小的倍数，也不是标记中的组合<var>protection</var>无效。
</p>
</dd>
<dt><code>EACCES</code></dt>
<dd><p>未使用与以下文件兼容的打开标志打开基于文件的映射的文件<var>protection</var> 。
</p>
</dd>
<dt><code>EPERM</code></dt>
<dd><p>系统安全策略不允许使用指定的标志进行映射。例如，两者的映射<code>PROT_EXEC</code>和<code>PROT_WRITE</code>同时可能不允许。
</p></dd>
</dl>
</dd></dl>

<p>如果<code>mprotect</code>函数用于通过指定<code>PROT_NONE</code>保护标志并在以后恢复访问，存储器保留其先前的内容。
</p>
<p>在某些系统上，可能无法指定首次创建映射时不存在的其他标志。例如，如果初始保护标志为' <samp>PROT_READ | PROT_WRITE</samp> '。
</p>
<p>一般来说， <code>mprotect</code>该函数可用于更改任何进程内存，无论其分配方式如何。但是，该函数的可移植使用要求它仅与由以下方法返回的内存区域一起使用<code>mmap</code>要么<code>mmap64</code> 。
</p>
<span id="Memory-Protection-Keys"></span><h4 class="subsection">3.4.1内存保护键</h4>

<span id="index-memory-protection-key"></span>
<span id="index-protection-key"></span>
<span id="index-MPK"></span>
<p>在某些系统上，可以使用<em>内存保护键</em>在特定页面上添加更多限制。这些限制的工作方式如下：</p>
<ul>
<li>所有内存页均与保护锁关联。默认保护密钥不会导致在内存访问期间应用任何其他保护。可以使用<code>pkey_alloc</code>功能，并应用于使用<code>pkey_mprotect</code> 。

</li><li>每个线程对每个保护密钥都有一组单独的访问权限限制。这些访问权限可以使用<code>pkey_set</code>和<code>pkey_get</code>功能。

</li><li>在内存访问期间，系统会获取被访问页面的保护密钥，并使用该密钥来确定适用于当前线程的访问权限。如果访问受到限制，则会导致分段错误（请参阅<a href="Program-Error-Signals.html#Program-Error-Signals">程序错误信号</a> ）。这些检查是除<code>PROT_</code> *保护标志设置<code>mprotect</code>要么<code>pkey_mprotect</code> 。
</li></ul>

<p>新线程和子进程继承当前线程的访问权限。如果随后分配了保护密钥，则现有线程（当前线程除外）将对与新分配的密钥相关联的访问权限使用未指定的系统默认值。
</p>
<p>进入信号处理程序后，系统将重置当前线程的访问权限，以便可以访问具有默认密钥的页面，但未指定其他保护密钥的访问权限。
</p>
<p>预期应用程序一旦使用就会分配一个密钥<code>pkey_alloc</code> ，并将密钥应用于需要使用以下命令进行特殊保护的存储区域<code>pkey_mprotect</code> ：</p>
<div class="example">
<pre class="example">  int key = pkey_alloc (0, PKEY_DISABLE_ACCESS);
  if (key &lt; 0)
    /* Perform error checking, including fallback for lack of support.  */
    ...;

  /* Apply the key to a special memory region used to store critical
     data.  */
  if (pkey_mprotect (region, region_length,
                     PROT_READ | PROT_WRITE, key) &lt; 0)
    ...; /* Perform error checking (generally fatal).  */
</pre></div>

<p>如果由于缺乏对内存保护密钥的支持而导致密钥分配失败，则<code>pkey_mprotect</code>通常可以跳过通话。在这种情况下，默认情况下将不保护该区域。也可以打电话<code>pkey_mprotect</code>键值为<em>-1</em> ，在这种情况下，它的行为与<code>mprotect</code> 。
</p>
<p>将密钥分配给内存页后， <code>pkey_set</code>可用于临时获取对内存区域的访问权并再次放弃它：</p>
<div class="example">
<pre class="example">  if (key &gt;= 0 &amp;&amp; pkey_set (key, 0) &lt; 0)
    ...; /* Perform error checking (generally fatal).  */
  /* At this point, the current thread has read-write access to the
     memory region.  */
  ...
  /* Revoke access again.  */
  if (key &gt;= 0 &amp;&amp; pkey_set (key, PKEY_DISABLE_ACCESS) &lt; 0)
    ...; /* Perform error checking (generally fatal).  */
</pre></div>

<p>在此示例中，负密钥值表示尚未分配任何密钥，这意味着系统缺乏对内存保护密钥的支持，并且无需更改当前线程的访问权限（因为它始终具有访问权限）。
</p>
<p>与使用相比<code>mprotect</code>要更改页面保护标志，此方法有两个优点：从某种意义上说，它是线程安全的，因为仅对当前线程更改了访问权限，因此另一个线程会同时更改其自身的访问权限以获取对映射的访问权限。没有突然看到其访问权限被撤销。和<code>pkey_set</code>通常不涉及调用内核和上下文切换，因此效率更高。
</p>
<dl>
<dt id="index-pkey_005falloc">功能： <em>int</em> <strong>pkey_alloc</strong> <em>（unsigned int <var>flags</var> ，unsigned int <var>restrictions</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>分配新的保护密钥。的<var>flags</var>参数保留，并且必须为零。的<var>restrictions</var>参数指定应用于当前线程的访问权限（就像使用<code>pkey_set</code>下面）。其他线程的访问权限不变。
</p>
<p>该函数返回新的保护密钥，一个非负数或错误时为<em>-1</em> 。
</p>
<p>下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>ENOSYS</code></dt>
<dd><p>系统未实现内存保护锁。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<var>flags</var>参数不为零。
</p>
<p>的<var>restrictions</var>参数无效。
</p>
<p>系统未实现内存保护键或在禁用内存保护键的模式下运行。
</p>
</dd>
<dt><code>ENOSPC</code></dt>
<dd><p>已经分配了所有可用的保护密钥。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-pkey_005ffree">函数： <em>int</em> <strong>pkey_free</strong> <em>（int <var>key</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>取消分配保护密钥，以便可以将其重用<code>pkey_alloc</code> 。
</p>
<p>调用此功能不会更改释放的保护密钥的访问权限。调用线程和其他线程可以保留对其的访问，即使随后再次对其进行了分配。因此，不建议致电<code>pkey_free</code>功能。
</p>
<dl compact>
<dt><code>ENOSYS</code></dt>
<dd><p>系统未实现内存保护锁。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<var>key</var>参数不是有效的保护密钥。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-pkey_005fmprotect">函数： <em>int</em> <strong>pkey_mprotect</strong> <em>（无效* <var>address</var> ，size_t <var>length</var> ，int <var>protection</var> ，int <var>key</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>相似<code>mprotect</code> ，还要将内存区域的内存保护键设置为<code>key</code> 。
</p>
<p>某些系统使用内存保护键来模拟某些组合<var>protection</var>标志。在这种情况下，指定显式保护键的行为可能与在<var>protection</var> ，即使使用默认保护密钥也不会发生这种情况。例如，某些系统可以支持<code>PROT_EXEC</code> -仅映射具有默认保护密钥的内存，以及具有通过以下方式分配的密钥的内存<code>pkey_alloc</code>如果仍然可读<code>PROT_EXEC</code>指定不带<code>PROT_READ</code> 。
</p>
<p>如果<var>key</var>是<em>-1</em> ，默认保护密钥将应用于映射，就像<code>mprotect</code>被打了。
</p>
<p>的<code>pkey_mprotect</code>函数成功返回<em>0</em> ，失败返回<em>-1</em> 。相同<code>errno</code>错误条件<code>mprotect</code>为此功能定义了以下内容：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>的<var>key</var>参数不是<em>-1</em>或使用分配的有效内存保护密钥<code>pkey_alloc</code> 。
</p>
</dd>
<dt><code>ENOSYS</code></dt>
<dd><p>系统未实现内存保护锁，并且<var>key</var>不是<em>-1</em> 。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-pkey_005fset">函数： <em>int</em> <strong>pkey_set</strong> <em>（int <var>key</var> ，unsigned int <var>rights</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>使用保护键更改当前线程对内存页面的访问权限<var>key</var>至<var>rights</var> 。如果<var>rights</var>为零，则不应用除页面保护标志之外的其他访问限制。除此以外， <var>rights</var>是以下标志的组合：</p>
<dl compact>
<dt><code>PKEY_DISABLE_WRITE</code>
<span id="index-PKEY_005fDISABLE_005fWRITE"></span>
</dt>
<dd>
<p>随后尝试使用指定的保护密钥写入内存将失败。
</p>
</dd>
<dt><code>PKEY_DISABLE_ACCESS</code>
<span id="index-PKEY_005fDISABLE_005fACCESS"></span>
</dt>
<dd>
<p>随后尝试使用指定的保护密钥对内存进行写入或读取操作将失败。
</p></dd>
</dl>

<p>未指定为标志的操作不受限制。特别是，这意味着如果将内存区域与<code>PROT_EXEC</code>保护标志和<code>PKEY_DISABLE_ACCESS</code>已指定。
</p>
<p>呼叫<code>pkey_set</code>具有未分配的保护密钥的功能<code>pkey_alloc</code>导致未定义的行为。这意味着在不支持内存保护键的系统上调用此函数是不确定的。
</p>
<p>的<code>pkey_set</code>函数成功返回<em>0</em> ，失败返回<em>-1</em> 。
</p>
<p>下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p>系统不支持<var>rights</var>论点。
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-pkey_005fget">函数： <em>int</em> <strong>pkey_get</strong> <em>（int <var>key</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>使用保护密钥返回当前线程对内存页面的访问权限<var>key</var> 。返回值为零或以下各项的组合<code>PKEY_DISABLE_</code> *标志；看到<code>pkey_set</code>功能。
</p>
<p>呼叫<code>pkey_get</code>具有未分配的保护密钥的功能<code>pkey_alloc</code>导致未定义的行为。这意味着在不支持内存保护键的系统上调用此函数是不确定的。
</p></dd></dl>

<hr>
<div class="header">
<p>下一个： <a href="Locking-Pages.html#Locking-Pages" rel="next" accesskey="n">锁定页面</a> ，上一个： <a href="Resizing-the-Data-Segment.html#Resizing-the-Data-Segment" rel="prev" accesskey="p">调整数据段大小</a> ，上一个： <a href="Memory.html#Memory" rel="up" accesskey="u">内存</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>