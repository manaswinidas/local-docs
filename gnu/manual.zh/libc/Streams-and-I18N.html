<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Streams和I18N（GNU C库）</title>

<meta name="description" content="Streams and I18N (The GNU C Library)">
<meta name="keywords" content="Streams and I18N (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" title="I/O on Streams">
<link href="Simple-Output.html#Simple-Output" rel="next" title="Simple Output">
<link href="Streams-and-Threads.html#Streams-and-Threads" rel="prev" title="Streams and Threads">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Streams-and-I18N"></span><div class="header">
<p>下一篇： <a href="Simple-Output.html#Simple-Output" rel="next" accesskey="n">简单输出</a> ，上一篇： <a href="Streams-and-Threads.html#Streams-and-Threads" rel="prev" accesskey="p">流和线程</a> ，上一篇： <a href="Streams-and-Threads.html#Streams-and-Threads" rel="prev" accesskey="p">流的</a> <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Streams-in-Internationalized-Applications"></span><h3 class="section">12.6国际化应用中的流</h3>

<p>ISO C90 <!-- /@w -->引入了新类型<code>wchar_t</code>允许处理更大的字符集。缺少的是输出字符串的可能性<code>wchar_t</code>直。一个必须使用将它们转换为多字节字符串<code>mbstowcs</code> （没有<code>mbsrtowcs</code> ），然后使用常规流功能。尽管这是可行的，但这样做非常麻烦，因为执行转换并非易事，并且极大地增加了程序的复杂性和大小。
</p>
<p>早期的Unix标准（我认为在XPG4.2中）为该标准引入了两个附加的格式说明符。 <code>printf</code>和<code>scanf</code>功能族。使用可以打印和读取单个宽字符<code>%C</code>说明符和宽字符串可以用<code>%S</code> 。这些修饰符的行为就像<code>%c</code>和<code>%s</code>只是他们希望相应的参数具有宽字符类型，并且应在使用宽字符和字符串之前将其转换为多字节字符串或从多字节字符串转换为多字节字符串。
</p>
<p>这是一个开始，但还不够好。并非总是希望使用<code>printf</code>和<code>scanf</code> 。其他的较小和较快的函数无法处理宽字符。其次，不可能有一个格式字符串<code>printf</code>和<code>scanf</code>由宽字符组成。结果是，如果格式字符串必须包含非基本字符，则必须生成格式字符串。
</p>
<span id="index-C_002b_002b-streams"></span>
<span id="index-streams_002c-C_002b_002b"></span>
<p>在对ISO C90 <!-- /@w -->的修订1 <!-- /@w --> ，添加了一组新功能来解决该问题。大多数流函数都有对应的函数，它们分别使用宽字符或宽字符串，而不是字符或字符串。新功能在相同的流上运行（例如<code>stdout</code> ）。这与C ++运行时库的模型不同，在C ++运行时库中，使用了分别用于宽和普通I / O的流。
</p>
<span id="index-orientation_002c-stream-1"></span>
<span id="index-stream-orientation-1"></span>
<p>能够将相同的流用于广泛操作和常规操作有一个限制：流可以用于广泛操作或常规操作。一旦决定，就没有回头路了。只能拨打<code>freopen</code>要么<code>freopen64</code>可以重置<em>方向</em> 。方向可以通过三种方式确定：</p>
<ul>
<li>如果使用了任何普通字符功能（包括<code>fread</code>和<code>fwrite</code>函数）流被标记为不面向宽。

</li><li>如果使用任何宽字符功能，则将流标记为面向宽方向。

</li><li>的<code>fwide</code>功能可用于设置任何一种方向。
</li></ul>

<p>重要的是，切勿在流中混合使用宽操作和不宽操作。没有发出诊断信息。应用程序的行为只会很奇怪，否则应用程序将崩溃。的<code>fwide</code>功能可以帮助避免这种情况。
</p>
<dl>
<dt id="index-fwide">函数： <em>int</em> <strong>fwide</strong> <em>（FILE * <var>stream</var> ，int <var>mode</var> ）</em></dt>
<dd>
<p>初步： MT安全|不安全AS损坏| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>fwide</code>函数可用于设置和查询流方向的状态<var>stream</var> 。如果<var>mode</var>参数为正值时，流将定向为宽方向；对于负值，则为窄方向。无法使用覆盖以前的方向<code>fwide</code> 。即，如果流<var>stream</var>在呼叫之前什么也没做好。
</p>
<p>如果<var>mode</var>为零时，查询当前方向状态，并且没有任何更改。
</p>
<p>的<code>fwide</code>如果流分别是窄的，根本没有或宽的，函数将返回负值，零或正值。
</p>
<p>此函数在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>通常，尽可能早地定向流是一个好主意。这可以防止意外，特别是对于标准流<code>stdin</code> ， <code>stdout</code>和<code>stderr</code> 。如果某些库函数在某些情况下使用这些流之一，并且这种使用使流以不同的方式定向，那么应用程序的其余部分希望它可能最终会产生难以再现的错误。请记住，如果流使用不正确，则不会发出任何错误信号。通常，只有在库函数创建可在不同上下文中使用的流时，才需要在创建后使流保持定向。
</p>
<p>在编写使用流并且可以在不同上下文中使用的代码时，重要的是在使用流之前先查询流的方向（除非库接口的规则要求特定的方向）。下面的一些愚蠢的功能说明了这一点。
</p>
<div class="example">
<pre class="example">void
print_f (FILE *fp)
{
  if (fwide (fp, 0) &gt; 0)
    /* <span class="roman">Positive return value means wide orientation.</span>  */
    fputwc (L'f', fp);
  else
    fputc ('f', fp);
}
</pre></div>

<p>请注意，在这种情况下<code>print_f</code>决定流的方向（如果以前未定向）（如果遵循上述建议，则不会发生）。
</p>
<p>用于的编码<code>wchar_t</code>值未指定，用户不得对此做任何假设。对于的I / O <code>wchar_t</code>值，这意味着不可能将这些值直接写入流中。这也不是来自ISO C <!-- /@w -->语言环境模型的结果。相反，发生的是，从底层媒体读取或写入底层媒体的字节首先被转换为实现为<code>wchar_t</code> 。外部编码由<code>LC_CTYPE</code>当前语言环境的类别或“ <samp>ccs</samp> '模式规范的一部分<code>fopen</code> ， <code>fopen64</code> ， <code>freopen</code> ， 要么<code>freopen64</code> 。转换的方式和时间是不确定的，并且对用户而言是不可见的。
</p>
<p>由于流是在未定向状态下创建的，因此在该点上没有与之关联的转换。将使用的转换取决于<code>LC_CTYPE</code>定向流时选择的类别。如果在运行时更改语言环境，则除非引起注意，否则可能会产生令人惊讶的结果。这只是尽快将流定向的另一个好理由，也许是通过调用<code>fwide</code> 。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Simple-Output.html#Simple-Output" rel="next" accesskey="n">简单输出</a> ，上一篇： <a href="Streams-and-Threads.html#Streams-and-Threads" rel="prev" accesskey="p">流和线程</a> ，上一篇： <a href="Streams-and-Threads.html#Streams-and-Threads" rel="prev" accesskey="p">流的</a> <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" rel="up" accesskey="u">I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>