<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>转换字符串（GNU C库）</title>

<meta name="description" content="Converting Strings (The GNU C Library)">
<meta name="keywords" content="Converting Strings (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" title="Restartable multibyte conversion">
<link href="Multibyte-Conversion-Example.html#Multibyte-Conversion-Example" rel="next" title="Multibyte Conversion Example">
<link href="Converting-a-Character.html#Converting-a-Character" rel="prev" title="Converting a Character">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Converting-Strings"></span><div class="header">
<p>下一篇： <a href="Multibyte-Conversion-Example.html#Multibyte-Conversion-Example" rel="next" accesskey="n">多字节转换示例</a> ，上一篇： <a href="Multibyte-Conversion-Example.html#Multibyte-Conversion-Example" rel="next" accesskey="n">转换</a> <a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">字符</a> ，上<a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">一篇</a> ： <a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">可</a> <a href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" accesskey="u">重新启动的多字节转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Converting-Multibyte-and-Wide-Character-Strings"></span><h4 class="subsection">6.3.4转换多字节和宽字符串</h4>

<p>上一节中描述的功能一次只能转换一个字符。在实际程序中要执行的大多数操作都包括字符串，因此ISO C <!-- /@w -->标准还定义了整个字符串的转换。但是，定义的功能集非常有限。因此，GNU C库包含一些可以在某些重要情况下提供帮助的扩展。
</p>
<dl>
<dt id="index-mbsrtowcs">功能： <em>size_t</em> <strong>mbsrtowcs</strong> <em>（wchar_t *限制<var>dst</var> ，const char ** restrict <var>src</var> ，size_t <var>len</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：mbsrtowcs /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>mbsrtowcs</code>函数（“多字节字符串可重新启动为宽字符串”）将以NUL结尾的多字节字符串转换为<code>*<var>src</var></code>转换为等效的宽字符串，包括末尾的NUL宽字符。使用来自指向的对象的状态信息开始转换<var>ps</var>或来自内部对象<code>mbsrtowcs</code>如果<var>ps</var>是一个空指针。返回之前，将状态对象更新为与最后一个转换字符之后的状态匹配。如果到达并转换了终止NUL字节，则该状态为初始状态。
</p>
<p>如果<var>dst</var>不是空指针，结果存储在由指向的数组中<var>dst</var> ;否则，转换结果不可用，因为它存储在内部缓冲区中。
</p>
<p>如果<var>len</var>宽字符存储在数组中<var>dst</var>在到达输入字符串的末尾之前，转换停止，并且<var>len</var>返回。如果<var>dst</var>是一个空指针， <var>len</var>从未检查过。
</p>
<p>函数调用过早返回的另一个原因是，如果输入字符串包含无效的多字节序列。在这种情况下，全局变量<code>errno</code>被设定为<code>EILSEQ</code>然后函数返回<code>(size_t) -1</code> 。
</p>

<p>在所有其他情况下，该函数返回在此调用期间转换的宽字符数。如果<var>dst</var>不为空， <code>mbsrtowcs</code>存储在由指向的指针中<var>src</var>空指针（如果到达输入字符串中的NUL字节）或最后一个转换的多字节字符后的字节地址。
</p>
<span id="index-wchar_002eh-12"></span>
<p><code>mbsrtowcs</code>在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>的定义<code>mbsrtowcs</code>功能有一个重要限制。要求<var>dst</var>如果必须使用文本转换缓冲区，则必须为NUL终止的字符串会带来问题。缓冲区通常不是NUL终止的字符串的集合，而是连续的行集合，由换行符分隔。现在假设需要一个从缓冲区转换一行的函数。由于该行不是NUL终止的，所以源指针不能直接指向未修改的文本缓冲区。这意味着，任何一个NUL字节都会在发生时间的适当位置插入<code>mbsrtowcs</code>函数调用（不适用于只读缓冲区或在多线程应用程序中执行）或将行复制到额外的缓冲区中，该行可以以NUL字节终止。请注意，通常无法通过设置参数来限制要转换的字符数<var>len</var>达到任何特定值。由于不知道每个多字节字符序列的字节数，因此只能猜测。
</p>
<span id="index-stateful-2"></span>
<p>NUL在换行符后立即终止行的方法仍然存在问题，这可能导致非常奇怪的结果。如描述中所述<code>mbsrtowcs</code>如果使用上述函数，则在处理输入字符串末尾的NUL字节后，可以确保转换状态为初始移位状态。但是，这个NUL字节实际上不是文本的一部分（即，原始文本中的换行符之后的转换状态可能与初始移位状态有所不同，因此，使用该状态对下一行的第一个字符进行编码）。但是，用户永远无法访问所讨论的状态，因为转换在NUL字节（复位状态）之后停止了。当今使用的大多数有状态字符集都要求换行符之后的shift状态为初始状态，但这并不是严格的保证。因此，仅NUL终止一段正在运行的文本并不总是适当的解决方案，因此，决不应该在通用代码中使用它。
</p>
<p>通用转换接口（请参见<a href="Generic-Charset-Conversion.html#Generic-Charset-Conversion">Generic Charset Conversion</a> ）没有此限制（它仅适用于缓冲区，而不适用于字符串），并且GNU C库包含一组函数，这些函数采用其他参数来指定从中消耗的最大字节数。输入字符串。这样的问题<code>mbsrtowcs</code>上面的示例可以通过确定行长并将此长度传递给函数来解决。
</p>
<dl>
<dt id="index-wcsrtombs">功能： <em>size_t</em> <strong>wcsrtombs</strong> <em>（字符*限制<var>dst</var> ，const wchar_t **限制<var>src</var> ，size_t <var>len</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：wcsrtombs /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcsrtombs</code>函数（“宽字符串可重新启动为多字节字符串”）将以NUL终止的宽字符串转换为<code>*<var>src</var></code>转换为等效的多字节字符串，并将结果存储在由指向的数组中<var>dst</var> 。NUL宽字符也将转换。转换从由指向的对象中描述的状态开始<var>ps</var>或通过本地的状态对象<code>wcsrtombs</code>如果<var>ps</var>是一个空指针。如果<var>dst</var>如果为空指针，则照常执行转换，但结果不可用。输入字符串的所有字符是否都已成功转换，并且<var>dst</var>不是空指针，由指向的指针<var>src</var>被分配一个空指针。
</p>
<p>如果输入字符串中的宽字符之一没有等效的有效多字节字符，则转换将提前停止，并设置全局变量<code>errno</code>至<code>EILSEQ</code> ，并返回<code>(size_t) -1</code> 。
</p>
<p>提前停止的另一个原因是<var>dst</var>不是空指针，下一个转换的字符将需要<var>len</var>数组的总字节数<var>dst</var> 。在这种情况下（如果<var>dst</var>不是null指针）所指向的指针<var>src</var>在最后一个成功转换后，立即分配一个指向宽字符的值。
</p>
<p>除非出现编码错误，否则的返回值<code>wcsrtombs</code>函数是存储在所有多字节字符序列中的字节数<var>dst</var> 。返回之前，由指向的对象中的状态<var>ps</var> （或内部对象，以防万一<var>ps</var>是一个空指针），以反映上一次转换后的状态。该状态是在转换终止NUL宽字符的情况下的初始移位状态。
</p>
<span id="index-wchar_002eh-13"></span>
<p>的<code>wcsrtombs</code>函数在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>

<p>上面提到的限制<code>mbsrtowcs</code>该功能在这里也适用。无法直接控制输入字符的数量。必须将NUL宽字符放置在正确的位置，或通过可用的输出数组大小间接控制消耗的输入（ <var>len</var>参数）。
</p>
<dl>
<dt id="index-mbsnrtowcs">函数： <em>size_t</em> <strong>mbsnrtowcs</strong> <em>（wchar_t *限制<var>dst</var> ，const char ** restrict <var>src</var> ，size_t <var>nmc</var> ，size_t <var>len</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：mbsnrtowcs /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>mbsnrtowcs</code>功能非常类似于<code>mbsrtowcs</code>功能。除以下参数外，所有参数均相同<var>nmc</var> ，这是新的。返回值与相同<code>mbsrtowcs</code> 。
</p>
<p>此新参数指定多字节字符串最多可以使用多少个字节。换句话说，多字节字符串<code>*<var>src</var></code>无需NUL终止。但是，如果在<var>nmc</var>字符串的第一个字节，转换在那里停止。
</p>
<p>此函数是GNU扩展。它旨在解决上述问题。现在，可以逐段转换具有多字节字符文本的缓冲区，而不必担心插入NUL字节以及NUL字节对转换状态的影响。
</p></dd></dl>

<p>将多字节字符串转换为宽字符串并显示它的函数可以这样编写（这不是一个非常有用的示例）：</p>
<div class="example">
<pre class="example">void
showmbs (const char *src, FILE *fp)
{
  mbstate_t state;
  int cnt = 0;
  memset (&amp;state, '\0', sizeof (state));
  while (1)
    {
      wchar_t linebuf[100];
      const char *endp = strchr (src, '\n');
      size_t n;

      /* <span class="roman">Exit if there is no more line.</span>  */
      if (endp == NULL)
        break;

      n = mbsnrtowcs (linebuf, &amp;src, endp - src, 99, &amp;state);
      linebuf[n] = L'\0';
      fprintf (fp, &quot;line %d: \&quot;%S\&quot;\n&quot;, linebuf);
    }
}
</pre></div>

<p>拨打电话后，状态没有问题<code>mbsnrtowcs</code> 。由于我们从一开始就不在字符串中不插入字符，因此我们使用<var>state</var>仅对于给定缓冲区的转换，更改状态没有问题。
</p>
<dl>
<dt id="index-wcsnrtombs">功能： <em>size_t</em> <strong>wcsnrtombs</strong> <em>（字符*限制<var>dst</var> ，const wchar_t **限制<var>src</var> ，size_t <var>nwc</var> ，size_t <var>len</var> ，mbstate_t *限制<var>ps</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：wcsnrtombs /！ps | AS不安全损坏的堆锁dlopen | AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcsnrtombs</code>函数实现从宽字符串到多字节字符串的转换。它类似于<code>wcsrtombs</code>但是，就像<code>mbsnrtowcs</code> ，它需要一个额外的参数，该参数指定输入字符串的长度。
</p>
<p>不超过<var>nwc</var>输入字符串中的宽字符<code>*<var>src</var></code>被转换。如果输入字符串的第一个字符包含NUL宽字符<var>nwc</var>字符，转换将在此位置停止。
</p>
<p>的<code>wcsnrtombs</code>函数是GNU扩展，就像<code>mbsnrtowcs</code>在没有可用NUL终止的输入字符串的情况下提供帮助。
</p></dd></dl>


<hr>
<div class="header">
<p>下一篇： <a href="Multibyte-Conversion-Example.html#Multibyte-Conversion-Example" rel="next" accesskey="n">多字节转换示例</a> ，上一篇： <a href="Multibyte-Conversion-Example.html#Multibyte-Conversion-Example" rel="next" accesskey="n">转换</a> <a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">字符</a> ，上<a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">一篇</a> ： <a href="Converting-a-Character.html#Converting-a-Character" rel="prev" accesskey="p">可</a> <a href="Restartable-multibyte-conversion.html#Restartable-multibyte-conversion" rel="up" accesskey="u">重新启动的多字节转换</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>