<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>异步读/写（GNU C库）</title>

<meta name="description" content="Asynchronous Reads/Writes (The GNU C Library)">
<meta name="keywords" content="Asynchronous Reads/Writes (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" title="Asynchronous I/O">
<link href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="next" title="Status of AIO Operations">
<link href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="prev" title="Asynchronous I/O">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Asynchronous-Reads_002fWrites"></span><div class="header">
<p>下一篇： <a href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="next" accesskey="n">AIO操作的状态</a> ，上一篇： <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" accesskey="u">异步I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Asynchronous-Read-and-Write-Operations"></span><h4 class="subsection">13.11.1异步读写操作</h4>

<dl>
<dt id="index-aio_005fread">功能： <em>int</em> <strong>aio_read</strong> <em>（struct aiocb * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>



<p>该函数启动异步读取操作。将操作加入队列后或遇到错误时，它将立即返回。
</p>
<p>首先<code>aiocbp->aio_nbytes</code>该文件的字节数<code>aiocbp->aio_fildes</code>是一个描述符，从此处开始将其写入缓冲区<code>aiocbp->aio_buf</code> 。读取从绝对位置开始<code>aiocbp->aio_offset</code>在文件中。
</p>
<p>如果平台支持优先的I / O，则<code>aiocbp->aio_reqprio</code>值用于在请求实际入队之前调整优先级。
</p>
<p>根据该通知，呼叫过程被通知有关读取请求的终止。 <code>aiocbp->aio_sigevent</code>值。
</p>
<p>什么时候<code>aio_read</code>返回值，如果在将进程加入队列之前未发现任何错误，则返回值为零。如果发现这样的早期错误，该函数将返回<em>-1</em>并进行设置<code>errno</code>为以下值之一：</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dd><p>由于（暂时）超出资源限制，请求未入队。
</p></dd>
<dt><code>ENOSYS</code></dt>
<dd><p>的<code>aio_read</code>功能未实现。
</p></dd>
<dt><code>EBADF</code></dt>
<dd><p>的<code>aiocbp->aio_fildes</code>描述符无效。在将请求放入队列之前无需识别此条件，因此也可能异步发出此错误信号。
</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<code>aiocbp->aio_offset</code>要么<code>aiocbp->aio_reqpiro</code>值无效。在将请求放入队列之前无需识别此条件，因此也可能异步发出此错误信号。
</p></dd>
</dl>

<p>如果<code>aio_read</code>返回零，可以使用以下命令查询请求的当前状态<code>aio_error</code>和<code>aio_return</code>功能。只要返回的值<code>aio_error</code>是<code>EINPROGRESS</code>操作尚未完成。如果<code>aio_error</code>返回零，则操作成功终止，否则该值将被解释为错误代码。如果函数终止，则可以使用以下命令获取操作结果： <code>aio_return</code> 。返回的值与对的等效调用相同<code>read</code>会回来的。可能返回的错误代码<code>aio_error</code>是：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p>的<code>aiocbp->aio_fildes</code>描述符无效。
</p></dd>
<dt><code>ECANCELED</code></dt>
<dd><p>操作在操作完成之前被取消（请参阅“ <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations">取消AIO操作”</a> ）</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<code>aiocbp->aio_offset</code>值无效。
</p></dd>
</dl>

<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>这个功能其实<code>aio_read64</code>因为LFS接口透明地替换了常规实现。
</p></dd></dl>

<dl>
<dt id="index-aio_005fread64">函数： <em>int</em> <strong>aio_read64</strong> <em>（struct aiocb64 * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>aio_read</code>功能。唯一的区别是在32位<!-- /@w -->机器上，文件描述符应以大文件模式打开。在内部， <code>aio_read64</code>使用等同于<code>lseek64</code> （请参阅<a href="File-Position-Primitive.html#File-Position-Primitive">File Position Primitive</a> ）以正确定位文件描述符以进行读取，而不是<code>lseek</code>用于的功能<code>aio_read</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code> ，此功能在名称下可用<code>aio_read</code>因此透明地替换了32位计算机上小文件的接口。
</p></dd></dl>

<p>为了将数据异步写入文件，存在一对具有非常相似接口的等效函数。
</p>
<dl>
<dt id="index-aio_005fwrite">功能： <em>int</em> <strong>aio_write</strong> <em>（struct aiocb * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该函数启动异步写操作。将操作加入队列后或在遇到错误之前，函数调用将立即返回。
</p>
<p>首先<code>aiocbp->aio_nbytes</code>从缓冲区开始的字节<code>aiocbp->aio_buf</code>被写入文件<code>aiocbp->aio_fildes</code>是一个描述符，从绝对位置开始<code>aiocbp->aio_offset</code>在文件中。
</p>
<p>如果平台支持优先的I / O，则<code>aiocbp->aio_reqprio</code>值用于在请求实际入队之前调整优先级。
</p>
<p>根据该通知，呼叫过程被通知有关读取请求的终止。 <code>aiocbp->aio_sigevent</code>值。
</p>
<p>什么时候<code>aio_write</code>返回值，如果在将进程加入队列之前未发现任何错误，则返回值为零。如果发现这样的早期错误，该函数将返回<em>-1</em>并进行设置<code>errno</code>为以下值之一。
</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dd><p>由于（暂时）超出资源限制，请求未入队。
</p></dd>
<dt><code>ENOSYS</code></dt>
<dd><p>的<code>aio_write</code>功能未实现。
</p></dd>
<dt><code>EBADF</code></dt>
<dd><p>的<code>aiocbp->aio_fildes</code>描述符无效。在将请求加入队列之前，可能无法识别此条件，因此也可能会异步发出此错误信号。
</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<code>aiocbp->aio_offset</code>要么<code>aiocbp->aio_reqprio</code>值无效。在将请求加入队列之前，可能无法识别此条件，因此也可能会异步发出此错误信号。
</p></dd>
</dl>

<p>在这种情况下<code>aio_write</code>返回零，则可以使用来查询请求的当前状态<code>aio_error</code>和<code>aio_return</code>功能。只要返回的值<code>aio_error</code>是<code>EINPROGRESS</code>操作尚未完成。如果<code>aio_error</code>返回零，则操作成功终止，否则该值将被解释为错误代码。如果函数终止，则可以使用以下命令获取操作结果： <code>aio_return</code> 。返回的值与对的等效调用相同<code>read</code>会回来的。可能返回的错误代码<code>aio_error</code>是：</p>
<dl compact>
<dt><code>EBADF</code></dt>
<dd><p>的<code>aiocbp->aio_fildes</code>描述符无效。
</p></dd>
<dt><code>ECANCELED</code></dt>
<dd><p>在操作完成之前，操作被取消。（请参阅<a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations">取消AIO操作</a> ）</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<code>aiocbp->aio_offset</code>值无效。
</p></dd>
</dl>

<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code> ，实际上这个功能<code>aio_write64</code>因为LFS接口透明地替换了常规实现。
</p></dd></dl>

<dl>
<dt id="index-aio_005fwrite64">函数： <em>int</em> <strong>aio_write64</strong> <em>（struct aiocb64 * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>aio_write</code>功能。唯一的区别是在32位<!-- /@w -->机器上，文件描述符应以大文件模式打开。内部地<code>aio_write64</code>使用等同于<code>lseek64</code> （请参见<a href="File-Position-Primitive.html#File-Position-Primitive">File Position Primitive</a> ）以正确定位文件描述符以进行写入，而不是<code>lseek</code>用于的功能<code>aio_write</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code> ，此功能在名称下可用<code>aio_write</code>因此透明地替换了32位计算机上小文件的接口。
</p></dd></dl>

<p>除了具有或多或少传统界面的这些功能外，POSIX.1b还定义了一种功能，该功能可以一次启动多个操作，并且可以处理自由混合的读写操作。因此，它类似于以下各项的组合<code>readv</code>和<code>writev</code> 。
</p>
<dl>
<dt id="index-lio_005flistio">函数： <em>int</em> <strong>lio_listio</strong> <em>（int <var>mode</var> ，struct aiocb * const <var>list</var> []，int <var>nent</var> ，struct sigevent * <var>sig</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>lio_listio</code>函数可用于一次排队任意数量的读取和写入请求。这些请求可以全部针对同一个文件，全部针对不同的文件或两者之间的每个解决方案。
</p>
<p><code>lio_listio</code>得到<var>nent</var>来自数组所指向的请求<var>list</var> 。要执行的操作由<code>aio_lio_opcode</code>每个元素的成员<var>list</var> 。如果该字段是<code>LIO_READ</code>读取操作入队，类似于的调用<code>aio_read</code>对于数组的这个元素（除了终止信号的发送方式不同，我们将在下面看到）。如果<code>aio_lio_opcode</code>成员是<code>LIO_WRITE</code>写操作入队。否则<code>aio_lio_opcode</code>一定是<code>LIO_NOP</code>在这种情况下， <var>list</var>只是被忽略了。这种“操作”在以下情况下非常有用： <code>struct aiocb</code>一次只需要处理几个元素的元素。另一种情况是<code>lio_listio</code>在处理所有请求之前，呼叫已被取消（请参阅“ <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations">取消AIO操作”</a> ），并且必须重新发出其余请求。
</p>
<p>数组所指向的每个元素的其他成员<code>list</code>必须具有适用于文档中所述操作的值<code>aio_read</code>和<code>aio_write</code>以上。
</p>
<p>的<var>mode</var>参数决定了<code>lio_listio</code>排队所有请求后的行为。如果<var>mode</var>是<code>LIO_WAIT</code>等待所有请求终止。除此以外<var>mode</var>一定是<code>LIO_NOWAIT</code>并且在这种情况下，函数将所有请求放入队列后立即返回。在这种情况下，呼叫者会根据通知获得所有请求终止的通知。 <var>sig</var>参数。如果<var>sig</var>是<code>NULL</code>没有发送通知。否则，将发送信号或启动线程，如关于<code>aio_read</code>要么<code>aio_write</code> 。
</p>
<p>如果<var>mode</var>是<code>LIO_WAIT</code>的返回值<code>lio_listio</code>当所有请求成功完成时为<em>0</em> 。否则，函数返回<em>-1，</em>然后<code>errno</code>被相应地设置。要找出哪个或哪些请求失败，必须使用<code>aio_error</code>对数组的所有元素起作用<var>list</var> 。
</p>
<p>如果<var>mode</var>是<code>LIO_NOWAIT</code> ，如果所有请求均已正确排队，该函数将返回<em>0</em> 。可以使用以下命令找到请求的当前状态<code>aio_error</code>和<code>aio_return</code>如上所述。如果<code>lio_listio</code>在此模式下返回<em>-1</em> ，全局变量<code>errno</code>被相应地设置。如果请求尚未终止，请致电<code>aio_error</code>退货<code>EINPROGRESS</code> 。如果值不同，则请求完成，并返回错误值（或<em>0</em> ），并且可以使用检索操作结果<code>aio_return</code> 。
</p>
<p>的可能值<code>errno</code>是：</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dd><p>目前，将所有请求排队所需的资源不可用。每个元素的错误状态<var>list</var>必须检查以确定哪个请求失败。
</p>
<p>另一个原因可能是超出了AIO请求的系统范围限制。在GNU系统上实现的情况并非如此，因为不存在任意限制。
</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>的<var>mode</var>参数无效或<var>nent</var>大于<code>AIO_LISTIO_MAX</code> 。
</p></dd>
<dt><code>EIO</code></dt>
<dd><p>请求的一个或多个I / O操作失败。应该检查每个请求的错误状态，以确定哪个请求失败。
</p></dd>
<dt><code>ENOSYS</code></dt>
<dd><p>的<code>lio_listio</code>不支持该功能。
</p></dd>
</dl>

<p>如果<var>mode</var>参数是<code>LIO_NOWAIT</code>并且调用者取消了一个请求，该请求的错误状态由返回<code>aio_error</code>是<code>ECANCELED</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code> ，实际上这个功能<code>lio_listio64</code>因为LFS接口透明地替换了常规实现。
</p></dd></dl>

<dl>
<dt id="index-lio_005flistio64">函数： <em>int</em> <strong>lio_listio64</strong> <em>（int <var>mode</var> ，struct aiocb64 * const <var>list</var> []，int <var>nent</var> ，struct sigevent * <var>sig</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此功能类似于<code>lio_listio</code>功能。唯一的区别是在32位<!-- /@w -->机器上，文件描述符应以大文件模式打开。在内部， <code>lio_listio64</code>使用等同于<code>lseek64</code> （请参阅<a href="File-Position-Primitive.html#File-Position-Primitive">File Position Primitive</a> ）以正确定位文件描述符以进行读取或写入，而不是<code>lseek</code>用于的功能<code>lio_listio</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code> ，此功能在名称下可用<code>lio_listio</code>因此透明地替换了32位计算机上小文件的接口。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="next" accesskey="n">AIO操作的状态</a> ，上一篇： <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" accesskey="u">异步I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>