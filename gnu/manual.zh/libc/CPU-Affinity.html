<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>CPU亲和力（GNU C库）</title>

<meta name="description" content="CPU Affinity (The GNU C Library)">
<meta name="keywords" content="CPU Affinity (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Priority.html#Priority" rel="up" title="Priority">
<link href="Memory-Resources.html#Memory-Resources" rel="next" title="Memory Resources">
<link href="Traditional-Scheduling-Functions.html#Traditional-Scheduling-Functions" rel="prev" title="Traditional Scheduling Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="CPU-Affinity"></span><div class="header">
<p>上一篇： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="prev" accesskey="p">传统计划</a> ，上一篇： <a href="Priority.html#Priority" rel="up" accesskey="u">优先</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Limiting-execution-to-certain-CPUs"></span><h4 class="subsection">22.3.5将执行限制为某些CPU</h4>

<p>在多处理器系统上，操作系统通常以使系统最有效地工作的方式分配可在所有可用CPU上运行的不同进程。可以在最后几节中描述的调度功能在某种程度上控制运行哪些进程和线程。但是没有涵盖哪个CPU最终执行哪个进程或线程。
</p>
<p>程序可能也要控制系统的这一方面的原因有很多：</p>
<ul>
<li>一个线程或进程负责绝对关键的工作，在任何情况下都不得因使用CPU资源的其他进程或线程而中断或阻碍其进展。在这种情况下，特殊进程将被限制在不允许其他进程或线程使用的CPU中。

</li><li>对不同资源（RAM，I / O端口）的访问成本来自不同的CPU。在NUMA（非统一内存体系结构）计算机中就是这种情况。最好应在本地访问内存，但此要求通常对调度程序是不可见的。因此，将进程或线程强制给可以本地访问最常用内存的CPU有助于显着提高性能。

</li><li>在受控的运行时中，资源分配和簿记工作（例如垃圾收集）是处理器本地的性能。如果不必保护资源免受来自不同处理器的并发访问，这可以帮助减少锁定成本。
</li></ul>

<p>到目前为止的POSIX标准对于解决此问题没有太大帮助。Linux内核提供了一组接口，以允许指定进程的<em>相似性集</em> 。调度程序将在亲和力掩码指定的CPU上调度线程或进程。GNU C库定义的接口在某种程度上遵循Linux内核接口。
</p>
<dl>
<dt id="index-cpu_005fset_005ft">资料类型： <strong>cpu_set_t</strong></dt>
<dd>
<p>该数据集是一个位集，其中每个位代表一个CPU。系统的CPU如何映射到位集中的位取决于系统。数据类型具有固定大小；在不太可能的情况下，位数不足以描述系统的CPU，因此必须使用其他接口。
</p>
<p>此类型是GNU扩展，在<samp>sched.h</samp> 。
</p></dd></dl>

<p>为了操作位集，设置和重置位，定义了许多宏。一些宏将CPU编号作为参数。在此重要的是，切勿超过位集的大小。以下宏指定了<code>cpu_set_t</code>位。
</p>
<dl>
<dt id="index-CPU_005fSETSIZE">巨集： <em>int</em> <strong>CPU_SETSIZE</strong></dt>
<dd>
<p>该宏的值是可以通过以下方式处理的最大CPU数： <code>cpu_set_t</code>宾语。
</p></dd></dl>

<p>类型<code>cpu_set_t</code>应该被认为是不透明的；所有操作都应通过接下来的四个宏进行。
</p>
<dl>
<dt id="index-CPU_005fZERO">巨集： <em>无效的</em> <strong>CPU_ZERO</strong> <em>（cpu_set_t * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此宏初始化CPU集<var>set</var>成为空集。
</p>
<p>此宏是GNU扩展，并在<samp>sched.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-CPU_005fSET">巨集： <em>void</em> <strong>CPU_SET</strong> <em>（int <var>cpu</var> ，cpu_set_t * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该宏添加<var>cpu</var>到CPU组<var>set</var> 。
</p>
<p>的<var>cpu</var>参数不能有副作用，因为它被评估了多次。
</p>
<p>此宏是GNU扩展，并在<samp>sched.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-CPU_005fCLR">巨集： <em>void</em> <strong>CPU_CLR</strong> <em>（int <var>cpu</var> ，cpu_set_t * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该宏删除<var>cpu</var>从CPU组<var>set</var> 。
</p>
<p>的<var>cpu</var>参数不能有副作用，因为它被评估了多次。
</p>
<p>此宏是GNU扩展，并在<samp>sched.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-CPU_005fISSET">宏： <em>int</em> <strong>CPU_ISSET</strong> <em>（int <var>cpu</var> ，const cpu_set_t * <var>set</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>如果此宏返回一个非零值（true） <var>cpu</var>是CPU集的成员<var>set</var> ，否则为零（假）。
</p>
<p>的<var>cpu</var>参数不能有副作用，因为它被评估了多次。
</p>
<p>此宏是GNU扩展，并在<samp>sched.h</samp> 。
</p></dd></dl>


<p>可以从头开始构建CPU位集，或者可以从系统中检索当前安装的亲和力掩码。
</p>
<dl>
<dt id="index-sched_005fgetaffinity">函数： <em>int</em> <strong>sched_getaffinity</strong> <em>（pid_t <var>pid</var> ，size_t <var>cpusetsize</var> ，cpu_set_t * <var>cpuset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此函数使用ID存储进程或线程的CPU亲和力掩码<var>pid</var>在里面<var>cpusetsize</var>指向的字节长位图<var>cpuset</var> 。如果成功，该函数将始终初始化<code>cpu_set_t</code>对象并返回零。
</p>
<p>如果<var>pid</var>不对应于系统上的进程或线程，或者函数由于其他原因而失败，则返回<code>-1</code>和<code>errno</code>设置为代表错误情况。
</p>
<dl compact>
<dt><code>ESRCH</code></dt>
<dd><p>找不到具有给定ID的进程或线程。
</p>
</dd>
<dt><code>EFAULT</code></dt>
<dd><p>指针<var>cpuset</var>没有指向有效的对象。
</p></dd>
</dl>

<p>此函数是GNU扩展，在中声明<samp>sched.h</samp> 。
</p></dd></dl>

<p>请注意，使用此信息来检索不同POSIX线程的信息是不可能的。为此必须提供一个单独的接口。
</p>
<dl>
<dt id="index-sched_005fsetaffinity">函数： <em>int</em> <strong>sched_setaffinity</strong> <em>（pid_t <var>pid</var> ，size_t <var>cpusetsize</var> ，const cpu_set_t * <var>cpuset</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>此功能将安装<var>cpusetsize</var>指向的字节长亲和力掩码<var>cpuset</var>具有ID的进程或线程<var>pid</var> 。如果成功，函数将返回零，并且调度程序将来会考虑关联性信息。
</p>
<p>如果函数失败，它将返回<code>-1</code>和<code>errno</code>设置为错误代码：</p>
<dl compact>
<dt><code>ESRCH</code></dt>
<dd><p>找不到具有给定ID的进程或线程。
</p>
</dd>
<dt><code>EFAULT</code></dt>
<dd><p>指针<var>cpuset</var>没有指向有效的对象。
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>该位无效。这可能意味着相似性集可能不会使处理器留给进程或线程运行。
</p></dd>
</dl>

<p>此函数是GNU扩展，在中声明<samp>sched.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-getcpu">函数： <em>int</em> <strong>getcpu</strong> <em>（unsigned int * cpu，unsigned int * node）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>getcpu</code>函数标识当前正在运行调用线程或进程的处理器和节点，并将它们写入由指针指向的整数。 <var>cpu</var>和<var>node</var>论点。处理器是标识CPU的唯一非负整数。该节点是标识NUMA节点的唯一非负整数。什么时候<var>cpu</var>要么<var>node</var>是<code>NULL</code> ，则不会将任何内容写入相应的指针。
</p>
<p>返回值为<code>0</code>成功与<code>-1</code>失败。下列<code>errno</code>为此功能定义了错误条件：</p>
<dl compact>
<dt><code>ENOSYS</code></dt>
<dd><p>操作系统不支持此功能。
</p></dd>
</dl>

<p>此函数特定于Linux，并在中声明<samp>sched.h</samp> 。
</p></dd></dl>

<hr>
<div class="header">
<p>上一篇： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="prev" accesskey="p">传统计划</a> ，上一篇： <a href="Priority.html#Priority" rel="up" accesskey="u">优先</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>