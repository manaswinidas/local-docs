<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>连接字符串（GNU C库）</title>

<meta name="description" content="Concatenating Strings (The GNU C Library)">
<meta name="keywords" content="Concatenating Strings (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Truncating-Strings.html#Truncating-Strings" rel="next" title="Truncating Strings">
<link href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays" rel="prev" title="Copying Strings and Arrays">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Concatenating-Strings"></span><div class="header">
<p>下一篇： <a href="Truncating-Strings.html#Truncating-Strings" rel="next" accesskey="n">截断字符串</a> ，上一篇： <a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays" rel="prev" accesskey="p">复制字符串和数组</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用工具</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Concatenating-Strings-1"></span><h3 class="section">5.5连接字符串</h3>
<span id="index-string_002eh-2"></span>
<span id="index-wchar_002eh-1"></span>
<span id="index-concatenating-strings-1"></span>
<span id="index-string-concatenation-functions-1"></span>

<p>本节中描述的功能将一个字符串或宽字符串的内容连接到另一个。它们遵循其约定中的字符串复制功能。请参见<a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays">复制字符串和数组</a> 。' <samp>strcat</samp> '在头文件中声明<samp>string.h</samp>而<samp>wcscat</samp> '在<samp>wchar.h</samp> 。
</p>
<dl>
<dt id="index-strcat">功能： <em>char *</em> <strong>strcat</strong> <em>（char * restrict <var>to</var> ，const char *限制<var>from</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strcat</code>功能类似于<code>strcpy</code> ，但来自的字节<var>from</var>串联或附加到末尾<var>to</var> ，而不是覆盖它。也就是说，来自的第一个字节<var>from</var>覆盖标记字节结尾的空字节<var>to</var> 。
</p>
<p>的等效定义<code>strcat</code>将会：</p>
<div class="example">
<pre class="example">char *
strcat (char *restrict to, const char *restrict from)
{
  strcpy (to + strlen (to), from);
  return to;
}
</pre></div>

<p>如果字符串重叠，则此函数的结果不确定。
</p>
<p>如下所述，此功能存在重大的性能问题。
</p></dd></dl>

<dl>
<dt id="index-wcscat">函数： <em>wchar_t *</em> <strong>wcscat</strong> <em>（wchar_t * restrict <var>wto</var> ，const wchar_t *限制<var>wfrom</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcscat</code>功能类似于<code>wcscpy</code> ，除了<var>wfrom</var>串联或附加到末尾<var>wto</var> ，而不是覆盖它。也就是说，从<var>wfrom</var>覆盖标有NULL的空宽字符<var>wto</var> 。
</p>
<p>的等效定义<code>wcscat</code>将会：</p>
<div class="example">
<pre class="example">wchar_t *
wcscat (wchar_t *wto, const wchar_t *wfrom)
{
  wcscpy (wto + wcslen (wto), wfrom);
  return wto;
}
</pre></div>

<p>如果字符串重叠，则此函数的结果不确定。
</p>
<p>如下所述，此功能存在重大的性能问题。
</p></dd></dl>

<p>程序员使用<code>strcat</code>要么<code>wcscat</code>功能（或<code>strncat</code>要么<code>wcsncat</code>就此而言，在随后的部分中定义的函数）很容易被认为是懒惰和鲁ck的。在几乎所有情况下，参与字符串的长度都是已知的（最好是这样，因为这样才能确保分配的缓冲区大小足够？）或者至少，如果有人跟踪各种函数调用的结果，他们可能会知道。但是使用起来效率很低<code>strcat</code> / <code>wcscat</code> 。查找目标字符串的末尾浪费了大量时间，因此可以开始实际的复制。这是一个常见的示例：</p>
<span id="index-va_005fcopy"></span>
<div class="example">
<pre class="example">/* <span class="roman">This function concatenates arbitrarily many strings.  The last</span>
   <span class="roman">parameter must be <code>NULL</code>.</span>  */
char *
concat (const char *str, &hellip;)
{
  va_list ap, ap2;
  size_t total = 1;
  const char *s;
  char *result;

  va_start (ap, str);
  va_copy (ap2, ap);

  /* <span class="roman">Determine how much space we need.</span>  */
  for (s = str; s != NULL; s = va_arg (ap, const char *))
    total += strlen (s);

  va_end (ap);

  result = (char *) malloc (total);
  if (result != NULL)
    {
      result[0] = '\0';

      /* <span class="roman">Copy the strings.</span>  */
      for (s = str; s != NULL; s = va_arg (ap2, const char *))
        strcat (result, s);
    }

  va_end (ap2);

  return result;
}
</pre></div>

<p>这看起来非常简单，尤其是第二个实际复制字符串的循环。但是，这些天真无邪的行径掩盖了主要的性能损失。试想一下，必须串联10个100字节的字符串。对于第二个字符串，我们在已存储的100个字节中搜索该字符串的末尾，以便我们可以追加下一个字符串。对于所有字符串，查找中间结果结尾所需的比较总计为5500！如果我们将复制与分配搜索结合起来，我们可以更有效地编写此函数：</p>
<div class="example">
<pre class="example">char *
concat (const char *str, &hellip;)
{
  va_list ap;
  size_t allocated = 100;
  char *result = (char *) malloc (allocated);

  if (result != NULL)
    {
      char *newp;
      char *wp;
      const char *s;

      va_start (ap, str);

      wp = result;
      for (s = str; s != NULL; s = va_arg (ap, const char *))
        {
          size_t len = strlen (s);

          /* <span class="roman">Resize the allocated memory if necessary.</span>  */
          if (wp + len + 1 &gt; result + allocated)
            {
              allocated = (allocated + len) * 2;
              newp = (char *) realloc (result, allocated);
              if (newp == NULL)
                {
                  free (result);
                  return NULL;
                }
              wp = newp + (wp - result);
              result = newp;
            }

          wp = mempcpy (wp, s, len);
        }

      /* <span class="roman">Terminate the result string.</span>  */
      *wp++ = '\0';

      /* <span class="roman">Resize memory to the optimal size.</span>  */
      newp = realloc (result, wp - result);
      if (newp != NULL)
        result = newp;

      va_end (ap);
    }

  return result;
}
</pre></div>

<p>有了更多有关输入字符串的知识，就可以微调内存分配。我们在这里指向的区别是我们不使用<code>strcat</code>不再。我们总是跟踪当前中间结果的长度，因此我们可以节省对字符串结尾的搜索并使用<code>mempcpy</code> 。请注意，我们也不要使用<code>stpcpy</code>由于我们正在处理字符串，因此这似乎更自然。但这不是必需的，因为我们已经知道字符串的长度，因此可以使用更快的内存复制功能。该示例将以相同方式适用于宽字符。
</p>
<p>每当程序员感到需要使用时<code>strcat</code>她或他应该三思而后行，并仔细检查程序，以查看是否无法利用已计算的结果来重写代码。再次：几乎总是不需要使用<code>strcat</code> 。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Truncating-Strings.html#Truncating-Strings" rel="next" accesskey="n">截断字符串</a> ，上一篇： <a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays" rel="prev" accesskey="p">复制字符串和数组</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用工具</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>