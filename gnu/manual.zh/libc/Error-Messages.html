<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>错误消息（GNU C库）</title>

<meta name="description" content="Error Messages (The GNU C Library)">
<meta name="keywords" content="Error Messages (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Error-Reporting.html#Error-Reporting" rel="up" title="Error Reporting">
<link href="Memory.html#Memory" rel="next" title="Memory">
<link href="Error-Codes.html#Error-Codes" rel="prev" title="Error Codes">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Error-Messages"></span><div class="header">
<p>上一页： <a href="Error-Codes.html#Error-Codes" rel="prev" accesskey="p">错误代码</a> ，向上： <a href="Error-Reporting.html#Error-Reporting" rel="up" accesskey="u">错误报告</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Error-Messages-1"></span><h3 class="section">2.3错误信息</h3>

<p>该库具有旨在方便您的程序以常规格式报告有关库调用失败的信息性错误消息的函数和变量。功能<code>strerror</code>和<code>perror</code>为您提供给定错误代码的标准错误消息；变量<code><span class="nolinebreak">program_invocation_short_name</span></code> <!-- /@w -->使您可以方便地访问遇到错误的程序的名称。
</p>
<dl>
<dt id="index-strerror">函数： <em>char *</em> <strong>strerror</strong> <em>（int <var>errnum</var> ）</em></dt>
<dd>
<p>初步： MT-不安全种族：错误| AS不安全堆i18n | AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strerror</code>函数将映射由指定的错误代码（请参阅<a href="Checking-for-Errors.html#Checking-for-Errors">检查错误</a> ）。 <var>errnum</var>描述性错误消息字符串的参数。返回值是指向该字符串的指针。
</p>
<p>价值<var>errnum</var>通常来自变量<code>errno</code> 。
</p>
<p>您不应该修改返回的字符串<code>strerror</code> 。另外，如果您随后拨打了<code>strerror</code> ，字符串可能会被覆盖。（但可以保证不会调用任何库函数<code>strerror</code>在你的背后。）
</p>
<p>功能<code>strerror</code>在中声明<samp>string.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-strerror_005fr">函数： <em>char *</em> <strong>strerror_r</strong> <em>（int <var>errnum</var> ，字符* <var>buf</var> ，size_t <var>n</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS-Unsafe i18n | AC不安全|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strerror_r</code>功能像<code>strerror</code>但是，它不是在进程中所有线程共享的静态分配的缓冲区中返回错误消息，而是返回该线程的私有副本。这可能是一些永久性全局数据，也可能是用户提供的缓冲区中的消息字符串，开始于<var>buf</var>长度为<var>n</var>个字节。
</p>
<p>最多<var>n</var>字符（包括NUL字节）被写入，因此用户可以选择足够大的缓冲区。
</p>
<p>此函数应始终在多线程程序中使用，因为无法保证由<code>strerror</code>确实属于当前线程的最后一次调用。
</p>
<p>功能<code>strerror_r</code>是GNU扩展，它在<samp>string.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-perror">功能： <em>void</em> <strong>perror</strong> <em>（const char * <var>message</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：stderr | AS-Unsafe损坏了i18n堆锁| AC不安全损坏的锁内存fd |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数将错误消息打印到流<code>stderr</code> ;请参阅<a href="Standard-Streams.html#Standard-Streams">标准流</a> 。的方向<code>stderr</code>不变。
</p>
<p>如果你打电话<code>perror</code>与一个<var>message</var>它是一个空指针或一个空字符串， <code>perror</code>只是打印对应的错误消息<code>errno</code> ，添加尾随换行符。
</p>
<p>如果您提供非null <var>message</var>论据<code>perror</code>使用此字符串在其输出之前添加前缀。它添加了一个冒号和一个空格字符来分隔<var>message</var>从错误字符串对应<code>errno</code> 。
</p>
<p>功能<code>perror</code>在中声明<samp>stdio.h</samp> 。
</p></dd></dl>

<p><code>strerror</code>和<code>perror</code>对于任何给定的错误代码产生完全相同的消息；精确的文本因系统而异。使用GNU C库，消息相当短。没有多行消息或嵌入的换行符。每个错误消息均以大写字母开头，并且不包含任何终止标点符号。
</p>
<span id="index-program-name"></span>
<span id="index-name-of-running-program"></span>
<p>如果任何系统调用失败，许多不读取终端输入的程序都将退出。按照惯例，来自此类程序的错误消息应以该程序的名称（无目录）开头。您可以在变量中找到该名称<code>program_invocation_short_name</code> ;完整的文件名存储在变量中<code>program_invocation_name</code> 。
</p>
<dl>
<dt id="index-program_005finvocation_005fname">变量： <em>char *</em> <strong>program_invocation_name</strong></dt>
<dd>
<p>该变量的值是用于调用当前进程中运行的程序的名称。与...相同<code>argv[0]</code> 。注意，这不一定是有用的文件名。通常它不包含目录名称。请参阅<a href="Program-Arguments.html#Program-Arguments">程序参数</a> 。
</p>
<p>此变量是GNU扩展，在中声明<samp>errno.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-program_005finvocation_005fshort_005fname">变量： <em>char *</em> <strong>program_invocation_short_name</strong></dt>
<dd>
<p>该变量的值是用于调用当前进程中正在运行的程序的名称，其中删除了目录名称。（也就是说，它与<code>program_invocation_name</code>减去所有内容，直到最后一个斜线为止。）
</p>
<p>此变量是GNU扩展，在中声明<samp>errno.h</samp> 。
</p></dd></dl>

<p>库初始化代码在调用之前设置了这两个变量<code>main</code> 。
</p>
<p><strong>可移植性注意：</strong>如果要让程序与非GNU库一起使用，则必须保存的值。 <code>argv[0]</code>在<code>main</code> ，然后自己删除目录名称。我们添加了这些扩展，以使得可以编写独立的错误报告子例程，而无需<code>main</code> 。
</p>
<p>这是显示如何处理无法正确打开文件的失败的示例。功能<code>open_sesame</code>尝试打开命名文件进行读取，如果成功，则返回流。的<code>fopen</code>如果由于某种原因而无法打开文件，则库函数将返回空指针。在那种情况下<code>open_sesame</code>使用以下命令构造适当的错误消息<code>strerror</code>功能，并终止程序。如果我们要在传递错误代码之前进行其他一些库调用<code>strerror</code> ，我们必须将其保存在本地变量中，因为其他库函数可能会覆盖<code>errno</code>同时。
</p>
<div class="example">
<pre class="example">#define _GNU_SOURCE

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *
open_sesame (char *name)
{
  FILE *stream;

  errno = 0;
  stream = fopen (name, &quot;r&quot;);
  if (stream == NULL)
    {
      fprintf (stderr, &quot;%s: Couldn't open file %s; %s\n&quot;,
               program_invocation_short_name, name, strerror (errno));
      exit (EXIT_FAILURE);
    }
  else
    return stream;
}
</pre></div>

<p>使用<code>perror</code>优点是该功能是可移植的，并且可在实现ISO C <!-- /@w -->所有系统上使用。但通常是文字<code>perror</code>生成的不是所需的内容，无法扩展或更改<code>perror</code>做。例如，GNU编码标准要求在错误消息之前加上程序名称，并且读取某些输入文件的程序应提供有关输入文件名和行号的信息，以防在读取文件时遇到错误。在这些情况下，有两个可用的功能在整个GNU项目中被广泛使用。这些函数在中声明<samp>error.h</samp> 。
</p>
<dl>
<dt id="index-error">函数： <em>无效</em> <strong>错误</strong> <em>（int <var>status</var> ，int <var>errnum</var> ，const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT安全区域| AS-Unsafe损坏的堆i18n |交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>error</code>函数可用于报告程序执行期间的一般问题。的<var>format</var>参数是格式字符串，就像给定的<code>printf</code>功能家族。格式所需的参数可以遵循<var>format</var>参数。就像<code>perror</code> ， <code>error</code>也可以以文本形式报告错误代码。但是不像<code>perror</code>错误值将显式传递给函数<var>errnum</var>参数。这样消除了上面提到的问题，即错误报告函数必须在导致错误的函数之后立即调用，因为否则<code>errno</code>可能会有不同的值。
</p>
<p><code>error</code>首先打印程序名称。如果应用程序定义了全局变量<code>error_print_progname</code>并将其指向一个函数，该函数将被调用以打印程序名称。否则来自全局变量的字符串<code>program_name</code>用来。程序名称后跟一个冒号和一个空格，其后依次是格式字符串产生的输出。如果<var>errnum</var>参数为非零格式字符串输出，后跟冒号和空格，后跟错误代码的错误消息<var>errnum</var> 。在任何情况下，输出都以换行符终止。
</p>
<p>输出定向到<code>stderr</code>流。如果<code>stderr</code>通话之前没有定向，之后将定向为窄定向。
</p>
<p>该函数将返回，除非<var>status</var>参数具有非零值。在这种情况下，该函数将调用<code>exit</code>与<var>status</var>其参数的值，因此永不返回。如果<code>error</code>返回，全局变量<code>error_message_count</code>递增一以跟踪报告的错误数。
</p></dd></dl>

<dl>
<dt id="index-error_005fat_005fline">函数： <em>void</em> <strong>error_at_line</strong> <em>（int <var>status</var> ，int <var>errnum</var> ，const char * <var>fname</var> ，unsigned int <var>lineno</var> ，const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT不安全种族：error_at_line / error_one_per_line语言环境| AS-Unsafe损坏的堆i18n |不安全AC损坏/ error_one_per_line |请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>error_at_line</code>功能非常类似于<code>error</code>功能。唯一的区别是其他参数<var>fname</var>和<var>lineno</var> 。其他参数的处理与<code>error</code>除了在程序名称和由格式字符串生成的字符串之间插入其他文本外。
</p>
<p>直接在程序名称后加冒号，后跟由指向的文件名<var>fname</var> ，另一个冒号，以及<var>lineno</var>打印。
</p>
<p>当然，此附加输出将用于在输入文件（如编程语言源代码文件等）中定位错误。
</p>
<p>如果全局变量<code>error_one_per_line</code>设置为非零值<code>error_at_line</code>将避免打印相同文件和行的连续消息。不直接跟随的重复不会被捕获。
</p>
<p>就像<code>error</code>该函数仅在以下情况下返回<var>status</var>是零。除此以外<code>exit</code>用非零值调用。如果<code>error</code>返回，全局变量<code>error_message_count</code>递增一以跟踪报告的错误数。
</p></dd></dl>

<p>如上所述， <code>error</code>和<code>error_at_line</code>可以通过定义名为的变量来自定义功能<code>error_print_progname</code> 。
</p>
<dl>
<dt id="index-_0028void_0029">变量： <em>void（* error_print_progname）</em> <strong>（void）</strong></dt>
<dd>
<p>如果<code>error_print_progname</code>变量定义为非零值，指向的函数由调用<code>error</code>要么<code>error_at_line</code> 。可以打印程序名称或执行类似的操作。
</p>
<p>该功能预计将打印到<code>stderr</code>流，并且必须能够处理流的方向。
</p>
<p>该变量是全局变量，并由所有线程共享。
</p></dd></dl>

<dl>
<dt id="index-error_005fmessage_005fcount">变量： <em>unsigned int</em> <strong>error_message_count</strong></dt>
<dd>
<p>的<code>error_message_count</code>只要其中一项功能，变量就会增加<code>error</code>要么<code>error_at_line</code>返回。该变量是全局变量，并由所有线程共享。
</p></dd></dl>

<dl>
<dt id="index-error_005fone_005fper_005fline">变量： <em>int</em> <strong>error_one_per_line</strong></dt>
<dd>
<p>的<code>error_one_per_line</code>仅可变影响<code>error_at_line</code> 。通常情况下<code>error_at_line</code>函数为每个调用创建输出。如果<code>error_one_per_line</code>设置为非零值<code>error_at_line</code>跟踪上次报告错误的文件名和行号，并避免直接跟随同一文件和行的消息。此变量是全局变量，并由所有线程共享。
</p></dd></dl>

<p>读取一些输入文件并报告错误的程序可能如下所示：</p>
<div class="example">
<pre class="example">{
  char *line = NULL;
  size_t len = 0;
  unsigned int lineno = 0;

  error_message_count = 0;
  while (! feof_unlocked (fp))
    {
      ssize_t n = getline (&amp;line, &amp;len, fp);
      if (n &lt;= 0)
        /* <span class="roman">End of file or error.</span>  */
        break;
      ++lineno;

      /* <span class="roman">Process the line.</span>  */
      &hellip;

      if (<span class="roman">Detect error in line</span>)
        error_at_line (0, errval, filename, lineno,
                       &quot;some error text %s&quot;, some_variable);
    }

  if (error_message_count != 0)
    error (EXIT_FAILURE, 0, &quot;%u errors found&quot;, error_message_count);
}
</pre></div>

<p><code>error</code>和<code>error_at_line</code>显然是选择的功能，并使程序员能够编写遵循GNU编码标准的应用程序。GNU C库还包含出于相同目的在BSD中使用的功能。这些函数在中声明<samp>err.h</samp> 。通常建议不要使用这些功能。仅出于兼容性考虑将它们包括在内。
</p>
<dl>
<dt id="index-warn">功能： <em>无效</em> <strong>警告</strong> <em>（const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT安全区域| AS-Unsafe损坏的堆i18n | AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>warn</code>函数大致相当于一个调用</p><div class="example">
<pre class="example">  error (0, errno, format, <span class="roman">the parameters</span>)
</pre></div>
<p>除了全局变量<code>error</code>不使用尊重和修改。
</p></dd></dl>

<dl>
<dt id="index-vwarn">功能： <em>void</em> <strong>vwarn</strong> <em>（const char * <var>format</var> ，va_list <var>ap</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS-Unsafe损坏的堆i18n | AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>vwarn</code>功能就像<code>warn</code>除了用于处理格式字符串的参数<var>format</var>作为类型的值传递<code>va_list</code> 。
</p></dd></dl>

<dl>
<dt id="index-warnx">功能： <em>void</em> <strong>warnx</strong> <em>（const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全的损坏堆| AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>warnx</code>函数大致相当于一个调用</p><div class="example">
<pre class="example">  error (0, 0, format, <span class="roman">the parameters</span>)
</pre></div>
<p>除了全局变量<code>error</code>不使用尊重和修改。区别于<code>warn</code>是没有打印错误号字符串。
</p></dd></dl>

<dl>
<dt id="index-vwarnx">功能： <em>void</em> <strong>vwarnx</strong> <em>（const char * <var>format</var> ，va_list <var>ap</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全的损坏堆| AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>vwarnx</code>功能就像<code>warnx</code>除了用于处理格式字符串的参数<var>format</var>作为类型的值传递<code>va_list</code> 。
</p></dd></dl>

<dl>
<dt id="index-err">函数： <em>void</em> <strong>err</strong> <em>（int <var>status</var> ，const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT安全区域| AS-Unsafe损坏的堆i18n | AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>err</code>函数大致相当于一个调用</p><div class="example">
<pre class="example">  error (status, errno, format, <span class="roman">the parameters</span>)
</pre></div>
<p>除了全局变量<code>error</code>尊重和修改不被使用，即使程序退出<var>status</var>是零。
</p></dd></dl>

<dl>
<dt id="index-verr">函数： <em>void</em> <strong>verr</strong> <em>（int <var>status</var> ，const char * <var>format</var> ，va_list <var>ap</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS-Unsafe损坏的堆i18n | AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>verr</code>功能就像<code>err</code>除了用于处理格式字符串的参数<var>format</var>作为类型的值传递<code>va_list</code> 。
</p></dd></dl>

<dl>
<dt id="index-errx">函数： <em>void</em> <strong>errx</strong> <em>（int <var>status</var> ，const char * <var>format</var> ，…）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全的损坏堆| AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>errx</code>函数大致相当于一个调用</p><div class="example">
<pre class="example">  error (status, 0, format, <span class="roman">the parameters</span>)
</pre></div>
<p>除了全局变量<code>error</code>尊重和修改不被使用，即使程序退出<var>status</var>是零。区别于<code>err</code>是没有打印错误号字符串。
</p></dd></dl>

<dl>
<dt id="index-verrx">函数： <em>void</em> <strong>verrx</strong> <em>（int <var>status</var> ，const char * <var>format</var> ，va_list <var>ap</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全的损坏堆| AC不安全损坏的锁内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>verrx</code>功能就像<code>errx</code>除了用于处理格式字符串的参数<var>format</var>作为类型的值传递<code>va_list</code> 。
</p></dd></dl>
<hr>
<div class="header">
<p>上一页： <a href="Error-Codes.html#Error-Codes" rel="prev" accesskey="p">错误代码</a> ，向上： <a href="Error-Reporting.html#Error-Reporting" rel="up" accesskey="u">错误报告</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>