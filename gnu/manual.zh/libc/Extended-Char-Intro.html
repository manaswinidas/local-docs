<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>扩展Char简介（GNU C库）</title>

<meta name="description" content="Extended Char Intro (The GNU C Library)">
<meta name="keywords" content="Extended Char Intro (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Character-Set-Handling.html#Character-Set-Handling" rel="up" title="Character Set Handling">
<link href="Charset-Function-Overview.html#Charset-Function-Overview" rel="next" title="Charset Function Overview">
<link href="Character-Set-Handling.html#Character-Set-Handling" rel="prev" title="Character Set Handling">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Extended-Char-Intro"></span><div class="header">
<p>下一页： <a href="Charset-Function-Overview.html#Charset-Function-Overview" rel="next" accesskey="n">字符集功能概述</a> ，上一篇： <a href="Charset-Function-Overview.html#Charset-Function-Overview" rel="next" accesskey="n">字符</a> <a href="Character-Set-Handling.html#Character-Set-Handling" rel="up" accesskey="u">集处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Introduction-to-Extended-Characters"></span><h3 class="section">6.1扩展字符简介</h3>

<p>有多种解决方案可用来克服字节与字符之间的比例为1：1的字符集之间的差异以及比例为2：1或4：1的字符集。本节的其余部分将提供一些示例，以帮助您理解在开发C库<!-- /@w -->的功能时所做的设计决策。
</p>
<span id="index-internal-representation"></span>
<p>我们必须立即区分内部和外部表示。<em>内部表示</em>表示程序将文本保留在内存中时使用的表示。通过某种通信渠道存储或传输文本时，将使用外部表示。外部表示的示例包括在目录中等待读取和解析的文件。
</p>
<p>传统上，这两种表示形式之间没有区别。在内部和外部使用相同的单字节表示形式同样舒适且有用。随着更多和更大的字符集，此舒适度降低。
</p>
<p>内部表示要克服的问题之一是处理使用不同字符集进行外部编码的文本。假定程序读取两个文本并使用某种度量标准比较它们。仅当文本在内部以通用格式保存时，比较才有用。
</p>
<span id="index-wide-character"></span>
<p>对于这样的通用格式（ <em>=</em>字符集），八位肯定不够了。因此，最小的实体将不得不增长：现在将使用<em>宽字符</em> 。而不是每个字符一个字节，而是使用两个或四个。（三个在内存中不好寻址，似乎不需要四个以上的字节）。
</p>
<span id="index-Unicode"></span>
<span id="index-ISO-10646"></span>
<p>如本手册其他部分所示，已经创建了一个全新的函数系列，可以处理内存中的宽字符文本。这种内部宽字符表示形式最常用的字符集是Unicode和ISO 10646 <!-- /@w --> （也称为通用字符集UCS）。Unicode最初计划为16位字符集。而ISO 10646 <!-- /@w -->被设计为31位大代码空间。这两个标准实际上是相同的。它们具有相同的字符表和代码表，但是Unicode指定添加的语义。目前，只有第一个字符<code>0x10000</code>代码位置（所谓的基本多语言平面，BMP）已被分配，但是在16位空间之外的更专用字符的分配已经在进行中。已为Unicode和ISO 10646 <!-- /@w -->字符定义了多种编码： <span id="index-UCS_002d2"></span><span id="index-UCS_002d4"></span><span id="index-UTF_002d8"></span><span id="index-UTF_002d16"></span> UCS-2是一个16位字，只能表示BMP中的字符，UCS-4是一个32位字，不能表示任何Unicode和ISO 10646 <!-- /@w -->字符，UTF-8是ASCII兼容编码，其中ASCII字符是用2-6个非ASCII字节序列表示ASCII字节和非ASCII字符，最后UTF-16是UCS-2的扩展，其中某些UCS-2单词对可用于编码非BMP字符取决于<code>0x10ffff</code> 。
</p>
<p>代表宽字符<code>char</code>类型不合适。因此，ISO C <!-- /@w -->标准引入了一种新类型，旨在保留宽字符串中的一个字符。为了保持相似性，还有一种对应于<code>int</code>对于那些具有单个宽字符的功能。
</p>
<dl>
<dt id="index-wchar_005ft">数据类型： <strong>wchar_t</strong></dt>
<dd>
<p>该数据类型用作宽字符串的基本类型。换句话说，此类型的对象数组等效于<code>char[]</code>用于多字节字符串。类型定义在<samp>stddef.h</samp> 。
</p>
<p>ISO C90 <!-- /@w -->标准，其中<code>wchar_t</code>被介绍了，没有说任何关于表示的细节。仅要求此类型能够存储基本字符集的所有元素。因此定义是合法的<code>wchar_t</code>如<code>char</code> ，这可能对嵌入式系统有意义。
</p>
<p>但是在GNU C库中<code>wchar_t</code>始终为32位宽，因此能够表示所有UCS-4值，因此涵盖了所有ISO 10646 <!-- /@w --> 。一些Unix系统定义<code>wchar_t</code>作为16位类型，因此非常严格地遵循Unicode。这个定义与标准完全吻合，但这也意味着要代表Unicode和ISO 10646中的所有字符， <!-- /@w -->必须使用UTF-16替代字符，实际上是一种多字符编码。但是诉诸于多字符编码会与<code>wchar_t</code>类型。
</p></dd></dl>

<dl>
<dt id="index-wint_005ft-1">数据类型： <strong>wint_t</strong></dt>
<dd>
<p><code>wint_t</code>是用于包含单个宽字符的参数和变量的数据类型。顾名思义，此类型等效于<code>int</code>当使用普通<code>char</code>字符串。类型<code>wchar_t</code>和<code>wint_t</code>如果其大小为32位宽，则通常具有相同的表示形式，但如果<code>wchar_t</code>被定义为<code>char</code>类型<code>wint_t</code>必须定义为<code>int</code>由于参数提升。
</p>
<span id="index-wchar_002eh-3"></span>
<p>此类型在<samp>wchar.h</samp>并在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入。
</p></dd></dl>

<p>由于有<code>char</code>数据类型宏可用于指定类型对象中可表示的最小值和最大值<code>wchar_t</code> 。
</p>
<dl>
<dt id="index-WCHAR_005fMIN">巨集： <em>wint_t</em> <strong>WCHAR_MIN</strong></dt>
<dd>
<p>宏<code>WCHAR_MIN</code>求出类型对象可表示的最小值<code>wint_t</code> 。
</p>
<p>此宏在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入。
</p></dd></dl>

<dl>
<dt id="index-WCHAR_005fMAX">巨集： <em>wint_t</em> <strong>WCHAR_MAX</strong></dt>
<dd>
<p>宏<code>WCHAR_MAX</code>评估为类型对象可表示的最大值<code>wint_t</code> 。
</p>
<p>此宏在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入。
</p></dd></dl>

<p>另一个特殊的宽字符值等效于<code>EOF</code> 。
</p>
<dl>
<dt id="index-WEOF">巨集： <em>wint_t</em> <strong>WEOF</strong></dt>
<dd>
<p>宏<code>WEOF</code>计算为类型的常量表达式<code>wint_t</code>其值不同于扩展字符集的任何成员。
</p>
<p><code>WEOF</code>不必与<code>EOF</code>和不一样<code>EOF</code>它也<em>不必</em>为负。换句话说，草率的代码就像</p>
<div class="example">
<pre class="example">{
  int c;
  &hellip;
  while ((c = getc (fp)) &lt; 0)
    &hellip;
}
</pre></div>

<p>必须重写才能使用<code>WEOF</code>在使用宽字符时明确显示：</p>
<div class="example">
<pre class="example">{
  wint_t c;
  &hellip;
  while ((c = wgetc (fp)) != WEOF)
    &hellip;
}
</pre></div>

<span id="index-wchar_002eh-4"></span>
<p>该宏在ISO C90 <!-- /@w -->修订1 <!-- /@w -->引入，并在<samp>wchar.h</samp> 。
</p></dd></dl>


<p>这些内部表示形式在存储和传输方面存在问题。因为每个单个宽字符都包含一个以上的字节，所以它们会受到字节顺序的影响。因此，具有不同字节序的机器在访问相同数据时将看到不同的值。此字节排序问题也适用于全部基于字节的通信协议，因此要求发送方决定将宽字符拆分为字节。最后一点（但并非最重要的一点）是，宽字符通常比自定义的面向字节的字符集需要更多的存储空间。
</p>
<span id="index-multibyte-character-1"></span>
<span id="index-EBCDIC"></span>
<p>由于上述所有原因，如果内部编码为UCS-2或UCS-4，则通常使用与内部编码不同的外部编码。外部编码是基于字节的，可以根据环境和要处理的文本进行适当选择。各种不同的字符集可用于此外部编码（此处将不详尽介绍的信息-而是对主要组的描述就足够了）。所有基于ASCII的字符集都满足一个要求：它们是“文件系统安全的”。这意味着角色<code>'/'</code>在编码中<em>仅</em>用于表示自身。对于像EBCDIC（扩展的二进制编码的十进制交换码，IBM使用的字符集家族）这样的字符集，情况有所不同，但是，如果操作系统不直接理解EBCDIC，则无论如何都必须首先转换参数到系统的调用。
</p>
<ul>
<li>最简单的字符集是单字节字符集。最多只能包含256个字符（对于8位<!-- /@w -->字符集），这不足以覆盖所有语言，但可能足以处理特定的文本。处理8位<!-- /@w -->字符集很简单。对于稍后介绍的其他类型而言，情况并非如此，因此，使用的应用程序可能需要使用8位<!-- /@w -->字符集。

</li><li> <span id="index-ISO-2022"></span> ISO 2022 <!-- /@w -->标准定义了一种扩展字符集的机制，其中一个字符<em>可以</em>用一个以上的字节表示。这是通过将状态与文本相关联来实现的。可用于更改状态的字符可以嵌入到文本中。文本中的每个字节在每种状态下都有不同的解释。该状态甚至可能影响给定字节是自己代表字符还是必须与更多字节组合。

<span id="index-EUC"></span>
<span id="index-Shift_005fJIS"></span>
<span id="index-SJIS"></span>
<p>在ISO 2022 <!-- /@w -->的大多数使用中，已定义的字符集不允许状态更改覆盖下一个字符。这具有很大的优势，那就是只要有人可以识别字符的字节序列的开头，就可以正确地解释文本。使用此策略的字符集的示例是各种EUC字符集（由Sun的操作系统，EUC-JP，EUC-KR，EUC-TW和EUC-CN使用）或Shift_JIS（SJIS，日语编码）。
</p>
<p>但是也有一些字符集使用的状态对多个字符有效，并且必须由另一字节序列进行更改。例如ISO-2022-JP，ISO-2022-KR和ISO-2022-CN。</p>
</li><li> <span id="index-ISO-6937"></span>早期尝试使用罗马字母来修复其他语言的8位字符集的尝试导致了诸如ISO 6937 <!-- /@w -->类的字符集。在这里，代表诸如尖音之类的字符的字节本身不会产生输出：必须将它们与其他字符组合才能获得所需的结果。例如，字节序列<code>0xc2 0x61</code> （不带空格的尖音符号，后跟小写字母“ a”）即可获得“带有尖音的小a”字符。要独自获得强烈的口音特征，必须写<code>0xc2 0x20</code> （非间隔急性，后跟空格）。

<p>ISO 6937 <!-- /@w -->类的字符集用于某些嵌入式系统（例如Teletex）中。
</p>
</li><li> <span id="index-UTF_002d8-1"></span>代替转换内部使用的Unicode或ISO 10646 <!-- /@w -->文本，通常只需使用不同于UCS-2 / UCS-4的编码就足够了。Unicode和ISO 10646 <!-- /@w -->标准甚至指定了这样的编码：UTF-8。此编码能够表示长度为1到6的字节串中的所有ISO 10646 <!-- /@w --> 31位。

<span id="index-UTF_002d7"></span>
<p>还有其他一些尝试对ISO 10646 <!-- /@w -->进行编码的尝试，例如UTF-7，但如今，UTF-8是唯一应使用的编码。实际上，幸运的是，UTF-8将很快成为唯一需要支持的外部编码。它被证明是通用的，并且唯一的缺点是，它通过使其他脚本（西里尔字母，希腊语，亚洲脚本）的字节字符串表示形式比为这些脚本使用特定的字符集更长的时间来支持罗马语言。诸如Unicode压缩方案之类的方法可以缓解这些问题。
</p></li></ul>

<p>剩下的问题是：如何选择要使用的字符集或编码。答案：您不能自己决定，它是由系统开发人员或大多数用户决定的。由于目标是互操作性，因此一个人必须使用与他人一起工作的任何东西。如果没有限制，则根据预期的用户圈子的要求进行选择。换句话说，如果某个项目仅预期在俄罗斯使用，则可以使用KOI8-R或类似字符集。但是，如果同时有来自希腊的人参加，那么应该使用一种允许所有人合作的字符集。
</p>
<p>最广泛使用的解决方案似乎是：使用最通用的字符集，即ISO 10646 <!-- /@w --> 。使用UTF-8作为外部编码，有关用户无法充分使用自己的语言的问题已成为过去。
</p>
<p>在这一点上，有必要对选择宽字符表示形式发表最后的评论。上面我们已经说过，自然的选择是使用Unicode或ISO 10646 <!-- /@w --> 。ISO C <!-- /@w -->标准不是必需的，但至少是鼓励这样做的。该标准至少定义了一个宏<code>__STDC_ISO_10646__</code>仅在其中<code>wchar_t</code>类型编码ISO 10646 <!-- /@w -->字符。如果未定义此符号，则应避免对宽字符表示进行假设。如果程序员仅使用C库提供的函数来处理宽字符串，则应该不会与其他系统存在兼容性问题。
</p>
<hr>
<div class="header">
<p>下一页： <a href="Charset-Function-Overview.html#Charset-Function-Overview" rel="next" accesskey="n">字符集功能概述</a> ，上一篇： <a href="Charset-Function-Overview.html#Charset-Function-Overview" rel="next" accesskey="n">字符</a> <a href="Character-Set-Handling.html#Character-Set-Handling" rel="up" accesskey="u">集处理</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>