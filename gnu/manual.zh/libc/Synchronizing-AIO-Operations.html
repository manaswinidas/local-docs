<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>同步AIO操作（GNU C库）</title>

<meta name="description" content="Synchronizing AIO Operations (The GNU C Library)">
<meta name="keywords" content="Synchronizing AIO Operations (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" title="Asynchronous I/O">
<link href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" rel="next" title="Cancel AIO Operations">
<link href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="prev" title="Status of AIO Operations">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Synchronizing-AIO-Operations"></span><div class="header">
<p>下一篇： <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" rel="next" accesskey="n">取消AIO操作</a> ，上一篇： <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" rel="next" accesskey="n">AIO操作</a> <a href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="prev" accesskey="p">状态</a> ，上一篇： <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" accesskey="u">异步I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Getting-into-a-Consistent-State"></span><h4 class="subsection">13.11.3进入一致状态</h4>

<p>在处理异步操作时，有时必须进入一致状态。对于AIO而言，这意味着希望知道某个请求或一组请求是否已处理。这可以通过在操作终止后等待系统发送的通知来完成，但这有时意味着浪费资源（主要是计算时间）。相反，POSIX.1b定义了两个函数，这些函数将有助于大多数类型的一致性。
</p>
<p>的<code>aio_fsync</code>和<code>aio_fsync64</code>仅当符号为<code>_POSIX_SYNCHRONIZED_IO</code>在中定义<samp>unistd.h</samp> 。
</p>
<span id="index-synchronizing-1"></span>
<dl>
<dt id="index-aio_005ffsync">函数： <em>int</em> <strong>aio_fsync</strong> <em>（int <var>op</var> ，struct aiocb * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>调用此函数会强制在文件描述符上进行函数调用时所有排队的I / O操作<code>aiocbp->aio_fildes</code>进入同步I / O完成状态（请参阅<a href="Synchronizing-I_002fO.html#Synchronizing-I_002fO">同步I / O</a> ）。的<code>aio_fsync</code>函数立即返回，但通过中描述的方法进行通知<code>aiocbp->aio_sigevent</code>仅在对该文件描述符的所有请求都终止并且文件同步之后，才会发生。这也意味着在同步请求之后排队的对该文件描述符的请求不会受到影响。
</p>
<p>如果<var>op</var>是<code>O_DSYNC</code>同步发生在<code>fdatasync</code> 。除此以外<var>op</var>应该<code>O_SYNC</code>和同步发生<code>fsync</code> 。
</p>
<p>只要未发生同步，请致电<code>aio_error</code>引用由指向的对象<var>aiocbp</var>退货<code>EINPROGRESS</code> 。同步完成后<code>aio_error</code>如果同步失败，则返回<em>0</em> 。否则，返回的值就是<code>fsync</code>要么<code>fdatasync</code>功能将设置<code>errno</code>变量。在这种情况下，不能假设写入该文件描述符的数据的一致性。
</p>
<p>如果请求成功入队，此函数的返回值为<em>0</em> 。否则，返回值为<em>-1</em> ， <code>errno</code>设置为以下值之一：</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dd><p>由于暂时缺乏资源，因此无法将请求加入队列。
</p></dd>
<dt><code>EBADF</code></dt>
<dd><p>文件描述符<code><var>aiocbp</var>->aio_fildes</code>无效。
</p></dd>
<dt><code>EINVAL</code></dt>
<dd><p>该实现不支持I / O同步或<var>op</var>参数不是<code>O_DSYNC</code>和<code>O_SYNC</code> 。
</p></dd>
<dt><code>ENOSYS</code></dt>
<dd><p>未实现此功能。
</p></dd>
</dl>

<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>这个功能其实<code>aio_fsync64</code>因为LFS接口透明地替换了常规实现。
</p></dd></dl>

<dl>
<dt id="index-aio_005ffsync64">函数： <em>int</em> <strong>aio_fsync64</strong> <em>（int <var>op</var> ，struct aiocb64 * <var>aiocbp</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁堆| AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>aio_fsync</code>唯一的区别是参数是对类型变量的引用<code>struct aiocb64</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>该功能在名称下可用<code>aio_fsync</code>因此透明地替换了32位计算机上小文件的接口。
</p></dd></dl>

<p>同步的另一种方法是等待，直到特定集合的一个或多个请求终止。这可以通过<code>aio_*</code>函数可以通知启动过程有关终止的信息，但是在某些情况下，这不是理想的解决方案。在一个不断更新以某种方式连接到服务器的客户端的程序中，由于某些连接速度可能很慢，因此并非总是最好的解决方案。另一方面，让<code>aio_*</code>函数通知调用者可能也不是最佳解决方案，因为每当进程为客户端准备数据时，通知就没有意义被中断，因为在服务当前客户端之前不会处理新客户端。对于这种情况<code>aio_suspend</code>应该使用。
</p>
<dl>
<dt id="index-aio_005fsuspend">函数： <em>int</em> <strong>aio_suspend</strong> <em>（const struct aiocb * const <var>list</var> []，int <var>nent</var> ，const struct timespec * <var>timeout</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>调用此函数时，调用线程将被挂起，直到该线程指向的至少一个请求为止。 <var>nent</var>数组的元素<var>list</var>已经完成。如果当时任何请求已经完成<code>aio_suspend</code>调用后，函数立即返回。通过将请求的错误状态与<code>EINPROGRESS</code> 。如果一个元素<var>list</var>是<code>NULL</code> ，则该条目将被忽略。
</p>
<p>如果没有完成请求，则调用过程将被挂起。如果<var>timeout</var>是<code>NULL</code> ，直到请求完成才唤醒该过程。如果<var>timeout</var>不是<code>NULL</code> ，则该过程至少应保持暂停，直到<var>timeout</var> 。在这种情况下， <code>aio_suspend</code>返回错误。
</p>
<p>如果来自的一个或多个请求，则该函数的返回值为<em>0。</em> <var>list</var>已终止。否则，函数返回<em>-1，</em>然后<code>errno</code>设置为以下值之一：</p>
<dl compact>
<dt><code>EAGAIN</code></dt>
<dd><p>没有来自的请求<var>list</var>在规定的时间内完成<var>timeout</var> 。
</p></dd>
<dt><code>EINTR</code></dt>
<dd><p>信号中断了<code>aio_suspend</code>功能。该信号也可能由AIO实现发送，同时发出请求之一的终止信号。
</p></dd>
<dt><code>ENOSYS</code></dt>
<dd><p>的<code>aio_suspend</code>功能未实现。
</p></dd>
</dl>

<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>这个功能其实<code>aio_suspend64</code>因为LFS接口透明地替换了常规实现。
</p></dd></dl>

<dl>
<dt id="index-aio_005fsuspend64">函数： <em>int</em> <strong>aio_suspend64</strong> <em>（const struct aiocb64 * const <var>list</var> []，int <var>nent</var> ，const struct timespec * <var>timeout</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全锁| AC不安全锁|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>该功能类似于<code>aio_suspend</code>唯一的区别是参数是对类型变量的引用<code>struct aiocb64</code> 。
</p>
<p>当源编译时<code>_FILE_OFFSET_BITS == 64</code>该功能在名称下可用<code>aio_suspend</code>因此透明地替换了32位计算机上小文件的接口。
</p></dd></dl>

<hr>
<div class="header">
<p>下一篇： <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" rel="next" accesskey="n">取消AIO操作</a> ，上一篇： <a href="Cancel-AIO-Operations.html#Cancel-AIO-Operations" rel="next" accesskey="n">AIO操作</a> <a href="Status-of-AIO-Operations.html#Status-of-AIO-Operations" rel="prev" accesskey="p">状态</a> ，上一篇： <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" rel="up" accesskey="u">异步I / O</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>