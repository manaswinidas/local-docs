<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>System V上下文（GNU C库）</title>

<meta name="description" content="System V contexts (The GNU C Library)">
<meta name="keywords" content="System V contexts (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Non_002dLocal-Exits.html#Non_002dLocal-Exits" rel="up" title="Non-Local Exits">
<link href="Signal-Handling.html#Signal-Handling" rel="next" title="Signal Handling">
<link href="Non_002dLocal-Exits-and-Signals.html#Non_002dLocal-Exits-and-Signals" rel="prev" title="Non-Local Exits and Signals">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="System-V-contexts"></span><div class="header">
<p>上一页： <a href="Non_002dLocal-Exits-and-Signals.html#Non_002dLocal-Exits-and-Signals" rel="prev" accesskey="p">非本地出口和信号</a> ，向上： <a href="Non_002dLocal-Exits.html#Non_002dLocal-Exits" rel="up" accesskey="u">非本地出口</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Complete-Context-Control"></span><h3 class="section">23.4完整的上下文控制</h3>

<p>Unix标准提供了更多的功能集来控制执行路径，并且这些功能比到目前为止本章中讨论的功能更强大。这些功能是原始System V <!-- /@w --> API的一部分，并通过此途径被添加到Unix API中。除了在品牌的Unix实现上，这些接口还没有广泛使用。并非所有GNU C库平台和/或体系结构都可提供此接口。使用<samp>configure</samp>检测可用性。
</p>
<p>类似于<code>jmp_buf</code>和<code>sigjmp_buf</code>变量用于包含状态的类型<code>longjmp</code>功能感兴趣的接口在这里也具有适当的类型。由于包含更多信息，因此这种类型的对象通常要大得多。正如我们将看到的，该类型还在更多的地方使用。本节中描述的类型和函数都分别在<samp>ucontext.h</samp>头文件。
</p>
<dl>
<dt id="index-ucontext_005ft">数据类型： <strong>ucontext_t</strong></dt>
<dd>

<p>的<code>ucontext_t</code> type被定义为至少包含以下元素的结构：</p>
<dl compact>
<dt><code>ucontext_t *uc_link</code></dt>
<dd><p>这是指向下一个上下文结构的指针，如果当前结构中描述的上下文返回，则使用该结构。
</p>
</dd>
<dt><code>sigset_t uc_sigmask</code></dt>
<dd><p>使用此上下文时被阻止的信号集。
</p>
</dd>
<dt><code>stack_t uc_stack</code></dt>
<dd><p>用于此上下文的堆栈。该值不必（通常不是）堆栈指针。请参阅<a href="Signal-Stack.html#Signal-Stack">信号堆栈</a> 。
</p>
</dd>
<dt><code>mcontext_t uc_mcontext</code></dt>
<dd><p>该元素包含过程的实际状态。的<code>mcontext_t</code>该标头中也定义了type，但该定义应视为不透明。对此类知识的任何使用都会使应用程序的可移植性降低。
</p>
</dd>
</dl>
</dd></dl>

<p>这种类型的对象必须由用户创建。初始化和修改通过以下功能之一进行：</p>
<dl>
<dt id="index-getcontext">函数： <em>int</em> <strong>getcontext</strong> <em>（ucontext_t * <var>ucp</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：ucp | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>getcontext</code>函数初始化由指向的变量<var>ucp</var>与调用线程的上下文。上下文包含寄存器，信号掩码和当前堆栈的内容。执行内容将从<code>getcontext</code>刚刚返回的电话。
</p>
<p><strong>兼容性说明：</strong>取决于操作系统，有关当前上下文堆栈的信息可能位于<code>uc_stack</code>现场<var>ucp</var> ，也可以位于的特定于体系结构的子字段中<code>uc_mcontext</code>领域。
</p>
<p>函数返回<code>0</code>如果成功。否则返回<code>-1</code>和集<code>errno</code>相应地。
</p></dd></dl>

<p>的<code>getcontext</code>功能类似于<code>setjmp</code>但这并不能说明<code>getcontext</code>是第一次返回，还是刚恢复了初始化的上下文。如果有必要，用户必须自己确定。由于上下文包含可能包含寄存器变量的寄存器，因此必须谨慎进行。这是定义变量的好情况<code>volatile</code> 。
</p>
<p>初始化上下文变量后，可以按原样使用它，也可以使用<code>makecontext</code>功能。后者通常在实现协同例程或类似构造时完成。
</p>
<dl>
<dt id="index-makecontext">函数： <em>void</em> <strong>makecontext</strong> <em>（ucontext_t * <var>ucp</var> ，无效（* <var>func</var> ）（void），int <var>argc</var> ，…）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：ucp | AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<var>ucp</var>参数传递给<code>makecontext</code>应通过调用来初始化<code>getcontext</code> 。上下文将以某种方式进行修改，使得如果上下文得以恢复，它将通过调用该函数开始<code>func</code>得到<var>argc</var>传递了整数参数。要传递的整数参数应遵循<var>argc</var>调用中的参数<code>makecontext</code> 。
</p>
<p>在调用此函数之前<code>uc_stack</code>和<code>uc_link</code>的元素<var>ucp</var>结构应该初始化。的<code>uc_stack</code>元素描述用于此上下文的堆栈。不能同时使用两个上下文为堆栈使用相同的内存区域。
</p>
<p>的<code>uc_link</code>指向的对象的元素<var>ucp</var>应该是当函数要执行的上下文的指针<var>func</var>返回，否则应为空指针。看到<code>setcontext</code>有关确切使用的更多信息。
</p></dd></dl>

<p>在为堆栈分配内存时，一定要小心。大多数现代处理器都会跟踪某个内存区域是否允许包含已执行的代码。数据段和堆内存通常没有标记以允许这样做。结果是程序将失败。此类代码的示例包括GNU C编译器为调用嵌套函数而生成的调用序列。正确分配堆栈的安全方法包括在原始线程的堆栈上使用内存，或显式分配标记为要使用执行的<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存</a> （请参阅<a href="Memory_002dmapped-I_002fO.html#Memory_002dmapped-I_002fO">内存映射的I / O</a> ）。
</p>
<p><strong>兼容性说明</strong> ：当前的Unix标准对于堆栈的分配方式非常不准确。所有实现似乎都同意<code>uc_stack</code>必须使用元素，但存储在元素中的值<code>stack_t</code>价值尚不清楚。GNU C库和大多数其他Unix实现要求<code>ss_sp</code>的价值<code>uc_stack</code>元素，该元素指向分配给堆栈的内存区域的基础，并且内存区域的大小存储在<code>ss_size</code> 。有一些实现需要<code>ss_sp</code>设置为堆栈指针将具有的值（根据堆栈增长的方向，该值可以不同）。这种差异使<code>makecontext</code>函数难以使用，并且需要在编译时检测平台。
</p>
<dl>
<dt id="index-setcontext">函数： <em>int</em> <strong>setcontext</strong> <em>（const ucontext_t * <var>ucp</var> ）</em></dt>
<dd>
<p>初步： MT-Safe竞赛：ucp |不安全AS损坏| AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>setcontext</code>函数恢复上下文描述的<var>ucp</var> 。上下文未修改，可以根据需要多次重用。
</p>
<p>如果上下文是由创建的<code>getcontext</code>继续执行，并用相同的值和相同的堆栈填充寄存器，就像<code>getcontext</code>刚刚返回的电话。
</p>
<p>如果通过调用修改了上下文<code>makecontext</code>执行继续，并将函数传递给<code>makecontext</code>它获取传递的指定参数。如果此函数返回，则在由引用的上下文中恢复执行。 <code>uc_link</code>传递给的上下文结构的元素<code>makecontext</code>在通话时。如果<code>uc_link</code>是空指针，应用程序正常退出，退出状态值为<code>EXIT_SUCCESS</code> （请参阅<a href="Program-Termination.html#Program-Termination">程序终止</a> ）。
</p>
<p>如果上下文是通过调用信号处理程序或从任何其他来源创建的，则行为<code>setcontext</code>未指定。
</p>
<p>由于上下文包含有关堆栈的信息，因此没有两个线程应同时使用同一上下文。在大多数情况下，结果将是灾难性的。
</p>
<p>的<code>setcontext</code>除非发生错误，否则函数不返回<code>-1</code> 。
</p></dd></dl>

<p>的<code>setcontext</code>函数只是将当前上下文替换为<var>ucp</var>参数。这通常很有用，但是在某些情况下必须保留当前上下文。
</p>
<dl>
<dt id="index-swapcontext">函数： <em>int</em> <strong>swapcontext</strong> <em>（ucontext_t *限制<var>oucp</var> ，const ucontext_t *限制<var>ucp</var> ）</em></dt>
<dd>
<p>初步： MT安全竞赛：oucp竞赛：ucp |不安全AS损坏| AC不安全的腐败|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>的<code>swapcontext</code>功能类似于<code>setcontext</code>但是，不仅要替换当前上下文，后者还要先保存在所指向的对象中<var>oucp</var>好像这是对<code>getcontext</code> 。调用后，已保存的上下文将恢复<code>swapcontext</code> 。
</p>
<p>保存当前上下文后，将在<var>ucp</var>如上下文中所述安装并继续执行。
</p>
<p>如果<code>swapcontext</code>成功除非上下文，否则函数不返回<var>oucp</var>不经事先修改即可使用<code>makecontext</code> 。在这种情况下，返回值为<code>0</code> 。如果函数失败，则返回<code>-1</code>和集<code>errno</code>相应地。
</p></dd></dl>

<span id="Example-for-SVID-Context-Handling"></span><h3 class="heading">SVID上下文处理示例</h3>

<p>使用上下文处理功能的最简单方法是替代<code>setjmp</code>和<code>longjmp</code> 。在大多数平台上，上下文都包含更多信息，这可能会导致更少的意外，但这也意味着使用这些功能的成本更高（除了具有较小的可移植性之外）。
</p>
<div class="example">
<pre class="example">int
random_search (int n, int (*fp) (int, ucontext_t *))
{
  volatile int cnt = 0;
  ucontext_t uc;

  /* <span class="roman">Safe current context.</span>  */
  if (getcontext (&amp;uc) &lt; 0)
    return -1;

  /* <span class="roman">If we have not tried <var>n</var> times try again.</span>  */
  if (cnt++ &lt; n)
    /* <span class="roman">Call the function with a new random number</span>
       <span class="roman">and the context</span>.  */
    if (fp (rand (), &amp;uc) != 0)
      /* <span class="roman">We found what we were looking for.</span>  */
      return 1;

  /* <span class="roman">Not found.</span>  */
  return 0;
}
</pre></div>

<p>以这种方式使用上下文可以模拟异常处理。搜索功能通过了<var>fp</var>参数可能非常大，嵌套且很复杂，这会使函数具有错误值（必须传递给调用者）变得复杂（或至少需要很多代码）。通过使用上下文，可以一步一步地保留搜索功能，并允许重新开始搜索，这还有一个很好的副作用，那就是它可以大大加快速度。
</p>
<p>很难实现的东西<code>setjmp</code>和<code>longjmp</code>是暂时切换到其他执行路径，然后在执行停止的地方恢复。
</p>
<div class="example">
<pre class="example">

#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ucontext.h&gt;
#include &lt;sys/time.h&gt;

/* <span class="roman">Set by the signal handler.</span> */
static volatile int expired;

/* <span class="roman">The contexts.</span> */
static ucontext_t uc[3];

/* <span class="roman">We do only a certain number of switches.</span> */
static int switches;


/* <span class="roman">This is the function doing the work.  It is just a
   skeleton, real code has to be filled in.</span> */
static void
f (int n)
{
  int m = 0;
  while (1)
    {
      /* <span class="roman">This is where the work would be done.</span> */
      if (++m % 100 == 0)
        {
          putchar ('.');
          fflush (stdout);
        }

      /* <span class="roman">Regularly the <var>expire</var> variable must be checked.</span> */
      if (expired)
        {
          /* <span class="roman">We do not want the program to run forever.</span> */
          if (++switches == 20)
            return;

          printf (&quot;\nswitching from %d to %d\n&quot;, n, 3 - n);
          expired = 0;
          /* <span class="roman">Switch to the other context, saving the current one.</span> */
          swapcontext (&amp;uc[n], &amp;uc[3 - n]);
        }
    }
}

/* <span class="roman">This is the signal handler which simply set the variable.</span> */
void
handler (int signal)
{
  expired = 1;
}


int
main (void)
{
  struct sigaction sa;
  struct itimerval it;
  char st1[8192];
  char st2[8192];

  /* <span class="roman">Initialize the data structures for the interval timer.</span> */
  sa.sa_flags = SA_RESTART;
  sigfillset (&amp;sa.sa_mask);
  sa.sa_handler = handler;
  it.it_interval.tv_sec = 0;
  it.it_interval.tv_usec = 1;
  it.it_value = it.it_interval;

  /* <span class="roman">Install the timer and get the context we can manipulate.</span> */
  if (sigaction (SIGPROF, &amp;sa, NULL) &lt; 0
      || setitimer (ITIMER_PROF, &amp;it, NULL) &lt; 0
      || getcontext (&amp;uc[1]) == -1
      || getcontext (&amp;uc[2]) == -1)
    abort ();

  /* <span class="roman">Create a context with a separate stack which causes the
     function <code>f</code> to be call with the parameter <code>1</code>.
     Note that the <code>uc_link</code> points to the main context
     which will cause the program to terminate once the function
     return.</span> */
  uc[1].uc_link = &amp;uc[0];
  uc[1].uc_stack.ss_sp = st1;
  uc[1].uc_stack.ss_size = sizeof st1;
  makecontext (&amp;uc[1], (void (*) (void)) f, 1, 1);

  /* <span class="roman">Similarly, but <code>2</code> is passed as the parameter to <code>f</code>.</span> */
  uc[2].uc_link = &amp;uc[0];
  uc[2].uc_stack.ss_sp = st2;
  uc[2].uc_stack.ss_size = sizeof st2;
  makecontext (&amp;uc[2], (void (*) (void)) f, 1, 2);

  /* <span class="roman">Start running.</span> */
  swapcontext (&amp;uc[0], &amp;uc[1]);
  putchar ('\n');

  return 0;
}
</pre></div>

<p>这个示例说明了如何使用上下文函数来实现协同例程或协作式多线程。所有要做的就是不时打一次电话<code>swapcontext</code>继续运行其他环境。不建议直接从信号处理程序进行上下文切换，因为通过<code>setcontext</code>如果信号是在非异步代码中传递的，则信号安全可能会导致问题。在信号处理程序中设置变量并在执行的函数主体中进行检查是一种比较安全的方法。以来<code>swapcontext</code>如果保存当前上下文，则代码中可能有多个不同的调度点。执行将始终在其保留的位置继续进行。</p><hr>
<div class="header">
<p>上一页： <a href="Non_002dLocal-Exits-and-Signals.html#Non_002dLocal-Exits-and-Signals" rel="prev" accesskey="p">非本地出口和信号</a> ，向上： <a href="Non_002dLocal-Exits.html#Non_002dLocal-Exits" rel="up" accesskey="u">非本地出口</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>