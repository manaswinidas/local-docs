<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>带外数据（GNU C库）</title>

<meta name="description" content="Out-of-Band Data (The GNU C Library)">
<meta name="keywords" content="Out-of-Band Data (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Connections.html#Connections" rel="up" title="Connections">
<link href="Datagrams.html#Datagrams" rel="next" title="Datagrams">
<link href="Server-Example.html#Server-Example" rel="prev" title="Server Example">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Out_002dof_002dBand-Data"></span><div class="header">
<p>上一篇： <a href="Server-Example.html#Server-Example" rel="prev" accesskey="p">服务器示例</a> ，上一篇： <a href="Connections.html#Connections" rel="up" accesskey="u">连接</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Out_002dof_002dBand-Data-1"></span><h4 class="subsection">16.9.8带外数据</h4>

<span id="index-out_002dof_002dband-data"></span>
<span id="index-high_002dpriority-data"></span>
<p>具有连接的流允许<em>带外</em>数据的传输比普通数据具有更高的优先级。通常，发送带外数据的原因是发送异常情况的通知。发送带外数据使用<code>send</code> ，指定标志<code>MSG_OOB</code> （请参阅<a href="Sending-Data.html#Sending-Data">发送数据</a> ）。
</p>
<p>带外数据的接收优先级较高，因为接收过程无需按顺序读取数据；读取下一个可用的带外数据，请使用<code>recv</code>与<code>MSG_OOB</code>标志（请参见<a href="Receiving-Data.html#Receiving-Data">接收数据</a> ）。普通的读取操作不会读取带外数据；他们只读取普通数据。
</p>
<span id="index-urgent-socket-condition"></span>
<p>当套接字发现带外数据正在传输时，它将发送一个<code>SIGURG</code>向套接字的所有者进程或进程组发出信号。您可以使用<code>F_SETOWN</code>命令给<code>fcntl</code>功能;请参见<a href="Interrupt-Input.html#Interrupt-Input">中断输入</a> 。您还必须按照<a href="Signal-Handling.html#Signal-Handling">信号处理中</a>所述为该信号建立一个处理程序，以便采取适当的措施，例如读取带外数据。
</p>
<p>或者，您可以使用以下方法测试未决的带外数据，或等待直到带外数据<code>select</code>功能;它可以等待套接字出现异常情况。有关更多信息，请参见<a href="Waiting-for-I_002fO.html#Waiting-for-I_002fO">等待I / O。</a> <code>select</code> 。
</p>
<p>带外数据通知（是否与<code>SIGURG</code>或搭配<code>select</code> ）表示带外数据正在传输中；数据可能直到稍后才会真正到达。如果您尝试在带外数据到达之前读取它们， <code>recv</code>失败了<code>EWOULDBLOCK</code>错误。
</p>
<p>自动发送带外数据会在普通数据流中放置一个“标记”，以显示带外数据“本来应该”的顺序。当带外数据的含义是“取消到目前为止发送的所有内容”时，这很有用。在接收过程中，可以通过以下方法测试在标记之前是否发送了任何普通数据：</p>
<div class="example">
<pre class="example">success = ioctl (socket, SIOCATMARK, &amp;atmark);
</pre></div>

<p>的<code>integer</code>变量<var>atmark</var>如果套接字的读取指针已达到“ mark”，则将其设置为非零值。
</p>

<p>这是一个函数，用于丢弃带外标记之前的任何普通数据：</p>
<div class="example">
<pre class="example">int
discard_until_mark (int socket)
{
  while (1)
    {
      /* <span class="roman">This is not an arbitrary limit; any size will do.</span>  */
      char buffer[1024];
      int atmark, success;

      /* <span class="roman">If we have reached the mark, return.</span>  */
      success = ioctl (socket, SIOCATMARK, &amp;atmark);
      if (success &lt; 0)
        perror (&quot;ioctl&quot;);
      if (result)
        return;

      /* <span class="roman">Otherwise, read a bunch of ordinary data and discard it.</span>
         <span class="roman">This is guaranteed not to read past the mark</span>
         <span class="roman">if it starts before the mark.</span>  */
      success = read (socket, buffer, sizeof buffer);
      if (success &lt; 0)
        perror (&quot;read&quot;);
    }
}
</pre></div>

<p>如果您不想丢弃标记前的普通数据，则无论如何都可能需要读取其中的一些数据，以便在内部系统缓冲区中为带外数据腾出空间。如果您尝试读取带外数据并获得<code>EWOULDBLOCK</code>错误，请尝试读取一些普通数据（保存该数据以便在需要时可以使用它），然后看看是否有空间。这是一个例子：</p>
<div class="example">
<pre class="example">struct buffer
{
  char *buf;
  int size;
  struct buffer *next;
};

/* <span class="roman">Read the out-of-band data from SOCKET and return it</span>
   <span class="roman">as a &lsquo;struct buffer&rsquo;, which records the address of the data</span>
   <span class="roman">and its size.</span>

   <span class="roman">It may be necessary to read some ordinary data</span>
   <span class="roman">in order to make room for the out-of-band data.</span>
   <span class="roman">If so, the ordinary data are saved as a chain of buffers</span>
   <span class="roman">found in the &lsquo;next&rsquo; field of the value.</span>  */

struct buffer *
read_oob (int socket)
{
  struct buffer *tail = 0;
  struct buffer *list = 0;

  while (1)
    {
      /* <span class="roman">This is an arbitrary limit.</span>
         <span class="roman">Does anyone know how to do this without a limit?</span>  */
#define BUF_SZ 1024
      char *buf = (char *) xmalloc (BUF_SZ);
      int success;
      int atmark;

      /* <span class="roman">Try again to read the out-of-band data.</span>  */
      success = recv (socket, buf, BUF_SZ, MSG_OOB);
      if (success &gt;= 0)
        {
          /* <span class="roman">We got it, so return it.</span>  */
          struct buffer *link
            = (struct buffer *) xmalloc (sizeof (struct buffer));
          link-&gt;buf = buf;
          link-&gt;size = success;
          link-&gt;next = list;
          return link;
        }

      /* <span class="roman">If we fail, see if we are at the mark.</span>  */
      success = ioctl (socket, SIOCATMARK, &amp;atmark);
      if (success &lt; 0)
        perror (&quot;ioctl&quot;);
      if (atmark)
        {
          /* <span class="roman">At the mark; skipping past more ordinary data cannot help.</span>
             <span class="roman">So just wait a while.</span>  */
          sleep (1);
          continue;
        }

      /* <span class="roman">Otherwise, read a bunch of ordinary data and save it.</span>
         <span class="roman">This is guaranteed not to read past the mark</span>
         <span class="roman">if it starts before the mark.</span>  */
      success = read (socket, buf, BUF_SZ);
      if (success &lt; 0)
        perror (&quot;read&quot;);

      /* <span class="roman">Save this data in the buffer list.</span>  */
      {
        struct buffer *link
          = (struct buffer *) xmalloc (sizeof (struct buffer));
        link-&gt;buf = buf;
        link-&gt;size = success;

        /* <span class="roman">Add the new link to the end of the list.</span>  */
        if (tail)
          tail-&gt;next = link;
        else
          list = link;
        tail = link;
      }
    }
}
</pre></div>

<hr>
<div class="header">
<p>上一篇： <a href="Server-Example.html#Server-Example" rel="prev" accesskey="p">服务器示例</a> ，上一篇： <a href="Connections.html#Connections" rel="up" accesskey="u">连接</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>