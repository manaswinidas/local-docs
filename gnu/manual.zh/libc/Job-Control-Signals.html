<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>作业控制信号（GNU C库）</title>

<meta name="description" content="Job Control Signals (The GNU C Library)">
<meta name="keywords" content="Job Control Signals (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Standard-Signals.html#Standard-Signals" rel="up" title="Standard Signals">
<link href="Operation-Error-Signals.html#Operation-Error-Signals" rel="next" title="Operation Error Signals">
<link href="Asynchronous-I_002fO-Signals.html#Asynchronous-I_002fO-Signals" rel="prev" title="Asynchronous I/O Signals">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Job-Control-Signals"></span><div class="header">
<p>下一篇： <a href="Operation-Error-Signals.html#Operation-Error-Signals" rel="next" accesskey="n">操作错误信号</a> ，上一篇： <a href="Asynchronous-I_002fO-Signals.html#Asynchronous-I_002fO-Signals" rel="prev" accesskey="p">异步I / O信号</a> ，上一篇： <a href="Standard-Signals.html#Standard-Signals" rel="up" accesskey="u">标准信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Job-Control-Signals-1"></span><h4 class="subsection">24.2.5作业控制信号</h4>
<span id="index-job-control-signals"></span>

<p>这些信号用于支持作业控制。如果您的系统不支持作业控制，则将定义这些宏，但是无法引发或处理信号本身。
</p>
<p>除非您真正了解工作控制的工作原理，否则通常应该不要理会这些信号。请参阅<a href="Job-Control.html#Job-Control">作业控制</a> 。
</p>
<dl>
<dt id="index-SIGCHLD">巨集： <em>int</em> <strong>SIGCHLD</strong></dt>
<dd>
<span id="index-child-process-signal"></span>
<p>每当其子进程之一终止或停止时，都会将该信号发送到父进程。
</p>
<p>此信号的默认操作是忽略它。如果在子进程已经终止但没有通过以下方式报告其状态时为该信号建立处理程序<code>wait</code>要么<code>waitpid</code> （请参阅“ <a href="Process-Completion.html#Process-Completion">进程完成”</a> ），新的处理程序是否适用于这些进程取决于特定的操作系统。
</p></dd></dl>

<dl>
<dt id="index-SIGCLD">巨集： <em>int</em> <strong>SIGCLD</strong></dt>
<dd>
<p>这是一个过时的名称<code>SIGCHLD</code> 。
</p></dd></dl>

<dl>
<dt id="index-SIGCONT">巨集： <em>int</em> <strong>SIGCONT</strong></dt>
<dd>
<span id="index-continue-signal"></span>
<p>您可以发送一个<code>SIGCONT</code>发出信号以使其继续进行。该信号很特殊-如果信号停止，则始终使过程继续，直到信号被传递为止。默认行为是什么也不做。您不能阻止此信号。您可以设置一个处理程序，但是<code>SIGCONT</code>始终使过程继续进行。
</p>
<p>大多数程序没有理由处理<code>SIGCONT</code> ;他们只是恢复执行而没有意识到他们曾经被停止过。您可以使用处理程序<code>SIGCONT</code>使程序在停止并继续执行时可以做一些特殊的事情，例如，在等待输入时在挂起时重新打印提示。
</p></dd></dl>

<dl>
<dt id="index-SIGSTOP">巨集： <em>int</em> <strong>SIGSTOP</strong></dt>
<dd>
<p>的<code>SIGSTOP</code>信号停止该过程。不能对其进行处理，忽略或阻止。
</p></dd></dl>
<span id="index-stop-signal"></span>

<dl>
<dt id="index-SIGTSTP">巨集： <em>int</em> <strong>SIGTSTP</strong></dt>
<dd>
<p>的<code>SIGTSTP</code> signal是一个交互式停止信号。不像<code>SIGSTOP</code> ，此信号可以处理和忽略。
</p>
<p>如果您特别需要在停止进程时将文件或系统表保持在安全状态，则程序应处理此信号。例如，关闭回声的程序应处理<code>SIGTSTP</code>因此他们可以在停止之前重新打开回声。
</p>
<p>当用户键入SUSP字符时（通常是<kbd>C-z</kbd> ）。有关终端驱动程序支持的更多信息，请参见<a href="Special-Characters.html#Special-Characters">特殊字符</a> 。
</p></dd></dl>
<span id="index-interactive-stop-signal"></span>

<dl>
<dt id="index-SIGTTIN">巨集： <em>int</em> <strong>SIGTTIN</strong></dt>
<dd>
<p>进程在作为后台作业运行时无法从用户终端读取。当后台作业中的任何进程尝试从终端读取时，作业中的所有进程都会发送给<code>SIGTTIN</code>信号。此信号的默认操作是停止该过程。有关它如何与终端驱动程序交互的更多信息，请参见<a href="Access-to-the-Terminal.html#Access-to-the-Terminal">访问终端</a> 。
</p></dd></dl>
<span id="index-terminal-input-signal"></span>

<dl>
<dt id="index-SIGTTOU">巨集： <em>int</em> <strong>SIGTTOU</strong></dt>
<dd>
<p>这类似于<code>SIGTTIN</code> ，但在后台作业中的进程尝试写入终端或设置其模式时生成。同样，默认操作是停止该过程。 <code>SIGTTOU</code>仅在尝试写入终端时生成<code>TOSTOP</code>设置输出模式；请参阅<a href="Output-Modes.html#Output-Modes">输出模式</a> 。
</p></dd></dl>
<span id="index-terminal-output-signal"></span>

<p>当一个进程停止时，除非继续执行，否则无法再传递任何信号给它<code>SIGKILL</code>信号和（显然） <code>SIGCONT</code>信号。信号被标记为未决，但直到继续处理才交付。的<code>SIGKILL</code>信号总是导致流程终止，并且不能被阻塞，处理或忽略。你可以忽略<code>SIGCONT</code> ，但是如果停止，它总是使该过程继续进行。发送一个<code>SIGCONT</code>给过程的信号导致该过程的任何挂起的停止信号被丢弃。同样，任何未决<code>SIGCONT</code>当某个过程的信号收到停止信号时，该信号将被丢弃。
</p>
<p>当孤立流程组（请参见<a href="Orphaned-Process-Groups.html#Orphaned-Process-Groups">孤立流程组</a> ）中的<a href="Orphaned-Process-Groups.html#Orphaned-Process-Groups">流程</a>收到<code>SIGTSTP</code> ， <code>SIGTTIN</code> ， 要么<code>SIGTTOU</code>信号并且不处理它，该过程不会停止。停止该进程可能不是很有用，因为没有外壳程序会注意到该进程已停止并允许用户继续执行。相反，会发生什么情况取决于您使用的操作系统。某些系统可能什么也不做。其他人可能会传递另一个信号，例如<code>SIGKILL</code>要么<code>SIGHUP</code> 。在GNU / Hurd系统上，进程死于<code>SIGKILL</code> ;这避免了系统周围存在许多已停止的孤立进程的问题。
</p>

<hr>
<div class="header">
<p>下一篇： <a href="Operation-Error-Signals.html#Operation-Error-Signals" rel="next" accesskey="n">操作错误信号</a> ，上一篇： <a href="Asynchronous-I_002fO-Signals.html#Asynchronous-I_002fO-Signals" rel="prev" accesskey="p">异步I / O信号</a> ，上一篇： <a href="Standard-Signals.html#Standard-Signals" rel="up" accesskey="u">标准信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>