<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>作业控制的概念（GNU C库）</title>

<meta name="description" content="Concepts of Job Control (The GNU C Library)">
<meta name="keywords" content="Concepts of Job Control (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Job-Control.html#Job-Control" rel="up" title="Job Control">
<link href="Controlling-Terminal.html#Controlling-Terminal" rel="next" title="Controlling Terminal">
<link href="Job-Control.html#Job-Control" rel="prev" title="Job Control">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Concepts-of-Job-Control"></span><div class="header">
<p>下一篇： <a href="Controlling-Terminal.html#Controlling-Terminal" rel="next" accesskey="n">控制终端</a> ，上一篇： <a href="Job-Control.html#Job-Control" rel="up" accesskey="u">作业控制</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Concepts-of-Job-Control-1"></span><h3 class="section">28.1工作控制的概念</h3>

<span id="index-shell"></span>
<p>交互式外壳程序的基本目的是从用户终端读取命令并创建进程以执行这些命令指定的程序。它可以使用<code>fork</code> （请参阅<a href="Creating-a-Process.html#Creating-a-Process">创建流程</a> ）和<code>exec</code> （请参阅<a href="Executing-a-File.html#Executing-a-File">执行文件</a> ）功能。
</p>
<p>单个命令可能只运行一个进程，但是一个命令通常会使用多个进程。如果您使用“ <samp>|</samp>在shell命令中使用'运算符，您可以在自己的进程中显式请求几个程序。但是，即使只运行一个程序，它也可以在内部使用多个进程。例如，只有一个编译命令，例如“ <samp>cc -c foo.c</samp>通常使用四个过程（尽管通常在任何给定时间只有两个）。如果你跑<code>make</code> ，其工作是在单独的进程中运行其他程序。
</p>
<p>属于单个命令的<em>进程</em>称为<em>进程组</em>或<em>作业</em> 。这样一来，您就可以一次对所有它们进行操作。例如，输入<kbd>C-c</kbd>发送信号<code>SIGINT</code>终止前台进程组中的所有进程。
</p>
<span id="index-session-1"></span>
<p><em>会话</em>是更大的一组进程。通常，一次登录产生的所有进程都属于同一会话。
</p>
<p>每个进程都属于一个进程组。创建流程后，该流程与其父流程成为同一流程组和会话的成员。您可以使用<code>setpgid</code>功能，前提是进程组属于同一会话。
</p>
<span id="index-session-leader"></span>
<p>将流程置于不同会话中的唯一方法是使用，使其成为新会话或<em>会话主持人</em>的初始流程。 <code>setsid</code>功能。这也将会话领导者置于新的流程组中，并且您无法将其再次移出该流程组。
</p>
<p>通常，新会话由系统登录程序创建，会话负责人是运行用户登录外壳程序的进程。
</p>
<span id="index-controlling-terminal"></span>
<p>支持作业控制的外壳必须安排控制可以随时使用终端的作业。否则，可能会有多个作业试图一次从终端读取，并且对于哪个进程应该接收用户键入的输入感到困惑。为避免这种情况，外壳程序必须使用本章中描述的协议与终端驱动程序配合使用。
</p>
<span id="index-foreground-job"></span>
<span id="index-background-job"></span>
<p>该外壳一次只能向一个过程组提供对控制终端的无限制访问。这称为该控制终端上的<em>前台作业</em> 。在没有对终端的这种访问的情况下执行的，由外壳程序管理的其他进程组称为<em>后台作业</em> 。
</p>
<span id="index-stopped-job"></span>
<p>如果后台作业需要从其控制终端读取，则由终端驱动程序<em>停止</em> ；如果<code>TOSTOP</code>设置模式，同样用于写入。用户可以通过键入SUSP字符（请参阅<a href="Special-Characters.html#Special-Characters">特殊字符</a> ）来停止前台作业，程序可以通过将其发送给用户来停止任何作业。 <code>SIGSTOP</code>信号。Shell的职责是通知作业何时停止，将其通知用户，并提供允许用户交互地继续停止的作业并在前台和后台之间切换作业的机制。
</p>
<p>有关<a href="Access-to-the-Terminal.html#Access-to-the-Terminal">访问</a>控制终端的I / O的更多信息，请参见<a href="Access-to-the-Terminal.html#Access-to-the-Terminal">访问</a>终端。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Controlling-Terminal.html#Controlling-Terminal" rel="next" accesskey="n">控制终端</a> ，上一篇： <a href="Job-Control.html#Job-Control" rel="up" accesskey="u">作业控制</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>