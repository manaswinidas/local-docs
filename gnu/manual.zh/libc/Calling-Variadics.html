<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>调用可变参数（GNU C库）</title>

<meta name="description" content="Calling Variadics (The GNU C Library)">
<meta name="keywords" content="Calling Variadics (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="How-Variadic.html#How-Variadic" rel="up" title="How Variadic">
<link href="Argument-Macros.html#Argument-Macros" rel="next" title="Argument Macros">
<link href="How-Many-Arguments.html#How-Many-Arguments" rel="prev" title="How Many Arguments">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Calling-Variadics"></span><div class="header">
<p>下一篇： <a href="Argument-Macros.html#Argument-Macros" rel="next" accesskey="n">参数宏</a> ，上一篇： <a href="How-Many-Arguments.html#How-Many-Arguments" rel="prev" accesskey="p">多少参数</a> ，上： <a href="How-Variadic.html#How-Variadic" rel="up" accesskey="u">可变</a> <a href="How-Many-Arguments.html#How-Many-Arguments" rel="prev" accesskey="p">参数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Calling-Variadic-Functions"></span><h4 class="subsubsection">A.2.2.4调用可变参数函数</h4>
<span id="index-variadic-functions_002c-calling"></span>
<span id="index-calling-variadic-functions"></span>
<span id="index-declaring-variadic-functions"></span>

<p>您不必执行任何特殊操作即可调用可变参数函数。像往常一样，只需将参数（必需的参数，后跟可选的参数）放在括号内，并以逗号分隔。但是您必须使用原型声明函数，并且知道如何转换参数值。
</p>
<p>原则上，每当调用函数时，也必须使用函数原型将<em>定义</em>为可变参数的函数<em>声明</em>为可变参数。（有关<a href="Variadic-Prototypes.html#Variadic-Prototypes">方法</a> ，请参见<a href="Variadic-Prototypes.html#Variadic-Prototypes">可变参数原型</a> 。）这是因为某些C编译器使用不同的调用约定将相同的参数值集传递给函数，具体取决于该函数采用可变参数还是固定参数。
</p>
<p>实际上，GNU C编译器始终以相同的方式传递给定的参数类型集，无论它们是可选的还是必需的。因此，只要参数类型是自提升的，您就可以放心地声明它们。通常，最好为可变参数函数以及所有函数声明参数类型。但是，有一些函数不必声明为可变参数就非常方便，例如， <code>open</code>和<code>printf</code> 。
</p>
<span id="index-default-argument-promotions"></span>
<span id="index-argument-promotion"></span>
<p>由于原型没有为可选参数指定类型，因此在对可变参数函数的调用中， <em>默认参数提升</em>是对可选参数值执行的。这意味着类型的对象<code>char</code>要么<code>short int</code> <!-- /@w --> （无论是否已签名）被提升为<code>int</code>要么<code>unsigned int</code> <!-- /@w --> ，视情况而定；那类型的对象<code>float</code>被提升为打字<code>double</code> 。因此，如果呼叫者通过<code>char</code>作为可选参数，它被提升为<code>int</code> ，并且该函数可以通过<code>va_arg (<var>ap</var>, int)</code> 。
</p>
<p>所需参数的转换由函数原型以通常的方式控制：将参数表达式转换为声明的参数类型，就像将其分配给该类型的变量一样。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Argument-Macros.html#Argument-Macros" rel="next" accesskey="n">参数宏</a> ，上一篇： <a href="How-Many-Arguments.html#How-Many-Arguments" rel="prev" accesskey="p">多少参数</a> ，上： <a href="How-Variadic.html#How-Variadic" rel="up" accesskey="u">可变</a> <a href="How-Many-Arguments.html#How-Many-Arguments" rel="prev" accesskey="p">参数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>