<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>密码存储（GNU C库）</title>

<meta name="description" content="Passphrase Storage (The GNU C Library)">
<meta name="keywords" content="Passphrase Storage (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Cryptographic-Functions.html#Cryptographic-Functions" rel="up" title="Cryptographic Functions">
<link href="Unpredictable-Bytes.html#Unpredictable-Bytes" rel="next" title="Unpredictable Bytes">
<link href="Cryptographic-Functions.html#Cryptographic-Functions" rel="prev" title="Cryptographic Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Passphrase-Storage"></span><div class="header">
<p>下一页： <a href="Unpredictable-Bytes.html#Unpredictable-Bytes" rel="next" accesskey="n">不可预测的字节</a> ，向上： <a href="Cryptographic-Functions.html#Cryptographic-Functions" rel="up" accesskey="u">加密函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Passphrase-Storage-1"></span><h3 class="section">33.1密码存储</h3>
<span id="index-passphrase-hashing"></span>
<span id="index-one_002dway-hashing"></span>
<span id="index-hashing_002c-passphrase"></span>

<p>有时，必须确保用户被授权使用计算机提供的某些服务，例如，以特定的用户ID登录（请参阅<a href="Users-and-Groups.html#Users-and-Groups">Users and Groups</a> ）。一种传统的方式是让每个用户选择一个秘密<em>密码</em> 。然后，系统可以询问声称是用户的某人该用户的密码，如果该人提供了正确的密码，则系统可以授予适当的特权。（传统上，这些被称为“密码”，但是如今一个单词太容易猜到了。）
</p>
<p>处理密码短语的程序必须格外小心，无论如何都不要透露给任何人。仅将它们保留在只有特殊特权才能访问的文件中是不够的。该文件可能是由于错误或配置错误而“泄露”的，即使系统管理员出于某种原因不得不编辑该文件，也不应该了解每个人的口令。为避免这种情况，在存储密码短语之前，还应使用<em>单向函数</em>将其转换为<em>单向哈希</em> 。
</p>
<p>单向函数很容易计算，但是没有已知的方法可以计算其逆函数。这意味着系统可以通过对密码进行散列并将结果与存储的散列进行比较，从而轻松检查密码。但是，发现某人的密码短语哈希的攻击者只能通过猜测和检查来发现与之对应的密码短语。除了最明显的猜测之外，单向函数的设计目的是使此过程不切实际地变慢。（请勿使用字典中的单词作为密码。）
</p>
<p>GNU C库提供了一个基于SHA-2-512，SHA-2-256，MD5和DES密码原语的四个单向函数的接口。新的密码短语应使用基于SHA的函数之一进行哈希处理。其他的对于新设置的密码短语来说太弱了，但是我们继续支持它们来验证旧的密码短语。基于DES的哈希值特别弱，因为它会忽略输入的前八个字符以外的所有字符。
</p>
<dl>
<dt id="index-crypt">函数： <em>char *</em> <strong>crypt</strong> <em>（const char * <var>phrase</var> ，const char * <var>salt</var> ）</em></dt>
<dd>

<p>初步： MT不安全种族：crypt | AS不安全损坏的锁定堆dlopen | AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>


<p>功能<code>crypt</code>转换密码短语字符串， <var>phrase</var> ，变成适合存储在用户数据库中的单向哈希。它返回的字符串将完全由可打印的ASCII字符组成。它不会包含空格，也不会包含任何字符' <samp>:</samp> '，' <samp>;</samp> '，' <samp>*</samp> '，' <samp>!</samp> '， 要么 ' <samp>\</samp> '。
</p>
<p>的<var>salt</var>参数控制使用哪种单向功能，并且即使每个用户具有相同的密码，也可以确保单向功能的输出是不同的。这使得很难从大型用户数据库中猜测密码短语。没有盐，攻击者可以猜测，逃跑<code>crypt</code>一次，然后将结果与所有哈希进行比较。盐迫使攻击者单独发出呼叫<code>crypt</code>对于每个用户。
</p>
<p>要验证密码，请将先前哈希的密码作为<var>salt</var> 。要散列用于存储的新密码，请设置<var>salt</var>根据此表，将其转换为包含前缀和一系列随机选择的字符的字符串：</p>
<table>
<thead><tr><th width="20%">单向功能</th><th width="10%">字首</th><th width="30%">随机序列</th></tr></thead>
<tbody><tr><td width="20%">SHA-2-512</td><td width="10%">' <samp>$6$</samp> '</td><td width="30%">16个字符</td></tr>
<tr><td width="20%">SHA-2-256</td><td width="10%">' <samp>$5$</samp> '</td><td width="30%">16个字符</td></tr>
<tr><td width="20%">MD5</td><td width="10%">' <samp>$1$</samp> '</td><td width="30%">8个字符</td></tr>
<tr><td width="20%">DES</td><td width="10%">' <samp></samp> '</td><td width="30%">2个字符</td></tr>
</tbody></table>

<p>在所有情况下，应从字母中选择随机字符<code>./0-9A-Za-z</code> 。
</p>
<p>使用<em>除</em> DES <em>之外的</em>所有哈希函数， <var>phrase</var>可以任意长，每个字节的所有八位都是有效的。使用DES时，仅前八个字符<var>phrase</var>影响输出，每个字节的第八位也被忽略。
</p>
<p><code>crypt</code>会失败。一些实现返回<code>NULL</code>失败时，其他人返回<em>无效的</em>哈希密码，该密码将以“ <samp>*</samp> '并且不会与<var>salt</var> 。在任一情况下， <code>errno</code>将设置为指示问题。一些可能的错误代码是：</p>
<dl compact>
<dt><code>EINVAL</code></dt>
<dd><p><var>salt</var>是无效的;对于任何受支持的哈希函数，既不是以前哈希的密码短语，也不是格式正确的新盐。
</p>
</dd>
<dt><code>EPERM</code></dt>
<dd><p>系统配置禁止使用由选择的哈希函数<var>salt</var> 。
</p>
</dd>
<dt><code>ENOMEM</code></dt>
<dd><p>无法分配内部暂存存储。
</p>
</dd>
<dt><code>ENOSYS</code></dt>
<dt><code>EOPNOTSUPP</code></dt>
<dd><p>完全不支持散列密码，或者不支持由<var>salt</var>不支持。GNU C库不使用这些错误代码，但是在其他操作系统上可能会遇到它们。
</p></dd>
</dl>

<p><code>crypt</code>对内部暂存及其返回的字符串均使用静态存储。打电话不安全<code>crypt</code>从多个线程同时访问，返回的字符串将被随后的任何调用覆盖<code>crypt</code> 。
</p>
<p><code>crypt</code>在X / Open可移植性指南中指定，并且几乎在所有历史Unix系统中都存在。但是，XPG没有指定任何单向功能。
</p>
<p><code>crypt</code>在中声明<samp>unistd.h</samp> 。GNU C库也在中声明了此函数<samp>crypt.h</samp> 。
</p></dd></dl>

<dl>
<dt id="index-crypt_005fr">功能： <em>char *</em> <strong>crypt_r</strong> <em>（const char * <var>phrase</var> ，const char * <var>salt</var> ，struct crypt_data * <var>data</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS不安全损坏的锁定堆dlopen | AC不安全锁记忆|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<span id="index-struct-crypt_005fdata"></span>

<p>功能<code>crypt_r</code>是的线程安全版本<code>crypt</code> 。它使用静态存储所指向的内存，而不是静态存储<var>data</var>草稿及其返回的字符串的参数。只要不同，就可以安全地从多个线程使用它<var>data</var>每个线程中使用对象。它返回的字符串仍将被另一个相同的调用覆盖<var>data</var> 。
</p>
<p><var>data</var>必须指向一个<code>struct crypt_data</code>调用者分配的对象。的所有领域<code>struct crypt_data</code>是私有的，但是在第一次使用其中一个对象之前，必须使用以下命令将其初始化为全零<code>memset</code>或类似。之后，它可以重复用于许多对<code>crypt_r</code>无需再次擦除。 <code>struct crypt_data</code>是很大的，所以最好用<code>malloc</code>而不是作为局部变量。请参阅<a href="Memory-Allocation.html#Memory-Allocation">内存分配</a> 。
</p>
<p><code>crypt_r</code>是GNU扩展。声明在<samp>crypt.h</samp> ，原样<code>struct crypt_data</code> 。
</p></dd></dl>

<p>以下程序显示如何使用<code>crypt</code>第一次输入密码。它用<code>getentropy</code>使盐尽可能不可预测；请参见<a href="Unpredictable-Bytes.html#Unpredictable-Bytes">不可预测的字节</a> 。
</p>
<div class="example">
<pre class="example">

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;crypt.h&gt;

int
main(void)
{
  unsigned char ubytes[16];
  char salt[20];
  const char *const saltchars =
    &quot;./0123456789ABCDEFGHIJKLMNOPQRST&quot;
    &quot;UVWXYZabcdefghijklmnopqrstuvwxyz&quot;;
  char *hash;
  int i;

  /* <span class="roman">Retrieve 16 unpredictable bytes from the operating system.</span> */
  if (getentropy (ubytes, sizeof ubytes))
    {
      perror (&quot;getentropy&quot;);
      return 1;
    }

  /* <span class="roman">Use them to fill in the salt string.</span> */
  salt[0] = '$';
  salt[1] = '5'; /* <span class="roman">SHA-256</span> */
  salt[2] = '$';
  for (i = 0; i &lt; 16; i++)
    salt[3+i] = saltchars[ubytes[i] &amp; 0x3f];
  salt[3+i] = '\0';

  /* <span class="roman">Read in the user&rsquo;s passphrase and hash it.</span> */
  hash = crypt (getpass (&quot;Enter new passphrase: &quot;), salt);
  if (!hash || hash[0] == '*')
    {
      perror (&quot;crypt&quot;);
      return 1;
    }

  /* <span class="roman">Print the results.</span> */
  puts (hash);
  return 0;
}
</pre></div>

<p>下一个程序演示了如何验证密码。它检查硬编码到程序中的哈希，因为查找真实用户的哈希密码可能需要特殊的特权（请参阅<a href="User-Database.html#User-Database">User Database</a> ）。它还表明，对于相同的密码短语，不同的单向函数会产生不同的哈希值。
</p>
<div class="example">
<pre class="example">

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;crypt.h&gt;

/* <span class="roman">&lsquo;<samp>GNU's Not Unix</samp>&rsquo; hashed using SHA-256, MD5, and DES.</span> */
static const char hash_sha[] =
  &quot;$5$DQ2z5NHf1jNJnChB$kV3ZTR0aUaosujPhLzR84Llo3BsspNSe4/tsp7VoEn6&quot;;
static const char hash_md5[] = &quot;$1$A3TxDv41$rtXVTUXl2LkeSV0UU5xxs1&quot;;
static const char hash_des[] = &quot;FgkTuF98w5DaI&quot;;

int
main(void)
{
  char *phrase;
  int status = 0;

  /* <span class="roman">Prompt for a passphrase.</span> */
  phrase = getpass (&quot;Enter passphrase: &quot;);

  /* <span class="roman">Compare against the stored hashes.  Any input that begins with
     &lsquo;<samp>GNU's No</samp>&rsquo; will match the DES hash, but the other two will
     only match &lsquo;<samp>GNU's Not Unix</samp>&rsquo;.</span> */

  if (strcmp (crypt (phrase, hash_sha), hash_sha))
    {
      puts (&quot;SHA: not ok&quot;);
      status = 1;
    }
  else
    puts (&quot;SHA: ok&quot;);

  if (strcmp (crypt (phrase, hash_md5), hash_md5))
    {
      puts (&quot;MD5: not ok&quot;);
      status = 1;
    }
  else
    puts (&quot;MD5: ok&quot;);

  if (strcmp (crypt (phrase, hash_des), hash_des))
    {
      puts (&quot;DES: not ok&quot;);
      status = 1;
    }
  else
    puts (&quot;DES: ok&quot;);

  return status;
}
</pre></div>

<hr>
<div class="header">
<p>下一页： <a href="Unpredictable-Bytes.html#Unpredictable-Bytes" rel="next" accesskey="n">不可预测的字节</a> ，向上： <a href="Cryptographic-Functions.html#Cryptographic-Functions" rel="up" accesskey="u">加密函数</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>