<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>整理函数（GNU C库）</title>

<meta name="description" content="Collation Functions (The GNU C Library)">
<meta name="keywords" content="Collation Functions (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Search-Functions.html#Search-Functions" rel="next" title="Search Functions">
<link href="String_002fArray-Comparison.html#String_002fArray-Comparison" rel="prev" title="String/Array Comparison">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Collation-Functions"></span><div class="header">
<p>下一页： <a href="Search-Functions.html#Search-Functions" rel="next" accesskey="n">搜索函数</a> ，上一篇： <a href="String_002fArray-Comparison.html#String_002fArray-Comparison" rel="prev" accesskey="p">字符串/数组比较</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用工具</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Collation-Functions-1"></span><h3 class="section">5.8整理功能</h3>

<span id="index-collating-strings"></span>
<span id="index-string-collation-functions"></span>

<p>在某些语言环境中，按字母顺序排序的约定与字符代码的严格数字顺序不同。例如，在西班牙语中，出于校对的目的，大多数带有变音符号（如重音符号）的字形都不被视为不同的字母。另一方面，两个字符的序列“ <samp>ll</samp> '被视为紧接在'之后的单个字母<samp>l</samp> '。
</p>
<p>您可以使用功能<code>strcoll</code>和<code>strxfrm</code> （在头文件中声明<samp>string.h</samp> ）和<code>wcscoll</code>和<code>wcsxfrm</code> （在头文件中声明<samp>wchar</samp> ），以使用适合当前语言环境的排序规则来比较字符串。这些功能特别使用的语言环境可以通过设置<code>LC_COLLATE</code>类别;请参阅<a href="Locales.html#Locales">语言环境</a> 。
<span id="index-string_002eh-4"></span>
<span id="index-wchar_002eh-2"></span>
</p>
<p>在标准C语言环境中，整理顺序为<code>strcoll</code>与...相同<code>strcmp</code> 。同样， <code>wcscoll</code>和<code>wcscmp</code>在这种情况下是相同的。
</p>
<p>实际上，这些功能的工作方式是通过应用映射将多字节字符串中的字符转换为表示该字符串在当前语言环境的整理序列中的位置的字节序列。以简单的方式比较两个这样的字节序列等效于将字符串与语言环境的整理序列进行比较。
</p>
<p>功能<code>strcoll</code>和<code>wcscoll</code>为了进行一次比较，隐式执行此转换。相比之下， <code>strxfrm</code>和<code>wcsxfrm</code>明确执行映射。如果您使用相同的字符串或一组字符串进行多个比较，则使用起来可能更有效<code>strxfrm</code>要么<code>wcsxfrm</code>一次转换所有字符串，然后将转换后的字符串与<code>strcmp</code>要么<code>wcscmp</code> 。
</p>
<dl>
<dt id="index-strcoll">函数： <em>int</em> <strong>strcoll</strong> <em>（const char * <var>s1</var> ，const char * <var>s2</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>strcoll</code>功能类似于<code>strcmp</code>但使用当前语言环境的整理顺序进行整理（ <code>LC_COLLATE</code>语言环境）。参数是多字节字符串。
</p></dd></dl>

<dl>
<dt id="index-wcscoll">函数： <em>int</em> <strong>wcscoll</strong> <em>（const wchar_t * <var>ws1</var> ，const wchar_t * <var>ws2</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>的<code>wcscoll</code>功能类似于<code>wcscmp</code>但使用当前语言环境的整理顺序进行整理（ <code>LC_COLLATE</code>语言环境）。
</p></dd></dl>

<p>这是一个使用字符串对数组进行排序的示例<code>strcoll</code>比较它们。实际的排序算法未在此处编写；它来自<code>qsort</code> （请参阅<a href="Array-Sort-Function.html#Array-Sort-Function">数组排序功能</a> ）。此处显示的代码的工作是说如何在对字符串进行排序时比较它们。（在本节的后面，我们将展示一种使用<code>strxfrm</code> ）
</p>
<div class="example">
<pre class="example">/* <span class="roman">This is the comparison function used with <code>qsort</code>.</span> */

int
compare_elements (const void *v1, const void *v2)
{
  char * const *p1 = v1;
  char * const *p2 = v2;

  return strcoll (*p1, *p2);
}

/* <span class="roman">This is the entry point&mdash;the function to sort</span>
   <span class="roman">strings using the locale&rsquo;s collating sequence.</span> */

void
sort_strings (char **array, int nstrings)
{
  /* <span class="roman">Sort <code>temp_array</code> by comparing the strings.</span> */
  qsort (array, nstrings,
         sizeof (char *), compare_elements);
}
</pre></div>

<span id="index-converting-string-to-collation-order"></span>
<dl>
<dt id="index-strxfrm">功能： <em>size_t</em> <strong>strxfrm</strong> <em>（char * restrict <var>to</var> ，const char *限制<var>from</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>strxfrm</code>转换多字节字符串<var>from</var>使用由当前选择用于排序规则的语言环境确定的排序规则转换，并将转换后的字符串存储在数组中<var>to</var> 。取决于<var>size</var>字节（包括终止的空字节）被存储。
</p>
<p>如果字符串，则行为未定义<var>to</var>和<var>from</var>交叠;请参见<a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays">复制字符串和数组</a> 。
</p>
<p>返回值是整个转换后的字符串的长度。此值不受以下值的影响<var>size</var> ，但大于或等于<var>size</var> ，则表示转换后的字符串不完全适合数组<var>to</var> 。在这种情况下，仅存储了尽可能多的实际字符串。要获取整个转换后的字符串，请调用<code>strxfrm</code>再次使用更大的输出数组。
</p>
<p>转换后的字符串可能比原始字符串更长，也可能更短。
</p>
<p>如果<var>size</var>为零，不存储任何字节<var>to</var> 。在这种情况下， <code>strxfrm</code>简单地返回将是转换后的字符串的长度的字节数。这对于确定分配的数组应为多少大小很有用。没关系<var>to</var>如果<var>size</var>为零； <var>to</var>甚至可以是空指针。
</p></dd></dl>

<dl>
<dt id="index-wcsxfrm">函数： <em>size_t</em> <strong>wcsxfrm</strong> <em>（wchar_t *限制<var>wto</var> ，const wchar_t * <var>wfrom</var> ，size_t <var>size</var> ）</em></dt>
<dd>
<p>初步： MT安全区域| AS不安全堆| AC不安全的内存|请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>功能<code>wcsxfrm</code>转换宽字符串<var>wfrom</var>使用由当前选择用于排序规则的语言环境确定的排序规则转换，并将转换后的字符串存储在数组中<var>wto</var> 。取决于<var>size</var>存储宽字符（包括终止的空宽字符）。
</p>
<p>如果字符串，则行为未定义<var>wto</var>和<var>wfrom</var>交叠;请参见<a href="Copying-Strings-and-Arrays.html#Copying-Strings-and-Arrays">复制字符串和数组</a> 。
</p>
<p>返回值是整个转换后的宽字符串的长度。此值不受以下值的影响<var>size</var> ，但大于或等于<var>size</var> ，则表示转换后的宽字符串不完全适合数组<var>wto</var> 。在这种情况下，仅存储实际适合的宽字符串。要获取整个转换后的宽字符串，请致电<code>wcsxfrm</code>再次使用更大的输出数组。
</p>
<p>转换后的宽字符串可能比原始宽字符串更长，也可能更短。
</p>
<p>如果<var>size</var>为零，不存储宽字符<var>to</var> 。在这种情况下， <code>wcsxfrm</code>只需返回宽字符的数量，该数量就是转换后的宽字符串的长度。这对于确定分配的数组应为多少大小很有用（记住要乘以<code>sizeof (wchar_t)</code> ）。没关系<var>wto</var>如果<var>size</var>为零； <var>wto</var>甚至可以是空指针。
</p></dd></dl>

<p>这是一个如何使用的例子<code>strxfrm</code>当您计划进行许多比较时。它执行与上一个示例相同的操作，但是速度更快，因为它只需转换每个字符串一次，而不管它与其他字符串相比要转换多少次。即使有很多字符串，分配和释放存储所需的时间也比我们节省的时间少得多。
</p>
<div class="example">
<pre class="example">struct sorter { char *input; char *transformed; };

/* <span class="roman">This is the comparison function used with <code>qsort</code></span>
   <span class="roman">to sort an array of <code>struct sorter</code>.</span> */

int
compare_elements (const void *v1, const void *v2)
{
  const struct sorter *p1 = v1;
  const struct sorter *p2 = v2;

  return strcmp (p1-&gt;transformed, p2-&gt;transformed);
}

/* <span class="roman">This is the entry point&mdash;the function to sort</span>
   <span class="roman">strings using the locale&rsquo;s collating sequence.</span> */

void
sort_strings_fast (char **array, int nstrings)
{
  struct sorter temp_array[nstrings];
  int i;

  /* <span class="roman">Set up <code>temp_array</code>.  Each element contains</span>
     <span class="roman">one input string and its transformed string.</span> */
  for (i = 0; i &lt; nstrings; i++)
    {
      size_t length = strlen (array[i]) * 2;
      char *transformed;
      size_t transformed_length;

      temp_array[i].input = array[i];

      /* <span class="roman">First try a buffer perhaps big enough.</span>  */
      transformed = (char *) xmalloc (length);

      /* <span class="roman">Transform <code>array[i]</code>.</span>  */
      transformed_length = strxfrm (transformed, array[i], length);

      /* <span class="roman">If the buffer was not large enough, resize it</span>
         <span class="roman">and try again.</span>  */
      if (transformed_length &gt;= length)
        {
          /* <span class="roman">Allocate the needed space. +1 for terminating</span>
             <span class="roman"><code>'\0'</code> byte.</span>  */
          transformed = (char *) xrealloc (transformed,
                                           transformed_length + 1);

          /* <span class="roman">The return value is not interesting because we know</span>
             <span class="roman">how long the transformed string is.</span>  */
          (void) strxfrm (transformed, array[i],
                          transformed_length + 1);
        }

      temp_array[i].transformed = transformed;
    }

  /* <span class="roman">Sort <code>temp_array</code> by comparing transformed strings.</span> */
  qsort (temp_array, nstrings,
         sizeof (struct sorter), compare_elements);

  /* <span class="roman">Put the elements back in the permanent array</span>
     <span class="roman">in their sorted order.</span> */
  for (i = 0; i &lt; nstrings; i++)
    array[i] = temp_array[i].input;

  /* <span class="roman">Free the strings we allocated.</span> */
  for (i = 0; i &lt; nstrings; i++)
    free (temp_array[i].transformed);
}
</pre></div>

<p>该代码对于宽字符版本的有趣部分如下所示：</p>
<div class="example">
<pre class="example">void
sort_strings_fast (wchar_t **array, int nstrings)
{
  &hellip;
      /* <span class="roman">Transform <code>array[i]</code>.</span>  */
      transformed_length = wcsxfrm (transformed, array[i], length);

      /* <span class="roman">If the buffer was not large enough, resize it</span>
         <span class="roman">and try again.</span>  */
      if (transformed_length &gt;= length)
        {
          /* <span class="roman">Allocate the needed space. +1 for terminating</span>
             <span class="roman"><code>L'\0'</code> wide character.</span>  */
          transformed = (wchar_t *) xrealloc (transformed,
                                              (transformed_length + 1)
                                              * sizeof (wchar_t));

          /* <span class="roman">The return value is not interesting because we know</span>
             <span class="roman">how long the transformed string is.</span>  */
          (void) wcsxfrm (transformed, array[i],
                          transformed_length + 1);
        }
  &hellip;
</pre></div>

<p>注意与<code>sizeof (wchar_t)</code>在里面<code>realloc</code>呼叫。
</p>
<p><strong>兼容性说明：</strong>字符串整理功能是ISO C90 <!-- /@w -->的新功能。较旧的C语言方言没有等效功能。宽字符版本是在ISO C90 <!-- /@w -->修订1 <!-- /@w -->中引入的。
</p>
<hr>
<div class="header">
<p>下一页： <a href="Search-Functions.html#Search-Functions" rel="next" accesskey="n">搜索函数</a> ，上一篇： <a href="String_002fArray-Comparison.html#String_002fArray-Comparison" rel="prev" accesskey="p">字符串/数组比较</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用工具</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>