<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>传统调度简介（GNU C库）</title>

<meta name="description" content="Traditional Scheduling Intro (The GNU C Library)">
<meta name="keywords" content="Traditional Scheduling Intro (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Traditional-Scheduling.html#Traditional-Scheduling" rel="up" title="Traditional Scheduling">
<link href="Traditional-Scheduling-Functions.html#Traditional-Scheduling-Functions" rel="next" title="Traditional Scheduling Functions">
<link href="Traditional-Scheduling.html#Traditional-Scheduling" rel="prev" title="Traditional Scheduling">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Traditional-Scheduling-Intro"></span><div class="header">
<p>下一页： <a href="Traditional-Scheduling-Functions.html#Traditional-Scheduling-Functions" rel="next" accesskey="n">传统的调度功能</a> ，最多： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="up" accesskey="u">传统的计划</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Introduction-To-Traditional-Scheduling"></span><h4 class="subsubsection">22.3.4.1传统计划简介</h4>

<p>在没有绝对优先级之前（请参阅<a href="Absolute-Priority.html#Absolute-Priority">绝对优先级</a> ），Unix系统正在使用该系统调度CPU。当POSIX像罗马人一样出现并强加了绝对优先级以适应实时处理的需求时，它离开了本地的绝对优先级零流程来通过自己熟悉的调度策略来管理自己。
</p>
<p>实际上，目前在许多系统上都没有高于零的绝对优先级，并且当它们存在时通常不使用它们，主要用于实时处理的计算机。因此，本节描述了许多程序员唯一需要关注的调度。
</p>
<p>但是，要清楚了解此调度的范围：任何时候，绝对优先级为0的进程和绝对优先级高于0的进程准备好同时运行时，绝对优先级为0的进程就不会运行。如果更高优先级的准备运行过程已经存在时，它已经在运行，它将立即停止。
</p>
<p>除了其绝对优先级为零外，每个进程还具有另一个优先级，我们将其称为“动态优先级”，因为它随时间而变化。对于绝对优先级高于零的过程，动态优先级没有意义。
</p>
<p>动态优先级有时会确定谁获得下一次启动CPU的机会。有时，它确定转弯持续多长时间。有时，它确定一个进程是否可以将另一个进程踢出CPU。</p>
<p>在Linux中，该值是这些因素的组合，但大多数情况下，它仅确定时间片的长度。进程的动态优先级越高，获得优先权的镜头就越长。如果在放弃CPU进行诸如等待I / O之类的操作之前没有用完时间片，则最好在准备好CPU时将其取回，以完成其时间片。除此之外，选择新时间片的过程基本上是循环的。但是调度程序确实会给低优先级进程带来麻烦：进程的动态优先级每次在调度进程中被缓冲时都会增加。在Linux中，即使是胖子也可以玩。
</p>
<p>流程动态优先级的波动由另一个值调节：“好”值。nice值是一个整数，通常在-20到20的范围内，代表进程动态优先级的上限。好的数字越高，该限制越低。
</p>
<p>例如，在典型的Linux系统上，一个值为20的进程一次只能在CPU上获得10毫秒，而一个值为-20的进程可以一次获得400毫秒的足够高的优先级。
</p>
<p>好的价值的想法是礼貌的礼貌。最初，在Eden的Unix花园中，所有进程在计算机系统的支持下均等地共享。但是并非所有进程都确实需要相同的CPU时间份额，因此，良好的价值赋予了礼貌的进程拒绝其他人可能繁荣的相等CPU时间份额的能力。因此，过程的好值越高，过程就越好。（然后，一条蛇来了，并给某些进程带来了负面的好价值，该系统成为了我们今天所知道的最重要的资源分配系统。）
</p>
<p>动态优先级倾向于向上和向下，其目的是使CPU时间分配更加平滑，并对不频繁的请求提供快速响应时间。但是它们永远不会超出其良好限制，因此在负载很重的CPU上，良好值可以有效地确定进程运行的速度。
</p>
<p>与Unix进程优先级的社会主义传统保持一致，进程以与父进程相同的良好价值开始生命，并且可以随意提高它的价值。一个进程还可以提高同一用户（或有效用户）拥有的任何其他进程的不错的价值。但是，只有特权进程才能降低其良好的价值。特权进程还可以提高或降低另一个进程的价值。
</p>
<p>有关获取和设置良好值的GNU C库函数，请参见“ <a href="Traditional-Scheduling-Functions.html#Traditional-Scheduling-Functions">传统调度功能”</a>中的描述。
</p>
<hr>
<div class="header">
<p>下一页： <a href="Traditional-Scheduling-Functions.html#Traditional-Scheduling-Functions" rel="next" accesskey="n">传统的调度功能</a> ，最多： <a href="Traditional-Scheduling.html#Traditional-Scheduling" rel="up" accesskey="u">传统的计划</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">内容</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>