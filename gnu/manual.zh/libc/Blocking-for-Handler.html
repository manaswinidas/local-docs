<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>处理程序的阻塞（GNU C库）</title>

<meta name="description" content="Blocking for Handler (The GNU C Library)">
<meta name="keywords" content="Blocking for Handler (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Blocking-Signals.html#Blocking-Signals" rel="up" title="Blocking Signals">
<link href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="next" title="Checking for Pending Signals">
<link href="Testing-for-Delivery.html#Testing-for-Delivery" rel="prev" title="Testing for Delivery">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Blocking-for-Handler"></span><div class="header">
<p>下一篇： <a href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="next" accesskey="n">检查待处理信号</a> ，上一篇： <a href="Testing-for-Delivery.html#Testing-for-Delivery" rel="prev" accesskey="p">交付测试</a> ，上一篇： <a href="Blocking-Signals.html#Blocking-Signals" rel="up" accesskey="u">阻塞信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Blocking-Signals-for-a-Handler"></span><h4 class="subsection">24.7.5处理程序的阻塞信号</h4>
<span id="index-blocking-signals_002c-in-a-handler"></span>

<p>调用信号处理程序时，通常希望它能够完成而不会被另一个信号中断。从处理程序启动到完成为止，您必须阻止可能混淆或破坏其数据的信号。
</p>
<p>当在信号上调用处理程序函数时，在处理程序运行期间，该信号（除了已在进程的信号掩码中的任何其他信号之外）都会被自动阻止。如果您为<code>SIGTSTP</code>例如，那么该信号的到来将进一步推动<code>SIGTSTP</code>表示要在处理程序执行期间等待。
</p>
<p>但是，默认情况下，不会阻止其他类型的信号。它们可以在处理程序执行期间到达。
</p>
<p>在处理程序执行期间阻止其他类型信号的可靠方法是使用<code>sa_mask</code>的成员<code>sigaction</code>结构体。
</p>
<p>这是一个例子：</p>
<div class="example">
<pre class="example">#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;

void catch_stop ();

void
install_handler (void)
{
  struct sigaction setup_action;
  sigset_t block_mask;

  sigemptyset (&amp;block_mask);
  /* <span class="roman">Block other terminal-generated signals while handler runs.</span> */
  sigaddset (&amp;block_mask, SIGINT);
  sigaddset (&amp;block_mask, SIGQUIT);
  setup_action.sa_handler = catch_stop;
  setup_action.sa_mask = block_mask;
  setup_action.sa_flags = 0;
  sigaction (SIGTSTP, &amp;setup_action, NULL);
}
</pre></div>

<p>这比在处理程序的代码中显式阻塞其他信号更可靠。如果在处理程序中显式阻塞信号，则无法避免在处理程序的开始至少间隔很短的时间（尚未阻塞信号）。
</p>
<p>您不能使用此机制从进程的当前掩码中删除信号。但是，您可以拨打<code>sigprocmask</code>在您的处理程序中根据需要阻止或取消阻止信号。
</p>
<p>无论如何，当处理程序返回时，系统将还原进入处理程序之前的掩码。如果有任何未通过此恢复解除阻塞的信号挂起，则该过程将立即返回这些信号，然后返回被中断的代码。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Checking-for-Pending-Signals.html#Checking-for-Pending-Signals" rel="next" accesskey="n">检查待处理信号</a> ，上一篇： <a href="Testing-for-Delivery.html#Testing-for-Delivery" rel="prev" accesskey="p">交付测试</a> ，上一篇： <a href="Blocking-Signals.html#Blocking-Signals" rel="up" accesskey="u">阻塞信号</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>