<html ><!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.30.

Copyright (C) 1993-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." --><!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>编码二进制数据（GNU C库）</title>

<meta name="description" content="Encode Binary Data (The GNU C Library)">
<meta name="keywords" content="Encode Binary Data (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" title="String and Array Utilities">
<link href="Argz-and-Envz-Vectors.html#Argz-and-Envz-Vectors" rel="next" title="Argz and Envz Vectors">
<link href="Obfuscating-Data.html#Obfuscating-Data" rel="prev" title="Obfuscating Data">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="zh-Hans" >
<span id="Encode-Binary-Data"></span><div class="header">
<p>下一篇： <a href="Argz-and-Envz-Vectors.html#Argz-and-Envz-Vectors" rel="next" accesskey="n">Argz和Envz向量</a> ，上<a href="Argz-and-Envz-Vectors.html#Argz-and-Envz-Vectors" rel="next" accesskey="n">一篇</a> ： <a href="Obfuscating-Data.html#Obfuscating-Data" rel="prev" accesskey="p">混淆数据</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>
<hr>
<span id="Encode-Binary-Data-1"></span><h3 class="section">5.14编码二进制数据</h3>

<p>为了在仅支持文本的环境中存储或传输二进制数据，必须通过将输入字节映射到允许存储或传输范围内的字节来对二进制数据进行编码。SVID系统（以及如今的XPG兼容系统）为该任务提供的支持最少。
</p>
<dl>
<dt id="index-l64a">函数： <em>char *</em> <strong>l64a</strong> <em>（长整数<var>n</var> ）</em></dt>
<dd>
<p>初步： MT不安全种族：l64a | AS不安全|交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>此函数使用基本字符集中的字节对32位输入值进行编码。它返回一个指向7字节缓冲区的指针，该缓冲区包含的编码版本<var>n</var> 。要编码一系列字节，用户必须将返回的字符串复制到目标缓冲区。如果返回，则返回空字符串<var>n</var>为零，这有点奇怪，但受标准要求。<br>
<strong>警告：</strong>由于使用了静态缓冲区，因此不应在多线程程序中使用此功能。C库中没有该函数的线程安全替代方法。<br>
<strong>兼容性说明：</strong> XPG标准指出<code>l64a</code>未定义，如果<var>n</var>是负面的。在GNU实现中， <code>l64a</code>将其参数视为无符号，因此它将为任何非零返回明智的编码<var>n</var> ;但是，可移植程序不应依赖于此。
</p>
<p>编码大缓冲区<code>l64a</code>必须在循环中调用一次，缓冲区的每个32位字一次。例如，一个人可以做这样的事情：</p>
<div class="example">
<pre class="example">char *
encode (const void *buf, size_t len)
{
  /* <span class="roman">We know in advance how long the buffer has to be.</span> */
  unsigned char *in = (unsigned char *) buf;
  char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
  char *cp = out, *p;

  /* <span class="roman">Encode the length.</span> */
  /* <span class="roman">Using &lsquo;htonl&rsquo; is necessary so that the data can be</span>
     <span class="roman">decoded even on machines with different byte order.</span>
     <span class="roman">&lsquo;l64a&rsquo; can return a string shorter than 6 bytes, so </span>
     <span class="roman">we pad it with encoding of 0 (</span>'.'<span class="roman">) at the end by </span>
     <span class="roman">hand.</span> */

  p = stpcpy (cp, l64a (htonl (len)));
  cp = mempcpy (p, &quot;......&quot;, 6 - (p - cp));

  while (len &gt; 3)
    {
      unsigned long int n = *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      len -= 4;
      p = stpcpy (cp, l64a (htonl (n)));
      cp = mempcpy (p, &quot;......&quot;, 6 - (p - cp));
    }
  if (len &gt; 0)
    {
      unsigned long int n = *in++;
      if (--len &gt; 0)
        {
          n = (n &lt;&lt; 8) | *in++;
          if (--len &gt; 0)
            n = (n &lt;&lt; 8) | *in;
        }
      cp = stpcpy (cp, l64a (htonl (n)));
    }
  *cp = '\0';
  return out;
}
</pre></div>

<p>奇怪的是，该库没有提供所需的全部功能，但事实如此。
</p>
</dd></dl>

<p>解码使用<code>l64a</code>应使用以下功能。
</p>
<dl>
<dt id="index-a64l">函数： <em>long int</em> <strong>a64l</strong> <em>（const char * <var>string</var> ）</em></dt>
<dd>
<p>初步： MT安全| AS安全交流安全请参阅<a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX安全概念</a> 。
</p>

<p>参数<var>string</var>应该包含一个通过调用产生的字符串<code>l64a</code> 。该函数至少处理该字符串的6个字节，并根据下表对找到的字节进行解码。当发现表中没有一个字节时，它将停止解码，就像<code>atoi</code> ;如果缓冲区已分成几行，则必须小心跳过行尾字节。
</p>
<p>解码后的数字作为<code>long int</code>值。
</p></dd></dl>

<p>的<code>l64a</code>和<code>a64l</code>函数使用base 64编码，其中编码字符串的每个字节代表一个输入字的六位。这些符号用于基数64位：</p>
<table>
<tbody><tr><td></td><td>0</td><td>1个</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td>0</td><td><code>.</code></td><td><code>/</code></td><td><code>0</code></td><td><code>1</code></td><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td><td><code>5</code></td></tr>
<tr><td>8</td><td><code>6</code></td><td><code>7</code></td><td><code>8</code></td><td><code>9</code></td><td><code>A</code></td><td><code>B</code></td><td><code>C</code></td><td><code>D</code></td></tr>
<tr><td>16</td><td><code>E</code></td><td><code>F</code></td><td><code>G</code></td><td><code>H</code></td><td><code>I</code></td><td><code>J</code></td><td><code>K</code></td><td><code>L</code></td></tr>
<tr><td>24</td><td><code>M</code></td><td><code>N</code></td><td><code>O</code></td><td><code>P</code></td><td><code>Q</code></td><td><code>R</code></td><td><code>S</code></td><td><code>T</code></td></tr>
<tr><td>32</td><td><code>U</code></td><td><code>V</code></td><td><code>W</code></td><td><code>X</code></td><td><code>Y</code></td><td><code>Z</code></td><td><code>a</code></td><td><code>b</code></td></tr>
<tr><td>40</td><td><code>c</code></td><td><code>d</code></td><td><code>e</code></td><td><code>f</code></td><td><code>g</code></td><td><code>h</code></td><td><code>i</code></td><td><code>j</code></td></tr>
<tr><td>48</td><td><code>k</code></td><td><code>l</code></td><td><code>m</code></td><td><code>n</code></td><td><code>o</code></td><td><code>p</code></td><td><code>q</code></td><td><code>r</code></td></tr>
<tr><td>56</td><td><code>s</code></td><td><code>t</code></td><td><code>u</code></td><td><code>v</code></td><td><code>w</code></td><td><code>x</code></td><td><code>y</code></td><td><code>z</code></td></tr>
</tbody></table>

<p>此编码方案不是标准的。还有一些其他的编码方法被更广泛地使用（UU编码，MIME编码）。通常，最好使用这些编码之一。
</p>
<hr>
<div class="header">
<p>下一篇： <a href="Argz-and-Envz-Vectors.html#Argz-and-Envz-Vectors" rel="next" accesskey="n">Argz和Envz向量</a> ，上<a href="Argz-and-Envz-Vectors.html#Argz-and-Envz-Vectors" rel="next" accesskey="n">一篇</a> ： <a href="Obfuscating-Data.html#Obfuscating-Data" rel="prev" accesskey="p">混淆数据</a> ，上一篇： <a href="String-and-Array-Utilities.html#String-and-Array-Utilities" rel="up" accesskey="u">字符串和数组实用程序</a> [ <a href="index.html#SEC_Contents" title="目录" rel="contents">目录</a> ] [ <a href="Concept-Index.html#Concept-Index" title="指数" rel="index">索引</a> ]</p>
</div>





</body></html>