<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>与数据源对象连接（Java™教程> JDBC（TM）数据库访问> JDBC基础）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="This JDBC Java tutorial describes how to use JDBC API to create, insert into, update, and query tables. You will also learn how to use simple and prepared statements, stored procedures and perform transactions">
     <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">JDBC基础</a></div>
<div class="linkAHEAD"><a href="gettingstarted.html">入门</a></div>
<div class="linkAHEAD"><a href="processingsqlstatements.html">使用JDBC处理SQL语句</a></div>
<div class="linkAHEAD"><a href="connecting.html">建立连接</a></div>
<div class="nolinkAHEAD">连接数据源对象</div>
<div class="linkAHEAD"><a href="sqlexception.html">处理SQLException</a></div>
<div class="linkAHEAD"><a href="tables.html">设置表格</a></div>
<div class="linkAHEAD"><a href="retrieving.html">从结果集中检索和修改值</a></div>
<div class="linkAHEAD"><a href="prepared.html">使用准备好的语句</a></div>
<div class="linkAHEAD"><a href="transactions.html">使用交易</a></div>
<div class="linkAHEAD"><a href="rowset.html">使用行集对象</a></div>
<div class="linkAHEAD"><a href="jdbcrowset.html">使用JdbcRowSet对象</a></div>
<div class="linkAHEAD"><a href="cachedrowset.html">使用CachedRowSetObjects</a></div>
<div class="linkAHEAD"><a href="joinrowset.html">使用JoinRowSet对象</a></div>
<div class="linkAHEAD"><a href="filteredrowset.html">使用FilteredRowSet对象</a></div>
<div class="linkAHEAD"><a href="webrowset.html">使用WebRowSet对象</a></div>
<div class="linkAHEAD"><a href="sqltypes.html">使用高级数据类型</a></div>
<div class="linkAHEAD"><a href="blob.html">使用大对象</a></div>
<div class="linkAHEAD"><a href="sqlxml.html">使用SQLXML对象</a></div>
<div class="linkAHEAD"><a href="array.html">使用数组对象</a></div>
<div class="linkAHEAD"><a href="distinct.html">使用DISTINCT数据类型</a></div>
<div class="linkAHEAD"><a href="sqlstructured.html">使用结构化对象</a></div>
<div class="linkAHEAD"><a href="sqlcustommapping.html">使用自定义类型映射</a></div>
<div class="linkAHEAD"><a href="sqldatalink.html">使用数据链接对象</a></div>
<div class="linkAHEAD"><a href="sqlrowid.html">使用RowId对象</a></div>
<div class="linkAHEAD"><a href="storedprocedures.html">使用存储过程</a></div>
<div class="linkAHEAD"><a href="jdbcswing.html">结合使用JDBC和GUI API</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b> JDBC（TM）数据库访问<br><b>课程：</b> JDBC基础</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> > <a href="../index.html" target="_top">JDBC（TM）数据库访问</a> > <a href="index.html" target="_top">JDBC基础</a>
            </div>
            <div class="NavBit">
                <a href="connecting.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="sqlexception.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>连接数据源对象</h1></div>
            <div id="PageContent">

<!-- <h3>Connecting with DataSource Objects</h3> -->
<p>本节涵盖<code>DataSource</code>对象，这是获得与数据源的连接的首选方法。除了它们的其他优点（稍后将进行说明）之外， <code>DataSource</code>对象可以提供连接池和分布式事务。此功能对于企业数据库计算至关重要。特别是，它是Enterprise JavaBeans（EJB）技术不可或缺的。</p>
<p>本节说明如何使用<code>DataSource</code>界面以及如何使用分布式事务和连接池。两者都涉及JDBC应用程序中很少的代码更改。</p>
<p>系统管理员通常使用工具（例如Apache Tomcat或Oracle WebLogic Server）来部署使这些操作成为可能的类而执行的工作因类型而异。 <code>DataSource</code>正在部署的对象。因此，本节的大部分内容专门介绍系统管理员如何设置环境，以便程序员可以使用<code>DataSource</code>对象以获取连接。</p>
<p>涵盖以下主题：</p>
<ul>
<li><a href="#datasource_connection">使用数据源对象获取连接</a></li>
<li><a href="#deploy_datasource">部署基本数据源对象</a></li>
<li><a href="#datasource_implementation">部署其他数据源实现</a></li>
<li><a href="#pooled_connection">获取和使用池化连接</a></li>
<li><a href="#deployment_distributed_transactions">部署分布式事务</a></li>
<li><a href="#using_connections_distributed_transactions">使用连接进行分布式事务</a></li>
</ul>
<!-- ************************************ -->
<h2><a name="datasource_connection" id="datasource_connection">使用数据源对象获取连接</a></h2>
<p>在<a href="connecting.html">建立连接中</a> ，您学习了如何使用<code>DriverManager</code>类。本节介绍如何使用<code>DataSource</code>对象以获取到数据源的连接，这是首选方法。</p>
<p>由实现了实例的类实例化的对象<code>DataSource</code>代表特定的DBMS或其他数据源，例如文件。一种<code>DataSource</code>对象代表特定的DBMS或其他数据源，例如文件。如果公司使用多个数据源，它将部署一个单独的<code>DataSource</code>每个对象。的<code>DataSource</code>接口由驱动程序供应商实现。它可以通过三种不同的方式实现：</p>
<ul>
<li>基本的<code>DataSource</code>实施产生标准<code>Connection</code>未在分布式事务中合并或使用的对象。</li>
<li>一种<code>DataSource</code>支持连接池的实现产生<code>Connection</code>参与连接池的对象，即可以回收的连接。</li>
<li>一种<code>DataSource</code>支持分布式事务的实现产生<code>Connection</code>可以在分布式事务（即访问两个或更多DBMS服务器的事务）中使用的对象。</li>
</ul>
<p>JDBC驱动程序至少应包括一个基本<code>DataSource</code>实施。例如，Java DB JDBC驱动程序包括实现<code>org.apache.derby.jdbc.ClientDataSource</code>对于MySQL， <code>com.mysql.jdbc.jdbc2.optional.MysqlDataSource</code> 。如果您的客户端在Java 8 Compact Profile 2上运行，则Java DB JDBC驱动程序为<code>org.apache.derby.jdbc.BasicClientDataSource40</code> 。本教程的样本要求压缩配置文件3或更高。</p>
<p>一种<code>DataSource</code>支持分布式事务的类通常也实现对连接池的支持。例如，一个<code>DataSource</code> EJB供应商提供的类几乎总是支持连接池和分布式事务。</p>
<p>假设从前面的示例来看，The Coffee Break商店蓬勃发展的连锁店的所有者已决定通过在互联网上出售咖啡来进一步扩大规模。预期会有大量在线业务，因此所有者肯定需要连接池。打开和关闭连接会涉及大量的开销，并且所有者希望此在线订购系统需要大量的查询和更新。使用连接池，可以反复使用连接池，从而避免了为每次数据库访问创建新连接的开销。此外，所有者现在拥有第二个DBMS，其中包含最近收购的咖啡烘焙公司的数据。这意味着所有者将希望能够编写使用旧DBMS服务器和新DBMS服务器的分布式事务。</p>
<p>链所有者已重新配置计算机系统，以服务于新的更大的客户群。所有者购买了最新的JDBC驱动程序和与其一起使用的EJB应用程序服务器，以便能够使用分布式事务并获得连接池带来的更高性能。提供了许多与最近购买的EJB服务器兼容的JDBC驱动程序。所有者现在具有三层体系结构，中间层是新的EJB应用程序服务器和JDBC驱动程序，第三层是两个DBMS服务器。发出请求的客户端计算机是第一层。</p>
<!-- ************************************ -->
<h2><a name="deploy_datasource" id="deploy_datasource">部署基本数据源对象</a></h2>
<p>系统管理员需要部署<code>DataSource</code>对象，以便Coffee Break的编程团队可以开始使用它们。部署<code>DataSource</code>对象包含三个任务：</p>
<ol>
<li>创建一个实例<code>DataSource</code>类</li>
<li>设置其属性</li>
<li>在使用Java命名和目录接口（JNDI）API的命名服务中注册它</li>
</ol>
<p>首先，请考虑最基本的情况，即使用<code>DataSource</code>接口，即不支持连接池或分布式事务的接口。在这种情况下，只有一个<code>DataSource</code>需要部署的对象。的基本实现<code>DataSource</code>产生与<code>DriverManager</code>类产生。</p>
<!-- ====================================== -->
<h3>创建数据源类的实例并设置其属性</h3>
<p>假设一家公司只希望基本实现<code>DataSource</code>已从JDBC供应商DB Access，Inc.购买了一个驱动程序。该驱动程序包括<code>com.dbaccess.BasicDataSource</code>实现了<code>DataSource</code>接口。以下代码摘录创建该类的实例<code>BasicDataSource</code>并设置其属性。实例之后<code>BasicDataSource</code>部署后，程序员可以调用该方法<code>DataSource.getConnection</code>获得与公司数据库的连接， <code>CUSTOMER_ACCOUNTS</code> 。首先，系统管理员创建<code>BasicDataSource</code>宾语<code><em>ds</em></code>使用默认构造函数。然后，系统管理员设置三个属性。请注意，以下代码通常由部署工具执行：</p>
<div class="codeblock"><pre>
com.dbaccess.BasicDataSource ds = new com.dbaccess.BasicDataSource();
ds.setServerName(&quot;grinder&quot;);
ds.setDatabaseName(&quot;CUSTOMER_ACCOUNTS&quot;);
ds.setDescription("Customer accounts database for billing");
</pre></div>
<p>变量<code><em>ds</em></code>现在代表数据库<code>CUSTOMER_ACCOUNTS</code>安装在服务器上。由连接器产生的任何连接<code>BasicDataSource</code>宾语<code><em>ds</em></code>将是到数据库的连接<code>CUSTOMER_ACCOUNTS</code> 。</p>
<!-- ====================================== -->
<h3>向使用JNDI API的命名服务注册数据源对象</h3>
<p>设置属性后，系统管理员可以注册<code>BasicDataSource</code>具有JNDI（Java命名和目录接口）命名服务的对象。通常使用的特定命名服务由系统属性确定，此处未显示。以下代码摘录注册了<code>BasicDataSource</code>对象并将其与逻辑名称绑定<code>jdbc/billingDB</code> ：</p>
<div class="codeblock"><pre>
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/billingDB&quot;, ds);
</pre></div>
<p>此代码使用JNDI API。第一行创建一个<code>InitialContext</code>对象，用作名称的起点，类似于文件系统中的根目录。第二行关联或绑定<code>BasicDataSource</code>宾语<code><em>ds</em></code>逻辑名称<code>jdbc/billingDB</code> 。在下一个代码摘录中，为命名服务赋予此逻辑名称，然后它返回<code>BasicDataSource</code>宾语。逻辑名称可以是任何字符串。在这种情况下，公司决定使用该名称<code>billingDB</code>作为逻辑名称<code>CUSTOMER_ACCOUNTS</code>数据库。</p>
<p>在上一个示例中， <code>jdbc</code>是初始上下文下的子上下文，就像根目录下的目录是子目录一样。名字<code>jdbc/billingDB</code>就像路径名一样，路径中的最后一项类似于文件名。在这种情况下， <code>billingDB</code>是给予的逻辑名称<code>BasicDataSource</code>宾语<code><em>ds</em></code> 。子上下文<code>jdbc</code>保留用于绑定逻辑名称<code>DataSource</code>对象，所以<code>jdbc</code>将始终是数据源逻辑名称的第一部分。</p>
<h3>使用部署的数据源对象</h3>
<p>基本之后<code>DataSource</code>系统实现由系统管理员部署，可供程序员使用。这意味着程序员可以提供绑定到实例的逻辑数据源名称。 <code>DataSource</code>类，并且JNDI命名服务将返回该类的一个实例<code>DataSource</code>类。方法<code>getConnection</code>然后可以调用<code>DataSource</code>对象以获取与其表示的数据源的连接。例如，程序员可以编写以下两行代码来获得<code>DataSource</code>产生与数据库连接的对象<code>CUSTOMER_ACCOUNTS</code> 。</p>
<div class="codeblock"><pre>
Context ctx = new InitialContext();
DataSource ds = (DataSource)ctx.lookup("jdbc/billingDB");
</pre></div>
<p>代码的第一行以初始上下文作为检索a的起点<code>DataSource</code>宾语。当您提供逻辑名时<code>jdbc/billingDB</code>方法<code>lookup</code> ，该方法返回<code>DataSource</code>系统管理员绑定到的对象<code>jdbc/billingDB</code>在部署时。因为方法的返回值<code>lookup</code>是Java <code>Object</code> ，我们必须将其转换为更具体的<code>DataSource</code>类型，然后将其分配给变量<code><em>ds</em></code> 。</p>
<p>变量<code><em>ds</em></code>是该类的一个实例<code>com.dbaccess.BasicDataSource</code>实现了<code>DataSource</code>接口。调用方法<code><em>ds</em>.getConnection</code>产生与<code>CUSTOMER_ACCOUNTS</code>数据库。</p>
<div class="codeblock"><pre>
Connection con = ds.getConnection("fernanda","brewed");
</pre></div>
<p>的<code>getConnection</code>该方法仅需要用户名和密码，因为该变量<code><em>ds</em></code>具有与以下设备建立连接所需的其余信息： <code>CUSTOMER_ACCOUNTS</code>数据库中的属性，例如数据库名称和位置。</p>
<h3>数据源对象的优点</h3>
<p>由于其特性， <code>DataSource</code>对象是比更好的选择<code>DriverManager</code>获取连接的类。程序员不再需要在他们的应用程序中对驱动程序名称或JDBC URL进行硬编码，这使它们更易于移植。也， <code>DataSource</code>属性使代码维护更加简单。如果有更改，系统管理员可以更新数据源属性，而不必担心更改与该数据源建立连接的每个应用程序。例如，如果将数据源移至其他服务器，则系统管理员要做的就是设置<code>serverName</code>属性设置为新的服务器名称。</p>
<p>除了便携性和易于维护之外，使用<code>DataSource</code>获得连接的对象可以提供其他优势。当。。。的时候<code>DataSource</code>介面可与<code>ConnectionPoolDataSource</code>实现中，由该实例产生的所有连接<code>DataSource</code>类将自动被池化连接。同样，当<code>DataSource</code>实现是为了与<code>XADataSource</code>类，它产生的所有连接将自动成为可在分布式事务中使用的连接。下一节将展示如何部署这些类型的<code>DataSource</code>实现。</p>
<!-- ************************************ -->
<h2><a name="datasource_implementation" id="datasource_implementation">部署其他数据源实现</a></h2>
<p>系统管理员或以该身份工作的其他人可以部署<code>DataSource</code>对象，以便它产生的连接是池连接。为此，他或她首先部署了一个<code>ConnectionPoolDataSource</code>对象，然后部署一个<code>DataSource</code>实现与之配合使用的对象。的属性<code>ConnectionPoolDataSource</code>设置对象以使其代表将与其建立连接的数据源。之后<code>ConnectionPoolDataSource</code>对象已在JNDI命名服务中注册， <code>DataSource</code>对象已部署。通常，仅必须为两个属性设置<code>DataSource</code>宾语： <code>description</code>和<code>dataSourceName</code> 。给定的值<code>dataSourceName</code>属性是标识<code>ConnectionPoolDataSource</code>先前部署的对象，该对象包含建立连接所需的属性。</p>
<p>随着<code>ConnectionPoolDataSource</code>和<code>DataSource</code>部署对象后，可以调用该方法<code>DataSource.getConnection</code>在<code>DataSource</code>对象并获得池化连接。此连接将连接到<code>ConnectionPoolDataSource</code>对象的属性。</p>
<p>以下示例说明了The Coffee Break的系统管理员如何部署<code>DataSource</code>实现以提供池化连接的对象。系统管理员通常将使用部署工具，因此本节中显示的代码片段是部署工具将执行的代码。</p>
<p>为了获得更好的性能，Coffee Break公司从DB Access，Inc.购买了JDBC驱动程序，其中包括<code>com.dbaccess.ConnectionPoolDS</code> ，它实现了<code>ConnectionPoolDataSource</code>接口。系统管理员创建创建此类的实例，设置其属性，并将其注册到JNDI命名服务。喝咖啡休息时间购买了它<code>DataSource</code>类， <code>com.applogic.PooledDataSource</code>从其EJB服务器供应商Application Logic，Inc.获得。 <code>com.applogic.PooledDataSource</code>通过使用以下内容提供的基础支持来实现连接池<code>ConnectionPoolDataSource</code>类<code>com.dbaccess.ConnectionPoolDS</code> 。</p>
<p>的<code>ConnectionPoolDataSource</code>必须先部署对象。以下代码创建了一个实例<code>com.dbaccess.ConnectionPoolDS</code>并设置其属性：</p>
<div class="codeblock"><pre>
com.dbaccess.ConnectionPoolDS cpds = new com.dbaccess.ConnectionPoolDS();
cpds.setServerName(&quot;creamer&quot;);
cpds.setDatabaseName(&quot;COFFEEBREAK&quot;);
cpds.setPortNumber(9040);
cpds.setDescription(&quot;Connection pooling for " + "COFFEEBREAK DBMS&quot;);
</pre></div>
<p>之后<code>ConnectionPoolDataSource</code>对象已部署，系统管理员将部署<code>DataSource</code>宾语。以下代码注册了<code>com.dbaccess.ConnectionPoolDS</code>宾语<code><em>cpds</em></code>使用JNDI命名服务。请注意，逻辑名称与<code><em>cpds</em></code>变量具有子上下文<code>pool</code>在子上下文下添加<code>jdbc</code> ，类似于将子目录添加到分层文件系统中的另一个子目录。类的任何实例的逻辑名称<code>com.dbaccess.ConnectionPoolDS</code>将始终以<code>jdbc/pool</code> 。甲骨文建议全力以赴<code>ConnectionPoolDataSource</code>子上下文中的对象<code>jdbc/pool</code> ：</p>
<div class="codeblock"><pre>
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/pool/fastCoffeeDB&quot;, cpds);
</pre></div>
<p>接下来， <code>DataSource</code>实现与<code><em>cpds</em></code>变量和其他实例<code>com.dbaccess.ConnectionPoolDS</code>类已部署。以下代码创建此类的实例并设置其属性。请注意，为此实例仅设置了两个属性<code>com.applogic.PooledDataSource</code> 。的<code>description</code>设置属性是因为它始终是必需的。设置的另一个属性， <code>dataSourceName</code> ，给出逻辑JNDI名称<code><em>cpds</em></code> ，这是<code>com.dbaccess.ConnectionPoolDS</code>类。换一种说法， <code><em>cpds</em></code>代表<code>ConnectionPoolDataSource</code>对象，将为该对象实现连接池<code>DataSource</code>宾语。</p>
<p>以下代码（可能会由部署工具执行）创建了一个<code>PooledDataSource</code>对象，设置其属性，并将其绑定到逻辑名称<code>jdbc/fastCoffeeDB</code> ：</p>
<div class="codeblock"><pre>
com.applogic.PooledDataSource ds = new com.applogic.PooledDataSource();
ds.setDescription("produces pooled connections to COFFEEBREAK");
ds.setDataSourceName(&quot;jdbc/pool/fastCoffeeDB&quot;);
Context ctx = new InitialContext();
ctx.bind("jdbc/fastCoffeeDB", ds);
</pre></div>
<p>此时， <code>DataSource</code>部署对象，应用程序可从该对象获取与数据库的池化连接<code>COFFEEBREAK</code> 。</p>
<!-- ************************************ -->
<h2><a name="pooled_connection" id="pooled_connection">获取和使用池化连接</a></h2>
<p><em>连接池</em>是数据库连接对象的缓存。这些对象表示物理数据库连接，应用程序可以使用这些物理数据库连接来连接数据库。在运行时，应用程序请求池中的连接。如果池包含可以满足请求的连接，则它将连接返回给应用程序。如果未找到任何连接，则会创建一个新连接并将其返回给应用程序。应用程序使用该连接在数据库上执行某些工作，然后将对象返回到池中。然后，该连接可用于下一个连接请求。</p>
<p>连接池可促进连接对象的重用，并减少创建连接对象的次数。连接池显着提高了数据库密集型应用程序的性能，因为创建连接对象在时间和资源上都非常昂贵。</p>
<p>现在这些<code>DataSource</code>和<code>ConnectionPoolDataSource</code>对象已部署，程序员可以使用<code>DataSource</code>对象以获取池化连接。获取池化连接的代码与获取非池化连接的代码一样，如以下两行所示：</p>
<div class="codeblock"><pre>
ctx = new InitialContext();
ds = (DataSource)ctx.lookup("jdbc/fastCoffeeDB");
</pre></div>
<p>变量<code><em>ds</em></code>代表一个<code>DataSource</code>产生与数据库的池化连接的对象<code>COFFEEBREAK</code> 。您需要检索此<code>DataSource</code>对象仅一次，因为您可以使用它来生成所需的尽可能多的池连接。调用方法<code>getConnection</code>在<code><em>ds</em></code>变量会自动产生一个池化连接，因为<code>DataSource</code>反对<code><em>ds</em></code>变量代表被配置为产生池连接。</p>
<p>连接池通常对程序员是透明的。使用池连接时，只需要做两件事：</p>
<ol>
<li>
<p>用一个<code>DataSource</code>对象而不是<code>DriverManager</code>类以获取连接。在下面的代码行中， <code><em>ds</em></code>是一个<code>DataSource</code>对象的实现和部署，以便它将创建池连接和<code>username</code>和<code>password</code>是代表有权访问数据库的用户凭据的变量：</p>
<div class="codeblock"><pre>
Connection con = ds.getConnection(username, password);
</pre></div>
</li>
<li>
<p>用一个<code>finally</code>语句以关闭池化连接。下列<code>finally</code>块将出现在<code>try/catch</code>适用于使用池化连接的代码的块：</p>
<div class="codeblock"><pre>
try {
    Connection con = ds.getConnection(username, password);
    // ... code to use the pooled
    // connection con
} catch (Exception ex {
    // ... code to handle exceptions
} finally {
    if (con != null) con.close();
}
</pre></div>
</li>
</ol>
<p>否则，使用池连接的应用程序与使用常规连接的应用程序相同。应用程序程序员在完成连接池时可能会注意到的唯一另一件事是性能更好。</p>
<p>以下示例代码获取<code>DataSource</code>产生与数据库连接的对象<code>COFFEEBREAK</code>并使用它来更新表格中的价格<code>COFFEES</code> ：</p>
<div class="codeblock"><pre>
import java.sql.*;
import javax.sql.*;
import javax.ejb.*;
import javax.naming.*;

public class ConnectionPoolingBean implements SessionBean {

    // ...

    public void ejbCreate() throws CreateException {
        ctx = new InitialContext();
        ds = (DataSource)ctx.lookup("jdbc/fastCoffeeDB");
    }

    public void updatePrice(float price, String cofName,
                            String username, String password)
        throws SQLException{

        Connection con;
        PreparedStatement pstmt;
        try {
            con = ds.getConnection(username, password);
            con.setAutoCommit(false);
            pstmt = con.prepareStatement(&quot;UPDATE COFFEES &quot; +
                        &quot;SET PRICE = ? " +
                        "WHERE COF_NAME = ?&quot;);
            pstmt.setFloat(1, price);
            pstmt.setString(2, cofName);
            pstmt.executeUpdate();

            con.commit();
            pstmt.close();

        } finally {
            if (con != null) con.close();
        }
    }

    private DataSource ds = null;
    private Context ctx = null;
}

</pre></div>
<p>此代码示例中的连接参与连接池，因为以下是正确的：</p>
<ul>
<li>一个实现类的实例<code>ConnectionPoolDataSource</code>已部署。</li>
<li>一个实现类的实例<code>DataSource</code>已经部署，并且为其设置的值<code>dataSourceName</code>属性是绑定到先前部署的逻辑名称<code>ConnectionPoolDataSource</code>宾语。</li>
</ul>
<p>请注意，尽管此代码与您之前看到的代码非常相似，但在以下方面有所不同：</p>
<ul>
<li>
<p>它导入<code>javax.sql</code> ， <code>javax.ejb</code>和<code>javax.naming</code>套餐除了<code>java.sql</code> 。</p>
<p>的<code>DataSource</code>和<code>ConnectionPoolDataSource</code>接口在<code>javax.sql</code>包和JNDI构造函数<code>InitialContext</code>和方法<code>Context.lookup</code>是的一部分<code>javax.naming</code>包。此特定示例代码采用EJB组件的形式，该组件使用来自<code>javax.ejb</code>包。本示例的目的是说明使用池化连接的方式与使用非池化连接的方式相同，因此您不必担心理解EJB API。</p>
</li>
<li>
<p>它使用<code>DataSource</code>对象以获取连接，而不是使用<code>DriverManager</code>设施。</p>
</li>
<li>
<p>它使用<code>finally</code>阻止以确保连接已关闭。</p>
</li>
</ul>
<p>获取和使用池化连接类似于获取和使用常规连接。当某人担任系统管理员后， <code>ConnectionPoolDataSource</code>对象和一个<code>DataSource</code>对象正确地被应用程序使用<code>DataSource</code>对象以获取池化连接。但是，应用程序应使用<code>finally</code>阻止关闭池化连接。为简单起见，前面的示例使用了<code>finally</code>阻止但没有<code>catch</code>块。如果方法中的方法抛出异常<code>try</code>块，它将默认被抛出，并且<code>finally</code>子句将在任何情况下执行。</p>
<!-- ************************************ -->
<h2><a name="deployment_distributed_transactions" id="deployment_distributed_transactions">部署分布式事务</a></h2>
<p><code>DataSource</code>可以部署对象以获得可在分布式事务中使用的连接。与连接池一样，必须部署两个不同的类实例： <code>XADataSource</code>对象和一个<code>DataSource</code>实现与之配合使用的对象。</p>
<p>假设The Coffee Break企业家购买的EJB服务器包括<code>DataSource</code>类<code>com.applogic.TransactionalDS</code> ，可与<code>XADataSource</code>诸如<code>com.dbaccess.XATransactionalDS</code> 。它适用于任何事实<code>XADataSource</code>类使EJB服务器可跨JDBC驱动程序移植。当。。。的时候<code>DataSource</code>和<code>XADataSource</code>部署对象后，产生的连接将能够参与分布式事务。在这种情况下<code>com.applogic.TransactionalDS</code>实现的目的是使生成的连接也是池连接，通常情况下<code>DataSource</code>作为EJB服务器实现的一部分提供的类。</p>
<p>的<code>XADataSource</code>必须先部署对象。以下代码创建了一个实例<code>com.dbaccess.XATransactionalDS</code>并设置其属性：</p>
<div class="codeblock"><pre>
com.dbaccess.XATransactionalDS xads = new com.dbaccess.XATransactionalDS();
xads.setServerName(&quot;creamer&quot;);
xads.setDatabaseName(&quot;COFFEEBREAK&quot;);
xads.setPortNumber(9040);
xads.setDescription("Distributed transactions for COFFEEBREAK DBMS");
</pre></div>
<p>以下代码注册了<code>com.dbaccess.XATransactionalDS</code>宾语<code><em>xads</em></code>使用JNDI命名服务。请注意，逻辑名称与<code><em>xads</em></code>有子上下文<code>xa</code>在下添加<code>jdbc</code> 。Oracle建议该类的任何实例的逻辑名称<code>com.dbaccess.XATransactionalDS</code>总是以<code>jdbc/xa</code> 。</p>
<div class="codeblock"><pre>
Context ctx = new InitialContext();
ctx.bind("jdbc/xa/distCoffeeDB", xads);
</pre></div>
<p>接下来， <code>DataSource</code>实现与之交互的对象<code><em>xads</em></code>和别的<code>XADataSource</code>对象已部署。请注意<code>DataSource</code>类， <code>com.applogic.TransactionalDS</code> ，可以与<code>XADataSource</code>任何JDBC驱动程序供应商提供的class。部署<code>DataSource</code>对象涉及创建的实例<code>com.applogic.TransactionalDS</code>类并设置其属性。的<code>dataSourceName</code>属性设置为<code>jdbc/xa/distCoffeeDB</code> ，与关联的逻辑名称<code>com.dbaccess.XATransactionalDS</code> 。这是<code>XADataSource</code>为该类实现分布式事务功能的类<code>DataSource</code>类。以下代码部署了<code>DataSource</code>类：</p>
<div class="codeblock"><pre>
com.applogic.TransactionalDS ds = new com.applogic.TransactionalDS();
ds.setDescription("Produces distributed transaction " +
                  "connections to COFFEEBREAK&quot;);
ds.setDataSourceName("jdbc/xa/distCoffeeDB");
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/distCoffeeDB&quot;, ds);
</pre></div>
<p>现在，这些类的实例<code>com.applogic.TransactionalDS</code>和<code>com.dbaccess.XATransactionalDS</code>已经部署，应用程序可以调用该方法<code>getConnection</code>在实例上<code>TransactionalDS</code>类以获取与<code>COFFEEBREAK</code>可以在分布式事务中使用的数据库。</p>
<!-- ************************************ -->
<h2><a name="using_connections_distributed_transactions" id="using_connections_distributed_transactions">使用连接进行分布式事务</a></h2>
<p>要获得可用于分布式事务的连接，必须使用<code>DataSource</code>已正确实现和部署的对象，如“ <a href="#deployment_distributed_transactions">部署分布式事务</a> ”部分中所示。有了这样的<code>DataSource</code>对象，调用方法<code>getConnection</code>在上面。建立连接后，就像使用其他任何连接一样使用它。因为<code>jdbc/distCoffeesDB</code>与一个<code>XADataSource</code> JNDI命名服务中的对象，以下代码会产生一个<code>Connection</code>可以在分布式事务中使用的对象：</p>
<div class="codeblock"><pre>
Context ctx = new InitialContext();
DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/distCoffeesDB&quot;);
Connection con = ds.getConnection();
</pre></div>
<p>对于此连接作为分布式事务的一部分时的使用方式，存在一些较小但重要的限制。事务管理器控制分布式事务何时开始以及何时提交或回滚。因此，应用程序代码永远不要调用方法<code>Connection.commit</code>要么<code>Connection.rollback</code> 。应用程序同样不应调用<code>Connection.setAutoCommit(true)</code> ，它启用了自动提交模式，因为这也会干扰事务管理器对事务边界的控制。这就解释了为什么在分布式事务范围内创建的新连接默认情况下会禁用其自动提交模式。请注意，这些限制仅在连接参与分布式事务时才适用。连接不是分布式事务的一部分时，没有任何限制。</p>
<p>对于以下示例，假设已订购一份咖啡，这将触发对位于不同DBMS服务器上的两个表的更新。第一张桌子是新的<code>INVENTORY</code>表，第二个是<code>COFFEES</code>表。因为这些表位于不同的DBMS服务器上，所以涉及它们的事务将是分布式事务。以下示例中的代码获得连接，然后更新<code>COFFEES</code>表，并关闭连接，是分布式事务的第二部分。</p>
<p>请注意，由于分布式事务的范围由中间层服务器的基础系统基础结构控制，因此代码不会明确地提交或回滚更新。同样，假设用于分布式事务的连接是池连接，则应用程序将使用<code>finally</code>阻止关闭连接。这样可以保证即使抛出异常也将关闭有效的连接，从而确保将连接返回到连接池以进行回收。</p>
<p>下面的代码示例说明了一个Enterprise Bean，它是一个实现可被客户端计算机调用的方法的类。此示例的目的是演示分布式事务的应用程序代码与其他代码没有什么不同，只是它不调用<code>Connection</code>方法<code>commit</code> ， <code>rollback</code> ， 要么<code>setAutoCommit(true)</code> 。因此，您不必担心了解所使用的EJB API。</p>
<div class="codeblock"><pre>
import java.sql.*;
import javax.sql.*;
import javax.ejb.*;
import javax.naming.*;

public class DistributedTransactionBean implements SessionBean {

    // ...

    public void ejbCreate() throws CreateException {

        ctx = new InitialContext();
        ds = (DataSource)ctx.lookup(&quot;jdbc/distCoffeesDB&quot;);
    }

    public void updateTotal(int incr, String cofName, String username,
                            String password)
        throws SQLException {

        Connection con;
        PreparedStatement pstmt;

        try {
            con = ds.getConnection(username, password);
            pstmt = con.prepareStatement(&quot;UPDATE COFFEES &quot; +
                        &quot;SET TOTAL = TOTAL + ? " +
                        "WHERE COF_NAME = ?&quot;);
            pstmt.setInt(1, incr);
            pstmt.setString(2, cofName);
            pstmt.executeUpdate();
            stmt.close();
        } finally {
            if (con != null) con.close();
        }
    }

    private DataSource ds = null;
    private Context ctx = null;
}
</pre></div>


        </div>
        <div class="NavBit">
            <a href="connecting.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="sqlexception.html" target="_top">下一个»</a>
        </div>
    </div>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>建立连接<br><b>下一页：</b>处理SQLExceptions</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</body></html>