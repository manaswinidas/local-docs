<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>将XML数据读入DOM（Java™教程>用于XML处理的Java API（JAXP）>文档对象模型）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="This JAXP Java tutorial describes Java API for XML Processing (jaxp), XSLT, SAX, and related XML topics">
     <meta name="keywords" content="java programming, learn java, java sample code, jaxp, xml, xslt, sax">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">文件对象模型</a></div>
<div class="linkAHEAD"><a href="when.html">何时使用DOM</a></div>
<div class="nolinkAHEAD">将XML数据读入DOM</div>
<div class="linkAHEAD"><a href="validating.html">使用XML模式进行验证</a></div>
<div class="linkAHEAD"><a href="info.html">更多信息</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b>用于XML处理的Java API（JAXP）<br><b>课程：</b>文档对象模型</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> > <a href="../index.html" target="_top">用于XML处理的Java API（JAXP）</a> > <a href="index.html" target="_top">文档对象模型</a>
            </div>
            <div class="NavBit">
                <a href="when.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="validating.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>将XML数据读入DOM</h1></div>
            <div id="PageContent">

<!-- Reading XML Data into a DOM -->
<p>在本节中，您将通过读取现有的XML文件来构造文档对象模型。</p>
<hr>
<p><b>注意-</b>在“ <a class="TutorialLink" href="../xslt/index.html" target="_top">可扩展样式表语言转换”中</a> ，您将看到如何将DOM编写为XML文件。（您还将看到如何相对轻松地将现有数据文件转换为XML。）</p>
<hr>
<h2><a name="gestu" id="gestu"></a>创建程序</h2>
<p>文档对象模型提供了API，可用于创建，修改，删除和重新排列节点。在尝试创建DOM之前，了解DOM的结构很有帮助。这一系列示例将通过名为<tt>DOMEcho</tt>的示例程序使DOM内部可见，在安装JAXP API之后，您将在目录<tt><i>INSTALL_DIR</i> / jaxp- <i>version</i> / samples / dom中</tt>找到该示例程序。</p>
<h3><a name="gestx" id="gestx"></a>创建骨架</h3>
<p>首先，构建一个简单的程序以将XML文档读入DOM，然后再次将其写回。</p>
<p>从应用程序的常规基本逻辑开始，并检查以确保在命令行上提供了参数：</p>
<div class="codeblock"><pre>
public class DOMEcho {

    static final String outputEncoding = "UTF-8";

    private static void usage() {
        // ...
    }

    public static void main(String[] args) throws Exception {
        String filename = null;
    
        for (int i = 0; i &lt; args.length; i++) {
            if (...) { 
                // ...
            } 
            else {
                filename = args[i];
                if (i != args.length - 1) {
                    usage();
                }
            }
        }

        if (filename == null) {
            usage();
        }
    }
}
</pre></div>
<p>此代码执行所有基本设置操作。<tt>DOMEcho的</tt>所有输出<tt>均</tt>使用UTF-8编码。如果未指定任何参数，则调用<tt>usage（）</tt>方法只是告诉您<tt>DOMEcho</tt>需要什么参数，因此此处未显示代码。还声明了一个<tt>文件名</tt>字符串，这将是<tt>DOMEcho</tt>解析为DOM的XML文件的名称。</p>
<h3><a name="gesun" id="gesun"></a>导入所需的类</h3>
<p>在本节中，所有类都单独命名，以便您在参考API文档时可以看到每个类的来源。在样本文件中，导入语句以较短的形式生成，例如<tt>javax.xml.parsers。*</tt> 。</p>
<p>这些是<tt>DOMEcho</tt>使用的JAXP API：</p>
<div class="codeblock"><pre>
package dom;
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory;
</pre></div>
<p>这些类用于解析XML文档时可能引发的异常：</p>
<div class="codeblock"><pre>
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException; 
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.*
</pre></div>
<p>这些类读取示例XML文件并管理输出：</p>
<div class="codeblock"><pre>
import java.io.File;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
</pre></div>
<p>最后，为DOM，DOM异常，实体和节点导入W3C定义：</p>
<div class="codeblock"><pre>
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Entity;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
</pre></div>
<h3><a name="gestm" id="gestm"></a>处理错误</h3>
<p>接下来，添加错误处理逻辑。最重要的一点是，在解析XML文档时遇到问题时，需要JAXP兼容的文档构建器报告SAX异常。DOM解析器实际上不必在内部使用SAX解析器，但是由于SAX标准已经存在，因此可以使用它来报告错误。结果，DOM应用程序的错误处理代码与SAX应用程序的错误处理代码非常相似：</p>
<div class="codeblock"><pre>
private static class MyErrorHandler implements ErrorHandler {
     
    private PrintWriter out;

    MyErrorHandler(PrintWriter out) {
        this.out = out;
    }

    private String getParseExceptionInfo(SAXParseException spe) {
        String systemId = spe.getSystemId();
        if (systemId == null) {
            systemId = "null";
        }

        String info = "URI=" + systemId + " Line=" + spe.getLineNumber() +
                      ": " + spe.getMessage();
        return info;
    }

    public void warning(SAXParseException spe) throws SAXException {
        out.println("Warning: " + getParseExceptionInfo(spe));
    }
        
    public void error(SAXParseException spe) throws SAXException {
        String message = "Error: " + getParseExceptionInfo(spe);
        throw new SAXException(message);
    }

    public void fatalError(SAXParseException spe) throws SAXException {
        String message = "Fatal Error: " + getParseExceptionInfo(spe);
        throw new SAXException(message);
    }
}

</pre></div>
<p>如您所见， <tt>DomEcho</tt>类的错误处理程序使用<tt>PrintWriter</tt>实例生成其输出。</p>
<h3><a name="geswy" id="geswy"></a>实例化工厂</h3>
<p>接下来，将以下代码添加到<tt>main（）</tt>方法中，以获得可以为我们提供文档构建器的工厂实例。</p>
<div class="codeblock"><pre>
public static void main(String[] args) throws Exception {
    <b>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</b>

    // ...
}

</pre></div>
<h3><a name="geswm" id="geswm"></a>获取解析器并解析文件</h3>
<p>现在，将以下代码添加到<tt>main（）中</tt>以获取构建器的实例，并使用其来解析指定的文件。</p>
<div class="codeblock"><pre>
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
<b>DocumentBuilder db = dbf.newDocumentBuilder(); 
Document doc = db.parse(new File(filename));</b>

</pre></div>
<p>被解析的文件由在<tt>main（）</tt>方法开始时声明的<tt>文件名</tt>变量提供，该<tt>文件名</tt>变量在程序运行时作为参数传递给<tt>DOMEcho</tt> 。</p>
<h3><a name="geswk" id="geswk"></a>配置工厂</h3>
<p>默认情况下，工厂返回一个不验证名称空间的非验证解析器。要获得一个验证解析器，或者一个了解名称空间（或两者兼而有之）的解析器，您可以使用以下代码将工厂配置为设置这两个选项中的一个或两个。</p>
<div class="codeblock"><pre>
public static void main(String[] args) throws Exception {

    String filename = null;
    boolean dtdValidate = false;
    boolean xsdValidate = false;
    String schemaSource = null;
        
    for (int i = 0; i &lt; args.length; i++) {
        if (args[i].equals("-dtd"))  { 
            dtdValidate = true;
        } 
        else if (args[i].equals("-xsd")) {
            xsdValidate = true;
        } 
        else if (args[i].equals("-xsdss")) {
            if (i == args.length - 1) {
                usage();
            }
            xsdValidate = true;
            schemaSource = args[++i];
        }
        else {
            filename = args[i];
            if (i != args.length - 1) {
                usage();
            }
        }
    }

    if (filename == null) {
        usage();
    }

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

    dbf.setNamespaceAware(true);
    dbf.setValidating(dtdValidate || xsdValidate);

    // ...

    DocumentBuilder db = dbf.newDocumentBuilder();
    Document doc = db.parse(new File(filename));
}
</pre></div>
<p>如您所见，设置了命令行参数，以便您可以通知<tt>DOMEcho</tt>针对DTD或XML Schema执行验证，并且将工厂配置为可<tt>识别</tt>名称空间并执行用户指定的任何验证类型。</p>
<hr>
<p><b>注意-</b>即使参考解析器支持，也不需要符合JAXP的解析器来支持这些选项的所有组合。如果指定的选项无效组合，则工厂在尝试获取解析器实例时会生成<tt>ParserConfigurationException</tt> 。</p>
<hr>
<p>“使用<a class="TutorialLink" href="validating.html" target="_top">XML模式</a>验证”中提供了有关如何使用名称空间和验证的更多信息，其中将描述上述摘录中缺少的代码。</p>
<h3><a name="gesxf" id="gesxf"></a>处理验证错误</h3>
<p>根据SAX标准的规定，对验证错误的默认响应是不执行任何操作。JAXP标准要求抛出SAX异常，因此您使用与用于SAX应用程序完全相同的错误处理机制。特别是，您使用<tt>DocumentBuilder</tt>类的<tt>setErrorHandler</tt>方法向其提供一个实现SAX <tt>ErrorHandler</tt>接口的对象。</p>
<hr>
<p><b>注-</b> <tt>DocumentBuilder的</tt>也有可以使用<tt>的setEntityResolver</tt>方法。</p>
<hr>
<p>以下代码将文档构建器配置为使用“ <a class="TutorialLink" href="readingXML.html#gestm" target="_top">处理错误”中</a>定义的错误处理程序。</p>
<div class="codeblock"><pre>
DocumentBuilder db = dbf.newDocumentBuilder();
OutputStreamWriter errorWriter = new OutputStreamWriter(System.err,
                                         outputEncoding);
db.setErrorHandler(new MyErrorHandler (new PrintWriter(errorWriter, true)));
Document doc = db.parse(new File(filename));
</pre></div>
<p>到目前为止，您所看到的代码已经设置了文档构建器，并将其配置为根据请求执行验证。错误处理也就位。但是， <tt>DOMEcho</tt>尚未执行任何操作。在下一节中，您将看到如何显示DOM结构并开始探索它。例如，您将看到DOM中的实体引用和CDATA部分的外观。也许最重要的是，您将看到文本节点（包含实际数据）如何驻留在DOM中的元素节点下。</p>
<h2><a name="gesxh" id="gesxh"></a>显示DOM节点</h2>
<p>要创建或操作DOM，有助于清楚了解DOM中的节点的结构。本教程的这一部分将介绍DOM的内部结构，以便您可以查看其中包含的内容。<tt>DOMEcho</tt>示例通过回显DOM节点，然后使用适当的缩进在屏幕<tt>上将</tt>它们打印出来，以使节点层次结构清晰<tt>可见</tt> ，来实现此目的。这些节点类型的规范可以在<a class="OutsideLink" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113" target="_blank">DOM级别2核心规范</a>的<tt>Node</tt> <a class="OutsideLink" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113" target="_blank">规范</a>下找到。<a href="#gfzpy">下表3-1</a>是根据该规范改编的。</p>
<p><a name="gfzpy" id="gfzpy"></a>表3-1节点类型</p>
<table summary="Node Types">
<colgroup><col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
</colgroup><tbody><tr>
<th align="left" valign="top" scope="col">
<p>节点</p>
</th>
<th align="left" valign="top" scope="col">
<p>nodeName</p>
</th>
<th align="left" valign="top" scope="col">
<p>nodeValue</p>
</th>
<th align="left" valign="top" scope="col">
<p>属性</p>
</th>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>Attr</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>属性名称</p>
</td>
<td align="left" valign="top" scope="row">
<p>属性值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>CDATA部分</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p><tt>＃cdata-section</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>CDATA部分的内容</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>评论</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p><tt>＃评论</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>评论内容</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>文献</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p><tt>＃文献</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>文档片段</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p><tt>#documentFragment</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>文件类型</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>文件类型名称</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>元件</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>标签名</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>实体</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>实体名称</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>实体参考</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>所引用实体的名称</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>符号</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>符号名称</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>加工说明</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>目标</p>
</td>
<td align="left" valign="top" scope="row">
<p>整个内容（不包括目标）</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>文本</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p><tt>＃文本</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>文本节点的内容</p>
</td>
<td align="left" valign="top" scope="row">
<p>空值</p>
</td>
</tr>
</tbody></table>
<p>该表中的信息非常有用。在使用DOM时，您将需要它，因为所有这些类型都混合在DOM树中。</p>
<h3><a name="gfzqh" id="gfzqh"></a>获取节点类型信息</h3>
<p>DOM节点元素类型信息是通过调用<tt>org.w3c.dom的各种方法获得的<tt>。节点</tt>类。以下代码回显了<tt>DOMEcho</tt>公开的节点属性。</tt></p><tt>
<div class="codeblock"><pre>
private void printlnCommon(Node n) {
    out.print(" nodeName=\"" + n.getNodeName() + "\"");

    String val = n.getNamespaceURI();
    if (val != null) {
        out.print(" uri=\"" + val + "\"");
    }

    val = n.getPrefix();

    if (val != null) {
        out.print(" pre=\"" + val + "\"");
    }

    val = n.getLocalName();
    if (val != null) {
        out.print(" local=\"" + val + "\"");
    }

    val = n.getNodeValue();
    if (val != null) {
        out.print(" nodeValue=");
        if (val.trim().equals("")) {
            // Whitespace
            out.print("[WS]");
        }
        else {
            out.print("\"" + n.getNodeValue() + "\"");
        }
    }
    out.println();
}
</pre></div>
<p>每个DOM节点至少都有一个类型，一个名称和一个值，该值可以为空也可以不为空。在上面的示例中， <tt>Node</tt>接口的<tt>getNamespaceURI（）</tt> ， <tt>getPrefix（）</tt> ， <tt>getLocalName（）</tt>和<tt>getNodeValue（）</tt>方法返回并打印回显的节点的名称空间URI，名称空间前缀，本地限定名称和值。请注意，对<tt>getNodeValue（）</tt>返回的值调用<tt>trim（）</tt>方法，以确定节点的值是否为空白，并相应地打印一条消息。</p>
<p>有关<tt>Node</tt>方法的完整列表及其返回的不同信息，请参见API文档。 <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Node.html" target="_blank"><code>Node</code></a> 。</p>
<p>接下来，定义一种方法来设置节点在打印时的缩进，以便可以轻松看到节点层次结构。</p>
<div class="codeblock"><pre>
private void outputIndentation() {
    for (int i = 0; i &lt; indent; i++) {
        out.print(basicIndent);
    }
}
</pre></div>
<p><tt>basicIndent</tt>常数用于定义<tt>DOMEcho</tt>显示节点树层次结构时使用的缩进的基本单位，是通过将以下突出显示的行添加到<tt>DOMEcho</tt>构造函数类中来定义的。</p>
<div class="codeblock"><pre>
public class DOMEcho {
    static final String outputEncoding = "UTF-8";

    <b>private PrintWriter out;</b>
    <b>private int indent = 0;</b>
    <b>private final String basicIndent = " ";</b>

    DOMEcho(PrintWriter out) {
        this.out = out;
    }
}
</pre></div>
<p>与<a class="TutorialLink" href="readingXML.html#gestm" target="_top">处理错误中</a>定义的错误处理程序一样， <tt>DOMEcho</tt>程序会将其输出创建为<tt>PrintWriter</tt>实例。</p>
<h3><a name="ggdwv" id="ggdwv"></a>词法控制</h3>
<p>词汇信息是重构XML文档原始语法所需的信息。保留词法信息对于编辑应用程序很重要，在该应用程序中，您想保存一个文档，该文档准确地反映了原始完整内容，包括注释，实体引用以及它可能一开始就包含的所有CDATA部分。</p>
<p>但是，大多数应用程序仅关注XML结构的内容。他们有能力忽略注释，也不必关心数据是在CDATA节中编码还是以纯文本格式编写，或者是否包含实体引用。对于此类应用程序，需要最少的词汇信息，因为它简化了应用程序必须准备检查的DOM节点的数量和种类。</p>
<p>以下<tt>DocumentBuilderFactory</tt>方法使您可以控制在DOM中看到的词汇信息。</p>
<dl>
<dt><tt>setCoalescing（）</tt></dt>
<dd>
<p>将<tt>CDATA</tt>节点转换为<tt>Text</tt>节点并追加到相邻的<tt>Text</tt>节点（如果有）。</p>
</dd>
<dt><tt>setExpandEntityReferences（）</tt></dt>
<dd>
<p>扩展实体参考节点。</p>
</dd>
<dt><tt>setIgnoringComments（）</tt></dt>
<dd>
<p>忽略评论。</p>
</dd>
<dt><tt>setIgnoringElementContentWhitespace（）</tt></dt>
<dd>
<p>忽略不是元素内容重要部分的空格。</p>
</dd>
</dl>
<p>所有这些属性的默认值为false，这保留了以原始形式重建传入文档所需的所有词汇信息。将它们设置为true可使您构造最简单的DOM，以便应用程序可以专注于数据的语义内容，而不必担心词汇语法细节。<a href="#ggdxy">表3-2</a>总结了设置的效果。</p>
<p><a name="ggdxy" id="ggdxy"></a>表3-2词法控件设置</p>
<table summary="Lexical Control Settings">
<colgroup><col width="33%">
<col width="33%">
<col width="33%">
</colgroup><tbody><tr>
<th align="left" valign="top" scope="col">
<p>API</p>
</th>
<th align="left" valign="top" scope="col">
<p>保留词法信息</p>
</th>
<th align="left" valign="top" scope="col">
<p>专注于内容</p>
</th>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>setCoalescing（）</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>假</p>
</td>
<td align="left" valign="top" scope="row">
<p>真正</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>setExpandEntityReferences（）</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>假</p>
</td>
<td align="left" valign="top" scope="row">
<p>真正</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>setIgnoringComments（）</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>假</p>
</td>
<td align="left" valign="top" scope="row">
<p>真正</p>
</td>
</tr>
<tr>
<td align="left" valign="top" scope="row">
<p><tt>setIgnoringElementContent</tt> <tt>Whitespace（）</tt></p>
</td>
<td align="left" valign="top" scope="row">
<p>假</p>
</td>
<td align="left" valign="top" scope="row">
<p>真正</p>
</td>
</tr>
</tbody></table>
<p>下面显示了<tt>DomEcho</tt>示例的main方法中这些方法的实现。</p>
<div class="codeblock"><pre>
// ...

dbf.setIgnoringComments(ignoreComments);
dbf.setIgnoringElementContentWhitespace(ignoreWhitespace);
dbf.setCoalescing(putCDATAIntoText);
dbf.setExpandEntityReferences(!createEntityRefs);

// ...
</pre></div>
<p>布尔变量<tt>ignoreComments</tt> ， <tt>ignoreWhitespace</tt> ， <tt>putCDATAIntoText</tt>和<tt>createEntityRefs</tt>在主要方法代码的开头声明，并在运行<tt>DomEcho</tt>时由命令行参数设置。</p>
<div class="codeblock"><pre>
public static void main(String[] args) throws Exception {
    // ...

    boolean ignoreWhitespace = false;
    boolean ignoreComments = false;
    boolean putCDATAIntoText = false;
    boolean createEntityRefs = false;

    for (int i = 0; i &lt; args.length; i++) {
        if (...) {  // Validation arguments here
           // ... 
        } 
        else if (args[i].equals("-ws")) {
            ignoreWhitespace = true;
        } 
        else if (args[i].startsWith("-co")) {
            ignoreComments = true;
        }
        else if (args[i].startsWith("-cd")) {
            putCDATAIntoText = true;
        } 
        else if (args[i].startsWith("-e")) {
            createEntityRefs = true;

            // ...
        } 
        else {
            filename = args[i];

            // Must be last arg
            if (i != args.length - 1) {
                usage();
            }
        }
    }

    // ...
}

</pre></div>
<p><a name="ggawi" id="ggawi"></a></p>
<h2>打印DOM树节点</h2>
<p><tt>DomEcho</tt>应用程序使您可以查看DOM的结构，并演示由哪些节点组成DOM以及如何安排它们。通常，DOM树中的绝大多数节点将是<tt>Element</tt>和<tt>Text</tt>节点。</p>
<hr>
<p><b>注-</b>文本节点位于DOM中的元素节点<b>下</b> ，并且数据始终存储在文本节点中。DOM处理中最常见的错误也许是导航到元素节点，并期望它包含存储在该元素中的数据。不是这样！即使是最简单的元素节点，其下都有一个包含数据的文本节点。</p>
<hr>
<p>下面显示了使用适当的缩进打印出DOM树节点的代码。</p>
<div class="codeblock"><pre>
private void echo(Node n) {
    outputIndentation();
    int type = n.getNodeType();

    switch (type) {
        case Node.ATTRIBUTE_NODE:
            out.print("ATTR:");
            printlnCommon(n);
            break;

        case Node.CDATA_SECTION_NODE:
            out.print("CDATA:");
            printlnCommon(n);
            break;

        case Node.COMMENT_NODE:
            out.print("COMM:");
            printlnCommon(n);
            break;

        case Node.DOCUMENT_FRAGMENT_NODE:
            out.print("DOC_FRAG:");
            printlnCommon(n);
            break;

        case Node.DOCUMENT_NODE:
            out.print("DOC:");
            printlnCommon(n);
            break;

        case Node.DOCUMENT_TYPE_NODE:
            out.print("DOC_TYPE:");
            printlnCommon(n);
            NamedNodeMap nodeMap = ((DocumentType)n).getEntities();
            indent += 2;
            for (int i = 0; i &lt; nodeMap.getLength(); i++) {
                Entity entity = (Entity)nodeMap.item(i);
                echo(entity);
            }
            indent -= 2;
            break;

        case Node.ELEMENT_NODE:
            out.print("ELEM:");
            printlnCommon(n);

            NamedNodeMap atts = n.getAttributes();
            indent += 2;
            for (int i = 0; i &lt; atts.getLength(); i++) {
                Node att = atts.item(i);
                echo(att);
            }
            indent -= 2;
            break;

        case Node.ENTITY_NODE:
            out.print("ENT:");
            printlnCommon(n);
            break;

        case Node.ENTITY_REFERENCE_NODE:
            out.print("ENT_REF:");
            printlnCommon(n);
            break;

        case Node.NOTATION_NODE:
            out.print("NOTATION:");
            printlnCommon(n);
            break;

        case Node.PROCESSING_INSTRUCTION_NODE:
            out.print("PROC_INST:");
            printlnCommon(n);
            break;

        case Node.TEXT_NODE:
            out.print("TEXT:");
            printlnCommon(n);
            break;

        default:
            out.print("UNSUPPORTED NODE: " + type);
            printlnCommon(n);
            break;
    }

    indent++;
    for (Node child = n.getFirstChild(); child != null;
         child = child.getNextSibling()) {
        echo(child);
    }
    indent--;
}
</pre></div>
<p>此代码首先使用switch语句以适当的缩进打印出不同的节点类型和任何可能的子节点。</p>
<p>节点属性不作为子级包含在DOM层次结构中。而是通过<tt>Node</tt>接口的<tt>getAttributes</tt>方法获取它们。</p>
<p><tt>文档类型</tt>接口是<tt>w3c.org.dom的扩展<tt>。节点</tt> 。它定义了<tt>getEntities</tt>方法，可用于获取<tt>Entity</tt>节点-定义实体的节点。像<tt>属性</tt>节点一样， <tt>实体</tt>节点不会显示为DOM节点的子节点。</tt></p><tt>
<p><a name="ggdyc" id="ggdyc"></a></p>
<h2>节点操作</h2>
<p>本节将快速介绍您可能要应用于DOM的一些操作。</p>
<ul>
<li>
<p>创建节点</p>
</li>
<li>
<p>遍历节点</p>
</li>
<li>
<p>搜索节点</p>
</li>
<li>
<p>获取节点内容</p>
</li>
<li>
<p>创建属性</p>
</li>
<li>
<p>删除和更改节点</p>
</li>
<li>
<p>插入节点</p>
</li>
</ul>
<p><a name="ggdyj" id="ggdyj"></a></p>
<h3>创建节点</h3>
<p>您可以使用<tt>Document</tt>界面的方法创建不同类型的节点。例如， <tt>createElement</tt> ， <tt>createComment</tt> ， <tt>createCDATAsection</tt> ， <tt>createTextNode</tt>等。API文档提供了用于创建不同节点的方法的完整列表。 <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Document.html" target="_blank"><code>org.w3c.dom.Document</code></a> 。</p>
<p><a name="ggdvz" id="ggdvz"></a></p>
<h3>遍历节点</h3>
<p><tt>org.w3c.dom。Node</tt>接口定义了许多可用于遍历节点的方法，包括<tt>getFirstChild</tt> ， <tt>getLastChild</tt> ， <tt>getNextSibling</tt> ， <tt>getPreviousSibling</tt>和<tt>getParentNode</tt> 。这些操作足以从树中的任何位置到达树中的任何其他位置。</p>
<p><a name="ggdwa" id="ggdwa"></a></p>
<h3>搜索节点</h3>
<p>当您搜索具有特定名称的节点时，还有一点需要考虑。尽管很想获得第一个孩子并检查它是否合适，但搜索必须考虑到以下事实：子列表中的第一个孩子可能是注释或处理指令。如果未验证XML数据，则它甚至可能是包含可忽略空格的文本节点。</p>
<p>本质上，您需要浏览子节点列表，忽略无关的节点，并检查您关心的节点。这是在DOM层次结构中搜索节点时需要编写的例程类型的示例。它在此处完整显示（带有注释），因此您可以在应用程序中将其用作模板。</p>
<div class="codeblock"><pre>
/**
 * Find the named subnode in a node's sublist.
 * &lt;ul>
 * &lt;li>Ignores comments and processing instructions.
 * &lt;li>Ignores TEXT nodes (likely to exist and contain
 *         ignorable whitespace, if not validating.
 * &lt;li>Ignores CDATA nodes and EntityRef nodes.
 * &lt;li>Examines element nodes to find one with
 *        the specified name.
 * &lt;/ul>
 * @param name  the tag name for the element to find
 * @param node  the element node to start searching from
 * @return the Node found
 */
public Node findSubNode(String name, Node node) {
    if (node.getNodeType() != Node.ELEMENT_NODE) {
        System.err.println("Error: Search node not of element type");
        System.exit(22);
    }

    if (! node.hasChildNodes()) return null;

    NodeList list = node.getChildNodes();
    for (int i=0; i &lt; list.getLength(); i++) {
        Node subnode = list.item(i);
        if (subnode.getNodeType() == Node.ELEMENT_NODE) {
           if (subnode.getNodeName().equals(name)) 
               return subnode;
        }
    }
    return null;
}
</pre></div>
<p>有关此代码的更详细说明，请参阅<a class="TutorialLink" href="when.html#gchls" target="_top">“</a> <a class="TutorialLink" href="when.html" target="_top">何时使用DOM中的</a> <a class="TutorialLink" href="when.html#gchls" target="_top">增加复杂性”</a> 。还要注意，您可以使用<a class="TutorialLink" href="readingXML.html#ggdwv" target="_top">Lexical Controls中</a>描述的API来修改解析器构造的DOM的类型。但是，此代码的优点是，它将几乎适用于所有DOM。</p>
<p><a name="ggdxv" id="ggdxv"></a></p>
<h3>获取节点内容</h3>
<p>当要获取节点包含的文本时，再次需要遍历子节点列表，忽略无关的条目，并累积在<tt>TEXT</tt>节点， <tt>CDATA</tt>节点和<tt>EntityRef</tt>节点中找到的<tt>文本</tt> 。这是可用于该过程的例程类型的示例。</p>
<div class="codeblock"><pre>
/**
  * Return the text that a node contains. This routine:
  * &lt;ul>
  * &lt;li>Ignores comments and processing instructions.
  * &lt;li>Concatenates TEXT nodes, CDATA nodes, and the results of
  *     recursively processing EntityRef nodes.
  * &lt;li>Ignores any element nodes in the sublist.
  *     (Other possible options are to recurse into element 
  *      sublists or throw an exception.)
  * &lt;/ul>
  * @param    node  a  DOM node
  * @return   a String representing its contents
  */
public String getText(Node node) {
    StringBuffer result = new StringBuffer();
    if (! node.hasChildNodes()) return "";

    NodeList list = node.getChildNodes();
    for (int i=0; i &lt; list.getLength(); i++) {
        Node subnode = list.item(i);
        if (subnode.getNodeType() == Node.TEXT_NODE) {
            result.append(subnode.getNodeValue());
        }
        else if (subnode.getNodeType() == Node.CDATA_SECTION_NODE) {
            result.append(subnode.getNodeValue());
        }
        else if (subnode.getNodeType() == Node.ENTITY_REFERENCE_NODE) {
            // Recurse into the subtree for text
            // (and ignore comments)
            result.append(getText(subnode));
        }
    }

    return result.toString();
}
</pre></div>
<p>有关此代码的更详细说明，请参阅<a class="TutorialLink" href="when.html#gchls" target="_top">“</a> <a class="TutorialLink" href="when.html" target="_top">何时使用DOM中的</a> <a class="TutorialLink" href="when.html#gchls" target="_top">增加复杂性”</a> 。同样，您可以通过使用<a class="TutorialLink" href="readingXML.html#ggdwv" target="_top">Lexical Controls中</a>描述的API修改解析器构造的DOM的类型来简化此代码。但是，此代码的好处是，它将几乎可用于任何DOM。</p>
<p><a name="ggdxn" id="ggdxn"></a></p>
<h3>创建属性</h3>
<p><tt>org.w3c.dom。扩展Node的Element</tt>接口定义了<tt>setAttribute</tt>操作，该操作将属性添加到该节点。（从Java平台的角度来看，更好的名字应该是<tt>addAttribute</tt> 。该属性不是该类的属性，并且创建了一个新对象。）您还可以使用<tt>Document</tt>的<tt>createAttribute</tt>操作创建<tt>Attribute</tt>的实例，然后使用<tt>setAttributeNode</tt>方法添加它。</p>
<p><a name="ggdyw" id="ggdyw"></a></p>
<h3>删除和更改节点</h3>
<p>要删除节点，请使用其父节点的<tt>removeChild</tt>方法。要对其进行更改，可以使用父节点的<tt>replaceChild</tt>操作或节点的<tt>setNodeValue</tt>操作。</p>
<p><a name="ggdxt" id="ggdxt"></a></p>
<h3>插入节点</h3>
<p>创建新节点时要记住的重要一点是，当您创建元素节点时，指定的唯一数据就是名称。实际上，该节点为您提供了挂物的钩子。通过将项添加到子节点列表中，可以将其挂在钩子上。例如，您可以添加文本节点， <tt>CDATA</tt>节点或属性节点。在构建时，请记住本教程中看到的结构。切记：层次结构中的每个节点都非常简单，仅包含一个数据元素。</p>
<p><a name="ggegf" id="ggegf"></a></p>
<h2>运行<tt>DOMEcho</tt>示例</h2>
<p>要运行<tt>DOMEcho</tt>示例，请按照以下步骤操作。</p>
<ol>
<li><b>导航到<tt>示例</tt>目录。</b><code>% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.</code></li>
<li><b>编译示例类。</b><code>% javac dom/*</code></li>
<li><b>在XML文件上运行<tt>DOMEcho</tt>程序。</b>
<p>在<tt>数据</tt>目录中选择一个XML文件，然后在其上运行<tt>DOMEcho</tt>程序。在这里，我们选择了在文件<tt>personal-schema.xml</tt>上运行程序。</p>
<code>% java dom/DOMEcho data/personal-schema.xml</code>
<p>XML文件<tt>personal-schema.xml</tt>包含一家小公司的人员文件。在其上运行<tt>DOMEcho</tt>程序时，应该看到以下输出。</p>
<div class="codeblock"><pre>
DOC: nodeName="#document"
 ELEM: nodeName="personnel" 
       local="personnel"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="person" 
       local="person"
 ATTR: nodeName="id" 
       local="id" 
       nodeValue="Big.Boss"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="name" 
       local="name"
 ELEM: nodeName="family" 
       local="family"
 TEXT: nodeName="#text" 
       nodeValue="Boss"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="given" 
       local="given"
 TEXT: nodeName="#text" 
       nodeValue="Big"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="email" 
       local="email"
 TEXT: nodeName="#text" 
       nodeValue="chief@foo.example.com"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="link" 
       local="link"
 ATTR: nodeName="subordinates" 
       local="subordinates" 
       nodeValue="one.worker two.worker 
                  three.worker four.worker
                  five.worker"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="person" 
       local="person"
 ATTR: nodeName="id" 
       local="id" 
       nodeValue="one.worker"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="name" 
       local="name"
 ELEM: nodeName="family" 
       local="family"
 TEXT: nodeName="#text" 
       nodeValue="Worker"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="given" 
       local="given"
 TEXT: nodeName="#text" 
       nodeValue="One"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="email" 
       local="email"
 TEXT: nodeName="#text" 
       nodeValue="one@foo.example.com"
 TEXT: nodeName="#text" 
       nodeValue=[WS]
 ELEM: nodeName="link" 
       local="link"
 ATTR: nodeName="manager" 
       local="manager" 
       nodeValue="Big.Boss"
 TEXT: nodeName="#text"
       nodeValue=[WS]

[...]

</pre></div>
<p>如您所见， <tt>DOMEcho将</tt>打印出文档中不同元素的所有节点，并带有正确的缩进以显示节点层次结构。</p>
</li>
</ol>


        </tt></tt></div><tt><tt>
        <div class="NavBit">
            <a href="when.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="validating.html" target="_top">下一个»</a>
        </div>
    </tt></tt></div><tt><tt>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>何时使用DOM<br><b>下一页：</b>使用XML模式进行验证</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</tt></tt></body></html>