<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>使用XSLT转换XML数据（Java™教程>用于XML处理的Java API（JAXP）>可扩展的样式表语言转换）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="This JAXP Java tutorial describes Java API for XML Processing (jaxp), XSLT, SAX, and related XML topics">
     <meta name="keywords" content="java programming, learn java, java sample code, jaxp, xml, xslt, sax">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">可扩展样式表语言转换</a></div>
<div class="linkAHEAD"><a href="intro.html">引入XSL，XSLT和XPath</a></div>
<div class="linkAHEAD"><a href="xpath.html">XPath的工作方式</a></div>
<div class="linkAHEAD"><a href="writingDom.html">写出DOM作为XML文件</a></div>
<div class="linkAHEAD"><a href="generatingXML.html">从任意数据结构生成XML</a></div>
<div class="nolinkAHEAD">使用XSLT转换XML数据</div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b>用于XML处理的Java API（JAXP）<br><b>课程：</b>可扩展样式表语言转换</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> > <a href="../index.html" target="_top">用于XML处理的Java API（JAXP）</a> > <a href="index.html" target="_top">可扩展样式表语言转换</a>
            </div>
            <div class="NavBit">
                <a href="generatingXML.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="../stax/index.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>使用XSLT转换XML数据</h1></div>
            <div id="PageContent">

<!-- Transforming XML Data with XSLT -->
<p>可扩展样式表语言转换（XSLT）API可以用于许多目的。例如，使用足够智能的样式表，您可以从XML数据生成PDF或PostScript输出。但通常，XSLT用于生成格式化的HTML输出，或创建数据的替代XML表示。</p>
<p>在本节中，将使用XSLT转换将XML输入数据转换为HTML输出。</p>
<hr>
<p><b>注意</b> <a class="OutsideLink" href="http://www.w3.org/TR/xslt20/" target="_blank">-XSLT规范</a>又大又复杂，因此本教程只能从头开始。它将为您提供一些背景知识，以便您可以理解简单的XSLT处理任务，但不会详细研究如何编写XSLT转换，而是着重于如何使用JAXP的XSLT转换API。有关XSLT的更全面基础，请查阅优质的参考手册，例如Michael Kay的<i>XSLT 2.0和XPath 2.0：程序员参考</i> （Wrox，2008年）。</p>
<hr>
<p><a name="ggyvk" id="ggyvk"></a></p>
<h2>定义简单的文档类型</h2>
<p>首先定义一个非常简单的文档类型，该文档类型可用于撰写文章。我们的<tt>文章</tt>文档将包含以下结构标签：</p>
<ul>
<li>
<p><tt><title></ tt>：文章标题</ p> </ li> <li> <p> <tt> <SECT> </ tt>：由标题和正文组成的部分</ p> < / li> <li> <p> <tt> <PARA> </ tt>：一段</ p> </ li> <li> <p> <tt> <LIST> </ tt>：列表< / p> </ li> <li> <p> <tt> <ITEM> </ tt>：列表中的条目</ p> </ li> <li> <p> <tt> <注意> < / tt>：顺便说一句，它偏离了正文</ p> </ li> </ ul> </ ul> <p>此结构的一点不寻常之处在于，我们不会为节标题创建单独的元素标签。通常创建此类元素是为了将标题文本（及其包含的任何标签）与节的主体（即，标题下方的任何结构元素）区分开。</ p> <p>相反，我们将允许标题无缝合并到节的主体中。这种安排给样式表增加了一些复杂性，但是它将使我们有机会探索XSLT的模板选择机制。它还符合我们对文档结构的直观期望，其中标题文本后直接跟随结构元素，这种结构可以简化面向轮廓的编辑。</ p> <hr> <p> <b>注意-</ b>这种结构不容易得到验证，因为XML的混合内容模型允许文本在节中的任何位置，而我们希望限制文本和内联元素，以便它们仅出现在节主体中的第一个结构元素之前。基于断言的验证器可以做到这一点，但是大多数其他模式机制不能。因此，我们无需为文档类型定义DTD。</ p> <hr> <p>在此结构中，可以嵌套节。嵌套的深度将决定将哪种HTML格式用于节标题（例如，<tt> h1 </ tt>或<tt> h2 </ tt>）。使用普通的<tt> SECT </ tt>标记（而不是编号的部分）在面向轮廓的编辑中也很有用，因为它使您可以随意移动各个部分，而不必担心更改任何受影响的部分的编号</ p> <p>对于列表，我们将使用type属性指定列表条目是无序（项目符号），alpha（由小写字母枚举），ALPHA（由大写字母枚举）还是带编号。</ p> <p>我们还将允许一些内联标签来更改文本的外观。</ p> <ul> <li> <p> <tt> <B> </ tt>：粗体</ p> </ li> <li> <p> <tt> <I> </ tt>：斜体字</ p> </ li> <li> <p> <tt> <U> </ tt>：下划线</ p> </ li> <li> <p> <tt> <DEF> </ tt>：定义</ p> </ li> <li> <p> <tt> <LINK> </ tt>：链接到URL </ p> </ li> </ ul> <hr> <p> <b>注意-</ b>内嵌标签不会生成换行符，因此由内嵌标签引起的样式更改会不会影响页面上文本的流动（尽管这会影响该文本的外观）。另一方面，结构标签会划分新的文本段，因此，除其他格式更改外，它至少还会产生换行符。</ p> <hr> <p> <tt> <DEF> </ tt>标记将用于文本中定义的术语。这些术语将以斜体显示，即它们通常在文档中的方式。但是，在XML中使用特殊标记将使索引程序可以找到此类定义，并将其与标题中的关键字一起添加到索引中。例如，在前面的注释中，可以用<tt> <DEF> </ tt>标签标记内联标签和结构标签的定义，以供将来索引。</ p> <p>最后，<tt> LINK </ tt>标签有两个作用。首先，它使我们可以创建指向URL的链接，而不必将URL放入两次。因此我们可以编写<tt> <link> http //...</ link> </ tt>而不是<tt> <a href="http//..."> http //...</ a> </ tt>。当然，我们还希望允许使用类似于<tt> <link target =“ ...”> ...名称... </ link> </ tt>的形式。这导致<tt> <link> </ tt>标签的第二个原因。</ p> <hr> <p> <b>注意-</ b>尽管文章结构非常简单（仅包含11个标记），但它引起了我们的注意。足够有趣的问题，使我们可以很好地了解XSLT的基本功能。但是，我们仍然会保留规范的大部分内容。在<a href="#ggyut"> XSLT还能做什么？</a>，我们将指出跳过的主要功能。</ p> <hr> <p> <a name="gghmv" id="gghmv"> </a> </ p> <h2>创建测试文档</ h2> <p>在这里，您将使用嵌套的<tt> <SECT> </ tt>元素，几个<PARA>元素，一个<tt> <NOTE> </ tt >元素，<tt> <LINK> </ tt>和<tt> <LIST type =“ unordered”> </ tt>。这个想法是创建一个包含所有内容的文档，以便我们可以探索更有趣的翻译机制。</ p> <hr> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<p> < b>注意-</ b>本节中讨论的代码位于<tt> article1.xml </ tt>中，在您将<a href= 解压缩后，该文件位于 <tt> xslt / data </ tt>目录中。 “ ../examples/xslt_samples.zip">XSLT示例</a>放入<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发行日期</ i> > <tt> / samples </ tt>目录。</ p>->“> FORMAT_PLACEHOLDER_5 </ span> <p> <b>注意-</ b>本节中讨论的代码在<tt> article1中.xml </ tt>，在您将<a class="SourceLink" target="_blank" href="../examples/xslt_samples.zip" 解压缩后，可在 <tt> xslt / data </ tt>目录中找到。 onclick =“ showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 149“> </ code> </a>到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ p> <hr> <p>要创建测试文档，请创建一个名为<tt> article.xml </ tt>的文件，然后输入以下XML数据。</ p> <div class =“ codeblock”> <pre data-markx =“ 158”> </ pre> </ div> <p>请注意，在XML文件中，该小节完全包含在主要部分中。（另一方面，在HTML中，标题不包含节的主体）。这样的结果是一个轮廓结构，很难像这样以纯文本格式进行编辑，但是使用面向轮廓的编辑器更容易进行编辑。</ p> <p>有一天，给出了一个理解树的XML编辑器内嵌标签，例如<tt> <B> </ tt>和<tt> <I> </ tt>，应该可以以大纲形式编辑此类文章，而无需复杂的样式表。（这样的编辑器将使作者能够专注于文章的结构，而将版面保留到该过程的后面）。在这样的编辑器中，文章片段将如下所示：</ p> <div class =“ codeblock”> <pre data-markx =“ 164”> </ pre> </ div> <hr> <p> <b>注意-</ b>目前，存在树状结构的编辑器，但是它们将内联标签（例如<tt> <B> </ tt>和<tt> <I> </ tt>他们处理结构标签的方式，可能会使“轮廓”有点难以理解。</ p> <hr> <p> <a name="gghnb" id="gghnb"> </a> </ p> <h2>编写XSLT转换</ h2> <p>现在是时候开始编写XSLT转换了，它将转换XML文章并将其呈现为HTML。</ p> <hr> <span class =“ notranslate hidefromparserselfclosedtags“ gtc：attrval =” <！-<p> <b>注意-</ b>本节中讨论的代码位于<tt> article1a.xsl </ tt>中，该代码位于<tt将<a href="../examples/xslt_samples.zip"> XSLT示例</a>解压缩到<i>安装目录</ i> <tt> / jaxp后，> xslt / data </ tt>目录-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ p>->“> FORMAT_PLACEHOLDER_6 </ span> <p> <b>注意- </ b>本节中讨论的代码位于<tt> article1a.xsl </ tt>中，在您解压缩<a class="SourceLink" target=" 后，该文件位于 <tt> xslt / data </ tt>目录中。 _blank“ href =” ../ examples / xslt_samples.zip“ onclick =” showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 181“> </ code> </a>到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ p> <hr> <p>从创建普通的XML文档开始：</ p> <div class =“ codeblock”> <pre data-markx =“ 189”> </ pre> </ div> <p>然后添加以下突出显示的行以创建XSL样式表：</ p> <div class =“ codeblock”> <pre data-markx =“ 192“> </ pre> </ div> <p>现在将其设置为产生HTML兼容的输出。</ p> <div class =” codeblock“> <pre data-markx =” 201“> </ pre > </ div> <p>在本节的后面，我们将详细介绍该条目的详细原因。现在，请注意，如果您要输出格式正确的XML以外的任何内容，则将需要一个<tt> <xsl：output> </ tt>标记，如图所示，并指定<tt> text </ tt >或<tt> html </ tt>。（默认值为<tt> xml </ tt>。）</ p> <hr> <p> <b>注意-</ b>注意-</ b>当您指定XML输出时，可以添加indent属性以产生很好的缩进XML输出。规范如下所示：<tt> <xsl：output method =“ xml” indent =“ yes” /> </ tt>。</ p> <hr> <p> <a name =“ ggyvc” id =“ ggyvc“> </a> </ p> <h2>处理基本结构元素</ h2> <p>您将通过处理用于创建目录的元素开始填充样式表：根元素，标题元素和标题。您还将处理测试文档中定义的<tt> PARA </ tt>元素。</ p> <hr> <p> <b>注意-</ b>如果一读就跳过了讨论XPath寻址机制<a class="TutorialLink" target="_top" href="xpath.html"> XPath的工作方式</a>，现在是回顾该部分的好时机。</ p> < hr> <p>首先添加处理根元素的主要指令：</ p> <div class =“ codeblock”> <pre data-markx =“ 225”> </ pre> </ div> <p>新的XSL命令以粗体显示。（请注意，它们是在<tt> xsl </ tt>命名空间中定义的）。指令<tt> <xsl：apply-templates> </ tt>处理当前节点的子代。在这种情况下，当前节点是根节点。</ p> <p>尽管该示例非常简单，但它说明了许多重要的想法，因此值得深入了解。第一个概念是样式表包含许多模板，这些模板由<tt> <xsl：template> </ tt>标记定义。每个模板都包含一个match属性，该属性使用<a class="TutorialLink" target="_top" href="xpath.html"> XPath的工作方式</a>中所述的XPath寻址机制来选择模板将要使用的元素。 </ p> <p>在模板中，仅复制不以<tt> xsl：namespace </ tt>前缀开头的标签。</ p> <hr> <p> <b>注意-</ b>注意：当不存在换行符时，通常会使用空格，因为它们之间的换行符和空格也会被复制。忽略了。在这种情况下，要在输出中包含空格或包含其他文本，可以使用<tt> <xsl：text> </ tt>标记。基本上，XSLT样式表希望处理标签。因此，它看到的所有内容都必须是<tt> <xsl：..> </ tt>标记，其他标记或空格。</ p> <hr> <p>在这种情况下，非XSL标记是HTML标记。因此，当根标记匹配时，XSLT输出HTML起始标记，处理适用于根子代的所有模板，然后输出HTML结束标记。</ p> <p> <a name =“ ggyxi” id = “ ggyxi”> </a> </ p> <h2>处理<tt> <TITLE> </ tt>元素</ h2> <p>接下来，添加一个模板来处理文章标题：</ p> <div class =“ codeblock”> <pre data-markx =“ 250”> </ pre> </ div> <p>在这种情况下，您可以指定TITLE元素的完整路径并输出一些HTML文本标题变成大的中心标题。在这种情况下，<tt> apply-templates </ tt>标签可确保如果标题包含任何内联标签（例如，斜体，链接或下划线），它们也将被处理。</ p> <p>更重要的是， <tt> apply-templates </ tt>指令导致标题文本被处理。像DOM数据模型一样，XSLT数据模型基于元素节点中包含的文本节点的概念（而文本节点又可以包含在其他元素节点中，依此类推）。该层次结构构成了源代码树。还有一个结果树，其中包含输出。</ p> <p> XSLT通过将源树转换为结果树来工作。为了使XSLT操作的结果可视化，有助于理解这些树的结构及其内容。（有关此主题的更多信息，请参见<a class="TutorialLink" target="_top" href="xpath.html#gchlm"> XSLT / XPath数据模型</a>）。</ p> <p> <a name =“ ggyuk” id =“ ggyuk”> </a> </ p> <h2>处理标题</ h2> <p>要继续处理基本结构元素，请添加一个模板来处理顶级标题： </ p> <div class =“ codeblock”> <pre data-markx =“ 265”> </ pre> </ div> <p>在这里，您指定最顶部<tt> SECT </ tt>的路径元素。但是这一次，您可以使用<tt> select </ tt>属性分两个阶段应用模板。在第一阶段，您将使用XPath <tt> text（）</ tt>函数选择文本节点以及内联标签，例如粗体和斜体。（垂直管道（<tt> | </ tt>）用于匹配多个项目：文本或粗体标签或斜体标签等）。在第二阶段，选择文件中包含的其他结构元素，用于节，段落，列表和注释。</ p> <p>使用select属性可以将文本元素和内联元素放在<tt>之间<h2> ... </ h2> </ tt>标记，同时确保此部分中的所有结构标记都在之后进行处理。换句话说，您要确保XML文档中标题的嵌套不会反映在HTML格式中，这对于HTML输出很重要。</ p> <p>通常，使用select子句可以使您将所有模板应用于当前上下文中可用信息的子集。作为另一个示例，此模板选择当前节点的所有属性：</ p> <div class =“ codeblock”> <pre data-markx =“ 280”> </ pre> </ div> <p>接下来，添加几乎相同的模板来处理嵌套更深一层的子标题：</ p> <div class =“ codeblock”> <pre data-markx =“ 283”> </ pre> </ div> <p> <一个名称=“ ggyuo” id =“ ggyuo”> </a> </ p> <h2>生成运行时消息</ h2> <p>您也可以添加模板以获取更深的标题，但是在某些时候您必须停止，仅仅是因为HTML仅下降到五个级别。对于此示例，您将在两个级别的节标题处停止。但是，如果XML输入恰好包含第三级，则将需要向用户传递错误消息。本节向您展示如何做到这一点。</ p> <hr> <p> <b>注意-</ b>我们可以继续处理<tt> SECT </ tt>元素，方法是使用以下命令选择它们表达式<tt> / SECT / SECT // SECT </ tt>。<tt> // </ tt>根据XPath寻址机制的定义，选择任意深度的任何<tt> SECT </ tt>元素。但相反，我们将趁此机会玩消息传递。</ p> <hr> <p>添加以下模板，以在遇到嵌套太深的部分时产生错误：</ p> <div class =“ codeblock“> <pre data-markx =” 303“> </ pre> </ div> <p> <tt> terminate =” yes“ </ tt>子句使转换过程在生成消息后停止。没有它，处理仍然可以继续进行，而该部分中的所有内容都将被忽略。</ p> <p>作为附加的练习，您可以扩展样式表以处理嵌套至最多四个部分的部分，从而生成<tt> <h2 > ... <h5> </ tt>标签。</ p> <p>最后，通过添加一个模板来处理<tt> PARA </ tt>标记来完成样式表：</ p> <div class =“ codeblock “> <pre data-markx =” 316“> </ pre> </ div> <p> <a name="ggyvn" id="ggyvn"> </a> </ p> <h2>编写基本程序</ h2> <p>现在，您将修改使用XSLT的程序以不变地回显XML文件，并对其进行更改，以使其使用样式表。</ p> <hr> <span class =“ notranslate hidefromparserselfclosedtags” gtc： attrval =“ <！-<p> <b>注意-</ b>本节中讨论的代码在<tt> Stylizer.java </ tt>中，该代码可在<tt> xslt </ tt中找到将<a href="../examples/xslt_samples.zip"> XSLT示例</a>解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1a.html </ tt>。</ p>->“> FORMAT_PLACEHOLDER_7 </ span> <p> <b>注意-< / b>本节中讨论的代码位于<tt> Stylizer.java </ tt>中，在将<a class="SourceLink" target="_blank 解压缩后，该文件位于 <tt> xslt </ tt>目录中。 “ href =” ../ examples / xslt_samples.zip“ onclick =” showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 330“> </ code> </a>到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1a.html </ tt>。</ p> <hr> <p> <tt> Stylizer </ tt>示例改编自<tt> TransformationApp02 </ tt>，它解析XML文件并将其写入<tt> System.out </ tt>。这两个程序之间的主要区别如下所述。</ p> <p>首先，<tt> Stylizer </ tt>在创建<tt> Transformer </ tt>对象时使用样式表。</ p> <div class =“ codeblock”> <pre data-markx =“ 346”> </ pre> </ div> <p>此代码使用文件创建<tt> StreamSource </ tt>对象，然后传递源对象</ p> <hr> <p> <b>注意-</ b>您可以通过消除<tt> DOMSource </ tt>类来简化代码。与其为XML文件创建一个<tt> DOMSource </ tt>对象，不如为其创建一个<tt> StreamSource </ tt>对象以及样式表对象。</ p> <hr> <p> <名称=“ ghbeu” id =“ ghbeu”> </a> </ p> <h3>运行<tt> Stylizer </ tt>示例</ h3> <ol> <li> <b>导航到<tt> samples </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 371”> </ pre> </ div> </ li> <span class =“ notranslate hidefromparserselfclosedtags“ gtc：attrval =” <！-<li> <b> <a href="../examples/xslt_samples.zip">通过单击此链接下载XSLT示例</a>，并将其解压缩到< i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> ->“> FORMAT_PLACEHOLDER_8 </ span> <li> <b> <a class =” SourceLink“ target =” _ blank“ href =” ../ examples / xslt_samples.zip“ onclick =” showCode（'.。/../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 379“> </ code> </a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> <li> <b>导航到<tt> xslt </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 388”> </ pre> </ div> </ li> <li> <b>编译<tt> Stylizer </ tt>示例。 </ b> <p>键入以下命令：</ p> <div class =“ codeblock”> <pre data-markx =“ 394”> </ pre> </ div> </ li> <li> < b>使用样式表<tt> article1a.xsl </ tt>在<tt> article1.xml </ tt>上运行<tt> Stylizer </ tt>示例。</ b> <div class =“ codeblock”> <pre data-markx =“ 401”> </ pre> </ div> <p>您将看到以下输出：</ p> <div class =“ codeblock”> <pre data-markx =“ 404”> </ pre> </ div> <p>这时，输出中有很多多余的空格。在下一节中，您将看到如何消除其中的大部分内容。</ p> </ li> </ ol> <p> <a name="ggyxa" id="ggyxa"> </a> </ p > <h2>修剪空白</ h2> <p>回想一下，当您查看DOM的结构时，有许多文本节点只包含可忽略的空白。输出中大多数多余的空白来自这些节点。幸运的是，XSL为您提供了一种消除它们的方法。（有关节点结构的更多信息，请参见<a class="TutorialLink" target="_top" href="xpath.html#gchlm"> XSLT / XPath数据模型</a>）。</ p> <hr> < span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<p> <b>注意-</ b>本节中讨论的样式表位于<tt> article1b.xsl </ tt>中将<a href="../examples/xslt_samples.zip"> XSLT示例</a>解压缩到<i> install-dir </ i> <后，在<tt> xslt / data </ tt>目录中tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1b.html </ tt>。</ p>->“> FORMAT_PLACEHOLDER_9 </ span> <p> <b>注意-< / b>本节中讨论的样式表位于<tt> article1b.xsl </ tt>中，在将<a class="SourceLink" target= 解压缩后，该文件位于 <tt> xslt / data </ tt>目录中。 “ _blank” href =“ ../ examples / xslt_samples.zip” onclick =“ showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 417“> </ code> </a>放入<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1b.html </ tt>。</ p> <hr> <p>要删除一些多余的空格，请添加以下突出显示的行</ p> <div class =“ codeblock”> <pre data-markx =“ 427”> </ pre> </ div> <p>此指令告诉XSL删除<tt>下的所有文本节点。 SECT </ tt>元素，其中只包含空格。包含非空格文本的节点将不受影响，其他类型的节点也将不受影响。</ p> <p> <a name="ghbaw" id="ghbaw"> </a> </ p> <h3>运行带有修剪空格的<tt> Stylizer </ tt>示例</ h3> <ol> <li> <b>导航到<tt> samples </ tt>目录。</ b> <div class =“ codeblock “> <pre data-markx =” 440“> </ pre> </ div> </ li> <span class =” notranslate hidefromparserselfclosedtags“ gtc：attrval =” <！-<li> <b> <a href =“ ../ examples / xslt_samples.zip”>通过单击此链接下载XSLT示例</a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt > <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li>->“> FORMAT_PLACEHOLDER_10 </ span> <li> <b> <a class = “ SourceLink” target =“ _ blank” href =“ ../ examples / xslt_samples.zip” onclick =“ showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 448“> </ code> </a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> <li> <b>导航到<tt> xslt </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 457”> </ pre> </ div> </ li> <li> <b>编译<tt> Stylizer </ tt>示例。 </ b> <p>键入以下命令：</ p> <div class =“ codeblock”> <pre data-markx =“ 463”> </ pre> </ div> </ li> <li> < b>使用样式表<tt> article1b.xsl </ tt>在<tt> article1.xml </ tt>上运行<tt> Stylizer </ tt>示例。</ b> <div class =“ codeblock”> <pre data-markx =“ 470”> </ pre> </ div> <p>您将看到以下输出：</ p> <div class =“ codeblock”> <pre data-markx =“ 473”> </ pre> </ div> <p>这是一个很大的改进。标题后面仍然有换行符和空格，但是它们来自XML的编写方式：</ p> <div class =“ codeblock”> <pre data-markx =“ 476”> </ pre> </ div> <p>在这里，您可以看到在开始PARA条目之前，节标题以换行符和缩进空间结尾。不必担心，因为将处理HTML的浏览器会压缩并例行忽略多余的空间。但是，还有另一种格式化工具可供我们使用。</ p> </ li> </ ol> <p> <a name="ghbbz" id="ghbbz"> </a> </ p> <h2 >删除最后一个空格</ h2> <hr> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<p> <b>注意-</ b>本节中讨论的样式表位于< tt> article1c.xsl </ tt>，该文件在您解压缩<a href="../examples/xslt_samples.zip"> XSLT示例</a>后的<tt> xslt / data </ tt>目录中进入<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1c.html </ tt>。</ p>->“> FORMAT_PLACEHOLDER_11 </ span> <p> <b>注意-< / b>本节中讨论的样式表位于<tt> article1c.xsl </ tt>中，在将<a class="SourceLink" target= 解压缩后，该文件位于 <tt> xslt / data </ tt>目录中。 “ _blank” href =“ ../ examples / xslt_samples.zip” onclick =“ showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 487“> </ code> </a>到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。结果是在<tt> xslt / data </ tt>中找到的<tt> stylizer1c.html </ tt>。</ p> <hr> <p>最后一点空格通过添加以下内容来处理到样式表：</ p> <div class =“ codeblock”> <pre data-markx =“ 497”> </ pre> </ div> <p>使用此样式表运行<tt> Stylizer </ tt>删除所有剩余的空白。</ p> <p> <a name="ghbah" id="ghbah"> </a> </ p> <h3>使用所有空白运行<tt> Stylizer </ tt>示例修剪</ h3> <ol> <li> <b>导航到<tt> samples </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 512”> < / pre> </ div> </ li> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<li> <b> <a href="../examples/xslt_samples.zip">下载单击此链接的XSLT示例</a>并将其解压缩到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发行日期</ i> <tt > / samples </ tt>目录。</ b> </ li>->“> FORMAT_PLACEHOLDER_12 </ span> <li> <b> <a class =” SourceLink“ target =” _ blank“ href =”.。 /examples/xslt_samples.zip“ onclick =” showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 520“> </ code> </a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> <li> <b>导航到<tt> xslt </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 529”> </ pre> </ div> </ li> <li> <b>编译<tt> Stylizer </ tt>示例。 </ b> <p>键入以下命令：</ p> <div class =“ codeblock”> <pre data-markx =“ 535”> </ pre> </ div> </ li> <li> < b>使用样式表<tt> article1c.xsl </ tt>在<tt> article1.xml </ tt>上运行<tt> Stylizer </ tt>示例。</ b> <div class =“ codeblock”> <pre data-markx =“ 542”> </ pre> </ div> <p>现在输出如下：</ p> <div class =“ codeblock”> <pre data-markx =“ 545”> </ pre> </ div> <p>那要好得多。当然，如果缩进会更好，但是事实证明它比预期的要难。以下是一些可能的攻击途径以及遇到的困难：</ p> <dl> <dt>缩进选项</ dt> <dd> <p>不幸的是，<tt> indent =“ yes” </ tt>可以应用于XML输出的选项不适用于HTML输出。即使该选项可用，也无济于事，因为HTML元素很少嵌套！尽管HTML源代码经常缩进来显示隐式结构，但是HTML标记本身并不是以创建真实结构的方式嵌套的。</ p> </ dd> <dt>缩进变量</ dt> <dd> <p > <tt> <xsl：text> </ tt>函数可让您添加所需的任何文本，包括空格。因此可以想象它可用于输出缩进空间。问题是改变缩进空间的数量。XSLT变量似乎是个好主意，但在这里不起作用。原因是，当您为模板中的变量分配值时，该值仅在该模板内才知道（静态，在编译时）。即使变量是全局定义的，分配的值也不会以使其他模板在运行时动态知道的方式存储。当<tt> <apply-templates /> </ tt>调用其他模板时，这些模板不知道在其他地方进行的任何变量设置。</ p> </ dd> <dt>参数化模板</ dt> <dd> < p>使用参数化模板是修改模板行为的另一种方法。但是确定作为参数传递的缩进空间的数量仍然是问题的症结所在。</ p> </ dd> </ dl> <p>目前，似乎没有任何好的方法可以解决这个问题。控制HTML格式输出的缩进。如果您需要将HTML显示或编辑为纯文本，这将很不方便。但这不是问题，如果您在XML表单上进行编辑，仅将HTML版本仅用于在浏览器中显示。（例如，当您查看<tt> stylizer1c.html </ tt>时，会看到预期的结果。）</ p> </ li> </ ol> <p> <a name =“ ghbam” id = “ ghbam”> </a> </ p> <h2>处理剩余的结构元素</ h2> <p>在本节中，您将处理<tt> LIST </ tt>和<tt> NOTE </ tt>元素，从而增加了文章的结构。</ p> <hr> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<p> <b>注意-</ b>该示例本节中描述的文档是<tt> article2.xml </ tt>，用于操作它的样式表是<tt> article2.xsl </ tt>。结果是<tt> stylizer2.html </ tt>。将<a href="../examples/xslt_samples.zip"> XSLT示例</a>解压缩到<i> install-dir <后，可以在<tt> xslt / data </ tt>目录中找到这些文件。 / i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ p>->“> FORMAT_PLACEHOLDER_13 </ span> <p> <b>注意-</ b>本节中描述的样本文档是<tt> article2.xml </ tt>，用于操作它的样式表是<tt> article2.xsl </ tt>。结果是<tt> stylizer2.html </ tt>。在您解压缩<a class="SourceLink" target="_blank" href="../examples/xslt_samples.zip" onclick="showCode(' 之后，在 <tt> xslt / data </ tt>目录中找到这些文件。 ../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 576“> </ code> </a>到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ p> <hr> <p>首先向示例文档中添加一些测试数据：</ p> <div class =“ codeblock” > <pre data-markx =“ 584”> </ pre> </ div> <hr> <p> <b>注意-</ b>尽管<tt> list </ tt>和<tt> note < XML文件中的/ tt>包含在它们各自的段落中，是否包含它们实际上没有什么区别；生成的HTML将是相同的。但是，将它们包含进来将使它们更易于在面向轮廓的编辑器中进行处理。</ p> <hr> <p> <a name="ggywf" id="ggywf"> </a> </ p> < h2>修改<tt> <PARA> </ tt>处理</ h2> <p>接下来，修改<tt> PARA </ tt>模板以考虑到我们现在允许某些结构元素嵌入段落：</ p> <div class =“ codeblock”> <pre data-markx =“ 598”> </ pre> </ div> <p>此修改使用与节标题相同的技术。唯一的区别是，段落中不应包含<tt> SECT </ tt>元素。（但是，一个段落很容易存在于另一个段落中，例如作为引用的材料）。</ p> <p> <a name="ggyua" id="ggyua"> </a> </ p> <h2 >处理<tt> <LIST> </ tt>和<tt> <ITEM> </ tt>元素</ h2> <p>现在您准备添加模板来处理<tt> LIST </ tt>元素：</ p> <div class =“ codeblock”> <pre data-markx =“ 612”> </ pre> </ div> <p> <tt> <xsl：if> </ tt>标签使用<tt> test =“” </ tt>属性以指定布尔条件。在这种情况下，将测试type属性的值，并且生成的列表会根据该值是有序还是无序而变化。</ p> <p>在此示例中注意两点：</ p> < ul> <li> <p>没有else子句，也没有return或exit语句，因此它需要两个<tt> <xsl：if> </ tt>标记来覆盖这两个选项。（或者可以使用<tt> <xsl：choose> </ tt>标签，该标签提供案例陈述功能）。</ p> </ li> <li> <p>在属性周围需要单引号价值观。否则，XSLT处理器会尝试将订购的单词解释为XPath函数而不是字符串。</ p> </ li> </ ul> <p>现在通过处理ITEM元素完成LIST处理：</ p> < div class =“ codeblock”> <pre data-markx =“ 626”> </ pre> </ div> <p> <a name="ggyvs" id="ggyvs"> </a> </ p> < h2>在样式表中订购模板</ h2> <p>到现在，您应该已经有了模板相互独立的想法，因此它们在文件中的位置通常无关紧要。因此，从现在开始，我们将仅显示您需要添加的模板。（为了进行比较，它们总是添加在示例样式表的末尾。）</ p> <p>当两个模板可以应用于同一节点时，顺序确实有所不同。在这种情况下，最后定义的是找到并处理的那个。例如，要更改缩进列表的顺序以使用小写字母，可以指定如下所示的模板模式：<tt> // LIST // LIST </ tt>。在该模板中，您将使用HTML选项而不是数字来生成字母枚举。</ p> <p>但是这种元素也可以通过模式<tt> // LIST </ tt>来标识。 。为了确保正确处理，指定<tt> // LIST </ tt>的模板必须出现在指定<tt> // LIST // LIST </ tt>的模板之前。</ p > <p> <a name="ggywm" id="ggywm"> </a> </ p> <h2>流程<tt> <NOTE> </ tt>元素</ h2> <p>最后一个剩余的元素结构元素是<tt> NOTE </ tt>元素。添加以下模板来处理该问题。</ p> <div class =“ codeblock”> <pre data-markx =“ 648”> </ pre> </ div> <p>此代码引发了一个有趣的问题，导致包含<tt> <br/> </ tt>标记。为了使文件格式正确，XML必须在样式表中将标签指定为<tt> <br/> </ tt>，但是许多浏览器无法识别该标签。尽管大多数浏览器都可以识别序列<tt> <br> </br> </ tt>，但它们都将其视为段落分隔符而不是单个换行符。</ p> <p>换句话说，转换必须生成<tt> <br> </ tt>标记，但是样式表必须指定<tt> <br/> </ tt>。这使我们想到了我们在样式表的早期添加的特殊输出标记的主要原因：</ p> <div class =“ codeblock”> <pre data-markx =“ 662”> </ pre> </ div> < p>该输出规范在输出时将空标签（例如<tt> <br/> </ tt>）转换为其HTML格式<tt> <br> </ tt>。该转换很重要，因为大多数浏览器无法识别空标记。以下是受影响的标记的列表：</ p> <div class =“ codeblock”> <pre data-markx =“ 668”> </ pre> </ div> <p>总而言之，默认情况下XSLT可以很好地生成输出的XML格式。而且由于XSL样式表是从格式良好的XML开始的，所以您不能轻易在其中间放置诸如<tt> <br> </ tt>之类的标签。<tt> <xsl：output method =“ html” /> </ tt>标记解决了此问题，因此您可以在样式表中编写<tt> <br/> </ tt>的代码，但获得<tt> <br> </ tt>在输出中。</ p> <p>指定<tt> <xsl：output method =“ html” /> </ tt>的另一个主要原因是，与规范<tt> < xsl：output method =“ text” /> </ tt>，生成的文本不会转义。例如，如果样式表包含<tt> << / tt>实体引用，则它将在生成的文本中显示为<tt> << / tt>字符。另一方面，当生成XML时，样式表中的<tt> << / tt>实体引用将保持不变，因此在生成的文本中将显示为<tt> << / tt>。</ p> <hr> <p> <b>注意-</ b>如果实际上希望将<tt> << / tt>生成为HTML输出的一部分，则需要将其编码为<tt> << / tt>。该序列在输出上变为<tt> << / tt>，因为只有<tt>＆</ tt>被转换为<tt>＆</ tt>字符。</ p> <hr> <p> <名称=“ ghbeb” id =“ ghbeb”> </a> </ p> <h3>使用<tt> LIST </ tt>和<tt> NOTE </ tt>运行</ tt> Stylizer </ tt>示例tt>定义的元素</ h3> <ol> <li> <b>导航到<tt> samples </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 701 “> </ pre> </ div> </ li> <span class =” notranslate hidefromparserselfclosedtags“ gtc：attrval =” <！-<li> <b> <a href =“ ../ examples / xslt_samples.zip “>通过单击此链接下载XSLT示例</a>，并将它们解压缩到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发行日期</ i > <tt> / samples </ tt>目录。</ b> </ li>->“> FORMAT_PLACEHOLDER_14 </ span> <li> <b> <a class =” SourceLink“ target =” _ blank“ href = “ ../examples/xslt_samples.zip” onclick =“ showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 709“> </ code> </a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> <li> <b>导航到<tt> xslt </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 718”> </ pre> </ div> </ li> <li> <b>编译<tt> Stylizer </ tt>示例。 </ b> <p>键入以下命令：</ p> <div class =“ codeblock”> <pre data-markx =“ 724”> </ pre> </ div> </ li> <li> < b>使用样式表<tt> article2.xsl </ tt>在<tt> article2.xml </ tt>上运行<tt> Stylizer </ tt>示例。</ b> <div class =“ codeblock”> <pre data-markx =“ 731”> </ pre> </ div> <p>以下是当您现在运行程序时为第二部分生成的HTML：</ p> <div class =“ codeblock” > <pre data-markx =“ 734”> </ pre> </ div> </ li> </ ol> <p> <a name="ggywl" id="ggywl"> </a> </ p > <h2>处理内联（内容）元素</ h2> <p> <tt> ARTICLE </ tt>类型中唯一剩余的标签是内联标签-不会在输出中创建换行符的标签，但是相反</ p> <p>内联元素与结构元素的不同之处在于，内联元素是标签内容的一部分。如果您将元素视为文档树中的一个节点，则每个节点都具有内容和结构。内容由包含的文本和内联标签组成。结构由标签下的其他元素（结构元素）组成。</ p> <hr> <p> <b>注意-</ b>本部分描述的示例文档为<tt> article3.xml </ </ b> tt>，用于操作它的样式表为<tt> article3.xsl </ tt>。结果是<tt> stylizer3.html </ tt>。</ p> <hr> <p>首先将更多测试数据添加到示例文档中：</ p> <div class =“ codeblock”> <pre data-markx =“ 750”> </ pre> </ div> <p>现在处理段落中的内联<tt> <DEF> </ tt>元素，并将其重命名为HTML斜体标签：</ p> <div class =“ codeblock”> <pre data-markx =“ 765”> </ pre> </ div> <p>接下来，注释掉文本节点规范化。它已经达到了目的，现在您需要保留重要的空间：</ p> <div class =“ codeblock”> <pre data-markx =“ 771”> </ pre> </ div > <p>此修改使我们避免在诸如<tt> <I> </ tt>和<tt> <DEF> </ tt>之类的标签之前丢失空格。（请尝试不做此修改的程序以查看结果）。</ p> <p>现在处理基本的内联HTML元素，例如<tt> <B> </ tt>，<tt> <I> </ tt>和<tt> <U> </ tt>表示粗体，斜体和下划线。</ p> <div class =“ codeblock”> <pre data-markx =“ 782”> </ pre> </ div> < p> <tt> <xsl：element> </ tt>标记可让您计算要生成的元素。在这里，您可以使用当前元素的名称生成适当的内联标签。特别要注意在<tt> name =“ ..” </ tt>表达式中使用花括号（<tt> {} </ tt>）。这些花括号将引号内的文本作为XPath表达式处理，而不是解释为文字字符串。在这里，它们使XPath <tt> name（）</ tt>函数返回当前节点的名称。</ p> <p>在任何可能出现属性值模板的地方都可以识别出大括号。（属性值模板在XSLT规范的7.6.2节中定义，并且它们在模板定义中出现在多个位置）。在这样的表达式中，花括号还可以用于引用属性的值<tt> {@ foo} </ tt>或元素<tt> {foo} </ tt>的内容。 / p> <hr> <p> <b>注意-</ b>您还可以使用<tt> <xsl：attribute> </ tt>生成属性。有关更多信息，请参见XSLT规范的7.1.3节。</ p> <hr> <p>最后剩余的元素是<tt> LINK </ tt>标记。处理该标签的最简单方法是设置一个可使用参数驱动的命名模板：</ p> <div class =“ codeblock”> <pre data-markx =“ 804”> </ pre> < / div> <p>此模板的主要区别在于，您无需使用match子句，而是使用<tt> name =“” </ tt>子句为模板命名。因此，此模板仅在您调用它时才执行。</ p> <p>在模板中，您还使用<tt> <xsl：param> </ tt>指定一个名为<tt> dest </ tt>的参数。标签。为了进行一些错误检查，您可以使用select子句为该参数赋予默认值<tt> UNDEFINED </ tt>。要在<tt> <xsl：value-of> </ tt>标记中引用变量，请指定<tt> </ tt>。</ p> <hr> <p> <b>注意-</ b >回想一下，引号中的条目将被解释为表达式，除非将其进一步用单引号引起来。这就是为什么在<tt>“ @ type ='ordered'” </ tt>中需要单引号的原因，以确保将ordered解释为字符串。</ p> <hr> <p> <tt> <xsl：element> </ tt>标记生成一个元素。以前，您可以通过编码<tt> <html> </ tt>之类的代码来简单地指定所需的元素。但是在这里，您是在<tt> <xsl：element> </ tt>标记的主体中动态生成HTML锚点（<tt> <a> </ tt>）的内容。并且您正在使用<tt> <xsl：attribute> </ tt>标签动态生成锚点的<tt> href </ tt>属性。</ p> <p>模板的最后一个重要部分是<tt> <apply-templates> </ tt>标记，它从<tt> LINK </ tt>元素下的文本节点插入文本。没有它，生成的HTML链接中将没有文本。</ p> <p>下一步，为<tt> LINK </ tt>标签添加模板，然后从其中调用命名模板：</ p > <div class =“ codeblock”> <pre data-markx =“ 840”> </ pre> </ div> <p>如果目标是<tt> test =“ @ target” </ tt>子句，则返回true属性存在于LINK标记中。因此，当链接的文本和为其定义的目标不同时，此<tt> <xsl-if> </ tt>标记会生成HTML链接。</ p> <p> <tt> <xsl：call-template > </ tt>标记将调用命名模板，而<tt> <xsl：with-param> </ tt>使用name子句指定参数，并使用select子句指定其值。</ p> <p>在样式表构建过程的最后一步，添加<tt> <xsl-if> </ tt>标签以处理没有目标属性的<tt> LINK </ tt>标签。</ p> <div class =“ codeblock”> <pre data-markx =“ 859”> </ pre> </ div> <p> <tt> not（...）</ tt>子句会反转先前的测试（请记住，是else子句）。因此，当未指定target属性时，将解释模板的这一部分。这次，参数值不是来自select子句，而是来自<tt> <xsl：with-param> </ tt>元素的内容。</ p> <hr> <p> <b>注意- </ b>只是为了明确起见：参数和变量（稍后在<a href="#ggyut"> XSLT还能做什么中讨论）。</a>可以通过允许使用XPath表达式的select子句或允许使用XSLT标记的元素内容来指定其值。</ p> <hr> <p>在这种情况下，参数的内容由<tt> <xsl：apply-templates /> </ tt>标记生成，该标记将文本节点的内容插入到<tt> LINK </ tt>元素下方。</ p > <p> <a name="ghbdo" id="ghbdo"> </a> </ p> <h3>运行带有定义的内联元素的<tt> Stylizer </ tt>示例</ h3> <ol> <li> <b>导航至<tt> samples </ tt>目录。</ b> <div class =“ codeblock”> <pre data-markx =“ 887”> </ pre> </ div> < / li> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-<li> <b> <a href="../examples/xslt_samples.zip">通过单击此链接下载XSLT示例< / a>并将其解压缩到<i>安装目录</ i> <tt> / jaxp-1_4_2-</ tt> <i>发行日期</ i> <tt> / samples </ tt>目录中。</ b> </ li>->“> FORMAT_PLACEHOLDER_15 </ span> <li> <b> <a class =” SourceLink“ target =” _ blank“ href =” ../ examples / xslt_samples.z ip“ onclick =” showCode（'../../displayCode.html'，'../examples/xslt_samples.zip'）;返回false;“> <code data-markx =” 895“> </ code> </a>并将其解压缩到<i> install-dir </ i> <tt> / jaxp-1_4_2-</ tt> <i>发布日期</ i> <tt> / samples </ tt>目录。</ b> </ li> <li> <b>导航到<tt> xslt </ tt>目录。</ b> <<div class =“ codeblock”> <pre data-markx =“ 904”> </ pre> </ div> </ li> <li> <b>编译<tt> Stylizer </ tt>示例。</ b> <p>键入以下命令：</ p> <div class =“ codeblock”> <pre data-markx =“ 910”> </ pre> </ div> </ li> <li> <b>使用样式表<tt> article3.xsl </ tt>在<tt> article3.xml </ tt>上运行<tt> Stylizer </ tt>示例。</ b> <div class =“ codeblock” > <pre data-markx =“ 917”> </ pre> </ div> <p>现在运行程序时，结果应如下所示：</ p> <div class =“ codeblock”> < pre data-markx =“ 920”> </ pre> </ div> <p>做得好！现在，您已经将一个相当复杂的XML文件转换为HTML。 （乍看起来似乎很简单，但是无疑为探索提供了很多机会。</ p> </ li> </ ol> <p> <a> <a name="ggywy" id="ggywy"> </ a > </ p> <h2>打印HTML </ h2> <p>您现在已经将XML文件转换为HTML。有一天，某人将产生一个可识别HTML的打印引擎，您可以通过Java Printing Service API查找和使用它。届时，您将能够通过生成HTML来打印任意XML文件。您要做的就是设置样式表并使用浏览器。</ p> <p> <a name="ggyut" id="ggyut"> </a> </ p> <h2>还有什么XSLT可以吗？</ h2> <p>与本节一样，它只是XSLT功能的表面。XSLT规范中还有许多其他可能性在等待您。以下是一些要查找的东西：</ p> <dl> <dt> <tt> import </ tt>（第2.6.2节）和<tt> include </ tt>（第2.6.1节）</ dt> <dd> <p> <tt> rt </ tt>（第2.6.2节）和include（第2.6.1节）使用这些语句来模块化和组合XSLT样式表。include语句仅插入包含文件中的所有定义。import语句使您可以使用自己的样式表中的定义覆盖导入文件中的定义。</ p> </ dd> <dt> <tt> for-each </ tt>循环（第8节）</ dt> <dd > <p>遍历一组项目并依次处理每个项目。</ p> </ dd> <dt> <tt>选择</ tt>（案例陈述）以进行条件处理（9.2节）</ dt > <dd> <p>根据输入值分支到多个处理路径之一。</ p> </ dd> <dt>生成数字（第7.7节）</ dt> <dd> <p>动态生成编号部分，编号的元素和数字文字。XSLT提供了三种编号模式：</ p> <ul> <li> <p>单：对单个标题下的项目进行编号，例如HTML中的有序列表</ p> </ li> <li> <p>产生多级编号，例如“ A.1.3” </ p> </ li> <li> <p>任何：连续对项目出现的位置进行编号，如在课程中的脚注一样。</ p> </ li> </ ul> </ dd> <dt>格式化数字（第12.3节）</ dt> <dd> <p>控制枚举格式，以便获取数字（<tt> format =“ 1” </ tt>），大写字母（<tt> format =“ A” </ tt>），小写字母（<tt> format =“ a” </ tt>）或复合数字（例如“ A.1”）以及数字和货币金额</ p> </ dd> <dt>排序输出（第10节）</ dt> <dd> <p>以所需的排序顺序生成输出。</ p> </ dd> <dt>基于模式的模板（第5.7节）</ dt> <dd> <p>多次处理一个元素，每次以不同的“模式”进行。您将mode属性添加到模板，然后指定<tt> <apply-templates mode =“ ...”> </ tt>以仅应用具有匹配模式的模板。结合<tt> <apply-templates select =“ ...”> </ tt>属性，将基于模式的处理应用于输入数据的子集。</ p> </ dd> <dt>变量（第11节）</ dt> <dd> <p>变量类似于方法参数，因为它们使您可以控制模板的行为。但是它们并不像您想象的那样有价值。变量的值仅在定义它的当前模板或<tt> <xsl：if> </ tt>标记（例如）的范围内才是已知的。您不能将值从一个模板传递到另一个模板，甚至不能从模板的封闭部分传递到同一模板的另一部分。</ p> <p>这些语句即使对于“全局”变量也适用。您可以在模板中更改其值，但是更改仅适用于该模板。当评估用于定义全局变量的表达式时，该评估在结构的根节点的上下文中进行。换句话说，全局变量本质上是运行时常量。这些常量对于更改模板的行为很有用，尤其是在与include和import语句结合使用时。但是变量不是通用的数据管理机制。</ p> </ dd> </ dl> <p> <a name="ggyuy" id="ggyuy"> </a> </ p> < h2>变量问题</ h2> <p>创建单个模板并为链接的目标设置变量很诱人，而不是麻烦地设置参数化模板并以两种不同方式调用它。想法是将变量设置为默认值（例如<tt> LINK </ tt>标记的文本），然后，如果目标属性存在，则将目标变量设置为目标属性的值。 / p> <p>如果可行，那将是个好主意。但同样，问题在于变量仅在定义它们的范围内是已知的。因此，当您编写<tt> <xsl：if> </ tt>标记以更改变量的值时，该值仅在<tt> <xsl：if> </ tt>标记的上下文中才是已知的。一旦遇到<tt> </ xsl：if> </ tt>，该变量设置的任何更改都将丢失。</ p> <p>同样诱人的想法是可以替换<tt> text（）|。 B | I | U | DEF | LINK </ tt>规范，带有变量（<tt> </ tt>）。但是因为变量的值由定义的位置决定，所以全局内联变量的值由文本节点，<tt> <B> </ tt>节点等组成，这些节点恰好存在于根目录下水平。换句话说，在这种情况下，此类变量的值为null。</ p> </ div> <div class =“ NavBit”> <a target="_top" href="generatingXML.html">«上一页</a>•<a target =“ _ top” href =“.。/TOC.html“>足迹</a>•<a target="_top" href="../stax/index.html">下一个»</a> </ div> </ div> <hr class = “ clearfloat”> <div id =“ Footer”> <p class =“ footertext”> <a href="http://www.oracle.com/corporate/index.html">关于Oracle </a> | < a href =“ http://www.oracle.com/us/corporate/contact/index.html”>与我们联系</a> | <a href =“ http://www.oracle.com/us/legal /index.html“>法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href =“ http://www.oracle.com/us/legal/privacy/index.html”>您的隐私权</a> </ p> <p class =“ footertext”> <a href =“ http：/ /www.oracle.com/pls/topic/lookup?ctx=cpyr&id=zh-CN“>版权所有©1995、2017 Oracle和/或其分支机构。</a> </ p> </ div> <div class =“ PrintHeaders”> <b>上一页：</ b>从任意数据结构生成XML <br> <b>下一页： </ b> XML的流API </ div> <span class =“ notranslate hidefromparserselfclosedtags” gtc：attrval =“ <！-启动SiteCatalyst代码->”> FORMAT_PLACEHOLDER_16 </ span> <script type =“ application / javascript “ src =” https://www.oracleimg.com/us/assets/metrics/ora_docs.js“ data-markx =” 1005“> </ script> <span class =” notranslate hidefromparserselfclosedtags“ gtc：attrval =” < ！-结束SiteCatalyst代码->“> FORMAT_PLACEHOLDER_17 </ span> </ body> </ html></title></tt></p></li></ul></div></div></body></html>