<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>使用文件和格式转换器（Java™教程>声音）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="">
     <meta name="keywords" content="java programming, learn java, java sample code, ">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkAHEAD"><a href="sampled-overview.html">采样包概述</a></div>
<div class="linkAHEAD"><a href="accessing.html">访问音频系统资源</a></div>
<div class="linkAHEAD"><a href="playing.html">播放音频</a></div>
<div class="linkAHEAD"><a href="capturing.html">捕捉音频</a></div>
<div class="linkAHEAD"><a href="controls.html">使用控件处理音频</a></div>
<div class="nolinkAHEAD">使用文件和格式转换器</div>
<div class="linkAHEAD"><a href="overview-MIDI.html">MIDI包概述</a></div>
<div class="linkAHEAD"><a href="accessing-MIDI.html">访问MIDI系统资源</a></div>
<div class="linkAHEAD"><a href="MIDI-messages.html">传输和接收MIDI信息</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-intro.html">音序器简介</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-methods.html">使用定序器方法</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-adv.html">使用高级音序器功能</a></div>
<div class="linkAHEAD"><a href="MIDI-synth.html">合成声音</a></div>
<div class="linkAHEAD"><a href="SPI-intro.html">服务提供商接口简介</a></div>
<div class="linkAHEAD"><a href="SPI-providing-sampled.html">提供音频采样服务</a></div>
<div class="linkAHEAD"><a href="SPI-providing-MIDI.html">提供MIDI服务</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>踪迹：</b>声音</div>
            <div id="BreadCrumbs">
                <a href="../index.html" target="_top">主页</a> > <a href="./index.html" target="_top">声音</a>
            </div>
            <div class="NavBit">
                <a href="controls.html" target="_top">«上一个</a> • <a href="./TOC.html" target="_top">追踪</a> • <a href="overview-MIDI.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>使用文件和格式转换器</h1></div>
            <div id="PageContent">

<p><a name="117603"></a>大多数处理声音的应用程序都需要读取声音文件或音频流。这是通用功能，而与程序随后对读取的数据（例如播放，混合或处理）无关。同样，许多程序需要编写声音文件（或流）。在某些情况下，已读取（或将要写入）的数据需要转换为其他格式。</p>
<p><a name="117604"></a>正如在<a class="TutorialLink" href="accessing.html" target="_top">访问音频系统资源中</a>简要提到的那样，Java Sound API为应用程序开发人员提供了用于文件输入/输出和格式转换的各种功能。应用程序可以在各种声音文件格式和音频数据格式之间进行读取，写入和转换。</p>
<p><a name="114517"></a> <a class="TutorialLink" href="sampled-overview.html" target="_top">采样包概述</a>介绍了与声音文件和音频数据格式有关的主要类。作为评论：</p>
<ul>
<li><a name="114884"></a>音频数据流（可能会从文件中读取或写入文件）由<code>AudioInputStream</code>宾语。 （ <code>AudioInputStream</code>继承自<code>java.io.InputStream</code> ）</li>
<li><a name="114885"></a>此音频数据的格式由<code>AudioFormat</code>宾语。
<p><a name="117222"></a>此格式指定音频样本本身的排列方式，但不指定它们可能存储在其中的文件的结构。换句话说， <code>AudioFormat</code>描述了“原始”音频数据，例如系统可能会在从麦克风输入中捕获程序或从声音文件中解析程序后将其交给您。一个<code>AudioFormat</code>包括诸如编码，字节顺序，通道数，采样率和每个采样的位数之类的信息。</p>
</li>
<li><a name="114521"></a>声音文件有几种众所周知的标准格式，例如WAV，AIFF或AU。不同类型的声音文件具有用于存储音频数据以及用于存储关于音频数据的描述性信息的不同结构。声音文件格式在Java Sound API中由<code>AudioFileFormat</code>宾语。的<code>AudioFileFormat</code>包括<code>AudioFormat</code>对象，用于描述存储在文件中的音频数据的格式，还包括有关文件类型和文件中数据长度的信息。</li>
<li><a name="114522"></a>的<code>AudioSystem</code>此类提供以下方法：（1）存储来自<code>AudioInputStream</code>放入特定类型的音频文件（换句话说，就是写入文件），（2）提取音频字节流（ <code>AudioInputStream</code> ）从音频文件（换句话说，读取文件），以及（3）将音频数据从一种数据格式转换为另一种数据格式。该页面分为三个部分，解释了这三种活动。</li>
</ul>
<p><a name="114524"></a></p>
<div class="note"><hr><strong>注意：</strong> <p>Java Sound API的实现不一定提供用于读取，写入和转换不同数据和文件格式的音频的全面功能。它可能仅支持最常见的数据和文件格式。但是，服务提供商可以开发和分发扩展该集合的转换服务，如您稍后将在<a href="SPI-providing-sampled.html">提供采样音频服务中</a>看到的那样。的<code>AudioSystem</code>类提供了一些方法，这些方法使应用程序可以学习可用的转换，如稍后在“ <a href="#114640">转换文件和数据格式”下所述</a> 。<a name="114527"></a></p>
<hr></div>
<h2>读取声音文件</h2>
<p><a name="114529"></a>的<code>AudioSystem</code>类提供两种类型的文件读取服务：</p>
<ul>
<li><a name="114530"></a>有关存储在声音文件中的音频数据格式的信息</li>
<li><a name="114531"></a>可以从声音文件读取的格式化音频数据流</li>
</ul>
<p><a name="118569"></a>其中的第一个是由<code>getAudioFileFormat</code>方法：</p>
<div class="codeblock"><pre>
    static AudioFileFormat getAudioFileFormat (java.io.File file)
    static AudioFileFormat getAudioFileFormat(java.io.InputStream stream)
    static AudioFileFormat getAudioFileFormat (java.net.URL url)
</pre></div>
<p>如上所述，返回<code>AudioFileFormat</code> object告诉您文件类型，文件中数据的长度，编码，字节顺序，通道数，采样率和每个样本的位数。</p>
<p><a name="114541"></a>这些文件提供了第二种文件读取功能<code>AudioSystem</code>方法</p>
<div class="codeblock"><pre>
    static AudioInputStream getAudioInputStream (java.io.File file)
    static AudioInputStream getAudioInputStream (java.net.URL url)
    static AudioInputStream getAudioInputStream (java.io.InputStream stream)
</pre></div>
<p>这些方法为您提供了一个对象（ <code>AudioInputStream</code> ），您可以使用以下一种读取方法来读取文件的音频数据： <code>AudioInputStream</code> 。我们暂时看一个例子。</p>
<p><a name="114549"></a>假设您正在编写一个声音编辑应用程序，该应用程序允许用户从文件中加载声音数据，显示相应的波形或频谱图，编辑声音，回放编辑后的数据并将结果保存到新文件中。也许您的程序将读取存储在文件中的数据，进行某种信号处理（例如在不改变音调的情况下减慢声音的算法），然后播放处理后的音频。无论哪种情况，您都需要访问音频文件中包含的数据。假设您的程序为用户提供了一些选择或指定输入声音文件的方法，那么读取该文件的音频数据涉及三个步骤：</p>
<ol>
<li><a name="114551"></a>得到一个<code>AudioInputStream</code>文件中的对象。</li>
<li><a name="114552"></a>创建一个字节数组，您将在其中存储文件中的连续数据块。</li>
<li><a name="114553"></a>从音频输入流中反复读取字节到数组中。在每次迭代中，对数组中的字节进行一些有用的操作（例如，您可以播放它们，过滤它们，分析它们，显示它们或将它们写入另一个文件）。</li>
</ol>
<p><a name="114555"></a>以下代码片段概述了这些步骤：</p>
<div class="codeblock"><pre>
int totalFramesRead = 0;
File fileIn = new File(somePathName);
// somePathName is a pre-existing string whose value was
// based on a user selection.
try {
  AudioInputStream audioInputStream = 
    AudioSystem.getAudioInputStream(fileIn);
  int bytesPerFrame = 
    audioInputStream.getFormat().getFrameSize();
    if (bytesPerFrame == AudioSystem.NOT_SPECIFIED) {
    // some audio formats may have unspecified frame size
    // in that case we may read any amount of bytes
    bytesPerFrame = 1;
  } 
  // Set an arbitrary buffer size of 1024 frames.
  int numBytes = 1024 * bytesPerFrame; 
  byte[] audioBytes = new byte[numBytes];
  try {
    int numBytesRead = 0;
    int numFramesRead = 0;
    // Try to read numBytes bytes from the file.
    while ((numBytesRead = 
      audioInputStream.read(audioBytes)) != -1) {
      // Calculate the number of frames actually read.
      numFramesRead = numBytesRead / bytesPerFrame;
      totalFramesRead += numFramesRead;
      // Here, do something useful with the audio data that's 
      // now in the audioBytes array...
    }
  } catch (Exception ex) { 
    // Handle the error...
  }
} catch (Exception e) {
  // Handle the error...
}
</pre></div>
<p>让我们看看上面的代码示例中发生了什么。首先，外部try子句实例化一个<code>AudioInputStream</code>通过调用对象<code>AudioSystem.getAudioInputStream(File)</code>方法。此方法透明地执行所有必要的测试，以确定指定的文件是否实际上是Java Sound API支持的类型的声音文件。如果正在检查文件（ <code>fileIn</code>在此示例中）不是声音文件，或者是某些不受支持的类型的声音文件， <code>UnsupportedAudioFileException</code>引发异常。这种行为很方便，因为应用程序程序员无需为测试文件属性而烦恼，也不必遵循任何文件命名约定。相反， <code>getAudioInputStream</code>该方法负责验证输入文件所需的所有低级解析和验证。 <a name="114595"></a> 外层<code>try</code>子句然后创建一个字节数组， <code>audioBytes</code> ，具有任意固定长度。我们确保其长度（以字节为单位）等于帧的整数，这样我们就不会最终只读取一部分帧，甚至更糟的是仅读取一部分样本。该字节数组将用作缓冲区，以临时保存从流中读取的音频数据块。如果我们知道只读取非常短的声音文件，则可以读取任何内容，则可以通过从帧的长度中得出字节的长度来得出此数组与文件中的数据相同的长度，如<code>AudioInputStream's getFrameLength</code>方法。（实际上，我们可能只会使用<code>Clip</code>对象。）但是为了避免在通常情况下用尽内存，我们改为分块读取文件，一次读取一个缓冲区。</p>
<p><a name="114597"></a>内在<code>try</code>子句包含一个<code>while</code>循环，这是我们从中读取音频数据的地方<code>AudioInputStream</code>放入字节数组。您应该在此循环中添加代码，以适合程序需要的任何方式处理此数组中的音频数据。如果您要对数据进行某种信号处理，则可能需要查询<code>AudioInputStream's AudioFormat</code>进一步，了解每个样本的位数等等。</p>
<p><a name="114599"></a>注意方法<code>AudioInputStream.read(byte[])</code>返回读取的<em>字节</em>数，而不是样本或帧的数目。没有更多数据可读取时，此方法返回-1。在检测到这种情况后，我们从<code>while</code>环。</p>
<p><a name="114602"></a></p>
<h2>写入声音文件</h2>
<p><a name="114604"></a>上一节介绍了使用特定方法读取声音文件的基础。 <code>AudioSystem</code>和<code>AudioInputStream</code>类。本节介绍如何将音频数据写出到新文件中。</p>
<p><a name="114606"></a>下列<code>AudioSystem</code>方法创建指定文件类型的磁盘文件。该文件将包含指定的音频数据<code>AudioInputStream</code> ：</p>
<div class="codeblock"><pre>
static int write(AudioInputStream in, 
  AudioFileFormat.Type fileType, File out)
</pre></div>
<p>请注意，第二个参数必须是系统支持的文件类型之一（例如AU，AIFF或WAV），否则， <code>write</code>方法会抛出一个<code>IllegalArgumentException</code> 。为避免这种情况，您可以测试是否<code>AudioInputStream</code>可以通过调用此文件将其写入特定类型的文件<code>AudioSystem</code>方法：</p>
<div class="codeblock"><pre>
static boolean isFileTypeSupported
  (AudioFileFormat.Type fileType, AudioInputStream stream)
</pre></div>
<p>它将返回<code>true</code>仅在支持特定组合的情况下。</p>
<p><a name="114618"></a>通常，您可以通过调用以下类型之一来了解系统可以写入的文件类型： <code>AudioSystem</code>方法：</p>
<div class="codeblock"><pre>
static AudioFileFormat.Type[] getAudioFileTypes() 
static AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) 
</pre></div>
<p>其中第一个返回系统可以写入的所有文件类型，第二个仅返回系统可以从给定的音频输入流写入的文件类型。</p>
<p><a name="119705"></a>以下摘录演示了一种从文件创建输出文件的技术<code>AudioInputStream</code>使用<code>write</code>上面提到的方法。</p>
<div class="codeblock"><pre>
File fileOut = new File(someNewPathName);
AudioFileFormat.Type fileType = fileFormat.getType();
if (AudioSystem.isFileTypeSupported(fileType, 
    audioInputStream)) {
  AudioSystem.write(audioInputStream, fileType, fileOut);
}
</pre></div>
<p>上面的第一条语句创建了一个新的<code>File</code>宾语， <code>fileOut</code> ，具有用户或程序指定的路径名。第二条语句从预先存在的文件中获取文件类型<code>AudioFileFormat</code>对象称为<code>fileFormat</code> ，它可能是从另一个声音文件获得的，例如上面的“ <a href="#114527">读取声音文件”</a>中<a href="#114527">读取的文件</a> 。（您可以改为提供所需的任何受支持文件类型，而不是从其他位置获取文件类型。例如，您可以删除第二条语句并替换其他两个出现的<code>fileType</code>在上面的代码中<code>AudioFileFormat.Type.WAVE</code> ）</p>
<p><a name="114635"></a>第三条语句测试是否可以从期望的文件中写入指定类型的文件<code>AudioInputStream</code> 。像文件格式一样，此流可能来自先前读取的声音文件。（如果是这样，大概是您已经以某种方式处理或更改了其数据，因为否则，有更简单的方法可以简单地复制文件。）或者，该流包含从麦克风输入中刚捕获的字节。</p>
<p><a name="114637"></a>最后，将流，文件类型和输出文件传递给<code>AudioSystem</code> 。 <code>write</code>方法，以达到写入文件的目的。</p>
<p><a name="114640"></a></p>
<h2>转换文件和数据格式</h2>
<p><a name="114642"></a>从<a class="TutorialLink" href="sampled-overview.html#formatted" target="_top">什么是格式化音频数据</a>回想起<a class="TutorialLink" href="sampled-overview.html#formatted" target="_top">？</a> ，即Java Sound API区分音频<em>文件</em>格式和音频<em>数据</em>格式。两者或多或少是独立的。粗略地说，数据格式是指计算机表示每个原始数据点（样本）的方式，而文件格式是指存储在磁盘上的声音文件的组织。每种声音文件格式都有一个特定的结构，该结构定义了例如存储在文件头中的信息。在某些情况下，除了实际的“原始”音频样本外，文件格式还包括包含某种形式的元数据的结构。该页面的其余部分将研究Java Sound API的方法，这些方法支持各种文件格式和数据格式转换。</p>
<p><a name="114644"></a></p>
<h2>从一种文件格式转换为另一种文件格式</h2>
<p><a name="114646"></a>本节介绍了在Java Sound API中转换音频文件类型的基础。我们再次提出一个假设的程序，这次的目的是从任意输入文件中读取音频数据并将其写入类型为AIFF的文件中。当然，输入文件必须是系统能够读取的类型，而输出文件必须是系统能够写入的类型。（在此示例中，我们假定系统能够写入AIFF文件。）该示例程序不执行任何数据格式转换。如果输入文件的数据格式不能表示为AIFF文件，则该程序只是通知用户该问题。另一方面，如果输入的声音文件已经是AIFF文件，则程序会通知用户不需要进行转换。</p>
<p><a name="114648"></a>以下函数实现了刚刚描述的逻辑：</p>
<div class="codeblock"><pre>
public void ConvertFileToAIFF(String inputPath, 
  String outputPath) {
  AudioFileFormat inFileFormat;
  File inFile;
  File outFile;
  try {
    inFile = new File(inputPath);
    outFile = new File(outputPath);     
  } catch (NullPointerException ex) {
    System.out.println("Error: one of the 
      ConvertFileToAIFF" +" parameters is null!");
    return;
  }
  try {
    // query file type
    inFileFormat = AudioSystem.getAudioFileFormat(inFile);
    if (inFileFormat.getType() != AudioFileFormat.Type.AIFF) 
    {
      // inFile is not AIFF, so let's try to convert it.
      AudioInputStream inFileAIS = 
        AudioSystem.getAudioInputStream(inFile);
      inFileAIS.reset(); // rewind
      if (AudioSystem.isFileTypeSupported(
             AudioFileFormat.Type.AIFF, inFileAIS)) {
         // inFileAIS can be converted to AIFF. 
         // so write the AudioInputStream to the
         // output file.
         AudioSystem.write(inFileAIS,
           AudioFileFormat.Type.AIFF, outFile);
         System.out.println("Successfully made AIFF file, "
           + outFile.getPath() + ", from "
           + inFileFormat.getType() + " file, " +
           inFile.getPath() + ".");
         inFileAIS.close();
         return; // All done now
       } else
         System.out.println("Warning: AIFF conversion of " 
           + inFile.getPath()
           + " is not currently supported by AudioSystem.");
    } else
      System.out.println("Input file " + inFile.getPath() +
          " is AIFF." + " Conversion is unnecessary.");
  } catch (UnsupportedAudioFileException e) {
    System.out.println("Error: " + inFile.getPath()
        + " is not a supported audio file type!");
    return;
  } catch (IOException e) {
    System.out.println("Error: failure attempting to read " 
      + inFile.getPath() + "!");
    return;
  }
}
</pre></div>
<p><a name="114706"></a>如前所述，该示例功能的目的是<code>ConvertFileToAIFF</code> ，是查询输入文件以确定它是否是AIFF声音文件，如果不是，则尝试将其转换为一个文件，从而生成路径名由第二个参数指定的新副本。（作为练习，您可以尝试使此函数更通用，以便使该函数不再转换为AIFF，而是转换为新函数参数指定的文件类型。）请注意，副本的音频数据格式（即新文件）模仿原始输入文件的音频数据格式。</p>
<p><a name="114708"></a>此功能大部分是不言自明的，并且不特定于Java Sound API。但是，例程使用了一些Java Sound API方法，这些方法对于声音文件类型的转换至关重要。这些方法调用全部在第二篇中找到<code>try</code>条款，并包括以下内容：</p>
<ul>
<li><a name="114710"></a><code>AudioSystem.getAudioFileFormat</code> ：在这里用于确定输入文件是否已经是AIFF类型。如果是这样，函数将快速返回；否则，将继续进行转换尝试。</li>
<li><a name="114712"></a><code>AudioSystem.isFileTypeSupported</code> ：指示系统是否可以写入包含来自指定音频数据的指定类型的文件<code>AudioInputStream.</code>在我们的示例中，此方法返回<code>true</code>指定的音频输入文件是否可以转换为AIFF音频文件格式。如果<code>AudioFileFormat.Type.AIFF</code>不被支持， <code>ConvertFileToAIFF</code>发出警告，提示输入文件无法转换，然后返回。</li>
<li><a name="114714"></a><code>AudioSystem.write</code> ：用于从AudioInputStream写入音频数据<code>inFileAIS</code>到输出文件<code>outFile</code> 。</li>
</ul>
<p><a name="114716"></a>这些方法中的第二种<code>isFileTypeSupported</code>有助于在写入之前确定特定的输入声音文件是否可以转换为特定的输出声音文件类型。在下一部分中，我们将看到如何对此进行一些修改<code>ConvertFileToAIFF</code>在示例例程中，我们可以转换音频数据格式以及声音文件类型。</p>
<p><a name="114718"></a></p>
<h2>在不同数据格式之间转换音频</h2>
<p><a name="114720"></a>上一节显示了如何使用Java Sound API将文件从一种<em>文件</em>格式（即一种声音文件）转换为另一种<em>文件</em>格式。本节探讨了一些支持音频<em>数据</em>格式转换的方法。</p>
<p><a name="114722"></a>在上一节中，我们从任意类型的文件中读取数据，并将其保存在AIFF文件中。请注意，尽管我们更改了用于存储数据的文件的类型，但并未更改音频数据本身的格式。（大多数常见的音频文件类型，包括AIFF，都可以包含各种格式的音频数据。）因此，如果原始文件包含CD质量的音频数据（16位样本大小，44.1 kHz采样率和两个通道），那么我们的输出AIFF文件也将包含在内。</p>
<p><a name="114724"></a>现在假设我们要指定输出文件的<em>数据</em>格式以及文件类型。例如，也许我们正在保存许多长文件供Internet使用，并担心文件所需的磁盘空间和下载时间。我们可能会选择创建包含较低分辨率数据的较小AIFF文件，例如，具有8位样本大小，8 kHz采样率和单个通道的数据。</p>
<p><a name="114726"></a>在不像以前那样深入介绍编码细节的情况下，让我们探讨一些用于数据格式转换的方法，并考虑我们需要对数据格式进行的修改。 <code>ConvertFileToAIFF</code>功能以实现新目标。</p>
<p><a name="118599"></a>音频数据转换的主要方法再次在<code>AudioSystem</code>类。此方法是<code>getAudioInputStream</code> ：</p>
<div class="codeblock"><pre>
AudioInputStream getAudioInputStream(AudioFormat
    format, AudioInputStream stream)
</pre></div>
<p>此函数返回一个<code>AudioInputStream</code>那是转换<code>AudioInputStream</code> ， <code>stream</code> ，使用指示的<code>AudioFormat</code> ， <code>format</code> 。如果不支持该转换<code>AudioSystem</code> ，此函数将引发<code>IllegalArgumentException</code> 。</p>
<p><a name="114734"></a>为避免这种情况，我们可以先通过调用此命令来检查系统是否可以执行所需的转换<code>AudioSystem</code>方法：</p>
<div class="codeblock"><pre>
boolean isConversionSupported(AudioFormat targetFormat,
    AudioFormat sourceFormat)
</pre></div>
<p>在这种情况下，我们会通过<code>stream.getFormat()</code>作为第二个论点。</p>
<p><a name="119726"></a>创建一个特定的<code>AudioFormat</code>对象，我们使用两者之一<code>AudioFormat</code>如下所示的构造函数：</p>
<div class="codeblock"><pre>
AudioFormat(float sampleRate, int sampleSizeInBits,
    int channels, boolean signed, boolean bigEndian)
</pre></div>
<p>构造一个<code>AudioFormat</code>具有线性PCM编码和给定参数，或者：</p>
<div class="codeblock"><pre>
AudioFormat(AudioFormat.Encoding encoding, 
    float sampleRate, int sampleSizeInBits, int channels,
    int frameSize, float frameRate, boolean bigEndian) 
</pre></div>
<p>这也构成了<code>AudioFormat</code> ，但是除了其他参数之外，您还可以指定编码，帧大小和帧频。</p>
<p><a name="114751"></a>现在，结合以上方法，让我们看看如何扩展我们的<code>ConvertFileToAIFF</code>功能执行所需的“低分辨率”音频数据格式转换。首先，我们将构建一个<code>AudioFormat</code>描述所需输出音频数据格式的对象。以下语句就足够了，并且可以在函数顶部附近插入：</p>
<div class="codeblock"><pre>
AudioFormat outDataFormat = new AudioFormat((float) 8000.0,
(int) 8, (int) 1, true, false);
</pre></div>
<p>自从<code>AudioFormat</code>上面的构造函数描述的是8位样本的格式，构造函数的最后一个参数无关紧要，该参数指定样本是大字节序还是小字节序。（仅当样本大小大于单个字节时，大字节序与小字节序才是问题。）</p>
<p><a name="114758"></a>以下示例说明了如何使用此新<code>AudioFormat</code>转换<code>AudioInputStream</code> ， <code>inFileAIS</code> ，我们是从输入文件创建的：</p>
<div class="codeblock"><pre>
AudioInputStream lowResAIS;         
  if (AudioSystem.isConversionSupported(outDataFormat,   
    inFileAIS.getFormat())) {
    lowResAIS = AudioSystem.getAudioInputStream
      (outDataFormat, inFileAIS);
  }
</pre></div>
<p>只要在构建完之后，我们在哪里插入这段代码都没关系<code>inFileAIS</code> 。没有<code>isConversionSupported</code>测试，通话将失败并引发<code>IllegalArgumentException</code>如果请求的特定转换不受支持。（在这种情况下，控制权将转移到适当的<code>catch</code>子句）。</p>
<p><a name="114769"></a>因此，在此过程的这一点上，我们将产生一个新的<code>AudioInputStream</code> ，是由于原始输入文件（在其<code>AudioInputStream</code>格式）转换为所需的低分辨率音频数据格式，如<code>outDataFormat</code> 。</p>
<p><a name="114771"></a>产生所需的低分辨率AIFF声音文件的最后一步是替换<code>AudioInputStream</code>调用中的参数<code>AudioSystem.write</code> （即第一个参数）与我们转换后的流， <code>lowResAIS</code> ， 如下：</p>
<div class="codeblock"><pre>
AudioSystem.write(lowResAIS, AudioFileFormat.Type.AIFF, 
  outFile);
</pre></div>
<p>对我们先前功能的一些修改产生了一些东西，可以转换音频数据和任何指定输入文件的文件格式，当然前提是系统支持转换。<a name="114777"></a></p>
<h2>了解哪些转换可用</h2>
<p><a name="114779"></a>一些<code>AudioSystem</code>方法测试其参数以确定系统是否支持特定的数据格式转换或文件写入操作。（通常，每个方法与另一个执行数据转换或写入文件的方法配对。）这些查询方法之一， <code>AudioSystem.isFileTypeSupported</code> ，用于我们的示例函数中， <code>ConvertFileToAIFF</code> ，以确定系统是否能够将音频数据写入AIFF文件。一个相关的<code>AudioSystem</code>方法， <code>getAudioFileTypes(AudioInputStream)</code> ，以数组形式返回给定流支持的文件类型的完整列表。 <code>AudioFileFormat.Type</code>实例。方法：BEGINCODE布尔值isConversionSupported（AudioFormat。编码编码<br>AudioFormat格式）</p></div>用于确定是否可以从具有指定音频格式的音频输入流中获取指定编码的音频输入流。同样，该方法：<p></p>
<div class="codeblock"><pre>
boolean isConversionSupported(AudioFormat newFormat,
                              AudioFormat oldFormat) 
</pre></div>
<p><a name="114790"></a>告诉我们是否<code>AudioInputStream</code>使用指定的音频格式<code>newFormat</code> ，可以通过将<code>AudioInputStream</code>具有音频格式<code>oldFormat</code> 。（此方法在上一节的代码摘录中被调用，该代码摘录创建了一个低分辨率音频输入流， <code>lowResAIS</code> ）</p>
<p><a name="114792"></a>这些与格式相关的查询有助于防止在尝试使用Java Sound API进行格式转换时出错。</p>


        </div>
        <div class="NavBit">
            <a href="controls.html" target="_top">«上一个</a> • <a href="./TOC.html" target="_top">追踪</a> • <a href="overview-MIDI.html" target="_top">下一个»</a>
        </div>
    
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>使用控件处理音频<br><b>下一页：</b> MIDI程序包概述</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</body></html>