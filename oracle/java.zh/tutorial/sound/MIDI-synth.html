<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>合成声音（Java™教程>声音）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="">
     <meta name="keywords" content="java programming, learn java, java sample code, ">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkAHEAD"><a href="sampled-overview.html">采样包概述</a></div>
<div class="linkAHEAD"><a href="accessing.html">访问音频系统资源</a></div>
<div class="linkAHEAD"><a href="playing.html">播放音频</a></div>
<div class="linkAHEAD"><a href="capturing.html">捕捉音频</a></div>
<div class="linkAHEAD"><a href="controls.html">使用控件处理音频</a></div>
<div class="linkAHEAD"><a href="converters.html">使用文件和格式转换器</a></div>
<div class="linkAHEAD"><a href="overview-MIDI.html">MIDI包概述</a></div>
<div class="linkAHEAD"><a href="accessing-MIDI.html">访问MIDI系统资源</a></div>
<div class="linkAHEAD"><a href="MIDI-messages.html">传输和接收MIDI信息</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-intro.html">音序器简介</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-methods.html">使用定序器方法</a></div>
<div class="linkAHEAD"><a href="MIDI-seq-adv.html">使用高级音序器功能</a></div>
<div class="nolinkAHEAD">合成声音</div>
<div class="linkAHEAD"><a href="SPI-intro.html">服务提供商接口简介</a></div>
<div class="linkAHEAD"><a href="SPI-providing-sampled.html">提供音频采样服务</a></div>
<div class="linkAHEAD"><a href="SPI-providing-MIDI.html">提供MIDI服务</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>踪迹：</b>声音</div>
            <div id="BreadCrumbs">
                <a href="../index.html" target="_top">主页</a> > <a href="./index.html" target="_top">声音</a>
            </div>
            <div class="NavBit">
                <a href="MIDI-seq-adv.html" target="_top">«上一个</a> • <a href="./TOC.html" target="_top">追踪</a> • <a href="SPI-intro.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>合成声音</h1></div>
            <div id="PageContent">

<p><a name="121725"></a>大多数使用Java Sound API的MIDI软件包的程序都是这样做的，以合成声音。之前讨论过的MIDI文件，事件，序列和音序器的整个装置几乎总是以最终将音乐数据发送到合成器以转换为音频为目标。（可能的例外包括将MIDI转换为乐谱供音乐家阅读的程序，以及将消息发送到外部MIDI控制的设备（例如调音台）的程序。）</p>
<p><a name="121727"></a>的<code>Synthesizer</code>因此，接口是MIDI包的基础。本页显示如何操纵合成器播放声音。许多程序将只使用音序器将MIDI文件数据发送到合成器，而无需调用许多<code>Synthesizer</code>方法直接。但是，可以直接控制合成器，而无需使用音序器甚至<code>MidiMessage</code>对象，如本页面末尾所述。</p>
<p><a name="121729"></a>对于不熟悉MIDI的读者而言，合成架构可能看起来很复杂。其API包括三个接口：</p>
<ul>
<li><a name="121730"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Synthesizer.html" target="_blank"><code>Synthesizer</code></a></li>
<li><a name="121731"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/MidiChannel.html" target="_blank"><code>MidiChannel</code></a></li>
<li><a name="121732"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Soundbank.html" target="_blank"><code>Soundbank</code></a></li>
</ul>
<p><a name="121733"></a>和四类：</p>
<ul>
<li><a name="121734"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Instrument.html" target="_blank"><code>Instrument</code></a></li>
<li><a name="121735"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Patch.html" target="_blank"><code>Patch</code></a></li>
<li><a name="121736"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/SoundbankResource.html" target="_blank"><code>SoundbankResource</code></a></li>
<li><a name="121737"></a> 
<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/VoiceStatus.html" target="_blank"><code>VoiceStatus</code></a></li>
</ul>
<p><a name="121739"></a>作为所有这些API的介绍，下一部分将说明MIDI合成的一些基础知识以及它们如何在Java Sound API中得到体现。随后的部分将更详细地介绍API。</p>
<p><a name="121742"></a></p>
<h2>了解MIDI综合</h2>
<p><a name="121745"></a>合成器如何产生声音？根据其实现，它可以使用一种或多种声音合成技术。例如，许多合成器都使用波表合成。波形表合成器从内存中读取存储的音频片段，以不同的采样率播放它们，然后循环播放以创建不同音高和持续时间的音符。例如，要合成萨克斯演奏音符C＃4（MIDI音符编号61）的声音，合成器可能会访问萨克斯演奏中音C（MIDI音符编号60）的录音中很短的一段，并且然后以比记录时稍快的采样率反复循环浏览此片段，从而产生音调稍高的长音。其他合成器使用诸如调频（FM），加法合成或物理建模之类的技术，这些技术不利用存储的音频，而是使用不同的算法从头开始生成音频。</p>
<p><a name="121747"></a></p>
<h3>仪器</h3>
<p><a name="123181"></a>所有合成技术的共同点是能够产生多种声音。不同的算法或同一算法中参数的不同设置会产生不同的结果。<em>乐器</em>是用于合成某种声音的规范。该声音可以模仿传统乐器，例如钢琴或小提琴。它可能会模仿其他类型的声源，例如电话或直升机；否则它可能根本不会模仿“真实世界”的声音。称为“通用MIDI”的规范定义了128种乐器的标准列表，但是大多数合成器也允许其他乐器使用。许多合成器提供了一组始终可用的内置乐器。一些合成器还支持加载其他乐器的机制。</p>
<p><a name="123190"></a>乐器可能是特定于供应商的，换句话说，仅适用于一个合成器或同一供应商的几种型号。当两个不同的合成器使用不同的声音合成技术或不同的内部算法和参数（即使基本技术相同）时，也会出现这种不兼容性。由于合成技术的细节通常是专有的，因此不兼容是常见的。Java Sound API包括检测给定合成器是否支持给定乐器的方法。</p>
<p><a name="121753"></a>通常可以将乐器视为预设；您无需了解产生声音的合成技术的细节。但是，您仍然可以改变其声音的各个方面。每条“音符开启”消息均指定单个音符的音高和音量。您还可以通过其他MIDI命令（例如控制器消息或系统专有消息）更改声音。</p>
<p><a name="121755"></a></p>
<h3>频道</h3>
<p><a name="121759"></a>许多合成器都是多<em>音色的</em> （有时称为多<em>音色</em> ），这意味着它们可以同时演奏不同乐器的音符。（ <em>Timbre</em>是使听众能够将一种乐器与其他乐器区分开的特征音质。）多重合成器可以仿真整个真实世界的乐器，而不是一次只仿真一台乐器。MIDI合成器通常通过利用MIDI规范允许传输数据的不同MIDI通道来实现此功能。在这种情况下，合成器实际上是声音生成单元的集合，每个声音生成单元模拟一个不同的乐器，并独立响应在不同MIDI通道上接收到的消息。由于MIDI规范仅提供16个通道，因此典型的MIDI合成器可以一次演奏多达16种不同的乐器。合成器接收MIDI命令流，其中许多是通道命令。（通道命令针对特定的MIDI通道；有关更多信息，请参见MIDI规范。）如果合成器是多音色的，它将根据命令中指示的通道号将每个通道命令路由到正确的声音生成单元。</p>
<p><a name="121761"></a>在Java Sound API中，这些声音生成单元是实现以下内容的类的实例： <code>MidiChannel</code>接口。一种<code>synthesizer</code>对象至少有一个<code>MidiChannel</code>宾语。如果合成器是多进制的，则它有多个，通常为16。每<code>MidiChannel</code>代表一个独立的发声单元。</p>
<p><a name="121763"></a>因为合成器的<code>MidiChannel</code>对象或多或少是独立的，对通道的乐器分配不必是唯一的。例如，所有16个通道可能都在弹钢琴音色，好像有16架钢琴合奏一样。可以进行任何分组-例如，通道1、5和8可以弹吉他声音，而通道2和3可以弹奏打击乐，而通道12可以具有低音音色。在给定的MIDI通道上演奏的乐器可以动态更改。这被称为<em>程序更改</em> 。</p>
<p><a name="121765"></a>即使大多数合成器在给定时间只激活16个或更少的乐器，这些乐器通常也可以从更大的选择中选择，并根据需要分配给特定的通道。</p>
<p><a name="121767"></a></p>
<h3>音库和补丁</h3>
<p><a name="121769"></a>乐器在合成器中按库号和程序号分层组织。可以将库和程序视为二维工具表中的行和列。银行是程序的集合。MIDI规范允许一个库中最多包含128个程序，每个库中最多包含128个程序。但是，特定的合成器可能仅支持一个或几个银行，并且每个银行可能支持少于128个程序。</p>
<p><a name="121771"></a>在Java Sound API中，层次结构有一个更高的层次：音库。声音库最多可包含128个库，每个库最多可包含128个乐器。一些合成器可以将整个音库加载到内存中。</p>
<p><a name="121773"></a>要从当前音库中选择乐器，请指定一个库号和一个程序号。MIDI规范通过两个MIDI命令来完成此任务：库选择和程序更改。在Java Sound API中，将银行编号和程序编号的组合封装在<code>Patch</code>宾语。您可以通过指定新音色来更改MIDI通道的当前乐器。可以将补丁视为当前音库中乐器的二维索引。</p>
<p><a name="121775"></a>您可能想知道音库是否也按数字索引。答案是不; MIDI规范不提供此功能。在Java Sound API中， <code>Soundbank</code>可以通过读取音库文件获得对象。如果声库由合成器支持，则可以将其乐器按需单独或全部加载到合成器中。许多合成器都有内置的或默认的声音库。声音库中包含的乐器始终可供合成器使用。</p>
<p><a name="121777"></a></p>
<h3>声音</h3>
<p><a name="121779"></a>区分合成器可以同时演奏的<em>音色</em>数量和它可以同时演奏的<em>音符</em>数量非常重要。前者已在上方的“渠道”中进行了说明。一次播放多个音符的能力称为<em>复音</em> 。即使不是多音色的合成器，通常一次也可以演奏一个以上的音符（所有音色相同，但音高不同）。例如，弹奏任何和弦，例如G大调三重奏或B小调第七和弦，都需要复音。任何实时生成声音的合成器都会限制其一次合成的音符数量。在Java Sound API中，合成器通过以下方式报告此限制： <code>getMaxPolyphony</code>方法。</p>
<p><a name="121783"></a> <em>声音</em>是一连串的单个音符，例如一个人可以唱歌的旋律。和弦由多种声音组成，例如合唱团演唱的部分。例如，一个32声合成器可以同时演奏32个音符。（但是，某些MIDI文献使用的“ voice”一词的含义不同，类似于“ instrument”或“ timbre”的含义。）</p>
<p><a name="121785"></a>将传入的MIDI音符分配给特定声音的过程称为<em>声音分配</em> 。合成器会维护一个声音列表，跟踪哪些声音处于活动状态（这意味着它们当前有音符发声）。当音符停止发声时，声音将变为非活动状态，这意味着它现在可以自由接受合成器收到的下一个音符开启请求。MIDI命令的输入流可以轻松请求比合成器所能生成的更多同时音符。当所有合成器的声音都处于活动状态时，应如何处理下一个“应要求提供注释”？合成器可以实施不同的策略：可以忽略最近请求的音符；或者可以通过中止另一个音符（例如最近启动的音符）来演奏。</p>
<p><a name="121787"></a>尽管不需要MIDI规范，但是合成器可以公开其每个声音的内容。Java Sound API包含一个<code>VoiceStatus</code>为此目的的课程。</p>
<p><a name="121788"></a>一种<code>VoiceStatus</code>报告语音的当前活动或非活动状态，MIDI通道，库和程序号，MIDI音符号和MIDI音量。</p>
<p><a name="121790"></a>在这种背景下，让我们研究用于综合的Java Sound API的细节。</p>
<p><a name="121793"></a></p>
<h2>管理乐器和音库</h2>
<p><a name="121795"></a>在许多情况下，程序可以利用<code>Synthesizer</code>对象，而无需显式调用几乎任何综合API。例如，假设您正在播放标准MIDI文件。您将其加载到<code>Sequence</code>对象，您可以通过让音序器将数据发送到默认的合成器来播放。序列中的数据按预期控制合成器，在正确的时间播放所有正确的音符。</p>
<p><a name="121797"></a>但是，在某些情况下，此简单方案是不够的。音序包含正确的音乐，但乐器听起来都不对！之所以出现这种不幸情况，是因为MIDI文件的创建者所考虑的乐器与当前加载到合成器中的乐器有所不同。</p>
<p><a name="123339"></a> MIDI 1.0规范提供了库选择和程序更改命令，这些命令会影响每个MIDI通道上当前正在演奏的乐器。但是，规范没有定义在每个音色位置（库和程序号）应驻留什么乐器。最新的通用MIDI规范通过定义包含128个与特定乐器声音相对应的程序的库来解决此问题。通用MIDI合成器使用128个与该指定集合匹配的乐器。不同的通用MIDI合成器在演奏原本应该是同一乐器的声音上也可能会大不相同。但是，无论播放哪个通用MIDI合成器，MIDI文件在大多数情况下应该听起来相似（即使不相同）。</p>
<p><a name="123341"></a>但是，并非所有MIDI文件的创建者都希望限于通用MIDI定义的128个音色组。本节说明如何从合成器随附的默认设置更改乐器。（如果没有默认值，则意味着在访问合成器时未加载任何乐器，无论如何，您都必须使用此API。）</p>
<p><a name="121803"></a></p>
<h3>学习加载什么乐器</h3>
<p><a name="121805"></a>要了解当前加载到合成器中的乐器是否是您想要的，您可以调用此<code>Synthesizer</code>方法：</p>
<div class="codeblock"><pre>
Instrument[] getLoadedInstruments() 
</pre></div>
<p>并遍历返回的数组以准确查看当前正在加载的仪器。您很可能会在用户界面中显示仪器的名称（使用<code>getName</code>的方法<code>Instrument</code> ），然后让用户决定是使用这些乐器还是加载其他乐器。的<code>Instrument</code> API包含一种报告该乐器属于哪个音库的方法。音库的名称可能有助于您的程序或用户确定乐器的确切含义。</p>
<p><a name="123382"></a>这个<code>Synthesizer</code>方法：</p>
<div class="codeblock"><pre>
Soundbank getDefaultSoundbank() 
</pre></div>
<p>给您默认的声音库。的<code>Soundbank</code> API包括检索音库名称，供应商和版本号的方法，程序或用户可以通过该方法来验证音库的身份。但是，您无法假定当您首次获得合成器时，默认音色库中的乐器已经加载到了合成器中。例如，一个合成器可能有各种各样的内置乐器可供使用，但是由于其内存有限，它可能无法自动加载它们。<a name="121824"></a></p>
<h3>加载不同的乐器</h3>
<p><a name="122802"></a>用户可能决定加载不同于当前仪器的仪器（或者您可以通过编程方式做出该决定）。下面的方法告诉您合成器附带了哪些乐器（相对于必须从音库文件中加载）：</p>
<div class="codeblock"><pre>
Instrument[] getAvailableInstruments()
</pre></div>
<p>您可以通过调用以下任何一种工具来加载：</p>
<div class="codeblock"><pre>
boolean loadInstrument(Instrument instrument) 
</pre></div>
<p>乐器将在仪器指定的位置加载到合成器中<code>Patch</code>对象（可以使用<code>getPatch</code>的方法<code>Instrument</code> ）。</p>
<p><a name="121836"></a>要从其他音库加载乐器，请先调用<code>Synthesizer's</code><code>isSupportedSoundbank</code>确保音库与此合成器兼容的方法（如果不兼容，则可以遍历系统的合成器以尝试找到支持音库的合成器）。然后，您可以调用以下方法之一从音色库加载乐器：</p>
<div class="codeblock"><pre>
boolean loadAllInstruments(Soundbank soundbank) 
boolean loadInstruments(Soundbank soundbank, 
  Patch[] patchList) 
</pre></div>
<p>顾名思义，其中的第一个从给定的音库加载整个乐器集，第二个从声库加载选定的乐器。您也可以使用<code>Soundbank's</code><code>getInstruments</code>一种方法来访问所有仪器，然后遍历它们并一次加载一个选定的仪器<code>loadInstrument</code> 。</p>
<p><a name="121843"></a>您加载的所有乐器都不必来自同一音库。你可以用<code>loadInstrument</code>要么<code>loadInstruments</code>从一个音库加载某些乐器，从另一个音库加载另一组乐器，依此类推。</p>
<p><a name="121846"></a>每个乐器都有自己的<code>Patch</code>指定在合成器上应加载乐器的位置的对象。该位置由一个银行号和一个程序号定义。没有API可以通过更改补丁的库号或程序号来更改位置。</p>
<p><a name="121852"></a>但是，可以使用以下方法将乐器加载到其补丁程序指定的位置以外的位置： <code>Synthesizer</code> ：</p>
<div class="codeblock"><pre>
boolean remapInstrument(Instrument from, Instrument to) 
</pre></div>
<p>此方法从合成器卸载其第一个参数，并将其第二个参数放置在第一个参数已占用的任何合成器补丁位置。<a name="121858"></a></p>
<h3>卸货工具</h3>
<p><a name="123434"></a>将仪器加载到程序位置会自动卸载该位置已经存在的任何仪器。您也可以显式卸载乐器，而不必用新的乐器替换它们。 <code>Synthesizer</code>包括与这三种加载方法相对应的三种卸载方法。如果合成器收到一个程序更改消息，该消息选择了当前未加载乐器的程序位置，则来自发送该程序更改消息的MIDI通道将没有任何声音。</p>
<p><a name="123435"></a></p>
<h3>访问Soundbank资源</h3>
<p><a name="123439"></a>一些合成器将乐器以外的其他信息存储在声库中。例如，波表合成器存储一个或多个乐器可以访问的音频样本。因为样本可能由多个乐器共享，所以它们独立于任何乐器存储在声库中。这俩<code>Soundbank</code>界面和<code>Instrument</code>类提供方法调用<code>getSoundbankResources</code> ，返回的列表<code>SoundbankResource</code>对象。这些对象的详细信息特定于为其设计了音库的合成器。在波表合成的情况下，资源可能是封装一系列音频样本的对象，这些音频样本取自一个录音片段。使用其他合成技术的合成器可能会将其他类型的对象存储在合成器的<code>SoundbankResources</code>数组。</p>
<p><a name="123441"></a></p>
<h2>查询合成器的功能和当前状态</h2>
<p><a name="121873"></a>的<code>Synthesizer</code>接口包含返回有关合成器功能信息的方法：</p>
<div class="codeblock"><pre>
    public long getLatency()
    public int getMaxPolyphony()
</pre></div>
<p>延迟测量了MIDI消息传递到合成器的时间和合成器实际产生相应结果的时间之间的最坏情况下的延迟。例如，在收到音符打开事件后，合成器可能需要花费几毫秒的时间才能开始生成音频。</p>
<p><a name="121880"></a>的<code>getMaxPolyphony</code>如前所述，该方法指示合成器可以同时发多少<a href="#121777">音</a> 。如同一讨论中所述，合成器可以提供有关其声音的信息。这可以通过以下方法完成：</p>
<div class="codeblock"><pre>
public VoiceStatus[] getVoiceStatus()
</pre></div>
<p>每<code>VoiceStatus</code>在返回的数组中，将报告声音的当前活动或不活动状态，MIDI通道，库和程序号，MIDI音符号和MIDI音量。数组的长度通常应与返回的数字相同<code>getMaxPolyphony</code> 。如果合成器没有播放，则全部播放<code>VoiceStatus</code>对象的活动字段设置为<code>false</code> 。</p>
<p><a name="121886"></a>您可以通过检索合成器的当前状态来了解其更多信息。 <code>MidiChannel</code>对象并查询其状态。下一节将对此进行更多讨论。</p>
<p><a name="121890"></a></p>
<h2>使用频道</h2>
<p><a name="121892"></a>有时访问合成器的<code>MidiChannel</code>直接对象。本节讨论这种情况。</p>
<p><a name="121894"></a></p>
<h3>不使用定序器控制合成器</h3>
<p><a name="121896"></a>使用序列时，例如从MIDI文件中读取一个序列，则无需自己将MIDI命令发送到合成器。相反，您只需将序列加载到音序器中，然后将音序器连接到合成器，然后运行即可。音序器负责安排事件的时间，结果是可预测的音乐演奏。如果事先知道所需的音乐，这种情况就可以很好地工作，从文件中读取音乐时也是如此。</p>
<p><a name="121898"></a>但是，在某些情况下，音乐在播放时会即时产生。例如，用户界面可能会显示音乐键盘或吉他指板，并允许用户通过单击鼠标随意弹奏音符。作为另一个示例，应用程序可能不使用合成器来播放音乐本身，而是响应用户的操作来产生声音效果。这种情况是典型的游戏。作为最后一个示例，该应用程序确实可能正在播放从文件读取的音乐，但是用户界面允许用户与音乐进行交互，从而动态地对其进行更改。在所有这些情况下，应用程序都直接将命令发送到合成器，因为MIDI消息需要立即传递，而不是将来被安排在确定的时间点。</p>
<p><a name="121900"></a>在不使用音序器的情况下，至少有两种方法可以将MIDI消息发送到合成器。首先是建立一个<code>MidiMessage</code>并使用的send方法将其传递给合成器<code>Receiver</code> 。例如，要立即在MIDI通道5（基于1）上产生Middle C（MIDI音符编号60），您可以执行以下操作：</p>
<div class="codeblock"><pre>
    ShortMessage myMsg = new ShortMessage();
    // Play the note Middle C (60) moderately loud
    // (velocity = 93)on channel 4 (zero-based).
    myMsg.setMessage(ShortMessage.NOTE_ON, 4, 60, 93); 
    Synthesizer synth = MidiSystem.getSynthesizer();
    Receiver synthRcvr = synth.getReceiver();
    synthRcvr.send(myMsg, -1); // -1 means no time stamp
</pre></div>
<p>第二种方法是绕过消息传递层（即<code>MidiMessage</code>和<code>Receiver</code> API），并与合成器的<code>MidiChannel</code>直接对象。您首先需要检索合成器的<code>MidiChannel</code>对象，使用以下<code>Synthesizer</code>方法：</p>
<div class="codeblock"><pre>
public MidiChannel[] getChannels()
</pre></div>
<p>之后，您可以调用所需的<code>MidiChannel</code>方法直接。这是比发送相应的路由更直接的路由<code>MidiMessages</code>到合成器的<code>Receiver</code>并让合成器自行处理通讯<code>MidiChannels</code> 。例如，与前面的示例相对应的代码为：</p>
<div class="codeblock"><pre>
    Synthesizer synth = MidiSystem.getSynthesizer();
    MidiChannel chan[] = synth.getChannels(); 
    // Check for null; maybe not all 16 channels exist.
    if (chan[4] != null) {
         chan[4].noteOn(60, 93); 
    }
</pre></div>
<h3>获取频道的当前状态</h3>
<p><a name="121939"></a>的<code>MidiChannel</code>接口提供了与MIDI规范定义的每个“通道语音”或“通道模式”消息一对一对应的方法。在上一个示例中，我们看到了使用noteOn方法的一种情况。但是，除了这些规范方法外，Java Sound API的<code>MidiChannel</code>界面添加了一些“获取”方法来检索相应语音或模式“设置”方法最近设置的值：</p>
<div class="codeblock"><pre>
    int       getChannelPressure()
    int       getController(int controller)
    boolean   getMono()
    boolean   getOmni() 
    int       getPitchBend() 
    int       getPolyPressure(int noteNumber)
    int       getProgram()
</pre></div>
<p>这些方法可能对向用户显示通道状态或确定随后要发送到该通道的值很有用。<a name="121953"></a></p>
<h3>静音和独奏通道</h3>
<p><a name="123492"></a> Java Sound API添加了每通道独奏和静音的概念，这是MIDI规范所不需要的。这些类似于MIDI序列轨道上的独奏和静音。</p>
<p><a name="123493"></a>如果启用静音，则此声道不会响起，但其他声道不受影响。如果打开了独奏，则此声道以及任何其他独奏的声道都会发声（如果未静音），但是不会响起其他声道。独奏和静音的通道都不会发出声音。的<code>MidiChannel</code> API包括四种方法：</p>
<div class="codeblock"><pre>
    boolean      getMute() 
    boolean      getSolo()
    void         setMute(boolean muteState) 
    void         setSolo(boolean soloState)
</pre></div>
<h2>播放合成声音的权限</h2>
<p><a name="123505"></a>由任何已安装的MIDI合成器产生的音频通常通过采样音频系统进行路由。如果您的程序没有播放音频的权限，则不会听到合成器的声音，并且会抛出安全异常。有关音频权限的更多信息，请参见前面关于使用音频资源的<a class="TutorialLink" href="accessing.html#113223" target="_top">权限的</a>讨论。</p>
<p><a name="121968"></a></p>


        </div>
        <div class="NavBit">
            <a href="MIDI-seq-adv.html" target="_top">«上一个</a> • <a href="./TOC.html" target="_top">追踪</a> • <a href="SPI-intro.html" target="_top">下一个»</a>
        </div>
    </div>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>使用高级音序器功能<br><b>下一页：</b>服务提供商接口简介</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</body></html>