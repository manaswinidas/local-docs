<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>如何使用表（Java™教程>使用JFC / Swing创建GUI>使用Swing组件）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="This Swing Java Tutorial describes developing graphical user interfaces (GUIs) for applications and applets using Swing components">
     <meta name="keywords" content="java programming, learn java, java sample code, java swing, java ui, java user interface, swing components, swing events, swing layout  ">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">使用Swing组件</a></div>
<div class="linkAHEAD"><a href="toplevel.html">使用顶层容器</a></div>
<div class="linkAHEAD"><a href="jcomponent.html">JComponent类</a></div>
<div class="linkAHEAD"><a href="text.html">使用文字组件</a></div>
<div class="linkBHEAD"><a href="generaltext.html">文字组件功能</a></div>
<div class="linkBHEAD"><a href="textapi.html">文字元件API</a></div>
<div class="linkAHEAD"><a href="componentlist.html">如何使用各种组件</a></div>
<div class="linkBHEAD"><a href="applet.html">如何制作小程序</a></div>
<div class="linkBHEAD"><a href="button.html">如何使用按钮，复选框和单选按钮</a></div>
<div class="linkBHEAD"><a href="buttongroup.html">如何使用ButtonGroup组件</a></div>
<div class="linkBHEAD"><a href="colorchooser.html">如何使用颜色选择器</a></div>
<div class="linkBHEAD"><a href="combobox.html">如何使用组合框</a></div>
<div class="linkBHEAD"><a href="dialog.html">如何制作对话框</a></div>
<div class="linkBHEAD"><a href="editorpane.html">如何使用编辑器窗格和文本窗格</a></div>
<div class="linkBHEAD"><a href="filechooser.html">如何使用文件选择器</a></div>
<div class="linkBHEAD"><a href="formattedtextfield.html">如何使用格式化的文本字段</a></div>
<div class="linkBHEAD"><a href="frame.html">如何制作框架（主窗口）</a></div>
<div class="linkBHEAD"><a href="internalframe.html">如何使用内部框架</a></div>
<div class="linkBHEAD"><a href="label.html">如何使用标签</a></div>
<div class="linkBHEAD"><a href="layeredpane.html">如何使用分层窗格</a></div>
<div class="linkBHEAD"><a href="list.html">如何使用清单</a></div>
<div class="linkBHEAD"><a href="menu.html">如何使用菜单</a></div>
<div class="linkBHEAD"><a href="panel.html">如何使用面板</a></div>
<div class="linkBHEAD"><a href="passwordfield.html">如何使用密码字段</a></div>
<div class="linkBHEAD"><a href="progress.html">如何使用进度条</a></div>
<div class="linkBHEAD"><a href="rootpane.html">如何使用根窗格</a></div>
<div class="linkBHEAD"><a href="scrollpane.html">如何使用滚动窗格</a></div>
<div class="linkBHEAD"><a href="separator.html">如何使用分隔符</a></div>
<div class="linkBHEAD"><a href="slider.html">如何使用滑块</a></div>
<div class="linkBHEAD"><a href="spinner.html">如何使用微调器</a></div>
<div class="linkBHEAD"><a href="splitpane.html">如何使用分割窗格</a></div>
<div class="linkBHEAD"><a href="tabbedpane.html">如何使用选项卡式窗格</a></div>
<div class="nolinkBHEAD">如何使用表格</div>
<div class="linkBHEAD"><a href="textarea.html">如何使用文字区</a></div>
<div class="linkBHEAD"><a href="textfield.html">如何使用文字栏位</a></div>
<div class="linkBHEAD"><a href="toolbar.html">如何使用工具栏</a></div>
<div class="linkBHEAD"><a href="tooltip.html">如何使用工具提示</a></div>
<div class="linkBHEAD"><a href="tree.html">如何使用树木</a></div>
<div class="linkAHEAD"><a href="html.html">如何在Swing组件中使用HTML</a></div>
<div class="linkAHEAD"><a href="model.html">如何使用模型</a></div>
<div class="linkAHEAD"><a href="icon.html">如何使用图标</a></div>
<div class="linkAHEAD"><a href="border.html">如何使用边框</a></div>
<div class="linkAHEAD"><a href="problems.html">解决常见组件问题</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b>使用JFC / Swing创建GUI<br><b>课程：</b>使用Swing组件<br><b>部分：</b>如何使用各种组件</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> > <a href="../index.html" target="_top">使用JFC / Swing创建GUI</a> > <a href="index.html" target="_top">使用Swing组件</a>
            </div>
            <div class="NavBit">
                <a href="tabbedpane.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="textarea.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>如何使用表格</h1></div>
            <div id="PageContent">

<p>随着<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html" target="_blank"><code>JTable</code></a>您可以显示数据表类，可以选择允许用户编辑数据。 <code>JTable</code>不包含或缓存数据；它只是您的数据视图。这是滚动窗格中显示的典型表的图片：</p>
<center><img src="../../figures/uiswing/components/BasicTable.png" width="529" height="145" align="bottom" alt="TableDemo的快照，显示典型表。"></center><p>本节的其余部分将向您展示如何完成一些与表相关的常见任务。以下是本节涵盖的主题：</p>
<ul>
<li><a href="#simple">创建一个简单的表</a></li>
<li><a href="#show">将表添加到容器</a></li>
<li><a href="#width">设置和更改列宽</a></li>
<li><a href="#selection">用户选择</a></li>
<li><a href="#data">创建表模型</a></li>
<li><a href="#modelchange">监听数据更改</a></li>
<li><a href="#fire">触发数据更改事件</a></li>
<li><a href="#editrender">概念：编辑器和渲染器</a></li>
<li><a href="#renderer">使用自定义渲染器</a></li>
<li><a href="#celltooltip">指定单元格的工具提示</a></li>
<li><a href="#headertooltip">指定列标题的工具提示</a></li>
<li><a href="#sorting">排序和过滤</a></li>
<li><a href="#combobox">使用组合框作为编辑器</a></li>
<li><a href="#editor">使用其他编辑器</a></li>
<li><a href="#validtext">使用编辑器验证用户输入的文本</a></li>
<li><a href="#printing">列印</a></li>
<li><a href="#eg">使用表格的例子</a></li>
</ul>
<h2><a name="simple" id="simple">创建一个简单的表</a></h2>
<div class="note"><hr><strong>尝试这个：</strong> <ol>
<li>
<p>单击启动按钮运行<code>SimpleTableDemo</code>使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#SimpleTableDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/SimpleTableDemoProject/SimpleTableDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动SimpleTableDemo示例"></a><br></li>
<li>
<p>单击包含“单板滑雪”的单元格。<br>整个第一行都被选中，表明您已经选择了Kathy Smith的数据。特殊高亮显示“单板滑雪”单元格是可编辑的。通常，您可以通过双击来开始编辑文本单元格。</p>
</li>
<li>
<p>将光标放在“名字”上。现在按下鼠标按钮并向右拖动。<br>如您所见，用户可以重新排列表中的列。</p>
</li>
<li>
<p>将光标定位在列标题的右侧。现在按下鼠标按钮并向右或向左拖动。<br>该列将更改大小，而其他列将进行调整以填充剩余空间。</p>
</li>
<li>调整包含表格的窗口的大小，使其大于显示整个表格所需的窗口。<br>所有表格单元都变得更宽，并扩大以填充额外的水平空间。</li>
</ol>
<hr></div>
<p>中的表<a class="SourceLink" href="../examples/components/SimpleTableDemoProject/src/components/SimpleTableDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/SimpleTableDemoProject/src/components/SimpleTableDemo.java'); return false;"><code>SimpleTableDemo.java</code></a>在String数组中声明列名称：</p>
<div class="codeblock"><pre>
String[] columnNames = {"First Name",
                        "Last Name",
                        "Sport",
                        "# of Years",
                        "Vegetarian"};
</pre></div>
<p>其数据已初始化并存储在二维Object数组中：</p>
<div class="codeblock"><pre>
Object[][] data = {
    {"Kathy", "Smith",
     "Snowboarding", new Integer(5), new Boolean(false)},
    {"John", "Doe",
     "Rowing", new Integer(3), new Boolean(true)},
    {"Sue", "Black",
     "Knitting", new Integer(2), new Boolean(false)},
    {"Jane", "White",
     "Speed reading", new Integer(20), new Boolean(true)},
    {"Joe", "Brown",
     "Pool", new Integer(10), new Boolean(false)}
};
</pre></div>
<p>然后，使用以下数据和columnNames构造表：</p>
<div class="codeblock"><pre>
JTable table = new JTable(data, columnNames);
</pre></div>
<p>那里有两个<code>JTable</code>直接接受数据的构造函数（ <code>SimpleTableDemo</code>使用第一个）：</p>
<ul>
<li><code>JTable(Object[][] rowData, Object[] columnNames)</code></li>
<li><code>JTable(Vector rowData, Vector columnNames)</code></li>
</ul>
<p>这些构造函数的优点是易于使用。但是，这些构造函数也有缺点：</p>
<ul>
<li>它们自动使每个单元格可编辑。</li>
<li>它们将所有数据类型视为相同（作为字符串）。例如，如果表列具有<code>Boolean</code>数据，该表可以在复选框中显示数据。但是，如果您使用两者之一<code>JTable</code>前面列出的构造函数，您的<code>Boolean</code>数据显示为字符串。您可以在<code>Vegetarian</code>上图中的一列。</li>
<li>他们要求您将表的所有数据放入数组或向量中，这可能不适用于某些数据。例如，如果要从数据库实例化一组对象，则可能要直接查询对象的值，而不是将所有值复制到数组或向量中。</li>
</ul>
<p>如果要解决这些限制，则需要实现自己的表模型，如<a href="#data">创建表模型中所述</a> 。</p>
<h2><a name="show" id="show">将表添加到容器</a></h2>
<p>以下是用于创建用作表容器的<a href="scrollpane.html">滚动窗格的</a>典型代码：</p>
<div class="codeblock"><pre>
JScrollPane scrollPane = new JScrollPane(table);
table.setFillsViewportHeight(true);
</pre></div>
<p>此代码段中的两行内容如下：</p>
<ul>
<li>的<code>JScrollPane</code>构造函数由引用表对象的参数调用。这将创建一个滚动窗格作为表的容器。该表将自动添加到容器中。</li>
<li><code>JTable.setFillsViewportHeight</code>被调用以设置<code>fillsViewportHeight</code>属性。当此属性是<code>true</code>即使表格的行数不足以使用整个垂直空间，表格也会使用容器的整个高度。这样可以更轻松地将表格用作拖放目标。</li>
</ul>
<p>滚动窗格会自动将表标题放置在视口的顶部。滚动表数据时，列名在查看区域的顶部保持可见。</p>
<p>如果使用的表没有滚动窗格，则必须获取表头组件并将其自己放置。例如：</p>
<div class="codeblock"><pre>
container.setLayout(new BorderLayout());
container.add(table.getTableHeader(), BorderLayout.PAGE_START);
container.add(table, BorderLayout.CENTER);
</pre></div>
<h2><a name="width" id="width">设置和更改列宽</a></h2>
<p>默认情况下，表格中的所有列均以相等的宽度开头，并且这些列自动填充表格的整个宽度。当表格变宽或变窄时（当用户调整包含表格的窗口的大小时可能会发生这种情况），所有列宽都会适当更改。</p>
<p>当用户通过拖动其右边框来调整列的大小时，其他列都必须更改大小，或者表的大小必须更改。默认情况下，表的大小保持不变，并且拖动点右侧的所有列都会调整大小，以容纳在拖动点左侧的列中添加或删除的空间。</p>
<p>要自定义初始列宽，可以调用<code>setPreferredWidth</code>在表格的每个列上。这既设置了列的首选宽度，又设置了它们的近似相对宽度。例如，将以下代码添加到<code>SimpleTableDemo</code>使第三列比其他列大：</p>
<div class="codeblock"><pre>
TableColumn column = null;
for (int i = 0; i &lt; 5; i++) {
    column = table.getColumnModel().getColumn(i);
    if (i == 2) {
        column.setPreferredWidth(100); //third column is bigger
    } else {
        column.setPreferredWidth(50);
    }
}
</pre></div>
<p>如前面的代码所示，表中的每一列都由一个<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableColumn.html" target="_blank"><code>TableColumn</code></a>宾语。 <code>TableColumn</code>提供用于列的最小，首选和最大宽度的getter和setter方法，以及获取当前宽度的方法。有关根据绘制单元格内容所需的空间的近似值设置单元格宽度的示例，请参见<code>initColumnSizes</code>方法中<a class="SourceLink" href="../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java'); return false;"><code>TableRenderDemo.java</code></a> 。</p>
<p>当用户显式调整列的大小时，将设置列的<em>首选</em>宽度，以使用户指定的大小成为列的新<em>当前</em>宽度。但是，当调整表本身的大小时（通常是因为窗口已调整大小）；列的首选宽度不变。而是使用现有的首选宽度来计算新的列宽度以填充可用空间。</p>
<p>您可以通过调用更改表的调整大小行为<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#setAutoResizeMode-int-" target="_blank"><code>setAutoResizeMode</code></a> 。</p>
<p>
</p>
<h2><a name="selection" id="selection">用户选择</a></h2>
<p>在其默认配置中，表支持由一个或多个行组成的选择。用户可以选择连续的行范围或任意行集。用户指示的最后一个单元格有特殊指示。在“金属”外观中，该单元格被概述。这个单元被称为<em>线索选择</em> ;有时称为“具有焦点的单元格”或“当前单元格”。</p>
<p>用户使用鼠标和/或键盘进行选择，如下表所示：</p>
<table border="1" summary="keyboard and mouse actions for table operations">
<tbody>
<tr>
<th>运作方式</th>
<th>鼠标动作</th>
<th>键盘动作</th>
</tr>
<tr>
<td>选择单行。</td>
<td>单击。</td>
<td>向上箭头或向下箭头。</td>
</tr>
<tr>
<td>扩展连续选择。</td>
<td>按住Shift键单击或拖动行。</td>
<td>上移箭头或下移箭头。</td>
</tr>
<tr>
<td>将行添加到选择/切换行选择。</td>
<td>按下控制键</td>
<td>使用Control-上箭头或Control-下箭头移动线索选择，然后使用空格键添加到选择中或使用Control-空格键切换行选择。</td>
</tr>
</tbody>
</table>
<p>要查看选择如何工作，请单击“启动”按钮以运行<code>TableSelectionDemo</code>使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableSelectionDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableSelectionDemoProject/TableSelectionDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableSelectionDemo示例"></a><br>
<p>该示例程序显示了熟悉的表，并允许用户操纵某些JTable选项。还有一个文本窗格，记录选择事件。</p>
<p>在下面的屏幕快照中，用户已运行该程序，在第一行中单击，然后在第三行中按住Control键单击。注意最后单击的单元格周围的轮廓；这就是Metal外观如何突出选择线索的方式。</p>
<center><img src="../../figures/uiswing/components/TableSelection-new.png" width="526" height="378" align="bottom" alt="具有不连续的行选择的TableSelectionDemo。"></center><p>在“选择模式”下，有一组单选按钮。单击标记为“单个选择”的一个。现在您一次只能选择一行。如果单击“单个间隔选择”单选按钮，则可以选择一组必须连续的行。</p>
<p>“选择模式”下的所有单选按钮都会调用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#setSelectionMode-int-" target="_blank"><code>JTable.setSelectionMode</code></a> 。此方法采用单个参数，该参数必须是以下参数中定义的常量之一<code>javax.swing.ListSelectionModel</code> ： <code>MULTIPLE_INTERVAL_SELECTION</code> ， <code>SINGLE_INTERVAL_SELECTION</code>和<code>SINGLE_SELECTION</code> 。</p>
<p>返回到<code>TableSelectionDemo</code> ，请注意“选择选项”下的三个选项复选框。每个复选框可控制<code>boolean</code>定义的绑定变量<code>JTable</code> ：</p>
<ul>
<li>“行选择”控件<code>rowSelectionAllowed</code>有setter方法<code>setRowSelectionAllowed</code>和吸气方法<code>getRowSelectionAllowed</code> 。当此绑定属性是<code>true</code> （和<code>columnSelectionAllowed</code>财产是<code>false</code> ），用户可以按行进行选择。</li>
<li>“列选择”控件<code>columnSelectionAllowed</code>有setter方法<code>setColumnSelectionAllowed</code>和吸气方法<code>getColumnSelectionAllowed</code> 。当此绑定属性是<code>true</code> （和<code>rowSelectionAllowed</code>绑定属性为<code>false</code> ），用户可以按列进行选择。</li>
<li>“单元格选择”控件<code>cellSelectionEnabled</code> ，它具有setter方法<code>setCellSelectionEnabled</code>和吸气方法<code>getCellSelectionEnabled</code> 。当此绑定属性是<code>true</code> ，用户可以选择单个单元格或矩形单元格块。</li>
</ul>
<div class="note"><hr><strong>注意：</strong> <code>JTable</code>使用非常简单的选择概念，将其作为行和列的交集进行管理。它不是设计用来处理完全独立的单元格选择的。
<hr></div>
<p>如果清除所有三个复选框（将所有三个绑定属性设置为<code>false</code> ），没有选择；仅显示潜在客户选择。</p>
<p>您可能会注意到，在多个时间间隔选择模式下，“单元格选择”复选框被禁用。这是因为演示中的此模式不支持单元格选择。您可以在多个时间间隔选择模式下按单元格指定选择，但是结果是一个不会产生有用选择的表。</p>
<p>您可能还会注意到，更改三个选择选项中的任何一个都会影响其他选项。这是因为同时允许行选择和列选择与启用单元格选择完全相同。 <code>JTable</code>根据需要自动更新三个绑定变量，以使其保持一致。</p>
<div class="note"><hr><strong>注意：</strong>设置<code>cellSelectionEnabled</code>设置为一个值会同时设置两个<code>rowSelectionEnabled</code>和<code>columnSelectionEnabled</code>达到那个值。同时设置<code>rowSelectionEnabled</code>和<code>columnSelectionEnabled</code>设置为一个值也会产生副作用<code>cellSelectionEnabled</code>达到那个值。设置<code>rowSelectionEnabled</code>和<code>columnSelectionEnabled</code>设置为不同的值也会产生副作用<code>cellSelectionEnabled</code>至<code>false</code> 。
<hr></div>
<p>要检索当前选择，请使用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#getSelectedRows--" target="_blank"><code>JTable.getSelectedRows</code></a>它返回一个行索引数组，并且<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#getSelectedColumns--" target="_blank"><code>JTable.getSelectedColumns</code></a>它返回列索引数组。要检索潜在顾客选择的坐标，请参考表本身和表的列模型的选择模型。以下代码格式化包含潜在顾客选择的行和列的字符串：</p>
<div class="codeblock"><pre>
String.format("Lead Selection: %d, %d. ",
    table.getSelectionModel().getLeadSelectionIndex(),
    table.getColumnModel().getSelectionModel().getLeadSelectionIndex());
</pre></div>
<p>用户选择会产生许多事件。有关这些信息，请参阅“ <a class="TutorialLink" href="../events/index.html" target="_top">编写事件侦听器”</a>课程中的<a class="TutorialLink" href="../events/listselectionlistener.html" target="_top">如何编写列表选择侦听</a> <a class="TutorialLink" href="../events/index.html" target="_top">器</a> 。</p>
<div class="note"><hr><strong>注意：</strong>选择数据实际上是在“视图”（在任何排序或过滤后显示的表数据）而不是表模型中描述所选单元格。除非通过排序，过滤或用户对列的操作重新排列了查看的数据，否则这种区别并不重要。在这种情况下，必须使用“ <a href="#sorting">排序和过滤”中</a>所述的转换方法转换选择坐标。
<hr></div>
<h2><a name="data" id="data">创建表模型</a></h2>
<p>每个表对象都使用一个<em>表模型对象</em>来管理实际的表数据。表格模型对象必须实现<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableModel.html" target="_blank"><code>TableModel</code></a>接口。如果程序员不提供表模型对象， <code>JTable</code>自动创建一个实例<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/DefaultTableModel.html" target="_blank"><code>DefaultTableModel</code></a> 。这种关系如下所示。</p>
<center><img src="../../figures/uiswing/components/model.png" width="321" height="144" align="bottom" alt="表，表对象，模型对象之间的关系"></center><p>的<code>JTable</code>构造函数使用<code>SimpleTableDemo</code>使用如下代码创建其表模型：</p>
<div class="codeblock"><pre>
new AbstractTableModel() {
    public String getColumnName(int col) {
        return columnNames[col].toString();
    }
    public int getRowCount() { return rowData.length; }
    public int getColumnCount() { return columnNames.length; }
    public Object getValueAt(int row, int col) {
        return rowData[row][col];
    }
    public boolean isCellEditable(int row, int col)
        { return true; }
    public void setValueAt(Object value, int row, int col) {
        rowData[row][col] = value;
        fireTableCellUpdated(row, col);
    }
}
</pre></div>
<p>如前面的代码所示，实现表模型很简单。通常，您可以在<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/AbstractTableModel.html" target="_blank"><code>AbstractTableModel</code></a>类。</p>
<p>您的模型可能会将其数据保存在数组，向量或哈希图中，或者可能从外部来源（例如数据库）获取数据。它甚至可能在执行时生成数据。</p>
<p>该表与<code>SimpleTableDemo</code>表以下列方式：</p>
<ul>
<li><code>TableDemo</code>的自定义表格模型（即使很简单）也可以轻松确定数据的类型，从而有助于<code>JTable</code>以最佳格式显示数据。 <code>SimpleTableDemo</code>另一方面，自动创建的表格模型不知道<b>“年</b>数<b>”</b>列中包含数字（通常应右对齐并具有特定格式）。它也不知道<code>Vegetarian</code>列包含布尔值，可以用复选框表示。</li>
<li>在以下位置实现的自定义表格模型<code>TableDemo</code>不允许您编辑名称列；但是，它允许您编辑其他列。在<code>SimpleTableDemo</code> ，所有单元格都是可编辑的。</li>
</ul>
<p>参见下面的代码<a class="SourceLink" href="../examples/components/TableDemoProject/src/components/TableDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDemoProject/src/components/TableDemo.java'); return false;"><code>TableDemo.java</code></a>这与<a class="SourceLink" href="../examples/components/SimpleTableDemoProject/src/components/SimpleTableDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/SimpleTableDemoProject/src/components/SimpleTableDemo.java'); return false;"><code>SimpleTableDemo.java</code></a> 。粗体字体表示使此表的模型与自动为之定义的表模型不同的代码<code>SimpleTableDemo</code> 。</p>
<div class="codeblock"><pre>
public TableDemo() {
    ...
    JTable table = new JTable(new MyTableModel());
    ...
}

class MyTableModel extends AbstractTableModel {
    private String[] columnNames = <em>...//same as before...</em>
    private Object[][] data = <em>...//same as before...</em>

    public int getColumnCount() {
        return columnNames.length;
    }

    public int getRowCount() {
        return data.length;
    }

    public String getColumnName(int col) {
        return columnNames[col];
    }

    public Object getValueAt(int row, int col) {
        return data[row][col];
    }

    <b>public Class getColumnClass(int c) {
        return getValueAt(0, c).getClass();
    }</b>

    /*
     * Don't need to implement this method unless your table's
     * editable.
     */
    public boolean isCellEditable(int row, int col) {
        //Note that the data/cell address is constant,
        //no matter where the cell appears onscreen.
        <b>if (col &lt; 2) {
            return false;
        } else {
            return true;
        }</b>
    }

    /*
     * Don't need to implement this method unless your table's
     * data can change.
     */
    public void setValueAt(Object value, int row, int col) {
        data[row][col] = value;
        fireTableCellUpdated(row, col);
    }
    ...
}
</pre></div>
<h2><a name="modelchange" id="modelchange">监听数据更改</a></h2>
<p>一个表模型可以具有一组侦听器，只要表数据发生更改，它们就会得到通知。侦听器是<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/event/TableModelListener.html" target="_blank"><code>TableModelListener</code></a> 。在以下示例代码中， <code>SimpleTableDemo</code>扩展为包括此类侦听器。新代码以粗体显示。</p>
<div class="codeblock"><pre>
<b>import javax.swing.event.*;
import javax.swing.table.TableModel;</b>

public class SimpleTableDemo ... <b>implements TableModelListener </b>{
    ...
    public SimpleTableDemo() {
        ...
        <b>table.getModel().addTableModelListener(this);</b>
        ...
    }

    <b>public void tableChanged(TableModelEvent e) {
        int row = e.getFirstRow();
        int column = e.getColumn();
        TableModel model = (TableModel)e.getSource();
        String columnName = model.getColumnName(column);
        Object data = model.getValueAt(row, column);

        <em>...// Do something with the data...</em></b>
    }
    ...
}
</pre></div>
<h2><a name="fire" id="fire">触发数据更改事件</a></h2>
<p>为了触发数据更改事件，表模型必须知道如何构造一个<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/event/TableModelEvent.html" target="_blank"><code>TableModelEvent</code></a>宾语。这可能是一个复杂的过程，但是已经在<code>DefaultTableModel</code> 。您可以允许<code>JTable</code>使用其默认实例<code>DefaultTableModel</code> ，或创建自己的自定义子类<code>DefaultTableModel</code> 。</p>
<p>如果<code>DefaultTableModel</code>对于您的自定义表模型类而言，它不是合适的基类，请考虑子类化<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/AbstractTableModel.html" target="_blank"><code>AbstractTableModel</code></a> 。此类实现了用于构建的简单框架<code>TableModelEvent</code>对象。您的自定义类只需要调用以下内容之一<code>AbstractTableModel</code>每个时间表数据由外部源更改的方法。</p>
<table border="1" summary="AbstractTableModel methods and effect">
<tbody>
<tr>
<th align="left">方法</th>
<th align="left">更改</th>
</tr>
<tr>
<td><code>fireTableCellUpdated</code></td>
<td>指定单元格的更新。</td>
</tr>
<tr>
<td><code>fireTableRowsUpdated</code></td>
<td>指定行的更新</td>
</tr>
<tr>
<td><code>fireTableDataChanged</code></td>
<td>更新整个表（仅数据）。</td>
</tr>
<tr>
<td><code>fireTableRowsInserted</code></td>
<td>插入了新行。</td>
</tr>
<tr>
<td><code>fireTableRowsDeleted</code></td>
<td>现有行已删除</td>
</tr>
<tr>
<td><code>fireTableStructureChanged</code>  </td>
<td>无效整个表，包括数据和结构。</td>
</tr>
</tbody>
</table>
<h2><a name="editrender" id="editrender">概念：编辑器和渲染器</a></h2>
<p>在继续接下来的几项任务之前，您需要了解表如何绘制其单元格。您可能希望表中的每个单元格都是一个组件。但是，出于性能原因，Swing表的实现方式有所不同。</p>
<p>取而代之的是，通常使用单个<em>单元格渲染器</em>来绘制包含相同类型数据的所有单元格。您可以将渲染器视为可配置的墨水戳，表格使用该墨水戳将格式正确的数据标记到每个单元格上。当用户开始编辑单元格的数据时， <em>单元格编辑器</em>将接管该单元格，从而控制该单元格的编辑行为。</p>
<p>例如， <b>“年份”</b>列中的每个单元格<code>TableDemo</code>包含<code>Number</code>数据-具体来说， <code>Integer</code>宾语。默认情况下， <code>Number</code>包含的列使用单个<code>JLabel</code>实例在列的单元格上绘制右对齐的适当数字。如果用户开始编辑其中一个单元格，则默认的单元格编辑器将使用右对齐<code>JTextField</code>控制单元格的编辑。</p>
<p>要选择在列中显示单元格的渲染器，表格首先确定您是否为该特定列指定了渲染器。如果您没有这样做，那么表将调用表模型的<code>getColumnClass</code>方法，该方法获取列单元格的数据类型。接下来，该表将列的数据类型与为其注册了单元格渲染器的数据类型列表进行比较。该列表由表初始化，但是您可以添加或更改它。当前，表将以下类型的数据放入列表中：</p>
<ul>
<li><code>Boolean</code> —用复选框呈现。</li>
<li><code>Number</code> —由右对齐的标签呈现。</li>
<li><code>Double</code> ， <code>Float</code> - 和...一样<code>Number</code> ，但是对象到文本的翻译是由<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html" target="_blank"><code>NumberFormat</code></a>实例（使用当前语言环境的默认数字格式）。</li>
<li><code>Date</code> —由标签呈现，由对象执行文本到文本的翻译<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html" target="_blank"><code>DateFormat</code></a>实例（使用简短样式表示日期和时间）。</li>
<li><code>ImageIcon</code> ， <code>Icon</code> —由居中标签呈现。</li>
<li><code>Object</code> —由显示对象的字符串值的标签呈现。</li>
</ul>
<p>使用类似的算法选择单元格编辑器。</p>
<p>请记住，如果让表创建自己的模型，它将使用<code>Object</code>作为每一列的类型。要指定更精确的列类型，表模型必须定义<code>getColumnClass</code>适当的方法，如<a class="SourceLink" href="../examples/components/TableDemoProject/src/components/TableDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDemoProject/src/components/TableDemo.java'); return false;"><code>TableDemo.java</code></a> 。</p>
<p>请记住，尽管渲染器确定每个单元格或列标题的外观并可以指定其工具提示文本，但是渲染器不会处理事件。如果您需要拾取表内发生的事件，则使用的技术会因您感兴趣的事件种类而异：</p>
<table border="1" cellspacing="2" summary="how to pick up table events">
<tbody>
<tr>
<th align="left">情况</th>
<th align="left">如何获得活动</th>
</tr>
<tr valign="top">
<td>要检测来自正在编辑的单元的事件...</td>
<td>使用单元格编辑器（或在单元格编辑器上注册一个侦听器）。</td>
</tr>
<tr valign="top">
<td>要检测行/列/单元格选择和取消选择...</td>
<td>如<a href="#selection">检测用户选择中</a>所述使用选择侦听器。</td>
</tr>
<tr valign="top">
<td>要检测列标题上的鼠标事件...</td>
<td>在表格的桌面上注册适当类型的<a class="TutorialLink" href="../events/mouselistener.html" target="_top">鼠标侦听器</a> <code>JTableHeader</code>宾语。（看到<a class="SourceLink" href="../examples/components/TableSorterDemoProject/src/components/TableSorter.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableSorterDemoProject/src/components/TableSorter.java'); return false;"><code>TableSorter.java</code></a>例如。）</td>
</tr>
<tr valign="top">
<td>要检测其他事件...</td>
<td>在上注册适当的侦听器<code>JTable</code>宾语。</td>
</tr>
</tbody>
</table>
<p>接下来的几节将告诉您如何通过指定渲染器和编辑器来自定义显示和编辑。您可以按列或按数据类型指定单元格渲染器和编辑器。</p>
<h2><a name="renderer" id="renderer">使用自定义渲染器</a></h2>
<p>本节介绍如何创建和指定单元格渲染器。您可以使用<code>JTable</code>方法<code>setDefaultRenderer</code> 。要指定特定列中的单元格应使用渲染器，请使用<code>TableColumn</code>方法<code>setCellRenderer</code> 。您甚至可以通过创建一个<code>JTable</code>子类。</p>
<p>自定义默认渲染器渲染的文本或图像很容易， <code>DefaultTableCellRenderer</code> 。您只需创建一个子类并实现<code>setValue</code>方法，以便它调用<code>setText</code>要么<code>setIcon</code>带有适当的字符串或图像。例如，以下是默认日期呈现器的实现方式：</p>
<div class="codeblock"><pre>
static class DateRenderer extends DefaultTableCellRenderer {
    DateFormat formatter;
    public DateRenderer() { super(); }

    public void setValue(Object value) {
        if (formatter==null) {
            formatter = DateFormat.getDateInstance();
        }
        setText((value == null) ? "" : formatter.format(value));
    }
}
</pre></div>
<p>如果扩展<code>DefaultTableCellRenderer</code>还不够，您可以使用另一个超类来构建渲染器。最简单的方法是创建现有组件的子类，使您的子类实现<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableCellRenderer.html" target="_blank"><code>TableCellRenderer</code></a>接口。 <code>TableCellRenderer</code>只需要一种方法： <code>getTableCellRendererComponent</code> 。此方法的实现应设置呈现组件以反映传入的状态，然后返回该组件。</p>
<p>在<a href="#colorRenderer">快照</a>中<code>TableDialogEditDemo</code> ，用于“ <b>收藏夹颜色”</b>单元格的渲染器是的子类<code>JLabel</code>叫<code>ColorRenderer</code> 。以下是摘录<a class="SourceLink" href="../examples/components/TableDialogEditDemoProject/src/components/ColorRenderer.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDialogEditDemoProject/src/components/ColorRenderer.java'); return false;"><code>ColorRenderer.java</code></a>展示了它是如何实现的。</p>
<div class="codeblock"><pre>
public class ColorRenderer extends JLabel
                           implements TableCellRenderer {
    ...
    public ColorRenderer(boolean isBordered) {
        this.isBordered = isBordered;
        setOpaque(true); //MUST do this for background to show up.
    }

    public Component getTableCellRendererComponent(
                            JTable table, Object color,
                            boolean isSelected, boolean hasFocus,
                            int row, int column) {
        Color newColor = (Color)color;
        setBackground(newColor);
        if (isBordered) {
            if (isSelected) {
                ...
                //selectedBorder is a solid border in the color
                //table.getSelectionBackground().
                setBorder(selectedBorder);
            } else {
                ...
                //unselectedBorder is a solid border in the color
                //table.getBackground().
                setBorder(unselectedBorder);
            }
        }
        
        setToolTipText(...); <em>//Discussed in the following section</em>
        return this;
    }
}
</pre></div>
<p>这是来自的代码<a class="SourceLink" href="../examples/components/TableDialogEditDemoProject/src/components/TableDialogEditDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDialogEditDemoProject/src/components/TableDialogEditDemo.java'); return false;"><code>TableDialogEditDemo.java</code></a>注册一个<code>ColorRenderer</code>实例作为所有实例的默认渲染器<code>Color</code>数据：</p>
<div class="codeblock"><pre>
table.setDefaultRenderer(Color.class, new ColorRenderer(true));
</pre></div>
<p>要指定特定于单元格的渲染器，您需要定义一个<code>JTable</code>覆盖<code>getCellRenderer</code>方法。例如，以下代码使表第一列中的第一个单元格使用自定义渲染器：</p>
<div class="codeblock"><pre>
TableCellRenderer weirdRenderer = new WeirdRenderer();
table = new JTable(...) {
    public TableCellRenderer getCellRenderer(int row, int column) {
        if ((row == 0) &amp;&amp; (column == 0)) {
            return weirdRenderer;
        }
        // else...
        return super.getCellRenderer(row, column);
    }
};
</pre></div>
<h2><a name="celltooltip" id="celltooltip">指定单元格的工具提示</a></h2>
<p>默认情况下，为表格单元格显示的工具提示文本由单元格的渲染器确定。但是，有时通过覆盖指定工具提示文本会更简单<code>JTable</code>的实施<code>getToolTipText(MouseEvent)</code>方法。本节说明如何使用这两种技术。</p>
<p>要将工具提示添加到使用其渲染器的单元格中，首先需要获取或创建单元格渲染器。然后，在确保渲染组件为<code>JComponent</code> ，调用<code>setToolTipText</code>方法就可以了。</p>
<p>单元格的设置工具提示示例如下<code>TableRenderDemo</code> 。单击启动按钮以使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）运行它。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableRenderDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableRenderDemoProject/TableRenderDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableRenderDemo示例"></a><br>
<p>源代码在<a class="SourceLink" href="../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java'); return false;"><code>TableRenderDemo.java</code></a> 。它使用以下代码将工具提示添加到“ <b>运动”</b>列的单元格中：</p>
<div class="codeblock"><pre>
//Set up tool tips for the sport cells.
DefaultTableCellRenderer renderer =
        new DefaultTableCellRenderer();
<b>renderer.setToolTipText("Click for combo box");</b>
sportColumn.setCellRenderer(renderer);
</pre></div>
<p>尽管上一个示例中的工具提示文本是静态的，但是您也可以实现工具提示，其文本根据单元或程序的状态而变化。这有几种方法：</p>
<ul>
<li>在渲染器的实现中添加一些代码<code>getTableCellRendererComponent</code>方法。</li>
<li>覆盖<code>JTable</code>方法<code>getToolTipText(MouseEvent)</code> 。</li>
</ul>
<p>在单元格渲染器中添加代码的示例在<code>TableDialogEditDemo</code> 。单击启动按钮以使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）运行它。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableDialogEditDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableDialogEditDemoProject/TableDialogEditDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableDialogEditDemo示例"></a><br>
<p><code>TableDialogEditDemo</code>为颜色使用渲染器，实现方式为<a class="SourceLink" href="../examples/components/TableDialogEditDemoProject/src/components/ColorRenderer.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDialogEditDemoProject/src/components/ColorRenderer.java'); return false;"><code>ColorRenderer.java</code></a> ，使用以下代码段中的粗体代码设置工具提示文本：</p>
<div class="codeblock"><pre>
public class ColorRenderer extends JLabel 
                           implements TableCellRenderer {
    ...
    public Component getTableCellRendererComponent(
                            JTable table, Object color,
                            boolean isSelected, boolean hasFocus,
                            int row, int column) {
        Color newColor = (Color)color;
        ...
        <b>setToolTipText("RGB value: " + newColor.getRed() + ", "
                                     + newColor.getGreen() + ", "
                                     + newColor.getBlue());</b>
        return this;
    }
}
</pre></div>
<p>这是工具提示的示例：</p>
<center><img src="../../figures/uiswing/components/TableDialogEditDemo-tooltip.png" width="526" height="119" align="bottom" alt="TableDialogEditDemo带有描述鼠标悬停单元格的RGB值的工具提示"></center><p>您可以通过覆盖指定工具提示文本<code>JTable</code>的<code>getToolTipText(MouseEvent)</code>方法。该程序<code>TableToolTipsDemo</code>显示如何。单击启动按钮以使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）运行它。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableToolTipsDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableToolTipsDemoProject/TableToolTipsDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableToolTipsDemo示例"></a><br>
<p>具有工具提示的单元格在“ <b>运动”</b>和“ <b>素食主义者”</b>列中。这是其工具提示的图片：</p>
<center><img src="../../figures/uiswing/components/TableToolTipsDemo-tooltip.png" width="579" height="119" align="bottom" alt="TableToolTipsDemo，带有“运动”列中单元格的工具提示"></center><p>这是来自的代码<a class="SourceLink" href="../examples/components/TableToolTipsDemoProject/src/components/TableToolTipsDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableToolTipsDemoProject/src/components/TableToolTipsDemo.java'); return false;"><code>TableToolTipsDemo.java</code></a>实现了“ <b>运动”</b>和“ <b>素食主义者”</b>列中单元格的工具提示：</p>
<div class="codeblock"><pre>
JTable table = new JTable(new MyTableModel()) {    
    //Implement table cell tool tips.
    public String getToolTipText(MouseEvent e) {
        String tip = null;
        java.awt.Point p = e.getPoint();
        int rowIndex = rowAtPoint(p);
        int colIndex = columnAtPoint(p);
        int realColumnIndex = convertColumnIndexToModel(colIndex);

        if (realColumnIndex == 2) { //Sport column
            tip = "This person's favorite sport to "
                   + "participate in is: "
                   + getValueAt(rowIndex, colIndex);

        } else if (realColumnIndex == 4) { //Veggie column
            TableModel model = getModel();
            String firstName = (String)model.getValueAt(rowIndex,0);
            String lastName = (String)model.getValueAt(rowIndex,1);
            Boolean veggie = (Boolean)model.getValueAt(rowIndex,4);
            if (Boolean.TRUE.equals(veggie)) {
                tip = firstName + " " + lastName
                      + " is a vegetarian";
            } else {
                tip = firstName + " " + lastName
                      + " is not a vegetarian";
            }

        } else { //another column
            //You can omit this part if you know you don't 
            //have any renderers that supply their own tool 
            //tips.
            tip = super.getToolTipText(e);
        }
        return tip;
    }
    ...
}
</pre></div>
<p>该代码非常简单，除了可能调用<code>convertColumnIndexToModel</code> 。该调用是必需的，因为如果用户在四处移动列，则该列的视图索引将与该列的模型索引不匹配。例如，用户可以拖动“ <b>素食主义者”</b>列（模型认为该列在索引4处），以便将其显示为第一列-在视图索引0处。以来<code>prepareRenderer</code>提供视图索引，则需要将视图索引转换为模型索引，以便可以确保已选择了预期的列。</p>
<h2><a name="headertooltip" id="headertooltip">指定列标题的工具提示</a></h2>
<p>您可以通过设置表格的工具提示文本来将工具提示添加到列标题<code>JTableHeader</code> 。通常，不同的列标题需要不同的工具提示文本。您可以通过覆盖表格标题的<code>getToolTipText</code>方法。或者，您可以调用<code>TableColumn.setHeaderRenderer</code>为标题提供自定义渲染器。</p>
<p>在所有列标题中使用相同的工具提示文本的示例在<a class="SourceLink" href="../examples/components/TableSorterDemoProject/src/components/TableSorterDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableSorterDemoProject/src/components/TableSorterDemo.java'); return false;"><code>TableSorterDemo.java</code></a> 。它是如何设置工具提示文本的：</p>

<div class="codeblock"><pre>
table.getTableHeader().setToolTipText(
        "Click to sort; Shift-Click to sort in reverse order");
</pre></div>

<p>
<a class="SourceLink" href="../examples/components/TableToolTipsDemoProject/src/components/TableToolTipsDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableToolTipsDemoProject/src/components/TableToolTipsDemo.java'); return false;"><code>TableToolTipsDemo.java</code></a>有一个实现列标题工具提示的示例，该提示因列而异。如果你跑<code>TableToolTipsDemo</code> （单击“启动”按钮）使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableToolTipsDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableToolTipsDemoProject/TableToolTipsDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableToolTipsDemo示例"></a><br>
<p>当您将鼠标悬停在除前两个头之外的任何列头上时，您将看到工具提示。名称栏不提供任何工具提示，因为它们似乎不言自明。这是列标题工具提示之一的图片：</p>
<center><img src="../../figures/uiswing/components/TableToolTipsDemo-tooltip-ch.png" width="566" height="119" align="bottom" alt="TableToolTipsDemo带有列标题的工具提示"></center><p>以下代码实现了工具提示。基本上，它创建了一个子类<code>JTableHeader</code>覆盖了<code>getToolTipText(MouseEvent)</code>方法，以便它返回当前列的文本。要将修改后的表头与表相关联， <code>JTable</code>方法<code>createDefaultTableHeader</code>被覆盖，以便它返回<code>JTableHeader</code>子类。</p>
<div class="codeblock"><pre>
protected String[] columnToolTips = {
    null, // &quot;First Name&quot; assumed obvious
    null, // &quot;Last Name&quot; assumed obvious
    "The person's favorite sport to participate in",
    "The number of years the person has played the sport",
    "If checked, the person eats no meat"};
...

JTable table = new JTable(new MyTableModel()) {
    ...

    //Implement table header tool tips.
    protected JTableHeader createDefaultTableHeader() {
        return new JTableHeader(columnModel) {
            public String getToolTipText(MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int index = columnModel.getColumnIndexAtX(p.x);
                int realIndex = 
                        columnModel.getColumn(index).getModelIndex();
                return columnToolTips[realIndex];
            }
        };
    }
};
</pre></div>
<h2><a name="sorting" id="sorting">排序和过滤</a></h2>
<p>表排序和筛选由<i>排序器</i>对象管理。提供分类对象的最简单方法是设置<code>autoCreateRowSorter</code>绑定到<code>true</code> ：</p>
<div class="codeblock"><pre>
JTable table = new JTable();
table.setAutoCreateRowSorter(true);
</pre></div>
<p>该操作定义了行排序器，该行排序器是<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableRowSorter.html" target="_blank"><code>javax.swing.table.TableRowSorter</code></a> 。这提供了一个表，当用户单击列标题时，该表将进行特定于区域设置的简单排序。这体现在<a class="SourceLink" href="../examples/components/TableSortDemoProject/src/components/TableSortDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableSortDemoProject/src/components/TableSortDemo.java'); return false;"><code><code>TableSortDemo.java</code></code></a> ，如以下屏幕截图所示：</p>
<center><img src="../../figures/uiswing/components/TableSortDemo.png" width="526" height="119" align="bottom" alt="单击姓氏后，TableSortDemo"></center><p>要更好地控制排序，您可以构造一个实例<code>TableRowSorter</code>并指定它是表的排序对象。</p>
<div class="codeblock"><pre>
TableRowSorter&lt;TableModel&gt; sorter 
    = new TableRowSorter&lt;TableModel&gt;(table.getModel());
table.setRowSorter(sorter);
</pre></div>
<p><code>TableRowSorter</code>用途<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank"><code>java.util.Comparator</code></a>对象对其行进行排序。实现此接口的类必须提供一种称为<code>compare</code>定义了如何比较两个对象以进行排序。例如，以下代码创建了一个<code>Comparator</code>按每个字符串中的最后一个单词对一组字符串进行排序：</p>
<div class="codeblock"><pre>
Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() {
    public int compare(String s1, String s2) {
        String[] strings1 = s1.split("\\s");
        String[] strings2 = s2.split("\\s");
        return strings1[strings1.length - 1]
            .compareTo(strings2[strings2.length - 1]);
    }
};
</pre></div>
<p>这个例子很简单。通常， <code>Comparator</code>实现是的子类<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/text/Collator.html" target="_blank"><code>java.text.Collator</code></a> 。您可以定义自己的子类，使用中的工厂方法<code>Collator</code>获得一个<code>Comparator</code>用于特定语言环境或使用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/text/RuleBasedCollator.html" target="_blank"><code>java.text.RuleBasedCollator</code></a> 。</p>
<p>确定哪个<code>Comparator</code>用于列<code>TableRowSorter</code>尝试依次应用以下每个规则。规则遵循以下列出的顺序；为分类器提供一个<code>Comparator</code>被使用，其余规则被忽略。</p>
<ol>
<li>如果通过调用指定了比较器<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/DefaultRowSorter.html#setComparator-int-java.util.Comparator-" target="_blank"><code>setComparator</code></a> ，使用该比较器。</li>
<li>如果表模型报告列数据由字符串组成（ <code>TableModel.getColumnClass</code>退货<code>String.class</code>对于该列），请使用比较器，该比较器根据当前语言环境对字符串进行排序。</li>
<li>如果列类返回<code>TableModel.getColumnClass</code>贯彻<code>Comparable</code> ，请使用一个比较器，该比较器根据的返回值对字符串进行排序<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-" target="_blank"><code>Comparable.compareTo</code></a> 。</li>
<li>如果通过调用为表指定了字符串转换器<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableRowSorter.html#setStringConverter-javax.swing.table.TableStringConverter-" target="_blank"><code>setStringConverter</code></a> ，请使用比较器，该比较器根据当前语言环境对结果字符串表示形式进行排序。</li>
<li>如果上述任何规则均不适用，则使用比较器来调用<code>toString</code>对列数据进行排序，并根据当前语言环境对结果字符串进行排序。</li>
</ol>
<p>对于更复杂的排序，子类<code>TableRowSorter</code>或其父类<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/DefaultRowSorter.html" target="_blank"><code>javax.swing.DefaultRowSorter</code></a> 。</p>
<p>要指定列的排序顺序和排序优先级，请调用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/DefaultRowSorter.html#setSortKeys-java.util.List-" target="_blank"><code>setSortKeys</code></a> 。这是一个示例，该示例按前两列对示例中使用的表进行排序。排序中列的优先级由排序键列表中排序键的顺序指示。在这种情况下，第二列具有第一个排序键，因此它们的行将按名字和姓氏排序。</p>
<div class="codeblock"><pre>
List &lt;RowSorter.SortKey&gt; sortKeys 
    = new ArrayList&lt;RowSorter.SortKey&gt;();
sortKeys.add(new RowSorter.SortKey(1, SortOrder.ASCENDING));
sortKeys.add(new RowSorter.SortKey(0, SortOrder.ASCENDING));
sorter.setSortKeys(sortKeys); 
</pre></div>
<p>除了对结果重新排序之外，表排序器还可以指定将显示哪些行。这称为<i>过滤</i> 。 <code>TableRowSorter</code>使用实现过滤<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/RowFilter.html" target="_blank"><code>javax.swing.RowFilter</code></a>对象。 <code>RowFilter</code>实现几种创建通用过滤器的工厂方法。例如， <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/RowFilter.html#regexFilter-java.lang.String-int...-" target="_blank"><code>regexFilter</code></a>返回一个<code>RowFilter</code>根据<a class="TutorialLink" href="../../essential/regex/" target="_top">正则表达式进行</a>过滤。</p>
<p>在下面的示例代码中，您显式创建一个sorter对象，以便以后可以使用它指定过滤器：</p>
<div class="codeblock"><pre>
MyTableModel model = new MyTableModel();
sorter = new TableRowSorter&lt;MyTableModel&gt;(model);
table = new JTable(model);
table.setRowSorter(sorter);
</pre></div>
<p>然后，根据文本字段的当前值进行过滤：</p>
<div class="codeblock"><pre>
private void newFilter() {
    RowFilter&lt;MyTableModel, Object&gt; rf = null;
    //If current expression doesn't parse, don't update.
    try {
        rf = RowFilter.regexFilter(filterText.getText(), 0);
    } catch (java.util.regex.PatternSyntaxException e) {
        return;
    }
    sorter.setRowFilter(rf);
}
</pre></div>
<p>在随后的示例中， <code>newFilter()</code>每次文本字段更改时都会调用。当用户输入复杂的正则表达式时， <code>try...catch</code>防止语法异常干扰输入。</p>
<p>当表使用排序器时，用户看到的数据可能与数据模型指定的顺序不同，并且可能不包括数据模型指定的所有行。用户实际看到的数据称为<i>view</i> ，并且具有自己的一组坐标。 <code>JTable</code>提供将模型坐标转换为视图坐标的方法- <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#convertColumnIndexToView-int-" target="_blank"><code>convertColumnIndexToView</code></a>和<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#convertRowIndexToView-int-" target="_blank"><code>convertRowIndexToView</code></a> -并将视图坐标转换为模型坐标- <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#convertColumnIndexToModel-int-" target="_blank"><code>convertColumnIndexToModel</code></a>和<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#convertRowIndexToModel-int-" target="_blank"><code>convertRowIndexToModel</code></a> 。</p>
<div class="note"><hr><strong>注意：</strong>使用排序器时，请始终记住要转换单元格坐标。
<hr></div>
<p>以下示例汇集了本节中讨论的想法。
<a class="SourceLink" href="../examples/components/TableFilterDemoProject/src/components/TableFilterDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableFilterDemoProject/src/components/TableFilterDemo.java'); return false;"><code><code>TableFilterDemo.java</code></code></a>添加少量更改<code>TableDemo</code> 。其中包括本节前面的代码段，这些代码段为主表提供了排序程序，并使用文本字段提供了过滤正则表达式。以下屏幕截图显示了<code>TableFilterDemo</code>在进行任何排序或过滤之前。请注意，模型中的第3行仍与视图中的第3行相同：</p>
<center><img src="../../figures/uiswing/components/FilterSort.png" width="526" height="177" align="bottom" alt="TableFilterDemo不排序"></center><p>如果用户在第二列上单击两次，则第四行成为第一行-但仅在视图中：</p>
<center><img src="../../figures/uiswing/components/Reverse.png" width="526" height="177" align="bottom" alt="TableFilterDemo在第二列中进行反向排序"></center><p>如前所述，用户在“过滤器文本”文本字段中输入的文本定义了一个过滤器，该过滤器确定显示哪些行。与排序一样，过滤可能导致视图坐标与模型坐标偏离：</p>
<center><img src="../../figures/uiswing/components/FilterFilter.png" width="526" height="177" align="bottom" alt="具有过滤功能的TableFilterDemo"></center><p>以下是更新状态字段以反映当前选择的代码：</p>
<div class="codeblock"><pre>
table.getSelectionModel().addListSelectionListener(
        new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent event) {
                int viewRow = table.getSelectedRow();
                if (viewRow &lt; 0) {
                    //Selection got filtered away.
                    statusText.setText("");
                } else {
                    int modelRow = 
                        table.convertRowIndexToModel(viewRow);
                    statusText.setText(
                        String.format("Selected Row in view: %d. " +
                            "Selected Row in model: %d.", 
                            viewRow, modelRow));
                }
            }
        }
);
</pre></div>
<h2><a name="combobox" id="combobox">使用组合框作为编辑器</a></h2>
<p>将<a href="combobox.html">组合框</a>设置为编辑器很简单，如以下示例所示。粗体代码行将组合框设置为特定列的编辑器。</p>
<div class="codeblock"><pre>
TableColumn sportColumn = table.getColumnModel().getColumn(2);
...
JComboBox comboBox = new JComboBox();
comboBox.addItem("Snowboarding");
comboBox.addItem("Rowing");
comboBox.addItem("Chasing toddlers");
comboBox.addItem("Speed reading");
comboBox.addItem("Teaching high school");
comboBox.addItem("None");
<b>sportColumn.setCellEditor(new DefaultCellEditor(comboBox));</b>
</pre></div>
<p>这是正在使用的组合框编辑器的图片：</p>
<center><img src="../../figures/uiswing/components/TableRenderDemo.png" width="525" height="188" align="bottom" alt="使用中的组合框单元格编辑器"></center><p>前面的代码来自<a class="SourceLink" href="../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java'); return false;"><code>TableRenderDemo.java</code></a> 。你可以跑<code>TableRenderDemo</code> （单击“启动”按钮）使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableRenderDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableRenderDemoProject/TableRenderDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableRenderDemo示例"></a><br>
<h2><a name="editor" id="editor">使用其他编辑器</a></h2>
<p>是否为单个单元格设置编辑器（使用<code>TableColumn</code><code>setCellEditor</code>方法）或针对特定类型的数据（使用<code>JTable</code><code>setDefaultEditor</code>方法），您可以使用与<code>TableCellEditor</code>接口。幸运的是<code>DefaultCellEditor</code>类实现此接口并提供构造函数，让您指定一个编辑组件，该组件是<code>JTextField</code> ， <code>JCheckBox</code> ， 要么<code>JComboBox</code> 。通常，您不必显式指定复选框作为编辑器，因为带有<code>Boolean</code>数据自动使用复选框渲染器和编辑器。</p>
<p>如果要指定除文本字段，复选框或组合框之外的编辑器怎么办？如<code>DefaultCellEditor</code>不支持其他类型的组件，则必须做更多的工作。您需要创建一个实现<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/table/TableCellEditor.html" target="_blank"><code>TableCellEditor</code></a>接口。的<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/AbstractCellEditor.html" target="_blank"><code>AbstractCellEditor</code></a> class是一个很好的超类。它实现<code>TableCellEditor</code>的超级接口， <a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/CellEditor.html" target="_blank"><code>CellEditor</code></a> ，省去了实现单元格编辑器所需的事件触发代码的麻烦。</p>
<p>您的单元格编辑器类至少需要定义两种方法- <code>getCellEditorValue</code>和<code>getTableCellEditorComponent</code> 。的<code>getCellEditorValue</code>方法，由<code>CellEditor</code> ，返回单元格的当前值。的<code>getTableCellEditorComponent</code>方法，由<code>TableCellEditor</code> ，应配置并返回要用作编辑器的组件。</p>
<p>这是带有对话框的表的图片，该对话框间接用作单元格编辑器。当用户开始在“ <b>收藏夹颜色”</b>列中编辑单元格时，将出现一个按钮（真正的单元格编辑器）并弹出对话框，用户可以使用该对话框选择其他颜色。</p>
<p><a name="colorRenderer" id="colorRenderer"></a></p>
<center><img src="../../figures/uiswing/components/ColorPicker.png" width="457" height="413" align="bottom" alt="单元格编辑器弹出一个对话框"></center><p>你可以跑<code>TableDialogEditDemo</code> （单击“启动”按钮）使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableDialogEditDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableDialogEditDemoProject/TableDialogEditDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableDialogEditDemo示例"></a><br>
<p>这是代码，摘自<a class="SourceLink" href="../examples/components/TableDialogEditDemoProject/src/components/ColorEditor.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableDialogEditDemoProject/src/components/ColorEditor.java'); return false;"><code>ColorEditor.java</code></a> ，它实现单元格编辑器。</p>
<div class="codeblock"><pre>
public class ColorEditor extends AbstractCellEditor
                         implements TableCellEditor,
                                    ActionListener {
    Color currentColor;
    JButton button;
    JColorChooser colorChooser;
    JDialog dialog;
    protected static final String EDIT = "edit";

    public ColorEditor() {
        button = new JButton();
        button.setActionCommand(EDIT);
        button.addActionListener(this);
        button.setBorderPainted(false);

        //Set up the dialog that the button brings up.
        colorChooser = new JColorChooser();
        dialog = JColorChooser.createDialog(button,
                                        "Pick a Color",
                                        true,  //modal
                                        colorChooser,
                                        this,  //OK button handler
                                        null); //no CANCEL button handler
    }

    public void actionPerformed(ActionEvent e) {
        if (EDIT.equals(e.getActionCommand())) {
            //The user has clicked the cell, so
            //bring up the dialog.
            button.setBackground(currentColor);
            colorChooser.setColor(currentColor);
            dialog.setVisible(true);

            fireEditingStopped(); //Make the renderer reappear.

        } else { //User pressed dialog's "OK" button.
            currentColor = colorChooser.getColor();
        }
    }

    //Implement the one CellEditor method that AbstractCellEditor doesn't.
    public Object getCellEditorValue() {
        return currentColor;
    }

    //Implement the one method defined by TableCellEditor.
    public Component getTableCellEditorComponent(JTable table,
                                                 Object value,
                                                 boolean isSelected,
                                                 int row,
                                                 int column) {
        currentColor = (Color)value;
        return button;
    }
}
</pre></div>
<p>如您所见，代码非常简单。唯一有些棘手的部分是调用<code>fireEditingStopped</code>在编辑器按钮的动作处理程序的末尾。没有此调用，即使不再显示模式对话框，编辑器也将保持活动状态。致电<code>fireEditingStopped</code>让表格知道它可以停用编辑器，让单元再次由渲染器处理。</p>
<h2><a name="validtext" id="validtext">使用编辑器验证用户输入的文本</a></h2>
<p>如果单元格的默认编辑器允许输入文本，则如果该单元格的类型指定为除<code>String</code>要么<code>Object</code> 。错误检查是将输入的文本转换为适当类型的对象的副作用。</p>
<p>当默认编辑器尝试创建与该单元格的列关联的类的新实例时，将自动检查用户输入的字符串。预设编辑器会使用采用<code>String</code>作为争论。例如，在其单元格具有类型的列中<code>Integer</code> ，当用户输入“ 123”时，默认编辑器会创建相应的<code>Integer</code>使用等效于<code>new Integer("123")</code> 。如果构造函数抛出异常，则单元格的轮廓变为红色，并拒绝让焦点移出单元格。如果实现了用作列数据类型的类，则可以使用默认编辑器（如果您的类提供了一个采用类型为单个参数的构造函数） <code>String</code> 。</p>
<p>如果您希望使用文本字段作为单元格的编辑器，但想对其进行自定义（例如可能要更严格地检查用户输入的文本或在文本无效时做出不同的反应），则可以更改单元格编辑器以使用<a href="formattedtextfield.html">格式化的文本领域</a> 。格式化的文本字段可以在用户键入时连续显示，也可以在用户指示键入结束后（例如，按Enter键）检查值。</p>
<p>以下代码摘自一个名为demo的演示<a class="SourceLink" href="../examples/components/TableFTFEditDemoProject/src/components/TableFTFEditDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableFTFEditDemoProject/src/components/TableFTFEditDemo.java'); return false;"><code>TableFTFEditDemo.java</code></a> ，将格式化的文本字段设置为编辑器，以将所有整数值限制在0到100之间。你可以跑<code>TableFTFEditDemo</code> （单击“启动”按钮）使用<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html" target="_blank">Java™Web Start</a> （ <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载JDK 7或更高版本</a> ）。或者，要自己编译并运行示例，请参考<a href="../examples/components/index.html#TableFTFEditDemo">示例索引</a> 。</p>
<a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TableFTFEditDemoProject/TableFTFEditDemo.jnlp"><img src="../../images/jws-launch-button.png" width="88" height="23" align="bottom" alt="启动TableFTFEditDemo示例"></a><br>
<p>以下代码使格式化的文本字段成为包含类型数据的所有列的编辑器<code>Integer</code> 。</p>
<div class="codeblock"><pre>
table.setDefaultEditor(Integer.class,
                       new IntegerEditor(0, 100));
</pre></div>
<p>的<code>IntegerEditor</code>类被实现为的子类<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/DefaultCellEditor.html" target="_blank"><code>DefaultCellEditor</code></a>使用一个<code>JFormattedTextField</code>而不是<code>JTextField</code>那<code>DefaultCellEditor</code>支持。为此，它首先使用<a href="formattedtextfield.html">如何使用带格式的文本字段中</a>介绍的API <a href="formattedtextfield.html">，将带格式的文本字段</a>设置为使用整数格式并具有指定的最小值和最大值。然后，它将覆盖<code>DefaultCellEditor</code>实施<code>getTableCellEditorComponent</code> ， <code>getCellEditorValue</code>和<code>stopCellEditing</code>方法，添加格式化文本字段所需的操作。</p>
<p>覆盖<code>getTableCellEditorComponent</code>设置格式化的文本字段的<em>value</em>属性（而不仅仅是它继承自的<em>text</em>属性） <code>JTextField</code> ），然后显示编辑器。覆盖<code>getCellEditorValue</code>将单元格值保留为<code>Integer</code> ，而不是说<code>Long</code>格式化的文本字段的解析器倾向于返回的值。最后，覆盖<code>stopCellEditing</code>使您可以检查文本是否有效，有可能阻止编辑器被关闭。如果文字无效，则您的实现<code>stopCellEditing</code>弹出一个对话框，使用户可以选择继续编辑或还原为上一个好的值。源代码有点长，无法包含在此处，但是您可以在以下位置找到它<a class="SourceLink" href="../examples/components/TableFTFEditDemoProject/src/components/IntegerEditor.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TableFTFEditDemoProject/src/components/IntegerEditor.java'); return false;"><code>IntegerEditor.java</code></a> 。</p>
<h2><a name="printing" id="printing">列印</a></h2>
<p><code>JTable</code>提供了用于打印表格的简单API。打印表的最简单方法是调用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#print--" target="_blank"><code>JTable.print</code></a>没有参数：</p>
<div class="codeblock"><pre>
try {
    if (! table.print()) {
        System.err.println("User cancelled printing");
    }
} catch (java.awt.print.PrinterException e) {
    System.err.format("Cannot print %s%n", e.getMessage());
}
</pre></div>
<p>调用中<code>print</code>在普通的Swing应用程序上，会弹出一个标准的打印对话框。（在无头应用程序中，只需打印表格即可。）返回值指示用户是继续打印作业还是取消打印作业。 <code>JTable.print</code>可以扔<code>java.awt.print.PrinterException</code> ，这是一个受<a class="TutorialLink" href="../../essential/exceptions/catchOrDeclare.html" target="_top">检查的异常</a> ;这就是为什么上面的示例使用<code>try ... catch</code> 。</p>
<p><code>JTable</code>提供了几个重载<code>print</code>有各种选择。以下代码来自<a class="SourceLink" href="../examples/components/TablePrintDemoProject/src/components/TablePrintDemo.java" target="_blank" onclick="showCode('../../displayCode.html', '../examples/components/TablePrintDemoProject/src/components/TablePrintDemo.java'); return false;"><code><code>TablePrintDemo.java</code></code></a>显示了如何定义页面标题：</p>
<div class="codeblock"><pre>
MessageFormat header = new MessageFormat("Page {0,number,integer}");
try {
    table.print(JTable.PrintMode.FIT_WIDTH, header, null);
} catch (java.awt.print.PrinterException e) {
    System.err.format("Cannot print %s%n", e.getMessage());
}
</pre></div>
<p>对于更复杂的打印应用，请使用<a class="APILink" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTable.html#getPrintable-javax.swing.JTable.PrintMode-java.text.MessageFormat-java.text.MessageFormat-" target="_blank"><code>JTable.getPrintable</code></a>获得一个<code>Printable</code>表格的对象。有关更多<code>Printable</code> ，请参阅“ <a class="TutorialLink" href="../../2d/index.html" target="_top">2D图形”</a>轨迹中的“ <a class="TutorialLink" href="../../2d/printing/index.html" target="_top">打印”</a>课程。</p>
<h2><a name="eg" id="eg">使用表格的例子</a></h2>
<p>下表列出了使用<code>JTable</code>以及描述这些示例的位置。</p>
<table border="1" summary="Information about examples">
<tbody>
<tr>
<th align="left">例</th>
<th align="left">描述的地方</th>
<th align="left">笔记</th>
</tr>
<tr>
<td><a href="../examples/components/index.html#SimpleTableDemo"><code>SimpleTableDemo</code></a></td>
<td><a href="#simple">创建一个简单的表</a></td>
<td><em>没有</em>自定义模型的基本表。不包括用于<a href="#width">指定列宽</a>或<a href="#modelchange">检测用户编辑的代码</a> 。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#SimpleTableSelectionDemo"><code>SimpleTable-<br> SelectionDemo</code></a></td>
<td><a href="#selection">检测用户选择</a></td>
<td>将单个选择和选择检测添加到<code>SimpleTableDemo</code> 。通过修改程序的<code>ALLOW_COLUMN_SELECTION</code>和<code>ALLOW_ROW_SELECTION</code>常量，您可以尝试使用表默认值（仅允许选择行）的替代方法。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableDemo"><code>TableDemo</code></a></td>
<td><a href="#data">创建表模型</a></td>
<td>具有自定义模型的基本表。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableFTFEditDemo"><code>TableFTFEditDemo</code></a></td>
<td><a href="#validtext">使用编辑器验证用户输入的文本</a></td>
<td>修改<code>TableDemo</code>对全部使用自定义编辑器（格式化的文本字段变体） <code>Integer</code>数据。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableRenderDemo"><code>TableRenderDemo</code></a></td>
<td><a href="#combobox">使用组合框作为编辑器</a></td>
<td>修改<code>TableDemo</code>对“ <b>体育”</b>列中的所有数据使用自定义编辑器（组合框）。还可以智能地选择列大小。使用渲染器显示运动单元的工具提示。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableDialogEditDemo"><code>TableDialogEditDemo</code></a></td>
<td><a href="#editor">使用其他编辑器</a></td>
<td>修改<code>TableDemo</code>具有显示颜色的单元格渲染器和编辑器，并允许您使用颜色选择器对话框选择新的颜色。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableToolTipsDemo"><code>TableToolTipsDemo</code></a></td>
<td><a href="#celltooltip">为单元格</a> <a href="#headertooltip">指定工具提示，为列标题指定工具提示</a> ，</td>
<td>演示如何使用多种技术来设置单元格和列标题的工具提示文本。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableSortDemo"><code>TableSortDemo</code></a></td>
<td><a href="#sorting">排序和过滤</a></td>
<td>演示默认的排序器，该排序器使用户可以通过单击标题来对列进行排序。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TableFilterDemo"><code>TableFilterDemo</code></a></td>
<td><a href="#sorting">排序和过滤</a></td>
<td>演示排序和过滤，以及如何使视图坐标与模型坐标偏离。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#TablePrintDemo"><code>TablePrintDemo</code></a></td>
<td><a href="#printing">列印</a></td>
<td>演示表格打印。</td>
</tr>
<tr>
<td><a href="../examples/events/index.html#ListSelectionDemo"><code>ListSelectionDemo</code></a></td>
<td><a href="../events/listselectionlistener.html">如何编写列表选择监听器</a></td>
<td>显示如何使用表和列表之间共享的列表选择侦听器来使用所有列表选择模式。</td>
</tr>
<tr>
<td><a href="../examples/components/index.html#SharedModelDemo"><code>SharedModelDemo</code></a></td>
<td>无处</td>
<td>建立在<code>ListSelectionDemo</code>使数据模型在表和列表之间共享。如果在表的第一列中编辑项目，则新值将反映在列表中。</td>
</tr>
</tbody>
</table>


        </div>
        <div class="NavBit">
            <a href="tabbedpane.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="textarea.html" target="_top">下一个»</a>
        </div>
    </div>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>如何使用选项卡式窗格<br><b>下一页：</b>如何使用文本区域</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</body></html>