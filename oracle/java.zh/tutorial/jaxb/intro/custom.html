<html lang="en-US"  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="load()">﻿
        <title>定制JAXB绑定（Java™教程> XML绑定的Java体系结构（JAXB）> JAXB简介）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="description" content="This JAXB tutorial describes Java Architecture for XML Binding (jaxb), and related XML topics">
     <meta name="keywords" content="java programming, learn java, java sample code, jaxb, xml">
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>

    <noscript>要使此页面正常运行，需要启用JavaScript的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文献资料</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">JAXB简介</a></div>
<div class="linkAHEAD"><a href="arch.html">JAXB体系结构</a></div>
<div class="linkAHEAD"><a href="repcon.html">表示XML内容</a></div>
<div class="linkAHEAD"><a href="bind.html">绑定XML模式</a></div>
<div class="linkAHEAD"><a href="customize.html">自定义生成的类和Java程序元素</a></div>
<div class="linkAHEAD"><a href="examples.html">JAXB示例</a></div>
<div class="linkAHEAD"><a href="basic.html">基本范例</a></div>
<div class="nolinkAHEAD">自定义JAXB绑定</div>
<div class="linkAHEAD"><a href="j2schema.html">Java到模式的示例</a></div>
<div class="linkAHEAD"><a href="info.html">想要查询更多的信息</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b> XML绑定的Java体系结构（JAXB）<br><b>课程：</b> JAXB简介</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> > <a href="../index.html" target="_top">XML绑定的Java体系结构（JAXB）</a> > <a href="index.html" target="_top">JAXB简介</a>
            </div>
            <div class="NavBit">
                <a href="basic.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="j2schema.html" target="_top">下一个»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。此页面中描述的示例和实践没有利用更高版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>自定义JAXB绑定</h1></div>
            <div id="PageContent">

<p>以下部分描述了一些示例，这些示例基于基本示例中演示的概念。</p>

<p>本部分的目的是说明如何使用自定义绑定声明来自定义JAXB绑定，该声明是通过以下两种方式之一进行的：</p>
<ul>
<li>作为注释在XML模式中内联</li>
<li>作为外部文件中的语句传递给JAXB绑定编译器</li>
</ul>
<p>与<a class="TutorialLink" href="basic.html" target="_top">Basic JAXB Examples中的示例</a>着重于各自<tt>Main.java</tt>类文件中的Java代码不同，此处的示例着重于<b>在</b>生成模式派生的Java绑定类<b>之前</b>对XML模式进行的自定义。</p>

<div class="note"><hr><strong>注意：</strong>当前必须手动进行JAXB绑定自定义。JAXB技术的目标之一是标准化绑定声明的格式，从而可以创建自定义工具并在JAXB实现之间提供标准的交换格式。
<hr></div>

<p>本节介绍可以对JAXB绑定和验证方法进行的自定义。有关更多信息，请参见<a class="OutsideLink" href="http://jaxb.java.net" target="_blank">JAXB规范</a> 。</p>

<h2><a name="bnbbg">为什么要自定义？</a></h2>

<p>在大多数情况下，由JAXB绑定编译器生成的默认绑定就足够了。但是，在某些情况下，您可能需要修改默认绑定。其中一些包括：</p>
<ul>
<li>为基于模式的JAXB包，类，方法和常量创建API文档：通过将自定义Javadoc工具注释添加到模式中，可以解释特定于实现的概念，准则和规则。</li>
<li>为默认的XML名称到Java标识符映射无法自动处理的情况提供语义上有意义的自定义名称；例如：<ul>
	<li>解决名称冲突（如<i>JAXB规范的</i>附录D.2.1中所述）。请注意，JAXB绑定编译器检测并报告所有名称冲突。</li>
	<li>为无效的Java标识符提供类型安全的枚举常量的名称；例如，对整数值进行枚举。</li>
	<li>当未命名模型组绑定到Java属性或类时，为它们的Java表示提供更好的名称。</li>
	<li>提供比默认情况下从目标名称空间URI派生的有意义的包名称。</li>
	</ul>
</li>
<li>覆盖默认绑定；例如：<ul>
	<li>指定模型组必须绑定到类而不是列表。</li>
	<li>指定可以将固定属性绑定到Java常量。</li>
	<li>覆盖XML Schema内置数据类型到Java数据类型的指定默认绑定。在某些情况下，您可能想引入一个替代Java类，该类可以表示内置XML Schema数据类型的其他特征。</li>
	</ul>
</li>
</ul>

<h2><a name="bnbbh"></a>定制概述</h2>
<p>本节说明一些JAXB核心定制概念：</p>
<ul>
	<li>内联和外部定制</li>
	<li>范围，继承和优先级</li>
	<li>自定义语法</li>
	<li>自定义名称空间前缀</li>
</ul>

<h2><a name="bnbbi"></a>内联和外部定制</h2>
<p>对默认JAXB绑定的自定义是以传递到JAXB绑定编译器的<b>绑定声明</b>的形式进行的。这些绑定声明可以通过以下两种方式之一进行：</p>
<ul>
<li>作为源XML模式中的内联注释</li>
<li>作为外部绑定定制文件中的声明</li>
</ul>
<p>对于某些用户而言，使用内联自定义更为容易，因为您可以在自定义对其应用的架构的上下文中看到自定义。相反，使用外部绑定自定义文件使您能够自定义JAXB绑定而无需修改源模式，并使您能够轻松地一次将自定义应用于多个模式文件。</p>

<div class="note"><hr><strong>注意：</strong>您可以组合两种类型的定制。例如，您可以在内联注释中包含对外部绑定定制文件的引用。但是，不能在同一架构元素上同时声明内联和外部定制。
<hr></div>

<p>以下各节将对每种类型的自定义进行更详细的描述：</p>

<h3><a name="bnbbj"></a>内联定制</h3>

<p>通过XML模式文件中的内联<b>绑定声明</b>对JAXB绑定进行的定制形式为<tt><xsd:appinfo></xsd:appinfo></tt>架构中嵌入的元素<tt><xsd:annotation></xsd:annotation></tt>元素（ <tt>xsd：</tt>是XML模式名称空间前缀，如W3C <i>XML模式第1部分：结构中</i>所定义）。以下示例显示了内联定制的一般形式：</p>

<div class="codeblock"><pre>
&lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
        &lt;!--
        ...
        binding declarations     .
        ...
        --&gt;
    &lt;/xs:appinfo&gt;
&lt;/xs:annotation&gt;
</pre></div>

<p>自定义应用在架构中声明它们的位置。例如，在特定元素级别的声明仅适用于该元素。请注意，XML模式名称空间前缀必须与<tt><annotation></annotation></tt>和<tt><appinfo></appinfo></tt>声明标签。在前面的示例中， <tt>xs：</tt>用作名称空间前缀，因此声明被标记<tt><xs:annotation></xs:annotation></tt>和<tt><xs:appinfo></xs:appinfo></tt> 。</p>

<h3><a name="bnbbk"></a>外部绑定自定义文件</h3>
<p>通过使用包含绑定声明的外部文件对JAXB绑定进行定制，其格式如下例所示：</p>

<div class="codeblock"><pre>
&lt;jxb:bindings schemaLocation = &quot;xs:anyURI&quot;&gt;
    &lt;jxb:bindings node = &quot;xs:string&quot;&gt;*
        &lt;!-- binding declaration --&gt;
    &lt;jxb:bindings&gt;
&lt;/jxb:bindings&gt;
</pre></div>
<ul>
	<li><tt>schemaLocation</tt>是对远程模式的URI引用。</li>
	<li><tt>node</tt>是XPath 1.0表达式，用于标识<tt>schemaLocation</tt>中与给定绑定声明关联的模式节点。</li>
</ul>
<p>例如，JAXB绑定声明文件中的第一个<tt>schemaLocation</tt> / <tt>节点</tt>声明指定了模式名称和根模式节点：</p>

<div class="codeblock"><pre>
&lt;jxb:bindings schemaLocation=&quot;po.xsd&quot; node=&quot;/xs:schema&quot;&gt;
&lt;/jxb:bindings&gt;
</pre></div>

<p>后续的<tt>schemaLocation</tt> / <tt>节点</tt>声明，例如上一个模式示例中名为<tt>ZipCodeType</tt>的<tt>simpleType</tt>元素，采用以下形式：</p>

<div class="codeblock"><pre>
&lt;jxb:bindings node=&quot;//xs:simpleType [@name=&rsquo;ZipCodeType&rsquo;]&quot;&gt;
</pre></div>

<h3><a name="bnbbl"></a>绑定自定义文件格式</h3>
<p>绑定自定义文件必须为ASCII文本。名称或扩展名无关紧要；尽管本章中使用的典型扩展名是<tt>.xjb</tt> 。</p>

<h3><a name="bnbbm"></a>将自定义文件传递给JAXB绑定编译器</h3>
<p>使用以下语法，将包含绑定声明的定制文件传递给JAXB Binding编译器<tt>xjc</tt> ：</p>

<div class="codeblock"><pre>
xjc -b file schema
</pre></div>
<p>其中， <i>file</i>是绑定定制文件的名称， <i>schema</i>是您要传递给绑定编译器的模式的名称。</p>

<p>您可以有一个包含多个模式自定义项的绑定文件，也可以将自定义项分成多个绑定文件。例如：</p>

<div class="codeblock"><pre>
xjc schema1.xsd schema2.xsd schema3.xsd \
    -b bindings123.xjb
xjc schema1.xsd schema2.xsd schema3.xsd \
    -b bindings1.xjb \
    -b bindings2.xjb \
    -b bindings3.xjb
</pre></div>

<p>注意，在命令行上模式文件和绑定文件的顺序无关紧要；尽管每个绑定定制文件必须在命令行上带有自己的<tt>-b</tt>开关。</p>

<p>有关一般<tt>xjc</tt>编译器选项的更多信息，请参见<a class="TutorialLink" href="examples.html#bnbal" target="_top">JAXB编译器选项</a> 。</p>

<h3><a name="bnbbn"></a>外部绑定自定义的限制</h3>
<p>有一些规则适用于在外部绑定定制文件中进行的绑定声明，而不适用于在源模式中内联进行的类似声明：</p>
<ul>
	<li>绑定定制文件必须以<tt>jxb：bindings版本</tt>属性以及JAXB和XMLSchema命名空间的属性开头：<div class="codeblock"><pre>
&lt;jxb:bindings version=&quot;1.0&quot; 
    xmlns:jxb=&quot;http://java.sun.com/xml/ns/jaxb&quot; 
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
</pre></div>
</li>
	<li>必须通过使用<tt>jxb：bindings</tt>声明指定<tt>schemaLocation</tt>和<tt>node</tt>属性，以XPath表示法明确标识要应用绑定声明的远程模式：<ul>
	<li><tt>schemaLocation</tt>指定对远程模式的URI引用。</li>
	<li><tt>节点</tt>指定一个XPath 1.0表达式，该表达式标识<tt>schemaLocation</tt>中与给定绑定声明关联的模式节点；对于绑定定制文件中的初始<tt>jxb：bindings</tt>声明，该节点通常是<tt>“ / xs：schema”</tt> 。</li>
	</ul>
</li>
</ul>

<p>类似地，必须使用XPath表示法指定要在其中应用定制的模式中的各个节点。例如：</p>
<div class="codeblock"><pre>
&lt;jxb:bindings node=&quot;//xs:complexType [@name=&rsquo;USAddress&rsquo;]&quot;&gt;
</pre></div>

<p>在这种情况下，绑定编译器会将自定义应用于节点，就像声明是内联地嵌入到节点的声明中一样。 <tt><xs:appinfo></xs:appinfo></tt>元件。</p>

<p>总结这些规则，外部绑定元素<tt><jxb:bindings></jxb:bindings></tt>仅在以下三种情况下才能被JAXB绑定编译器识别为处理：</p>
<ul>
<li>当其父母是<tt><xs:appinfo></xs:appinfo></tt>元件。</li>
<li>当它是另一个的祖先<tt><jxb:bindings></jxb:bindings></tt>元件。</li>
<li>当它是文档的根元素时。具有以下内容的XML文档： <tt><jxb:bindings></jxb:bindings></tt>元素作为其根称为外部绑定声明文件。</li>
</ul>

<h3><a name="bnbbo"></a>范围，继承和优先级</h3>
<p>可以在四个不同的级别或<b>范围内</b>自定义或覆盖默认的JAXB绑定。</p>

<p>下图说明了自定义声明的继承和优先级。具体来说，朝向金字塔顶部的声明会继承并取代位于其下方的声明。</p>

<p>组件声明继承并取代了定义声明；定义声明继承并取代Schema声明；和Schema声明继承并替代Global声明。</p>

<p><a name="bnbbp"></a>图：自定义范围的继承和优先级</p>
<center><img src="../../figures/jaxb/jaxb-customInheritance.gif" width="400" height="340" align="bottom" alt="自定义范围的继承和优先级"></center><br><br>
<h3>自定义语法</h3>
<p>下一节将描述四种类型的JAXB绑定声明的语法，XML到Java数据类型绑定声明的语法以及定制名称空间前缀。</p>
<ul>
   <li><a href="#bnbbr">全球约束力声明</a></li>
   <li><a href="#bnbbs">模式绑定声明</a></li>
   <li><a href="#bnbbt">类绑定声明</a></li>
   <li><a href="#bnbbu">属性绑定声明</a></li>
   <li><a href="#bnbbv">javaType绑定声明</a></li>
   <li><a href="#bnbbw">类型安全枚举绑定声明</a></li>
   <li><a href="#bnbbx">javadoc绑定声明</a></li>
</ul>

<h3><a name="bnbbr"></a>全球约束力声明</h3>
<p>全局范围自定义用声明<tt><globalbindings></globalbindings></tt> 。全局范围自定义的语法如下：</p>

<div class="codeblock"><pre>
&lt;globalBindings&gt;
    [ collectionType = &quot;collectionType&quot; ]
    [ fixedAttributeAsConstantProperty = &quot;true&quot; | &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ generateIsSetMethod = &quot;true&quot; | &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ enableFailFastCheck = &quot;true&quot; | &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ choiceContentProperty = &quot;true&quot; | &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ underscoreBinding = &quot;asWordSeparator&quot; | &quot;asCharInWord&quot; ]
    [ typesafeEnumBase = &quot;typesafeEnumBase&quot; ]
    [ typesafeEnumMemberName = &quot;generateName&quot; | &quot;generateError&quot; ]
    [ enableJavaNamingConventions = &quot;true&quot; | &quot;false&quot; 
    | &quot;1&quot; | &quot;0&quot; ]
    [ bindingStyle = &quot;elementBinding&quot; | &quot;modelGroupBinding&quot; ]
    [ &lt;javaType&gt; ... &lt;/javaType&gt; ]*
&lt;/globalBindings&gt;
</pre></div>

<ul>
	<li>可以对<tt>collectionType</tt>进行<tt>索引，</tt>也可以对实现<tt>java.util的任何完全限定的类名进行<tt>索引</tt> <tt>。清单</tt> 。</tt></li><tt>
	<li><tt>fixedAttributeAsConstantProperty</tt>可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。默认值为<tt>false</tt> 。</li> 
	<li><tt>generateIsSetMethod</tt>可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。默认值为<tt>false</tt> 。</li>
	<li><tt>enableFailFastCheck</tt>可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。如果<tt>enableFailFastCheck</tt>为<tt>true</tt>或<tt>1</tt> ，并且JAXB实现支持此可选检查，则在设置属性时执行类型约束检查。默认值为<tt>false</tt> 。请注意，JAXB实现不支持快速故障验证。</li>
	<li><tt>choiceContentProperty</tt>可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。默认值为<tt>false</tt> 。 <tt>choiceContentProperty</tt>是不相关的，当<tt>bindingStyle</tt>是<tt>elementBinding。</tt>因此，如果将<tt>bindingStyle</tt>指定为<tt>elementBinding</tt> ，则<tt>choiceContentProperty</tt>必须导致无效的自定义。</li>
	<li><tt>underscoreBinding</tt>可以是<tt>asWordSeparator</tt>或<tt>asCharInWord</tt> 。默认值为<tt>asWordSeparator</tt> 。</li>
	<li><tt>typesafeEnumBase</tt>可以是QName的列表，每个QName必须解析为简单的类型定义。默认值为<tt>xs：NCName</tt> 。有关<tt>simpleType</tt>定义到Java <tt>typesafe枚举</tt>类的本地化映射的信息，请参见<a href="#bnbbw">Typesafe枚举绑定声明</a> 。</li>
	<li><tt>typesafeEnumMemberName</tt>可以是<tt>generateError</tt>或<tt>generateName</tt> 。默认值为<tt>generateError</tt> 。</li>
	<li><tt>enableJavaNamingConventions</tt>可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。默认值为<tt>true</tt> 。</li>
	<li><tt>bindingStyle</tt>可以是<tt>elementBinding</tt>或<tt>modelGroupBinding</tt> 。默认值为<tt>elementBinding</tt> 。</li>
	<li><tt><javatype></javatype></tt>可以是零个或多个javaType绑定声明。有关更多信息，请参见<a href="#bnbbv">javaType绑定声明</a> 。</li>
</tt></ul><tt>
<p><tt><globalbindings></globalbindings></tt>声明仅在顶级<tt>模式</tt>元素的<tt>注释</tt>元素中有效。只能有一个实例<tt><globalbindings></globalbindings></tt>任何给定模式或绑定声明文件中的声明。如果一个源模式包括或导入另一个源模式，则<tt><globalbindings></globalbindings></tt>声明必须在第一个源模式中声明。</p>

<h3><a name="bnbbs"></a>模式绑定声明</h3>
<p>模式范围自定义声明为<tt><schemabindings></schemabindings></tt> 。模式范围自定义的语法为：</p>

<div class="codeblock"><pre>
&lt;schemaBindings&gt;
[ &lt;package&gt; package &lt;/package&gt; ]
[ &lt;nameXmlTransform&gt; ... &lt;/nameXmlTransform&gt; ]*
&lt;/schemaBindings&gt;
    
&lt;package 
    [ name = &quot;packageName&quot; ]
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/package&gt;

&lt;nameXmlTransform&gt;
[ &lt;typeName 
    [ suffix=&quot;suffix&quot; ]
    [ prefix=&quot;prefix&quot; ] /&gt; ]
[ &lt;elementName 
    [ suffix=&quot;suffix&quot; ]
    [ prefix=&quot;prefix&quot; ] /&gt; ]
[ &lt;modelGroupName 
    [ suffix=&quot;suffix&quot; ]
    [ prefix=&quot;prefix&quot; ] /&gt; ]
[ &lt;anonymousTypeName 
    [ suffix=&quot;suffix&quot; ]
    [ prefix=&quot;prefix&quot; ] /&gt; ]
&lt;/nameXmlTransform&gt;
</pre></div>

<p>如上图所示<tt><schemabinding></schemabinding></tt>声明包括两个子组件：</p>
<ul>
	<li><tt><package>...</package></tt>指定程序包的名称，以及（如果需要）指定架构派生类的API文档的位置。</li>
	<li><tt><namexmltransform>...</namexmltransform></tt>指定要应用的定制。</li>
</ul>

<h3><a name="bnbbt"></a>类绑定声明</h3>
<p>的<tt><class></class></tt>绑定声明使您可以自定义架构元素到Java内容接口或Java <tt>Element</tt>接口的绑定。 <tt><class></class></tt>声明可用于自定义：</p>
<ul>
<li>模式派生的Java接口的名称</li>
<li>模式派生的Java内容接口的实现类</li>
</ul>

<p>的语法<tt><class></class></tt>定制是：</p>

<div class="codeblock"><pre>
&lt;class 
    [ name = &quot;className&quot;]
    [ implClass= &quot;implClass&quot; ] &gt;
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/class&gt;
</pre></div>

<ul>
	<li><tt>name</tt>是派生的Java接口的名称。它必须是有效的Java接口名称，并且不能包含程序包前缀。包前缀是从包的当前值继承的。</li>
	<li><tt>implClass</tt>是<i>className</i>的实现类的名称，并且必须包含完整的程序包名称。</li>
	<li>的<tt><javadoc></javadoc></tt>元素为模式派生的Java接口指定Javadoc工具注释。在此输入的字符串必须使用<tt>CDATA</tt>或<tt><</tt>来转义嵌入的HTML标记。</li>
</ul>

<h3><a name="bnbbu"></a>属性绑定声明</h3>
<p>的<tt><property></property></tt>绑定声明使您可以自定义XML模式元素到Java表示形式的属性绑定。定制的范围可以在定义级别或组件级别，具体取决于<tt><property></property></tt>指定了绑定声明。</p>
<p>的语法<tt><property></property></tt>定制是：</p>

<div class="codeblock"><pre>
&lt;property
    [ name = &quot;propertyName&quot;]
    [ collectionType = &quot;propertyCollectionType&quot; ]
    [ fixedAttributeAsConstantProperty = &quot;true&quot; |
    &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ generateIsSetMethod = &quot;true&quot; | 
    &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ enableFailFastCheck =&quot;true&quot; | 
    &quot;false&quot; | &quot;1&quot; | &quot;0&quot; ]
    [ &lt;baseType&gt; ... &lt;/baseType&gt; ]
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/property&gt;

&lt;baseType&gt;
    &lt;javaType&gt; ... &lt;/javaType&gt;
&lt;/baseType&gt;
</pre></div>
<ul>
	<li><tt>name</tt>定义自定义值<tt>propertyName</tt> ；它必须是有效的Java标识符。</li>
	<li><tt>collectionType</tt>定义了定制值<tt>propertyCollectionType，</tt>这是属性<tt>，propertyCollectionType</tt>集合类型。如果指定该属性，则可以为该<tt>索引建立索引</tt> ，也可以为实现<tt>java.util的任何完全限定的类名<tt>。清单</tt> 。</tt></li><tt>
	<li><tt>fixedAttributeAsConstantProperty</tt>定义定制值<tt>fixedAttributeAsConstantProperty</tt> 。该值可以是<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。</li>
	<li><tt>generateIsSetMethod</tt>定义<tt>generateIsSetMethod</tt>的定制值。该值可以是<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。</li>
	<li><tt>enableFailFastCheck</tt>定义自定义值<tt>enableFailFastCheck</tt> 。该值可以是<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。请注意，JAXB实现不支持快速故障验证。</li>
	<li><tt><javadoc></javadoc></tt>为属性的getter方法自定义Javadoc工具注释。</li>
</tt></ul><tt>
<h3><a name="bnbbv"></a> javaType绑定声明</h3>

<p>的<tt><javatype></javatype></tt>声明提供了一种自定义XML数据类型与Java数据类型之间的转换的方法。XML提供的数据类型比Java多，因此<tt><javatype></javatype></tt>当默认的JAXB绑定不能充分表示您的模式时，可以使用声明来指定自定义数据类型绑定。</p>
<p>目标Java数据类型可以是Java内置数据类型，也可以是特定于应用程序的Java数据类型。如果将特定于应用程序的Java数据类型用作目标，则您的实现还必须提供解析和打印方法来解组和编组数据。为此，JAXB规范支持<tt>parseMethod</tt>和<tt>printMethod</tt> ：</p>
<ul>
<li>在解组期间调用<tt>parseMethod</tt>将输入文档中的字符串转换为目标Java数据类型的值。</li>
<li>在编组期间将调用<tt>printMethod</tt> ，以将目标类型的值转换为词汇表示形式。</li>
</ul>
<p>如果您希望定义自己的数据类型转换，则JAXB定义一个静态类<tt>DatatypeConverter</tt> ，以帮助解析和打印XML Schema内置数据类型的有效词法表示。</p>

<p>的语法<tt><javatype></javatype></tt>定制是：</p>
<div class="codeblock"><pre>
&lt;javaType name= &quot;<i>javaType</i>&quot;
    [ xmlType= &quot;<i>xmlType</i>&quot; ]
    [ hasNsContext = &quot;true&quot; | &quot;false&quot; ]
    [ parseMethod= &quot;<i>parseMethod</i>&quot; ]
    [ printMethod= &quot;<i>printMethod</i>&quot; ]&gt;
</pre></div>

<ul>
	<li><tt>name</tt>是<tt>xmlType</tt>绑定到的Java数据类型。</li>
	<li><tt>xmlType</tt>是<tt>javaType</tt>绑定到的XML Schema数据类型的名称；当<tt><javatype></javatype></tt>声明是<tt><globalbindings></globalbindings></tt> 。</li>
	<li><tt>hasNsContext</tt>允许将名称空间上下文指定为print或parse方法的第二个参数；可以为<tt>true</tt> ， <tt>false</tt> ， <tt>1</tt>或<tt>0</tt> 。默认情况下，此属性为<tt>false</tt> ，并且在大多数情况下，无需更改它。</li>
	<li><tt>parseMethod</tt>是在解组期间要调用的parse方法的名称。</li>
	<li><tt>printMethod</tt>是在编组期间要调用的打印方法的名称。</li>
</ul>
<p>的<tt><javatype></javatype></tt>声明可用于：</p>
<ul>
	<li>一种<tt><globalbindings></globalbindings></tt>宣言</li>
	<li>简单类型定义， <tt>GlobalBindings</tt>和的注释元素<tt><basetype></basetype></tt>声明书</li>
	<li>一种<tt><property></property></tt>宣言</li>
</ul>

<p>有关如何操作的示例，请参见<a href="#bnbch"><tt>MyDatatypeConverter</tt>类</a> 。 <tt><javatype></javatype></tt>声明和<tt>DatatypeConverterInterface</tt>接口在自定义数据类型转换器类中实现。</p>

<h3><a name="bnbbw"></a>类型安全枚举绑定声明</h3>
<p>类型安全枚举声明提供了一种将XML <tt>simpleType</tt>元素映射到Java <tt>类型安全枚举</tt>类的本地化方法。您可以进行两种类型的类型安全枚举声明：</p>
<ul>
<li><tt><typesafeenumclass></typesafeenumclass></tt>使您可以将整个<tt>simpleType</tt>类映射到<tt>类型安全的枚举</tt>类。</li>
<li><tt><typesafeenummember></typesafeenummember></tt>使您可以将<tt>simpleType</tt>类的选定成员映射到<tt>typesafe枚举</tt>类。</li>
</ul>

<p>在这两种情况下，这种类型的定制都有两个主要限制：</p>
<ul>
<li>使用此绑定声明只能自定义带有枚举构面的<tt>simpleType</tt>定义。</li>
<li>此定制一次仅适用于单个<tt>simpleType</tt>定义。要在全局级别映射相似的<tt>simpleType</tt>定义的集合，请在列表中使用<tt>typesafeEnumBase</tt>属性。 <tt><globalbindings></globalbindings></tt>声明，如《 <a href="#bnbbr">全球约束声明》中所述</a> 。</li>
</ul>

<p>的语法<tt><typesafeenumclass></typesafeenumclass></tt>定制是：</p>

<div class="codeblock"><pre>
&lt;typesafeEnumClass 
    [ name = &quot;enumClassName&quot; ]
    [ &lt;typesafeEnumMember&gt; ... &lt;/typesafeEnumMember&gt; ]*
    [ &lt;javadoc&gt; enumClassJavadoc &lt;/javadoc&gt; ]
&lt;/typesafeEnumClass&gt;
</pre></div>
<ul>
	<li><tt>名称</tt>必须是有效的Java标识符，并且不能具有包前缀。</li>
	<li>您可以有零个或多个<tt><typesafeenummember></typesafeenummember></tt>嵌入在<tt><typesafeenumclass></typesafeenumclass></tt>宣言。</li>
	<li><tt><javadoc></javadoc></tt>为枚举类定制Javadoc工具注释。</li>
</ul>

<p>的语法<tt><typesafeenummember></typesafeenummember></tt>定制是：</p>

<div class="codeblock"><pre>
&lt;typesafeEnumMember 
    name = &quot;enumMemberName&quot;&gt;
    [ value = &quot;enumMemberValue&quot; ]
    [ &lt;javadoc&gt; enumMemberJavadoc &lt;/javadoc&gt; ]
&lt;/typesafeEnumMember&gt;
</pre></div>
<ul>
	<li>必须始终指定<tt>名称，</tt>并且必须是有效的Java标识符。</li>
	<li><tt>值</tt>必须是在wece模式中指定的枚举值。</li>
	<li><tt><javadoc></javadoc></tt>自定义枚举常量的Javadoc工具注释。</li>
</ul>
<p>对于内联注释， <tt><typesafeenumclass></typesafeenumclass></tt>声明必须在的注释元素中指定<tt><simpletype></simpletype></tt>元件。的<tt><typesafeenummember></typesafeenummember></tt>必须在枚举成员的注释元素中指定。这使枚举成员可以独立于枚举类进行自定义。</p>

<p>有关类型安全的枚举设计模式的信息，请参见<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/page1-139488.html" target="_blank">Oracle技术网上Joshua Bloch的<i>有效Java编程</i></a>的<a class="OutsideLink" href="http://www.oracle.com/technetwork/java/page1-139488.html" target="_blank">示例章节。</a> 。</p>


<h3><a name="bnbbx"></a> javadoc绑定声明</h3>
<p>的<tt><javadoc></javadoc></tt>声明使您可以将自定义Javadoc工具注释添加到源自架构的JAXB包，类，接口，方法和字段。注意<tt><javadoc></javadoc></tt>声明不能全局应用；它们仅作为其他绑定自定义项的子元素有效。</p>

<p>的语法<tt><javadoc></javadoc></tt>定制是：</p>

<div class="codeblock"><pre>
&lt;javadoc&gt;
    Contents in &lt;b&gt;Javadoc&lt;\b&gt; format.
&lt;/javadoc&gt;
</pre></div>

<p>要么</p>
<div class="codeblock"><pre>
&lt;javadoc&gt;
    &lt;&lt;![CDATA[Contents in &lt;b&gt;Javadoc&lt;\b&gt; format ]]&gt;
&lt;/javadoc&gt;
</pre></div>
<p>请注意，文档中的字符串<tt><javadoc></javadoc></tt>在包级别应用的声明必须包含<tt></tt>打开和关闭标签；例如：</p>

<div class="codeblock"><pre>
&lt;jxb:package 
    name=&quot;primer.myPo&quot;&gt;
    &lt;jxb:javadoc&gt;
        &lt;![CDATA[&lt;body&gt;
            Package level documentation for generated package primer.myPo.
        &lt;/body&gt;]]&gt;
    &lt;/jxb:javadoc&gt;
&lt;/jxb:package&gt;
</pre></div>

<h3><a name="bnbby"></a>自定义命名空间前缀</h3>
<p>所有标准JAXB绑定声明必须在名称空间前缀之前，该名称空间前缀映射到JAXB名称空间URI <a class="OutsideLink" href="http://java.sun.com/xml/ns/jaxb" target="_blank">http://java.sun.com/xml/ns/jaxb</a> 。例如，在此示例中，使用了<tt>jxb:。</tt>为此，您要使用标准JAXB绑定声明自定义的任何模式都<b>必须</b>在模式文件的顶部包含JAXB名称空间声明和JAXB版本号。例如，在“自定义内联”示例的<tt>po.xsd</tt>中，名称空间声明如下：</p>

<div class="codeblock"><pre>
&lt;xsd:schema 
    xmlns:xsd= &quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:jxb= &quot;http://java.sun.com/xml/ns/jaxb&quot;
    jxb:version=&quot;1.0&quot;&gt;
</pre></div>

<p>具有<tt>jxb</tt>名称空间前缀的绑定声明采用以下形式：</p>
<div class="codeblock"><pre>
&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
    &lt;jxb:globalBindings 
        <i>binding declarations</i> /&gt;
    &lt;jxb:schemaBindings&gt;
        ...
        <i>binding declarations</i>         .
        ...
    &lt;/jxb:schemaBindings&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;
</pre></div>
<p>请注意，在此示例中， <tt>globalBindings</tt>和<tt>schemaBindings</tt>声明分别用于指定全局范围和模式范围的自定义。这些自定义范围在<a href="#bnbbo">Scope，Inheritance和Precedence</a>中有更详细的描述。</p>

<h4><a name="bnbbz"></a>自定义内联示例</h4>
<p>“定制内联”示例说明了通过对名为<tt>po.xsd</tt>的XML模式的内联注释进行的一些基本自定义。此外，此示例还实现了自定义数据类型转换器类<tt>MyDatatypeConverter.java</tt> ，该类说明了<tt><javatype></javatype></tt>用于处理自定义数据类型转换的自定义。</p>
<p>总结这个例子：</p>
<ol>
	<li><tt>po.xsd</tt>是包含内联绑定定制的XML模式。</li>
	<li><tt>MyDatatypeConverter.java</tt>是一个Java类文件，它实现了由指定的打印和解析方法<tt><javatype></javatype></tt> <tt>po.xsd中的</tt>定制。</li>
	<li><tt>Main.java</tt>是Customize Inline示例中的主要类文件，它使用JAXB编译器生成的架构派生的类。</li>
</ol>
<h3><a name="bnbcb"></a>使用Ant构建和运行定制内联示例</h3>
<p>要使用Ant编译并运行Customize Inline示例，请在终端窗口中，转到<i>jaxb-ri-install</i> <tt>/ samples / inline-customize /</tt>目录并键入以下内容：</p>
<div class="codeblock"><pre>
ant 
</pre></div>
<p><tt>下一节</tt>将更详细地描述此示例中的键自定义和自定义<tt>MyDatatypeConverter.java</tt>类。</p>

<h3><a name="bnbcc"></a>定制架构</h3>
<p>“定制内联”示例中使用的定制模式位于文件<i>jaxb-ri-install</i> <tt>/samples/inline-customize/po.xsd中</tt> 。自定义项位于<tt><xsd:annotation></xsd:annotation></tt>标签。</p>

<h3><a name="bnbcd"></a>全球约束力声明</h3>
<p>下面的代码示例示出了在该<tt>po.xsd中</tt>声明<tt>globalBindings：</tt></p>

<div class="codeblock"><pre>
&lt;jxb:globalBindings
    fixedAttributeAsConstantProperty=&quot;true&quot;
    collectionType=&quot;java.util.Vector&quot;
    typesafeEnumBase=&quot;xsd:NCName&quot;
    choiceContentProperty=&quot;false&quot;
    typesafeEnumMemberName=&quot;generateError&quot;
    bindingStyle=&quot;elementBinding&quot;
    enableFailFastCheck=&quot;false&quot;
    generateIsSetMethod=&quot;false&quot;
    underscoreBinding=&quot;asCharInWord&quot;/&gt;
</pre></div>
<p>在此示例中，除<tt>collectionType</tt>之外，所有值均设置为默认值。</p>
<ul>
	<li>将<tt>fixedAttributeAsConstantProperty</tt>设置为true表示所有固定属性都应绑定到Java常量。默认情况下，固定属性映射到简单属性或集合属性，以较合适的为准。</li>
	<li>将<tt>collectionType</tt>设置为<tt>java.util。Vector</tt>指定所生成的实现类中的所有列表在内部都表示为矢量。请注意，您为<tt>collectionType</tt>指定的类名称必须实现<tt>java.util。列出</tt>并可由<tt>newInstance</tt>调用。</li>
	<li>如果将<tt>typesafeEnumBase</tt>设置为<tt>xsd：string</tt> ，则这是一种全局方法，用于指定所有直接或间接从<tt>xsd：string</tt>派生且具有枚举构面的<tt>简单</tt>类型定义都必须默认绑定到<tt>typesafe enum</tt> 。如果将<tt>typesafeEnumBase</tt>设置为空字符串（ <tt>“”</tt> ），则默认情况下，没有<tt>简单的</tt>类型定义绑定到<tt>typesafe枚举</tt>类。<tt>typesafeEnumBase</tt>的值可以是除<tt>xsd：boolean</tt>和两个二进制类型之外的任何原子简单类型定义。
	</li>
	<li>JAXB实现不支持<tt>enableFailFastCheck</tt>属性。
	
<div class="note"><hr><strong>注意：</strong>使用类型安全的枚举类使您能够将架构枚举值映射到Java常量，这使得可以对Java常量而不是字符串值进行比较。
<hr></div>
</li>
</ul>

<h3><a name="bnbce"></a>模式绑定声明</h3>
<p>以下代码显示<tt>po.xsd</tt>中的模式绑定声明：</p>

<div class="codeblock"><pre>
&lt;jxb:schemaBindings&gt;
&lt;jxb:package name=&quot;primer.myPo&quot;&gt;
    &lt;jxb:javadoc&gt;
        &lt;![CDATA[&lt;body&gt;
            Package level documentation for generated package primer.myPo.
        &lt;/body&gt;]]&gt;
    &lt;/jxb:javadoc&gt;
&lt;/jxb:package&gt;
    &lt;jxb:nameXmlTransform&gt;
        &lt;jxb:elementName suffix=&quot;Element&quot;/&gt;
    &lt;/jxb:nameXmlTransform&gt;
&lt;/jxb:schemaBindings&gt;
</pre></div>
<ul>
	<li><tt><jxb:package name="primer.myPo"></jxb:package></tt>将<tt>prime.myPo</tt>指定为在其中生成架构派生类的包。</li>
	<li><tt><jxb:namexmltransform></jxb:namexmltransform></tt>指定默认情况下，所有生成的Java元素接口都将<tt>Element</tt>附加到生成的名称之后。例如，当针对该模式运行JAXB编译器时，将生成元素接口<tt>CommentElement</tt>和<tt>PurchaseOrderElement</tt> 。相反，如果没有此定制，则默认绑定将生成<tt>Comment</tt>和<tt>PurchaseOrder</tt> 。如果模式在不同的符号空间中使用相同的名称，则此定制很有用；例如，在全局元素和类型定义中。在这种情况下，通过这种自定义，您可以使用一个声明来解决冲突，而不必使用单独的绑定声明来单独解决每个冲突。</li>
	<li><tt><jxb:javadoc></jxb:javadoc></tt>为<tt>primer.myPo</tt>软件包指定定制的Javadoc工具注释。请注意，与<tt><javadoc></javadoc></tt>类级别的声明，如下面的示例所示，打开和关闭<tt></tt>当<tt><javadoc></javadoc></tt>声明是在包级别进行的。</li>
</ul>
<h3><a name="bnbcf"></a>类绑定声明</h3>
<p>以下代码显示<tt>po.xsd</tt>中的类绑定声明：</p>
<div class="codeblock"><pre>
&lt;xsd:complexType name=&quot;PurchaseOrderType&quot;&gt;
    &lt;xsd:annotation&gt;
        &lt;xsd:appinfo&gt;
            &lt;jxb:class name=&quot;POType&quot;&gt;
                &lt;jxb:javadoc&gt;
                    A &amp;lt;b&gt;Purchase Order&amp;lt;/b&gt;
                    consists of addresses and items.
                &lt;/jxb:javadoc&gt;
            &lt;/jxb:class&gt;
        &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;!-- ... --&gt;
&lt;/xsd:complexType&gt;
</pre></div>
<p>模式派生的<tt>POType</tt>类的Javadoc工具注释将包含描述<tt>“ <b>购买订单</ b>由地址和项目组成”。</tt> <tt><</tt>用于逃脱<tt><b></b></tt> HTML标记。</p>

<div class="note"><hr><strong>注意：</strong>当<tt><class></class></tt>定制是在<tt>complexType</tt>定义的<tt>appinfo</tt>元素中指定的，如前面的示例所示， <tt>complexType</tt>定义绑定到Java内容接口。
<hr></div>

<p>后来在<tt>po.xsd中</tt> ，另一个<tt><javadoc></javadoc></tt>定制是在此类级别声明的，但是这次HTML字符串使用<tt>CDATA进行了</tt>转义：</p>

<div class="codeblock"><pre>
&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
        &lt;jxb:class&gt;
            &lt;jxb:javadoc&gt;
                &lt;![CDATA[
                    First line of documentation for a
                    &lt;b&gt;USAddress&lt;/b&gt;.]]&gt;
            &lt;/jxb:javadoc&gt;
        &lt;/jxb:class&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;
</pre></div>

<div class="note"><hr><strong>注意：</strong>如果您想在<tt><jaxb:javadoc></jaxb:javadoc></tt>自定义，您必须将数据包含在<tt>CDATA</tt>节中，或使用<tt><来</tt>转义所有左尖括号。有关更多信息，请参见<a class="OutsideLink" href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-cdata-sect" target="_blank">XML 1.0 2nd Edition</a> 。
<hr></div>

<h3><a name="bnbcg"></a>属性绑定声明</h3>
<p>这里特别值得关注的是<tt>generateIsSetMethod</tt>定制，它导致<tt>生成</tt>两个附加的属性方法<tt>isSetQuantity</tt>和<tt>unsetQuantity</tt> 。这些方法使客户端应用程序可以区分架构默认值和在实例文档中显式出现的值。</p>

<p>例如，在<tt>po.xsd中</tt> ：</p>
<div class="codeblock"><pre>
&lt;xsd:complexType name=&quot;Items&quot;&gt;
    &lt;xsd:sequence&gt;
        &lt;xsd:element name=&quot;item&quot; 
            minOccurs=&quot;1&quot;  
            maxOccurs=&quot;unbounded&quot;&gt;
            &lt;xsd:complexType&gt;
                &lt;xsd:sequence&gt;
                    &lt;xsd:element 
                        name=&quot;productName&quot; 
                        type=&quot;xsd:string&quot;/&gt;
                    &lt;xsd:element 
                        name=&quot;quantity&quot; 
                        default=&quot;10&quot;&gt;
                        &lt;xsd:annotation&gt;
                            &lt;xsd:appinfo&gt;
                                &lt;jxb:property 
                                    generateIsSetMethod=&quot;true&quot;/&gt;
                            &lt;/xsd:appinfo&gt;
                        &lt;/xsd:annotation&gt;
                        &lt;!-- ... --&gt;
                    &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
</pre></div>
<p><tt>@generateIsSetMethod</tt>适用于<tt>数量</tt>元素，该元素绑定到<tt>Items中的属性<tt>。ItemType</tt>接口。在<tt>Items中生成<tt>unsetQuantity</tt>和<tt>isSetQuantity</tt>方法<tt>。ItemType</tt>接口。</tt></tt></p><tt><tt>

<h3><a name="bnbch"></a> <tt>MyDatatypeConverter</tt>类别</h3>
<p>下例显示的<i>jaxb-ri-install</i> <tt>/ samples / inline-customize / src / inlinecustomize / primer / MyDatatypeConverter类</tt>提供了一种使用以下命令自定义XML数据类型与Java数据类型之间的转换的方法。 <tt><javatype></javatype></tt>定制。
</p>

<div class="codeblock"><pre>
package primer;
import java.math.BigInteger;
import javax.xml.bind.DatatypeConverter;

public class MyDatatypeConverter {

    public static short parseIntegerToShort(String value) {
        BigInteger result = DatatypeConverter.parseInteger(value);
        return (short)(result.intValue());
    }

    public static String printShortToInteger(short value) {
        BigInteger result = BigInteger.valueOf(value);
        return DatatypeConverter.printInteger(result);
    }

    public static int parseIntegerToInt(String value) {
        BigInteger result = DatatypeConverter.parseInteger(value);
        return result.intValue();
    }

    public static String printIntToInteger(int value) {
        BigInteger result = BigInteger.valueOf(value);
        return DatatypeConverter.printInteger(result);
    }
};
</pre></div>
<p>以下代码显示了如何在<tt>MyDatatypeConverter</tt>类中引用<tt><javatype></javatype></tt> <tt>po.xsd中的</tt>声明：</p>

<div class="codeblock"><pre>
&lt;xsd:simpleType name=&quot;ZipCodeType&quot;&gt;
<b>&lt;xsd:annotation&gt;</b>
    <b>&lt;xsd:appinfo&gt;</b>
    <b>&lt;jxb:javaType name=&quot;int&quot;</b>
        <b>parseMethod=&quot;primer.MyDatatypeConverter.parseIntegerToInt&quot;</b>
        <b>printMethod=&quot;primer.MyDatatypeConverter.printIntTo Integer&quot; /&gt;</b>
    <b>&lt;/xsd:appinfo&gt;</b>
<b>&lt;/xsd:annotation&gt;</b>
    &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt;
    &lt;xsd:minInclusive value=&quot;10000&quot;/&gt;
    &lt;xsd:maxInclusive value=&quot;99999&quot;/&gt;
    &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</pre></div>
<p>在此示例中， <tt>jxb：javaType</tt>绑定声明覆盖了此类型到<tt>java.math的默认JAXB绑定<tt>。BigInteger</tt> 。就Customize Inline示例而言，对<tt>ZipCodeType</tt>的限制（具体来说，有效的美国邮政编码限制为五位数字）使得所有有效值都可以适合Java基本数据类型<tt>int</tt> 。另请注意，因为<tt><jxb:javatype name="int"></jxb:javatype></tt>在<tt>ZipCodeType</tt>中声明，该定制适用于所有引用此<tt>simpleType</tt>定义的JAXB属性，包括<tt>getZip</tt>和<tt>setZip</tt>方法。</tt></p><tt>

<h4><a name="bnbci"></a> DataType转换器示例</h4>
<p>DataType Converter示例类似于Customize Inline示例。与Customize Inline示例一样，通过使用XML模式中的<tt>po.xsd</tt>应用程序的内联绑定声明来进行Datatype Converter示例中的自定义。</p>

<p>Customize Inline和DataType Converter示例的全局，架构和包以及大多数类自定义是相同的。Datatype Converter示例与Customize Inline示例的不同之处在于用于将XML数据转换为Java <tt>int</tt>数据类型的<tt>parseMethod</tt>和<tt>printMethod</tt> 。</p>

<p>具体来说，数据类型转换器示例不使用自定义<tt>MyDataTypeConverter</tt>类中的方法来执行这些数据类型转换，而是使用<tt>javax.xml.bind提供的内置方法<tt>。数据类型转换器</tt> ：</tt></p><tt>

<div class="codeblock"><pre>
&lt;xsd:simpleType name=&quot;ZipCodeType&quot;&gt;
    &lt;xsd:annotation&gt;
        &lt;xsd:appinfo&gt;
            &lt;jxb:javaType 
                name=&quot;int&quot;
                parseMethod=&quot;javax.xml.bind.DatatypeConverter.parseInt&quot;
                printMethod=&quot;javax.xml.bind.DatatypeConverter.printInt&quot;/&gt;
        &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt;
        &lt;xsd:minInclusive value=&quot;10000&quot;/&gt;
        &lt;xsd:maxInclusive value=&quot;99999&quot;/&gt;
    &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</pre></div>
<h3><a name="bnbck"></a>使用Ant构建和运行数据类型转换器示例</h3>

<p>要使用Ant编译并运行DataType Converter示例，请在终端窗口中，转到<i>jaxb-ri-install</i> <tt>/ samples / datatypeconverter /</tt>目录并键入以下内容：</p>
<div class="codeblock"><pre>
ant
</pre></div>

<h4><a name="bnbcl"></a>绑定声明文件</h4>
<p>以下各节提供有关绑定声明文件的信息：</p>
<ul>
<li><a href="#bnbcm">JAXB版本，命名空间和架构属性</a>
</li>
<li><a href="#bnbcq">全局和模式绑定声明</a></li>
<li><a href="#bnbcr">类声明</a></li>
</ul>

<h3><a name="bnbcm"></a> JAXB版本，命名空间和架构属性</h3>
<p>所有JAXB绑定声明文件必须以以下内容开头：</p>
<ul>
	<li>JAXB版本号</li>
	<li>命名空间声明</li>
	<li>模式名称和节点</li>
</ul>
<p><tt>bindings.xjb</tt>中的版本，名称空间和架构声明如下：</p>
<div class="codeblock"><pre>
&lt;jxb:bindings 
    version=&quot;1.0&quot;
    xmlns:jxb=&quot;http://java.sun.com/xml/ns/jaxb&quot;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
    &lt;jxb:bindings 
        schemaLocation=&quot;po.xsd&quot; 
        node=&quot;/xs:schema&quot;&gt;
            &lt;!-- ...
            <i>binding-declarations</i> 
            ... --&gt;
    &lt;/jxb:bindings&gt;
    &lt;!-- 
    schemaLocation=&quot;po.xsd&quot; 
    node=&quot;/xs:schema&quot; --&gt;
&lt;/jxb:bindings&gt;
</pre></div>

<h3><a name="bnbcn"></a> JAXB版本号</h3>
<p>根元素为的XML文件<tt><jaxb:bindings></jaxb:bindings></tt>被视为外部绑定文件。根元素必须指定其绑定声明必须遵循的JAXB版本属性；特别是根<tt><jxb:bindings></jxb:bindings></tt>元素必须包含< <tt>jxb：version></tt>声明或<tt>版本</tt>属性。相反，当以内联方式进行绑定声明时，将JAXB版本号作为<tt><xsd:schema></xsd:schema></tt>宣言：</p>
<div class="codeblock"><pre>
&lt;xsd:schema 
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:jxb=&quot;http://java.sun.com/xml/ns/jaxb&quot;
    jxb:version=&quot;1.0&quot;&gt;
</pre></div>

<h3><a name="bnbco"></a>命名空间声明</h3>
<p>如<a href="#bnbcm">JAXB版本，名称空间和模式属性中所示</a> ，外部绑定声明文件中的名称空间声明包括JAXB名称空间和XMLSchema名称空间。注意，本示例中使用的前缀实际上可以是您想要的任何前缀；重要的是要始终使用在文件的后续声明中在此处定义的任何前缀。</p>

<h3><a name="bnbcp"></a>架构名称和架构节点</h3>
<p><a href="#bnbcm">JAXB版本，名称空间和模式属性</a>中的代码的第四行指定了此绑定声明文件所应用的模式的名称，以及自定义将首先生效的模式节点。此文件中的后续绑定声明可以引用架构中的特定节点，但是此第一个声明应将架构整体包含在内；例如，在<tt>bindings.xjb中</tt> ：</p>

<div class="codeblock"><pre>
&lt;jxb:bindings schemaLocation=&quot;po.xsd&quot; node=&quot;/xs:schema&quot;&gt;
</pre></div>

<h3><a name="bnbcq"></a>全局和模式绑定声明</h3>
<p><tt>bindings.xjb</tt>中的全局模式绑定声明与DataType Converter示例中的<tt>po.xsd</tt>中的声明相同。唯一的区别是，因为<tt>po.xsd</tt>中的声明是内联的，所以必须将它们嵌入<tt><xs:appinfo></xs:appinfo></tt>元素，这些元素又嵌入<tt><xs:annotation></xs:annotation></tt>元素。不需要在外部绑定文件中以这种方式嵌入声明。</p>

<div class="codeblock"><pre>
&lt;jxb:globalBindings
    fixedAttributeAsConstantProperty=&quot;true&quot;
    collectionType=&quot;java.util.Vector&quot;
    typesafeEnumBase=&quot;xs:NCName&quot;
    choiceContentProperty=&quot;false&quot;
    typesafeEnumMemberName=&quot;generateError&quot;
    bindingStyle=&quot;elementBinding&quot;
    enableFailFastCheck=&quot;false&quot;
    generateIsSetMethod=&quot;false&quot;
    underscoreBinding=&quot;asCharInWord&quot;/&gt;
    &lt;jxb:schemaBindings&gt;
        &lt;jxb:package name=&quot;primer.myPo&quot;&gt;
            &lt;jxb:javadoc&gt;
                &lt;![CDATA[&lt;body&gt;
                    Package level documentation for generated package
                    primer.myPo.&lt;/body&gt;]]&gt;
                &lt;/jxb:javadoc&gt;
        &lt;/jxb:package&gt;
        &lt;jxb:nameXmlTransform&gt;
            &lt;jxb:elementName suffix=&quot;Element&quot;/&gt;
        &lt;/jxb:nameXmlTransform&gt;
    &lt;/jxb:schemaBindings&gt;
</pre></div>
<p>相比之下， <tt>po.xsd中</tt>用于DataType Converter示例的语法为：</p>
<div class="codeblock"><pre>
&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
        &lt;jxb:globalBindings
            ...
            <i>binding-declarations</i>
            ...
        &lt;jxb:schemaBindings&gt;
            ...
            <i>binding-declarations</i>
            ...
        &lt;/jxb:schemaBindings&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;
</pre></div>

<h3><a name="bnbcr"></a>类声明</h3>

<p><tt>bindings.xjb中</tt>的类级绑定声明与<tt>potypes</tt>示例中<tt>po.xsd中</tt>类似的声明有两种不同：</p>
<ul>
<li>与<tt>bindings.xjb中的</tt>所有其他绑定声明一样，您无需在架构中嵌入自定义项<tt><xsd:appinfo></xsd:appinfo></tt>元素。</li>
<li>您必须指定应用定制的模式节点。这种声明的一般语法为：<div class="codeblock"><pre>
&lt;jxb:bindings node=&quot;//<i>node-type</i>[@name=&rsquo;<i>node-name</i>&rsquo;]&quot;&gt;
</pre></div>
</li>
</ul>
<p>例如，以下代码显示了名为<tt>USAddress</tt>的<tt>complexType的</tt>绑定声明。</p>

<div class="codeblock"><pre>
&lt;jxb:bindings node=&quot;//xs:complexType [@name=&rsquo;USAddress&rsquo;]&quot;&gt;
    &lt;jxb:class&gt;
        &lt;jxb:javadoc&gt;
            &lt;![CDATA[
                First line of documentation for a &lt;b&gt;USAddress&lt;/b&gt;.
            ]]&gt;
        &lt;/jxb:javadoc&gt;
    &lt;/jxb:class&gt;

&lt;jxb:bindings node=&quot;.//xs:element [@name=&rsquo;name&rsquo;]&quot;&gt;
    &lt;jxb:property name=&quot;toName&quot;/&gt;
&lt;/jxb:bindings&gt;

&lt;jxb:bindings node=&quot;.//xs:element [@name=&rsquo;zip&rsquo;]&quot;&gt;
    &lt;jxb:property name=&quot;zipCode&quot;/&gt;
&lt;/jxb:bindings&gt;
&lt;/jxb:bindings&gt;
&lt;!-- 
    node=&quot;//xs:complexType
    [@name=&rsquo;USAddress&rsquo;]&quot; --&gt;
</pre></div>
<p>请注意，在此示例中， <tt>USAddress</tt>是子元素<tt>name</tt>和<tt>zip</tt>的父元素，因此<tt></tt>标记将子元素的<tt>绑定</tt>声明和类级别的<tt>javadoc</tt>声明<tt>括起来</tt> 。</p>

<h4><a name="bnbcs"></a>外部自定义示例</h4>
<p>“外部定制”示例与“数据类型转换器”示例相同，不同之处在于，“外部定制”示例中的绑定声明是通过使用外部绑定声明文件而不是在源XML架构中内联进行的。</p>
<p>“外部定制”示例中使用的绑定定制文件是<i>jaxb-ri-install</i> <tt>/samples/external-customize/binding.xjb</tt> 。</p> 
<p>本部分将<tt>bindings.xjb中</tt>的自定义声明与<tt>XMLType中</tt>的类似声明<tt>po.xsd</tt> （在DataType Converter示例中）进行了比较。两组声明实现了完全相同的结果。</p>
<h3><a name="bnbcu"></a>使用Ant构建和运行外部定制示例</h3>
<p>要使用Ant编译并运行“外部定制”示例，请在终端窗口中，转到<i>jaxb-ri-install</i> <tt>/ samples / external-customize /</tt>目录并键入以下内容：</p>
<div class="codeblock"><pre>
ant
</pre></div>

        </tt></tt></tt></tt></tt></tt></div><tt><tt>
        <div class="NavBit">
            <a href="basic.html" target="_top">«上一个</a> • <a href="../TOC.html" target="_top">追踪</a> • <a href="j2schema.html" target="_top">下一个»</a>
        </div>
    </tt></tt></div><tt><tt>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">版权所有©1995、2017 Oracle和/或其分支机构。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>基本示例<br><b>下一页：</b> Java到模式的示例</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 

 
</tt></tt></body></html>