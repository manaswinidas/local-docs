<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <meta name="description" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <title>垃圾优先垃圾收集器优化</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="garbage-first-garbage-collector.html" title="Previous" type="text/html">
      <link rel="next" href="z-garbage-collector1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="garbage-first-garbage-collector.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="z-garbage-collector1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot虚拟机垃圾收集优化指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">垃圾优先垃圾收集器优化</li>
            </ol>
            <a id="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" name="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A"></a>
            
            <h2 id="JSGCT-GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" class="sect2"><span class="enumeration_chapter">10</span>垃圾优先垃圾收集器优化</h2>
         </header>
         <div class="ind">
            <div>
               <p>本节介绍了如何在不满足您的要求的情况下调整垃圾优先垃圾收集器（G1 GC）的行为。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A__GUID-85B75A91-240B-4DDC-BB87-BEA49959B39F">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6">G1的一般建议</a></li>
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-E26056D1-02A5-4367-94EF-72C66D314AF7">从其他收藏家移至G1</a></li>
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" title="本节介绍了默认值以及本主题中介绍的有关命令行选项的一些其他信息。">改善G1表现</a><ul style="list-style-type:disc">
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC">观察完整的垃圾收集</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-2428DA90-B93D-48E6-B336-A849ADF1C552">巨大的物体碎片</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-4914A8D4-DE41-4250-B68E-816B58D4E278">调整延迟</a><ul style="list-style-type:disc">
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658">异常的系统或实时使用</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74">参考对象处理时间过长</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C">“仅年轻”阶段中的“仅年轻”收藏集时间过长</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469">混合馆藏时间过长</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F">高更新RS和扫描RS时间</a></li>
                              </ul>
                           </li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9">吞吐量调整</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0770AB01-E334-4E23-B307-FD2114B16E0E">调整堆大小</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" title="本节介绍了默认值以及本主题中介绍的有关命令行选项的一些其他信息。">可调默认值</a></li>
                        </ul>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" name="GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6"></a><h3 id="JSGCT-GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" class="sect3">G1的一般建议</h3>
               <div>
                  <p>通常的建议是使用G1的默认设置，最终给它一个不同的暂停时间目标，并通过使用设置最大Java堆大小<code class="codeph">-Xmx</code>如果需要的话。
                  </p>
                  <p>G1默认值与其他任何一个收集器的平衡方式都不一样。G1在默认配置中的目标既不是最大吞吐量也不是最低延迟，而是在高吞吐量下提供相对较小且均匀的暂停。但是，G1的增量回收堆空间和暂停时间控制的机制在应用程序线程和空间回收效率方面都产生了一些开销。</p>
                  <p>如果您喜欢高吞吐量，请使用以下方法放宽暂停时间目标<code class="codeph">-XX:MaxGCPauseMillis</code>或提供更大的堆。如果延迟是主要要求，则修改暂停时间目标。通过使用类似的选项，避免将年轻代的大小限制为特定值<code class="codeph">-Xmn</code> ， <code class="codeph">-XX:NewRatio</code>其他原因是，年轻一代的大小是让G1满足暂停时间的主要手段。将年轻代大小设置为单个值将覆盖并实际上禁用暂停时间控制。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" name="GUID-E26056D1-02A5-4367-94EF-72C66D314AF7"></a><h3 id="JSGCT-GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" class="sect3">从其他收藏家移至G1</h3>
               <div>
                  <p>通常，从其他收集器（尤其是并发标记扫描收集器）移至G1时，首先要删除所有影响垃圾收集的选项，而仅使用以下方法设置暂停时间目标和总堆大小<code class="codeph">-Xmx</code>以及可选<code class="codeph">-Xms</code> 。
                  </p>
                  <p>对于其他收集器以某种特定方式响应很有用的许多选项，或者根本没有效果，甚至会降低吞吐量和达到暂停时间目标的可能性。例如，设置年轻代大小可以完全阻止G1调整年轻代大小以满足暂停时间目标。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" name="GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4"></a><h3 id="JSGCT-GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" class="sect3">改善G1表现</h3>
               <div>
                  <p>G1旨在提供良好的整体性能，而无需指定其他选项。但是，在某些情况下，默认的试探法或它们的默认配置会提供次优的结果。本节提供了有关这些情况下的诊断和改进的一些准则。本指南仅描述在给定应用程序的情况下，G1提供的可能性，以提高所选指标中的垃圾收集器性能。在逐个案例的基础上，应用程序级优化可能比尝试调整VM更好地发挥作用更有效，例如，通过避免寿命更长的对象完全避免出现问题的情况。</p>
                  <p>出于诊断目的，G1提供了全面的日志记录。一个好的开始是使用<code class="codeph">-Xlog:gc*=debug</code>选项，然后根据需要优化输出。该日志在有关垃圾回收活动的暂停期间和暂停期间提供了详细的概述。这包括收集的类型以及在暂停的特定阶段花费的时间的细分。
                  </p>
                  <p>以下小节探讨了一些常见的性能问题。</p>
               </div>
               <div class="sect3"><a id="GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" name="GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC"></a><h4 id="JSGCT-GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" class="sect4">观察完整的垃圾收集</h4>
                  <div>
                     <p>完整堆垃圾收集（完整GC）通常非常耗时。通过在日志中找到“ <span class="italic">暂停已满（分配失败）</span> ”一词，可以检测到旧一代中堆占用率过高导致的完整GC。完整的GC通常在垃圾收集之前遇到垃圾回收，它们指示为<code class="codeph">to-space exhausted</code>标签。
                     </p>
                     <p>发生完全GC的原因是因为应用程序分配了太多无法快速回收的对象。通常，并发标记无法及时完成以开始空间回收阶段。分配大量巨型对象可能会增加进入完全GC的可能性。由于在G1中分配这些对象的方式，它们可能会占用比预期更多的内存。</p>
                     <p>目标应该是确保并发标记按时完成。这可以通过降低旧版本中的分配率或给并发标记更多的时间来完成。</p>
                     <p>G1为您提供了几种更好地处理这种情况的选项：</p>
                     <ul style="list-style-type:disc">
                        <li>您可以使用以下命令确定Java堆上巨大对象占用的区域数<code class="codeph">gc+heap=info</code>记录。 <code class="codeph">Y</code>在行中<code class="codeph">Humongous regions: X->Y</code>为您提供巨大物体占据的区域数量。如果此数目比旧区域的数目高，则最佳选择是尝试减少此对象的数目。您可以通过使用<code class="codeph">-XX:G1HeapRegionSize</code>选项。当前选择的堆区域大小将打印在日志的开头。
                        </li>
                        <li>增加Java堆的大小。这通常会增加标记必须完成的时间。</li>
                        <li>通过设置增加并发标记线程的数量<code class="codeph">-XX:ConcGCThreads</code>明确地。
                        </li>
                        <li>强制G1更早开始标记。G1会根据较早的应用程序行为自动确定初始堆占用百分比（IHOP）阈值。如果应用程序行为发生变化，则这些预测可能是错误的。有两种选择：通过修改来增加自适应IHOP计算中使用的缓冲区，降低何时开始空间回收的目标占用率。 <code class="codeph">-XX:G1ReservePercent</code> ;或者，通过使用手动设置来禁用IHOP的自适应计算<code class="codeph">-XX:-G1UseAdaptiveIHOP</code>和<code class="codeph">-XX:InitiatingHeapOccupancyPercent</code> 。
                        </li>
                     </ul>
                     <p>完整GC的分配失败以外的其他原因通常表明应用程序或某些外部工具导致了完整堆收集。如果原因是<code class="codeph">System.gc()</code> ，并且无法修改应用程序源，可以通过使用来减轻Full GC的影响<code class="codeph">-XX:+ExplicitGCInvokesConcurrent</code>或通过设置让虚拟机完全忽略它们<code class="codeph">-XX:+DisableExplicitGC</code> 。外部工具可能仍会强制使用Full GC。只能通过不要求将它们删除。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" name="GUID-2428DA90-B93D-48E6-B336-A849ADF1C552"></a><h4 id="JSGCT-GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" class="sect4">巨大的物体碎片</h4>
                  <div>
                     <p>由于有必要为它们找到一组连续的区域，因此在耗尽所有Java堆内存之前可能会发生Full GC。在这种情况下，潜在的选项是通过使用选项来增加堆区域的大小<code class="codeph">-XX:G1HeapRegionSize</code>减少庞大的对象数或增加堆的大小。在极端情况下，即使可用内存另有指示，G1可能没有足够的连续空间来分配对象。如果Full GC无法回收足够的连续空间，这将导致VM退出。结果，除了如上所述减少庞大的对象分配数量或增加堆之外，没有其他选择。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4914A8D4-DE41-4250-B68E-816B58D4E278" name="GUID-4914A8D4-DE41-4250-B68E-816B58D4E278"></a><h4 id="JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278" class="sect4">调整延迟</h4>
                  <div>
                     <p>本节讨论在常见延迟问题（即，暂停时间过长）的情况下改善G1行为的提示。</p>
                  </div>
                  <div class="sect4"><a id="GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" name="GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658"></a><h5 id="JSGCT-GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" class="sect5">异常的系统或实时使用</h5>
                     <div>
                        <p>对于每个垃圾收集暂停， <code class="codeph">gc+cpu=info</code>日志输出包含一行，其中包含来自操作系统的信息，以及有关在暂停时间内花费的时间的细分。这样的输出的一个例子是<code class="codeph">User=0.19s Sys=0.00s Real=0.01s</code> 。
                        </p>
                        <p>用户时间是在VM代码中花费的时间， <span class="variable" translate="no">system time</span>是在操作系统中花费的时间， <span class="variable" translate="no">real time</span>是暂停期间经过的绝对时间。如果系统时间相对较长，则通常是环境造成的。
                        </p>
                        <p>高系统时间的常见已知问题是：</p>
                        <ul style="list-style-type:disc">
                           <li>VM从操作系统内存分配或释放内存可能会导致不必要的延迟。通过使用选项将最小和最大堆大小设置为相同的值来避免延迟<code class="codeph">-Xms</code>和<code class="codeph">-Xmx</code> ，并使用<code class="codeph">-XX:+AlwaysPreTouch</code>将此工作移至VM启动阶段。
                           </li>
                           <li>尤其是在Linux中，通过<span class="italic">透明大页面（THP）</span>功能将小页面合并为大页面趋向于使随机进程停滞不前，而不仅仅是在暂停期间。由于VM分配并维护大量内存，因此VM长时间停滞的进程的风险要比平常高。有关如何禁用“透明大页面”功能的信息，请参阅操作系统的文档。
                           </li>
                           <li>由于某些后台任务间歇性地占用了写入日志的硬盘的所有I / O带宽，因此写入日志输出可能会停顿一段时间。考虑将单独的磁盘用于日志或其他一些存储，例如内存支持的文件系统，以避免这种情况。</li>
                        </ul>
                        <p>需要注意的另一种情况是，实时情况比其他情况的总和要大得多，这可能表明VM在可能超负荷的计算机上没有获得足够的CPU时间。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" name="GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74"></a><h5 id="JSGCT-GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" class="sect5">参考对象处理时间过长</h5>
                     <div>
                        <p>有关处理参考对象的时间的信息显示在<code class="codeph">Reference Processing</code>相。在此期间<code class="codeph">Reference Processing</code>在此阶段，G1根据特定类型的参考对象的要求更新参考对象的参考对象。默认情况下，G1尝试并行化以下子阶段<code class="codeph">Reference Processing</code>使用以下启发式方法： <code class="codeph">-XX:ReferencesPerThread</code> reference对象启动一个线程，该线程受in中的值限制<code class="codeph">-XX:ParallelGCThreads</code> 。可以通过设置禁用此启发式<code class="codeph">-XX:ReferencesPerThread</code>设置为0以默认使用所有可用线程，或者由完全禁用并行化<code class="codeph">-XX:-ParallelRefProcEnabled</code> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" name="GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C"></a><h5 id="JSGCT-GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" class="sect5">“仅年轻”阶段中的“仅年轻”收藏集时间过长</h5>
                     <div>
                        <p>正常的年轻对象，以及一般来说，任何年轻集合的时间大约与年轻一代的大小成正比，或更确切地说，与集合集中需要复制的活动对象的数量成正比。如果“ <span class="italic">撤离集合集”</span>阶段花费的时间过长，尤其是“ <span class="italic">对象复制”</span>子阶段，则减少<code class="codeph">-XX:G1NewSizePercent</code> 。这减小了年轻一代的最小大小，从而允许可能更短的停顿。
                        </p>
                        <p>如果应用程序的性能，尤其是幸存的对象数量突然变化，则可能会出现年轻一代的另一个问题。这可能会导致垃圾收集暂停时间激增。通过使用减小最大的年轻代大小可能很有用<code class="codeph">-XX:G1MaxNewSizePercent</code> 。这限制了年轻代的最大大小，因此限制了暂停期间需要处理的对象数量。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" name="GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469"></a><h5 id="JSGCT-GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" class="sect5">混合馆藏时间过长</h5>
                     <div>
                        <p>混合馆藏用于回收旧时代的空间。混合集合的集合集包含年轻人和老年人区。您可以通过启用以下选项来获取有关年轻人或较老一代地区疏散多少时间对暂停时间的信息： <code class="codeph">gc+ergo+cset=trace</code>日志输出。分别查看年轻和老一代区域的<span class="italic">预计年轻区域</span>时间和<span class="italic">预计老区域</span>时间。
                        </p>
                        <p>如果预测的年轻区域时间太长，请参阅<a href="garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C">“仅年轻阶段”内的“仅年轻集合”，“太长”</a>以获得更多选择。否则，为了减少旧区域对暂停时间的影响，G1提供了三个选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过增加旧的区域回收在更多垃圾收集中的分布<code class="codeph">-XX:G1MixedGCCountTarget</code> 。
                              </p>
                           </li>
                           <li>
                              <p>通过不使用-将它们放到候选收集集中，避免收集花费相应时间的区域。 <code class="codeph">XX:G1MixedGCLiveThresholdPercent</code> 。在许多情况下，人满为患的地区需要花费很多时间才能收集。
                              </p>
                           </li>
                           <li>
                              <p>尽早停止旧的空间回收，以使G1不会收集那么多高度占领的区域。在这种情况下，增加<code class="codeph">-XX:G1HeapWastePercent</code> 。
                              </p>
                           </li>
                        </ul>
                        <p>请注意，最后两个选项减少了可以在当前空间回收阶段回收空间的收集集候选区域的数量。这可能意味着G1可能无法回收旧一代中足够的空间来持续运行。但是，以后的空间回收阶段可能能够对它们进行垃圾收集。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" name="GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F"></a><h5 id="JSGCT-GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" class="sect5">高更新RS和扫描RS时间</h5>
                     <div>
                        <p>为了使G1能够撤离单个旧区域，G1跟踪<span class="italic">跨区域引用的</span>位置，即从一个区域指向另一个<span class="italic">区域的引用</span> 。指向给定区域的跨区域引用<span class="italic">集</span>称为该区域的<span class="italic">记忆集</span> 。移动区域的内容时，必须更新记忆的集。区域记忆集的维护大部分是并发的。为了提高性能，当应用程序在两个对象之间安装新的跨区域引用时，G1不会立即更新记忆的区域集。记住的集合更新请求将被延迟并进行批量处理以提高效率。
                        </p>
                        <p>G1需要完整的记住集用于垃圾回收，因此垃圾回收的<span class="italic">Update RS</span>阶段将处理所有未完成的记住集更新请求。<span class="italic">扫描RS</span>阶段在记忆集中搜索对象引用，移动区域内容，然后将这些对象引用更新到新位置。根据应用程序，这两个阶段可能会花费大量时间。
                        </p>
                        <p>使用选项调整堆区域的大小<code class="codeph">-XX:G1HeapRegionSize</code>影响跨区域引用的数量以及记忆集合的大小。处理记住的区域集可能是垃圾收集工作的重要组成部分，因此这对可达到的最大暂停时间有直接影响。较大的区域往往具有较少的跨区域引用，因此处理它们所花费的相对工作量会减少，尽管与此同时，较大的区域可能意味着每个区域有更多的活体撤离，这增加了其他阶段的时间。
                        </p>
                        <p>G1尝试安排对记住的集合更新的并发处理，以便Update RS阶段大约需要<code class="codeph">-XX:G1RSetUpdatingPauseTimePercent</code>最大允许暂停时间的百分比。通过减小该值，G1通常可以同时执行更多记住的集更新工作。
                        </p>
                        <p>虚假的高更新RS时间与应用程序分配大对象的组合可能是由优化引起的，该优化尝试通过批量处理来减少并发记住的集更新工作。如果创建此类批处理的应用程序刚好在垃圾回收之前发生，则垃圾回收必须在暂停的“更新RS时间”部分处理所有这些工作。使用<code class="codeph">-XX:-ReduceInitialCardMarks</code>禁用此行为并可能避免这些情况。
                        </p>
                        <p>扫描RS时间也由G1执行的压缩量来确定，以保持较低的记忆存储容量。记住的集合在内存中存储的越紧凑，则在垃圾回收期间检索存储的值所花费的时间就越长。G1自动执行此压缩，称为记忆集粗化，同时根据该区域记忆集的当前大小更新记忆集。尤其是在最高压缩级别下，检索实际数据可能会非常缓慢。选项<code class="codeph">-XX:G1SummarizeRSetStatsPeriod</code>与...结合<code class="codeph">gc+remset=trace</code>级别日志记录显示是否发生这种粗化。如果是这样，那么<code class="codeph">X</code>在行中<code class="codeph">Did <X> coarsenings</code> “ <span class="italic">GC之前摘要”</span>部分中的值较高。的<code class="codeph">-XX:G1RSetRegionEntries</code>可以显着增加选择权以减少这些粗化的数量。避免在生产环境中使用这种记住的详细记录集，因为收集此数据可能会花费大量时间。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" name="GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9"></a><h4 id="JSGCT-GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" class="sect4">吞吐量调整</h4>
                  <div>
                     <p>G1的默认策略试图在吞吐量和延迟之间保持平衡。但是，在某些情况下需要更高的吞吐量。除了减少前面部分所述的总体暂停时间之外，还可以减少暂停的频率。主要思想是通过使用以下命令增加最大暂停时间<code class="codeph">-XX:MaxGCPauseMillis</code> 。世代大小启发法将自动适应年轻世代的大小，这直接决定了停顿的频率。如果那没有导致预期的行为，尤其是在空间垦殖阶段，则使用<code class="codeph">-XX:G1NewSizePercent</code>将迫使G1这样做。
                     </p>
                     <p>在某些情况下， <code class="codeph">-XX:G1MaxNewSizePercent</code>最大允许的年轻代大小可能会通过限制年轻代大小来限制吞吐量。可以通过查看的区域摘要输出来诊断<code class="codeph">gc+heap=info</code>记录。在这种情况下，伊甸园地区和幸存者地区的总百分比接近<code class="codeph">-XX:G1MaxNewSizePercent</code>占地区总数的百分比。考虑增加<code class="codeph">-XX:G1MaxNewSizePercent</code>在这种情况下。
                     </p>
                     <p>增加吞吐量的另一种方法是尝试减少并发工作量，尤其是并发记住的集更新通常需要大量的CPU资源。越来越多<code class="codeph">-XX:G1RSetUpdatingPauseTimePercent</code>将工作从并发操作移至垃圾回收暂停。在最坏的情况下，可以通过设置禁用并发记忆集更新<code class="codeph">-XX:-G1UseAdaptiveConcRefinement</code><code class="codeph">-XX:G1ConcRefinementGreenZone=</code><code class="codeph">2G</code><code class="codeph">-XX:G1ConcRefinementThreads=</code><code class="codeph">0</code> 。这通常会禁用此机制，并将所有记住的集合更新工作移至下一个垃圾回收暂停。
                     </p>
                     <p>通过使用启用大页面<code class="codeph">-XX:+UseLargePages</code>也可以提高吞吐量。有关如何设置大页面，请参阅您的操作系统文档。
                     </p>
                     <p>您可以通过禁用它来最大程度地减少堆大小调整工作。设置选项<code class="codeph">-Xms</code>和<code class="codeph">-Xmx</code>值相同另外，您可以使用<code class="codeph">-XX:+AlwaysPreTouch</code>将操作系统工作移至具有物理内存的虚拟内存到VM启动时间。为了使停顿时间更一致，这两种措施都是特别理想的。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" name="GUID-0770AB01-E334-4E23-B307-FD2114B16E0E"></a><h4 id="JSGCT-GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" class="sect4">调整堆大小</h4>
                  <div>
                     <p>与其他收集器一样，G1的目的是调整堆的大小，以便使垃圾收集所花费的时间低于由垃圾收集器确定的比率。 <code class="codeph">-XX:GCTimeRatio</code>选项。调整此选项以使G1满足您的要求。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" name="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89"></a><h4 id="JSGCT-GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" class="sect4">可调默认值</h4>
                  <div>
                     <p>本节介绍了默认值以及本主题中介绍的有关命令行选项的一些其他信息。</p>
                     <div class="section">
                        <div class="tblformal" id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89__ERGONOMICDEFAULTSFORDETERMINISTICG1-9C74ED9D">
                           <p class="titleintable">表10-1可调默认值G1 GC</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="可调默认值G1 GC" width="100%" border="1" summary="Tunable defaults for G1 GC" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="46%" id="d5396e627">选项和默认值</th>
                                    <th align="left" valign="bottom" width="54%" id="d5396e630">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e635" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+G1UseAdaptiveConcRefinement</code></p>
                                       <p><code class="codeph">-XX:G1ConcRefinementGreenZone=</code><span class="italic"><ergo></ergo></span> 
                                       </p>
                                       <p><code class="codeph">-XX:G1ConcRefinementYellowZone=</code><span class="italic"><ergo></ergo></span></p>
                                       <p> <code class="codeph">-XX:G1ConcRefinementRedZone=</code><span class="italic"><ergo></ergo></span></p>
                                       <p> <code class="codeph">-XX:G1ConcRefinementThreads=</code><span class="italic"><ergo></ergo></span></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e635 d5396e630 ">
                                       <p>并发记忆集更新（优化）使用这些选项来控制并发优化线程的工作分配。G1为这些选项选择人体工程学值，以便<code class="codeph">-XX:G1RSetUpdatingPauseTimePercent</code>在垃圾收集暂停中花费时间来处理任何剩余的工作，并根据需要进行自适应调整。请谨慎更改，因为这可能会导致暂停时间过长。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e669" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+ReduceInitialCardMarks</code></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e669 d5396e630 ">
                                       <p>这会将初始对象分配的并发记忆集更新（优化）工作分批处理。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e677" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+ParallelRefProcEnabled</code></p>
                                       <p><code class="codeph">-XX:ReferencesPerThread=1000</code></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e677 d5396e630 ">
                                       <p><code class="codeph">-XX:ReferencesPerThread</code>确定并行化的程度：对于每<span class="italic">N个</span>参考对象，一个线程将参与参考处理的子阶段，受限于<code class="codeph">-XX:ParallelGCThreads</code> 。值为0表示由的值指示的最大线程数<code class="codeph">-XX:ParallelGCThreads</code>将始终使用。
                                       </p>
                                       <p>这确定是否处理<span class="apiname">java.lang。Ref。*</span>实例应由多个线程并行完成。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e704" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:G1RSetUpdatingPauseTimePercent=</code><code class="codeph">10</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e704 d5396e630 ">
                                       <p>这确定了在更新RS阶段更新所有剩余的已记住集时应花费的总垃圾回收时间G1的百分比。G1使用此设置控制并发记忆集更新的数量。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e715" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:G1SummarizeRSetStatsPeriod=</code><code class="codeph">0</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e715 d5396e630 ">
                                       <p>这是G1生成记住的集合摘要报告的多个GC中的时间段。将此设置为零可禁用。生成记住的集合摘要报告是一项昂贵的操作，因此仅在必要时才使用它，并且它应具有较高的价值。使用<code class="codeph">gc+remset=trace</code>打印任何东西。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e729" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:GCTimeRatio=</code><code class="codeph">12</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e729 d5396e630 ">
                                       <p>这是目标时间比例的除数，该目标时间比例是垃圾回收而不是应用程序所花费的时间。确定增加堆之前可以在垃圾回收中花费的目标时间比例的实际公式是<code class="codeph">1 / (1 + GCTimeRatio)</code> 。此默认值导致目标大约有8％的时间用于垃圾回收。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnote" id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89__GUID-158B2AD4-B43D-4956-A474-67EAD0594471">
                           <p class="notep1">注意：</p><code class="codeph"><ergo></code>表示实际值是根据环境根据人体工程学确定的。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>