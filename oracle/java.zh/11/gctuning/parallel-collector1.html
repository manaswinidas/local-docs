<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The parallel collector (also referred to here as the throughput collector) is a generational collector similar to the serial collector. The primary difference between the serial and parallel collectors is that the parallel collector has multiple threads that are used to speed up garbage collection.">
      <meta name="description" content="The parallel collector (also referred to here as the throughput collector) is a generational collector similar to the serial collector. The primary difference between the serial and parallel collectors is that the parallel collector has multiple threads that are used to speed up garbage collection.">
      <title>并行收集器</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content="The parallel collector (also referred to here as the throughput collector) is a generational collector similar to the serial collector. The primary difference between the serial and parallel collectors is that the parallel collector has multiple threads that are used to speed up garbage collection.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="available-collectors.html" title="Previous" type="text/html">
      <link rel="next" href="mostly-concurrent-collectors.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="available-collectors.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="mostly-concurrent-collectors.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot虚拟机垃圾收集优化指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">并行收集器</li>
            </ol>
            <a id="GUID-DCDD6E46-0406-41D1-AB49-FB96A50EB9CE" name="GUID-DCDD6E46-0406-41D1-AB49-FB96A50EB9CE"></a>
            
            <h2 id="JSGCT-GUID-DCDD6E46-0406-41D1-AB49-FB96A50EB9CE" class="sect2"><span class="enumeration_chapter">6</span>并行收集器</h2>
         </header>
         <div class="ind">
            <div>
               <p>并行收集器（在此也称为<span class="italic">吞吐量收集器</span> ）是类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器具有多个线程，这些线程用于加速垃圾收集。
               </p>
               <p>并行收集器通过命令行选项启用<code class="codeph">-XX:+UseParallelGC</code> 。默认情况下，使用此选项，次要收集和主要收集都可以并行运行，以进一步减少垃圾收集的开销。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-DCDD6E46-0406-41D1-AB49-FB96A50EB9CE__GUID-F0A64679-FB43-4A92-AB07-4215F2D1487F">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="parallel-collector1.html#GUID-5A7866BE-59DF-44AD-B51A-274DE3F2BF59" title="在具有<N>个硬件线程（其中<N>大于8）的机器上，并行收集器使用<N>的固定分数作为垃圾收集器线程的数量。">并行收集器垃圾收集器线程数</a></li>
                     <li><a href="parallel-collector1.html#GUID-D004A36D-60F0-4101-A9E9-03C6E248F178" title="在并行收集器中，世代的布置是不同的。">平行收藏家的世代安排</a></li>
                     <li><a href="parallel-collector1.html#GUID-ECF0EE1D-C39E-453D-9B3D-603E25ADB9AD" title="您可以指定最大垃圾收集暂停时间，吞吐量和占用空间（堆大小）。目标是最大暂停时间目标，吞吐量目标和最小占用空间目标，并且按以下顺序解决目标：收集器保留的平均暂停时间之类的统计信息将在每次收集结束时更新。除非在命令行上指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量来计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的1/64。分配给年轻代的最大空间量是堆总大小的三分之一。您可以使用选项-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。">并行收集器人体工程学</a><ul style="list-style-type:disc">
                           <li><a href="parallel-collector1.html#GUID-C921A9CF-5FE3-49BB-AF1A-696412A9A38F" title="您可以指定最大垃圾收集暂停时间，吞吐量和占用空间（堆大小）。">指定并行收集器行为的选项</a></li>
                           <li><a href="parallel-collector1.html#GUID-6C8D4E24-A580-4FEA-82F0-FE610057DD15" title="目标是最大暂停时间目标，吞吐量目标和最小占用空间目标，并且按以下顺序解决目标：">并行收集器目标的优先级</a></li>
                           <li><a href="parallel-collector1.html#GUID-CAB83393-3438-44ED-98F0-D15641B43C7D" title="每次收集结束时都会更新统计信息，例如收集器保持的平均暂停时间。">并行收集器生成大小调整</a></li>
                           <li><a href="parallel-collector1.html#GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4" title="除非在命令行上指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量来计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的1/64。分配给年轻代的最大空间量是堆总大小的三分之一。">并行收集器默认堆大小</a><ul style="list-style-type:disc">
                                 <li><a href="parallel-collector1.html#GUID-78D7B28B-AD4A-4DFA-AF95-F0273D2ABAAA" title="您可以使用选项-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。">并行收集器的初始堆大小和最大堆大小的规范</a></li>
                              </ul>
                           </li>
                        </ul>
                     </li>
                     <li><a href="parallel-collector1.html#GUID-31F3D722-5F93-41D6-817A-C6B91C095B6F" title="如果在垃圾回收（GC）上花费了太多时间，则并行收集器将引发OutOfMemoryError。">过多的并行收集器时间和OutOfMemoryError</a></li>
                     <li><a href="parallel-collector1.html#GUID-7E5EB9F9-AEBA-4908-88B5-68670465D952">并行收集器测量</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="props_rev_3"><a id="GUID-5A7866BE-59DF-44AD-B51A-274DE3F2BF59" name="GUID-5A7866BE-59DF-44AD-B51A-274DE3F2BF59"></a><h3 id="JSGCT-GUID-5A7866BE-59DF-44AD-B51A-274DE3F2BF59" class="sect3">并行收集器垃圾收集器线程数</h3>
               <div>
                  <p>在带有<span class="variable" translate="no"><n></n></span>硬件线程在哪里<span class="variable" translate="no"><n></n></span>大于8，则并行收集器使用固定比例的<span class="variable" translate="no"><n></n></span>作为垃圾收集器线程的数量。
                  </p>
                  <div class="section">
                     <p>对于较大的值，该分数约为5/8 <span class="variable" translate="no"><n></n></span> 。的值为<span class="variable" translate="no"><n> </n></span>低于8，使用的数字是<span class="variable" translate="no"><n></n></span> 。在选定的平台上，该分数下降到5/16。垃圾收集器线程的具体数量可以使用命令行选项（稍后将进行描述）进行调整。在具有一个处理器的主机上，由于并行执行（例如，同步）所需的开销，并行收集器的性能可能不如串行收集器。但是，当运行具有中型到大型堆的应用程序时，在具有两个处理器的计算机上，它通常比串行收集器的性能要适中，并且在有两个以上处理器可用时，其性能通常比串行收集器好得多。
                     </p>
                     <p>垃圾收集器线程的数量可以通过命令行选项控制<code class="codeph">-XX:ParallelGCThreads=</code> <span class="variable" translate="no"><n></n></span> 。如果要使用命令行选项调整堆，那么并行收集器要获得良好性能所需的堆大小与串行收集器所需的堆大小相同。但是，启用并行收集器应缩短收集暂停时间。因为多个垃圾收集器线程正在参与次要收集，所以由于收集期间从年轻一代升级到老一代，可能会产生一些碎片。次要收集中涉及的每个垃圾收集线程都保留了旧版本中的一部分以进行升级，并且将可用空间划分为这些“促销缓冲区”会导致碎片效应。减少垃圾收集器线程的数量并增加旧一代的大小将减少这种碎片效应。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-D004A36D-60F0-4101-A9E9-03C6E248F178" name="GUID-D004A36D-60F0-4101-A9E9-03C6E248F178"></a><h3 id="JSGCT-GUID-D004A36D-60F0-4101-A9E9-03C6E248F178" class="sect3">平行收藏家的世代安排</h3>
               <div>
                  <p>在并行收集器中，世代的布置是不同的。</p>
                  <div class="section">
                     <p>这种安排<a href="parallel-collector1.html#GUID-D004A36D-60F0-4101-A9E9-03C6E248F178__GEN_ARRANGEMENT_PARALLEL">如图6-1</a>所示：</p>
                     <div class="figure" id="GUID-D004A36D-60F0-4101-A9E9-03C6E248F178__GEN_ARRANGEMENT_PARALLEL">
                        <p class="titleinfigure">图6-1并行收集器中的世代排列</p><img src="img/jsgct_dt_002_armgnt_gn_pl_new.png" alt="如下图6-1所示" title="如下图6-1所示" longdesc="img_text/jsgct_dt_002_armgnt_gn_pl_new.html"><br><a href="img_text/jsgct_dt_002_armgnt_gn_pl_new.html">“图6-1并行收集器中的世代排列”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-ECF0EE1D-C39E-453D-9B3D-603E25ADB9AD" name="GUID-ECF0EE1D-C39E-453D-9B3D-603E25ADB9AD"></a><h3 id="JSGCT-GUID-ECF0EE1D-C39E-453D-9B3D-603E25ADB9AD" class="sect3">并行收集器人体工程学</h3>
               <div>
                  <p>通过使用选择并行收集器时<code class="codeph">-XX:+UseParallelGC</code> ，它启用了一种自动调整的方法，该方法允许您指定行为而不是生成大小和其他低级调整详细信息。
                  </p>
               </div>
               <div class="props_rev_3"><a id="GUID-C921A9CF-5FE3-49BB-AF1A-696412A9A38F" name="GUID-C921A9CF-5FE3-49BB-AF1A-696412A9A38F"></a><h4 id="JSGCT-GUID-C921A9CF-5FE3-49BB-AF1A-696412A9A38F" class="sect4">指定并行收集器行为的选项</h4>
                  <div>
                     <p>您可以指定最大垃圾收集暂停时间，吞吐量和占用空间（堆大小）。</p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>最大垃圾收集暂停时间：最大暂停时间目标是通过命令行选项指定的<code class="codeph">-XX:MaxGCPauseMillis=</code> <span class="variable" translate="no"><n></n></span> 。这被解释为提示暂停时间为<span class="variable" translate="no"><n></n></span>毫秒或更短；默认情况下，没有最大暂停时间目标。如果指定了暂停时间目标，则将调整堆大小和与垃圾回收相关的其他参数，以使垃圾回收的暂停时间短于指定值；但是，可能无法始终满足期望的暂停时间目标。这些调整可能导致垃圾收集器降低应用程序的整体吞吐量。
                              </p>
                           </li>
                           <li>
                              <p>吞吐量：吞吐量目标是根据进行垃圾收集所花费的时间与在垃圾收集之外所花费的时间（称为<span class="italic">应用时间</span> ）来衡量的。目标由命令行选项指定<code class="codeph">-XX:GCTimeRatio=</code> <span class="variable" translate="no"><n></n></span> ，它将垃圾收集时间与应用程序时间之比设置为<code class="codeph">1 / (1 +</code> <span class="variable" translate="no"><n></n></span> <code class="codeph">)</code> 。
                              </p>
                              <p>例如， <code class="codeph">-XX:GCTimeRatio=19</code>将垃圾收集的目标设定为总时间的1/20或5％。默认值为99，导致垃圾回收的目标时间为1％。
                              </p>
                           </li>
                           <li>
                              <p>占用空间：使用选项指定最大堆占用空间<code class="codeph">-Xmx</code> <span class="variable" translate="no"><n></n></span> 。另外，收集器还有一个隐含的目标，即只要满足其他目标，就将堆的大小最小化。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6C8D4E24-A580-4FEA-82F0-FE610057DD15" name="GUID-6C8D4E24-A580-4FEA-82F0-FE610057DD15"></a><h4 id="JSGCT-GUID-6C8D4E24-A580-4FEA-82F0-FE610057DD15" class="sect4">并行收集器目标的优先级</h4>
                  <div>
                     <p>目标是最大暂停时间目标，吞吐量目标和最小占用空间目标，并且按以下顺序解决目标：</p>
                     <p>首先达到最大暂停时间目标。只有在达到目标之后，才能实现吞吐量目标。同样，只有在达到前两个目标后，才会考虑足迹目标。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-CAB83393-3438-44ED-98F0-D15641B43C7D" name="GUID-CAB83393-3438-44ED-98F0-D15641B43C7D"></a><h4 id="JSGCT-GUID-CAB83393-3438-44ED-98F0-D15641B43C7D" class="sect4">并行收集器生成大小调整</h4>
                  <div>
                     <p>每次收集结束时都会更新统计信息，例如收集器保持的平均暂停时间。</p>
                     <p>然后进行确定目标是否达到的测试，并对世代大小进行任何必要的调整。唯一的例外是，在保留统计信息和调整世代大小方面，将忽略显式垃圾回收（例如，对<span class="apiname">System.gc（）的</span>调用<span class="apiname">）</span> 。
                     </p>
                     <p>增长和缩小世代的大小是通过增加作为世代大小的固定百分比来实现的，这样一来，世代就可以朝其期望的大小递增或递减。生长和收缩以不同的速率进行。默认情况下，世代以20％的增量增长，而以5％的增量萎缩。增长百分比由命令行选项控制<code class="codeph">-XX:YoungGenerationSizeIncrement=</code> <span class="variable" translate="no"><y></y></span>对于年轻一代<code class="codeph">-XX:TenuredGenerationSizeIncrement=</code> <span class="variable" translate="no"><t> </t></span>为老一辈。世代缩小的百分比由命令行标志调整<code class="codeph">-XX:AdaptiveSizeDecrementScaleFactor=</code> <span class="variable" translate="no"><d></d></span> 。如果增长增量为<span class="variable" translate="no">X</span> ％，则收缩的增量为<span class="variable" translate="no">X</span> / <span class="variable" translate="no">D</span> ％。
                     </p>
                     <p>如果收集器决定在启动时增加一代，那么增量中会添加一个补充百分比。该补充剂随收集物的数量而衰减，并且没有长期影响。补充的目的是提高启动性能。缩小百分比没有补充。</p>
                     <p>如果没有达到最大的停顿时间目标，那么一次只能压缩一代人的大小。如果两个世代的暂停时间都超过了目标，则首先缩减具有较大暂停时间的世代的大小。</p>
                     <p>如果没有达到吞吐量目标，那么两代产品的大小都会增加。每一个都按其对总垃圾收集时间的贡献成比例增加。例如，如果年轻一代的垃圾收集时间占总收集时间的25％，并且如果年轻一代的完全增量将增加20％，则年轻一代将增加5％。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4" name="GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4"></a><h4 id="JSGCT-GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4" class="sect4">并行收集器默认堆大小</h4>
                  <p>除非在命令行上指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量来计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的1/64。分配给年轻代的最大空间量是堆总大小的三分之一。</p>
                  <div class="props_rev_3"><a id="GUID-78D7B28B-AD4A-4DFA-AF95-F0273D2ABAAA" name="GUID-78D7B28B-AD4A-4DFA-AF95-F0273D2ABAAA"></a><h5 id="JSGCT-GUID-78D7B28B-AD4A-4DFA-AF95-F0273D2ABAAA" class="sect5">并行收集器的初始堆大小和最大堆大小的规范</h5>
                     <div>
                        <p>您可以使用以下选项指定初始堆大小和最大堆大小<code class="codeph">-Xms</code> （初始堆大小）和<code class="codeph">-Xmx</code> （最大堆大小）。
                        </p>
                        <p>如果您知道应用程序需要多少堆才能正常工作，则可以设置<code class="codeph">-Xms</code>和<code class="codeph">-Xmx</code>值相同如果您不知道，那么JVM将首先使用初始堆大小，然后扩展Java堆，直到找到堆使用率和性能之间的平衡为止。
                        </p>
                        <p>其他参数和选项可能会影响这些默认值。要验证您的默认值，请使用<code class="codeph">-XX:+PrintFlagsFinal</code>选择并寻找<code class="codeph">-XX:MaxHeapSize</code>在输出中。例如，在Linux或Solaris上，可以运行以下命令：</p><pre class="pre codeblock"><code>java -XX:+PrintFlagsFinal <span class="italic">&lt;GC options&gt;</span> -version | grep MaxHeapSize</code></pre></div>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-31F3D722-5F93-41D6-817A-C6B91C095B6F" name="GUID-31F3D722-5F93-41D6-817A-C6B91C095B6F"></a><h3 id="JSGCT-GUID-31F3D722-5F93-41D6-817A-C6B91C095B6F" class="sect3">过多的并行收集器时间和OutOfMemoryError</h3>
               <div>
                  <p>并行收集器抛出一个<code class="codeph">OutOfMemoryError</code>如果在垃圾回收（GC）上花费了太多时间。
                  </p>
                  <p>如果超过98％的总时间花费在垃圾收集上，而少于2％的堆被回收，则<code class="codeph">OutOfMemoryError</code> ，被抛出。此功能旨在防止应用程序长时间运行，而由于堆太小而几乎没有进展，甚至没有进展。如有必要，可以通过添加选项来禁用此功能<code class="codeph">-XX:-UseGCOverheadLimit</code>到命令行。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-7E5EB9F9-AEBA-4908-88B5-68670465D952" name="GUID-7E5EB9F9-AEBA-4908-88B5-68670465D952"></a><h3 id="JSGCT-GUID-7E5EB9F9-AEBA-4908-88B5-68670465D952" class="sect3">并行收集器测量</h3>
               <div>
                  <p>并行收集器输出的详细垃圾收集器与串行收集器的输出基本相同。</p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>