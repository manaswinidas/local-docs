<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while the application is running.">
      <meta name="description" content="The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while the application is running.">
      <title>Concurrent Mark Sweep (CMS) Collector</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content="The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while the application is running.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="mostly-concurrent-collectors.html" title="Previous" type="text/html">
      <link rel="next" href="garbage-first-garbage-collector.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="mostly-concurrent-collectors.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="garbage-first-garbage-collector.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot虚拟机垃圾收集优化指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">并发标记扫描（CMS）收集器</li>
            </ol>
            <a id="GUID-FF8150AC-73D9-4780-91DD-148E63FA1BFF" name="GUID-FF8150AC-73D9-4780-91DD-148E63FA1BFF"></a>
            
            <h2 id="JSGCT-GUID-FF8150AC-73D9-4780-91DD-148E63FA1BFF" class="sect2"><span class="enumeration_chapter">8个</span>并发标记扫描（CMS）收集器</h2>
         </header>
         <div class="ind">
            <div>
               <p>并发标记扫描（CMS）收集器是为那些希望较短的垃圾收集暂停并且可以在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计的。</p>
               <p>通常，具有相对较长的长期数据集（较大的旧一代）并在具有两个或多个处理器的计算机上运行的应用程序往往会受益于此收集器的使用。CMS收集器通过命令行选项启用<code class="codeph">-XX:+UseConcMarkSweepGC</code> 。
               </p>
               <p>CMS收集器已弃用。强烈考虑改用垃圾优先收集器。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-FF8150AC-73D9-4780-91DD-148E63FA1BFF__GUID-8D298D12-23F4-4F44-8D7C-30D710524E6D">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-4CB5DCEB-FCBF-4A57-83A1-F2C47BF0B3D7" title="与其他可用的收集器相似，CMS收集器是世代相传的。因此，次要收藏和主要收藏都发生了。CMS收集器尝试通过使用单独的垃圾收集器线程在执行应用程序线程的同时并跟踪可访问对象，来减少由于主要收集而导致的暂停时间。">并发标记扫描收集器的性能和结构</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD" title="CMS收集器使用一个或多个垃圾收集器线程，这些线程与应用程序线程同时运行，目的是在旧版本变满之前完成对旧版本的收集。">并发模式故障</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-8A7DC9B6-0448-4AC5-8F6D-41C83B6C618E" title="如果在垃圾回收上花费了太多时间，则CMS收集器将引发OutOfMemoryError：如果在垃圾回收中花费了总时间的98％以上，而回收的堆少于2％，则抛出OutOfMemoryError。">过多的GC时间和OutOfMemoryError</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-72A6F5B6-93D6-4F25-8EDB-1D467FE2D7C3" title="与Java HotSpot VM中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它至少标识堆中的所有可访问对象。">并发标记扫描收集器和浮动垃圾</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-937A32AD-E2EA-4109-823D-A66D001A1807" title="CMS收集器在并发收集周期中两次暂停应用程序。第一个停顿是将可从根直接访问的对象（例如，来自应用程序线程堆栈和寄存器的对象引用，静态对象等）和从堆中其他位置（例如，年轻代）直接标记为活动状态。">并发标记扫描收集器暂停</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-9ED1CD04-A251-459A-9F49-008509F2FAE7" title="可达对象图的并发跟踪发生在初始标记暂停和注释暂停之间。">并发标记扫描收集器并发阶段</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-2F92DC98-6D4E-4C5B-9C6A-A679E17E4C38" title="使用串行收集器时，只要老一代已满，并且收集完成时所有应用程序线程都停止，就会发生主要收集。相反，必须对CMS收集器中的并发收集的开始进行定时，以使收集可以在老版本变满之前完成。否则，由于并发模式故障，应用程序将观察到更长的暂停。有几种启动并发收集的方法。">开始并发收集周期</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-704EEEB0-EE76-44D4-BA18-FA92F5A7574A" title="年轻一代收藏和老一代收藏的暂停独立发生。">安排暂停</a></li>
                     <li><a href="concurrent-mark-sweep-cms-collector.html#GUID-613350C4-0F12-48C4-A004-E5A7FCFB09FB">并发标记扫描收集器测量</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="props_rev_3"><a id="GUID-4CB5DCEB-FCBF-4A57-83A1-F2C47BF0B3D7" name="GUID-4CB5DCEB-FCBF-4A57-83A1-F2C47BF0B3D7"></a><h3 id="JSGCT-GUID-4CB5DCEB-FCBF-4A57-83A1-F2C47BF0B3D7" class="sect3">并发标记扫描收集器的性能和结构</h3>
               <div>
                  <p>与其他可用的收集器相似，CMS收集器是世代相传的。因此，次要收藏和主要收藏都发生了。CMS收集器尝试通过使用单独的垃圾收集器线程在执行应用程序线程的同时并跟踪可访问对象，来减少由于主要收集而导致的暂停时间。</p>
                  <p>在每个主要的收集周期中，CMS收集器会在收集开始时暂停所有应用程序线程一小段时间，然后再将其暂停到收集中间。第二个停顿往往是两个停顿中较长的一个。在两个暂停期间，多个线程执行收集工作。一个或多个垃圾收集器线程负责收集的其余部分（包括大多数跟踪活动对象和清除无法访问的对象）。次要收集可以与进行中的主周期交错，并且以与并行收集器类似的方式完成（特别是在次要收集期间停止应用程序线程）。</p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD" name="GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD"></a><h3 id="JSGCT-GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD" class="sect3">并发模式故障</h3>
               <div>
                  <p>CMS收集器使用一个或多个垃圾收集器线程，这些线程与应用程序线程同时运行，目的是在旧版本变满之前完成对旧版本的收集。</p>
                  <p>如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行的情况下执行其大部分跟踪和清除工作，因此应用程序线程仅会看到短暂的暂停。但是，如果CMS收集器无法在旧的一代填满之前完成对无法访问的对象的回收，或者如果旧一代中的可用空闲空间块无法满足分配要求，则暂停应用程序，并使用所有应用程序线程均已停止。无法同时完成收集的情况称为<span class="italic">并发模式故障</span> ，表示需要调整CMS收集器参数。如果并发收集被显式垃圾回收（ <span class="apiname">System.gc（）</span> ）中断，或者为提供诊断工具信息所需的垃圾收集中断了，则将报告并发模式中断。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-8A7DC9B6-0448-4AC5-8F6D-41C83B6C618E" name="GUID-8A7DC9B6-0448-4AC5-8F6D-41C83B6C618E"></a><h3 id="JSGCT-GUID-8A7DC9B6-0448-4AC5-8F6D-41C83B6C618E" class="sect3">过多的GC时间和OutOfMemoryError</h3>
               <div>
                  <p>CMS收集器会抛出一个<code class="codeph">OutOfMemoryError</code>如果在垃圾回收上花费了太多时间：如果超过98％的总时间花在了垃圾回收上，并且回收了不到2％的堆，则<samp class="msgph">OutOfMemoryError</samp>被抛出。
                  </p>
                  <p>此功能旨在防止应用程序长时间运行，而由于堆太小而几乎没有进展，甚至没有进展。如有必要，可以通过添加选项来禁用此功能<code class="codeph">-XX:-UseGCOverheadLimit</code>到命令行。
                  </p>
                  <p>该策略与并行收集器中的策略相同，除了执行并发收集所花费的时间不计入98％的时间限制。换句话说，只有在应用程序停止时执行的收集才计入过多的GC时间。此类收集通常是由于并发模式故障或显式收集请求（例如，对<code class="codeph">System.gc()</code> ）。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-72A6F5B6-93D6-4F25-8EDB-1D467FE2D7C3" name="GUID-72A6F5B6-93D6-4F25-8EDB-1D467FE2D7C3"></a><h3 id="JSGCT-GUID-72A6F5B6-93D6-4F25-8EDB-1D467FE2D7C3" class="sect3">并发标记扫描收集器和浮动垃圾</h3>
               <div>
                  <p>与Java HotSpot VM中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它至少标识堆中的所有可访问对象。</p>
                  <p>理查德·琼斯（Richard Jones）和拉斐尔·林斯（Rafael D.Lins）在其出版物《 <span class="italic">垃圾收集：自动动态内存算法》中</span> ，它是一个增量更新收集器。因为应用程序线程和垃圾收集器线程在主收集期间同时运行，所以垃圾收集器线程跟踪的对象随后可能会在收集过程结束时变得不可访问。尚未回收的此类无法访问的对象称为<span class="variable" translate="no">floating garbage</span> 。浮动垃圾的数量取决于并发收集周期的持续时间以及应用程序对引用更新（也称为<span class="variable" translate="no">mutations</span>的频率。此外，由于年轻一代和老年一代是独立收集的，因此每个人都是彼此的根源。作为粗略的指导，请尝试将旧一代的大小增加20％，以解决浮动垃圾的问题。在一个并发收集周期结束时，将在下一个收集周期中收集堆中的浮动垃圾。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-937A32AD-E2EA-4109-823D-A66D001A1807" name="GUID-937A32AD-E2EA-4109-823D-A66D001A1807"></a><h3 id="JSGCT-GUID-937A32AD-E2EA-4109-823D-A66D001A1807" class="sect3">并发标记扫描收集器暂停</h3>
               <div>
                  <p>CMS收集器在并发收集周期中两次暂停应用程序。第一个停顿是将可从根直接访问的对象（例如，来自应用程序线程堆栈和寄存器的对象引用，静态对象等）和从堆中其他位置（例如，年轻代）直接标记为活动状态。</p>
                  <p>此第一个停顿称为<span class="variable" translate="no">initial mark pause</span> 。第二个暂停是在并发跟踪阶段的末尾，它发现由于CMS收集器完成对对象的引用后，应用程序线程对对象中的引用进行了更新而导致并发跟踪遗漏的对象。此第二个停顿称为<span class="variable" translate="no">remark pause</span> 。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-9ED1CD04-A251-459A-9F49-008509F2FAE7" name="GUID-9ED1CD04-A251-459A-9F49-008509F2FAE7"></a><h3 id="JSGCT-GUID-9ED1CD04-A251-459A-9F49-008509F2FAE7" class="sect3">并发标记扫描收集器并发阶段</h3>
               <div>
                  <p>可达对象图的并发跟踪发生在初始标记暂停和注释暂停之间。</p>
                  <p>在此并发跟踪阶段，一个或多个并发垃圾收集器线程可能正在使用处理器资源，否则这些资源将可供应用程序使用。结果，即使没有暂停应用程序线程，在此阶段以及其他并发阶段中，受计算绑定的应用程序的应用程序吞吐量也可能会相应下降。备注暂停后，并发清除阶段将收集标识为不可访问的对象。收集周期结束后，CMS收集器将等待，几乎不消耗任何计算资源，直到下一个主要收集周期开始。</p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-2F92DC98-6D4E-4C5B-9C6A-A679E17E4C38" name="GUID-2F92DC98-6D4E-4C5B-9C6A-A679E17E4C38"></a><h3 id="JSGCT-GUID-2F92DC98-6D4E-4C5B-9C6A-A679E17E4C38" class="sect3">开始并发收集周期</h3>
               <div>
                  <p>使用串行收集器时，只要老一代已满，并且收集完成时所有应用程序线程都停止，就会发生主要收集。相反，必须对CMS收集器中的并发收集的开始进行定时，以使收集可以在老版本变满之前完成。否则，由于并发模式故障，应用程序将观察到更长的暂停。有几种启动并发收集的方法。</p>
                  <p>根据最近的历史记录，CMS收集器将保留对旧的驱动器用尽之前的剩余时间以及并发收集周期所需时间的估计。使用这些动态估计，一个并发的收集周期开始，其目的是在耗尽旧一代之前完成收集周期。为安全起见，对这些估计值进行了填充，因为并发模式故障的代价可能很高。</p>
                  <p>如果老一代的占用率超过了初始占用率（占老一代的百分比），则并发收集也将开始。此初始占用阈值的默认值约为92％，但是该值可能会因版本而异。可以使用命令行选项手动调整此值<code class="codeph">-XX:CMSInitiatingOccupancyFraction=</code><code class="codeph"><N></code> ，在哪里<code class="codeph"><N></code>是旧一代大小的整数百分比（0到100）。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-704EEEB0-EE76-44D4-BA18-FA92F5A7574A" name="GUID-704EEEB0-EE76-44D4-BA18-FA92F5A7574A"></a><h3 id="JSGCT-GUID-704EEEB0-EE76-44D4-BA18-FA92F5A7574A" class="sect3">安排暂停</h3>
               <div>
                  <p>年轻一代收藏和老一代收藏的暂停独立发生。</p>
                  <p>它们不会重叠，但是可能会快速连续发生，因此一个集合的暂停，紧接着是另一个集合的暂停，可能看起来像是一个更长的暂停。为避免这种情况，CMS收集器尝试在上一个和下一个年轻暂停之间的大致中间时间安排注释暂停。当前未针对初始标记暂停执行此计划，该时间通常比标记暂停短得多。</p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-613350C4-0F12-48C4-A004-E5A7FCFB09FB" name="GUID-613350C4-0F12-48C4-A004-E5A7FCFB09FB"></a><h3 id="JSGCT-GUID-613350C4-0F12-48C4-A004-E5A7FCFB09FB" class="sect3">并发标记扫描收集器测量</h3>
               <div>
                  <div class="section">
                     <p>以下是带有选项的CMS收集器的输出<code class="codeph">-Xlog:gc</code> ：</p><pre class="pre codeblock"><code>[121,834s][info][gc] GC(657) Pause Initial Mark 191M-&gt;191M(485M) (121,831s, 121,834s) 3,433ms
[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)
[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms
[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)
[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms
[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)
[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M-&gt;199M(485M) (121,929s, 121,949s) 19,705ms
[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M-&gt;200M(485M) (122,043s, 122,068s) 24,892ms
[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms
[122,087s][info][gc] GC(657) Pause Remark 209M-&gt;209M(485M) (122,076s, 122,087s) 11,373ms
[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)
[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M-&gt;165M(485M) (122,181s, 122,193s) 12,151ms
[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms
[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)
[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms
[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M-&gt;128M(485M) (122,291s, 122,297s) 5,797ms</code></pre><div class="infoboxnote" id="GUID-613350C4-0F12-48C4-A004-E5A7FCFB09FB__GUID-BD3ECE63-C497-440C-B862-20B543297985">
                        <p class="notep1">注意：</p>CMS集合（GC ID 657）的输出与次要集合（GC ID 658、659和660）的输出相互穿插；通常在并发收集周期中会发生许多次要收集。暂停初始标记指示并发收集周期的开始。以“并发”开头的行指示并发阶段的开始和结束。暂停备注是最后的暂停。先前未讨论的是预清洁阶段。预清理代表可以在准备备注阶段时同时进行的工作。最后阶段由并发重置指示，并为下一个并发收集做准备。
                     </div>
                     <p>相对于次要收集暂停时间，初始标记暂停通常较短。并发阶段（并发标记，并发预清理和并发扫描）通常持续的时间明显长于次要收集暂停，如CMS收集器输出示例所示。但是请注意，在这些并发阶段中不会暂停应用程序。备注停顿的长度通常可与次要收藏相媲美。备注暂停受某些应用程序特性的影响（例如，对象修改率较高，可能会增加此暂停）以及自上次次要收集以来的时间（例如，年轻一代中的更多对象可能会增加此暂停）。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>