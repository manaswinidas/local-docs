<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="One strength of the Java SE platform is that it shields the developer from the complexity of memory allocation and garbage collection.">
      <meta name="description" content="One strength of the Java SE platform is that it shields the developer from the complexity of memory allocation and garbage collection.">
      <title>垃圾收集器实施</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content="One strength of the Java SE platform is that it shields the developer from the complexity of memory allocation and garbage collection.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="ergonomics.html" title="Previous" type="text/html">
      <link rel="next" href="factors-affecting-garbage-collection-performance.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="ergonomics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="factors-affecting-garbage-collection-performance.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot虚拟机垃圾收集优化指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">垃圾收集器实施</li>
            </ol>
            <a id="GUID-23844E39-7499-400C-A579-032B68E53073" name="GUID-23844E39-7499-400C-A579-032B68E53073"></a>
            
            <h2 id="JSGCT-GUID-23844E39-7499-400C-A579-032B68E53073" class="sect2"><span class="enumeration_chapter">3</span>垃圾收集器的实现</h2>
         </header>
         <div class="ind">
            <div>
               <p>Java SE平台的优势之一在于，它使开发人员免受内存分配和垃圾回收的复杂性的困扰。</p>
               <p>但是，当垃圾收集是主要瓶颈时，了解实现的某些方面很有用。垃圾收集器对应用程序使用对象的方式进行了假设，这些反映在可调整的参数中，可以调整这些参数以提高性能，而又不牺牲抽象的力量。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-23844E39-7499-400C-A579-032B68E53073__GUID-98D024E4-22C4-4A01-B5C5-1B2ABACF057F">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="garbage-collector-implementation.html#GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D" title="如果无法从正在运行的程序中任何其他活动对象的任何引用中访问该对象，则该对象被视为垃圾，并且VM可以重用其内存。">世代垃圾收集</a></li>
                     <li><a href="garbage-collector-implementation.html#GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57" title="为了针对这种情况进行优化，需要分代管理内存（保存不同年龄对象的内存池）。当世代填满时，垃圾收集会在每个世代中发生。">世代</a></li>
                     <li><a href="garbage-collector-implementation.html#GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" title="垃圾收集的主要衡量指标是吞吐量和延迟。">性能考量</a></li>
                     <li><a href="garbage-collector-implementation.html#GUID-A24775AB-16A3-4B86-9963-76E5AC398A3E" title="吞吐量和占用空间最好使用特定于应用程序的指标来衡量。">吞吐量和足迹测量</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="props_rev_3"><a id="GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D" name="GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D"></a><h3 id="JSGCT-GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D" class="sect3">世代垃圾收集</h3>
               <div>
                  <p>如果无法从正在运行的程序中任何其他活动对象的任何引用中访问该对象，则该对象被视为垃圾，并且VM可以重用其内存。</p>
                  <p>理论上最简单的垃圾回收算法会在每次可运行对象运行时对其进行迭代。任何剩余的对象都被视为垃圾。这种方法所花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序是不允许的。</p>
                  <p>Java HotSpot VM包含许多不同的垃圾收集算法，这些算法均使用称为<span class="variable" translate="no">generational collection</span>的技术。天真的垃圾收集每次都会检查堆中的每个活动对象，而世代收集则利用大多数应用程序的一些经验观察到的属性，以最大程度地减少回收未使用（垃圾）对象所需的工作。这些观察到的特性中最重要的是<span class="variable" translate="no">weak generational hypothesis</span> ，该<span class="variable" translate="no">weak generational hypothesis</span>指出大多数物体只能存活很短的时间。
                  </p>
                  <p><a href="garbage-collector-implementation.html#GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D__DISTRIBUTION_LIFETIMES">图3-1中</a>的蓝色区域是对象生命周期的典型分布。x轴显示以分配的字节为单位的对象生存期。y轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后可以回收的对象（换句话说，已“死亡”）。例如， <code class="codeph">iterator</code>对象通常仅在单个循环的时间内才存在。
                  </p>
                  <div class="figure" id="GUID-71D796B3-CBAB-4D80-B5C3-2620E45F6E5D__DISTRIBUTION_LIFETIMES">
                     <p class="titleinfigure">图3-1对象生命周期的典型分布</p><img src="img/jsgct_dt_003_alc_vs_srvng.png" alt="如下图3-1所示" title="如下图3-1所示" longdesc="img_text/jsgct_dt_003_alc_vs_srvng.html"><br><a href="img_text/jsgct_dt_003_alc_vs_srvng.html">“图3-1对象生命周期的典型分布”的描述</a></div>
                  <!-- class="figure" -->
                  <p>有些对象的寿命更长，因此分布向右延伸。例如，通常在初始化时分配一些对象，这些对象一直存在直到VM退出。在这两个极端之间的是在某些中间计算过程中存在的对象，在此处被视为初始峰值右侧的块。一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。通过关注大多数对象“早逝”这一事实，可以进行有效的收集。</p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57" name="GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57"></a><h3 id="JSGCT-GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57" class="sect3">世代</h3>
               <div>
                  <p>为了针对这种情况进行优化，需要分<span class="italic">代</span>管理内存（保存不同年龄对象的内存池）。当世代填满时，垃圾收集会在每个世代中发生。
                  </p>
                  <p>绝大多数对象分配在专用于年轻对象（ <span class="italic">年轻一代</span> ）的池中，并且大多数对象在那里死亡。当年轻一代填满时，将导致<span class="italic">次要集合</span> ，其中仅收集年轻一代。没有回收其他世代的垃圾。首先，这种收集的费用与所收集的有生命物体的数量成正比；可以很快收集到充满死亡物体的年轻一代。通常，在每个次要收藏期间，来自年轻一代的幸存对象中有一部分会转移到<span class="italic">老一代</span> 。最终，老一代填满并必须进行收集，从而导致<span class="italic">主收集</span> ，其中收集了整个堆。主要集合的持续时间通常比次要集合的持续时间长得多，因为涉及的对象数量很多。<a href="garbage-collector-implementation.html#GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57__DEFAULT_ARRANGEMENT_GEN">图3-2</a>显示了串行垃圾收集器中各代的默认排列：</p>
                  <div class="figure" id="GUID-16166ED9-32C6-402D-BB22-FD85BCB04E57__DEFAULT_ARRANGEMENT_GEN">
                     <p class="titleinfigure">图3-2串行收集器中的世代默认排列</p><img src="img/jsgct_dt_001_armgnt_gn_new.png" alt="如下图3-2所示" title="如下图3-2所示" longdesc="img_text/jsgct_dt_001_armgnt_gn_new.html"><br><a href="img_text/jsgct_dt_001_armgnt_gn_new.html">“图3-2串行收集器中世代的默认排列”的描述</a></div>
                  <!-- class="figure" -->
                  <p>启动时，Java HotSpot VM会在地址空间中保留整个Java堆，但除非需要，否则不会为其分配任何物理内存。从逻辑上讲，覆盖Java堆的整个地址空间都分为年轻一代和老一代。保留给对象存储器的完整地址空间可以分为年轻一代和老一代。</p>
                  <p>年轻一代由伊甸园和两个幸存者空间组成。大多数对象最初是在eden中分配的。一个幸存者空间随时都是空的，在伊甸园中用作活动对象的目的地，而在垃圾回收期间，另一个幸存者空间用作目的地；垃圾回收后，伊甸园和源幸存者空间为空。在下一个垃圾收集中，交换了两个幸存者空间的目的。最近填充的一个空间是复制到另一个幸存者空间中的活动对象的来源。以这种方式在幸存者空间之间复制对象，直到它们被复制了一定次数或空间不足为止。这些对象被复制到旧区域中。此过程也称为<span class="italic">老化</span> 。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" name="GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D"></a><h3 id="JSGCT-GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" class="sect3">性能考量</h3>
               <div>
                  <p>垃圾收集的主要衡量指标是吞吐量和延迟。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic">吞吐量</span>是长时间内未花费在垃圾回收上的总时间的百分比。吞吐量包括分配所花费的时间（但通常不需要调整分配速度）。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">延迟</span>是应用程序的响应能力。垃圾回收暂停会影响应用程序的响应速度。
                        </p>
                     </li>
                  </ul>
                  <p>用户对垃圾回收有不同的要求。例如，有些人认为Web服务器的正确度量标准是吞吐量，因为垃圾回收期间的暂停可能是可以容忍的，或者可能被网络延迟所掩盖。但是，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。</p>
                  <p>一些用户对其他注意事项敏感。<span class="italic">足迹</span>是流程的工作集，以页和缓存行为单位。在具有有限物理内存或许多进程的系统上，占用空间可能决定可伸缩性。<span class="italic">及时性</span>是当一个物体变得死亡之间的时间当内存可用，分布式系统，包括远程方法调用（RMI）的重要考虑因素。
                  </p>
                  <p>通常，为特定世代选择大小是这些考虑之间的权衡。例如，一个非常大的年轻一代可以最大化吞吐量，但是这样做会以占用空间，及时性和暂停时间为代价。可以通过使用少量的年轻一代来最小化年轻一代的停顿，但会降低吞吐量。一代的大小不会影响另一一代的收集频率和暂停时间。</p>
                  <p>没有选择世代大小的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可能会被命令行选项所替代。请参阅<a href="factors-affecting-garbage-collection-performance.html#GUID-5508674B-F32D-4B02-9002-D0D8C7CDDC75" title="影响垃圾收集性能的两个最重要因素是总可用内存和专用于年轻一代的堆的比例。">影响垃圾收集性能的因素</a> 。
                  </p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A24775AB-16A3-4B86-9963-76E5AC398A3E" name="GUID-A24775AB-16A3-4B86-9963-76E5AC398A3E"></a><h3 id="JSGCT-GUID-A24775AB-16A3-4B86-9963-76E5AC398A3E" class="sect3">吞吐量和足迹测量</h3>
               <div>
                  <p>吞吐量和占用空间最好使用特定于应用程序的指标来衡量。</p>
                  <p>例如，可以使用客户端负载生成器来测试Web服务器的吞吐量，而可以使用Solaris Server在Solaris操作系统上测量服务器的占用空间。 <code class="codeph">pmap</code>命令。但是，通过检查虚拟机本身的诊断输出，很容易估算出由于垃圾收集而引起的暂停。
                  </p>
                  <p>命令行选项<code class="codeph">-verbose:gc</code>在每个集合上打印有关堆和垃圾回收的信息。这是一个例子：</p><pre class="pre codeblock"><code>[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M-&gt;57M(307M) (15,646s, 15,651s) 5,048ms
[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M-&gt;57M(307M) (16,146s, 16,162s) 16,565ms
[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M-&gt;31M(104M) (16,202s, 16,367s) 164,581ms</code></pre><p>输出显示两个年轻的集合，然后是一个完整的集合，该集合由应用程序调用并调用<code class="codeph">System.gc()</code> 。这些行以一个时间戳开始，指示从应用程序启动开始的时间。接下来是有关此行的日志级别（info）和标签（gc）的信息。随后是GC标识号。在这种情况下，存在三个GC，其编号分别为36、37和38。然后记录GC的类型和原因。此后，将记录有关内存消耗的一些信息。该日志使用“ GC前使用”->“ GC后使用”（“堆大小”）的格式。
                  </p>
                  <p>在示例的第一行中，这是239M-> 57M（307M），这意味着在GC之前使用了239 MB，GC清除了大部分内存，但仍有57 MB可用。堆大小为307 MB。请注意，在此示例中，完整的GC将堆从307 MB缩小到104 MB。在内存使用情况信息之后，将记录GC的开始和结束时间以及持续时间（结束-开始）。</p>
                  <p>的<code class="codeph">-verbose:gc</code>命令是的别名<code class="codeph">-Xlog:gc</code> 。 <code class="codeph">-Xlog</code>是用于登录HotSpot JVM的常规日志记录配置选项。这是一个基于标签的系统<code class="codeph">gc</code>是标签之一。要获取有关GC正在执行的操作的更多信息，可以配置日志记录以打印具有以下内容的任何消息： <code class="codeph">gc</code>标签和其他任何标签。命令行选项是<code class="codeph">-Xlog:gc*</code> 。
                  </p>
                  <p>这是一个使用G1年轻记录登录<code class="codeph">-Xlog:gc*</code> ：</p><pre class="pre codeblock"><code>[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) 
[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation 
[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms
[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms 
[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms 
[10.191s][info][gc,phases ] GC(36) Other: 0.2ms 
[10.191s][info][gc,heap ] GC(36) Eden regions: 286-&gt;0(276) 
[10.191s][info][gc,heap ] GC(36) Survivor regions: 15-&gt;26(38)
[10.191s][info][gc,heap ] GC(36) Old regions: 88-&gt;88 
[10.191s][info][gc,heap ] GC(36) Humongous regions: 3-&gt;1 
[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K-&gt;8152K(1056768K)
[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M-&gt;114M(508M) 13.075ms 
[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s</code></pre><div class="infoboxnote" id="GUID-A24775AB-16A3-4B86-9963-76E5AC398A3E__GUID-E8F29322-FCA8-4F68-AE8E-F05CED0DD900">
                     <p class="notep1">注意：</p>产生的输出格式<code class="codeph">-Xlog:gc*</code>在将来的版本中可能会发生变化。
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>