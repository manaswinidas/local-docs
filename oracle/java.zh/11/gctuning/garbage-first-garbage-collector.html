<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Garbage-First Garbage Collector</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="concurrent-mark-sweep-cms-collector.html" title="Previous" type="text/html">
      <link rel="next" href="garbage-first-garbage-collector-tuning.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="concurrent-mark-sweep-cms-collector.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="garbage-first-garbage-collector-tuning.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot虚拟机垃圾收集优化指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">垃圾第一垃圾收集器</li>
            </ol>
            <a id="GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573" name="GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573"></a>
            
            <h2 id="JSGCT-GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573" class="sect2"><span class="enumeration_chapter">9</span>垃圾第一垃圾收集器</h2>
         </header>
         <div class="ind">
            <div>
               <p>本节介绍垃圾优先（G1）垃圾收集器（GC）。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573__GUID-2F1C60CB-B61C-4A32-BE8A-93D7F86C3B95">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="garbage-first-garbage-collector.html#GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42">垃圾优先收集器简介</a></li>
                     <li><a href="garbage-first-garbage-collector.html#GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D">启用G1</a></li>
                     <li><a href="garbage-first-garbage-collector.html#GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF">基本概念</a><ul style="list-style-type:disc">
                           <li><a href="garbage-first-garbage-collector.html#GUID-15921907-B297-43A4-8C48-DC88035BC7CF">堆布局</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180">垃圾回收周期</a></li>
                        </ul>
                     </li>
                     <li><a href="garbage-first-garbage-collector.html#GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F">垃圾优先内部</a><ul style="list-style-type:disc">
                           <li><a href="garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3">确定初始堆占用率</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-AC383806-7FA7-4698-8B92-4FD092B9F368">打标</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-BE157AF6-29E7-461A-82CF-50C1978785DA">堆非常紧的情况下的行为</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3">确定初始堆占用率</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC">杂物</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-C268549C-7D95-499C-9B24-A6670B44E49C">仅年轻阶段生成大小</a></li>
                           <li><a href="garbage-first-garbage-collector.html#GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8">空间填埋阶段生成大小</a></li>
                        </ul>
                     </li>
                     <li><a href="garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" title="本主题概述了特定于G1的最重要默认值及其默认值。他们使用G1粗略地概述了预期的行为和资源使用情况，没有任何其他选项。">G1 GC的人体工程学默认值</a></li>
                     <li><a href="garbage-first-garbage-collector.html#GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF">与其他收藏家的比较</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42" name="GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42"></a><h3 id="JSGCT-GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42" class="sect3">垃圾优先收集器简介</h3>
               <div>
                  <p>Garbage-First（G1）垃圾收集器的目标是具有大量内存的多处理器计算机。它试图以极高的可能性满足垃圾收集暂停时间的目标，同时在几乎不需要配置的情况下实现高吞吐量。G1的目标是使用当前的目标应用程序和环境在延迟和吞吐量之间达到最佳平衡，其特点包括：</p>
                  <ul style="list-style-type:disc">
                     <li>堆大小最大为10 GB或更大，其中超过50％的Java堆占用实时数据。</li>
                     <li>对象分配和升级的速率可能会随时间而显着变化。</li>
                     <li>堆中有大量碎片。</li>
                     <li>可预测的暂停时间目标目标不超过几百毫秒，避免了长时间的垃圾收集暂停。</li>
                  </ul>
                  <p>G1取代了并发标记扫描（CMS）收集器。它也是默认的收集器。</p>
                  <p>G1收集器可实现高性能，并尝试通过以下各节中描述的几种方式满足暂停时间目标。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D" name="GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D"></a><h3 id="JSGCT-GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D" class="sect3">启用G1</h3>
               <div>
                  <p>Garbage-First垃圾收集器是默认的收集器，因此通常不必执行任何其他操作。您可以通过提供显式启用它<code class="codeph">-XX:+UseG1GC</code>在命令行上。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF" name="GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF"></a><h3 id="JSGCT-GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF" class="sect3">基本概念</h3>
               <div>
                  <p>G1是世代的，增量的，并行的，主要是并发的，停止运行的并撤离的垃圾收集器，它监视每个停止运行中的暂停中的暂停时间目标。与其他收集器类似，G1将堆分成（虚拟的）年轻一代和老一代。填海工作主要集中在最有效的年轻一代，而老一代则偶尔进行填海</p>
                  <p>某些操作总是在停下来的暂停中执行以提高吞吐量。在应用程序停止时会花费更多时间的其他操作（如<span class="italic">全局标记之</span>类的整个堆操作）与应用程序并行并发执行。为了使停顿世界停顿的时间不至于引起空间争夺，G1分步和并行地逐步执行空间争夺。G1通过跟踪有关先前的应用程序行为和垃圾收集暂停的信息来构建可关联成本模型，从而实现可预测性。它使用此信息来确定暂停中完成的工作。例如，G1首先回收最有效区域中的空间（也就是大部分被垃圾填充的区域，因此称为名称）。
                  </p>
                  <p>G1主要通过疏散来回收空间：将在选定存储区域中收集的活动对象复制到新的存储区域中，并在此过程中对其进行压缩。疏散完成后，活动对象先前占用的空间将重新用于应用程序分配。</p>
                  <p>垃圾优先收集器不是实时收集器。它试图在更长的时间内以较高的概率达到设定的暂停时间目标，但对于给定的暂停时间并不一定总是具有绝对的确定性。</p>
               </div>
               <div class="sect3"><a id="GUID-15921907-B297-43A4-8C48-DC88035BC7CF" name="GUID-15921907-B297-43A4-8C48-DC88035BC7CF"></a><h4 id="JSGCT-GUID-15921907-B297-43A4-8C48-DC88035BC7CF" class="sect4">堆布局</h4>
                  <div>
                     <p>G1将堆划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定时间，这些区域中的每个区域都可以为空（浅灰色），或分配给特定的年龄段（年轻或年长）。随着内存请求的到来，内存管理器将释放可用区域。内存管理器将它们分配给一个世代，然后将它们作为可分配自身的可用空间返回给应用程序。</p>
                     <div class="figure" id="GUID-15921907-B297-43A4-8C48-DC88035BC7CF__HEAP_DIVISION_BY_G1">
                        <p class="titleinfigure">图9-1 G1垃圾收集器堆布局</p><img src="img/jsgct_dt_004_grbg_frst_hp.png" alt="如下图9-1所示" title="如下图9-1所示" longdesc="img_text/jsgct_dt_004_grbg_frst_hp.html"><br><a href="img_text/jsgct_dt_004_grbg_frst_hp.html">“图9-1 G1垃圾收集器堆布局”的描述</a></div>
                     <!-- class="figure" -->
                     <p>年轻的一代包含伊甸园区域（红色）和幸存者区域（带有“ S”的红色）。这些区域提供的功能与其他收集器中相应的连续空间相同，不同之处在于，在G1中，这些区域通常以非连续模式布置在内存中。老区域（浅蓝色）构成了老一代。对于跨越多个区域的对象，旧区域可能是巨大的（浅蓝色，带有“ H”）。</p>
                     <p>应用程序总是分配给年轻的一代，即伊甸园地区，但直接分配为属于老一代的庞大对象除外。</p>
                     <p>G1垃圾收集暂停可以在整个年轻一代中回收空间，并且可以在任何收集暂停时回收任何其他的旧一代区域集。在暂停期间，G1将对象从该<span class="italic">集合集中</span>复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：将整个年轻代复制到幸存者区域或旧区域中，并使用老化将对象从旧区域复制到其他不同的旧区域。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180" name="GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180"></a><h4 id="JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180" class="sect4">垃圾回收周期</h4>
                  <div>
                     <p>在较高级别上，G1收集器在两相之间交替。仅限年轻阶段包含垃圾收集，这些垃圾收集逐渐将旧一代中的对象填充到当前可用的内存中。在太空回收阶段，G1除了处理年轻一代外，还逐步回收老一代的空间。然后，循环以仅年轻阶段重新开始。</p>
                     <p>图9-2给出了有关此循环的概述，并举例说明了可能发生的垃圾收集暂停的顺序：</p>
                     <div class="figure" id="GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180__GUID-2D6AABE8-15CA-4E8B-AD13-12A9638C6274">
                        <p class="titleinfigure">图9-2垃圾收集周期概述</p><img src="img/jsgct_dt_001_grbgcltncyl.png" alt="如下图9-2所示" title="如下图9-2所示" longdesc="img_text/jsgct_dt_001_grbgcltncyl.html"><br><a href="img_text/jsgct_dt_001_grbgcltncyl.html">“图9-2垃圾收集周期概述”的描述</a></div>
                     <!-- class="figure" -->
                     <p>以下列表详细描述了G1垃圾回收周期的各个阶段，它们的暂停以及这些阶段之间的过渡：</p>
                     <ol>
                        <li>
                           <p>仅限年轻阶段：此阶段开始于一些普通的年轻收藏，这些收藏将对象推广到老一辈。当老一代占用率达到某个阈值（起始堆占用率阈值）时，仅年轻阶段和空间回收阶段之间的过渡开始。此时，G1计划并发开始年轻集合，而不是正常年轻集合。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>并发开始：这种类型的收集除了执行正常的年轻收集外，还开始标记过程。并发标记确定了在下一个空间回收阶段中要保留的旧生成区域中所有当前可到达的（活动）对象。馆藏标记尚未完全完成时，可能会出现普通的年轻馆藏。标记结束时有两个特殊的停顿世界：“注释”和“清理”。</p>
                              </li>
                              <li>
                                 <p>备注：此暂停将最终完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在“备注”和“清除”之间，G1计算信息以便以后能够同时回收选定的旧生成区域中的可用空间，这些信息将在“清除暂停”中最终确定。</p>
                              </li>
                              <li>
                                 <p>清理：此暂停确定是否将实际进行空间回收阶段。如果进行空间回收阶段，则仅年轻人阶段将以单个“准备混合”年轻人集合结束。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>空间回收阶段：此阶段包括多个混合集合，这些集合除了年轻一代区域外，还撤离了旧一代区域集的活动对象。当G1确定撤离更多旧一代地区不会产生值得努力的足够自由空间时，太空争夺阶段结束。</p>
                        </li>
                     </ol>
                     <p>在进行空间回收之后，收集周期会从另一个仅年轻阶段开始。作为备份，如果应用程序在收集活动信息时内存不足，则G1会像其他收集器一样执行就地停止的全堆压缩（Full GC）。</p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F" name="GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F"></a><h3 id="JSGCT-GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F" class="sect3">垃圾优先内部</h3>
               <div>
                  <p>本节描述了垃圾优先（G1）垃圾收集器的一些重要细节。</p>
               </div>
               <div class="sect3"><a id="GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" name="GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3"></a><h4 id="JSGCT-GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" class="sect4">确定初始堆占用率</h4>
                  <div>
                     <p><span class="italic">初始堆占用率（IHOP）</span>是触发初始标记收集的阈值，并且定义为旧一代大小的百分比。
                     </p>
                     <p>默认情况下，G1通过观察标记所需的时间以及标记周期内旧代中通常分配的内存量来自动确定最佳的IHOP。此功能称为“ <span class="italic">自适应IHOP”</span> 。如果此功能处于活动状态，则该选项<code class="codeph">-XX:InitiatingHeapOccupancyPercent</code>只要没有足够的观察结果可以很好地预测“初始堆占用”阈值，就可以将初始值确定为当前旧一代的大小的百分比。使用选项关闭G1的这种行为<code class="codeph">-XX:-G1UseAdaptiveIHOP</code> 。在这种情况下， <code class="codeph">-XX:InitiatingHeapOccupancyPercent</code>始终确定此阈值。
                     </p>
                     <p>在内部，自适应IHOP尝试设置“初始堆占用”，以便当老一代占用量为当前最大老一代大小减去的值时，开始空间回收阶段的第一个混合垃圾收集。 <code class="codeph">-XX:G1HeapReservePercent</code>作为额外的缓冲区。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AC383806-7FA7-4698-8B92-4FD092B9F368" name="GUID-AC383806-7FA7-4698-8B92-4FD092B9F368"></a><h4 id="JSGCT-GUID-AC383806-7FA7-4698-8B92-4FD092B9F368" class="sect4">打标</h4>
                  <div>
                     <p>G1标记使用称为<span class="italic">Snapshot-At-The-Beginning（SATB）的算法</span> 。当初始标记暂停时，它会为堆创建虚拟快照，此时在标记的剩余时间内，所有在标记开始时处于活动状态的对象都被视为处于活动状态。这意味着出于空间回收的目的（在某些情况下例外），在标记过程中变成死（不可到达）的对象仍被认为是带电的。与其他收集器相比，这可能导致错误地保留了一些额外的内存。但是，SATB可能在备注暂停期间提供更好的延迟。在该标记过程中过于保守地认为有生命的物体将在下一次标记期间回收。有关标记问题的更多信息，请参见<a href="garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" title="本节介绍了如何在不满足您的要求的情况下调整垃圾优先垃圾收集器（G1 GC）的行为。">垃圾优先垃圾收集器优化</a>主题。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BE157AF6-29E7-461A-82CF-50C1978785DA" name="GUID-BE157AF6-29E7-461A-82CF-50C1978785DA"></a><h4 id="JSGCT-GUID-BE157AF6-29E7-461A-82CF-50C1978785DA" class="sect4">堆非常紧的情况下的行为</h4>
                  <div>
                     <p>当应用程序保留大量内存以致疏散找不到足够的空间复制时，疏散失败就会发生。撤离失败意味着G1试图通过将所有已经移动的对象保持在新位置来完成当前的垃圾收集，而不是复制任何尚未移动的对象，仅调整对象之间的引用。疏散失败可能会产生一些额外的开销，但通常应与其他年轻集合一样快。在撤离失败的垃圾收集之后，G1将恢复正常运行，而无需采取任何其他措施。G1假定疏散失败发生在垃圾收集即将结束时；也就是说，大多数对象已被移动，并且剩余空间足以继续运行应用程序，直到标记完成并开始空间回收。</p>
                     <p>如果这个假设不成立，那么G1最终将安排一个Full GC。这种类型的收集执行整个堆的就地压缩。这可能很慢。</p>
                     <p>有关在内存不足之前发出分配失败或完整GC的问题的更多信息，请参见<a href="garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" title="本节介绍了如何在不满足您的要求的情况下调整垃圾优先垃圾收集器（G1 GC）的行为。">垃圾优先垃圾收集器优化</a> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC" name="GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC"></a><h4 id="JSGCT-GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC" class="sect4">杂物</h4>
                  <div>
                     <p>大型物体是大于或等于一半区域大小的物体。如在所描述的当前的区域尺寸是符合人体工程学确定<a href="garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" title="本主题概述了特定于G1的最重要默认值及其默认值。他们使用G1粗略地概述了预期的行为和资源使用情况，没有任何其他选项。">为G1 GC人体工学默认值</a> ，除非使用集合中的部分中， <code class="codeph">-XX:G1HeapRegionSize</code>选项。
                     </p>
                     <div class="p">这些巨大的对象有时会以特殊方式处理：<ul style="list-style-type:disc">
                           <li>在上一代中，每个大型对象都被分配为一系列连续区域。对象本身的起点始终按该顺序位于第一个区域的起点。序列的最后一个区域中的所有剩余空间都将丢失以进行分配，直到回收整个对象为止。</li>
                           <li>通常，大型对象只能在清理暂停期间的标记结束时回收，或者在无法访问时在完全GC期间回收。但是，对于大型对象有特殊的规定，例如原始类型的数组， <code class="codeph">bool</code> ，各种整数和浮点值。如果在任何类型的垃圾回收暂停中许多对象都未引用大型对象，则G1机会尝试回收大型对象。默认情况下启用此行为，但您可以使用选项禁用它<code class="codeph">-XX:G1EagerReclaimHumongousObjects</code> 。
                           </li>
                           <li>庞大对象的分配可能导致垃圾回收暂停提前发生。G1在每次大型对象分配时检查“起始堆占用”阈值，如果当前占用量超过该阈值，则可能会立即强制执行初始标记年轻集合。</li>
                           <li>巨大的物体永远不会移动，即使在Full GC中也不会移动。这可能会导致过早的Full GC缓慢出现，或者由于区域空间的碎片而导致意外的内存不足情况，并留有大量可用空间。</li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C268549C-7D95-499C-9B24-A6670B44E49C" name="GUID-C268549C-7D95-499C-9B24-A6670B44E49C"></a><h4 id="JSGCT-GUID-C268549C-7D95-499C-9B24-A6670B44E49C" class="sect4">仅年轻阶段生成大小</h4>
                  <div>
                     <p>在仅年轻阶段，要收集的区域集（集合集）仅由年轻一代区域组成。G1总是在正常的年轻系列结束时为下一个突变者阶段确定年轻一代的大小。这样，G1可以满足使用设置的暂停时间目标<code class="codeph">-XX:MaxGCPauseTimeMillis</code>和<code class="codeph">-XX:PauseTimeIntervalMillis</code>根据对实际暂停时间的长期观察。它考虑了撤离规模相似的年轻一代需要多长时间。这包括诸如在收集过程中必须复制多少个对象以及这些对象之间如何互连的信息。
                     </p>
                     <p>如果没有其他限制，则G1会在介于<code class="codeph">-XX:G1NewSizePercent</code>和<code class="codeph">-XX:G1MaxNewSizePercent</code>确定满足暂停时间。有关如何解决长时间停顿的更多信息，请参见<a href="garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" title="本节介绍了如何在不满足您的要求的情况下调整垃圾优先垃圾收集器（G1 GC）的行为。">垃圾优先垃圾收集器调整</a> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8" name="GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8"></a><h4 id="JSGCT-GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8" class="sect4">空间填埋阶段生成大小</h4>
                  <div>
                     <p>在空间回收阶段，G1尝试在单个垃圾回收暂停中最大化旧一代中回收的空间量。将年轻一代的大小设置为允许的最小值，通常由<code class="codeph">-XX:G1NewSizePercent</code> ，并且添加任何旧的回收区域，直到G1确定添加更多区域将超过暂停时间目标为止。在特定的垃圾收集暂停中，G1按照回收效率的顺序添加旧的区域，优先顺序最高，然后剩余可用时间以获得最终的收集集。
                     </p>
                     <p>每个垃圾收集所占用的旧生成区域的数量在下端由要收集的潜在候选旧生成区域（ <span class="italic">收集集合候选区域</span> ）的数量除以空间回收阶段的长度，该长度由<code class="codeph">-XX:G1MixedGCCountTarget</code> 。集合集候选区域是所有旧的区域，其占用率低于<code class="codeph">-XX:G1MixedGCLiveThresholdPercent</code>在该阶段的开始。
                     </p>
                     <p>当可在集合集候选区域中回收的剩余空间量小于设置的百分比时，该阶段结束<code class="codeph">-XX:G1HeapWastePercent</code> 。
                     </p>
                     <p>有关G1将使用多少个旧区域以及如何避免长时间的混合收集暂停的更多信息，请参见<a href="garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" title="本节介绍了如何在不满足您的要求的情况下调整垃圾优先垃圾收集器（G1 GC）的行为。">垃圾优先的垃圾收集器优化</a> 。
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" name="GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016"></a><h3 id="JSGCT-GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" class="sect3">G1 GC的人体工程学默认值</h3>
               <div>
                  <p>本主题概述了特定于G1的最重要默认值及其默认值。他们使用G1粗略地概述了预期的行为和资源使用情况，没有任何其他选项。</p>
                  <div class="section">
                     <div class="tblformal" id="GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016__ERGONOMICDEFAULTSFORDETERMINISTICG1-9C74ED9D">
                        <p class="titleintable">表9-1符合人体工程学的默认值G1 GC</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="符合人体工程学的默认G1 GC" width="100%" border="1" summary="Ergonomic defaults for G1 GC" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="46%" id="d4197e489">选项和默认值</th>
                                 <th align="left" valign="bottom" width="54%" id="d4197e492">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e497" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:MaxGCPauseMillis=200</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e497 d4197e492 ">
                                    <p>最大暂停时间的目标。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e505" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:GCPauseTimeInterval</code> =<span class="italic"><ergo></ergo></span></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e505 d4197e492 ">
                                    <p>最大暂停时间间隔的目标。默认情况下，G1不设置任何目标，允许G1在极端情况下连续执行垃圾收集。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e516" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:ParallelGCThreads</code> =<span class="italic"><ergo></ergo></span></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e516 d4197e492 ">
                                    <p>垃圾回收暂停期间用于并行工作的最大线程数。这是通过以下方式从运行VM的计算机的可用线程数中得出的：如果进程可用的CPU线程数少于或等于8，则使用该数量。否则，将线程数的八分之八增加到最终线程数。</p>
                                    <p>在每个暂停的开始，最大使用的线程数进一步受到最大总堆大小的限制：G1每次使用的线程数不得超过一个<code class="codeph">-XX:HeapSizePerGCThread</code> Java堆容量。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e532" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:ConcGCThreads</code> = <span class="italic"><ergo></ergo></span> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e532 d4197e492 ">
                                    <p>用于并发工作的最大线程数。默认情况下，此值为<code class="codeph">-XX:ParallelGCThreads</code>除以4。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e547" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:+G1UseAdaptiveIHOP</code></p>
                                    <p><code class="codeph">-XX:InitiatingHeapOccupancyPercent=45</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e547 d4197e492 ">
                                    <p>用于控制初始堆占用的默认值指示该值的自适应确定已打开，并且对于前几个收集周期，G1将使用旧一代的占用率的45％作为标记开始阈值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e558" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:G1HeapRegionSize=<span class="codeinlineitalic"><ergo></span> </code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e558 d4197e492 ">
                                    <p>基于初始堆大小和最大堆大小的堆区域大小集。因此该堆包含大约2048个堆区域。堆区域的大小可以从1到32 MB不等，并且必须为2的幂。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e569" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:G1NewSizePercent=5</code></p>
                                    <p><code class="codeph">-XX:G1MaxNewSizePercent=60</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e569 d4197e492 ">总体上，年轻代的大小在这两个值之间变化，以当前使用的Java堆的百分比表示。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e579" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:G1HeapWastePercent=5</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e579 d4197e492 ">集合中允许的未回收空间设置为候选百分比。如果收集集合候选中的可用空间低于该间隔，则G1停止空间回收阶段。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e586" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:G1MixedGCCountTarget=8</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e586 d4197e492 ">许多集合中空间回收阶段的预期长度。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="46%" id="d4197e593" headers="d4197e489 ">
                                    <p><code class="codeph">-XX:G1MixedGCLiveThresholdPercent=85</code></p>
                                 </td>
                                 <td align="left" valign="top" width="54%" headers="d4197e593 d4197e492 ">在此空间回收阶段，不会收集活动对象占用率高于此百分比的旧区域。</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016__GUID-158B2AD4-B43D-4956-A474-67EAD0594471">
                        <p class="notep1">注意：</p><code class="codeph"><ergo></code>表示实际值是根据环境根据人体工程学确定的。
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF" name="GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF"></a><h3 id="JSGCT-GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF" class="sect3">与其他收藏家的比较</h3>
               <div>
                  <p>这是G1与其他收集器之间主要区别的摘要：</p>
                  <ul style="list-style-type:disc">
                     <li>并行GC只能从整体上压缩和回收旧一代中的空间。G1将这项工作逐步分配到多个较短的集合中。这大大缩短了暂停时间，但潜在地增加了吞吐量。</li>
                     <li>与CMS类似，G1同时执行部分旧空间回收。但是，CMS无法对旧的堆进行碎片整理，最终会遇到较长的Full GC。</li>
                     <li>G1可能比其他收集器具有更高的开销，由于其并发性而影响吞吐量。</li>
                  </ul>
                  <p>由于其工作方式，G1具有一些独特的机制来提高垃圾收集效率：</p>
                  <ul style="list-style-type:disc">
                     <li>G1可以在任何收集期间回收旧的一些完全空白的大区域。这样可以避免许多其他不必要的垃圾收集，而无需付出很多努力即可释放大量空间。</li>
                     <li>G1可以选择尝试同时对Java堆上的重复字符串进行重复数据删除。</li>
                  </ul>
                  <p>始终启用从旧一代回收空的大型对象。您可以使用以下选项禁用此功能<code class="codeph">-XX:-G1EagerReclaimHumongousObjects</code> 。默认情况下，禁用字符串重复数据删除。您可以使用选项启用它<code class="codeph">-XX:+G1EnableStringDeduplication</code> 。
                  </p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>