<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Using JConsole</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Monitoring and Management Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Monitoring and Management Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-se-monitoring-and-management-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T10:39:15-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2006, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95200-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="monitoring-and-management-using-jmx-technology.html" title="Previous" type="text/html">
      <link rel="next" href="using-platform-mbean-server-and-platform-mxbeans.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java SE Monitoring and Management Guide">
    <meta name="dcterms.isVersionOf" content="MANAGEMENT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="monitoring-and-management-using-jmx-technology.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="using-platform-mbean-server-and-platform-mxbeans.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">监控管理指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用JConsole</li>
            </ol>
            <a id="GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5" name="GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5"></a>
            
            <h2 id="JSMGM-GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5" class="sect2"><span class="enumeration_chapter">3</span>使用JConsole</h2>
         </header>
         <div class="ind">
            <div>
               <p>JConsole图形用户界面是一种监视工具，符合Java管理扩展（JMX）规范。JConsole使用Java虚拟机（Java VM）的广泛工具来提供有关在Java平台上运行的应用程序的性能和资源消耗的信息。</p>
               <p>JConsole已更新，可以显示Windows和GNOME桌面的外观（其他平台将显示标准的Java图形外观）。本文档中提供的屏幕截图取自Windows XP上运行的界面的一个实例。</p>
            </div>
            <div class="sect2"><a id="GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955" name="GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955"></a><h3 id="JSMGM-GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955" class="sect3">启动JConsole</h3>
               <div>
                  <p>的<code class="codeph">jconsole</code>可执行文件位于<code class="codeph"><span class="codeinlineitalic">JDK_HOME</span>/bin</code> ，在哪里<code class="codeph"><span class="codeinlineitalic">JDK_HOME</span></code>是Java开发工具包（JDK）的安装目录。如果此目录在您的系统路径中，那么您只需输入以下内容即可启动JConsole <code class="codeph">jconsole</code>在命令（shell）提示符下。否则，您必须输入可执行文件的完整路径。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE" name="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE"></a><h4 id="JSMGM-GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE" class="sect4">命令语法</h4>
                  <div>
                     <p>您可以使用JConsole监视本地应用程序（即与JConsole在同一系统上运行的本地应用程序）和远程应用程序（即在其他系统上运行的那些远程应用程序）。</p>
                     <div class="infoboxnote" id="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE__GUID-C7398F1E-047B-4390-B8DC-A94BAF6F98BE">
                        <p class="notep1">注意：</p>使用JConsole监视本地应用程序对于开发和创建原型很有用，但不建议在生产环境中使用，因为JConsole本身会消耗大量系统资源。建议进行远程监视，以将JConsole应用程序与要监视的平台隔离。
                     </div>
                     <p>看到<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSWOR-GUID-02BB4CB1-9C56-436A-9CEC-6D61984D48C1" target="_blank"><code class="codeph">jconsole</code></a> <span><cite>Java平台标准版工具参考</cite></span>中的完整语法。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE" name="GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE"></a><h5 id="JSMGM-GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE" class="sect5">设置本地监控</h5>
                     <div>
                        <p>使用以下命令启动JConsole：</p><pre class="pre codeblock"><code>% jconsole
</code></pre><p>JConsole启动时，选择JConsole可以连接到本地运行的所需Java应用程序。</p>
                        <p>如果要监视特定的应用程序，并且知道该应用程序的进程ID，则启动JConsole，使其连接到该应用程序。该应用程序必须使用与JConsole相同的用户ID运行。使用以下命令语法来启动JConsole以对特定应用程序进行本地监视：</p><pre class="pre codeblock"><code>% jconsole <span class="variable" translate="no">processID</span>
</code></pre><p><code class="codeph"><span class="variable" translate="no">processID</span></code>是应用程序的进程ID（PID）。您可以通过以下方式确定应用程序的PID：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在Solaris，Linux或macOS系统上，您可以使用<code class="codeph">ps</code>命令来查找的PID <code class="codeph">java</code>正在运行的实例。
                              </p>
                           </li>
                           <li>
                              <p>在Windows系统上，您可以使用任务管理器查找以下对象的PID <code class="codeph">java</code>要么<code class="codeph">javaw</code> 。
                              </p>
                           </li>
                           <li>
                              <p>您也可以使用<code class="codeph">jps</code>命令行实用程序来确定PID。看到<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSWOR-GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank"><code class="codeph">jps</code></a> <span><cite>Java平台标准版工具参考中的内容</cite></span> 。
                              </p>
                           </li>
                        </ul>
                        <p>例如，如果<code class="codeph">Notepad</code>应用程序是<code class="codeph">2956</code> ，然后使用以下命令启动JConsole：</p><pre class="pre codeblock"><code>% jconsole 2956
</code></pre><p>JConsole和应用程序都必须由同一用户执行。管理和监视系统使用操作系统的文件权限。如果未指定进程ID，则JConsole将自动检测所有本地Java应用程序，并显示一个对话框，供您选择要监视的应用程序（请参阅<a href="using-jconsole.html#GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC">连接到JMX Agent</a> ）。
                        </p>
                        <p>请参阅<a href="monitoring-and-management-using-jmx-technology.html#GUID-096EA656-4D07-4B09-A493-9EDEF83ABF28">本地监视和管理</a> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3668A05B-F532-4254-B7C9-8ACD87371162" name="GUID-3668A05B-F532-4254-B7C9-8ACD87371162"></a><h5 id="JSMGM-GUID-3668A05B-F532-4254-B7C9-8ACD87371162" class="sect5">设置远程监控</h5>
                     <div>
                        <p>要启动JConsole进行远程监视，请使用以下命令语法：</p><pre class="pre codeblock"><code>% jconsole <span class="variable" translate="no">hostName</span>:<span class="variable" translate="no">portNum</span>
</code></pre><p>的<code class="codeph"><span class="variable" translate="no">hostName</span></code>是运行应用程序的系统的名称，并且<code class="codeph"><span class="variable" translate="no">portNum</span></code>是在启动Java VM时启用JMX代理时指定的端口号。请参阅<a href="monitoring-and-management-using-jmx-technology.html#GUID-F08985BB-629A-4FBF-A0CB-8762DF7590E0">远程监视和管理</a> 。
                        </p>
                        <p>如果未指定主机名/端口号组合，则JConsole将显示一个连接对话框（正在<a href="using-jconsole.html#GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC">连接至JMX代理</a> ），以使您能够输入主机名和端口号。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E" name="GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E"></a><h5 id="JSMGM-GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E" class="sect5">设置安全的远程监控</h5>
                     <div>
                        <p>您也可以启动JConsole，以便在通过使用安全套接字层（SSL）进行保护的连接上执行监视。有关使用安全连接启动JConsole的命令，请参见<a href="monitoring-and-management-using-jmx-technology.html#GUID-8CF90313-3A12-45BD-93C1-3495139D0457">使用启用</a>了<a href="monitoring-and-management-using-jmx-technology.html#GUID-8CF90313-3A12-45BD-93C1-3495139D0457">SSL的JConsole进行远程监视</a> 。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC" name="GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC"></a><h4 id="JSMGM-GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC" class="sect4">连接到JMX代理</h4>
                  <div>
                     <p>如果使用指定要连接的JMX代理的参数启动JConsole，则它将自动开始监视指定的Java VM。您可以随时通过选择<span class="bold">Connection</span>和<span class="bold">New Connection</span>并输入必要的信息来连接到其他主机。
                     </p>
                     <p>否则，如果在启动JConsole时未提供任何参数，那么您看到的第一件事就是连接对话框。此对话框有两个选项，允许连接到本地或远程进程。</p>
                  </div>
                  <div class="sect4"><a id="GUID-08D3C963-BE4D-4007-A797-980E975EF526" name="GUID-08D3C963-BE4D-4007-A797-980E975EF526"></a><h5 id="JSMGM-GUID-08D3C963-BE4D-4007-A797-980E975EF526" class="sect5">将JConsole连接到本地进程</h5>
                     <div>
                        <p>如果启动JConsole时未提供要连接的特定JMX代理，则将看到以下对话框：</p>
                        <p id="GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05"><span class="bold">图3-1创建与本地进程的连接</span></p><img src="img/connect.gif" alt="用于创建与本地进程的连接的对话框" title="用于创建与本地进程的连接的对话框"><p>Local Process选项列出了以与JConsole相同的用户ID启动的，在本地系统上运行的所有Java VM，以及它们的进程ID和类或自变量信息。要将JConsole连接到您的应用程序，请选择要监视的应用程序，然后单击<span class="bold">Connect</span> 。本地进程列表包括在以下类型的Java VM中运行的应用程序：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>启用了管理代理的应用程序：这些应用程序包括Java SE平台上以<code class="codeph">-Dcom.sun.management.jmxremote</code>选项或与<code class="codeph">-Dcom.sun.management.jmxremote.port</code>指定的选项。此外，该列表还包括在Java SE平台上启动的，没有任何管理属性但由JConsole附加的任何应用程序，JConsole可以在运行时启用管理代理。
                              </p>
                           </li>
                           <li>
                              <p>在禁用管理代理的情况下<span class="variable" translate="no">attachable</span>应用程序：这些包含<span class="variable" translate="no">attachable</span>应用程序，该应用程序支持在运行时加载管理代理。可附加的应用程序包括在Java SE平台上启动的应用程序，它们支持Attach API。支持动态附加的应用程序不需要通过指定以下选项来启动管理代理： <code class="codeph">com.sun.management.jmxremote</code>要么<code class="codeph">com.sun.management.jmxremote.port</code>命令行中的选项。启动应用程序之前，JConsole不需要连接到管理代理。如果选择此应用程序，则会在屏幕上显示一条注释，说明建立连接后将启用管理代理。在<a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">图3-1</a>所示的示例连接对话框中，NetBeans IDE和JConsole在Java SE平台VM中启动。两者均以普通文本显示，这意味着JConsole可以连接到它们。在<a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">图3-1中</a> ，选择了JConsole，并且该注释可见。
                              </p>
                           </li>
                           <li>
                              <p>在管理代理已禁用的情况下不可附加的应用程序：这些包括在Java SE平台上启动的应用程序，没有<code class="codeph">-Dcom.sun.management.jmxremote</code>要么<code class="codeph">com.sun.management.jmxremote.port</code>选项。这些应用程序在表中显示为灰色，并且JConsole无法连接到它们。在<a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">图3-1</a>所示的示例连接对话框中， <code class="codeph">Anagrams</code>该应用程序是使用Java SE平台VM启动的，该VM没有任何用于启用JMX代理的管理属性，因此显示为灰色，无法选择。
                              </p>
                           </li>
                        </ul>
                        <p id="GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-2ATTEMPTINGTOCONNECTTOANAPP-8F10456B"><span class="bold">图3-2尝试在未启用管理代理的情况下连接到应用程序</span></p><img src="img/noconnect.gif" alt="尝试在未启用管理代理的情况下连接到本地进程。JConsole无法连接到此应用程序。" title="尝试在未启用管理代理的情况下连接到本地进程。JConsole无法连接到此应用程序。"><p>在<a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-2ATTEMPTINGTOCONNECTTOANAPP-8F10456B">图3-2</a>所示的示例连接对话框中，您可以看到<code class="codeph">Anagrams</code>已选择“应用程序”，但“ <span class="bold">连接”</span>仍显示为灰色，并且出现一条注释，通知您该过程未启用管理代理。JConsole无法连接到<code class="codeph">Anagrams</code>因为它不是使用正确的Java VM或正确的选项启动的。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5" name="GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5"></a><h5 id="JSMGM-GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5" class="sect5">将JConsole连接到远程进程</h5>
                     <div>
                        <p>当连接对话框打开时，您还可以选择连接到远程进程。</p>
                        <p><span class="bold">图3-3创建到远程进程的连接</span></p><img src="img/connectrem.gif" alt="用于创建与远程进程的连接的对话框" title="用于创建与远程进程的连接的对话框"><p>要监视在远程Java VM上运行的进程，您必须提供以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主机名：运行Java VM的计算机的名称。</p>
                           </li>
                           <li>
                              <p>端口号：启动Java VM时指定的JMX代理端口号。</p>
                           </li>
                           <li>
                              <p>用户名和密码：要使用的用户名和密码（仅当通过需要密码身份验证的JMX代理监视Java VM时才需要）。</p>
                           </li>
                        </ul>
                        <p>要设置JMX代理的端口号，请参阅<a href="monitoring-and-management-using-jmx-technology.html#GUID-E17343B0-FED2-4050-88D7-E4793E704ED5">启用就绪管理</a> 。
                        </p>
                        <p>请参阅<a href="monitoring-and-management-using-jmx-technology.html#GUID-D4CBA2D6-2E24-4856-A7D8-62B3DFFB76EA">使用密码和访问文件</a> 。
                        </p>
                        <p>要监视运行JConsole的Java VM，请单击“ <span class="bold">连接”</span> ，然后输入host作为<code class="codeph">localhost</code>和港口<code class="codeph">0</code> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4448A647-D858-443C-8DCF-49F552AA1745" name="GUID-4448A647-D858-443C-8DCF-49F552AA1745"></a><h5 id="JSMGM-GUID-4448A647-D858-443C-8DCF-49F552AA1745" class="sect5">使用JMX服务URL进行连接</h5>
                     <div>
                        <p>您还可以使用Remote Process选项通过指定其他JMX代理的JMX服务URL以及用户名和密码来连接到其他JMX代理。JMX服务URL的语法要求您提供用于建立连接的传输协议以及服务访问点。API文档中描述了JMX服务URL的完整语法。 <code class="codeph">javax.management.remote.JMXServiceURL</code> 。
                        </p>
                        <p><span class="bold">图3-4使用JMX服务URL连接到JMX代理</span></p><img src="img/connectadv.gif" alt="使用JMX服务URL连接到JMX代理" title="使用JMX服务URL连接到JMX代理"><p>如果JMX代理使用Java平台中未包含的连接器，则在运行JMX代理时必须将连接器类添加到类路径中。 <code class="codeph">jconsole</code>命令，如下所示：</p><pre class="pre codeblock"><code>% jconsole -J-Djava.class.path=<span class="variable" translate="no">JAVA_HOME</span>/lib/jconsole.jar:<span class="variable" translate="no">JAVA_HOME</span>/lib/tools.jar:<span class="variable" translate="no">connector-path</span>
</code></pre><p><code class="codeph"><span class="variable" translate="no">connector-path</span></code>是目录或Java归档（JAR）文件，其中包含JConsole要使用的JDK中未包含的连接器类。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245" name="GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245"></a><h4 id="JSMGM-GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245" class="sect4">呈现JConsole选项卡</h4>
                  <div>
                     <p>将JConsole连接到应用程序后，JConsole将显示以下六个选项卡：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>概述：显示有关Java VM和监视值的概述信息</p>
                        </li>
                        <li>
                           <p>内存：显示有关内存使用的信息</p>
                        </li>
                        <li>
                           <p>线程：显示有关线程使用的信息</p>
                        </li>
                        <li>
                           <p>类：显示有关类加载的信息</p>
                        </li>
                        <li>
                           <p>VM：显示有关Java VM的信息</p>
                        </li>
                        <li>
                           <p>MBean：显示有关MBean的信息</p>
                        </li>
                     </ul>
                     <p>使用JConsole右上角的绿色连接状态图标可断开与正在运行的Java VM的连接或重新连接至该Java VM。通过选择<span class="bold">Connection</span> ，然后从下拉菜单中选择<span class="bold">New Connection</span> ，可以一次连接到任意数量的正在运行的Java VM。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-E40C6B77-957C-455E-AAE1-D003C61331BA" name="GUID-E40C6B77-957C-455E-AAE1-D003C61331BA"></a><h5 id="JSMGM-GUID-E40C6B77-957C-455E-AAE1-D003C61331BA" class="sect5">查看概述信息</h5>
                     <div>
                        <p>“概述”选项卡在一个屏幕上显示有关CPU使用率，内存使用率，线程数以及Java VM中加载的类的图形监视信息。</p>
                        <p><span class="bold">图3-5概述选项卡</span></p><img src="img/overviewtab.gif" height="306" width="417" alt="JConsole概述选项卡" title="JConsole概述选项卡"><p>“概述”选项卡提供了一种简单的方法来关联以前仅在多个选项卡之间切换才可用的信息。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA" name="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA"></a><h5 id="JSMGM-GUID-FD200C08-6B7D-45F1-800F-306A68B655CA" class="sect5">保存图表数据</h5>
                     <div>
                        <p>JConsole允许您将图表中显示的数据保存在逗号分隔值（CSV）文件中。要保存图表中的数据，请右键单击任何图表，选择“ <span class="bold">将数据另存为...”</span> ，然后指定将在其中<span class="bold">保存数据</span>的文件。您可以通过这种方式保存JConsole的不同选项卡中显示的任何图表中的数据。
                        </p>
                        <p id="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA__GDKCK">CSV格式通常用于电子表格应用程序之间的数据交换。可以将CSV文件导入电子表格应用程序，并可以在这些应用程序中创建图表。数据显示为两个或多个命名列，其中第一列表示时间戳。将文件导入电子表格应用程序后，通常需要选择第一列并将其格式更改为<kbd class="userinput">date</kbd>要么<kbd class="userinput">date/time</kbd>作为适当的。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-139C787E-E180-4305-8A9F-B13D38149502" name="GUID-139C787E-E180-4305-8A9F-B13D38149502"></a><h5 id="JSMGM-GUID-139C787E-E180-4305-8A9F-B13D38149502" class="sect5">监视内存消耗</h5>
                     <div>
                        <p>内存选项卡提供有关内存消耗和内存池的信息。</p>
                        <p><span class="bold">图3-6内存选项卡</span></p><img src="img/memtab.gif" height="305" width="417" alt="“ JConsole内存”选项卡。" title="“ JConsole内存”选项卡。"><p>单击“内存”选项卡中的“ <span class="bold">执行GC”</span> ，可以随时执行垃圾回收。该图表显示了Java VM随时间推移对堆和非堆内存以及特定内存池的内存使用情况。可用的内存池取决于所使用的Java VM的版本。对于HotSpot Java VM，用于串行垃圾回收的内存池如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>Eden Space（堆）：最初从中为大多数对象分配内存的池。</p>
                           </li>
                           <li>
                              <p>幸存者空间（堆）：包含在Eden空间的垃圾回收中幸存的对象的池。</p>
                           </li>
                           <li>
                              <p>永久生成（堆）：包含幸存者空间中已存在一段时间的对象的池。</p>
                           </li>
                           <li>
                              <p>永久生成（非堆）：包含虚拟机本身所有反射数据的池，例如类和方法对象。对于使用类数据共享的Java VM，这一代被分为只读和读/写区域。</p>
                           </li>
                           <li>
                              <p>代码缓存（非堆）：HotSpot Java VM还包括代码缓存，其中包含用于编译和存储本机代码的内存。</p>
                           </li>
                        </ul>
                        <p>通过在“ <span class="bold">图表”</span>下拉菜单中选择所需的选项，可以显示不同的图表以绘制这些内存池的使用情况。另外，单击右下角的“堆”或“不堆”条形图将切换显示的图表。最后，您可以通过在“ <span class="bold">时间范围”</span>下拉菜单中选择所需的选项来指定跟踪内存使用情况的<span class="bold">时间范围</span> 。
                        </p>
                        <p>请参阅<a href="using-jconsole.html#GUID-A81AE10A-0693-462A-B129-5E292F46523E">垃圾收集</a> 。
                        </p>
                        <p><span class="bold">详细信息</span>区域显示了几个当前的内存指标：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>已用：当前使用的内存量，包括所有对象可访问和不可访问的内存。</p>
                           </li>
                           <li>
                              <p>承诺：保证Java VM可使用的内存量。提交的内存量可能会随时间变化。Java虚拟机可能会向系统释放内存，并且已提交的内存量可能会少于启动时最初分配的内存量。提交的内存量将始终大于或等于已使用的内存量。</p>
                           </li>
                           <li>
                              <p>最大值：可以用于内存管理的最大内存量。其值可能会更改或不确定。如果Java VM尝试将已使用的内存增加到大于已提交的内存，则内存分配可能会失败，即使所使用的数量小于或等于<code class="codeph">max</code> （例如，当系统虚拟内存不足时）。
                              </p>
                           </li>
                           <li>
                              <p>GC时间：花费在垃圾收集上的累积时间和调用总数。它可能有多行，每行代表Java VM中使用的一种垃圾收集器算法。</p>
                           </li>
                        </ul>
                        <p>右下方的条形图显示了堆和非堆内存中内存池消耗的内存。当使用的内存超过内存使用量阈值时，该条将变为红色。您可以通过以下属性设置内存使用量阈值<code class="codeph">MemoryMXBean</code> 。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-87E608D9-A384-485B-902E-B4867F132F3F" name="GUID-87E608D9-A384-485B-902E-B4867F132F3F"></a><h6 id="JSMGM-GUID-87E608D9-A384-485B-902E-B4867F132F3F" class="sect6">堆和非堆内存</h6>
                        <div>
                           <p>Java VM管理两种内存：堆内存和非堆内存，这两种内存都是在Java VM启动时创建的。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>堆内存：是Java VM从中为所有类实例和数组分配内存的运行时数据区域。堆的大小可以固定或可变。垃圾收集器是一个自动内存管理系统，可以回收对象的堆内存。</p>
                              </li>
                              <li>
                                 <p>非堆内存：包括在所有线程之间共享的方法区域以及Java VM的内部处理或优化所需的内存。它存储每个类的结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码。方法区域在逻辑上是堆的一部分，但是根据实现的不同，Java VM可能不会对其进行垃圾回收或压缩。像堆内存一样，方法区域的大小可以固定或可变。方法区域的内存不必是连续的。</p>
                              </li>
                           </ul>
                           <p>除了方法区域之外，Java VM可能需要用于内部处理或优化的内存，该内存也属于非堆内存。例如，即时（JIT）编译器需要内存来存储从Java VM代码转换而来的本机代码，以实现高性能。</p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832" name="GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832"></a><h6 id="JSMGM-GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832" class="sect6">内存池和内存管理器</h6>
                        <div>
                           <p>内存池和内存管理器是Java VM内存系统的关键方面。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>内存池：代表Java VM管理的内存区域。Java VM具有至少一个内存池，并且它可以在执行期间创建或删除内存池。内存池可以属于堆或非堆内存。</p>
                              </li>
                              <li>
                                 <p>内存管理器：管理一个或多个内存池。垃圾收集器是一种内存管理器，负责回收无法访问的对象使用的内存。一台Java VM可能具有一个或多个内存管理器。它可能在执行期间添加或删除内存管理器。一个内存池可以由多个内存管理器管理。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-A81AE10A-0693-462A-B129-5E292F46523E" name="GUID-A81AE10A-0693-462A-B129-5E292F46523E"></a><h6 id="JSMGM-GUID-A81AE10A-0693-462A-B129-5E292F46523E" class="sect6">垃圾收集</h6>
                        <div>
                           <p>垃圾回收（GC）是Java VM如何释放不再引用的对象所占用的内存。这是常见认为具有为活动引用的对象的<span class="variable" translate="no">live</span>和非参考或不可达的对象为<span class="variable" translate="no">dead</span> 。垃圾回收是释放死对象使用的内存的过程。GC使用的算法和参数可能会对性能产生巨大影响。
                           </p>
                           <p>Java HotSpot VM垃圾收集器使用分代GC。分代GC利用了大多数程序都遵循以下概括的观察结果：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它们创建许多寿命短的对象，例如迭代器和局部变量。</p>
                              </li>
                              <li>
                                 <p>它们创建了一些寿命很长的对象，例如高级持久性对象。</p>
                              </li>
                           </ul>
                           <p>分代GC将内存分为几代，并为每一代分配一个或多个内存池。当某个世代用完其分配的内存时，VM在该内存池上执行部分GC（也称为次要集合），以回收死对象使用的内存。此部分GC通常比完整GC快得多。</p>
                           <p>Java HotSpot VM定义了两代：年轻的一代（有时称为<span class="italic">托儿所</span> ）和老一代。年轻一代由一个<span class="italic">伊甸园空间</span>和两个<span class="italic">幸存者空间组成</span> 。VM首先将所有对象分配给Eden空间，大多数对象在那里死亡。执行次要GC时，VM会将所有剩余的对象从Eden空间移至幸存者空间之一。虚拟机移动对象是活足够长的生存空间在老一代的<span class="italic">终身</span>空间。当使用权的一代填满时，会有一个完整的GC，它通常要慢得多，因为它涉及所有活动对象。永久生成保留虚拟机本身的所有反射数据，例如类和方法对象。
                           </p>
                           <p>世代的默认排列<a href="using-jconsole.html#GUID-A81AE10A-0693-462A-B129-5E292F46523E__FIGURE3-7GENERATIONSOFDATAINGARBAGE-8F135AA1">如图3-7所示</a> 。
                           </p>
                           <p id="GUID-A81AE10A-0693-462A-B129-5E292F46523E__FIGURE3-7GENERATIONSOFDATAINGARBAGE-8F135AA1"><span class="bold">图3-7垃圾收集中的数据生成</span></p><img src="img/generations.gif" height="249" width="450" alt="垃圾收集器定义的不同代数据" title="垃圾收集器定义的不同代数据"><p>如果垃圾收集器已成为瓶颈，那么可以通过定制世代大小来提高性能。使用JConsole，可以通过试验垃圾收集器参数来研究性能指标的敏感性。请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSGCT-GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" target="_blank">《</a> <span><cite>Java Platform，标准版HotSpot虚拟机垃圾收集调优指南》中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSGCT-GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" target="_blank">性能注意事项</a> 。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3" name="GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3"></a><h6 id="JSMGM-GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3" class="sect6">监视线程使用</h6>
                        <div>
                           <p>线程选项卡提供有关线程使用的信息。</p>
                           <p><span class="bold">图3-8线程选项卡</span></p><img src="img/threadtab.gif" height="381" width="521" alt="“ JConsole线程”选项卡。" title="“ JConsole线程”选项卡。"><p>左下角的“线程”列表列出了所有活动线程。如果在“过滤器”字段中输入字符串，则“线程”列表将仅显示名称包含您输入的字符串的那些线程。单击“ <span class="bold">线程”</span>列表中的线程名称，以在右侧显示有关该线程的信息，包括线程名称，状态和堆栈跟踪。
                           </p>
                           <p>该图显示了一段时间内活动线程的数量。显示两行：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>红色：峰值线程数</p>
                              </li>
                              <li>
                                 <p>蓝色：活动线程数</p>
                              </li>
                           </ul>
                           <p>线程MXBean提供了“线程”选项卡未涵盖的其他一些有用的操作。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">findMonitorDeadlockedThreads</code> ：检测对象监视器锁上是否有任何线程死锁。该操作返回一个死锁线程ID数组。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">getThreadInfo</code> ：返回线程信息。这包括名称，堆栈跟踪和线程当前被阻止的监视器锁（如果有）以及哪个线程持有该锁，以及线程争用统计信息。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">getThreadCpuTime</code> ：返回给定线程消耗的CPU时间。
                                 </p>
                              </li>
                           </ul>
                           <p>您可以通过在MBeans树中选择<span class="bold">Threading MXBean</span> ，通过MBeans选项卡访问这些附加功能。该MXBean列出了用于访问被监视的Java VM中的线程信息的所有属性和操作。请参阅<a href="using-jconsole.html#GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87">监视和管理MBean</a> 。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236" name="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236"></a><h6 id="JSMGM-GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236" class="sect6">检测死锁线程</h6>
                        <div>
                           <p>要检查您的应用程序是否已陷入死锁（例如，您的应用程序似乎已挂起），可以通过单击<span class="bold">检测死锁</span>来<span class="bold">检测死锁的</span>线程。如果检测到任何死锁线程，这些线程将显示在“ <span class="bold">线程”</span>选项卡旁边的新选项卡中， <a href="using-jconsole.html#GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236__FIGURE3-9DEADLOCKEDTHREADS-8F1BA8FE">如图3-9</a>所示。
                           </p>
                           <p id="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236__FIGURE3-9DEADLOCKEDTHREADS-8F1BA8FE"><span class="bold">图3-9死锁线程</span></p><img src="img/deadlock.gif" height="275" width="504" alt="JConsole检测到死锁的线程。" title="JConsole检测到死锁的线程。"><p><span class="bold">“检测死锁”</span>将检测涉及对象监视器和<code class="codeph">java.util.concurrent</code>可拥有的同步器（请参阅API规范文档中的<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/management/LockInfo.html" target="_blank"><span class="apiname">java.lang.management。LockInfo</span></a> ）。监控支持<code class="codeph">java.util.concurrent</code>从Java SE 6.0版本开始添加了锁。如果JConsole连接到Java SE 5.0 VM，则“检测死锁”机制将仅找到与对象监视器相关的死锁。JConsole将不会显示与可拥有的同步器相关的任何死锁。
                           </p>
                           <p>请参阅API文档以获取<code class="codeph">java.lang.Thread</code>有关线程和守护程序线程的更多信息。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C" name="GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C"></a><h5 id="JSMGM-GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C" class="sect5">监视类加载</h5>
                     <div>
                        <p>“类”选项卡显示有关类加载的信息。</p>
                        <p><span class="bold">图3-10类别选项卡</span></p><img src="img/classtab.gif" height="383" width="522" alt="该图像提供有关已加载的类数的信息。" title="该图像提供有关已加载的类数的信息。"><p>该图表绘制了随时间推移加载的类的数量。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>红线是已加载的类的总数（包括随后卸载的类）。</p>
                           </li>
                           <li>
                              <p>蓝线是当前加载的类数。</p>
                           </li>
                        </ul>
                        <p>选项卡底部的“详细信息”部分显示自Java VM启动以来已加载的类总数，当前已加载的数量以及已卸载的数量。通过选中右上角的复选框，可以将类加载的跟踪设置为详细输出。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2" name="GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2"></a><h5 id="JSMGM-GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2" class="sect5">查看虚拟机信息</h5>
                     <div>
                        <p>“ VM摘要”选项卡提供有关Java VM的信息。</p>
                        <p><span class="bold">图3-11虚拟机摘要选项卡</span></p><img src="img/vmtab.gif" height="459" width="487" alt="“ JConsole VM摘要”选项卡。" title="“ JConsole VM摘要”选项卡。"><p>此选项卡中显示的信息包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">摘要</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>正常运行时间：自Java VM启动以来的总时间。</p>
                                 </li>
                                 <li>
                                    <p>进程CPU时间：自Java VM启动以来已消耗的CPU时间总量。</p>
                                 </li>
                                 <li>
                                    <p>总编译时间：JIT编译花费的总累积时间。Java VM确定何时进行JIT编译。Hotspot VM使用自适应编译，其中VM使用标准解释器启动应用程序，然后在运行时分析代码以检测性能瓶颈或热点。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">线程数</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>活动线程：当前活动守护程序线程数和非守护程序线程数。</p>
                                 </li>
                                 <li>
                                    <p>峰值：自Java VM启动以来活动线程数最高。</p>
                                 </li>
                                 <li>
                                    <p>守护程序线程：当前活动的守护程序线程数。</p>
                                 </li>
                                 <li>
                                    <p>已启动的线程总数：自Java VM启动以来已启动的线程总数，包括守护程序，非守护程序和终止的线程。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">班级</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>当前加载的类：当前加载到内存中的类数。</p>
                                 </li>
                                 <li>
                                    <p>已加载的类总数：自Java VM启动以来，已加载到内存中的类总数，包括随后卸载的类总数。</p>
                                 </li>
                                 <li>
                                    <p>卸载的类总数：自Java VM启动以来从内存中卸载的类数。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">记忆</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>当前堆大小：堆当前占用的千字节数。</p>
                                 </li>
                                 <li>
                                    <p>承诺的内存：分配给堆使用的内存总量。</p>
                                 </li>
                                 <li>
                                    <p>最大堆大小：堆占用的最大千字节数。</p>
                                 </li>
                                 <li>
                                    <p>待完成的对象数：待完成的对象数。</p>
                                 </li>
                                 <li>
                                    <p>垃圾收集器：有关垃圾收集的信息，包括垃圾收集器的名称，执行的收集次数以及执行GC所花费的总时间。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">操作系统</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>物理内存总量：操作系统拥有的随机访问内存（RAM）的数量。</p>
                                 </li>
                                 <li>
                                    <p>可用物理内存：操作系统可用的可用RAM量。</p>
                                 </li>
                                 <li>
                                    <p>承诺的虚拟内存：保证正在运行的进程可用的虚拟内存量。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">其他资讯</span></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>VM参数：应用程序传递给Java VM的输入参数，不包括main方法的参数。</p>
                                 </li>
                                 <li>
                                    <p>类路径：系统类加载器用来搜索类文件的类路径。</p>
                                 </li>
                                 <li>
                                    <p>库路径：加载库时要搜索的路径列表。</p>
                                 </li>
                                 <li>
                                    <p>引导类路径：引导类加载器用来搜索类文件的路径。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87" name="GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87"></a><h5 id="JSMGM-GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87" class="sect5">监视和管理MBean</h5>
                     <div>
                        <p>“ MBeans”选项卡以通用方式显示有关在平台MBean服务器上注册的所有MBean的信息。MBeans选项卡允许您访问平台MXBean的完整工具集，包括其他选项卡中不可见的工具。另外，您可以使用“ MBeans”选项卡监视和管理应用程序的MBean。</p>
                        <p><span class="bold">图3-12 MBeans选项卡</span></p><img src="img/mbeantab.gif" height="381" width="520" alt="JConsole MBeans选项卡。" title="JConsole MBeans选项卡。"><p>左侧的树显示了当前正在运行的所有MBean。当您在树中选择一个MBean时，其<code class="codeph">MBeanInfo</code>和它的MBean <code class="codeph">Descriptor</code>都显示在右侧，并且任何属性，操作或通知都显示在其下方的树中。
                        </p>
                        <p>可从JConsole的MBeans选项卡访问所有平台MXBean及其各种操作和属性。</p>
                     </div>
                     <div class="sect5"><a id="GUID-83749035-6012-446A-A6BD-6D650A37F076" name="GUID-83749035-6012-446A-A6BD-6D650A37F076"></a><h6 id="JSMGM-GUID-83749035-6012-446A-A6BD-6D650A37F076" class="sect6">构造MBean树</h6>
                        <div>
                           <p>缺省情况下，MBean基于对象名称显示在树中。JConsole在将对象添加到MBean树时，将保留在创建对象名称时指定的键属性顺序。JConsole将用于构建MBean树的确切密钥属性列表将是该方法返回的列表。 <code class="codeph">ObjectName.getKeyPropertyListString()</code> ，带有<code class="codeph">type</code>作为第一把钥匙<code class="codeph">j2eeType</code> （如果存在）作为第二个键。
                           </p>
                           <p>但是，依靠默认的顺序<code class="codeph">ObjectName</code> JConsole呈现MBean树时，关键属性有时会导致意外行为。例如，如果两个对象名称具有相似的键，但是它们的键顺序不同，则将不会在MBean树的相同节点下创建对应的MBean。
                           </p>
                           <p>例如，假设您创建<code class="codeph">Triangle</code>具有以下名称的MBean对象。
                           </p><pre class="pre codeblock"><code>com.sun.example:type=Triangle,side=isosceles,name=1
com.sun.example:type=Triangle,name=2,side=isosceles
com.sun.example:type=Triangle,side=isosceles,name=3
</code></pre><p>就JMX技术而言，将以完全相同的方式处理这些对象。对象名称中键的顺序与JMX技术没有区别。但是，如果JConsole连接到这些MBean并使用默认的MBean树呈现，则该对象<code class="codeph">com.sun.example:type=Triangle,name=2,side=isosceles</code>最终将在<code class="codeph">Triangle</code>节点，在称为<code class="codeph">2</code> ，而该子节点将包含一个名为<code class="codeph">isosceles</code> 。另外两个等腰三角形<code class="codeph">name=1</code>和<code class="codeph">name=3</code> ，将归类为<code class="codeph">Triangle</code>在另一个称为<code class="codeph">isosceles</code> ， <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5">如图3-13</a>所示。
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5"><span class="bold">图3-13意外的MBean树呈现示例</span></p><img src="img/mbeantree1.gif" alt="意外的MBean树呈现示例" title="意外的MBean树呈现示例"><p>为了避免此问题，可以在命令行上启动JConsole时通过提供有序键属性列表来指定MBean在树中的显示顺序。这是通过设置系统属性来实现的<code class="codeph">com.sun.tools.jconsole.mbeans.keyPropertyList</code> ，如以下命令所示。
                           </p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=<span class="variable" translate="no">key</span>[,<span class="variable" translate="no">key</span>]*
</code></pre><p>键属性列表系统属性按选择顺序获取逗号分隔的键列表，其中<code class="codeph"><span class="variable" translate="no">key</span></code>必须是代表对象名称键的字符串或空字符串。如果列表中指定的键不适用于特定的MBean，则该键将被丢弃。如果MBean的键数超过键属性列表中指定的键数，则由以下命令返回的值定义的键顺序<code class="codeph">ObjectName.getKeyPropertyListString()</code>将用于完成由定义的按键顺序<code class="codeph">keyPropertyList</code> 。因此，指定一个空的键列表意味着JConsole将按照它们在MBean的显示顺序来显示键。 <code class="codeph">ObjectName</code> 。
                           </p>
                           <p>所以，回到例子<code class="codeph">Triangle</code>前面引用的MBean，可以通过指定JBean启动JConsole <code class="codeph">keyPropertyList</code>系统属性，以便所有MBean都将根据它们的分组<code class="codeph">side</code>首先是关键财产， <code class="codeph">name</code>关键属性第二。为此，请使用以下命令启动JConsole：</p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=side,name
</code></pre><p>在指定此系统属性的情况下启动JConsole将产生MBean树， <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">如图3-14</a>所示。
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F"><span class="bold">图3-14使用keyPropertyList构造的MBean树示例</span></p><img src="img/mbeantree2.gif" alt="使用keyPropertyList构造的MBean树示例" title="使用keyPropertyList构造的MBean树示例"><p>在<a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">图3-14中</a> ， <code class="codeph">side</code>钥匙先到，然后是<code class="codeph">name</code>键。的<code class="codeph">type</code>由于密钥属性列表中未指定密钥，因此密钥排在最后，因此MBean树算法对其余密钥应用了原始密钥顺序。因此， <code class="codeph">type</code>密钥被添加到由密钥定义的密钥之后的末尾<code class="codeph">keyPropertyList</code>系统属性。
                           </p>
                           <p>根据《 <a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html" target="_blank">JMX最佳实践指南》</a>定义的对象名称约定， <code class="codeph">type</code>钥匙应该永远放在第一位。您必须使用以下系统属性启动JConsole：</p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=type,side,name
</code></pre><p>先前的命令将使JConsole渲染Triangle MBean的MBean树， <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-15EXAMPLEOFMBEANTREECONSTRU-8F2064BC">如图3-15</a>所示。
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-15EXAMPLEOFMBEANTREECONSTRU-8F2064BC"><span class="bold">图3-15遵循JMX最佳实践构造的MBean树示例</span></p><img src="img/mbeantree3.gif" alt="尊重JMX最佳实践的MBean树示例" title="尊重JMX最佳实践的MBean树示例"><p>这比<a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5">图3-13</a>和<a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">图3-14</a>中<a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5">所示</a>的MBean树可理解。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428" name="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428"></a><h6 id="JSMGM-GUID-1C3C7299-FBD2-48FC-A940-2622953B4428" class="sect6">MBean属性</h6>
                        <div>
                           <p>选择“ <span class="bold">属性”</span>节点将显示MBean的所有属性。<a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-16VIEWINGALLMBEANATTRIBUTES-8F220721">图3-16</a>显示了Threading平台MXBean的所有属性。
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-16VIEWINGALLMBEANATTRIBUTES-8F220721"><span class="bold">图3-16查看所有MBean属性</span></p><img src="img/allattributes.gif" height="298" width="481" alt="查看线程MBean的属性。" title="查看线程MBean的属性。"><p>从树中选择一个单独的MBean属性，然后显示该属性的值， <code class="codeph">MBeanAttributeInfo</code> ，并在右窗格中关联了Descriptor， <a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-17VIEWINGANINDIVIDUALMBEANA-8F2218BC">如图3-17所示</a> 。
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-17VIEWINGANINDIVIDUALMBEANA-8F2218BC"><span class="bold">图3-17查看单个MBean属性</span></p><img src="img/attributes.gif" height="381" width="521" alt="在“ MBeans”选项卡中查看MBean属性。" title="在“ MBeans”选项卡中查看MBean属性。"><p>如果属性值以粗体显示，则可以双击该属性值来显示有关该属性的其他信息。例如，如果您单击<code class="codeph">HeapMemoryUsage</code>的属性<code class="codeph">java.lang.Memory</code> MBean，然后您将看到一个类似于<a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-18DISPLAYINGATTRIBUTEVALUES-8F225584">图3-18</a>的图表。
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-18DISPLAYINGATTRIBUTEVALUES-8F225584"><span class="bold">图3-18显示属性值</span></p><img src="img/chart.gif" alt="查看MBean属性的值。" title="查看MBean属性的值。"><p>双击数值属性值将显示一个图表，该图表绘制该数值的变化。例如，双击垃圾收集器MBean的<span class="bold">CollectionTime</span>属性。 <code class="codeph">PS Marksweep</code>将标出执行垃圾收集所花费的时间。
                           </p>
                           <p>您还可以使用JConsole设置可写属性的值。可写属性的值以蓝色显示。在这里，您可以看到Memory MBean的Verbose属性。</p>
                           <p><span class="bold">图3-19设置可写属性值</span></p><img src="img/writeableattrib.gif" alt="设置MBean的可写属性值。" title="设置MBean的可写属性值。"><p>您可以通过单击属性然后进行编辑来设置属性。例如，要在JConsole中启用或禁用垃圾收集器的详细跟踪，请在<span class="bold">MBeans</span>选项卡中选择<span class="bold">Memory MXBean</span>并设置<code class="codeph">Verbose</code>归因于<code class="codeph">true</code>要么<code class="codeph">false</code> 。同样，加载MXBean的类也具有<code class="codeph">Verbose</code>属性，可以设置为启用或禁用类加载详细跟踪。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4" name="GUID-1714F49C-7637-41EB-B576-23861C55B8D4"></a><h6 id="JSMGM-GUID-1714F49C-7637-41EB-B576-23861C55B8D4" class="sect6">MBean操作</h6>
                        <div>
                           <p>选择“ <span class="bold">操作”</span>节点将显示MBean的所有操作。MBean操作显示为按钮，您可以单击以调用该操作。 <a href="using-jconsole.html#GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-20VIEWINGALLMBEANOPERATIONS-8F228DD0"> 图3-20</a>显示了Threading平台MXBean的所有操作。
                           </p>
                           <p id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-20VIEWINGALLMBEANOPERATIONS-8F228DD0"><span class="bold">图3-20查看所有MBean操作</span></p><img src="img/alloperations.gif" height="437" width="586" alt="查看线程平台MXBean的操作。" title="查看线程平台MXBean的操作。"><p>在树中选择单个MBean操作将显示用于调用MBean操作的按钮，以及该操作的<code class="codeph">MBeanOperationInfo</code>及其描述符， <a href="using-jconsole.html#GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-21VIEWINGINDIVIDUALMBEANOPE-8F22BED4">如图3-21</a>所示。
                           </p>
                           <p id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-21VIEWINGINDIVIDUALMBEANOPE-8F22BED4"><span class="bold">图3-21查看单个MBean操作</span></p><img src="img/operations.gif" height="383" width="520" alt="调用MBean的操作。" title="调用MBean的操作。"></div>
                     </div>
                     <div class="sect5"><a id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7" name="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7"></a><h6 id="JSMGM-GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7" class="sect6">MBean通知</h6>
                        <div>
                           <p>您可以通过选择左侧树中的“ <span class="bold">通知”</span>节点，然后单击右侧显示的“ <span class="bold">订阅”</span>按钮来订阅以接收通知。收到的通知数显示在方括号中，并且在收到新通知时，“通知”节点本身将以粗体显示。Memory平台MXBean的通知<a href="using-jconsole.html#GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-22VIEWINGMBEANNOTIFICATIONS-8F237C7D">如图3-22</a>所示。
                           </p>
                           <p id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-22VIEWINGMBEANNOTIFICATIONS-8F237C7D"><span class="bold">图3-22查看MBean通知</span></p><img src="img/allnotifications.gif" height="275" width="612" alt="查看MBean的通知。" title="查看MBean的通知。"><p>选择单个MBean通知将显示<code class="codeph">MBeanNotificationInfo</code>在右侧窗格中， <a href="using-jconsole.html#GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-23VIEWINGINDIVIDUALMBEANNOT-8F23872C">如图3-23</a>所示。
                           </p>
                           <p id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-23VIEWINGINDIVIDUALMBEANNOT-8F23872C"><span class="bold">图3-23查看单个MBean通知</span></p><img src="img/notifications.gif" height="381" width="522" alt="订阅以接收MBean通知。" title="订阅以接收MBean通知。"></div>
                     </div>
                     <div class="sect5"><a id="GUID-A9086B53-310E-45E0-9B67-8DB2806DE009" name="GUID-A9086B53-310E-45E0-9B67-8DB2806DE009"></a><h6 id="JSMGM-GUID-A9086B53-310E-45E0-9B67-8DB2806DE009" class="sect6">热点诊断MXBean</h6>
                        <div>
                           <p>JConsole的MBeans选项卡还允许您告诉HotSpot VM执行堆转储，并使用以下命令获取或设置VM选项： <code class="codeph">HotSpotDiagnostic</code> MXBean。
                           </p>
                           <p><span class="bold">图3-24查看HotSpot诊断MBean</span></p><img src="img/hotspotdiagnostic.gif" height="382" width="521" alt="使用HotSpot VM Diagnostic MBean执行堆转储。" title="使用HotSpot VM Diagnostic MBean执行堆转储。"><p>您可以通过调用<code class="codeph">com.sun.management.HotSpotDiagnostic</code> MXBean的<code class="codeph">dumpHeap</code>操作。此外，您可以指定<code class="codeph">HeapDumpOnOutOfMemoryError</code> Java VM选项使用<code class="codeph">setVMOption</code>操作，以便VM每次收到<code class="codeph">OutOfMemoryError</code> 。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7" name="GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7"></a><h5 id="JSMGM-GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7" class="sect5">创建自定义标签</h5>
                     <div>
                        <p>除了现有的标准选项卡，您还可以向JConsole添加自己的自定义选项卡，以执行自己的监视活动。JConsole插件API提供了一种机制，通过该机制，您可以例如添加一个选项卡来访问您自己的应用程序的MBean。JConsole插件API定义了<code class="codeph">com.sun.tools.jconsole.JConsolePlugin</code>您可以扩展以构建自定义插件的抽象类。
                        </p>
                        <p>如前所述，您的插件必须扩展<code class="codeph">JConsolePlugin,</code>并实施<code class="codeph">JConsolePlugin</code><code class="codeph">getTabs</code>和<code class="codeph">newSwingWorker</code>方法。的<code class="codeph">getTabs</code>方法返回要添加到JConsole的选项卡的列表，或者返回一个空列表。的<code class="codeph">newSwingWorker</code>方法返回<code class="codeph">SwingWorker</code>负责插件的GUI更新。
                        </p>
                        <p>您必须在Java归档（JAR）文件中提供该插件，该文件包含一个名为<code class="codeph">META-INF/services/com.sun.tools.jconsole.JConsolePlugin</code> 。这个<code class="codeph">JConsolePlugin</code>文件本身包含要添加为新的JConsole选项卡的插件的所有标准类名的列表。JConsole使用服务提供者加载工具来查找和加载插件。您可以有多个插件，每个插件中有一个条目<code class="codeph">JConsolePlugin</code> 。
                        </p>
                        <p>要将新的自定义插件加载到JConsole中，请使用以下命令启动JConsole：</p><pre class="pre codeblock"><code>%  jconsole -pluginpath <span class="variable" translate="no">plugin-path</span>
</code></pre><p>在上一个命令中， <code class="codeph"><span class="variable" translate="no">plugin-path</span></code>指定要查找的JConsole插件的路径。这些路径可以是目录名或JAR文件，并且可以使用平台的标准分隔符指定多个路径。
                        </p>
                        <p>Java SE <span>11</span>平台提供了一个示例JConsole插件。的<code class="codeph">JTop</code> application是一个JDK演示（演示），它显示了应用程序中运行的所有线程的CPU使用率。该演示对于识别具有较高CPU占用率的线程很有用，并且已更新为可以用作JConsole插件和独立GUI。 <code class="codeph">JTop</code>与Java SE <span>11</span>平台捆绑在一起，作为演示应用程序。您可以通过运行以下命令来使用JTop插件运行JConsole：</p><pre class="pre codeblock"><code>
% <span class="variable" translate="no">JDK_HOME</span>/bin/jconsole -pluginpath <span class="variable" translate="no">JDK_HOME</span>/demo/management/JTop/JTop.jar
</code></pre><p>如果连接到此JConsole实例，则将看到<code class="codeph">JTop</code>选项卡已添加，显示正在运行的各个线程的CPU使用率。
                        </p>
                        <p><span class="bold">图3-25查看自定义插件选项卡</span></p><img src="img/plugin.gif" height="250" width="516" alt="一个定制选项卡，显示已连接到JTop示例程序。" title="一个定制选项卡，显示已连接到JTop示例程序。"></div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>