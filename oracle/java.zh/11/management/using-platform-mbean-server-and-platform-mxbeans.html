<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Using the Platform MBean Server and Platform MXBeans</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Monitoring and Management Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Monitoring and Management Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-se-monitoring-and-management-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T10:39:15-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2006, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95200-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="using-jconsole.html" title="Previous" type="text/html">
      <link rel="next" href="java-discovery-protocol.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java SE Monitoring and Management Guide">
    <meta name="dcterms.isVersionOf" content="MANAGEMENT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-jconsole.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="java-discovery-protocol.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">监控管理指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用平台MBean服务器和平台MXBean</li>
            </ol>
            <a id="GUID-6239456C-FD46-46EA-96EF-DC02800D58EC" name="GUID-6239456C-FD46-46EA-96EF-DC02800D58EC"></a>
            
            <h2 id="JSMGM-GUID-6239456C-FD46-46EA-96EF-DC02800D58EC" class="sect2"><span class="enumeration_chapter">4</span>使用平台MBean服务器和平台MXBean</h2>
         </header>
         <div class="ind">
            <div>
               <p>本主题介绍了作为Java平台标准版（Java SE）的一部分提供的MBean服务器和MXBean，它们可用于监视和管理。Java管理扩展（JMX）技术MBean和MBean服务器在<a href="overview-java-se-monitoring-and-management.html#GUID-EA3CFF69-F0D3-47AB-9AED-EF1CBF7F2B24" title="Java虚拟机（Java VM）用于监视和管理，启用了内置（或即用型）管理功能，可以远程和本地访问这些功能。">Java SE监视和管理概述中</a>进行了简要介绍。请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSJMX-GUID-72DCB4C1-93F8-4F37-B46E-2C708139C8A5" target="_blank">《</a> <span><cite>Java平台标准版Java管理扩展指南》中的“</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&id=JSJMX-GUID-72DCB4C1-93F8-4F37-B46E-2C708139C8A5" target="_blank">JMX技术简介</a> <span><cite>”</cite></span> 。
               </p>
            </div>
            <div class="sect2"><a id="GUID-656AF20D-E386-4F75-9079-9B26F9EDCD68" name="GUID-656AF20D-E386-4F75-9079-9B26F9EDCD68"></a><h3 id="JSMGM-GUID-656AF20D-E386-4F75-9079-9B26F9EDCD68" class="sect3">使用平台MBean服务器</h3>
               <div>
                  <p>MBean服务器是MBean的存储库，它提供管理应用程序对MBean的访问。应用程序不直接访问MBean，而是使用其唯一的特性通过MBean服务器访问它们。 <code class="codeph">ObjectName</code>类。MBean服务器实现接口<code class="codeph">javax.management.MBeanServer</code> 。
                  </p>
                  <p><span class="variable" translate="no">platform MBean server</span>是Java SE 5.0中引入的，它是内置在Java虚拟机（Java VM）中的MBean服务器。平台MBean服务器可以由Java VM中运行的所有托管组件共享。您可以使用来访问平台MBean服务器<code class="codeph">java.lang.management.ManagementFactory</code>方法<code class="codeph">getPlatformMBeanServer</code> 。当然，您也可以使用以下命令创建自己的MBean服务器<code class="codeph">javax.management.MBeanServerFactory</code>类。但是，通常不需要一个以上的MBean服务器，因此建议使用平台MBean服务器。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-64A12637-275D-42C7-AB31-2170F424DA2E" name="GUID-64A12637-275D-42C7-AB31-2170F424DA2E"></a><h3 id="JSMGM-GUID-64A12637-275D-42C7-AB31-2170F424DA2E" class="sect3">访问平台MXBean</h3>
               <div>
                  <p><span class="variable" translate="no">platform MXBean</span>是用于监视和管理Java VM的MBean。每个MXBean都封装了VM功能的一部分。<a href="overview-java-se-monitoring-and-management.html#GUID-762C5224-0541-4A1B-A314-F3D55311C124__PLATFORMMXBEANS-4D30B595" title="平台MXBean">表1-1</a>中提供了平台随附的MXBean的完整列表。
                  </p>
                  <p>管理应用程序可以通过三种不同的方式访问平台MXBean：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>从直接访问<code class="codeph">ManagementFactory</code>类</p>
                     </li>
                     <li>
                        <p>从MXBean代理直接访问</p>
                     </li>
                     <li>
                        <p>来自的间接访问<code class="codeph">MBeanServerConnection</code>类</p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA" name="GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA"></a><h4 id="JSMGM-GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA" class="sect4">使用ManagementFactory类访问平台MXBean</h4>
                  <div>
                     <p>应用程序可以直接调用与自身在同一Java VM中运行的平台MXBean的方法。要进行直接调用，您可以使用的静态方法<code class="codeph">ManagementFactory</code>类。的<code class="codeph">ManagementFactory</code>班有<code class="codeph">accessor</code>每个不同平台MXBean的方法，例如， <code class="codeph">getClassLoadingMXBean()</code> ， <code class="codeph">getGarbageCollectorMXBeans()</code> ， <code class="codeph">getRuntimeMXBean()</code> ， 等等。如果平台MXBean不止一个，则该方法返回找到的平台MXBean的列表。
                     </p>
                     <p>例如， <a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA__EXAMPLE4-1ACCESSINGAPLATFORMMXBEANU-8F3B94EC">示例4-1</a>使用了静态方法<code class="codeph">ManagementFactory</code>获得平台MXBean <code class="codeph">RuntimeMXBean</code> ，然后从平台MXBean获取供应商名称。
                     </p>
                     <p id="GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA__EXAMPLE4-1ACCESSINGAPLATFORMMXBEANU-8F3B94EC">示例4-1使用ManagementFactory类访问平台MXBean</p><pre class="pre codeblock"><code>RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();
String vendor = mxbean.getVmVendor(); 
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57" name="GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57"></a><h4 id="JSMGM-GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57" class="sect4">使用MXBean代理访问平台MXBean</h4>
                  <div>
                     <p>应用程序还可以使用MXBean代理调用平台MXBean方法。为此，您必须构造一个MXBean代理实例，该实例通过调用静态方法将方法调用转发到给定的MBean服务器。 <code class="codeph">ManagementFactory.newPlatformMXBeanProxy()</code> 。应用程序通常构造一个代理，以获取对另一个Java VM的平台MXBean的远程访问。</p>
                     <p>例如， <a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57__EXAMPLE4-2ACCESSINGAPLATFORMMXBEANV-8F3C48A5">示例4-2</a>执行与<a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA__EXAMPLE4-1ACCESSINGAPLATFORMMXBEANU-8F3B94EC">示例4-1</a>完全相同的操作，但是这次它使用MXBean代理。
                     </p>
                     <p id="GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57__EXAMPLE4-2ACCESSINGAPLATFORMMXBEANV-8F3C48A5">示例4-2使用MXBean代理访问平台MXBean</p><pre class="pre codeblock"><code>MBeanServerConnection mbs;
...
// Get a MBean proxy for RuntimeMXBean interface
RuntimeMXBean proxy =
    ManagementFactory.newPlatformMXBeanProxy(mbs,ManagementFactory.RUNTIME_MXBEAN_NAME,RuntimeMXBean.class);
// Get standard attribute "VmVendor"
String vendor = proxy.getVmVendor();
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-7D0C32D9-7317-42B5-8F39-301A977A3ED5" name="GUID-7D0C32D9-7317-42B5-8F39-301A977A3ED5"></a><h4 id="JSMGM-GUID-7D0C32D9-7317-42B5-8F39-301A977A3ED5" class="sect4">使用MBeanServerConnection类访问平台MXBean</h4>
                  <div>
                     <p>应用程序可以通过以下方式间接调用平台MXBean方法： <code class="codeph">MBeanServerConnection</code>连接到另一个正在运行的Java VM的平台MBean服务器的接口。您使用<code class="codeph">MBeanServerConnection</code>类<code class="codeph">getAttribute()</code>提供MBean的方法来获取平台MXBean的属性的方法<code class="codeph">ObjectName</code>并将属性名称作为参数。
                     </p>
                     <p>例如， <a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-7D0C32D9-7317-42B5-8F39-301A977A3ED5__EXAMPLE4-3ACCESSINGAPLATFORMMXBEANU-8F3CBD97">例4-3</a>执行与<a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-96CEF00E-83E8-4505-B6E1-6E89213FB0CA__EXAMPLE4-1ACCESSINGAPLATFORMMXBEANU-8F3B94EC">例4-1</a>和<a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-4C287D90-7F37-41FC-9B73-D93B0C814A57__EXAMPLE4-2ACCESSINGAPLATFORMMXBEANV-8F3C48A5">例4-2</a>相同的工作，但它通过以下方式使用间接调用<code class="codeph">MBeanServerConnection</code> 。
                     </p>
                     <p id="GUID-7D0C32D9-7317-42B5-8F39-301A977A3ED5__EXAMPLE4-3ACCESSINGAPLATFORMMXBEANU-8F3CBD97">示例4-3使用MBeanServerConnection类访问平台MXBean</p><pre class="pre codeblock"><code>MBeanServerConnection mbs;
...
try {
  ObjectName oname = new ObjectName(ManagementFactory.RUNTIME_MXBEAN_NAME);
  // Get standard attribute "VmVendor"
  String vendor = (String) mbs.getAttribute(oname, "VmVendor");
} catch (....) {
  // Catch the exceptions thrown by ObjectName constructor
  // and MBeanServer.getAttribute method
  ...
}
</code></pre></div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-89C9B849-87E0-499E-A3EF-DD772C21C978" name="GUID-89C9B849-87E0-499E-A3EF-DD772C21C978"></a><h3 id="JSMGM-GUID-89C9B849-87E0-499E-A3EF-DD772C21C978" class="sect3">使用Oracle JDK的平台扩展</h3>
               <div>
                  <p>Java VM可以通过定义特定于平台的测量和管理操作的接口来扩展管理接口。静态工厂方法<code class="codeph">ManagementFactory</code>类将返回带有平台扩展的MBean。
                  </p>
                  <p>的<code class="codeph">com.sun.management</code>该软件包包含Oracle JDK的平台扩展。以下各节提供了有关如何从Oracle JDK的实现中访问特定于平台的属性的示例。 <code class="codeph">OperatingSystemMXBean</code>接口。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-DB0DFAD1-8BB2-4A9C-B3D4-3868856C4D76" name="GUID-DB0DFAD1-8BB2-4A9C-B3D4-3868856C4D76"></a><h4 id="JSMGM-GUID-DB0DFAD1-8BB2-4A9C-B3D4-3868856C4D76" class="sect4">直接访问MXBean属性</h4>
                  <div>
                     <p><a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-DB0DFAD1-8BB2-4A9C-B3D4-3868856C4D76__EXAMPLE4-4ACCESSINGANMXBEANATTRIBUT-8F3D42EF">例4-4</a>说明了对Oracle JDK的MXBean接口之一的直接访问。
                     </p>
                     <p id="GUID-DB0DFAD1-8BB2-4A9C-B3D4-3868856C4D76__EXAMPLE4-4ACCESSINGANMXBEANATTRIBUT-8F3D42EF">示例4-4直接访问MXBean属性</p><pre class="pre codeblock"><code>com.sun.management.OperatingSystemMXBean mxbean =
  (com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();

// Get the number of processors
int numProcessors = mxbean.getAvailableProcessors();

// Get the Oracle JDK-specific attribute Process CPU time
long cpuTime = mxbean.getProcessCpuTime();
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-F4A461C6-9BDD-4601-B247-8706DB2BF3DE" name="GUID-F4A461C6-9BDD-4601-B247-8706DB2BF3DE"></a><h4 id="JSMGM-GUID-F4A461C6-9BDD-4601-B247-8706DB2BF3DE" class="sect4">使用MBeanServerConnection访问MXBean属性</h4>
                  <div>
                     <p><a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-F4A461C6-9BDD-4601-B247-8706DB2BF3DE__EXAMPLE4-5ACCESSINGANMXBEANATTRIBUT-8F3D7096">例4-5</a>说明了使用以下命令访问Oracle JDK的MXBean接口之一<code class="codeph">MBeanServerConnection</code>类。
                     </p>
                     <p id="GUID-F4A461C6-9BDD-4601-B247-8706DB2BF3DE__EXAMPLE4-5ACCESSINGANMXBEANATTRIBUT-8F3D7096">示例4-5使用MBeanServerConnection访问MXBean属性</p><pre class="pre codeblock"><code>MBeanServerConnection mbs;

// Connect to a running Java VM (or itself) and get MBeanServerConnection
// that has the MXBeans registered in it
...

try {
    // Assuming the OperatingSystem MXBean has been registered in mbs
    ObjectName oname = new ObjectName(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME);

    // Get standard attribute "Name"
    String vendor = (String) mbs.getAttribute(oname, "Name");

    // Check if this MXBean contains Oracle JDK's extension
    if (mbs.isInstanceOf(oname, "com.sun.management.OperatingSystemMXBean")) {
        // Get platform-specific attribute "ProcessCpuTime"
        long cpuTime = (Long) mbs.getAttribute(oname, "ProcessCpuTime");
    }
} catch (....) {
    // Catch the exceptions thrown by ObjectName constructor
    // and MBeanServer methods
    ...
}
</code></pre></div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E954720D-0C11-491C-8784-4364738DDEE3" name="GUID-E954720D-0C11-491C-8784-4364738DDEE3"></a><h3 id="JSMGM-GUID-E954720D-0C11-491C-8784-4364738DDEE3" class="sect3">监视线程争用和CPU时间</h3>
               <div>
                  <p>的<code class="codeph">ThreadMXBean</code>平台MXBean提供了对监视线程争用和线程中央处理器（CPU）时间的支持。
                  </p>
                  <p>Oracle JDK的HotSpot VM支持线程争用监视。您使用<code class="codeph">ThreadMXBean.isThreadContentionMonitoringSupported()</code>确定Java VM是否支持线程争用监视的方法。默认情况下，线程争用监视处于禁用状态。使用<code class="codeph">setThreadContentionMonitoringEnabled()</code>启用它的方法。
                  </p>
                  <p>Oracle JDK的HotSpot VM支持大多数平台上线程CPU时间的度量。此接口提供的CPU时间具有纳秒精度，但不一定具有纳秒精度。</p>
                  <p>您使用<code class="codeph">isThreadCpuTimeSupported()</code>确定Java VM是否支持任何线程的CPU时间度量的方法。你用<code class="codeph">isCurrentThreadCpuTimeSupported()</code>确定Java VM是否支持测量当前线程的CPU时间。支持任何线程的CPU时间测量的Java VM也将支持当前线程的时间。
                  </p>
                  <p>Java VM可以禁用线程CPU时间测量。您使用<code class="codeph">isThreadCpuTimeEnabled()</code>确定是否启用线程CPU时间测量的方法。您使用<code class="codeph">setThreadCpuTimeEnabled()</code>启用或禁用线程CPU时间度量的方法。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-470524BF-8291-485F-95BD-C4185A0A4D2D" name="GUID-470524BF-8291-485F-95BD-C4185A0A4D2D"></a><h3 id="JSMGM-GUID-470524BF-8291-485F-95BD-C4185A0A4D2D" class="sect3">管理操作系统</h3>
               <div>
                  <p>的<code class="codeph">OperatingSystem</code>平台MXBean允许您访问某些操作系统资源信息，例如：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>处理CPU时间</p>
                     </li>
                     <li>
                        <p>总计和可用物理内存量</p>
                     </li>
                     <li>
                        <p>提交的虚拟内存量（即，保证正在运行的进程可用的虚拟内存量）</p>
                     </li>
                     <li>
                        <p>总交换空间和自由交换空间</p>
                     </li>
                     <li>
                        <p>打开文件描述符的数量（仅适用于Solaris，Linux或macOS平台）。</p>
                     </li>
                  </ul>
                  <p>在JConsole中选择“ MBeans”选项卡中的“操作系统MXBean”后，您将看到所有属性和操作，包括平台扩展。通过双击属性的值字段，可以监视数字属性随时间的变化。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E7CCD12F-00C4-4547-B3F4-E9D969768C9E" name="GUID-E7CCD12F-00C4-4547-B3F4-E9D969768C9E"></a><h3 id="JSMGM-GUID-E7CCD12F-00C4-4547-B3F4-E9D969768C9E" class="sect3">记录管理</h3>
               <div>
                  <p>Java SE平台提供了用于记录目的的特殊MXBean， <code class="codeph">LoggingMXBean</code>接口。
                  </p>
                  <p>的<code class="codeph">LoggingMXBean</code>界面使您可以执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>获取与指定记录器关联的日志级别的名称</p>
                     </li>
                     <li>
                        <p>获取当前注册的记录器列表</p>
                     </li>
                     <li>
                        <p>获取指定记录器的父名称</p>
                     </li>
                     <li>
                        <p>将指定的记录器设置为指定的新级别</p>
                     </li>
                  </ul>
                  <p>独特的<code class="codeph">ObjectName</code>的<code class="codeph">LoggingMXBean</code>是<code class="codeph">java.util.logging:type=Logging</code> 。该对象名称存储在<code class="codeph">LogManager.LOGGING_MXBEAN_NAME</code>领域。
                  </p>
                  <p>有一个全局实例<code class="codeph">LoggingMXBean</code>界面，您可以通过调用<code class="codeph">LogManager.getLoggingMXBean()</code> 。
                  </p>
                  <p>的<code class="codeph">LoggingMXBean</code>接口定义一个<code class="codeph">LoggerNames</code>描述记录器名称列表的属性。要在您的应用程序中找到记录器列表，您可以选择<code class="codeph">Logging MXBean</code>下的界面<code class="codeph">java.util.logging</code> MBeans标签中的域，然后双击<code class="codeph">LoggerNames</code>属性。
                  </p>
                  <p>的<code class="codeph">Logging MXBean</code>界面还支持两种操作：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">getLoggerLevel</code> ：返回给定记录器的日志级别</p>
                     </li>
                     <li>
                        <p><code class="codeph">setLoggerLevel</code> ：将给定记录器的日志级别设置为新级别</p>
                     </li>
                  </ul>
                  <p>这些操作将记录器名称作为第一个参数。要更改记录器的级别，请在第一个参数中输入记录器名称，并在第二个参数中输入应该设置的级别名称。 <code class="codeph">setLoggerLevel</code>操作。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-76F64803-CD1A-45E2-9C74-3A5E7792EC1A" name="GUID-76F64803-CD1A-45E2-9C74-3A5E7792EC1A"></a><h3 id="JSMGM-GUID-76F64803-CD1A-45E2-9C74-3A5E7792EC1A" class="sect3">检测低内存</h3>
               <div>
                  <p>内存使用是内存系统的重要属性。它可以指示以下问题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>应用程序过多的内存消耗</p>
                     </li>
                     <li>
                        <p>自动内存管理系统上的工作量过多</p>
                     </li>
                     <li>
                        <p>潜在的内存泄漏</p>
                     </li>
                  </ul>
                  <p>您可以使用两种内存阈值来检测内存不足情况： <span class="variable" translate="no">usage threshold</span>和<span class="variable" translate="no">collection usage threshold</span> 。您可以通过<span class="variable" translate="no">polling</span>或<span class="variable" translate="no">threshold notification</span>使用这些阈值之一来检测内存不足的情况。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-0D16BF63-86E4-434B-B2A5-BFB0A3AA712D" name="GUID-0D16BF63-86E4-434B-B2A5-BFB0A3AA712D"></a><h4 id="JSMGM-GUID-0D16BF63-86E4-434B-B2A5-BFB0A3AA712D" class="sect4">内存阈值</h4>
                  <div>
                     <p>内存池可以具有两种内存阈值：使用率阈值和收集使用率阈值。特定内存池可能不支持这些阈值之一。使用量阈值和收集使用量阈值的值都可以使用JConsole中的“ MBeans”选项卡进行设置。</p>
                  </div>
                  <div class="sect4"><a id="GUID-706EADC3-3447-49E2-9490-9DF95AE1CC78" name="GUID-706EADC3-3447-49E2-9490-9DF95AE1CC78"></a><h5 id="JSMGM-GUID-706EADC3-3447-49E2-9490-9DF95AE1CC78" class="sect5">使用阈值</h5>
                     <div>
                        <p>使用量阈值是某些内存池的可管理属性。它使您能够以较低的开销监视内存使用情况。将阈值设置为正值可使内存池执行使用率阈值检查。将使用率阈值设置为零将禁用使用率阈值检查。默认值由Java VM提供。</p>
                        <p>Java VM在最合适的时间（通常是在垃圾回收期间）对内存池执行使用情况阈值检查。每当使用率超过阈值时，每个内存池都会增加使用率阈值计数。</p>
                        <p>您使用<code class="codeph">isUsageThresholdSupported()</code>确定内存池是否支持使用率阈值的方法，因为使用率阈值不适用于某些内存池。例如，在分代垃圾收集器（例如HotSpot VM中的垃圾收集器；请参阅<a href="using-jconsole.html#GUID-A81AE10A-0693-462A-B129-5E292F46523E">Garbage Collection</a> ）中，大多数对象是从Eden内存池中分配给年轻的一代。伊甸园池被设计为可装满的。收集Eden内存池的垃圾将释放其大部分内存空间，因为它预计将包含大多数在垃圾收集时无法访问的短期对象。因此，Eden内存池不支持使用量阈值。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2D3404CA-3458-4222-BE03-F8380909E994" name="GUID-2D3404CA-3458-4222-BE03-F8380909E994"></a><h5 id="JSMGM-GUID-2D3404CA-3458-4222-BE03-F8380909E994" class="sect5">集合使用阈值</h5>
                     <div>
                        <p>收集使用量阈值是某些垃圾收集的内存池的可管理属性。Java VM对内存池执行垃圾回收后，该池中的某些内存仍将被使用。收集使用量阈值允许您为此内存设置一个值。您使用<code class="codeph">isCollectionUsageThresholdSupported()</code>的方法<code class="codeph">MemoryPoolMXBean</code>接口，以确定池是否支持收集使用量阈值。
                        </p>
                        <p>Java VM在执行垃圾回收时可能会检查内存池上的回收使用阈值。将收集使用量阈值设置为正值以启用检查。将收集使用阈值设置为零（默认值）以禁用检查。</p>
                        <p>可以在JConsole的“ MBeans”选项卡中设置使用量阈值和收集使用量阈值。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-86E4727D-E8AD-4F8E-87BE-49FBAB419684" name="GUID-86E4727D-E8AD-4F8E-87BE-49FBAB419684"></a><h5 id="JSMGM-GUID-86E4727D-E8AD-4F8E-87BE-49FBAB419684" class="sect5">内存MXBean</h5>
                     <div>
                        <p>可以使用平台管理各种内存阈值<code class="codeph">MemoryMXBean</code> 。的<code class="codeph">MemoryMXBean</code>定义以下四个属性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">HeapMemoryUsage</code> ：描述当前堆内存使用情况的只读属性。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">NonHeapMemoryUsage</code> ：描述非堆内存使用情况的只读属性。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ObjectPendingFinalizationCount</code> ：一个只读属性，描述待定案的对象数。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">Verbose</code> ：一个布尔属性，描述垃圾收集（GC）的详细跟踪设置。可以动态设置。启动Java VM时，GC详细记录将显示在指定的位置。 Hotspot VM的GC详细输出的默认位置是<code class="codeph">stdout</code> 。
                              </p>
                           </li>
                        </ul>
                        <p>Memory MXBean支持一项操作， <code class="codeph">gc</code> ，用于明确的垃圾收集请求。
                        </p>
                        <p>Memory MXBean接口的详细信息在<code class="codeph">java.lang.management.MemoryMXBean</code>规格。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-83A05689-B759-4CF2-BB82-7B82D8DA9F25" name="GUID-83A05689-B759-4CF2-BB82-7B82D8DA9F25"></a><h5 id="JSMGM-GUID-83A05689-B759-4CF2-BB82-7B82D8DA9F25" class="sect5">内存池MXBean</h5>
                     <div>
                        <p>的<code class="codeph">MemoryPoolMXBean</code>平台MXBean定义了一组操作来管理内存阈值。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">getUsageThreshold()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setUsageThreshold(long threshold)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">isUsageThresholdExceeded()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">isUsageThresholdSupported()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">getCollectionUsageThreshold()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setCollectionUsageThreshold(long threshold)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">isCollectionUsageThresholdSupported()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">isCollectionUsageThresholdExceeded()</code></p>
                           </li>
                        </ul>
                        <p>每个内存池可能具有两种内存阈值，以支持低内存检测：使用率阈值和收集使用率阈值。特定内存池可能不支持这些阈值之一。有关更多信息，请参见API参考文档。 <code class="codeph">MemoryPoolMXBean</code>类。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1" name="GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1"></a><h4 id="JSMGM-GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1" class="sect4">轮询</h4>
                  <div>
                     <p>应用程序可以通过调用以下任一方法来连续监视其内存使用情况： <code class="codeph">getUsage()</code>所有内存池的方法或<code class="codeph">isUsageThresholdExceeded()</code>支持使用率阈值的内存池的方法。
                     </p>
                     <p><a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1__EXAMPLE4-6USINGPOLLING-8F3EC957">例4-6</a>有一个专门用于任务分配和处理的线程。在每个时间间隔，它都会根据其内存使用情况确定是否应该接收和处理新任务。如果内存使用率超过其使用率阈值，则它将未完成的任务重新分配给其他VM，并停止接收新任务，直到内存使用率回到阈值以下。
                     </p>
                     <p id="GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1__EXAMPLE4-6USINGPOLLING-8F3EC957">示例4-6使用轮询</p><pre class="pre codeblock"><code>pool.setUsageThreshold(myThreshold);
....
boolean lowMemory = false;
while (true) {
  if (pool.isUsageThresholdExceeded()) {
    lowMemory = true;
    redistributeTasks();  // redistribute tasks to other VMs
    stopReceivingTasks();  // stop receiving new tasks
  } else {
    if (lowMemory) { // resume receiving tasks
      lowMemory = false;
      resumeReceivingTasks();
    }
    // processing outstanding task
    ...
  }
  // sleep for sometime
  try {
    Thread.sleep(sometime);
  } catch (InterruptedException e) {
    ...
  }
}      
</code></pre><p><a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1__EXAMPLE4-6USINGPOLLING-8F3EC957">例4-6</a>并未将两次使用之间存储器使用量暂时降至使用量阈值以下的情况与存储器使用量保持在阈值以上的情况进行区分。您可以使用由<code class="codeph">getUsageThresholdCount()</code>确定两次使用之间的内存使用率是否已返回阈值以下的方法。
                     </p>
                     <p>要测试收集使用量阈值，请使用<code class="codeph">isCollectionUsageThresholdSupported()</code> ， <code class="codeph">isCollectionThresholdExceeded()</code>和<code class="codeph">getCollectionUsageThreshold()</code>方法与<a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1__EXAMPLE4-6USINGPOLLING-8F3EC957">示例4-6中</a>所示的方法相同。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E2E075B3-9D4F-4F14-825C-99DA09B27812" name="GUID-E2E075B3-9D4F-4F14-825C-99DA09B27812"></a><h4 id="JSMGM-GUID-E2E075B3-9D4F-4F14-825C-99DA09B27812" class="sect4">阈值通知</h4>
                  <div>
                     <p>当。。。的时候<code class="codeph">MemoryMXBean</code>接口检测到内存池已达到或超过其使用量阈值，它发出<span class="variable" translate="no">usage threshold exceeded</span>通知。的<code class="codeph">MemoryMXBean</code>除非使用率已降至阈值以下，然后再次超过该阈值，否则界面不会发出另一个“使用率超过阈值”通知。同样，当垃圾收集后的内存使用量超过收集使用量阈值时， <code class="codeph">MemoryMXBean</code>界面发出超出集合使用量阈值的通知。
                     </p>
                     <p><a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-E2E075B3-9D4F-4F14-825C-99DA09B27812__EXAMPLE4-7USINGTHRESHOLDNOTIFICATIO-8F41249C">例4-7</a>实现了与<a href="using-platform-mbean-server-and-platform-mxbeans.html#GUID-8B19A349-4075-47F2-BC95-3CC88CA96BB1__EXAMPLE4-6USINGPOLLING-8F3EC957">例4-6</a>相同的逻辑，但是使用使用率阈值通知来检测内存不足的情况。收到通知后，侦听器会通知另一个线程执行一些操作，例如重新分发未完成的任务，拒绝接受新任务或允许再次接受新任务。
                     </p>
                     <p>通常，您应该设计<code class="codeph">handleNotification</code>一种方法，以最少的工作量来避免延迟传递后续通知。您应该在单独的线程中执行耗时的操作。由于多个线程可以同时调用通知侦听器，因此该侦听器应同步其正确执行的任务。
                     </p>
                     <p id="GUID-E2E075B3-9D4F-4F14-825C-99DA09B27812__EXAMPLE4-7USINGTHRESHOLDNOTIFICATIO-8F41249C">示例4-7使用阈值通知</p><pre class="pre codeblock"><code>class MyListener implements javax.management.NotificationListener {
  public void handleNotification(Notification notification, Object handback)  {
    String notifType = notification.getType();
    if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {
      // potential low memory, redistribute tasks to other VMs &amp; stop receiving new tasks.
      lowMemory = true;
      notifyAnotherThread(lowMemory);
    }
  }
}

// Register MyListener with MemoryMXBean
MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
NotificationEmitter emitter = (NotificationEmitter) mbean;
MyListener listener = new MyListener();
emitter.addNotificationListener(listener, null, null);
</code></pre><p>假设此内存池支持使用量阈值，则可以将阈值设置为某个值（代表字节数），超过该值应用程序将不接受新任务。</p><pre class="pre codeblock"><code>pool.setUsageThreshold(myThreshold);
</code></pre><p>此后，将启用使用率阈值检测并<code class="codeph">MyListener</code>类将处理通知。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>