<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter provides some suggestions for diagnosing problems involving possible memory leaks.">
      <meta name="description" content="This chapter provides some suggestions for diagnosing problems involving possible memory leaks.">
      <title>解决内存泄漏</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="This chapter provides some suggestions for diagnosing problems involving possible memory leaks.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="diagnostic-tools.html" title="Previous" type="text/html">
      <link rel="next" href="troubleshoot-performance-issues-using-jfr.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="diagnostic-tools.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="troubleshoot-performance-issues-using-jfr.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="general-java-troubleshooting.html" property="item" typeof="WebPage"><span property="name">常规Java故障排除</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">解决内存泄漏</li>
            </ol>
            <a id="GUID-8090B138-6E0C-4926-9659-BE739062AB75" name="GUID-8090B138-6E0C-4926-9659-BE739062AB75"></a><a id="JSTGD267"></a><a id="JSTGD266"></a>
            
            <h2 id="JSTGD-GUID-8090B138-6E0C-4926-9659-BE739062AB75" class="sect2"><span class="enumeration_chapter">3</span>解决内存泄漏</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本章为诊断涉及可能的内存泄漏的问题提供了一些建议。</span></div>
               <p>如果应用程序的执行时间越来越长，或者操作系统的运行速度越来越慢，则可能表明存在内存泄漏。换句话说，正在分配虚拟内存，但是在不再需要虚拟内存时不返回虚拟内存。最终，应用程序或系统内存不足，应用程序异常终止。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="troubleshoot-memory-leaks.html#GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD" title="Java Flight Recorder记录有关Java运行时和在Java运行时中运行的Java应用程序的详细信息。">使用Java Flight Recorder调试内存泄漏</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-memory-leaks.html#GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" title="java.lang。当没有足够的空间在Java堆中分配对象时，将引发OutOfMemoryError错误。">了解OutOfMemoryError异常</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-memory-leaks.html#GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2" title="使用致命错误日志或崩溃转储中的信息来对崩溃进行故障排除。">解决崩溃而不是OutOfMemoryError问题</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-memory-leaks.html#GUID-442CF6A1-3DF8-496C-A910-3A239326A161" title="使用NetBeans分析器诊断Java语言代码中的泄漏。">诊断Java语言代码中的泄漏</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-memory-leaks.html#GUID-79F26B47-9240-4F32-A817-1DD77A361F31" title="可以使用多种技术来查找和隔离本机代码内存泄漏。通常，对于所有平台都没有理想的解决方案。">诊断本机代码泄漏</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD268"></a><div class="props_rev_3"><a id="GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD" name="GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD"></a><h3 id="JSTGD-GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD" class="sect3">使用Java Flight Recorder调试内存泄漏</h3>
               <div>
                  <p>Java Flight Recorder记录有关Java运行时和在Java运行时中运行的Java应用程序的详细信息。</p>
                  <p>以下各节显示图形，并描述如何使用Java Flight Recorder调试内存泄漏。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26" title="尽早发现内存泄漏，并使用Java Flight Recordings防止OutOfmemoryError。">检测内存泄漏</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359" title="使用Java飞行记录来识别内存泄漏。">查找泄漏类</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-01CA595F-83F0-431F-876A-4138E68E34D2" title="使用Java Flight Recordings的其他信息来识别内存泄漏的提示。">找到泄漏</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD270"></a><a id="JSTGD269"></a><div class="props_rev_3"><a id="GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26" name="GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26"></a><h4 id="JSTGD-GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26" class="sect4">检测内存泄漏</h4>
                  <div>
                     <p>尽早发现内存泄漏并防止<code class="codeph">OutOfmemoryErrors</code>使用Java飞行记录。
                     </p>
                     <div class="section">
                        <p>检测缓慢的内存泄漏可能很难。一个典型的症状是，由于频繁的垃圾回收，应用程序长时间运行后会变慢。最终， <code class="codeph">OutOfmemoryErrors</code>可能会看到。但是，即使使用Java Flight Records发生问题之前，也可以及早发现内存泄漏。
                        </p>
                        <p>观察应用程序的实时设置是否随着时间增加。活动集是旧集合（所有未活动的对象都已被垃圾回收）之后使用的Java堆的数量。可以通过多种方式检查现场设置： <code>-verbosegc</code>选项，或使用JMC JMX控制台连接到JVM并查看<code class="codeph">com.sun.management.GarbageCollectorAggregator MBean</code> 。但是，另一种简单的方法是进行飞行记录。
                        </p>
                        <p>开始录制时启用“ <span class="bold">堆统计信息”</span> ，这会在录制开始和结束时触发旧的收集。这可能会导致应用程序中的轻微延迟。但是， <span class="bold">堆统计</span>信息会生成准确的实时设置信息。如果您怀疑内存泄漏非常快，那么请进行一段长达一个小时的性能分析记录。单击“ <span class="bold">内存”</span>页签，选择“ <span class="bold">垃圾回收”</span>页签，查看第一个和最后一个旧回收项， <a href="troubleshoot-memory-leaks.html#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">如图3-1</a>所示。
                        </p>
                        <div class="figure" id="GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">
                           <p class="titleinfigure">图3-1调试内存泄漏-垃圾回收选项卡</p><img src="img/jfr-gc-collectors.png" alt="如下图3-1所示" title="如下图3-1所示" longdesc="img_text/jfr-gc-collectors.html"><br><a href="img_text/jfr-gc-collectors.html">“图3-1调试内存泄漏-垃圾回收选项卡”的描述</a></div>
                        <!-- class="figure" -->
                        <p>选择第一个旧集合， <a href="troubleshoot-memory-leaks.html#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">如图3-1</a>所示，以查看GC之后的堆数据和堆使用情况。在此记录中，它是34.10 MB。现在，查看列表中最后一个旧集合中的相同数据，并查看实时集合是否增加。进行录制之前，必须允许应用程序启动并达到稳定状态。
                        </p>
                        <p>如果泄漏很慢，则可以记录较短的5分钟。然后，再进行一次录音，例如24小时后（取决于您怀疑内存泄漏的速度）。显然，您的实时设置可能会上下波动，但是如果您发现随着时间的推移稳定增长，那么可能会发生内存泄漏。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD272"></a><a id="JSTGD271"></a><div class="props_rev_3"><a id="GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359" name="GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359"></a><h4 id="JSTGD-GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359" class="sect4">查找泄漏类</h4>
                  <div>
                     <p>使用Java飞行记录来识别内存泄漏。</p>
                     <div class="section">
                        <p>记录显示泄漏后，可以查看“ <span class="bold">对象统计信息”</span> 。查看一个较长的记录，然后查看在该记录中哪些类的堆使用量增长最多。如果您不时进行几次记录，则比较堆内容部分，查看两次记录之间哪些对象类型增加最多， <a href="troubleshoot-memory-leaks.html#GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359__CIHIBAEJ">如图3-2</a>所示。
                        </p>
                        <div class="figure" id="GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359__CIHIBAEJ">
                           <p class="titleinfigure">图3-2调试内存泄漏-查找泄漏类</p><img src="img/jfr-memory-leak.png" alt="如下图3-2所示" title="如下图3-2所示" longdesc="img_text/jfr-memory-leak.html"><br><a href="img_text/jfr-memory-leak.html">“图3-2调试内存泄漏-查找泄漏类”的描述</a></div>
                        <!-- class="figure" -->
                        <p>特别是，请注意不属于标准库的类。例如，您经常会看到<code class="codeph">Char</code>列为顶级种植者之一。这是由于许多<code class="codeph">Strings</code>被分配；因此，请注意保持这些物品的物品<code class="codeph">Strings</code>活。如果您的班级有10个<code class="codeph">Strings</code>作为成员，那么对象本身将不会使用太多堆。堆将由<code class="codeph">Strings</code> ，其中大部分包含指向<code class="codeph">Char</code>数组。因此，最好根据实例的数量而不是对象的大小进行排序。如果您的应用程序类之一具有许多实例，则可能是那些使其他对象保持活动状态的对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD274"></a><a id="JSTGD273"></a><div class="props_rev_3"><a id="GUID-01CA595F-83F0-431F-876A-4138E68E34D2" name="GUID-01CA595F-83F0-431F-876A-4138E68E34D2"></a><h4 id="JSTGD-GUID-01CA595F-83F0-431F-876A-4138E68E34D2" class="sect4">找到泄漏</h4>
                  <div>
                     <p>使用Java Flight Recordings的其他信息来识别内存泄漏的提示。</p>
                     <div class="section">
                        <p>使用Java Flight Recordings可以找到一些其他信息。</p>
                        <p>查看“ <span class="bold">分配”</span>子选项卡， <a href="troubleshoot-memory-leaks.html#GUID-01CA595F-83F0-431F-876A-4138E68E34D2__CIHJCAGI">如图3-3</a>所示，以获取对象分配位置的一些示例。
                        </p>
                        <div class="figure" id="GUID-01CA595F-83F0-431F-876A-4138E68E34D2__CIHJCAGI">
                           <p class="titleinfigure">图3-3调试内存泄漏-分配选项卡</p><img src="img/jfr-find-leak.png" alt="如下图3-3所示" title="如下图3-3所示" longdesc="img_text/jfr-find-leak.html"><br><a href="img_text/jfr-find-leak.html">“图3-3调试内存泄漏-分配选项卡”的描述</a></div>
                        <!-- class="figure" -->
                        <p>如果除了特定的类泄漏，请<span class="bold">在新的“ TLAB”</span>选项卡中查看“ <span class="bold">分配”</span> 。检查分配的班级样本。如果泄漏很慢，则可能分配了该对象，并且可能没有样本。另外，可能只有特定的分配站点导致泄漏。总而言之，这不能保证导致您找到正确的分配堆栈跟踪以进行泄漏，但是它可能会提供重要的线索。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD275"></a><div class="props_rev_3"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B"></a><h3 id="JSTGD-GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" class="sect3">了解OutOfMemoryError异常</h3>
               <div>
                  <p><code class="codeph">java.lang.OutOfMemoryError</code>当没有足够的空间在Java堆中分配对象时，将引发错误。
                  </p>
                  <p>内存泄漏的一种常见迹象是<code class="codeph">java.lang.OutOfMemoryError</code>例外。在这种情况下，垃圾收集器无法提供空间来容纳新对象，并且堆无法进一步扩展。另外，当本机内存不足以支持Java类的加载时，可能会引发此错误。在极少数情况下， <code class="codeph">java.lang.OutOfMemoryError</code>当花费大量时间进行垃圾回收并且释放了很少的内存时，可能会抛出该异常。
                  </p>
                  <p>当一个<code class="codeph">java.lang.OutOfMemoryError</code>引发异常时，还将打印堆栈跟踪。
                  </p>
                  <p>的<code class="codeph">java.lang.OutOfMemoryError</code>当无法满足本机分配时（例如，如果交换空间不足），本机库代码也可能引发异常。
                  </p>
                  <p>早期诊断<code class="codeph">OutOfMemoryError</code>异常是确定异常的原因。是因为Java堆已满还是本机堆已满而引发了它？为了帮助您找到原因，该异常的文本末尾包括一条详细消息，如以下异常所示。
                  </p>
                  <dl>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-6640E414-548C-4308-B8A3-EAEE74A28DFA"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：Java堆空间</dt>
                     <dd>
                        <p><span class="keyword">原因：</span>详细消息<span class="italic"><span class="bold">Java堆空间</span></span>指示无法在Java堆中分配对象。此错误不一定表示内存泄漏。该问题可以像配置问题一样简单，其中指定的堆大小（或默认大小，如果未指定）对于应用程序来说是不够的。
                        </p>
                        <p>在其他情况下，尤其是对于寿命长的应用程序，该消息可能表示该应用程序无意间持有了对对象的引用，这防止了对象被垃圾回收。这是等效于Java语言的内存泄漏。<span class="italic">注意：</span>应用程序调用的API也可能无意中包含对象引用。
                        </p>
                        <p>过度使用终结器的应用程序可能导致此错误。如果一个班级有一个<code class="codeph">finalize</code>方法，则该类型的对象在垃圾回收时不会回收其空间。取而代之的是，在进行垃圾回收之后，将对象排队等待定稿，这将在以后发生。在Oracle Sun实施中，终结器由为终结队列提供服务的守护程序线程执行。如果终结器线程无法跟上终结器队列，那么Java堆可能会填满，并且这种类型的<code class="codeph">OutOfMemoryError</code>将会抛出异常。一种可能导致这种情况的情况是，应用程序创建了高优先级线程，这些线程导致终结处理队列以比终结器线程为该队列提供服务的速率快的速率增加。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>要了解更多有关如何监视尚未完成终结的对象的信息，请监视正在等待终结<a href="troubleshoot-memory-leaks.html#GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" title="可使用不同的命令和选项来监视挂起的对象。">的对象</a> 。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__TAHITI1150092"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：超出了GC开销限制</dt>
                     <dd>
                        <p><span class="keyword">原因：</span>详细消息“超出了GC开销限制”表示垃圾收集器一直在运行，并且Java程序的进度非常慢。进行垃圾回收之后，如果Java进程花费了其大约98％以上的时间用于垃圾回收，并且其回收的内存少于2％，并且在最近5个（编译时间常数）连续垃圾中一直这样做集合，然后<code class="codeph">java.lang.OutOfMemoryError</code>被抛出。通常会抛出此异常，因为活动数据量几乎无法容纳到Java堆中，而新分配的可用空间却很少。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>增加堆大小。的<code class="codeph">java.lang.OutOfMemoryError</code>可以通过命令行标志关闭<span class="bold">超出GC开销限制的</span>异常<code class="codeph">-XX:-UseGCOverheadLimit</code> 。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-289BB010-8FF3-46DA-830B-B8FEFB1F18E1"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：请求的数组大小超出了VM限制</dt>
                     <dd>
                        <p><span class="keyword">原因：</span>详细消息“请求的数组大小超出VM限制”指示该应用程序（或该应用程序使用的API）试图分配大于堆大小的数组。例如，如果应用程序尝试分配512 MB的数组，但最大堆大小为256 MB，则<code class="codeph">OutOfMemoryError</code>将抛出“请求的阵列大小超出VM限制”的原因。</p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>通常是配置问题（堆大小太小）或导致应用程序尝试创建巨大数组的错误（例如，当使用计算结果的算法来计算数组中的元素数时）尺寸不正确）。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-F78066FC-0EAD-41BD-BD7B-8F2ADA707AB3"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：元空间</dt>
                     <dd>
                        <p><span class="keyword">原因：</span> Java类元数据（Java类的虚拟机内部表示形式）分配在本机内存（在此称为元空间）中。如果类元数据的元空间用尽，则<code class="codeph">java.lang.OutOfMemoryError</code>详细的例外<code class="codeph">MetaSpace</code>被抛出。可用于类元数据的元空间数量受参数限制<code class="codeph">MaxMetaSpaceSize</code> ，这是在命令行上指定的。当类元数据所需的本机内存量超过<code class="codeph">MaxMetaSpaceSize</code> ， 一种<code class="codeph">java.lang.OutOfMemoryError</code>详细的例外<code class="codeph">MetaSpace</code>被抛出。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>如果<code class="codeph">MaxMetaSpaceSize</code> ，已在命令行上设置，请增加其值。 <code class="codeph">MetaSpace</code>从与Java堆相同的地址空间分配。减少Java堆的大小将为<code class="codeph">MetaSpace</code> 。只有在Java堆中有多余的可用空间时，这才是正确的权衡。有关<span class="bold">交换空间不足的</span>详细消息，请参阅以下操作。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-D21A14F5-3462-49BE-96F2-25D02A963752"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：请求<span class="variable" translate="no">reason</span> <span class="variable" translate="no">size</span>字节。交换空间不足？
                     </dt>
                     <dd>
                        <p><span class="keyword">原因：</span>详细信息“ <span class="variable" translate="no">reason</span>请求<span class="variable" translate="no">size</span>字节。交换空间不足？“似乎是<code class="codeph">OutOfMemoryError</code>例外。但是，当来自本机堆的分配失败并且本机堆可能快要用尽时，Java HotSpot VM代码报告此明显的异常。该消息指示失败的请求的大小（以字节为单位）以及内存请求的原因。通常，原因是报告分配失败的源模块的名称，尽管有时是实际原因。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">操作：</span>抛出此错误消息时，VM会调用致命错误处理机制（即，它会生成致命错误日志文件，其中包含有关崩溃时线程，进程和系统的有用信息）。在本机堆耗尽的情况下，日志中的堆内存和内存映射信息可能会很有用。请参阅<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。
                        </p>
                        <p>如果这种类型的<code class="codeph">OutOfMemoryError</code>引发异常，您可能需要在操作系统上使用故障排除实用程序来进一步诊断问题。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-01312D6E-BE5E-454A-8CC9-3DAF6CD50034"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError：压缩的类空间</dt>
                     <dd>
                        <p><span class="keyword">原因：</span>在64位平台上，指向类元数据的指针可以由32位偏移量表示（ <code class="codeph">UseCompressedOops</code> ）。这由命令行标志控制<code class="codeph">UseCompressedClassPointers</code> （默认情况下处于启用状态）。如果<code class="codeph">UseCompressedClassPointers</code>使用时，可用于类元数据的空间量固定为该量<code class="codeph">CompressedClassSpaceSize</code> 。如果需要空间<code class="codeph">UseCompressedClassPointers</code>超过<code class="codeph">CompressedClassSpaceSize</code> ， 一种<code class="codeph">java.lang.OutOfMemoryError</code>详细信息抛出<span class="bold">压缩的类空间</span> 。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>增加<code class="codeph">CompressedClassSpaceSize</code>把关掉<code class="codeph">UseCompressedClassPointers</code> 。<span class="italic">注意：</span>可接受的大小有界限<code class="codeph">CompressedClassSpaceSize</code> 。例如<code class="codeph">-XX: CompressedClassSpaceSize=4g</code> ，超出可接受的范围将导致显示以下消息</p>
                        <p><code class="codeph">CompressedClassSpaceSize</code> 4294967296中的无效；必须介于1048576和3221225472之间。
                        </p>
                        <div class="infoboxnote" id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-0FFF3AAB-A882-40EC-99ED-404BE63B8E62">
                           <p class="notep1">注意：</p>类元数据不止一种， <code class="codeph">–klass</code>元数据和其他元数据。只要<code class="codeph">klass</code>元数据存储在由<code class="codeph">CompressedClassSpaceSize</code> 。其他元数据存储在<code class="codeph">Metaspace</code> 。
                        </div>
                     </dd>
                     <dt class="dlterm"><a name="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-6861E00E-EF63-4556-92DD-7029268A70A1"><!-- --></a>线程<span class="variable" translate="no">thread_name</span>异常：java.lang。OutOfMemoryError： <span class="variable" translate="no">reason</span> <span class="variable" translate="no">stack_trace_with_native_method</span></dt>
                     <dd>
                        <p><span class="keyword">原因：</span>如果错误消息的详细信息部分是“ <span class="variable" translate="no">reason</span> <span class="variable" translate="no">stack_trace_with_native_method</span> ，并且打印了堆栈跟踪，其中顶部框架是本机方法，则表明本机方法遇到分配失败。该消息与上一条消息之间的区别在于，在Java本机接口（JNI）或本机方法中而不是在JVM代码中检测到分配失败。
                        </p>
                     </dd>
                     <dd class="ddexpand">
                        <p><span class="keyword">行动：</span>如果这种类型的<code class="codeph">OutOfMemoryError</code>引发异常，您可能需要使用操作系统的本机实用程序来进一步诊断问题。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                        </p>
                     </dd>
                  </dl>
               </div>
            </div><a id="JSTGD276"></a><div class="props_rev_3"><a id="GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2" name="GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2"></a><h3 id="JSTGD-GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2" class="sect3">解决崩溃而不是OutOfMemoryError问题</h3>
               <div>
                  <p>使用致命错误日志或崩溃转储中的信息来对崩溃进行故障排除。</p>
                  <p>有时，从本机堆分配失败后，应用程序立即崩溃。发生这种情况的本机代码不检查内存分配函数返回的错误。</p>
                  <p>例如， <code class="codeph">malloc</code>系统调用返回<code class="codeph">null</code>如果没有可用的内存。如果从<code class="codeph">malloc</code>如果未选中，则在尝试访问无效的内存位置时应用程序可能会崩溃。根据情况，可能很难找到此类问题。
                  </p>
                  <p>但是，有时致命错误日志或故障转储中的信息足以诊断此问题。致命错误日志中详细介绍了<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。如果崩溃的原因是分配失败，请确定分配失败的原因。与其他任何本机堆问题一样，系统可能配置为交换空间不足，系统上的另一个进程可能正在消耗所有内存资源，或者应用程序（或其调用的API）中可能存在泄漏），导致系统内存不足。
                  </p>
               </div>
            </div><a id="JSTGD277"></a><div class="props_rev_3"><a id="GUID-442CF6A1-3DF8-496C-A910-3A239326A161" name="GUID-442CF6A1-3DF8-496C-A910-3A239326A161"></a><h3 id="JSTGD-GUID-442CF6A1-3DF8-496C-A910-3A239326A161" class="sect3">诊断Java语言代码中的泄漏</h3>
               <div>
                  <p>使用NetBeans分析器诊断Java语言代码中的泄漏。</p>
                  <div class="section">
                     <p>诊断Java语言代码中的泄漏可能很困难。通常，它需要非常详细的应用程序知识。另外，该过程通常是反复的和漫长的。本节提供有关可用于诊断Java语言代码中的内存泄漏的工具的信息。</p>
                     <div class="infoboxnote" id="GUID-442CF6A1-3DF8-496C-A910-3A239326A161__GUID-A9D119FE-5A94-44AC-9D45-1889CBC31998">
                        <p class="notep1">注意：</p>
                        <p>除了本节中提到的工具之外，还可以使用大量的第三方内存调试器工具。Eclipse内存分析器工具（MAT）和YourKit（www.yourkit.com）是具有内存调试功能的商业工具的两个示例。还有许多其他产品，因此不建议使用特定产品。</p>
                     </div>
                     <p>以下实用程序用于诊断Java语言代码中的泄漏。</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span><span class="bold">NetBeans Profiler：</span> NetBeans Profiler可以非常快速地找到内存泄漏。商业内存泄漏调试工具可能需要很长时间才能在大型应用程序中定位泄漏。但是，NetBeans Profiler使用此类对象通常演示的内存分配和回收模式。此过程还包括缺少内存回收。探查器可以检查这些对象的分配位置，这通常足以确定泄漏的根本原因。</span><div>
                           <p>请参阅<a href="http://profiler.netbeans.org" target="_blank">NetBeans Profiler</a> 。
                           </p>
                        </div>
                     </li>
                  </ol>
                  <div class="section">
                     <p>以下各节描述了诊断Java语言代码中泄漏的其他方法。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="troubleshoot-memory-leaks.html#GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9" title="可使用不同的命令和选项来获取堆直方图，以识别内存泄漏。">获取堆直方图</a></p>
                        </li>
                        <li>
                           <p><a href="troubleshoot-memory-leaks.html#GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" title="可使用不同的命令和选项来监视挂起的对象。">监视即将完成的对象</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSTGD282"></a><div class="props_rev_3"><a id="GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9" name="GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9"></a><h4 id="JSTGD-GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9" class="sect4">获取堆直方图</h4>
                  <div>
                     <p>可使用不同的命令和选项来获取堆直方图，以识别内存泄漏。</p>
                     <div class="section">
                        <p>您可以尝试通过检查堆直方图来快速缩小内存泄漏的范围。您可以通过几种方式获得堆直方图：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>如果Java进程以<code>-XX:+PrintClassHistogram</code>命令行选项，然后Control + Break处理程序将生成一个堆直方图。</span></li>
                        <li class="stepexpand"><span>您可以使用<code class="codeph">jmap</code>从运行的进程中获取堆直方图的实用程序：</span><div>
                              <p>建议使用最新的实用程序， <code class="codeph">jcmd</code> ， 代替<code class="codeph">jmap</code>实用程序可增强诊断并降低性能开销。请参阅<a href="diagnostic-tools.html#GUID-B7480F58-82B5-4F29-94E6-1DA669947265" title="在不同版本的HotSpot VM中，可用的诊断命令可能有所不同。因此，使用jcmd <进程ID /主类>帮助是查看所有可用选项的最佳方法。">jcmd实用程序的有用命令</a> 。以下示例中的命令使用以下命令为正在运行的进程创建堆直方图： <code class="codeph">jcmd</code>结果类似于以下内容<code class="codeph">jmap</code>命令。
                              </p><pre class="pre codeblock"><code>jcmd &lt;process id/main class&gt; GC.class_histogram filename=Myheaphistogram
</code></pre><pre class="pre codeblock"><code>jmap -histo <span class="variable" translate="no">pid</span>
</code></pre><p>输出显示堆中每种类类型的总大小和实例计数。如果获得了一系列直方图（例如，每2分钟一次），那么您可能会看到一个趋势，可以进行进一步的分析。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>您可以使用<code class="codeph">jmap</code>实用程序从核心文件获取堆直方图，如以下示例所示。</span><div><pre class="pre codeblock"><code>jmap -histo <span class="variable" translate="no">core_file</span>
</code></pre><p>例如，如果您指定<code>-XX:+HeapDumpOnOutOfMemoryError</code>命令行选项，同时运行您的应用程序，然后<code class="codeph">OutOfMemoryError</code>抛出异常后，JVM将生成堆转储。然后可以执行<code class="codeph">jmap</code>在核心文件上获取直方图，如下例所示。
                              </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jmap -histo \ /java/re/javase/6/latest/binaries/solaris-sparc/bin/java core.27421</code></span>

Attaching to core core.27421 from executable 
/java/re/javase/6/latest/binaries/solaris-sparc/bin/java, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 1.6.0-beta-b63
Iterating over heap. This may take a while...
Heap traversal took 8.902 seconds.

Object Histogram:
 
Size      Count   Class description
-------------------------------------------------------
86683872  3611828 java.lang.String
20979136  204     java.lang.Object[]
403728    4225    * ConstMethodKlass
306608    4225    * MethodKlass
220032    6094    * SymbolKlass
152960    294     * ConstantPoolKlass
108512    277     * ConstantPoolCacheKlass
104928    294     * InstanceKlassKlass
68024     362     byte[]
65600     559     char[]
31592     359     java.lang.Class
27176     462     java.lang.Object[]
25384     423     short[]
17192     307     int[]
:
</code></pre><p>上面的例子表明<code class="codeph">OutOfMemoryError</code>异常是由数量引起的<code class="codeph">java.lang.String</code>对象（堆中的3,611,828个实例）。如果不做进一步分析，则不清楚在哪里分配字符串。但是，该信息仍然有用。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD286"></a><div class="props_rev_3"><a id="GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" name="GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B"></a><h4 id="JSTGD-GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" class="sect4">监视即将完成的对象</h4>
                  <div>
                     <p>可使用不同的命令和选项来监视挂起的对象。</p>
                     <div class="section">
                        <p>当“ Java堆空间”详细信息引发OutOfMemoryError异常时，原因可能是过度使用了终结器。为了诊断这一点，您有几个选项可以监视即将完成的对象的数量：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span><a href="diagnostic-tools.html#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="JDK下载中包含的另一个有用的工具是JConsole监视工具。该工具与JMX兼容。该工具使用JVM中的内置JMX工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">JConsole</a>管理工具可用于监视即将完成的对象的数量。该工具在“ <span class="bold">摘要”</span>选项卡窗格上的内存统计信息中报告挂起的完成计数。该计数是近似值，但可用于表征应用程序并了解其是否在很大程度上取决于定型。</span></li>
                        <li><span>在Oracle Solaris和Linux操作系统上， <code class="codeph">jmap</code>实用程序可以与<code class="codeph">-finalizerinfo</code>打印有关等待完成的对象的信息的选项。</span></li>
                        <li><span>应用程序可以使用<code class="codeph">getObjectPendingFinalizationCount</code>的方法<code class="codeph">java.lang.management.MemoryMXBean</code>类。可以在“ <a href="diagnostic-tools.html#GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" title="JDK具有广泛的API，可以开发自定义工具来观察，监视，分析，调试和诊断JRE中部署的应用程序中的问题。">自定义诊断工具”中</a>找到指向API文档和示例代码的链接。可以轻松扩展示例代码，以包括未决终结计数的报告。</span></li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSTGD287"></a><div class="props_rev_3"><a id="GUID-79F26B47-9240-4F32-A817-1DD77A361F31" name="GUID-79F26B47-9240-4F32-A817-1DD77A361F31"></a><h3 id="JSTGD-GUID-79F26B47-9240-4F32-A817-1DD77A361F31" class="sect3">诊断本机代码泄漏</h3>
               <div>
                  <p>可以使用多种技术来查找和隔离本机代码内存泄漏。通常，对于所有平台都没有理想的解决方案。</p>
                  <p>以下是一些诊断本机代码泄漏的技术。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-06976380-65AC-4455-BBFC-94BC02A42BBC" title="可用于跟踪所有内存分配和该内存使用情况的工具。">跟踪所有内存分配和免费通话</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-7AF676F1-D313-4AE2-BE62-37176A103A13" title="如果编写JNI库，请考虑使用一种简单的包装方法，创建一种本地化的方法以确保您的库不会泄漏内存。">跟踪JNI库中的所有内存分配</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-24C06368-4F3D-4332-9069-0005145E24A7" title="可用于跟踪操作系统中的内存分配的工具。">在操作系统支持下跟踪内存分配</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" title="dbx调试器包括运行时检查（RTC）功能，该功能可以查找泄漏。dbx调试器是Oracle Solaris Studio的一部分，也可用于Linux。">使用dbx调试器查找泄漏</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-memory-leaks.html#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="首次在Oracle Solaris 9操作系统更新3中引入libumem.so库和模块化调试器mdb可用于调试内存泄漏。">使用libumem工具查找泄漏</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD288"></a><div class="props_rev_3"><a id="GUID-06976380-65AC-4455-BBFC-94BC02A42BBC" name="GUID-06976380-65AC-4455-BBFC-94BC02A42BBC"></a><h4 id="JSTGD-GUID-06976380-65AC-4455-BBFC-94BC02A42BBC" class="sect4">跟踪所有内存分配和免费通话</h4>
                  <div>
                     <p>可用于跟踪所有内存分配和该内存使用情况的工具。</p>
                     <div class="section">
                        <p>一种非常普遍的做法是跟踪所有分配和本机分配的免费调用。这可以是相当简单的过程，也可以是非常复杂的过程。多年来，围绕跟踪本机堆分配和使用该内存建立了许多产品。</p>
                        <p>诸如IBM Rational Purify之类的工具以及Sun Studio的运行时检查功能<code class="codeph">dbx</code>调试器可用于在正常的本机代码情况下查找这些泄漏，还可以查找对本机堆内存的任何访问，这些访问代表未初始化内存的分配或对释放的内存的访问。请参见<a href="troubleshoot-memory-leaks.html#GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" title="dbx调试器包括运行时检查（RTC）功能，该功能可以查找泄漏。dbx调试器是Oracle Solaris Studio的一部分，也可用于Linux。">使用dbx调试器查找泄漏</a> 。
                        </p>
                        <p>并非所有这些类型的工具都可以与使用本机代码的Java应用程序一起使用，并且通常这些工具是特定于平台的。由于虚拟机会在运行时动态创建代码，因此这些工具可能会错误地解释代码，导致根本无法运行，或者提供错误的信息。请与您的工具供应商联系，以确保该工具的版本与您使用的虚拟机的版本兼容。</p>
                        <p>有关许多简单且可移植的本机内存泄漏检测示例，请参见<a href="http://sourceforge.net/" target="_blank">sourceforge</a> 。大多数库和工具都假定您可以重新编译或编辑应用程序的源，并将包装函数放在分配函数之上。这些工具中功能更强大的功能使您可以通过动态插入这些分配函数来保持应用程序不变。库就是这种情况<code class="codeph">libumem.so</code>首先在Oracle Solaris 9操作系统更新3中引入；请参阅<a href="troubleshoot-memory-leaks.html#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="首次在Oracle Solaris 9操作系统更新3中引入libumem.so库和模块化调试器mdb可用于调试内存泄漏。">使用libumem工具查找泄漏</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD289"></a><div class="props_rev_3"><a id="GUID-7AF676F1-D313-4AE2-BE62-37176A103A13" name="GUID-7AF676F1-D313-4AE2-BE62-37176A103A13"></a><h4 id="JSTGD-GUID-7AF676F1-D313-4AE2-BE62-37176A103A13" class="sect4">跟踪JNI库中的所有内存分配</h4>
                  <div>
                     <p>如果编写JNI库，请考虑使用一种简单的包装方法，创建一种本地化的方法以确保您的库不会泄漏内存。</p>
                     <div class="section">
                        <p>以下示例中的过程是针对JNI库的一种简单的本地化分配跟踪方法。首先，在所有源文件中定义以下行。</p><pre class="pre codeblock"><code>#include &lt;stdlib.h&gt;
#define malloc(n) debug_malloc(n, __FILE__, __LINE__)
#define free(p) debug_free(p, __FILE__, __LINE__)
</code></pre><p>然后，您可以使用以下示例中的功能来监视泄漏。</p><pre class="pre codeblock"><code>/* Total bytes allocated */
static int total_allocated;
/* Memory alignment is important */
typedef union { double d; struct {size_t n; char *file; int line;} s; } Site;
void *
debug_malloc(size_t n, char *file, int line) 
{ 
    char *rp;
    rp = (char*)malloc(sizeof(Site)+n); 
    total_allocated += n; 
    ((Site*)rp)-&gt;s.n = n;
    ((Site*)rp)-&gt;s.file = file;
    ((Site*)rp)-&gt;s.line = line;
    return (void*)(rp + sizeof(Site));
}
void 
debug_free(void *p, char *file, int line)
{
    char *rp;
    rp = ((char*)p) - sizeof(Site);
    total_allocated -= ((Site*)rp)-&gt;s.n;
    free(rp);
}
</code></pre><p>然后，JNI库将需要定期（或在关闭时）检查<code class="codeph">total_allocated</code>变量以验证它是否有意义。前面的代码也可以扩展为将剩余的分配保存在链表中，并报告泄漏内存的分配位置。这是一种本地化和可移植的方式，可以在一组源中跟踪内存分配。您将需要确保<span class="apiname">debug_free（）</span>被调用只与来自<span class="apiname">debug_malloc（）</span>传来的指针，你也需要创建<span class="apiname">的realloc</span>类似的功能<span class="apiname">（），</span> <span class="apiname">释放calloc（）</span> <span class="apiname">的strdup（），</span>等等，如果他们被使用。
                        </p>
                        <p>寻找本机堆内存泄漏的更全局的方法涉及插入整个过程的库调用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD292"></a><div class="props_rev_3"><a id="GUID-24C06368-4F3D-4332-9069-0005145E24A7" name="GUID-24C06368-4F3D-4332-9069-0005145E24A7"></a><h4 id="JSTGD-GUID-24C06368-4F3D-4332-9069-0005145E24A7" class="sect4">在操作系统支持下跟踪内存分配</h4>
                  <div>
                     <p>可用于跟踪操作系统中的内存分配的工具。</p>
                     <div class="section">
                        <p>大多数操作系统都包含某种形式的全局分配跟踪支持。</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>在Windows上，搜索<a href="http://msdn.microsoft.com/library" target="_blank">MSDN库</a>以获得调试支持。Microsoft C ++编译器具有<code class="codeph">/Md</code>和<code class="codeph">/Mdd</code>编译器选项将自动包括对跟踪内存分配的额外支持。</span></li>
                        <li><span>Linux系统具有以下工具<code class="codeph">mtrace</code>和<code class="codeph">libnjamd</code>帮助处理分配跟踪。</span></li>
                        <li><span>Oracle Solaris操作系统提供了<code class="codeph">watchmalloc</code>工具。Oracle Solaris 9操作系统更新3还引入了<code class="codeph">libumem</code>工具。请参阅<a href="troubleshoot-memory-leaks.html#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="首次在Oracle Solaris 9操作系统更新3中引入libumem.so库和模块化调试器mdb可用于调试内存泄漏。">使用libumem工具查找泄漏</a> 。</span></li>
                     </ul>
                  </div>
               </div><a id="JSTGD293"></a><div class="props_rev_3"><a id="GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" name="GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D"></a><h4 id="JSTGD-GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" class="sect4">使用dbx调试器查找泄漏</h4>
                  <div>
                     <p>的<code class="codeph">dbx</code>调试器包括运行时检查（RTC）功能，该功能可以查找泄漏。的<code class="codeph">dbx</code>调试器是Oracle Solaris Studio的一部分，也可用于Linux。
                     </p>
                     <div class="section">
                        <p>以下示例显示了一个示例<code class="codeph">dbx</code>会议。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">dbx ${java_home}/bin/java</code></span>
Reading java
Reading ld.so.1
Reading libthread.so.1
Reading libdl.so.1
Reading libc.so.1
(dbx) <span class="bold"><code class="codeph">dbxenv rtc_inherit on</code></span>
(dbx) <span class="bold"><code class="codeph">check -leaks</code></span>
leaks checking - ON
(dbx) <span class="bold"><code class="codeph">run HelloWorld</code></span>
Running: java HelloWorld 
(process id 15426)
Reading rtcapihook.so
Reading rtcaudit.so
Reading libmapmalloc.so.1
Reading libgen.so.1
Reading libm.so.2
Reading rtcboot.so
Reading librtc.so
RTC: Enabling Error Checking...
RTC: Running program...
dbx: process 15426 about to exec("/net/bonsai.sfbay/export/home2/user/ws/j2se/build/solaris-i586/bin/java")
dbx: program "/net/bonsai.sfbay/export/home2/user/ws/j2se/build/solaris-i586/bin/java"
just exec'ed
dbx: to go back to the original program use "debug $oprog"
RTC: Enabling Error Checking...
RTC: Running program...
t@1 (l@1) stopped in main at 0x0805136d
0x0805136d: main       :        pushl    %ebp
(dbx) <span class="bold"><code class="codeph">when dlopen libjvm { suppress all in libjvm.so; }</code></span>
(2) when dlopen libjvm { suppress all in libjvm.so; }  
(dbx) <span class="bold"><code class="codeph">when dlopen libjava { suppress all in libjava.so; }</code></span>
(3) when dlopen libjava { suppress all in libjava.so; }  
(dbx) cont                                             
Reading libjvm.so
Reading libsocket.so.1
Reading libsched.so.1
Reading libCrun.so.1
Reading libm.so.1
Reading libnsl.so.1
Reading libmd5.so.1
Reading libmp.so.2
Reading libhpi.so
Reading libverify.so
Reading libjava.so
Reading libzip.so
Reading en_US.ISO8859-1.so.3
hello world
hello world
Checking for memory leaks...

Actual leaks report    (actual leaks:           27  total size:      46851 bytes)

  Total     Num of  Leaked     Allocation call stack
  Size      Blocks  Block
                    Address
==========  ====== =========== =======================================
     44376       4      -      calloc &lt; zcalloc 
      1072       1  0x8151c70  _nss_XbyY_buf_alloc &lt; get_pwbuf &lt; _getpwuid &lt;
                               GetJavaProperties &lt; Java_java_lang_System_initProperties &lt;
                               0xa740a89a&lt; 0xa7402a14&lt; 0xa74001fc
       814       1  0x8072518  MemAlloc &lt; CreateExecutionEnvironment &lt; main 
       280      10      -      operator new &lt; Thread::Thread 
       102       1  0x8072498  _strdup &lt; CreateExecutionEnvironment &lt; main 
        56       1  0x81697f0  calloc &lt; Java_java_util_zip_Inflater_init &lt; 0xa740a89a&lt;
                               0xa7402a6a&lt; 0xa7402aeb&lt; 0xa7402a14&lt; 0xa7402a14&lt; 0xa7402a14
        41       1  0x8072bd8  main 
        30       1  0x8072c58  SetJavaCommandLineProp &lt; main 
        16       1  0x806f180  _setlocale &lt; GetJavaProperties &lt;
                               Java_java_lang_System_initProperties &lt; 0xa740a89a&lt; 0xa7402a14&lt;
                               0xa74001fc&lt; JavaCalls::call_helper &lt; os::os_exception_wrapper 
        12       1  0x806f2e8  operator new &lt; instanceKlass::add_dependent_nmethod &lt;
                               nmethod::new_nmethod &lt; ciEnv::register_method &lt;
                               Compile::Compile #Nvariant 1 &lt; C2Compiler::compile_method &lt;
                               CompileBroker::invoke_compiler_on_method &lt;
                               CompileBroker::compiler_thread_loop 
        12       1  0x806ee60  CheckJvmType &lt; CreateExecutionEnvironment &lt; main 
        12       1  0x806ede8  MemAlloc &lt; CreateExecutionEnvironment &lt; main 
        12       1  0x806edc0  main 
         8       1  0x8071cb8  _strdup &lt; ReadKnownVMs &lt; CreateExecutionEnvironment &lt; main 
         8       1  0x8071cf8  _strdup &lt; ReadKnownVMs &lt; CreateExecutionEnvironment &lt; main 
</code></pre><p>输出显示<code class="codeph">dbx</code>如果在进程即将退出时未释放内存，调试器将报告内存泄漏。但是，在初始化时分配的，在进程生命周期中所需的内存通常永远不会在本机代码中释放。因此，在这种情况下， <code class="codeph">dbx</code>调试器可以报告不是真正泄漏的内存泄漏。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D__GUID-8E64CCB7-2ABF-4F1A-8C3F-3F94514665F1">
                              <p class="notep1">注意：</p>上一个示例使用了两个<code class="codeph">suppress</code>抑制虚拟机中报告的泄漏的命令： <code class="codeph">libjvm.so</code>和Java支持库， <code class="codeph">libjava.so</code> 。
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD295"></a><div class="props_rev_3"><a id="GUID-28DC43A9-45EB-459C-975E-51689886126D" name="GUID-28DC43A9-45EB-459C-975E-51689886126D"></a><h4 id="JSTGD-GUID-28DC43A9-45EB-459C-975E-51689886126D" class="sect4">使用libumem工具查找泄漏</h4>
                  <div>
                     <p>在Oracle Solaris 9操作系统更新3中首次引入<code class="codeph">libumem.so</code>库和模块化调试器<code class="codeph">mdb</code>可用于调试内存泄漏。
                     </p>
                     <div class="p">
                        <p>使用之前<code class="codeph">libumem</code> ，您必须预先加载<code class="codeph">libumem</code>库并设置环境变量，如以下示例所示。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="pre codeblock"><code>$ LD_PRELOAD=libumem.so
$ export LD_PRELOAD
$ UMEM_DEBUG=default
$ export UMEM_DEBUG
</code></pre><p>现在，运行Java应用程序，但是在退出之前将其停止。以下示例使用<code class="codeph">truss</code>当它调用<code class="codeph">_exit</code>系统调用。
                        </p><pre class="pre codeblock"><code>$ truss -f -T _exit java MainClass <span class="variable" translate="no">arguments</span>
</code></pre><p>此时，您可以附加<code class="codeph">mdb</code>调试器，如以下示例所示。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">mdb -p </code></span><span class="italic"><span class="bold"><code class="codeph">pid</code></span></span>
&gt;<span class="bold"><code class="codeph">::findleaks</code></span>
</code></pre><p>的<code class="codeph">::findleaks</code>命令是<code class="codeph">mdb</code>命令以查找内存泄漏。如果发现泄漏，则此命令将打印分配调用的地址，缓冲区地址和最近的符号。
                        </p>
                        <p>也可以通过转储内存来获取导致内存泄漏的分配的堆栈跟踪。 <code class="codeph">bufctl</code>结构体。该结构的地址可以从<code class="codeph">::findleaks</code>命令。
                        </p>
                        <p>请参阅<a href="https://docs.oracle.com/docs/cd/E19424-01/820-4814/geogv/" target="_blank">使用分析内存泄漏<code class="codeph">libumem</code></a>解决内存泄漏的原因。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>