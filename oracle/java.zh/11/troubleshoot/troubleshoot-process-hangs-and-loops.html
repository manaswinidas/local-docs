<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter provides information and guidance about some specific procedures for troubleshooting hanging or looping processes.">
      <meta name="description" content="This chapter provides information and guidance about some specific procedures for troubleshooting hanging or looping processes.">
      <title>解决进程挂起和循环问题</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="This chapter provides information and guidance about some specific procedures for troubleshooting hanging or looping processes.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="troubleshoot-system-crashes.html" title="Previous" type="text/html">
      <link rel="next" href="handle-signals-and-exceptions.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="troubleshoot-system-crashes.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="handle-signals-and-exceptions.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="debug-jvm-issues.html" property="item" typeof="WebPage"><span property="name">调试JVM问题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">解决进程挂起和循环问题</li>
            </ol>
            <a id="GUID-0777035D-123C-4DC5-A241-21560882C7BB" name="GUID-0777035D-123C-4DC5-A241-21560882C7BB"></a><a id="JSTGD336"></a><a id="JSTGD335"></a>
            
            <h2 id="JSTGD-GUID-0777035D-123C-4DC5-A241-21560882C7BB" class="sect2"><span class="enumeration_chapter">6</span>对过程挂起和循环进行故障排除</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本章提供有关对挂起或循环过程进行故障排除的某些特定过程的信息和指南。</span></div>
               <p>可能会出现涉及挂起或循环过程的问题。挂起可能有多种原因，但通常是由于应用程序代码，API代码或库代码中的死锁引起的。挂起可能是由于Java HotSpot VM中的错误所致。</p>
               <p>有时，明显的挂起实际上是一个循环。例如，VM进程中的错误导致一个或多个线程进入无限循环，可能会消耗所有可用的CPU周期。</p>
               <p>诊断挂起的第一步是确定VM进程是否空闲或消耗了所有可用的CPU周期。您可以使用本机操作系统（OS）实用程序执行此操作。如果该进程似乎很忙并且正在消耗所有可用的CPU周期，则问题可能出在线程循环而不是死锁。例如，在Oracle Solaris操作系统上，命令<code class="codeph">prstat -L -p <span class="variable" translate="no">pid</span></code>可以用于报告目标进程中所有轻量级进程（LWP）的统计信息，因此可以识别消耗大量CPU周期的线程。
               </p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-8D398808-91BF-4AC5-B516-109E2DC41413" title="如果VM进程似乎正在循环，则第一步是尝试获取线程转储。如果可以获得线程转储，则通常会清楚哪个线程在循环。如果可以识别出正在循环的线程，则线程转储中的跟踪堆栈可以提供有关线程正在循环的位置（可能是为什么）的方向。">诊断循环过程</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-E36E9610-5EC9-4AB4-8F6B-EB479205DDC3" title="使用线程转储来诊断挂起的进程。">诊断挂起进程</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-CA219DD8-7862-4924-8353-6A9C76369E06">Oracle Solaris 8线程库</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD337"></a><div class="props_rev_3"><a id="GUID-8D398808-91BF-4AC5-B516-109E2DC41413" name="GUID-8D398808-91BF-4AC5-B516-109E2DC41413"></a><h3 id="JSTGD-GUID-8D398808-91BF-4AC5-B516-109E2DC41413" class="sect3">诊断循环过程</h3>
               <div>
                  <p>如果VM进程似乎正在循环，则第一步是尝试获取线程转储。如果可以获得线程转储，则通常会清楚哪个线程在循环。如果可以识别出正在循环的线程，则线程转储中的跟踪堆栈可以提供有关线程正在循环的位置（可能是为什么）的方向。</p>
                  <div class="section">
                     <p>如果应用程序控制台（标准输入/输出）可用，则按Control + \组合键（在Oracle Solaris或Linux上）或Control + Break组合键（在Windows上）以使HotSpot VM打印线程转储，包括线程状态。在Oracle Solaris和Linux操作系统上，也可以通过发送一个<code class="codeph">SIGQUIT</code>到过程（命令<code class="codeph">kill -QUIT <span class="variable" translate="no">pid</span></code> ）。在这种情况下，线程转储将打印到目标进程的标准输出。输出可能会定向到文件，具体取决于启动过程的方式。
                     </p>
                     <p>如果Java进程以<code>-XX:+PrintClassHistogram</code>命令行选项，然后Control + Break处理程序将生成一个堆直方图。
                     </p>
                     <p>如果可以获得线程转储，那么一个不错的起点是位于线程库中的线程的线程堆栈。 <code class="codeph">RUNNABLE</code>州。有关<a href="diagnostic-tools.html#GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" title="线程转储由虚拟机中所有Java线程的线程堆栈（包括线程状态）组成。">线程转储</a>的格式以及线程转储中可能的线程状态的表的更多信息，请参见线程转储。在某些情况下，可能有必要获取一系列的线程转储，以确定哪些线程看起来一直很忙。
                     </p>
                     <p>如果应用程序控制台不可用（例如，该进程在后台运行，或者VM输出定向到未知位置），则<code class="codeph">jstack</code>实用程序可用于获取堆栈线程。有关<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="Use the jcmd utility, instead of jcmd utility to diagnose problems with JVM and Java applications.">此实用程序</a>输出的更多信息，请参见<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack实用</a>程序。的<code class="codeph">jstack</code>如果线程转储没有提供任何证据表明Java线程正在循环，则也应使用该实用程序。
                     </p>
                     <p>在查看输出时<code class="codeph">jstack</code>实用程序，首先着眼于<code class="codeph">RUNNABLE</code>州。对于繁忙且可能正在循环的线程，这是最可能的状态。可能有必要执行<code class="codeph">jstack</code>很多次可以更好地了解正在循环的线程。如果线程似乎总是存在于<code class="codeph">RUNNABLE</code>状态，然后<code>-m</code>选项可用于打印本机框架并提供有关线程正在做什么的进一步提示。如果线程在运行中似乎连续循环<code class="codeph">RUNNABLE</code>状态，则表明可能存在潜在的HotSpot VM错误，需要进一步调查。
                     </p>
                     <p>如果VM不响应Control + \，则这可能表示VM错误，而不是应用程序或库代码出现问题。在这种情况下，请使用<code class="codeph">jstack</code>与<code>-m</code>为所有线程获取线程堆栈的选项。输出将包括VM内部线程的线程堆栈。在此堆栈跟踪中，标识似乎没有在等待的线程。例如，在Oracle Solaris操作系统上，您可以确定函数中未包含的线程，例如<code class="codeph">__lwp_cond_wait</code> ， <code class="codeph">__lwp_park</code> ， <code class="codeph">___pollsys</code>或其他阻止功能。如果循环似乎是由VM错误引起的，请收集尽可能多的数据并提交错误报告。有关数据收集的更多信息，请参见<a href="submit-bug-report.html#GUID-DB465A9C-03FA-4324-BFF9-45BF9699F349" title="有关如何提交错误报告的指南。它包括有关提交报告之前应尝试的操作以及为该报告收集哪些数据的建议。">提交错误报告</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD338"></a><div class="props_rev_3"><a id="GUID-E36E9610-5EC9-4AB4-8F6B-EB479205DDC3" name="GUID-E36E9610-5EC9-4AB4-8F6B-EB479205DDC3"></a><h3 id="JSTGD-GUID-E36E9610-5EC9-4AB4-8F6B-EB479205DDC3" class="sect3">诊断挂起进程</h3>
               <div>
                  <p>使用线程转储来诊断挂起的进程。</p>
                  <div class="section">
                     <p>如果该应用程序似乎已挂起，并且该进程似乎处于空闲状态，则第一步是尝试获取线程转储。如果应用程序控制台可用，则按Control + \（在Oracle Solaris或Linux上）或Control + Break（在Windows上）以使HotSpot VM打印线程转储。在Oracle Solaris和Linux操作系统上，也可以通过发送一个<code class="codeph">SIGQUIT</code>到过程（命令<code class="codeph">kill -QUIT <span class="variable" translate="no">pid</span></code> ）。如果挂起的进程可以生成线程转储，则输出将打印到目标进程的标准输出。
                     </p>
                     <p>打印线程转储后，HotSpot VM执行死锁检测算法。</p>
                     <p>以下各节描述了挂起进程的各种情况。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-5A88BA3D-D0FC-466F-B5B9-566ED0D62DF1" title="如果检测到死锁，它将与死锁中涉及的线程的堆栈跟踪一起打印。">检测到死锁</a></p>
                        </li>
                        <li>
                           <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-8B8DE8E0-D7E3-48A9-96EB-77BC1128100D" title="如果打印了线程转储并且未找到死锁，则问题可能是一个错误，其中一个线程正在等待一个从不通知的监视器。这可能是时序问题或一般的逻辑错误。">未检测到死锁</a></p>
                        </li>
                        <li>
                           <p><a href="troubleshoot-process-hangs-and-loops.html#GUID-88307E36-5BA7-4EF7-B90D-5B8F028E7890" title="如果VM死锁或挂起，请使用jstack命令。">没有线程转储</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSTGD339"></a><div class="props_rev_3"><a id="GUID-5A88BA3D-D0FC-466F-B5B9-566ED0D62DF1" name="GUID-5A88BA3D-D0FC-466F-B5B9-566ED0D62DF1"></a><h4 id="JSTGD-GUID-5A88BA3D-D0FC-466F-B5B9-566ED0D62DF1" class="sect4">检测到死锁</h4>
                  <div>
                     <p>如果检测到死锁，它将与死锁中涉及的线程的堆栈跟踪一起打印。</p>
                     <p>以下示例显示了这种情况的堆栈跟踪。</p><pre class="pre codeblock"><code>Found one Java-level deadlock:
=============================
"AWT-EventQueue-0":
  waiting to lock monitor 0x000ffbf8 (object 0xf0c30560, a java.awt.Component$AWTTreeLock),
  which is held by "main"
"main":
  waiting to lock monitor 0x000ffe38 (object 0xf0c41ec8, a java.util.Vector),
  which is held by "AWT-EventQueue-0"

Java stack information for the threads listed above:
===================================================
"AWT-EventQueue-0":
        at java.awt.Container.removeNotify(Container.java:2503)
        - waiting to lock &lt;0xf0c30560&gt; (a java.awt.Component$AWTTreeLock)
        at java.awt.Window$1DisposeAction.run(Window.java:604)
        at java.awt.Window.doDispose(Window.java:617)
        at java.awt.Dialog.doDispose(Dialog.java:625)
        at java.awt.Window.dispose(Window.java:574)
        at java.awt.Window.disposeImpl(Window.java:584)
        at java.awt.Window$1DisposeAction.run(Window.java:598)
        - locked &lt;0xf0c41ec8&gt; (a java.util.Vector)
        at java.awt.Window.doDispose(Window.java:617)
        at java.awt.Window.dispose(Window.java:574)
        at javax.swing.SwingUtilities$SharedOwnerFrame.dispose(SwingUtilities.java:1743)
        at javax.swing.SwingUtilities$SharedOwnerFrame.windowClosed(SwingUtilities.java:1722)
        at java.awt.Window.processWindowEvent(Window.java:1173)
        at javax.swing.JDialog.processWindowEvent(JDialog.java:407)
        at java.awt.Window.processEvent(Window.java:1128)
        at java.awt.Component.dispatchEventImpl(Component.java:3922)
        at java.awt.Container.dispatchEventImpl(Container.java:2009)
        at java.awt.Window.dispatchEventImpl(Window.java:1746)
        at java.awt.Component.dispatchEvent(Component.java:3770)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:463)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:214)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
"main":
        at java.awt.Window.getOwnedWindows(Window.java:844)
        - waiting to lock &lt;0xf0c41ec8&gt; (a java.util.Vector)
        at javax.swing.SwingUtilities$SharedOwnerFrame.installListeners(SwingUtilities.java:1697)
        at javax.swing.SwingUtilities$SharedOwnerFrame.addNotify(SwingUtilities.java:1690)
        at java.awt.Dialog.addNotify(Dialog.java:370)
        - locked &lt;0xf0c30560&gt; (a java.awt.Component$AWTTreeLock)
        at java.awt.Dialog.conditionalShow(Dialog.java:441)
        - locked &lt;0xf0c30560&gt; (a java.awt.Component$AWTTreeLock)
        at java.awt.Dialog.show(Dialog.java:499)
        at java.awt.Component.show(Component.java:1287)
        at java.awt.Component.setVisible(Component.java:1242)
        at test01.main(test01.java:10)

Found 1 deadlock.
</code></pre><p>默认死锁检测适用于使用synced关键字获得的锁，以及使用<code class="codeph">java.util.concurrent</code>包。如果Java VM标志<code>-XX:+PrintConcurrentLocks</code>设置后，堆栈跟踪还将显示锁所有者列表。
                     </p>
                     <p>如果检测到死锁，则必须更详细地检查输出以了解死锁。在前面的示例中，线程<code class="codeph">main</code>正在锁定对象<code class="codeph">0xf0c30560</code>并等待进入<code class="codeph">0xf0c41ec8</code> ，该线程已被线程锁定<code class="codeph">AWT-EventQueue-0</code> 。但是，线程<code class="codeph">AWT-EventQueue-0</code>正在等待进入<code class="codeph">0xf0c30560</code> ，由<code class="codeph">main</code> 。
                     </p>
                     <p>堆栈跟踪中的详细信息提供了可帮助您找到死锁的信息。</p>
                  </div>
               </div><a id="JSTGD341"></a><div class="props_rev_3"><a id="GUID-8B8DE8E0-D7E3-48A9-96EB-77BC1128100D" name="GUID-8B8DE8E0-D7E3-48A9-96EB-77BC1128100D"></a><h4 id="JSTGD-GUID-8B8DE8E0-D7E3-48A9-96EB-77BC1128100D" class="sect4">未检测到死锁</h4>
                  <div>
                     <p>如果打印了线程转储并且未找到死锁，则问题可能是一个错误，其中一个线程正在等待一个从不通知的监视器。这可能是时序问题或一般的逻辑错误。</p>
                     <p>要查找有关此问题的更多信息，请检查线程转储中的每个线程以及在其中阻塞的每个线程<code class="codeph">Object.wait()</code> 。堆栈跟踪中的调用者框架指示正在调用的类和方法。 <code class="codeph">wait()</code>方法。如果代码是使用行号信息编译的（默认设置），则这将为要检查的代码提供指导。在大多数情况下，您必须具有应用程序逻辑或库的一些知识才能进一步诊断此问题。通常，您必须了解同步在应用程序中的工作方式，以及有关何时何地通知监视器的详细信息和条件。
                     </p>
                  </div>
               </div><a id="JSTGD342"></a><div class="props_rev_3"><a id="GUID-88307E36-5BA7-4EF7-B90D-5B8F028E7890" name="GUID-88307E36-5BA7-4EF7-B90D-5B8F028E7890"></a><h4 id="JSTGD-GUID-88307E36-5BA7-4EF7-B90D-5B8F028E7890" class="sect4">没有线程转储</h4>
                  <div>
                     <p>如果虚拟机死锁或挂起，请使用<code class="codeph">jstack</code>命令。
                     </p>
                     <p>如果VM不响应Control + \或Control + Break，则VM可能由于某些其他原因而死锁或挂起。在这种情况下，请使用<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack Utility</a>获得线程转储。这也适用于无法访问应用程序或输出定向到未知位置的情况。
                     </p>
                     <p>在里面<code class="codeph">jstack</code>输出，检查中的每个线程<code class="codeph">BLOCKED</code>州。顶部框架有时可以指示为什么线程被阻止（例如， <code class="codeph">Object.wait</code>要么<code class="codeph">Thread.sleep</code> ）。堆栈的其余部分将指示线程在做什么。当使用行号信息（默认）编译源代码时，尤其如此，并且您可以交叉引用源代码。
                     </p>
                     <p>如果线程在<code class="codeph">BLOCKED</code>状态和原因不清楚，然后使用<code class="codeph">-m</code>选项以获取混合堆栈。使用混合堆栈输出，应该可以确定线程被阻塞的原因。如果某个线程在尝试输入同步方法或块时被阻止，那么您将看到诸如<code class="codeph">ObjectMonitor::enter</code>在堆栈顶部附近。以下示例显示了一个混合堆栈输出示例。
                     </p><pre class="pre codeblock"><code>----------------- t@13 -----------------
0xff31e8b8      ___lwp_cond_wait + 0x4
0xfea8c810      void ObjectMonitor::EnterI(Thread*) + 0x2b8
0xfeac86b8      void ObjectMonitor::enter2(Thread*) + 0x250
:
</code></pre><p>中的线程<code class="codeph">RUNNABLE</code>状态也可能被阻止。混合堆栈中的前几帧应指示线程在做什么。
                     </p>
                     <p>要检查的一个特定线程是<code class="codeph">VMThread</code> 。这是用于执行诸如垃圾回收（GC）之类的操作的特殊线程。可以将其标识为正在执行的线程<code class="codeph">VMThread::run()</code>在其初始帧中。在Oracle Solaris上，通常<code class="codeph">t@4</code> 。在Linux上，应使用C ++乱码名称进行识别<code class="codeph">_ZN8VMThread4loopEv</code> 。
                     </p>
                     <p>通常，VM线程处于以下三种状态之一：等待执行VM操作，同步所有线程以准备VM操作或执行VM操作。如果您认为挂起是HotSpot VM错误而不是应用程序或类库死锁，请特别注意VM线程。</p>
                     <p>如果VM线程似乎卡在其中<code class="codeph">SafepointSynchronize::begin</code> ，则可能表明将虚拟机带入安全点的问题。安全点表示VM中正在执行的所有线程均被阻塞，并在等待特殊操作（例如GC）完成。
                     </p>
                     <p>如果VM线程似乎卡在其中<code class="codeph">function</code> ，在哪里<code class="codeph">function</code>结束于<code class="codeph">doit</code> ，那么这也可能表示VM问题。
                     </p>
                     <p>通常，如果可以从命令行执行应用程序，并且进入虚拟机不响应Control + \或Control + Break的状态，则很有可能是您发现了VM Bug（线程库问题） ，或另一个库中的错误。发生这种情况时，请进行故障转储。请参阅<a href="submit-bug-report.html#GUID-597FDBF7-68A6-47CC-869D-F9B8849AB7DC" title="生成和收集核心转储（也称为崩溃转储）的过程。核心转储或崩溃转储是正在运行的进程的内存快照。">收集核心转储，</a>以获取有关收集尽可能多的信息并提交错误报告或致电支持的说明。
                     </p>
                     <p>在挂起进程的上下文中要提及的另一种工具是<code class="codeph">pstack</code> Oracle Solaris操作系统上的实用程序。在Oracle Solaris 8和9操作系统上，此实用程序将在目标进程中打印LWP的线程堆栈。在Oracle Solaris 10操作系统上，从JDK 5.0发行版开始，输出为<code class="codeph">pstack</code>与来自以下设备的输出类似但不完全相同<code class="codeph">jstack -m</code> 。与<code class="codeph">jstack</code> ，Oracle Solaris 10操作系统的实现<code class="codeph">pstack</code>打印完全限定的类名，方法名和字节码索引（BCI）。对于使用行号信息编译源的情况，它还将打印行号（默认）。这对熟悉Oracle Solaris操作系统上其他实用程序的功能的开发人员和管理员很有用。 <code class="codeph">/proc</code>文件系统。
                     </p>
                     <p>的等效工具<code class="codeph">pstack</code>在Linux上是<code class="codeph">lsstack</code> 。该实用程序包含在某些发行版中，或者从<a href="http://sourceforge.net" target="_blank">sourceforge</a>获得。在撰写本文时， <code class="codeph">lsstack</code>仅报告本机帧。
                     </p>
                  </div>
               </div>
            </div><a id="JSTGD344"></a><div class="props_rev_3"><a id="GUID-CA219DD8-7862-4924-8353-6A9C76369E06" name="GUID-CA219DD8-7862-4924-8353-6A9C76369E06"></a><h3 id="JSTGD-GUID-CA219DD8-7862-4924-8353-6A9C76369E06" class="sect3">Oracle Solaris 8线程库</h3>
               <div>
                  <p>Oracle Solaris 8操作系统上的默认线程库通常称为T1库。该线程库实现了<span class="variable" translate="no">m</span> ： <span class="variable" translate="no">n</span>线程模型，其中<span class="variable" translate="no">m</span>用户线程映射到<span class="variable" translate="no">n</span>内核级线程（LWP）。Oracle Solaris 8操作系统在以下版本中还附带了一个替代的和较新的线程库： <code>/usr/lib/lwp</code> 。备用线程库通常称为T2库，它成为Oracle Solaris 9和10操作系统中的默认线程库。在早期版本的J2SE（尤其是1.4.0之前的版本）中，默认线程库存在许多问题（例如，线程库中的错误，LWP同步问题或LWP匮乏）。LWP饥饿是一种场景，其中的用户线程<code class="codeph">RUNNABLE</code>状态，但没有可用的内核级线程。
                  </p>
                  <p>尽管引用的问题是历史性的，但应注意的是，当JDK软件部署在Oracle Solaris 8操作系统上时，默认情况下仍使用T1库。LWP饥饿类型问题不会发生，因为JDK版本使用“绑定线程”，因此每个用户线程都绑定到一个内核线程。但是，如果遇到您认为是线程库问题的问题（例如挂起），则可以通过在/ usr / lib / lwp中添加/ usr / lib / lwp来指示HotSpot VM使用T2库。 <code class="codeph">LD_LIBRARY_PATH</code> 。要检查是否正在使用T2库，请发出命令<code class="codeph">pldd <span class="variable" translate="no">pid</span></code>列出指定进程加载的库。
                  </p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>