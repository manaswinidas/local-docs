<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter provides information and guidance on some specific procedures for troubleshooting some of the most common issues that might be found in the Java SE Swing API.">
      <meta name="description" content="This chapter provides information and guidance on some specific procedures for troubleshooting some of the most common issues that might be found in the Java SE Swing API.">
      <title>摇摆</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="This chapter provides information and guidance on some specific procedures for troubleshooting some of the most common issues that might be found in the Java SE Swing API.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-2d.html" title="Previous" type="text/html">
      <link rel="next" href="internationalization.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-2d.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="internationalization.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="debug-client-issues.html" property="item" typeof="WebPage"><span property="name">调试客户端问题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">摇摆</li>
            </ol>
            <a id="GUID-F09B98F1-AA52-49FB-B695-3BC0754860CD" name="GUID-F09B98F1-AA52-49FB-B695-3BC0754860CD"></a><a id="JSTGD462"></a><a id="JSTGD461"></a>
            
            <h2 id="JSTGD-GUID-F09B98F1-AA52-49FB-B695-3BC0754860CD" class="sect2"><span class="enumeration_chapter">13</span>秋千</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章提供有关一些特定过程的信息和指南，以对Java SE Swing API中可能发现的一些最常见问题进行故障排除。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="swing.html#GUID-C7D3DA57-ABEE-41B7-AEDD-8AE340323FBC" title="在Java SE 6中，Swing的绘画基础结构发生了很大的变化。如果发现Java SE 6或更高版本中特定的绘画工件，则可以尝试关闭新功能。这可以通过属性swing.bufferPerWindow来完成。">Swing的一般调试提示</a></p>
                  </li>
                  <li>
                     <p><a href="swing.html#GUID-06A687BD-D9D9-48D6-8CF2-FA9F4C52207F" title="Swing的特定调试技巧，并提供了可能的问题和解决方法的示例。">Swing的特定调试提示</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD463"></a><div class="props_rev_3"><a id="GUID-C7D3DA57-ABEE-41B7-AEDD-8AE340323FBC" name="GUID-C7D3DA57-ABEE-41B7-AEDD-8AE340323FBC"></a><h3 id="JSTGD-GUID-C7D3DA57-ABEE-41B7-AEDD-8AE340323FBC" class="sect3">Swing的一般调试提示</h3>
               <div>
                  <p>在Java SE 6中，Swing的绘画基础结构发生了很大的变化。如果发现Java SE 6或更高版本中特定的绘画工件，则可以尝试关闭新功能。这可以通过属性来完成<code class="codeph">swing.bufferPerWindow</code> 。
                  </p>
                  <p>在调试弹出菜单时执行的Swing代码时，建议远程使用调试器。否则，调试过程和应用程序执行会相互阻塞，这将阻止进一步使用系统。如果发生这种情况，唯一可以采取的措施是针对Oracle Solaris和Linux杀死X服务器。请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6517045" target="_blank">错误数据库</a> 。
                  </p>
                  <p>以下是一些常见的Swing问题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>绘画。</p>
                     </li>
                     <li>
                        <p>渲染器。</p>
                     </li>
                     <li>
                        <p>从错误的线程更新模型。</p>
                     </li>
                     <li>
                        <p>挂了</p>
                     </li>
                     <li>
                        <p>反应灵敏。</p>
                     </li>
                     <li>
                        <p>重涂问题。</p>
                     </li>
                     <li>
                        <p><code class="codeph">isOpaque</code>用法。
                        </p>
                     </li>
                     <li>
                        <p>启动：可能是由小的堆导致的，加载了不必要的类。</p>
                     </li>
                  </ul>
                  <p>以下是需要考虑的一些事项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>每窗口缓冲区功能。</p>
                     </li>
                     <li>
                        <p>原生的外观保真度：Gnome vs Windows</p>
                     </li>
                     <li>
                        <p>Swing应用程序的足迹。</p>
                     </li>
                     <li>
                        <p><code class="codeph">JTable</code> ， <code class="codeph">JTree</code>和<code class="codeph">JList</code>全部使用渲染器。
                        </p>
                     </li>
                     <li>
                        <p>确保自定义渲染器的工作尽可能少。</p>
                     </li>
                     <li>
                        <p>仅从事件分配线程更新模型。否则，显示内容将无法反映模型的状态。</p>
                     </li>
                  </ul>
                  <p>以下标识不良渲染器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>应用程序运行缓慢，尤其是在滚动时。</p>
                     </li>
                     <li>
                        <p>使用优化程序观看绘画呼叫，查找对<code class="codeph">getTableCellTRendererComponent</code> 。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="JSTGD464"></a><div class="props_rev_3"><a id="GUID-06A687BD-D9D9-48D6-8CF2-FA9F4C52207F" name="GUID-06A687BD-D9D9-48D6-8CF2-FA9F4C52207F"></a><h3 id="JSTGD-GUID-06A687BD-D9D9-48D6-8CF2-FA9F4C52207F" class="sect3">Swing的特定调试提示</h3>
               <div>
                  <p>Swing的特定调试技巧，并提供了可能的问题和解决方法的示例。</p>
                  <p>以下主题描述了Swing和故障排除技术中的问题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="swing.html#GUID-2B4B8143-1731-43DA-BD79-B58996D96F7B" title="随机异常和绘画问题通常是Swing错误使用线程的结果。">线程错误</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-BABA5847-91DD-4318-87EB-60787434E90A" title="如果允许JComponent的子代重叠，则可能出现绘画问题的另一个来源。">JComponent儿童重叠</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-5EE04B57-0E04-454F-AD9B-50FCCAF93A42" title="如果您在需要更新显示时未正确调用重新绘制，则会出现绘制问题的另一个来源。">显示更新</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-391FD503-7B22-4A46-8446-8917B33F5BAC" title="更改Swing组件的可见属性时，调用重绘，而在模型更改时，也不需要调用重绘。">型号变更</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-879FC96E-074F-4681-A531-D2D023E2DBB8" title="添加或删除组件时，必须手动调用重新绘制或重新验证Swing和AWT。">添加或删除组件</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-99980EF9-93D8-412F-8DDF-442B6C56769A" title="绘画问题的另一个可能领域是组件是否不覆盖不透明。">不透明替代</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-1C90A220-FB64-4D38-8152-A719F02B7BF2" title="不要对传递给paint，paintComponent或paintChildren的Graphics进行任何永久更改。">永久更改图形</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-6A7C9FCB-74FA-4D52-943B-6E0C6E233F32" title="尽管您可以覆盖绘画并在覆盖中进行自定义绘画，但您应该替代重写paintComponent。">自定义绘画和双缓冲</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-61A3C658-DE21-4871-BEC5-A1DC6803273D" title="Swing的绘画架构需要一个不透明的内容窗格。">不透明内容窗格</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-0247F7FD-119D-484E-818F-8FD843F711BD" title="为每个单元绘制渲染器，因此请确保渲染器的工作尽可能少。">渲染器要求每个单元的性能</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-E17A2C90-C781-42A3-9275-33F0575FEE5A" title="如果模型的生命周期长于使用该模型的组件的窗口的生命周期，则必须将Swing组件的模型显式设置为null。">可能的泄漏</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-3CF05078-9B07-48F3-8B69-8D8F4400847C" title="只要重量级组件与任何现有的Swing组件不重叠，就可以在某些情况下混合使用重量级和轻量级的组件。">混合重量级和轻量级组件</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-79AA3986-FEF1-49D7-B107-23A0070C8359" title="合成器是一块空的画布。">使用合成器</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-56FCD857-F29C-4661-9C86-197A39EEAE7D" title="如果Swing应用程序尝试在事件分配线程上执行过多操作，则该应用程序将显得呆滞且无响应。">跟踪事件调度线程上的活动</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-7D0AF4DE-3261-4EAC-8CCE-F7D9B09DB6F9" title="可能是由于Swing组件上的默认布局管理器类不同而引起的。">指定默认布局管理器</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-6BC5FDA9-9DBE-4BCA-8635-E2FFD12F2C85" title="MouseListener对象被调度到具有MouseListener对象（或已启用MouseEvent对象）的最深组件。">侦听器对象调度到不正确的组件</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-51E79950-8FDC-40CB-AFC9-5BE9849CC18F" title="您必须将JFrame，JWindow或JDialog组件添加到内容窗格中。">将组件添加到内容窗格</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-DB8214A9-E866-4462-83C4-569DE74E7F77" title="使用Swing时，应使用TransferHandler提供的Swing拖放支持。">拖放支持</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-2B32B552-38AB-4709-86DC-A1F6FBDDE911" title="请记住，一个组件一次只能存在于一个父对象中。">一个组件的父代</a></p>
                     </li>
                     <li>
                        <p><a href="swing.html#GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09" title="JFileChooser类在Windows OS（.lnk文件）上不支持快捷方式。">Windows快捷方式的JFileChooser问题</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD465"></a><div class="props_rev_3"><a id="GUID-2B4B8143-1731-43DA-BD79-B58996D96F7B" name="GUID-2B4B8143-1731-43DA-BD79-B58996D96F7B"></a><h4 id="JSTGD-GUID-2B4B8143-1731-43DA-BD79-B58996D96F7B" class="sect4">线程错误</h4>
                  <div>
                     <p>随机异常和绘画问题通常是Swing错误使用线程的结果。</p>
                     <div class="section">
                        <p>除非在javadoc中有特别说明，否则<span class="italic">所有</span>对Swing组件的访问都必须在事件分发线程上进行。这包括任何型号（ <code class="codeph">TableModel</code> ， <code class="codeph">ListModel</code>和其他）。
                        </p>
                        <p>检查Swing是否使用不当的最佳方法是使用检测到的<code class="codeph">RepaintManager</code> ，如以下示例所示。
                        </p><pre class="pre codeblock"><code>public class CheckThreadViolationRepaintManager extends RepaintManager {
     // it is recommended to pass the complete check
     private boolean completeCheck = true;

     public boolean isCompleteCheck() {
         return completeCheck;
     }

     public void setCompleteCheck(boolean completeCheck) {
         this.completeCheck = completeCheck;
     }

     public synchronized void addInvalidComponent(JComponent component) {
         checkThreadViolations(component);
         super.addInvalidComponent(component);
     }

     public void addDirtyRegion(JComponent component, int x, int y, int w, int 
h) {
         checkThreadViolations(component);
         super.addDirtyRegion(component, x, y, w, h);
     }

     private void checkThreadViolations(JComponent c) {
         if (!SwingUtilities.isEventDispatchThread() &amp;&amp; (completeCheck || 
c.isShowing())) {
             Exception exception = new Exception();
             boolean repaint = false;
             boolean fromSwing = false;
             StackTraceElement[] stackTrace = exception.getStackTrace();
             for (StackTraceElement st : stackTrace) {
                 if (repaint &amp;&amp; st.getClassName().startsWith("javax.swing.")) {
                     fromSwing = true;
                 }
                 if ("repaint".equals(st.getMethodName())) {
                     repaint = true;
                 }
             }
             if (repaint &amp;&amp; !fromSwing) {
                 //no problems here, since repaint() is thread safe
                 return;
             }
             exception.printStackTrace();
         }
     }
}
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD467"></a><div class="props_rev_3"><a id="GUID-BABA5847-91DD-4318-87EB-60787434E90A" name="GUID-BABA5847-91DD-4318-87EB-60787434E90A"></a><h4 id="JSTGD-GUID-BABA5847-91DD-4318-87EB-60787434E90A" class="sect4">JComponent儿童重叠</h4>
                  <div>
                     <p>如果您允许孩子的绘画，可能会出现绘画问题的另一个来源<code class="codeph">JComponent</code>重叠。
                     </p>
                     <p>在这种情况下，父级必须覆盖<code class="codeph">isOptimizedDrawingEnabled</code>返回<code class="codeph">false</code> 。如果不覆盖<code class="codeph">isOptimizedDrawingEnabled</code> ，则组件可以随机出现在其他组件之上，具体取决于调用了重绘的组件。
                     </p>
                  </div>
               </div><a id="JSTGD468"></a><div class="props_rev_3"><a id="GUID-5EE04B57-0E04-454F-AD9B-50FCCAF93A42" name="GUID-5EE04B57-0E04-454F-AD9B-50FCCAF93A42"></a><h4 id="JSTGD-GUID-5EE04B57-0E04-454F-AD9B-50FCCAF93A42" class="sect4">显示更新</h4>
                  <div>
                     <p>如果您在需要更新显示时未正确调用重新绘制，则会出现绘制问题的另一个来源。</p>
                     <p>更改Swing组件的可见属性（例如字体）将触发重新绘制或重新验证。如果要编写自定义组件，则每当更新显示或调整大小信息时，都必须调用repaint并可能重新验证。如果不这样做，则只有在下次有人触发重新粉刷时，显示屏才会更新。</p>
                     <p>诊断此问题的一种好方法是调整窗口大小。如果内容在调整大小之后出现，则表示该组件未正确调用重新绘制或重新验证。</p>
                  </div>
               </div><a id="JSTGD469"></a><div class="props_rev_3"><a id="GUID-391FD503-7B22-4A46-8446-8917B33F5BAC" name="GUID-391FD503-7B22-4A46-8446-8917B33F5BAC"></a><h4 id="JSTGD-GUID-391FD503-7B22-4A46-8446-8917B33F5BAC" class="sect4">型号变更</h4>
                  <div>
                     <p>更改Swing组件的可见属性时，调用重绘，而在模型更改时，也不需要调用重绘。</p>
                     <p>如果您的模型发出了正确的更改通知，则<code class="codeph">JComponent</code>将视情况调用重绘或重新验证。
                     </p>
                     <p>但是，如果您更改模型但不发送通知，则重新绘制事件甚至可能不起作用。特别是这不适用于<code class="codeph">JTree</code> 。正确的做法是发送适当的模型通知。通常可以通过调整窗口大小并注意到显示未正确更新来诊断。
                     </p>
                  </div>
               </div><a id="JSTGD470"></a><div class="props_rev_3"><a id="GUID-879FC96E-074F-4681-A531-D2D023E2DBB8" name="GUID-879FC96E-074F-4681-A531-D2D023E2DBB8"></a><h4 id="JSTGD-GUID-879FC96E-074F-4681-A531-D2D023E2DBB8" class="sect4">添加或删除组件</h4>
                  <p>添加或删除组件时，必须手动调用重新绘制或重新验证Swing和AWT。</p>
               </div><a id="JSTGD471"></a><div class="props_rev_3"><a id="GUID-99980EF9-93D8-412F-8DDF-442B6C56769A" name="GUID-99980EF9-93D8-412F-8DDF-442B6C56769A"></a><h4 id="JSTGD-GUID-99980EF9-93D8-412F-8DDF-442B6C56769A" class="sect4">不透明替代</h4>
                  <div>
                     <p>绘画问题的另一个可能领域是组件是否不覆盖不透明。</p>
                     <p>此外，如果不调用实现，则必须使用opaque属性，也就是说，如果此组件是不透明的，则必须使用非不透明的颜色完全填充背景。如果您不尊重opaque属性，那么您可能会看到视觉伪像。</p>
                     <p>唯一的检查方法是在组件调用重绘时寻找一致的视觉效果。</p>
                  </div>
               </div><a id="JSTGD472"></a><div class="props_rev_3"><a id="GUID-1C90A220-FB64-4D38-8152-A719F02B7BF2" name="GUID-1C90A220-FB64-4D38-8152-A719F02B7BF2"></a><h4 id="JSTGD-GUID-1C90A220-FB64-4D38-8152-A719F02B7BF2" class="sect4">永久更改图形</h4>
                  <div>
                     <p>请勿对产品进行任何永久更改<code class="codeph">Graphics</code>传递给<code class="codeph">paint</code> ， <code class="codeph">paintComponent</code> ， 要么<code class="codeph">paintChildren</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-1C90A220-FB64-4D38-8152-A719F02B7BF2__GUID-B28866C1-BFEA-48DF-AFE8-79575F080313">
                        <p class="notep1">注意：</p>
                        <p>如果您覆盖了子类中的图形，则不应永久更改<code class="codeph">paint</code> ， <code class="codeph">paintComponent</code> ， 要么<code class="codeph">paintChildren</code>通过<code class="codeph">Graphics</code> 。例如，您不应更改剪辑<code class="codeph">Rectangle</code>或修改变换。如果您需要执行这些操作，则可能会发现创建新文件更容易<code class="codeph">Graphics</code>从传入的<code class="codeph">Graphics</code>并操纵它。
                        </p>
                     </div>
                     <p>如果忽略此限制，那么结果将是剪辑或其他奇怪的视觉伪像。</p>
                  </div>
               </div><a id="JSTGD473"></a><div class="props_rev_3"><a id="GUID-6A7C9FCB-74FA-4D52-943B-6E0C6E233F32" name="GUID-6A7C9FCB-74FA-4D52-943B-6E0C6E233F32"></a><h4 id="JSTGD-GUID-6A7C9FCB-74FA-4D52-943B-6E0C6E233F32" class="sect4">自定义绘画和双缓冲</h4>
                  <div>
                     <p>虽然可以覆盖<code class="codeph">paint</code>并在覆盖中进行自定义绘画，则应覆盖<code class="codeph">paintComponent</code> 。
                     </p>
                     <p>的<code class="codeph">JComponent.paint</code>方法确保绘制发生在双缓冲区上。如果您覆盖<code class="codeph">paint</code>直接，那么您可能会失去双重缓冲。
                     </p>
                  </div>
               </div><a id="JSTGD474"></a><div class="props_rev_3"><a id="GUID-61A3C658-DE21-4871-BEC5-A1DC6803273D" name="GUID-61A3C658-DE21-4871-BEC5-A1DC6803273D"></a><h4 id="JSTGD-GUID-61A3C658-DE21-4871-BEC5-A1DC6803273D" class="sect4">不透明内容窗格</h4>
                  <div>
                     <p>Swing的绘画架构需要一个不透明的内容窗格。</p>
                     <p>Swing的绘画体系要求不透明<code class="codeph">JComponent</code>存在于所有其他组件之上的容纳层次结构中。通常使用内容窗格提供此功能。如果替换内容窗格，建议使用<span class="apiname">setOpaque（true）</span>使内容窗格不透明。此外，如果内容窗格覆盖<code class="codeph">paintComponent</code> ，那么它将需要以不透明颜色完全填充背景<code class="codeph">paintComponent</code> 。
                     </p>
                  </div>
               </div><a id="JSTGD475"></a><div class="props_rev_3"><a id="GUID-0247F7FD-119D-484E-818F-8FD843F711BD" name="GUID-0247F7FD-119D-484E-818F-8FD843F711BD"></a><h4 id="JSTGD-GUID-0247F7FD-119D-484E-818F-8FD843F711BD" class="sect4">渲染器要求每个单元的性能</h4>
                  <div>
                     <p>为每个单元绘制渲染器，因此请确保渲染器的工作尽可能少。</p>
                     <p>渲染器中的所有速度减慢都会在所有单元格中放大。例如，如果用50x20的可见单元格重新绘制表格的可见区域，则将有1000次调用渲染器。</p>
                  </div>
               </div><a id="JSTGD476"></a><div class="props_rev_3"><a id="GUID-E17A2C90-C781-42A3-9275-33F0575FEE5A" name="GUID-E17A2C90-C781-42A3-9275-33F0575FEE5A"></a><h4 id="JSTGD-GUID-E17A2C90-C781-42A3-9275-33F0575FEE5A" class="sect4">可能的泄漏</h4>
                  <div>
                     <p>如果模型的生命周期长于使用该模型的组件的窗口的生命周期，则必须将Swing组件的模型显式设置为null。</p>
                     <div class="section">
                        <p>如果您未将模型设置为null，则您的模型将保留对<code class="codeph">Component</code> ，这将防止窗口中的所有组件被垃圾回收。看下面的例子。
                        </p><pre class="pre codeblock"><code>TableModel myModel = ...;
JFrame frame = new JFrame();
frame.setContentPane(new JScrollPane(new JTable(myModel)));
frame.dispose();
</code></pre><p>如果您的应用程序仍然保留对<code class="codeph">myModel</code> ， 然后<code class="codeph">frame</code>并且所有的孩子仍然可以通过听众到达<code class="codeph">JTable</code>装置<code class="codeph">myModel</code> 。解决方案是调用<span class="apiname">table.setModel（new DefaultTableModel（））</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD478"></a><div class="props_rev_3"><a id="GUID-3CF05078-9B07-48F3-8B69-8D8F4400847C" name="GUID-3CF05078-9B07-48F3-8B69-8D8F4400847C"></a><h4 id="JSTGD-GUID-3CF05078-9B07-48F3-8B69-8D8F4400847C" class="sect4">混合重量级和轻量级组件</h4>
                  <div>
                     <p>只要重量级组件与任何现有的Swing组件不重叠，就可以在某些情况下混合使用重量级和轻量级的组件。</p>
                     <div class="section">
                        <p>例如，重量级对象无法在内部框架中工作，因为当用户在内部框架周围拖动时，它将与其他内部框架重叠。如果使用重量级，则调用以下方法：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span><span class="apiname">JPopupMenu.setDefaultLightWeightPopupEnabled（false）</span></span></li>
                        <li><span><span class="apiname">ToolTipManager.sharedInstance（）。setLightWeightPopupEnabled（false）</span></span></li>
                     </ul>
                  </div>
               </div><a id="JSTGD479"></a><div class="props_rev_3"><a id="GUID-79AA3986-FEF1-49D7-B107-23A0070C8359" name="GUID-79AA3986-FEF1-49D7-B107-23A0070C8359"></a><h4 id="JSTGD-GUID-79AA3986-FEF1-49D7-B107-23A0070C8359" class="sect4">使用合成器</h4>
                  <div>
                     <p><code class="codeph">Synth</code>是一块空的画布。
                     </p>
                     <div class="section">
                        <p>使用<code class="codeph">Synth</code> ，您必须提供配置外观的完整XML文件，或扩展<code class="codeph">SynthLookAndFeel</code>并提供自己的<code class="codeph">SynthStyleFactory</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD480"></a><div class="props_rev_3"><a id="GUID-56FCD857-F29C-4661-9C86-197A39EEAE7D" name="GUID-56FCD857-F29C-4661-9C86-197A39EEAE7D"></a><h4 id="JSTGD-GUID-56FCD857-F29C-4661-9C86-197A39EEAE7D" class="sect4">跟踪事件调度线程上的活动</h4>
                  <div>
                     <p>如果Swing应用程序尝试在事件分配线程上执行过多操作，则该应用程序将显得呆滞且无响应。</p>
                     <div class="section">
                        <p>检测这种情况的一种方法是推送新的<code class="codeph">EventQueue</code>如果事件处理时间太长，则可以输出日志信息。这种方法并不是完美的，因为它在焦点事件和模态方面存在问题，但是对于临时测试是好的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD481"></a><div class="props_rev_3"><a id="GUID-7D0AF4DE-3261-4EAC-8CCE-F7D9B09DB6F9" name="GUID-7D0AF4DE-3261-4EAC-8CCE-F7D9B09DB6F9"></a><h4 id="JSTGD-GUID-7D0AF4DE-3261-4EAC-8CCE-F7D9B09DB6F9" class="sect4">指定默认布局管理器</h4>
                  <div>
                     <p>可能是由于Swing组件上的默认布局管理器类不同而引起的。</p>
                     <div class="section">
                        <p>例如，默认的<code class="codeph">JPanel</code>类是<code class="codeph">FlowLayout</code> ，但默认为<code class="codeph">JFrame</code>类是<code class="codeph">BorderLayout</code> 。通过指定一个<code class="codeph">LayoutManager</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD482"></a><div class="props_rev_3"><a id="GUID-6BC5FDA9-9DBE-4BCA-8635-E2FFD12F2C85" name="GUID-6BC5FDA9-9DBE-4BCA-8635-E2FFD12F2C85"></a><h4 id="JSTGD-GUID-6BC5FDA9-9DBE-4BCA-8635-E2FFD12F2C85" class="sect4">侦听器对象调度到不正确的组件</h4>
                  <div>
                     <p><code class="codeph">MouseListener</code>对象被分派到具有<code class="codeph">MouseListener</code>对象（或已启用<code class="codeph">MouseEvent</code>对象）。
                     </p>
                     <div class="section">
                        <p>如果您附加了一个<code class="codeph">MouseListener</code>到其后代具有<code class="codeph">MouseListener</code>对象，你的<code class="codeph">MouseListener</code>对象将永远不会被调用。
                        </p>
                        <p>这很容易通过复合组件（例如可编辑<code class="codeph">JComboBox</code> 。因为一个<code class="codeph">JComboBox</code>有具有<code class="codeph">MouseListener</code> ， 一种<code class="codeph">MouseListener</code>附加到可编辑的<code class="codeph">JComboBox</code>永远不会得到通知。
                        </p>
                        <p>如果你的<code class="codeph">MouseListener</code>突然停止获取事件，然后可能是应用程序更改的结果，因此后代组件现在有了<code class="codeph">MouseListener</code> 。检查此问题的一种好方法是遍历后代，询问后代是否有任何鼠标侦听器。
                        </p>
                        <p>类似的情况发生在<code class="codeph">KeyListener</code>类。一种<code class="codeph">KeyListener</code>对象仅分派给关注的组件。
                        </p>
                        <p>的<code class="codeph">JComboBox</code>案例是这种情况的另一个例子。在可编辑的<code class="codeph">JComboBox</code>如果编辑获得焦点，而不是<code class="codeph">JComboBox</code> 。结果， <code class="codeph">KeyListener</code>附加到可编辑的<code class="codeph">JComboBox</code>永远不会得到通知。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD483"></a><div class="props_rev_3"><a id="GUID-51E79950-8FDC-40CB-AFC9-5BE9849CC18F" name="GUID-51E79950-8FDC-40CB-AFC9-5BE9849CC18F"></a><h4 id="JSTGD-GUID-51E79950-8FDC-40CB-AFC9-5BE9849CC18F" class="sect4">将组件添加到内容窗格</h4>
                  <div>
                     <p>您必须添加一个<code class="codeph">JFrame</code> ， <code class="codeph">JWindow</code> ， 要么<code class="codeph">JDialog</code>组件添加到内容窗格。
                     </p>
                     <div class="section">
                        <p>添加到顶层Swing组件的组件必须转到内容窗格，但是<code class="codeph">add</code>方法（以及其他几种方法） <code class="codeph">JFrame</code> ， <code class="codeph">JWindow</code>和<code class="codeph">JDialog</code>类重定向到内容窗格。换句话说， <span class="apiname">frame.getContentPane（）。add（component）</span>与<span class="apiname">frame.add（component）</span>相同。
                        </p>
                        <p>以下方法将为您重定向到内容窗格： <span class="apiname">添加</span> （及其变体）， <span class="apiname">删除</span> （及其变体）和<span class="apiname">setLayout</span> 。
                        </p>
                        <p>这纯粹是方便，但会引起混乱。特别是， <code class="codeph">getChildren</code> ， <code class="codeph">getLayout</code> ，其他各种则不会重定向到内容窗格。
                        </p>
                        <p>这种变化影响<code class="codeph">LayoutManagers</code>仅适用于一个组件，例如<code class="codeph">GroupLayout</code>和<code class="codeph">BoxLayout</code> 。例如，新的<span class="apiname">GroupLayout（frame）</span>将不起作用；相反，您必须使用<span class="apiname">GroupLayout（frame.getContentPane（））</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD484"></a><div class="props_rev_3"><a id="GUID-DB8214A9-E866-4462-83C4-569DE74E7F77" name="GUID-DB8214A9-E866-4462-83C4-569DE74E7F77"></a><h4 id="JSTGD-GUID-DB8214A9-E866-4462-83C4-569DE74E7F77" class="sect4">拖放支持</h4>
                  <p>使用Swing时，应使用Swing提供的拖放支持<code class="codeph">TransferHandler</code> 。
                  </p>
               </div><a id="JSTGD485"></a><div class="props_rev_3"><a id="GUID-2B32B552-38AB-4709-86DC-A1F6FBDDE911" name="GUID-2B32B552-38AB-4709-86DC-A1F6FBDDE911"></a><h4 id="JSTGD-GUID-2B32B552-38AB-4709-86DC-A1F6FBDDE911" class="sect4">一个组件的父代</h4>
                  <div>
                     <p>请记住，一个组件一次只能存在于一个父对象中。</p>
                     <p>当您在菜单之间共享菜单项时，会出现问题。例如， <code class="codeph">JMenuItem</code>是组件，因此一次只能存在于一个菜单中。
                     </p>
                  </div>
               </div><a id="JSTGD486"></a><div class="props_rev_3"><a id="GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09" name="GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09"></a><h4 id="JSTGD-GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09" class="sect4">Windows快捷方式的JFileChooser问题</h4>
                  <div>
                     <p>的<code class="codeph">JFileChooser</code>该类在Windows OS（.lnk文件）上不支持快捷方式。
                     </p>
                     <div class="section">
                        <p>与标准Windows文件选择器不同， <code class="codeph">JFileChooser</code>不允许用户浏览文件系统时遵循Windows快捷方式，因为它没有显示文件的正确路径。
                        </p>
                        <p>要重现此问题，请按照下列步骤操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li id="GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09__BACBCCGJ"><span>在桌面上创建一个文本文件，例如， <code>MyFile.txt</code> 。打开文本文件，然后键入一些文本，例如： <code class="codeph">This is the contents of MyFile.txt</code> 。</span></li>
                        <li><span>通过以下方式创建新文本文件的快捷方式：用鼠标右键将文件拖到桌面上的另一个位置，然后<span class="bold">在此处</span>选择<span class="bold">创建快捷方式</span> 。</span></li>
                        <li><span>跑过<code class="codeph">JfileChooser</code>测试应用程序，浏览桌面，选择<span class="bold">快捷方式<code>MyFile.txt</code></span>然后点击<span class="bold">打开</span> 。</span></li>
                        <li><span>结果文件是<code><span class="variable" translate="no">PathToDesktop</span>\Shortcut</code>至<code>MyFile.txt.lnk</code> ，但应该是<code><span class="variable" translate="no">PathToDesktop</span>\MyFile.txt</code> 。</span></li>
                        <li><span>另外，结果文件的内容在文本区域中显示了文件快捷方式的内容。 <code>MyFile.txt.lnk</code> ，但内容应为<code class="codeph">This is the contents of MyFile.txt</code> ，这是在步骤<a href="swing.html#GUID-8694C211-C204-4B07-9969-3BD8F7EE1A09__BACBCCGJ">1</a>中键入的。</span></li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>