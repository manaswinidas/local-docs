<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Information and guidance about some specific procedures for troubleshooting system crashes.">
      <meta name="description" content="Information and guidance about some specific procedures for troubleshooting system crashes.">
      <title>解决系统崩溃问题</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="Information and guidance about some specific procedures for troubleshooting system crashes.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="debug-jvm-issues.html" title="Previous" type="text/html">
      <link rel="next" href="troubleshoot-process-hangs-and-loops.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="debug-jvm-issues.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="troubleshoot-process-hangs-and-loops.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="debug-jvm-issues.html" property="item" typeof="WebPage"><span property="name">调试JVM问题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">解决系统崩溃问题</li>
            </ol>
            <a id="GUID-BDA1D041-355C-4C85-9ED0-E2AC46D67BED" name="GUID-BDA1D041-355C-4C85-9ED0-E2AC46D67BED"></a><a id="JSTGD315"></a><a id="JSTGD314"></a>
            
            <h2 id="JSTGD-GUID-BDA1D041-355C-4C85-9ED0-E2AC46D67BED" class="sect2"><span class="enumeration_chapter">5</span>对系统崩溃进行故障排除</h2>
         </header>
         <div class="ind">
            <div>
               <p>有关对系统崩溃进行故障排除的某些特定过程的信息和指南。</p>
               <p>崩溃或致命错误会导致进程异常终止。发生崩溃的原因可能有多种。例如，崩溃可能是由于Java HotSpot VM，系统库，Java SE库或API，应用程序本机代码甚至操作系统（OS）中的错误引起的。诸如操作系统中的资源耗尽之类的外部因素也可能导致崩溃。</p>
               <p>由Java HotSpot VM或Java SE库代码中的错误引起的崩溃很少见。本章提供有关如何检查崩溃并解决一些问题（如果可能）的建议，直到诊断出并修复了错误的原因为止。</p>
               <p>通常，发生任何崩溃的第一步是找到致命错误日志。这是Java HotSpot VM在崩溃时生成的文本文件。有关如何找到此文件的说明以及文件的详细说明，请参见<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。
               </p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="troubleshoot-system-crashes.html#GUID-153DA983-743E-4839-9984-8863D4E6C943" title="这些示例演示了如何使用错误日志查找崩溃原因，并根据原因提供了一些用于解决问题的提示。">确定崩溃发生的位置</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-system-crashes.html#GUID-59018F70-70E1-4BDE-AA42-9680773E585F" title="如果关键应用程序发生崩溃，则可能的解决方法。">寻找解决方法</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshoot-system-crashes.html#GUID-9C81B6BA-4A0A-47D8-8ACA-6AF2925C6CEB" title="JDK软件是使用Microsoft Visual Studio 2013在Windows上构建的。">Microsoft Visual C ++版本注意事项</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD316"></a><div class="props_rev_3"><a id="GUID-153DA983-743E-4839-9984-8863D4E6C943" name="GUID-153DA983-743E-4839-9984-8863D4E6C943"></a><h3 id="JSTGD-GUID-153DA983-743E-4839-9984-8863D4E6C943" class="sect3">确定崩溃发生的位置</h3>
               <div>
                  <p>这些示例演示了如何使用错误日志查找崩溃原因，并根据原因提供了一些用于解决问题的提示。</p>
                  <p>错误日志标头指示错误的类型和有问题的帧，而线程堆栈指示当前线程和堆栈跟踪。请参阅<a href="fatal-error-log.html#GUID-DDFA3BD4-49F6-44EC-AD22-F7B93463D1F9" title="每个致命错误日志文件开头的标头部分均包含对该问题的简短描述。">标题格式</a> 。
                  </p>
                  <p>以下是导致崩溃的可能原因。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-035D93F9-7F3F-4F00-898C-0467D137FE7C" title="分析故障转储文件或核心文件，以识别崩溃是否发生在本机代码或Java本机接口（JNI）库代码中。">崩溃本机代码</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-8786A1C9-7260-45AC-A195-5D0387677F8C" title="分析致命错误日志以识别崩溃是否发生在已编译的代码中。">编译代码崩溃</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-59387D99-26F5-4834-84DD-6A67246959AB" title="分析致命错误日志，以确定是否在HotSpot编译器线程中发生了崩溃。">HotSpot编译器线程崩溃</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-E755361B-68F4-4474-802C-B90793474A04" title="分析致命错误日志以识别VMThread中是否发生了崩溃。">VM线程崩溃</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-CFBD30A1-5840-4D97-8880-0603F3862EEA" title="Java语言代码中的堆栈溢出通常会导致令人反感的线程抛出java.lang。StackOverflowError异常。">因堆栈溢出而崩溃</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD317"></a><div class="props_rev_3"><a id="GUID-035D93F9-7F3F-4F00-898C-0467D137FE7C" name="GUID-035D93F9-7F3F-4F00-898C-0467D137FE7C"></a><h4 id="JSTGD-GUID-035D93F9-7F3F-4F00-898C-0467D137FE7C" class="sect4">崩溃本机代码</h4>
                  <div>
                     <p>分析故障转储文件或核心文件，以识别崩溃是否发生在本机代码或Java本机接口（JNI）库代码中。</p>
                     <div class="section">
                        <p>如果致命错误日志指示有问题的框架是本机库，则本机代码或Java本机接口（JNI）库代码中可能存在错误。崩溃可能是由其他原因引起的，但是对库和任何核心文件或崩溃转储的分析是一个很好的起点。在以下示例中，请考虑致命错误日志标题中的摘录。</p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
#  SIGSEGV (0xb) at pc=0x417789d7, pid=21139, tid=1024
#
# Java VM: Java HotSpot(TM) Server VM (6-beta2-b63 mixed mode)
# Problematic frame:
# C  [libApplication.so+0x9d7]
</code></pre><p>在这种情况下<code class="codeph">SIGSEGV</code>发生与库中执行的线程<code class="codeph">libApplication.so</code> 。
                        </p>
                        <p>在某些情况下，本机库中的错误表现为Java VM代码崩溃。在以下示例中考虑崩溃，其中<code class="codeph">JavaThread</code>在中失败<code class="codeph">_thread_in_vm</code>状态（表示它正在Java VM代码中执行）。
                        </p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x08083d77, pid=3700, tid=2896
#
# Java VM: Java HotSpot(TM) Client VM (1.5-internal mixed mode)
# Problematic frame:
# V  [jvm.dll+0x83d77]

---------------  T H R E A D  ---------------

Current thread (0x00036960):  JavaThread "main" [_thread_in_vm, id=2896]
 :
Stack: [0x00040000,0x00080000),  sp=0x0007f9f8,  free space=254k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
V  [jvm.dll+0x83d77]
C  [App.dll+0x1047]          &lt;========= C/native frame
j  Test.foo()V+0
j  Test.main([Ljava/lang/String;)V+0
v  ~StubRoutines::call_stub
V  [jvm.dll+0x80f13]
V  [jvm.dll+0xd3842]
V  [jvm.dll+0x80de4]
V  [jvm.dll+0x87cd2]
C  [java.exe+0x14c0]
C  [java.exe+0x64cd]
C  [kernel32.dll+0x214c7]
 :
</code></pre><p>在这种情况下，尽管有问题的帧是VM帧，但线程堆栈显示在<code class="codeph">App.dll</code>已经调用了VM（可能是通过JNI）。
                        </p>
                        <p>解决本机库中的崩溃的第一步是调查发生崩溃的本机库的源。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果您的应用程序提供了本机库，请调查本机库的源代码。通过使用以下命令运行应用程序，可以确定JNI代码存在大量问题。 <code>-Xcheck:jni</code>选项添加到命令行。请参见<a href="command-line-options1.html#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDDEGBI">-Xcheck：jni选项</a> 。
                              </p>
                           </li>
                           <li>
                              <p>如果本机库是由其他供应商提供的，并且已由您的应用程序使用，则针对该第三方应用程序提交错误报告，并提供致命错误日志信息。</p>
                           </li>
                           <li>
                              <p>如果发生崩溃的本机库是Java运行时环境（JRE）的一部分（例如awt.dll，net.dll等），则可能遇到库或API错误。如果是这样，请收集尽可能多的数据，并提交一个错误或报告，指出库名称。您可以在<code>jre/lib</code>要么<code>jre/bin</code> JRE发行版的目录。请参阅<a href="submit-bug-report.html#GUID-DB465A9C-03FA-4324-BFF9-45BF9699F349" title="有关如何提交错误报告的指南。它包括有关提交报告之前应尝试的操作以及为该报告收集哪些数据的建议。">提交错误报告</a> 。
                              </p>
                           </li>
                        </ul>
                        <p>您可以通过将本机调试器附加到核心文件或故障转储（如果有）来解决本机应用程序库中的崩溃问题。根据操作系统，本机调试器是<code class="codeph">dbx</code> ， <code class="codeph">gdb</code> ， 要么<code class="codeph">windbg</code> 。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD320"></a><div class="props_rev_3"><a id="GUID-8786A1C9-7260-45AC-A195-5D0387677F8C" name="GUID-8786A1C9-7260-45AC-A195-5D0387677F8C"></a><h4 id="JSTGD-GUID-8786A1C9-7260-45AC-A195-5D0387677F8C" class="sect4">编译代码崩溃</h4>
                  <div>
                     <p>分析致命错误日志以识别崩溃是否发生在已编译的代码中。</p>
                     <div class="section">
                        <p>如果致命错误日志指示崩溃发生在已编译代码中，则可能是您遇到了导致错误代码生成的编译器错误。如果有问题的框架的类型是<code class="codeph">J</code> （表示已编译的Java框架）。以下示例显示了这种崩溃。
                        </p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
#  SIGSEGV (0xb) at pc=0x0000002a99eb0c10, pid=6106, tid=278546
#
# Java VM: Java HotSpot(TM) 64-Bit Server VM (1.6.0-beta-b51 mixed mode)
# Problematic frame:
# J  org.foobar.Scanner.body()V
#
:
Stack: [0x0000002aea560000,0x0000002aea660000),  sp=0x0000002aea65ddf0,
  free space=1015k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
J  org.foobar.Scanner.body()V

[error occurred during error reporting, step 120, id 0xb]
</code></pre><div class="p">
                           <div class="infoboxnote" id="GUID-8786A1C9-7260-45AC-A195-5D0387677F8C__GUID-230E5C8C-D31C-4727-A7A7-2F21026E9E85">
                              <p class="notep1">注意：</p>没有完整的线程堆栈。输出行“错误报告期间发生错误”表示尝试获取堆栈跟踪信息时出现了问题（这可能表示堆栈损坏）。
                           </div> 
                        </div>
                        <p>通过切换编译器或通过从编译中排除引发崩溃的方法，可以暂时解决此问题。</p>
                        <p>请参阅<a href="troubleshoot-system-crashes.html#GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033" title="如果崩溃发生在热点编译器线程中，则可能的解决方法。">解决HotSpot编译器线程或编译代码中的崩溃</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD322"></a><div class="props_rev_3"><a id="GUID-59387D99-26F5-4834-84DD-6A67246959AB" name="GUID-59387D99-26F5-4834-84DD-6A67246959AB"></a><h4 id="JSTGD-GUID-59387D99-26F5-4834-84DD-6A67246959AB" class="sect4">HotSpot编译器线程崩溃</h4>
                  <div>
                     <p>分析致命错误日志，以确定是否在HotSpot编译器线程中发生了崩溃。</p>
                     <div class="section">
                        <p>如果致命错误日志输出显示当前线程是<code class="codeph">JavaThread</code>命名<code class="codeph">CompilerThread0</code> ， <code class="codeph">CompilerThread1</code> ， 要么<code class="codeph">AdapterCompiler</code> ，则很可能遇到编译器错误。在这种情况下，可能有必要通过切换编译器来临时解决此问题（例如，通过使用HotSpot Client VM代替HotSpot Server VM，反之亦然），或者通过从编译中排除引发该问题的方法来解决此问题。崩溃。
                        </p>
                        <p>请参阅<a href="troubleshoot-system-crashes.html#GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033" title="如果崩溃发生在热点编译器线程中，则可能的解决方法。">解决HotSpot编译器线程或编译代码中的崩溃</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD323"></a><div class="props_rev_3"><a id="GUID-E755361B-68F4-4474-802C-B90793474A04" name="GUID-E755361B-68F4-4474-802C-B90793474A04"></a><h4 id="JSTGD-GUID-E755361B-68F4-4474-802C-B90793474A04" class="sect4">VM线程崩溃</h4>
                  <div>
                     <p>分析致命错误日志以识别崩溃是否发生在<code class="codeph">VMThread</code> 。
                     </p>
                     <div class="section">
                        <p>如果致命错误日志输出显示当前线程是<code class="codeph">VMThread</code> ，然后查找包含<code class="codeph">VM_Operation</code>在里面<code class="codeph">THREAD</code>部分。一种<code class="codeph">VMThread</code>是HotSpot VM中的特殊线程。它在VM中执行特殊任务，例如垃圾收集（GC）。如果<code class="codeph">VM_Operation</code>提示该操作是GC，则可能会遇到堆损坏之类的问题。
                        </p>
                        <p>除了GC问题外，还可能是其他原因（例如编译器或运行时错误）导致堆中的对象引用处于不一致或不正确的状态。在这种情况下，请收集有关环境的尽可能多的信息，然后尝试可能的解决方法。如果问题与GC有关，则可以通过更改GC配置暂时解决此问题。</p>
                        <p>请参阅<a href="troubleshoot-system-crashes.html#GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48" title="如果崩溃发生在垃圾收集过程中，则可能的解决方法。">在回收垃圾时解决崩溃</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD324"></a><div class="props_rev_3"><a id="GUID-CFBD30A1-5840-4D97-8880-0603F3862EEA" name="GUID-CFBD30A1-5840-4D97-8880-0603F3862EEA"></a><h4 id="JSTGD-GUID-CFBD30A1-5840-4D97-8880-0603F3862EEA" class="sect4">因堆栈溢出而崩溃</h4>
                  <div>
                     <p>Java语言代码中的堆栈溢出通常会导致有问题的线程抛出<code class="codeph">java.lang.StackOverflowError</code>例外。
                     </p>
                     <div class="section">
                        <p>另一方面，C和C ++的写操作超出堆栈末尾，并导致堆栈溢出。这是一个致命错误，导致进程终止。</p>
                        <p>在HotSpot实现中，Java方法与C / C ++本机代码（即用户本机代码和虚拟机本身）共享堆栈帧。Java方法会生成代码，该代码检查在堆栈末端附近固定距离处是否有可用的堆栈空间，以便可以在不超出堆栈空间的情况下调用本机代码。到堆栈末端的距离称为影子页面。影子页面的大小在3到20页之间，具体取决于平台。此距离是可调的，因此具有本机代码的应用程序需要的距离比默认距离还大，可以增加影子页面的大小。增加阴影页的选项是<code>-XX:StackShadowPages=</code> <span class="variable" translate="no">n</span> ，其中<span class="variable" translate="no">n</span>大于平台的默认堆栈影子页面。
                        </p>
                        <p>如果您的应用程序出现分段错误而没有核心文件或致命错误日志文件，请参阅<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。或者如果您的应用程序获得<code class="codeph">STACK_OVERFLOW_ERROR</code> Windows或消息“发生了不可恢复的堆栈溢出”，则表明<code class="codeph">StackShadowPages</code>已超出，需要更多空间。
                        </p>
                        <p>如果增加<code class="codeph">StackShadowPages</code> ，您可能还需要使用来增加默认的线程堆栈大小<code class="codeph">-Xss</code>参数。增加默认线程堆栈大小可能会减少可以创建的线程数，因此请谨慎选择线程堆栈大小的值。线程堆栈大小因平台而异，从256 KB到1024 KB。</p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
#  EXCEPTION_STACK_OVERFLOW (0xc00000fd) at pc=0x10001011, pid=296, tid=2940
#
# Java VM: Java HotSpot(TM) Client VM (1.6-internal mixed mode, sharing)
# Problematic frame:
# C  [App.dll+0x1011]
#

---------------  T H R E A D  ---------------

Current thread (0x000367c0):  JavaThread "main" [_thread_in_native, id=2940]
:
Stack: [0x00040000,0x00080000),  sp=0x00041000,  free space=4k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
C  [App.dll+0x1011]
C  [App.dll+0x1020]
C  [App.dll+0x1020]
:
C  [App.dll+0x1020]
C  [App.dll+0x1020]
...&lt;more frames&gt;...

Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)
j  Test.foo()V+0
j  Test.main([Ljava/lang/String;)V+0
v  ~StubRoutines::call_stub
</code></pre><p>您可以从以上示例中解释以下信息。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>例外是<code class="codeph">EXCEPTION_STACK_OVERFLOW</code> 。
                              </p>
                           </li>
                           <li>
                              <p>线程状态为<code class="codeph">_thread_in_native,</code>这意味着线程正在执行本机或JNI代码。
                              </p>
                           </li>
                           <li>
                              <p>在堆栈信息中，可用空间仅为4 KB（在Windows系统上为单个页面）。另外，堆栈指针（ <code class="codeph">sp</code> ）在<code class="codeph">0x00041000</code> ，它接近堆栈的末尾<code class="codeph">0x00040000</code> 。
                              </p>
                           </li>
                           <li>
                              <p>本机框架的打印输出表明在这种情况下，递归本机函数是问题所在。输出表示法<code class="codeph">...<more frames>...</code>表示存在其他框，但未打印。输出限制为100帧。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD326"></a><div class="props_rev_3"><a id="GUID-59018F70-70E1-4BDE-AA42-9680773E585F" name="GUID-59018F70-70E1-4BDE-AA42-9680773E585F"></a><h3 id="JSTGD-GUID-59018F70-70E1-4BDE-AA42-9680773E585F" class="sect3">寻找解决方法</h3>
               <div>
                  <p>如果关键应用程序发生崩溃，则可能的解决方法。</p>
                  <p>如果关键应用程序发生崩溃，并且崩溃似乎是由HotSpot VM中的错误引起的，那么可能需要快速找到一种临时解决方法。如果崩溃发生在使用最新版本的JDK部署的应用程序中，则应将崩溃报告给Oracle。</p>
                  <div class="infoboxnote" id="GUID-59018F70-70E1-4BDE-AA42-9680773E585F__GUID-F065A498-45C6-43E5-8287-922BE985A115">
                     <p class="notep1">重要：</p>
                     <p>即使本节中的解决方法成功消除了崩溃，该解决方法<span class="bold">也不</span>是解决问题的方法，而只是临时解决方案。拨打支持电话或使用可证明问题的原始配置提交错误报告。
                     </p>
                  </div>
                  <p>以下是找到系统崩溃的解决方法的三种方案。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033" title="如果崩溃发生在热点编译器线程中，则可能的解决方法。">解决HotSpot编译器线程或编译代码中的崩溃</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48" title="如果崩溃发生在垃圾收集过程中，则可能的解决方法。">回收垃圾时应对崩溃</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshoot-system-crashes.html#GUID-40D9724D-8FDB-49AB-82A7-B4A433FA32F3">解决由类数据共享导致的崩溃</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD327"></a><div class="props_rev_3"><a id="GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033" name="GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033"></a><h4 id="JSTGD-GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033" class="sect4">解决HotSpot编译器线程或编译代码中的崩溃</h4>
                  <div>
                     <p>如果崩溃发生在热点编译器线程中，则可能的解决方法。</p>
                     <div class="section">
                        <p>如果致命错误日志指示崩溃发生在编译器线程中，则可能（但并非总是如此）遇到编译器错误。同样，如果崩溃发生在编译后的代码中，则编译器可能会生成错误的代码。</p>
                        <p>如果是HotSpot Client VM（ <code>-client</code>选项），则编译器线程在错误日志中显示为<code class="codeph">CompilerThread0</code> 。使用HotSpot Server VM，有多个编译器线程，它们在错误日志文件中显示为<code class="codeph">CompilerThread0</code> ， <code class="codeph">CompilerThread1</code>和<code class="codeph">AdapterThread</code> 。
                        </p>
                        <p>从JDK 7u5版本开始，默认情况下会忽略HotSpot编译器。可以使用命令行选项来模拟旧行为，当排除多个方法时，该选项很有用。查看<a href="http://www.oracle.com/technetwork/java/javase/7u5-relnotes-1653274.html" target="_blank">JDK 7u5中的重要错误修复</a> 。
                        </p>
                        <p>通过使用JVM标志（而不是JVM标志）排除编译方法<code class="codeph">.hotspot_compile</code>文件，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/troubleshoot&id=JSWOR624" target="_blank"><code>-XX:CompileCommand</code></a> <span><cite>Java平台标准版工具参考</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/troubleshoot&id=JSWOR624" target="_blank">中的“高级JIT编译器选项”</a>中的。
                        </p>
                        <p>以下示例显示了在开发过程中遇到并修复的编译器错误的错误日志的片段。日志文件显示已使用HotSpot Server VM，并且崩溃发生在<code class="codeph">CompilerThread1</code> 。另外，日志文件显示当前<code class="codeph">CompileTask</code>是《 <code class="codeph">java.lang.Thread.setPriority</code>方法。
                        </p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
:
# Java VM: Java HotSpot(TM) Server VM (1.5-internal-debug mixed mode)
:
---------------  T H R E A D  ---------------

Current thread (0x001e9350): JavaThread "CompilerThread1" daemon [_thread_in_vm, id=20]

Stack: [0xb2500000,0xb2580000),  sp=0xb257e500,  free space=505k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
V  [libjvm.so+0xc3b13c]
:

Current CompileTask:
opto: 11      java.lang.Thread.setPriority(I)V (53 bytes)

---------------  P R O C E S S  ---------------

Java Threads: ( =&gt; current thread )
  0x00229930 JavaThread "Low Memory Detector" daemon [_thread_blocked, id=21]
=&gt;0x001e9350 JavaThread "CompilerThread1" daemon [_thread_in_vm, id=20]
 :
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在这种情况下，有两种可能的解决方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>暴力破解方法：更改配置，以使应用程序与<code>-client</code>选项以指定HotSpot客户端VM。</p>
                           </li>
                           <li>
                              <p>巧妙的方法：假设该错误仅在编译过程中发生<code class="codeph">java.lang.Thread.setPriority</code>方法，并从编译中排除此方法。
                              </p>
                           </li>
                        </ul>
                        <p>第一种方法（使用<code>-client</code>选项）在某些环境中进行配置可能并不容易。在其他情况下，如果配置复杂或无法轻松访问用于配置VM的命令行，则可能会更加困难。通常，从HotSpot服务器VM切换到HotSpot Client VM也会降低应用程序的最佳性能。根据环境的不同，在诊断并解决问题之前，这可能是可以接受的。
                        </p>
                        <p>第二种方法（从编译中排除该方法）需要创建文件<code class="codeph">.hotspot_compiler</code>在应用程序的工作目录中。以下示例显示了此方法。
                        </p><pre class="pre codeblock"><code>exclude java/lang/Thread setPriority
</code></pre><p>通常，此文件的格式为<code class="codeph">exclude<span class="variable" translate="no">class</span><span class="variable" translate="no">method</span></code> ，在哪里<code class="codeph"><span class="variable" translate="no">class</span></code>是类（使用包名称完全限定），并且<code class="codeph"><span class="variable" translate="no">method</span></code>是方法的名称。构造方法指定为<code class="codeph"><init></code>和静态初始值设定项指定为<code class="codeph"><clinit></code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033__GUID-8FA211A1-0BE2-467D-A187-AF7250F0334B">
                           <p class="notep1">注意：</p>
                           <p>的<code class="codeph">.hotspot_compiler</code>文件是不受支持的界面。本文仅在进行故障排除和查找临时解决方法时进行记录。
                           </p>
                        </div>
                        <p>重新启动应用程序后，编译器将不会尝试编译该方法中排除的任何方法。 <code class="codeph">.hotspot_compiler</code>文件。在某些情况下，这可以暂时缓解问题，直到诊断出崩溃的根本原因并修复了错误。
                        </p>
                        <p>为了验证HotSpot VM是否正确定位并处理了<code class="codeph">.hotspot_compiler</code>第二种方法的上一个示例中显示的文件，请在运行时查找日志信息。
                        </p>
                        <div class="infoboxnote" id="GUID-473B0F71-9C29-47E0-A17A-38E3F85FA033__GUID-7C682E82-EB45-42FA-840D-919A8E7C67D4">
                           <p class="notep1">注意：</p>文件名分隔符是点而不是斜杠。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD330"></a><div class="props_rev_3"><a id="GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48" name="GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48"></a><h4 id="JSTGD-GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48" class="sect4">回收垃圾时应对崩溃</h4>
                  <div>
                     <p>如果崩溃发生在垃圾收集过程中，则可能的解决方法。</p>
                     <div class="section">
                        <p>如果在垃圾回收（GC）期间发生崩溃，则致命错误日志将报告<code class="codeph">VM_Operation</code>正在处理。为了便于讨论，假设大多数并发GC（ <code>-XX:+UseConcMarkSweep</code> ）未使用。的<code class="codeph">VM_Operation</code>显示在<code class="codeph">THREAD</code>日志部分，并指示以下情况之一：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>代收集</p>
                           </li>
                           <li>
                              <p>全代收藏</p>
                           </li>
                           <li>
                              <p>并行GC分配失败</p>
                           </li>
                           <li>
                              <p>并行GC永久分配失败</p>
                           </li>
                           <li>
                              <p>平行GC系统GC</p>
                           </li>
                        </ul>
                        <p>最有可能的是，日志中报告的当前线程是<code class="codeph">VMThread</code> 。这是用于在HotSpot VM中执行特殊任务的特殊线程。以下示例是来自串行垃圾收集器崩溃的致命错误日志的一部分。
                        </p><pre class="pre codeblock"><code>---------------  T H R E A D  ---------------

Current thread (0x002cb720):  VMThread [id=3252]

siginfo: ExceptionCode=0xc0000005, reading address 0x00000000

Registers:
EAX=0x0000000a, EBX=0x00000001, ECX=0x00289530, EDX=0x00000000
ESP=0x02aefc2c, EBP=0x02aefc44, ESI=0x00289530, EDI=0x00289530
EIP=0x0806d17a, EFLAGS=0x00010246

Top of Stack: (sp=0x02aefc2c)
0x02aefc2c:   00289530 081641e8 00000001 0806e4b8
0x02aefc3c:   00000001 00000000 02aefc9c 0806e4c5
0x02aefc4c:   081641e8 081641c8 00000001 00289530
0x02aefc5c:   00000000 00000000 00000001 00000001
0x02aefc6c:   00000000 00000000 00000000 08072a9e
0x02aefc7c:   00000000 00000000 00000000 00035378
0x02aefc8c:   00035378 00280d88 00280d88 147fee00
0x02aefc9c:   02aefce8 0806e0f5 00000001 00289530
Instructions: (pc=0x0806d17a)
0x0806d16a:   15 08 83 3d c0 be 15 08 05 53 56 57 8b f1 75 0f
0x0806d17a:   0f be 05 00 00 00 00 83 c0 05 a3 c0 be 15 08 8b 

Stack: [0x02ab0000,0x02af0000),  sp=0x02aefc2c,  free space=255k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
V  [jvm.dll+0x6d17a]
V  [jvm.dll+0x6e4c5]
V  [jvm.dll+0x6e0f5]
V  [jvm.dll+0x71771]
V  [jvm.dll+0xfd1d3]
V  [jvm.dll+0x6cd99]
V  [jvm.dll+0x504bf]
V  [jvm.dll+0x6cf4b]
V  [jvm.dll+0x1175d5]
V  [jvm.dll+0x1170a0]
V  [jvm.dll+0x11728f]
V  [jvm.dll+0x116fd5]
C  [MSVCRT.dll+0x27fb8]
C  [kernel32.dll+0x1d33b]

VM_Operation (0x0373f71c): generation collection for allocation, mode:
 safepoint, requested by thread 0x02db7108
</code></pre><div class="infoboxnote" id="GUID-F364244B-ABC0-4FAF-AFA5-35BABA346E48__GUID-FC941FA9-004D-434A-9C3F-EB0A1FDDC0F4">
                           <p class="notep1">注意：</p>
                           <p>垃圾回收过程中发生崩溃并不意味着垃圾回收实现中存在错误。它还可能指示编译器或运行时错误，或其他问题。</p>
                        </div>
                        <p>如果您在垃圾回收期间反复崩溃，则可以尝试以下解决方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>切换GC配置。例如，如果您正在使用串行收集器，则尝试使用吞吐量收集器，反之亦然。</p>
                           </li>
                           <li>
                              <p>如果使用的是HotSpot Server VM，请尝试使用HotSpot Client VM。</p>
                           </li>
                        </ul>
                        <p>如果您不确定使用哪个垃圾收集器，则可以使用<code class="codeph">jmap</code> Oracle Solaris和Linux操作系统上的实用程序。如果核心文件可用，请参见<a href="diagnostic-tools.html#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="jmap命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。">jmap实用程序</a>以从核心文件获取堆信息。通常，如果未在命令行上指定GC配置，则将在Windows上使用串行收集器。在Oracle Solaris和Linux操作系统上，它取决于计算机配置。如果计算机至少有2 GB的内存并且至少有2个CPU，则将使用吞吐量收集器（Parallel GC）。对于较小的计算机，串行收集器是默认设置。选择串行收集器的选项是<code>-XX:+UseSerialGC</code>选择吞吐量收集器的选项是<code>-XX:+UseParallelGC</code> 。作为解决方法，如果您从吞吐量收集器切换到串行收集器，则可能会在多处理器系统上遇到性能下降的问题。在诊断并解决根本问题之前，这可能是可以接受的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD332"></a><div class="props_rev_3"><a id="GUID-40D9724D-8FDB-49AB-82A7-B4A433FA32F3" name="GUID-40D9724D-8FDB-49AB-82A7-B4A433FA32F3"></a><h4 id="JSTGD-GUID-40D9724D-8FDB-49AB-82A7-B4A433FA32F3" class="sect4">解决由类数据共享导致的崩溃</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>安装JRE后，安装程序会将系统JAR文件中的一组类加载到私有内部表示形式中，并将该表示形式转储到称为共享档案的文件中。当JVM启动时，共享归档文件将映射到内存，以允许在多个JVM进程之间共享这些类的只读JVM元数据。启动时间减少了，因此节省了成本，因为还原共享档案比加载类要快。Java HotSpot VM支持类数据共享。支持G1，串行，并行和parallelOldGC垃圾收集器。共享字符串功能（类数据共享的一部分）在非Windows平台上仅支持G1垃圾收集器。</p>
                        <p>致命错误日志在日志标题中打印版本字符串。如果启用了共享，则由文本“共享”指示，如以下示例所示。</p><pre class="pre codeblock"><code># An unexpected error has been detected by HotSpot Virtual Machine:
#
#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x08083d77, pid=3572, tid=784
#
# Java VM: Java HotSpot(TM) Client VM (1.5-internal mixed mode, sharing)
# Problematic frame:
# V  [jvm.dll+0x83d77]
</code></pre><p>可以通过提供CDS来禁用CDS <code>-Xshare:off</code>命令行上的选项。如果仅在启用共享的情况下发生崩溃，则可能是您在此功能中遇到了错误。在这种情况下，请收集尽可能多的信息并提交错误报告。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD334"></a><div class="props_rev_3"><a id="GUID-9C81B6BA-4A0A-47D8-8ACA-6AF2925C6CEB" name="GUID-9C81B6BA-4A0A-47D8-8ACA-6AF2925C6CEB"></a><h3 id="JSTGD-GUID-9C81B6BA-4A0A-47D8-8ACA-6AF2925C6CEB" class="sect3">Microsoft Visual C ++版本注意事项</h3>
               <div>
                  <p>JDK软件是使用Microsoft Visual Studio 2013在Windows上构建的。</p>
                  <p>如果您遇到Java应用程序崩溃的情况，并且拥有使用其他版本的编译器编译的本机或JNI库，则必须考虑运行时之间的兼容性问题。具体来说，仅当您在处理多个运行时时遵循Microsoft准则时，才支持您的环境。例如，如果使用一个运行时分配内存，则必须使用相同的运行时释放它。如果您使用与分配资源的库不同的库释放资源，则可能发生不可预知的行为或崩溃。</p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>