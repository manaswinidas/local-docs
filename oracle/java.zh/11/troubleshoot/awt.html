<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter provides information and guidance about some specific procedures for troubleshooting common issues that might occur in the Java SE Abstract Window Toolkit (AWT).">
      <meta name="description" content="This chapter provides information and guidance about some specific procedures for troubleshooting common issues that might occur in the Java SE Abstract Window Toolkit (AWT).">
      <title>AWT</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="This chapter provides information and guidance about some specific procedures for troubleshooting common issues that might occur in the Java SE Abstract Window Toolkit (AWT).">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="introduction-client-issues.html" title="Previous" type="text/html">
      <link rel="next" href="java-2d-pipeline-rendering-and-properties.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction-client-issues.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="java-2d-pipeline-rendering-and-properties.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="debug-client-issues.html" property="item" typeof="WebPage"><span property="name">调试客户端问题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">AWT</li>
            </ol>
            <a id="GUID-E2C5A322-F6BA-4D25-BC2F-D946B10BC581" name="GUID-E2C5A322-F6BA-4D25-BC2F-D946B10BC581"></a><a id="JSTGD394"></a><a id="JSTGD393"></a>
            
            <h2 id="JSTGD-GUID-E2C5A322-F6BA-4D25-BC2F-D946B10BC581" class="sect2"><span class="enumeration_chapter">10</span> AWT</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本章提供有关一些特定过程的信息和指导，以对Java SE抽象窗口工具包（AWT）中可能发生的常见问题进行故障排除。</span></div>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="awt.html#GUID-623C61BB-8E09-4918-A120-911CA5C92FC6" title="调试与AWT相关的问题的有用提示。">AWT的调试提示</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-7BE06BA5-0206-42FE-8AD2-468A1AFA8512" title="布局管理器可能存在的问题，并在可用时提供了解决方法。">布局管理器问题</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-861F1E94-1944-42C2-AD73-9E1E6C854321" title="当前版本中尚未解决的与处理关键事件有关的问题。">关键事件</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-094860B0-DC42-428A-BE28-33ECB81C8C72" title="有关使用模态的问题的信息。">模态问题</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-130F872C-7F03-4AEF-BB02-72F1A3BECFAE" title="识别并解决与AWT相关的崩溃。">AWT崩溃</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-0448A5F0-F0C4-4943-BFB2-0D8C137B8212" title="解决与焦点事件有关的问题。">焦点活动</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-DF31EA29-6196-405B-9B32-005D67395048" title="数据传输功能可能存在的问题，使您可以向应用程序添加拖放（DnD）以及剪切，复制和粘贴（CCP）操作。">数据传输</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-986C2FB7-94D4-4201-9659-55F2461B6D34" title="解决其他问题，例如启动画面问题，弹出菜单问题和AWT的背景色继承，并提供解决问题的信息。">其他事宜</a></p>
                  </li>
                  <li>
                     <p><a href="awt.html#GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD" title="重量级或轻型（HW / LW）组件混合功能出现问题。">重量级或轻量级组分混合</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD395"></a><div class="props_rev_3"><a id="GUID-623C61BB-8E09-4918-A120-911CA5C92FC6" name="GUID-623C61BB-8E09-4918-A120-911CA5C92FC6"></a><h3 id="JSTGD-GUID-623C61BB-8E09-4918-A120-911CA5C92FC6" class="sect3">AWT的调试提示</h3>
               <div>
                  <p>调试与AWT相关的问题的有用提示。</p>
                  <div class="section">
                     <p>要转储AWT组件层次结构，请按Control + Shift + F1。</p>
                     <p>如果应用程序挂起，请通过按Windows上的Control + Break（发送SIGBREAK信号）或Oracle Solaris和Linux操作系统上的Control + \（发送SIGQUIT信号）来获得堆栈跟踪。</p>
                     <p>要在Oracle Solaris和Linux操作系统上跟踪X11错误，请设置<code class="codeph">sun.awt.noisyerrorhandler</code>系统属性<code class="codeph">true</code> 。在Java SE 6和更低版本中， <code class="codeph">NOISY_AWT</code>为此使用了环境变量。
                     </p>
                     <p>在Java SE 8之前，可以通过设置系统属性来捕获在AWT事件调度线程（EDT）中引发的异常<code class="codeph">sun.awt.exception.handler</code>到实现该类的类的名称<code class="codeph">public void handle(Throwable)</code>方法。该机制已在Java SE 8中更新为使用标准<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html" target="_blank"><code class="codeph">Thread.UncaughtExceptionHandler</code></a>接口。
                     </p>
                     <p>调试AWT问题时，记录器可以产生有用的输出。看到<a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html" target="_blank"><code class="codeph">java.util.logging</code></a>包装说明。
                     </p>
                     <p>以下记录器可用：</p>
                     <ul class="simple" style="list-style-type:none;padding-left:0">
                        <li><code class="codeph">java.awt</code></li>
                        <li><code class="codeph">java.awt.focus</code></li>
                        <li><code class="codeph">java.awt.event</code></li>
                        <li><code class="codeph">java.awt.mixing</code></li>
                        <li><code class="codeph">sun.awt</code></li>
                        <li><code class="codeph">sun.awt.windows</code></li>
                        <li><code class="codeph">sun.awt.X11</code></li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD396"></a><div class="props_rev_3"><a id="GUID-7BE06BA5-0206-42FE-8AD2-468A1AFA8512" name="GUID-7BE06BA5-0206-42FE-8AD2-468A1AFA8512"></a><h3 id="JSTGD-GUID-7BE06BA5-0206-42FE-8AD2-468A1AFA8512" class="sect3">布局管理器问题</h3>
               <div>
                  <p>布局管理器可能存在的问题，并在可用时提供了解决方法。</p>
                  <div class="section">布局管理器和解决方法出现以下问题：</div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span><span class="bold">调用<span class="apiname">invalidate（）</span>和</span> <span class="bold">validate（）会</span> <span class="bold">增加组件的大小</span></span><div>
                           <p><span class="bold">原因：</span>由于某些细节<code class="codeph">GridBagLayout</code>布局经理，如果<code class="codeph">ipadx</code>要么<code class="codeph">ipady</code>设置，并调用<span class="apiname">invalidate（）</span>和<span class="apiname">validate（）</span> ，然后组件的大小增加到的值<code class="codeph">ipadx</code>要么<code class="codeph">ipady</code> 。发生这种情况是因为<code class="codeph">GridBagLayout</code>布局管理器迭代地计算在容器中存储组件所需的空间量。
                           </p>
                           <p><span class="bold">解决方法：</span>在这种情况下，JDK没有提供可靠且简单的方法来检测布局管理器是否应该重新排列组件，但是有一个简单的解决方法。将组件与重写的方法<span class="apiname">getPreferredSize（）</span>结合使用，该方法返回所需的当前大小，如以下示例所示。
                           </p><pre class="pre codeblock"><code>public Dimension getPreferredSize(){
   return new Dimension(size+xpad*2+1, size+ypad*2+1); 
}
</code></pre></div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">从任何</span> <span class="bold">Container.doLayout（）</span> <span class="bold">方法</span> <span class="bold">使用<span class="apiname">validate（）进行</span>无限递归</span></span><div>
                           <p><span class="bold">原因：</span>从任何<span class="apiname">Container.doLayout（）</span>方法调用<span class="apiname">validate（）</span>都可能导致无限递归，因为AWT本身会从<span class="apiname">validate（）</span>调用<span class="apiname">doLayout</span> <span class="apiname">（）</span> 。
                           </p>
                        </div>
                     </li>
                  </ol>
               </div>
            </div><a id="JSTGD398"></a><div class="props_rev_3"><a id="GUID-861F1E94-1944-42C2-AD73-9E1E6C854321" name="GUID-861F1E94-1944-42C2-AD73-9E1E6C854321"></a><h3 id="JSTGD-GUID-861F1E94-1944-42C2-AD73-9E1E6C854321" class="sect3">关键事件</h3>
               <div>
                  <p>当前版本中尚未解决的与处理关键事件有关的问题。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-861F1E94-1944-42C2-AD73-9E1E6C854321__GUID-40D445E0-D20E-4E91-9133-8AF89C262D16">当前尚未解决以下键盘问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在某些非英语键盘上，某些重音键会刻在键上，因此是主要图层字符。但是，它们不能用于助记符，因为没有相应的Java密钥代码。</p>
                        </li>
                        <li>
                           <p>在运行时更改默认语言环境不会更改菜单快捷键显示的文本。</p>
                        </li>
                        <li>
                           <p>在标准的109键日语键盘上，日元键和反斜杠键都生成一个反斜杠，因为它们具有相同的字符代码。 <code class="codeph">WM_CHAR</code>信息。AWT应该区分它们。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-861F1E94-1944-42C2-AD73-9E1E6C854321__GUID-15068C39-6C67-4EB1-BD42-8E607EB90410">以下键盘问题与Oracle Solaris 10和Linux x86系统有关。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>这些系统中的键盘输入通常基于X Window系统的X键盘扩展名（XKB）。用户可以配置一种键盘布局（例如，丹麦语： <code class="codeph">dk</code> ）或几种布局之间切换（例如， <code class="codeph">us</code>和<code class="codeph">dk</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>例如，使用某些键盘布局<code class="codeph">sk</code> ， <code class="codeph">hu</code>和<code class="codeph">cz</code> ，按数字键盘上的小数点分隔符不仅可以输入分隔符，还可以删除前一个字符。这是由于一个本地错误。一种解决方法是使用两种布局，例如， <code class="codeph">us</code>和<code class="codeph">sk</code> 。在这种情况下，数字小键盘在两种布局中均可以正常工作。
                           </p>
                        </li>
                        <li>
                           <p>在支持动态键盘更改的UNIX系统上，正在运行的Java应用程序无法识别此类更改。例如，将键盘从美国更改为德语不会更改键盘映射。尽管X服务器检测到更改并发出了<code class="codeph">MappingNotify</code>向感兴趣的客户发送事件AWT不会刷新其键码-键符号映射的概念。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD399"></a><div class="props_rev_3"><a id="GUID-094860B0-DC42-428A-BE28-33ECB81C8C72" name="GUID-094860B0-DC42-428A-BE28-33ECB81C8C72"></a><h3 id="JSTGD-GUID-094860B0-DC42-428A-BE28-33ECB81C8C72" class="sect3">模态问题</h3>
               <div>
                  <p>有关使用模态的问题的信息。</p>
                  <div class="section">
                     <p>在Java SE 6发行版中，解决了许多问题，并在AWT模态领域实现了许多改进。如果您发现Java SE 1.5或更早版本存在模态问题，请首先升级到最新的Java SE版本，以查看问题是否已解决。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Java SE 6中修复的一些问题如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>模态对话框位于被阻止的框架后面。</p>
                        </li>
                        <li>
                           <p>同时打开具有相同父窗口的两个模式对话框。</p>
                        </li>
                     </ul>
                     <p>本节解决以下问题。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">UNIX窗口管理器：</span></p>
                           <p>许多模式改进在某些Oracle Solaris或Linux环境中不可用，例如，在使用通用桌面环境（CDE）窗口管理器时。在Java SE 6和更高版本中，要查看特定配置中是否支持模式类型或模式排除类型，请使用以下方法：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">Toolkit.isModalityTypeSupported()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">Toolkit.isModalExclusionTypeSupported()</code></p>
                              </li>
                           </ul>
                           <p>当屏幕上出现模式对话框时，窗口管理器可能会从任务栏隐藏同一应用程序中的某些Java顶级窗口。这可能会使最终用户感到困惑，但不会对他们的工作造成太大影响，因为所有隐藏的窗口都被模式阻止并且无法操作。</p>
                        </li>
                        <li>
                           <p><span class="bold">其他模态问题：</span></p>
                           <p>有关与模态相关的功能以及如何使用它们的更多信息，请参阅<a href="https://docs.oracle.com/javase/8/docs/api/java/awt/doc-files/Modality.html" target="_blank">AWT Modality规范</a> 。
                           </p>
                           <p>该规范中的部分内容描述了一些可能与模式对话框相关或受其影响的AWT功能：永远在线的属性，焦点处理，窗口状态等。在这种情况下，应用程序行为通常是不确定的或取决于平台；因此，不要依赖任何特定的行为。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD402"></a><div class="props_rev_3"><a id="GUID-130F872C-7F03-4AEF-BB02-72F1A3BECFAE" name="GUID-130F872C-7F03-4AEF-BB02-72F1A3BECFAE"></a><h3 id="JSTGD-GUID-130F872C-7F03-4AEF-BB02-72F1A3BECFAE" class="sect3">AWT崩溃</h3>
               <div>
                  <p>识别并解决与AWT相关的崩溃。</p>
                  <ul>
                     <li class="stepexpand"><span><span class="bold">区分AWT崩溃：</span></span><div>
                           <p>发生崩溃时，将创建一个错误日志，其中包含信息以及崩溃时获得的状态。请参阅<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。
                           </p>
                           <p>文件顶部附近的线表示发生错误的库。以下示例显示了当崩溃与AWT库相关时的错误日志文件的一部分。</p><pre class="pre codeblock"><code>...
# Java VM: Java HotSpot(TM) Client VM (1.6.0-beta2-b76 mixed mode, sharing)
# Problematic frame:
# C  [awt.dll+0x123456]
...
</code></pre><p>但是，崩溃可能发生在系统库的某个深处，尽管仍然是由AWT引起的。在这种情况下， <code class="codeph">awt.dll</code>不会显示为有问题的框架，因此您需要在文件的“ <code class="codeph">Stack: Native frames: Java frames</code>如以下示例所示。
                           </p><pre class="pre codeblock"><code>Stack: [0x0aeb0000,0x0aef0000),  sp=0x0aeefa44,  free space=254k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
C  0x00abc751
C  [USER32.dll+0x3a5f]
C  [USER32.dll+0x3b2e]
C  [USER32.dll+0x5874]
C  [USER32.dll+0x58a4]
C  [ntdll.dll+0x108f]
C  [USER32.dll+0x5e7e]
C  [awt.dll+0xec889]
C  [awt.dll+0xf877d]
j  sun.awt.windows.WToolkit.eventLoop()V+0
j  sun.awt.windows.WToolkit.run()V+69
j  java.lang.Thread.run()V+11
v  ~StubRoutines::call_stub
V  [jvm.dll+0x83c86]
V  [jvm.dll+0xd870f]
V  [jvm.dll+0x83b48]
V  [jvm.dll+0x838a5]
V  [jvm.dll+0x9ebc8]
V  [jvm.dll+0x108ba1]
V  [jvm.dll+0x108b6f]
C  [MSVCRT.dll+0x27fb8]
C  [kernel32.dll+0x202ed]

Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)
j  sun.awt.windows.WToolkit.eventLoop()V+0
j  sun.awt.windows.WToolkit.run()V+69
j  java.lang.Thread.run()V+11
v  ~StubRoutines::call_stub
</code></pre><p>如果文字<code class="codeph">awt.dll</code>出现在本机框架中的某处，则崩溃可能与AWT有关。</p>
                        </div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">解决AWT崩溃</span> ：</span><div>
                           <p>大多数AWT崩溃发生在Windows平台上，并且是由线程跟踪引起的。这些问题中有许多是在Java SE 6中修复的，因此，如果崩溃是在较早的版本中发生的，则首先尝试确定问题是否已在最新版本中得到解决。</p>
                           <p>崩溃的可能原因之一是许多AWT操作是异步的。例如，如果显示一个调用<span class="apiname">frame.setVisible（true）</span>的框架，则无法确定该框架将是此调用返回后的活动窗口。
                           </p>
                           <p>另一个示例涉及本机文件对话框。操作系统需要花费一些时间来初始化和显示这些对话框，如果在调用<span class="apiname">setVisible（true）</span>之后立即将其丢弃，则可能会发生崩溃。因此，如果您的应用程序包含一些同时运行或一次又一次运行的AWT调用，则最好在它们之间插入一些延迟或添加一些同步。
                           </p>
                        </div>
                     </li>
                  </ul>
               </div>
            </div><a id="JSTGD405"></a><div class="props_rev_3"><a id="GUID-0448A5F0-F0C4-4943-BFB2-0D8C137B8212" name="GUID-0448A5F0-F0C4-4943-BFB2-0D8C137B8212"></a><h3 id="JSTGD-GUID-0448A5F0-F0C4-4943-BFB2-0D8C137B8212" class="sect3">焦点活动</h3>
               <div>
                  <p>解决与焦点事件有关的问题。</p>
                  <div class="section">
                     <p>以下各节讨论与焦点事件相关的疑难解答问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="awt.html#GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32" title="解决焦点问题。">如何追踪焦点事件</a></p>
                        </li>
                        <li>
                           <p><a href="awt.html#GUID-6B26ECBC-DB97-47BC-89CE-40CABD221F9F" title="有时，本机平台可能会引起问题。要检查这一点，请调查与焦点相关的本地事件。">本机聚焦系统</a></p>
                        </li>
                        <li>
                           <p><a href="awt.html#GUID-3C2D2F6C-6A4E-4CFD-AB3E-D14079C8DD85" title="X窗口管理器支持的焦点模型列表。">X窗口管理器支持的焦点模型</a></p>
                        </li>
                        <li>
                           <p><a href="awt.html#GUID-67FAB2F0-36DA-4A66-BBF1-FCC117ADA258" title="与AWT中可能出现的焦点相关的问题以及建议的解决方案。">焦点杂项问题</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSTGD406"></a><div class="props_rev_3"><a id="GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32" name="GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32"></a><h4 id="JSTGD-GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32" class="sect4">如何追踪焦点事件</h4>
                  <div>
                     <p>解决焦点问题。</p>
                     <div class="section">
                        <p>您可以通过将焦点侦听器添加到工具包来跟踪焦点事件，如以下示例所示。</p><pre class="pre codeblock"><code>Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener(
   public void eventDispatched(AWTEvent e) {
      System.err.println(e);
   }
), FocusEvent.FOCUS_EVENT_MASK | WindowEvent.WINDOW_FOCUS_EVENT_MASK |
   WindowEvent.WINDOW_EVENT_MASK);
</code></pre><p>的<code class="codeph">System.err</code>在这里使用stream，是因为它不缓冲输出。
                        </p>
                        <div class="infoboxnote" id="GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32__GUID-48553924-23E4-4A61-B7EE-4D4235257730">
                           <p class="notep1">记得：</p>焦点事件的正确顺序如下：<ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">FOCUS_LOST</code>关于组件失去重点</p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_LOST_FOCUS</code>在顶级失去重点</p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_DEACTIVATED</code>在顶级失败激活上</p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_ACTIVATED</code>在顶层成为主动寡妇</p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_GAINED_FOCUS</code>在顶层成为焦点窗口</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FOCUS_GAINED</code>专注于组件</p>
                              </li>
                           </ul>
                           <p>当焦点在焦点窗口内的组件之间转移时，仅<code class="codeph">FOCUS_LOST</code>和<code class="codeph">FOCUS_GAINED</code>应生成事件。当焦点在同一所有者的所有窗口之间或在所有者的窗口与其所有者之间转移时，应生成以下事件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">FOCUS_LOST</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_LOST_FOCUS</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">WINDOW_GAINED_FOCUS</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">FOCUS_GAINED</code></p>
                              </li>
                           </ul>
                        </div>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-22136A2E-1A0B-44B1-BBD1-89A484207C32__GUID-450179D8-6EBB-4B44-B95A-7DC6D0513049">
                              <p class="notep1">注意：</p>失去焦点或激活的事件应该首先出现。
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD408"></a><div class="props_rev_3"><a id="GUID-6B26ECBC-DB97-47BC-89CE-40CABD221F9F" name="GUID-6B26ECBC-DB97-47BC-89CE-40CABD221F9F"></a><h4 id="JSTGD-GUID-6B26ECBC-DB97-47BC-89CE-40CABD221F9F" class="sect4">本机聚焦系统</h4>
                  <div>
                     <p>有时，本机平台可能会引起问题。要检查这一点，请调查与焦点相关的本地事件。</p>
                     <p>确保激活了要聚焦的窗口，并且要聚焦的组件收到了本机聚焦事件。</p>
                     <p>在Windows平台上，本机焦点事件如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">WM_ACTIVATE</code>为顶级。 <code class="codeph">WPARAM</code>是<code class="codeph">WA_ACTIVE</code>当激活和<code class="codeph">WA_INACTIVE</code>停用时。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">WM_SETFOCUS</code>和<code class="codeph">WM_KILLFOCUS</code>对于一个组件。
                           </p>
                        </li>
                     </ul>
                     <p>在Windows平台上，实现了<strong class="term">综合关注</strong>的概念。这意味着焦点所有者组件仅模拟其可聚焦状态，而实际的本机焦点设置为<strong class="term">焦点代理</strong>组件。该组件接收键和输入法本机消息，并将它们分派给焦点所有者。在JDK7之前，焦点代理组件是框架或对话框中的专用隐藏子组件。在最新的JDK版本中，框架或对话框用作焦点代理。现在，它的代理不仅集中于拥有的窗口中的组件，还集中于所有子组件。一个简单的窗口永远不会获得本机焦点，而是依赖于其所有者的焦点代理。该机制对用户是透明的，但在调试时应予以考虑。
                     </p>
                     <p>在Oracle Solaris和Linux操作系统上，XToolkit使用焦点模型，该模型允许AWT自己管理焦点。使用此模型，窗口管理器不会直接在顶级窗口上设置输入焦点，而是仅发送<code class="codeph">WM_TAKE_FOCUS</code>客户消息，指示应设置焦点。然后，如果允许，AWT会明确将焦点设置在顶级窗口上。
                     </p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-6B26ECBC-DB97-47BC-89CE-40CABD221F9F__GUID-633F6422-A816-4327-A0E3-9BC694BAF424">
                           <p class="notep1">注意：</p>X服务器和某些窗口管理器可能会将焦点事件发送到窗口。但是，这些事件被AWT丢弃。</div> 
                     </div>
                     <p>当顶级内部的组件获得焦点时，AWT不会生成焦点事件的层次链。此外，映射到组件的本机窗口不会获得本机焦点事件。在Oracle Solaris和Linux平台以及Windows平台上，AWT使用焦点代理机制。因此，通过合成焦点事件来设置对组件的焦点，而不可见的焦点代理具有本机焦点。</p>
                     <p>映射到<code class="codeph">Window</code>对象（不是<code class="codeph">Frame</code>要么<code class="codeph">Dialog</code>对象）具有<code class="codeph">override-redirect</code>标志集。因此，窗口管理器不会将焦点更改通知给窗口。仅在鼠标单击时才要求在窗口上聚焦。此窗口将根本不接收本地焦点事件。因此，您只能跟踪<code class="codeph">FocusIn</code>要么<code class="codeph">FocusOut</code>框架或对话框上的事件。因为焦点的主要处理发生在Java级别，所以XToolkit的调试焦点比WToolkit的调试要简单。
                     </p>
                  </div>
               </div><a id="JSTGD410"></a><div class="props_rev_3"><a id="GUID-3C2D2F6C-6A4E-4CFD-AB3E-D14079C8DD85" name="GUID-3C2D2F6C-6A4E-4CFD-AB3E-D14079C8DD85"></a><h4 id="JSTGD-GUID-3C2D2F6C-6A4E-4CFD-AB3E-D14079C8DD85" class="sect4">X窗口管理器支持的焦点模型</h4>
                  <div>
                     <p>X窗口管理器支持的焦点模型列表。</p>
                     <p>X窗口管理器支持以下焦点模型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><strong class="term">单击焦点</strong>是常用的焦点模型。（例如，Microsoft Windows使用此模型。）
                           </p>
                        </li>
                        <li>
                           <p><strong class="term">焦点跟随鼠标</strong>是一种焦点模型，其中焦点移到鼠标悬停的窗口上。
                           </p>
                        </li>
                     </ul>
                     <p>在Java SE 7的XAWT中未检测到<strong class="term">焦点跟随鼠标</strong>模型，这会导致简单窗口（对象<code class="codeph">java.awt.Window</code>类）。这样的窗户有<code class="codeph">override-redirect</code>属性，这意味着它们只能在按下鼠标按钮时聚焦，而不能悬停在窗口上。解决方法是，设置<code class="codeph">MouseListener</code>在窗口上，并在鼠标越过窗口边界时请求将焦点放在窗口上。
                     </p>
                  </div>
               </div><a id="JSTGD411"></a><div class="props_rev_3"><a id="GUID-67FAB2F0-36DA-4A66-BBF1-FCC117ADA258" name="GUID-67FAB2F0-36DA-4A66-BBF1-FCC117ADA258"></a><h4 id="JSTGD-GUID-67FAB2F0-36DA-4A66-BBF1-FCC117ADA258" class="sect4">焦点杂项问题</h4>
                  <div>
                     <p>与AWT中可能出现的焦点相关的问题以及建议的解决方案。</p>
                     <ol>
                        <li class="stepexpand"><span><span class="bold">单击框架的标题时，Linux + KDE，XToolkit无法在两个框架之间切换。</span></span><div>
                              <p>单击框架内的组件会导致焦点发生变化。</p>
                              <p><span class="bold">解决方案：</span>检查窗口管理器的版本并将其升级到3.0或更高版本。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">您想使用<code class="codeph">KeyListener</code>转移焦点以响应Tab / Shift + Tab，但不会出现按键事件。</span></span><div>
                              <p><span class="bold">解决方案：</span>要捕获遍历键事件，必须通过调用<span class="apiname">Component.setFocusTraversalKeysEnabled（true）</span>来启用它们。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">使用<span class="apiname">Window.setModalExclusionType（ModalExclusionType）</span>将窗口设置为模态排除。</span></span><div>
                              <p>框架（其所有者）被模式阻止。在这种情况下，窗口也将保持模式阻止状态。</p>
                              <p><span class="bold">解决方案：</span>如果不允许窗口的所有者获得焦点，则该窗口不能成为焦点窗口。解决方案是将所有者从模态中排除。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">在Windows上，组件请求焦点，并同时从其容器中删除。</span></span><div>
                              <p>有时<code class="codeph">java.lang.NullPointerException: null pData</code>被抛出。
                              </p>
                              <p><span class="bold">解决方案：</span>避免引发异常的最简单方法是执行删除操作并要求将注意力集中在EDT上。另一种更复杂的方法是，如果需要在不同的线程上执行这些操作，则同步请求的焦点和删除。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">当请求焦点在组件上并且焦点所有者被立即删除时，焦点将在删除的组件之后移至该组件。</span></span><div>
                              <p>例如，组件A是焦点所有者。请求将焦点放在组件B上，并在将组件A从其容器中取出后立即进行。最终，焦点将转移到组件C，该组件C在容器中位于组件A之后，而不是组件B。</p>
                              <p><span class="bold">解决方案：</span>在这种情况下，请确保在删除组件A之后而不是在删除组件A之后执行请求焦点。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">在Windows上，当窗口设置为<code class="codeph">alwaysOnTop</code>在不活动的框架中，窗口无法接收按键事件。</span></span><div>
                              <p>例如，显示一个框架及其拥有的窗口。该框架处于非活动状态，因此窗口未聚焦。然后，将窗口设置为<code class="codeph">alwaysOnTop</code> 。窗口获得焦点，但其所有者保持不活动状态。因此，该窗口不能接收键事件。
                              </p>
                              <p><span class="bold">解决方案：</span>在将窗口设置为之前，将框架置于最前面（ <span class="apiname">Frame.toFront（）</span>方法）。 <code class="codeph">alwaysOnTop</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">当显示初始屏幕并在初始屏幕窗口关闭后显示框架时，该框架不会被激活。</span></span><div>
                              <p><span class="bold">解决方案：</span>表示它<span class="apiname">（Frame.setVisible（true）</span>方法）后带上帧到前方<span class="apiname">（Frame.toFront（）</span>方法）。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold"><span class="apiname">WindowFocusListener.windowGainedFocus（WindowEvent）</span>方法不返回框架的最新焦点所有者。</span></span><div>
                              <p>例如，框架是焦点窗口，框架的一部分是焦点所有者。单击另一个窗口，然后再次单击框架。 <code class="codeph">WINDOW_GAINED_FOCUS</code>来到框架并调用<span class="apiname">WindowFocusListener.windowGainedFocus（WindowEvent）</span>方法。但是，在此回调内部，您无法确定框架的最新焦点所有者，因为<span class="apiname">Frame.getMostRecentFocusOwner（）</span>返回<code class="codeph">null</code> 。
                              </p>
                              <p><span class="bold">解决方案：</span>您可以在<span class="apiname">WindowListener.windowActivated（WindowEvent）</span>回调内部获取框架的最新焦点所有者。但是，到这个时候，只有当它没有拥有的窗口时，框架才会成为聚焦窗口。
                              </p>
                              <div class="infoboxnote" id="GUID-67FAB2F0-36DA-4A66-BBF1-FCC117ADA258__GUID-7B38F638-8CA0-4F43-8C83-78FB91BB6588">
                                 <p class="notep1">注意：</p>
                                 <p>此方法不适用于窗口，仅适用于框架或对话框。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">使用<span class="apiname">Component.setEnabled（false）</span>禁用了窗口，但窗口不会完全无法聚焦。</span></span><div>
                              <p><span class="bold">解决方案：</span>不要假设通过调用<span class="apiname">Component.setEnabled（false）</span>或<span class="apiname">Component.setFocusable（false）</span>设置的条件及其所有内容都将保持不聚焦。而是使用<span class="apiname">Window.setFocusableWindowState（boolean）</span>方法。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="JSTGD413"></a><div class="props_rev_3"><a id="GUID-DF31EA29-6196-405B-9B32-005D67395048" name="GUID-DF31EA29-6196-405B-9B32-005D67395048"></a><h3 id="JSTGD-GUID-DF31EA29-6196-405B-9B32-005D67395048" class="sect3">数据传输</h3>
               <div>
                  <p>数据传输功能可能存在的问题，使您可以向应用程序添加<span class="italic">拖放</span> （DnD）以及<span class="italic">剪切，复制和粘贴</span> （CCP）操作。
                  </p>
                  <p>以下各节讨论数据传输功能可能出现的问题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="awt.html#GUID-B8D077F0-7BE8-40E4-9FAC-EEC071DDC081" title="可用于解决拖放（DnD）应用程序问题的方法。">调试拖放应用程序</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-227FEA78-44C5-4560-96A4-3396DE443D97" title="AWT中的数据传输操作经常发生的问题以及建议的故障排除解决方案。">数据传输常见问题</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD414"></a><div class="props_rev_3"><a id="GUID-B8D077F0-7BE8-40E4-9FAC-EEC071DDC081" name="GUID-B8D077F0-7BE8-40E4-9FAC-EEC071DDC081"></a><h4 id="JSTGD-GUID-B8D077F0-7BE8-40E4-9FAC-EEC071DDC081" class="sect4">调试拖放应用程序</h4>
                  <div>
                     <p>可用于解决拖放（DnD）应用程序问题的方法。</p>
                     <div class="section">
                        <p>使用调试器对DnD功能进行故障排除很困难，因为在拖放操作期间，所有输入都被捕获。因此，如果在DnD期间放置断点，则可能需要重新启动X服务器。尝试改用远程调试。</p>
                        <p>可以使用两种简单的方法来解决DnD的大多数问题：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>全部列印<code class="codeph">DataFlavor</code>实例</span></li>
                        <li class="stepexpand"><span>打印收到的数据</span><div>远程调试的替代方法是<span class="apiname">System.err.println（）</span>函数，该函数可以无延迟地打印输出。
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD415"></a><div class="props_rev_3"><a id="GUID-227FEA78-44C5-4560-96A4-3396DE443D97" name="GUID-227FEA78-44C5-4560-96A4-3396DE443D97"></a><h4 id="JSTGD-GUID-227FEA78-44C5-4560-96A4-3396DE443D97" class="sect4">数据传输常见问题</h4>
                  <div>
                     <p>AWT中的数据传输操作经常发生的问题以及建议的故障排除解决方案。</p>
                     <ol>
                        <li class="stepexpand"><span><span class="bold">从剪贴板粘贴大量数据会花费太多时间。</span></span><div>
                              <p>使用<span class="apiname">Clipboard.getContents（）</span>函数进行粘贴操作有时会导致应用程序挂起一段时间，特别是如果富应用程序提供要粘贴的数据时。
                              </p>
                              <p><span class="apiname">Clipboard.getContents（）</span>函数以所有可用的类型（例如，某些文本和图像类型）获取剪贴板数据，这可能既昂贵又不必要。
                              </p>
                              <p><span class="bold">解决方案：</span>使用<span class="apiname">Clipboard.getData（）</span>方法仅从<span class="apiname">剪贴板</span>中获取特定数据。如果仅需要一种或几种类型的数据，请使用以下一种方法<code class="codeph">Clipboard</code>方法而不是<span class="apiname">getContents（）</span> ：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="apiname">DataFlavor [] getAvailableDataFlavors（）</span></p>
                                 </li>
                                 <li>
                                    <p><span class="apiname">boolean isDataFlavorAvailable（DataFlavor风格）</span></p>
                                 </li>
                                 <li>
                                    <p><span class="apiname">对象getData（DataFlavor风味）</span></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">当Java应用程序将</span> <span class="bold"><span class="apiname">Transferable.getTransferData（）</span></span> <span class="bold">用于DnD操作时，拖动似乎要花费很长时间。</span></span><div>
                              <p>为了仅在需要时初始化传输的数据，将初始化代码放入<span class="apiname">Transferable.getTransferData（）中</span> 。
                              </p>
                              <p><code class="codeph">Transferable</code>数据生成成本很高，并且在DnD操作期间，多次调用<span class="apiname">Transferable.getTransferData（）</span> ，从而导致速度变慢。
                              </p>
                              <p><span class="bold">解决方案：</span>缓存<code class="codeph">Transferable</code>数据，因此仅生成一次。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">无法在Java应用程序与GNOME / KDE桌面和文件浏览器之间传输文件。</span></span><div>
                              <p>在Windows和某些窗口管理器上，传输的文件列表可以表示为<code class="codeph">DataFlavor.javaFileListFlavor</code>数据类型。但是，并非所有的窗口管理器都以这种格式表示文件列表。例如，GNOME窗口管理器将文件列表表示为URI列表。</p>
                              <p><span class="bold">解决方法：</span>要获取文件，请请求类型的数据<code class="codeph">String</code> ，然后根据RFC 2483中描述的text / uri-list格式将字符串转换为文件列表。要启用将文件从Java应用程序拖放到GNOME / KDE桌面和文件浏览器的功能，请以text / uri-list格式导出数据。有关示例，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4899516" target="_blank">RFE的“变通方法”部分</a> 。</p>
                              <p><span class="bold">解决方案：</span>在DnD操作期间，随着鼠标光标的移动，移动带有图像的窗口。请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4899516" target="_blank">RFE中“变通方法”部分中</a>的代码示例。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">图像被传递到以下方法的</span> <span class="bold"><span class="apiname">startDrag（）</span></span> <span class="bold">方法之一</span> <span class="bold"><code class="codeph">DragGestureEvent</code></span>要么<span class="bold"><code class="codeph">DragSource</code></span> ， <span class="bold">但在随后的DnD操作期间不显示图像。</span></span></li>
                        <li class="stepexpand"><span><span class="bold">无法使用DnD传输阵列。</span></span><div>
                              <p>的<code class="codeph">DataFlavor</code>类没有可处理数组的构造函数。数组的mime类型包含转义的字符。以下示例中的代码抛出一个<code class="codeph">IllegalArgumentException</code> 。
                              </p><pre class="pre codeblock"><code>new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType + 
"; class=" + 
(new String[0]).getClass().getName())
</code></pre><p><span class="bold">解决方案：</span> “引用”表示形式类参数的值，如以下示例所示，其中引号转义：</p><pre class="pre codeblock"><code>new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType + 
"; class=" + 
"\"" + 
(new String[0]).getClass().getName() + 
"\"")
</code></pre><p>请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4276926" target="_blank">错误报告</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">将AWT DnD支持与Swing组件一起使用时存在问题。</span></span><div>
                              <p>可能会发生各种问题，例如，在DnD操作期间触发了奇怪的事件，无法拖放多个项目， <code class="codeph">InvalidDnDOperationException</code>被抛出。
                              </p>
                              <p><span class="bold">解决方案：</span>将Swing的DnD支持与Swing组件一起使用。尽管Swing DnD实现基于AWT DnD实现，但是您不能混合使用Swing和AWT DnD。请参见<a href="https://docs.oracle.com/javase/tutorial/uiswing/dnd/" target="_blank">Swing教程</a>文档的<a href="https://docs.oracle.com/javase/tutorial/uiswing/dnd/" target="_blank">DnD部分</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">无法更改源的状态以依赖于目标。</span></span><div>
                              <p>为了将源的状态更改为依赖于目标，您必须在同一代码区中引用源和目标组件，但这在DnD API中当前未实现。</p>
                              <p><span class="bold">解决方法：</span>一种解决方法是将标志添加到可转让对象中，以使您可以确定事件的上下文。
                              </p>
                              <p>为了在一个Java VM中传输数据，提出了以下解决方法：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>将目标组件实现为<code class="codeph">DragSourceListener</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>在<span class="apiname">DragGestureRecognizer.dragGestureRecognized（）中</span> ，将目标添加到拖动源侦听器，如以下示例所示。
                                    </p><pre class="pre codeblock"><code>public void dragGestureRecognized(DragGestureEvent dge) {
             dge.startDrag(null, new StringSelection("SomeTransferedText"));
             dge.getDragSource().addDragSourceListener(target);             
        }
</code></pre></li>
                                 <li>
                                    <p>现在，您可以在<span class="apiname">DragSourceListener（）</span>的<span class="apiname">dragEnter（）</span> ， <span class="apiname">dragOver（）</span> ， <span class="apiname">dropActionChanged（）</span>和<span class="apiname">dragDropEnd</span> <span class="apiname">（）</span>方法中获取目标和源。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">在应用程序中传输对象需要很长时间。</span></span><div>
                              <p>大量数据的传输或传输对象的创建花费了太长时间。用户必须等待很长时间才能完成数据传输。</p>
                              <p>此昂贵的操作使传输时间太长，因为您必须等待<span class="apiname">Transferable.getTransferData（）</span>完成。
                              </p>
                              <p><span class="bold">解决方案：</span>此解决方案仅对在一个Java VM中传输数据有效。在拖动操作之前创建或获取昂贵的资源。例如，在创建可传输数据时获取文件内容，以使<span class="apiname">Transferable.getTransferData（）</span>不会太长。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="JSTGD419"></a><div class="props_rev_3"><a id="GUID-986C2FB7-94D4-4201-9659-55F2461B6D34" name="GUID-986C2FB7-94D4-4201-9659-55F2461B6D34"></a><h3 id="JSTGD-GUID-986C2FB7-94D4-4201-9659-55F2461B6D34" class="sect3">其他事宜</h3>
               <div>
                  <p>解决其他问题，例如启动画面问题，弹出菜单问题和AWT的背景色继承，并提供解决问题的信息。</p>
                  <p>以下小节讨论了其他问题的疑难解答提示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="awt.html#GUID-DF9940D6-5E09-40E6-8ADC-25646C1AD7A2" title="启动画面AWT和解决方案可能发生的问题。">启动画面问题</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-7FA44C9A-CF3D-43A1-9E96-D6E421D7508C" title="托盘图标可能出现的问题。">纸盒图标问题</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-978E5804-C296-43B2-AC0C-9AB3ED570E2D" title="弹出菜单中可能出现的问题。">弹出菜单问题</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-1A48C3D7-E94A-4FB0-8926-CD1327EAECDB" title="为了确保您的应用程序在每个平台上的一致性，请为每个组件或容器使用显式的颜色分配（前景和背景）。">背景或前景颜色继承</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-C6F6952D-3B58-4070-9129-A0DEBE518EC3" title="AWT容器有大小限制。在大多数平台上，此限制为32,767像素。">AWT面板尺寸限制</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-797CC032-8C6A-4518-A229-D48B3B02DC09" title="在调试某些图形用户界面（GUI）组件期间，设置-Dsun.awt.disablegrab = true系统属性。">在X11上的弹出菜单和类似组件的调试过程中挂起</a></p>
                     </li>
                     <li>
                        <p><a href="awt.html#GUID-871DD428-64B3-4BB8-B8FD-6F8287B07FBE" title="由于第三方软件（尤其是窗口管理器，例如Metacity）强制实施的限制，toFront（）/ toBack（）方法可能无法按预期工作，并且导致窗口相对于其他窗口而言不会更改其堆叠顺序顶层窗口。">X11上的Window.toFront（）/ toBack（）行为</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD420"></a><div class="props_rev_3"><a id="GUID-DF9940D6-5E09-40E6-8ADC-25646C1AD7A2" name="GUID-DF9940D6-5E09-40E6-8ADC-25646C1AD7A2"></a><h4 id="JSTGD-GUID-DF9940D6-5E09-40E6-8ADC-25646C1AD7A2" class="sect4">启动画面问题</h4>
                  <div>
                     <p>启动画面AWT和解决方案可能发生的问题。</p>
                     <div class="section">
                        <p>本节描述了AWT中的初始屏幕可能发生的一些问题：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span><span class="bold">用户使用适当的名称指定了JAR文件<code class="codeph">MANIFEST.MF</code>在<code class="codeph">-classpath</code> ，但初始屏幕不起作用。</span></span><div><span class="bold">解决方案：</span>请参阅下一个问题的解决方案。
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">目前尚不清楚应用程序中几个JAR文件中的哪个应包含初始屏幕图像。</span></span><div><span class="bold">解决方案：</span>仅当JAR文件与<code class="codeph">-jar</code>命令行选项。此JAR文件应同时包含“ SplashScreen-Image”清单选项和图像文件。JAR文件<code class="codeph">-classpath</code>永远不会检查初始屏幕<code class="codeph">MANIFEST.MF</code> 。如果不使用<code class="codeph">-jar</code> ，您仍然可以使用<code class="codeph">-splash</code>在命令行中指定初始屏幕图像。
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">半透明的PNG初始屏幕在Oracle Solaris和Linux操作系统上不起作用。</span></span><div><span class="bold">解决方案：</span>这是X11的本机限制。在Oracle Solaris和Linux操作系统上，会将半透明映像的alpha通道与50％阈值进行比较。大于0.5的Alpha值将使像素不透明，而小于0.5的Alpha值将完全透明。
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSTGD421"></a><div class="props_rev_3"><a id="GUID-7FA44C9A-CF3D-43A1-9E96-D6E421D7508C" name="GUID-7FA44C9A-CF3D-43A1-9E96-D6E421D7508C"></a><h4 id="JSTGD-GUID-7FA44C9A-CF3D-43A1-9E96-D6E421D7508C" class="sect4">纸盒图标问题</h4>
                  <div>
                     <p>托盘图标可能出现的问题。</p>
                     <div class="section">
                        <p>在Windows 98上的Java SE 6发行版中，不支持<span class="apiname">TrayIcon.displayMessage（）</span>方法，因为Windows 98不支持显示气球的本机服务。
                        </p>
                        <p>如果一个<code class="codeph">SecurityManager</code>已安装，则值<code class="codeph">AWTPermission</code>必须设置为<code class="codeph">accessSystemTray</code>为了创建一个<code class="codeph">TrayIcon</code>宾语。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD422"></a><div class="props_rev_3"><a id="GUID-978E5804-C296-43B2-AC0C-9AB3ED570E2D" name="GUID-978E5804-C296-43B2-AC0C-9AB3ED570E2D"></a><h4 id="JSTGD-GUID-978E5804-C296-43B2-AC0C-9AB3ED570E2D" class="sect4">弹出菜单问题</h4>
                  <div>
                     <p>弹出菜单中可能出现的问题。</p>
                     <div class="section">
                        <p>在<span class="apiname">JPopupMenu.setInvoker（）</span>方法中，调用程序是要在其中显示弹出菜单的组件。如果将此属性设置为<code class="codeph">null</code> ，则弹出菜单无法正常运行。
                        </p>
                        <p>解决方案是将弹出窗口的调用程序设置为其自身。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD423"></a><div class="props_rev_3"><a id="GUID-1A48C3D7-E94A-4FB0-8926-CD1327EAECDB" name="GUID-1A48C3D7-E94A-4FB0-8926-CD1327EAECDB"></a><h4 id="JSTGD-GUID-1A48C3D7-E94A-4FB0-8926-CD1327EAECDB" class="sect4">背景或前景颜色继承</h4>
                  <div>
                     <p>为了确保您的应用程序在每个平台上的一致性，请为每个组件或容器使用显式的颜色分配（前景和背景）。</p>
                     <div class="section">
                        <p>许多AWT组件使用自己的默认颜色作为背景色和前景色，而不是使用父色。</p>
                        <p>此行为取决于平台。同一组件在不同平台上的行为可能有所不同。此外，某些组件将默认值用于背景色或前景色，而将父级的值作为另一种颜色。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD424"></a><div class="props_rev_3"><a id="GUID-C6F6952D-3B58-4070-9129-A0DEBE518EC3" name="GUID-C6F6952D-3B58-4070-9129-A0DEBE518EC3"></a><h4 id="JSTGD-GUID-C6F6952D-3B58-4070-9129-A0DEBE518EC3" class="sect4">AWT面板尺寸限制</h4>
                  <div>
                     <p>AWT容器有大小限制。在大多数平台上，此限制为32,767像素。</p>
                     <div class="section">
                        <p>这意味着，例如，如果canvas对象高25个像素，则Java AWT面板最多可以显示1310个对象。</p>
                        <p>不幸的是，无论是使用Java代码还是使用本机代码，都无法更改此限制。该限制取决于操作系统用来存储窗口小部件大小的数据类型。例如，Windows 2000 / XP操作系统和Linux X操作系统使用<code class="codeph">integer</code>类型，因此限制为整数的最大大小。其他操作系统可能使用不同的类型，例如<code class="codeph">long</code> ，在这种情况下，限制可能会更高。
                        </p>
                        <p>请参阅所用平台的文档。</p>
                        <p>以下是此限制可能会有所帮助的变通办法示例：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>逐页显示组件。</span></li>
                        <li><span>使用标签可一次显示一些组件。</span></li>
                     </ul>
                  </div>
               </div><a id="JSTGD425"></a><div class="props_rev_3"><a id="GUID-797CC032-8C6A-4518-A229-D48B3B02DC09" name="GUID-797CC032-8C6A-4518-A229-D48B3B02DC09"></a><h4 id="JSTGD-GUID-797CC032-8C6A-4518-A229-D48B3B02DC09" class="sect4">在X11上的弹出菜单和类似组件的调试过程中挂起</h4>
                  <div>
                     <p>设置<code class="codeph">-Dsun.awt.disablegrab=true</code>某些图形用户界面（GUI）组件调试期间的系统属性。
                     </p>
                     <div class="section">
                        <p>某些图形用户界面（GUI）动作需要捕获所有输入事件，以确定该动作何时应终止（例如，导航弹出菜单）。抓斗处于活动状态时，其他任何应用程序都不会接收输入事件。如果正在调试Java应用程序，并且在抓取处于活动状态时到达了断点，则操作系统似乎挂起。发生这种情况的原因是，持有抓斗的Java应用程序已由调试器停止，并且无法处理任何输入事件，并且其他应用程序由于已安装的抓斗而无法接收事件。为了允许调试此类应用程序，从调试器运行应用程序时应设置以下系统属性：</p><pre class="pre codeblock"><code>-Dsun.awt.disablegrab=true
</code></pre><p>该属性有效地关闭了设置抓取的设置，并且不会挂起系统。但是，设置此选项后，在某些情况下，这可能导致无法终止通常会终止的GUI操作。例如，单击窗口的标题栏时，可能不会关闭弹出菜单。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD426"></a><div class="props_rev_3"><a id="GUID-871DD428-64B3-4BB8-B8FD-6F8287B07FBE" name="GUID-871DD428-64B3-4BB8-B8FD-6F8287B07FBE"></a><h4 id="JSTGD-GUID-871DD428-64B3-4BB8-B8FD-6F8287B07FBE" class="sect4">X11上的Window.toFront（）/ toBack（）行为</h4>
                  <div>
                     <p>由于第三方软件（尤其是窗口管理器，例如Metacity）强制实施的限制， <span class="apiname">toFront（）</span> / <span class="apiname">toBack（）</span>方法可能无法按预期工作，并且导致窗口相对于其他窗口而言不会更改其堆叠顺序顶层视窗。
                     </p>
                     <div class="section">
                        <p>更多详细信息，请参见CR 6472274。</p>
                        <p>如果应用程序希望将窗口置于顶部，则可以尝试通过以下方法解决该问题：调用<span class="apiname">Window.setAlwaysOnTop（true）</span>暂时使窗口始终位于顶部，然后调用<span class="apiname">setAlwaysOnTop（false）</span>重置“始终位于顶部” ”状态。
                        </p>
                        <div class="infoboxnote" id="GUID-871DD428-64B3-4BB8-B8FD-6F8287B07FBE__GUID-1653096E-C515-425A-A70A-2C638BA9B8FD">
                           <p class="notep1">注意：</p>
                           <p>由于窗口管理器可以实施更多限制，因此不能保证此解决方法有效。此外，将窗口设置为“始终位于顶部”仅适用于受信任的应用程序。</p>
                           <p>但是，本机应用程序会遇到类似的问题，并且这种特殊性使得Java应用程序的行为类似于本机应用程序。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD427"></a><div class="props_rev_3"><a id="GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD" name="GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD"></a><h3 id="JSTGD-GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD" class="sect3">重量级或轻量级组分混合</h3>
               <div>
                  <p>重量级或轻型（HW / LW）组件混合功能出现问题。</p>
                  <div class="section">
                     <p>重量级或轻量级（HW / LW）组件混合功能解决了以下问题：</p>
                  </div>
                  <!-- class="section" -->
                  <ul>
                     <li class="stepexpand"><span><span class="bold">验证组件层次结构：</span></span><div>
                           <p>更改组件的任何与布局相关的属性，例如其大小，位置或字体，都会使该组件及其祖先无效。为了使硬件/硬件混合功能正常运行，必须在进行此类更改后验证组件层次结构。默认情况下，失效会停止在层次结构的最顶层容器上（例如， <code class="codeph">Frame</code>宾语）。因此，要恢复层次结构的有效性，应用程序应调用<code class="codeph">Frame.validate()</code>方法。例如：</p><pre class="pre codeblock"><code>component.setFont(myFont);
frame.validate();
</code></pre><div class="p"><code class="codeph">frame</code>指包含<code class="codeph">component</code> 。
                              <div class="infoboxnote" id="GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD__GUID-9290D8A0-4E91-459A-9963-F6B6873C4F44">
                                 <p class="notep1">注意：</p>Swing应用程序和Swing库通常使用以下模式：<pre class="pre codeblock"><code>component.setFont(myFont);
component.revalidate();
</code></pre><p>因为它验证的层级仅从组件的最近验证根开始，从而留下上部容器无效<span class="apiname">重新验证（）</span>调用是<span class="italic">不够</span>的。在这种情况下，硬件/硬件功能可能无法为硬件组件计算正确的形状，并且可能在屏幕上看到视觉伪像。
                                 </p>
                                 <p>要验证整个组件层次结构的有效性，用户可以使用组合键Control + Shift + F1，如<a href="awt.html#GUID-623C61BB-8E09-4918-A120-911CA5C92FC6" title="调试与AWT相关的问题的有用提示。">AWT的调试提示中</a>所述。标记为“无效”的组件可能表示某处缺少<span class="apiname">validate（）</span>调用。
                                 </p>
                              </div> 
                           </div>
                        </div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">验证根：</span></span><div>
                           <p>在Swing中引入了“ <span class="bold">验证组件层次结构”中</span>提到的“验证根”的概念，以加快验证组件层次结构的过程，因为这可能要花费大量时间。尽管此类优化使层次结构的上部无效，但这不会产生任何问题，因为验证根内部的组件布局不会影响外部组件层次结构（即验证根的同级兄弟）的布局。但是，当硬件和硬件组件在层次结构中混合在一起时，该语句不再成立。这就是为什么该功能要求整个组件层次结构有效的原因。
                           </p>
                           <p>调用<span class="apiname">frame.validate（）</span>可能效率低下，并且AWT支持另一种优化的方式来处理组件层次结构的失效/验证。通过系统属性启用此功能：</p><pre class="pre codeblock"><code>-Djava.awt.smartInvalidate=true
</code></pre><p>一旦指定了此属性， <span class="apiname">invalidate（）</span>方法到达已调用了<span class="apiname">invalidate（）</span>方法的组件的最近验证根时，它将停止层次结构的<span class="apiname">无效化</span> 。然后，为了恢复组件层次结构的有效性，应用程序应该简单地调用：</p><pre class="pre codeblock"><code>component.revalidate();
</code></pre><div class="p">
                              <div class="infoboxnote" id="GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD__GUID-70561A46-2690-4DAF-899A-1542B2CB2E58">
                                 <p class="notep1">注意：</p>在这种情况下，调用<span class="apiname">frame.validate（）</span>实际上是无操作的（不执行任何操作的语句），因为<code class="codeph">frame</code>仍然有效。由于某些应用程序直接依赖于高于层次结构的验证根（例如，框架）的组件调用<span class="apiname">validate（）</span> ，因此这种新的优化行为可能会导致不兼容问题，因此仅在指定系统属性时可用。
                              </div> 
                           </div>
                           <p>如果应用程序在以这种新的优化模式运行时遇到任何困难，则用户可以使用组合键Control + Shift + F1（如<a href="awt.html#GUID-623C61BB-8E09-4918-A120-911CA5C92FC6" title="调试与AWT相关的问题的有用提示。">AWT的调试提示中</a>所述）调查组件层次结构的哪些部分无效，从而可能导致问题。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">摇摆绘画优化：</span></span><div>
                           <p>默认情况下，Swing库假定组件层次结构中没有硬件组件，因此使用优化的绘图技术来提高Swing GUI的性能。如果组件层次结构包含硬件组件，则必须关闭优化。这与Swing有关<code class="codeph">JScrollPanes</code>首先。您可以使用<span class="apiname">JViewPort.setScrollMode（int）</span>方法来更改滚动模式。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">非透明LW组件：</span></span><div>
                           <p>默认情况下，HW / LW混合功能实现不支持非不透明LW组件。为了使非矩形LW组件与HW组件混合，应用程序必须使用<span class="apiname">com.sun.awt。AWTUtilities.setComponentMixingCutoutShape（）</span>非公共API。</p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-CE1BB907-78F8-48D4-9B02-A39BA2F7D3AD__GUID-D56B076E-4796-4FC7-BD1A-1CB726042DDA">
                                 <p class="notep1">注意：</p>非矩形LW组件仍应使用不透明（alpha = 1.0）或透明（alpha = 0.0）颜色进行绘制。不支持使用半透明颜色（0.0 <alpha <1.0）。
                              </div> 
                           </div>
                        </div>
                     </li>
                     <li class="stepexpand"><span><span class="bold">禁用默认的硬件/硬件混合功能：</span></span><div>
                           <p>过去，一些开发人员在必须将硬件和硬件组件混合在一起的情况下实施了自己的支持。自JDK 6和JDK 7起可用的内置功能实现可能会导致自定义解决方法出现问题。为了禁用内置功能，必须使用以下系统属性启动应用程序：</p><pre class="pre codeblock"><code>-Dsun.awt.disableMixing=true
</code></pre></div>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </article>
   

</body></html>