<html lang="en-us" dir="ltr" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter introduces diagnostic and other monitoring tools that can be used with the Java Development Kit (JDK). Then, it describes in detail the diagnostic tools in JDK 9 and troubleshooting tools specific to various operating systems. Finally, this chapter explains how to develop custom diagnostic tools using the application programing interfaces (APIs) provided by JDK.">
      <meta name="description" content="This chapter introduces diagnostic and other monitoring tools that can be used with the Java Development Kit (JDK). Then, it describes in detail the diagnostic tools in JDK 9 and troubleshooting tools specific to various operating systems. Finally, this chapter explains how to develop custom diagnostic tools using the application programing interfaces (APIs) provided by JDK.">
      <title>Diagnostic Tools</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Troubleshooting Guide">
      <meta property="og:description" content="This chapter introduces diagnostic and other monitoring tools that can be used with the Java Development Kit (JDK). Then, it describes in detail the diagnostic tools in JDK 9 and troubleshooting tools specific to various operating systems. Finally, this chapter explains how to develop custom diagnostic tools using the application programing interfaces (APIs) provided by JDK.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Troubleshooting Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="troubleshooting-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T10:41:43-07:00">
      <meta name="dcterms.title" content="Troubleshooting Guide">
      <meta name="dcterms.dateCopyrighted" content="1995, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94880-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="prepare-java-troubleshooting.html" title="Previous" type="text/html">
      <link rel="next" href="troubleshoot-memory-leaks.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TROUBLESHOOT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="prepare-java-troubleshooting.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="troubleshoot-memory-leaks.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">故障排除指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="general-java-troubleshooting.html" property="item" typeof="WebPage"><span property="name">常规Java故障排除</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">诊断工具</li>
            </ol>
            <a id="GUID-CBC97A20-7379-4762-BA17-FB1A560D02E4" name="GUID-CBC97A20-7379-4762-BA17-FB1A560D02E4"></a><a id="JSTGD115"></a><a id="JSTGD114"></a>
            
            <h2 id="JSTGD-GUID-CBC97A20-7379-4762-BA17-FB1A560D02E4" class="sect2"><span class="enumeration_chapter">2个</span>诊断工具</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本章介绍了可与Java Development Kit（JDK）一起使用的诊断和其他监视工具。然后，它详细描述了JDK 9中的诊断工具和特定于各种操作系统的故障排除工具。最后，本章说明如何使用JDK提供的应用程序编程接口（API）开发自定义诊断工具。</span></div>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E" title="本节中描述的大多数命令行实用程序都包含在JDK或本机操作系统工具和实用程序中。">诊断工具概述</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78" title="Java Flight Recorder记录有关Java运行时和在Java运行时中运行的Java应用程序的详细信息。">什么是Java飞行记录</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC" title="使用Java Mission Control（JMC）轻松管理飞行记录。在命令行上使用启动标志来生成性能分析记录，连续记录和使用诊断命令。您可以将Java Mission Control设置为在满足条件时自动开始或转储飞行记录。这是从JMX控制台完成的。要启动JMX控制台，请在JVM浏览器中找到您的应用程序，右键单击它，然后选择“启动JMX浏览器”。">如何制作飞行记录</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8" title="有关如何获取样本JFR来检查飞行记录的信息，以及Java Mission Control中的各种选项卡供您分析飞行记录。">检查飞行记录</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="jcmd实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Recording，故障排除和诊断JVM和Java应用程序很有用。">jcmd实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77" title="本机内存跟踪（NMT）是Java HotSpot VM的一项功能，可跟踪Java HotSpot VM的内部内存使用情况。">本机内存跟踪</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="JDK下载中包含的另一个有用的工具是JConsole监视工具。该工具与JMX兼容。该工具使用JVM中的内置JMX工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">J控制台</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="jdb实用程序作为示例命令行调试器包含在JDK中。jdb实用程序使用Java调试接口（JDI）来启动或连接到目标JVM。">jdb实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="jinfo命令行实用程序从正在运行的Java进程或故障转储中获取配置信息，并打印用于启动JVM的系统属性或命令行标志。">jinfo实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="jmap命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。">jmap实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-FC269C18-470F-441E-9564-7EEA182F8125" title="jps实用程序列出了目标系统上当前用户的每个已检测的Java HotSpot VM。">jps实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7" title="jrunscript实用程序是命令行脚本外壳。">jrunscript实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="jstat实用程序使用Java HotSpot VM中的内置工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">jstat实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="visualgc工具提供了垃圾收集（GC）系统的图形视图。">visualgc工具</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="在操作系统（例如Oracle Solaris或Linux或Windows）上的应用程序控制台上按Control键和反斜杠（\）键的结果。">控制+中断处理程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">本机操作系统工具</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" title="JDK具有广泛的API，可以开发自定义工具来观察，监视，分析，调试和诊断JRE中部署的应用程序中的问题。">自定义诊断工具</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="Java Serviceability Agent调试守护程序（jsadebugd）附加到Java进程或核心文件，并充当调试服务器。">jsadebugd守护程序</a></p>
                  </li>
                  <li>
                     <p><a href="diagnostic-tools.html#GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" title="jstatd守护程序是一个RMI服务器应用程序，它监视每个检测到的Java HotSpot的创建和终止，并提供一个接口，以允许远程监视工具连接到在本地主机上运行的JVM。">jstatd守护程序</a></p>
                  </li>
               </ul>
            </div><a id="JSTGD116"></a><div class="props_rev_3"><a id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E" name="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E"></a><h3 id="JSTGD-GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E" class="sect3">诊断工具概述</h3>
               <div>
                  <p>本节中描述的大多数命令行实用程序都包含在JDK或本机操作系统工具和实用程序中。</p>
                  <p>尽管JDK下载中包括了JDK命令行实用程序，但重要的是要考虑它们可用于诊断问题并监视与Java Runtime Environment（JRE）一起部署的应用程序。</p>
                  <p>通常，诊断工具和选项使用各种机制来获取它们报告的信息。这些机制特定于虚拟机（VM）的实现，操作系统和发行版。通常，只有一部分工具在特定时间适用于给定的问题。带有前缀的命令行选项<code class="codeph">-XX</code>特定于Java HotSpot VM。请参阅<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6" title="带有-XX前缀的命令行选项特定于Java HotSpot虚拟机。这些选项中的许多对于性能调整和诊断目的都很重要，因此在本附录中进行了描述。">Java HotSpot VM命令行选项</a> 。
                  </p>
                  <div class="infoboxnote" id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E__GUID-71023838-D959-4D82-B1F2-8AF31D528184">
                     <p class="notep1">注意：</p>
                     <p>的<code>-XX</code>选项不是Java API的一部分，并且从一个版本到下一个版本可能有所不同。
                     </p>
                  </div>
                  <p>工具和选项分为几类，具体取决于要进行故障排除的问题的类型。某些工具和选项可能属于多个类别。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">事后诊断</span>这些工具和选项可用于在应用程序崩溃后诊断问题。请参阅<a href="diagnostic-tools.html#GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3" title="可以对应用程序和Java HotSpot VM之间的问题进行事后诊断的工具和选项的列表。">事后诊断工具</a> 。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">挂起过程</span>这些工具可用于调查挂起或死锁的过程。请参阅“ <a href="diagnostic-tools.html#GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B" title="用于在挂起的过程中诊断应用程序和Java HotSpot VM之间的问题的工具和选项的列表。">挂起流程工具”</a> 。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">监视</span>这些工具可用于监视正在运行的应用程序。请参阅<a href="diagnostic-tools.html#GUID-90B85B8D-DCFA-4094-9A85-218D467222B0" title="监视正在运行的应用程序和检测问题的工具和选项的列表。">监视工具</a> 。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">其他</span>这些工具和选项可用于帮助诊断其他问题。请参阅<a href="diagnostic-tools.html#GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC" title="可帮助诊断问题的常规故障排除工具，选项，变量和属性的列表。">其他工具，选项，变量和属性</a> 。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E__GUID-4FF37A47-5AFF-41C6-9B3E-D7A45100A58D">
                     <p class="notep1">注意：</p>
                     <p>本节中描述的某些命令行实用程序是实验性的。的<code class="codeph">jstack</code> ， <code class="codeph">jinfo</code>和<code class="codeph">jmap</code>实用程序是实验性实用程序的示例。建议使用最新的诊断实用程序， <code class="codeph">jcmd</code>而不是以前的<code class="codeph">jstack</code> ， <code class="codeph">jinfo,</code>和<code class="codeph">jmap</code>实用程序。
                     </p>
                  </div>
               </div>
            </div><a id="JSTGD117"></a><div class="props_rev_3"><a id="GUID-58CC8913-4144-42C3-B5AA-61A73C0EC7FC" name="GUID-58CC8913-4144-42C3-B5AA-61A73C0EC7FC"></a><h3 id="JSTGD-GUID-58CC8913-4144-42C3-B5AA-61A73C0EC7FC" class="sect3">Java任务控制</h3>
               <div>
                  <p>Java Mission Control（JMC）是用于HotSpot JVM的JDK分析和诊断工具平台。</p>
                  <p>它是用于基本监视，管理和生产时性能分析以及高性能诊断的工具套件。Java Mission Control最大限度地减少了性能分析开销，而性能开销通常是性能分析工具遇到的问题。</p>
                  <p>Java Mission Control（JMC）包含Java管理控制台（JMX），Java Flight Recorder（JFR）以及可从该工具下载的其他几个插件。JMX是用于监视和管理Java应用程序的工具，而JFR是配置文件工具。Java Mission Control也可以作为Eclipse IDE的一组插件使用。</p>
                  <p>以下主题描述了如何使用Java Mission Control进行故障排除。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7" title="对可以使用Java Mission Control执行的活动进行故障诊断。">使用Java Mission Control进行故障排除</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD118"></a><div class="props_rev_3"><a id="GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7" name="GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7"></a><h4 id="JSTGD-GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7" class="sect4">使用Java Mission Control进行故障排除</h4>
                  <div>
                     <p>对可以使用Java Mission Control执行的活动进行故障诊断。</p>
                     <div class="section">
                        <p>Java Mission Control允许您执行以下故障排除活动：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>Java管理控制台（JMX）连接到正在运行的JVM，并实时收集和显示关键特征。</span></li>
                        <li class="stepexpand"><span>触发用户提供的JVM自定义操作和规则。</span></li>
                        <li class="stepexpand"><span>实验性插件，例如- <code class="codeph">WLS</code> ， <code class="codeph">DTrace</code> ， <code class="codeph">JOverflow</code>和JMC工具中的其他工具提供故障排除活动。</span><ul>
                              <li><code class="codeph">DTrace</code>插件是扩展的<code class="codeph">DScript</code>产生自我描述事件的语言。它提供类似于Java Flight Recorder的可视化。
                              </li>
                              <li><code class="codeph">JOverflow</code>是另一个用于分析堆废物（空/稀疏收集）的插件工具。建议使用JDK 8版本及更高版本，以最佳使用<code class="codeph">JOverflow</code>插入。
                              </li>
                           </ul>
                        </li>
                        <li class="stepexpand"><span>Java Mission Control中的Java Flight Recording（JFR）可用于分析事件。预先配置的选项卡使您可以轻松地深入了解各个共同感兴趣的领域，例如代码，内存和gc，线程和I / O。通过“常规事件”选项卡和“操作性事件”选项卡，可以进一步深入钻取具有某些属性的一组事件。“事件”选项卡通常具有复选框，仅显示操作集中的事件。</span><ul>
                              <li>JFR用作JMC客户端的插件时，将诊断信息显示在按逻辑分组的表，图表和拨号盘中。它使您能够选择关注问题所需的时间范围和详细程度。请参阅<a href="https://docs.oracle.com/javacomponents/jmc.htm" target="_blank">Java Flight Recorder</a> 。
                              </li>
                           </ul>
                        </li>
                        <li class="stepexpand"><span>Java Mission Control插件使用Java管理扩展（JMX）代理连接到JVM。JMX是用于管理和监视资源（例如应用程序，设备，服务和Java虚拟机）的标准API。</span><div>
                              <p>要了解有关JMC的更多信息，请参阅<a href="https://docs.oracle.com/javacomponents/jmc.htm" target="_blank">JMC文档</a> 。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSTGD119"></a><div class="props_rev_3"><a id="GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78" name="GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78"></a><h3 id="JSTGD-GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78" class="sect3">什么是Java飞行记录</h3>
               <div>
                  <p>Java Flight Recorder记录有关Java运行时和在Java运行时中运行的Java应用程序的详细信息。</p>
                  <p>记录过程几乎没有开销。数据记录为带有时间戳的数据点，称为事件。典型事件可以是等待锁的线程，垃圾回收，定期的CPU使用率数据等。</p>
                  <p>创建飞行记录时，您选择应保存的事件。这称为<span class="bold">记录模板</span> 。一些模板仅保存非常基本的事件，并且几乎不影响性能。其他模板可能会带来轻微的性能开销，并且可能还会触发GC，以收集其他信息。通常，很少会看到超过百分之几的开销。
                  </p>
                  <p>飞行记录可用于调试各种问题，从性能问题到内存泄漏或严重的锁争用。</p>
                  <p>下列主题描述了产生Java飞行记录的记录类型。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E" title="飞行记录的两种类型是连续记录和概要记录。">录音类型</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD120"></a><div class="props_rev_3"><a id="GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E" name="GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E"></a><h4 id="JSTGD-GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E" class="sect4">录音类型</h4>
                  <div>
                     <p>飞行记录的两种类型是连续记录和概要记录。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">连续记录：</span>连续记录是始终打开并保存例如最近6个小时数据的记录。如果您的应用程序遇到任何问题，则可以转储例如最后一个小时的数据，并查看发生问题时发生的情况。
                           </p>
                           <p>连续录制的默认设置是使用开销较小的录制配置文件。该配置文件不会获得堆统计信息或分配配置文件，但仍会收集很多有用的数据。</p>
                           <p>连续记录非常适合始终运行，并且在调试很少发生的问题时非常有用。可以使用jcmd或JMC手动转储记录。您还可以在JMC中设置触发器，以在满足特定条件时转储飞行记录。</p>
                        </li>
                        <li>
                           <p><span class="bold">配置文件记录：</span>配置文件记录是已打开，在指定时间段内运行然后停止的记录。通常，性能分析记录会启用更多事件，并且可能会对性能产生较大影响。可以根据对概要记录的使用来修改打开的事件。
                           </p>
                           <p>概要分析记录的典型用例如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>剖析最常运行的方法以及创建最多对象的位置。</p>
                              </li>
                              <li>
                                 <p>查找使用越来越多堆的类，这表明内存泄漏。</p>
                              </li>
                              <li>
                                 <p>寻找由于同步和更多此类用例引起的瓶颈。</p>
                              </li>
                           </ul>
                           <p>即使您不对特定问题进行故障排除，性能分析记录也会提供很多信息。概要分析记录可以使您对应用程序有个很好的了解，并可以帮助您发现任何需要改进的瓶颈或领域。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E__GUID-8DAFAD5B-8B0A-4A19-87C2-9E4B2D2DCF2D">
                        <p class="notep1">注意：</p>
                        <p>通常的开销大约为2％，因此，除非您对性能或延迟非常敏感，否则您可以在生产环境（这是JFR的主要用例之一）上运行性能分析记录。</p>
                     </div>
                  </div>
               </div>
            </div><a id="JSTGD121"></a><div class="props_rev_3"><a id="GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC" name="GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC"></a><h3 id="JSTGD-GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC" class="sect3">如何制作飞行记录</h3>
               <div>
                  <p>以下各节描述了制作飞行记录的三种方法。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2" title="使用Java Mission Control（JMC）轻松管理飞行记录。">使用Java Mission Control生成飞行记录</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-551AED1E-3316-4150-AE20-C6D4F41127B7" title="在命令行上使用启动标志来生成性能分析记录，连续记录和使用诊断命令。">在命令行中使用启动标志来生成飞行记录</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493" title="您可以将Java Mission Control设置为在满足条件时自动开始或转储飞行记录。这是从JMX控制台完成的。要启动JMX控制台，请在JVM浏览器中找到您的应用程序，右键单击它，然后选择“启动JMX浏览器”。">使用触发器进行自动记录</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD123"></a><a id="JSTGD124"></a><a id="JSTGD125"></a><a id="JSTGD126"></a><a id="JSTGD127"></a><a id="JSTGD122"></a><div class="props_rev_3"><a id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2" name="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2"></a><h4 id="JSTGD-GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2" class="sect4">使用Java Mission Control生成飞行记录</h4>
                  <div>
                     <p>使用Java Mission Control（JMC）轻松管理飞行记录。</p>
                     <div class="p"><span class="bold">先决条件：</span><p>首先，在最左侧的JVM浏览器中找到您的服务器， <a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABFEGBD">如图2-1</a>所示。
                        </p>
                        <div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABFEGBD">
                           <p class="titleinfigure">图2-1 Java Mission Control-查找服务器</p><img src="img/jmc-event.png" alt="如下图2-1所示" title="如下图2-1所示" longdesc="img_text/jmc-event.html"><br><a href="img_text/jmc-event.html">“图2-1 Java Mission Control-查找服务器”的描述</a></div>
                        <!-- class="figure" -->
                        <p>默认情况下，将列出所有本地运行的JVM。必须将远程JVM（以与运行JMC的用户相同的有效用户身份运行）设置为使用远程JMX代理。然后，单击“ <span class="bold">新建JVM连接”</span>按钮，然后输入网络详细信息。
                        </p>
                        <p>可以在运行时启用Java Flight Recorder。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是使用Java Mission Control生成飞行记录的三种方法：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span><span class="bold">检查正在运行的记录：</span>将JVM浏览器中的节点扩展到正在运行的记录。<a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJJIJC">图2-2</a>显示了连续运行的记录（带有无穷大符号）和定时的分析记录。</span><div>
                              <div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJJIJC">
                                 <p class="titleinfigure">图2-2 Java Mission Control-运行记录</p><img src="img/jmc-expand-node.png" alt="如下图2-2所示" title="如下图2-2所示" longdesc="img_text/jmc-expand-node.html"><br><a href="img_text/jmc-expand-node.html">“图2-2 Java任务控制-运行记录”的描述</a></div>
                              <!-- class="figure" -->
                              <p>右键单击任何记录以转储，编辑或停止记录。停止概要分析记录仍会产生一个记录文件，而关闭概要记录将丢弃该记录。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">转储连续记录：</span>在JVM浏览器中右键单击连续记录，然后选择将其转储到文件中。在出现的对话框中，选择转储所有可用数据或仅转储记录的最后一部分， <a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABEHFAC">如图2-3</a>所示。</span><div>
                              <div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABEHFAC">
                                 <p class="titleinfigure">图2-3 Java任务控制-转储连续记录</p><img src="img/jmc-continue-record.png" alt="如下图2-3所示" title="如下图2-3所示" longdesc="img_text/jmc-continue-record.html"><br><a href="img_text/jmc-continue-record.html">“图2-3 Java任务控制-转储连续记录”的描述</a></div>
                              <!-- class="figure" -->
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">开始新的录制：</span>要开始新的录制，请右键单击要录制的JVM，然后选择<span class="bold">Start Flight Recording</span> 。然后，显示一个窗口， <a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">如图2-4</a>所示。</span><div>
                              <div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">
                                 <p class="titleinfigure">图2-4 Java任务控制-开始飞行记录</p><img src="img/jmc-start-record.png" alt="如下图2-4所示" title="如下图2-4所示" longdesc="img_text/jmc-start-record.html"><br><a href="img_text/jmc-start-record.html">“图2-4 Java任务控制-开始飞行记录”的描述</a></div>
                              <!-- class="figure" -->
                              <p>选择<span class="bold">时间固定录制</span> （性能分析录制）或<span class="bold">连续录制</span> ， <a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">如图2-4</a>所示。对于连续录制，您还可以指定要保存的事件的最大大小或期限。
                              </p>
                              <p>您也可以选择<span class="bold">事件设置</span> 。有一个选项可以创建自己的模板，但是对于所有用例的99％，您想要选择“连续”模板（用于非常低的开销记录）或“概要文件”模板（用于更多的数据和稍微更多的开销）。<span class="italic">注意：</span>概要记录的典型开销约为2％。
                              </p>
                              <p>完成后，单击“ <span class="bold">下一步”</span> 。下一个屏幕（ <a href="diagnostic-tools.html#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABBFHEC">如图2-5</a>所示）使您有机会针对不同的用例修改模板。
                              </p>
                              <div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABBFHEC">
                                 <p class="titleinfigure">图2-5 Java Mission Control-用于分析的事件选项</p><img src="img/jmc-event-profile.png" alt="如下图2-5所示" title="如下图2-5所示" longdesc="img_text/jmc-event-profile.html"><br><a href="img_text/jmc-event-profile.html">“图2-5 Java Mission Control-用于分析的事件选项”的描述</a></div>
                              <!-- class="figure" -->
                              <p>默认设置可以在数据和性能之间取得良好的平衡。在某些情况下，您可能需要添加其他事件。例如，如果您正在调查内存泄漏或想要查看占用最多Java堆的对象，请启用<span class="bold">Heap Statistics</span> 。这将在录制的开始和结束时触发两个“旧收藏”，因此会带来一些额外的延迟。您还可以选择显示所有引发的异常，甚至包括已捕获的异常。对于某些应用程序，这将生成很多事件。
                              </p>
                              <p><span class="bold">阈</span>值是事件记录的长度。例如，默认情况下，将收集10毫秒以上的同步事件。这意味着，如果线程等待锁定的时间超过10毫秒，则将保存一个事件。您可以降低此值以获得更详细的数据以用于短期争用。
                              </p>
                              <p><span class="bold">线程转储</span>设置为您提供了进行定期线程转储的选项。这些将是正常的文本线程转储，就像使用诊断命令将获得的那样<code class="codeph">Thread.print</code> ，或使用<code class="codeph">jstack</code>工具。线程转储对事件进行补充。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSTGD128"></a><div class="props_rev_3"><a id="GUID-551AED1E-3316-4150-AE20-C6D4F41127B7" name="GUID-551AED1E-3316-4150-AE20-C6D4F41127B7"></a><h4 id="JSTGD-GUID-551AED1E-3316-4150-AE20-C6D4F41127B7" class="sect4">在命令行中使用启动标志来生成飞行记录</h4>
                  <div>
                     <p>在命令行上使用启动标志来生成性能分析记录，连续记录和使用诊断命令。</p>
                     <div class="section">
                        <p>有关JFR标志的完整说明，请参见《 <span><cite>Java平台标准版工具参考》</cite></span>中的“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/troubleshoot&id=JSWOR624" target="_blank">高级运行时选项”</a> 。
                        </p>
                        <p>以下是在命令行中启动标志以生成飞行记录的三种方式。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span><span class="bold">开始分析记录：</span>您可以使用以下命令在应用程序启动时配置时间固定记录<code>-XX:StartFlightRecording</code>选项。以下示例说明了如何运行<code class="codeph">MyApp</code>应用程序并在启动JVM 20秒后开始60秒的记录，该记录将保存到名为<code class="codeph">myrecording.jfr</code> ：</span><div>
                              <p><code class="codeph">java -XX:StartFlightRecording=delay=20s,duration=60s,name=myrecording,filename=C:\TEMP\myrecording.jfr,settings=profile MyApp</code></p>
                              <p>settings参数采用模板的路径或名称。默认模板位于<code class="codeph">jre/lib/jfr</code>夹。这两个标准配置文件是： <span class="italic"><span class="bold">默认值</span></span> -一种低开销的设置，主要用于连续记录和<span class="italic"><span class="bold">配置文件</span></span> -收集更多的数据，主要用于分析记录。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">开始连续录制：</span>您也可以使用以下命令从命令行开始连续录制<code>-XX:FlightRecorderOptions</code> 。这些标志将开始连续记录，以后可以根据需要将其转储。以下示例说明了连续记录。临时数据将保存到磁盘， <code class="codeph">/tmp</code>文件夹，将存储6个小时的数据。</span><div>
                              <p><code class="codeph">java -XX:FlightRecorderOptions=defaultrecording=true,disk=true,repository=/tmp,maxage=6h,settings=default MyApp</code></p>
                              <div class="p">
                                 <div class="infoboxnote" id="GUID-551AED1E-3316-4150-AE20-C6D4F41127B7__GUID-4F7A4937-FD41-4005-A794-E24AEB24EB57">
                                    <p class="notep1">注意：</p>当您实际转储记录时，可以为转储的文件指定一个新位置，因此存储库中的文件只是临时的。
                                 </div> 
                              </div>
                              <p>要了解有关配置和管理Java Flight Recordings的更多信息，请参阅《 <a class="new-window" href="http://www.oracle.com/pls/topic/lookup?ctx=javacomponents&id=JFRRT164">Java Flight Recorder运行时指南》</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">使用诊断命令：</span></span><div>
                              <p>您还可以使用Java命令行诊断命令来控制记录。执行诊断命令的最简单方法是使用<code class="codeph">jcmd</code> Java安装目录中的工具。有关更多详细信息，请参见<a href="diagnostic-tools.html#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="jcmd实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Recording，故障排除和诊断JVM和Java应用程序很有用。">jcmd实用程序</a> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSTGD130"></a><a id="JSTGD131"></a><a id="JSTGD129"></a><div class="props_rev_3"><a id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493" name="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493"></a><h4 id="JSTGD-GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493" class="sect4">使用触发器进行自动记录</h4>
                  <div>
                     <p>您可以将Java Mission Control设置为在满足条件时自动开始或转储飞行记录。这是从JMX控制台完成的。要启动JMX控制台，请在JVM浏览器中找到您的应用程序，右键单击它，然后选择<span class="bold">Start JMX Browser</span> 。
                     </p>
                     <div class="section">
                        <p>选择屏幕底部的<span class="bold">Triggers</span>选项卡， <a href="diagnostic-tools.html#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABCJFCD">如图2-6</a>所示。
                        </p>
                        <div class="figure" id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABCJFCD">
                           <p class="titleinfigure">图2-6 Java Mission Control-自动记录</p><img src="img/jmc-autorecording.png" alt="如下图2-6所示" title="如下图2-6所示" longdesc="img_text/jmc-autorecording.html"><br><a href="img_text/jmc-autorecording.html">“图2-6 Java Mission Control-自动记录”的描述</a></div>
                        <!-- class="figure" -->
                        <p>您可以选择在任何一个上创建触发器<code class="codeph">MBean</code>在应用程序中。对于常见情况（例如高CPU使用率，死锁线程或活动集太大），有几种默认触发器设置。选择<span class="bold">添加</span>以选择任何<code class="codeph">MBean</code>在应用程序中，包括您自己的特定于应用程序的应用程序。选择触发器时，还可以选择必须满足的条件。有关更多信息，请单击右上角的问号以查看内置帮助。
                        </p>
                        <p>单击触发器旁边的框，以运行多个触发器。</p>
                        <p>选择条件后，单击“ <span class="italic"><span class="bold">操作”</span></span>选项卡。然后，选择满足条件时的操作。最后，选择转储连续记录或开始限时飞行记录， <a href="diagnostic-tools.html#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABEIDAH">如图2-7</a>所示。
                        </p>
                        <div class="figure" id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABEIDAH">
                           <p class="titleinfigure">图2-7 Java Mission Control-使用触发器</p><br><div class="imagecenter"><img class="imagecenter" src="img/jmc-triggers.png" alt="如下图2-7所示" title="如下图2-7所示" longdesc="img_text/jmc-triggers.html"><br><a href="img_text/jmc-triggers.html">“图2-7 Java Mission Control-使用触发器”的描述</a></div><br></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD132"></a><div class="props_rev_3"><a id="GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8" name="GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8"></a><h3 id="JSTGD-GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8" class="sect3">检查飞行记录</h3>
               <div>
                  <p>有关如何获取样本JFR来检查飞行记录的信息，以及Java Mission Control中的各种选项卡供您分析飞行记录。</p>
                  <p>描述以下部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62" title="创建飞行记录，您可以在任务控制中打开它。">如何获取样本JFR进行检查</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9" title="使用范围导航器检查飞行记录。">范围导航器</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE" title="在“常规”选项卡中检查飞行记录。">常规选项卡</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6" title="在“内存”选项卡中检查飞行记录。">记忆标签</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE" title="在“代码”选项卡中检查飞行记录。">代码标签</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870" title="在“线程”选项卡中检查飞行记录。">线程选项卡</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C" title="“ I / O”选项卡显示有关文件读取，文件写入，套接字读取和套接字写入的信息。">I / O标签</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-D1453594-A80C-4304-981C-BFD7CE572808" title="系统选项卡提供有关运行应用程序的计算机的CPU，内存和操作系统的详细信息。">系统标签</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910" title="“事件”选项卡显示记录中的所有事件。">活动标签</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD133"></a><div class="props_rev_3"><a id="GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62" name="GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62"></a><h4 id="JSTGD-GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62" class="sect4">如何获取样本JFR进行检查</h4>
                  <div>
                     <p>创建飞行记录，您可以在任务控制中打开它。</p>
                     <div class="section">
                        <p>创建飞行记录后，可以在任务控制中将其打开。查看飞行记录的一种简单方法是：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>打开任务控制，然后选择“ <span class="bold">JVM浏览器”</span>选项卡。</span></li>
                        <li class="stepexpand"><span>选择<span class="bold">JVM Running Mission Control</span>选项以创建简短记录。</span><div>
                              <p>打开飞行记录，以查看几个主要选项卡，例如“ <span class="bold">常规”，“内存”，“代码”，“线程”，“ I / O”，“系统”和“事件”</span> 。如果安装了任何插件，您还可以具有其他主选项卡。这些主选项卡中的每个都有子选项卡。单击问号以查看主选项卡和子选项卡的内置帮助部分。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD135"></a><a id="JSTGD134"></a><div class="props_rev_3"><a id="GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9" name="GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9"></a><h4 id="JSTGD-GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9" class="sect4">范围导航器</h4>
                  <div>
                     <p>使用范围导航器检查飞行记录。</p>
                     <p>每个选项卡在顶视图中都有一个范围导航器。</p>
                     <div class="figure" id="GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9__BABDAJJH">
                        <p class="titleinfigure">图2-8检查飞行记录-范围导航器</p><br><div class="imagecenter"><img class="imagecenter" src="img/jfr-range-navigator.png" alt="如下图2-8所示" title="如下图2-8所示" longdesc="img_text/jfr-range-navigator.html"><br><a href="img_text/jfr-range-navigator.html">“图2-8检查飞行记录-范围导航器”的描述</a></div><br></div>
                     <!-- class="figure" -->
                     <p><a href="diagnostic-tools.html#GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9__BABDAJJH">图2-8中</a>的竖线表示记录中的事件。条形越高，当时发生的事件越多。您可以拖动选定时间的边缘以放大或缩小录制内容。双击范围导航器以缩小并查看整个记录。单击所有子选项卡的“ <span class="bold">同步选择”</span>复选框以使用相同的缩放级别。
                     </p>
                     <p>有关更多信息，请参见内置帮助中的“ <span class="bold">使用范围导航器”</span> 。这些事件按选项卡名称命名。
                     </p>
                  </div>
               </div><a id="JSTGD137"></a><a id="JSTGD136"></a><div class="props_rev_3"><a id="GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE" name="GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE"></a><h4 id="JSTGD-GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE" class="sect4">常规选项卡</h4>
                  <div>
                     <p>在“常规”选项卡中检查飞行记录。</p>
                     <p><span class="bold">常规选项卡</span>包含一些描述常规应用程序的子选项卡。第一个子选项卡是<span class="bold">Overview</span> ，它显示一些基本信息，例如最大堆使用率，CPU总使用率和GC暂停时间， <a href="diagnostic-tools.html#GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE__BABHDDEG">如图2-9</a>所示。
                     </p>
                     <div class="figure" id="GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE__BABHDDEG">
                        <p class="titleinfigure">图2-9检查飞行记录-常规选项卡</p><img src="img/jfr-general-tab.png" alt="如下图2-9所示" title="如下图2-9所示" longdesc="img_text/jfr-general-tab.html"><br><a href="img_text/jfr-general-tab.html">“图2-9检查飞行记录-常规选项卡”的描述</a></div>
                     <!-- class="figure" -->
                     <p>另外，查看一段时间内的<span class="bold">CPU使用率</span>以及应用程序使用率和计算机总数。当应用程序中立即出现问题时，可以使用此选项卡进行查看。例如，请注意CPU使用率激增接近100％，或者CPU使用率太低或垃圾回收暂停时间太长。
                     </p>
                     <p><span class="italic">注意：</span>从“ <span class="bold">堆统计信息”</span>开始的概要分析记录会在记录的开始和结尾获得两个旧集合，它们可能比其余记录更长。</p>
                     <p>另一个子选项卡<span class="bold">-JVM信息</span>显示JVM信息。启动参数子选项卡- <span class="bold">系统属性</span>显示所有设置的系统属性，“ <span class="bold">记录”</span>显示有关特定记录的信息，例如打开的事件。单击问号以获取有关所有选项卡和子选项卡的内置详细信息。
                     </p>
                  </div>
               </div><a id="JSTGD139"></a><a id="JSTGD140"></a><a id="JSTGD141"></a><a id="JSTGD138"></a><div class="props_rev_3"><a id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6" name="GUID-01E1A944-1918-4B46-927A-FB194E680BA6"></a><h4 id="JSTGD-GUID-01E1A944-1918-4B46-927A-FB194E680BA6" class="sect4">记忆标签</h4>
                  <div>
                     <p>在“ <span class="bold">内存”</span>选项卡中检查飞行记录。
                     </p>
                     <p><span class="bold">内存</span>选项卡包含有关垃圾收集，分配模式和对象统计信息的信息。此选项卡特别有助于调试内存泄漏以及调整GC。</p>
                     <p>“ <span class="bold">概述”</span>选项卡显示有关内存使用的一些常规信息以及有关垃圾回收的一些统计信息。<span class="italic">注意：</span> “ <span class="bold">概述”</span>选项卡中的图形比例上升到计算机中的可用物理内存；因此，在某些情况下，Java堆可能只占底部的一小部分。
                     </p>
                     <p>“内存”选项卡描述了以下三个子选项卡。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">垃圾收集选项卡：</span> <span class="bold">垃圾收集</span>选项卡显示一段时间内的内存使用情况以及有关所有垃圾收集的信息。
                           </p>
                           <div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABECCBH">
                              <p class="titleinfigure">图2-10检查飞行记录-垃圾收集</p><img src="img/jfr-memory-tab.png" alt="如下图2-10所示" title="如下图2-10所示" longdesc="img_text/jfr-memory-tab.html"><br><a href="img_text/jfr-memory-tab.html">“图2-10检查飞行记录-垃圾收集”的描述</a></div>
                           <!-- class="figure" -->
                           <p><a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABECCBH">如图2-10</a>所示，堆使用情况的尖峰模式是完全正常的。在大多数应用程序中，始终会分配临时对象。满足条件后，将触发垃圾收集（GC），并删除所有不再使用的对象。因此，堆使用率稳定增加，直到触发GC，然后堆使用率突然下降。
                           </p>
                           <p>Java中的大多数GC都有一些较小的垃圾回收。旧的GC将遍历整个Java堆，而另一个GC可能会查看堆的一部分。旧集合之后的堆使用情况是应用程序正在使用的内存，称为活动集。</p>
                           <p>启用“ <span class="bold">堆统计”后</span>生成的飞行记录将以旧的GC开始和结束。在GC列表中选择那个旧的GC，然后选择“ <span class="bold">常规”</span>选项卡以查看“ <span class="bold">GC原因</span> - <span class="bold">堆检查启动的GC”</span> 。这些GC通常比其他GC花费更长的时间。
                           </p>
                           <p>为了更好地解决内存泄漏问题，请查看第一个和最后一个旧GC中的“ <span class="bold">Heap After GC”</span>值。当该值随着时间增加时，可能会发生内存泄漏。
                           </p>
                           <p>“ <span class="bold">GC时间”</span>选项卡包含有关执行GC的时间以及由于GC导致应用程序完全暂停的时间的信息。“ <span class="bold">GC配置”</span>选项卡包含GC配置信息。有关这些选项卡的更多详细信息，请单击右上角的问号以查看内置帮助。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">分配选项卡：</span> <a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">图2-11</a>显示了所有已分配内存的选择。Java中的小对象在<span class="bold">TLAB</span> （线程本地缓冲区）中分配。TLAB是一个小的内存区域，在其中分配了新对象。TLAB装满后，线程将获得一个新线程。记录所有内存分配会产生开销。因此，将记录所有触发新TLAB的分配。较大的对象分配在<span class="bold">TLAB</span>之外，并且也会记录这些对象。
                           </p>
                           <div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">
                              <p class="titleinfigure">图2-11检查飞行记录-分配选项卡</p><img src="img/jfr-allocations-tab.png" alt="如下图2-11所示" title="如下图2-11所示" longdesc="img_text/jfr-allocations-tab.html"><br><a href="img_text/jfr-allocations-tab.html">“图2-11检查飞行记录-分配选项卡”的描述</a></div>
                           <!-- class="figure" -->
                           <p>要估算每个类的内存分配，请<span class="bold">在新的“ TLAB”</span>选项卡中选择“ <span class="bold">分配”</span> ，然后选择“ <span class="bold">分配”</span>选项卡。这些分配是碰巧触发新TLAB的对象分配。的<code class="codeph">char</code>阵列会触发最新的TLAB。分配多少内存<code class="codeph">char</code>数组未知。TLAB的大小可以很好地估计由<code class="codeph">char</code>数组。
                           </p>
                           <p><a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">图2-11</a>是一个示例<code class="codeph">char</code>分配最多内存的数组。单击一个类以查看这些分配的<span class="bold">堆栈跟踪</span> 。示例记录显示，所有分配压力的44％来自<code class="codeph">char</code>阵列，其中27％来自<code class="codeph">Array.copyOfRange</code> ，从<code class="codeph">StringBuilder.toString</code> 。的<code class="codeph">StringBuilder.toString</code>通常被称为<code class="codeph">Throwable.printStackTrace</code>和<code class="codeph">StackTraceElement.toString</code> 。进一步展开以查看如何调用这些方法。
                           </p>
                           <p><span class="italic">注意</span> ：应用程序分配的临时对象越多，应用程序必须进行垃圾收集的越多。<span class="bold">分配</span>选项卡可帮助您找到最多的分配并减少应用程序中的GC压力。查看“ <span class="bold">TLAB”</span>选项卡<span class="bold">外部的“分配”</span>以查看大的内存分配，该内存分配通常比“ <span class="bold">新建TLAB”</span>选项卡中的分配具有更少的内存压力。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">“对象统计信息”选项卡：</span> “ <span class="bold">对象统计信息”</span>选项卡显示具有最活跃集合的类。阅读“ <a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6" title="Inspect the flight recordings in the Memory tab.">内存”选项卡中</a>的“ <span class="bold">垃圾回收”</span>子<a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6" title="在“内存”选项卡中检查飞行记录。">选项卡</a>以了解实时设置。<a href="diagnostic-tools.html#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABJFHJG">图2-12</a>显示了飞行记录的堆统计信息。为飞行记录启用<span class="bold">堆统计信息</span>以显示数据。底部的“ <span class="bold">顶部种植者”</span>选项卡显示在飞行记录期间每种对象类型的大小如何增加。特定对象类型的大小增加很多表示内存泄漏；但是，很小的差异是正常的。特别是，调查非标准Java类的主要增长者。
                           </p>
                           <div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABJFHJG">
                              <p class="titleinfigure">图2-12检查飞行记录-“对象统计信息”选项卡</p><img src="img/jfr-statistics-tab.png" alt="如下图2-12所示" title="如下图2-12所示" longdesc="img_text/jfr-statistics-tab.html"><br><a href="img_text/jfr-statistics-tab.html">“图2-12检查飞行记录-对象统计信息选项卡”的描述</a></div>
                           <!-- class="figure" -->
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD143"></a><a id="JSTGD142"></a><div class="props_rev_3"><a id="GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE" name="GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE"></a><h4 id="JSTGD-GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE" class="sect4">代码标签</h4>
                  <div>
                     <p>在“ <span class="bold">代码”</span>选项卡中检查飞行记录。
                     </p>
                     <p>“ <span class="bold">代码”</span>选项卡包含有关应用程序大部分时间花在哪里的信息。<span class="bold">Overview</span>子选项卡显示了花费最多执行时间的软件包和类。该数据来自采样。JFR抽取间隔运行的线程样本。仅对运行实际代码的线程进行采样；没有显示正在睡眠，等待锁或I / O的线程。
                     </p>
                     <p>要查看有关运行实际代码的应用程序时间的更多详细信息，请查看“ <span class="bold">热门方法”</span>子选项卡。
                     </p>
                     <div class="figure" id="GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE__BABFCFGD">
                        <p class="titleinfigure">图2-13检查飞行记录-“代码”选项卡</p><img src="img/jfr-code-tab.png" alt="如下图2-13所示" title="如下图2-13所示" longdesc="img_text/jfr-code-tab.html"><br><a href="img_text/jfr-code-tab.html">“图2-13检查飞行记录-代码选项卡”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="diagnostic-tools.html#GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE__BABFCFGD">图2-13</a>显示了采样最多的方法。展开示例以查看它们的调用位置。如果一个<code class="codeph">HashMap.getEntry</code>被称为很多，然后扩展此节点，直到找到调用最多的方法。这是用于查找应用程序瓶颈的最佳选项卡。
                     </p>
                     <p>“ <span class="bold">呼叫树”</span>子选项卡显示相同的事件，但从底部开始；例如，来自<code class="codeph">Thread.run</code> 。
                     </p>
                     <p>“ <span class="bold">例外”</span>子选项卡显示所有抛出的异常。默认情况下，仅记录<span class="italic">错误</span> ，但是在开始新的记录时将此设置更改为包括<span class="italic">所有异常</span> 。
                     </p>
                     <p>“ <span class="bold">编译”</span>子选项卡显示了随着应用程序运行随时间推移而<span class="bold">编译</span>的方法。
                     </p>
                     <p>“ <span class="bold">类加载”</span>子选项卡显示一段时间内已加载的类，实际已加载的类和已卸载的类的数量。该子选项卡仅在记录开始时启用“ <span class="italic">类加载”</span>事件时显示信息。
                     </p>
                     <p>有关这些选项卡的更多详细信息，请单击右上角的问号以查看内置帮助。</p>
                  </div>
               </div><a id="JSTGD145"></a><a id="JSTGD144"></a><div class="props_rev_3"><a id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870" name="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870"></a><h4 id="JSTGD-GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870" class="sect4">线程选项卡</h4>
                  <div>
                     <p>在“ <span class="bold">线程”</span>选项卡中检查飞行记录。
                     </p>
                     <p><span class="bold">线程</span>选项卡包含有关线程，锁争用和其他延迟的信息。
                     </p>
                     <p>“ <span class="bold">概述”</span>子选项卡显示CPU使用率以及一段时间内的线程数。
                     </p>
                     <p><span class="bold">Hot Threads</span>子选项卡显示执行大多数代码执行的线程。此信息基于与<span class="bold">“代码”</span>选项卡中“ <span class="bold">热方法”</span>子选项卡相同的采样数据。
                     </p>
                     <p>“ <span class="bold">争用”</span>选项卡可用于查找由于锁定争用而引起的瓶颈。
                     </p>
                     <div class="figure" id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__BABDAEAF">
                        <p class="titleinfigure">图2-14检查飞行记录-“争用”选项卡</p><img src="img/jfr-contention-tab.png" alt="如下图2-14所示" title="如下图2-14所示" longdesc="img_text/jfr-contention-tab.html"><br><a href="img_text/jfr-contention-tab.html">“图2-14检查飞行记录-争用选项卡”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="p"><a href="diagnostic-tools.html#GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__BABDAEAF">图2-14</a>显示了由于同步而等待最长时间的对象。选择一个<span class="bold">类</span>以查看每个对象的等待时间的<span class="bold">堆栈跟踪</span> 。这些暂停通常是由同步方法引起的，其中另一个线程持有该锁。
                        <div class="infoboxnote" id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__GUID-8B34039A-A892-47B5-B313-E280D6A8436F">
                           <p class="notep1">注意：</p>默认情况下，仅记录超过10毫秒的同步事件，但是您可以在开始记录时降低此阈值。
                        </div>
                     </div>
                     <p><span class="bold">延迟</span>子选项卡显示了其他<span class="bold">延迟</span>源。例如，调用睡眠或等待，从套接字读取或等待文件I / O。</p>
                     <p>“ <span class="bold">线程转储”</span>子选项卡显示可以在记录中触发的定期线程转储。
                     </p>
                     <p>“ <span class="bold">锁定实例”</span>子选项卡显示由于同步而等待最长时间的确切对象实例。
                     </p>
                     <p>有关这些选项卡的更多详细信息，请单击右上角的问号以查看内置帮助。</p>
                  </div>
               </div><a id="JSTGD146"></a><div class="props_rev_3"><a id="GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C" name="GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C"></a><h4 id="JSTGD-GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C" class="sect4">I / O标签</h4>
                  <div>
                     <p>“ <span class="bold">I / O”</span>选项卡显示有关文件读取，文件写入，套接字读取和套接字写入的信息。
                     </p>
                     <div class="p">根据应用程序的不同，该选项卡很有用。特别是当任何I / O操作需要很长时间时。
                        <div class="infoboxnote" id="GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C__GUID-675BC3A5-6ED8-4DCB-B88B-06C15B43B144">
                           <p class="notep1">注意：</p>默认情况下，仅显示超过10毫秒的事件。创建新记录时可以修改阈值。
                        </div> 
                     </div>
                  </div>
               </div><a id="JSTGD147"></a><div class="props_rev_3"><a id="GUID-D1453594-A80C-4304-981C-BFD7CE572808" name="GUID-D1453594-A80C-4304-981C-BFD7CE572808"></a><h4 id="JSTGD-GUID-D1453594-A80C-4304-981C-BFD7CE572808" class="sect4">系统标签</h4>
                  <div>
                     <p><span class="bold">系统</span>选项卡提供有关运行应用程序的计算机的CPU，内存和操作系统的详细信息。
                     </p>
                     <p>它还显示了环境变量和与JVM同时运行的任何其他进程。</p>
                  </div>
               </div><a id="JSTGD148"></a><div class="props_rev_3"><a id="GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910" name="GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910"></a><h4 id="JSTGD-GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910" class="sect4">活动标签</h4>
                  <div>
                     <p>“ <span class="bold">事件”</span>选项卡显示记录中的所有事件。
                     </p>
                     <p>这是一个高级选项卡，可以用多种不同方式使用。有关这些选项卡的更多详细信息，请单击右上角的问号以查看内置帮助。</p>
                  </div>
               </div>
            </div><a id="JSTGD149"></a><div class="props_rev_3"><a id="GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" name="GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254"></a><h3 id="JSTGD-GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" class="sect3">jcmd实用程序</h3>
               <div>
                  <p>的<code class="codeph">jcmd</code>该实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Recording，对Java和Java应用程序进行故障排除和诊断很有用。
                  </p>
                  <p><code class="codeph">jcmd</code>必须在运行JVM的同一台计算机上使用，并且必须具有用于启动JVM的相同有效用户和组标识符。</p>
                  <p>特殊命令<code class="codeph">jcmd <process id/main class> PerfCounter.print</code>打印该过程中的所有性能计数器。
                  </p>
                  <p>命令<code class="codeph">jcmd <process id/main class> <command> [options]</code>将命令发送到JVM。</p>
                  <p>以下示例显示了使用以下命令对JVM的诊断命令请求： <code class="codeph">jcmd</code>效用。
                  </p><pre class="pre codeblock"><code>&gt; jcmd
5485 sun.tools.jcmd.JCmd
2125 MyProgram
 
&gt; jcmd MyProgram help (or "jcmd 2125 help")
2125:
The following commands are available:
JFR.configure
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.log
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.status
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
Compiler.directives_clear
Compiler.directives_remove
Compiler.directives_add
Compiler.directives_print
VM.print_touched_methods
Compiler.codecache
Compiler.codelist
Compiler.queue
VM.classloader_stats
Thread.print
JVMTI.data_dump
JVMTI.agent_load
VM.stringtable
VM.symboltable
VM.class_hierarchy
VM.systemdictionary
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.finalizer_info
GC.heap_info
GC.run_finalization
GC.run
VM.info
VM.uptime
VM.dynlibs
VM.set_flag
VM.flags
VM.system_properties
VM.command_line
VM.version
help

For more information about a specific command use 'help &lt;command&gt;'. 

&gt; jcmd MyProgram help Thread.print
2125:
Thread.print
Print all threads with stacktraces.
 
Impact: Medium: Depends on the number of threads.
 
Permission: java.lang.management.ManagementPermission(monitor)
 
Syntax : Thread.print [options]
 
Options: (options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax)
        -l : [optional] print java.util.concurrent locks (BOOLEAN, false)
 
&gt; jcmd MyProgram Thread.print
2125:
2018-07-06 12:43:46
Full thread dump Java HotSpot(TM) 64-Bit Server VM (10.0.1+10 mixed mode):
...</code></pre><p>以下各节介绍了一些有用的命令和故障排除方法， <code class="codeph">jcmd</code>效用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-B7480F58-82B5-4F29-94E6-1DA669947265" title="在不同版本的HotSpot VM中，可用的诊断命令可能有所不同。因此，使用jcmd <进程ID /主类>帮助是查看所有可用选项的最佳方法。">jcmd实用程序的有用命令</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91" title="使用jcmd实用程序进行故障排除。">使用jcmd实用程序进行故障排除</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD151"></a><div class="props_rev_3"><a id="GUID-B7480F58-82B5-4F29-94E6-1DA669947265" name="GUID-B7480F58-82B5-4F29-94E6-1DA669947265"></a><h4 id="JSTGD-GUID-B7480F58-82B5-4F29-94E6-1DA669947265" class="sect4">jcmd实用程序的有用命令</h4>
                  <div>
                     <p>在不同版本的HotSpot VM中，可用的诊断命令可能有所不同。因此，使用<code class="codeph">jcmd <process id/main class> help</code>是查看所有可用选项的最佳方法。
                     </p>
                     <div class="section">
                        <p>以下是其中一些最有用的命令<code class="codeph">jcmd</code>工具。请记住，您可以随时使用<code class="codeph">jcmd <process id/main class> help <command></code>获取这些命令的任何其他选项：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>打印完整的HotSpot和JDK版本ID。</span><div><code class="codeph">jcmd <process id/main class> VM.version</code></div>
                        </li>
                        <li class="stepexpand"><span>打印为虚拟机设置的所有系统属性。</span><div>
                              <p>可能会显示数百行信息。</p>
                              <p><code class="codeph">jcmd <process id/main class> VM.system_properties</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>打印用于虚拟机的所有标志。</span><div>
                              <p>即使没有提供标志，也会打印一些默认值，例如初始和最大堆大小。</p>
                              <p><code class="codeph">jcmd <process id/main class> VM.flags</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>以秒为单位打印正常运行时间。</span><div>
                              <p><code class="codeph">jcmd <process id/main class> VM.uptime</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个类直方图。</span><div>
                              <p>结果可能很冗长，因此您可以将输出重定向到文件。列表中包括内部类和特定于应用程序的类。占用最多内存的类在顶部列出，并且类以降序列出。</p>
                              <p><code class="codeph">jcmd <process id/main class> GC.class_histogram</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个堆转储。</span><div>
                              <p><code class="codeph">jcmd GC.heap_dump filename=Myheapdump</code></p>
                              <p>这与使用相同<code class="codeph">jmap -dump:file=<file> <pid></code> ，但是<code class="codeph">jcmd</code>是推荐使用的工具。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个堆直方图。</span><div>
                              <p><code class="codeph">jcmd <process id/main class> GC.class_histogram filename=Myheaphistogram</code></p>
                              <p>这与使用相同<code class="codeph">jmap -histo <pid></code> ，但是<code class="codeph">jcmd</code>是推荐使用的工具。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>打印所有带有堆栈跟踪的线程。</span><div>
                              <p><code class="codeph">jcmd <process id/main class> Thread.print</code></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD152"></a><div class="props_rev_3"><a id="GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91" name="GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91"></a><h4 id="JSTGD-GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91" class="sect4">使用jcmd实用程序进行故障排除</h4>
                  <div>
                     <p>使用<code class="codeph">jcmd</code>实用程序进行故障排除。
                     </p>
                     <div class="section">
                        <p>的<code class="codeph">jcmd</code>实用程序提供以下故障排除选项：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>开始录音。</span><div>
                              <p>例如，使用标识符在运行中的Java进程上开始2分钟的录制<code class="codeph">7060</code>并将其保存到当前目录的myrecording.jfr中，使用以下命令：</p>
                              <p><code class="codeph">jcmd 7060 JFR.start name=MyRecording settings=profile delay=20s duration=2m filename=C:\TEMP\myrecording.jfr</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>检查录音。</span><div>
                              <p>的<code class="codeph">JFR.check</code>诊断命令检查正在运行的录像。例如：</p>
                              <p><code class="codeph">jcmd 7060 JFR.check</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>停止录音。</span><div>
                              <p>的<code class="codeph">JFR.stop</code>诊断命令停止正在运行的记录，并可以选择放弃记录数据。例如：</p>
                              <p><code class="codeph">jcmd 7060 JFR.stop</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>转储录音。</span><div>
                              <p>的<code class="codeph">JFR.dump</code>诊断命令停止正在运行的录像，并可以选择将录像转储到文件中。例如：</p>
                              <p><code class="codeph">jcmd 7060 JFR.dump name=MyRecording filename=C:\TEMP\myrecording.jfr</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个堆转储。</span><div>
                              <p>创建堆转储的首选方法是</p>
                              <p><code class="codeph">jcmd <pid> GC.heap_dump filename=Myheapdump</code></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个堆直方图。</span><div>
                              <p>创建堆直方图的首选方法是</p>
                              <p><code class="codeph">jcmd <pid> GC.class_histogram filename=Myheaphistogram</code></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSTGD153"></a><div class="props_rev_3"><a id="GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77" name="GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77"></a><h3 id="JSTGD-GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77" class="sect3">本机内存跟踪</h3>
               <div>
                  <p>本机内存跟踪（NMT）是Java HotSpot VM的一项功能，可跟踪Java HotSpot VM的内部内存使用情况。</p>
                  <p>由于NMT不会通过非JVM代码跟踪内存分配，因此您可能必须使用操作系统支持的工具来检测本机代码中的内存泄漏。</p>
                  <p>以下各节介绍如何监视VM内部内存分配和诊断VM内存泄漏。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775" title="使用本机内存跟踪来检测内存泄漏的过程。">使用NMT检测内存泄漏</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081" title="可以设置本机内存跟踪以监视内存，并确保应用程序在开发或维护期间不会开始使用越来越多的内存。">如何监视虚拟机内存</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37" title="NMT使用的本机内存跟踪内存类别列表。">NMT内存类别</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD154"></a><div class="props_rev_3"><a id="GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775" name="GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775"></a><h4 id="JSTGD-GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775" class="sect4">使用NMT检测内存泄漏</h4>
                  <div>
                     <p>使用本机内存跟踪来检测内存泄漏的过程。</p>
                     <div class="section">
                        <p>请按照以下步骤检测内存泄漏：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>使用命令行选项以<span class="italic"><span class="bold">摘要</span></span>或<span class="italic"><span class="bold">详细信息</span></span>跟踪启动JVM： <code class="codeph">-XX:NativeMemoryTracking=summary</code>要么<code class="codeph">-XX:NativeMemoryTracking=detail</code> 。</span></li>
                        <li><span>建立早期基线。使用NMT基准功能，通过运行以下命令来获得基准，以便在开发和维护期间进行比较： <code class="codeph">jcmd <pid> VM.native_memory baseline</code> 。</span></li>
                        <li><span>使用以下方法监视内存更改： <code class="codeph">jcmd <pid> VM.native_memory detail.diff</code> 。</span></li>
                        <li><span>如果应用程序泄漏少量内存，则可能需要一段时间才能显示出来。</span></li>
                     </ol>
                  </div>
               </div><a id="JSTGD155"></a><div class="props_rev_3"><a id="GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081" name="GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081"></a><h4 id="JSTGD-GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081" class="sect4">如何监视虚拟机内存</h4>
                  <div>
                     <p>可以设置本机内存跟踪以监视内存，并确保应用程序在开发或维护期间不会开始使用越来越多的内存。</p>
                     <div class="section">
                        <p>有关NMT内存类别的详细信息，请<a href="diagnostic-tools.html#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC" title="下表描述了本机内存跟踪内存类别">参见表2-1</a> 。
                        </p>
                        <p>以下各节描述如何获取NMT的<span class="italic"><span class="bold">摘要</span></span>或<span class="italic"><span class="bold">明细</span></span>数据，并描述如何解释示例输出。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span><span class="bold">解释示例输出：</span>从以下示例输出中，您将看到<span class="italic"><span class="bold">保留</span></span>和<span class="italic"><span class="bold">提交的</span></span>内存。请注意，实际上仅使用了已<span class="italic"><span class="bold">提交的</span></span>内存。例如，如果您使用<code class="codeph">-Xms100m -Xmx1000m</code> ，那么JVM将为Java堆保留1000 MB。因为初始堆大小仅为100 MB，所以最初只承诺100 MB。对于地址空间几乎不受限制的64位计算机，如果JVM保留大量内存，就没有问题。如果提交了越来越多的内存，则会出现问题，这可能导致交换或本机内存不足（OOM）的情况。</span><div>
                              <p>竞技场是使用malloc分配的内存块。当退出作用域或离开代码区域时，将内存从这些块中释放出来。这些块可以在其他子系统中重用以保存临时内存，例如，线程前分配。竞技场malloc策略可确保没有内存泄漏。因此，竞技场是作为一个整体而不是单个对象进行跟踪的。无法追踪某些初始内存。</p>
                              <p>启用NMT将导致JVM性能下降<span class="italic"><span class="bold">5-10％</span></span> ，并且NMT的内存使用量将2个机器字作为malloc标头添加到所有malloc内存中。NMT还会跟踪NMT内存使用情况。</p><pre class="pre codeblock"><code>Total:  reserved=664192KB,  committed=253120KB                                           &lt;--- total memory tracked by Native Memory Tracking
 
-                 Java Heap (reserved=516096KB, committed=204800KB)                      &lt;--- Java Heap
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6568KB, committed=4140KB)                          &lt;--- class metadata
                            (classes #665)                                               &lt;--- number of loaded classes
                            (malloc=424KB, #1000)                                        &lt;--- malloc'd memory, #number of malloc
                            (mmap: reserved=6144KB, committed=3716KB)
 
-                    Thread (reserved=6868KB, committed=6868KB)
                            (thread #15)                                                 &lt;--- number of threads
                            (stack: reserved=6780KB, committed=6780KB)                   &lt;--- memory used by thread stacks
                            (malloc=27KB, #66)
                            (arena=61KB, #30)                                            &lt;--- resource and handle areas
 
-                      Code (reserved=102414KB, committed=6314KB)
                            (malloc=2574KB, #74316)
                            (mmap: reserved=99840KB, committed=3740KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #90)
                            (arena=99KB, #3)
 
-                  Internal (reserved=586KB, committed=554KB)
                            (malloc=554KB, #1677)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=906KB, committed=906KB)
                            (malloc=514KB, #2736)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=3184KB, committed=3184KB)
                            (malloc=3184KB, #300)
 
-        Pooled Free Chunks (reserved=1276KB, committed=1276KB)
                            (malloc=1276KB)
 
-                   Unknown (reserved=33KB, committed=33KB)
                            (arena=33KB, #1)</code></pre></div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">获取详细数据：</span>要更详细地了解本机内存使用情况，请使用命令行选项启动JVM： <code class="codeph">-XX:NativeMemoryTracking=detail</code> 。这将准确跟踪哪些方法分配了最多的内存。启用NMT将导致JVM性能下降<span class="italic"><span class="bold">5-10％，</span></span>并且NMT的内存使用量会向所有malloc内存中添加2个单词作为malloc标头。NMT还会跟踪NMT内存使用情况。</span><div>
                              <p>以下示例显示了将跟踪级别设置为<span class="italic"><span class="bold">detail的</span></span>虚拟内存的示例输出。获得此示例输出的一种方法是运行： <code class="codeph">jcmd <pid> VM.native_memory detail</code> 。
                              </p>
                              <p></p><pre class="pre codeblock"><code>Virtual memory map:
 
[0x8f1c1000 - 0x8f467000] reserved 2712KB for Thread Stack
		from [Thread::record_stack_base_and_size()+0xca]
	[0x8f1c1000 - 0x8f467000] committed 2712KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f585000 - 0x8f729000] reserved 1680KB for Thread Stack
		from [Thread::record_stack_base_and_size()+0xca]
	[0x8f585000 - 0x8f729000] committed 1680KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f930000 - 0x90100000] reserved 8000KB for GC
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
	[0x8f930000 - 0x90100000] committed 8000KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
 
[0x902dd000 - 0x9127d000] reserved 16000KB for GC
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
	[0x902dd000 - 0x9127d000] committed 16000KB from [os::pd_commit_memory(char*, unsigned int, unsigned int, bool)+0x36]
 
[0x9127d000 - 0x91400000] reserved 1548KB for Thread Stack
		from [Thread::record_stack_base_and_size()+0xca]
	[0x9127d000 - 0x91400000] committed 1548KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x91400000 - 0xb0c00000] reserved 516096KB for Java Heap                                                                            &lt;--- reserved memory range
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x190]                  &lt;--- callsite that reserves the memory
	[0x91400000 - 0x93400000] committed 32768KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]               &lt;--- committed memory range and its callsite
	[0xa6400000 - 0xb0c00000] committed 172032KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]                             &lt;--- committed memory range and its callsite
 
[0xb0c61000 - 0xb0ce2000] reserved 516KB for Thread Stack
		from [Thread::record_stack_base_and_size()+0xca]
	[0xb0c61000 - 0xb0ce2000] committed 516KB from [Thread::record_stack_base_and_size()+0xca]
 
[0xb0ce2000 - 0xb0e83000] reserved 1668KB for GC
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
	[0xb0ce2000 - 0xb0cf0000] committed 56KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
	[0xb0d88000 - 0xb0d96000] committed 56KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
	[0xb0e2e000 - 0xb0e83000] committed 340KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
 
[0xb0e83000 - 0xb7003000] reserved 99840KB for Code
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
	[0xb0e83000 - 0xb0e92000] committed 60KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]
	[0xb1003000 - 0xb139b000] committed 3680KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7003000 - 0xb7603000] reserved 6144KB for Class
		from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
	[0xb7003000 - 0xb73a4000] committed 3716KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7603000 - 0xb760b000] reserved 32KB for Internal
		from [PerfMemory::create_memory_region(unsigned int)+0x8ba]
 
[0xb770b000 - 0xb775c000] reserved 324KB for Thread Stack
		from [Thread::record_stack_base_and_size()+0xca]
	[0xb770b000 - 0xb775c000] committed 324KB from [Thread::record_stack_base_and_size()+0xca]</code></pre></div>
                        </li>
                        <li class="stepexpand"><span><span class="bold">从NMT基线获取差异：</span>对于<span class="italic">摘要</span>和<span class="italic">详细信息</span>级别的跟踪，您可以在应用程序启动并运行后设置基线。通过运行来做到这一点<code class="codeph">jcmd <pid> VM.native_memory baseline</code>应用程序预热后。然后，您可以运行<code class="codeph">jcmd <pid> VM.native_memory summary.diff</code>要么<code class="codeph">jcmd <pid> VM.native_memory detail.diff</code> 。</span><div>
                              <p>以下示例显示了自设置基准以来本机内存使用情况的<span class="italic"><span class="bold">摘要</span></span>差异的示例输出，这是查找内存泄漏的好方法。
                              </p><pre class="pre codeblock"><code>Total:  reserved=664624KB  -20610KB, committed=254344KB -20610KB                         &lt;--- total memory changes vs. earlier baseline. '+'=increase '-'=decrease
 
-                 Java Heap (reserved=516096KB, committed=204800KB)
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6578KB +3KB, committed=4530KB +3KB)
                            (classes #668 +3)                                            &lt;--- 3 more classes loaded
                            (malloc=434KB +3KB, #930 -7)                                 &lt;--- malloc'd memory increased by 3KB, but number of malloc count decreased by 7
                            (mmap: reserved=6144KB, committed=4096KB)
 
-                    Thread (reserved=60KB -1129KB, committed=60KB -1129KB)
                            (thread #16 +1)                                              &lt;--- one more thread
                            (stack: reserved=7104KB +324KB, committed=7104KB +324KB)
                            (malloc=29KB +2KB, #70 +4)
                            (arena=31KB -1131KB, #32 +2)                                 &lt;--- 2 more arenas (one more resource area and one more handle area)
 
-                      Code (reserved=102328KB +133KB, committed=6640KB +133KB)
                            (malloc=2488KB +133KB, #72694 +4287)
                            (mmap: reserved=99840KB, committed=4152KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #93)
                            (arena=99KB, #3)
 
-                  Internal (reserved=590KB +35KB, committed=558KB +35KB)
                            (malloc=558KB +35KB, #1699 +20)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=911KB +5KB, committed=911KB +5KB)
                            (malloc=519KB +5KB, #2921 +180)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=2073KB -887KB, committed=2073KB -887KB)
                            (malloc=2073KB -887KB, #84 -210)
 
-        Pooled Free Chunks (reserved=2624KB -15876KB, committed=2624KB -15876KB)
                            (malloc=2624KB -15876KB)</code></pre><p>以下示例是一个示例输出，显示了自基线以来本机内存使用情况的<span class="italic"><span class="bold">详细</span></span>差异，并且是查找内存泄漏的好方法。
                              </p><pre class="pre codeblock"><code>Details:
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=482KB -481KB, #8 -8)
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=2786KB -19742KB, #134 -618)
 
[0x013bd432] CodeBlob::set_oop_maps(OopMapSet*)+0xa2
                            (malloc=591KB +6KB, #681 +37)
 
[0x013c12b1] CodeBuffer::block_comment(int, char const*)+0x21                &lt;--- [callsite address] method name + offset
                            (malloc=562KB +33KB, #35940 +2125)               &lt;--- malloc'd amount, increased by 33KB #malloc count, increased by 2125
 
[0x0145f172] ConstantPool::ConstantPool(Array&lt;unsigned char&gt;*)+0x62
                            (malloc=69KB +2KB, #610 +15)
 
...
 
[0x01aa3ee2] Thread::allocate(unsigned int, bool, unsigned short)+0x122
                            (malloc=21KB +2KB, #13 +1)
 
[0x01aa73ca] Thread::record_stack_base_and_size()+0xca
                            (mmap: reserved=7104KB +324KB, committed=7104KB +324KB)</code></pre></div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSTGD173"></a><div class="props_rev_3"><a id="GUID-92074912-77E2-46B4-9A2F-A27F10331576" name="GUID-92074912-77E2-46B4-9A2F-A27F10331576"></a><h3 id="JSTGD-GUID-92074912-77E2-46B4-9A2F-A27F10331576" class="sect3">J控制台</h3>
               <div>
                  <p>JDK下载中包含的另一个有用的工具是<code class="codeph">JConsole</code>监控工具。该工具与JMX兼容。该工具使用JVM中的内置JMX工具来提供有关正在运行的应用程序的性能和资源消耗的信息。
                  </p>
                  <p>尽管该工具包含在JDK下载中，但它也可以用于监视和管理JRE部署的应用程序。</p>
                  <p>的<code class="codeph">JConsole</code>该工具可以附加到任何Java应用程序上，以显示有用的信息，例如线程使用情况，内存消耗以及有关类加载，运行时编译和操作系统的详细信息。
                  </p>
                  <p>此输出有助于对问题进行高级诊断，例如内存泄漏，过多的类加载和正在运行的线程。它对于调整和堆大小也很有用。</p>
                  <p>除了监控之外<code class="codeph">JConsole</code>可用于动态更改正在运行的系统中的多个参数。例如， <code class="codeph">-verbose:gc</code>可以更改option，以便可以为正在运行的应用程序动态启用或禁用垃圾收集跟踪输出。
                  </p>
                  <p>以下各节介绍了JConsole工具的故障排除技术。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-10CE3834-3A19-40E1-964D-A41740FC93E6" title="使用JConsole工具监视数据。">使用JConsole工具进行故障排除</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9" title="JConsole可以监视本地应用程序和远程应用程序。如果使用指定要连接的JMX代理的参数启动该工具，则该工具将自动开始监视指定的应用程序。">使用JConsole监视本地和远程应用程序</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD174"></a><div class="props_rev_3"><a id="GUID-10CE3834-3A19-40E1-964D-A41740FC93E6" name="GUID-10CE3834-3A19-40E1-964D-A41740FC93E6"></a><h4 id="JSTGD-GUID-10CE3834-3A19-40E1-964D-A41740FC93E6" class="sect4">使用JConsole工具进行故障排除</h4>
                  <div>
                     <p>使用<code class="codeph">JConsole</code>监视数据的工具。
                     </p>
                     <p>以下列表提供了可以使用<code class="codeph">JConsole</code>工具。每个标题对应于工具中的一个选项卡窗格。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">总览</span></p>
                           <p>此窗格显示图形，这些图形显示堆内存使用情况，线程数，类数以及一段时间内的CPU使用率。此概述使您可以一次可视化多个资源的活动。</p>
                        </li>
                        <li>
                           <p><span class="bold">记忆</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于选定的内存区域（堆，非堆，各种内存池）：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>该图显示了一段时间内的内存使用情况</p>
                                    </li>
                                    <li>
                                       <p>当前内存大小</p>
                                    </li>
                                    <li>
                                       <p>提交的内存量</p>
                                    </li>
                                    <li>
                                       <p>最大记忆体大小</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>垃圾收集器信息，包括执行的收集次数以及执行垃圾收集所花费的总时间</p>
                              </li>
                              <li>
                                 <p>该图显示了当前使用的堆和非堆内存的百分比</p>
                              </li>
                           </ul>
                           <p>此外，在此窗格上，您可以请求执行垃圾收集。</p>
                        </li>
                        <li>
                           <p><span class="bold">线程数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>该图显示了一段时间内的线程使用情况。</p>
                              </li>
                              <li>
                                 <p>活动线程：当前活动线程数。</p>
                              </li>
                              <li>
                                 <p>峰值：自JVM启动以来活动线程数最多。</p>
                              </li>
                              <li>
                                 <p>对于选定的线程，请提供名称，状态和堆栈跟踪，对于阻塞的线程，请参见该线程正在等待获取的同步器以及拥有该锁的线程。</p>
                              </li>
                              <li>
                                 <p>“ <span class="bold">死锁检测”</span>按钮向目标应用程序发送执行死锁检测的请求，并在单独的选项卡中显示每个死锁周期。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><span class="bold">班级</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>该图显示了随时间推移已加载的类的数量</p>
                              </li>
                              <li>
                                 <p>当前加载到内存中的类数</p>
                              </li>
                              <li>
                                 <p>自JVM启动以来已装入内存的类总数，包括随后卸载的类的总数</p>
                              </li>
                              <li>
                                 <p>自JVM启动以来从内存中卸载的类总数</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><span class="bold">虚拟机摘要</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>常规信息，例如JConsole连接数据，JVM的正常运行时间，JVM消耗的CPU时间，编译器名称，总编译时间，等等。</p>
                              </li>
                              <li>
                                 <p>线程和类摘要信息</p>
                              </li>
                              <li>
                                 <p>内存和垃圾回收信息，包括即将完成的对象数，等等</p>
                              </li>
                              <li>
                                 <p>有关操作系统的信息，包括物理特征，正在运行的进程的虚拟内存量以及交换空间</p>
                              </li>
                              <li>
                                 <p>有关JVM本身的信息，例如参数和类路径</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><span class="bold">豆类</span></p>
                           <p>该窗格显示一个树形结构，该结构显示在已连接的JMX代理中注册的所有平台和应用程序MBean。在树中选择MBean时，将显示其属性，操作，通知和其他信息。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您可以调用操作（如果有）。例如操作<code class="codeph">dumpHeap</code>为了<code class="codeph">HotSpotDiagnostic</code> MBean，位于<code class="codeph">com.sun.management</code>域，执行堆转储。此操作的输入参数是运行目标VM的计算机上堆转储文件的路径名。
                                 </p>
                              </li>
                              <li>
                                 <p>您可以设置可写属性的值。例如，您可以通过调用以下选项来设置，取消设置或更改某些VM标志的值： <code class="codeph">setVMOption</code>操作<code class="codeph">HotSpotDiagnostic</code> MBean。这些标志由的值列表表示<code class="codeph">DiagnosticOptions</code>属性。
                                 </p>
                              </li>
                              <li>
                                 <p>您可以使用“ <span class="bold">订阅”</span>和“ <span class="bold">取消订阅”</span>按钮<span class="bold">订阅</span>通知（如果有）。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD176"></a><a id="JSTGD175"></a><div class="props_rev_3"><a id="GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9" name="GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9"></a><h4 id="JSTGD-GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9" class="sect4">使用JConsole监视本地和远程应用程序</h4>
                  <div>
                     <p>JConsole可以监视本地应用程序和远程应用程序。如果使用指定要连接的JMX代理的参数启动该工具，则该工具将自动开始监视指定的应用程序。</p>
                     <div class="section">
                        <p>要监视本地应用程序，执行命令<code class="codeph">jconsole<span class="variable" translate="no">pid</span></code> ，在哪里<code class="codeph"><span class="variable" translate="no">pid</span></code>是应用程序的进程ID。
                        </p>
                        <p>要监视远程应用程序，执行命令<code class="codeph">jconsole<span class="variable" translate="no">hostname</span>:</code> <span class="variable" translate="no">portnumber</span> <code class="codeph"><span class="variable" translate="no">hostname</span></code>是运行应用程序的主机的名称，并且<code class="codeph"><span class="variable" translate="no">portnumber</span></code>是启用JMX代理时指定的端口号。
                        </p>
                        <p>如果执行<code class="codeph">jconsole</code>如果命令中没有参数，该工具将从显示“ <span class="bold">新建连接”</span>窗口开始，在该窗口中您可以指定要监视的本地或远程进程。您可以随时使用“ <span class="bold">连接”</span>菜单连接到其他主机。
                        </p>
                        <p>对于最新的JDK版本，启动要监视的应用程序时不需要任何选项。</p>
                        <p>作为监视工具输出的示例， <a href="diagnostic-tools.html#GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9__BABJECGB">图2-15</a>显示了堆内存使用情况的图表。
                        </p>
                        <div class="figure" id="GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9__BABJECGB">
                           <p class="titleinfigure">图2-15 JConsole的示例输出</p><img src="img/jconsole-memory-tab.gif" alt="如下图2-15所示" title="如下图2-15所示" longdesc="img_text/jconsole-memory-tab.html"><br><a href="img_text/jconsole-memory-tab.html">“图2-15 JConsole的示例输出”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD179"></a><div class="props_rev_3"><a id="GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" name="GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7"></a><h3 id="JSTGD-GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" class="sect3">jdb实用程序</h3>
               <div>
                  <p>的<code class="codeph">jdb</code> JDK中包含实用程序作为示例命令行调试器。的<code class="codeph">jdb</code>实用程序使用Java调试接口（JDI）启动或连接到目标JVM。</p>
                  <p>JDI是高级Java API，可为调试器和需要访问（通常是远程）虚拟机运行状态的类似系统提供有用的信息。JDI是Java平台调试器体系结构（JPDA）的组件。请参阅<a href="diagnostic-tools.html#GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" title="Java平台调试器体系结构（JPDA）是设计供调试器和类似调试器的工具使用的体系结构。">Java平台调试器体系结构</a> 。
                  </p>
                  <p>以下各节提供了以下故障排除技术<code class="codeph">jdb</code>效用。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27" title="jdb实用程序用于监视用于远程调试的调试器连接器。">使用jdb Utility进行故障排除</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD">附加流程</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-76F4E095-0E93-4CD8-9914-C03B643D713E" title="SA核心附加连接器用于将调试器附加到核心文件。">附加到同一台机器上的核心文件</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-8ADCA645-9831-4972-87C0-184C12B188E1" title="在安装调试器的计算机上，可以使用SA调试服务器附加连接器连接到调试服务器。">从另一台计算机附加到核心文件或挂起的进程</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD180"></a><div class="props_rev_3"><a id="GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27" name="GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27"></a><h4 id="JSTGD-GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27" class="sect4">使用jdb Utility进行故障排除</h4>
                  <div>
                     <p>jdb实用程序用于监视用于远程调试的调试器连接器。</p>
                     <p>在JDI中，连接器是调试器连接到目标JVM的方式。传统上，JDK附带用于启动和建立与目标JVM的调试会话的连接器，以及用于远程调试（使用TCP / IP或共享内存传输）的连接器。</p>
                     <p>JDK还附带了几个Serviceability Agent（SA）连接器，这些连接器允许Java语言调试器连接到故障转储或挂起的进程。这对于确定崩溃或挂起时应用程序正在执行的操作很有用。</p>
                     <p>这些连接器是<code class="codeph">SACoreAttachingConnector</code> ， <code class="codeph">SADebugServerAttachingConnector</code>和<code class="codeph">SAPIDAttachingConnector</code> 。
                     </p>
                     <p>这些连接器通常与企业调试器一起使用，例如NetBeans集成开发环境（IDE）或商业IDE。以下各节说明如何将这些连接器与<code class="codeph">jdb</code>命令行调试器。
                     </p>
                     <p>命令<code class="codeph">jdb -listconnectors</code>打印可用连接器的列表。命令<code class="codeph">jdb -help</code>打印命令用法帮助。
                     </p>
                     <p>请参见《 <span><cite>Java平台标准版工具参考》</cite></span>中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/troubleshoot&id=JSWOR-GUID-B801F121-35B5-4FE2-A307-950412CE4E99" target="_blank">jdb实用</a> <span><cite>工具</cite></span></p>
                  </div>
               </div><a id="JSTGD181"></a><div class="props_rev_3"><a id="GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD" name="GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD"></a><h4 id="JSTGD-GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD" class="sect4">附加流程</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>以下示例使用SA PID附加连接器附加到进程。目标进程没有任何特殊选项启动；那就是<code class="codeph">-agentlib:jdwp</code>选项不是必需的。当此连接器连接到进程时，它以只读模式进行连接：调试器可以检查线程和正在运行的应用程序，但不能更改任何内容。连接调试器时冻结该过程。
                        </p>
                        <p>以下示例中的命令指示<code class="codeph">jdb</code>使用名为<code class="codeph">sun.jvm.hotspot.jdi.SAPIDAttachingConnector</code> 。这是连接器名称，而不是类名称。连接器接受一个名为<code class="codeph">pid</code> ，其值为目标流程的流程ID（ <code class="codeph">9302</code> ）。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jdb -connect sun.jvm.hotspot.jdi.SAPIDAttachingConnector:pid=9302</code></span>

Initializing jdb ...
&gt; <span class="bold"><code class="codeph">threads</code></span>
Group system:
  (java.lang.ref.Reference$ReferenceHandler)0xa Reference Handler unknown
  (java.lang.ref.Finalizer$FinalizerThread)0x9  Finalizer         unknown
  (java.lang.Thread)0x8                         Signal Dispatcher running
  (java.lang.Thread)0x7                         Java2D Disposer   unknown
  (java.lang.Thread)0x2                         TimerQueue        unknown
Group main:
  (java.lang.Thread)0x6                         AWT-XAWT          running
  (java.lang.Thread)0x5                         AWT-Shutdown      unknown
  (java.awt.EventDispatchThread)0x4             AWT-EventQueue-0  unknown
  (java.lang.Thread)0x3                         DestroyJavaVM     running
  (sun.awt.image.ImageFetcher)0x1               Image Animator 0  sleeping
  (java.lang.Thread)0x0                         Intro             running
&gt; <span class="bold"><code class="codeph">thread 0x7</code></span>
Java2D Disposer[1] <span class="bold"><code class="codeph">where</code></span>
  [1] java.lang.Object.wait (native method)
  [2] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:116)
  [3] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:132)
  [4] sun.java2d.Disposer.run (Disposer.java:125)
  [5] java.lang.Thread.run (Thread.java:619)
Java2D Disposer[1] <span class="bold"><code class="codeph">up 1</code></span>
Java2D Disposer[2] <span class="bold"><code class="codeph">where</code></span>
  [2] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:116)
  [3] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:132)
  [4] sun.java2d.Disposer.run (Disposer.java:125)
  [5] java.lang.Thread.run (Thread.java:619)
</code></pre><p>在此示例中， <code class="codeph">threads</code>命令用于获取所有线程的列表。然后，使用<code class="codeph">thread 0x7</code>命令，以及<code class="codeph">where</code>命令用于获取线程转储。接下来， <code class="codeph">up 1</code>命令用于在堆栈中上移一帧，然后<code class="codeph">where</code>再次使用该命令获取线程转储。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD183"></a><div class="props_rev_3"><a id="GUID-76F4E095-0E93-4CD8-9914-C03B643D713E" name="GUID-76F4E095-0E93-4CD8-9914-C03B643D713E"></a><h4 id="JSTGD-GUID-76F4E095-0E93-4CD8-9914-C03B643D713E" class="sect4">附加到同一台机器上的核心文件</h4>
                  <div>
                     <p>SA核心附加连接器用于将调试器附加到核心文件。</p>
                     <div class="section">
                        <p>崩溃后可能已创建核心文件。请参阅<a href="troubleshoot-system-crashes.html#GUID-BDA1D041-355C-4C85-9ED0-E2AC46D67BED" title="有关对系统崩溃进行故障排除的某些特定过程的信息和指南。">对系统崩溃进行故障排除</a> 。核心文件也可以通过使用<code class="codeph">gcore</code> Oracle Solaris操作系统上的命令或<code class="codeph">gcore</code>命令输入<code class="codeph">gdb</code>在Linux上。因为核心文件是创建核心文件时进程的快照，所以连接器以只读模式连接：调试器可以在崩溃时检查线程和正在运行的应用程序。
                        </p>
                        <p>以下示例中的命令指示<code class="codeph">jdb</code>使用名为<code class="codeph">sun.jvm.hotspot.jdi.SACoreAttachingConnector</code> 。连接器采用两个参数： <code class="codeph">javaExecutable</code>和<code class="codeph">core</code> 。的<code class="codeph">javaExecutable</code>参数指示Java二进制文件的名称。的<code class="codeph">core</code>参数是核心文件名（来自PID 20441的进程的核心，如以下示例所示）。
                        </p><pre class="pre codeblock"><code>$ jdb -connect sun.jvm.hotspot.jdi.SACoreAttachingConnector:javaExecutable=<span class="variable" translate="no">java-home</span>/bin/java,core=core.20441
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD185"></a><div class="props_rev_3"><a id="GUID-8ADCA645-9831-4972-87C0-184C12B188E1" name="GUID-8ADCA645-9831-4972-87C0-184C12B188E1"></a><h4 id="JSTGD-GUID-8ADCA645-9831-4972-87C0-184C12B188E1" class="sect4">从另一台计算机附加到核心文件或挂起的进程</h4>
                  <div>
                     <p>在安装调试器的计算机上，可以使用SA调试服务器附加连接器连接到调试服务器。</p>
                     <div class="section">
                        <p>要调试从另一台计算机传输的核心文件，操作系统版本和库必须匹配。在这种情况下，您可以首先运行一个称为SA调试服务器的代理服务器。然后，在安装了调试器的计算机上，可以使用SA调试服务器附加连接器连接到调试服务器。</p>
                        <p>例如，有两台机器：machine1和machine2。核心文件在machine1上可用，调试器在machine2上可用。SA调试服务器在machine1上启动，如以下示例所示。</p><pre class="pre codeblock"><code>$ jsadebugd <span class="variable" translate="no">java-home</span>/bin/java core.20441
</code></pre><p>的<code class="codeph">jsadebugd</code>该命令有两个参数。第一个参数是可执行文件的名称。通常这是<code class="codeph">java</code> ，但可以是另一个名称（例如，在嵌入式VM中）。第二个参数是核心文件的名称。在此示例中，使用PID 20441为进程获取了核心文件。 <code class="codeph">gcore</code>效用。
                        </p>
                        <p>在machine2上，调试器使用SA Debug Server附加连接器连接到远程SA Debug Server，如以下示例所示。</p><pre class="pre codeblock"><code>$ jdb -connect sun.jvm.hotspot.jdi.SADebugServerAttachingConnector:debugServerName=machine1
</code></pre><p>示例中的命令指示<code class="codeph">jdb</code>使用名为<code class="codeph">sun.jvm.hotspot.jdi.SADebugServerAttachingConnector</code> 。连接器有一个参数， <code class="codeph">debugServerName</code> ，这是运行SA Debug Server的计算机的主机名或IP地址。
                        </p>
                        <div class="infoboxnote" id="GUID-8ADCA645-9831-4972-87C0-184C12B188E1__GUID-AF35BFD7-389E-4E03-9DF0-05CE4E8898CC">
                           <p class="notep1">注意：</p>
                           <p>SA调试服务器也可以用于远程调试挂起的进程。在这种情况下，它只接受一个参数，即进程的PID。此外，如果需要在同一台计算机上运行多个调试服务器，则必须为每个调试服务器提供唯一的ID。对于SA Debug Server附加连接器，此ID作为附加的连接器参数提供。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD196"></a><div class="props_rev_3"><a id="GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" name="GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE"></a><h3 id="JSTGD-GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" class="sect3">jinfo实用程序</h3>
               <div>
                  <p>的<code class="codeph">jinfo</code>命令行实用程序从正在运行的Java进程或故障转储中获取配置信息，并打印用于启动JVM的系统属性或命令行标志。</p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。使用最新的实用程序， <code class="codeph">jcmd</code> ，而不是以前的<code class="codeph">jinfo</code>实用程序可增强诊断并降低性能开销。
                  </p>
                  <div class="p">的<code class="codeph">jinfo</code>实用程序也可以使用<code class="codeph">jsadebugd</code>守护程序，用于查询远程计算机上的进程或核心文件。
                     <div class="infoboxnote" id="GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE__GUID-7EC37A3A-6BB8-426C-B66C-BB1BF51EAAC7">
                        <p class="notep1">注意：</p>在这种情况下，输出需要更长的打印时间。
                     </div> 
                  </div>
                  <p>随着<code class="codeph">-flag</code>选项， <code class="codeph">jinfo</code>实用程序可以为指定的Java进程动态设置，取消设置或更改某些JVM标志的值。请参阅<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6" title="带有-XX前缀的命令行选项特定于Java HotSpot虚拟机。这些选项中的许多对于性能调整和诊断目的都很重要，因此在本附录中进行了描述。">Java HotSpot VM命令行选项</a> 。
                  </p>
                  <p>输出为<code class="codeph">jinfo</code>以下示例显示了PID号为29620的Java进程的实用程序。
                  </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jinfo 29620</code></span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
Java System Properties:

java.runtime.name = Java(TM) SE Runtime Environment
sun.boot.library.path = /usr/jdk/instances/jdk1.6.0/jre/lib/sparc
java.vm.version = 1.6.0-rc-b100
java.vm.vendor = Sun Microsystems Inc.
java.vendor.url = http://java.sun.com/
path.separator = :
java.vm.name = Java HotSpot(TM) Client VM
file.encoding.pkg = sun.io
sun.java.launcher = SUN_STANDARD
sun.os.patch.level = unknown
java.vm.specification.name = Java Virtual Machine Specification
user.dir = /home/js159705
java.runtime.version = 1.6.0-rc-b100
java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment
java.endorsed.dirs = /usr/jdk/instances/jdk1.6.0/jre/lib/endorsed
os.arch = sparc
java.io.tmpdir = /var/tmp/
line.separator =

java.vm.specification.vendor = Sun Microsystems Inc.
os.name = SunOS
sun.jnu.encoding = ISO646-US
java.library.path = /usr/jdk/instances/jdk1.6.0/jre/lib/sparc/client:/usr/jdk/instances/jdk1.6.0/jre/lib/sparc:
/usr/jdk/instances/jdk1.6.0/jre/../lib/sparc:/net/gtee.sfbay/usr/sge/sge6/lib/sol-sparc64:
/usr/jdk/packages/lib/sparc:/lib:/usr/lib
java.specification.name = Java Platform API Specification
java.class.version = 50.0
sun.management.compiler = HotSpot Client Compiler
os.version = 5.10
user.home = /home/js159705
user.timezone = US/Pacific
java.awt.printerjob = sun.print.PSPrinterJob
file.encoding = ISO646-US
java.specification.version = 1.6
java.class.path = /usr/jdk/jdk1.6.0/demo/jfc/Java2D/Java2Demo.jar
user.name = js159705
java.vm.specification.version = 1.0
java.home = /usr/jdk/instances/jdk1.6.0/jre
sun.arch.data.model = 32
user.language = en
java.specification.vendor = Sun Microsystems Inc.
java.vm.info = mixed mode, sharing
java.version = 1.6.0-rc
java.ext.dirs = /usr/jdk/instances/jdk1.6.0/jre/lib/ext:/usr/jdk/packages/lib/ext
sun.boot.class.path = /usr/jdk/instances/jdk1.6.0/jre/lib/resources.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/rt.jar:/usr/jdk/instances/jdk1.6.0/jre/lib/sunrsasign.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/jsse.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/jce.jar:/usr/jdk/instances/jdk1.6.0/jre/lib/charsets.jar:
/usr/jdk/instances/jdk1.6.0/jre/classes
java.vendor = Sun Microsystems Inc.
file.separator = /
java.vendor.url.bug = http://java.sun.com/cgi-bin/bugreport.cgi
sun.io.unicode.encoding = UnicodeBig
sun.cpu.endian = big
sun.cpu.isalist =

VM Flags:
</code></pre><p>以下主题介绍了使用以下工具进行故障排除的方法： <code class="codeph">jinfo</code>效用。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1" title="jinfo的输出提供java.class.path和sun.boot.class.path的设置。">使用jinfo实用程序进行故障排除</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD198"></a><div class="props_rev_3"><a id="GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1" name="GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1"></a><h4 id="JSTGD-GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1" class="sect4">使用jinfo实用程序进行故障排除</h4>
                  <div>
                     <p>来自的输出<code class="codeph">jinfo</code>提供以下设置<code class="codeph">java.class.path</code>和<code class="codeph">sun.boot.class.path</code> 。
                     </p>
                     <div class="section">
                        <p>如果您使用<code class="codeph">-classpath</code>和<code class="codeph">-Xbootclasspath</code>参数，然后从<code class="codeph">jinfo</code>提供以下设置<code class="codeph">java.class.path</code>和<code class="codeph">sun.boot.class.path</code> 。调查类加载器问题时，可能需要此信息。
                        </p>
                        <p>除了从流程中获取信息外， <code class="codeph">jinfo</code>工具可以使用核心文件作为输入。例如，在Oracle Solaris操作系统上， <code class="codeph">gcore</code>在前面的示例中，实用程序可用于获取进程的核心文件。核心文件将命名为<code class="codeph">core.29620</code>并将在流程的工作目录中生成。必须将Java可执行文件和核心文件的路径指定为<code class="codeph">jinfo</code>实用程序，如以下示例所示。
                        </p><pre class="pre codeblock"><code>$ jinfo <span class="variable" translate="no">java-home</span>/bin/java core.29620
</code></pre><p>有时，二进制名称不会<code class="codeph">java</code> 。使用JNI调用API创建VM时会发生这种情况。的<code class="codeph">jinfo</code>该工具需要从中生成核心文件的二进制文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD200"></a><div class="props_rev_3"><a id="GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" name="GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818"></a><h3 id="JSTGD-GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" class="sect3">jmap实用程序</h3>
               <div>
                  <p>的<code class="codeph">jmap</code>命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。
                  </p>
                  <p></p>
                  <p>该实用程序还可以使用<code class="codeph">jsadebugd</code>守护程序，用于查询远程计算机上的进程或核心文件。在这种情况下，输出需要更长的打印时间。
                  </p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。建议使用最新的实用程序， <code class="codeph">jcmd</code>而不是以前的<code class="codeph">jmap</code>实用程序可增强诊断并降低性能开销。
                  </p>
                  <p>如果<code class="codeph">jmap</code>与没有任何命令行选项的进程或核心文件一起使用，然后打印已加载的共享对象的列表（输出类似于<code class="codeph">pmap</code> Oracle Solaris操作系统上的实用程序）。有关更多特定信息，您可以使用选项<code class="codeph">-heap</code> ， <code class="codeph">-histo</code> ， 要么<code class="codeph">-permstat</code> 。这些选项在随后的小节中介绍。
                  </p>
                  <p>此外，JDK 7版本还引入了<code class="codeph">-dump:format=b,file=<span class="variable" translate="no">filename</span></code>选项，这会导致<code class="codeph">jmap</code>将Java堆以二进制格式转储到指定文件。
                  </p>
                  <p>如果<code class="codeph">jmap<span class="variable" translate="no">pid</span></code>命令由于挂起的进程而没有响应，则<code class="codeph">-F</code>可以使用该选项（仅在Oracle Solaris和Linux操作系统上）来强制使用Serviceability Agent。
                  </p>
                  <p>以下各节介绍了<code class="codeph">jmap</code>命令用法和故障排除技术，并提供示例，这些示例为正在运行的VM或核心文件打印与内存相关的统计信息。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB" title="使用jmap -heap命令获取Java堆信息。">堆配置和使用</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9" title="带有-histo选项的jmap命令可用于获取堆的特定于类的直方图。">堆直方图</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876" title="永久性生成是堆的区域，其中包含虚拟机本身的所有反射数据，例如类和方法对象。">永久世代统计</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD201"></a><div class="props_rev_3"><a id="GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB" name="GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB"></a><h4 id="JSTGD-GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB" class="sect4">堆配置和使用</h4>
                  <div>
                     <p>使用<code class="codeph">jmap -heap</code>命令以获取Java堆信息。
                     </p>
                     <div class="section">
                        <p>的<code class="codeph">-heap</code> option用于获取以下Java堆信息：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>垃圾回收（GC）算法的特定信息，包括GC算法的名称（例如，并行GC）和特定于算法的详细信息（例如，并行GC的线程数）。</p>
                           </li>
                           <li>
                              <p>堆配置可能已被指定为命令行选项或由VM根据机器配置选择。</p>
                           </li>
                           <li>
                              <p>堆使用情况摘要：对于每一代（堆的区域），该工具都会显示堆的总容量，使用中的内存和可用的可用内存。如果将一个世代组织成一个空间集合（例如，新一代），则将包括一个特定于空间的内存大小摘要。</p>
                           </li>
                        </ul>
                        <p>以下示例显示了<code class="codeph">jmap -heap</code>命令。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jmap -heap 29620</code></span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100

using thread-local object allocation.
Mark Sweep Compact GC

Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 67108864 (64.0MB)
   NewSize          = 2228224 (2.125MB)
   MaxNewSize       = 4294901760 (4095.9375MB)
   OldSize          = 4194304 (4.0MB)
   NewRatio         = 8
   SurvivorRatio    = 8
   PermSize         = 12582912 (12.0MB)
   MaxPermSize      = 67108864 (64.0MB)

Heap Usage:
New Generation (Eden + 1 Survivor Space):
   capacity = 2031616 (1.9375MB)
   used     = 70984 (0.06769561767578125MB)
   free     = 1960632 (1.8698043823242188MB)
   3.4939673639112905% used
Eden Space:
   capacity = 1835008 (1.75MB)
   used     = 36152 (0.03447723388671875MB)
   free     = 1798856 (1.7155227661132812MB)
   1.9701276506696428% used
From Space:
   capacity = 196608 (0.1875MB)
   used     = 34832 (0.0332183837890625MB)
   free     = 161776 (0.1542816162109375MB)
   17.716471354166668% used
To Space:
   capacity = 196608 (0.1875MB)
   used     = 0 (0.0MB)
   free     = 196608 (0.1875MB)
   0.0% used
tenured generation:
   capacity = 15966208 (15.2265625MB)
   used     = 9577760 (9.134063720703125MB)
   free     = 6388448 (6.092498779296875MB)
   59.98769400974859% used
Perm Generation:
   capacity = 12582912 (12.0MB)
   used     = 1469408 (1.401336669921875MB)
   free     = 11113504 (10.598663330078125MB)
   11.677805582682291% used
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD203"></a><div class="props_rev_3"><a id="GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9" name="GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9"></a><h4 id="JSTGD-GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9" class="sect4">堆直方图</h4>
                  <div>
                     <p>的<code class="codeph">jmap</code>用命令<code class="codeph">-histo</code> option可用于获取堆的特定于类的直方图。
                     </p>
                     <div class="section">
                        <p>根据指定的参数， <code class="codeph">jmap -histo</code>命令可以打印正在运行的进程或核心文件的堆直方图。
                        </p>
                        <p>在正在运行的进程上执行命令时，该工具将打印对象数量，以字节为单位的内存大小以及每个类的完全限定的类名称。Java HotSpot VM中的内部类包含在尖括号中。直方图对于了解如何使用堆非常有用。要获取对象的大小，必须将总大小除以该对象类型的计数。</p>
                        <p>以下示例显示了<code class="codeph">jmap -histo</code>在PID号为29620的进程上执行时执行命令。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jmap -histo 29620</code></span>
num   #instances    #bytes  class name
--------------------------------------
  1:      1414     6013016  [I
  2:       793      482888  [B
  3:      2502      334928  &lt;constMethodKlass&gt;
  4:       280      274976  &lt;instanceKlassKlass&gt;
  5:       324      227152  [D
  6:      2502      200896  &lt;methodKlass&gt;
  7:      2094      187496  [C
  8:       280      172248  &lt;constantPoolKlass&gt;
  9:      3767      139000  [Ljava.lang.Object;
 10:       260      122416  &lt;constantPoolCacheKlass&gt;
 11:      3304      112864  &lt;symbolKlass&gt;
 12:       160       72960  java2d.Tools$3
 13:       192       61440  &lt;objArrayKlassKlass&gt;
 14:       219       55640  [F
 15:      2114       50736  java.lang.String
 16:      2079       49896  java.util.HashMap$Entry
 17:       528       48344  [S
 18:      1940       46560  java.util.Hashtable$Entry
 19:       481       46176  java.lang.Class
 20:        92       43424  javax.swing.plaf.metal.MetalScrollButton
... more lines removed here to reduce output...
1118:         1           8  java.util.Hashtable$EmptyIterator
1119:         1           8  sun.java2d.pipe.SolidTextRenderer
Total    61297    10152040
</code></pre><p>当。。。的时候<code class="codeph">jmap -histo</code>命令在核心文件上执行，该工具会打印每个类的大小，计数和类名称。Java HotSpot VM中的内部类以星号（*）为前缀。
                        </p>
                        <p>显示的输出<code class="codeph">jmap -histo</code>在核心文件上执行时的命令。
                        </p><pre class="pre codeblock"><code>&amp; <span class="bold"><code class="codeph">jmap -histo /net/koori.sfbay/onestop/jdk/6.0/promoted/all/b100/binaries/solaris-sparcv9/bin/java core</code></span>
Attaching to core core from executable /net/koori.sfbay/onestop/jdk/6.0/
promoted/all/b100/binaries/solaris-sparcv9/bin/java, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 1.6.0-rc-b100
Iterating over heap. This may take a while...
Heap traversal took 8.902 seconds.

Object Histogram:

Size    Count    Class description
-------------------------------------------------------
4151816    2941    int[]
2997816    26403    * ConstMethodKlass
2118728    26403    * MethodKlass
1613184    39750    * SymbolKlass
1268896    2011    * ConstantPoolKlass
1097040    2011    * InstanceKlassKlass
882048    1906    * ConstantPoolCacheKlass
758424    7572    char[]
733776    2518    byte[]
252240    3260    short[]
214944    2239    java.lang.Class
177448    3341    * System ObjArray
176832    7368    java.lang.String
137792    3756    java.lang.Object[]
121744    74    long[]
72960    160    java2d.Tools$3
63680    199    * ObjArrayKlassKlass
53264    158    float[]
... more lines removed here to reduce output...
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD206"></a><div class="props_rev_3"><a id="GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876" name="GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876"></a><h4 id="JSTGD-GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876" class="sect4">永久世代统计</h4>
                  <div>
                     <p>永久性生成是堆的区域，其中包含虚拟机本身的所有反射数据，例如类和方法对象。</p>
                     <div class="section">
                        <p>在<span class="italic">Java虚拟机规范</span>中<span class="italic">，</span>该区域也称为方法区域。
                        </p>
                        <p>配置永久生成的大小对于动态生成和加载大量类（例如Java Server Pages或Web容器）的应用程序很重要。如果应用程序加载了太多的类，则可能会因以下错误而终止：</p><pre class="pre codeblock"><code>Exception in thread <span class="variable" translate="no">thread_name</span> java.lang.OutOfMemoryError: PermGen space
</code></pre><p>请参阅<a href="troubleshoot-memory-leaks.html#GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" title="java.lang。当没有足够的空间在Java堆中分配对象时，将引发OutOfMemoryError错误。">了解OutOfMemoryError异常</a> 。
                        </p>
                        <p>要获取有关永久代的更多信息，您可以使用<code class="codeph">-permstat</code>的选项<code class="codeph">jmap</code>命令打印永久代中对象的统计信息。
                        </p>
                        <p>以下示例显示了<code class="codeph">jmap -permstat</code>该命令在PID号为29620的进程上执行。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jmap -permstat 29620</code></span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
12674 intern Strings occupying 1082616 bytes.
finding class loader instances ..Unknown oop at 0xd0400900
Oop's klass is 0xd0bf8408
Unknown oop at 0xd0401100
Oop's klass is null
done.
computing per loader stat ..done.
please wait.. computing liveness.........................................done.
class_loader    classes bytes   parent_loader   alive?  type

&lt;bootstrap&gt;     1846 5321080  null        live   &lt;internal&gt;
0xd0bf3828  0      0      null         live    sun/misc/Launcher$ExtClassLoader@0xd8c98c78
0xd0d2f370  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99280  1   1440      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b71d90  0      0   0xd0b5b9c0    live java/util/ResourceBundle$RBClassLoader@0xd8d042e8
0xd0d2f4c0  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5bf98  1    920   0xd0b5bf38      dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99248  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f488  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5bf38  6   11832  0xd0b5b9c0      dead    sun/reflect/misc/MethodUtil@0xd8e8e560
0xd0d2f338  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f418  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f3a8  1    904     null          dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5b9c0  317 1397448 0xd0bf3828     live    sun/misc/Launcher$AppClassLoader@0xd8cb83d8
0xd0d2f300  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f3e0  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0ec3968  1   1440      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0e0a248  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99210  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f450  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f4f8  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0e0a280  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50

total = 22      2186    6746816   N/A   alive=4, dead=18       N/A    
</code></pre><p></p>
                        <p>对于每个类加载器对象，将打印以下详细信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行实用程序时快照中的类加载器对象的地址</p>
                           </li>
                           <li>
                              <p>加载的类数</p>
                           </li>
                           <li>
                              <p>该类加载器加载的所有类的元数据消耗的大概字节数</p>
                           </li>
                           <li>
                              <p>父类加载器的地址（如果有）</p>
                           </li>
                           <li>
                              <p>是否Loader对象的<span class="italic"><span class="bold">活的</span></span>或<span class="italic"><span class="bold">死的</span></span>指示将被垃圾收集在未来</p>
                           </li>
                           <li>
                              <p>该类加载器的类名称</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD208"></a><div class="props_rev_3"><a id="GUID-FC269C18-470F-441E-9564-7EEA182F8125" name="GUID-FC269C18-470F-441E-9564-7EEA182F8125"></a><h3 id="JSTGD-GUID-FC269C18-470F-441E-9564-7EEA182F8125" class="sect3">jps实用程序</h3>
               <div>
                  <p>的<code class="codeph">jps</code>该实用程序列出了目标系统上当前用户的每个检测到的Java HotSpot VM。
                  </p>
                  <div class="section">
                     <p>该实用程序在嵌入式VM的环境中非常有用，也就是说，使用JNI Invocation API（而不是JNI Invocation API）启动VM。 <code class="codeph">java</code>发射器。在这些环境中，在进程列表中识别Java进程并不总是那么容易。
                     </p>
                     <p>以下示例显示了<code class="codeph">jps</code>效用。
                     </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jps</code></span>
16217 MyApplication
16342 jps
</code></pre><p>的<code class="codeph">jps</code>实用程序列出了用户具有访问权限的虚拟机。这由特定于操作系统的访问控制机制确定。例如，在Oracle Solaris操作系统上，如果非root用户执行<code class="codeph">jps</code>实用程序，然后输出是使用该用户的UID启动的虚拟机的列表。</p>
                     <p>除了列出PID，该实用程序还提供选项以输出传递给应用程序的参数的参数。 <code class="codeph">main</code>方法，VM参数的完整列表以及应用程序的完整程序包名称<code class="codeph">main</code>类。的<code class="codeph">jps</code>如果远程系统正在运行该实用程序，该实用程序还可以列出该远程系统上的进程。 <code class="codeph">jstatd</code>守护程序。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD212"></a><div class="props_rev_3"><a id="GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" name="GUID-36CBAF37-0B61-4455-9183-1268E6D497DD"></a><h3 id="JSTGD-GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" class="sect3">jstack实用程序</h3>
               <div>
                  <p>使用<code class="codeph">jcmd</code>实用程序，而不是<code class="codeph">jcmd</code>用于诊断JVM和Java应用程序问题的实用程序。
                  </p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。建议使用最新的实用程序， <code class="codeph">jcmd</code> ，而不是以前的<code class="codeph">jstack</code>实用程序可增强诊断并降低性能开销。
                  </p>
                  <p>以下各节介绍了使用<code class="codeph">jstack</code>效用。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-1240C470-CA56-4045-8098-E6E2FA259F6A" title="jstack命令行实用程序将附加到指定的进程或核心文件，并打印附加到虚拟机的所有线程（包括Java线程和VM内部线程）以及可选的本机堆栈帧的堆栈跟踪。该实用程序还执行死锁检测。">使用jstack实用程序进行故障排除</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-E789DE61-D453-48D0-9EBE-F81E4261379A" title="使用jstack命令从核心转储获取堆栈跟踪。">来自核心转储的堆栈跟踪</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E" title="jstack实用程序还可以用于打印混合堆栈。也就是说，除了Java堆栈外，它还可以打印本机堆栈帧。本机帧是与VM代码和JNI /本机代码关联的C / C ++帧。">混合堆叠</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD213"></a><div class="props_rev_3"><a id="GUID-1240C470-CA56-4045-8098-E6E2FA259F6A" name="GUID-1240C470-CA56-4045-8098-E6E2FA259F6A"></a><h4 id="JSTGD-GUID-1240C470-CA56-4045-8098-E6E2FA259F6A" class="sect4">使用jstack实用程序进行故障排除</h4>
                  <div>
                     <p>的<code class="codeph">jstack</code>命令行实用程序将附加到指定的进程或核心文件，并打印附加到虚拟机的所有线程的堆栈跟踪，包括Java线程和VM内部线程，以及可选的本机堆栈帧。该实用程序还执行死锁检测。
                     </p>
                     <div class="section">
                        <p>该实用程序还可以使用<code class="codeph">jsadebugd</code>守护程序，用于查询远程计算机上的进程或核心文件。在这种情况下，输出需要更长的打印时间。
                        </p>
                        <p>所有线程的堆栈跟踪对于诊断许多问题（例如死锁或挂起）很有用。</p>
                        <p>的<code class="codeph">-l</code>选项指示实用程序在堆中查找可拥有的同步器，并输出有关<code class="codeph">java.util.concurrent.locks</code> 。如果没有此选项，则线程转储仅包含有关监视器的信息。
                        </p>
                        <p>来自的输出<code class="codeph">jstack <span class="variable" translate="no">pid</span></code>选项与在应用程序控制台（标准输入）上按Ctrl + \或向进程发送退出信号所获得的选项相同。有关输出示例，请参见<a href="diagnostic-tools.html#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="在操作系统（例如Oracle Solaris或Linux或Windows）上的应用程序控制台上按Control键和反斜杠（\）键的结果。">Control + Break Handler</a> 。
                        </p>
                        <p>线程转储也可以使用<code class="codeph">Thread.getAllStackTraces</code>方法，或在调试器中使用debugger选项打印所有线程堆栈（ <code class="codeph">where</code>在命令的情况下<code class="codeph">jdb</code>示例调试器）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD216"></a><div class="props_rev_3"><a id="GUID-E789DE61-D453-48D0-9EBE-F81E4261379A" name="GUID-E789DE61-D453-48D0-9EBE-F81E4261379A"></a><h4 id="JSTGD-GUID-E789DE61-D453-48D0-9EBE-F81E4261379A" class="sect4">来自核心转储的堆栈跟踪</h4>
                  <div>
                     <p>使用<code class="codeph">jstack</code>命令从核心转储获取堆栈跟踪。
                     </p>
                     <div class="section">
                        <p>要从核心转储中获取堆栈跟踪，请执行<code class="codeph">jstack</code>核心文件上的命令，如以下示例所示。
                        </p>
                        <p></p><pre class="pre codeblock"><code>$ jstack <span class="variable" translate="no">java-home</span>/bin/java core
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSTGD218"></a><div class="props_rev_3"><a id="GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E" name="GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E"></a><h4 id="JSTGD-GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E" class="sect4">混合堆叠</h4>
                  <div>
                     <p>的<code class="codeph">jstack</code>实用程序还可用于打印混合堆栈；也就是说，除了Java堆栈外，它还可以打印本机堆栈帧。本机帧是与VM代码和JNI /本机代码关联的C / C ++帧。
                     </p>
                     <div class="section">
                        <p>要打印混合纸叠，请使用<code class="codeph">-m</code>选项，如以下示例所示。
                        </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jstack -m 21177</code></span>
Attaching to process ID 21177, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
Deadlock Detection:

Found one Java-level deadlock:
=============================

"Thread1":
  waiting to lock Monitor@0x0005c750 (Object@0xd4405938, a java/lang/String),
  which is held by "Thread2"
"Thread2":
  waiting to lock Monitor@0x0005c6e8 (Object@0xd4405900, a java/lang/String),
  which is held by "Thread1"

Found a total of 1 deadlock.

----------------- t@1 -----------------
0xff2c0fbc    __lwp_wait + 0x4
0xff2bc9bc    _thrp_join + 0x34
0xff2bcb28    thr_join + 0x10
0x00018a04    ContinueInNewThread + 0x30
0x00012480    main + 0xeb0
0x000111a0    _start + 0x108
----------------- t@2 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xfec03638    bool Monitor::wait(bool,long) + 0x420
0xfec9e2c8    bool Threads::destroy_vm() + 0xa4
0xfe93ad5c    jni_DestroyJavaVM + 0x1bc
0x00013ac0    JavaMain + 0x1600
0xff2bfd9c    _lwp_start
----------------- t@3 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xff2ac104    _lwp_cond_timedwait + 0x1c
0xfec034f4    bool Monitor::wait(bool,long) + 0x2dc
0xfece60bc    void VMThread::loop() + 0x1b8
0xfe8b66a4    void VMThread::run() + 0x98
0xfec139f4    java_start + 0x118
0xff2bfd9c    _lwp_start
----------------- t@4 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xfec195e8    void os::PlatformEvent::park() + 0xf0
0xfec88464    void ObjectMonitor::wait(long long,bool,Thread*) + 0x548
0xfe8cb974    void ObjectSynchronizer::wait(Handle,long long,Thread*) + 0x148
0xfe8cb508    JVM_MonitorWait + 0x29c
0xfc40e548    * java.lang.Object.wait(long) bci:0 (Interpreted frame)
0xfc40e4f4    * java.lang.Object.wait(long) bci:0 (Interpreted frame)
0xfc405a10    * java.lang.Object.wait() bci:2 line:485 (Interpreted frame)
... more lines removed here to reduce output...
----------------- t@12 -----------------
0xff2bfe3c    __lwp_park + 0x10
0xfe9925e4    AttachOperation*AttachListener::dequeue() + 0x148
0xfe99115c    void attach_listener_thread_entry(JavaThread*,Thread*) + 0x1fc
0xfec99ad8    void JavaThread::thread_main_inner() + 0x48
0xfec139f4    java_start + 0x118
0xff2bfd9c    _lwp_start
----------------- t@13 -----------------
0xff2c1500    _door_return + 0xc
----------------- t@14 -----------------
0xff2c1500    _door_return + 0xc
</code></pre><p>带星号（*）前缀的框架是Java框架，而没有带星号的框架是本机C / C ++框架。</p>
                        <p>该实用程序的输出可以通过管道传输<code class="codeph">c++filt</code>分解C ++损坏的符号名称。由于Java HotSpot VM是使用C ++语言开发的，因此<code class="codeph">jstack</code>实用程序将为Java HotSpot内部函数打印C ++修饰的符号名称。
                        </p>
                        <p>的<code class="codeph">c++filt</code>实用程序随本地C ++编译器套件一起提供： <code class="codeph">SUNWspro</code>在Oracle Solaris操作系统上<code class="codeph">gnu</code>在Linux上。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSTGD220"></a><div class="props_rev_3"><a id="GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" name="GUID-370616DE-AB80-49EB-9802-C278AF75AAE8"></a><h3 id="JSTGD-GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" class="sect3">jstat实用程序</h3>
               <div>
                  <p>的<code class="codeph">jstat</code>该实用程序使用Java HotSpot VM中的内置工具来提供有关正在运行的应用程序的性能和资源消耗的信息。
                  </p>
                  <div class="section">
                     <p>诊断性能问题，尤其是与堆大小和垃圾回收有关的问题时，可以使用该工具。的<code class="codeph">jstat</code>实用程序不需要使用任何特殊选项启动VM。默认情况下，Java HotSpot VM中的内置工具是启用的。对于Oracle支持的所有操作系统平台，该实用程序都包含在JDK下载中。
                     </p>
                     <div class="infoboxnote" id="GUID-370616DE-AB80-49EB-9802-C278AF75AAE8__GUID-3212741D-DBEE-4479-A36D-3B430AE7F89B">
                        <p class="notep1">注意：</p>
                        <p>无法在FAT32文件系统上访问该工具。</p>
                     </div>
                     <p>请参见《 <span><cite>Java平台标准版工具参考》</cite></span>中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/troubleshoot&id=JSWOR734" target="_blank">jstat</a> 。
                     </p>
                     <p>的<code class="codeph">jstat</code>实用程序使用虚拟机标识符（VMID）来标识目标进程。该文档描述了VMID的语法，但是它唯一需要的组件是本地虚拟机标识符（LVMID）。LVMID通常（但并非总是）是目标JVM进程的操作系统PID。
                     </p>
                     <p>的<code class="codeph">jstat</code>实用程序提供的数据类似于<code class="codeph">vmstat</code>和<code class="codeph">iostat</code>在Oracle Solaris和Linux操作系统上。
                     </p>
                     <p>对于数据的图形表示，可以使用<code class="codeph">visualgc</code>工具。请参阅<a href="diagnostic-tools.html#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="visualgc工具提供了垃圾收集（GC）系统的图形视图。">visualgc工具</a> 。
                     </p>
                     <p>以下示例说明了<code class="codeph">-gcutil</code>选项，其中<code class="codeph">jstat</code>实用程序附加到LVMID号2834，并以250毫秒的间隔进行7个采样。
                     </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jstat -gcutil 2834 250 7</code></span>
  S0     S1     E      O      M     YGC     YGCT    FGC    FGCT     GCT   
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124</code></pre><p></p>
                     <p>此示例的输出向您显示在第三和第四个样本之间发生了年轻代收集。收集耗时0.017秒，将物体从伊甸园空间（E）提升到旧空间（O），导致旧空间利用率从46.56％提高到54.60％。</p>
                     <p>以下示例说明了<code class="codeph">-gcnew</code>选择其中<code class="codeph">jstat</code>实用程序附加到LVMID号2834，以250毫秒的间隔进行采样，并显示输出。此外，它使用<code class="codeph">-h3</code>选项，每三行数据后显示列标题。
                     </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jstat -gcnew -h3 2834 250</code></span>
S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0    942.0    218    1.999
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1024.8    218    1.999
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1068.1    218    1.999
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1109.0    218    1.999
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0      0.0    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     71.6    219    2.019
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     73.7    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     78.0    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0    116.1    219    2.019
</code></pre><p>除了显示重复的标题字符串外，此示例还显示在第四和第五个样本之间，出现了一个年轻代集合，其持续时间为0.02秒。该集合发现了足够的实时数据，以至于生存空间1的利用率（S1U）将超过所需的生存空间大小（DSS）。结果，对象被提升为旧一代（在此输出中不可见），并且任职期限（TT）从15降低到1。</p>
                     <p>以下示例说明了<code class="codeph">-gcoldcapacity</code>选项，其中<code class="codeph">jstat</code>实用程序附加到LVMID号21891，并以250毫秒的间隔进行3个采样。的<code class="codeph">-t</code> option用于为第一列中的每个样本生成时间戳。
                     </p><pre class="pre codeblock"><code>$ <span class="bold"><code class="codeph">jstat -gcoldcapacity -t 21891 250 3</code></span>
Timestamp    OGCMN     OGCMX       OGC        OC   YGC   FGC     FGCT     GCT
    150.1   1408.0   60544.0   11696.0   11696.0   194    80    2.874   3.799
    150.4   1408.0   60544.0   13820.0   13820.0   194    81    2.938   3.863
    150.7   1408.0   60544.0   13820.0   13820.0   194    81    2.938   3.863
</code></pre><p>“时间戳记”列报告自目标JVM启动以来经过的时间（以秒为单位）。除此之外<code class="codeph">-gcoldcapacity</code>输出显示随着堆扩展以满足分配或升级需求，旧发电容量（OGC）和旧空间容量（OC）不断增加。该OGC已经从11696 KB的<sup>第</sup> 81代满容量（FGC）后生长至13820 KB。生成的最大容量（和空间）为60544 KB（OGCMX），因此仍有扩展空间。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSTGD225"></a><a id="JSTGD224"></a><div class="props_rev_3"><a id="GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" name="GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25"></a><h3 id="JSTGD-GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" class="sect3">visualgc工具</h3>
               <div>
                  <p>的<code class="codeph">visualgc</code>该工具提供了垃圾收集（GC）系统的图形视图。
                  </p>
                  <p>的<code class="codeph">visualgc</code>该工具与<code class="codeph">jstat</code>工具。请参阅<a href="diagnostic-tools.html#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="jstat实用程序使用Java HotSpot VM中的内置工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">jstat实用程序</a> 。的<code class="codeph">visualgc</code>该工具提供了垃圾收集（GC）系统的图形视图。与<code class="codeph">jstat</code> ，它使用Java HotSpot VM的内置工具。</p>
                  <p>的<code class="codeph">visualgc</code>该工具未包含在JDK版本中，但可以从以下位置单独下载<a href="http://www.oracle.com/technetwork/java/jvmstat-142257.html" target="_blank"><code class="codeph">jvmstat</code>技术</a>页面。
                  </p>
                  <p><a href="diagnostic-tools.html#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25__BABDGABF">图2-16</a>显示了如何可视化GC和堆。
                  </p>
                  <div class="figure" id="GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25__BABDGABF">
                     <p class="titleinfigure">图2-16来自的样本输出<code class="codeph">visualgc</code></p><img src="img/visualgc.gif" alt="如下图2-16所示" title="如下图2-16所示" longdesc="img_text/visualgc.html"><br><a href="img_text/visualgc.html">“图2-16 visualgc的示例输出”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="JSTGD226"></a><div class="props_rev_3"><a id="GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" name="GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C"></a><h3 id="JSTGD-GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" class="sect3">控制+中断处理程序</h3>
               <div>
                  <p>在操作系统（例如Oracle Solaris或Linux或Windows）上的应用程序控制台上按Control键和反斜杠（\）键的结果。</p>
                  <p>在Oracle Solaris或Linux操作系统上，在应用程序控制台（标准输入）上按Control键和反斜杠（\）键的组合使Java HotSpot VM将线程转储打印到应用程序的标准输出。在Windows上，等效的键序列为Control和Break键。这些组合键的总称是Control + Break处理程序。</p>
                  <p>在Oracle Solaris和Linux操作系统上，如果Java进程收到退出信号，则将打印线程转储。因此， <code class="codeph">kill -QUIT <span class="variable" translate="no">pid</span></code>命令导致具有ID的进程<code class="codeph"><span class="variable" translate="no">pid</span></code>将线程转储打印到标准输出。
                  </p>
                  <p>以下各节描述了Control + Break处理程序跟踪的数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" title="线程转储由虚拟机中所有Java线程的线程堆栈（包括线程状态）组成。">线程转储</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57" title="Control + Break处理程序可用于检测线程中的死锁。">检测死锁</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51" title="Control + Break处理程序可用于打印堆摘要。">堆摘要</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD227"></a><div class="props_rev_3"><a id="GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" name="GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238"></a><h4 id="JSTGD-GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" class="sect4">线程转储</h4>
                  <div>
                     <p>线程转储由虚拟机中所有Java线程的线程堆栈（包括线程状态）组成。</p>
                     <p>线程转储不会终止应用程序：它在线程信息打印后继续。</p>
                     <p>以下示例说明了线程转储。</p><pre class="pre codeblock"><code>Full thread dump Java HotSpot(TM) Client VM (1.6.0-rc-b100 mixed mode):

"DestroyJavaVM" prio=10 tid=0x00030400 nid=0x2 waiting on condition [0x00000000..0xfe77fbf0]
   java.lang.Thread.State: RUNNABLE

"Thread2" prio=10 tid=0x000d7c00 nid=0xb waiting for monitor entry [0xf36ff000..0xf36ff8c0]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a938&gt; (a java.lang.String)
        - locked &lt;0xf819a970&gt; (a java.lang.String)

"Thread1" prio=10 tid=0x000d6c00 nid=0xa waiting for monitor entry [0xf37ff000..0xf37ffbc0]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a970&gt; (a java.lang.String)
        - locked &lt;0xf819a938&gt; (a java.lang.String)

"Low Memory Detector" daemon prio=10 tid=0x000c7800 nid=0x8 runnable [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"CompilerThread0" daemon prio=10 tid=0x000c5400 nid=0x7 waiting on condition [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" daemon prio=10 tid=0x000c4400 nid=0x6 waiting on condition [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" daemon prio=10 tid=0x000b2800 nid=0x5 in Object.wait() [0xf3f7f000..0xf3f7f9c0]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0xf4000b40&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:116)
        - locked &lt;0xf4000b40&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:132)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)

"Reference Handler" daemon prio=10 tid=0x000ae000 nid=0x4 in Object.wait() [0xfe57f000..0xfe57f940]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0xf4000a40&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:485)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)
        - locked &lt;0xf4000a40&gt; (a java.lang.ref.Reference$Lock)

"VM Thread" prio=10 tid=0x000ab000 nid=0x3 runnable 

"VM Periodic Task Thread" prio=10 tid=0x000c8c00 nid=0x9 waiting on condition 
</code></pre><p>输出由多个由空行分隔的线程条目组成。首先打印Java线程（能够执行Java语言代码的线程），然后是有关VM内部线程的信息。每个线程条目均包含一个标题行，后跟线程堆栈跟踪。</p>
                     <p>标题行包含有关线程的以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>线程名称。</p>
                        </li>
                        <li>
                           <p>指示线程是否是守护程序线程。</p>
                        </li>
                        <li>
                           <p>线程优先级（prio）。</p>
                        </li>
                        <li>
                           <p>线程ID（tid），它是内存中线程结构的地址。</p>
                        </li>
                        <li>
                           <p>本机线程（nid）的ID。</p>
                        </li>
                        <li>
                           <p>线程状态，指示线程转储时线程在做什么。有关更多详细信息，请<a href="diagnostic-tools.html#GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI" title="下表列出了可能的线程状态，这些状态指示线程在转储时线程在做什么。">参见表2-6</a> 。
                           </p>
                        </li>
                        <li>
                           <p>地址范围，用于估计线程的有效堆栈区域。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSTGD229"></a><div class="props_rev_3"><a id="GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57" name="GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57"></a><h4 id="JSTGD-GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57" class="sect4">检测死锁</h4>
                  <div>
                     <p>Control + Break处理程序可用于检测线程中的死锁。</p>
                     <p>除了线程堆栈，Control + Break处理程序还执行死锁检测算法。如果检测到任何死锁，则Control + Break处理程序（如以下示例所示）在线程转储后输出有关每个死锁线程的其他信息。</p><pre class="oac_no_warn" dir="ltr">Found one Java-level deadlock:
=============================
"Thread2":
  waiting to lock monitor 0x000af330 (object 0xf819a938, a java.lang.String),
  which is held by "Thread1"
"Thread1":
  waiting to lock monitor 0x000af398 (object 0xf819a970, a java.lang.String),
  which is held by "Thread2"

Java stack information for the threads listed above:
===================================================
"Thread2":
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a938&gt; (a java.lang.String)
        - locked &lt;0xf819a970&gt; (a java.lang.String)
"Thread1":
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a970&gt; (a java.lang.String)
        - locked &lt;0xf819a938&gt; (a java.lang.String)

Found 1 deadlock.
</pre><p>如果JVM标志<code class="codeph">-XX:+PrintConcurrentLocks</code>设置后，Control + Break处理程序还将打印每个线程拥有的并发锁列表。
                     </p>
                  </div>
               </div><a id="JSTGD231"></a><div class="props_rev_3"><a id="GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51" name="GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51"></a><h4 id="JSTGD-GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51" class="sect4">堆摘要</h4>
                  <div>
                     <p>Control + Break处理程序可用于打印堆摘要。</p>
                     <p>以下示例显示了不同的世代（堆的区域），以及大小，使用的数量和地址范围。如果您还使用以下工具检查过程，则地址范围特别有用： <code class="codeph">pmap</code> 。
                     </p><pre class="pre codeblock"><code>Heap
 def new generation   total 1152K, used 435K [0x22960000, 0x22a90000, 0x22e40000
)
  eden space 1088K,  40% used [0x22960000, 0x229ccd40, 0x22a70000)
  from space 64K,   0% used [0x22a70000, 0x22a70000, 0x22a80000)
  to   space 64K,   0% used [0x22a80000, 0x22a80000, 0x22a90000)
 tenured generation   total 13728K, used 6971K [0x22e40000, 0x23ba8000, 0x269600
00)
   the space 13728K,  50% used [0x22e40000, 0x2350ecb0, 0x2350ee00, 0x23ba8000)
 compacting perm gen  total 12288K, used 1417K [0x26960000, 0x27560000, 0x2a9600
00)
   the space 12288K,  11% used [0x26960000, 0x26ac24f8, 0x26ac2600, 0x27560000)
    ro space 8192K,  62% used [0x2a960000, 0x2ae5ba98, 0x2ae5bc00, 0x2b160000)
    rw space 12288K,  52% used [0x2b160000, 0x2b79e410, 0x2b79e600, 0x2bd60000)
</code></pre><p>如果JVM标志<code>-XX:+PrintClassHistogram</code>设置后，Control + Break处理程序将生成堆直方图。
                     </p>
                  </div>
               </div>
            </div><a id="JSTGD233"></a><div class="props_rev_3"><a id="GUID-08957176-5459-4CEA-A141-D325D1204D54" name="GUID-08957176-5459-4CEA-A141-D325D1204D54"></a><h3 id="JSTGD-GUID-08957176-5459-4CEA-A141-D325D1204D54" class="sect3">本机操作系统工具</h3>
               <div>
                  <p>Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。</p>
                  <p>为每个工具提供了简要说明。有关更多详细信息，请参见操作系统文档（或Oracle Solaris和Linux操作系统的手册页）。</p>
                  <p>日志文件的格式和命令行实用程序的输出取决于版本。例如，如果您开发的脚本依赖于致命错误日志的格式，则如果日志文件的格式在将来的版本中更改，则相同的脚本可能无法工作。</p>
                  <p>您还可以在<a href="http://msdn.microsoft.com" target="_blank">MSDN开发人员网络</a>上搜索Windows特定的调试支持。
                  </p>
                  <p>以下各节介绍了故障排除技术和对一些本机操作系统工具的改进。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB" title="可用于解决问题的本机Windows工具列表。">基于操作系统的故障排除工具</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" title="Oracle Solaris 10操作系统包括DTrace工具，该工具允许动态跟踪操作系统内核和用户级程序。">DTrace工具</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B" title="Java HotSpot VM包含两个内置的探针提供程序hotspot和hotspot_jni。">Java HotSpot VM中的探针提供程序</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-792C5321-65E3-40CB-8F07-DE63F2142363" title="对Oracle Solaris 10操作系统中的pmap实用程序的改进。">pmap实用程序的改进</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" title="对Oracle Solaris 10操作系统中的pstack实用程序的改进。">pstack实用程序的改进</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD234"></a><div class="props_rev_3"><a id="GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" name="GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16"></a><h4 id="JSTGD-GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" class="sect4">DTrace工具</h4>
                  <div>
                     <p>Oracle Solaris 10操作系统包括DTrace工具，该工具允许动态跟踪操作系统内核和用户级程序。</p>
                     <p>该工具支持在系统调用进入和退出，用户模式功能进入和退出以及许多其他探测点的脚本。脚本使用<span class="bold">D编程语言</span>编写，该<span class="bold">语言</span>是具有安全指针语义的类C语言。这些脚本可以帮助您解决问题或解决性能问题。
                     </p>
                     <p>的<code class="codeph">dtrace</code> command是DTrace工具的通用前端。此命令提供了一个简单的界面，用于调用D语言，检索缓冲的跟踪数据以及访问一组基本例程以格式化和打印跟踪的数据。
                     </p>
                     <p>您可以使用D语言编写自己的自定义DTrace脚本，或者下载并使用各种站点上已经可用的许多脚本中的一个或多个。</p>
                     <p>探针由称为提供程序的内核模块交付和检测。探针提供程序提供的跟踪类型包括用户指令跟踪，函数边界跟踪，内核锁定检测，配置文件中断，系统调用跟踪等等。如果您编写自己的脚本，则使用D语言来启用探针。该语言还允许条件跟踪和输出格式化。</p>
                     <p>您可以使用<code class="codeph">dtrace -l</code>命令以探索Oracle Solaris操作系统上可用的提供程序和探针集。
                     </p>
                     <p>DTraceToolkit是由Open Oracle Solaris DTrace社区开发的有用文档的集合。请参阅<a href="http://www.brendangregg.com/dtracetoolkit.html" target="_blank">DTraceToolkit</a> 。
                     </p>
                     <p>请参见《 <a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-intro/" target="_blank"><span class="italic">Solaris动态跟踪指南》</span></a> 。
                     </p>
                  </div>
               </div><a id="JSTGD235"></a><div class="props_rev_3"><a id="GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B" name="GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B"></a><h4 id="JSTGD-GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B" class="sect4">Java HotSpot VM中的探针提供程序</h4>
                  <div>
                     <p>Java HotSpot VM包含两个内置的探针提供程序<code class="codeph">hotspot</code>和<code class="codeph">hotspot_jni</code> 。
                     </p>
                     <p>这些提供程序提供的探针可用于监视VM以及正在运行的Java应用程序的内部状态和活动。</p>
                     <p>JVM探针提供程序可以分类如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>VM生命周期：VM初始化开始和结束，以及VM关闭</p>
                        </li>
                        <li>
                           <p>线程生命周期：线程的开始和停止，线程名称，线程ID等</p>
                        </li>
                        <li>
                           <p>类加载：Java类的加载和卸载</p>
                        </li>
                        <li>
                           <p>垃圾收集：系统范围或内存池中垃圾收集的开始和停止</p>
                        </li>
                        <li>
                           <p>方法编译：方法编译的开始和结束以及方法的加载和卸载</p>
                        </li>
                        <li>
                           <p>监视器探针：等待事件，通知事件，竞争的监视器进入和退出</p>
                        </li>
                        <li>
                           <p>应用程序跟踪：方法的输入和返回，Java对象的分配</p>
                        </li>
                     </ul>
                     <p>为了从本机代码调用到Java代码，本机代码必须通过JNI接口进行调用。的<code class="codeph">hotspot_jni</code> provider对于JNI接口提供的用于调用Java代码和检查VM状态的每种方法，在入口点和返回点管理DTrace探针。</p>
                     <p>在探测点，您可以使用<span class="apiname">ustack</span>内置函数来打印当前线程的堆栈跟踪。除了C / C ++本机函数名称外，此函数还会打印Java方法名称。以下示例是一个简单的D脚本，该脚本在线程调用<span class="apiname">read</span>系统调用时打印完整的堆栈跟踪。
                     </p><pre class="pre codeblock"><code>#!/usr/sbin/dtrace -s
syscall::read:entry 
/pid == $1 &amp;&amp; tid == 1/ {    
   ustack(50, 0x2000);
}
</code></pre><p>上一个示例中的脚本存储在一个名为<code class="codeph">read.d</code>并通过指定要跟踪的Java进程的PID来运行，如以下示例所示。
                     </p><pre class="pre codeblock"><code>read.d <span class="italic"><code class="codeph">pid</code></span>
</code></pre><p>如果您的Java应用程序生成了很多I / O或有一些意外的延迟，那么DTrace工具及其<span class="apiname">ustack（）</span>操作可以帮助您诊断问题。
                     </p>
                  </div>
               </div><a id="JSTGD238"></a><div class="props_rev_3"><a id="GUID-792C5321-65E3-40CB-8F07-DE63F2142363" name="GUID-792C5321-65E3-40CB-8F07-DE63F2142363"></a><h4 id="JSTGD-GUID-792C5321-65E3-40CB-8F07-DE63F2142363" class="sect4">pmap实用程序的改进</h4>
                  <div>
                     <p>的改进<code class="codeph">pmap</code> Oracle Solaris 10操作系统中的实用程序。
                     </p>
                     <p>的<code class="codeph">pmap</code>在Oracle Solaris 10操作系统中改进了该实用程序，以打印带有文本的堆栈段<code class="codeph">[stack]</code> 。该文本可帮助您轻松找到堆栈。
                     </p>
                     <p>以下示例显示了具有改进功能的堆栈跟踪<code class="codeph">pmap</code>效用。
                     </p><pre class="pre codeblock"><code>19846:    /net/myserver/export1/user/j2sdk6/bin/java -Djava.endorsed.d
00010000      72K r-x--  /export/disk09/jdk/6/rc/b63/binaries/solsparc/bin/java
00030000      16K rwx--  /export/disk09/jdk/6/rc/b63/binaries/solsparc/bin/java
00034000   32544K rwx--    [ heap ]
D1378000      32K rwx-R    [ stack tid=44 ]
D1478000      32K rwx-R    [ stack tid=43 ]
D1578000      32K rwx-R    [ stack tid=42 ]
D1678000      32K rwx-R    [ stack tid=41 ]
D1778000      32K rwx-R    [ stack tid=40 ]
D1878000      32K rwx-R    [ stack tid=39 ]
D1974000      48K rwx-R    [ stack tid=38 ]
D1A78000      32K rwx-R    [ stack tid=37 ]
D1B78000      32K rwx-R    [ stack tid=36 ]
[.. more lines removed here to reduce output ..]
FF370000       8K r-x--  /usr/lib/libsched.so.1
FF380000       8K r-x--  /platform/sun4u-us3/lib/libc_psr.so.1
FF390000      16K r-x--  /lib/libthread.so.1
FF3A4000       8K rwx--  /lib/libthread.so.1
FF3B0000       8K r-x--  /lib/libdl.so.1
FF3C0000     168K r-x--  /lib/ld.so.1
FF3F8000       8K rwx--  /lib/ld.so.1
FF3FA000       8K rwx--  /lib/ld.so.1
FFB80000      24K -----    [ anon ]
FFBF0000      64K rwx--    [ stack ]
 total    167224K
</code></pre></div>
               </div><a id="JSTGD240"></a><div class="props_rev_3"><a id="GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" name="GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A"></a><h4 id="JSTGD-GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" class="sect4">pstack实用程序的改进</h4>
                  <div>
                     <p>的改进<code class="codeph">pstack</code> Oracle Solaris 10操作系统中的实用程序。
                     </p>
                     <p>在Oracle Solaris 10操作系统之前， <code class="codeph">pstack</code>实用程序不支持Java。它为解释的和编译的Java方法打印十六进制地址。
                     </p>
                     <p>从Oracle Solaris 10操作系统开始， <code class="codeph">pstack</code>命令行工具从核心文件或实时进程中打印混合模式的堆栈跟踪（Java和C / C ++框架）。该实用程序为解释的，编译的和内联的Java方法打印Java方法名称。
                     </p>
                  </div>
               </div>
            </div><a id="JSTGD241"></a><div class="props_rev_3"><a id="GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" name="GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901"></a><h3 id="JSTGD-GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" class="sect3">自定义诊断工具</h3>
               <div>
                  <p>JDK具有广泛的API，可以开发自定义工具来观察，监视，分析，调试和诊断JRE中部署的应用程序中的问题。</p>
                  <p>新工具的开发超出了本文档的范围。相反，本节简要概述了可用的API。</p>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/" target="_blank">Java SE API规范</a>中描述了本节中提到的所有软件包。
                  </p>
                  <p>请参阅JDK下载中包含的示例和演示代码。</p>
                  <p>以下各节介绍了可作为自定义诊断工具进行故障排除的程序包，接口类和Java调试器。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6" title="java.lang.management软件包提供了用于监视和管理JVM和操作系统的管理接口。">java.lang.management软件包</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16" title="java.lang.instrument软件包提供了一些服务，这些服务允许Java编程语言代理检测运行在JVM上的程序。">java.lang.instrument包</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-86702778-D112-429D-8B2C-148384FCC4E0" title="java.lang。线程类有一个名为getAllStackTraces的静态方法，该方法返回所有活动线程的堆栈跟踪图。">java.lang。螺纹类</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" title="JVM工具接口（JVM TI）是本机（C / C ++）编程接口，可以由各种开发和监视工具使用。">JVM工具界面</a></p>
                     </li>
                     <li>
                        <p><a href="diagnostic-tools.html#GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" title="Java平台调试器体系结构（JPDA）是设计供调试器和类似调试器的工具使用的体系结构。">Java平台调试器架构</a></p>
                     </li>
                  </ul>
               </div><a id="JSTGD242"></a><div class="props_rev_3"><a id="GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" name="GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97"></a><h4 id="JSTGD-GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" class="sect4">Java平台调试器架构</h4>
                  <div>
                     <p>Java平台调试器体系结构（JPDA）是设计供调试器和类似调试器的工具使用的体系结构。</p>
                     <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html" target="_blank">Java Platform Debugger Architecture</a>由两个编程接口和一个有线协议组成：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Java虚拟机工具接口（JVM TI）是虚拟机的接口。请参阅<a href="diagnostic-tools.html#GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" title="JVM工具接口（JVM TI）是本机（C / C ++）编程接口，可以由各种开发和监视工具使用。">JVM工具界面</a> 。
                           </p>
                        </li>
                        <li>
                           <p>Java调试接口（JDI）在用户代码级别定义信息和请求。它是用于调试Java编程语言应用程序的纯Java编程语言接口。在JPDA中，JDI是正在调试的虚拟机的调试器进程中的远程视图。它是由前端实现的，在前端是类似于调试器的应用程序（例如，IDE，调试器，跟踪器或监视工具）。参见模块<a href="https://docs.oracle.com/javase/10/docs/api/jdk.jdi-summary.html" target="_blank"><span class="apiname">jdk.jdi</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jdwp/jdwp-spec.html" target="_blank">Java调试线协议（JDWP）</a>定义了在正在调试的进程和实现JDI的调试器前端之间传输的信息和请求的格式。</p>
                        </li>
                     </ul>
                     <p>的<code class="codeph">jdb</code> JDK中包含实用程序作为示例命令行调试器。的<code class="codeph">jdb</code>实用程序使用JDI启动或连接到目标VM。请参见<a href="diagnostic-tools.html#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="jdb实用程序作为示例命令行调试器包含在JDK中。jdb实用程序使用Java调试接口（JDI）来启动或连接到目标JVM。">jdb Utility</a> 。
                     </p>
                     <p>除了传统的调试器类型的工具之外，JDI还可以用于开发工具，以帮助事后诊断和需要工具以非合作方式连接到流程（例如，挂起的流程）的场景。</p>
                  </div>
               </div>
            </div><a id="JSTGD244"></a><a id="JSTGD243"></a><div class="props_rev_3"><a id="GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37" name="GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37"></a><h3 id="JSTGD-GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37" class="sect3">NMT内存类别</h3>
               <div>
                  <p>NMT使用的本机内存跟踪内存类别列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC" title="下表描述了本机内存跟踪内存类别">表2-1说明</a>了NMT使用的本机内存类别。这些类别可能会随着发布而改变。
                  </p>
                  <div class="tblformal" id="GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC">
                     <p class="titleintable">表2-1本机内存跟踪内存类别</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="本机内存跟踪内存类别" width="100%" border="1" summary="This table describes native memory tracking memory categories" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e4241">类别</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e4244">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4249" headers="d2739e4241 ">
                                 <p>Java堆</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4249 d2739e4244 ">
                                 <p>对象所在的堆</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4256" headers="d2739e4241 ">
                                 <p>类</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4256 d2739e4244 ">
                                 <p>类元数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4263" headers="d2739e4241 ">
                                 <p>码</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4263 d2739e4244 ">
                                 <p>生成的代码</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4270" headers="d2739e4241 ">
                                 <p>GC</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4270 d2739e4244 ">
                                 <p>GC使用的数据，例如卡表</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4277" headers="d2739e4241 ">
                                 <p>编译器</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4277 d2739e4244 ">
                                 <p>生成代码时编译器使用的内存跟踪</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4284" headers="d2739e4241 ">
                                 <p>符号</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4284 d2739e4244 ">
                                 <p>符号</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4291" headers="d2739e4241 ">
                                 <p>记忆追踪</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4291 d2739e4244 ">
                                 <p>NMT使用的内存。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4298" headers="d2739e4241 ">
                                 <p>合并免费块</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4298 d2739e4244 ">
                                 <p>竞技场块池中的块所使用的内存</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4305" headers="d2739e4241 ">
                                 <p>共享课程空间</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4305 d2739e4244 ">
                                 <p>内存映射到类数据共享存档</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4312" headers="d2739e4241 ">
                                 <p>线</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4312 d2739e4244 ">
                                 <p>线程使用的内存，包括线程数据结构，资源区域，句柄区域等。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4319" headers="d2739e4241 ">
                                 <p>线程堆栈</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4319 d2739e4244 ">
                                 <p>线程堆栈。它被标记为已提交的内存，但是可能不会被操作系统完全提交。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4327" headers="d2739e4241 ">
                                 <p>内部</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4327 d2739e4244 ">
                                 <p>不适合先前类别的内存，例如命令行解析器使用的内存，JVMTI，属性等。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4334" headers="d2739e4241 ">
                                 <p>未知</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4334 d2739e4244 ">
                                 <p>无法确定内存类别时。</p>
                                 <p>竞技场：将竞技场用作堆栈或值对象时</p>
                                 <p>虚拟内存：类型信息尚未到达时</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD246"></a><a id="JSTGD245"></a><div class="sect2"><a id="GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3" name="GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3"></a><h3 id="JSTGD-GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3" class="sect3">事后诊断工具</h3>
               <div>
                  <p>可以对应用程序和Java HotSpot VM之间的问题进行事后诊断的工具和选项的列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3__BABIEHBC" title="下表包含用于对应用程序和Java HotSpot VM之间的问题进行事后诊断的工具和选项的列表，并附有说明。">表2-2</a>总结了为事后诊断设计的选项和工具。如果应用程序崩溃，则可以在崩溃时或以后使用崩溃转储中的信息来使用这些选项和工具来获取其他信息。
                  </p>
                  <div class="tblformal" id="GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3__BABIEHBC">
                     <p class="titleintable">表2-2验尸诊断工具</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="事后诊断工具" width="100%" border="1" summary="This table contains a list of tools and options for post-mortem diagnostics of problems between the application and the Java HotSpot VM, with their descriptions." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e4380">工具或选件</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e4383">说明和用法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4388" headers="d2739e4380 ">
                                 <p>致命错误日志</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4388 d2739e4383 ">
                                 <p>当发生不可恢复的（致命）错误时，将创建一个错误日志。该文件包含发生致命错误时获得的信息。在许多情况下，它是检查何时发生崩溃的第一项。请参阅<a href="fatal-error-log.html#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="描述致命错误日志，其位置和内容。">致命错误日志</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4401" headers="d2739e4380 ">
                                 <p><code class="codeph">-XX:+HeapDumpOnOutOfMemoryError</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4401 d2739e4383 ">
                                 <p>此命令行选项指定当VM检测到本机内存不足错误时生成堆转储。请参见<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDFDIJI">-XX：HeapDumpOnOutOfMemoryError选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4413" headers="d2739e4380 ">
                                 <p><code class="codeph">-XX:OnError</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4413 d2739e4383 ">
                                 <p>此命令行选项指定发生致命错误时要执行的一系列用户提供的脚本或命令。例如，在Windows上，此选项可以执行命令以强制崩溃转储。此选项在未配置事后调试器的系统上非常有用。请参见<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDFEJBB">-XX：OnError选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4425" headers="d2739e4380 ">
                                 <p><code class="codeph">-XX:+ShowMessageBoxOnError</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4425 d2739e4383 ">
                                 <p>发生致命错误时，此命令行选项将挂起进程。根据用户的响应，该选项可以启动本机调试器（例如， <code class="codeph">dbx</code> ， <code class="codeph">gdb</code> ， <code class="codeph">msdev</code> ）以附加到VM。请参阅<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDJIEHH">-XX：ShowMessageBoxOnError选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4446" headers="d2739e4380 ">
                                 <p>其他<code class="codeph">-XX</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4446 d2739e4383 ">
                                 <p>其他几个<code class="codeph">-XX</code>命令行选项在故障排除中很有用。请参阅<a href="command-line-options1.html#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDHGIDJ">其他-XX选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4462" headers="d2739e4380 ">
                                 <p><code class="codeph">jdb</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4462 d2739e4383 ">
                                 <p>调试器支持包括<code class="codeph">AttachingConnector</code> ， 这使得<code class="codeph">jdb</code>和其他Java语言调试器附加到核心文件。当试图了解崩溃时每个线程在做什么时，这很有用。请参见<a href="diagnostic-tools.html#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="jdb实用程序作为示例命令行调试器包含在JDK中。jdb实用程序使用Java调试接口（JDI）来启动或连接到目标JVM。">jdb Utility</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4489" headers="d2739e4380 ">
                                 <p><code class="codeph">jinfo</code>效用</p>
                                 <p>（仅在Oracle Solaris和Linux操作系统上进行事后使用）</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4489 d2739e4383 ">
                                 <p>该实用程序可以从崩溃中获取的核心文件或使用以下命令获取的核心文件中获取配置信息： <code class="codeph">gcore</code>效用。请参阅<a href="diagnostic-tools.html#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="jinfo命令行实用程序从正在运行的Java进程或故障转储中获取配置信息，并打印用于启动JVM的系统属性或命令行标志。">jinfo实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4512" headers="d2739e4380 ">
                                 <p><code class="codeph">jmap</code>效用</p>
                                 <p>（仅在Oracle Solaris和Linux操作系统上进行事后使用）</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4512 d2739e4383 ">
                                 <p>该实用程序可以从崩溃中获取的核心文件或使用以下命令获取的核心文件中获取内存映射信息，包括堆直方图<code class="codeph">gcore</code>效用。请参阅<a href="diagnostic-tools.html#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="jmap命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。">jmap实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4535" headers="d2739e4380 ">
                                 <p><code class="codeph">jsadebugd</code>守护程序</p>
                                 <p>（仅限Oracle Solaris和Linux操作系统）</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4535 d2739e4383 ">
                                 <p>可维护性代理调试守护程序（ <code class="codeph">jsadebugd</code> ）附加到Java进程或核心文件，并充当调试服务器。请参阅<a href="diagnostic-tools.html#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="Java Serviceability Agent调试守护程序（jsadebugd）附加到Java进程或核心文件，并充当调试服务器。">jsadebugd守护程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4558" headers="d2739e4380 ">
                                 <p><code class="codeph">jstack</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4558 d2739e4383 ">
                                 <p>该实用程序可以从Java进程获取Java和本机堆栈信息。在Oracle Solaris和Linux操作系统上，该实用程序还可以从核心文件或远程调试服务器中获取信息。请参阅<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4579" headers="d2739e4380 ">
                                 <p>本机工具</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4579 d2739e4383 ">
                                 <p>每个操作系统都有可用于事后诊断的本机工具和实用程序。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD248"></a><a id="JSTGD247"></a><div class="sect2"><a id="GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B" name="GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B"></a><h3 id="JSTGD-GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B" class="sect3">挂件工艺工具</h3>
               <div>
                  <p>用于在挂起的过程中诊断应用程序和Java HotSpot VM之间的问题的工具和选项的列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B__BABIFDCH" title="下表包含用于在挂起进程的情况下诊断应用程序和Java HotSpot VM之间的问题的工具和选项的列表，并附有说明。">表2-3</a>总结了可以在涉及死机或死锁进程的方案中使用的选项和工具。这些工具不需要任何特殊选项即可启动应用程序。
                  </p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。建议使用最新的实用程序， <code class="codeph">jcmd</code> ，而不是以前的<code class="codeph">jstack</code> ， <code class="codeph">jinfo,</code>和<code class="codeph">jmap</code>用于增强诊断和降低性能开销的实用程序。
                  </p>
                  <div class="tblformal" id="GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B__BABIFDCH">
                     <p class="titleintable">表2-3挂起ProcessTools</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="挂式工艺工具" width="100%" border="1" summary="This table contains a list of tools and options for diagnosing problems between the application and the Java HotSpot VM in case of a hung process, with their descriptions." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e4643">工具或选件</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e4646">说明和用法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4651" headers="d2739e4643 ">
                                 <p>Ctrl + Break处理程序</p>
                                 <p>（按Control + \或<code class="codeph">kill -QUIT <span class="variable" translate="no">pid</span></code>在Oracle Solaris和Linux操作系统上，以及Windows上的Control + Break）</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4651 d2739e4646 ">
                                 <p>此组合键执行线程转储和死锁检测。Ctrl + Break处理程序可以选择打印并发锁及其所有者的列表以及堆直方图。请参阅<a href="diagnostic-tools.html#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="在操作系统（例如Oracle Solaris或Linux或Windows）上的应用程序控制台上按Control键和反斜杠（\）键的结果。">Control + Break Handler</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4671" headers="d2739e4643 ">
                                 <p><code class="codeph">jcmd</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4671 d2739e4646 ">
                                 <p>此实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java飞行记录（JFR）很有用。JFR用于故障排除和诊断飞行记录事件。请参阅<a href="diagnostic-tools.html#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="jcmd实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Recording，故障排除和诊断JVM和Java应用程序很有用。">jcmd实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4689" headers="d2739e4643 ">
                                 <p><code class="codeph">jdb</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4689 d2739e4646 ">
                                 <p>调试器支持包括连接器，该连接器允许<code class="codeph">jdb</code>以及附加到进程的其他Java语言调试器。这可以帮助显示在挂起或死锁时每个线程在做什么。请参见<a href="diagnostic-tools.html#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="jdb实用程序作为示例命令行调试器包含在JDK中。jdb实用程序使用Java调试接口（JDI）来启动或连接到目标JVM。">jdb Utility</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4713" headers="d2739e4643 ">
                                 <p><code class="codeph">jinfo</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4713 d2739e4646 ">
                                 <p>该实用程序可以从Java进程获取配置信息。请参阅<a href="diagnostic-tools.html#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="jinfo命令行实用程序从正在运行的Java进程或故障转储中获取配置信息，并打印用于启动JVM的系统属性或命令行标志。">jinfo实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4731" headers="d2739e4643 ">
                                 <p><code class="codeph">jmap</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4731 d2739e4646 ">
                                 <p>该实用程序可以从Java进程获取内存映射信息，包括堆直方图。在Oracle Solaris和Linux操作系统上， <code class="codeph">-F</code>如果进程挂起，则可以使用该选项。请参阅<a href="diagnostic-tools.html#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="jmap命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。">jmap实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4752" headers="d2739e4643 ">
                                 <p><code class="codeph">jsadebugd</code>守护程序</p>
                                 <p>（仅限Oracle Solaris和Linux操作系统）</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4752 d2739e4646 ">
                                 <p>可维护性代理调试守护程序（ <code class="codeph">jsadebugd</code> ）附加到Java进程或核心文件，并充当调试服务器。请参阅<a href="diagnostic-tools.html#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="Java Serviceability Agent调试守护程序（jsadebugd）附加到Java进程或核心文件，并充当调试服务器。">jsadebugd守护程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4775" headers="d2739e4643 ">
                                 <p><code class="codeph">jstack</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4775 d2739e4646 ">
                                 <p>该实用程序可以从Java进程获取Java和本机堆栈信息。请参阅<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4796" headers="d2739e4643 ">
                                 <p>本机工具</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4796 d2739e4646 ">
                                 <p>每个操作系统都有本机工具和实用程序，它们在挂起或死锁情况下很有用。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD250"></a><a id="JSTGD249"></a><div class="sect2"><a id="GUID-90B85B8D-DCFA-4094-9A85-218D467222B0" name="GUID-90B85B8D-DCFA-4094-9A85-218D467222B0"></a><h3 id="JSTGD-GUID-90B85B8D-DCFA-4094-9A85-218D467222B0" class="sect3">监控工具</h3>
               <div>
                  <p>监视正在运行的应用程序和检测问题的工具和选项的列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-90B85B8D-DCFA-4094-9A85-218D467222B0__BABFCEHE" title="下表包含工具和选项的列表，这些工具和选项用于监视正在运行的应用程序以及检测应用程序与Java HotSpot VM之间发生的问题及其说明。">表2-4</a>中列出的工具旨在监视正在运行的应用程序。
                  </p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。建议使用最新的实用程序， <code class="codeph">jcmd</code> ，而不是以前的<code class="codeph">jstack</code> ， <code class="codeph">jinfo,</code>和<code class="codeph">jmap</code>用于增强诊断和降低性能开销的实用程序。
                  </p>
                  <div class="tblformalwide" id="GUID-90B85B8D-DCFA-4094-9A85-218D467222B0__BABFCEHE">
                     <p class="titleintable">表2-4监控工具</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="监控工具" width="100%" border="1" summary="This table contains a list of tools and options for monitoring running applications and detect problems that occur between the application and the Java HotSpot VM, with their descriptions." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e4861">工具或选件</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e4864">说明和用法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4869" headers="d2739e4861 ">
                                 <p>Java任务控制</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4869 d2739e4864 ">
                                 <p>Java Mission Control（JMC）是适用于HotSpot JVM的新JDK分析和诊断工具平台。它是用于高性能的基本监视，管理和生产时间配置文件和诊断的工具套件。Java Mission Control最大限度地减少了性能分析开销，而性能开销通常是性能分析工具遇到的问题。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4876" headers="d2739e4861 ">
                                 <p><code class="codeph">jcmd utility</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4876 d2739e4864 ">
                                 <p>该实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Records很有用。JFR用于通过飞行记录事件对JVM和Java应用程序进行故障排除和诊断。请参阅<a href="diagnostic-tools.html#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="jcmd实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java Flight Recording，故障排除和诊断JVM和Java应用程序很有用。">jcmd实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4893" headers="d2739e4861 ">
                                 <p>JConsole实用程序</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4893 d2739e4864 ">
                                 <p>该实用程序是基于Java管理扩展（JMX）的监视工具。该工具使用Java虚拟机中的内置JMX工具来提供有关正在运行的应用程序的性能和资源消耗的信息。参见<a href="diagnostic-tools.html#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="JDK下载中包含的另一个有用的工具是JConsole监视工具。该工具与JMX兼容。该工具使用JVM中的内置JMX工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">JConsole</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4909" headers="d2739e4861 ">
                                 <p><code class="codeph">jmap</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4909 d2739e4864 ">
                                 <p>该实用程序可以从Java进程，核心文件或远程调试服务器获取内存映射信息，包括堆直方图。请参阅<a href="diagnostic-tools.html#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="jmap命令行实用程序为正在运行的VM或核心文件打印与内存相关的统计信息。">jmap实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4927" headers="d2739e4861 ">
                                 <p><code class="codeph">jps</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4927 d2739e4864 ">
                                 <p>该实用程序列出了目标系统上已检测到的Java HotSpot VM。该实用程序在嵌入式VM的环境中非常有用，也就是说，它是使用JNI Invocation API而不是使用JNI Invocation API启动的。 <code class="codeph">java</code>发射器。请参阅<a href="diagnostic-tools.html#GUID-FC269C18-470F-441E-9564-7EEA182F8125" title="jps实用程序列出了目标系统上当前用户的每个已检测的Java HotSpot VM。">jps实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4948" headers="d2739e4861 ">
                                 <p><code class="codeph">jstack</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4948 d2739e4864 ">
                                 <p>该实用程序可以从Java进程获取Java和本机堆栈信息。在Oracle Solaris和Linux操作系统上，该实用程序还可以从核心文件或远程调试服务器中获取信息。请参阅<a href="diagnostic-tools.html#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="使用jcmd实用程序而不是jcmd实用程序来诊断JVM和Java应用程序的问题。">jstack实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4969" headers="d2739e4861 ">
                                 <p><code class="codeph">jstat</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4969 d2739e4864 ">
                                 <p>该实用程序使用Java中的内置工具来提供有关正在运行的应用程序的性能和资源消耗的信息。诊断性能问题（尤其是与堆大小和垃圾回收相关的问题）时可以使用该工具。请参阅<a href="diagnostic-tools.html#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="jstat实用程序使用Java HotSpot VM中的内置工具来提供有关正在运行的应用程序的性能和资源消耗的信息。">jstat实用程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e4987" headers="d2739e4861 ">
                                 <p><code class="codeph">jstatd</code>守护程序</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e4987 d2739e4864 ">
                                 <p>该工具是一个远程方法调用（RMI）服务器应用程序，它监视已检测Java虚拟机的创建和终止，并提供一个接口，以允许远程监视工具连接到在本地主机上运行的VM。请参见<a href="diagnostic-tools.html#GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" title="jstatd守护程序是一个RMI服务器应用程序，它监视每个检测到的Java HotSpot的创建和终止，并提供一个接口，以允许远程监视工具连接到在本地主机上运行的JVM。">jstatd守护程序</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5005" headers="d2739e4861 ">
                                 <p><code class="codeph">visualgc</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5005 d2739e4864 ">
                                 <p>该实用程序提供了垃圾收集系统的图形视图。与<code class="codeph">jstat</code> ，它使用Java HotSpot VM的内置工具。请参阅<a href="diagnostic-tools.html#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="visualgc工具提供了垃圾收集（GC）系统的图形视图。">visualgc工具</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5026" headers="d2739e4861 ">
                                 <p>本机工具</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5026 d2739e4864 ">
                                 <p>每个操作系统都有本机工具和实用程序，可用于监视目的。例如，Oracle Solaris 10操作系统中引入的动态跟踪（DTrace）功能执行高级监视。请参阅本<a href="diagnostic-tools.html#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="Windows，Linux和Oracle Solaris操作系统上可用的本机工具列表，这些工具可用于故障排除或监视。">机操作系统工具</a> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD252"></a><a id="JSTGD251"></a><div class="sect2"><a id="GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC" name="GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC"></a><h3 id="JSTGD-GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC" class="sect3">其他工具，选项，变量和属性</h3>
               <div>
                  <p>可帮助诊断问题的常规故障排除工具，选项，变量和属性的列表。</p>
                  <p>除了针对特定类型问题设计的工具之外， <a href="diagnostic-tools.html#GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC__BABGFGEE" title="下表包含常规疑难解答工具和选项的列表，这些工具和选项不是针对应用程序和Java HotSpot VM之间发生的特定类型的问题而设计的，并提供了说明。">表2-5中</a>列出的工具，选项，变量和属性还可以帮助诊断其他问题。
                  </p>
                  <p>Java Mission Control，Java Flight Recorder和<code class="codeph">jcmd</code>该实用程序可用于诊断JVM和Java应用程序的问题。建议使用最新的实用程序， <code class="codeph">jcmd</code> ，而不是以前的<code class="codeph">jstack</code> ， <code class="codeph">jinfo,</code>和<code class="codeph">jmap</code>用于增强诊断和降低性能开销的实用程序。
                  </p>
                  <div class="tblformal" id="GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC__BABGFGEE">
                     <p class="titleintable">表2-5常规故障排除工具和选项</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="常规故障排除工具和选项" width="100%" border="1" summary="This table contains a list of general troubleshooting tools and options which are not designed for specific types of problems that occur between the application and the Java HotSpot VM, with their descriptions." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e5092">工具或选件</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e5095">说明和用法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5100" headers="d2739e5092 ">
                                 <p>Java任务控制</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5100 d2739e5095 ">
                                 <p>Java Mission Control（JMC）是适用于HotSpot JVM的新JDK分析和诊断工具平台。它是用于高性能的基本监视，管理和生产时间配置文件和诊断的工具套件。Java Mission Control最大限度地减少了性能分析开销，而性能开销通常是性能分析工具遇到的问题。请参阅<a href="https://docs.oracle.com/javacomponents/index.html" target="_blank">Java Mission Control</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5111" headers="d2739e5092 ">
                                 <p><code class="codeph">jcmd</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5111 d2739e5095 ">
                                 <p>此实用程序用于将诊断命令请求发送到JVM，这些请求对于控制Java飞行记录（JFR）很有用。JFR用于通过飞行记录事件对JVM和Java应用程序进行故障排除和诊断。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5120" headers="d2739e5092 ">
                                 <p><code class="codeph">jinfo</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5120 d2739e5095 ">
                                 <p>该实用程序可以为指定的Java进程动态设置，取消设置和更改某些JVM标志的值。在Oracle Solaris和Linux操作系统上，它也可以打印配置信息。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5129" headers="d2739e5092 ">
                                 <p><code class="codeph">jrunscript</code>效用</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5129 d2739e5095 ">
                                 <p>此实用程序是命令行脚本外壳，它支持交互式和批处理模式脚本执行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5138" headers="d2739e5092 ">
                                 <p>Oracle Solaris Studio <code class="codeph">dbx</code>调试器</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5138 d2739e5095 ">
                                 <p>这是一个交互式的命令行调试工具，使您可以完全控制程序的动态执行，包括停止程序和检查其状态。有关详细信息，请参见最新<code class="codeph">dbx</code>位于<a href="https://docs.oracle.com/cd/E24457_01/html/E21993/blabb.html#scrolltoc" target="_blank">Oracle Solaris Studio程序调试的</a>文档。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5155" headers="d2739e5092 ">
                                 <p>Oracle Solaris Studio性能分析器</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5155 d2739e5095 ">
                                 <p>该工具可以帮助您评估代码的性能，识别潜在的性能问题，并找出发生问题的代码部分。可以从命令行或图形用户界面使用Performance Analyzer。有关详细信息，请参见<a href="https://docs.oracle.com/cd/E18659_01/html/821-1379/afabb.html#scrolltoc" target="_blank">Oracle Solaris Studio Performance Analyzer</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5166" headers="d2739e5092 ">
                                 <p>Sun的数据空间分析：DProfile</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5166 d2739e5095 ">
                                 <p>该工具可洞察Sun计算系统中的数据流，帮助您确定软件和硬件中的瓶颈。Sun Studio 11编译器套件通过Performance Analyzer GUI支持DProfile。请参阅<a href="http://www.oracle.com/technetwork/server-storage/solaris/dtrace-tutorial-142317.html" target="_blank">DTrace或动态跟踪诊断工具</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5177" headers="d2739e5092 ">
                                 <p><code class="codeph">-Xcheck:jni</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5177 d2739e5095 ">
                                 <p>在诊断使用Java本机接口（JNI）或使用第三方库（例如某些JDBC驱动程序）的应用程序的问题时，此选项很有用。请参见<a href="command-line-options1.html#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDDEGBI">-Xcheck：jni选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5189" headers="d2739e5092 ">
                                 <p><code class="codeph">-verbose:class</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5189 d2739e5095 ">
                                 <p>此选项启用记录类加载和卸载。请参阅<a href="command-line-options1.html#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDJECGJ">-verbose：class选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5201" headers="d2739e5092 ">
                                 <p><code class="codeph">-verbose:gc</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5201 d2739e5095 ">
                                 <p>此选项启用垃圾收集信息的日志记录。请参阅<a href="command-line-options1.html#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDJIIFF">-verbose：gc选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5213" headers="d2739e5092 ">
                                 <p><code>-verbose:jni</code>选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5213 d2739e5095 ">
                                 <p>此选项启用JNI日志记录。请参阅<a href="command-line-options1.html#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDCHGEE">-verbose：jni选项</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5226" headers="d2739e5092 ">
                                 <p><code class="codeph">JAVA_TOOL_OPTIONS</code>环境变量</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5226 d2739e5095 ">
                                 <p>该环境变量允许您指定工具的初始化，特别是使用以下命令启动本机或Java编程语言代理： <code class="codeph">-agentlib</code>要么<code class="codeph">-javaagent</code>选项。请参阅<a href="environment-variables-and-system-properties.html#GUID-A91E7E21-2E91-48C4-89A4-836A7C0EE93B" title="本附录描述了环境变量和系统属性，它们对于排除Java HotSpot VM的问题很有用。">环境变量和系统属性</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5247" headers="d2739e5092 ">
                                 <p><code class="codeph">java.security.debug</code>系统属性</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5247 d2739e5095 ">
                                 <p>此系统属性控制安全性是否在执行期间检查Java打印跟踪消息的JRE。请参见<a href="environment-variables-and-system-properties.html#GUID-FE488B52-B0B6-48B6-B050-D58798F5242C" title="此系统属性控制Java运行时环境（JRE）的安全系统在执行期间是否打印跟踪消息。">java.security.debug系统属性</a> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD253"></a><div class="sect2"><a id="GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6" name="GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6"></a><h3 id="JSTGD-GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6" class="sect3">java.lang.management软件包</h3>
               <div>
                  <p>的<code class="codeph">java.lang.management</code>软件包提供了用于监视和管理JVM和操作系统的管理接口。
                  </p>
                  <p>具体来说，它涵盖以下系统的接口：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>类加载</p>
                     </li>
                     <li>
                        <p>汇编</p>
                     </li>
                     <li>
                        <p>垃圾收集</p>
                     </li>
                     <li>
                        <p>内存管理器</p>
                     </li>
                     <li>
                        <p>运行</p>
                     </li>
                     <li>
                        <p>线程数</p>
                     </li>
                  </ul>
                  <p>除了<code class="codeph">java.lang.management</code>软件包，JDK版本在<code class="codeph">com.sun.management</code>包。平台扩展包括一个管理界面，该管理界面可从垃圾收集器获取详细的统计信息，这些垃圾收集器将按周期执行收集。这些扩展还包括一个管理界面，用于从操作系统获取其他内存统计信息。
                  </p>
               </div>
            </div><a id="JSTGD254"></a><div class="sect2"><a id="GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16" name="GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16"></a><h3 id="JSTGD-GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16" class="sect3">java.lang.instrument包</h3>
               <div>
                  <p>的<code class="codeph">java.lang.instrument</code>软件包提供的服务允许Java编程语言代理检测运行在JVM上的程序。</p>
                  <p>工具由探查器，用于跟踪方法调用的工具等许多工具使用。该软件包可简化加载时间和动态检测。它还包括获取有关已加载类的信息和有关给定对象消耗的存储量的信息的方法。</p>
               </div>
            </div><a id="JSTGD255"></a><div class="sect2"><a id="GUID-86702778-D112-429D-8B2C-148384FCC4E0" name="GUID-86702778-D112-429D-8B2C-148384FCC4E0"></a><h3 id="JSTGD-GUID-86702778-D112-429D-8B2C-148384FCC4E0" class="sect3">java.lang。螺纹类</h3>
               <div>
                  <p>的<code class="codeph">java.lang.Thread</code>类有一个名为<span class="apiname">getAllStackTraces</span>的静态方法，该方法返回所有活动线程的堆栈跟踪图。
                  </p>
                  <p>的<code class="codeph">Thread</code>类还具有一个名为<span class="apiname">getState</span>的方法，该方法返回线程状态；状态由<code class="codeph">java.lang.Thread.State</code>列举。当您向应用程序添加诊断或监视功能时，这些方法会很有用。
                  </p>
               </div>
            </div><a id="JSTGD256"></a><div class="sect2"><a id="GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" name="GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A"></a><h3 id="JSTGD-GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" class="sect3">JVM工具界面</h3>
               <div>
                  <p>JVM工具接口（JVM TI）是本机（C / C ++）编程接口，可以由各种开发和监视工具使用。</p>
                  <p>JVM TI为需要访问VM状态的全部工具提供了接口，包括但不限于性能分析，调试，监视，线程分析和覆盖率分析工具。</p>
                  <p>依赖JVM TI的代理的一些示例如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Java调试线协议（JDWP）</p>
                     </li>
                     <li>
                        <p>的<code class="codeph">java.lang.instrument</code>包</p>
                     </li>
                  </ul>
                  <p>JVM TI的规范可以在<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html" target="_blank">JVM Tool Interface</a>文档中找到。
                  </p>
               </div>
            </div><a id="JSTGD257"></a><div class="sect2"><a id="GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7" name="GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7"></a><h3 id="JSTGD-GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7" class="sect3">jrunscript实用程序</h3>
               <div>
                  <p>的<code class="codeph">jrunscript</code>实用程序是命令行脚本外壳。
                  </p>
                  <p>它支持交互模式和批处理模式下的脚本执行。默认情况下，shell使用JavaScript，但是您可以指定其他任何脚本语言，并为其提供脚本引擎JAR文件的路径。 <code class="codeph">.class</code>文件。
                  </p>
                  <p>由于Java语言和脚本语言之间的沟通， <code class="codeph">jrunscript</code>实用程序支持探索性编程风格。
                  </p>
               </div>
            </div><a id="JSTGD258"></a><div class="sect2"><a id="GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" name="GUID-D3BBA20A-4777-44D2-BF04-05568AD49977"></a><h3 id="JSTGD-GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" class="sect3">jsadebugd守护程序</h3>
               <div>
                  <p>Java Serviceability Agent调试守护程序（ <code class="codeph">jsadebugd</code> ）附加到Java进程或核心文件，并充当调试服务器。
                  </p>
                  <p>该实用程序当前仅在Oracle Solaris和Linux操作系统上可用。远程客户端，例如<code class="codeph">jstack</code> ， <code class="codeph">jmap</code>和<code class="codeph">jinfo</code>可以使用Java远程方法调用（RMI）附加到服务器。
                  </p>
               </div>
            </div><a id="JSTGD259"></a><div class="sect2"><a id="GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" name="GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67"></a><h3 id="JSTGD-GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" class="sect3">jstatd守护程序</h3>
               <div>
                  <p>的<code class="codeph">jstatd</code>守护程序是一个RMI服务器应用程序，它监视每个检测到的Java HotSpot的创建和终止，并提供一个接口，以允许远程监视工具连接到在本地主机上运行的JVM。
                  </p>
                  <p>例如，此守护程序允许<code class="codeph">jps</code>列出远程系统上的进程的实用程序。
                  </p>
                  <div class="infoboxnote" id="GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67__GUID-72857E9D-A426-4854-BD5D-59AB363ECAC6">
                     <p class="notep1">注意：</p>
                     <p>无法在FAT32文件系统上访问该工具。</p>
                  </div>
               </div>
            </div><a id="JSTGD261"></a><a id="JSTGD260"></a><div class="sect2"><a id="GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA" name="GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA"></a><h3 id="JSTGD-GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA" class="sect3">线程转储的线程状态</h3>
               <div>
                  <p>线程转储的可能线程状态列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI" title="下表列出了可能的线程状态，这些状态指示线程在转储时线程在做什么。">表2-6</a>列出了使用<a href="diagnostic-tools.html#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="在操作系统（例如Oracle Solaris或Linux或Windows）上的应用程序控制台上按Control键和反斜杠（\）键的结果。">Control + Break Handler</a>进行线程转储的可能线程状态。
                  </p>
                  <div class="tblformal" id="GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI">
                     <p class="titleintable">表2-6线程转储的线程状态</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="线程转储的线程状态" width="100%" border="1" summary="This table lists the possible thread states which indicate what the thread was doing at the time of the thread dump." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e5542">线程状态</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e5545">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5550" headers="d2739e5542 ">
                                 <p>新</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5550 d2739e5545 ">
                                 <p>该线程尚未启动。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5557" headers="d2739e5542 ">
                                 <p>可运行</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5557 d2739e5545 ">
                                 <p>线程正在JVM中执行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5564" headers="d2739e5542 ">
                                 <p>已封锁</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5564 d2739e5545 ">
                                 <p>线程被阻止，等待监视器锁定。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5571" headers="d2739e5542 ">
                                 <p>等候</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5571 d2739e5545 ">
                                 <p>线程无限期地等待另一个线程执行特定操作。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5578" headers="d2739e5542 ">
                                 <p>TIMED_WAITING</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5578 d2739e5545 ">
                                 <p>线程正在等待另一个线程在指定的等待时间内执行操作。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5585" headers="d2739e5542 ">
                                 <p>已终止</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5585 d2739e5545 ">
                                 <p>线程已退出。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="JSTGD263"></a><a id="JSTGD264"></a><a id="JSTGD265"></a><a id="JSTGD262"></a><div class="sect2"><a id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB" name="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB"></a><h3 id="JSTGD-GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB" class="sect3">基于操作系统的故障排除工具</h3>
               <div>
                  <p>可用于解决问题的本机Windows工具列表。</p>
                  <p><a href="diagnostic-tools.html#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABIJHEH" title="下表包含可用于解决Java HotSpot VM问题的本机Windows工具列表。">表2-7</a>列出了Windows操作系统上可用的故障排除工具。
                  </p>
                  <div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABIJHEH">
                     <p class="titleintable">表2-7 Windows上的本机故障排除工具</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Windows上的本机故障排除工具" width="100%" border="1" summary="This table contains a list of native Windows tools which can be used for troubleshooting problems with the Java HotSpot VM." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e5629">工具</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e5632">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5637" headers="d2739e5629 ">
                                 <p><code class="codeph">dumpchk</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5637 d2739e5632 ">
                                 <p>命令行实用程序，用于验证是否正确创建了内存转储文件。该工具包含在Microsoft的Windows调试工具下载中。请参阅<a href="submit-bug-report.html#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="在Windows操作系统中，有三种故障转储类型：Dr.Watson日志文件，用户小型转储和Dr.Watson完整转储。">在Windows上收集故障转储</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5651" headers="d2739e5629 ">
                                 <p><code class="codeph">msdev</code>调试器</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5651 d2739e5632 ">
                                 <p>命令行实用程序，可用于启动Visual C ++和Win32调试器</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5660" headers="d2739e5629 ">
                                 <p><code class="codeph">userdump</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5660 d2739e5632 ">
                                 <p>用户模式过程转储程序包含在OEM支持工具下载中，该下载可从Microsoft网站下载。请参阅<a href="submit-bug-report.html#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="在Windows操作系统中，有三种故障转储类型：Dr.Watson日志文件，用户小型转储和Dr.Watson完整转储。">在Windows上收集故障转储</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5674" headers="d2739e5629 ">
                                 <p><code class="codeph">windbg</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5674 d2739e5632 ">
                                 <p>Windows调试器可用于调试Windows应用程序或崩溃转储。该工具包含在Microsoft的Windows调试工具下载中。请参阅<a href="submit-bug-report.html#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="在Windows操作系统中，有三种故障转储类型：Dr.Watson日志文件，用户小型转储和Dr.Watson完整转储。">在Windows上收集故障转储</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5688" headers="d2739e5629 ">
                                 <p><code class="codeph">/Md</code>和<code class="codeph">/Mdd</code>编译器选项</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5688 d2739e5632 ">
                                 <p>编译器选项自动包括对跟踪内存分配的额外支持</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="diagnostic-tools.html#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABECEAH" title="下表包含本机Linux工具的列表，可用于对Java HotSpot VM的问题进行故障排除。">表2-8</a>描述了Linux操作系统版本10中引入或改进的一些故障排除工具。
                  </p>
                  <div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABECEAH">
                     <p class="titleintable">表2-8 Linux上的本机故障排除工具</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Linux上的本机故障排除工具" width="100%" border="1" summary="This table contains a list of native Linux tools which can be used for troubleshooting problems with the Java HotSpot VM." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e5715">工具</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e5718">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5723" headers="d2739e5715 ">
                                 <p><code class="codeph">c++filt</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5723 d2739e5718 ">
                                 <p>Demangle C ++破坏了符号名称。该实用程序与本地C ++编译器套件一起提供： <code class="codeph">gcc</code>在Linux上。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5734" headers="d2739e5715 ">
                                 <p><code class="codeph">gdb</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5734 d2739e5718 ">
                                 <p>GNU调试器</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5742" headers="d2739e5715 ">
                                 <p><code class="codeph">libnjamd</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5742 d2739e5718 ">
                                 <p>内存分配跟踪</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5750" headers="d2739e5715 ">
                                 <p><code class="codeph">lsstack</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5750 d2739e5718 ">
                                 <p>打印线程堆栈（类似于<code class="codeph">pstack</code>在Oracle Solaris操作系统中）</p>
                                 <p>默认情况下，并非所有发行版都提供此工具。因此，您可能必须从“ <a href="http://sourceforge.net" target="_blank">开源下载”中</a>下载它。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5767" headers="d2739e5715 ">
                                 <p><code class="codeph">ltrace</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5767 d2739e5718 ">
                                 <p>库调用跟踪器（等效于<code class="codeph">truss -u</code>在Oracle Solaris操作系统中）</p>
                                 <p>默认情况下，并非所有发行版都提供此工具。因此，您可能必须从“ <a href="http://sourceforge.net" target="_blank">开源下载”中</a>下载它。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5784" headers="d2739e5715 ">
                                 <p><code class="codeph">mtrace</code>和<code class="codeph">muntrace</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5784 d2739e5718 ">
                                 <p>GNU <code class="codeph">malloc</code>示踪剂</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5798" headers="d2739e5715 ">
                                 <p><code class="codeph">proc</code>诸如<code class="codeph">pmap</code>和<code class="codeph">pstack</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5798 d2739e5718 ">
                                 <p>一些但不是全部<code class="codeph">proc</code> Oracle Solaris操作系统上的工具在Linux上具有等效的工具。对Linux的核心文件支持不如对Oracle Solaris操作系统的支持。例如， <code class="codeph">pstack</code>不适用于核心转储</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5818" headers="d2739e5715 ">
                                 <p><code class="codeph">strace</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5818 d2739e5718 ">
                                 <p>系统调用跟踪器（等效于<code class="codeph">truss -t</code>在Oracle Solaris操作系统中）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5829" headers="d2739e5715 ">
                                 <p><code class="codeph">top</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5829 d2739e5718 ">
                                 <p>显示最占用CPU的进程。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5837" headers="d2739e5715 ">
                                 <p><code class="codeph">vmstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5837 d2739e5718 ">
                                 <p>报告有关进程，内存，页面调度，块I / O，陷阱和CPU活动的信息。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="diagnostic-tools.html#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABCJBCG" title="下表包含本机Solaris OS工具的列表，可用于对Java HotSpot VM的问题进行故障排除。">表2-9</a>列出了Oracle Solaris操作系统上可用的故障排除工具。
                  </p>
                  <div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABCJBCG">
                     <p class="titleintable">表2-9 Oracle Solaris操作系统上的本机故障排除工具</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Solaris操作系统上的本机故障排除工具" width="100%" border="1" summary="This table contains a list of native Solaris OS tools which can be used for troubleshooting problems with the Java HotSpot VM." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d2739e5860">工具</th>
                              <th align="left" valign="bottom" width="69%" id="d2739e5863">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5868" headers="d2739e5860 ">
                                 <p><code class="codeph">coreadm</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5868 d2739e5863 ">
                                 <p>指定JVM生成的核心文件的名称和位置。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5876" headers="d2739e5860 ">
                                 <p><code class="codeph">cpustat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5876 d2739e5863 ">
                                 <p>使用CPU性能计数器监视系统行为。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5884" headers="d2739e5860 ">
                                 <p><code class="codeph">cputrack</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5884 d2739e5863 ">
                                 <p>使用CPU性能计数器监视进程和LWP行为。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5892" headers="d2739e5860 ">
                                 <p><code class="codeph">c++filt</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5892 d2739e5863 ">
                                 <p>Demangle C ++破坏了符号名称。该实用程序与本地C ++编译器套件一起提供： <code class="codeph">SUNWspro</code>在Oracle Solaris操作系统上。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5903" headers="d2739e5860 ">
                                 <p><code class="codeph">dtrace</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5903 d2739e5863 ">
                                 <p>DTrace在Oracle Solaris 10操作系统中引入，是一种动态跟踪编译器和跟踪实用程序。它可以执行内核功能，系统调用和用户功能的动态跟踪。该工具允许在入口，出口和其他探测点执行任意，安全的脚本。该脚本以类似于C的但安全的指针语义语言（称为D编程语言）编写。另请参见<a href="diagnostic-tools.html#GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" title="Oracle Solaris 10操作系统包括DTrace工具，该工具允许动态跟踪操作系统内核和用户级程序。">DTrace工具</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5917" headers="d2739e5860 ">
                                 <p><code class="codeph">gcore</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5917 d2739e5863 ">
                                 <p>强制进行进程的核心转储。写入核心转储后，该过程继续。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5925" headers="d2739e5860 ">
                                 <p><code class="codeph">intrstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5925 d2739e5863 ">
                                 <p>报告有关中断线程消耗的CPU的统计信息。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5933" headers="d2739e5860 ">
                                 <p><code class="codeph">iostat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5933 d2739e5863 ">
                                 <p>报告I / O统计信息。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5941" headers="d2739e5860 ">
                                 <p><code class="codeph">libumem</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5941 d2739e5863 ">
                                 <p>该库在Oracle Solaris 9操作系统更新3中引入，提供了快速，可扩展的对象缓存内存分配和广泛的调试支持。该工具可用于查找和修复内存管理错误。请参阅<a href="troubleshoot-memory-leaks.html#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="首次在Oracle Solaris 9操作系统更新3中引入libumem.so库和模块化调试器mdb可用于调试内存泄漏。">使用libumem工具查找泄漏</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5961" headers="d2739e5860 ">
                                 <p><code class="codeph">mdb</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5961 d2739e5863 ">
                                 <p>用于内核和用户应用程序以及崩溃转储的模块化调试器</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5969" headers="d2739e5860 ">
                                 <p><code class="codeph">netstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5969 d2739e5863 ">
                                 <p>显示各种与网络相关的数据结构的内容。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5978" headers="d2739e5860 ">
                                 <p><code class="codeph">pargs</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5978 d2739e5863 ">
                                 <p>打印过程参数，环境变量或辅助向量。长输出不会像其他命令那样被截断<code class="codeph">ps</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5989" headers="d2739e5860 ">
                                 <p><code class="codeph">pfiles</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5989 d2739e5863 ">
                                 <p>在进程文件描述符上打印信息。从Oracle Solaris 10操作系统开始，该工具还将打印文件名。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e5997" headers="d2739e5860 ">
                                 <p><code class="codeph">pldd</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e5997 d2739e5863 ">
                                 <p>打印进程加载的共享对象。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6005" headers="d2739e5860 ">
                                 <p><code class="codeph">pmap</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6005 d2739e5863 ">
                                 <p>进程或核心文件的打印内存布局，包括堆，数据和文本部分。从Oracle Solaris 10开始，堆栈段用文本清楚地标识<code class="codeph">[stack]</code>以及线程ID。请参阅<a href="diagnostic-tools.html#GUID-792C5321-65E3-40CB-8F07-DE63F2142363" title="对Oracle Solaris 10操作系统中的pmap实用程序的改进。">对pmap实用程序的改进</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6025" headers="d2739e5860 ">
                                 <p><code class="codeph">prstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6025 d2739e5863 ">
                                 <p>报告活动的Oracle Solaris操作系统进程的统计信息。（相似<code class="codeph">top</code> ）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6036" headers="d2739e5860 ">
                                 <p><code class="codeph">prun</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6036 d2739e5863 ">
                                 <p>将进程设置为运行模式（与<code class="codeph">pstop</code> ）。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6047" headers="d2739e5860 ">
                                 <p><code class="codeph">ps</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6047 d2739e5863 ">
                                 <p>列出所有进程。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6055" headers="d2739e5860 ">
                                 <p><code class="codeph">psig</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6055 d2739e5863 ">
                                 <p>列出进程的信号处理程序。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6063" headers="d2739e5860 ">
                                 <p><code class="codeph">pstack</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6063 d2739e5863 ">
                                 <p>打印给定进程或核心文件的线程堆栈。从Oracle Solaris 10操作系统开始，可以为Java框架打印Java方法名称。请参阅<a href="diagnostic-tools.html#GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" title="对Oracle Solaris 10操作系统中的pstack实用程序的改进。">对pstack实用程序的改进</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6080" headers="d2739e5860 ">
                                 <p><code class="codeph">pstop</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6080 d2739e5863 ">
                                 <p>停止该过程（挂起）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6088" headers="d2739e5860 ">
                                 <p><code class="codeph">ptree</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6088 d2739e5863 ">
                                 <p>打印包含给定PID的过程树。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6097" headers="d2739e5860 ">
                                 <p><code class="codeph">sar</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6097 d2739e5863 ">
                                 <p>系统活动报告者</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6105" headers="d2739e5860 ">
                                 <p><code class="codeph">sdtprocess</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6105 d2739e5863 ">
                                 <p>显示最占用CPU的进程。 （相似<code class="codeph">top</code> ）。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6116" headers="d2739e5860 ">
                                 <p><code class="codeph">sdtperfmeter</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6116 d2739e5863 ">
                                 <p>显示显示系统性能的图形（例如，CPU，磁盘和网络）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6124" headers="d2739e5860 ">
                                 <p><code class="codeph">top</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6124 d2739e5863 ">
                                 <p>显示最占用CPU的进程。该工具可作为Oracle Solaris操作系统的免费软件获得，但默认情况下未安装。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6132" headers="d2739e5860 ">
                                 <p><code class="codeph">trapstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6132 d2739e5863 ">
                                 <p>显示运行时陷阱统计信息（仅SPARC）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6140" headers="d2739e5860 ">
                                 <p><code class="codeph">truss</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6140 d2739e5863 ">
                                 <p>跟踪系统调用，用户模式功能和信号的进入和退出事件； （可选）在这些事件之一中停止该过程。该工具还可以打印系统调用和用户函数的参数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6148" headers="d2739e5860 ">
                                 <p><code class="codeph">vmstat</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6148 d2739e5863 ">
                                 <p>报告系统虚拟内存统计信息。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d2739e6156" headers="d2739e5860 ">
                                 <p><code class="codeph">watchmalloc</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d2739e6156 d2739e5863 ">
                                 <p>跟踪内存分配。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>