<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes the performance enhancements in the Oracle’s HotSpot Virtual Machine technology.">
      <meta name="description" content="This chapter describes the performance enhancements in the Oracle’s HotSpot Virtual Machine technology.">
      <title>Java HotSpot Virtual Machine Performance Enhancements</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Virtual Machine Guide">
      <meta property="og:description" content="This chapter describes the performance enhancements in the Oracle’s HotSpot Virtual Machine technology.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Virtual Machine Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-virtual-machine-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T02:39:56-07:00">
      <meta name="dcterms.title" content="Java Virtual Machine Guide">
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95202-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="class-data-sharing.html" title="Previous" type="text/html">
      <link rel="next" href="support-non-java-languages.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VM">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="class-data-sharing.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="support-non-java-languages.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java虚拟机指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java HotSpot虚拟机性能增强</li>
            </ol>
            <a id="GUID-3BB4C26F-6DE7-4299-9329-A3E02620D50A" name="GUID-3BB4C26F-6DE7-4299-9329-A3E02620D50A"></a>
            
            <h2 id="JSJVM-GUID-3BB4C26F-6DE7-4299-9329-A3E02620D50A" class="sect2"><span class="enumeration_chapter">5</span> Java HotSpot虚拟机性能增强</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了Oracle HotSpot虚拟机技术的性能增强。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-3BB4C26F-6DE7-4299-9329-A3E02620D50A__GUID-C52942E1-15F0-4C01-95A9-E9AD5E66B18D">话题：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4" title="紧凑的字符串功能为字符串引入了节省空间的内部表示形式。">紧凑弦</a></li>
                     <li><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-85BA7DE7-4AF9-47D9-BFCF-379230C66412">分层编译</a></li>
                     <li><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444">压缩普通对象指针</a></li>
                     <li>
                        <p><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-19475E49-11C6-43DF-B21F-DFEC436EC849" title="Graal是一种用Java编写的高性能，优化，及时的编译器，与Java HotSpot VM集成在一起。这是一个可自定义的动态编译器，您可以从Java调用它。">Graal：基于Java的JIT编译器</a></p>
                     </li>
                     <li>
                        <p><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6" title="提前（AOT）编译通过在启动虚拟机之前将Java类编译为本地代码来缩短大小型Java应用程序的启动时间。">提前编译</a></p>
                     </li>
                     <li><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-E9E4603D-2B6B-44CA-A87E-FB14F0721745">从零开始的压缩普通对象指针</a></li>
                     <li><a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD">转义分析</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4" name="GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4"></a><h3 id="JSJVM-GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4" class="sect3">紧凑弦</h3>
               <div>
                  <p>紧凑的字符串功能为字符串引入了节省空间的内部表示形式。</p>
                  <p>来自不同应用程序的数据表明，字符串是Java堆用法的主要组成部分，并且大多数<code class="codeph">java.lang.String</code>对象仅包含Latin-1个字符。此类字符仅需要存储一个字节。结果，内部字符数组中一半的空间<code class="codeph">java.lang.String</code>不使用对象。Java SE 9中引入的紧凑字符串功能减少了内存占用，并减少了垃圾回收活动。如果您在应用程序中发现性能下降问题，则可以禁用此功能。
                  </p>
                  <div class="section">
                     <p>紧凑字符串功能不会引入新的公共API或接口。它修改了<code class="codeph">java.lang.String</code>从UTF-16（两个字节）字符数组到带有附加字段以标识字符编码的字节数组的类。其他与字符串相关的类，例如<code class="codeph">AbstractStringBuilder</code> ， <code class="codeph">StringBuilder</code>和<code class="codeph">StringBuffer</code>更新为使用类似的内部表示形式。
                     </p>
                     <p>在Java SE 9中，默认情况下启用了压缩字符串功能。因此， <code class="codeph">java.lang.String</code>类将每个字符的字符存储为一个字节，编码为Latin-1。附加字符编码字段指示所使用的编码。HotSpot VM字符串内在函数已更新和优化以支持内部表示。
                     </p>
                     <p>您可以使用<code class="codeph">-XX:-CompactStrings</code>用标记<code class="codeph">java</code>命令行。禁用该功能后， <code class="codeph">java.lang.String</code>类将字符存储为两个字节（编码为UTF-16）和HotSpot VM字符串内部函数以使用UTF-16编码。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-85BA7DE7-4AF9-47D9-BFCF-379230C66412" name="GUID-85BA7DE7-4AF9-47D9-BFCF-379230C66412"></a><h3 id="JSJVM-GUID-85BA7DE7-4AF9-47D9-BFCF-379230C66412" class="sect3">分层编译</h3>
               <div>
                  <p>Java SE 7中引入的分层编译将客户端VM的启动速度提高到服务器VM。在不费力地进行编译的情况下，服务器VM使用解释器来收集有关发送到编译器的方法的分析信息。通过分层编译，服务器VM还使用客户端编译器生成方法的编译版本，这些方法收集有关自身的性能分析信息。编译后的代码比解释器快得多，并且程序在性能分析阶段以更高的性能执行。通常，启动要比客户端VM的启动速度快，因为服务器编译器生成的最终代码可能在应用程序初始化的早期阶段可用。与常规服务器VM相比，分层编译还可以实现更好的峰值性能，因为更快的分析阶段允许更长的分析时间，这可以产生更好的优化。</p>
                  <p>默认情况下，服务器VM启用分层编译。支持64位模式和<a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444">压缩普通对象指针</a> 。您可以使用来禁用分层编译<code class="codeph">-XX:-TieredCompilation</code>用标记<code class="codeph">java</code>命令。
                  </p>
                  <p>为了容纳通过分层编译生成的其他概要分析代码，代码缓存的默认大小乘以5倍。为了有效地组织和管理更大的空间，使用了<a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55">分段代码缓存</a> 。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55" name="GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55"></a><h4 id="JSJVM-GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55" class="sect4">分段代码缓存</h4>
                  <div>
                     <p>代码缓存是Java虚拟机存储生成的本机代码的内存区域。它被组织为一个连续的内存块之上的单个堆数据结构。</p>
                     <p>代码缓存不是分成一个代码堆，而是分为多个段，每个段包含特定类型的已编译代码。这种分段可更好地控制JVM内存占用量，缩短编译方法的扫描时间，显着减少代码缓存的分段，并提高性能。</p>
                     <p>代码缓存分为以下三个部分：</p>
                     <div class="tblformal" id="GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55__SEGMENTEDCODECACHE-3DA33898">
                        <p class="titleintable">表5-1分段代码缓存</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="分段代码缓存" width="100%" border="1" summary="Distinct segments of code cache" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d6470e174">代码缓存段</th>
                                 <th align="left" valign="bottom" width="30%" id="d6470e177">描述</th>
                                 <th align="left" valign="bottom" width="51%" id="d6470e180">JVM命令行参数</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d6470e185" headers="d6470e174 ">
                                    <p>非方法</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d6470e185 d6470e177 ">
                                    <p>该代码堆包含非方法代码，例如编译器缓冲区和字节码解释器。此代码类型永远保留在代码缓存中。代码堆的固定大小为3 MB，剩余的代码缓存在已配置和未配置的代码堆之间平均分配。</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d6470e185 d6470e180 ">
                                    <p><code class="codeph">-XX:NonMethodCodeHeapSize</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d6470e196" headers="d6470e174 ">
                                    <p>已剖析</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d6470e196 d6470e177 ">
                                    <p>此代码堆包含经过短暂优化的，经过概要分析的方法，并且寿命很短。</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d6470e196 d6470e180 ">
                                    <p><code class="codeph">–XX:ProfiledCodeHeapSize</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d6470e207" headers="d6470e174 ">
                                    <p>未剖析</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d6470e207 d6470e177 ">
                                    <p>此代码堆包含经过完全优化的非概要分析方法，使用寿命可能很长。</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d6470e207 d6470e180 ">
                                    <p><code class="codeph">-XX:NonProfiledCodeHeapSize</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-19475E49-11C6-43DF-B21F-DFEC436EC849" name="GUID-19475E49-11C6-43DF-B21F-DFEC436EC849"></a><h3 id="JSJVM-GUID-19475E49-11C6-43DF-B21F-DFEC436EC849" class="sect3">Graal：基于Java的JIT编译器</h3>
               <div>
                  <p>Graal是一种用Java编写的高性能，优化，及时的编译器，与Java HotSpot VM集成在一起。这是一个可自定义的动态编译器，您可以从Java调用它。</p>
                  <p>Graal的一些功能和优点包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>灵活的投机优化</p>
                     </li>
                     <li>
                        <p>更好的内联</p>
                     </li>
                     <li>
                        <p>部分逃逸分析</p>
                     </li>
                     <li>
                        <p>受益于Java工具和IDE支持</p>
                     </li>
                     <li>
                        <p>元循环方法，可以更严格地控制代码生成</p>
                     </li>
                  </ul>
                  <p>您也可以在静态上下文中使用Graal。静态的<a href="java-hotspot-virtual-machine-performance-enhancements.html#GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6" title="提前（AOT）编译通过在启动虚拟机之前将Java类编译为本地代码来缩短大小型Java应用程序的启动时间。">Ahead of Time Compiler</a>基于Graal框架。
                  </p>
                  <p>Graal是JDK构建的一部分，并且作为内部模块提供， <code class="codeph">jdk.internal.vm.compiler</code> 。它使用JVM编译器接口（JVMCI）与JVM通信。JVMCI也是JDK构建的一部分，它包含在内部模块中： <code class="codeph">jdk.internal.vm.ci</code> 。
                  </p>
                  <p>要将Graal启用为JIT编译器，请在<code class="codeph">java</code>命令行：</p><pre class="pre codeblock"><code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code></pre><div class="infoboxnote" id="GUID-19475E49-11C6-43DF-B21F-DFEC436EC849__GUID-8DB5B551-F8AA-4F85-A5E5-243B6BA2FC6F">
                     <p class="notep1">注意：</p>Graal是一项实验性功能，仅在Linux-x64上受支持。
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6" name="GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6"></a><h3 id="JSJVM-GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6" class="sect3">提前编译</h3>
               <div>
                  <p>提前（AOT）编译通过在启动虚拟机之前将Java类编译为本地代码来缩短大小型Java应用程序的启动时间。</p>
                  <p>尽管即时（JIT）编译器速度很快，但编译大型Java程序仍需要时间。另外，当重复解释某些未编译的Java方法时，性能会受到影响。AOT解决了这些问题。</p>
                  <div class="p">新工具<code class="codeph">jaotc</code>用于AOT编译。的语法<code class="codeph">jaotc</code>工具如下：<pre class="pre codeblock"><code>jaotc &lt;options&gt; &lt;list of classes or jar files&gt;
jaotc &lt;options&gt; &lt;--module name&gt;
</code></pre></div>
                  <p>例如：</p><pre class="pre codeblock"><code>jaotc --output libHelloWorld.so HelloWorld.class
jaotc --output libjava.base.so --module java.base</code></pre><p>的<code class="codeph">jaotc</code>该工具是Java安装的一部分，类似于<code class="codeph">javac</code> 。
                  </p>
                  <div class="p">在执行应用程序时指定生成的AOT库：<pre class="pre codeblock"><code>java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld</code></pre>JVM启动时，AOT初始化代码查找使用以下命令指定的库： <code class="codeph">AOTLibrary</code>旗。如果未找到这些库，则将关闭该JVM实例的AOT。
                  </div>
                  <p>有关详细信息<span><cite>，</cite></span>请参见《 <span><cite>Java平台，标准版工具参考</cite></span> 》。 <code class="codeph">jaotc</code>工具。
                  </p>
                  <div class="infoboxnote" id="GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6__GUID-54A8CB7B-241D-49A3-B6EB-7CB0845F0C35">
                     <p class="notep1">注意：</p>提前（AOT）编译是一项实验性功能，仅在Linux-x64上受支持。
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444" name="GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444"></a><h3 id="JSJVM-GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444" class="sect3">压缩普通对象指针</h3>
               <div>
                  <p>Java Hotspot术语中的普通对象指针（oop）是指向对象的托管指针。通常，oop与本地机器指针的大小相同，在LP64系统上为64位。在ILP32系统上，最大堆大小小于4 GB，这对于许多应用程序来说是不够的。在LP64系统上，给定程序使用的堆可能必须比在ILP32系统上运行时大1.5倍左右。该要求归因于托管指针的扩展大小。内存价格便宜，但是如今带宽和缓存都供不应求，因此大幅增加堆大小并且仅超过4 GB限制是不可取的。</p>
                  <p>Java堆中的托管指针指向在8字节地址边界上对齐的对象。压缩的oop将托管指针（在Java虚拟机（JVM）软件中的很多但不是全部位置）表示为相对于64位Java堆基址的32位对象偏移量。因为它们是对象偏移量而不是字节偏移量，所以oop可以用于寻址多达40亿个<span class="italic">对象</span> （而不是字节），或者堆大小最多约为32 GB。要使用它们，必须将它们缩放8倍，并添加到Java堆基址中以找到它们所引用的对象。使用压缩的oop的对象大小与ILP32模式下的对象大小相当。
                  </p>
                  <p>术语<span class="italic">解码</span>是指将32位压缩oop转换为64位本机地址并添加到托管堆中的操作。术语<span class="italic">编码</span>是指逆运算。
                  </p>
                  <p>Java SE 6u23和更高版本默认情况下支持并启用压缩的oops。在Java SE 7中，当以下情况时，默认情况下为64位JVM进程启用压缩的oops： <code class="codeph">-Xmx</code>未指定，且值为<code class="codeph">-Xmx</code>小于32 GB。对于早于6u23版本的JDK版本，请使用<code class="codeph">-XX:+UseCompressedOops</code>用标记<code class="codeph">java</code>命令启用压缩的oops。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E9E4603D-2B6B-44CA-A87E-FB14F0721745" name="GUID-E9E4603D-2B6B-44CA-A87E-FB14F0721745"></a><h3 id="JSJVM-GUID-E9E4603D-2B6B-44CA-A87E-FB14F0721745" class="sect3">从零开始的压缩普通对象指针</h3>
               <div>
                  <p>当JVM在64位JVM进程中使用压缩的普通对象指针（oops）时，JVM软件会向操作系统发送一个请求，以从虚拟地址零开始为Java堆保留内存。如果操作系统支持此类请求，并且可以在虚拟地址零处为Java堆保留内存，则使用基于零的压缩oop。</p>
                  <p>当使用从零开始的压缩oop时，可以从32位对象偏移量解码64位指针，而无需包括Java堆基址。对于小于4 GB的堆大小，JVM软件可以使用字节偏移量而不是对象偏移量，因此也可以避免将偏移量缩放8。将64位地址编码为32位偏移量相对有效。</p>
                  <p>对于最大26 GB的Java堆，Solaris，Linux和Windows操作系统通常可以在虚拟地址零处分配Java堆。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD" name="GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD"></a><h3 id="JSJVM-GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD" class="sect3">转义分析</h3>
               <div>
                  <p>转义分析是Java HotSpot Server编译器可以用来分析新对象使用范围并决定是否在Java堆上分配对象的一种技术。</p>
                  <p>Java SE 6u23和更高版本默认情况下支持并启用转义分析。</p>
                  <p>Java HotSpot Server编译器实现了对流量不敏感的转义分析算法，该算法描述如下：</p><pre class="pre codeblock"><code>
 [Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,
          Vugranam C. Sreedhar, Sam Midkiff,
          "Escape Analysis for Java", Procedings of ACM SIGPLAN
          OOPSLA  Conference, November 1, 1999
</code></pre><p>基于转义分析的对象的转义状态可以是以下状态之一：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">GlobalEscape</code> ：对象转义方法和线程。例如，存储在静态字段中的对象，存储在转义对象的字段中的对象或作为当前方法的结果返回的对象。
                     </li>
                     <li><code class="codeph">ArgEscape</code> ：该对象作为参数传递或由参数引用，但在调用过程中不会全局转义。通过分析被调用方法的字节码确定此状态。
                     </li>
                     <li><code class="codeph">NoEscape</code> ：该对象是标量可替换对象，这意味着可以从生成的代码中删除其分配。
                     </li>
                  </ul>
                  <p>经过转义分析后，服务器编译器从生成的代码中消除了标量可替换对象分配和关联的锁。服务器编译器还消除了不会全局转义的对象的锁定。它<span class="italic">不会</span>取代一个堆栈分配的堆分配不逃避全局对象。
                  </p>
                  <p>以下示例描述了一些进行转义分析的方案：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>服务器编译器可能会消除某些对象分配。例如，一种方法制作对象的防御性副本，然后将该副本返回给调用方。</p><pre class="pre codeblock"><code>
public class Person {
  private String name;
  private int age;
  public Person(String personName, int personAge) {
    name = personName;
                age = personAge;
  }
        
  public Person(Person p) { this(p.getName(), p.getAge()); }
  public int getName() { return name; }
  public int getAge() { return age; }
}

public class Employee {
  private Person person;
  
        // makes a defensive copy to protect against modifications by caller
        public Person getPerson() { return new Person(person) };
        
        public void printEmployeeDetail(Employee emp) {
          Person person = emp.getPerson();
          // this caller does not modify the object, so defensive copy was unnecessary
                System.out.println ("Employee's name: " + person.getName() + "; age: "  + person.getAge());     
        }
}       
        
</code></pre><p>该方法进行复制以防止调用者修改原始对象。如果编译器确定<code class="codeph">getPerson</code>方法被循环调用，然后编译器内联该方法。通过使用转义分析，当编译器确定从未修改原始对象时，编译器可以优化并消除进行复制的调用。
                        </p>
                     </li>
                     <li>
                        <p>如果服务器编译器确定某个对象是线程本地的，则可以消除同步块（ <span class="italic">锁</span>省略）。例如，类的方法例如<code class="codeph">StringBuffer</code>和<code class="codeph">Vector</code>之所以被同步，是因为它们可以被不同的线程访问。但是，在大多数情况下，它们以线程本地方式使用。如果用法是线程本地的，则编译器可以优化和删除同步块。
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </article>
   

</body></html>