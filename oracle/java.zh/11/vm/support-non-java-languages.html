<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <meta name="description" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <title>对非Java语言的支持</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Virtual Machine Guide">
      <meta property="og:description" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Virtual Machine Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-virtual-machine-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T02:39:56-07:00">
      <meta name="dcterms.title" content="Java Virtual Machine Guide">
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95202-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-hotspot-virtual-machine-performance-enhancements.html" title="Previous" type="text/html">
      <link rel="next" href="signal-chaining.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VM">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-hotspot-virtual-machine-performance-enhancements.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="signal-chaining.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java虚拟机指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对非Java语言的支持</li>
            </ol>
            <a id="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE" name="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE"></a>
            
            <h2 id="JSJVM-GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE" class="sect2"><span class="enumeration_chapter">6</span>对非Java语言的支持</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍Java虚拟机中的非Java语言功能。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE__GUID-7345B5CB-173A-4352-B342-DD9163EFDAF0">话题：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="support-non-java-languages.html#GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA">非Java语言功能简介</a></li>
                     <li><a href="support-non-java-languages.html#GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587">静态和动态键入</a></li>
                     <li><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">编译动态类型语言的挑战</a></li>
                     <li><a href="support-non-java-languages.html#GUID-7FDE8A77-F901-455B-8871-E01B61A9A504">动态调用指令</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA" name="GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA"></a><h3 id="JSJVM-GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA" class="sect3">非Java语言功能简介</h3>
               <div>
                  <p>Java平台标准版（Java SE）支持开发具有以下功能的应用程序：</p>
                  <ul style="list-style-type:disc">
                     <li>它们可以编写一次并可以在任何地方运行</li>
                     <li>由于Java沙箱安全模型，它们可以安全运行</li>
                     <li>它们易于包装和交付</li>
                  </ul>
                  <p>Java SE平台在以下领域提供了强大的支持：</p>
                  <ul style="list-style-type:disc">
                     <li>并发</li>
                     <li>垃圾收集</li>
                     <li>反射访问类和对象</li>
                     <li>JVM工具接口（JVM TI）：供工具使用的本机编程接口。它提供了一种检查状态并控制JVM中运行的应用程序执行的方式。</li>
                  </ul>
                  <p>Oracle的HotSpot JVM提供以下工具和功能：</p>
                  <ul style="list-style-type:disc">
                     <li>DTrace：动态跟踪实用程序，用于监视应用程序和操作系统的行为。</li>
                     <li>性能优化</li>
                     <li>PrintAssembly：一个Java HotSpot选项，它打印字节码和本机方法的程序集代码。</li>
                  </ul>
                  <p>Java SE 7平台使非Java语言可以使用JVM的基础结构和潜在的性能优化。关键机制是<code class="codeph">invokedynamic</code>指令，简化了JVM上动态类型语言的编译器和运行时系统的实现。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587" name="GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587"></a><h3 id="JSJVM-GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587" class="sect3">静态和动态键入</h3>
               <div>
                  <p>如果编程语言在编译时执行类型检查，则它是静态类型的。类型检查是验证程序是否安全的过程。如果程序的所有操作的参数都是正确的类型，则它是类型安全的。</p>
                  <p>Java是一种静态类型的语言。编译程序时，类型信息可用于类和实例变量，方法参数，返回值和其他变量。Java编程语言的编译器使用此类型信息生成强类型的字节码，然后可以在运行时由JVM有效地执行。</p>
                  <p>下面的Hello World程序示例演示了静态键入。类型以<span class="bold">粗体显示</span> 。
                  </p><pre class="pre codeblock"><code>
import <span class="bold">java.util.Date;</span>

public class HelloWorld {
    public static <span class="bold">void</span> main(<span class="bold">String[]</span> argv) {
        <span class="bold">String</span> hello = "Hello ";
        <span class="bold">Date</span> currDate = new Date();
        for (<span class="bold">String</span> a : argv) {
            System.out.println(hello + a);
            System.out.println("Today's date is: " + currDate);
        }
    }
}
</code></pre><p>如果编程语言在运行时执行类型检查，则它是动态类型的。JavaScript和Ruby是动态类型语言的示例。这些语言在运行时而不是在编译时验证应用程序中的值是否符合预期的类型。通常，在编译应用程序时，这些语言的类型信息不可用。对象的类型仅在运行时确定。过去，很难在JVM上有效地实现动态类型的语言。</p>
                  <p>以下是用Ruby编程语言编写的Hello World程序的示例：</p><pre class="pre codeblock"><code>
#!/usr/bin/env ruby
require 'date'

hello = "Hello "
currDate = DateTime.now
ARGV.each do|a|
  puts hello + a
  puts "Date and time: " + currDate.to_s
end
</code></pre><p>在示例中，引入的每个名称都没有类型声明。主程序未位于Holder类型（Java类<code class="codeph">HelloWorld</code> ）。相当于Java的Ruby <code class="codeph">for</code>循环位于动态类型内<code class="codeph">ARGV</code>变量。循环的主体包含在称为闭包的块中，这是动态语言中的常见功能。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3" name="GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3"></a><h4 id="JSJVM-GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3" class="sect4">静态类型的语言不一定是强类型的语言</h4>
                  <div>
                     <p>静态类型的编程语言可以采用强类型或弱类型。使用强类型的编程语言会指定对其操作提供的值类型的限制，并且如果其参数的类型错误，则会阻止执行操作。如果使用弱类型的语言的类型错误或不兼容，则它们将隐式转换（或强制转换）操作的参数。</p>
                     <p>动态类型语言可以采用强类型或弱类型。例如，Ruby编程语言是动态类型和强类型的。当使用某种类型的值初始化变量时，Ruby编程语言不会将变量隐式转换为另一种数据类型。</p>
                     <p>在下面的示例中，Ruby编程语言没有隐式转换数字2，该数字2具有一个<code class="codeph">Fixnum</code>输入一个字符串。
                     </p><pre class="pre codeblock"><code>
a = "40"
b = a + 2
</code></pre></div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74" name="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74"></a><h3 id="JSJVM-GUID-99173E26-45BC-40F9-976B-C19D67D1DB74" class="sect3">编译动态类型语言的挑战</h3>
               <div>
                  <p>考虑以下动态类型化方法， <code class="codeph">addtwo</code> ，将两个数字相加（可以是任何数字类型）并返回它们的总和：</p><pre class="pre codeblock"><code>
def addtwo(a, b)
       a + b;
end
</code></pre><p>假设您的组织正在为使用该方法的编程语言实现编译器和运行时系统<code class="codeph">addtwo</code>被写。在强类型语言中，无论是静态类型还是动态类型，其行为<code class="codeph">+</code> （加法运算符）取决于操作数类型。静态类型语言的编译器选择适当的实现<code class="codeph">+</code>根据静态类型<code class="codeph">a</code>和<code class="codeph">b</code> 。例如，Java编译器实现<code class="codeph">+</code>与<code class="codeph">iadd</code> JVM指令的类型<code class="codeph">a</code>和<code class="codeph">b</code>是<code class="codeph">int</code> 。由于JVM，加法运算符被编译为方法调用<code class="codeph">iadd</code>指令要求操作数类型是静态已知的。
                  </p>
                  <p>动态类型语言的编译器必须将选择推迟到运行时。该声明<code class="codeph">a + b</code>被编译为方法调用<code class="codeph">+(a, b)</code> ，在哪里<code class="codeph">+</code>是方法名称。一种名为<code class="codeph">+</code>在JVM中允许，但在Java编程语言中是不允许的。如果动态类型语言的运行时系统能够识别<code class="codeph">a</code>和<code class="codeph">b</code>是整数类型的变量，则运行时系统希望调用的实现<code class="codeph">+</code>专用于整数类型而不是任意对象类型。
                  </p>
                  <p>编译动态类型语言的挑战在于，如何在程序被编译后实现一个运行时系统，该系统可以选择最合适的方法或函数的实现。将所有变量视为的对象<code class="codeph">Object</code>类型不能有效地工作；的<code class="codeph">Object</code>类不包含名为<code class="codeph">+</code> 。
                  </p>
                  <p>在Java SE 7和更高版本中， <code class="codeph">invokedynamic</code>指令使运行时系统可以自定义调用站点和方法实现之间的链接。在此示例中， <code class="codeph">invokedynamic</code>呼叫网站是<code class="codeph">+</code> 。一个<code class="codeph">invokedynamic</code>调用站点通过<span class="italic">bootstrap方法</span>链接到一个方法，该<span class="italic">方法</span>是由编译器为动态类型语言指定的一种方法，该语言由JVM调用一次以链接该站点。假设编译器发出了<code class="codeph">invokedynamic</code>调用指令<code class="codeph">+</code> ，并假设运行时系统知道该方法<code class="codeph">adder(Integer,Integer)</code> ，运行时可以链接<code class="codeph">invokedynamic</code>呼叫网站<code class="codeph">adder</code>方法如下：</p>
                  <p id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__INTEGEROPS.JAVA-336DB0F2"><span class="bold">IntegerOps.java</span></p><pre class="pre codeblock"><code>
class IntegerOps {

  public static Integer adder(Integer x, Integer y) {
    return x + y;
  }
}
</code></pre><p id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__EXAMPLE.JAVA-336DB496"><span class="bold">范例.java</span></p><pre class="pre codeblock"><code>
import java.util.*;
import java.lang.invoke.*;
import static java.lang.invoke.MethodType.*;
import static java.lang.invoke.MethodHandles.*;

class Example {

  public static CallSite mybsm(
    MethodHandles.Lookup callerClass, String dynMethodName, MethodType dynMethodType)
    throws Throwable {

    MethodHandle mh =
      callerClass.findStatic(
        Example.class,
        "IntegerOps.adder",
        MethodType.methodType(Integer.class, Integer.class, Integer.class));

    if (!dynMethodType.equals(mh.type())) {
      mh = mh.asType(dynMethodType);
    }

    return new ConstantCallSite(mh);
  }
}
</code></pre><p>在此示例中， <code class="codeph">IntegerOps</code>类属于运行时系统附带的用于动态类型语言的库。
                  </p>
                  <p>的<code class="codeph">Example.mybsm</code>方法是一种将<code class="codeph">invokedynamic</code>呼叫网站<code class="codeph">adder</code>方法。
                  </p>
                  <p>的<code class="codeph">callerClass</code>对象是一个<code class="codeph">lookup</code>对象，这是用于创建方法句柄的工厂。
                  </p>
                  <p>的<code class="codeph">MethodHandles.Lookup.findStatic</code>方法（从<code class="codeph">callerClass</code><code class="codeph">lookup</code>对象）为方法创建一个静态方法句柄<code class="codeph">adder</code> 。
                  </p>
                  <p><span class="bold">注意</span> ：此引导程序方法将<code class="codeph">invokedynamic</code>呼叫网站仅转到<code class="codeph">adder</code>方法。它假设给定的参数<code class="codeph">invokedynamic</code>呼叫站点是<code class="codeph">Integer</code>对象。引导程序方法需要其他代码才能正确链接<code class="codeph">invokedynamic</code>如果使用bootstrap方法的参数（在本例中， <code class="codeph">callerClass</code> ， <code class="codeph">dynMethodName</code>和<code class="codeph">dynMethodType</code> ）。
                  </p>
                  <p>的<code class="codeph">java.lang.invoke.MethodHandles</code>类和<code class="codeph">java.lang.invoke.MethodHandle</code>类包含基于现有方法句柄创建方法句柄的各种方法。这个例子称<code class="codeph">asType</code>方法，如果方法类型为<code class="codeph">mh</code>方法句柄与<code class="codeph">dynMethodType</code>参数。这使引导方法可以链接<code class="codeph">invokedynamic</code>调用网站的方法类型不完全匹配的Java方法。
                  </p>
                  <p>的<code class="codeph">ConstantCallSite</code> bootstrap方法返回的实例代表一个与不同网站相关联的呼叫站点<code class="codeph">invokedynamic</code>指令。一个目标<code class="codeph">ConstantCallSite</code>实例是永久的，无法更改。在这种情况下，一种Java方法<code class="codeph">adder</code> ，是执行呼叫站点的候选对象。此方法不必是Java方法。相反，如果运行时系统可以使用几种这样的方法，每种方法处理不同的参数类型，则<code class="codeph">mybsm</code>引导程序方法可以根据情况动态选择正确的方法<code class="codeph">dynMethodType</code>论点。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504" name="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504"></a><h3 id="JSJVM-GUID-7FDE8A77-F901-455B-8871-E01B61A9A504" class="sect3">动态调用指令</h3>
               <div>
                  <p>您可以使用<code class="codeph">invokedynamic</code> JVM上用于动态类型化语言的编译器和运行时系统实现中的指令。的<code class="codeph">invokedynamic</code>指令使语言实现者可以定义自定义链接。这与其他JVM指令（例如<code class="codeph">invokevirtual</code> ，其中JVM硬连接了特定于Java类和接口的链接行为。</p>
                  <p>每个实例<code class="codeph">invokedynamic</code>指令称为<span class="italic">动态调用站点</span> 。创建动态呼叫站点的实例后，它处于未链接状态，没有为呼叫站点指定要调用的方法。动态调用站点通过引导方法链接到方法。动态调用站点的引导方法是编译器为动态类型语言指定的方法。该方法由JVM调用一次以链接站点。从引导方法返回的对象将永久确定呼叫站点的活动。
                  </p>
                  <p>的<code class="codeph">invokedynamic</code>指令包含一个常量池索引（与其他格式相同） <code class="codeph">invoke</code>说明）。该常量池索引引用了一个<code class="codeph">CONSTANT_InvokeDynamic</code>条目。此项指定了引导方法（ <code class="codeph">CONSTANT_MethodHandle</code>条目），动态链接方法的名称以及对动态链接方法的调用的参数类型和返回类型。
                  </p>
                  <p>在以下示例中，运行时系统链接由以下项指定的动态调用站点： <code class="codeph">invokedynamic</code>指令（即<code class="codeph">+</code> ，加法运算符） <code class="codeph"><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__INTEGEROPS.JAVA-336DB0F2">IntegerOps.adder</a></code>通过使用<code class="codeph"><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__EXAMPLE.JAVA-336DB496">Example.mybsm</a></code>引导方法。的<code class="codeph">adder</code>方法和<code class="codeph">mybsm</code>方法在<a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">“编译动态类型语言的挑战”中</a>进行了定义（为清楚起见添加了换行符）：</p><pre class="pre codeblock"><code>
invokedynamic   InvokeDynamic
  REF_invokeStatic:
    Example.mybsm:
      "(Ljava/lang/invoke/MethodHandles/Lookup;
        Ljava/lang/String;
        Ljava/lang/invoke/MethodType;)
      Ljava/lang/invoke/CallSite;":
    +:
      "(Ljava/lang/Integer;
        Ljava/lang/Integer;)
      Ljava/lang/Integer;";
</code></pre><div class="p">
                     <div class="infoboxnote" id="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504__GUID-BB5F3290-9D56-4825-A011-9956BC3EA9C5">
                        <p class="notep1">注意：</p>字节码示例使用<a href="http://asm.ow2.org/" target="_blank">ASM</a> Java字节码操作和分析框架的语法。
                     </div>
                  </div>
                  <p>使用调用动态链接的方法<code class="codeph">invokedynamic</code>指令涉及以下步骤：</p>
                  <ol>
                     <li><a href="support-non-java-languages.html#GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB">定义Bootstrap方法</a></li>
                     <li><a href="support-non-java-languages.html#GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4">指定常量池条目</a></li>
                     <li><a href="support-non-java-languages.html#GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921">使用<code class="codeph">invokedynamic</code>指令</a></li>
                  </ol>
               </div>
               <div class="sect3"><a id="GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB" name="GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB"></a><h4 id="JSJVM-GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB" class="sect4">定义Bootstrap方法</h4>
                  <div>
                     <p>在运行时，JVM第一次遇到<code class="codeph">invokedynamic</code>指令，它会调用bootstrap方法。该方法链接了<code class="codeph">invokedynamic</code>指令使用代码指定执行目标方法，该方法由方法句柄引用。下次JVM执行相同的操作<code class="codeph">invokedynamic</code>指令，它不调用bootstrap方法；它会自动调用链接的方法句柄。
                     </p>
                     <p>bootstrap方法的返回类型必须为<code class="codeph">java.lang.invoke.CallSite</code> 。的<code class="codeph">CallSite</code>对象表示链接状态<code class="codeph">invokedynamic</code>指令及其链接的方法句柄。
                     </p>
                     <p>bootstrap方法采用以下三个或多个参数：</p>
                     <ul style="list-style-type:disc">
                        <li><code class="codeph">MethodHandles.Lookup</code>对象：在以下环境中创建方法句柄的工厂<code class="codeph">invokedynamic</code>指令。
                        </li>
                        <li><code class="codeph">String</code>对象：动态调用站点中提到的方法名称。
                        </li>
                        <li><code class="codeph">MethodType</code> object：动态调用站点的已解析类型签名。
                        </li>
                        <li>的一个或多个其他静态参数<code class="codeph">invokedynamic</code>指令：从常量池中提取的可选参数旨在帮助语言实现者安全，紧凑地编码对bootstrap方法有用的其他元数据。原则上，名称和其他参数是多余的，因为可以为每个调用站点赋予其唯一的引导程序方法。但是，这种做法很可能会产生大型类文件和常量池</li>
                     </ul>
                     <p>有关引导方法的示例，请参见<a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">编译动态类型语言的挑战</a> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4" name="GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4"></a><h4 id="JSJVM-GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4" class="sect4">指定常量池条目</h4>
                  <div>
                     <p>的<code class="codeph">invokedynamic</code>指令包含对常量池中条目的引用，其中包含<code class="codeph">CONSTANT_InvokeDynamic</code>标签。该条目包含对常量池中其他条目的引用以及对属性的引用。请参阅<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/package-summary.html" target="_blank"><span class="apiname">java.lang.invoke软件包文档</span></a>和<span class="italic">Java虚拟机规范</span> 。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-D88BBC6A-2372-4717-A770-C90558C8F337" name="GUID-D88BBC6A-2372-4717-A770-C90558C8F337"></a><h5 id="JSJVM-GUID-D88BBC6A-2372-4717-A770-C90558C8F337" class="sect5">常量池示例</h5>
                     <div>
                        <p>以下示例显示了该类的常量池的摘录<code class="codeph">Example</code> ，其中包含bootstrap方法<code class="codeph">Example.mybsm</code>链接方法<code class="codeph">+</code>用Java方法<code class="codeph">adder</code> ：</p><pre class="pre codeblock"><code>
    class #159; // #47
    Utf8 "adder"; // #83
    Utf8 "(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;"; // #84
    Utf8 "mybsm"; // #87
    Utf8 "(Ljava/lang/invoke/MethodHandles/Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)
      java/lang/invoke/CallSite;"; // #88
    Utf8 "Example"; // #159
    Utf8 "+"; // #166

    // ...

    NameAndType #83 #84; // #228
    Method #47 #228; // #229
    MethodHandle 6b #229; // #230
    NameAndType #87 #88; // #231
    Method #47 #231; // #232
    <span class="bold">MethodHandle 6b #232; // #233</span>
    NameAndType #166 #84; // #234
    Utf8 "BootstrapMethods"; // #235
    <span class="bold">InvokeDynamic 0s #234; // #236</span>
</code></pre><p>的常量池条目<code class="codeph">invokedynamic</code>本示例中的指令包含以下值：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">CONSTANT_InvokeDynamic</code>标签</li>
                           <li>无符号的价值不足<code class="codeph">0</code></li>
                           <li>恒定池索引<code class="codeph">#234</code> 。
                           </li>
                        </ul>
                        <p>价值， <code class="codeph">0</code> ，指的是存储在的说明符数组中的第一个引导方法说明符<code class="codeph">BootstrapMethods</code>属性。引导程序方法说明符不在常量池表中。它们包含在该单独的说明符数组中。每个引导方法说明符都包含一个指向<code class="codeph">CONSTANT_MethodHandle</code>常量池条目，它是引导方法本身。
                        </p>
                        <p>以下示例显示了来自相同常量池的摘录，其中显示了<code class="codeph">BootstrapMethods</code>属性，其中包含引导程序方法说明符的数组：</p><pre class="pre codeblock"><code>
  [3] { // Attributes

    // ...

    Attr(#235, 6) { // BootstrapMethods at 0x0F63
      [1] { // bootstrap_methods
        {  //  bootstrap_method
          #233; // bootstrap_method_ref
          [0] { // bootstrap_arguments
          }  //  bootstrap_arguments
        }  //  bootstrap_method
      }
    } // end BootstrapMethods
  } // Attributes
</code></pre><p>引导方法的常量池条目<code class="codeph">mybsm</code>方法句柄包含以下值：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">CONSTANT_MethodHandle</code>标签</li>
                           <li>值的无符号字节<code class="codeph">6</code></li>
                           <li>恒定池索引<code class="codeph">#232</code> 。
                           </li>
                        </ul>
                        <p>价值， <code class="codeph">6</code> ， 是个<code class="codeph">REF_invokeStatic</code>子标签。有关此子标记的更多信息，请参见<a href="support-non-java-languages.html#GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921">使用invokedynamic指令</a> 。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921" name="GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921"></a><h4 id="JSJVM-GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921" class="sect4">使用invokedynamic指令</h4>
                  <div>
                     <p>以下示例显示了字节码如何使用<code class="codeph">invokedynamic</code>指令调用<code class="codeph">mybsm</code>引导方法，该方法链接动态调用网站（ <code class="codeph">+</code> ，加法运算符） <code class="codeph">adder</code>方法。本示例使用<code class="codeph">+</code>数字加法<code class="codeph">40</code>和<code class="codeph">2</code> （为清楚起见，添加了换行符）：</p><pre class="pre codeblock"><code>
bipush  40;
invokestatic    Method java/lang/Integer.valueOf:"(I)Ljava/lang/Integer;";
iconst_2;
invokestatic    Method java/lang/Integer.valueOf:"(I)Ljava/lang/Integer;";
invokedynamic   InvokeDynamic
  REF_invokeStatic:
    Example.mybsm:
      "(Ljava/lang/invoke/MethodHandles/Lookup;
        Ljava/lang/String;
        Ljava/lang/invoke/MethodType;)
      Ljava/lang/invoke/CallSite;":
    +:
      "(Ljava/lang/Integer;
        Ljava/lang/Integer;)
      Ljava/lang/Integer;";
</code></pre><p>前四个指令放整数<code class="codeph">40</code>和<code class="codeph">2</code>在堆栈中并将它们放在<code class="codeph">java.lang.Integer</code>包装器类型。第五条指令调用动态方法。该指令指的是带有<code class="codeph">CONSTANT_InvokeDynamic</code>标签：</p><pre class="pre codeblock"><code>
REF_invokeStatic:
  Example.mybsm:
    "(Ljava/lang/invoke/MethodHandles/Lookup;
      Ljava/lang/String;
      Ljava/lang/invoke/MethodType;)
    Ljava/lang/invoke/CallSite;":
  +:
    "(Ljava/lang/Integer;
      Ljava/lang/Integer;)
    Ljava/lang/Integer;";
</code></pre><p>跟随四个字节<code class="codeph">CONSTANT_InvokeDynamic</code>标记在此条目中。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>前两个字节构成对<code class="codeph">CONSTANT_MethodHandle</code>引用引导程序方法说明符的条目：</p><pre class="pre codeblock"><code>
REF_invokeStatic:
  Example.mybsm:
    "(Ljava/lang/invoke/MethodHandles/Lookup;
      Ljava/lang/String;
      Ljava/lang/invoke/MethodType;)
    Ljava/lang/invoke/CallSite;"
</code></pre><p>对引导方法说明符的引用不在常量池表中。它包含在由名为的类文件属性定义的单独数组中<code class="codeph">BootstrapMethods</code> 。引导程序方法说明符包含指向<code class="codeph">CONSTANT_MethodHandle</code>常量池条目，它是引导方法本身。
                           </p>
                           <p>跟着三个字节<code class="codeph">CONSTANT_MethodHandle</code>常量池条目：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>第一个字节是<code class="codeph">REF_invokeStatic</code>子标签。这意味着该引导方法将为静态方法创建方法句柄；请注意，此引导程序方法将动态调用站点与静态Java链接在一起<code class="codeph">adder</code>方法。
                                 </p>
                              </li>
                              <li>
                                 <p>接下来的两个字节构成一个<code class="codeph">CONSTANT_Methodref</code>代表要为其创建方法句柄的方法的条目：</p><pre class="pre codeblock"><code>
Example.mybsm:
  "(Ljava/lang/invoke/MethodHandles/Lookup;
    Ljava/lang/String;
    Ljava/lang/invoke/MethodType;)
  Ljava/lang/invoke/CallSite;"
</code></pre><p>在此示例中，bootstrap方法的标准名称为<code class="codeph">Example.mybsm</code> 。参数类型是<code class="codeph">MethodHandles.Lookup</code> ， <code class="codeph">String</code>和<code class="codeph">MethodType</code> 。返回类型为<code class="codeph">CallSite</code> 。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>接下来的两个字节构成对<code class="codeph">CONSTANT_NameAndType</code>条目：</p><pre class="pre codeblock"><code>
+:
  "(Ljava/lang/Integer;
    Ljava/lang/Integer;)
  Ljava/lang/Integer;"
</code></pre><p>此常量池条目指定方法名称（ <code class="codeph">+</code> ），参数类型（两个<code class="codeph">Integer</code>实例），以及动态调用网站的返回类型（ <code class="codeph">Integer</code> ）。
                           </p>
                        </li>
                     </ul>
                     <p>在此示例中，为动态调用网站显示了带框的整数值，这些值与最终目标的类型完全匹配，即<code class="codeph">adder</code>方法。实际上，参数和返回类型不必完全匹配。例如， <code class="codeph">invokedynamic</code>指令可以将它的一个或两个操作数作为原始传递给JVM堆栈<code class="codeph">int</code>价值观。一个或两个操作数都可以是无类型的<code class="codeph">Object</code>价值观。的<code class="codeph">invokedynamic</code>指令可以将其结果作为原语接收<code class="codeph">int</code>值或无类型<code class="codeph">Object</code>值。无论如何， <code class="codeph">dynMethodType</code>争论<code class="codeph">mybsm</code>准确地描述所需的方法类型<code class="codeph">invokedynamic</code>指令。
                     </p>
                     <p>的<code class="codeph">adder</code>可以为方法提供原始或无类型的参数或返回值。引导程序方法负责弥补<code class="codeph">dynMethodType</code>和类型<code class="codeph">adder</code>方法。如代码中所示，这很容易通过<code class="codeph">asType</code>调用目标方法。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>