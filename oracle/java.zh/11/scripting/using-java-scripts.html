<html lang="en-us" dir="ltr" xml:lang="en-us"><head></head><body dir="ltr">﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section describes how to access Java classes and interfaces from scripts.">
      <meta name="description" content="This section describes how to access Java classes and interfaces from scripts.">
      <title>通过脚本使用Java</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Scripting Programmer's Guide">
      <meta property="og:description" content="This section describes how to access Java classes and interfaces from scripts.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Scripting Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-scripting-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T19:12:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94834-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-scripting-api.html" title="Previous" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Scripting Programmer’s Guide">
    <meta name="dcterms.isVersionOf" content="SCRIPTING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-scripting-api.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="#" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java脚本程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">通过脚本使用Java</li>
            </ol>
            <a id="GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291" name="GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291"></a><a id="JSJSG115"></a><a id="JSJSG114"></a>
            
            <h2 id="JSJSG-GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291" class="sect2"><span class="enumeration_chapter">3</span>通过脚本使用Java</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本节介绍如何从脚本访问Java类和接口。</span></div>
               <div class="infoboxnote" id="GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291__THENASHORNENGINEISDEPRECATEDINJDK11-A65B130B">
                  <p class="notep1">注意：</p>JDK 11中不推荐使用Nashorn引擎，以准备在将来的版本中删除。
               </div>
               <p>这些代码段是用JavaScript编写的，但是您可以使用任何符合JSR 223的脚本语言。示例可以用作脚本文件，也可以一次在一个表达式中在交互式外壳程序中运行。访问对象的字段和方法的语法在JavaScript中与在Java中相同。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291__GUID-6F1C3014-01B4-48C5-92A7-7AAE3D2C198F">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="using-java-scripts.html#GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC">访问Java类</a></li>
                     <li><a href="using-java-scripts.html#GUID-F725315F-2F0C-48EF-A48B-5E0333B13209">导入Java包和类</a></li>
                     <li><a href="using-java-scripts.html#GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD">使用Java数组</a></li>
                     <li><a href="using-java-scripts.html#GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6">实施Java接口</a></li>
                     <li><a href="using-java-scripts.html#GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB">扩展抽象Java类</a></li>
                     <li><a href="using-java-scripts.html#GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8">扩展具体的Java类</a></li>
                     <li><a href="using-java-scripts.html#GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC">访问Java类</a></li>
                     <li><a href="using-java-scripts.html#GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0">将实现绑定到类</a></li>
                     <li><a href="using-java-scripts.html#GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494">选择方法重载变量</a></li>
                     <li><a href="using-java-scripts.html#GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A">映射数据类型</a></li>
                     <li><a href="using-java-scripts.html#GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167" title="函数Java.asJSONCompatible（obj）接受脚本对象并返回与大多数Java JSON库的期望兼容的对象：它将所有数组公开为List对象（而不是Map对象），并将所有其他对象公开为Map对象。">将JSON对象传递给Java</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JSJSG116"></a><div class="props_rev_3"><a id="GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC" name="GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC"></a><h3 id="JSJSG-GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC" class="sect3">访问Java类</h3>
               <div>
                  <p>要从JavaScript访问原始类型和引用Java类型，请调用<code class="codeph">Java.type()</code>函数，该函数返回一个类型对象，该对象与作为字符串传入的类的全名相对应。下面的示例向您展示如何获取各种类型的对象：</p><pre class="oac_no_warn" dir="ltr">var ArrayList = Java.type("java.util.ArrayList");
var intType = Java.type("int");
var StringArrayType = Java.type("java.lang.String[]");
var int2DArrayType = Java.type("int[][]");
</pre><p>返回的类型对象<code class="codeph">Java.type()</code>可以在JavaScript代码中使用该函数，类似于在Java中使用类名的方式。例如，您可以使用它实例化新对象，如下所示：</p><pre class="oac_no_warn" dir="ltr">var anArrayList = new Java.type("java.util.ArrayList");
</pre><p>Java类型的对象可用于实例化新的Java对象。下面的示例向您展示如何使用默认构造函数并将参数传递给另一个构造函数来实例化新对象：</p><pre class="oac_no_warn" dir="ltr">var ArrayList = Java.type("java.util.ArrayList");
var defaultSizeArrayList = new ArrayList;
var customSizeArrayList = new ArrayList(16);
</pre><p>您可以使用由<code class="codeph">Java.type()</code>用于访问静态字段和方法的函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">var File = Java.type("java.io.File");
File.createTempFile("nashorn", ".tmp");
</pre><p>要访问静态内部类，请在传递给的参数中使用美元符号（$）。 <code class="codeph">Java.type()</code>方法。以下示例说明了如何返回<code class="codeph">Float</code>内在阶级<code class="codeph">java.awt.geom.Arc2D</code> ：</p><pre class="oac_no_warn" dir="ltr">var Float = Java.type("java.awt.geom.Arc2D$Float");
</pre><p>如果您已经具有外部类类型对象，则可以按如下方式访问内部类作为外部类的属性：</p><pre class="oac_no_warn" dir="ltr">var Arc2D = Java.type("java.awt.geom.Arc2D")
var Float = Arc2D.Float
</pre><p>如果是非静态内部类，则必须将外部类的实例作为第一个参数传递给构造函数。</p>
                  <p>尽管JavaScript中的类型对象的用法类似于Java类，但与<code class="codeph">java.lang.Class</code>对象，由<code class="codeph">getClass()</code>方法。您可以使用<code class="codeph">class</code>和<code class="codeph">static</code>属性。以下示例显示了这种区别：</p><pre class="oac_no_warn" dir="ltr">var ArrayList = Java.type("java.util.ArrayList");
var a = new ArrayList;

// All of the following are true:
print("Type acts as target of instanceof: " + (a instanceof ArrayList));
print("Class doesn't act as target of instanceof: " + !(a instanceof a.getClass()));
print("Type is not the same as instance's getClass(): " + (a.getClass() !== ArrayList));
print("Type's `class` property is the same as instance's getClass(): " + (a.getClass() === ArrayList.class));
print("Type is the same as the `static` property of the instance's getClass(): " + (a.getClass().static === ArrayList));
</pre><p>在语法和语义上，编译时类表达式和运行时类对象之间的这种区别使JavaScript类似于Java代码。但是，没有等效的<code class="codeph">static</code>物业<code class="codeph">Class</code> Java中的对象，因为编译时类表达式从不表示为对象。
                  </p>
               </div>
            </div><a id="JSJSG117"></a><div class="props_rev_3"><a id="GUID-F725315F-2F0C-48EF-A48B-5E0333B13209" name="GUID-F725315F-2F0C-48EF-A48B-5E0333B13209"></a><h3 id="JSJSG-GUID-F725315F-2F0C-48EF-A48B-5E0333B13209" class="sect3">导入Java包和类</h3>
               <div>
                  <p>要通过简单名称访问Java类，可以使用<code class="codeph">importPackage()</code>和<code class="codeph">importClass()</code>导入Java包和类的函数。这些功能内置在兼容性脚本中（ <code class="codeph">mozilla_compat.js</code> ）。以下示例显示了如何使用<code class="codeph">importPackage()</code>和<code class="codeph">importClass()</code>功能：</p><pre class="oac_no_warn" dir="ltr">// Load compatibility script
load("nashorn:mozilla_compat.js");
// Import the java.awt package
importPackage(java.awt);
// Import the java.awt.Frame class
importClass(java.awt.Frame);
// Create a new Frame object
var frame = new java.awt.Frame("hello");
// Call the setVisible() method
frame.setVisible(true);
// Access a JavaBean property
print(frame.title);
</pre><p>您可以使用<code class="codeph">Packages</code>全局变量（例如， <code class="codeph">Packages.java.util.Vector</code>要么<code class="codeph">Packages.javax.swing.JFrame</code> ），但标准的Java SE软件包具有快捷方式（ <code class="codeph">java</code>对于<code class="codeph">Packages.java</code> ， <code class="codeph">javax</code>对于<code class="codeph">Packages.javax</code>和<code class="codeph">org</code>对于<code class="codeph">Packages.org</code> ）。
                  </p>
                  <p>的<code class="codeph">java.lang</code>默认情况下不导入包，因为它的类将与<code class="codeph">Object</code> ， <code class="codeph">Boolean</code> ， <code class="codeph">Math</code> ，以及其他内置的JavaScript对象。此外，导入任何Java包或类都可能导致与JavaScript中的全局变量作用域冲突。为避免这种情况，请定义一个<code class="codeph">JavaImporter</code>反对并使用<code class="codeph">with</code>语句以限制导入的Java包和类的范围，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">// Create a JavaImporter object with specified packages and classes to import
var Gui = new JavaImporter(java.awt, javax.swing);

// Pass the JavaImporter object to the "with" statement and access the classes
// from the imported packages by their simple names within the statement's body
with (Gui) {
    var awtframe = new Frame("AWT Frame");
    var jframe = new JFrame("Swing JFrame");
};
</pre></div>
            </div><a id="JSJSG118"></a><div class="props_rev_3"><a id="GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD" name="GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD"></a><h3 id="JSJSG-GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD" class="sect3">使用Java数组</h3>
               <div>
                  <p>要创建Java数组对象，首先必须获取Java数组类型对象，然后将其实例化。访问数组元素的语法和<code class="codeph">length</code> JavaScript中的属性与Java中的属性相同，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">var StringArray = Java.type("java.lang.String[]");
var a = new StringArray(5);

// Set the value of the first element
a[0] = "Scripting is great!";
// Print the length of the array
print(a.length);
// Print the value of the first element
print(a[0]);
</pre><p>给定一个JavaScript数组，您可以使用来将其转换为Java数组。 <code class="codeph">Java.to()</code>方法。您必须将JavaScript数组变量作为字符串或类型对象传递给此方法和要返回的数组类型。您也可以省略数组类型参数以返回<code class="codeph">Object[]</code>数组。转换是根据ECMAScript转换规则执行的。以下示例显示了如何使用各种方法将JavaScript数组转换为Java数组<code class="codeph">Java.to()</code>方法参数：</p><pre class="oac_no_warn" dir="ltr">// Create a JavaScript array
var anArray = [1, "13", false];

// Convert the JavaScript array to a Java int[] array
var javaIntArray = Java.to(anArray, "int[]");
print(javaIntArray[0]); // prints the number 1
print(javaIntArray[1]); // prints the number 13
print(javaIntArray[2]); // prints the number 0

// Convert the JavaScript array to a Java String[] array
var javaStringArray = Java.to(anArray, Java.type("java.lang.String[]"));
print(javaStringArray[0]); // prints the string "1"
print(javaStringArray[1]); // prints the string "13"
print(javaStringArray[2]); // prints the string "false"

// Convert the JavaScript array to a Java Object[] array
var javaObjectArray = Java.to(anArray);
print(javaObjectArray[0]); // prints the number 1
print(javaObjectArray[1]); // prints the string "13"
print(javaObjectArray[2]); // prints the boolean value "false"
</pre><p>给定一个Java数组，您可以使用以下命令将其转换为JavaScript数组<code class="codeph">Java.from()</code>方法。以下示例显示如何将包含当前目录中文件列表的Java数组转换为具有相同内容的JavaScript数组：</p><pre class="oac_no_warn" dir="ltr">// Get the Java File type object
var File = Java.type("java.io.File");
// Create a Java array of File objects
var listCurDir = new File(".").listFiles();
// Convert the Java array to a JavaScript array
var jsList = Java.from(listCurDir);
// Print the JavaScript array
print(jsList);
</pre><div class="infoboxnote" id="GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD__GUID-952A75B6-346D-437F-B4CF-0B67964CC0BF">
                     <p class="notep1">注意：</p>
                     <p>在大多数情况下，您可以在脚本中使用Java数组，而无需将Java数组转换为JavaScript数组。</p>
                  </div>
               </div>
            </div><a id="JSJSG119"></a><div class="props_rev_3"><a id="GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6" name="GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6"></a><h3 id="JSJSG-GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6" class="sect3">实施Java接口</h3>
               <div>
                  <p>在JavaScript中实现Java接口的语法类似于在Java中声明匿名类的方式。您可以在同一表达式中实例化接口并实现其方法（作为JavaScript函数）。以下示例说明了如何实施<code class="codeph">Runnable</code>接口：</p><pre class="oac_no_warn" dir="ltr">// Create an object that implements the Runnable interface by implementing
// the run() method as a JavaScript function
var r  = new java.lang.Runnable() {
    run: function() {
        print("running...\n");
    }
};

// The r variable can be passed to Java methods that expect an object implementing
// the java.lang.Runnable interface
var th = new java.lang.Thread(r);
th.start();
th.join();
</pre><p>如果某个方法需要一个仅使用一个方法实现接口的对象，则可以将脚本函数（而不是对象）传递给此方法。例如，在前面的示例中， <code class="codeph">Thread()</code>构造函数期望一个实现<code class="codeph">Runnable</code>接口，仅定义一种方法。您可以利用自动转换功能并将脚本函数传递给<code class="codeph">Thread()</code>构造函数而不是对象。以下示例向您展示了如何创建一个<code class="codeph">Thread</code>对象而不实现<code class="codeph">Runnable</code>接口：</p><pre class="oac_no_warn" dir="ltr">// Define a JavaScript function
function func() {
    print("I am func!");
};

// Pass the JavaScript function instead of an object that implements
// the java.lang.Runnable interface
var th = new java.lang.Thread(func);
th.start();
th.join();
</pre><p>您可以通过将相关的类型对象传递给子类来在子类中实现多个接口。 <code class="codeph">Java.extend()</code>功能;请参阅<a href="using-java-scripts.html#GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8">扩展具体的Java类</a> 。
                  </p>
               </div>
            </div><a id="JSJSG120"></a><div class="props_rev_3"><a id="GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB" name="GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB"></a><h3 id="JSJSG-GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB" class="sect3">扩展抽象Java类</h3>
               <div>
                  <p>您可以通过将其属性值为实现抽象方法的函数的JavaScript对象传递给其构造函数，来实例化抽象Java类的匿名子类。如果方法过载，那么JavaScript函数将为该方法的所有变体提供实现。下面的示例向您展示如何实例化abstract的子类。 <code class="codeph">TimerTask</code>类：</p><pre class="oac_no_warn" dir="ltr">var TimerTask =  Java.type("java.util.TimerTask");
var task = new TimerTask({ run: function() { print("Hello World!") } });
</pre><p>除了调用构造函数并将参数传递给它之外，您还可以在<code class="codeph">new</code>表达。以下示例向您显示此语法（类似于Java匿名内部类定义）如何简化上一示例中的第二行：</p><pre class="oac_no_warn" dir="ltr">var task = new TimerTask {
    run: function() {
        print("Hello World!")
    }
};
</pre><p>如果抽象类是一个函数接口（它具有一个抽象方法），则可以将实现该方法的函数传递给构造函数，而不是将JavaScript对象传递给构造函数。以下示例显示了使用功能接口时如何简化语法：</p><pre class="oac_no_warn" dir="ltr">var task = new TimerTask(function() { print("Hello World!") });
</pre><p>无论选择哪种语法，如果需要使用参数调用构造函数，都可以在实现对象或函数之前指定参数。</p>
                  <p>如果要调用以功能接口作为参数的Java方法，则可以将JavaScript函数传递给该方法。Nashorn将实例化预期类的子类，并使用该函数实现其唯一的抽象方法。以下示例说明了如何调用<code class="codeph">Timer.schedule()</code>方法，期望<code class="codeph">TimerTask</code>对象作为参数：</p><pre class="oac_no_warn" dir="ltr">var Timer = Java.type("java.util.Timer");
Timer.schedule(function() { print("Hello World!") });
</pre><div class="infoboxnote" id="GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB__GUID-A4E20A50-A8BD-4BA8-ABA5-242AB2505941">
                     <p class="notep1">注意：</p>
                     <p>先前的语法假定期望的功能接口是接口，或者具有默认构造函数，Nashorn使用该构造函数实例化期望类的子类。不能使用非默认构造函数。</p>
                  </div>
               </div>
            </div><a id="JSJSG121"></a><div class="props_rev_3"><a id="GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8" name="GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8"></a><h3 id="JSJSG-GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8" class="sect3">扩展具体的Java类</h3>
               <div>
                  <p>为避免歧义，具体类不允许使用扩展抽象类的语法。因为可以实例化具体的类，所以这种语法可以解释为尝试创建该类的新实例，并将构造函数期望的类型的对象传递给该实例（如果期望的对象类型是接口）。为了说明这一点，请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">var t = new java.lang.Thread({ run: function() { print("Thread running!") } });
</pre><p>此代码可以解释为扩展<code class="codeph">Thread</code>具有指定实现的类<code class="codeph">run()</code>方法，以及实例化<code class="codeph">Thread</code>类，通过将其实现的对象传递给其构造函数<code class="codeph">Runnable</code>接口。请参阅<a href="using-java-scripts.html#GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6">实现Java接口</a> 。
                  </p>
                  <p>要扩展具体的Java类，请将其类型对象传递给<code class="codeph">Java.extend()</code>该函数返回子类的类型对象。然后，将子类的类型对象用作JavaScript到Java适配器，以使用指定的方法实现创建子类的实例。以下示例显示了如何扩展<code class="codeph">Thread</code>具有指定实现的类<code class="codeph">run()</code>方法：</p><pre class="oac_no_warn" dir="ltr">var Thread = Java.type("java.lang.Thread");
var threadExtender = Java.extend(Thread);
var t = new threadExtender() {
    run: function() { print("Thread running!") }};
</pre><p>的<code class="codeph">Java.extend()</code>函数可以获取多个类型对象的列表。您最多可以指定一个Java类的类型对象，并可以指定任意数量的Java接口类型对象。返回的类型对象扩展了指定的类（或<code class="codeph">java.lang.Object</code> （如果未指定类），并实现所有接口。类类型对象不必在列表中排在第一位。
                  </p>
               </div>
            </div><a id="JSJSG123"></a><a id="JSJSG122"></a><div class="props_rev_3"><a id="GUID-14527FC1-202D-40B7-9128-70788BF534F2" name="GUID-14527FC1-202D-40B7-9128-70788BF534F2"></a><h3 id="JSJSG-GUID-14527FC1-202D-40B7-9128-70788BF534F2" class="sect3">超类的访问方法</h3>
               <div>
                  <p>要访问超类中的方法，可以使用<code class="codeph">Java.super()</code>功能。<a href="using-java-scripts.html#GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">例3-1</a>展示了如何扩展<code class="codeph">java.lang.Exception</code>类并访问超类中的方法。
                  </p>
                  <p>如果运行<a href="using-java-scripts.html#GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">示例3-1中</a>的代码，则将以下内容打印到标准输出中：</p><pre class="oac_no_warn" dir="ltr">jdk.nashorn.javaadapters.java.lang.Exception: MY EXCEPTION MESSAGE</pre><div class="example" id="GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">
                     <p class="titleinexample">示例3-1 Supreclass的访问方法（super.js）</p><pre class="oac_no_warn" dir="ltr">var Exception = Java.type("java.lang.Exception");
var ExceptionAdapter = Java.extend(Exception);

var exception = new ExceptionAdapter("My Exception Message") {
    getMessage: function() {
        var _super_ = Java.super(exception);
        return _super_.getMessage().toUpperCase();
    }
}

try {
    throw exception;
} catch (ex) {
    print(exception);
}</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="JSJSG124"></a><div class="props_rev_3"><a id="GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0" name="GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0"></a><h3 id="JSJSG-GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0" class="sect3">将实现绑定到类</h3>
               <div>
                  <p>前面的部分描述了如何在指定实现的构造函数中使用额外的JavaScript对象参数扩展Java类和实现接口。因此，实现绑定到使用以下命令创建的实际实例<code class="codeph">new</code> ，而不是全班。这具有一些优势，例如，在运行时的内存占用方面，因为Nashorn可以为要实现的每种类型的组合创建单个通用适配器。但是，以下示例显示不同的实例具有相同的Java类，而不管它们具有不同的JavaScript实现对象：</p><pre class="oac_no_warn" dir="ltr">var Runnable = java.lang.Runnable;
var r1 = new Runnable(function() { print("I'm runnable 1!") });
var r2 = new Runnable(function() { print("I'm runnable 2!") });
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre><p>前面的示例显示以下内容：</p><pre class="oac_no_warn" dir="ltr">I'm runnable 1!
I'm runnable 2!
We share the same class: true
</pre><p>如果要将实例化的类传递给外部API（例如，使用JavaFX框架时， <code class="codeph">Application</code>类传递给JavaFX API（实例化它），您必须扩展Java类或使用绑定到该类而不是其实例的实现来实现接口。您可以通过将实现作为最后一个参数传递给实现的JavaScript对象，将实现绑定到类<code class="codeph">Java.extend()</code>功能。这将创建一个与原始类具有相同构造函数的类，因为它们不需要额外的实现对象参数。下面的示例演示如何将实现绑定到该类，并说明在这种情况下，不同调用的实现类是不同的：</p><pre class="oac_no_warn" dir="ltr">var RunnableImpl1 = Java.extend(java.lang.Runnable, function() { print("I'm runnable 1!") });
var RunnableImpl2 = Java.extend(java.lang.Runnable, function() { print("I'm runnable 2!") });
var r1 = new RunnableImpl1();var r2 = new RunnableImpl2();
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre><p>前面的示例显示以下内容：</p><pre class="oac_no_warn" dir="ltr">I'm runnable 1!
I'm runnable 2!
We share the same class: false
</pre><p>将实现对象从构造函数调用移动到对象的调用<code class="codeph">Java.extend()</code>函数消除了构造函数调用中额外参数的需要。每次调用<code class="codeph">Java.extend()</code>带有特定于类的实现对象的函数会产生一个新的Java适配器类。具有类绑定实现的适配器类仍可以使用其他构造函数参数来进一步覆盖某些实例的行为。因此，您可以将两种方法结合起来：您可以在传递给的基于类的JavaScript实现对象中提供部分实现。 <code class="codeph">Java.extend()</code>函数，并为传递给构造函数的对象中的实例提供实现。由传递给构造方法的对象定义的功能将覆盖由类绑定对象定义的功能。下面的示例演示如何使用传递给构造函数的函数覆盖在类绑定对象中定义的函数：</p><pre class="oac_no_warn" dir="ltr">var RunnableImpl = Java.extend(java.lang.Runnable, function() { print("I'm runnable 1!") });
var r1 = new RunnableImpl();
var r2 = new RunnableImpl(function() { print("I'm runnable 2!") });
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre><p>前面的示例显示以下内容：</p><pre class="oac_no_warn" dir="ltr">I'm runnable 1!
I'm runnable 2!
We share the same class: true
</pre></div>
            </div><a id="JSJSG125"></a><div class="props_rev_3"><a id="GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494" name="GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494"></a><h3 id="JSJSG-GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494" class="sect3">选择方法重载变量</h3>
               <div>
                  <p>Java方法可以由参数类型重载。Java编译器（ <code class="codeph">javac</code> ）在编译过程中选择正确的方法变体。调用该方法时，将执行从Nashorn调用的Java方法的重载解析。根据参数类型自动选择正确的变量。但是，如果在实际参数类型上遇到真正的歧义，则可以显式指定特定的重载变量。这也可以提高性能，因为Nashorn引擎在调用期间不需要执行重载解析。
                  </p>
                  <p>过载变量作为特殊属性公开。您可以以字符串形式引用它们，这些字符串包含方法名称以及括号内的参数类型。以下示例说明了如何调用<code class="codeph">System.out.println()</code>期望的方法<code class="codeph">Object</code>类作为参数，并通过<code class="codeph">"hello"</code>对此：</p><pre class="oac_no_warn" dir="ltr">var out = java.lang.System.out;
out["println(Object)"]("hello");
</pre><p>在上一个示例中，不合格的类名（ <code class="codeph">Object</code> ）就足够了，因为它可以唯一地标识正确的签名。必须在签名中使用完全限定的类名称的唯一情况是，两个重载变量使用具有相同的非限定名称的不同参数类型（如果具有相同名称的参数类型来自不同的程序包，则可能发生这种情况）。
                  </p>
               </div>
            </div><a id="JSJSG126"></a><div class="props_rev_3"><a id="GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A" name="GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A"></a><h3 id="JSJSG-GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A" class="sect3">映射数据类型</h3>
               <div>
                  <p>Java和JavaScript之间的大多数转换都能按预期工作。前面的部分描述了Java和JavaScript之间不太明显的数据类型映射。Aray被自动转换为Java数组类型，例如<code class="codeph">java.util.List</code> ， <code class="codeph">java.util.Collection</code> ， <code class="codeph">java.util.Queue</code>和<code class="codeph">java.util.Deque</code> 。将JavaScript函数作为参数传递给Java方法时，它们会自动转换为SAM类型。每个JavaScript对象都实现<code class="codeph">java.util.Map</code>接口，使API可以直接接收地图。将数字传递给Java API时，它们将转换为预期的目标数字类型，即盒装或原始。但是，如果目标类型不太明确（例如， <code class="codeph">Number</code> ），您只能期望它们是类型<code class="codeph">Number</code> ，并且必须专门测试该类型是否为盒装<code class="codeph">Double</code> ， <code class="codeph">Integer</code> ， <code class="codeph">Long</code> ， 等等。由于内部优化，该数字可以是任何盒装类型。另外，您可以将任何JavaScript值传递给Java API，并希望使用带框数字或原始数字，因为<code class="codeph">ToNumber</code>由JavaScript规范定义的转换算法将应用于该值。如果Java方法期望<code class="codeph">String</code>或<code class="codeph">Boolean</code>对象，这些值将使用<code class="codeph">ToString</code>和<code class="codeph">ToBoolean</code> JavaScript规范定义的转换。Nashorn确保将内部JavaScript字符串转换为<code class="codeph">java.lang.String</code>当暴露在外部时。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167" name="GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167"></a><h3 id="JSJSG-GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167" class="sect3">将JSON对象传递给Java</h3>
               <div>
                  <p>功能<code class="codeph">Java.asJSONCompatible(obj)</code>接受脚本对象并返回与大多数Java JSON库的期望兼容的对象：它将所有数组公开为<code class="codeph">List</code>对象（而不是<code class="codeph">Map</code>对象）以及所有其他对象<code class="codeph">Map</code>对象。
                  </p>
                  <p><a href="using-java-scripts.html#GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A">映射数据类型</a>提到，每个JavaScript对象在暴露给Java API时都会实现<code class="codeph">java.util.Map</code>接口。即使对于JavaScript数组也是如此。但是，当Java代码需要JSON解析的对象时，通常不希望这种行为。操作JSON解析对象的Java库通常期望数组公开<code class="codeph">java.util.List</code>接口。如果您需要以将数组公开为列表而不是映射的方式公开JavaScript对象，请使用<code class="codeph">Java.asJSONCompatible(obj)</code>功能，在哪里<code class="codeph">obj</code>是JSON对象树的根。
                  </p>
                  <div class="example" id="GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167__GUID-D0548DFF-0B03-4D66-AC50-2F2C95410AF7">
                     <p class="titleinexample">示例3-2 Java.asJSONCompatible（）函数的示例</p>
                     <p>以下示例调用函数<code class="codeph">JSON.parse()</code>和<code class="codeph">Java.asJSONCompatible()</code>在同一个JSON对象上。功能<code class="codeph">JSON.parse()</code>解析数组<code class="codeph">[2,4,5]</code>作为地图而功能<code class="codeph">Java.asJSONCompatible()</code>解析与列表相同的数组。
                     </p><pre class="pre codeblock"><code>import javax.script.*;
import java.util.*;

public class JSONTest {
  public static void main(String[] args) throws Exception {
    ScriptEngineManager m = new ScriptEngineManager();
    ScriptEngine e = m.getEngineByName("nashorn");

    Object obj1 = e.eval(
      "JSON.parse('{ \"x\": 343, \"y\": \"hello\", \"z\": [2,4,5] }');");
    Map&lt;String, Object&gt; map1 = (Map&lt;String, Object&gt;)obj1;
    System.out.println(map1.get("x"));
    System.out.println(map1.get("y"));
    System.out.println(map1.get("z"));
    Map&lt;Object, Object&gt; array1 = (Map&lt;Object, Object&gt;)map1.get("z");
    array1.forEach((a, b) -&gt; System.out.println("z[" + a + "] = " + b));

    System.out.println();
    
    Object obj2 = e.eval(
      "Java.asJSONCompatible({ \"x\": 343, \"y\": \"hello\", \"z\": [2,4,5] })");
    Map&lt;String, Object&gt; map2 = (Map&lt;String, Object&gt;)obj2;
    System.out.println(map2.get("x"));
    System.out.println(map2.get("y"));
    System.out.println(map2.get("z"));
    List&lt;Object&gt; array2 = (List&lt;Object&gt;)map2.get("z");
    array2.forEach(a -&gt; System.out.println(a));
  }
}</code></pre><p>本示例打印以下内容：</p><pre class="pre codeblock"><code>343
hello
[object Array]
z[0] = 2
z[1] = 4
z[2] = 5

343
hello
[2, 4, 5]
2
4
5
</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>