<html lang="en-us" dir="ltr" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section introduces the Java Scripting API and describes how the Java Scripting API (defined by JSR 223) is used to embed scripts in your Java applications. It also provides a number of examples with Java classes, which demonstrate the features of the Java Scripting API.">
      <meta name="description" content="This section introduces the Java Scripting API and describes how the Java Scripting API (defined by JSR 223) is used to embed scripts in your Java applications. It also provides a number of examples with Java classes, which demonstrate the features of the Java Scripting API.">
      <title>The Java Scripting API</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Scripting Programmer's Guide">
      <meta property="og:description" content="This section introduces the Java Scripting API and describes how the Java Scripting API (defined by JSR 223) is used to embed scripts in your Java applications. It also provides a number of examples with Java classes, which demonstrate the features of the Java Scripting API.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Scripting Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-scripting-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T19:12:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94834-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="scripting-languages-and-java.html" title="Previous" type="text/html">
      <link rel="next" href="using-java-scripts.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Scripting Programmer’s Guide">
    <meta name="dcterms.isVersionOf" content="SCRIPTING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="scripting-languages-and-java.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="using-java-scripts.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java脚本程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java脚本API</li>
            </ol>
            <a id="GUID-C4A6EB7C-0AEA-45EC-8662-099BDEFC361A" name="GUID-C4A6EB7C-0AEA-45EC-8662-099BDEFC361A"></a><a id="JSJSG110"></a><a id="JSJSG109"></a>
            
            <h2 id="JSJSG-GUID-C4A6EB7C-0AEA-45EC-8662-099BDEFC361A" class="sect2"><span class="enumeration_chapter">2</span> Java脚本API</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本节介绍Java Scripting API，并描述如何使用Java Scripting API（由JSR 223定义）将脚本嵌入Java应用程序中。它还提供了许多有关Java类的示例，这些示例演示了Java脚本API的功能。</span></div>
               <div class="infoboxnote" id="GUID-C4A6EB7C-0AEA-45EC-8662-099BDEFC361A__THENASHORNENGINEISDEPRECATEDINJDK11-A65B0241">
                  <p class="notep1">注意：</p>JDK 11中不推荐使用Nashorn引擎，以准备在将来的版本中删除。
               </div>
               <div class="section">
                  <p class="subhead1" id="GUID-C4A6EB7C-0AEA-45EC-8662-099BDEFC361A__GUID-60CF8489-B5C2-4806-9E5A-7140A3546B6F">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="java-scripting-api.html#GUID-6D94983D-97BF-4DD4-810D-7B15871510BA">JavaScript套件</a></li>
                     <li><a href="java-scripting-api.html#GUID-BB128CF4-E0AE-487D-AF6C-3507AB186455">如何使用Java脚本API嵌入脚本</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JSJSG111"></a><div class="props_rev_3"><a id="GUID-6D94983D-97BF-4DD4-810D-7B15871510BA" name="GUID-6D94983D-97BF-4DD4-810D-7B15871510BA"></a><h3 id="JSJSG-GUID-6D94983D-97BF-4DD4-810D-7B15871510BA" class="sect3">JavaScript套件</h3>
               <div>
                  <p>Java Scripting API由来自<a href="https://docs.oracle.com/javase/10/docs/api/javax/script/package-summary.html" target="_blank"><code class="codeph">javax.script</code></a>包。它是一个相对较小和简单的包装，带有<code class="codeph">ScriptEngineManager</code>课堂为起点。一种<code class="codeph">ScriptEngineManager</code>对象可以通过JAR文件服务发现机制发现脚本引擎，并实例化<code class="codeph">ScriptEngine</code>解释以特定脚本语言编写的脚本的对象。
                  </p>
                  <p>Nashorn引擎是Java SE开发套件（JDK）附带的默认ECMAScript（JavaScript）引擎。作为OpenJDK项目<a href="http://openjdk.java.net/projects/nashorn/" target="_blank">Nashorn</a>项目的一部分，Nashorn引擎由Oracle完全用Java开发。
                  </p>
                  <p>尽管Nashorn是Java Scripting API使用的默认ECMAScript引擎，但是您可以使用任何与JSR 223兼容的脚本引擎，也可以实现自己的脚本引擎。本文档未涵盖与JSR 223兼容的脚本引擎的实现，但在最基本的级别上，您必须实现<code class="codeph">javax.script.ScriptEngine</code>和<code class="codeph">javax.script.ScriptEngineFactory</code>接口。抽象类<code class="codeph">javax.script.AbstractScriptEngine</code>为以下方法中的一些提供有用的默认值<code class="codeph">ScriptEngine</code>接口。
                  </p>
               </div>
            </div><a id="JSJSG112"></a><div class="props_rev_3"><a id="GUID-BB128CF4-E0AE-487D-AF6C-3507AB186455" name="GUID-BB128CF4-E0AE-487D-AF6C-3507AB186455"></a><h3 id="JSJSG-GUID-BB128CF4-E0AE-487D-AF6C-3507AB186455" class="sect3">如何使用Java脚本API嵌入脚本</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-BB128CF4-E0AE-487D-AF6C-3507AB186455__GUID-AB96C1ED-F647-4FC6-B6E9-31AAF9B63CFF">要使用Java脚本API：</p>
                     <ol>
                        <li>
                           <p>创建一个<code class="codeph">ScriptEngineManager</code>宾语。
                           </p>
                        </li>
                        <li>
                           <p>得到<code class="codeph">ScriptEngine</code>来自经理的对象。
                           </p>
                        </li>
                        <li>
                           <p>使用脚本引擎的评估脚本<code class="codeph">eval()</code>方法。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSJSG113"></a><div class="props_rev_3"><a id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB" name="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB"></a><h3 id="JSJSG-GUID-9E09719F-164D-4380-A585-72F53D9C5AFB" class="sect3">Java类的Java脚本API示例</h3>
               <div>
                  <div class="section">
                     <p>以下示例显示了如何在Java中使用Java脚本API。为了使示例简单，不处理异常。但是，Java Scripting API会抛出检查异常和运行时异常，因此应正确处理它们。在每个示例中， <code class="codeph">ScriptEngineManager</code>类用于请求Nashorn引擎（ <code class="codeph">ScriptEngine</code>类）使用<code class="codeph">getEngineByName()</code>方法。如果不存在具有指定名称的引擎， <code class="codeph">null</code>返回。有关使用Nashorn引擎的更多信息，请参阅《 <span class="italic">Nashorn用户指南》</span> 。
                     </p>
                     <div class="infoboxnote" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-221E2985-EFFC-445C-8ADF-498C9896B377">
                        <p class="notep1">注意：</p>
                        <p>每<code class="codeph">ScriptEngine</code>对象具有自己的可变范围；请参阅<a href="java-scripting-api.html#GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__BABGBJBA">使用多个范围</a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-98735D93-FA1C-4555-9D5F-1DC33D689785">评估陈述</p>
                     <p>在此示例中， <code class="codeph">eval()</code>在脚本引擎实例上调用方法，以从<code class="codeph">String</code>宾语。
                     </p><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class EvalScript {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code
        engine.eval("print('Hello, World')");
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-0443B15B-C1B9-4216-9D04-E96CDEDDC9B6">评估脚本文件</p>
                     <p>在此示例中， <code class="codeph">eval()</code>方法采用<code class="codeph">FileReader</code>从名为的文件中读取JavaScript代码的对象<code class="codeph">script.js</code> 。通过将各种输入流对象包装为读取器，可以从文件，URL和其他资源执行脚本。
                     </p><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class EvalFile {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code
        engine.eval(new java.io.FileReader("script.js"));
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-7D8E967C-6D58-49FA-B6FE-662A17BBE8CF">将Java对象公开为全局变量</p>
                     <p>在此示例中， <code class="codeph">File</code>创建对象并将其作为名为的全局变量公开给引擎<code class="codeph">file</code>使用<code class="codeph">put()</code>方法。然后<code class="codeph">eval()</code>使用访问该变量并调用<code class="codeph">getAbsolutePath()</code>方法。
                     </p>
                     <div class="infoboxnote" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-3C24B68A-CA4E-4755-AB84-ECCA84189C4F">
                        <p class="notep1">注意：</p>
                        <p>访问作为变量公开的Java对象的字段和调用方法的语法取决于脚本语言。本示例使用与Java相似的JavaScript语法。</p>
                     </div><pre class="oac_no_warn" dir="ltr">import javax.script.*;
import java.io.*;

public class ScriptVars {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // create File object
        File f = new File("test.txt");

        // expose File object as a global variable to the engine
        engine.put("file", f);

        // evaluate JavaScript code and access the variable
        engine.eval("print(file.getAbsolutePath())");
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-D85DE8E1-E95A-4156-9AC5-7AD2AAAFBFE6">调用脚本功能</p>
                     <p>在此示例中， <code class="codeph">eval()</code>用定义了一个参数的函数的JavaScript代码调用方法。然后， <code class="codeph">Invocable</code>创建对象及其<code class="codeph">invokeFunction()</code>方法用于调用该函数。
                     </p>
                     <div class="infoboxnote" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-D3CB4753-CC44-45B4-97F6-63E4EBFA869C">
                        <p class="notep1">注意：</p>
                        <p>并非所有脚本引擎都实现<code class="codeph">Invocable</code>接口。此示例使用Nashorn引擎，该引擎可以在以前由该引擎评估过的脚本中调用函数。
                        </p>
                     </div><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class InvokeScriptFunction {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code that defines a function with one parameter
        engine.eval("function hello(name) { print('Hello, ' + name) }");

        // create an Invocable object by casting the script engine object
        Invocable inv = (Invocable) engine;

        // invoke the function named "hello" with "Scripting!" as the argument
        inv.invokeFunction("hello", "Scripting!");
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-48761C06-472A-423B-AEE9-19D0893E5982">调用脚本对象的方法</p>
                     <p>在此示例中， <code class="codeph">eval()</code>用定义方法的JavaScript代码调用method。然后使用脚本引擎的对象将该对象从脚本公开给Java应用程序<code class="codeph">get()</code>方法。然后， <code class="codeph">Invocable</code>对象已创建，其<code class="codeph">invokeMethod()</code> method用于调用为脚本对象定义的方法。
                     </p>
                     <div class="infoboxnote" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-6ACD8BAC-A379-44FC-AD86-ABD9C328F189">
                        <p class="notep1">注意：</p>
                        <p>并非所有脚本引擎都实现<code class="codeph">Invocable</code>接口。此示例使用Nashorn引擎，该引擎可以在以前由该引擎评估过的脚本中调用方法。
                        </p>
                     </div><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class InvokeScriptMethod {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code that defines an object with one method
        engine.eval("var obj = new Object()");
        engine.eval("obj.hello = function(name) { print('Hello, ' + name) }");

        // expose object defined in the script to the Java application
        Object obj = engine.get("obj");

        // create an Invocable object by casting the script engine object
        Invocable inv = (Invocable) engine;

        // invoke the method named "hello" on the object defined in the script
        // with "Script Method!" as the argument
        inv.invokeMethod(obj, "hello", "Script Method!");
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-40587FEE-0349-43C8-AD7F-099E5F0B9CE6">使用脚本功能实现Java接口</p>
                     <p>在此示例中， <code class="codeph">eval()</code>使用定义函数的JavaScript代码调用方法。然后， <code class="codeph">Invocable</code>对象已创建，其<code class="codeph">getInterface()</code>方法用于创建一个<code class="codeph">Runnable</code>接口对象。接口的方法由名称匹配的脚本函数实现（在这种情况下， <code class="codeph">run()</code>函数用于实现<code class="codeph">run()</code>接口对象中的方法）。最后，启动一个运行脚本功能的新线程。
                     </p><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class ImplementRunnable {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code that defines a function with one parameter
        engine.eval("function run() { print('run() function called') }");

        // create an Invocable object by casting the script engine object
        Invocable inv = (Invocable) engine;

        // get Runnable interface object
        Runnable r = inv.getInterface(Runnable.class);

        // start a new thread that runs the script
        Thread th = new Thread(r);
        th.start();
        th.join();
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-EC3ED43D-AD0F-4425-81FD-A9F9DE1B9FA1">使用脚本对象的方法实现Java接口</p>
                     <p>在此示例中， <code class="codeph">eval()</code>用定义方法的JavaScript代码调用method。然后使用脚本引擎的对象将该对象从脚本公开给Java应用程序<code class="codeph">get()</code>方法。然后， <code class="codeph">Invocable</code>对象已创建，其<code class="codeph">getInterface()</code>方法用于创建一个<code class="codeph">Runnable</code>接口对象。接口的方法由脚本对象的名称匹配的方法实现（在这种情况下， <code class="codeph">run</code>的方法<code class="codeph">obj</code>对象用于实现<code class="codeph">run()</code>接口对象中的方法）。最后，启动一个运行脚本对象方法的新线程。
                     </p><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class ImplementRunnableObject {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // evaluate JavaScript code that defines a function with one parameter
        engine.eval("var obj = new Object()")
        engine.eval("obj.run = function() { print('obj.run() method called') }");

        // expose object defined in the script to the Java application
        Object obj = engine.get("obj");

        // create an Invocable object by casting the script engine object
        Invocable inv = (Invocable) engine;

        // get Runnable interface object
        Runnable r = inv.getInterface(obj, Runnable.class);

        // start a new thread that runs the script
        Thread th = new Thread(r);
        th.start();
        th.join();
    }
}
</pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__BABGBJBA">
                     <p class="subhead2" id="GUID-9E09719F-164D-4380-A585-72F53D9C5AFB__GUID-CC3A13EE-1466-4472-8E28-78710B08A632">使用多个范围</p>
                     <p>在此示例中，脚本引擎的<code class="codeph">put()</code>方法用于设置变量<code class="codeph">x</code>到一个<code class="codeph">String</code>宾语<code class="codeph">hello</code> 。然后， <code class="codeph">eval()</code>方法用于在默认范围内打印变量。然后，定义不同的脚本上下文，并使用其范围将同一变量设置为不同的值（ <code class="codeph">String</code>宾语<code class="codeph">world</code> ）。最后，该变量将在显示不同值的新脚本上下文中打印。
                     </p>
                     <p>单一范围是<code class="codeph">javax.script.Bindings</code>接口。此接口派生自<code class="codeph">java.util.Map<String, Object></code>接口。范围是一组名称和值对，其中名称是非空，非空<code class="codeph">String</code>宾语。的<code class="codeph">javax.script.ScriptContext</code>接口支持具有关联的多个范围<code class="codeph">Bindings</code>对于每个范围。默认情况下，每个脚本引擎都有一个默认的脚本上下文。默认脚本上下文具有至少一个由静态字段表示的范围<code class="codeph">ENGINE_SCOPE</code> 。脚本上下文支持的各种作用域可以通过<code class="codeph">getScopes()</code>方法。
                     </p><pre class="oac_no_warn" dir="ltr">import javax.script.*;

public class MultipleScopes {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // set global variable
        engine.put("x","hello");

        // evaluate JavaScript code that prints the variable (x = "hello")
        engine.eval("print(x)");

        // define a different script context
        ScriptContext newContext = new SimpleScriptContext();
        newContext.setBindings(engine.createBindings(), ScriptContext.ENGINE_SCOPE);
        Bindings engineScope = newContext.getBindings(ScriptContext.ENGINE_SCOPE);

        // set the variable to a different value in another scope
        engineScope.put("x", "world");

        // evaluate the same code but in a different script context (x = "world")
        engine.eval("print(x)", newContext);

</pre></div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>