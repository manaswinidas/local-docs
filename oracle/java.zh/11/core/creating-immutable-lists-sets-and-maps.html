<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Convenience static factory methods on the List, Set, and Map interfaces, which were added in JDK 9, let you easily create immutable lists, sets, and maps.">
      <meta name="description" content="Convenience static factory methods on the List, Set, and Map interfaces, which were added in JDK 9, let you easily create immutable lists, sets, and maps.">
      <title>创建不可变的列表，集合和映射</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content="Convenience static factory methods on the List, Set, and Map interfaces, which were added in JDK 9, let you easily create immutable lists, sets, and maps.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T08:11:40-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94895-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="xml-catalog-api1.html" title="Previous" type="text/html">
      <link rel="next" href="process-api1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="xml-catalog-api1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="process-api1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">核心图书馆</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">创建不可变的列表，集合和映射</li>
            </ol>
            <a id="GUID-DD066F67-9C9B-444E-A3CB-820503735951" name="GUID-DD066F67-9C9B-444E-A3CB-820503735951"></a>
            
            <h2 id="JSCOR-GUID-DD066F67-9C9B-444E-A3CB-820503735951" class="sect2"><span class="enumeration_chapter">5</span>创建不可变的列表，集合和映射</h2>
         </header>
         <div class="ind">
            <div>
               <p>JDK 9中添加了<span class="apiname">List</span> ， <span class="apiname">Set</span>和<span class="apiname">Map</span>接口上的便捷静态工厂方法，使您可以轻松创建不可变的列表，集合和映射。
               </p>
               <p>如果对象的状态在构造后无法更改，则认为该对象是<span class="italic">不可变的</span> 。创建集合的不变实例后，只要引用存在，它就保存相同的数据。
               </p>
               <p>如果使用这些方法创建的集合包含不可变的对象，则它们在构造后将自动成为线程安全的。因为这些结构不需要支持突变，所以可以使它们的空间利用率更高。不可变集合实例通常比可变实例消耗更少的内存。</p>
               <p>如<a href="creating-immutable-lists-sets-and-maps.html#GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4" title="通常，通过JDK 9中添加的便捷工厂方法返回的集合是不可变的。从这些集合中添加，设置或删除元素的任何尝试都会引发UnsupportedOperationException。">关于不可变性中所述</a> ，不可变集合可以包含可变对象，并且如果包含可变对象，则该集合既不可变也不线程安全。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-DD066F67-9C9B-444E-A3CB-820503735951__GUID-75C3A9C7-CEAF-4F84-AE7A-155439538C0B">话题</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-1222F8A3-7EC0-4E49-9B75-C3B263F9A1BB" title="不可变方法的常见用例是从已知值初始化的集合，并且永远不会更改。如果您的数据很少更改，也请考虑使用这些方法。">用例</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-930A5334-9413-4E87-A1D7-6FF4E9E421B2" title="这些新集合的API非常简单，尤其是对于少量元素而言。">句法</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-23F23104-CCEF-43C2-92F8-663094050FA5" title="让我们考虑以下情况：创建一个集合，方法是添加元素并对其进行修改，然后在某个时候想要该集合的不可变快照。使用JDK 10中添加的copyOf方法族创建副本。">创建集合的不变副本</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-29B476E6-66E9-4C95-B744-874ECA6FAB51" title="Streams库包含一组称为收集器的终端操作。收集器最常用于创建包含流元素的新集合。从JDK 10开始，java.util.stream。Collectors类具有Collector，它们可以从流的元素创建新的不可变集合。">从流创建不可变集合</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-A9B36F89-BA86-41BA-AAE1-ED73A5FC5C6E" title="Set元素和Map键的迭代顺序是随机的：从一个JVM到下一个JVM，它的顺序可能不同。这是有意的，它使您更容易识别依赖于迭代顺序的代码。有时，对迭代顺序的依赖性会不经意间渗入代码中，并导致难以调试的问题。">随机迭代顺序</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4" title="通常，通过JDK 9中添加的便捷工厂方法返回的集合是不可变的。从这些集合中添加，设置或删除元素的任何尝试都会引发UnsupportedOperationException。">关于不变性</a></p>
                     </li>
                     <li>
                        <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199" title="便捷工厂方法返回的集合比其可变的等效项在空间效率上更高。">空间效率</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-1222F8A3-7EC0-4E49-9B75-C3B263F9A1BB" name="GUID-1222F8A3-7EC0-4E49-9B75-C3B263F9A1BB"></a><h3 id="JSCOR-GUID-1222F8A3-7EC0-4E49-9B75-C3B263F9A1BB" class="sect3">用例</h3>
               <div>
                  <p>不可变方法的常见用例是从已知值初始化的集合，并且永远不会更改。如果您的数据很少更改，也请考虑使用这些方法。</p>
                  <p>为了获得最佳性能，不可变集合存储一个永不更改的数据集。但是，即使数据随时更改，您也可以利用性能和节省空间的优势。即使您的数据偶尔更改，这些集合也可能提供比可变集合更好的性能。</p>
                  <p>如果您有大量的值，则可以考虑将它们存储在<a href="https://docs.oracle.com/javase/10/docs/api/java/util/HashMap.html" target="_blank"><span class="apiname">HashMap中</span></a> 。如果您要不断添加和删除条目，那么这是一个不错的选择。但是，如果您拥有一组永不更改或很少更改的值，并且从中读取了很多内容，则不变的<span class="apiname">Map</span>是一种更有效的选择。如果经常读取数据集，并且值很少改变，那么即使将值改变时销毁和重建不可变<span class="apiname">Map</span>的性能影响包括在内，您也可能会发现整体速度更快。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-930A5334-9413-4E87-A1D7-6FF4E9E421B2" name="GUID-930A5334-9413-4E87-A1D7-6FF4E9E421B2"></a><h3 id="JSCOR-GUID-930A5334-9413-4E87-A1D7-6FF4E9E421B2" class="sect3">句法</h3>
               <div>
                  <p>这些新集合的API非常简单，尤其是对于少量元素而言。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-930A5334-9413-4E87-A1D7-6FF4E9E421B2__GUID-75C3A9C7-CEAF-4F84-AE7A-155439538C0B">话题</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-202D195E-6E18-41F6-90C0-7423B2C9B381" title="List.of静态工厂方法提供了一种创建不可变列表的便捷方法。">不变列表静态工厂方法</a></p>
                        </li>
                        <li>
                           <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-DB0865D2-C052-40BC-A3DC-20FCB3088DC9" title="Set.of静态工厂方法提供了一种创建不可变集的便捷方法。">不变集静态工厂方法</a></p>
                        </li>
                        <li>
                           <p><a href="creating-immutable-lists-sets-and-maps.html#GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4" title="Map.of和Map.ofEntries静态工厂方法提供了一种创建不可变地图的便捷方法。">不变地图静态工厂方法</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-202D195E-6E18-41F6-90C0-7423B2C9B381" name="GUID-202D195E-6E18-41F6-90C0-7423B2C9B381"></a><h4 id="JSCOR-GUID-202D195E-6E18-41F6-90C0-7423B2C9B381" class="sect4">不变列表静态工厂方法</h4>
                  <div>
                     <p><span class="apiname">List.of</span>静态工厂方法提供了一种创建不可变列表的便捷方法。
                     </p>
                     <p>列表是有序集合，通常允许重复元素。不允许为空值。</p>
                     <p>这些方法的语法为：</p><pre class="pre codeblock"><code>List.of()
List.of(e1)
List.of(e1, e2)         // fixed-argument form overloads up to 10 elements
List.of(elements...)   // varargs form supports an arbitrary number of elements or an array</code></pre><div class="example" id="GUID-202D195E-6E18-41F6-90C0-7423B2C9B381__GUID-1D2F8109-0F3B-46CE-ABC7-649FE6B8CE1F">
                        <p class="titleinexample">示例5-1示例</p>
                        <p>在JDK 8中：</p><pre class="pre codeblock"><code>List&lt;String&gt; stringList = Arrays.asList("a", "b", "c");
stringList = Collections.unmodifiableList(stringList);</code></pre><p>在JDK 9中：</p><pre class="pre codeblock"><code>List stringList = List.of("a", "b", "c");</code></pre><p>请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/util/List.html#immutable" target="_blank">不可变列表静态工厂方法</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DB0865D2-C052-40BC-A3DC-20FCB3088DC9" name="GUID-DB0865D2-C052-40BC-A3DC-20FCB3088DC9"></a><h4 id="JSCOR-GUID-DB0865D2-C052-40BC-A3DC-20FCB3088DC9" class="sect4">不变集静态工厂方法</h4>
                  <div>
                     <p><span class="apiname">Set.of</span>静态工厂方法提供了一种创建不可变集的便捷方法。
                     </p>
                     <p>集合是不包含重复元素的集合。如果检测到重复条目，则<code class="codeph">IllegalArgumentException</code>被抛出。不允许为空值。
                     </p>
                     <p>这些方法的语法为：</p><pre class="pre codeblock"><code>Set.of()
Set.of(e1)
Set.of(e1, e2)         // fixed-argument form overloads up to 10 elements
Set.of(elements...)   // varargs form supports an arbitrary number of elements or an array</code></pre><div class="example" id="GUID-DB0865D2-C052-40BC-A3DC-20FCB3088DC9__GUID-1D2F8109-0F3B-46CE-ABC7-649FE6B8CE1F">
                        <p class="titleinexample">示例5-2</p>
                        <p>在JDK 8中：</p><pre class="pre codeblock"><code>Set&lt;String&gt; stringSet = new HashSet&lt;&gt;(Arrays.asList("a", "b", "c"));
stringSet = Collections.unmodifiableSet(stringSet);</code></pre><p>在JDK 9中：</p><pre class="pre codeblock"><code>Set&lt;String&gt; stringSet = Set.of("a", "b", "c");</code></pre><p>请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html#immutable" target="_blank">不可变集静态工厂方法</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4" name="GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4"></a><h4 id="JSCOR-GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4" class="sect4">不变地图静态工厂方法</h4>
                  <div>
                     <p><span class="apiname">Map.of</span>和<span class="apiname">Map.ofEntries</span>静态工厂方法提供了一种创建不可变地图的便捷方法。
                     </p>
                     <p><span class="apiname">映射</span>不能包含重复的键；每个键最多可以映射到一个值。如果检测到重复的密钥，则<code class="codeph">IllegalArgumentException</code>被抛出。空值不能用作<span class="apiname">映射</span>键或值。
                     </p>
                     <p>这些方法的语法为：</p><pre class="pre codeblock"><code>Map.of()
Map.of(k1, v1)
Map.of(k1, v1, k2, v2)    // fixed-argument form overloads up to 10 key-value pairs
Map.ofEntries(entry(k1, v1), entry(k2, v2),...)
 // varargs form supports an arbitrary number of Entry objects or an array</code></pre><div class="example" id="GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4__GUID-1D2F8109-0F3B-46CE-ABC7-649FE6B8CE1F">
                        <p class="titleinexample">示例5-3</p>
                        <p>在JDK 8中：</p><pre class="pre codeblock"><code>Map&lt;String, Integer&gt; stringMap = new HashMap&lt;String, Integer&gt;(); 
stringMap.put("a", 1); 
stringMap.put("b", 2);
stringMap.put("c", 3);
stringMap = Collections.unmodifiableMap(stringMap);</code></pre><p>在JDK 9中：</p><pre class="pre codeblock"><code>Map stringMap = Map.of("a", 1, "b", 2, "c", 3);</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ECD1A3C5-14A7-47E2-995E-40C9B6B935C4__GUID-09185476-6886-4C66-8A11-3E9F27E504E2">
                        <p class="titleinexample">示例5-4具有任意对数的映射</p>
                        <p>如果您有10个以上的键/值对，请使用<span class="apiname">Map.entry</span>方法创建地图条目，然后将这些对象传递给<span class="apiname">Map.ofEntries</span>方法。例如：</p><pre class="pre codeblock"><code>import static java.util.Map.entry;
Map &lt;Integer, String&gt; friendMap = Map.ofEntries(
   entry(1, "Tom"),
   entry(2, "Dick"),
   entry(3, "Harry"),
   ...
   entry(99, "Mathilde"));
</code></pre><p>请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/util/Map.html#immutable" target="_blank">不可变映射静态工厂方法</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-23F23104-CCEF-43C2-92F8-663094050FA5" name="GUID-23F23104-CCEF-43C2-92F8-663094050FA5"></a><h3 id="JSCOR-GUID-23F23104-CCEF-43C2-92F8-663094050FA5" class="sect3">创建集合的不变副本</h3>
               <div>
                  <p>让我们考虑以下情况：创建一个集合，方法是添加元素并对其进行修改，然后在某个时候想要该集合的不可变快照。使用JDK 10中添加的<span class="apiname">copyOf</span>方法族创建副本。
                  </p>
                  <div class="p">例如，假设您有一些代码从多个地方收集元素：<pre class="pre codeblock" xml:lang="java"><code>   List&lt;Item&gt; list = new ArrayList&lt;&gt;();
   list.addAll(getItemsFromSomewhere());
   list.addAll(getItemsFromElsewhere());
   list.addAll(getItemsFromYetAnotherPlace());</code></pre></div>
                  <div class="p">使用<span class="apiname">List.of</span>方法创建不可变的集合<span class="apiname">很不方便</span> 。为此，需要创建一个大小合适的数组，将列表中的元素复制到该数组中，然后调用<code class="codeph">List.of(array)</code>创建不可变的快照。而是使用<span class="apiname">copyOf</span>静态工厂方法一步完成此<span class="apiname">操作</span> ：<pre class="pre codeblock" xml:lang="java"><code>   List&lt;Item&gt; snapshot = List.copyOf(list); </code></pre></div>
                  <p>Set和Map有对应的静态工厂方法，称为<span class="apiname">Set.copyOf</span>和<span class="apiname">Map.copyOf</span> 。
                  </p>
                  <p>如果原始集合是可变的，则<span class="apiname">copyOf</span>方法将创建一个不可变的集合，该集合是原始集合的副本。也就是说，结果包含与原始元素相同的所有元素。如果将元素添加到原始集合中或从原始集合中删除，则不会影响副本。
                  </p>
                  <p>如果原始集合<span class="italic">已经</span>是不可变的，则<span class="apiname">copyOf</span>方法仅返回对原始集合的引用。复制的目的是将返回的集合与原始集合的更改隔离开来。但是，如果原始集合无法更改，则无需对其进行复制。
                  </p>
                  <p>在这两种情况下，如果元素是可变的，并且元素被修改，则该更改将导致原始集合和副本看起来都已更改。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-29B476E6-66E9-4C95-B744-874ECA6FAB51" name="GUID-29B476E6-66E9-4C95-B744-874ECA6FAB51"></a><h3 id="JSCOR-GUID-29B476E6-66E9-4C95-B744-874ECA6FAB51" class="sect3">从流创建不可变集合</h3>
               <div>
                  <p>Streams库包含一组终端操作，称为<code class="codeph">Collectors</code> 。一种<code class="codeph">Collector</code>最常用于创建包含流元素的新集合。从JDK 10开始， <span class="apiname">java.util.stream。收藏家</span>类有<code class="codeph">Collectors</code>从流的元素创建新的不可变集合。
                  </p>
                  <p>如果要保证返回的集合是不可变的，则应使用<span class="apiname">toUnmodifiable-</span>收集器之一。这些收集器是：</p><pre class="pre codeblock"><code>   Collectors.toUnmodifiableList()
   Collectors.toUnmodifiableSet()
   Collectors.toUnmodifiableMap(keyMapper, valueMapper) &nbsp;&nbsp;&nbsp; 
   Collectors.toUnmodifiableMap(keyMapper, valueMapper, mergeFunction)</code></pre><p>例如，要转换源集合的元素并将结果放入不可变的集合中，可以执行以下操作：</p><pre class="pre codeblock"><code>   Set&lt;Item&gt; immutableSet =
      sourceCollection.stream()
                      .map(...)&nbsp;
                      .collect(Collectors.toUnmodifiableSet());</code></pre><p>这些收集器在概念上类似于其对应的<span class="apiname">toList</span> ， <span class="apiname">toSet</span>和对应的两个<span class="apiname">toMap</span>方法，但是它们具有不同的特性。具体来说， <span class="apiname">toList</span> ， <span class="apiname">toSet</span>和<span class="apiname">toMap</span>方法不能保证返回的集合是可变的还是不可变的。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-A9B36F89-BA86-41BA-AAE1-ED73A5FC5C6E" name="GUID-A9B36F89-BA86-41BA-AAE1-ED73A5FC5C6E"></a><h3 id="JSCOR-GUID-A9B36F89-BA86-41BA-AAE1-ED73A5FC5C6E" class="sect3">随机迭代顺序</h3>
               <div>
                  <p><span class="apiname">Set</span>元素和<span class="apiname">Map</span>键的迭代顺序是随机的：从一个JVM到下一个JVM，它的顺序可能不同。这是有意的，它使您更容易识别依赖于迭代顺序的代码。有时，对迭代顺序的依赖性会不经意间渗入代码中，并导致难以调试的问题。
                  </p>
                  <p>您可以看到迭代顺序如何相同，直到<code class="codeph">jshell</code>重新启动。
                  </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">Map stringMap = Map.of("a", 1, "b", 2, "c", 3);</span>
stringMap ==&gt; {b=2, c=3, a=1}

jshell&gt; <span class="bold">Map stringMap = Map.of("a", 1, "b", 2, "c", 3);</span>
stringMap ==&gt; {b=2, c=3, a=1}

jshell&gt; <span class="bold">/exit</span>
|  Goodbye

C:\Program Files\Java\jdk-9\bin&gt;<span class="bold">jshell</span>
|  Welcome to JShell -- Version 9-ea
|  For an introduction type: /help intro

jshell&gt; <span class="bold">Map stringMap = Map.of("a", 1, "b", 2, "c", 3);</span>
stringMap ==&gt; {a=1, b=2, c=3}
</code></pre><p>由<span class="apiname">Set.of</span> ， <span class="apiname">Map.of</span>和<span class="apiname">Map.ofEntries</span>方法创建的集合实例是唯一其迭代顺序是随机的实例。集合实现（例如<span class="apiname">HashMap</span>和<span class="apiname">HashSet</span> ）的迭代顺序不变。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4" name="GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4"></a><h3 id="JSCOR-GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4" class="sect3">关于不变性</h3>
               <div>
                  <p>通常，通过JDK 9中添加的便捷工厂方法返回的集合是不可变的。从这些集合中添加，设置或删除元素的任何尝试都会引发<span class="apiname">UnsupportedOperationException</span> 。
                  </p>
                  <p>这些集合不是<span class="q">“不变的持久性”</span>或<span class="q">“功能性”</span>集合。如果使用的是这些集合之一，则可以对其进行修改，但是当您这样做时，将返回一个新的更新的集合，该集合可以共享第一个集合的结构。
                  </p>
                  <p>不可变集合的一个优点是它是自动线程安全的。创建集合后，您可以将其移交给多个线程，它们都将看到一致的视图。</p>
                  <p>但是，对象的不可变集合与对象的不可变集合不同。如果所包含的元素是可变的，则可能导致集合的行为不一致或使其内容似乎发生变化。</p>
                  <p>我们来看一个不可变集合包含可变元素的示例。使用<code class="codeph">jshell</code> ，使用<span class="apiname">ArrayList</span>类创建两个<span class="apiname">String</span>对象列表，其中第二个列表是第一个列表的副本。不重要的<code class="codeph">jshell</code>输出已删除。
                  </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span>
jshell&gt; <span class="bold">list1.add("a")</span>
jshell&gt; <span class="bold">list1.add("b")</span>
jshell&gt; <span class="bold">list1</span>
list1 ==&gt; [a, b]

jshell&gt; <span class="bold">List&lt;String&gt; list2 = new ArrayList&lt;&gt;(list1);</span>
list2 ==&gt; [a, b]</code></pre><p>接下来，使用<span class="apiname">List.of</span>方法，创建<code class="codeph">ilist1</code>和<code class="codeph">ilist2</code>指向第一个列表。如果您尝试修改<code class="codeph">ilist1</code> ，那么您会看到一个异常错误，因为<code class="codeph">ilist1</code>是一成不变的。任何修改尝试都会引发异常。
                  </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">List&lt;List&lt;String&gt;&gt; ilist1 = List.of(list1, list1);</span>
ilist1 ==&gt; [[a, b], [a, b]]

jshell&gt; <span class="bold">List&lt;List&lt;String&gt;&gt; ilist2 = List.of(list2, list2);</span>
ilist2 ==&gt; [[a, b], [a, b]]

jshell&gt; <span class="bold">ilist1.add(new ArrayList&lt;String&gt;())</span>
|  java.lang.UnsupportedOperationException thrown:
|        at ImmutableCollections.uoe (ImmutableCollections.java:70)
|        at ImmutableCollections$AbstractImmutableList.add (ImmutableCollections
.java:76)
|        at (#10:1)
</code></pre><p>但是如果您修改原始<code class="codeph">list1</code> ， <code class="codeph">ilist1</code>和<code class="codeph">ilist2</code>不再相等。
                  </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">list1.add("c")</span>
jshell&gt; <span class="bold">list1</span>
list1 ==&gt; [a, b, c]
jshell&gt; <span class="bold">ilist1</span>
ilist1 ==&gt; [[a, b, c], [a, b, c]]

jshell&gt; <span class="bold">ilist2</span>
ilist2 ==&gt; [[a, b], [a, b]]

jshell&gt; <span class="bold">ilist1.equals(ilist2)</span>
$14 ==&gt; false
</code></pre><div class="section">
                     <p class="subhead2" id="GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4__RANDOMIZEDITERATIONORDER-D9F4965B">不变和不可修改是不一样的</p>
                     <p>不可变集合的行为与<span class="apiname">Collections.unmodifiable ...</span>包装器的行为相同。但是，这些集合不是包装器-这些是由类实现的数据结构，在这些类中，任何试图修改数据的尝试都将引发异常。
                     </p>
                     <p>如果创建一个<span class="apiname">List</span>并将其传递给<span class="apiname">Collections.unmodifiableList</span>方法，则将获得不可修改的视图。基础列表仍然是可修改的，并且通过返回的<span class="apiname">列表</span>可以看到对其的修改，因此它实际上并不是不可变的。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-4F3E2B7D-CE90-4862-A78A-414FC08DA6E4__GUID-89F8942F-F166-4FB0-ADB2-215F18620C8B">
                     <p>若要演示此行为，请创建一个<span class="apiname">List</span>并将其传递给<span class="apiname">Collections.unmodifiableList</span> 。如果您尝试直接添加到该<span class="apiname">列表</span> ，则会引发异常。
                     </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">List&lt;String&gt; unmodlist1 = Collections.unmodifiableList(list1);</span>
unmodlist1 ==&gt; [a, b, c]

jshell&gt; <span class="bold">unmodlist1.add("d")</span>
|  java.lang.UnsupportedOperationException thrown:
|        at Collections$UnmodifiableCollection.add (Collections.java:1056)
|        at (#17:1)
</code></pre><p>但是，如果您更改原始<code class="codeph">list1</code> ，则不会产生错误，并且<code class="codeph">unmodlist1</code>列表已被修改。
                     </p><pre class="pre codeblock"><code>jshell&gt; <span class="bold">list1.add("d")</span>
$19 ==&gt; true
jshell&gt; <span class="bold">list1</span>
list1 ==&gt; [a, b, c, d]

jshell&gt; <span class="bold">unmodlist1</span>
unmodlist1 ==&gt; [a, b, c, d]
</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199" name="GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199"></a><h3 id="JSCOR-GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199" class="sect3">空间效率</h3>
               <div>
                  <p>便捷工厂方法返回的集合比其可变的等效项在空间效率上更高。</p>
                  <p>这些集合的所有实现都是隐藏在静态工厂方法后面的私有类。调用它时，静态工厂方法根据大小选择实现类。数据可以以紧凑的基于字段或基于阵列的布局存储。</p>
                  <div class="p">让我们看一下两个替代实现所消耗的堆空间。首先，这是一个不可修改的<span class="apiname">HashSet</span> ，其中包含两个字符串：<pre class="pre codeblock"><code>Set&lt;String&gt; set = new HashSet&lt;&gt;(3);   // 3 buckets
set.add("silly");
set.add("string");
set = Collections.unmodifiableSet(set);</code></pre>该集合包括六个对象：不可修改的包装器； <span class="apiname">HashSet</span> ，其中包含一个<span class="apiname">HashMap</span> ；桶表（数组）；和两个<span class="apiname">Node</span>实例（每个元素一个）。在典型的VM（每个对象有12个字节的标头）上，集合的总开销为96字节+ 28 * 2 = 152字节。与存储的数据量相比，这是大量的开销。另外，对数据的访问不可避免地需要多个方法调用和指针取消引用。
                  </div>
                  <p>相反，我们可以使用<span class="apiname">Set.of</span>实现集合：</p><pre class="pre codeblock"><code>Set&lt;String&gt; set = Set.of("silly", "string");</code></pre><p>因为这是基于字段的实现，所以该集合包含一个对象和两个字段。开销为20个字节。无论是在固定开销上还是在每个元素的基础上，新集合都消耗更少的堆空间。</p>
                  <p>不需要支持突变也有助于节省空间。另外，由于保存数据所需的对象较少，因此改进了引用的局部性。</p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>