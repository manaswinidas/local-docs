<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <meta name="description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <title>序列化过滤</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T08:11:40-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94895-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-core-libraries1.html" title="Previous" type="text/html">
      <link rel="next" href="enhanced-deprecation1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-core-libraries1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="enhanced-deprecation1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">核心图书馆</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">序列化过滤</li>
            </ol>
            <a id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" name="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A"></a>
            
            <h2 id="JSCOR-GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" class="sect2"><span class="enumeration_chapter">2</span>序列化过滤</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用Java序列化过滤机制来帮助防止反序列化漏洞。您可以定义基于模式的过滤器，也可以创建自定义过滤器。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A__GUID-A1F99FA7-F03B-4A05-AC6A-BBC71C48F7D2">话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" title="接受不受信任的数据并将其反序列化的应用程序很容易受到攻击。您可以创建过滤器来筛选序列化对象的输入流，然后再对其进行反序列化。">解决反序列化漏洞</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" title="Java序列化过滤机制筛选传入的序列化对象流，以帮助提高安全性和鲁棒性。过滤器可以在反序列化输入类之前对其进行验证。">Java序列化过滤器</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" title="可以使用基于模式的过滤器或自定义过滤器来实现白名单和黑名单。这些列表使您可以采取主动和防御性方法来保护您的应用程序。">白名单和黑名单</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-91735293-E38E-4A81-85DC-719AFEB36026" title="基于模式的过滤器是您在不更改应用程序代码的情况下定义的过滤器。您可以在属性文件中添加进程范围的过滤器，或者在Java命令行中添加特定于应用程序的过滤器。">创建基于模式的过滤器</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" title="自定义过滤器是您在应用程序代码中指定的过滤器。它们在流程中的单个流或所有流上设置。您可以将自定义过滤器实现为模式，方法，lambda表达式或类。">创建自定义过滤器</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="Java远程方法调用（RMI）注册表，RMI分布式垃圾收集器和Java管理扩展（JMX）都具有JDK中包含的过滤器。您应该为RMI注册表和RMI分布式垃圾收集器指定自己的过滤器，以增加其他保护。">内置过滤器</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-6A048F49-052E-4591-9183-2775DC50831E" title="您可以打开日志记录，以记录对序列化过滤器的调用的初始化，拒绝和接受。在配置白名单和黑名单时，可以将日志输出用作诊断工具来查看正在反序列化的内容，并确认设置。">记录过滤器操作</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" name="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480"></a><h3 id="JSCOR-GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" class="sect3">解决反序列化漏洞</h3>
               <div>
                  <p>接受不受信任的数据并将其反序列化的应用程序很容易受到攻击。您可以创建过滤器来筛选序列化对象的输入流，然后再对其进行反序列化。</p>
                  <p>当对象的状态转换为字节流时，该对象将被序列化。该流可以发送到文件，数据库或网络。如果Java对象的类或其任何超类实现了<span class="apiname">java.io，则它是可序列化的。可序列化的</span>接口或<span class="apiname">java.io。可外部化的</span>子接口。在JDK中，序列化用于很多领域，包括远程方法调用（RMI），用于进程间通信（IPC）协议的自定义RMI（例如Spring HTTP调用程序），Java管理扩展（JMX）和Java消息服务（JMS） ）。
                  </p>
                  <p>当对象的序列化形式转换为该对象的副本时，该对象将反序列化。确保此转换的安全性很重要。反序列化是代码执行，因为要反序列化的类的<span class="apiname">readObject</span>方法可以包含自定义代码。可序列化的类（也称为<span class="q">“小工具类”</span> ）可以执行任意反射操作，例如创建类并在其上调用方法。如果您的应用程序反序列化这些类，则它们可能导致拒绝服务或远程执行代码。
                  </p>
                  <p>创建过滤器时，可以指定应用程序可以接受哪些类，哪些应该被拒绝。您可以在反序列化期间控制对象图的大小和复杂度，以使对象图不会超出合理的限制。筛选器可以配置为属性，也可以通过编程实现。</p>
                  <div class="p">除了创建过滤器之外，您还可以采取以下措施来防止反序列化漏洞：<ul style="list-style-type:disc">
                        <li>
                           <p>不要反序列化不受信任的数据。</p>
                        </li>
                        <li>
                           <p>使用SSL加密和验证应用程序之间的连接。</p>
                        </li>
                        <li>
                           <p>在分配之前验证字段值，包括使用<span class="apiname">readObject</span>方法检查对象不变式。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnote" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-87B52F1C-9D44-483B-80AA-B2C8A4B0C06E">
                     <p class="notep1">注意：</p>为RMI提供了内置过滤器。但是，您应该仅将这些内置过滤器用作起点。配置黑名单和/或扩展白名单，以为使用RMI的应用程序添加额外的保护。请参阅<a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="Java远程方法调用（RMI）注册表，RMI分布式垃圾收集器和Java管理扩展（JMX）都具有JDK中包含的过滤器。您应该为RMI注册表和RMI分布式垃圾收集器指定自己的过滤器，以增加其他保护。">内置过滤器</a> 。
                  </div>
                  <p>有关这些策略和其他策略的更多信息，请参见<span class="q">《</span> <a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html" target="_blank">Java SE安全编码指南</a> <span class="q">》</span>中的<span class="q">“序列化和反序列化”</span> 。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" name="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66"></a><h3 id="JSCOR-GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" class="sect3">Java序列化过滤器</h3>
               <div>
                  <p>Java序列化过滤机制筛选传入的序列化对象流，以帮助提高安全性和鲁棒性。过滤器可以在反序列化输入类之前对其进行验证。</p>
                  <div class="p">如JEP 290中所述，Java序列化过滤机制的目标是：<ul style="list-style-type:disc">
                        <li>
                           <p>提供一种将可以反序列化的类缩小为上下文适合的类集的方法。</p>
                        </li>
                        <li>
                           <p>为反序列化期间的图表大小和复杂度向过滤器提供指标，以验证正常的图表行为。</p>
                        </li>
                        <li>
                           <p>允许RMI导出的对象验证调用中期望的类。</p>
                        </li>
                     </ul>
                  </div>
                  <p>您可以通过以下方式实现序列化过滤器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>基于模式的过滤器不需要您修改应用程序。它们由一系列模式组成，这些模式在属性，配置文件或命令行中定义。基于模式的过滤器可以接受或拒绝特定的类，程序包或模块。他们可以限制数组大小，图形深度，总引用和流大小。典型的用例是将已被识别为可能危害Java运行时的类列入黑名单。为一个应用程序或流程中的所有应用程序定义了基于模式的过滤器。</p>
                     </li>
                     <li>
                        <p>使用<span class="apiname">ObjectInputFilter</span> API实现自定义过滤器。它们允许应用程序集成比基于模式的过滤器更好的控制，因为它们可以特定于每个<span class="apiname">ObjectInputStream</span> 。在单个输入流或流程中的所有流上设置自定义过滤器。
                        </p>
                     </li>
                  </ul>
                  <p>针对流中的每个新对象调用过滤器机制。如果存在多个活动过滤器（过程范围过滤器，应用程序过滤器或特定于流的过滤器），则仅调用最特定的过滤器。</p>
                  <p>在大多数情况下，自定义过滤器应检查是否设置了进程范围的过滤器。如果存在，则自定义过滤器应调用它并使用进程范围过滤器的结果，除非状态为<code class="codeph">UNDECIDED</code> 。
                  </p>
                  <p>从JDK 9开始包含对序列化过滤器的支持，在Java CPU版本中从8u121、7u131和6u141开始。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" name="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25"></a><h3 id="JSCOR-GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" class="sect3">白名单和黑名单</h3>
               <div>
                  <p>可以使用基于模式的过滤器或自定义过滤器来实现白名单和黑名单。这些列表使您可以采取主动和防御性方法来保护您的应用程序。</p>
                  <p>主动方法使用白名单来仅接受公认和信任的类。您可以在开发应用程序时在代码中实现白名单，也可以稍后定义基于模式的过滤器。如果您的应用程序仅处理少量的类，则此方法可以很好地工作。您可以通过指定允许的类，程序包或模块来实现白名单。</p>
                  <p>防御方法使用黑名单拒绝不信任的类。通常，黑名单是在发现某个类存在问题的攻击后实施的。通过定义基于模式的过滤器，无需更改代码即可将类添加到黑名单。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-91735293-E38E-4A81-85DC-719AFEB36026" name="GUID-91735293-E38E-4A81-85DC-719AFEB36026"></a><h3 id="JSCOR-GUID-91735293-E38E-4A81-85DC-719AFEB36026" class="sect3">创建基于模式的过滤器</h3>
               <div>
                  <p>基于模式的过滤器是您在不更改应用程序代码的情况下定义的过滤器。您可以在属性文件中添加流程范围的过滤器，也可以在<code class="codeph">java</code>命令行。
                  </p>
                  <p>基于模式的过滤器是一系列模式。每个模式都与流中的类名称或资源限制匹配。可以将基于类的资源限制模式组合在一个过滤器字符串中，每种模式都用分号（;）分隔。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-EC22FEC6-A855-4152-9049-23F38E590256">基于模式的过滤器语法</p>
                     <div class="p">创建由模式组成的过滤器时，请遵循以下准则：<ul style="list-style-type:disc">
                           <li>
                              <p>用分号分隔模式。例如：</p><pre class="pre codeblock"><code>pattern1.*;pattern2.*</code></pre></li>
                           <li>
                              <p>空白很重要，被认为是模式的一部分。</p>
                           </li>
                           <li>
                              <p>将限制放在字符串的第一位。无论它们在字符串中的什么位置，都将首先评估它们，因此将它们放在第一位可加强顺序。否则，从左到右评估模式。</p>
                           </li>
                           <li>
                              <div class="p">与前面的模式匹配的类<code class="codeph">!</code>被拒绝。一个与模式匹配但没有<code class="codeph">!</code>被接受。以下过滤器拒绝<code class="codeph">pattern1.MyClass</code>但接受<code class="codeph">pattern2.MyClass</code> ：<pre class="pre codeblock"><code>!pattern1.*;pattern2.*</code></pre></div>
                           </li>
                           <li>
                              <div class="p">使用通配符（ <code class="codeph">*</code> ）以一种模式表示未指定的类，如以下示例所示：<ul style="list-style-type:disc">
                                    <li>
                                       <p>要匹配每个班级，请使用<code class="codeph">*</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p>匹配每个班级<code class="codeph">mypackage</code> ， 使用<code class="codeph">mypackage.*</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p>匹配每个班级<code class="codeph">mypackage</code>及其子包，使用<code class="codeph">mypackage.**</code></p>
                                    </li>
                                    <li>
                                       <p>匹配所有以<code class="codeph">text</code> ， 使用<code class="codeph">text*</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p>如果一个类与任何过滤器都不匹配，则它被接受。如果您只想接受某些类，则过滤器必须拒绝所有不匹配的内容。要拒绝除指定类别之外的所有其他类别，请包括<code class="codeph">!*</code>作为类过滤器中的最后一个模式。
                     </p>
                     <p>有关模式语法的完整说明，请参见<code class="codeph">conf/security/java.security</code>文件，或参见<a href="http://openjdk.java.net/jeps/290" target="_blank">JEP 290</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-B3365B18-7AA0-4B9A-A305-DD22D21F0602">基于模式的过滤器限制</p>
                     <p>基于模式的过滤器用于简单的接受或拒绝。这些过滤器有一些限制。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>模式不允许基于类的不同大小的数组。</p>
                        </li>
                        <li>
                           <p>模式无法根据类的超类型或接口来匹配类。</p>
                        </li>
                        <li>
                           <p>模式没有状态，并且无法做出选择，具体取决于流中反序列化的早期类。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5D6D5344-3E6F-468E-8CBB-05767E04B254">为一个应用程序定义基于模式的过滤器</p>
                     <p>您可以将基于模式的过滤器定义为一个应用程序的系统属性。系统属性取代安全属性值。</p>
                     <p>要创建仅适用于一个应用程序且仅适用于Java单个调用的过滤器，请定义<code class="codeph">jdk.serialFilter</code>命令行中的系统属性。
                     </p>
                     <p>下面的示例显示如何限制单个应用程序的资源使用：</p><pre class="pre codeblock"><code>java -Djdk.serialFilter=maxarray=100000;maxdepth=20;maxrefs=500&nbsp;com.example.test.Application</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__DEFINEAPATTERN-BASEDFILTERFORONEAPP-631AE055">为流程中的所有应用程序定义基于模式的过滤器</p>
                     <p>您可以为流程中的所有应用程序将基于模式的过滤器定义为安全性属性。系统属性取代安全属性值。</p>
                     <ol>
                        <li>
                           <div class="p">编辑<code>java.security</code>属性文件。
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>JDK 9及更高版本：<code>$JAVA_HOME/conf/security/java.security</code></p>
                                 </li>
                                 <li>
                                    <p>JDK 8,7,6： <code>$JAVA_HOME/lib/security/java.security</code>  
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>将图案添加到<code class="codeph">jdk.serialFilter</code>安全属性。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5CE8B605-78A3-4B10-9DE8-5108EEB452A7">定义一个类过滤器</p>
                     <p>您可以创建一个全局应用的基于模式的类过滤器。例如，模式可以是类名或带有通配符的包。</p>
                     <div class="p">在以下示例中，过滤器拒绝包中的一个类（ <code class="codeph">!example.somepackage.SomeClass</code> ），并接受包中的所有其他类：<pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;</code></pre></div>
                     <div class="p">前面的示例过滤器接受所有其他类，而不仅仅是<code class="codeph">example.somepackage.*</code> 。要拒绝所有其他类别，请添加<code class="codeph">!*</code> ：<pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;<span class="bold">!*</span></code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-F0AE9610-1379-44D6-A051-8F67E5522065">定义资源限制过滤器</p>
                     <div class="p">资源过滤器限制了图的复杂性和大小。您可以为以下参数创建过滤器，以控制每个应用程序的资源使用情况：<ul style="list-style-type:disc">
                           <li>
                              <p>允许的最大数组大小。例如： <code class="codeph">maxarray=100000;</code> 
                              </p>
                           </li>
                           <li>
                              <p>图形的最大深度。例如： <code class="codeph">maxdepth=20;</code> 
                              </p>
                           </li>
                           <li>
                              <p>对象之间的图形中的最大引用。例如： <code class="codeph">maxrefs=500;</code> 
                              </p>
                           </li>
                           <li>
                              <p>流中的最大字节数。例如： <code class="codeph">maxbytes=500000;</code> 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" name="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E"></a><h3 id="JSCOR-GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" class="sect3">创建自定义过滤器</h3>
               <div>
                  <p>自定义过滤器是您在应用程序代码中指定的过滤器。它们在流程中的单个流或所有流上设置。您可以将自定义过滤器实现为模式，方法，lambda表达式或类。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__DESERIALIZINGOBJECTSFROMASTREAM-50A5362A">读取序列化对象流</p>
                     <p>您可以在一个上设置自定义过滤器<code class="codeph">ObjectInputStream</code> ，或者要将同一过滤器应用于每个流，请设置一个进程范围的过滤器。如果<code class="codeph">ObjectInputStream</code>没有为它定义一个过滤器，如果有的话，将调用全过程过滤器。
                     </p>
                     <p>在对流进行解码时，将发生以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li> 
                           <p>对于流中的每个新对象，在实例化和反序列化对象之前将调用过滤器。</p>
                        </li>
                        <li>
                           <p>对于流中的每个类，将使用已解析的类来调用过滤器。对于流中的每个超类型和接口分别调用它。</p>
                        </li>
                        <li>
                           <p>过滤器可以检查流中引用的每个类，包括要创建的对象的类，这些类的超类型及其接口。</p>
                        </li>
                        <li>
                           <p>对于流中的每个数组，无论是原始数组，字符串数组还是对象数组，都将使用数组类和数组长度来调用过滤器。</p>
                        </li>
                        <li>
                           <p>对于已经从流中读取的对对象的每个引用，都将调用过滤器，以便可以检查深度，引用数和流长度。深度从1开始，并针对每个嵌套对象增加，并在每个嵌套调用返回时减小。</p>
                        </li>
                        <li>
                           <p>不为基本体或<span class="apiname">java.lang调用过滤器<span class="apiname">。在流中具体编码的字符串</span>实例。
                           </span></p>
                        </li>
                        <li>
                           <p>过滤器返回接受，拒绝或未确定的状态。</p>
                        </li>
                        <li>
                           <p>如果启用了日志记录，则会记录过滤器操作。</p>
                        </li>
                     </ul>
                     <p>除非过滤器拒绝对象，否则对象将被接受。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__SETTINGAFILTERFORANINDIVIDUALSTREAM-51012200">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-8BB4703B-04A7-4205-9257-7B79C9BB96D4">为单个流设置自定义过滤器</p>
                     <p>当流的输入不受信任并且筛选器具有一组有限的要强制执行的类或约束时，可以在单个<span class="apiname">ObjectInputStream</span>上设置筛选器。例如，您可以确保流仅包含数字，字符串和其他应用程序指定的类型。
                     </p>
                     <p>自定义过滤器是使用<span class="apiname">setObjectInputFilter</span>方法设置。必须先设置自定义过滤器，然后才能从流中读取对象。
                     </p>
                     <p>在以下示例中，使用<span class="apiname">setObjectInputFilter</span>方法调用<code class="codeph">dateTimeFilter</code>方法。该过滤器仅接受<span class="apiname">java.time</span>包中的类。的<code class="codeph">dateTimeFilter</code>在“ <a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__IMPLEMENTINGACUSTOMFILTERASAMETHOD-54AED1D7">将自定义过滤器设置为</a>方法”中的代码示例中<a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__IMPLEMENTINGACUSTOMFILTERASAMETHOD-54AED1D7">定义了method</a> 。
                     </p>
                     <div class="p"><pre class="pre codeblock"><code>    LocalDateTime readDateTime(InputStream is) throws IOException {
        try (ObjectInputStream ois = new ObjectInputStream(is)) {
            ois.setObjectInputFilter(FilterClass::dateTimeFilter);
            return (LocalDateTime) ois.readObject();
        } catch (ClassNotFoundException ex) {
            IOException ioe = new StreamCorruptedException("class missing");
            ioe.initCause(ex);
            throw ioe;
        }
    }</code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-182FDEED-AA81-4EFF-9762-76390C1AACFE">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-02A2A232-D1EE-48C5-9456-DA11C24BA5A7">设置流程范围的自定义过滤器</p>
                     <p>您可以设置一个进程范围的过滤器，该过滤器适用于<span class="apiname">ObjectInputStream的</span>每次使用，除非它在特定的流上被覆盖。如果您可以确定整个应用程序所需的每种类型和条件，则过滤器可以允许这些类型和条件，而拒绝其余的类型和条件。通常，过程范围的筛选器用于拒绝特定的类或包，或限制数组大小，图形深度或图形总大小。
                     </p>
                     <p>使用<span class="apiname">ObjectInputFilter的方法设置一次进程范围的过滤器<span class="apiname">。Config</span>类。过滤器可以是类，lambda表达式，方法引用或模式的实例。
                     </span></p><pre class="pre codeblock"><code>    ObjectInputFilter filter = ...
    ObjectInputFilter.Config.setSerialFilter(filter);
</code></pre><p>在下面的示例中，使用lambda表达式设置进程范围的过滤器。</p><pre class="pre codeblock"><code>    ObjectInputFilter.Config.setSerialFilter(info -&gt; info.depth() &gt; 10 ? Status.REJECTED : Status.UNDECIDED);
</code></pre><p>在以下示例中，使用类的实例设置进程范围的过滤器。</p><pre class="pre codeblock"><code>    ObjectInputFilter.Config.setSerialFilter(FilterClass::dateTimeFilter);</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-57F34BA4-3982-421D-89CD-F4C83FC7EF0B">使用模式设置自定义过滤器</p>
                     <p>使用<span class="apiname">ObjectInputFilter可以创建基于模式的自定义过滤器，该过滤器对于简单情况很方便<span class="apiname">。Config.createFilter</span>方法。您可以将基于模式的过滤器创建为系统属性或“安全性”属性。将基于模式的过滤器实现为方法或lambda表达式可为您提供更大的灵活性。
                     </span></p>
                     <p>过滤器模式可以接受或拒绝特定的类，程序包，模块，并且可以限制数组大小，图形深度，总引用和流大小。模式不能匹配类的超类型或接口。</p>
                     <div class="p">在以下示例中，过滤器允许<code class="codeph">example.File</code>并拒绝<code class="codeph">example.Directory</code>类。<pre class="pre codeblock"><code>    ObjectInputFilter filesOnlyFilter = ObjectInputFilter.Config.createFilter("example.File;!example.Directory");
</code></pre></div>
                     <div class="p">这个例子只允许<code class="codeph">example.File</code> 。所有其他类别均被拒绝。<pre class="pre codeblock"><code>    ObjectInputFilter filesOnlyFilter = ObjectInputFilter.Config.createFilter("example.File;!*");
</code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-50E87F6F-2E7B-4F73-9E1B-ADD031551256">将自定义过滤器设置为类</p>
                     <p>可以将自定义过滤器实现为实现<span class="apiname">java.io的类。ObjectInputFilter</span>接口，可以是lambda表达式，也可以是方法。
                     </p>
                     <p>过滤器通常是无状态的，仅对输入参数执行检查。但是，您可以实现一个过滤器，例如，在调用之间保持状态<code class="codeph">checkInput</code>计算流中伪像的方法。
                     </p>
                     <p>在以下示例中， <code class="codeph">FilterNumber</code>类允许作为对象实例的任何对象<code class="codeph">Number</code>上课并拒绝所有其他人。
                     </p><pre class="pre codeblock"><code>    class FilterNumber implements ObjectInputFilter {
        public Status checkInput(FilterInfo filterInfo) {
            Class&lt;?&gt; clazz = filterInfo.serialClass();
            if (clazz != null) {
                return (Number.class.isAssignableFrom(clazz)) ? Status.ALLOWED : Status.REJECTED;
            }
            return Status.UNDECIDED;
        }
    }</code></pre><p>在示例中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>的<code class="codeph">checkInput</code>方法接受<code class="codeph">ObjectInputFilter.FilterInfo</code>宾语。对象的方法提供对要检查的类的访问，数组大小，当前深度，对现有对象的引用数以及到目前为止读取的流大小。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">serialClass</code>不为null，表示正在创建一个新对象，将检查该值以查看该对象的类是否为<code class="codeph">Number</code> 。如果是这样，它被接受，否则它被拒绝。
                           </p>
                        </li>
                        <li>
                           <p>参数的任何其他组合返回<code class="codeph">UNDECIDED</code> 。反序列化继续进行，所有剩余的过滤器都会运行，直到对象被接受或拒绝为止。如果没有其他过滤器，则接受该对象。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__IMPLEMENTINGACUSTOMFILTERASAMETHOD-54AED1D7">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-2D9120BA-1262-4CD0-8C0F-2D7B2FE09DC7">将自定义过滤器设置为方法</p>
                     <p>定制过滤器也可以实现为方法。使用方法引用代替内联lambda表达式。</p>
                     <p>的<code class="codeph">dateTimeFilter</code> <a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__SETTINGAFILTERFORANINDIVIDUALSTREAM-51012200">设置单个流的自定义过滤器中</a>的代码示例使用了以下示例中定义的方法。
                     </p><pre class="pre codeblock"><code>    public class FilterClass {
        static ObjectInputFilter.Status dateTimeFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getPackageName().equals("java.time")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
        }
    }</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-8C13D401-0AF8-4E0D-8240-798915982690">示例：过滤java.base模块中的类</p>
                     <p>这个自定义过滤器（也实现为方法）仅允许在JDK的基本模块中找到类。本示例适用于JDK 9及更高版本。</p><pre class="pre codeblock"><code>        static ObjectInputFilter.Status baseFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getModule().getName().equals("java.base")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
       }</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" name="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841"></a><h3 id="JSCOR-GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" class="sect3">内置过滤器</h3>
               <div>
                  <p>Java远程方法调用（RMI）注册表，RMI分布式垃圾收集器和Java管理扩展（JMX）都具有JDK中包含的过滤器。您应该为RMI注册表和RMI分布式垃圾收集器指定自己的过滤器，以增加其他保护。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-4A6545F6-C1BA-4F4B-B5FB-1A0FFC17EE58">RMI注册表过滤器</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-2EDDE4F4-6635-4724-BE9B-E250436F23AE">
                        <p class="notep1">注意：</p>仅将这些内置过滤器用作起点。编辑<code class="codeph">sun.rmi.registry.registryFilter</code>系统属性以配置黑名单和/或扩展白名单，以为RMI注册表添加其他保护。为了保护整个应用程序，请将模式添加到<code class="codeph">jdk.serialFilter</code>全局系统属性，以增加对没有自己的自定义过滤器的其他序列化用户的保护。
                     </div>
                     <p>RMI注册表具有内置的白名单过滤器，该过滤器允许将对象绑定到注册表中。它包括<code class="codeph">java.rmi.Remote</code> ， <code class="codeph">java.lang.Number</code> ， <code class="codeph">java.lang.reflect.Proxy</code> ， <code class="codeph">java.rmi.server.UnicastRef</code> ， <code class="codeph">java.rmi.activation.ActivationId</code> ， <code class="codeph">java.rmi.server.UID</code> ， <code class="codeph">java.rmi.server.RMIClientSocketFactory</code>和<code class="codeph">java.rmi.server.RMIServerSocketFactory</code>类。
                     </p>
                     <div class="p">内置过滤器包括尺寸限制：<pre class="pre codeblock"><code> maxarray=1000000,maxdepth=20</code></pre></div>
                     <p>通过使用定义过滤器来取代内置过滤器<code class="codeph">sun.rmi.registry.registryFilter</code>具有模式的系统属性。如果您定义的过滤器接受传递给该过滤器的类，或者拒绝这些类或大小，则不会调用内置过滤器。如果您的过滤器不接受或拒绝任何内容，则将调用内置过滤器。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-1FA9EA68-C15E-4D08-B938-368EB4B3CF58">RMI分布式垃圾收集器的过滤器</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-5C6D93BF-3B7B-41DA-9F7C-A1D387A9A2F6">
                        <p class="notep1">注意：</p>仅将这些内置过滤器用作起点。编辑<code class="codeph">sun.rmi.transport.dgcFilter</code>系统属性，以配置黑名单和/或扩展白名单以为分布式垃圾收集器添加附加保护。为了保护整个应用程序，请将模式添加到<code class="codeph">jdk.serialFilter</code>全局系统属性，以增加对没有自己的自定义过滤器的其他序列化用户的保护。
                     </div>
                     <p>RMI分布式垃圾收集器具有一个内置的白名单过滤器，可以接受一组有限的类。它包括<code class="codeph">java.rmi.server.ObjID</code> ， <code class="codeph">java.rmi.server.UID</code> ， <code class="codeph">java.rmi.dgc.VMID</code>和<code class="codeph">java.rmi.dgc.Lease</code>类。
                     </p>
                     <div class="p">内置过滤器包括尺寸限制：<pre class="pre codeblock"><code>maxarray=1000000,maxdepth=20</code></pre></div>
                     <p>通过使用定义过滤器来取代内置过滤器<code class="codeph">sun.rmi.transport.dgcFilter</code>具有模式的系统属性。如果过滤器接受传递给过滤器的类，或者拒绝类或大小，则不会调用内置过滤器。如果取代的过滤器不接受或拒绝任何内容，则将调用内置过滤器。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-AD9BEFEA-80D5-49C8-88EC-766F2D2BE3C9">JMX过滤器</p>您可以指定在进行<span class="apiname">RMIServer.newClient</span>远程调用以及通过RMI向服务器发送反序列化参数时使用的反序列化过滤器模式字符串。您还可以使用以下命令向默认代理提供过滤器模式字符串<code class="codeph">management.properties</code>文件。
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6A048F49-052E-4591-9183-2775DC50831E" name="GUID-6A048F49-052E-4591-9183-2775DC50831E"></a><h3 id="JSCOR-GUID-6A048F49-052E-4591-9183-2775DC50831E" class="sect3">记录过滤器操作</h3>
               <div>
                  <p>您可以打开日志记录，以记录对序列化过滤器的调用的初始化，拒绝和接受。在配置白名单和黑名单时，可以将日志输出用作诊断工具来查看正在反序列化的内容，并确认设置。</p>
                  <p>启用日志记录后，过滤器操作将记录到<span class="apiname">java.io.serialization</span>记录器中。
                  </p>
                  <p>要启用序列化过滤器日志记录，请编辑<code class="codeph">$JDK_HOME/conf/logging.properties</code>文件。
                  </p>
                  <div class="p">要记录被拒绝的呼叫，请添加<pre class="pre codeblock"><code>java.io.serialization.level = FINER</code></pre> </div>
                  <div class="p">要记录所有过滤器结果，请添加<pre class="pre codeblock"><code>java.io.serialization.level = FINEST</code></pre> </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>