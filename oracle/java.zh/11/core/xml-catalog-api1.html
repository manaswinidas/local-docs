<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Use the XML Catalog API to implement a local XML catalog.">
      <meta name="description" content="Use the XML Catalog API to implement a local XML catalog.">
      <title>XML Catalog API</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content="Use the XML Catalog API to implement a local XML catalog.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T08:11:40-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94895-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="enhanced-deprecation1.html" title="Previous" type="text/html">
      <link rel="next" href="creating-immutable-lists-sets-and-maps.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="enhanced-deprecation1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="creating-immutable-lists-sets-and-maps.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">核心图书馆</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XML目录API</li>
            </ol>
            <a id="GUID-96D2C9AC-641A-4BDB-BB08-9FA04358A6F4" name="GUID-96D2C9AC-641A-4BDB-BB08-9FA04358A6F4"></a>
            
            <h2 id="JSCOR-GUID-96D2C9AC-641A-4BDB-BB08-9FA04358A6F4" class="sect2"><span class="enumeration_chapter">4</span> XML目录API</h2>
         </header>
         <div class="ind">
            <div>
               <p>使用XML Catalog API来实现本地XML目录。</p>
               <p>Java SE 9引入了新的XML Catalog API，以支持组织结构化信息标准组织（OASIS） <a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" target="_blank">XML Catalogs，即OASIS Standard V1.1</a> 。《 Oracle JDK 9核心库指南》的本章介绍了API，Java XML处理器对其的支持以及使用模式。
               </p>
               <p>XML Catalog API是用于实现本地目录的简单API，JDK XML处理器的支持使配置处理器或整个环境更容易利用该功能。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-96D2C9AC-641A-4BDB-BB08-9FA04358A6F4__GUID-CA8EF513-8478-41BD-809D-196EE02EBAA1">了解有关创建目录的更多信息</p>
                  <p>要了解有关创建目录的信息，请参阅<a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" target="_blank">目录标准</a> 。目录下的XML目录<code class="codeph">/etc/xml/catalog</code>在某些Linux发行版上，也可以作为创建本地目录的良好参考。
                  </p>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-1E93ECBF-4583-4E03-86CF-33A16377604F" name="GUID-1E93ECBF-4583-4E03-86CF-33A16377604F"></a><h3 id="JSCOR-GUID-1E93ECBF-4583-4E03-86CF-33A16377604F" class="sect3">XML Catalog API的目的</h3>
               <div>
                  <p>XML Catalog API和Java XML处理器为开发人员和系统管理员提供了一个更好地管理外部资源的选项。</p>
                  <p>XML Catalog API提供了OASIS XML Catalogs v1.1的实现，该标准旨在解决由外部资源引起的问题。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-1E93ECBF-4583-4E03-86CF-33A16377604F__GUID-7E30F8B3-837A-4AC5-BEBF-9D9AE22064B8">外部资源引起的问题</p>
                     <p>XML，XSD和XSL文档可能包含对Java XML处理器需要检索来处理文档的外部资源的引用。外部资源可能导致应用程序或系统出现问题。Catalog API和Java XML处理器为开发人员和系统管理员提供了一个更好地管理这些外部资源的选项。</p>
                     <div class="p">外部资源可能会在以下方面导致应用程序或系统出现问题：<ul style="list-style-type:disc">
                           <li>
                              <p>可用性。当资源是远程的时，XML处理器必须能够连接到远程服务器。尽管连接很少是一个问题，但它仍然是应用程序稳定性的一个因素。太多的连接可能会对拥有资源的服务器造成危害（例如，有据可查的案例表明，直接到W3C服务器的DTD流量过多），这反过来又可能影响您的应用程序。有关<a href="xml-catalog-api1.html#GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036" title="Use the XML Catalog API with various Java XML processors.">使用</a> XML Catalog API解决此问题的示例，请参见<a href="xml-catalog-api1.html#GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036" title="将XML Catalog API与各种Java XML处理器一起使用。">使用XML处理器</a>使用目录。</p>
                           </li>
                           <li>
                              <p>性能。尽管在大多数情况下连接不是问题，但是远程访存仍可能导致应用程序性能问题。此外，同一系统上可能有多个应用程序试图解析同一源，这将浪费系统资源。</p>
                           </li>
                           <li>
                              <p>安全。如果应用程序处理不受信任的XML源，则允许远程连接会带来安全风险。</p>
                           </li>
                           <li>
                              <p>可管理性。如果系统处理大量的XML文档，则外部引用的文档（无论是本地的还是远程的）都可能成为维护麻烦。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1E93ECBF-4583-4E03-86CF-33A16377604F__GUID-82C5A675-26C7-433F-9773-1C7131ABB8E0">XML Catalog API如何解决由外部资源引起的问题</p>
                     <p>XML Catalog API和Java XML处理器为开发人员和系统管理员提供了一个更好地管理外部资源的选项。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>应用程序开发人员–您可以为应用程序创建一个包含所有外部引用的本地目录，然后让Catalog API为应用程序解析它们。这不仅避免了远程连接，而且使管理这些资源变得更加容易。</p>
                        </li>
                        <li>
                           <p>系统管理员–您可以为系统建立本地目录，并将Java VM配置为指向目录。然后，假定它们与Java SE 9兼容，则系统上的所有应用程序都可以共享同一目录，而无需对应用程序进行任何代码更改。要建立目录，您可以利用现有目录，例如某些Linux发行版随附的目录。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF" name="GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF"></a><h3 id="JSCOR-GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF" class="sect3">XML目录API接口</h3>
               <div>
                  <p>通过其接口访问XML Catalog API。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF__GUID-F365A0B8-9F28-44A8-812D-20E883809EDA">XML目录API接口</p>
                     <p>XML Catalog API定义了以下接口：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>的<code class="codeph">Catalog</code> interface表示由<a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" target="_blank">XML Catalogs（OASIS标准V1.1，2005年10月7日）</a>定义的实体目录。一种<code class="codeph">Catalog</code>对象是不可变的。创建完成后， <code class="codeph">Catalog</code>对象可用于在<code class="codeph">system</code> ， <code class="codeph">public</code> ， 要么<code class="codeph">uri</code>条目。定制解析器实现可能会发现通过目录定位本地资源很有用。
                           </p>
                        </li>
                        <li>
                           <p>的<code class="codeph">CatalogFeatures</code>类包含Catalog API支持的所有功能和属性，包括<code class="codeph">javax.xml.catalog.files</code> ， <code class="codeph">javax.xml.catalog.defer</code> ， <code class="codeph">javax.xml.catalog.prefer</code>和<code class="codeph">javax.xml.catalog.resolve</code> 。
                           </p>
                        </li>
                        <li>
                           <p>的<code class="codeph">CatalogManager</code>类管理XML目录和目录解析器的创建。
                           </p>
                        </li>
                        <li>
                           <p>的<code class="codeph">CatalogResolver</code>接口是实现SAX的目录解析器<code class="codeph">EntityResolver</code> ，StAX <code class="codeph">XMLResolver</code> ，DOM LS <code class="codeph">LSResourceResolver</code>用于模式验证和转换<code class="codeph">URIResolver</code> 。此接口使用目录解析外部引用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF__GUID-EB39BEC9-94E6-4ED2-BD9A-2B03401CFE00">CatalogFeatures类的详细信息</p>
                     <p>目录功能是在<span class="apiname">CatalogFeatures</span>类中共同定义的。这些功能是在API和系统级别定义的，这意味着可以通过API，系统属性和JAXP属性进行设置。要通过API设置功能，请使用<span class="apiname">CatalogFeatures</span>类。
                     </p>
                     <p>以下代码将<span class="apiname">javax.xml.catalog.resolve</span>设置为<code class="codeph">"continue"</code>因此，即使<code class="codeph">CatalogResolver</code> ：</p><pre class="pre codeblock"><code>CatalogFeatures f = CatalogFeatures.builder().with(Feature.RESOLVE, "continue").build();</code></pre><p>设定这个<code class="codeph">"continue"</code>系统范围内的功能，请使用Java命令行或<span class="apiname">System.setProperty</span>方法：</p><pre class="pre codeblock"><code>System.setProperty(Feature.RESOLVE.getPropertyName(), "continue");</code></pre><p>设定这个<code class="codeph">"continue"</code>整个JVM实例的功能，请在<code class="codeph">jaxp.properties</code>文件：</p><pre class="pre codeblock"><code>javax.xml.catalog.resolve = "continue"</code></pre><p>的<code class="codeph">resolve</code>财产以及<code class="codeph">prefer</code>和<code class="codeph">defer</code>属性，可以设置为目录文件中目录或组条目的属性。例如，在以下目录中， <code class="codeph">resolve</code>属性设置了一个值<code class="codeph">"continue"</code>在目录条目上指示处理器在通过此目录未找到匹配项时继续操作。该属性也可以在<code class="codeph">group</code>条目如下：</p><pre class="pre codeblock"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;catalog
  xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog"
  resolve="continue"
  xml:base="http://local/base/dtd/"&gt;
  &lt;group resolve="continue"&gt;
    &lt;system
      systemId="http://remote/dtd/alice/docAlice.dtd"
      uri="http://local/dtd/docAliceSys.dtd"/&gt; &nbsp;&nbsp;&nbsp; 
  &lt;/group&gt;&nbsp;
&lt;/catalog&gt;</code></pre><p>在较窄范围内设置的属性将覆盖在较宽范围内设置的属性。因此，通过API设置的属性始终优先。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-A1A8F504-3E55-4F0A-A52C-5D5B67ED0DE1" name="GUID-A1A8F504-3E55-4F0A-A52C-5D5B67ED0DE1"></a><h3 id="JSCOR-GUID-A1A8F504-3E55-4F0A-A52C-5D5B67ED0DE1" class="sect3">使用XML Catalog API</h3>
               <div>
                  <p>使用XML Catalog标准的各种条目类型来解析XML源文档中的DTD，实体和备用URI引用。</p>
                  <p>XML目录标准定义了许多条目类型。其中，系统条目包括<code class="codeph">system</code> ， <code class="codeph">rewriteSystem</code>和<code class="codeph">systemSuffix</code>条目，用于解析XML源文档中的DTD和实体引用，而<code class="codeph">uri</code>条目用于备用URI引用。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-0734C523-42D3-4643-8242-60756C2F89AF" name="GUID-0734C523-42D3-4643-8242-60756C2F89AF"></a><h4 id="JSCOR-GUID-0734C523-42D3-4643-8242-60756C2F89AF" class="sect4">系统参考</h4>
                  <div>
                     <p>用一个<code class="codeph">CatalogResolver</code>对象来定位本地资源。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-0734C523-42D3-4643-8242-60756C2F89AF__GUID-F1B6D824-2A5B-4B8D-AF1B-D91D5E3CD21B">查找本地资源</p>
                        <p>以下示例演示了如何使用<code class="codeph">CatalogResolver</code>对象使用<code class="codeph">system</code>条目，给定一个XML文件，其中包含对<code class="codeph">example.dtd</code>属性：</p><pre class="pre codeblock"><code>&lt;?xml version="1.0"?&gt; 
&lt;!DOCTYPE catalogtest PUBLIC "-//OPENJDK//XML CATALOG DTD//1.0" 
  "http://openjdk.java.net/xml/catalog/dtd/example.dtd"&gt;

&lt;catalogtest&gt;
  Test &amp;example; entry
&lt;/catalogtest&gt;</code></pre><p>的<code class="codeph">example.dtd</code>定义一个实体<code class="codeph">"example"</code> ：</p>
                        <div class="p"><pre class="pre codeblock"><code>&lt;!ENTITY example "system"&gt;</code></pre></div>
                        <p>的URI <code class="codeph">example.dtd</code> XML中不需要存在。目的是为<code class="codeph">CatalogResolver</code>对象来定位本地资源。为此，请创建一个名为<code class="codeph">catalog.xml</code>与一个<code class="codeph">system</code>条目以引用本地资源：</p><pre class="pre codeblock"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog"&gt;
  &lt;system
    systemId="http://openjdk.java.net/xml/catalog/dtd/example.dtd"
    uri="example.dtd"/&gt;
&lt;/catalog&gt;</code></pre><p>有了这个目录和<code class="codeph">system</code>条目，您需要做的就是获取默认值<code class="codeph">CatalogFeatures</code>对象，然后将URI设置为目录文件以创建一个<code class="codeph">CatalogResolver</code>宾语：</p><pre class="pre codeblock"><code>CatalogResolver cr =
  CatalogManager.catalogResolver(CatalogFeatures.defaults(), catalogUri);</code></pre><p><code class="codeph">catalogUri</code>必须是有效的URI。例如：</p><pre class="pre codeblock"><code>URI.create("file:///users/auser/catalog/catalog.xml")</code></pre><p>的<code class="codeph">CatalogResolver</code>对象现在可以用作JDK XML解析器。在下面的示例中，它用作SAX <code class="codeph">EntityResolver</code> ：</p><pre class="pre codeblock"><code>SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
XMLReader reader = factory.newSAXParser().getXMLReader();
reader.setEntityResolver(cr);</code></pre><p>注意，在该示例中，系统标识符被赋予了绝对URI。这样一来，解析程序就可以轻松找到完全相同的匹配项<code class="codeph">systemId</code>在目录的<code class="codeph">system</code>条目。
                        </p>
                        <p>如果<code class="codeph">system</code> XML中的标识符是相对的，那么它可能会使匹配过程复杂化，因为XML处理器可能已经使用指定的基本URI或源文件的URI使其成为绝对值。在这种情况下， <code class="codeph">systemId</code>系统条目的ID必须与预期的绝对URI相匹配。一个更简单的解决方案是使用<code class="codeph">systemSuffix</code>条目，例如：</p><pre class="pre codeblock"><code>&lt;systemSuffix systemIdSuffix="example.dtd" uri="example.dtd"/&gt;</code></pre><p>的<code class="codeph">systemSuffix</code>条目匹配以结尾的任何引用<code class="codeph">example.dtd</code>在XML源中并将其解析为本地<code class="codeph">example.dtd</code>文件中指定的<code class="codeph">uri</code>属性。您可以在中添加更多<code class="codeph">systemId</code>以确保它是唯一的或正确的参考。例如，您可以设置<code class="codeph">systemIdSuffix</code>至<code class="codeph">xml/catalog/dtd/example.dtd</code> ，或重命名<code class="codeph">id</code>在XML源文件和<code class="codeph">systemSuffix</code>使其唯一匹配的条目，例如<code class="codeph">my_example.dtd</code> 。
                        </p>
                        <p>的URI <code class="codeph">system</code>条目可以是绝对的也可以是相对的。如果外部资源的位置固定，则绝对URI更有可能保证唯一性。如果外部资源是相对于您的应用程序或目录条目文件放置的，则相对URI可能更有效，从而可以在不知道应用程序安装位置的情况下进行应用程序部署。然后，如果未指定基本URI，则使用基本URI或目录文件的URI解析此类相对URI。在上一个示例中， <code class="codeph">example.dtd</code>假定与目录文件放置在同一目录中。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-FD0F8292-05D9-4062-9021-6B9F1CD3404A" name="GUID-FD0F8292-05D9-4062-9021-6B9F1CD3404A"></a><h4 id="JSCOR-GUID-FD0F8292-05D9-4062-9021-6B9F1CD3404A" class="sect4">公众参考</h4>
                  <div>
                     <p>用一个<code class="codeph">public</code>条目代替<code class="codeph">system</code>条目以查找所需的资源。
                     </p>
                     <p>如果不<code class="codeph">system</code>条目匹配所需的资源，并且<code class="codeph">PREFER</code>指定属性以匹配<code class="codeph">public</code> ，然后<code class="codeph">public</code>条目可以与<code class="codeph">system</code>条目。注意<code class="codeph">public</code>是默认设置<code class="codeph">PREFER</code>属性。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-FD0F8292-05D9-4062-9021-6B9F1CD3404A__GUID-EA3F06B2-F89C-4572-8ED3-0CB77DE340D2">使用公共条目</p>
                        <p>当解析的XML文件中的DTD引用包含公共标识符时，例如<code class="codeph">"-//OPENJDK//XML CATALOG DTD//1.0"</code> ， 一种<code class="codeph">public</code>条目可以在目录条目文件中编写如下：</p> <pre class="pre codeblock"><code>&lt;public publicId="-//OPENJDK//XML CATALOG DTD//1.0" uri="example.dtd"/&gt;</code></pre><p>当您创建并使用<code class="codeph">CatalogResolver</code>带有该条目文件的对象<code class="codeph">example.dtd</code>通过解决<code class="codeph">publicId</code>属性。请参阅<a href="xml-catalog-api1.html#GUID-0734C523-42D3-4643-8242-60756C2F89AF" title="使用CatalogResolver对象查找本地资源。">系统参考</a>中有关创建<code class="codeph">CatalogResolver</code>宾语。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3BD223F8-583D-4E0D-AF40-96E947DFC698" name="GUID-3BD223F8-583D-4E0D-AF40-96E947DFC698"></a><h4 id="JSCOR-GUID-3BD223F8-583D-4E0D-AF40-96E947DFC698" class="sect4">URI参考</h4>
                  <div>
                     <p>用一个<code class="codeph">uri</code>条目以查找所需的资源。
                     </p>
                     <p>URI类型条目，包括<code class="codeph">uri</code> ， <code class="codeph">rewriteURI</code>和<code class="codeph">uriSuffix</code>可以与系统类型条目类似的方式使用。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-3BD223F8-583D-4E0D-AF40-96E947DFC698__GUID-71D3640F-5584-48F2-A352-6CF4BE2C82D9">使用URI条目</p>
                        <p>XML Catalog Standard优先考虑<code class="codeph">system</code>输入用于解析DTD引用的条目，以及<code class="codeph">uri</code>类型条目的其他内容，Java XML Catalog API并没有区别。这是因为现有Java XML解析器的规范，例如<code class="codeph">XMLResolver</code>和<code class="codeph">LSResourceResolver</code> ，没有给出偏好。的<code class="codeph">uri</code>类型条目，包括<code class="codeph">uri</code> ， <code class="codeph">rewriteURI</code>和<code class="codeph">uriSuffix</code> ，可以与<code class="codeph">system</code>输入条目。的<code class="codeph">uri</code>定义元素以将备用URI引用与URI引用相关联。如果是<code class="codeph">system</code>参考，这是<code class="codeph">systemId</code>属性。
                        </p>
                        <p>因此，您可以更换<code class="codeph">system</code>带有<code class="codeph">uri</code>在以下示例中， <code class="codeph">system</code>条目通常用于DTD参考。
                        </p><pre class="pre codeblock"><code>&lt;system
  systemId="http://openjdk.java.net/xml/catalog/dtd/example.dtd"
  uri="example.dtd"/&gt;</code></pre><p>一种<code class="codeph">uri</code>条目如下所示：</p><pre class="pre codeblock"><code>&lt;uri name="http://openjdk.java.net/xml/catalog/dtd/example.dtd" uri="example.dtd"/&gt;</code></pre><p>而<code class="codeph">system</code>条目通常用于DTD， <code class="codeph">uri</code>对于URI引用（例如XSD和XSL导入和包含），首选使用条目。下一个示例使用<code class="codeph">uri</code>解决XSL导入的条目。
                        </p>
                        <p>如<a href="xml-catalog-api1.html#GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF" title="通过其接口访问XML Catalog API。">XML Catalog API接口</a>中所述，XML Catalog API定义了<code class="codeph">CatalogResolver</code>扩展Java XML解析器的接口，包括<code class="codeph">EntityResolver</code> ， <code class="codeph">XMLResolver</code> ， <code class="codeph">URIResolver</code>和<code class="codeph">LSResolver</code> 。因此， <code class="codeph">CatalogResolver</code> SAX，DOM，StAX，架构验证以及XSLT转换可以使用该对象。以下代码创建了一个<code class="codeph">CatalogResolver</code>具有默认功能设置的对象：</p><pre class="pre codeblock"><code>CatalogResolver cr =
  CatalogManager.catalogResolver(CatalogFeatures.defaults(), catalogUri);</code></pre><p>然后代码将其注册<code class="codeph">CatalogResolver</code>上的对象<code class="codeph">TransformerFactory</code>上课的地方<code class="codeph">URIResolver</code>预期对象：</p><pre class="pre codeblock"><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setURIResolver(cr);</code></pre><p>或者，代码可以注册<code class="codeph">CatalogResolver</code>上的对象<code class="codeph">Transformer</code>宾语：</p><pre class="pre codeblock"><code>Transformer transformer = factory.newTransformer(xslSource); 
transformer.setURIResolver(cur);</code></pre><p>假设XSL源文件包含一个<code class="codeph">import</code>元素导入<code class="codeph">xslImport.xsl</code>文件放入XSL源：</p><pre class="pre codeblock"><code>&lt;xsl:import href="pathto/xslImport.xsl"/&gt;</code></pre><p>解决<code class="codeph">import</code>引用导入文件的实际位置， <code class="codeph">CatalogResolver</code>对象应设置在<code class="codeph">TransformerFactory</code>创建之前的类<code class="codeph">Transformer</code>对象和一个<code class="codeph">uri</code>必须将以下条目添加到目录条目文件中：</p><pre class="pre codeblock"><code>&lt;uri name="pathto/xslImport.xsl" uri="xslImport.xsl"/&gt;</code></pre><p>关于绝对或相对URI的讨论以及<code class="codeph">systemSuffix</code>要么<code class="codeph">uriSuffix</code>系统参考的条目适用于<code class="codeph">uri</code>条目。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-51446739-F878-4B70-A36F-47FBBE12A26A" name="GUID-51446739-F878-4B70-A36F-47FBBE12A26A"></a><h3 id="JSCOR-GUID-51446739-F878-4B70-A36F-47FBBE12A26A" class="sect3">Java XML处理器支持</h3>
               <div>
                  <p>将XML Catalogs功能与标准Java XML处理器一起使用。</p>
                  <p>整个Java XML处理器都支持XML Catalogs功能，包括SAX和DOM（ <code class="codeph">javax.xml.parsers</code> ）和StAX解析器（ <code class="codeph">javax.xml.stream</code> ），架构验证（ <code class="codeph">javax.xml.validation</code> ）和XML转换（ <code class="codeph">javax.xml.transform</code> ）。
                  </p>
                  <p>这意味着您不需要在XML处理器外部创建<span class="apiname">CatalogResolver</span>对象。目录文件可以直接注册到Java XML处理器，也可以通过系统属性或在<span class="apiname">jaxp.properties</span>文件中指定。XML处理器自动通过目录执行映射。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF" name="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF"></a><h4 id="JSCOR-GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF" class="sect4">启用目录支持</h4>
                  <div>
                     <p>要在处理器上启用对XML Catalogs功能的支持， <code class="codeph">USE_CATALOG</code>功能必须设置为<code class="codeph">true</code> ，并至少指定一个目录条目文件。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF__GUID-283E36EC-7A78-42E7-ADAE-4EB33B512EA5">USE_CATALOG</p>
                        <p>Java XML处理器根据的值确定是否支持XML Catalogs功能。 <code class="codeph">USE_CATALOG</code>特征。默认， <code class="codeph">USE_CATALOG</code>被设定为<code class="codeph">true</code>适用于所有JDK XML处理器。Java XML处理器进一步检查目录文件的可用性，并仅在以下情况下尝试使用XML Catalog API： <code class="codeph">USE_CATALOG</code>功能是<code class="codeph">true</code>并提供目录。
                        </p>
                        <p>的<code class="codeph">USE_CATALOG</code> XML Catalog API，系统属性和<code class="codeph">jaxp.properties</code>文件。例如，如果<code class="codeph">USE_CATALOG</code>被设定为<code class="codeph">true</code>并且最好禁用特定处理器的目录支持，然后可以通过设置<code class="codeph">USE_CATALOG</code>具有<code class="codeph">false</code>通过处理器的<code class="codeph">setFeature</code>方法。以下代码设置了<code class="codeph">USE_CATALOG</code>达到指定值<code class="codeph">useCatalog</code>为<code class="codeph">XMLReader</code>宾语：</p><pre class="pre codeblock"><code>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setNamespaceAware(true);
XMLReader reader = spf.newSAXParser().getXMLReader();
if (setUseCatalog) {
   reader.setFeature(XMLConstants.USE_CATALOG, useCatalog); 
}</code></pre><p>另一方面，如果必须关闭整个环境的目录，则可以通过配置<code class="codeph">jaxp.properties</code>带有一行的文件：</p><pre class="pre codeblock"><code> javax.xml.useCatalog = false;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF__GUID-B0B2E03F-97E3-4CF6-B92F-6E4ACA90EDFD">javax.xml.catalog.files</p>
                        <p>的<code class="codeph">javax.xml.catalog.files</code>属性由XML Catalog API定义，并由JDK XML处理器以及其他目录功能支持。要在解析，验证或转换过程中使用目录功能，所需要做的就是设置<code class="codeph">FILES</code>通过处理器的系统属性或使用<code class="codeph">jaxp.properties</code>文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF__GUID-57232880-CC4D-4E34-9907-228B48BE471F">目录URI</p>
                        <p>目录文件引用必须是有效的URI，例如<code class="codeph">file:///users/auser/catalog/catalog.xml</code> 。
                        </p>
                        <p>系统中的URI引用或目录文件中的URI条目可以是绝对的或相对的。如果它们是相对的，则使用目录文件的URI或基本URI（如果指定）来解析它们。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F00FF957-8339-45D2-8109-EAFEDAFF3BBF__GUID-643A9364-8508-4445-B03E-F32839258227">使用系统或uri条目</p>
                        <p>直接使用XML Catalog API时（有关示例，请参见<a href="xml-catalog-api1.html#GUID-D9216F5E-8759-4286-95CA-E1D041DD72AF" title="通过其接口访问XML Catalog API。">XML Catalog API接口</a> ）， <code class="codeph">system</code>和<code class="codeph">uri</code>当使用JDK XML Processors的本机支持时，两个条目均起作用<code class="codeph">CatalogFeatures</code>类。一般来说， <code class="codeph">system</code>首先搜索条目，然后<code class="codeph">public</code>条目，如果找不到匹配项，则处理器继续搜索<code class="codeph">uri</code>条目。因为两者<code class="codeph">system</code>和<code class="codeph">uri</code>支持条目，建议您在使用<code class="codeph">system</code>要么<code class="codeph">uri</code>条目。例如，DTD用<code class="codeph">systemId</code>因此<code class="codeph">system</code>条目是更可取的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036" name="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036"></a><h4 id="JSCOR-GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036" class="sect4">将目录与XML处理器一起使用</h4>
                  <div>
                     <p>将XML Catalog API与各种Java XML处理器一起使用。</p>
                     <p>整个JDK XML处理器都支持XML Catalog API。以下各节描述如何为特定类型的处理器启用它。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-11888EDF-0427-41D3-A061-18691E354E27">将目录与DOM一起使用</p>
                        <p>要将目录与DOM一起使用，请设置<code class="codeph">FILES</code>物业<code class="codeph">DocumentBuilderFactory</code>实例，如以下代码所示：</p><pre class="pre codeblock"><code>static final String CATALOG_FILE = CatalogFeatures.Feature.FILES.getPropertyName();
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setNamespaceAware(true);
if (catalog != null) {
   dbf.setAttribute(CATALOG_FILE, catalog);
}</code></pre><p>注意<code class="codeph">catalog</code>是目录文件的URI。例如，可能是<code class="codeph">"file:///users/auser/catalog/catalog.xml"</code> 。
                        </p>
                        <p>最好与目录条目文件一起部署解析目标文件，以便可以相对于目录文件解析文件。例如，如果以下是<code class="codeph">uri</code>目录文件中的条目，然后<code class="codeph">XSLImport_html.xsl</code>文件将位于<code class="codeph">/users/auser/catalog/XSLImport_html.xsl</code> 。
                        </p><pre class="pre codeblock"><code>&lt;uri name="pathto/XSLImport_html.xsl" uri="XSLImport_html.xsl"/&gt;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-9617CF43-33CA-4C2F-8FF4-75CC73C09779">将目录与SAX一起使用</p>
                        <p>要在SAX解析器上使用目录功能，请将目录文件设置为<code class="codeph">SAXParser</code>实例：</p><pre class="pre codeblock"><code>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setNamespaceAware(true);
spf.setXIncludeAware(true);
SAXParser parser = spf.newSAXParser();
parser.setProperty(CATALOG_FILE, catalog);</code></pre><p>在前面的示例代码中，请注意以下语句<code class="codeph">spf.setXIncludeAware(true)</code> 。启用此功能后，任何<code class="codeph">XInclude</code>也可以使用目录来解决。
                        </p>
                        <p>给定一个XML文件<code class="codeph">XI_simple.xml</code> ：</p><pre class="pre codeblock"><code>&lt;simple&gt; 
  &lt;test xmlns:xinclude="http://www.w3.org/2001/XInclude"&gt; &nbsp; 
    &lt;latin1&gt;
      &lt;firstElement/&gt;
      &lt;xinclude:include href="pathto/XI_text.xml" parse="text"/&gt;
      &lt;insideChildren/&gt;
      &lt;another&gt;
        &lt;deeper&gt;text&lt;/deeper&gt;
      &lt;/another&gt;
    &lt;/latin1&gt;
    &lt;test2&gt;
      &lt;xinclude:include href="pathto/XI_test2.xml"/&gt; &nbsp; 
    &lt;/test2&gt;
  &lt;/test&gt;
&lt;/simple&gt;</code></pre><p>另外，给定另一个XML文件<code class="codeph">XI_test2.xml</code> ：</p><pre class="pre codeblock"><code>&lt;?xml version="1.0"?&gt;
&lt;!-- comment before root --&gt;
&lt;!DOCTYPE red SYSTEM "pathto/XI_red.dtd"&gt;
&lt;red xmlns:xinclude="http://www.w3.org/2001/XInclude"&gt;
  &lt;blue&gt;
    &lt;xinclude:include href="pathto/XI_text.xml" parse="text"/&gt;
  &lt;/blue&gt;
&lt;/red&gt;</code></pre><p>假设另一个文本文件， <code class="codeph">XI_text.xml</code> ，包含一个简单的字符串和文件<code class="codeph">XI_red.dtd</code>如下：</p><pre class="pre codeblock"><code> &lt;!ENTITY red "it is read"&gt;</code></pre><p>在这些XML文件中， <code class="codeph">XInclude</code>里面的元素<code class="codeph">XInclude</code>元素，以及对DTD的引用。假设它们与目录文件位于同一文件夹中<code class="codeph">CatalogSupport.xml</code> ，添加以下目录条目以进行映射：</p><pre class="pre codeblock"><code>&lt;uri name="pathto/XI_text.xml" uri="XI_text.xml"/&gt;
&lt;uri name="pathto/XI_test2.xml" uri="XI_test2.xml"/&gt;&nbsp;
&lt;system systemId="pathto/XI_red.dtd" uri="XI_red.dtd"/&gt;</code></pre><p>当。。。的时候<code class="codeph">parser.parse</code>调用方法来解析<code class="codeph">XI_simple.xml</code>文件，它可以找到<code class="codeph">XI_test2.xml</code>文件在<code class="codeph">XI_simple.xml</code>文件，以及<code class="codeph">XI_text.xml</code>文件和<code class="codeph">XI_red.dtd</code>文件在<code class="codeph">XI_test2.xml</code>通过指定目录的文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-A1F24B26-F76B-43B3-B1BD-CB63C0E97D51">将目录与StAX一起使用</p>
                        <p>要将目录功能与StAX解析器一起使用，请在<code class="codeph">XMLInputFactory</code>创建之前的实例<code class="codeph">XMLStreamReader</code>宾语：</p><pre class="pre codeblock"><code>XMLInputFactory factory = XMLInputFactory.newInstance();
factory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);
XMLStreamReader streamReader =
  factory.createXMLStreamReader(xml, new FileInputStream(xml));</code></pre><p>当。。。的时候<code class="codeph">XMLStreamReader</code><code class="codeph">streamReader</code>对象用于解析XML源，然后根据目录中的指定条目解析源中的外部引用。
                        </p>
                        <p>请注意，与<code class="codeph">DocumentBuilderFactory</code>兼有<code class="codeph">setFeature</code>和<code class="codeph">setAttribute</code>方法， <code class="codeph">XMLInputFactory</code>类仅定义一个<code class="codeph">setProperty</code>方法。XML Catalog API功能包括<code class="codeph">XMLConstants.USE_CATALOG</code>都通过这个设置<code class="codeph">setProperty</code>方法。例如，禁用<code class="codeph">USE_CATALOG</code>在一个<code class="codeph">XMLStreamReader</code>对象，您可以执行以下操作：</p><pre class="pre codeblock"><code>factory.setProperty(XMLConstants.USE_CATALOG, false);</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__USECATALOGWITHSCHEMAVALIDATION-BE2EFC88">
                        <p class="subhead3" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-1481904D-374F-4BC4-AFE3-164ACFD3B619">将目录与模式验证一起使用</p>
                        <p>使用目录来解析架构中的任何外部资源，例如XSD <code class="codeph">import</code>和<code class="codeph">include</code> ，将目录设置在<code class="codeph">SchemaFactory</code>宾语：</p><pre class="pre codeblock"><code>SchemaFactory factory =
  SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
factory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);
Schema schema = factory.newSchema(schemaFile);</code></pre><p><a href="https://www.w3.org/2009/XMLSchema/XMLSchema.xsd" target="_blank">XMLSchema模式文档</a>包含对外部DTD的引用：</p><pre class="pre codeblock"><code>&lt;!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200102//EN" "pathto/XMLSchema.dtd" [
   ...&nbsp;
]&gt;</code></pre><p>并<code class="codeph">xsd</code>进口：</p><pre class="pre codeblock"><code>&lt;xs:import
  namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/pathto/xml.xsd"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Get access to the xml: attribute groups for xml:lang
      as declared on 'schema' and 'documentation' below
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:import&gt;</code></pre><p>跟随此示例，使用本地资源通过减少对W3C服务器的调用来提高应用程序性能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将这些条目包括在<code class="codeph">SchemaFactory</code>宾语：</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>&lt;public publicId="-//W3C//DTD XMLSCHEMA 200102//EN" uri="XMLSchema.dtd"/&gt;
&lt;!-- XMLSchema.dtd refers to datatypes.dtd --&gt; 
&lt;systemSuffix systemIdSuffix="datatypes.dtd" uri="datatypes.dtd"/&gt;
&lt;uri name="http://www.w3.org/2001/pathto/xml.xsd" uri="xml.xsd"/&gt;</code></pre><ul style="list-style-type:disc">
                           <li>
                              <p>下载源文件<code class="codeph">XMLSchema.dtd</code> ， <code class="codeph">datatypes.dtd</code>和<code class="codeph">xml.xsd</code>并将它们与目录文件一起保存。
                              </p>
                           </li>
                        </ul>
                        <p>如前所述，XML Catalog API使您可以使用任何喜欢的条目类型。在以前的情况下， <code class="codeph">uri</code>条目，您还可以使用以下任一选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>一种<code class="codeph">public</code>进入，因为<code class="codeph">namespace</code>中的属性<code class="codeph">import</code>元素被视为<code class="codeph">publicId</code>元件：</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>&lt;public publicId="http://www.w3.org/XML/1998/namespace" uri="xml.xsd"/&gt;</code></pre><ul style="list-style-type:disc">
                           <li>
                              <p>一种<code class="codeph">system</code>条目：</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>&lt;system systemId="http://www.w3.org/2001/pathto/xml.xsd" uri="xml.xsd"/&gt;</code></pre><div class="infoboxnote" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-03FAAC96-CE0B-434D-BB3D-3711E4CD6ED1">
                           <p class="notep1">注意：</p>在尝试使用XML Catalog API时，确保示例文件中使用的URI或系统ID都不指向Internet上的任何实际资源，尤其是W3C服务器，可能会很有用。这样，您可以在目录解析失败时及早发现错误，并避免给W3C服务器造成负担，从而使它们摆脱不必要的连接。本主题以及有关XML Catalog API的其他相关主题中的所有示例均具有任意字符串<code class="codeph">"pathto"</code>为此已添加到任何URI，因此没有URI可能无法解析为外部W3C资源。
                        </div>
                        <p>要使用目录解析要验证的XML源中的任何外部资源，请在<code class="codeph">Validator</code>宾语：</p><pre class="pre codeblock"><code>SchemaFactory schemaFactory =
  SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
Schema schema = schemaFactory.newSchema();
Validator validator = schema.newValidator();
validator.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);
StreamSource source = new StreamSource(new File(xml));
validator.validate(source);</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34E80AF6-7D70-49A3-99C4-1B91DB0B3036__GUID-01244FB1-15CF-4BD6-AAA3-E667CD3C4806">将目录与转换一起使用</p>
                        <p>要在XSLT转换过程中使用XML Catalog API，请在<code class="codeph">TransformerFactory</code>宾语。
                        </p><pre class="pre codeblock"><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);
Transformer transformer = factory.newTransformer(xslSource);</code></pre><p>如果工厂使用XSL源创建了<code class="codeph">Transformer</code>对象包含DTD，import和include类似于以下内容的语句：</p><pre class="pre codeblock"><code>&lt;!DOCTYPE HTMLlat1 SYSTEM "http://openjdk.java.net/xml/catalog/dtd/XSLDTD.dtd"&gt;
&lt;xsl:import href="pathto/XSLImport_html.xsl"/&gt;
&lt;xsl:include href="pathto/XSLInclude_header.xsl"/&gt;</code></pre><p>然后，可以使用以下目录条目来解析这些引用：</p><pre class="pre codeblock"><code>&lt;system
  systemId="http://openjdk.java.net/xml/catalog/dtd/XSLDTD.dtd"
  uri="XSLDTD.dtd"/&gt;
&lt;uri name="pathto/XSLImport_html.xsl" uri="XSLImport_html.xsl"/&gt;
&lt;uri name="pathto/XSLInclude_header.xsl" uri="XSLInclude_header.xsl"/&gt;</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-963956F7-17C1-483D-AF0F-5106298A8C99" name="GUID-963956F7-17C1-483D-AF0F-5106298A8C99"></a><h3 id="JSCOR-GUID-963956F7-17C1-483D-AF0F-5106298A8C99" class="sect3">解析器的呼叫顺序</h3>
               <div>
                  <p>JDK XML处理器在目录解析器之前调用自定义解析器。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-963956F7-17C1-483D-AF0F-5106298A8C99__GUID-CDD5A4A2-A16C-40DB-A0E0-77D9C95521F8">自定义解析器优先于目录解析器</p> 
                     <p>目录解析器（由<code class="codeph">CatalogResolver</code>接口）可用于已设置目录文件的JDK XML处理器解析外部引用。但是，如果还提供了自定义解析器，则始终将其放置在目录解析器之前。这意味着JDK XML处理器首先调用自定义解析器以尝试解析外部资源。如果解析成功，则处理器将跳过目录解析器并继续。仅当没有自定义解析器或自定义解析器的解析返回null时，处理器才调用目录解析器。
                     </p>
                     <p>对于使用自定义解析器的应用程序，因此可以安全地设置一个附加目录来解析自定义解析器无法处理的任何资源。对于现有应用程序，如果更改代码不可行，则可以通过system属性或<code class="codeph">jaxp.properties</code>文件以将外部引用重定向到本地资源，因为知道这样的设置不会干扰自定义解析程序处理的现有过程。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-CB46075E-925E-4695-AFF1-DC236B270BCD" name="GUID-CB46075E-925E-4695-AFF1-DC236B270BCD"></a><h3 id="JSCOR-GUID-CB46075E-925E-4695-AFF1-DC236B270BCD" class="sect3">检测错误</h3>
               <div>
                  <p>通过隔离问题来检测配置问题。</p>
                  <p>XML Catalogs Standard要求处理器从任何资源故障中恢复并继续，因此XML Catalog API会忽略任何失败的目录条目文件而不会发出错误，这使得检测配置问题更加困难。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-CB46075E-925E-4695-AFF1-DC236B270BCD__GUID-2DB9420E-572C-4AF1-9D7C-19AC7B99DED1">检测配置问题</p>
                     <p>要检测配置问题，请一次设置一个目录，然后设置一个<code class="codeph">RESOLVE</code>重视<code class="codeph">strict</code> ，然后检查<code class="codeph">CatalogException</code>找不到匹配项时发生异常。
                     </p>
                     <div class="tblformal" id="GUID-CB46075E-925E-4695-AFF1-DC236B270BCD__GUID-1B3E84C2-73B8-4204-AC60-1DE1E2C8D77D">
                        <p class="titleintable">表4-1 RESOLVE设置</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="解决设置" border="1" summary="This table shows the effect of different RESOLVE settings on the behavior of the CatalogResolver class if there is an error." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d2792e1216">解决价值</th>
                                 <th align="left" valign="bottom" id="d2792e1221">CatalogResolver行为</th>
                                 <th align="left" valign="bottom" id="d2792e1226">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d2792e1231" headers="d2792e1216 ">
                                    <p><code class="codeph">strict</code> （默认）</p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1231 d2792e1221 ">
                                    <p>抛出一个<code class="codeph">CatalogException</code>如果找不到与指定参考的匹配项</p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1231 d2792e1226 ">
                                    <p>引用不匹配可能表示目录或设置目录中可能存在错误。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d2792e1246" headers="d2792e1216 ">
                                    <p><code class="codeph">continue</code></p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1246 d2792e1221 ">
                                    <p>悄悄返回</p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1246 d2792e1226 ">
                                    <p>这在生产环境中非常有用，在生产环境中，您希望XML处理器继续解析目录未涵盖的任何外部引用。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d2792e1257" headers="d2792e1216 ">
                                    <p><code class="codeph">ignore</code></p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1257 d2792e1221 ">
                                    <p>悄悄返回</p>
                                 </td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d2792e1257 d2792e1226 ">
                                    <p>对于允许跳过外部引用的处理器（例如SAX）， <code class="codeph">ignore</code>值指示<code class="codeph">CatalogResolver</code>对象返回空<code class="codeph">InputSource</code>对象，从而跳过外部参考。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>