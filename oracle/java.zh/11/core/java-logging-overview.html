<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Java Logging Overview</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T08:11:40-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94895-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="process-api1.html" title="Previous" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="process-api1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="#" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">核心图书馆</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java记录概述</li>
            </ol>
            <a id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA" name="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA"></a>
            
            <h2 id="JSCOR-GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA" class="sect2"><span class="enumeration_chapter">7</span> Java日志概述</h2>
         </header>
         <div class="ind">
            <div>
               <p>包<a href="https://docs.oracle.com/javase/10/docs/api/java/util/logging/package-summary.html" target="_blank"><span class="apiname">java.util.logging中</span></a>包含的Java Logging API通过生成适合最终用户，系统管理员，现场服务工程师和软件开发团队进行分析的日志报告，促进了客户站点的软件服务和维护。记录API捕获信息，例如安全失败，配置错误，性能瓶颈和/或应用程序或平台中的错误。
               </p>
               <p>核心软件包包括支持将纯文本或XML格式的日志记录传递到内存，输出流，控制台，文件和套接字。此外，日志记录API能够与主机操作系统上已经存在的日志记录服务进行交互。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-2DC64A97-2766-43CB-B5B8-B39B388C0F78">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__OVERVIEWOFCONTROLFLOW-4D022D4F">控制流程概述</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGLEVELS-4D023007">日志级别</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGERS-4D023227">记录仪</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGINGMETHODS-4D0234DF">记录方法</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__HANDLERS-4D023767">处理程序</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__FORMATTERS-4D023953">格式化程序</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__THELOGMANAGER-4D023AE3">日志管理器</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">配置文件</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DEFAULTCONFIGURATION-4D023EDA">默认配置</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DYNAMICCONFIGURATIONUPDATES-4D0240C7">动态配置更新</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__NATIVEMETHODS-4D0242BC">本机方法</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__XMLDTD-4D0243CB">XML DTD</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__UNIQUEMESSAGEIDS-4D024671">唯一消息ID</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">安全</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONMANAGEMENT-4D02480C">配置管理</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__PACKAGING-4D024A51">打包</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOCALIZATION-4D024B46">本土化</a></li>
                     <li><a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__REMOTEACCESSANDSERIALIZATION-4D024D3A">远程访问和序列化</a></li>
                     <li><a href="java-logging-overview.html#GUID-48004124-2C00-49F7-A640-0C0DDA271DBC">Java记录范例</a></li>
                     <li><a href="java-logging-overview.html#GUID-84971801-F327-4F96-8F35-DA4D6737F857">附录A：XMLFormatter输出的DTD</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__OVERVIEWOFCONTROLFLOW-4D022D4F">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-E6520922-1AE6-4725-9C12-5615F2D67669">控制流程概述</p>
                  <p>应用程序在<span class="apiname">Logger</span>对象上进行日志记录调用。<span class="apiname">记录器</span>对象以分层名称空间组织，子<span class="apiname">记录器</span>对象可以从名称空间的父级继承一些记录属性。
                  </p>
                  <p>应用程序在<span class="apiname">Logger</span>对象上进行日志记录调用。这些<span class="apiname">Logger</span>对象分配<span class="apiname">LogRecord</span>对象，该对象将传递到<span class="apiname">Handler</span>对象以进行发布。<span class="apiname">Logger</span>和<span class="apiname">Handler</span>对象都可以使用Logging <span class="apiname">Level</span>对象和（可选） <span class="apiname">Filter</span>对象来确定它们是否对特定<span class="apiname">LogRecord</span>对象感兴趣。当需要在外部发布<span class="apiname">LogRecord</span>对象时， <span class="apiname">Handler</span>对象可以（可选）使用<span class="apiname">Formatter</span>对象对消息进行本地化和格式化，然后再将其发布到I / O流。
                  </p>
                  <div class="figure" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-45676A2F-2702-43EA-B3FB-22D6EF7C50E5">
                     <p class="titleinfigure">图7-1 Java日志记录控制流程</p><img src="img/java_pb_001a.png" alt="该图说明了上一段。" title="该图说明了上一段。"></div>
                  <!-- class="figure" -->
                  <p>每个<span class="apiname">Logger</span>对象都跟踪一组输出<span class="apiname">Handler</span>对象。默认情况下，所有<span class="apiname">Logger</span>对象还将其输出发送到其父<span class="apiname">Logger</span> 。但是， <span class="apiname">Logger</span>对象也可以配置为忽略树上方的<span class="apiname">Handler</span>对象。
                  </p>
                  <p>某些<span class="apiname">处理程序</span>对象可能会将输出定向到其他<span class="apiname">处理程序</span>对象。例如， <span class="apiname">MemoryHandler</span>维护<span class="apiname">LogRecord</span>对象的内部环形缓冲区，并在触发事件时通过目标<span class="apiname">Handler</span>发布其<span class="apiname">LogRecord</span>对象。在这种情况下，任何格式化都由链中的最后一个<span class="apiname">Handler</span>完成。
                  </p>
                  <div class="figure" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-56BC5167-3EDF-44DF-88F7-A8F3D2BD40B3">
                     <p class="titleinfigure">图7-2使用MemoryHandler的Java日志记录控制流</p><img src="img/java_pb_002a.png" alt="该图说明了上一段。" title="该图说明了上一段。"></div>
                  <!-- class="figure" -->
                  <p>这些API的结构使得禁用日志记录时，对Logger API的调用可以便宜。如果对于给定的日志级别禁用了日志记录，则Logger可以进行便宜的比较测试并返回。如果为给定的日志级别启用了日志记录，则Logger在将<span class="apiname">LogRecord</span>传递到<span class="apiname">Handler</span>之前，仍要小心谨慎以最小化成本。特别是，本地化和格式设置（相对昂贵）要推迟到<span class="apiname">Handler</span>请求它们之前。例如， <span class="apiname">MemoryHandler</span>可以维护<span class="apiname">LogRecord</span>对象的循环缓冲区，而不必支付格式化费用。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGLEVELS-4D023007">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-ECD677F8-19D2-4B96-B9E8-7DC23C9402A2">日志级别</p>
                  <p>每个日志消息都有一个关联的日志<span class="apiname">级别</span>对象。该<span class="apiname">级别</span>为日志消息的重要性和紧迫性提供了粗略的指导。日志<span class="apiname">级别</span>对象封装一个整数值，其中较高的值表示较高的优先级。
                  </p>
                  <p><span class="apiname">Level</span>类定义了七个标准日志级别，范围从<span class="apiname">FINEST</span> （最低优先级，具有最低的值）到<span class="apiname">SEVERE</span> （最高优先级，具有最高的值）。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGERS-4D023227">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-EAC23024-5C26-47C1-9145-FCA9761D1B40">记录仪</p>
                  <p>如前所述，客户端代码将日志请求发送到<span class="apiname">Logger</span>对象。每个记录器均会跟踪其感兴趣的日志级别，并丢弃该级别以下的日志请求。
                  </p>
                  <p><span class="apiname">记录器</span>对象通常使用点分隔的名称（例如<span class="apiname">java.awt）</span>命名为实体。名称空间是分层的，由<span class="apiname">LogManager</span>管理。该名称空间通常应与Java包装名称空间对齐，但并不需要严格遵循该名称空间。例如，一个名为<span class="apiname">java.awt</span>的Logger可以处理<span class="apiname">java.awt</span>包中类的日志记录请求，但是它也可以处理<span class="apiname">sun.awt</span>中支持<span class="apiname">java.awt</span>包中定义的客户端可见抽象的类的日志记录。
                  </p>
                  <p>除了命名的<span class="apiname">Logger</span>对象之外，还可以创建不出现在共享名称空间中的匿名<span class="apiname">Logger</span>对象。请参阅“ <a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">安全性”</a>部分。
                  </p>
                  <p>记录器在记录名称空间中跟踪其父记录器。记录器的父级是其在记录名称空间中最接近的现有祖先。根记录器（名为“”）没有父级。匿名记录器都被赋予根记录器作为其父记录器。记录器可以在记录器名称空间中从其父项继承各种属性。记录器尤其可以继承：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">日志记录级别</span> ：如果记录器的级别设置为null，则记录器将使用有效<span class="apiname">级别</span> ，该<span class="apiname">级别</span>将通过沿父级树并使用第一个非空<span class="apiname">级别来获得</span> 。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">处理程序</span> ：默认情况下， <span class="apiname">记录器</span>会将所有输出消息<span class="apiname">记录</span>到其父级的处理程序中，依此类推。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">资源束名称</span> ：如果记录器的资源束名称为空，则它将继承为其父级定义的任何资源束名称，以此类推。
                        </p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGINGMETHODS-4D0234DF">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-77ACA2F4-E0CB-4261-B328-F7ED2D0289C4">记录方法</p>
                  <p><span class="apiname">Logger</span>类提供了大量方便的方法来生成日志消息。为方便起见，每个日志记录级别都有一些方法，以日志记录级别名称命名。因此，而不是调用<span class="apiname">logger.log（Level。警告...）</span> ，开发人员可以简单地调用便捷方法<span class="apiname">logger.warning（...）</span> 。
                  </p>
                  <p>日志记录方法有两种不同的样式，可以满足不同用户社区的需求。</p>
                  <p>首先，有些方法采用显式的源类名称和源方法名称。这些方法供希望快速找到任何给定日志消息源的开发人员使用。这种样式的一个示例是：</p><pre class="pre codeblock"><code>void warning(String sourceClass, String sourceMethod, String msg);</code></pre><p>其次，有一组方法不采用显式的源类或源方法名称。这些对象供那些想要易于使用的日志记录并且不需要详细的源信息的开发人员使用。</p><pre class="pre codeblock"><code>void warning(String msg);</code></pre><p>对于第二组方法，Logging框架将“尽最大的努力”确定将哪些类和方法调用到Logging框架中，并将此信息添加到<span class="apiname">LogRecord中</span> 。但是，重要的是要认识到，这种自动推断的信息可能仅是近似的。虚拟机在即时编译时会执行广泛的优化，并且可能会完全删除堆栈帧，从而无法可靠地定位调用类和方法。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__HANDLERS-4D023767">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-9A51C76D-0A9D-46F8-8F63-FF4E4ADAAFE6">处理程序</p>
                  <p>Java SE提供了以下<span class="apiname">Handler</span>类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="apiname">StreamHandler</span> ：一个简单的处理程序，用于将格式化的记录写入<span class="apiname">OutputStream</span> 。
                        </p>
                     </li>
                     <li>
                        <p><span class="apiname">ConsoleHandler</span> ：一个简单的处理程序，用于将格式化的记录写入<span class="apiname">System.err</span></p>
                     </li>
                     <li>
                        <p><span class="apiname">FileHandler</span> ：将格式化的日志记录写入单个文件或一组轮换日志文件的处理程序。
                        </p>
                     </li>
                     <li>
                        <p><span class="apiname">SocketHandler</span> ：将格式化的日志记录写入远程TCP端口的处理程序。
                        </p>
                     </li>
                     <li>
                        <p><span class="apiname">MemoryHandler</span> ：一个在内存中缓冲日志记录的处理程序。
                        </p>
                     </li>
                  </ul>
                  <p>开发新的<span class="apiname">Handler</span>类非常简单。需要特定功能的开发人员可以从头开始开发处理程序，也可以将提供的处理程序之一子类化。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__FORMATTERS-4D023953">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-2236782F-EA40-435B-AED3-CECCEC2F767D">格式化程序</p>
                  <p>Java SE还包括两个标准的<span class="apiname">Formatter</span>类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="apiname">SimpleFormatter</span> ：编写日志记录的简短的“易于阅读的”摘要。
                        </p>
                     </li>
                     <li>
                        <p><span class="apiname">XMLFormatter</span> ：编写详细的XML结构信息。
                        </p>
                     </li>
                  </ul>
                  <p>与处理程序一样，开发新的格式化程序非常简单。</p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__THELOGMANAGER-4D023AE3">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-2EAC6FF5-B07A-4536-A214-BD37D5A3DD53">日志管理器</p>
                  <p>有一个全局<span class="apiname">LogManager</span>对象，用于跟踪全局日志记录信息。这包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>命名Logger的分层名称空间。</p>
                     </li>
                     <li>
                        <p>从配置文件中读取的一组日志记录控件属性。请参阅“ <a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">配置文件</a> ”部分。
                        </p>
                     </li>
                  </ul>
                  <p>可以使用静态<span class="apiname">LogManager.getLogManager</span>方法检索单个<span class="apiname">LogManager</span>对象。这是在<span class="apiname">LogManager</span>初始化期间根据系统属性创建的。此属性允许容器应用程序（例如EJB容器）代替默认类替换其自己的<span class="apiname">LogManager</span>子类。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-87471F37-716C-465C-931B-E1AB97BE9546">配置文件</p>
                  <p>可以使用将在启动时读取的日志配置文件来初始化日志配置。此日志记录配置文件位于标准<span class="apiname">java.util中。属性</span>格式。
                  </p>
                  <p>或者，可以通过指定可用于读取初始化属性的类来初始化日志记录配置。这种机制允许从任意来源（例如LDAP和JDBC）读取配置数据。请参阅“ <a href="java-logging-overview.html#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">配置文件”</a>部分。
                  </p>
                  <p>全局配置信息很少。这是在<span class="apiname">LogManager</span>类的描述中指定的，并包括在启动期间要安装的根级处理程序的列表。
                  </p>
                  <p>初始配置可以为特定记录器指定级别。这些级别将应用于命名记录器以及命名层次结构中位于其下的所有记录器。按照在配置文件中定义的顺序应用级别。</p>
                  <p>初始配置可以包含供处理程序或进行日志记录的子系统使用的任意属性。按照惯例，这些属性应使用以处理程序类的名称或子系统的主<span class="apiname">Logger的</span>名称开头的名称。
                  </p>
                  <p>例如， <span class="apiname">MemoryHandler</span>使用属性<span class="apiname">java.util.logging。MemoryHandler.size</span>确定其环形缓冲区的默认大小。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DEFAULTCONFIGURATION-4D023EDA">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-5F550228-7A87-4617-B9F7-08ECA4F053E8">默认配置</p>
                  <p>JRE附带的默认日志记录配置仅是默认配置，并且可以被ISV，系统管理员和最终用户覆盖。</p>
                  <p>默认配置仅限制使用磁盘空间。它不会使用户充满信息，但可以确保始终捕获关键故障信息。</p>
                  <p>默认配置在根记录器上建立单个处理程序，用于将输出发送到控制台。</p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DYNAMICCONFIGURATIONUPDATES-4D0240C7">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-8CC794A8-647B-4A04-8187-CFEEE163F38E">动态配置更新</p>
                  <p>程序员可以通过多种方式在运行时更新日志记录配置：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="apiname">FileHandler</span> ， <span class="apiname">MemoryHandler</span>和<span class="apiname">ConsoleHandler</span>对象都可以使用各种属性来创建。
                        </p>
                     </li>
                     <li>
                        <p>可以添加新的<span class="apiname">处理程序</span>对象，而删除旧的对象。
                        </p>
                     </li>
                     <li>
                        <p>可以创建新的<span class="apiname">Logger</span>对象，并可以随特定的Handlers一起提供。
                        </p>
                     </li>
                     <li>
                        <p>可以在目标<span class="apiname">处理程序</span>对象上设置<span class="apiname">级别</span>对象。
                        </p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__NATIVEMETHODS-4D0242BC">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-11A50898-3365-4CA5-A71A-2558AD300755">本机方法</p>
                  <p>没有用于记录的本机API。</p>
                  <p>希望使用Java Logging机制的本机代码应对Java Logging API进行普通的JNI调用。</p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__XMLDTD-4D0243CB">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-D5DE7E94-C497-4C71-9291-2EE35BB3426F">XML DTD</p>
                  <p><span class="apiname">XMLFormatter</span>使用的XML DTD在<a href="java-logging-overview.html#GUID-84971801-F327-4F96-8F35-DA4D6737F857">附录A：XMLFormatter输出的DTD中</a>指定。
                  </p>
                  <p>DTD设计有一个<code class="codeph"><log></code>元素作为顶级文档。然后将各个日志记录写为<code class="codeph"><record></code>元素。
                  </p>
                  <p>请注意，如果JVM崩溃，则可能无法通过适当的关闭干净地终止<span class="apiname">XMLFormatter</span>流<code class="codeph"></log></code> 。因此，应准备分析日志记录的工具以应对未终止的流。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__UNIQUEMESSAGEIDS-4D024671">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-416B9C2E-4902-46E5-A890-3139B9BFE8AB">唯一消息ID</p>Java Logging API不提供对唯一消息ID的任何直接支持。那些需要唯一消息ID的应用程序或子系统应定义自己的约定，并在消息字符串中适当包含唯一ID。
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-E027A099-015F-4305-9972-391AABAD812C">安全</p>
                  <p>主要的安全要求是不受信任的代码不应能够更改日志记录配置。具体来说，如果已将日志记录配置设置为将特定类别的信息记录到特定的Handler，则不受信任的代码应该不能阻止或中断该日志记录。</p>
                  <p>安全权限<span class="apiname">LoggingPermission</span>控制对日志记录配置的更新。
                  </p>
                  <p>受信任的应用程序将获得适当的<span class="apiname">LoggingPermission，</span>因此它们可以调用任何日志记录配置API。不信任的小程序则是另外一回事。不受信任的小程序可以按常规方式创建和使用命名记录器，但是不允许它们更改记录控制设置，例如添加或删除处理程序或更改日志级别。但是，不受信任的applet可以使用<span class="apiname">Logger.getAnonymousLogger</span>创建和使用自己的“匿名”记录器。这些匿名记录器未在全局名称空间中注册，其方法也未经访问检查，甚至允许不受信任的代码更改其记录控制设置。
                  </p>
                  <p>日志记录框架不会尝试防止欺骗。无法可靠地确定日志记录调用的来源，因此当发布<span class="apiname">LogRecord</span>声称自己来自特定的源类和源方法时，它可能是捏造的。同样，诸如<span class="apiname">XMLFormatter之类的</span>格式化程序也不会尝试保护自己免受消息字符串内嵌套的日志消息的侵害。因此，欺骗<span class="apiname">LogRecord</span>可能在其消息字符串中包含一组XML欺骗，以使其看起来好像输出中还有其他XML记录。
                  </p>
                  <p>此外，日志记录框架不会尝试保护自己免受拒绝服务攻击。任何给定的日志记录客户端都可以使用无意义的消息来填充日志记录框架，以隐藏一些重要的日志消息。</p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONMANAGEMENT-4D02480C">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-13A1DE6F-BF10-48B7-BB8B-97E9B9F03C6C">配置管理</p>
                  <p>这些API的结构使得从配置文件中读取的一组初始配置信息作为属性。然后可以通过调用各种日志记录类和对象来以编程方式更改配置信息。</p>
                  <p>此外， <span class="apiname">LogManager</span>上还有一些方法可以允许重新读取配置文件。发生这种情况时，配置文件值将覆盖以编程方式进行的所有更改。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__PACKAGING-4D024A51">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-8A9AEE03-D319-49ED-A6F3-D90F1F705F10">打包</p>
                  <p>所有日志记录类都在<code class="codeph">java.*</code>名称空间的一部分，位于<span class="apiname">java.util.logging</span>包中。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOCALIZATION-4D024B46">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-6EFD37D7-7C78-4EFF-8BDF-CBA4227C7386">本土化</p>
                  <p>日志消息可能需要本地化。</p>
                  <p>每个记录器可能都有与之关联的<span class="apiname">ResourceBundle</span>名称。相应的<span class="apiname">ResourceBundle</span>可用于在原始消息字符串和本地化消息字符串之间进行映射。
                  </p>
                  <p>通常，格式化程序执行本地化。为方便起见， <span class="apiname">Formatter</span>类提供了<span class="apiname">formatMessage</span>方法，该方法提供了一些基本的本地化和格式支持。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__REMOTEACCESSANDSERIALIZATION-4D024D3A">
                  <p class="subhead1" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-36FBD7AA-0061-4F32-BB92-99D33100D1F9">远程访问和序列化</p>
                  <p>与大多数Java平台API一样，日志记录API旨在在单个地址空间内使用。所有呼叫均应是本地电话。但是，预计某些处理程序将希望将其输出转发到其他系统。有多种方法可以执行此操作：</p>
                  <p>一些处理程序（例如<span class="apiname">SocketHandler</span> ）可能会使用<span class="apiname">XMLFormatter</span>将数据写入其他系统。这提供了一种简单的，标准的，可互换的格式，可以在各种系统上进行解析和处理。
                  </p>
                  <p>一些处理程序可能希望通过RMI传递<span class="apiname">LogRecord</span>对象。因此<span class="apiname">LogRecord</span>类是可序列化的。但是，如何处理<span class="apiname">LogRecord</span>参数存在问题。一些参数可能无法序列化，而其他参数可能已被设计为序列化比日志记录所需更多的状态。为了避免这些问题， <span class="apiname">LogRecord</span>类具有一个自定义的<span class="apiname">writeObject</span>方法，该方法在将参数写出之前将参数转换为字符串（使用<span class="apiname">Object.toString（）</span> ）。
                  </p>
                  <p>大多数日志记录类都不打算可序列化。记录器和处理程序都是有状态的类，它们绑定到特定的虚拟机中。在这方面，它们类似于<span class="apiname">java.io</span>类，它们也不能序列化。
                  </p>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC" name="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC"></a><h3 id="JSCOR-GUID-48004124-2C00-49F7-A640-0C0DDA271DBC" class="sect3">Java记录范例</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC__GUID-E6520922-1AE6-4725-9C12-5615F2D67669">使用简单</p>
                     <p>以下是一个使用默认配置执行日志记录的小程序。</p>
                     <p>该程序依赖于<span class="apiname">LogManager</span>基于配置文件建立的根处理程序。它创建自己的<span class="apiname">Logger</span>对象，然后调用该<span class="apiname">Logger</span>对象以报告各种事件。
                     </p><pre class="pre codeblock"><code>package com.wombat;
import java.util.logging.*;

public class Nose {
    // Obtain a suitable logger.
    private static Logger logger = Logger.getLogger("com.wombat.nose");
    public static void main(String argv[]) {
        // Log a FINE tracing message
        logger.fine("doing stuff");
        try {
            Wombat.sneeze();
        } catch (Exception ex) {
            // Log the exception
            logger.log(Level.WARNING, "trouble sneezing", ex);
        }
        logger.fine("done");
    }
}</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC__GUID-E4F30666-F7D1-489B-B856-4A72E8721D68">更改配置</p>
                     <p>这是一个小程序，可动态调整日志记录配置，以将输出发送到特定文件并获取有关袋熊的大量信息。模式<code class="codeph">%t</code>表示系统临时目录。
                     </p><pre class="pre codeblock"><code>public static void main(String[] args) {
    Handler fh = new FileHandler("%t/wombat.log");
    Logger.getLogger("").addHandler(fh);
    Logger.getLogger("com.wombat").setLevel(Level.FINEST);
    ...
}</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC__GUID-3142B0F0-7264-4F44-B502-C12FFE348676">使用简单，忽略全局配置</p>
                     <p>这是一个小程序，它设置自己的日志记录<span class="apiname">处理程序</span>并忽略全局配置。
                     </p><pre class="pre codeblock"><code>package com.wombat;

import java.util.logging.*;

public class Nose {
    private static Logger logger = Logger.getLogger("com.wombat.nose");
    private static FileHandler fh = new FileHandler("mylog.txt");
    public static void main(String argv[]) {
        // Send logger output to our FileHandler.
        logger.addHandler(fh);
        // Request that every detail gets logged.
        logger.setLevel(Level.ALL);
        // Log a simple INFO message.
        logger.info("doing stuff");
        try {
            Wombat.sneeze();
        } catch (Exception ex) {
            logger.log(Level.WARNING, "trouble sneezing", ex);
        }
        logger.fine("done");
    }
}</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC__GUID-15299134-B1DC-48E1-A454-A96F211F4A2D">XML输出样例</p>
                     <p>这是一些<span class="apiname">XMLFormatter</span> XML输出看起来的小样本：</p><pre class="pre codeblock"><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE log SYSTEM "logger.dtd"&gt;
&lt;log&gt;
  &lt;record&gt;
    &lt;date&gt;2015-02-27T09:35:44.885562Z&lt;/date&gt;
    &lt;millis&gt;1425029744885&lt;/millis&gt;
    &lt;nanos&gt;562000&lt;/nanos&gt;
    &lt;sequence&gt;1256&lt;/sequence&gt;
    &lt;logger&gt;kgh.test.fred&lt;/logger&gt;
    &lt;level&gt;INFO&lt;/level&gt;
    &lt;class&gt;kgh.test.XMLTest&lt;/class&gt;
    &lt;method&gt;writeLog&lt;/method&gt;
    &lt;thread&gt;10&lt;/thread&gt;
    &lt;message&gt;Hello world!&lt;/message&gt;
  &lt;/record&gt;
&lt;/log&gt;</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-84971801-F327-4F96-8F35-DA4D6737F857" name="GUID-84971801-F327-4F96-8F35-DA4D6737F857"></a><h3 id="JSCOR-GUID-84971801-F327-4F96-8F35-DA4D6737F857" class="sect3">附录A：XMLFormatter输出的DTD</h3>
               <div>
                  <p></p><pre class="pre codeblock"><code>&lt;!-- DTD used by the java.util.logging.XMLFormatter --&gt;
&lt;!-- This provides an XML formatted log message. --&gt;

&lt;!-- The document type is "log" which consists of a sequence
of record elements --&gt;
&lt;!ELEMENT log (record*)&gt;

&lt;!-- Each logging call is described by a record element. --&gt;
&lt;!ELEMENT record (date, millis, nanos?, sequence, logger?, level,
class?, method?, thread?, message, key?, catalog?, param*, exception?)&gt;

&lt;!-- Date and time when LogRecord was created in ISO 8601 format --&gt;
&lt;!ELEMENT date (#PCDATA)&gt;

&lt;!-- Time when LogRecord was created in milliseconds since
midnight January 1st, 1970, UTC. --&gt;
&lt;!ELEMENT millis (#PCDATA)&gt;

&lt;!-- Nano second adjustement to add to the time in milliseconds. 
This is an optional element, added since JDK 9, which adds further
precision to the time when LogRecord was created.
 --&gt;
&lt;!ELEMENT nanos (#PCDATA)&gt;

&lt;!-- Unique sequence number within source VM. --&gt;
&lt;!ELEMENT sequence (#PCDATA)&gt;

&lt;!-- Name of source Logger object. --&gt;
&lt;!ELEMENT logger (#PCDATA)&gt;

&lt;!-- Logging level, may be either one of the constant
names from java.util.logging.Level (such as "SEVERE"
or "WARNING") or an integer value such as "20". --&gt;
&lt;!ELEMENT level (#PCDATA)&gt;

&lt;!-- Fully qualified name of class that issued
logging call, e.g. "javax.marsupial.Wombat". --&gt;
&lt;!ELEMENT class (#PCDATA)&gt;

&lt;!-- Name of method that issued logging call.
It may be either an unqualified method name such as
"fred" or it may include argument type information
in parenthesis, for example "fred(int,String)". --&gt;
&lt;!ELEMENT method (#PCDATA)&gt;

&lt;!-- Integer thread ID. --&gt;
&lt;!ELEMENT thread (#PCDATA)&gt;

&lt;!-- The message element contains the text string of a log message. --&gt;
&lt;!ELEMENT message (#PCDATA)&gt;

&lt;!-- If the message string was localized, the key element provides
the original localization message key. --&gt;
&lt;!ELEMENT key (#PCDATA)&gt;

&lt;!-- If the message string was localized, the catalog element provides
the logger's localization resource bundle name. --&gt;
&lt;!ELEMENT catalog (#PCDATA)&gt;

&lt;!-- If the message string was localized, each of the param elements
provides the String value (obtained using Object.toString())
of the corresponding LogRecord parameter. --&gt;
&lt;!ELEMENT param (#PCDATA)&gt;

&lt;!-- An exception consists of an optional message string followed
by a series of StackFrames. Exception elements are used
for Java exceptions and other java Throwables. --&gt;
&lt;!ELEMENT exception (message?, frame+)&gt;

&lt;!-- A frame describes one line in a Throwable backtrace. --&gt;
&lt;!ELEMENT frame (class, method, line?)&gt;

&lt;!-- an integer line number within a class's source file. --&gt;
&lt;!ELEMENT line (#PCDATA)&gt;
</code></pre></div>
            </div>
         </div>
      </article>
   

</body></html>