<html lang="en-us" dir="ltr" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section describes how to access Java from a script interpreted by the Nashorn engine.">
      <meta name="description" content="This section describes how to access Java from a script interpreted by the Nashorn engine.">
      <title>The Nashorn Java API</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Nashorn User's Guide">
      <meta property="og:description" content="This section describes how to access Java from a script interpreted by the Nashorn engine.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Nashorn User's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="nashorn-users-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T19:14:09-07:00">
      <meta name="dcterms.title" content="Nashorn User's Guide">
      <meta name="dcterms.dateCopyrighted" content="2014, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94836-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="introduction.html" title="Previous" type="text/html">
      <link rel="next" href="nashorn-and-javafx.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="NASHORN">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="nashorn-and-javafx.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Nashorn用户指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Nashorn Java API</li>
            </ol>
            <a id="GUID-0C8FD2AD-6000-425F-BC22-25AAC6A14225" name="GUID-0C8FD2AD-6000-425F-BC22-25AAC6A14225"></a><a id="JSNUG113"></a><a id="JSNUG112"></a>
            
            <h2 id="JSNUG-GUID-0C8FD2AD-6000-425F-BC22-25AAC6A14225" class="sect2"><span class="enumeration_chapter">2</span> Nashorn Java API</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本节介绍如何从Nashorn引擎解释的脚本访问Java。</span></div>
               <div class="infoboxnote" id="GUID-0C8FD2AD-6000-425F-BC22-25AAC6A14225__THENASHORNENGINETHEJJSTOOLANDTHEMOD-A65A6866">
                  <p class="notep1">注意：</p>Nashorn引擎<code class="codeph">jjs</code> JDK 11中不推荐使用<span class="apiname">jdk.scripting.nashorn</span>和<span class="apiname">jdk.scripting.nashorn.shell</span>模块，以准备在将来的版本中删除。
               </div>
               <p>本节包含Nashorn引擎以交互语言外壳模式解释的脚本语句示例。该交互式外壳程序通过运行<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/nashorn&id=JSWOR-GUID-0F3625BB-9E0E-46C3-8FF1-CEFDD91EDF85" target="_blank"><code class="codeph">jjs</code></a>命令，但不传递任何脚本。这对于尝试进行操作很有用，但是Nashorn Java API的主要目的是将Java应用程序编写为可以由Nashorn引擎解释的脚本。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-0C8FD2AD-6000-425F-BC22-25AAC6A14225__GUID-A51CDA65-EC53-49FC-8BAD-FB498977DD30">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="nashorn-java-api.html#GUID-336B7904-ABCF-4588-A640-C2F7746F8333" title="使用Nashorn访问包和类的方法有两种：传统方法是使用Packages全局对象，推荐的方法是使用Java全局对象。本节介绍两种方法。">访问Java类</a></li>
                     <li><a href="nashorn-java-api.html#GUID-5EB82F41-6871-4896-8495-6D3DA373DE13" title="要实例化一个类，请将JavaClass函数对象传递给new运算符。Nashorn基于传递给函数的参数调用相应的构造函数。">创建Java对象</a></li>
                     <li><a href="nashorn-java-api.html#GUID-5ED04A1E-9269-463A-AFB8-7A6C365ABC9F" title="您可以使用标准的点符号来访问静态字段，方法和内部类，如下所示。">访问类和实例成员</a></li>
                     <li><a href="nashorn-java-api.html#GUID-594ED1F7-993A-433F-A2AE-B1B8B12E1690" title="Nashorn使您可以将JavaBean中的访问器和更改器方法视为等效的JavaScript属性。该属性的名称是不带get或set后缀的JavaBean方法的名称，并以小写字母开头。">使用JavaBeans</a></li>
                     <li><a href="nashorn-java-api.html#GUID-B63F085D-82E0-4B45-AC85-B0F78A213E9D" title="要访问Java数组类，请将包含数组的对象类型（后跟一对方括号）传递给Java.type（）函数（类似于Java语法）。">使用Java数组</a></li>
                     <li><a href="nashorn-java-api.html#GUID-1674531B-4008-4871-B47E-D13628616C66" title="Nashorn将字符串表示为java.lang。字符串对象。连接两个字符串时，将获得一个String实例。">使用Java字符串</a></li>
                     <li><a href="nashorn-java-api.html#GUID-191A697D-23F8-4F73-BAAD-FCE653BECF36" title="Nashorn将数字解释为java.lang。Double，java.lang。Long或java.lang。整数对象，取决于执行的计算。您可以使用Number（）函数将数字强制为Double对象，如以下示例所示。">使用Java数字</a></li>
                     <li><a href="nashorn-java-api.html#GUID-D1C84FB4-33D6-4584-843A-FD3356C4D11F" title="Nashorn将Java列表解释为数组；使用for每个语句遍历列表的值。要遍历映射中的键和值，请使用keySet（）和values（）方法。">使用Java列表和地图</a></li>
                     <li><a href="nashorn-java-api.html#GUID-B631F440-2320-47D7-8012-85A70A40F986" title="您可以使用Java.extend（）函数扩展一个类，该函数将Java类型作为第一个参数，并将方法实现（以JavaScript函数的形式）作为其他参数。">扩展Java类</a></li>
                     <li><a href="nashorn-java-api.html#GUID-44255E9F-8FAE-4FFD-84BA-90A572AFC51B" title="jdk.nashorn.api.scripting。ClassFilter接口通过限制从Nashorn脚本引擎运行的脚本对指定Java类的访问来提供对从JavaScript代码对Java类的访问的细粒度控制。">将脚本访问限制为指定的Java类</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JSNUG114"></a><div class="props_rev_3"><a id="GUID-336B7904-ABCF-4588-A640-C2F7746F8333" name="GUID-336B7904-ABCF-4588-A640-C2F7746F8333"></a><h3 id="JSNUG-GUID-336B7904-ABCF-4588-A640-C2F7746F8333" class="sect3">访问Java类</h3>
               <div>
                  <p>使用Nashorn访问包和类的方法有两种：传统方法是使用<code class="codeph">Packages</code>全局对象，建议的方法是使用<code class="codeph">Java</code>全局对象。本节介绍两种方法。
                  </p>
                  <p>预定义的顶层<code class="codeph">Packages</code>对象使您可以使用Java包和类的完全限定名称来访问它们，就像它们是<code class="codeph">Packages</code>宾语。以下示例显示了如何访问<code class="codeph">MyPackage</code>包装及其<code class="codeph">MyClass</code>如果<code class="codeph">MyPackage.jar</code>在您的课程路径中：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Packages.MyPackage</span>
[JavaPackage MyPackage]
jjs&gt; <span class="bold">Packages.MyPackage.MyClass</span>
[JavaClass MyPackage.MyClass]
</code></pre><p>访问标准Java包和类比访问自定义包和类更直接。为了方便起见，为每个标准Java包定义了全局对象： <code class="codeph">com</code> ， <code class="codeph">edu</code> ， <code class="codeph">java</code> ， <code class="codeph">javax</code>和<code class="codeph">org</code> 。它们的别名与<code class="codeph">Packages</code>宾语。以下示例显示了如何访问<code class="codeph">java.lang</code>包装和<code class="codeph">java.lang.System</code>类：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">java.lang</span>
[JavaPackage java.lang]
jjs&gt; <span class="bold">typeof java.lang</span>
object
jjs&gt; <span class="bold">java.lang.System</span>
[JavaClass java.lang.System]
jjs&gt; <span class="bold">typeof java.lang.System</span>
function
</code></pre><p>从上一个示例中可以看到，Nashorn将Java包解释为<code class="codeph">JavaPackage</code>对象和Java类<code class="codeph">JavaClass</code>函数对象，可用作类的构造函数。<a href="nashorn-java-api.html#GUID-5EB82F41-6871-4896-8495-6D3DA373DE13" title="要实例化一个类，请将JavaClass函数对象传递给new运算符。Nashorn基于传递给函数的参数调用相应的构造函数。">创建Java对象</a>描述了如何实例化一个类。
                  </p>
                  <p>访问Java包和类的传统方法是直观，直接的，但是同时，由于以下原因，它效率低下，受限制且容易出错：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>每次属性访问都需要付出一定的代价，因此在较深的层次结构中访问包或类可能很慢。</p>
                     </li>
                     <li>
                        <p>创建Java数组没有特殊的语法。您必须使用<code class="codeph">java.lang.reflect.Array</code>类作为解决方法。
                        </p>
                     </li>
                     <li>
                        <p>如果您拼写错误的类名，Nashorn会假定您提供了包名，并将其解释为<code class="codeph">JavaPackage</code>对象而不是<code class="codeph">JavaClass</code>功能对象。尝试将其用作类时，可能会引发错误，直到您才意识到这一点。为避免这种情况，请使用<code class="codeph">typeof</code>运算符，有条件地测试您尝试访问的构造是否被解释为功能对象。以下示例显示了此条件检查的工作方式：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">typeof java.lang.System == "function"</span>
true
jjs&gt; <span class="bold">typeof java.lang.Zyztem == "function"</span>
false
</code></pre></li>
                  </ul>
                  <p>为了避免上述方法的缺点，Nashorn定义了<code class="codeph">Java</code>具有多个用于处理Java类的功能的全局对象。的<code class="codeph">Java.type()</code>函数采用具有完全限定的Java类名称的字符串，并返回对应的<code class="codeph">JavaClass</code>功能对象。以下示例显示了如何访问<code class="codeph">java.lang.System</code>类：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Java.type("java.lang.System")</span>
[JavaClass java.lang.System]
</code></pre><p>类似于在Java中导入类，优良作法是声明以下变量： <code class="codeph">JavaClass</code>在脚本的开头键入。以下示例说明了如何声明<code class="codeph">System</code>变量并为其赋值<code class="codeph">java.lang.System</code>类：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var System = Java.type("java.lang.System")</span>
jjs&gt; <span class="bold">System</span>
[JavaClass java.lang.System]
</code></pre></div>
            </div><a id="JSNUG115"></a><div class="props_rev_3"><a id="GUID-5EB82F41-6871-4896-8495-6D3DA373DE13" name="GUID-5EB82F41-6871-4896-8495-6D3DA373DE13"></a><h3 id="JSNUG-GUID-5EB82F41-6871-4896-8495-6D3DA373DE13" class="sect3">创建Java对象</h3>
               <div>
                  <p>要实例化一个类，请传递<code class="codeph">JavaClass</code>功能对象<code class="codeph">new</code>操作员。Nashorn基于传递给函数的参数调用相应的构造函数。
                  </p>
                  <div class="section">
                     <p>以下示例说明了如何实例化<code class="codeph">java.util.HashMap</code>具有默认初始容量并且初始容量设置为100的类：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var HashMap = Java.type("java.util.HashMap")</span>
jjs&gt; <span class="bold">var mapDef = new HashMap()</span>
jjs&gt; <span class="bold">var map100 = new HashMap(100)</span>
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG116"></a><div class="props_rev_3"><a id="GUID-5ED04A1E-9269-463A-AFB8-7A6C365ABC9F" name="GUID-5ED04A1E-9269-463A-AFB8-7A6C365ABC9F"></a><h3 id="JSNUG-GUID-5ED04A1E-9269-463A-AFB8-7A6C365ABC9F" class="sect3">访问类和实例成员</h3>
               <div>
                  <p>您可以使用标准的点符号来访问静态字段，方法和内部类，如下所示。</p>
                  <div class="section"><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Java.type("java.lang.Math").PI</span>
3.141592653589793
jjs&gt; <span class="bold">Java.type("java.lang.System").currentTimeMillis()</span>
1375813353330
jjs&gt; <span class="bold">Java.type("java.util.Map").Entry</span>
[JavaClass java.util.Map$Entry]
</code></pre><p>内部类也可以使用带有美元符号（ <code class="codeph">$</code> ）作为分隔符或点，与Java一致：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Java.type("java.util.Map$Entry")</span>
[JavaClass java.util.Map$Entry]
jjs&gt; <span class="bold">Java.type("java.util.Map.Entry")</span>
[JavaClass java.util.Map$Entry]
</code></pre><p>要调用实例方法或访问对象的实例字段，请使用点运算符，类似于Java中的操作。以下示例说明了如何调用<code class="codeph">toUpperCase()</code>上的方法<code class="codeph">String</code>宾语：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var String = Java.type("java.lang.String")</span>
jjs&gt; <span class="bold">var str = new String("Hello")</span>
jjs&gt; str
Hello
jjs&gt; <span class="bold">var upper = str.toUpperCase()</span>
jjs&gt; <span class="bold">upper</span>
HELLO
</code></pre><p>Nashorn还支持使用括号表示法访问成员，在该方法中，您将成员的名称指定为括号之间的字符串（ <code class="codeph">[]</code> ），紧随类（对于静态成员）或对象（对于实例成员）。此方法由ECMAScript定义为点表示法的替代方法，对于Java开发人员而言不直观。但是，它可以用来解决方法重载的歧义。默认情况下，Nashorn使用与参数最匹配的重载方法，这并不总是您所期望的。例如，如果您要打印一个<code class="codeph">double</code>值，您必须使用<code class="codeph">java.lang.System.out.println(double)</code>方法重载，如以下示例所示：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Java.type("java.lang.System").out.println(10)</span>
10
jjs&gt; <span class="bold">Java.type("java.lang.System").out["println(double)"](10)</span>
10.0
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG117"></a><div class="props_rev_3"><a id="GUID-594ED1F7-993A-433F-A2AE-B1B8B12E1690" name="GUID-594ED1F7-993A-433F-A2AE-B1B8B12E1690"></a><h3 id="JSNUG-GUID-594ED1F7-993A-433F-A2AE-B1B8B12E1690" class="sect3">使用JavaBeans</h3>
               <div>
                  <p>Nashorn使您可以将JavaBean中的访问器和更改器方法视为等效的JavaScript属性。该属性的名称是JavaBean方法的名称，不包含<code class="codeph">get</code>要么<code class="codeph">set</code>后缀，并以小写字母开头。
                  </p>
                  <div class="section">
                     <p>例如，您可以致电<code class="codeph">getYear()</code>和<code class="codeph">setYear()</code>一个方法<code class="codeph">java.util.Date</code>使用对象<code class="codeph">year</code>属性如下：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var Date = Java.type("java.util.Date")</span>
jjs&gt; <span class="bold">var date = new Date()</span>
jjs&gt; <span class="bold">date.year + 1900</span>
2013
jjs&gt; <span class="bold">date.year = 2014 - 1900</span>
114
jjs&gt; <span class="bold">date.year + 1900</span>
2014
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG118"></a><div class="props_rev_3"><a id="GUID-B63F085D-82E0-4B45-AC85-B0F78A213E9D" name="GUID-B63F085D-82E0-4B45-AC85-B0F78A213E9D"></a><h3 id="JSNUG-GUID-B63F085D-82E0-4B45-AC85-B0F78A213E9D" class="sect3">使用Java数组</h3>
               <div>
                  <p>要访问Java数组类，请传递至<code class="codeph">Java.type()</code>函数的功能是组成数组的对象的类型，后跟一对括号（类似于Java语法）。
                  </p>
                  <div class="section">
                     <p>以下示例说明如何访问整数的Java数组和的Java数组。 <code class="codeph">String</code>对象：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">Java.type("int[]")</span>
[JavaClass [I]
jjs&gt; <span class="bold">Java.type("java.lang.String[]")</span>
[JavaClass [Ljava.lang.String;]
</code></pre><p>拥有数组类型对象后，可以像处理其他任何类一样使用它实例化数组。您可以通过数组索引访问它们的索引，并使用点号或方括号表示法来访问成员（类似于Java语法），如以下示例所示：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var IntArrayType = Java.type("int[]")</span>
jjs&gt; <span class="bold">var arr = new IntArrayType(10)</span>
jjs&gt; <span class="bold">arr[1] = 123</span>
123
jjs&gt; <span class="bold">arr[2] = 321</span>
321
jjs&gt; <span class="bold">arr[1] + arr[2]</span>
444
jjs&gt; <span class="bold">arr[10]</span>
java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 10
jjs&gt; <span class="bold">arr.length</span>
10
</code></pre><p>如果您有现有的JavaScript数组，则可以使用以下命令将其转换为Java数组<code class="codeph">Java.to()</code>功能。以下示例显示了如何转换字符串的JavaScript数组<code class="codeph">"a"</code> ， <code class="codeph">"b"</code>和<code class="codeph">"c"</code> ，到<code class="codeph">java.lang.String[]</code>具有相同值的数组：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var jsArr = ["a","b","c"]</span>
jjs&gt; <span class="bold">var strArrType = Java.type("java.lang.String[]")</span>
jjs&gt; <span class="bold">var javaArr = Java.to(jsArr, strArrType)</span>
jjs&gt; <span class="bold">javaArr.class</span>
class [Ljava.lang.String;
jjs&gt; <span class="bold">javaArr[0]</span>
a
</code></pre><p>您可以使用来遍历Java数组的索引和值<code class="codeph">for</code>和<code class="codeph">for each</code>声明如下：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">for (var i in javaArr) print(i)</span>
0
1
2
jjs&gt; <span class="bold">for each (var i in javaArr) print(i)</span>
a
b
c
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG119"></a><div class="props_rev_3"><a id="GUID-1674531B-4008-4871-B47E-D13628616C66" name="GUID-1674531B-4008-4871-B47E-D13628616C66"></a><h3 id="JSNUG-GUID-1674531B-4008-4871-B47E-D13628616C66" class="sect3">使用Java字符串</h3>
               <div>
                  <p>Nashorn将字符串表示为<code class="codeph">java.lang.String</code>对象。连接两个字符串时，会得到一个<code class="codeph">String</code>实例。
                  </p>
                  <div class="section"><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var a = "abc"</span>
jjs&gt; <span class="bold">a.class</span>
class java.lang.String
jjs&gt; <span class="bold">var b = a + "def"</span>
jjs&gt; <span class="bold">b.class</span>
class java.lang.String
jjs&gt; <span class="bold">var c = String(b)</span>
jjs&gt; <span class="bold">c.class</span>
class java.lang.String</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG120"></a><div class="props_rev_3"><a id="GUID-191A697D-23F8-4F73-BAAD-FCE653BECF36" name="GUID-191A697D-23F8-4F73-BAAD-FCE653BECF36"></a><h3 id="JSNUG-GUID-191A697D-23F8-4F73-BAAD-FCE653BECF36" class="sect3">使用Java数字</h3>
               <div>
                  <p>Nashorn将数字解释为<code class="codeph">java.lang.Double</code> ， <code class="codeph">java.lang.Long</code> ， 要么<code class="codeph">java.lang.Integer</code>对象，具体取决于执行的计算。您可以使用<code class="codeph">Number()</code>强制数字为<code class="codeph">Double</code>对象，如以下示例所示。
                  </p>
                  <div class="section"><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var intNum = 10</span>
jjs&gt; <span class="bold">intNum.class</span>
class java.lang.Integer
jjs&gt; <span class="bold">var dblNum = Number(intNum)</span>
jjs&gt; <span class="bold">dblNum.class</span>
class java.lang.Double
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG121"></a><div class="props_rev_3"><a id="GUID-D1C84FB4-33D6-4584-843A-FD3356C4D11F" name="GUID-D1C84FB4-33D6-4584-843A-FD3356C4D11F"></a><h3 id="JSNUG-GUID-D1C84FB4-33D6-4584-843A-FD3356C4D11F" class="sect3">使用Java列表和地图</h3>
               <div>
                  <p>Nashorn将Java列表解释为数组；使用来遍历列表的值<code class="codeph">for each</code>声明。要遍历映射中的键和值，请使用<code class="codeph">keySet()</code>和<code class="codeph">values()</code>方法。
                  </p>
                  <div class="section">
                     <p>您可以使用方括号中的索引来访问列表元素（ <code class="codeph">[]</code> ）并使用来遍历列表的值<code class="codeph">for each</code>语句，如以下示例所示。
                     </p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var ArrayList = Java.type("java.util.ArrayList")</span>
jjs&gt; <span class="bold">var alist = new ArrayList()</span>
jjs&gt; <span class="bold">alist.add("a")</span>
true
jjs&gt; <span class="bold">alist.add("b")</span>
true
jjs&gt; <span class="bold">alist.add("c")</span>
true
jjs&gt; <span class="bold">alist[1]</span>
b
jjs&gt; <span class="bold">for each (var i in alist) print(i)</span>
a
b
c
</code></pre><div class="infoboxnote" id="GUID-D1C84FB4-33D6-4584-843A-FD3356C4D11F__GUID-312AC634-ED0F-4BDF-9F3A-23D0A3872720">
                        <p class="notep1">注意：</p>您只能使用方括号中的索引来访问列表和地图元素。特别是，您无法使用此语法访问队列和设置元素。
                     </div>
                     <p>以下示例说明了如何创建<code class="codeph">HashMap</code>对象，并使用<code class="codeph">keySet()</code>和<code class="codeph">values()</code>方法。
                     </p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var HashMap = Java.type("java.util.HashMap")</span>
jjs&gt; <span class="bold">var hm = new HashMap()</span>
jjs&gt; <span class="bold">hm.put("name", "Bob")</span>
jjs&gt; <span class="bold">hm.put("age", 40)</span>
jjs&gt; <span class="bold">hm.put("weight", 180)</span>
jjs&gt; <span class="bold">for each (var i in hm.keySet()) print(i)</span>
weight
age
name
jjs&gt; <span class="bold">for each (var i in hm.values()) print(i)</span>
180
40
Bob
</code></pre><p>另外，您可以以迭代列表值的方式来迭代映射的值，如以下示例所示：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">for each (var i in hm) print(i)</span>
180
40
Bob
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSNUG123"></a><a id="JSNUG124"></a><a id="JSNUG122"></a><div class="props_rev_3"><a id="GUID-B631F440-2320-47D7-8012-85A70A40F986" name="GUID-B631F440-2320-47D7-8012-85A70A40F986"></a><h3 id="JSNUG-GUID-B631F440-2320-47D7-8012-85A70A40F986" class="sect3">扩展Java类</h3>
               <div>
                  <p>您可以使用<code class="codeph">Java.extend()</code>将Java类型作为第一个参数的函数，将方法实现（以JavaScript函数的形式）作为其他参数。
                  </p>
                  <div class="section">
                     <p>以下脚本扩展了<code class="codeph">java.lang.Runnable</code>界面并使用它来构建一个新的<code class="codeph">java.lang.Thread</code>宾语：</p><pre class="pre codeblock"><code>var Run = Java.type("java.lang.Runnable");
var MyRun = Java.extend(Run, {
    run: function() {
        print("Run in separate thread");
    }
});
var Thread = Java.type("java.lang.Thread");
var th = new Thread(new MyRun());
</code></pre><p>如果您提供了用于实现方法的函数作为构造函数的参数，则Nashorn可以自动扩展功能接口（请参见注释类型<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/FunctionalInterface.html" target="_blank"><span class="apiname">FunctionalInterface</span></a> ）。以下脚本扩展了<code class="codeph">java.lang.Runnable</code>界面并使用它来构建一个新的<code class="codeph">java.lang.Thread</code>对象，但是它使用的代码行比<a href="nashorn-java-api.html#GUID-B631F440-2320-47D7-8012-85A70A40F986__CDEFGJBD">示例2-1中的少</a> ，因为<code class="codeph">Java.extend()</code>函数会自动为功能接口调用。
                     </p><pre class="pre codeblock"><code>var Thread = Java.type("java.lang.Thread")
var th = new Thread(function() print("Run in a separate thread"))
</code></pre><p>在<span><cite>Java Edition Standard Edition中</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/nashorn&id=JSJSG-GUID-B631F440-2320-47D7-8012-85A70A40F986" target="_blank">扩展Java类</a>中的<span><cite>Java脚本编程指南，</cite></span>描述了<span><cite>Java脚本</cite></span>的功能。 <code class="codeph">Java.extend()</code>功能。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B631F440-2320-47D7-8012-85A70A40F986__CDEFGJBD">
                     <p class="titleinexample">示例2-1扩展Java类</p><pre class="pre codeblock"><code>var Run = Java.type("java.lang.Runnable");
var MyRun = Java.extend(Run, {
    run: function() {
        print("Run in separate thread");
    }
});
var Thread = Java.type("java.lang.Thread");
var th = new Thread(new MyRun());
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-B631F440-2320-47D7-8012-85A70A40F986__CDEHEEHG">
                     <p class="titleinexample">示例2-2扩展功能接口</p><pre class="pre codeblock"><code>var Thread = Java.type("java.lang.Thread")
var th = new Thread(function() print("Run in a separate thread"))
</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="JSNUG125"></a><div class="props_rev_3"><a id="GUID-44255E9F-8FAE-4FFD-84BA-90A572AFC51B" name="GUID-44255E9F-8FAE-4FFD-84BA-90A572AFC51B"></a><h3 id="JSNUG-GUID-44255E9F-8FAE-4FFD-84BA-90A572AFC51B" class="sect3">将脚本访问限制为指定的Java类</h3>
               <div>
                  <p>的<code class="codeph">jdk.nashorn.api.scripting.ClassFilter</code>接口通过限制从Nashorn脚本引擎运行的脚本对指定Java类的访问来提供对从JavaScript代码对Java类的访问的细粒度控制。
                  </p>
                  <p>嵌入Nashorn的应用程序（尤其是服务器端JavaScript框架）通常必须从不受信任的来源运行脚本，因此必须限制对Java API的访问。这些应用程序可以实现<a href="https://docs.oracle.com/javase/10/docs/api/jdk/nashorn/api/scripting/ClassFilter.html" target="_blank"><span class="apiname">ClassFilter</span></a>接口，以将Java类访问限制为Java类的子集。为此，客户端应用程序必须使用Nashorn API来实例化Nashorn脚本引擎。
                  </p>
                  <div class="infoboxnote" id="GUID-44255E9F-8FAE-4FFD-84BA-90A572AFC51B__GUID-38BC71CE-A2BD-4519-85B1-0721B004B440">
                     <p class="notep1">注意：</p>尽管<span class="apiname">ClassFilter</span>接口可以阻止对Java类的访问，但仅安全地运行不受信任的脚本还不够。<span class="apiname">ClassFilter</span>接口不能替代安全管理器。在评估来自不受信任来源的脚本之前，应用程序仍应与安全管理器一起运行。除了安全管理器提供的功能外，类过滤还可以提供更好的控制。例如，嵌入Nashorn的应用程序可能会阻止安全管理器可能允许的脚本或其他占用大量资源的操作产生线程。
                  </div>
               </div><a id="JSNUG126"></a><div class="props_rev_3"><a id="GUID-8C6BE273-E3D3-475F-B56B-14458DE9F33F" name="GUID-8C6BE273-E3D3-475F-B56B-14458DE9F33F"></a><h4 id="JSNUG-GUID-8C6BE273-E3D3-475F-B56B-14458DE9F33F" class="sect4">使用类过滤器</h4>
                  <div>
                     <p>要使用类过滤器，请实现<code class="codeph">ClassFilter</code>接口并定义方法<code class="codeph">boolean exposeToScripts(String)</code> 。
                     </p>
                     <div class="section">
                        <p>的<code class="codeph">String</code>参数是Nashorn脚本引擎在运行脚本时遇到的Java类或包的名称。定义方法<code class="codeph">exposeToScripts</code>这样它返回<code class="codeph">false</code>对于您要阻止脚本访问的那些类和包。然后，使用该方法的类过滤器创建Nashron脚本引擎<code class="codeph">NashornScriptEngineFactory.getScriptEngine(ClassFilter)</code>要么<code class="codeph">NashornScriptEngineFactory.getScriptEngine(String[], ClassLoader, ClassFilter)</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSNUG127"></a><div class="props_rev_3"><a id="GUID-FBB32DB3-CF59-4016-B690-9581E1406594" name="GUID-FBB32DB3-CF59-4016-B690-9581E1406594"></a><h4 id="JSNUG-GUID-FBB32DB3-CF59-4016-B690-9581E1406594" class="sect4">限制对Java Reflection API的访问</h4>
                  <div>
                     <p>如果您使用的是安全管理器，则Nashorn允许脚本使用Java Reflection API（例如， <code class="codeph">java.lang.reflect</code>和<code class="codeph">java.lang.invoke</code>软件包） <code class="codeph">nashorn.javaReflection</code>运行时权限。
                     </p>
                     <div class="section">
                        <p>如果您使用的是类过滤器，那么即使没有安全管理器，Nashorn也会阻止对Java Reflection API的访问。请注意，如果Java Reflection API可用，则无需使用类过滤器，因为脚本可以使用<code class="codeph">Class.forName(String)</code>规避类过滤器。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSNUG129"></a><a id="JSNUG128"></a><div class="props_rev_3"><a id="GUID-AEA63402-EE9B-42B4-95E6-BACAC990C04D" name="GUID-AEA63402-EE9B-42B4-95E6-BACAC990C04D"></a><h4 id="JSNUG-GUID-AEA63402-EE9B-42B4-95E6-BACAC990C04D" class="sect4">使用ClassFilter接口的示例</h4>
                  <div>
                     <p>这个例子<code class="codeph">MyClassFilterTest.java</code> ，演示<code class="codeph">ClassFilter</code>接口。它限制了脚本对类<span class="apiname">java.io的访问。文件</span> 。
                     </p>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import javax.script.ScriptEngine;
import jdk.nashorn.api.scripting.ClassFilter;
import jdk.nashorn.api.scripting.NashornScriptEngineFactory;
 
public class MyClassFilterTest {
 
  class MyCF implements ClassFilter {
    @Override
    public boolean exposeToScripts(String s) {
      if (s.compareTo("java.io.File") == 0) return false;
      return true;
    }
  }
 
  public void testClassFilter() {
 
    final String script =
      "print(java.lang.System.getProperty(\"java.home\"));" +
      "print(\"Create file variable\");" +
      "var File = Java.type(\"java.io.File\");";
 
    NashornScriptEngineFactory factory = new NashornScriptEngineFactory();
 
    ScriptEngine engine = factory.getScriptEngine(
      new MyClassFilterTest.MyCF());
    try {
      engine.eval(script);
    } catch (Exception e) {
      System.out.println("Exception caught: " + e.toString());
    }
  }
 
  public static void main(String[] args) {
    MyClassFilterTest myApp = new MyClassFilterTest();
    myApp.testClassFilter();
  }
}
</pre><p>本示例打印以下内容：</p><pre class="oac_no_warn" dir="ltr">C:\Java\jre8
Create file variable
Exception caught: java.lang.RuntimeException: java.lang.ClassNotFoundException:
java.io.File
</pre><p>的<code class="codeph">MyClassFilterTest.java</code>该示例执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>实现<code class="codeph">ClassFilter</code>与内在阶级<code class="codeph">MyCF</code>通过定义方法<code class="codeph">exposeToScripts</code> 。在此示例中，方法<code class="codeph">exposeToScripts</code>如果其返回false <code class="codeph">String</code>论据是<code class="codeph">java.io.File</code> ;否则返回<code class="codeph">true</code> 。</span></li>
                        <li class="stepexpand"><span>创建一个Nashorn脚本引擎， <code class="codeph">engine</code> ，方法<code class="codeph">NashornScriptEngineFactory.getScriptEngine(ClassFilter)</code> 。该示例调用<code class="codeph">getScriptEgnine</code>与一个实例<code class="codeph">MyCF</code> 。</span></li>
                        <li class="stepexpand"><span>使用Nashorn脚本引擎运行以下脚本<code class="codeph">engine</code> ：</span><div><pre class="oac_no_warn" dir="ltr">print(java.lang.System.getProperty(\"java.home\"));
print(\"Create file variable\");
var File = Java.type(\"java.io.File\");
</pre><p>中的类过滤器<code class="codeph">engine</code>检查脚本中的每个Java包和类。当班级过滤器遇到班级时<code class="codeph">java.io.File</code> ，类过滤器返回<code class="codeph">false</code>和<code class="codeph">Java.type</code>函数抛出一个<code class="codeph">ClassNotFoundException</code> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>