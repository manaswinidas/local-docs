<html lang="en-us" dir="ltr" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section describes the extensions of the Nashorn engine that enable you to use UNIX shell scripting features for JavaScript scripts.">
      <meta name="description" content="This section describes the extensions of the Nashorn engine that enable you to use UNIX shell scripting features for JavaScript scripts.">
      <title>Nashorn and Shell Scripting</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Nashorn User's Guide">
      <meta property="og:description" content="This section describes the extensions of the Nashorn engine that enable you to use UNIX shell scripting features for JavaScript scripts.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Nashorn User's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="nashorn-users-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T19:14:09-07:00">
      <meta name="dcterms.title" content="Nashorn User's Guide">
      <meta name="dcterms.dateCopyrighted" content="2014, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94836-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="nashorn-and-javafx.html" title="Previous" type="text/html">
      <link rel="next" href="javafx-script-application-examples.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="NASHORN">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="nashorn-and-javafx.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="javafx-script-application-examples.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Nashorn用户指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Nashorn和Shell脚本</li>
            </ol>
            <a id="GUID-C6DCDAEC-67AA-49F3-9143-9181C681E2E6" name="GUID-C6DCDAEC-67AA-49F3-9143-9181C681E2E6"></a><a id="JSNUG155"></a><a id="JSNUG154"></a>
            
            <h2 id="JSNUG-GUID-C6DCDAEC-67AA-49F3-9143-9181C681E2E6" class="sect2"><span class="enumeration_chapter">4</span> Nashorn和Shell脚本</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>本节介绍Nashorn引擎的扩展，使您可以将UNIX Shell脚本功能用于JavaScript脚本。</span></div>
               <div class="infoboxnote" id="GUID-C6DCDAEC-67AA-49F3-9143-9181C681E2E6__THENASHORNENGINETHEJJSTOOLANDTHEMOD-A65A778C">
                  <p class="notep1">注意：</p>Nashorn引擎<code class="codeph">jjs</code> JDK 11中不推荐使用<span class="apiname">jdk.scripting.nashorn</span>和<span class="apiname">jdk.scripting.nashorn.shell</span>模块，以准备在将来的版本中删除。
               </div>
               <p>您可以使用以下命令在Nashorn中启用Shell脚本扩展<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/nashorn&id=JSWOR-GUID-0F3625BB-9E0E-46C3-8FF1-CEFDD91EDF85" target="_blank"><code>jjs</code></a>用命令<code class="codeph">-scripting</code>选项。例如，以下命令在启用外壳脚本扩展的交互模式下调用Nashorn：</p><pre class="oac_no_warn" dir="ltr">jjs -scripting
</pre><p>除了标准的JavaScript注释（ <code class="codeph">//</code>和<code class="codeph">/*</code><code class="codeph">*/</code> ），Nashorn支持使用数字符号（ <code class="codeph">#</code> ）。如果数字符号是脚本中的第一个字符，则即使您使用<code class="codeph">jjs</code>没有的工具<code class="codeph">-scripting</code>选项。在指定shebang（ <code class="codeph">#!</code> ）脚本的开头，以将其作为shell可执行文件运行。见社<a href="nashorn-and-shell-scripting.html#GUID-BB003552-BF07-4029-9E68-745A8A235827" title="您可以使用shebang（＃！）在脚本文件的开头，以使脚本文件可以作为Shell可执行文件运行。如果在shebang中指定jjs工具的路径，则在执行脚本时，shell会运行jjs工具，并将脚本文件传递给它。">邦</a> 。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-C6DCDAEC-67AA-49F3-9143-9181C681E2E6__GUID-3F440F12-5F8A-400A-A2D0-27B570495D13">话题</p>
                  <ul style="list-style-type:disc">
                     <li><a href="nashorn-and-shell-scripting.html#GUID-BB003552-BF07-4029-9E68-745A8A235827" title="您可以使用shebang（＃！）在脚本文件的开头，以使脚本文件可以作为Shell可执行文件运行。如果在shebang中指定jjs工具的路径，则在执行脚本时，shell会运行jjs工具，并将脚本文件传递给它。">舍邦</a></li>
                     <li><a href="nashorn-and-shell-scripting.html#GUID-D51BDF86-4221-4199-98BC-CDA0BC237B85" title="字符串插值用于UNIX Shell中，以构造包含变量或表达式值的字符串。启用外壳脚本功能后，Nashorn使您能够以相同的方式将变量和表达式嵌入到字符串文字中。">字符串插值</a></li>
                     <li><a href="nashorn-and-shell-scripting.html#GUID-C6FDE05C-EBD4-47AE-9C67-0DA76C9DE771" title="here文档（heredoc）在UNIX shell中指定了保留换行符和缩进的字符串。启用外壳脚本功能后，您可以使用Nashorn来评估带有heredocs的脚本。">此处文件</a></li>
                     <li><a href="nashorn-and-shell-scripting.html#GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1" title="启用外壳脚本功能后，Nashorn定义了几个全局对象。">全局对象</a></li>
                     <li><a href="nashorn-and-shell-scripting.html#GUID-9D5E4301-C777-465D-887E-654E6D7A42FA" title="Nashorn定义了几个内置函数：echo，readLine和readFully函数仅在-scripting模式下定义。其他扩展（例如quit，exit，load，loadWithNewGlobal，Object.bindProperties）始终可用。">附加的Nashorn内置功能</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JSNUG157"></a><a id="JSNUG156"></a><div class="props_rev_3"><a id="GUID-BB003552-BF07-4029-9E68-745A8A235827" name="GUID-BB003552-BF07-4029-9E68-745A8A235827"></a><h3 id="JSNUG-GUID-BB003552-BF07-4029-9E68-745A8A235827" class="sect3">舍邦</h3>
               <div>
                  <p>您可以使用shebang（ <code class="codeph">#!</code> ）在脚本文件的开头，以使脚本文件可以作为Shell可执行文件运行。如果指定路径<code class="codeph">jjs</code>工具，然后在执行脚本时，shell运行<code class="codeph">jjs</code>工具，然后将脚本文件传递给它。
                  </p>
                  <p>的<code class="codeph">jjs</code>工具位于<code class="codeph">JAVA_HOME/bin</code>目录，在哪里<code class="codeph">JAVA_HOME</code>是JDK（或JRE）的安装目录。当您安装JDK时， <code class="codeph">JAVA_HOME</code>环境变量通常是自动设置的。如果不是自动设置的，或者您安装了多个版本的JDK，请设置<code class="codeph">JAVA_HOME</code>手动将环境变量更改为JDK安装目录的正确路径。
                  </p>
                  <p>您可以指定到的直接路径<code class="codeph">jjs</code>工具中的工具，但这是在该工具中创建符号链接的好习惯<code class="codeph">/usr/bin</code>目录如下：</p><pre class="pre codeblock"><code>&gt;&gt; <span class="bold">cd /usr/bin</span>
&gt;&gt; <span class="bold">ln -s $JAVA_HOME/bin/jjs jjs</span>
&gt;&gt; 
</code></pre><div class="infoboxnote" id="GUID-BB003552-BF07-4029-9E68-745A8A235827__GUID-DFB813BA-510C-4112-8285-C9A80E52B888">
                     <p class="notep1">注意：</p>
                     <p>您可能需要运行<code class="codeph">ln</code>具有root特权的命令使用<code class="codeph">sudo</code> 。
                     </p>
                  </div>
                  <p>设置符号链接后，您可以创建可以作为可执行文件运行的Nashorn脚本。同样，可以将命令行选项直接添加到shebang语句中。下面的例子， <code>scriptArgs.js</code> ，显示一个可执行脚本，该脚本打印Nashorn引擎的版本，然后打印传递给该脚本的参数。
                  </p><pre class="pre codeblock"><code>#!/usr/bin/jjs -fv
print("Arguments: " + arguments);
</code></pre><p>如果您运行<code class="codeph">scriptArgs.js</code>文件作为Shell可执行文件，由Nashorn引擎解释如下：</p><pre class="pre codeblock"><code>&gt;&gt; <span class="bold">./scriptArgs.js -- arg1 arg2 arg3</span>
nashorn full version 1.8.0
Arguments: arg1,arg2,arg3
&gt;&gt;
</code></pre><p>或者，如果通向<code class="codeph">jjs</code>工具在<code class="codeph">PATH</code>环境变量，您可以将shebang指向<code class="codeph">jjs</code>如下：</p><pre class="pre codeblock"><code>#!/usr/bin/env jjs</code></pre></div>
            </div><a id="JSNUG158"></a><div class="props_rev_3"><a id="GUID-D51BDF86-4221-4199-98BC-CDA0BC237B85" name="GUID-D51BDF86-4221-4199-98BC-CDA0BC237B85"></a><h3 id="JSNUG-GUID-D51BDF86-4221-4199-98BC-CDA0BC237B85" class="sect3">字符串插值</h3>
               <div>
                  <p>字符串插值用于UNIX Shell中，以构造包含变量或表达式值的字符串。启用外壳脚本功能后，Nashorn使您能够以相同的方式将变量和表达式嵌入到字符串文字中。</p>
                  <p>例如，您可以分配<code class="codeph">Date()</code>的构造函数<code class="codeph">date</code>变量，然后使用美元符号将该变量传递给字符串（ <code class="codeph">$</code> ）和花括号（ <code class="codeph">{}</code> ） 如下：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var date = Date()</span>
jjs&gt; <span class="bold">"Date and time: ${date}"</span>
Date and time: Mon Aug 19 2013 19:43:08 GMT+0400 (MSK)
</code></pre><p>上例显示了当<code class="codeph">date</code>为变量分配了由返回的值<code class="codeph">Date()</code>构造函数。如果要在计算表达式时显示当前日期和时间，则可以传递<code class="codeph">Date()</code>构造函数直接如下：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">"Current date and time: ${Date()}"</span>
Current date and time: Mon Aug 19 2013 19:49:53 GMT+0400 (MSK)
</code></pre><p>字符串插值仅适用于双引号内的字符串。单引号内的字符串不会插值：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">'The variable is ${date}'</span>
The variable is ${date}
</code></pre></div>
            </div><a id="JSNUG160"></a><a id="JSNUG159"></a><div class="props_rev_3"><a id="GUID-C6FDE05C-EBD4-47AE-9C67-0DA76C9DE771" name="GUID-C6FDE05C-EBD4-47AE-9C67-0DA76C9DE771"></a><h3 id="JSNUG-GUID-C6FDE05C-EBD4-47AE-9C67-0DA76C9DE771" class="sect3">此处文件</h3>
               <div>
                  <p>here文档（ <span class="italic">heredoc</span> ）在UNIX shell中指定了保留换行符和缩进的字符串。启用外壳脚本功能后，您可以使用Nashorn来评估带有heredocs的脚本。
                  </p>
                  <p>下面的例子， <code class="codeph">scriptHereArgs.js</code> ，显示了一个可执行脚本，该脚本在第一行上打印第一个传入的参数，然后在第二行上缩进第二个参数，在第四行（一个空白行之后）打印第三个参数。
                  </p><pre class="pre codeblock"><code>#!/usr/bin/jjs
print(&lt;&lt;EOD);
${arguments[0]} is normal
    ${arguments[1]} is indented

${arguments[2]} is separated by a blank line
EOD
</code></pre><p>如果您运行<code class="codeph">scriptHereArgs.js</code>文件作为Shell可执行文件，由Nashorn引擎解释如下：</p><pre class="oac_no_warn" dir="ltr">&gt;&gt; <span class="bold">./scriptHereArgs.js -- Line1 Line2 Line3</span>
Line1 is normal
    Line2 is indented

Line3 is separated by a blank line
</pre></div>
            </div><a id="JSNUG161"></a><div class="props_rev_3"><a id="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1" name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1"></a><h3 id="JSNUG-GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1" class="sect3">全局对象</h3>
               <div>
                  <p>启用外壳脚本功能后，Nashorn定义了几个全局对象。</p>
                  <dl>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-FA766FF0-66F4-4C54-9129-D961EB6CA24D">
                           <!-- --></a><code class="codeph">$ARG</code></dt>
                     <dd>
                        <p>此全局对象可用于访问传递给脚本的参数，类似于<code class="codeph">arguments</code>使用对象，例如：</p><pre class="pre codeblock"><code>&gt;&gt; <span class="bold">jjs -scripting -- arg1 arg2 arg3</span>
jjs&gt; <span class="bold">$ARG</span>
arg1,arg2,arg3
jjs&gt; <span class="bold">$ARG[1]</span>
arg2
</code></pre></dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-92ECF48E-2C2A-4CDB-8D5B-9C567F626DC8">
                           <!-- --></a><code class="codeph">$ENV</code></dt>
                     <dd>
                        <p>此全局对象映射所有当前环境变量，例如：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">$ENV.USER</span>
johndoe
jjs&gt; <span class="bold">$ENV.PWD</span>
/foo/bar
</code></pre></dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-BA34D3A5-2721-4540-8BE4-495D0DE3250C">
                           <!-- --></a><code class="codeph">$EXEC()</code></dt>
                     <dd>
                        <p>此全局函数启动进程来运行命令，例如：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">$EXEC("ls -l")</span>
total 0
drwxr-xr-x+ 1 johndoe staff 4096 Aug 18 11:03 dir
-rwxrw-r--  1 johndoe staff  168 Aug 19 17:44 file.txt

jjs&gt; 
</code></pre><p>的<code class="codeph">$EXEC()</code>函数还可以采用第二个参数，该参数是用作标准输入的字符串（ <code class="codeph">stdin</code> ）的过程：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">$EXEC("cat", "Send this to stdout")</span>
Send this to stdout
jjs&gt; 
</code></pre><div class="infoboxnote" id="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-0F537DCD-D571-4C4C-9BF0-A41F2C7CF248">
                           <p class="notep1">注意：</p>
                           <p>如果该命令不需要任何输入，则可以使用反引号字符串表示法启动进程。例如，代替<code class="codeph">$EXEC("ls -l")</code> ， 您可以使用<code class="codeph">`ls -l`</code> 。
                           </p>
                        </div>
                     </dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-19AA08A1-88DC-4693-A39C-77F778D746D2">
                           <!-- --></a><code class="codeph">$OPTIONS</code></dt>
                     <dd>
                        <p>此对象公开传递给nashorn“命令行”的命令行选项。例如：</p><pre class="pre codeblock"><code>jjs&gt; print("-scripting=" + $OPTIONS_scripting);
jjs&gt; print("--compile-only=" + $OPTIONS_compile_only);
jjs&gt; print("-timezone="+ $OPTIONS_timezone.ID);
</code></pre></dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-CF2A4C53-FCF0-4005-A6E4-3611EA5FD380">
                           <!-- --></a><code class="codeph">$OUT</code></dt>
                     <dd>
                        <p>该全局对象用于存储最新的标准输出（ <code class="codeph">stdout</code> ）的过程。例如，结果<code class="codeph">$EXEC()</code>保存到<code class="codeph">$OUT</code> 。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-E6D92614-7B58-4DF0-A3BF-A8D5B3DAC1D0">
                           <!-- --></a><code class="codeph">$ERR</code></dt>
                     <dd>
                        <p>该全局对象用于存储最新的标准错误（ <code class="codeph">stderr</code> ）的过程。
                        </p>
                     </dd>
                     <dt class="dlterm"><a name="GUID-FFA9ED03-1481-45AF-AA64-341EB3C89BD1__GUID-CAD2728C-DA2F-4CBB-9E26-C8009D3CB665">
                           <!-- --></a><code class="codeph">$EXIT</code></dt>
                     <dd>
                        <p>该全局对象用于存储流程的退出代码。如果退出代码不为零，则该过程失败。</p>
                     </dd>
                  </dl>
               </div>
            </div><a id="JSNUG162"></a><div class="props_rev_3"><a id="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA" name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA"></a><h3 id="JSNUG-GUID-9D5E4301-C777-465D-887E-654E6D7A42FA" class="sect3">附加的Nashorn内置功能</h3>
               <div>
                  <p>Nashorn定义了几个内置函数： <code class="codeph">echo</code> ， <code class="codeph">readLine</code>和<code class="codeph">readFully</code>功能仅针对<code class="codeph">-scripting</code>模式。其他扩展名如<code class="codeph">quit</code> ， <code class="codeph">exit</code> ， <code class="codeph">load</code> ， <code class="codeph">loadWithNewGlobal</code> ， <code class="codeph">Object.bindProperties</code>随时可用。
                  </p>
                  <div class="section">
                     <dl>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-A5F8D379-29BA-493D-9054-4557060A7443"><!-- --></a> <span class="apiname">quit（）</span></dt>
                        <dt class="dlterm"><span class="apiname">出口（）</span></dt>
                        <dd>
                           <p>这些功能是同义词，导致当前脚本进程退出系统。您可以传递一个整数值作为表示要返回到系统的退出代码的参数。默认情况下，不带参数的退出代码设置为0，表示该进程正确终止。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-55DF408F-D627-4CB9-A410-5632EF5395F5"><!-- --></a> <span class="apiname">print（）</span></dt>
                        <dt class="dlterm"><span class="apiname">回声（）</span></dt>
                        <dd>
                           <p>这些函数是同义词，导致作为参数传入的值转换为字符串，并打印到<code class="codeph">stdout</code>用空格隔开，然后换行。该实现涉及到<code class="codeph">java.lang.System.out.print(string)</code>其次是<code class="codeph">java.lang.System.out.println()</code> 。
                           </p><pre class="pre codeblock"><code>&gt;&gt; <span class="bold">jjs -scripting -- arg1</span>
jjs&gt; <span class="bold">var a = "Hello"</span>
jjs&gt; <span class="bold">print(123, $ARG[0], a, "World")</span>
123 arg1 Hello World
jjs&gt; 
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-7050BBD1-79C4-46BD-8189-7AFDAB9F0CD0"><!-- --></a> <span class="apiname">readLine（）</span></dt>
                        <dd>
                           <p>此功能从中读取一行输入<code class="codeph">stdin</code>并发送给<code class="codeph">stdout</code> ，也可以将结果分配给变量。您还可以将字符串传递给<code class="codeph">readLine()</code>函数以获取提示行，如以下示例所示：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var name = readLine("What is your name? ")</span>
What is your name? <span class="bold">Bob</span>
jjs&gt; <span class="bold">print("Hello, ${name}!")</span>
Hello, Bob!
jjs&gt; 
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-FEDD8747-1ACB-4839-868E-66F1D07D0DE0"><!-- --></a> <span class="apiname">readFully（）</span></dt>
                        <dd>
                           <p>该函数读取作为字符串参数传入的文件的全部内容，并将其发送到<code class="codeph">stdout</code> ，也可以将结果分配给变量。
                           </p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">readFully("text.txt")</span>
This is the contents of the text.txt file located in the current working directory.

jjs&gt; 
</code></pre><p><span class="apiname">readFully（）</span>函数使用<a href="https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html#readAllBytes-java.nio.file.Path-" target="_blank"><span class="apiname">byte [] Files.readAllBytes（Path）</span></a>方法读取数据，然后对返回的字节数组执行字节顺序标记（BOM）检测，以确定读取的数据是否经过Unicode编码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-B3EA58AA-38DB-4F12-905B-7B648546B5A0"><!-- --></a> <span class="apiname">load（）</span></dt>
                        <dd>
                           <p>此函数从路径，URL或脚本对象加载并评估脚本。</p><pre class="pre codeblock"><code>jjs&gt; load("/foo/bar/script.js")
jjs&gt; load("http://example.com/script.js")
jjs&gt; load({name:"script.js", script:"var x = 1 + 1; x;"})
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-DB164B7A-9AC2-4660-BB58-A05E858ED80C"><!-- --></a> <span class="apiname">loadWithNewGlobal（）</span></dt>
                        <dd>
                           <p>此功能类似于<code class="codeph">load()</code>函数，但脚本使用新的全局对象进行评估。这是用于创建评估脚本的新上下文的主要方法。附加参数（脚本之后）传递给<code class="codeph">loadWithNewGlobal()</code>存储在<code class="codeph">arguments</code>新上下文的全局变量。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-9D5E4301-C777-465D-887E-654E6D7A42FA__GUID-D506F863-212E-4796-A240-79C112630D78">
                              <!-- --></a><code class="codeph">Object.bindProperties(<span class="variable" translate="no">target</span>, <span class="variable" translate="no">source</span>)</code></dt>
                        <dd>
                           <p>此功能用于绑定<code class="codeph"><span class="variable" translate="no">source</span></code>对象的属性<code class="codeph"><span class="variable" translate="no">target</span></code> 。该功能可以共享全局属性。例如，在文档对象模型（DOM）模拟中，您可以在全局对象和文档之间共享属性。在多线程应用程序中，您可以在线程的全局对象之间共享功能。
                           </p>
                           <p>以下示例说明了如何绑定<code class="codeph">obj</code>对象的属性到全局对象：</p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">var obj = {x:34,y:100}</span>
jjs&gt; <span class="bold">obj.x</span>
34
jjs&gt; <span class="bold">obj.y</span>
100
jjs&gt; <span class="bold">x</span>
&lt;shell&gt;:1 ReferenceError: "x" is not defined
jjs&gt; <span class="bold">Object.bindProperties(this,obj)</span>
[object global]
jjs&gt; <span class="bold">x</span>
34
jjs&gt; <span class="bold">y = Math.PI</span>
3.141592653589793
jjs&gt; <span class="bold">obj.y</span>
3.141592653589793
jjs&gt; 
</code></pre><p>请注意，函数<span class="apiname">Object.bindProperties（target，source）</span>仅绑定<span class="variable" translate="no">target</span>不存在的<span class="variable" translate="no">source</span>属性。在以下示例中，函数<span class="apiname">bindProperties</span>尝试绑定对象的属性。 <code class="codeph">obj</code>对象到全局对象。然而<code class="codeph">x</code>属性已存在于全局对象中。因此，函数<span class="apiname">bindProperties</span>不绑定<code class="codeph">obj.x</code>走向全球<code class="codeph">x</code> 。因此，更改<code class="codeph">obj.x</code>不会改变全球价值<code class="codeph">x</code> 。
                           </p><pre class="pre codeblock"><code>jjs&gt; <span class="bold">x = 2</span>
2
jjs&gt; <span class="bold">var obj = {x:3}</span>
jjs&gt; <span class="bold">Object.bindProperties(this,obj)</span>
[object global]
jjs&gt; <span class="bold">x</span>
2
jjs&gt; <span class="bold">x = 4</span>
4
jjs&gt; <span class="bold">obj.x</span>
3
jjs&gt; <span class="bold">x</span>
4</code></pre></dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>