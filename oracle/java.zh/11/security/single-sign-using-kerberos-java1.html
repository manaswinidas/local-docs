<html lang="en-us" dir="ltr" xml:lang="en-us"><head></head><body dir="ltr">﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="">
      <meta name="description" content="">
      <title>Java中使用Kerberos的单点登录</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="accessing-native-gss-api.html" title="Previous" type="text/html">
      <link rel="next" href="advanced-security-programming-java-se-authentication-secure-communication-and-single-sign1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="accessing-native-gss-api.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="advanced-security-programming-java-se-authentication-secure-communication-and-single-sign1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="java-generic-security-services-java-gss-api1.html" property="item" typeof="WebPage"><span property="name">Java通用安全服务（Java GSS-API）</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java中使用Kerberos的单点登录</li>
            </ol>
            <a id="GUID-D4230975-A28B-4532-B1DD-3C7219A4867F" name="GUID-D4230975-A28B-4532-B1DD-3C7219A4867F"></a>
            
            <h2 id="JSSEC-GUID-D4230975-A28B-4532-B1DD-3C7219A4867F" class="sect2">Java中使用Kerberos的单点登录</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='single-sign-using-kerberos-java1'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p></p>
            </div>
            <div class="sect2"><a id="GUID-E8171823-258A-45DF-A420-661EAC84CCDD" name="GUID-E8171823-258A-45DF-A420-661EAC84CCDD"></a><h3 id="JSSEC-GUID-E8171823-258A-45DF-A420-661EAC84CCDD" class="sect3">抽象</h3>
               <div>
                  <p>Java SE安全性体系结构的一项重大增强是使用Kerberos版本5实现单点登录的能力。单一登录解决方案使用户只需进行一次身份验证即可访问多个系统中任何一个系统上的信息。这是通过使用JAAS进行身份验证和授权以及使用Java GSS-API来建立与对等应用程序进行通信的安全上下文来完成的。尽管将来可能会添加其他安全机制，但我们将重点放在Kerberos V5作为单点登录的基础安全机制上。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-7147244C-E7D5-4D70-92C6-069EB7C651A3" name="GUID-7147244C-E7D5-4D70-92C6-069EB7C651A3"></a><h3 id="JSSEC-GUID-7147244C-E7D5-4D70-92C6-069EB7C651A3" class="sect3">介绍</h3>
               <div>
                  <p>随着分布式系统使用的增加，用户需要访问通常是远程的资源。传统上，用户必须登录多个系统，每个系统可能涉及不同的用户名和身份验证技术。相反，通过单点登录，用户只需要进行一次身份验证，并且身份验证的身份将安全地跨网络携带，以代表用户访问资源。</p>
                  <p>在本文中，我们讨论了如何使用基于Kerberos V5协议的单点登录。我们使用Java身份验证和授权服务（JAAS）对Kerberos验证主体，并获得证明其身份的凭证。我们展示了如何实现Oracle的Kerberos登录模块的实现，以从包含本机Kerberos支持的平台上的现有缓存中读取凭据。然后，我们使用Java通用安全服务API（Java GSS-API），使用先前获得的Kerberos凭据向远程对等方进行身份验证。我们还将展示如何在多层环境中委派Kerberos凭据进行单点登录。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-6F8CAB6F-7DA8-4DED-8369-92BBB95C8A9E" name="GUID-6F8CAB6F-7DA8-4DED-8369-92BBB95C8A9E"></a><h3 id="JSSEC-GUID-6F8CAB6F-7DA8-4DED-8369-92BBB95C8A9E" class="sect3">Kerberos V5</h3>
               <div>
                  <p>Kerberos V5是一种受信任的第三方网络身份验证协议，旨在使用秘密密钥加密技术提供强身份验证。使用Kerberos V5时，除非在Kerberos V5管理期间，否则用户密码永远不会通过网络发送，甚至不会以加密形式发送。Kerberos是MIT雅典娜计划的一部分，于1980年代中期开发。Kerberos V5协议的完整描述超出了本文的范围。有关Kerberos V5协议的更多信息，请参考<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-01">[1]</a>和<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-02">[2]</a> 。
                  </p>
                  <p>Kerberos V5是一种成熟的协议，已被广泛部署。MIT提供了免费的C语言参考实现。由于这些原因，我们选择了Kerberos V5作为Java SE中单点登录的基础技术。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-38C14739-0A86-46EA-B0E9-44A7CD6AA9E4" name="GUID-38C14739-0A86-46EA-B0E9-44A7CD6AA9E4"></a><h3 id="JSSEC-GUID-38C14739-0A86-46EA-B0E9-44A7CD6AA9E4" class="sect3">Java身份验证和授权服务（JAAS）</h3>
               <div>
                  <p>Java SE安全性体系结构用于仅通过代码的来源以及与代码签名者匹配的公钥证书来确定特权。然而，在多用户环境中，期望基于运行代码的用户的认证身份来进一步指定特权。</p>
                  <p>JAAS提供了这样的功能。JAAS是一个可插拔的框架和编程接口，专门用于基于身份验证的身份验证和访问控制。</p>
               </div>
               <div class="sect3"><a id="GUID-B4D7E22E-459E-4909-ABF7-647733847E75" name="GUID-B4D7E22E-459E-4909-ABF7-647733847E75"></a><h4 id="JSSEC-GUID-B4D7E22E-459E-4909-ABF7-647733847E75" class="sect4">可插拔和可堆叠框架</h4>
                  <div>
                     <p>JAAS认证框架基于可插拔认证模块（PAM）；参见<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-03">[3]</a>和<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-04">[4]</a> 。JAAS身份验证以可插入方式执行，允许系统管理员添加适当的身份验证模块。这允许Java应用程序保持独立于底层身份验证技术，并且可以无缝配置新的或更新的身份验证技术，而无需修改应用程序本身。
                     </p>
                     <p>JAAS认证框架还支持认证模块的堆叠。可以指定多个模块，并由JAAS框架按指定的顺序调用它们。整体身份验证的成功取决于各个身份验证模块的结果。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2FFC7B8E-C8FC-492B-8D57-0BC14EA4D033" name="GUID-2FFC7B8E-C8FC-492B-8D57-0BC14EA4D033"></a><h4 id="JSSEC-GUID-2FFC7B8E-C8FC-492B-8D57-0BC14EA4D033" class="sect4">认证与授权</h4>
                  <div>
                     <p>JAAS框架可以分为两个组件：身份验证组件和授权组件。</p>
                     <p>JAAS身份验证组件提供了可靠和安全地确定当前正在执行Java代码的人员的能力，而不管该代码是作为应用程序，小应用程序，bean还是servlet运行的。</p>
                     <p>JAAS授权组件通过提供一种方法来限制执行中的Java代码执行敏感任务，从而对其进行补充，该方法取决于其代码源以及取决于谁在执行代码。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AA7F81DA-583A-4275-8D2E-0C1FD2919ED2" name="GUID-AA7F81DA-583A-4275-8D2E-0C1FD2919ED2"></a><h4 id="JSSEC-GUID-AA7F81DA-583A-4275-8D2E-0C1FD2919ED2" class="sect4">学科</h4>
                  <div>
                     <p>JAAS使用术语“主题”来指代任何访问资源请求的实体。主题可以是用户或服务。由于实体可能具有许多名称或主体，因此JAAS将Subject作为额外的抽象层，用于处理每个实体的多个名称。因此，主题由一组主体组成。主体名称没有限制。</p>
                     <p>主题仅填充有经过验证的主体。身份验证通常涉及用户提供身份证明，例如密码。</p>
                     <p>主体还可以具有与安全性相关的属性，这些属性称为凭据。凭证可以是公共的或私人的。诸如私人加密密钥之类的敏感凭证存储在主题的私人凭证集中。</p>
                     <p><span class="apiname">Subject</span>类具有检索与之关联的主体，公共凭证和私人凭证的方法。
                     </p>
                     <p>请注意，对这些类进行操作可能需要不同的权限。例如，可能需要<span class="apiname">AuthPermission（“ modifyPrincipals”）</span>来修改Subject的主体集。需要类似的权限才能修改公共凭据，私有凭据以及获取当前主题。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6F5671ED-C6FC-4842-A1FA-DB08E61C369A" name="GUID-6F5671ED-C6FC-4842-A1FA-DB08E61C369A"></a><h4 id="JSSEC-GUID-6F5671ED-C6FC-4842-A1FA-DB08E61C369A" class="sect4">doAs和doAsPrivileged</h4>
                  <div>
                     <p>Java SE通过<span class="apiname">java.lang实施运行时访问控制<span class="apiname">。安全管理器</span> 。尝试进行敏感操作时，请咨询<span class="apiname">SecurityManager</span> 。<span class="apiname">SecurityManager</span>将此职责委托给<span class="apiname">java.security。AccessController</span> 。<span class="apiname">AccessController</span>的获得<span class="apiname">的AccessControlContext</span>和验证的当前图像，它有足够的权限执行请求的操作。
                     </span></p>
                     <p>JAAS提供了两种方法<span class="apiname">doAs</span>和<span class="apiname">doAsPrivileged</span> ，可用于将经过身份验证的Subject与<span class="apiname">AccessControlContext</span>动态关联。
                     </p>
                     <p><span class="apiname">doAs</span>方法将Subject与当前线程的访问控制上下文相关联，并基于正在执行的代码和执行它的Subject进行后续访问控制检查。
                     </p><pre class="pre codeblock"><code>public static Object doAs(final Subject subject,
                          final PrivilegedAction action)

public static Object doAs(final Subject subject,
                          final PrivilegedExceptionAction action)
    throws  PrivilegedActionException;
</code></pre><p>两种形式的<span class="apiname">doAs</span>方法都首先将指定的主题与当前线程的<span class="apiname">AccessControlContext</span>关联，然后执行操作。这样可以达到将动作作为主题运行的效果。第一个方法可以引发运行时异常，但是正常执行会使它从其action参数的<span class="apiname">run（）</span>方法返回一个<span class="apiname">Object</span> 。第二种方法的行为类似，除了它可以从其<span class="apiname">run（）</span>方法中抛出已检查的<span class="apiname">PrivilegedActionException</span>之外。需要<span class="apiname">AuthPermission（“ doAs”）</span>才能调用<span class="apiname">doAs</span>方法。
                     </p>
                     <p>以下方法也将代码作为特定主题执行：</p><pre class="pre codeblock"><code>public static Object doAsPrivileged(final Subject subject,
                                    final PrivilegedAction action,
                                    final AccessControlContext  acc);

public static Object doAsPrivileged(final Subject subject,
                                    final PrivilegedExceptionAction action,
                                    final AccessControlContext acc)
    throws PrivilegedActionException;
</code></pre><p><span class="apiname">doAsPrivileged</span>方法的行为与<span class="apiname">doAs</span>完全相同，不同之处在于它允许调用者指定访问控制上下文。因此，它有效地丢弃了当前的<span class="apiname">AccessControlContext，</span>并且授权决策将基于传入的<span class="apiname">AccessControlContext</span> 。
                     </p>
                     <p>由于<span class="apiname">AccessControlContext</span>是基于每个线程设置的，因此JVM中的不同线程可以采用不同的身份。可以使用以下方法来检索与特定<span class="apiname">AccessControlContext</span>关联的Subject：</p><pre class="pre codeblock"><code>public static Subject getSubject(final AccessControlContext acc);
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-DBF4F859-01ED-4E47-B842-EE128B146E8D" name="GUID-DBF4F859-01ED-4E47-B842-EE128B146E8D"></a><h4 id="JSSEC-GUID-DBF4F859-01ED-4E47-B842-EE128B146E8D" class="sect4">LoginContext</h4>
                  <div>
                     <p><span class="apiname">LoginContext</span>类提供了用于验证主题的基本方法。它还允许应用程序独立于基础身份验证技术。<span class="apiname">LoginContext</span>咨询一种配置，该配置确定为特定应用程序配置的身份验证服务或<span class="apiname">LoginModule</span> 。如果应用程序没有特定的条目，则默认为标识为“其他”的条目。
                     </p>
                     <p>为了支持<span class="apiname">LoginModules</span>的可堆叠性， <span class="apiname">LoginContext</span>分两个阶段执行身份验证。在第一阶段或登录阶段，它将调用每个已配置的LoginModule尝试进行身份验证。如果所有必需的<span class="apiname">LoginModules</span>成功，则<span class="apiname">LoginContext</span>进入第二阶段，在该阶段再次调用每个LoginModule以正式提交身份验证过程。在此阶段，主题中将填充经过身份验证的主体及其凭据。如果任一阶段失败，则<span class="apiname">LoginContext会</span>调用每个已配置的模块以中止整个身份验证尝试。然后，每个<span class="apiname">LoginModule都会</span>清除与身份验证尝试关联的所有相关状态。
                     </p>
                     <p><span class="apiname">LoginContext</span>具有四个可用于实例化它的构造函数。所有这些都需要传递配置条目名称。另外，主题和/或<span class="apiname">CallbackHandler</span>也可以传递给构造函数。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-20572EC0-B790-4C69-B168-6129F9B42C26" name="GUID-20572EC0-B790-4C69-B168-6129F9B42C26"></a><h4 id="JSSEC-GUID-20572EC0-B790-4C69-B168-6129F9B42C26" class="sect4">回呼</h4>
                  <div>
                     <p>JAAS调用的登录模块必须能够从调用方那里获取信息以进行身份验证。例如，Kerberos登录模块可能要求用户输入其Kerberos密码进行身份验证。</p>
                     <p><span class="apiname">LoginContext</span>允许应用程序指定基础登录模块用来与用户交互的回调处理程序。有两个回调处理程序-一个基于命令行，另一个基于GUI。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8AFBA819-AE63-4879-B83F-0E64FB880939" name="GUID-8AFBA819-AE63-4879-B83F-0E64FB880939"></a><h4 id="JSSEC-GUID-8AFBA819-AE63-4879-B83F-0E64FB880939" class="sect4">LoginModules</h4>
                  <div>
                     <p>Oracle提供了<span class="apiname">UnixLoginModule</span> ， <span class="apiname">NTLoginModule</span> ， <span class="apiname">JNDILoginModule</span> ， <span class="apiname">KeyStoreLoginModule</span>和<span class="apiname">Krb5LoginModule的实现</span> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E" name="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E"></a><h4 id="JSSEC-GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E" class="sect4">Kerberos登录模块</h4>
                  <div>
                     <p><span class="apiname">com.sun.security.auth.module类<span class="apiname">。Krb5LoginModule</span>是Oracle针对Kerberos版本5协议的登录模块的实现。身份验证成功后，票证授予票证（TGT）将存储在主题的专用凭据集中，而Kerberos主体将存储在主题的主体集中。
                     </span></p>
                     <p>根据某些可配置选项， <span class="apiname">Krb5LoginModule</span>也可以使用现有的凭据缓存（例如操作系统中的本机缓存）来获取TGT和/或使用<code>keytab</code>包含用于隐式验证主体的密钥的文件。Solaris和Windows均包含凭据缓存， <span class="apiname">Krb5LoginModule</span>可将其用于获取TGT。 Solaris还包含系统范围的<code>keytab</code> <span class="apiname">Krb5LoginModule</span>可以用来获取密钥的文件。在所有平台上， <span class="apiname">Krb5LoginModule</span>支持用于设置票证缓存或<code>keytab</code>选择的文件。当安装了第三方Kerberos支持并且需要Java集成时，这很有用。请查阅<span class="apiname">Krb5LoginModule</span>的文档以了解这些选项。在没有本机缓存或<code>keytab</code> ，系统将提示用户输入从密钥分发中心（KDC）获得的密码和TGT。
                     </p>
                     <p>以下是客户端应用程序的样本JAAS登录配置条目。在此示例中， <span class="apiname">Krb5LoginModule</span>将使用本机票<span class="apiname">证</span>缓存来获取其中可用的TGT。身份验证的身份将是TGT所属的Kerberos主体的身份。
                     </p><pre class="pre codeblock" id="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLECLIENTCOM.SUN.SECURITY.AUTH.M-37F332E5"><code>// Sample client configuration entry

SampleClient {
    com.sun.security.auth.module.Krb5LoginModule required <span class="bold">useTicketCache=true</span>
};
</code></pre><p>以下是服务器应用程序的示例登录配置条目。使用此配置，密钥表中的密钥用于验证主体<code class="codeph">nfs/bar.example.com</code>并且将从Kerberos KDC获得的TGT和密钥都存储在主题的专用凭据集中。以后可以使用存储的密钥来验证客户端发送的服务票证（请参阅Java GSS-API上的部分。）
                     </p><pre class="pre codeblock" id="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLESERVERCONFIGURATIONENTRYSAMPL-37F37F85"><code>// Sample server configuration entry

SampleServer {
     com.sun.security.auth.module.Krb5LoginModule
         required <span class="bold">useKeyTab=true storeKey=true principal="nfs/bar.example.com"</span>
};
</code></pre><p>在以下客户端代码示例中，配置条目<code class="codeph">SampleClient</code>将由<span class="apiname">LoginContext使用</span> 。<span class="apiname">TextCallbackHandler</span>类将用于提示用户输入Kerberos密码。用户登录后，将使用Kerberos主体名称和TGT填充主题。此后，用户可以使用<span class="apiname">Subject.doA</span>传递从<span class="apiname">LoginContext</span>获得的<span class="apiname">Subject</span>来执行代码。
                     </p><pre class="pre codeblock" id="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLECLIENTCODELOGINCONTEXTLCNULLT-37F389A2"><code>// Sample client code

LoginContext lc = null;

try {
        lc = new LoginContext(<span class="bold">"SampleClient"</span>, new TextCallbackHandler());
        // attempt authentication
        lc.login();
} catch (LoginException le) {
    ...
}

// Now try to execute ClientAction as the authenticated Subject

Subject mySubject = lc.getSubject();
PrivilegedAction action = new <span class="bold">ClientAction</span>();
Subject.doAs(mySubject, action);
</code></pre><p><span class="apiname">ClientAction</span>可以是仅具有特定值的经过身份验证的Kerberos客户端主体允许的操作。
                     </p>
                     <p>下面显示了服务器端示例代码。除了应用程序条目名称和<span class="apiname">PrivilegedAction</span>之外，它与<a href="single-sign-using-kerberos-java1.html#GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLECLIENTCODELOGINCONTEXTLCNULLT-37F389A2">示例客户机代码</a>相似。
                     </p><pre class="pre codeblock" id="GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLESERVERCODELOGINCONTEXTLCNULLT-37F4D999"><code>// Sample server code

LoginContext lc = null;

try {
        lc = new LoginContext(<span class="bold">"SampleServer"</span>, new TextCallbackHandler());
        // attempt authentication
        lc.login();
} catch (LoginException le) {
   ...
}

// Now try to execute ServerAction as the authenticated Subject

Subject mySubject = lc.getSubject();
PrivilegedAction action = new <span class="bold">ServerAction</span>();
Subject.doAs(mySubject, action);
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-A82CE65B-0730-42EC-973B-51D1CDA7D382" name="GUID-A82CE65B-0730-42EC-973B-51D1CDA7D382"></a><h4 id="JSSEC-GUID-A82CE65B-0730-42EC-973B-51D1CDA7D382" class="sect4">Kerberos类别</h4>
                  <div>
                     <p>为了使其他供应商能够提供可以与Java GSS-API一起使用的Kerberos登录模块实现，在<span class="apiname">javax.security.auth.kerberos</span>软件包中引入了三个标准的Kerberos类。这是<span class="apiname">Kerberos</span>的Kerberos主体<span class="apiname">，KerberosKey</span>为长期的Kerberos密钥和<span class="apiname">KerberosTicket</span>的Kerberos票据。Kerberos登录模块的所有实现都必须使用这些类在主体中存储主体，密钥和票证。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BB48DD97-7BC5-487D-AE9C-E469917DFE73" name="GUID-BB48DD97-7BC5-487D-AE9C-E469917DFE73"></a><h4 id="JSSEC-GUID-BB48DD97-7BC5-487D-AE9C-E469917DFE73" class="sect4">授权书</h4>
                  <div>
                     <p>成功验证主题后，可以基于与已验证主题相关联的主体来实施访问控制。基于JAAS委托人的访问控制增强了Java SE的<span class="apiname">CodeSource</span>访问控制。授予Subject的权限在<span class="apiname">Policy</span>中配置， <span class="apiname">Policy</span>是一个抽象类，用于表示系统范围的访问控制策略。Oracle提供了<span class="apiname">Policy</span>类的基于文件的实现。<span class="apiname">Policy</span>类基于提供程序，因此其他人可以提供自己的策略实现。
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-3336BC5D-90CA-4646-B96A-FE79EA2D1AD6" name="GUID-3336BC5D-90CA-4646-B96A-FE79EA2D1AD6"></a><h3 id="JSSEC-GUID-3336BC5D-90CA-4646-B96A-FE79EA2D1AD6" class="sect3">Java通用安全服务应用程序接口（Java GSS-API）</h3>
               <div></div>
               <div class="sect3"><a id="GUID-A92F4222-4C58-49AA-AF94-E7BB12D3C3C5" name="GUID-A92F4222-4C58-49AA-AF94-E7BB12D3C3C5"></a><h4 id="JSSEC-GUID-A92F4222-4C58-49AA-AF94-E7BB12D3C3C5" class="sect4">通用安全服务API（GSS-API）</h4>
                  <div>
                     <p>企业应用程序通常具有不同的安全性要求，并部署各种基础技术来实现此目的。在这种情况下，我们如何开发客户端服务器应用程序，以便它可以轻松地从一种技术迁移到另一种技术？GSS-API是在IETF的“通用身份验证技术”工作组中设计的，旨在通过为对等身份验证和安全通信提供统一的应用程序编程接口来解决此问题，从而使调用者与底层技术的细节隔离。</p>
                     <p>在RFC 2743 <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-06">[6]</a>中以语言独立的形式描述的API包含以下安全服务：身份验证，消息机密性和完整性，受保护消息的排序，重播检测和凭证委派。除了基本的单向身份验证之外，所使用的基础安全技术或“安全机制”还可以选择支持这些功能中的一个或多个。<a id="fn_1" name="fn_1" href="#fn_1" the="" gss-api="" kerberos="" mechanism="" performs="" client="" authentication="" at="" minimum=")" ="" onclick="footdisplay(1, "><sup>脚1</sup></a></p>
                     <p>IETF已定义了两种主要的标准安全机制：Kerberos V5 <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-06">[6]</a>和简单公钥机制（SPKM） <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-08">[8]</a> 。
                     </p>
                     <p>API的设计使实现可以同时支持多种机制，从而使应用程序能够在运行时选择一种机制。但是，彼此通信的客户端应用程序和服务器应用程序必须使用相同的安全性机制。<a href="single-sign-using-kerberos-java1.html#GUID-A92F4222-4C58-49AA-AF94-E7BB12D3C3C5__AMULTI-MECHANISMGSS-APIIMPLEMENTATI-37F451B6">图7-1</a>对此进行了说明。它显示了使用GSS-API进行安全通信的客户端-服务器应用程序。GSS框架使该应用程序能够支持多种安全机制（在本示例中为Kerberos V5和SPKM）。一旦GSS-API协商了客户端或服务器应用程序的安全机制（在本示例中为Kerberos V5），另一个必须使用相同的机制。
                     </p>
                     <div class="figure" id="GUID-A92F4222-4C58-49AA-AF94-E7BB12D3C3C5__AMULTI-MECHANISMGSS-APIIMPLEMENTATI-37F451B6">
                        <p class="titleinfigure">图7-1多机制GSS-API实现</p><img src="img/jgss_pb_001b.png" alt="周围的文字描述了此图。" title="周围的文字描述了此图。"></div>
                     <!-- class="figure" -->
                     <p>通过在IANA中注册的唯一对象标识符（OID）来识别机制。例如，Kerberos V5机制由OID标识<code class="codeph">{iso(1) member-body(2) United States(840) mit(113554) infosys(1) gssapi(2) krb5(2)}</code></p>
                     <p>该API的另一个重要功能是它是基于令牌的。即，对API的调用会生成不透明的八位位组，应用程序必须将该八位位组传输到其对等端。这使API能够独立于传输。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D73F1DE2-D003-429F-B918-2CDC6897E9C7" name="GUID-D73F1DE2-D003-429F-B918-2CDC6897E9C7"></a><h4 id="JSSEC-GUID-D73F1DE2-D003-429F-B918-2CDC6897E9C7" class="sect4">Java GSS-API</h4>
                  <div>
                     <p>通用安全服务的Java API也在IETF上定义，并记录在RFC 2853 <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-10">[10]中</a> 。Oracle正在Java社区流程（JCP） <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-11">[11]</a>下追求该API的标准化，并计划与Merlin一起提供参考实现。因为JCP只是认可此外部定义的API，所以IETF分配了程序包名称空间<code class="codeph">org.ietf.jgss</code>将保留在Merlin。
                     </p>
                     <p>Oracle的Java GSS-API实现最初将仅支持Kerberos V5机制。Kerberos V5机制支持对于Java SE中的所有Java GSS-API实现都是必需的，尽管它们可以自由支持其他机制。在将来的版本中，将添加服务提供商接口（SPI），以便可以静态甚至在运行时配置新机制。即使现在，Merlin中的参考实现也将是模块化的，并支持私有提供者SPI，将在标准化后将其转换为公共。</p>
                     <p>Java GSS-API框架本身非常薄，并且所有与安全性相关的功能都委托给从底层机制获得的组件。<span class="apiname">GSSManager</span>类知道已安装的所有机制提供程序，并负责调用它们以获取这些组件。
                     </p>
                     <p>Java SE附带的默认<span class="apiname">GSSManager</span>的实现如下获得：</p><pre class="pre codeblock"><code>GSSManager manager = GSSManager.getInstance();
</code></pre><p><span class="apiname">GSSManager</span>可用于配置新的提供程序并列出已经存在的所有机制。<span class="apiname">GSSManager</span>还充当三个重要接口的工厂类： <span class="apiname">GSSName</span> ， <span class="apiname">GSSCredential</span>和<span class="apiname">GSSContext</span> 。这些接口将在下面通过实例化其实现的方法进行描述。有关完整的API规范，请参阅<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-09">[9]</a>和<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-11">[11]</a> 。
                     </p>
                     <p>对Java GSS-API的大多数调用都会引发<span class="apiname">GSSException</span> ，该<span class="apiname">异常</span>封装了在GSS-API框架以及机制提供程序中都发生的问题。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB5BB523-052A-4ACA-B0D5-BF5A3C220093" name="GUID-AB5BB523-052A-4ACA-B0D5-BF5A3C220093"></a><h4 id="JSSEC-GUID-AB5BB523-052A-4ACA-B0D5-BF5A3C220093" class="sect4">GSSName接口</h4>
                  <div>
                     <p>此接口代表用于Java GSS-API的实体。该接口的实现实例化如下：</p><pre class="pre codeblock"><code>GSSName GSSManager.createName(String name, Oid nameType)
    throws GSSException
</code></pre><p>例如：</p><pre class="pre codeblock"><code>GSSName clientName = manager.createName("duke", GSSName.NT_USER_NAME);
</code></pre><p>该调用返回代表用户主体的<span class="apiname">GSSName</span> <code class="codeph">duke</code>在独立于机制的水平上。在内部，假定每种受支持的机制都将用户的通用表示映射为机制更特定的形式。例如，Kerberos V5机制提供程序可能将此名称映射到<code class="codeph">duke@EXAMPLE.COM</code>哪里<code class="codeph">EXAMPLE.COM</code>是本地Kerberos领域。同样，基于公共密钥的机制提供程序可能将此名称映射到X.509专有名称。
                     </p>
                     <p>如果我们指的不是一个用户，而是某种服务的委托人，我们将向Java GSS-API调用表明这一点，以便该机制知道以不同的方式解释它。</p>
                     <p>例：</p><pre class="pre codeblock"><code>GSSName serverName = manager.createName("nfs@bar.example.com",
                                         GSSName.NT_HOSTBASED_SERVICE);
</code></pre><p>Kerberos V5机制会将此名称映射到Kerberos特定形式<code class="codeph">nfs/bar.example.com@EXAMPLE.COM</code>哪里<code class="codeph">EXAMPLE.COM</code>是校长的境界。该主体代表服务<code class="codeph">nfs</code>在主机上运行<code class="codeph">bar.example.com</code> 。
                     </p>
                     <p>Oracle的实施<code class="codeph">GSSName</code>接口是一个容器类。当使用它们的机制时，容器类会懒惰地要求各个提供者执行其映射，然后将每个映射的元素存储在一组主体中。在这方面， <code class="codeph">GSSName</code>与存储在主题中的主体集相似。它甚至可能包含与Subject的主体集中的元素相同的元素，但是它的使用仅限于Java GSS-API的上下文。</p>
                     <p>Oracle Kerberos V5提供程序存储的name元素是的子类的实例。 <code class="codeph">javax.security.auth.kerberos.KerberosPrincipal</code> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-01637F56-125B-469E-8C4A-D642417DE870" name="GUID-01637F56-125B-469E-8C4A-D642417DE870"></a><h4 id="JSSEC-GUID-01637F56-125B-469E-8C4A-D642417DE870" class="sect4">GSSCredential接口</h4>
                  <div>
                     <p>此接口封装了一个实体拥有的凭据。像<span class="apiname">GSSName</span>一样，该接口也是一个多机制容器。
                     </p>
                     <p>其实现实例如下：</p><pre class="pre codeblock"><code>GSSCredential createCredential(GSSName name,
                               int lifetime,
                               Oid[] desiredMechs,
                               int usage)
    throws GSSException
</code></pre><p>这是在客户端的此调用的示例：</p><pre class="pre codeblock"><code>GSSCredential clientCreds =
    manager.createCredential(clientName,
                             8*3600,
                             desiredMechs,
                             GSSCredential.INITIATE_ONLY);
</code></pre><p><span class="apiname">GSSManager</span>为属于<span class="apiname">GSSName</span> <span class="apiname">clientName的</span>凭据调用<span class="apiname">desireMech中</span>列出的机制的提供程序。另外，它施加了以下限制：凭据必须是可以发起出站请求的类型（即，客户端凭据），并要求其使用8小时。返回的对象包含来自<span class="apiname">desireMech</span>的子集的元素，这些子集具有一些可用于满足此条件的凭据。Kerberos V5机制存储的元素是<span class="apiname">javax.security.auth.kerberos的子类的实例<span class="apiname">。包含属于用户的TGT的KerberosTicket</span> 。
                     </span></p>
                     <p>服务器端的凭证获取发生如下：</p><pre class="pre codeblock"><code>GSSCredential serverCreds =
    manager.createCredential(serverName,
                             GSSCredential.INDEFINITE_LIFETIME,
                             desiredMechs,
                             GSSCredential.ACCEPT_ONLY);
</code></pre><p>该行为与客户端情况相似，不同的是所请求的凭证类型是可以接受传入请求的凭证（即服务器凭证）。而且，服务器通常寿命很长，并且喜欢请求更长的生存期来获取凭据，例如此处显示的<span class="apiname">INDEFINITE_LIFETIME</span> 。存储的Kerberos V5机制元素是<span class="apiname">javax.security.auth.kerberos子类的实例<span class="apiname">。包含服务器秘密密钥的KerberosKey</span> 。
                     </span></p>
                     <p>此步骤可能是一个昂贵的步骤，并且应用程序通常会在初始化时获取对其期望在其生存期内使用的所有凭据的引用。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D552C782-1820-444B-85EA-A4AED3DE3757" name="GUID-D552C782-1820-444B-85EA-A4AED3DE3757"></a><h4 id="JSSEC-GUID-D552C782-1820-444B-85EA-A4AED3DE3757" class="sect4">GSSContext接口</h4>
                  <div>
                     <p><span class="apiname">GSSContext</span>是一个接口，其实现为两个对等方提供安全服务。
                     </p>
                     <p>在客户端，通过以下API调用获得<span class="apiname">GSSContext</span>实现：</p><pre class="pre codeblock"><code>GSSContext GSSManager.createContext(GSSName peer,
                                    Oid mech,
                                    GSSCredential clientCreds,
                                    int lifetime)
    throws GSSException
</code></pre><p>这将返回一个初始化的安全上下文，该上下文知道必须与之通信的对等方以及用于通信的机制。客户的凭据是向对等方进行身份验证所必需的。</p>
                     <p>在服务器端，按以下方式获取<span class="apiname">GSSContext</span> ：</p><pre class="pre codeblock"><code>GSSContext GSSManager.createContext(GSSCredential serverCreds)
    throws GSSException
</code></pre><p>这将在接受者方返回初始化的安全上下文。此时，它不知道将发送上下文建立请求的对等方（客户端）的名称，甚至不知道将要使用的基础机制。但是，如果传入请求不是针对由凭据<span class="apiname">serverCreds</span>表示的服务主体，或者客户端请求的基础机制在<span class="apiname">serverCreds</span>中没有凭据元素，则请求将失败。
                     </p>
                     <p>在<span class="apiname">GSSContext</span>可以用于其安全服务之前，必须通过两个对等方之间的令牌交换来建立它。每次对上下文建立方法的调用都会生成一个不透明的令牌，应用程序必须使用其选择的通信通道以某种方式将其发送给对等方。
                     </p>
                     <p>客户端使用以下API调用来建立上下文：</p><pre class="pre codeblock"><code>byte[] GSSContext.initSecContext(byte[] inToken,
                                 int offset,
                                 int len)

   throws GSSException
</code></pre><p>服务器使用以下调用：</p><pre class="pre codeblock"><code>byte[] acceptSecContext(byte[] inToken,
                        int offset,
                        int len)

   throws GSSException
</code></pre><p>这两种方法是互补的，一种方法接受的输入是另一种方法生成的输出。当客户端第一次调用<span class="apiname">initSecContext</span>时，将生成第一个令牌。在调用期间，将忽略此方法的参数。生成的最后一个令牌取决于所使用的安全机制的详细信息以及所建立上下文的属性。
                     </p>
                     <p>认证对等方所需的GSS-API令牌的往返次数因机制而异，并且还随特性（例如，需要相互认证还是单向认证）而变化。因此，应用程序的每一方都必须继续循环调用上下文建立方法，直到该过程完成为止。</p>
                     <p>对于Kerberos V5机制，在上下文建立期间最多只能进行一次令牌往返。客户端首先发送由其<span class="apiname">initSecContext（）</span>生成的令牌，该令牌包含Kerberos AP-REQ消息<a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-02">[2]</a> 。为了生成AP-REQ消息，Kerberos提供程序使用客户端的TGT获取目标服务器的服务票证。服务票证使用服务器的长期秘密密钥加密，并封装为AP-REQ消息的一部分。服务器收到此令牌后，将其传递到<span class="apiname">acceptSecContext（）</span>方法，该方法解密服务票证并对客户端进行身份验证。如果不要求相互身份验证，则将同时建立客户端和服务器端上下文，并且服务器端<span class="apiname">acceptSecContext（）</span>将不生成任何输出。
                     </p>
                     <p>但是，如果启用了相互身份验证，则服务器的<span class="apiname">acceptSecContext（）</span>将生成一个包含Kerberos AP-REP <a href="single-sign-using-kerberos-java1.html#GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-02">[2]</a>消息的输出令牌。在建立客户端上下文之前，需要将该令牌发送回客户端以通过其<span class="apiname">initSecContext（）</span>进行处理。
                     </p>
                     <p>请注意，当在客户端上初始化<span class="apiname">GSSContext</span>时，很明显需要使用哪种底层机制。Java GSS-API框架可以从适当的机制提供程序获取上下文实现。此后，所有对<span class="apiname">GSSContext</span>对象的调用都委托给该机制的上下文实现。在服务器端，要确定使用的机制，直到来自客户端的第一个令牌到达。
                     </p>
                     <p>这是一个类，显示如何对应用程序的客户端进行编码。这是<code class="codeph">ClientAction</code> <a href="single-sign-using-kerberos-java1.html#GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E">Kerberos登录模块</a>小节中的<a href="single-sign-using-kerberos-java1.html#GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLECLIENTCODELOGINCONTEXTLCNULLT-37F389A2">示例客户端代码</a>中使用<span class="apiname">doAs</span>方法执行的类：</p><pre class="pre codeblock"><code>// Sample client using Java GSS-API

class ClientAction implements PrivilegedAction {

    public Object run() {
        ...
        ...
        try {
            GSSManager manager = GSSManager.getInstance();
            GSSName clientName =
                manager.createName("duke", GSSName.NT_USER_NAME);
            GSSCredential clientCreds =
                manager.createCredential(clientName,
                                          8*3600,
                                          desiredMechs,
                                          GSSCredential.INITIATE_ONLY);
            GSSName peerName =
                manager.createName("nfs@bar.example.com",
                                    GSSName.NT_HOSTBASED_SERVICE);
            GSSContext secContext =
                manager.createContext(peerName,
                                      krb5Oid,
                                      clientCreds,
                                      GSSContext.DEFAULT_LIFETIME);
            secContext.requestMutualAuth(true);

            // The first input token is ignored
            byte[] inToken = new byte[0];

            byte[] outToken = null;

            boolean established = false;

           // Loop while the context is still not established
           while (!established) {
               outToken =
                   secContext.initSecContext(inToken, 0, inToken.length);

               // Send a token to the peer if one was generated
               if (outToken != null)
                  sendToken(outToken);

               if (!secContext.isEstablished()) {
                  inToken = readToken();
               else
                  established = true;
            }
        } catch (GSSException e) {
             ....
        }
        ...
        ...
    }
}
</code></pre><p>在服务器端运行相应代码的部分<code class="codeph">ServerAction</code> <a href="single-sign-using-kerberos-java1.html#GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E">Kerberos登录模块</a>部分中<a href="single-sign-using-kerberos-java1.html#GUID-45DD4879-CD1B-4E02-8B20-572C95C8386E__SAMPLESERVERCODELOGINCONTEXTLCNULLT-37F4D999">示例服务器代码</a>中的类：</p><pre class="pre codeblock"><code>// Sample server using Java GSS-API

class ServerAction implelemts PrivilegedAction {

    public Object run() {
        ...
        ...
        try {
            GSSManager manager = GSSManager.getInstance();
            GSSName serverName =
                manager.createName("nfs@bar.example.com",
                                    GSSName.NT_HOSTBASED_SERVICE);
            GSSCredential serverCreds =
             manager.createCredential(serverName,
                                       GSSCredential.INDEFINITE_LIFETIME,
                                       desiredMechs,
                                       GSSCredential.ACCEPT_ONLY);
            GSSContext secContext = manager.createContext(serverCreds);

            byte[] inToken = null;
            byte[] outToken = null;

            // Loop while the context is still not established
            while (!secContext.isEstablished()) {
                 inToken = readToken();
                 outToken =
                     secContext.acceptSecContext(inToken, 0, inToken.length);

                  // Send a token to the peer if one was generated
                  if (outToken != null)
                      sendToken(outToken);
            }
        } catch (GSSException e) {
          ...
        }
        ...
        ...
   }
}</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-627867F1-0787-4D20-A971-01F2B5EA3FF3" name="GUID-627867F1-0787-4D20-A971-01F2B5EA3FF3"></a><h4 id="JSSEC-GUID-627867F1-0787-4D20-A971-01F2B5EA3FF3" class="sect4">讯息保护</h4>
                  <div>
                     <p>一旦建立了安全上下文，就可以将其用于消息保护。Java GSS-API提供消息完整性和消息机密性。启用此功能的两个调用如下：</p><pre class="pre codeblock"><code>byte[] GSSContext.wrap(byte[] clearText,
                       int offset,
                       int len,
                       MessageProp properties)
    throws GSSException
</code></pre><p>和</p><pre class="pre codeblock"><code>byte[] unwrap(byte[] inToken,
              int offset,
              int len,
              MessageProp properties)
    throws GSSException
</code></pre><p><span class="apiname">wrap</span>方法用于将纯文本消息封装在令牌中，以使其受到完整性保护。（可选）还可以通过通过<span class="apiname">MessageProp</span>对象进行请求来对消息进行加密。<span class="apiname">wrap</span>方法返回一个不透明的令牌，调用者将其发送给其对等方。当令牌传递给原始明文时，对等方的<span class="apiname">unwrap</span>方法将其返回。<span class="apiname">展开</span>侧的<span class="apiname">MessageProp</span>对象返回有关该消息是仅受完整性保护还是也已加密的信息。它还包含排序和重复的令牌警告。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B" name="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B"></a><h4 id="JSSEC-GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B" class="sect4">凭证委派</h4>
                  <div>
                     <p>Java GSS-API允许客户端将其凭据安全地委派给服务器，以便服务器可以代表客户端启动其他安全上下文。此功能对于多层环境中的单点登录很有用。<a href="single-sign-using-kerberos-java1.html#GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__GUID-BDE6C438-A115-4935-BF04-A06CAC888B99">图7-2</a>对此进行了说明。
                     </p>
                     <div class="figure" id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__GUID-BDE6C438-A115-4935-BF04-A06CAC888B99">
                        <p class="titleinfigure">图7-2传统凭证委派</p><img src="img/jgss_pb_002c.png" alt="如下图7-2所示" title="如下图7-2所示" longdesc="img_text/jgss_pb_002c.html"><br><a href="img_text/jgss_pb_002c.html">“图7-2传统凭据委派”的说明</a></div>
                     <!-- class="figure" -->
                     <p>客户端在首次调用<span class="apiname">initSecContext（）</span>之前请求凭据委派：</p><pre class="pre codeblock"><code>void GSSContext.requestCredDeleg(boolean state)
    throws GSSException
</code></pre><p>通过将state设置为true。</p>
                     <p>服务器在上下文建立后接收委托的凭据：</p><pre class="pre codeblock"><code>GSSCredential GSSContext.getDelegCred() throws GSSException
</code></pre><p>然后，服务器可以将此<span class="apiname">GSSCredential</span>传递给假装为客户端的<span class="apiname">GSSManager.createContext（）</span> 。
                     </p>
                     <p>对于Kerberos V5机制，委托凭证是转发的TGT，它封装为从客户端发送到服务器的第一个令牌的一部分。使用此TGT，服务器可以代表客户端获取任何其他服务的服务票证。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__GUID-E43C7480-0051-43C8-B515-0C9842866DE5">MS-SFU Kerberos扩展</p>
                        <p><a href="http://msdn.microsoft.com/en-us/library/cc246071.aspx" target="_blank">MS-SFU</a>是指Microsoft Kerberos 5扩展，它允许服务代表客户端获得Kerberos服务票证。Microsoft将此功能称为受限委派。当客户端与该服务之间的身份验证未通过Kerberos建立时（因此无法使用标准的Kerberos委派），但是该服务需要以客户端的名义访问受Kerberos保护的后端服务器时，此功能很有用。
                        </p>
                        <p>MS-SFU在该协议上添加了两个扩展：“用户到自身的服务（S4U2self）”，该服务允许前端服务代表用户获得针对其自身的Kerberos服务票证；以及“用户到代理的服务”（S4U2proxy），这样一来，它就可以代表用户获得第二项后端服务的服务票证。这两个扩展一起使前端服务可以代表用户获得Kerberos服务票证。生成的服务凭单可用于访问本地或远程计算机上的其他服务。<span class="apiname">com.sun.security.jgss</span>包中的公共方法<a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/jgss/ExtendedGSSCredential.html#impersonate-org.ietf.jgss.GSSName-" target="_blank"><span class="apiname">ExtendedGSSCredential :: impersonate</span></a>实现了这些扩展。
                        </p>
                        <p>此功能在安全的企业部署中非常有用。例如，在典型的网络服务中，前端（例如Web服务器）通常需要代表客户端访问后端（例如数据库服务器）。常规Kerberos 5支持委派，但是要求该链中的所有层在每个步骤中都明确使用Kerberos身份验证，这并非总是可能或不希望的。</p>
                        <p>例如，如果客户端使用摘要身份验证登录到Web服务器，则没有要委派的Kerberos凭据，并且无法进行常规的逐步Kerberos 5身份验证。但是，由于MS-SFU定义了“用户服务（S4U2self）”扩展，以便前端可以代表客户端访问后端而无需提供客户端的Kerberos凭据，因此MS-SFU可以在这种情况下提供身份验证。<a href="single-sign-using-kerberos-java1.html#GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__CONSTRAINEDDELEGATIONWITHS4U2SELF-47300961">图7-3</a>对此进行了说明。
                        </p>
                        <div class="figure" id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__CONSTRAINEDDELEGATIONWITHS4U2SELF-47300961">
                           <p class="titleinfigure">图7-3 S4U2self的约束委派</p><img src="img/jgss_pb_004c.png" alt="如下图7-3所示" title="如下图7-3所示" longdesc="img_text/jgss_pb_004c.html"><br><a href="img_text/jgss_pb_004c.html">“图7-3 S4U2self的约束委派”的描述</a></div>
                        <!-- class="figure" -->
                        <p>此外，标准Kerberos 5委托机制（Microsoft称为开放委托）中可能存在安全漏洞。在这种机制中，一旦服务帐户获得了客户端的委派凭据，便可以访问任何服务。因此，在公开授权时需要格外小心。</p>
                        <p>相反，通过MS-SFU委派（在S4U2proxy中实现），管理员可以精确地控制特定客户可以代表其访问的服务。<a href="single-sign-using-kerberos-java1.html#GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__CONSTRAINEDDELEGATIONWITHS4U2PROXY-47300C1F">图7-4</a>对此进行了说明。
                        </p>
                        <div class="figure" id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__CONSTRAINEDDELEGATIONWITHS4U2PROXY-47300C1F">
                           <p class="titleinfigure">图7-4使用S4U2proxy的约束委派</p><img src="img/jgss_pb_003c.png" alt="如下图7-4所示" title="如下图7-4所示" longdesc="img_text/jgss_pb_003c.html"><br><a href="img_text/jgss_pb_003c.html">“图7-4使用S4U2proxy约束委派”的描述</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnote" id="GUID-363496FF-1E54-4A63-8B3B-89D7D23C2C4B__GUID-E3BFE2DB-1022-4C40-A5E6-9A7CA8223CD0">
                           <p class="notep1">注意：</p>
                           <p>要按照本文档RFC中的规定委派凭据，必须使用传统委派。使用受约束的委派，客户端无法确定是否可以委派自己的凭据，因为这是由KDC确定的。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B54B88B4-087F-4B0D-A28B-C0980D762D5C" name="GUID-B54B88B4-087F-4B0D-A28B-C0980D762D5C"></a><h3 id="JSSEC-GUID-B54B88B4-087F-4B0D-A28B-C0980D762D5C" class="sect3">默认凭证获取模型</h3>
               <div>
                  <p>之前，我们讨论了应用程序如何使用<span class="apiname">GSSManager.createCredential（）</span>方法用机制特定的凭据填充<span class="apiname">GSSCredential</span>对象。接下来的两个小节将重点介绍Java GSS-API机制如何获取这些凭据。这些机制本身不会执行用户登录。取而代之的是，登录是在使用Java GSS-API之前执行的，并且凭据被假定存储在机制提供者知道的某些缓存中。<span class="apiname">GSSManager.createCredential（）</span>方法仅获取对这些凭据的引用，并将它们返回到以GSS为中心的容器<span class="apiname">GSSCredential中</span> 。
                  </p>
                  <p>在Java SE中，我们施加了以下限制：Java GSS-API机制提供者用来获取这些元素的凭据缓存必须专门是当前访问控制上下文上Subject中的公共和私有凭据集。</p>
                  <p>从应用程序的角度来看，此模型的优点是凭据管理简单且可预测。具有正确权限的应用程序可以清除主题中的凭据，也可以使用标准Java API对其进行续订。如果清除了凭据，则可以确保Java GSS-API机制将失败，或者如果它更新了基于时间的凭据，则可以确保该机制将成功。</p>
                  <p>这是图3和6中的客户端应用程序使用Kerberos V5机制时与凭证获取有关的事件序列：</p>
                  <ol>
                     <li>该应用程序调用JAAS登录名，而JAAS登录名又调用配置的<span class="apiname">Krb5LoginModule</span></li>
                     <li><span class="apiname">Krb5LoginModule</span>从KDC或从现有票证缓存中获取用户的TGT（ <span class="apiname">KerberosTicket</span> ），并将此TGT存储在Subject的专用凭据集中</li>
                     <li>应用程序检索填充的Subject，然后调用<span class="apiname">Subject.doAs</span> / <span class="apiname">doAsPrivileged</span> ，它将此Subject置于执行<span class="apiname">ClientAction</span>的线程的访问控制上下文中</li>
                     <li><span class="apiname">ClientAction</span>调用<span class="apiname">GSSManager.createCredential</span>方法，并将其传递给<span class="apiname">desireMechs中</span>的Kerberos V5 OID。
                     </li>
                     <li>GSSManager.createCredential调用Kerberos V5 GSS-API提供程序，要求提供用于启动安全上下文的Kerberos凭据。</li>
                     <li>Kerberos提供程序从当前访问控制上下文中获取主题，并在其专用证书集中搜索代表用户TGT的有效KerberosTicket。</li>
                     <li>KerberosTicket返回到GSSManager，后者将其存储在GSSCredential容器实例中，以返回给调用方。</li>
                  </ol>
                  <p>在服务器端，当步骤2中的Kerberos登录成功时，除了KerberosTicket之外，Krb5LoginModule还将服务器的KerberosKey存储在主题中。稍后，在步骤5至7中检索KerberosKey，并将其用于解密客户端发送的服务票证。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-7F63948A-0FF3-4818-89E8-B39A1CF4DBB3" name="GUID-7F63948A-0FF3-4818-89E8-B39A1CF4DBB3"></a><h3 id="JSSEC-GUID-7F63948A-0FF3-4818-89E8-B39A1CF4DBB3" class="sect3">模型的例外</h3>
               <div>
                  <p>Java GSS-API的默认凭据获取模型要求凭据在当前主题中存在。通常，在应用程序进行JAAS登录后，将凭据放置在此处。</p>
                  <p>在某些情况下，应用程序希望从主题外部使用Kerberos凭据。建议通过将<span class="apiname">Krb5LoginModule</span>配置为读取这些<span class="apiname">凭据</span> ，或者编写一个读取它们的自定义登录模块，将这些凭据作为初始JAAS登录的一部分读取。但是，某些应用程序可能会受到限制，或者阻止它们在调用Java GSS-API之前使用JAAS，或者迫使它们使用某些Kerberos机制提供程序，该提供程序没有从当前主题中检索凭证。
                  </p>
                  <p>系统属性<code class="codeph">javax.security.auth.useSubjectCredsOnly</code>适应这种情况，同时仍为其他人保留标准模型。此系统属性用作布尔值，其中true值要求遵循标准的凭证获取模型，而false值则允许提供程序使用其选择的任何缓存。此属性的默认值（未设置时）将假定为true。
                  </p>
                  <p>如果当前主题中没有有效的Kerberos凭据，并且此属性为true，则Kerberos机制将引发<span class="apiname">GSSException</span> 。将此属性设置为false并不一定意味着提供程序必须使用当前主题以外的其他缓存，它仅使提供程序可以自由选择是否愿意。
                  </p>
                  <p>Kerberos V5 GSS-API机制的Oracle提供程序始终从主题获取凭据。如果当前主题中没有有效的凭据，并且此属性设置为false，则提供程序将尝试通过调用JAAS登录本身来从临时主题中获取新的凭据。它使用文本回调处理程序与用户进行输入/输出，并使用“ other”标识的JAAS配置条目来使用的模块和选项列表。<a id="fn_2" name="fn_2" href="#fn_2" actually="" it="" first="" tries="" to="" use="" the="" jaas="" configuration="" entry="" com.sun.security.jgss.initiate="" for="" client="" and="" com.sun.security.jgss.accept="" server="" falls="" back="" on="" ="other\" ,="" if="" these="" entries="" are="" missing.="" this="" gives="" system="" administrators="" some="" additional="" control="" over="" its="" behavior=")" ="" onclick="footdisplay(2, "><sup>脚2</sup></a></p>
                  <p>Kerberos V5 GSS-API机制的Oracle提供程序假定这些模块之一将是Kerberos登录模块。可以配置列在“其他”下的模块以读取预先存在的缓存，以便在Java GSS-API调用过程中不会意外提示用户输入密码。从登录名中检索到所需的凭据后，Kerberos GSS-API机制将丢弃此登录名填充的新主题。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-1793ADE8-8B78-4680-A871-063ED761CFF5" name="GUID-1793ADE8-8B78-4680-A871-063ED761CFF5"></a><h3 id="JSSEC-GUID-1793ADE8-8B78-4680-A871-063ED761CFF5" class="sect3">安全风险</h3>
               <div>
                  <p>单点登录的便利性也带来了新的风险。如果恶意用户从您可以在其中启动小程序的位置访问您的无人照管桌面，会发生什么情况？如果恶意小程序在您登录到不应该使用的服务时登录，该怎么办？</p>
                  <p>对于前者，我们别无选择，只能警告您不要解锁您的工作站！对于后者，我们有许多授权检查。</p>
                  <p>为了说明权限模型的一些细节，请考虑一个示例，其中您的浏览器在启动时执行了JAAS登录，并将主题与其中运行的所有小程序相关联。</p>
                  <p>通过<span class="apiname">javax.security.auth可以保护Subject免受恶意小程序的<span class="apiname">攻击。AuthPermission</span>类。每当代码尝试获取对与任何访问控制上下文相关联的Subject的引用时，都会检查此权限。
                  </span></p>
                  <p>即使已向applet授予了对Subject的访问权限，它也需要<span class="apiname">javax.security.auth。PrivateCredentialPermission</span>实际读取存储在其中的敏感私有凭据。
                  </p>
                  <p>Java GSS-API机制提供者在读取凭据并代表凭据所有者建立安全上下文时，将执行其他类型的检查。为了支持Kerberos V5机制，软件包<span class="apiname">javax.security.auth.kerberos中</span>添加了两个新的权限类：</p><pre class="pre codeblock"><code>ServicePermission(String servicePrinicipal, String action)
DelegationPermission(String principals)
</code></pre><p>由于新的GSS-API机制已针对Java SE进行了标准化，因此将添加更多软件包，其中包含这些机制的提供者的相关权限类。</p>
                  <p>Kerberos GSS-API机制权限检查在程序执行的以下几点进行：</p>
               </div>
               <div class="sect3"><a id="GUID-23E25BFC-E77A-495C-8406-897E9D124395" name="GUID-23E25BFC-E77A-495C-8406-897E9D124395"></a><h4 id="JSSEC-GUID-23E25BFC-E77A-495C-8406-897E9D124395" class="sect4">凭证获取</h4>
                  <div>
                     <p><span class="apiname">GSSManager.createCredential（）</span>方法从诸如当前Subject之类的缓存中获取特定于机制的凭据元素，并将其存储在<span class="apiname">GSSCredential</span>容器中。不允许小程序自由获取<span class="apiname">GSSCredential</span> ，即使他们不能使用它们做很多事情也是不希望的。这样做会泄漏有关用户和服务主体存在的信息。因此，在应用程序获取其中包含任何Kerberos凭据元素的<span class="apiname">GSSCredential</span>之前，需要进行<span class="apiname">ServicePermission</span>检查。
                     </p>
                     <p>在客户端，成功获取<span class="apiname">GSSCredential</span>意味着已从缓存访问了TGT。因此，将检查以下<span class="apiname">ServicePermission</span> ：</p><pre class="pre codeblock"><code>ServicePermission("krbtgt/EXAMPLE.COM@EXAMPLE.COM", "initiate");
</code></pre><p>服务主体<code class="codeph">krbtgt/EXAMPLE.COM@EXAMPLE.COM</code>表示Kerberos领域中的票证授予服务（TGS） <code class="codeph">EXAMPLE.COM</code> ，并且操作“启动”表明正在访问此服务的票证。在获取客户端凭据时，将始终在此权限检查中使用TGS服务主体。
                     </p>
                     <p>在服务器端，成功获取<span class="apiname">GSSCredential</span>表示已从缓存访问了密钥。因此，将检查以下<span class="apiname">ServicePermission</span> ：</p><pre class="pre codeblock"><code>ServicePermission("nfs/bar.example.com@EXAMPLE.COM", "accept");
</code></pre><p>这里的服务主体<code class="codeph">nfs/bar.example.com</code>表示Kerberos服务主体，并且操作“接受”表明正在请求此服务的秘密密钥。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5BB1D535-B4A3-403A-91CF-8A5B98B6DB0E" name="GUID-5BB1D535-B4A3-403A-91CF-8A5B98B6DB0E"></a><h4 id="JSSEC-GUID-5BB1D535-B4A3-403A-91CF-8A5B98B6DB0E" class="sect4">上下文建立</h4>
                  <div>
                     <p>具有联系特定服务器（例如LDAP服务器）权限的小程序一定不能联系其他服务器（例如FTP服务器）。当然，可以借助<span class="apiname">SocketPermission</span>来限制applet的操作。但是，即使允许网络连接，也可以使用<span class="apiname">ServicePermission</span>限制它使用您的身份进行身份验证。
                     </p>
                     <p>当Kerberos机制提供者即将启动上下文建立时，它会检查<span class="apiname">ServicePermission</span> ：</p><pre class="pre codeblock"><code>ServicePermission("ftp@EXAMPLE.COM", "initiate");
</code></pre><p>此检查可防止未经授权的代码获取和使用Kerberos服务票证作为主体<code class="codeph">ftp@EXAMPLE.COM</code> 。
                     </p>
                     <p>使用此权限提供对特定服务主体的有限访问仍然很危险。允许下载的代码与其源主机进行通讯。恶意小程序可能会将包含在目标服务主体的长期秘密密钥中加密的<span class="apiname">KerberosTicket</span>的初始GSS-API输出令牌发回，从而使其遭受脱机字典攻击。因此，建议不要对从不受信任的站点下载的代码授予任何“启动” <span class="apiname">ServicePermission</span> 。
                     </p>
                     <p>在服务器端，在凭证获取期间已经检查了使用秘密密钥接受传入的安全上下文建立请求的权限。因此，在上下文建立阶段不进行任何检查。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3D1AFF31-323B-4DD6-829A-B7205FA11161" name="GUID-3D1AFF31-323B-4DD6-829A-B7205FA11161"></a><h4 id="JSSEC-GUID-3D1AFF31-323B-4DD6-829A-B7205FA11161" class="sect4">凭证委派</h4>
                  <div>
                     <p>有权代表您与服务器建立安全性上下文的小程序还具有请求将您的凭据委派给该服务器的功能。但是，并非所有服务器都可以信任，因此可以将凭据委派给它们。因此，在Kerberos提供程序获取要发送给对等方的委派凭据之前，它会检查以下权限：</p><pre class="pre codeblock"><code>DelegationPermission(" \"ftp@EXAMPLE.COM\" \"krbtgt/EXAMPLE.COM@EXAMPLE.COM\" ");
</code></pre><p>此权限允许Kerberos服务主体ftp@EXAMPLE.COM接收转发的TGT（由票证授予服务krbtgt/EXAMPLE.COM@EXAMPLE.COM表示）。<a id="fn_3" name="fn_3" href="#fn_3" the="" use="" of="" two="" principal="" names="" in="" this="" permission="" allows="" for="" finer="" grained="" delegation="" such="" as="" proxy="" tickets="" specific="" services="" unlike="" a="" carte="" blanche="" forwarded="" tgt.="" even="" though="" gss-api="" does="" not="" allow="" tickets,="" another="" api="" jsse="" might="" support="" idea="" at="" some="" point="" future=")" ="" onclick="footdisplay(3, "><sup>脚3</sup></a></p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-4A2151A0-B23A-4B2E-BFEE-A17545262B48" name="GUID-4A2151A0-B23A-4B2E-BFEE-A17545262B48"></a><h3 id="JSSEC-GUID-4A2151A0-B23A-4B2E-BFEE-A17545262B48" class="sect3">结论</h3>
               <div>
                  <p>在本文中，我们提出了一个框架来启用Java单点登录。这要求在进行初始身份验证以获取证书的JAAS与使用这些证书通过网络安全通信的Java GSS-API之间共享证书。我们将Kerberos V5作为基础安全机制，但是JAAS的可堆叠体系结构和Java GSS-API的多机制特性使我们可以同时使用许多不同的机制。</p>
                  <p>JAAS的Kerberos登录模块能够读取本机缓存，因此用户无需在支持Kerberos的平台上进行桌面登录以外的身份验证。此外，用于Java GSS-API的Kerberos V5机制允许委派凭据，从而可以在多层环境中进行单点登录。</p>
                  <p>最后，显示了许多权限检查，以防止未经授权使用Kerberos提供的单点登录功能。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-D65B3B0F-2689-4B4E-BAAD-A9E0D3571A84" name="GUID-D65B3B0F-2689-4B4E-BAAD-A9E0D3571A84"></a><h3 id="JSSEC-GUID-D65B3B0F-2689-4B4E-BAAD-A9E0D3571A84" class="sect3">致谢</h3>
               <div>
                  <p>我们感谢Gary Ellison，Charlie Lai和Jeff Nisewanger在Kerberos单点登录项目的每个阶段所做的贡献。Charlie将JAAS 1.0实现为Kestrel（J2SE 1.3）的可选软件包。Gary曾为Kerberos Java GSS-API机制设计权限模型。我们感谢Bob Scheifler对将JAAS 1.0集成到Merlin中的反馈以及Tim Tim Blackman对KeyStoreLoginModule和CallbackHandler实现的反馈。我们也感谢Bruce Rich，Tony Nadalin，Thomas Owusu和Yanni Zhang的评论和建议。我们感谢Mary Dageforde提供的文档和教程。Sriramulu Lakkaraju，Stuart Ke和Shital Shisode为项目提供了测试。Maxine Erlund为该项目提供了管理支持。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B" name="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B"></a><h3 id="JSSEC-GUID-67712665-922E-4947-8103-0AAE9C2AAC2B" class="sect3">参考文献</h3>
               <div>
                  <ol>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-01">Neuman，Clifford和Tso，Theodore（1994）。Kerberos：《计算机网络身份验证服务》，IEEE通信，第39卷，第33-38页</li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-02">J.Kohl和C.Neuman。Kerberos网络身份验证服务（V5）Internet工程任务组，1993年9月， <a href="http://www.ietf.org/rfc/rfc1510.txt" target="_blank">请求注释1510</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-03">V. Samar和C. Lai。使登录服务独立于身份验证技术。1996年3月，在SunSoft开发者大会的会议记录中。</li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-04">X / Open单一登录服务（XSSO）-可插入身份验证。初步规范P702，开放团体，1997年6月<a href="http://www3.opengroup.org/" target="_blank">。http://www.opengroup.org</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-05">用于Java身份验证和授权服务的智能卡登录模块。 <a href="http://www.gemalto.com/gemplus/index.html" target="_blank">http://www.gemplus.com/techno/smartjaas/index.html</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-06">J·林恩通用安全服务应用程序接口，版本2。互联网工程任务组，2000年1月， <a href="http://www.ietf.org/rfc/rfc2743.txt" target="_blank">征求意见2743</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-07">J·林恩Kerberos版本5 GSS-API机制。互联网工程任务组，1996年6月， <a href="http://www.ietf.org/rfc/rfc1964.txt" target="_blank">征求意见，1964年</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-08">亚当斯简单的公钥GSS-API机制（SPKM）。互联网工程任务组，1996年10月， <a href="http://www.ietf.org/rfc/rfc2025.txt" target="_blank">征求意见2025</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-09">J. Kabat和M.Upadhyay。通用安全服务API版本2：Java绑定。互联网工程任务组，1997年1月， <a href="http://www.ietf.org/rfc/rfc2853.txt" target="_blank">征求意见2853</a></li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-10">JSR 000072通用安全服务API</li>
                     <li id="GUID-67712665-922E-4947-8103-0AAE9C2AAC2B__SSO-KERBEROS-11"><a href="https://docs.oracle.com/javase/10/docs/api/overview-summary.html" target="_blank">Java平台，标准版API规范</a></li>
                  </ol>
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：GSS-API Kerberos机制至少执行客户端身份验证。<br>脚注2：实际上，它首先尝试使用JAAS配置条目<code class="codeph">com.sun.security.jgss.initiate</code>为客户和<code class="codeph">com.sun.security.jgss.accept</code>服务器，如果缺少这些条目，则退回到“其他”条目。这使系统管理员可以对其行为进行一些其他控制。<br>脚注3：在此权限中使用两个主体名称可以实现更细粒度的委派，例如特定服务的代理票证，而不是将空白票证转发给TGT。即使GSS-API不允许使用代理票证，但将来的某个时候，另一个API（例如JSSE）也可能支持此想法。<br></div>
      </article>
   

</body></html>