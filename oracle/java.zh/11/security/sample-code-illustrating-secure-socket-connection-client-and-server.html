<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="These samples illustrate how to set up a secure socket connection between a client and a server.">
      <meta name="description" content="These samples illustrate how to set up a secure socket connection between a client and a server.">
      <title>Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="These samples illustrate how to set up a secure socket connection between a client and a server.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="sample-truststores.html" title="Previous" type="text/html">
      <link rel="next" href="sample-code-illustrating-https-connections.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sample-truststores.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="sample-code-illustrating-https-connections.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="running-jsse-sample-code1.html" property="item" typeof="WebPage"><span property="name">运行JSSE示例代码</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">示例代码说明了客户端和服务器之间的安全套接字连接</li>
            </ol>
            <a id="GUID-A4D59ABB-62AF-4FC0-900E-A795FDC84E41" name="GUID-A4D59ABB-62AF-4FC0-900E-A795FDC84E41"></a>
            
            <h2 id="JSSEC-GUID-A4D59ABB-62AF-4FC0-900E-A795FDC84E41" class="sect2">示例代码说明了客户端和服务器之间的安全套接字连接</h2>
         </header>
         <div class="ind">
            <div>
               <p>这些示例说明了如何在客户端和服务器之间建立安全的套接字连接。</p>
               <p>在运行示例客户端程序时，您可以与现有服务器（例如Web服务器）进行通信，也可以与示例服务器程序进行通信， <code class="codeph">ClassFileServer</code> 。您可以在连接到同一网络的不同计算机上运行示例客户端和示例服务器程序，也可以在一台计算机上从不同的终端窗口运行它们。
               </p>
               <p>所有样品<code class="codeph">SSLSocketClient*</code> samples / sockets / client目录中的程序（和<code class="codeph">URLReader*</code>可以在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">示例代码示例HTTPS连接中</a>描述的程序）与<code class="codeph">ClassFileServer</code>示例服务器程序。<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">使用ClassFileServer运行SSLSocketClientWithClientAuth中</a>显示了如何执行此操作的示例。您可以进行类似的更改以运行<code class="codeph">URLReader</code> ， <code class="codeph">SSLSocketClient</code> ， 要么<code class="codeph">SSLSocketClientWithTunneling</code>与<code class="codeph">ClassFileServer</code> 。
               </p>
               <p>如果客户端和服务器之间的通信过程中发生身份验证错误（无论是使用Web服务器还是<code class="codeph">ClassFileServer</code> ），则最有可能是因为必要的密钥不在信任库（信任密钥数据库）中。请参阅<a href="terms-and-definitions.html" title="以下是常用的密码术术语及其定义。">术语和定义</a> 。例如， <code class="codeph">ClassFileServer</code>使用名为<code class="codeph">testkeys</code>包含的私钥<code class="codeph">localhost</code>在SSL握手期间根据需要。的<code class="codeph">testkeys</code>密钥库包含在与密钥库相同的sample / sockets / server目录中<code class="codeph">ClassFileServer</code>资源。如果客户端找不到对应于的公共密钥的证书<code class="codeph">localhost</code>在它查询的信任库中，将发生身份验证错误。请务必使用<code class="codeph">samplecacerts</code>信任库（包含公钥和证书的证书） <code class="codeph">localhost</code> ），如<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7">SSL套接字示例的配置要求中</a>所述。
               </p>
            </div>
            <div class="sect2"><a id="GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7" name="GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7"></a><h3 id="JSSEC-GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7" class="sect3">SSL套接字示例的配置要求</h3>
               <div>
                  <p></p>
                  <p>运行在客户端和服务器之间创建安全套接字连接的示例程序时，需要使相应的证书文件（信任库）可用。对于客户端程序和服务器程序，都应使用证书文件<code class="codeph">samplecacerts</code>来自<code class="codeph">samples</code>目录。使用此证书文件将允许客户端对服务器进行身份验证。该文件包含JDK随附的所有通用证书颁发机构（CA）证书（在cacerts文件中），以及用于<code class="codeph">localhost</code>客户需要进行身份验证<code class="codeph">localhost</code>与样本服务器通信时<code class="codeph">ClassFileServer</code> 。的<code class="codeph">ClassFileServer</code>使用包含私钥的密钥库<code class="codeph">localhost</code>对应于<code class="codeph">samplecacerts</code> 。
                  </p>
                  <p>为了使<code class="codeph">samplecacerts</code>客户端和服务器均可使用的文件，您可以将其复制到文件中<code>java-home/lib/security/jssecacerts</code> ，将其重命名为<code>cacerts</code> ，并用它替换<code>java-home/lib/security/cacerts</code>文件，或在运行以下命令时将以下选项添加到命令行<code class="codeph">java</code>客户端和服务器的命令：</p><pre class="codeblock"><code>-Djavax.net.ssl.trustStore=<span class="variable" translate="no">path_to_samplecacerts_file</span>
</code></pre><p>的密码<code class="codeph">samplecacerts</code>信任库为<code class="codeph">changeit</code> 。您可以使用<code class="codeph">keytool</code>效用。
                  </p>
                  <p>如果您使用浏览器来访问<code class="codeph">ClassFileServer</code>例如，然后可能会弹出一个对话框，提示您无法识别证书。这是正常的，因为与示例程序一起使用的证书是自签名的，并且仅用于测试。您可以接受当前会话的证书。在测试SSL服务器之后，您应该退出浏览器，该浏览器将从浏览器的名称空间中删除测试证书。
                  </p>
                  <p>对于客户端身份验证，单独<code class="codeph">duke</code>证书位于相应的目录中。公钥和证书也存储在<code class="codeph">samplecacerts</code>文件。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666" name="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666"></a><h3 id="JSSEC-GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666" class="sect3">运行SSLSocketClient</h3>
               <div>
                  <p></p>
                  <p>这个例子<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__SSLSOCKETCLIENT.JAVA-32CFECE1"><code>SSLSocketClient.java</code></a>演示如何创建使用<code class="codeph">SSLSocket</code>发送HTTP请求并从HTTPS服务器获得响应。默认情况下，此示例连接到<code class="codeph">www.verisign.com</code> ，但可以轻松进行调整以连接到<code>ClassFileServer</code> （请参阅<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C">运行ClassFileServer</a> ）。该程序的输出是HTML源代码，用于<code class="codeph">https://www.verisign.com/index.html</code> 。
                  </p>
                  <p>您一定不能在防火墙后面运行该程序。如果从防火墙后面运行它，则会得到一个<code class="codeph">UnknownHostException</code>因为JSSE无法通过防火墙找到通往<code class="codeph">www.verisign.com</code> 。要创建可以从防火墙后面运行的等效客户端，请如示例程序中所示设置代理隧道。 <code>SSLSocketClientWithTunneling</code> 。
                  </p>
                  <div class="infoboxnote" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__GUID-50A25A9C-8F31-43ED-A0A4-04AE3227AB3E">
                     <p class="notep1">注意：</p>
                     <p>必须稍微修改GET请求，以便指定文件。</p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__GUID-D489112E-A898-4039-B966-93502CBA12BE">用法</p><pre class="pre codeblock"><code>java SSLSocketClient</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__SSLSOCKETCLIENT.JAVA-32CFECE1">
                     <p class="subhead2" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__GUID-D84158C8-E138-4074-A137-E623E6D7A255">SSLSocketClient.java</p><pre class="pre codeblock"><code>import java.net.*;
import java.io.*;
import javax.net.ssl.*;

/*
 * This example demostrates how to use a SSLSocket as client to
 * send a HTTP request and get response from an HTTPS server.
 * It assumes that the client is not behind a firewall
 */

public class SSLSocketClient {

    public static void main(String[] args) throws Exception {
        try {
            SSLSocketFactory factory =
                (SSLSocketFactory)SSLSocketFactory.getDefault();
            SSLSocket socket =
                (SSLSocket)factory.createSocket("www.verisign.com", 443);

            /*
             * send http request
             *
             * Before any application data is sent or received, the
             * SSL socket will do SSL handshaking first to set up
             * the security attributes.
             *
             * SSL handshaking can be initiated by either flushing data
             * down the pipe, or by starting the handshaking by hand.
             *
             * Handshaking is started manually in this example because
             * PrintWriter catches all IOExceptions (including
             * SSLExceptions), sets an internal error flag, and then
             * returns without rethrowing the exception.
             *
             * Unfortunately, this means any error messages are lost,
             * which caused lots of confusion for others using this
             * code.  The only way to tell there was an error is to call
             * PrintWriter.checkError().
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));

            out.println("GET / HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient:  java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;
            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9" name="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9"></a><h3 id="JSSEC-GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9" class="sect3">运行SSLSocketClientWithTunnelling</h3>
               <div>
                  <p></p>
                  <p>这个例子<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__SSLSOCKETCLIENTWITHTUNNELING.JAVA-32D03DB5"><code>SSLSocketClientWithTunneling.java</code></a>说明了如何执行代理隧道以从防火墙后面访问安全的Web服务器。
                  </p>
                  <p>该程序将从以下位置返回HTML源文件<code class="codeph">https://www.verisign.com/index.html</code> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__GUID-E3055D7F-E4B8-4DDE-B802-A04CC3039A03">用法</p>
                     <p><code class="codeph">java -Dhttps.proxyHost=<span class="variable" translate="no">webproxy</span> -Dhttps.proxyPort=<span class="variable" translate="no">ProxyPortNumber</span> SSLSocketClientWithTunneling</code></p>
                     <p>更换<code class="codeph"><span class="variable" translate="no">webproxy</span></code>与您的代理主机的名称和<code class="codeph"><span class="variable" translate="no">ProxyPortNumber</span></code>使用适当的端口号。
                     </p>
                     <p>系统属性<code class="codeph">https.proxyHost</code>和<code class="codeph">https.proxyPort</code>用于建立与代理主机的套接字连接，然后<span class="apiname">SSLSocket</span>层叠在该<span class="apiname">Socket的</span>顶部。
                     </p><pre class="pre codeblock"><code></code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__SSLSOCKETCLIENTWITHTUNNELING.JAVA-32D03DB5">
                     <p class="subhead2" id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__GUID-9EFA28C7-836E-4DB3-9669-251FB6B6C019">SSLSocketClientWithTunneling.java</p>
                  </div>
                  <!-- class="section" --><pre class="pre codeblock"><code>import java.net.*;
import java.io.*;
import javax.net.ssl.*;

/*
 * This example illustrates how to do proxy Tunneling to access a
 * secure web server from behind a firewall.
 *
 * Please set the following Java system properties
 * to the appropriate values:
 *
 *   https.proxyHost = &lt;secure proxy server hostname&gt;
 *   https.proxyPort = &lt;secure proxy server port&gt;
 */

public class SSLSocketClientWithTunneling {

    public static void main(String[] args) throws Exception {
        new SSLSocketClientWithTunneling().doIt("www.verisign.com", 443);
    }

    String tunnelHost;
    int tunnelPort;

    public void doIt(String host, int port) {
        try {

            /*
             * Let's setup the SSLContext first, as there's a lot of
             * computations to be done.  If the socket were created
             * before the SSLContext, the server/proxy might timeout
             * waiting for the client to actually send something.
             */
            SSLSocketFactory factory =
                (SSLSocketFactory)SSLSocketFactory.getDefault();

            /*
             * Set up a socket to do tunneling through the proxy.
             * Start it off as a regular socket, then layer SSL
             * over the top of it.
             */
            tunnelHost = System.getProperty("https.proxyHost");
            tunnelPort = Integer.getInteger("https.proxyPort").intValue();

            Socket tunnel = new Socket(tunnelHost, tunnelPort);
            doTunnelHandshake(tunnel, host, port);

            /*
             * Ok, let's overlay the tunnel socket with SSL.
             */
            SSLSocket socket =
                (SSLSocket)factory.createSocket(tunnel, host, port, true);

            /*
             * register a callback for handshaking completion event
             */
            socket.addHandshakeCompletedListener(
                new HandshakeCompletedListener() {
                    public void handshakeCompleted(
                            HandshakeCompletedEvent event) {
                        System.out.println("Handshake finished!");
                        System.out.println(
                            "\t CipherSuite:" + event.getCipherSuite());
                        System.out.println(
                            "\t SessionId " + event.getSession());
                        System.out.println(
                            "\t PeerHost " + event.getSession().getPeerHost());
                    }
                }
            );

            /*
             * send http request
             *
             * See SSLSocketClient.java for more information about why
             * there is a forced handshake here when using PrintWriters.
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));

            out.println("GET / HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient:  java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;

            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();
            tunnel.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /*
     * Tell our tunnel where we want to CONNECT, and look for the
     * right reply.  Throw IOException if anything goes wrong.
     */
    private void doTunnelHandshake(Socket tunnel, String host, int port)
    throws IOException
    {
        OutputStream out = tunnel.getOutputStream();
        String msg = "CONNECT " + host + ":" + port + " HTTP/1.0\n"
                     + "User-Agent: "
                     + sun.net.www.protocol.http.HttpURLConnection.userAgent
                     + "\r\n\r\n";
        byte b[];
        try {
            /*
             * We really do want ASCII7 -- the http protocol doesn't change
             * with locale.
             */
            b = msg.getBytes("ASCII7");
        } catch (UnsupportedEncodingException ignored) {
            /*
             * If ASCII7 isn't there, something serious is wrong, but
             * Paranoia Is Good (tm)
             */
            b = msg.getBytes();
        }
        out.write(b);
        out.flush();

        /*
         * We need to store the reply so we can create a detailed
         * error message to the user.
         */
        byte            reply[] = new byte[200];
        int             replyLen = 0;
        int             newlinesSeen = 0;
        boolean         headerDone = false;     /* Done on first newline */

        InputStream     in = tunnel.getInputStream();
        boolean         error = false;

        while (newlinesSeen &lt; 2) {
            int i = in.read();
            if (i &lt; 0) {
                throw new IOException("Unexpected EOF from proxy");
            }
            if (i == '\n') {
                headerDone = true;
                ++newlinesSeen;
            } else if (i != '\r') {
                newlinesSeen = 0;
                if (!headerDone &amp;&amp; replyLen &lt; reply.length) {
                    reply[replyLen++] = (byte) i;
                }
            }
        }

        /*
         * Converting the byte array to a string is slightly wasteful
         * in the case where the connection was successful, but it's
         * insignificant compared to the network overhead.
         */
        String replyStr;
        try {
            replyStr = new String(reply, 0, replyLen, "ASCII7");
        } catch (UnsupportedEncodingException ignored) {
            replyStr = new String(reply, 0, replyLen);
        }

        /* We asked for HTTP/1.0, so we should get that back */
        if (!replyStr.startsWith("HTTP/1.0 200")) {
            throw new IOException("Unable to tunnel through "
                    + tunnelHost + ":" + tunnelPort
                    + ".  Proxy returns \"" + replyStr + "\"");
        }

        /* tunneling Handshake was successful! */
    }
}</code></pre></div>
            </div>
            <div class="sect2"><a id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B" name="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B"></a><h3 id="JSSEC-GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B" class="sect3">运行SSLSocketClientWithClientAuth</h3>
               <div>
                  <p></p>
                  <p>这个例子<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C"><code>SSLSocketClientWithClientAuth.java</code></a>与<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666">运行SSLSocketClient</a>相似，但是它显示了如何设置密钥管理器以在服务器要求时进行客户端身份验证。该程序还假定客户端不在防火墙之外。您可以按照<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9">运行SSLSocketClientWithTunnelling中</a>的示例修改程序以从防火墙内部进行连接。
                  </p>
                  <p>要运行该程序，必须指定三个参数：主机，端口和请求的文件路径。为了反映前面的示例，您可以通过将主机设置为来运行此程序而无需客户端身份验证<code class="codeph">www.verisign.com</code> ，前往的港口<code class="codeph">443</code> ，以及请求的文件路径<code class="codeph">https://www.verisign.com/</code> 。使用这些参数时的输出是网站的HTML <code class="codeph">https://www.verisign.com/</code> 。
                  </p>
                  <p>跑步<code class="codeph">SSLSocketClientWithClientAuth</code>要进行客户端身份验证，您必须访问请求客户端身份验证的服务器。您可以使用示例程序<code class="codeph">ClassFileServer</code>作为此服务器。请参阅<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E">使用ClassFileServer运行SSLSocketClientWithClientAuth</a> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__GUID-3AB4FC6F-6146-4804-B149-0B94F7DF7504">用法</p><pre class="pre codeblock"><code>java SSLSocketClientWithClientAuth <span class="variable" translate="no">host</span> <span class="variable" translate="no">port</span> <span class="variable" translate="no">requestedfilepath</span></code></pre><div class="infoboxnote" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__IFYOUARECONNECTINGTOTHECLASSFILESER-32D0BDD3">
                        <p class="notep1">注意：</p>如果要连接到上面的<span class="apiname">ClassFileServer</span>应用程序，请确保它可以找到以下文件的凭据： <code class="codeph">duke</code>用户。请参阅<a href="sample-truststores.html">示例信任库</a> 。
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C">
                     <p class="subhead2" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__GUID-A187EE4B-84F1-4C9A-A340-AD32C08D9038">SSLSocketClientWithClientAuth.java</p>
                  </div>
                  <!-- class="section" --><pre class="pre codeblock"><code>import java.net.*;
import java.io.*;
import javax.net.ssl.*;
import javax.security.cert.X509Certificate;
import java.security.KeyStore;

/*
 * This example shows how to set up a key manager to do client
 * authentication if required by server.
 *
 * This program assumes that the client is not inside a firewall.
 * The application can be modified to connect to a server outside
 * the firewall by following SSLSocketClientWithTunneling.java.
 */
public class SSLSocketClientWithClientAuth {

    public static void main(String[] args) throws Exception {
        String host = null;
        int port = -1;
        String path = null;
        for (int i = 0; i &lt; args.length; i++)
            System.out.println(args[i]);

        if (args.length &lt; 3) {
            System.out.println(
                "USAGE: java SSLSocketClientWithClientAuth " +
                "host port requestedfilepath");
            System.exit(-1);
        }

        try {
            host = args[0];
            port = Integer.parseInt(args[1]);
            path = args[2];
        } catch (IllegalArgumentException e) {
             System.out.println("USAGE: java SSLSocketClientWithClientAuth " +
                 "host port requestedfilepath");
             System.exit(-1);
        }

        try {

            /*
             * Set up a key manager for client authentication
             * if asked by the server.  Use the implementation's
             * default TrustStore and secureRandom routines.
             */
            SSLSocketFactory factory = null;
            try {
                SSLContext ctx;
                KeyManagerFactory kmf;
                KeyStore ks;
                char[] passphrase = "passphrase".toCharArray();

                ctx = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                ks.load(new FileInputStream("testkeys"), passphrase);

                kmf.init(ks, passphrase);
                ctx.init(kmf.getKeyManagers(), null, null);

                factory = ctx.getSocketFactory();
            } catch (Exception e) {
                throw new IOException(e.getMessage());
            }

            SSLSocket socket = (SSLSocket)factory.createSocket(host, port);

            /*
             * send http request
             *
             * See SSLSocketClient.java for more information about why
             * there is a forced handshake here when using PrintWriters.
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));
            out.println("GET " + path + " HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient: java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;

            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre></div>
            </div>
            <div class="sect2"><a id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C" name="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C"></a><h3 id="JSSEC-GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C" class="sect3">运行ClassFileServer</h3>
               <div>
                  <p></p>
                  <p>此示例包括<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B"><code>ClassFileServer.java</code></a>和<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSSERVER.JAVA-3314BE5B"><code>ClassServer.java</code></a>演示了小型Web服务器的实现，该服务器可以处理简单的HTTP或HTTPS请求（仅支持GET方法）。默认情况下，服务器不使用SSL / TLS。但是，命令行选项启用SSL / TLS。请求必须采用以下形式：</p><pre class="pre codeblock"><code>GET /<span class="variable" translate="no">&lt;filename&gt;</span></code></pre><div class="section">
                     <p class="subhead2" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__GUID-8705FC51-5340-4FA5-BE05-870AB89EF643">用法</p><pre class="pre codeblock"><code>java ClassFileServer <span class="variable" translate="no">port</span> <span class="variable" translate="no">docroot</span> [TLS [true]]
</code></pre><ul style="list-style-type:disc">
                        <li><code class="codeph"><span class="variable" translate="no">port</span></code> ：服务器所在的端口。它可以是任何可用的未使用的端口号，例如，您可以使用该端口号<code class="codeph">2001</code> 。
                        </li>
                        <li><code class="codeph"><span class="variable" translate="no">docroot</span></code> ：本地目录层次结构的根。它指示服务器上包含您要检索的文件的目录。例如，在Linux上，您可以使用<code>/home/<span class="variable" translate="no">userid</span>/</code> （哪里<code><span class="variable" translate="no">userid</span></code>是指您的特定UID），而在Windows系统上，您可以使用<code>C:\</code> 。
                        </li>
                        <li><code class="codeph">TLS</code> ：启用SSL / TLS服务的可选标志。如果您省略<code class="codeph">TLS</code>和<code class="codeph">true</code>参数，该参数指示应使用普通（非TLS）文件服务器，而无需进行身份验证，则什么也不会发生。这是因为一侧（客户端）正尝试与TLS协商，而另一侧（服务器）未与TLS协商，因此它们无法通信。
                        </li>
                        <li><code class="codeph">true</code> ：一个可选标志，要求客户端进行身份验证。此选项要求启用SSL / TLS支持。
                        </li>
                     </ul>
                     <p>安全服务器已预装了证书，用于<code class="codeph">localhost</code> 。如果服务器与客户端位于同一主机上，则URL格式为<code class="codeph">https://localhost:<span class="variable" translate="no">port</span>/<span class="variable" translate="no">file</span></code>应该通过主机名验证。如果选择在单独的主机上运行，则应为正在使用的https主机名创建一个新的主机证书，否则将出现主机名不匹配的问题。（注意：在Java中，可以通过提供自定义<span class="apiname">HostnameVerifier</span>实现在<span class="apiname">HttpsURLConnection</span>类中进行纠正，也可以在浏览器中通过接受描述主机名不匹配的对话框来进行纠正。）
                     </p>
                     <p>如果您使用的是TLS变体（HTTPS），请记住指定https协议：</p><pre class="pre codeblock"><code><span class="bold">https</span>://hostname:2001/dir1/file1</code></pre><div class="infoboxnote" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__GUID-9BE85FD2-AF32-451A-855F-132DF2E35267">
                        <p class="notep1">注意：</p>如果使用浏览器，则会弹出一个对话框，提示您应用程序无法识别<code class="codeph">localhost</code>证书。这是正常现象，因为最初不信任提供给浏览器的自签名证书。如果需要，您可以导入<code class="codeph">localhost</code>证书进入浏览器的信任库。
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B">
                     <p class="subhead2" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B8E7">ClassFileServer.java</p><pre class="pre codeblock"><code>import java.io.*;
import java.net.*;
import java.security.KeyStore;
import javax.net.*;
import javax.net.ssl.*;
import javax.security.cert.X509Certificate;

/* ClassFileServer.java -- a simple file server that can server
 * Http get request in both clear and secure channel
 *
 * The ClassFileServer implements a ClassServer that
 * reads files from the file system. See the
 * doc for the "Main" method for how to run this
 * server.
 */

public class ClassFileServer extends ClassServer {

    private String docroot;

    private static int DefaultServerPort = 2001;

    /**
     * Constructs a ClassFileServer.
     *
     * @param path the path where the server locates files
     */
    public ClassFileServer(ServerSocket ss, String docroot) throws IOException
    {
        super(ss);
        this.docroot = docroot;
    }

    /**
     * Returns an array of bytes containing the bytes for
     * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
     *
     * @return the bytes for the file
     * @exception FileNotFoundException if the file corresponding
     * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
     */
    public byte[] getBytes(String path)
        throws IOException
    {
        System.out.println("reading: " + path);
        File f = new File(docroot + File.separator + path);
        int length = (int)(f.length());
        if (length == 0) {
            throw new IOException("File length is zero: " + path);
        } else {
            FileInputStream fin = new FileInputStream(f);
            DataInputStream in = new DataInputStream(fin);

            byte[] bytecodes = new byte[length];
            in.readFully(bytecodes);
            return bytecodes;
        }
    }

    /**
     * Main method to create the class server that reads
     * files. This takes two command line arguments, the
     * port on which the server accepts requests and the
     * root of the path. To start up the server: &lt;br&gt;&lt;br&gt;
     *
     * &lt;code&gt;   java ClassFileServer &lt;port&gt; &lt;path&gt;
     * &lt;/code&gt;&lt;br&gt;&lt;br&gt;
     *
     * &lt;code&gt;   new ClassFileServer(port, docroot);
     * &lt;/code&gt;
     */
    public static void main(String args[])
    {
        System.out.println(
            "USAGE: java ClassFileServer port docroot [TLS [true]]");
        System.out.println("");
        System.out.println(
            "If the third argument is TLS, it will start as\n" +
            "a TLS/SSL file server, otherwise, it will be\n" +
            "an ordinary file server. \n" +
            "If the fourth argument is true,it will require\n" +
            "client authentication as well.");

        int port = DefaultServerPort;
        String docroot = "";

        if (args.length &gt;= 1) {
            port = Integer.parseInt(args[0]);
        }

        if (args.length &gt;= 2) {
            docroot = args[1];
        }
        String type = "PlainSocket";
        if (args.length &gt;= 3) {
            type = args[2];
        }
        try {
            ServerSocketFactory ssf =
                ClassFileServer.getServerSocketFactory(type);
            ServerSocket ss = ssf.createServerSocket(port);
            if (args.length &gt;= 4 &amp;&amp; args[3].equals("true")) {
                ((SSLServerSocket)ss).setNeedClientAuth(true);
            }
            new ClassFileServer(ss, docroot);
        } catch (IOException e) {
            System.out.println("Unable to start ClassServer: " +
                               e.getMessage());
            e.printStackTrace();
        }
    }

    private static ServerSocketFactory getServerSocketFactory(String type) {
        if (type.equals("TLS")) {
            SSLServerSocketFactory ssf = null;
            try {
                // set up key manager to do server authentication
                SSLContext ctx;
                KeyManagerFactory kmf;
                KeyStore ks;
                char[] passphrase = "passphrase".toCharArray();

                ctx = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                ks.load(new FileInputStream("testkeys"), passphrase);
                kmf.init(ks, passphrase);
                ctx.init(kmf.getKeyManagers(), null, null);

                ssf = ctx.getServerSocketFactory();
                return ssf;
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            return ServerSocketFactory.getDefault();
        }
        return null;
    }
}</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSSERVER.JAVA-3314BE5B">
                     <p class="subhead2" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSSERVER.JAVA-3314C021">ClassServer.java</p><pre class="pre codeblock"><code>import java.io.*;
import java.net.*;
import javax.net.*;

/*
 * ClassServer.java -- a simple file server that can serve
 * Http get request in both clear and secure channel
 */

public abstract class ClassServer implements Runnable {

    private ServerSocket server = null;
    /**
     * Constructs a ClassServer based on &lt;b&gt;ss&lt;/b&gt; and
     * obtains a file's bytecodes using the method &lt;b&gt;getBytes&lt;/b&gt;.
     *
     */
    protected ClassServer(ServerSocket ss)
    {
        server = ss;
        newListener();
    }

    /**
     * Returns an array of bytes containing the bytes for
     * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
     *
     * @return the bytes for the file
     * @exception FileNotFoundException if the file corresponding
     * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
     * @exception IOException if error occurs reading the class
     */
    public abstract byte[] getBytes(String path)
        throws IOException, FileNotFoundException;

    /**
     * The "listen" thread that accepts a connection to the
     * server, parses the header to obtain the file name
     * and sends back the bytes for the file (or error
     * if the file is not found or the response was malformed).
     */
    public void run()
    {
        Socket socket;

        // accept a connection
        try {
            socket = server.accept();
        } catch (IOException e) {
            System.out.println("Class Server died: " + e.getMessage());
            e.printStackTrace();
            return;
        }

        // create a new thread to accept the next connection
        newListener();

        try {
            OutputStream rawOut = socket.getOutputStream();

            PrintWriter out = new PrintWriter(
                                new BufferedWriter(
                                new OutputStreamWriter(
                                rawOut)));
            try {
                // get path to class file from header
                BufferedReader in =
                    new BufferedReader(
                        new InputStreamReader(socket.getInputStream()));
                String path = getPath(in);
                // retrieve bytecodes
                byte[] bytecodes = getBytes(path);
                // send bytecodes in response (assumes HTTP/1.0 or later)
                try {
                    out.print("HTTP/1.0 200 OK\r\n");
                    out.print("Content-Length: " + bytecodes.length +
                                   "\r\n");
                    out.print("Content-Type: text/html\r\n\r\n");
                    out.flush();
                    rawOut.write(bytecodes);
                    rawOut.flush();
                } catch (IOException ie) {
                    ie.printStackTrace();
                    return;
                }

            } catch (Exception e) {
                e.printStackTrace();
                // write out error response
                out.println("HTTP/1.0 400 " + e.getMessage() + "\r\n");
                out.println("Content-Type: text/html\r\n\r\n");
                out.flush();
            }

        } catch (IOException ex) {
            // eat exception (could log error to log file, but
            // write out to stdout for now).
            System.out.println("error writing response: " + ex.getMessage());
            ex.printStackTrace();

        } finally {
            try {
                socket.close();
            } catch (IOException e) {
            }
        }
    }

    /**
     * Create a new thread to listen.
     */
    private void newListener()
    {
        (new Thread(this)).start();
    }

    /**
     * Returns the path to the file obtained from
     * parsing the HTML header.
     */
    private static String getPath(BufferedReader in)
        throws IOException
    {
        String line = in.readLine();
        String path = "";
        // extract class from GET line
        if (line.startsWith("GET /")) {
            line = line.substring(5, line.length()-1).trim();
            int index = line.indexOf(' ');
            if (index != -1) {
                path = line.substring(0, index);
            }
        }

        // eat the rest of header
        do {
            line = in.readLine();
        } while ((line.length() != 0) &amp;&amp;
                 (line.charAt(0) != '\r') &amp;&amp; (line.charAt(0) != '\n'));

        if (path.length() != 0) {
            return path;
        } else {
            throw new IOException("Malformed Header");
        }
    }
}</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E" name="GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E"></a><h3 id="JSSEC-GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E" class="sect3">使用ClassFileServer运行SSLSocketClientWithClientAuth</h3>
               <div>
                  <p></p>
                  <p>您可以使用示例程序<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C"><code>SSLSocketClientWithClientAuth.java</code></a>和<a href="sample-code-illustrating-secure-socket-connection-client-and-server.html#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B"><code class="codeph">ClassFileServer.;ava</code></a>设置经过身份验证的通信，其中客户端和服务器相互进行身份验证。您可以在连接到同一网络的不同计算机上运行两个示例程序，也可以在一台计算机上从不同的终端窗口或命令提示符窗口运行它们。要设置客户端和服务器，请执行以下操作：</p>
                  <ol>
                     <li>运行程序<code class="codeph">ClassFileServer</code>从一台机器或终端窗口。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">运行ClassFileServer</a> 。
                     </li>
                     <li>运行程序<code class="codeph">SSLSocketClientWithClientAuth</code>在另一台计算机或终端窗口上。 <code class="codeph">SSLSocketClientWithClientAuth</code>需要以下参数：<ul style="list-style-type:disc">
                           <li><code class="codeph">host</code>是用于运行的计算机的主机名<code class="codeph">ClassFileServer</code> 。
                           </li>
                           <li><code class="codeph">port</code>与您指定的端口相同<code class="codeph">ClassFileServer</code> 。
                           </li>
                           <li><code class="codeph">requestedfilepath</code>表示要从服务器检索的文件的路径。您必须将此参数指定为<code class="codeph">/filepath</code> 。文件路径中需要使用正斜杠，因为它用作GET语句的一部分，无论您运行的是哪种操作系统，该语句都需要正斜杠。该语句的格式如下：<pre class="codeblock"><code>"GET " + requestedfilepath + " HTTP/1.0"
</code></pre></li>
                        </ul> 
                     </li>
                  </ol>
                  <div class="infoboxnote" id="GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E__GUID-80571B4D-FD52-412D-80AF-BB6FF98147C3">
                     <p class="notep1">注意：</p>您可以修改其他<code class="codeph">SSLClient*</code>应用程序的<code class="codeph">GET</code>命令连接到正在运行的本地计算机<code class="codeph">ClassFileServer</code> 。
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>