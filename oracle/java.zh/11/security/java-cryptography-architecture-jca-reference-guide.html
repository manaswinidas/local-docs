<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <meta name="description" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <title>Java Cryptography Architecture (JCA) Reference Guide</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="troubleshooting-security.html" title="Previous" type="text/html">
      <link rel="next" href="howtoimplaprovider.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="troubleshooting-security.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="howtoimplaprovider.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java密码体系结构（JCA）参考指南</li>
            </ol>
            <a id="GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" name="GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190"></a>
            
            <h2 id="JSSEC-GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" class="sect2"><span class="enumeration_chapter">2</span> Java密码体系结构（JCA）参考指南</h2>
         </header>
         <div class="ind">
            <div>
               <p>Java密码体系结构（JCA）是该平台的主要组成部分，包含“提供程序”体系结构和一组API，用于数字签名，消息摘要（哈希），证书和证书验证，加密（对称/非对称块/流）密码），密钥生成和管理以及安全的随机数生成（仅举几例）。</p>
            </div>
            <div class="sect2"><a id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231" name="GUID-815542FE-CF3D-407A-9673-CAE9840F6231"></a><h3 id="JSSEC-GUID-815542FE-CF3D-407A-9673-CAE9840F6231" class="sect3">Java密码学体系结构简介</h3>
               <div>
                  <p>Java平台特别强调安全性，包括语言安全性，加密技术，公钥基础结构，身份验证，安全通信和访问控制。</p>
                  <p>JCA是该平台的主要部分，包含一个“提供程序”体系结构和一组API，用于数字签名，消息摘要（哈希），证书和证书验证，加密（对称/非对称块/流密码），密钥生成和管理，以及安全的随机数生成，仅举几例。这些API使开发人员可以轻松地将安全性集成到其应用程序代码中。该体系结构是围绕以下原则设计的：</p>
                  <ul style="list-style-type:disc">
                     <li> 
                        <p><span class="bold">实现独立性</span> ：应用程序不需要实现安全算法。相反，他们可以从Java平台请求安全服务。安全性服务是在提供程序中实现的（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">Cryptographic Service Providers</a> ），这些<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">提供程序</a>通过标准接口插入到Java平台中。一个应用程序可能依赖多个独立的提供程序来提供安全功能。
                        </p> 
                     </li>
                     <li> 
                        <p><span class="bold">实现互操作性</span> ：提供程序可跨应用程序互操作。具体而言，应用程序未绑定到特定的提供程序，并且提供程序也未绑定到特定的应用程序。
                        </p> 
                     </li>
                     <li> 
                        <p><span class="bold">算法可扩展性</span> ：Java平台包括许多内置提供程序，这些提供程序实现了当今广泛使用的一组基本安全服务。但是，某些应用程序可能依赖于尚未实施的新兴标准或专有服务。Java平台支持安装实现此类服务的自定义提供程序。
                        </p> 
                     </li>
                  </ul>
                  <p>JDK中可用的其他密码通信库使用JCA提供程序体系结构，但在其他地方有描述。JSSE组件提供对安全套接字层（SSL），传输层安全性（TLS）和数据报传输层安全性（DTLS）实现的访问。请参阅《 <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" title="Java安全套接字扩展（JSSE）支持安全的Internet通信。它为TLS和DTLS协议的Java版本提供了框架和实现，并包括数据加密，服务器身份验证，消息完整性和可选的客户端身份验证的功能。">Java安全套接字扩展（JSSE）参考指南》</a> 。您可以使用Java通用安全服务（JGSS）（通过Kerberos）API和简单身份验证和安全层（SASL）在通信的应用程序之间安全地交换消息。请参阅<a href="introduction-jaas-and-java-gss-api-tutorials1.html">《 JAAS和Java GSS-API教程简介》</a>和《 <a href="java-sasl-api-programming-and-deployment-guide1.html#GUID-6D78EE33-62E6-4D85-9695-322EED493F72">Java SASL API编程和部署指南》</a> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231__GUID-66BC8EAA-E1BC-42DA-BBC5-BF6BCF8E75B0">术语说明</p>
                     <ul style="list-style-type:disc">
                        <li> 
                           <p>在JDK 1.4之前，JCE是非捆绑产品，因此，JCA和JCE通常被称为独立的不同组件。由于JCE现在捆绑在JDK中，因此区别变得不那么明显了。由于JCE使用与JCA相同的体系结构，因此应该更恰当地将JCE视为JCA的一部分。</p> 
                        </li>
                        <li> 
                           <p>JDK中的JCA包括两个软件组件：</p> 
                           <ul style="list-style-type:disc">
                              <li>定义和支持提供者为其提供实现的加密服务的框架。该框架包括以下软件包： <code class="codeph">java.security</code> ， <code class="codeph">javax.crypto</code> ， <code class="codeph">javax.crypto.spec</code>和<code class="codeph">javax.crypto.interfaces</code> 。
                              </li>
                              <li>实际的提供者如<code class="codeph">Sun</code> ， <code class="codeph">SunRsaSign</code> ， <code class="codeph">SunJCE</code> ，其中包含实际的加密实现。
                              </li>
                           </ul>
                           <p>每当提及特定的JCA提供程序时，将通过提供程序的名称显式地引用它。</p> 
                        </li>
                     </ul>
                     <div class="infoboxnotewarn" id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231__GUID-4604E723-D0C5-432A-B831-F3D6B61C1614">
                        <p class="notep1">警告：</p>通过JCA，可以轻松地将安全功能集成到应用程序中。但是，除了对讨论API所必需的概念进行基本介绍之外，本文档并未涵盖安全性/密码学理论。本文档也没有涵盖特定算法的优势/劣势，也没有涵盖协议设计。密码术是一门高级主题，应充分参考（最好是近期参考）以便最好地利用这些工具。
                        <p>您应该始终了解自己在做什么以及原因：不要简单地复制随机代码并期望它完全解决您的使用情况。由于选择了错误的工具或算法，已部署了许多包含严重安全性或性能问题的应用程序。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-71693272-7F57-4155-99F9-A2139271FD6D" name="GUID-71693272-7F57-4155-99F9-A2139271FD6D"></a><h4 id="JSSEC-GUID-71693272-7F57-4155-99F9-A2139271FD6D" class="sect4">JCA设计原则</h4>
                  <div>
                     <p>JCA的设计遵循以下原则：</p>
                     <ul style="list-style-type:disc">
                        <li>实现独立性和互操作性</li>
                        <li>算法独立性和可扩展性</li>
                     </ul>
                     <p>实现独立性和算法独立性是互补的；您可以使用加密服务，例如数字签名和消息摘要，而不必担心实现细节或什至构成这些概念基础的算法。尽管不可能完全独立于算法，但JCA提供了标准化的，特定于算法的API。当不需要实现独立性时，JCA允许开发人员指示特定的实现。</p>
                     <p>通过定义密码“引擎”（服务）的类型，并定义提供这些密码引擎功能的类，可以实现算法独立性。这些类称为<span class="variable" translate="no">engine classes</span> ，示例包括<a href="https://docs.oracle.com/javase/10/docs/api/java/security/MessageDigest.html" target="_blank"><span class="apiname">MessageDigest</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/java/security/Signature.html" target="_blank"><span class="apiname">Signature</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyFactory.html" target="_blank"><span class="apiname">KeyFactory</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyPairGenerator.html" target="_blank"><span class="apiname">KeyPairGenerator</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/Cipher.html" target="_blank"><span class="apiname">Cipher</span></a>类。
                     </p>
                     <p>使用基于“提供商”的体系结构可实现实现独立性。术语“加密服务提供者（CSP）”与术语“提供者”可互换使用（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">加密服务提供者</a> ）是指实现一个或多个加密服务（例如，数字签名算法，消息摘要）的一个包或一组包。算法和密钥转换服务。程序可以简单地请求特定类型的对象（例如<code class="codeph">Signature</code>对象）来实现特定服务（例如DSA签名算法），并从已安装的提供程序之一获取实现。如果需要，程序可以代替地请求特定提供者的实现。例如，当可以使用更快或更安全的版本时，可以对应用程序透明地更新提供程序。
                     </p>
                     <p>实现互操作性意味着各种实现可以相互协作，使用彼此的密钥或验证彼此的签名。例如，这将意味着，对于相同的算法，由一个提供程序生成的密钥将可由另一提供程序使用，而由一个提供程序生成的签名将可由另一提供程序验证。</p>
                     <p>算法可扩展性意味着可以轻松添加适合其中一种支持的引擎类的新算法。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859" name="GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859"></a><h4 id="JSSEC-GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859" class="sect4">提供者架构</h4>
                  <div>
                     <p>提供程序包含一个（或一组）软件包，这些软件包为广告加密算法提供了具体的实现。</p>
                  </div>
                  <div class="sect4"><a id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920" name="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920"></a><h5 id="JSSEC-GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920" class="sect5">加密服务提供商</h5>
                     <div>
                        <p><code class="codeph">java.security.Provider</code>是所有安全提供程序的基类。每个CSP都包含一个此类的实例，该实例包含提供者的名称并列出其实现的所有安全服务/算法。当需要特定算法的实例时，JCA框架将查询提供者的数据库，并且如果找到合适的匹配项，则会创建该实例。
                        </p>
                        <p>提供程序包含一个（或一组）软件包，这些软件包为广告加密算法提供了具体的实现。默认情况下，每个JDK安装都安装和配置了一个或多个提供程序。可以静态或动态添加其他提供程序。客户端可以配置其运行时环境以指定提供程序<span class="variable" translate="no">preference order</span> 。优先顺序是当没有特定提供者被请求时，在提供者中搜索请求的服务的顺序。
                        </p>
                        <p>要使用JCA，应用程序只需请求特定类型的对象（例如<code class="codeph">MessageDigest</code> ）和特定的算法或服务（例如“ SHA-256”算法），并从已安装的提供程序之一获取实现。例如，以下语句请求已安装的提供程序的SHA-256消息摘要：</p><pre class="codeblock"><code>    md = MessageDigest.getInstance("SHA-256");
</code></pre><p>或者，程序可以向特定提供者请求对象。每个提供程序都有一个用来引用它的名称。例如，以下语句从名为ProviderC的提供程序请求SHA-256消息摘要：</p><pre class="codeblock"><code>    md = MessageDigest.getInstance("SHA-256", "ProviderC");
</code></pre><p>下图说明了请求SHA-256消息摘要实现。它们显示了三个实现不同消息摘要算法（SHA-256，SHA-384和SHA-512）的提供程序。提供者按优先级从左到右（1-3）排序。在<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTIMPLEMEN-0606134F">图2-1中</a> ，应用程序在<span class="bold">不</span>指定提供程序名称的情况<span class="bold">下</span>请求SHA-256算法的实现。按优先顺序搜索提供者，并从提供该特定算法ProviderB的第一个提供者返回实现。在<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTWITHPROV-CB5635FE">图2-2中</a> ，应用程序<span class="bold">从特定的提供</span>程序ProviderC请求SHA-256算法的实现。这次，即使具有较高优先级顺序的提供者ProviderB也提供了MD5实现，也将返回ProviderC的实现。
                        </p>
                        <div class="figure" id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTIMPLEMEN-0606134F">
                           <p class="titleinfigure">图2-1请求SHA-256消息摘要实现而未指定提供程序</p><br><img src="img/security-overview-message-digest-wo-provider.png" alt="如下图2-1所示" title="如下图2-1所示" longdesc="img_text/security-overview-message-digest-wo-provider.html"><br><a href="img_text/security-overview-message-digest-wo-provider.html">“图2-1请求SHA-256消息摘要实现而未指定提供者”的描述</a><br></div>
                        <!-- class="figure" -->
                        <div class="figure" id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTWITHPROV-CB5635FE">
                           <p class="titleinfigure">图2-2使用ProviderC请求SHA-256消息摘要</p><br><img src="img/security-overview-message-digest-providerc.png" alt="如下图2-2所示" title="如下图2-2所示" longdesc="img_text/security-overview-message-digest-providerc.html"><br><a href="img_text/security-overview-message-digest-providerc.html">“图2-2使用ProviderC请求SHA-256消息摘要”的描述</a><br></div>
                        <!-- class="figure" -->
                        <p>JDK中的加密实现是通过几个不同的提供程序（ <code class="codeph">Sun</code> ， <code class="codeph">SunJSSE</code> ， <code class="codeph">SunJCE</code> ， <code class="codeph">SunRsaSign</code> ），主要是出于历史原因，但在较小程度上取决于它们提供的功能和算法的类型。其他Java运行时环境可能不一定包含这些提供程序，因此除非知道特定的提供程序可用，否则应用程序不应请求特定于提供程序的实现。
                        </p>
                        <p>JCA提供了一组API，这些API允许用户查询安装了哪些提供程序以及他们支持哪些服务。</p>
                        <p>这种体系结构还使最终用户可以轻松添加其他提供程序。许多第三方提供程序实现已经可用。有关如何编写，安装和注册<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" title="In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (SUN, SunJCE, SunJSSE, SunRsaSign, etc.) that are already installed and registered. The following sections describe how to install and register additional providers.Each Provider class instance has a (currently case-sensitive) name, a version number, and a string description of the provider and its services.">提供程序</a>的更多信息，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" title="为了使用，必须先安装密码提供程序，然后静态或动态注册。此版本附带有许多Sun提供程序（SUN，SunJCE，SunJSSE，SunRsaSign等）已安装并注册。以下各节描述了如何安装和注册其他提供程序。每个提供程序类实例都有一个（当前区分大小写）名称，版本号以及提供程序及其服务的字符串描述。">提供程序类</a> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FD5163BD-E113-4B9D-A230-11184A668616" name="GUID-FD5163BD-E113-4B9D-A230-11184A668616"></a><h5 id="JSSEC-GUID-FD5163BD-E113-4B9D-A230-11184A668616" class="sect5">提供商的实际实施方式</h5>
                     <div>
                        <p><span class="variable" translate="no">Algorithm independence</span>是通过定义所有应用程序用来访问服务类型的通用高级应用程序编程接口（API）来实现的。通过使所有提供程序实现均符合定义良好的接口，可以实现<span class="variable" translate="no">Implementation independence</span> 。因此，引擎类的实例由具有相同方法签名的实现类“支持”。应用程序调用通过引擎类进行路由，并传递给基础支持实现。该实现将处理请求并返回正确的结果。
                        </p>
                        <div class="section">
                           <p>每个引擎类中的应用程序API方法通过实现相应服务提供者接口（SPI）的类路由到提供者的实现。也就是说，对于每个引擎类，都有一个对应的抽象SPI类，该类定义了每个密码服务提供者的算法必须实现的方法。每个SPI类的名称与相应引擎类的名称相同，后跟<code class="codeph">Spi</code> 。例如， <code class="codeph">Signature</code>引擎类提供对数字签名算法功能的访问。实际的提供程序实现在以下子类中提供<code class="codeph">SignatureSpi</code> 。应用程序调用引擎类的API方法，然后在实际实现中依次调用SPI方法。
                           </p>
                           <p>每个SPI类都是抽象的。为了为特定算法提供特定类型服务的实现，提供程序必须子类化对应的SPI类，并提供所有抽象方法的实现。</p>
                           <p>对于API中的每个引擎类，通过调用引擎类中的<span class="apiname">getInstance（）</span> <span class="variable" translate="no">factory method</span>来请求并实例化实现实例。工厂方法是返回类实例的静态方法。引擎类使用上述框架提供者选择机制来获取实际的支持实现（SPI），然后创建实际的引擎对象。引擎类的每个实例封装（作为私有字段）相应的SPI类的实例（称为SPI对象）。API对象的所有API方法都声明为final，并且其实现调用封装的SPI对象的相应SPI方法。
                           </p>
                           <p>为了使这一点更加清楚，请查看<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FD5163BD-E113-4B9D-A230-11184A668616__SAMPLECODEFORGETTINGANINSTANCEOFANE-724746B9">示例2-1</a>和<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FD5163BD-E113-4B9D-A230-11184A668616__GUID-F8F97C84-B042-4576-B56D-1FD217F20400">图2-3</a> ：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-FD5163BD-E113-4B9D-A230-11184A668616__SAMPLECODEFORGETTINGANINSTANCEOFANE-724746B9">
                           <p class="titleinexample">示例2-1获取引擎类实例的示例代码</p><pre class="codeblock"><code>
    import javax.crypto.*;

    Cipher c = Cipher.getInstance("AES");
    c.init(ENCRYPT_MODE, key);
</code></pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="figure" id="GUID-FD5163BD-E113-4B9D-A230-11184A668616__GUID-F8F97C84-B042-4576-B56D-1FD217F20400">
                              <p class="titleinfigure">图2-3应用程序检索“ AES”密码实例</p><img src="img/aes-cipher.gif" alt="如下图2-3所示" title="如下图2-3所示" longdesc="img_text/aes-cipher.html"><br><a href="img_text/aes-cipher.html">“图2-3应用程序检索“ AES”密码实例”的说明</a></div>
                           <!-- class="figure" -->
                           <p>这里的应用程序需要一个“ AES” <code class="codeph">javax.crypto.Cipher</code>实例，并且不关心使用哪个提供程序。该应用程序调用<code class="codeph">getInstance()</code>的工厂方法<code class="codeph">Cipher</code>引擎类，该类依次要求JCA框架找到支持“ AES”的第一个提供程序实例。该框架会咨询每个已安装的提供程序，并获取该提供程序的实例。 <code class="codeph">Provider</code>类。（回想一下<code class="codeph">Provider</code>类是可用算法的数据库。）该框架搜索每个提供程序，最后在CSP3中找到合适的条目。该数据库条目指向实现类<code class="codeph">com.foo.AESCipher</code>延伸<code class="codeph">CipherSpi</code> ，因此适合由<code class="codeph">Cipher</code>引擎类。的实例<code class="codeph">com.foo.AESCipher</code>被创建，并封装在新创建的<code class="codeph">javax.crypto.Cipher</code> ，这将返回给应用程序。现在，应用程序在以下位置执行<span class="apiname">init（）</span>操作时： <code class="codeph">Cipher</code>例如， <code class="codeph">Cipher</code>引擎类将请求路由到相应的<span class="apiname">engineInit（）</span>支持方法中<code class="codeph">com.foo.AESCipher</code>类。
                           </p> <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>列出了为Java环境定义的标准名称。其他第三方提供程序可能会定义自己的这些服务甚至附加服务的实现。
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1" name="GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1"></a><h5 id="JSSEC-GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1" class="sect5">密钥库</h5>
                     <div>
                        <p>可以使用称为“密钥库”的数据库来管理密钥和证书的存储库。密钥库可用于需要数据进行身份验证，加密或签名的应用程序。</p>
                        <p>应用程序可以通过<code class="codeph">KeyStore</code>类，在<code class="codeph">java.security</code>包。从JDK 9开始，默认和推荐的密钥库类型（格式）为“ pkcs12”，它基于RSA PKCS12个人信息交换语法标准。以前，默认密钥库类型为“ jks”，这是专有格式。还可以使用其他密钥库格式，例如“ jceks”（这是替代的专有密钥库格式）和“ pkcs11”，其基于RSA PKCS11标准并支持对加密令牌的访问，例如硬件安全模块和智能卡。
                        </p>
                        <p>应用程序可以使用前面描述的相同提供程序机制从不同提供程序中选择不同的密钥库实现。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" title="一个名为a的数据库" keystor="=" ="">密钥管理</a> 。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" name="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212"></a><h4 id="JSSEC-GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" class="sect4">引擎类别和算法</h4>
                  <div>
                     <p>引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。</p>
                     <p>引擎提供以下之一：</p>
                     <ul style="list-style-type:disc">
                        <li>加密操作（加密，数字签名，消息摘要等），</li>
                        <li>加密材料（密钥和算法参数）的生成器或转换器，或</li>
                        <li>封装了加密数据的对象（密钥库或证书），可以在更高的抽象层使用。</li>
                     </ul>
                     <p>可以使用以下引擎类：</p>
                     <ul style="list-style-type:disc">
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36"><code class="codeph">SecureRandom</code></a> ：用于生成随机或伪随机数。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" title="创建MessageDigest对象的过程。更新消息摘要对象的过程。使用不同类型的digest（）方法计算摘要的过程。"><code class="codeph">MessageDigest</code></a> ：用于计算指定数据的消息摘要（哈希）。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" title="签名对象是模式对象。这意味着Signature对象始终处于给定状态，在该状态下它只能执行一种类型的操作。签名或验证签名的第一步是创建一个签名实例。使用签名对象之前，必须对其进行初始化。初始化方法取决于对象将用于签名还是用于验证。"><code class="codeph">Signature</code></a> ：使用密钥初始化，用于签名数据和验证数字签名。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566"><code class="codeph">Cipher</code></a> ：使用密钥初始化，这些密钥用于加密/解密数据。有多种算法：对称批量加密（例如AES），非对称加密（例如RSA）和基于密码的加密（例如PBE）。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" title="类似于MessageDigest，消息身份验证代码（MAC）提供了一种方法来检查通过不可靠介质传输或存储在不可靠介质中的信息的完整性，但在计算中包括密钥。">消息验证码（MAC）</a> ：类似<code class="codeph">MessageDigest</code> ，它们还会生成哈希值，但首先使用密钥进行初始化以保护消息的完整性。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A"><code class="codeph">KeyFactory</code></a> ：用于转换现有的不透明类型的加密密钥<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。"><code class="codeph">Key</code></a>转换成关键规范（底层关键材料的透明表示），反之亦然。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5E8F4099-779F-4484-9A95-F1CEA167601A"><code class="codeph">SecretKeyFactory</code></a> ：用于转换现有的不透明类型的加密密钥<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。"><code class="codeph">SecretKey</code></a>转换成关键规范（底层关键材料的透明表示），反之亦然。 <code class="codeph">SecretKeyFactory</code> s是专业的<code class="codeph">KeyFactory</code>仅创建秘密（对称）密钥的。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD"><code class="codeph">KeyPairGenerator</code></a> ：用于生成适用于指定算法的一对新的公钥和私钥。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" title="密钥生成器用于生成对称算法的秘密密钥。"><code class="codeph">KeyGenerator</code></a> ：用于生成用于指定算法的新密钥。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" title="密钥协商是一种协议，通过该协议，两个或更多方可以建立相同的加密密钥，而不必交换任何秘密信息。"><code class="codeph">KeyAgreement</code></a> ：由两个或两个以上的各方用来达成共识并建立用于特定加密操作的特定密钥。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" title="与键和键规范一样，算法的初始化参数由AlgorithmParameters或AlgorithmParameterSpecs表示。"><code class="codeph">AlgorithmParameters</code></a> ：用于存储特定算法的参数，包括参数编码和解码。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C"><code class="codeph">AlgorithmParameterGenerator</code></a> ：用于生成适用于指定算法的一组AlgorithmParameters。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09050137-31F1-468A-A552-B051A4E35876" title="KeyStore类提供了定义明确的接口来访问和修改密钥库中的信息。"><code class="codeph">KeyStore</code></a> ：用于创建和管理<span class="variable" translate="no">keystore</span> 。密钥库是密钥的数据库。密钥库中的私钥具有与其关联的证书链，该证书链对相应的公钥进行身份验证。密钥库还包含来自受信任实体的证书。
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" title="CertificateFactory类定义证书工厂的功能，该功能用于从其编码生成证书和证书吊销列表（CRL）对象。"><code class="codeph">CertificateFactory</code></a> ：用于创建公钥证书和证书吊销列表（CRL）。
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="CertPathBuilder类是用于构建认证路径的引擎类。"><code class="codeph">CertPathBuilder</code></a> ：用于构建证书链（也称为证书路径）。
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="CertPathValidator类是用于验证证书路径的引擎类。"><code class="codeph">CertPathValidator</code></a> ：用于验证证书链。
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" title="CertStore类是引擎类，用于提供证书和证书吊销列表（CRL）存储库的功能。"><code class="codeph">CertStore</code></a> ：用于检索<code class="codeph">Certificate</code>和<code class="codeph">CRL</code>来自存储库。
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212__GUID-4ADAF14D-B1E3-451D-9708-F21608DCC42A">
                        <p class="notep1">注意：</p><span class="variable" translate="no">generator</span>创建具有全新内容的对象，而<span class="variable" translate="no">factory</span>使用现有材料（例如，编码）创建对象。
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F" name="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F"></a><h3 id="JSSEC-GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F" class="sect3">核心类和接口</h3>
               <div>
                  <p>以下是JCA中提供的核心类和接口。</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">Provider</code>和<code class="codeph">Security</code></li>
                     <li><code class="codeph">SecureRandom</code> ， <code class="codeph">MessageDigest</code> ， <code class="codeph">Signature</code> ， <code class="codeph">Cipher</code> ， <code class="codeph">Mac</code> ， <code class="codeph">KeyFactory</code> ， <code class="codeph">SecretKeyFactory</code> ， <code class="codeph">KeyPairGenerator</code> ， <code class="codeph">KeyGenerator</code> ， <code class="codeph">KeyAgreement</code> ， <code class="codeph">AlgorithmParameter</code> ， <code class="codeph">AlgorithmParameterGenerator</code> ， <code class="codeph">KeyStore</code> ， <code class="codeph">CertificateFactory</code>和引擎</li>
                     <li><code class="codeph">Key Interface</code> ，<code class="codeph">KeyPair</code></li>
                     <li><code class="codeph">AlgorithmParameterSpec Interface</code> ， <code class="codeph">AlgorithmParameters</code> ， <code class="codeph">AlgorithmParameterGenerator</code>以及算法参数规范中的接口和类<code class="codeph">java.security.spec</code>和<code class="codeph">javax.crypto.spec</code>包。
                     </li>
                     <li><code class="codeph">KeySpec Interface</code> ， <code class="codeph">EncodedKeySpec</code> ， <code class="codeph">PKCS8EncodedKeySpec</code>和<code class="codeph">X509EncodedKeySpec</code> 。
                     </li>
                     <li><code class="codeph">SecretKeyFactory</code> ， <code class="codeph">KeyFactory</code> ， <code class="codeph">KeyPairGenerator</code> ， <code class="codeph">KeyGenerator</code> ， <code class="codeph">KeyAgreement</code>和<code class="codeph">KeyStore</code> 。
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F__GUID-81034E79-9AB1-4E97-8EEA-5129FDBB3183">
                     <p class="notep1">注意：</p>看到<code class="codeph">CertPathBuilder</code> ， <code class="codeph">CertPathValidator</code>和<code class="codeph">CertStore</code> <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="Java认证路径API由用于处理认证路径的类和接口组成，这些类和接口也称为认证链。如果认证路径满足某些验证规则，则可以使用它来安全地建立公共密钥到主题的映射。">Java PKI程序员指南</a>中的引擎类。
                  </div>
                  <p>该指南将首先涵盖最有用的高级类（提供者，安全性，SecureRandom，MessageDigest，签名，密码和Mac），然后深入探讨各种支持类。就目前而言，简单地说密钥（公共，私有和秘密）是由各种JCA类生成和表示的，并由高级类用作其操作的一部分就足够了。</p>
                  <p>本节显示每个类和接口中主要方法的签名。相应的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-871FA938-5110-409E-A4EC-16F2A898093A">“代码示例”</a>部分提供了其中一些类的示例（MessageDigest，Signature，KeyPairGenerator，SecureRandom，KeyFactory和密钥规范类）。
                  </p>
                  <p>有关安全性API软件包的完整参考文档可在软件包摘要中找到：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/package-summary.html" target="_blank"><code class="codeph">java.security</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/package-summary.html" target="_blank"><code class="codeph">javax.crypto</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/package-summary.html" target="_blank"><code class="codeph">java.security.cert</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/package-summary.html" target="_blank"><code class="codeph">java.security.spec</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/package-summary.html" target="_blank"><code class="codeph">javax.crypto.spec</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/package-summary.html" target="_blank"><code class="codeph">java.security.interfaces</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/package-summary.html" target="_blank"><code class="codeph">javax.crypto.interfaces</code></a></li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" name="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307"></a><h4 id="JSSEC-GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" class="sect4">提供者类别</h4>
                  <div>
                     <p>术语“加密服务提供者”（与本文档中的“提供者”互换使用）是指一个包或一组包，它们提供JDK安全API密码功能子集的具体实现。的<code class="codeph">Provider</code> <span class="italic">class</span>是此类软件包或一组软件包的接口。它具有访问提供程序名称，版本号和其他信息的方法。请注意，除了注册加密服务的实现外， <code class="codeph">Provider</code>该类还可以用于注册其他安全服务的实现，这些实现可能被定义为JDK安全API或其扩展之一。
                     </p>
                     <p>为了提供加密服务的实现，实体（例如，开发组）编写实现代码并创建密码服务的子类。 <code class="codeph">Provider</code>类。的构造函数<code class="codeph">Provider</code>子类设置各种属性的值； JDK Security API使用这些值来查找提供程序实现的服务。换句话说，子类指定实现服务的类的名称。
                     </p>
                     <div class="figure" id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307__GUID-DA3FDF88-BB48-44FA-A992-70FB7CA08DBF">
                        <p class="titleinfigure">图2-4提供程序类</p><img src="img/provider.png" alt="如下图2-4所示" title="如下图2-4所示" longdesc="img_text/provider.html"><br><a href="img_text/provider.html">“图2-4提供程序类”的描述</a></div>
                     <!-- class="figure" -->
                     <p>提供程序包可以实现几种类型的服务。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。
                     </p>
                     <p>不同的实现可以具有不同的特征。一些可能基于软件，而另一些可能基于硬件。一些可能与平台无关，而另一些可能与平台有关。某些提供程序的源代码可能可供查看和评估，而另一些则没有。JCA允许最终用户和开发人员确定他们的需求。</p>
                     <p>您可以找到有关最终用户如何安装适合其需求的加密实现以及开发人员如何请求适合其需求的实现的信息。</p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307__GUID-8FA29B58-275F-40EE-B871-31BAF7A54250">
                           <p class="notep1">注意：</p>要实现提供程序，请参阅<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">实现和集成提供程序的步骤</a> 。
                        </div> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741" name="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741"></a><h5 id="JSSEC-GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741" class="sect5">如何请求和提供提供商实现</h5>
                     <div>
                        <div class="section">
                           <p>对于API中的每个引擎类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> ），通过调用引擎类上的<span class="apiname">getInstance</span>方法之一，指定所需算法的名称以及提供者的名称，来请求并实例化实现实例。 （或者<code class="codeph">Provider</code>类）。
                           </p><pre class="codeblock"><code>
static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm)
    throws NoSuchAlgorithmException

static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm, String provider)
    throws NoSuchAlgorithmException, NoSuchProviderException

static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm, Provider provider)
    throws NoSuchAlgorithmException
</code></pre><p>哪里</p>
                           <p><span class="italic">EngineClassName</span></p>
                           <p>是所需的引擎类型（MessageDigest / Cipher / etc）。例如：</p><pre class="codeblock"><code>
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    KeyAgreement ka = KeyAgreement.getInstance("DH", "SunJCE");
</code></pre><p>分别返回“ SHA-256” MessageDigest和“ DH” KeyAgreement对象的实例。</p>
                           <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全性标准算法名称</a>包含已被标准化用于Java环境的名称列表。一些提供程序可能会选择也包含别名名称，这些别名也引用相同的算法。例如，“ SHA256”算法可能称为“ SHA-256”。应用程序应使用标准名称而不是别名，因为并非所有提供程序都可以以相同的方式别名算法名称。
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741__GUID-123854F3-B43E-4650-8BB4-BF14004B3468">
                                 <p class="notep1">注意：</p>算法名称不区分大小写。例如，以下所有调用都是等效的：<pre class="codeblock"><code>
MessageDigest.getInstance("SHA256")
MessageDigest.getInstance("sha256")
MessageDigest.getInstance("sHa256")
</code></pre></div>
                           </div>
                           <p>如果未指定提供者， <code class="codeph">getInstance</code>在注册的提供程序中搜索与命名算法关联的请求的加密服务的实现。在任何给定的Java虚拟机（JVM）中，将按给定的<span class="variable" translate="no">preference order</span>安装提供程序，如果未请求特定的提供程序，则将按搜索顺序搜索提供程序列表。（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" title="为了使用，必须先安装密码提供程序，然后静态或动态注册。此版本附带有许多Sun提供程序（SUN，SunJCE，SunJSSE，SunRsaSign等）已安装并注册。以下各节描述了如何安装和注册其他提供程序。">安装提供程序</a> 。）例如，假设在JVM中安装了两个提供程序， <code class="codeph">PROVIDER_1</code>和<code class="codeph">PROVIDER_2</code> 。假使，假设：</p>
                           <ul style="list-style-type:disc">
                              <li><code class="codeph">PROVIDER_1</code>实现SHA-256和DESede。 <code class="codeph">PROVIDER_1</code>优先顺序为1（最高优先级）。
                              </li>
                              <li><code class="codeph">PROVIDER_2</code>实现SHA256withDSA，SHA-256，RC5和RSA。 <code class="codeph">PROVIDER_2</code>优先顺序为2。
                              </li>
                           </ul>
                           <p>现在让我们看一下三种情况：</p>
                           <ol>
                              <li>如果我们正在寻找SHA-256实现。两家提供商都提供了这样的实现。的<code class="codeph">PROVIDER_1</code>实现返回，因为<code class="codeph">PROVIDER_1</code>优先级最高，并且首先搜索。
                              </li>
                              <li>如果我们正在寻找SHA256withDSA签名算法， <code class="codeph">PROVIDER_1</code>首先被搜索。找不到实现，因此<code class="codeph">PROVIDER_2</code>被搜索。由于找到了实现，因此将其返回。
                              </li>
                              <li>假设我们正在寻找一种SHA256withRSA签名算法。由于没有安装的提供程序实现，因此<code class="codeph">NoSuchAlgorithmException</code>被抛出。
                              </li>
                           </ol>
                           <p>包含提供者参数的<span class="apiname">getInstance</span>方法适用于想要指定要从中提供算法的提供者的开发人员。例如，联邦机构将要使用已获得联邦认证的提供商实施。我们假设SHA256withDSA实现来自<code class="codeph">PROVIDER_1</code>尚未获得此类认证，而DSA实施<code class="codeph">PROVIDER_2</code>已经收到了。
                           </p>
                           <p>然后，联邦机构计划将进行以下通话，具体说明<code class="codeph">PROVIDER_2</code>由于它具有经过认证的实现：</p><pre class="codeblock"><code>Signature dsa = Signature.getInstance("SHA256withDSA", "PROVIDER_2");
</code></pre><p>在这种情况下<code class="codeph">PROVIDER_2</code>没有安装，一个<code class="codeph">NoSuchProviderException</code>即使另一个安装的提供程序实现了所请求的算法，也将抛出该错误。
                           </p>
                           <p>程序还可以选择获取所有已安装的提供程序的列表（使用<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA">“安全类”</a>类中的<span class="apiname">getProviders</span>方法），然后从列表中选择一个。
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741__GUID-8A66CE47-C14C-4CBC-BA2E-E5BAAFBF9477">
                                 <p class="notep1">注意：</p>通用应用程序<span class="bold">不应</span>从特定提供商那里请求加密服务。否则，应用程序将绑定到其他Java实现上可能无法使用的特定提供程序。他们可能也无法利用优先级高于特定请求提供者的可用优化提供者（例如，通过PKCS11的硬件加速器或Microsoft MSCAPI之类的本机OS实现）。
                              </div> 
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" name="GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007"></a><h5 id="JSSEC-GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" class="sect5">安装提供程序</h5>
                     <div>
                        <p>为了使用，必须先安装密码提供程序，然后静态或动态注册。此版本附带了许多Sun提供程序（ <code class="codeph">SUN</code> ， <code class="codeph">SunJCE</code> ， <code class="codeph">SunJSSE</code> ， <code class="codeph">SunRsaSign</code>等）已安装并注册。以下各节描述了如何安装和注册其他提供程序。
                        </p>
                        <p>所有JDK提供程序均已安装并注册。但是，如果您需要任何第三方提供程序，请参阅<a href="howtoimplaprovider.html#GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" title="The next steps describe how to install and configure your new provider so that it is available via the JCA.">步骤8：</a>从<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">实现和集成提供程序的步骤</a> <a href="howtoimplaprovider.html#GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" title="后续步骤描述了如何安装和配置新的提供程序，以便可以通过JCA使用它。">准备测试</a> ， <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">以</a>获取有关如何将提供程序添加到类或模块路径，注册提供程序（静态或动态）以及添加的信息。任何必需的权限。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8" name="GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8"></a><h5 id="JSSEC-GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8" class="sect5">提供者类方法</h5>
                     <div>
                        <p>每<code class="codeph">Provider</code>类实例具有（当前区分大小写）名称，版本号以及提供程序及其服务的字符串描述。
                        </p>
                        <div class="section">
                           <p>您可以查询<code class="codeph">Provider</code>通过调用以下方法获取此信息的实例：</p><pre class="codeblock"><code>
public String getName()
public double getVersion()
public String getInfo()
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA" name="GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA"></a><h4 id="JSSEC-GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA" class="sect4">安全等级</h4>
                  <div>
                     <p><span class="apiname">Security</span>类管理已安装的提供程序和安全范围的属性。它仅包含静态方法，并且不会实例化。添加或删除提供程序以及进行设置的方法<code class="codeph">Security</code>属性，只能由受信任的程序执行。目前，“受信任的程序”是</p>
                     <ul style="list-style-type:disc">
                        <li>不在安全管理器下运行的本地应用程序，或</li>
                        <li>具有执行指定方法权限的小程序或应用程序（请参见下文）。</li>
                     </ul>
                     <p>确定将代码视为可信的代码可以执行尝试的操作（例如，添加提供程序）要求为小程序授予该特定操作的适当权限。JDK安装的策略配置文件指定来自指定代码源的代码所允许的权限（哪些类型的系统资源访问）。（请参见下文以及“ <a href="permissions-jdk1.html#GUID-789089CA-8557-4017-B8B0-6899AD3BA18D">默认策略实现和策略文件语法”</a>以及“ <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc.html" target="_blank">Java安全体系结构规范”</a>文件。）
                     </p>
                     <p>通常认为执行的代码来自特定的“代码源”。代码源不仅包括代码所源自的位置（URL），而且还包括对与可能已用于对代码进行签名的私有密钥相对应的任何公共密钥的引用。代码源中的公钥由用户的（符号）别名来引用。</p>
                     <p>在策略配置文件中，代码源由两个组件表示：代码库（URL）和别名（以<code class="codeph">signedBy</code> ），其中别名表示包含必须用于验证代码签名的公共密钥的密钥库条目。
                     </p>
                     <p>这样的文件中的每个“ grant”语句都会向指定的代码源授予一组权限，以指定允许哪些操作。</p>
                     <p>这是一个示例策略配置文件：</p><pre class="codeblock"><code>grant codeBase "file:/home/sysadmin/", signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider";
    permission java.security.SecurityPermission "removeProvider";
    permission java.security.SecurityPermission "putProviderProperty.*";
};
</code></pre><p>此配置文件指定从签名的JAR文件中加载的代码<code class="codeph">/home/sysadmin/</code>本地文件系统上的目录可以添加或删除提供程序或设置提供程序属性。（请注意，可以使用别名引用的公钥来验证JAR文件的签名<code class="codeph">sysadmin</code>在用户的密钥库中。）。
                     </p>
                     <p>代码源的任何一个组件（或两者）都可能丢失。这是一个配置文件的示例，其中<code class="codeph">codeBase</code>省略：</p><pre class="codeblock"><code>
grant signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</code></pre><p>如果该政策有效，则JAR文件中的代码由签名<code class="codeph">/home/sysadmin/</code>本地文件系统上的目录可以添加或删除提供程序。该代码不需要签名。
                     </p>
                     <p>一个例子都没有<code class="codeph">codeBase</code>也不<code class="codeph">signedBy</code>包括的是：</p><pre class="codeblock"><code>
grant {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</code></pre><p>在这里，缺少两个代码源组件，任何代码（无论它起源于何处，是否已签名或由谁签名）都可以添加/删除提供程序。显然，绝对不建议这样做，因为此赠款可能会打开安全漏洞。不受信任的代码可能会安装提供程序，从而影响依赖正常运行的实现的更高版本的代码。（例如，流氓<code class="codeph">Cipher</code>对象可能会捕获并存储接收到的敏感信息。）
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90" name="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90"></a><h5 id="JSSEC-GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90" class="sect5">管理提供者</h5>
                     <div>
                        <p>下表总结了<code class="codeph">Security</code>您可以用来查询哪个类<code class="codeph">Provider</code>已安装，以及在运行时安装或删除提供程序。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-E1111DD9-08A0-42EC-8ACA-780019AF3E78">查询提供者</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-2846E40D-F447-42D0-99BE-7A7C18C69B62">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Methods to query installed Providers" frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1213">方法</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1215">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1219" headers="d30788e1213 "><code class="codeph">static Provider[] getProviders()</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1219 d30788e1215 ">返回包含所有已安装的提供程序的数组（从技术上讲， <code class="codeph">Provider</code>每个包提供者的子类）。的顺序<code class="codeph">Provider</code>数组中的s是他们的偏好顺序。
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1231" headers="d30788e1213 "><code class="codeph">static Provider getProvider (String providerName)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1231 d30788e1215 ">返回<code class="codeph">Provider</code>命名<code class="codeph">providerName</code> 。它返回<code class="codeph">null</code>如果<code class="codeph">Provider</code>找不到。
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-C75C8051-F384-44C8-8911-9A760A0B2C17">添加提供商</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-A7326F94-A51D-47F9-A638-D44E80710671">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Methods to add installed Providers " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1259">方法</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1261">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1265" headers="d30788e1259 "><code class="codeph">static int addProvider(Provider provider)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1265 d30788e1261 ">添加一个<code class="codeph">Provider</code>到已安装列表的末尾<code class="codeph">Provider</code> s。它返回首选项位置，其中<code class="codeph">Provider</code>已添加，或<code class="codeph">-1</code>如果<code class="codeph">Provider</code>未添加，因为已安装。
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1286" headers="d30788e1259 "><code class="codeph">static int insertProviderAt (Provider provider, int position)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1286 d30788e1261 ">新增一个<code class="codeph">Provider</code>在指定位置。如果给定的提供程序安装在请求的位置，则该提供程序以前位于该位置，并且所有位置大于<code class="codeph">position</code>向上移动一个位置（向列表末尾移动）。此方法返回首选项位置，其中<code class="codeph">Provider</code>已添加，或<code class="codeph">-1</code>如果<code class="codeph">Provider</code>未添加，因为已安装。
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-CA265A2C-A101-4984-AEED-DF429CE17688">删除提供者</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-B2A12498-B82E-48A3-8E2C-D2DE65AA3B61">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Methods to remove installed Providers " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1317">方法</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1319">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1323" headers="d30788e1317 "><code class="codeph">static void removeProvider(String name)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1323 d30788e1319 ">删除<code class="codeph">Provider</code>具有指定名称。如果未安装提供程序，它将以静默方式返回。删除指定的提供程序后，位于比指定的提供程序大的位置的所有提供程序都将下移一个位置（朝已安装的提供程序列表的开头）。
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnote" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-D4EE4FE3-379E-451D-BDAE-FAC97B332CC4">
                              <p class="notep1">注意：</p>如果要更改提供者的首选项位置，则必须先将其删除，然后再将其重新插入到新的首选项位置。
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E" name="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E"></a><h5 id="JSSEC-GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E" class="sect5">安全性</h5>
                     <div>
                        <p>的<code class="codeph">Security</code>该类维护系统范围的安全性列表。这些属性类似于<code class="codeph">System</code>属性，但与安全性相关。这些属性可以静态设置（通过<code><span class="variable" translate="no"><java-home></span>/conf/security/java.security</code>文件）或动态（使用API）。请参阅<a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">步骤8.1：</a>从<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">步骤</a> <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">配置提供程序</a> <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">以实现和集成提供程序</a> 。有关向静态注册提供者的示例<code class="codeph">security.provider.<span class="variable" translate="no">n</span></code>安全属性。如果要动态设置属性，则可信程序可以使用以下方法：</p><pre class="codeblock"><code>static String getProperty(String key)
static void setProperty(String key, String datum)
</code></pre><div class="infoboxnote" id="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E__GUID-35369CF0-AB08-463E-ACFC-DB1568B85F22">
                           <p class="notep1">注意：</p>安全提供程序列表是在VM启动过程中建立的。因此，必须使用上述方法来更改提供者列表。
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36" name="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36"></a><h4 id="JSSEC-GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36" class="sect4">SecureRandom类</h4>
                  <div>
                     <p>SecureRandom类是一种引擎类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> ），通过访问伪随机数生成器（PRNG）（一种确定性算法，该算法从初始种子值生成伪随机序列）来提供具有加密强度的随机数，或通过阅读本机随机性来源（例如， <code>/dev/random</code>或真正的随机数生成器）。PRNG的一个示例是<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf" target="_blank">NIST SP 800-90Ar1中</a>指定的确定性随机位生成器（DRBG）。其他实现可能会产生真正的随机数，而其他实现可能会同时使用这两种技术。加密强度高的随机数至少要符合<a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf" target="_blank">FIPS 140-2“加密模块的安全性要求”</a>第4.9.1节中指定的统计随机数生成器测试。
                     </p>
                     <p>所有Java SE实现都必须指出它们在的支持下提供的最强（最随机）的SecureRandom实现。 <code class="codeph">securerandom.strongAlgorithms</code>的属性<code class="codeph">java.security.Security</code>类。当需要特别强的随机值时，可以使用此实现。
                     </p>
                     <p>的<code class="codeph">securerandom.drbg.config</code>属性用于指定DRBG <code class="codeph">SecureRandom</code> SUN提供程序中的配置和实现。的<code class="codeph">securerandom.drbg.config</code>是的财产<code class="codeph">java.security.Security</code>类。其他DRBG实现也可以使用<code class="codeph">securerandom.drbg.config</code>属性。
                     </p>
                     <div class="figure" id="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36__GUID-BC14EED8-64AD-4750-9417-6E35322A2C07">
                        <p class="titleinfigure">图2-5 SecureRandom类</p><img src="img/secure-random.png" alt="如下图2-5所示" title="如下图2-5所示" longdesc="img_text/secure-random.html"><br><a href="img_text/secure-random.html">“图2-5 SecureRandom类”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div class="sect4"><a id="GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35" name="GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35"></a><h5 id="JSSEC-GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35" class="sect5">创建一个SecureRandom对象</h5>
                     <div>
                        <p>有几种获取实例的方法<code class="codeph">SecureRandom</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p>所有Java SE实现均提供默认值<code class="codeph">SecureRandom</code>使用无参数构造函数： <code class="codeph">new SecureRandom()</code> 。此构造函数从最喜欢的提供程序开始遍历已注册安全提供程序的列表，然后从第一个支持以下操作的提供程序返回新的<span class="apiname">SecureRandom</span>对象： <code class="codeph">SecureRandom</code>随机数生成器（RNG）算法。如果提供程序都不支持RNG算法，则它将返回使用SUN提供程序中的SHA1PRNG的<span class="apiname">SecureRandom</span>对象。
                              </p> 
                           </li>
                           <li> 
                              <p>获得特定的实现<code class="codeph">SecureRandom</code> ，使用<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a>之一。
                              </p> 
                           </li>
                           <li> 
                              <p>使用<code class="codeph">getInstanceStrong()</code>获得强势的方法<code class="codeph">SecureRandom</code>实施定义<code class="codeph">securerandom.strongAlgorithms</code>的属性<code class="codeph">java.security.Security</code>类。此属性列出了适合于生成重要值的平台实现。
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8" name="GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8"></a><h5 id="JSSEC-GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8" class="sect5">播种或重新播种SecureRandom对象</h5>
                     <div>
                        <p>除非对<span class="apiname">getInstance（）</span>的调用后跟对以下<span class="apiname">setSeed</span>方法之一的调用，否则使用随机种子初始化<span class="apiname">SecureRandom</span>对象。
                        </p><pre class="codeblock"><code>    void setSeed(byte[] seed)
    void setSeed(long seed)
</code></pre><p>必须在第一个<span class="apiname">nextBytes</span>调用之前调用<span class="apiname">setSeed</span> ，以防止任何环境随机性。
                        </p>
                        <p><span class="apiname">SecureRandom</span>对象产生的位的随机性取决于种子位的随机性</p>
                        <p>在任何时候<code class="codeph">SecureRandom</code>可以使用以下方法之一重新植入对象<code class="codeph">setSeed</code>要么<code class="codeph">reseed</code>方法。给定的种子<code class="codeph">setSeed</code>补充而不是替代现有种子；因此，保证重复呼叫永远不会降低随机性。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD" name="GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD"></a><h5 id="JSSEC-GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD" class="sect5">使用SecureRandom对象</h5>
                     <div>
                        <p>要获取随机字节，调用方只需传递任意长度的数组，然后将其填充为随机字节：</p><pre class="codeblock"><code>
    void nextBytes(byte[] bytes)
</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340" name="GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340"></a><h5 id="JSSEC-GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340" class="sect5">生成种子字节</h5>
                     <div>
                        <p>如果需要，可以调用<span class="apiname">generateSeed</span>方法来生成给定数量的种子字节（例如，为其他随机数生成器提供种子）：</p><pre class="codeblock"><code>
byte[] <span class="apiname">generateSeed</span>(int numBytes)
</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" name="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7"></a><h4 id="JSSEC-GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" class="sect4">MessageDigest类</h4>
                  <div>
                     <p>的<code class="codeph">MessageDigest</code> class是一个引擎类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> ），旨在提供加密安全消息摘要（例如SHA-256或SHA-512）的功能。密码安全的消息摘要采用任意大小的输入（字节数组），并生成固定大小的输出，称为<span class="variable" translate="no">digest</span>或哈希。
                     </p>
                     <div class="figure" id="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7__GUID-55B0CED3-CB64-479F-9599-A95FD2B243FC">
                        <p class="titleinfigure">图2-6 MessageDigest类</p><img src="img/message-digest.png" alt="如下图2-6所示" title="如下图2-6所示" longdesc="img_text/message-digest.html"><br><a href="img_text/message-digest.html">“图2-6 MessageDigest类”的描述</a></div>
                     <!-- class="figure" -->
                     <p>例如，SHA-256算法生成一个32字节的摘要，而SHA-512则为64字节。</p>
                     <p>摘要具有两个属性：</p>
                     <ul style="list-style-type:disc">
                        <li>找到两个散列为相同值的消息应该在计算上不可行。</li>
                        <li>摘要不应该透露有关用于生成摘要的任何信息。</li>
                     </ul>
                     <p>消息摘要用于生成数据的唯一且可靠的标识符。它们有时被称为数据的“校验和”或“数字指纹”。仅更改消息的一点应产生不同的摘要值。</p>
                     <p>消息摘要有许多用途，可以确定何时有意修改数据。最近，人们付出了巨大的努力来确定流行算法中是否存在任何弱点，而结果却不尽相同。选择摘要算法时，应始终参考最近的参考文献以确定其状态和适用于当前任务的适当性。</p>
                  </div>
                  <div class="sect4"><a id="GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A" name="GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A"></a><h5 id="JSSEC-GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A" class="sect5">创建一个MessageDigest对象</h5>
                     <div>
                        <p>创建一个程序<code class="codeph">MessageDigest</code>宾语。
                        </p>
                        <ul>
                           <li class="stepexpand"><span>要计算摘要，请创建消息摘要实例。的<code class="codeph">MessageDigest</code>对象是通过使用以下方法中的一种<span class="apiname">getInstance（）</span>方法获得的： <code class="codeph">MessageDigest</code>类。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。</span><div>工厂方法返回一个初始化的消息摘要对象。因此，它不需要进一步的初始化。</div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" name="GUID-72106C04-D90A-4CB8-B320-1F4F864221DC"></a><h5 id="JSSEC-GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" class="sect5">更新消息摘要对象</h5>
                     <div>
                        <p>更新消息摘要对象的过程。</p>
                        <ul>
                           <li class="stepexpand"><span>要计算某些数据的摘要，必须将数据提供给初始化的消息摘要对象。它可以一次全部提供，也可以分批提供。可以通过调用<code class="codeph">update</code>方法：</span><div><pre class="codeblock"><code>
void update(byte input)
void update(byte[] input)
void update(byte[] input, int offset, int len)
</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789" name="GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789"></a><h5 id="JSSEC-GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789" class="sect5">计算摘要</h5>
                     <div>
                        <p>使用不同类型的<span class="apiname">digest（）</span>方法计算摘要的过程。
                        </p>
                        <div class="p">数据块必须通过调用来提供<code class="codeph">update</code>方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" title="更新消息摘要对象的过程。">更新消息摘要对象</a> 。
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>摘要是通过调用以下内容之一来计算的： <code class="codeph">digest</code>方法：</span><div><pre class="codeblock"><code>
byte[] digest()
byte[] digest(byte[] input)
int digest(byte[] buf, int offset, int len)
</code></pre></div>
                              <ol>
                                 <li><span>的<code class="codeph">byte[] digest()</code>方法返回计算的摘要。</span></li>
                                 <li><span>的<code class="codeph">byte[] digest(byte[] input)</code>方法做最后<code class="codeph">update(input)</code>在调用之前使用输入字节数组<code class="codeph"><span class="apiname">digest()</span></code> ，它返回摘要字节数组。</span></li>
                                 <li><span>的<code class="codeph">int digest(byte[] buf, int offset, int len)</code>方法将计算的摘要存储在提供的缓冲区中<code class="codeph">buf</code> ， 开始于<code class="codeph">offset</code> 。 <code class="codeph">len</code>是中的字节数<code class="codeph">buf</code>分配给摘要，该方法返回实际存储在其中的字节数<code class="codeph">buf</code> 。如果缓冲区中没有足够的空间，则该方法将引发异常。</span></li>
                              </ol>
                              <div>请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" title="描述计算MessageDigest对象的过程的示例。">计算MessageDigest对象</a> 。
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" name="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF"></a><h4 id="JSSEC-GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" class="sect4">签名班</h4>
                  <div>
                     <p>的<code class="codeph">Signature</code> class是引擎类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> （旨在提供诸如SHA256withDSA或SHA512withRSA之类的密码数字签名算法的功能。密码安全签名算法采用任意大小的输入和私钥，并生成相对较短的（通常是固定大小的字节字符串，称为<span class="variable" translate="no">signature</span> ，具有以下属性：</p>
                     <ul style="list-style-type:disc">
                        <li>只有私钥/公钥对的所有者才能创建签名。对于仅拥有公钥和许多签名来恢复私钥的任何人，在计算上都是不可行的。</li>
                        <li>给定与用于生成签名的私钥相对应的公钥，应该有可能验证输入的真实性和完整性。</li>
                     </ul>
                     <div class="figure" id="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF__GUID-9CD447B5-97F4-4E45-B883-77C9EAFCB7B6">
                        <p class="titleinfigure">图2-7签名类</p><img src="img/signature.png" alt="如下图2-7所示" title="如下图2-7所示" longdesc="img_text/signature.html"><br><a href="img_text/signature.html">“图2-7签名类”的描述</a></div>
                     <!-- class="figure" -->
                     <p>将<span class="apiname">签名</span>对象初始化为使用私钥进行签名，并为其提供了要签名的数据。生成的签名字节通常与签名数据一起保存。当需要验证时，将创建另一个<span class="apiname">Signature</span>对象，并将其初始化以进行验证并提供相应的公钥。数据和签名字节被馈送到签名对象，如果数据和签名匹配，则<span class="apiname">签名</span>对象报告成功。
                     </p>
                     <p>即使签名看起来类似于消息摘要，但它们在提供的保护类型方面有非常不同的目的。实际上，诸如“ SHA256WithRSA”之类的算法使用消息摘要“ SHA256”来将大型数据集初始“压缩”为更易于管理的形式，然后使用“ RSA”算法对所得的32字节消息摘要进行签名。</p>
                     <p>有关签名和验证数据的示例，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" title="使用生成的密钥生成和验证签名的示例。">使用生成的密钥生成和验证签名</a> 。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE" name="GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE"></a><h5 id="JSSEC-GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE" class="sect5">签名对象状态</h5>
                     <div>
                        <p><code class="codeph">Signature</code>对象是模态对象。这意味着<code class="codeph">Signature</code>对象始终处于给定状态，在该状态下只能执行一种类型的操作。
                        </p>
                        <p>状态表示为在其各自类别中定义的最终整数常数。</p>
                        <p>三个州<code class="codeph">Signature</code>对象可能有：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">UNINITIALIZED</code></li>
                           <li><code class="codeph">SIGN</code></li>
                           <li><code class="codeph">VERIFY</code></li>
                        </ul>
                        <p>首次创建时， <code class="codeph">Signature</code>对象在<code class="codeph">UNINITIALIZED</code>州。的<code class="codeph">Signature</code>类定义了两种初始化方法， <code class="codeph">initSign</code>和<code class="codeph">initVerify</code> ，将状态更改为<code class="codeph">SIGN</code>和<code class="codeph">VERIFY</code> ， 分别。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6" name="GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6"></a><h5 id="JSSEC-GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6" class="sect5">创建签名对象</h5>
                     <div>
                        <p>签名或验证签名的第一步是创建一个<code class="codeph">Signature</code>实例。
                        </p>
                        <p><code class="codeph">Signature</code>通过使用其中之一获得对象<code class="codeph">Signature</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6" name="GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6"></a><h5 id="JSSEC-GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6" class="sect5">初始化签名对象</h5>
                     <div>
                        <p>一种<code class="codeph">Signature</code>对象必须在使用之前进行初始化。初始化方法取决于对象将用于签名还是用于验证。
                        </p>
                        <p>如果要用于签名，则必须首先使用将要生成签名的实体的私钥初始化该对象。通过调用以下方法完成初始化：</p><pre class="codeblock"><code>
final void initSign(PrivateKey privateKey)
</code></pre><p>这种方法把<code class="codeph">Signature</code>中的对象<code class="codeph">SIGN</code>州。如果相反<code class="codeph">Signature</code>对象将用于验证，必须首先使用要验证其签名的实体的公钥对其进行初始化。通过调用以下方法之一来完成此初始化：</p><pre class="codeblock"><code>
    final void initVerify(PublicKey publicKey)

    final void initVerify(Certificate certificate)
</code></pre><p>这种方法把<code class="codeph">Signature</code>中的对象<code class="codeph">VERIFY</code>州。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA" name="GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA"></a><h5 id="JSSEC-GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA" class="sect5">使用签名对象签名</h5>
                     <div>
                        <p>如果<code class="codeph">Signature</code>对象已初始化以进行签名（如果该对象位于<code class="codeph">SIGN</code>状态），然后可以将要签名的数据提供给对象。这是通过以下方式之一进行的： <code class="codeph">update</code>方法：</p><pre class="codeblock"><code>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</code></pre><p>呼叫<code class="codeph">update</code>直到所有要签名的数据都已提供给<code class="codeph">Signature</code>宾语。
                        </p>
                        <p>要生成签名，只需调用<code class="codeph">sign</code>方法：</p><pre class="codeblock"><code>
final byte[] sign()
final int sign(byte[] outbuf, int offset, int len)
</code></pre><p>第一种方法以字节数组形式返回签名结果。第二个将签名结果存储在提供的缓冲区<span class="variable" translate="no">outbuf</span> ，从<span class="variable" translate="no">offset</span>开始。 <span class="variable" translate="no">len</span>是分配给签名的<span class="variable" translate="no">outbuf</span>的字节数。该方法返回实际存储的字节数。
                        </p>
                        <p>签名编码是特定于算法的。请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称，</a>以了解有关Java密码体系结构中ASN.1编码使用的更多信息。
                        </p>
                        <p>呼叫<code class="codeph">sign</code>方法将签名对象重置为先前通过调用进行初始化以进行签名时的状态<code class="codeph">initSign</code> 。也就是说，如果需要，可以通过重新调用对象来重置对象，并使用相同的私钥生成该签名。 <code class="codeph">update</code>和<code class="codeph">sign</code> 。
                        </p>
                        <p>另外，也可以拨打新电话<code class="codeph">initSign</code>指定其他私钥，或<code class="codeph">initVerify</code> （以初始化<code class="codeph">Signature</code>对象以验证签名）。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A" name="GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A"></a><h5 id="JSSEC-GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A" class="sect5">使用签名对象进行验证</h5>
                     <div>
                        <p>如果<code class="codeph">Signature</code>对象已初始化以进行验证（如果它在<code class="codeph">VERIFY</code>状态），然后可以验证所指控的签名是否实际上是与其关联的数据的真实签名。首先，将要验证的数据（与签名本身相反）提供给对象。通过调用以下方法之一将数据传递给对象： <code class="codeph">update</code>方法：</p><pre class="codeblock"><code>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</code></pre><p>呼叫<code class="codeph">update</code>直到所有要验证的数据都已提供给<code class="codeph">Signature</code>宾语。现在可以通过调用以下方法之一来验证签名： <code class="codeph">verify</code>方法：</p><pre class="codeblock"><code>
final boolean verify(byte[] signature)

final boolean verify(byte[] signature, int offset, int length)
</code></pre><p>参数必须是包含签名的字节数组。此字节数组将保存签名字节，这些签名字节是先前调用其中一个返回的。 <code class="codeph">sign</code>方法。
                        </p>
                        <p>的<code class="codeph">verify</code>方法返回一个<code class="codeph">boolean</code>指示编码的签名是否是提供给服务器的数据的真实签名<code class="codeph">update</code>方法）。
                        </p>
                        <p>致电<code class="codeph">verify</code>方法将签名对象初始化为通过调用进行验证以进行验证时的状态<code class="codeph">initVerify</code> 。也就是说，该对象被重置，并且可以用来从身份验证另一个签名，该身份的调用中已指定了其公钥。 <code class="codeph">initVerify</code> 。
                        </p>
                        <p>另外，也可以拨打新电话<code class="codeph">initVerify</code>指定其他公共密钥（以初始化<code class="codeph">Signature</code>用于验证来自其他实体的签名的对象），或<code class="codeph">initSign</code> （以初始化<code class="codeph">Signature</code>用于生成签名的对象）。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566" name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566"></a><h4 id="JSSEC-GUID-94225C88-F2F1-44D1-A781-1DD9D5094566" class="sect4">密码类</h4>
                  <div>
                     <p>的<code class="codeph">Cipher</code>类提供用于加密和解密的加密密码的功能。加密是获取数据（称为<span class="variable" translate="no">cleartext</span> ）和<span class="variable" translate="no">key</span> ，并产生对不知道密钥的第三方毫无意义的数据（ <span class="variable" translate="no">ciphertext</span> ）的过程。解密是相反的过程：采用密文和密钥并生成明文的过程。
                     </p>
                     <div class="figure" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-25964623-7C57-4290-9086-29968AA379B1">
                        <p class="titleinfigure">图2-8密码类</p><img src="img/cipher.gif" alt="如下图2-8所示" title="如下图2-8所示" longdesc="img_text/cipher.html"><br><a href="img_text/cipher.html">“图2-8密码类”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-88B6E4EB-FA21-4834-ACD6-957B97D559F6">对称加密与非对称加密</p>
                        <p>加密有两种主要类型： <span class="variable" translate="no">symmetric</span> （也称为<span class="variable" translate="no">secret key</span> ）和<span class="variable" translate="no">asymmetric</span> （或<span class="variable" translate="no">public key cryptography</span> ）。在对称密码学中，用于加密和解密数据的相同密钥。对密钥保密对于确保数据机密至关重要。另一方面，非对称加密使用公共/专用密钥对来加密数据。用一个密钥加密的数据用另一个密钥解密。用户首先生成一个公钥/私钥对，然后将公钥发布到任何人都可以访问的受信任数据库中。希望与该用户进行安全通信的用户使用检索到的公共密钥对数据进行加密。只有私钥的持有者才能解密。对私钥保持机密性对于此方案至关重要。
                        </p>
                        <p>非对称算法（例如RSA）通常比对称算法慢得多。这些算法的设计目的不是有效地保护大量数据。实际上，非对称算法用于交换较小的秘密密钥，这些密钥用于初始化对称算法。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-DDE676A1-290F-45FE-BE6C-CD84D2470469">流与分组密码</p>
                        <p>密码主要有两种类型： <span class="variable" translate="no">block</span>和<span class="variable" translate="no">stream</span> 。块密码一次处理整个块，通常长度为多个字节。如果没有足够的数据来构成一个完整的输入块，则必须<span class="variable" translate="no">padded</span>该数据：也就是说，在加密之前，必须添加伪字节以使密码的块大小成为整数倍。然后在解密阶段将这些字节剥离。填充可以通过应用程序完成，也可以通过初始化密码以使用填充类型（例如“ PKCS5PADDING”）来完成。相反，流密码一次处理一个小的单位（通常是一个字节甚至一个位）的输入数据。这允许密码处理任意数量的数据而无需填充。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MODESOFOPERATION-A64768C7">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MODESOFOPERATION-A6473469">操作方式</p>
                        <p>使用简单的分组密码进行加密时，两个相同的明文块将始终产生相同的密文块。尝试破解密文的密码学家如果注意到重复的文本块，将可以轻松完成工作。密码操作模式使密码文本在基于区块位置或其他密码文本块的值的输出区块更改中难以预测。第一个块将需要一个初始值，该值称为<span class="variable" translate="no">initialization vector (IV)</span> 。由于IV只是在进行任何加密之前更改了数据，因此IV应该是随机的，但不一定需要保密。有多种模式，例如CBC（密码块链接），CFB（密码反馈模式）和OFB（输出反馈模式）。ECB（电子密码簿模式）是一种不受块位置或其他密文块影响的模式。因为如果ECB密文使用相同的明文/密钥，则它们是相同的，因此该模式通常不适用于加密应用程序，因此不应使用。
                        </p>
                        <p>某些算法（例如AES和RSA）允许使用不同长度的密钥，而其他算法则是固定的，例如3DES。使用更长的密钥进行加密通常意味着对消息恢复的抵抗力更强。与往常一样，在安全性和时间之间需要权衡取舍，因此请适当选择密钥长度。</p>
                        <p>大多数算法使用二进制密钥。即使以十六进制表示，大多数人也没有能力记住较长的二进制数序列。字符密码更容易调用。由于字符密码通常是从少量字符中选择的（例如[a-zA-Z0-9]），因此已定义了诸如“基于密码的加密”（PBE）之类的协议，这些协议采用字符密码并生成强二进制文件键。为了使攻击者从密码到密钥的获取变得非常耗时（通过所谓的“彩虹表攻击”或“预先计算的字典攻击”，其中预先计算了常见的字典词->值映射），大多数PBE实现将以随机数混合，称为<span class="variable" translate="no">salt</span> ，以减少预计算表的实用性。
                        </p>
                        <p>较新的密码模式（例如，关联数据的身份验证加密（AEAD））（例如， <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf" target="_blank">伽罗瓦/计数器模式（GCM）</a> ）对数据进行加密并同时对生成的消息进行身份验证。可以在计算所得的AEAD标签（MAC）的过程中使用附加的关联数据（AAD），但是不会将该AAD数据作为密文输出。（例如，某些数据可能不需要保密，但应将其计入标签计算中以检测修改。）<span class="apiname">Cipher.updateAAD（）</span>方法可用于在标签计算中包括AAD。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-6B8936D6-E7FA-4C94-824A-D4B6D78847B5">在GCM模式下使用AES密码</p>
                        <p>带有GCM的AES密码是一种AEAD密码，其使用方式与非AEAD密码不同。除了常规数据外，它还需要AAD，AAD对于加密/解密是可选的，但必须在加密/解密数据之前提供AAD。另外，为了安全地使用GCM，呼叫者不应重复使用密钥和IV组合进行加密。这意味着每次加密操作都应使用不同的参数集显式地重新初始化密码对象。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__SECRETKEYMYKEY...BYTEMYAAD...BYTEPL-7249BF00">
                        <p class="titleinexample">示例2-2在GCM模式下使用AES密码的示例代码</p><pre class="codeblock"><code>
	SecretKey myKey = ...
	byte[] myAAD = ...
	byte[] plainText = ...
        int myTLen = ... 
        byte[] myIv = ...

	GCMParameterSpec myParams = new GCMParameterSpec(myTLen, myIv);
	Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
	c.init(Cipher.ENCRYPT_MODE, myKey, myParams);

	// AAD is optional, if present, it must be supplied before any update/doFinal calls.
	c.updateAAD(myAAD);  // if AAD is non-null
	byte[] cipherText = new byte[c.getOutputSize(plainText.length)];
	// conclusion of encryption operation
	int actualOutputLen = c.doFinal(plainText, 0, plainText.length, cipherText);
 
	// To decrypt, same AAD and GCM parameters must be supplied
	c.init(Cipher.DECRYPT_MODE, myKey, myParams);
	c.updateAAD(myAAD);
	byte[] recoveredText = c.doFinal(cipherText, 0, actualOutputLen);

	// MUST CHANGE IV VALUE if the same key were to be used again for encryption
     	byte[] newIv = ...;
	myParams = new GCMParameterSpec(myTLen, newIv);
</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-687A68F7-2023-44E6-B9B5-3CDBE3FC75F0">创建密码对象</p>
                        <p><code class="codeph">Cipher</code>通过使用其中之一获得对象<code class="codeph">Cipher</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。在这里，算法名称与其他引擎类略有不同，因为它不仅指定算法名称，而且指定“转换”。转换是一个字符串，它描述要在给定输入上执行以产生某些输出的操作（或一组操作）。转换过程始终包含加密算法的名称（例如， <code class="codeph">AES</code> ），然后可以跟随模式和填充方案。
                        </p>
                        <p>转换的形式为：</p>
                        <ul style="list-style-type:disc">
                           <li>“ <span class="variable" translate="no">algorithm/mode/padding</span> ”或</li>
                           <li>“ <span class="variable" translate="no">algorithm</span> ”</li>
                        </ul>
                        <p>例如，以下是有效的转换：</p><pre class="codeblock"><code>
    "<span class="variable" translate="no">AES/CBC/PKCS5Padding</span>"

    "<span class="variable" translate="no">AES</span>"
</code></pre><p>如果仅指定一个转换名称，则系统将确定环境中是否存在所请求转换的实现，如果有多个，则返回一个首选转换。</p>
                        <p>如果同时指定了转换名称和程序包提供者，则系统将确定所请求的程序包中是否存在所请求的转换的实现，如果没有，则引发异常。</p>
                        <p>建议使用完全指定算法，模式和填充的转换。否则，提供程序将使用默认值。例如，对于许多对称密码，SunJCE和SunPKCS11提供程序将ECB用作默认模式，将PKCS5Padding用作默认填充。</p>
                        <p>这意味着在<code class="codeph">SunJCE</code>提供者：</p><pre class="codeblock"><code>    Cipher c1 = Cipher.getInstance("<span class="variable" translate="no">AES/ECB/PKCS5Padding</span>");
</code></pre><p>和</p><pre class="codeblock"><code>    Cipher c1 = Cipher.getInstance("<span class="variable" translate="no">AES</span>");
</code></pre><p>是等效的语句。</p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-CAFC698A-6EE6-4448-98F8-9FE612C86FDA">
                              <p class="notep1">注意：</p>ECB模式是最容易使用的分组密码模式，并且是JDK和JRE中的默认模式。当使用不同的密钥时，ECB适用于单个数据块，但绝对不应将其用于多个数据块。其他密码模式，例如密码块链接（CBC）或Galois /计数器模式（GCM）更合适。
                           </div>
                        </div>
                        <p>使用CFB和OFB等模式，分组密码可以以小于密码实际分组大小的单位加密数据。请求这种模式时，您可以选择将每次处理的位数附加到模式名称中，从而指定一次要处理的位数，如<span class="variable" translate="no">AES/CFB8/NoPadding</span>和<span class="variable" translate="no">AES/OFB32/PKCS5Padding</span>转换所示。如果未指定此数字，则使用提供程序特定的默认值。（例如， <code class="codeph">SunJCE</code>提供程序使用AES的默认128位。）因此，可以通过使用8位模式（例如CFB8或OFB8）将块密码转换为面向字节的流密码。
                        </p>
                        <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>包含标准名称列表，这些标准名称可用于指定转换的算法名称，模式和填充方案组件。
                        </p>
                        <p>工厂方法返回的对象尚未初始化，必须先初始化才能使用。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-C3874333-8A0C-4AAB-ADD6-6D7F885EF075">初始化密码对象</p>
                        <p>通过获取的密码对象<code class="codeph">getInstance</code>必须针对以下四种模式之一进行初始化，这四种模式在<code class="codeph">Cipher</code>类。可以通过其符号名称来引用这些模式，这些符号名称如下所示，并对每种模式的用途进行了描述：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-7CD0B30D-A692-401F-8B7F-1D8CAF2558AA"><!-- --></a> ENCRYPT_MODE</dt>
                           <dd>数据加密。</dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-5E5D22CB-35E7-4472-BB46-C85985D27707"><!-- --></a> DECRYPT_MODE</dt>
                           <dd>数据解密。</dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-53BB5B82-CDCF-4FA4-83F9-5F0B82EC715C"><!-- --></a> WRAP_MODE</dt>
                           <dd>包装一个<code class="codeph">java.security.Key</code>字节，以便可以安全地传输密钥。
                           </dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-17922D9E-7BE5-4179-B8E0-0C06E4BAFD60"><!-- --></a> UNWRAP_MODE</dt>
                           <dd>将先前包装的密钥解包到<code class="codeph">java.security.Key</code>宾语。
                           </dd>
                        </dl>
                        <p>每个密码初始化方法都采用一个操作模式参数（ <code class="codeph">opmode</code> ），并为此模式初始化Cipher对象。其他参数包括键（ <code class="codeph">key</code> ）或包含密钥的证书（ <code class="codeph">certificate</code> ），算法参数（ <code class="codeph">params</code> ），以及随机性的来源（ <code class="codeph">random</code> ）。
                        </p>
                        <p>要初始化Cipher对象，请调用以下其中一项<code class="codeph">init</code>方法：</p><pre class="codeblock"><code>
    public void init(int opmode, Key key);

    public void init(int opmode, Certificate certificate);

    public void init(int opmode, Key key, SecureRandom random);

    public void init(int opmode, Certificate certificate,
                     SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params, SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameters params);

    public void init(int opmode, Key key,
                     AlgorithmParameters params, SecureRandom random);
</code></pre><p>如果需要加密的需要加密参数的Cipher对象被初始化，并且没有参数提供给加密对象<code class="codeph">init</code>在这种方法中，应该通过生成随机参数或使用默认的，提供商特定的参数集来提供基本的密码实现本身所需的参数。
                        </p>
                        <p>但是，如果初始化需要参数的Cipher对象以进行解密，并且没有参数提供给<code class="codeph">init</code>方法<code class="codeph">InvalidKeyException</code>要么<code class="codeph">InvalidAlgorithmParameterException</code>将会引发异常，具体取决于<code class="codeph">init</code>已使用的方法。
                        </p>
                        <p>请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MANAGINGALGORITHMPARAMETERS-63E08852">管理算法参数</a> 。
                        </p>
                        <p>必须将用于加密的相同参数用于解密。</p>
                        <p>请注意，初始化Cipher对象后，它将丢失所有先前获取的状态。换句话说，初始化Cipher等效于创建该Cipher的新实例并将其初始化。例如，如果首先使用给定的密钥将密码初始化为解密，然后再进行加密初始化，则它将丢失在解密模式下获得的任何状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-013270DA-8041-4A87-B328-92D84F2359F2">加密和解密数据</p>
                        <p>数据可以一步（ <span class="variable" translate="no">single-part operation</span>步<span class="variable" translate="no">single-part operation</span> ）或多步（ <span class="variable" translate="no">multiple-part operation</span>步<span class="variable" translate="no">single-part operation</span> ）进行加密或解密。如果您事先不知道数据将要存储多长时间，或者数据太长而无法一次全部存储在内存中，则多部分操作很有用。
                        </p>
                        <p>要在一个步骤中加密或解密数据，请调用<code class="codeph">doFinal</code>方法：</p><pre class="codeblock"><code>
    public byte[] doFinal(byte[] input);

    public byte[] doFinal(byte[] input, int inputOffset, int inputLen);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output, int outputOffset)
</code></pre><p>要分多个步骤加密或解密数据，请调用<code class="codeph">update</code>方法：</p><pre class="codeblock"><code>
    public byte[] update(byte[] input);

    public byte[] update(byte[] input, int inputOffset, int inputLen);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output, int outputOffset)
</code></pre><p>多部分操作必须由上述之一终止<code class="codeph">doFinal</code>方法（如果最后一步还有一些输入数据），或者通过以下方法之一<code class="codeph">doFinal</code>方法（如果最后一步没有输入数据）：</p><pre class="codeblock"><code>
    public byte[] doFinal();

    public int doFinal(byte[] output, int outputOffset);
</code></pre><p>所有的<code class="codeph">doFinal</code>如果已将填充（或取消填充）请求作为指定转换的一部分，则方法会处理任何必要的填充（或取消填充）。
                        </p>
                        <p>致电<code class="codeph">doFinal</code>将Cipher对象重置为通过调用进行初始化时的状态<code class="codeph">init</code> 。也就是说，将重置Cipher对象，并且该对象可用于加密或解密（取决于对的调用中指定的操作模式<code class="codeph">init</code> ）更多数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__WRAPPINGANDUNWRAPPINGKEYS-74578038">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-337B0BAB-8284-44B3-BDCA-CA856B004611">包装和展开键</p>
                        <p>包装钥匙可以将钥匙从一个地方安全地转移到另一个地方。</p>
                        <p>的<code class="codeph">wrap/unwrap</code> API直接与关键对象一起使用，因此使编写代码更加方便。这些方法还使安全传输基于硬件的密钥成为可能。
                        </p>
                        <p>要<span class="bold">包装</span>密钥，请首先为WRAP_MODE初始化Cipher对象，然后调用以下命令：</p><pre class="codeblock"><code>
    public final byte[] wrap(Key key);
</code></pre><p>如果您提供包装的密钥字节（调用的结果<code class="codeph">wrap</code> ）给将要拆开包装的其他人，请确保还发送收件人需要的其他信息，以便进行<code class="codeph">unwrap</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li>密钥算法的名称。</li>
                           <li>换行密钥的类型（其中一个<code class="codeph">Cipher.SECRET_KEY</code> ， <code class="codeph">Cipher.PRIVATE_KEY</code> ， 要么<code class="codeph">Cipher.PUBLIC_KEY</code> ）。
                           </li>
                        </ul>
                        <p>关键算法名称可以通过调用<code class="codeph">getAlgorithm</code> Key界面中的方法：</p><pre class="codeblock"><code>
    public String getAlgorithm();
</code></pre><p><span class="bold">解开</span>上一个调用返回的字节<code class="codeph">wrap</code> ，首先为UNWRAP_MODE初始化一个Cipher对象，然后调用以下命令：</p><pre class="codeblock"><code>
    public final Key unwrap(byte[] wrappedKey,
                            String wrappedKeyAlgorithm,
                            int wrappedKeyType));
</code></pre><p>这里， <code class="codeph">wrappedKey</code>是从上一个包装调用返回的字节， <code class="codeph">wrappedKeyAlgorithm</code>是与包装密钥关联的算法，并且<code class="codeph">wrappedKeyType</code>是包装键的类型。这必须是以下之一<code class="codeph">Cipher.SECRET_KEY</code> ， <code class="codeph">Cipher.PRIVATE_KEY</code> ， 要么<code class="codeph">Cipher.PUBLIC_KEY</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MANAGINGALGORITHMPARAMETERS-63E08852">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-776F1F5C-451D-4210-8557-C85AC5E64D21">管理算法参数</p>
                        <p>基础<span class="apiname">Cipher</span>实现使用的参数已显式传递给<code class="codeph">init</code>可以通过调用<span class="apiname">Cipher</span>对象的<span class="apiname">Cipher</span>对象来检索应用程序的方法或由基础实现本身生成的方法<code class="codeph">getParameters</code>方法，该方法将参数返回为<code class="codeph">java.security.AlgorithmParameters</code>对象（或<code class="codeph">null</code>如果未使用任何参数）。如果参数是初始化向量（IV），则也可以通过调用<code class="codeph">getIV</code>方法。
                        </p>
                        <p>在以下示例中，仅使用密钥而不使用参数来初始化实现基于密码的加密（PBE）的<span class="apiname">Cipher</span>对象。但是，为基于密码的加密选择的算法需要两个参数<span class="variable" translate="no">salt</span>和<span class="variable" translate="no">iteration count</span> 。这些将由基础算法实现本身生成。应用程序可以从<span class="apiname">Cipher</span>对象检索生成的参数，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1314-724A0BB7">示例2-3</a> 。
                        </p>
                        <p>必须将用于加密的相同参数用于解密。可以从其编码实例化它们，并使用它们初始化相应的Cipher对象以进行解密，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1315-724A0E25">示例2-4</a> 。
                        </p>
                        <p>如果在初始化Cipher对象时未指定任何参数，并且不确定基础实现是否使用任何参数，则可以通过简单地调用<code class="codeph">getParameters</code>您的Cipher对象的方法，并检查返回的值。返回值为<code class="codeph">null</code>表示未使用任何参数。
                        </p>
                        <p>以下密码算法由<code class="codeph">SunJCE</code>提供者使用参数：</p>
                        <ul style="list-style-type:disc">
                           <li>AES，DES-EDE和河豚在反馈（即CBC，CFB，OFB或PCBC）模式下使用时，请使用初始化向量（IV）。的<code class="codeph">javax.crypto.spec.IvParameterSpec</code>类可用于使用给定的IV初始化<span class="apiname">Cipher</span>对象。另外，CTR和GCM模式需要IV。</li>
                           <li>PBE <span class="apiname">密码</span>算法使用一组参数，包括盐和迭代计数。的<code class="codeph">javax.crypto.spec.PBEParameterSpec</code>该类可用于使用给定的盐和迭代计数来初始化实现PBE算法（例如：PBEWithHmacSHA256AndAES_256）的<span class="apiname">Cipher</span>对象。
                           </li>
                        </ul>
                        <p>请注意，如果使用<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" title="此类使程序员可以创建对象并使用密码算法保护其机密性。">The SealedObject Class</a>类，则不必担心存储或传输供解密操作使用的任何算法参数。此类将用于密封（加密）的参数附加到加密的对象内容，并使用相同的参数进行开封（解密）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1314-724A0BB7">
                        <p class="titleinexample">示例2-3用于从密码对象检索参数的示例代码</p>
                        <p>应用程序可以从Cipher对象检索生成的用于加密的参数，如下所示：</p><pre class="codeblock"><code>
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for encryption, without supplying
    // any parameters. Here, "myKey" is assumed to refer
    // to an already-generated key.
    c.init(Cipher.ENCRYPT_MODE, myKey);

    // encrypt some data and store away ciphertext
    // for later decryption
    byte[] cipherText = c.doFinal("This is just an example".getBytes());

    // retrieve parameters generated by underlying cipher
    // implementation
    AlgorithmParameters algParams = c.getParameters();

    // get parameter encoding and store it away
    byte[] encodedAlgParams = algParams.getEncoded();
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1315-724A0E25">
                        <p class="titleinexample">示例2-4用于初始化用于解密的密码对象的示例代码</p>
                        <p>必须将用于加密的相同参数用于解密。可以从其编码实例化它们，并将其用于初始化相应的Cipher对象以进行解密，如下所示：</p><pre class="codeblock"><code>
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get parameter object for password-based encryption
    AlgorithmParameters algParams;
    algParams = AlgorithmParameters.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize with parameter encoding from above
    algParams.init(encodedAlgParams);

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for decryption, using one of the
    // init() methods that takes an AlgorithmParameters
    // object, and pass it the algParams object from above
    c.init(Cipher.DECRYPT_MODE, myKey, algParams);
</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-3944EBCA-4728-4F30-9E6A-73528AE0E89B">密码输出注意事项</p>
                        <p>一些<code class="codeph">update</code>和<code class="codeph">doFinal</code> Cipher的方法允许调用者指定将数据加密或解密到的输出缓冲区。在这些情况下，重要的是传递一个足够大的缓冲区以容纳加密或解密操作的结果。
                        </p>
                        <p>Cipher中的以下方法可用于确定输出缓冲区应有多大：</p><pre class="codeblock"><code>
    public int getOutputSize(int inputLen)
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836" name="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836"></a><h4 id="JSSEC-GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836" class="sect4">其他基于密码的类</h4>
                  <div>
                     <p>内部有一些辅助类<code class="codeph">Cipher</code>以便轻松访问常用密码。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836__GUID-384607A1-E0B1-459E-9772-48459EF59CD1">话题</p>
                        <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" title="CipherInputStream和CipherOutputStream类是Cipher流类。">密码流类</a></p>
                        <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" title="此类使程序员可以创建对象并使用密码算法保护其机密性。">SealedObject类</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" name="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF"></a><h5 id="JSSEC-GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" class="sect5">密码流类</h5>
                     <div>
                        <p>的<code class="codeph">CipherInputStream</code>和<code class="codeph">CipherOutputStream</code>类是密码流类。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__GUID-C4E63681-24B8-4A4C-9CCD-C20F8AD22918">CipherInputStream类</p>
                           <p>这堂课是<code class="codeph">FilterInputStream</code>加密或解密通过它的数据。它由一个<code class="codeph">InputStream</code> 。<span class="apiname">CipherInputStream</span>表示已插入<span class="apiname">Cipher</span>对象的安全输入流。的<code class="codeph">read</code> <span class="apiname">CipherInputStream的</span>方法返回从基础<span class="apiname">InputStream</span>读取但已由嵌入式<span class="apiname">Cipher</span>对象另外处理的数据。<span class="apiname">Cipher</span>对象必须先完全初始化CipherInputStream才能使用。
                           </p>
                           <p>例如，如果嵌入式<span class="apiname">Cipher</span>已初始化为解密，则<span class="apiname">CipherInputStream</span>将尝试解密从基础<span class="apiname">InputStream</span>读取的数据，然后再将其返回给应用程序。
                           </p>
                           <p>此类严格遵循其祖先类的语义，尤其是失败语义<code class="codeph">java.io.FilterInputStream</code>和<code class="codeph">java.io.InputStream</code> 。此类恰好具有在其祖先类中指定的那些方法，并将它们全部覆盖，以便由嵌入式密码另外处理数据。此外，此类捕获其祖先类未抛出的所有异常。特别是<code class="codeph">skip(long)</code>方法仅跳过由<span class="apiname">Cipher</span>处理过的数据。
                           </p>
                           <p>对于使用此类的程序员，至关重要的是不要使用未在此类中定义或覆盖的方法（例如，后来添加到超类之一的新方法或构造函数），因为这些方法的设计和实现不太可能考虑到与<span class="apiname">CipherInputStream</span>有关的安全性影响。假设其用法请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORENCRYPTINGINPUTSTREAMD-74CAEA35">示例2-5</a> 。 <code class="codeph">cipher1</code>已初始化加密。该程序从文件读取并加密内容<code class="codeph">/tmp/a.txt</code>然后将结果（加密的字节）存储在<code class="codeph">/tmp/b.txt</code> 。
                           </p>
                           <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__THEFOLLOWINGEXAMPLEDEMONSTRATESHOWT-74CAEEB6">例2-6</a>演示了如何轻松连接多个实例<code class="codeph">CipherInputStream</code>和<code class="codeph">FileInputStream</code> 。在此示例中，假设<code class="codeph">cipher1</code>和<code class="codeph">cipher2</code>已分别初始化以进行加密和解密（具有相应的密钥）。该程序从文件复制内容<code class="codeph">/tmp/a.txt</code>至<code class="codeph">/tmp/b.txt</code> ，但从中读取内容时，首先对内容进行加密，然后再解密<code class="codeph">/tmp/a.txt</code> 。当然，由于此程序只是对文本进行加密并立即解密，因此它实际上不是非常有用，除了作为一种简单的说明链接的方式之外， <code class="codeph">CipherInputStreams</code> 。
                           </p>
                           <p>请注意， <code class="codeph">CipherInputStream</code>将阻塞直到从基础密码返回数据。如果使用分组密码，则必须从底层获得完整的密文块<code class="codeph">InputStream</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORENCRYPTINGINPUTSTREAMD-74CAEA35">
                           <p class="titleinexample">示例2-5使用CipherInputStream和FileInputStream的示例代码</p>
                           <p>以下代码演示了如何使用<code class="codeph">CipherInputStream</code>包含那个密码和一个<code class="codeph">FileInputStream</code>为了加密输入流数据：</p><pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
CipherInputStream cis = new CipherInputStream(fis, cipher1);
FileOutputStream fos = new FileOutputStream("/tmp/b.txt")) {
    byte[] b = new byte[8];
    int i = cis.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis.read(b);
    }
}</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__THEFOLLOWINGEXAMPLEDEMONSTRATESHOWT-74CAEEB6">
                           <p class="titleinexample">示例2-6用于连接CipherInputStream和FileInputStream的示例代码</p>
                           <p>下面的示例演示如何轻松连接<span class="apiname">CipherInputStream</span>和<span class="apiname">FileInputStream的</span>多个实例。在此示例中，假设<code class="codeph">cipher1</code>和<code class="codeph">cipher2</code>已分别针对加密和解密（使用相应的密钥）进行了初始化：</p><pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        CipherInputStream cis1 = new CipherInputStream(fis, cipher1);
        CipherInputStream cis2 = new CipherInputStream(cis1, cipher2);
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt")) {
    byte[] b = new byte[8];
    int i = cis2.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis2.read(b);
    }
}  </code></pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__GUID-80F9ECCB-D464-422B-B365-CCE8763A7F76">CipherOutputStream类</p>
                           <p>这堂课是<code class="codeph">FilterOutputStream</code>加密或解密通过它的数据。它由一个<code class="codeph">OutputStream</code> ，或其子类别之一，以及<code class="codeph">Cipher</code> 。<span class="apiname">CipherOutputStream</span>表示其中已插入<span class="apiname">Cipher</span>对象的安全输出流。的<code class="codeph">write</code> <span class="apiname">CipherOutputStream的</span>方法首先使用嵌入的<span class="apiname">Cipher</span>对象处理数据，然后再将其写到基础<span class="apiname">OutputStream上</span> 。<span class="apiname">CipherOutputStream</span>使用<span class="apiname">Cipher</span>对象之前，必须对其进行完全初始化。
                           </p>
                           <p>例如，如果已对嵌入式<span class="apiname">密码</span>进行了初始化以进行加密，则<code class="codeph">CipherOutputStream</code>在将数据写到基础输出流之前，将对其进行加密。
                           </p>
                           <p>此类严格遵循其祖先类的语义，尤其是失败语义<code class="codeph">java.io.OutputStream</code>和<code class="codeph">java.io.FilterOutputStream</code> 。此类恰好在其祖先类中指定了那些方法，并覆盖了所有这些方法，以便所有数据都由嵌入密码进行额外处理。此外，此类捕获其祖先类未抛出的所有异常。
                           </p>
                           <p>对于使用此类的程序员，至关重要的是不要使用未在此类中定义或覆盖的方法（例如，后来添加到超类之一的新方法或构造函数），因为这些方法的设计和实现不太可能考虑到以下方面的安全影响<code class="codeph">CipherOutputStream</code> 。
                           </p>
                           <p>假设<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">示例2-7</a>的用法，请参见<code class="codeph">cipher1</code>已初始化加密。程序从文件中读取内容<code class="codeph">/tmp/a.txt</code> ，然后将结果（加密的字节）加密并存储在<code class="codeph">/tmp/b.txt</code> 。
                           </p>
                           <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">例2-7</a>演示了如何轻松连接的多个实例<code class="codeph">CipherOutputStream</code>和<code class="codeph">FileOutputStream</code> 。在此示例中，假设<code class="codeph">cipher1</code>和<code class="codeph">cipher2</code>已分别针对解密和加密（具有相应的密钥）进行了初始化。该程序从文件复制内容<code class="codeph">/tmp/a.txt</code>至<code class="codeph">/tmp/b.txt</code> ，除了先将内容加密然后再解密再写入内容<code class="codeph">/tmp/b.txt</code> 。
                           </p>
                           <p>使用<span class="variable" translate="no">block</span>密码算法时要记住的一件事是，必须将完整的明文数据块提供给<code class="codeph">CipherOutputStream</code>数据将被加密并发送到基础输出流之前。
                           </p>
                           <p>两者之间还有另一个重要区别<code class="codeph">flush</code>和<code class="codeph">close</code>此类的方法，如果封装的<span class="apiname">Cipher</span>对象实现启用了填充的分组密码算法，则该方法将变得更加重要：</p>
                           <ul style="list-style-type:disc">
                              <li><code class="codeph">flush</code>通过强制将已封装的Cipher对象已处理的所有缓冲输出字节写出来刷新基础<span class="apiname">OutputStream</span> 。封装的<span class="apiname">Cipher</span>对象缓冲并等待其处理的任何字节都<span class="bold">不会</span>被写出。
                              </li>
                              <li><code class="codeph">close</code>关闭基础<span class="apiname">OutputStream</span>并释放与其关联的所有系统资源。它调用<code class="codeph">doFinal</code>封装的<span class="apiname">Cipher</span>对象的方法，通过调用其缓冲的任何字节来处理并写入基础流<code class="codeph">flush</code>方法。
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">
                           <p class="titleinexample">示例2-7使用CipherOutputStream和FileOutputStream的示例代码</p>该代码演示了如何使用<code class="codeph">CipherOutputStream</code>包含那个密码和一个<code class="codeph">FileOutputStream</code>为了加密要写入输出流的数据：<pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt");
        CipherOutputStream cos = new CipherOutputStream(fos, cipher1)) {
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos.write(b, 0, i);
        i = fis.read(b);
    }
    cos.flush();
}</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORCONNECTINGCIPHEROUTPUT-74D599F3">
                           <p class="titleinexample">示例2-8用于连接CipherOutputStream和FileOutputStream的示例代码</p>该代码演示了如何轻松连接<span class="apiname">CipherOutputStream</span>和<span class="apiname">FileOutputStream的</span>多个实例。在此示例中，假设<code class="codeph">cipher1</code>和<code class="codeph">cipher2</code>已分别针对解密和加密（使用相应的密钥）进行了初始化：<pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt");
        CipherOutputStream cos1 = new CipherOutputStream(fos, cipher1);
        CipherOutputStream cos2 = new CipherOutputStream(cos1, cipher2)) {
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos2.write(b, 0, i);
        i = fis.read(b);
    }
    cos2.flush();
}</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" name="GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8"></a><h5 id="JSSEC-GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" class="sect5">SealedObject类</h5>
                     <div>
                        <p>此类使程序员可以创建对象并使用密码算法保护其机密性。</p>
                        <div class="section">
                           <p>给定任何实现<code class="codeph">java.io.Serializable</code>界面，可以创建一个<code class="codeph">SealedObject</code>它以序列化格式（即“深拷贝”）封装原始对象，并使用诸如AES之类的加密算法密封（加密）其序列化内容，以保护其机密性。加密的内容随后可以解密（使用相应的算法使用正确的解密密钥）并进行反序列化，从而产生原始对象。
                           </p>
                           <p>以下代码段说明了一种典型用法：为了密封对象，您可以创建一个<code class="codeph">SealedObject</code>从要密封的对象开始并完全初始化<code class="codeph">Cipher</code>将加密序列化对象内容的对象。在此示例中，使用“ AES”算法密封了字符串“ This is a secret”。请注意，可以在密封操作中使用的任何算法参数都存储在<code class="codeph">SealedObject</code> ：</p><pre class="codeblock"><code>
    // create Cipher object
    // NOTE: sKey is assumed to refer to an already-generated
    // secret AES key.
    Cipher c = Cipher.getInstance("AES");
    c.init(Cipher.ENCRYPT_MODE, sKey);

    // do the sealing
    SealedObject so = new SealedObject("This is a secret", c);
</code></pre><p>被密封的原始对象可以通过两种不同的方式来恢复：</p>
                           <ul style="list-style-type:disc">
                              <li>通过使用<code class="codeph">Cipher</code>已使用与密封对象完全相同的算法，密钥，填充方案等进行初始化的对象：<pre class="codeblock"><code>
    c.init(Cipher.DECRYPT_MODE, sKey);
    try {
        String s = (String)so.getObject(c);
    } catch (Exception e) {
        // do something
    };
</code></pre> <p>这种方法的优点在于，打开密封对象的一方不需要知道解密密钥。例如，一方已使用所需的解密密钥初始化了密码对象后，它可以将密码对象移交给另一方，然后另一方将密封的对象解封。</p> 
                              </li>
                              <li>通过使用适当的解密密钥（由于AES是对称加密算法，我们使用相同的密钥进行密封和开封）：<pre class="codeblock"><code>
    try {
        String s = (String)so.getObject(sKey);
    } catch (Exception e) {
        // do something
    };
</code></pre> <p>通过这种方法， <code class="codeph">getObject</code>方法为适当的解密算法创建一个密码对象，并使用给定的解密密钥和存储在密封对象中的算法参数（如果有）对其进行初始化。这种方法的优点在于，开封物体的一方不需要跟踪用于密封物体的参数（例如，IV）。
                                 </p> 
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" name="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A"></a><h4 id="JSSEC-GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" class="sect4">Mac类</h4>
                  <div>
                     <p>类似于<code class="codeph">MessageDigest</code>消息认证码（Message Authentication Code，MAC）提供了一种方法来检查通过不可靠介质传输或存储在不可靠介质中的信息的完整性，但在计算中包括密钥。
                     </p>
                     <div class="section">
                        <p>只有拥有正确密钥的人才能验证收到的消息。通常，消息身份验证代码用于共享密钥的两方之间，以验证在这两方之间传输的信息。</p>
                        <div class="figure" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-53D5C5FD-6E47-42AC-AEA2-C8BDCFB8B566">
                           <p class="titleinfigure">图2-9 Mac类</p><img src="img/mac-class.png" alt="如下图2-9所示" title="如下图2-9所示" longdesc="img_text/mac-class.html"><br><a href="img_text/mac-class.html">“图2-9 Mac类”的说明</a></div>
                        <!-- class="figure" -->
                        <p>基于密码哈希函数的MAC机制称为HMAC。 HMAC可以与任何秘密哈希函数（例如SHA-256）结合使用秘密共享密钥。</p>
                        <p>的<code class="codeph">Mac</code>类提供消息身份验证代码（MAC）的功能。参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" title="以下是一个示例程序，该示例程序演示了如何为HMAC-SHA256生成密钥对象，并使用该对象初始化HMAC-SHA256对象。">HMAC-SHA256示例</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-8DBAA334-4A7A-4A83-BC28-CEF9C6EDEB5F">创建一个Mac对象</p><code class="codeph">Mac</code>通过使用其中之一获得对象<code class="codeph">Mac</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-7B481699-5CC9-444F-BD4A-3BD0C290FE7E">初始化Mac对象</p>
                        <p>Mac对象始终使用（秘密）密钥初始化，并且可以选择使用一组参数进行初始化，具体取决于底层的MAC算法。</p>
                        <p>要初始化Mac对象，请调用其<span class="apiname">init</span>方法之一：</p><pre class="codeblock"><code>
    public void <span class="apiname">init(Key key)</span>;

    public void <span class="apiname">init(Key key, AlgorithmParameterSpec params)</span>;
</code></pre><p>您可以使用实现了<code class="codeph">javax.crypto.SecretKey</code>接口。这可能是<span class="apiname">javax.crypto返回的对象<span class="apiname">。KeyGenerator.generateKey（）</span> ，它是由<span class="apiname">javax.crypto返回的密钥协商协议的结果<span class="apiname">。KeyAgreement.generateSecret（）</span>或以下对象的实例<code class="codeph">javax.crypto.spec.SecretKeySpec</code> 。
                        </span></span></p>
                        <p>对于某些MAC算法，与用于初始化Mac对象的（secret-）密钥对象相关联的（secret-）密钥算法无关紧要（这是HMAC-MD5和HMAC-SHA1实现的情况<code class="codeph">SunJCE</code>提供者）。但是，对于其他算法，（秘密）密钥算法确实很重要， <code class="codeph">InvalidKeyException</code>如果使用具有不适当的（秘密）密钥算法的（秘密）密钥对象，则会引发。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-F30CAFF4-D4EB-4EFF-A27A-05D28513FF1D">计算MAC</p>
                        <p>MAC可以一步（ <span class="variable" translate="no">single-part operation</span> ）或多步（ <span class="variable" translate="no">multiple-part operation</span> ）计算。如果您事先不知道数据将要存储多长时间，或者数据太长而无法一次全部存储在内存中，则多部分操作很有用。
                        </p>
                        <p>要在单个步骤中计算某些数据的MAC，请调用以下<span class="apiname">doFinal</span>方法：</p><pre class="codeblock"><code>
    public byte[] <span class="apiname">doFinal(byte[] input)</span>;
</code></pre><p>要分多个步骤计算某些数据的MAC，请调用<code class="codeph">update</code>方法：</p><pre class="codeblock"><code>
    public void <span class="apiname">update(byte input)</span>;

    public void <span class="apiname">update(byte[] input)</span>;

    public void <span class="apiname">update(byte[] input, int inputOffset, int inputLen)</span>;
</code></pre><p>多部分操作必须由上述操作终止<code class="codeph">doFinal</code>方法（如果最后一步还有一些输入数据），或者通过以下方法之一<code class="codeph">doFinal</code>方法（如果最后一步没有输入数据）：</p><pre class="codeblock"><code>
    public byte[] <span class="apiname">doFinal()</span>;

    public void <span class="apiname">doFinal(byte[] output, int outOffset)</span>;
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC"></a><h4 id="JSSEC-GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" class="sect4">关键接口</h4>
                  <div>
                     <p>的<code class="codeph">java.security.Key</code> interface是所有不透明键的顶级接口。它定义了所有不透明键对象共享的功能。
                     </p>
                     <p>到此为止，我们已经集中了JCA的高级用法，而又不会迷失什么是密钥以及如何生成/表示密钥的细节。现在是时候将我们的注意力转移到按键上。</p>
                     <p><span class="variable" translate="no">opaque</span>密钥表示形式是您不能直接访问构成密钥的密钥材料的一种形式。换句话说：“不透明”可让您有限地访问密钥-只是由密钥定义的三种方法<code class="codeph">Key</code>界面（见下文）： <code class="codeph">getAlgorithm</code> ， <code class="codeph">getFormat</code>和<code class="codeph">getEncoded</code> 。
                     </p>
                     <p>这与<span class="variable" translate="no">transparent</span>表示法相反，在<span class="variable" translate="no">transparent</span>表示法中，您可以通过以下方式之一分别访问每个关键材料值： <code class="codeph">get</code>在相应的<span class="apiname">KeySpec</span>接口中定义的方法（请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组并提供类型安全。所有关键规范都必须实现此接口。">KeySpec接口</a> ）。
                     </p>
                     <p>所有不透明键都具有三个特征：</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-5B43C71A-CA72-4787-B3AE-F8FA11DF7866"><!-- --></a> <span class="bold">一种算法</span></dt>
                        <dd>该密钥的密钥算法。密钥算法通常是加密或非对称运算算法（例如<code class="codeph">AES</code> ， <code class="codeph">DSA</code>要么<code class="codeph">RSA</code> ），它将与这些算法以及相关算法（例如<code class="codeph">SHA256withRSA</code> ）。密钥算法的名称是使用以下方法获得的：<pre class="codeblock"><code>
String getAlgorithm()
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-5D585F10-ECBA-4A07-AC3D-5C3ABA919A6A"><!-- --></a> <span class="bold">编码表格</span></dt>
                        <dd>在Java虚拟机外部需要密钥的标准表示时（例如，将密钥传输给其他方时），使用密钥的外部编码形式。密钥根据标准格式（例如X.509或PKCS8）进行编码，并使用以下方法返回：<pre class="codeblock"><code>
byte[] getEncoded()
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-EC833FCD-5697-4E38-9933-6E336A126496"><!-- --></a> <span class="bold">格式</span></dt>
                        <dd>编码密钥的格式名称。它由方法返回：<pre class="codeblock"><code>
String getFormat()
</code></pre></dd>
                     </dl>
                     <p>密钥通常通过使用<span class="apiname">KeyFactory的</span>密钥生成器（例如<span class="apiname">KeyGenerator</span>类和<span class="apiname">KeyPairGenerator</span>类），证书，密钥规范（请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组并提供类型安全。所有关键规范都必须实现此接口。">KeySpec接口</a> ）或访问用于管理密钥的密钥库数据库的<span class="apiname">Keystore</span>实现来获取。可以使用<span class="apiname">KeyFactory</span>以算法相关的方式解析编码的密钥。
                     </p>
                     <p>也可以使用<span class="apiname">CertificateFactory</span>解析<span class="apiname">证书</span> 。
                     </p>
                     <p>这是扩展接口的列表<code class="codeph">Key</code>界面<code class="codeph">java.security.interfaces</code>和<code class="codeph">javax.crypto.interfaces</code>套餐：</p>
                     <ul style="list-style-type:disc">
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/SecretKey.html" target="_blank"><span class="apiname">密钥</span></a><ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/PBEKey.html" target="_blank"><span class="apiname">PBE密钥</span></a></li>
                           </ul>
                        </li>
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/PrivateKey.html" target="_blank"><span class="apiname">私钥</span></a><ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPrivateKey.html" target="_blank"><span class="apiname">DHPrivateKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPrivateKey.html" target="_blank"><span class="apiname">DSAPrivateKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/ECPrivateKey.html" target="_blank"><span class="apiname">私钥</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAMultiPrimePrivateCrtKey.html" target="_blank"><span class="apiname">RSAMultiPrimePrivateCrtKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateCrtKey.html" target="_blank"><span class="apiname">RSAPrivateCrtKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateKey.html" target="_blank"><span class="apiname">RSAPrivateKey</span></a></li>
                           </ul>
                        </li>
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/PublicKey.html" target="_blank"><span class="apiname">公钥</span></a><ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPublicKey.html" target="_blank"><span class="apiname">DHP公钥</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPublicKey.html" target="_blank"><span class="apiname">DSAP公共密钥</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/ECPublicKey.html" target="_blank"><span class="apiname">电子公钥</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><span class="apiname">RSAP公开密钥</span></a></li>
                           </ul>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-8D6CDB98-51C1-4211-8A4A-30BDD16FA7FD">PublicKey和PrivateKey接口</p>
                        <p>的<code class="codeph">PublicKey</code>和<code class="codeph">PrivateKey</code>接口（都扩展了<code class="codeph">Key</code>接口）是无方法接口，用于类型安全和类型标识。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B" name="GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B"></a><h4 id="JSSEC-GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B" class="sect4">密钥对类</h4>
                  <div>
                     <p>的<code class="codeph">KeyPair</code> class是密钥对（公共密钥和私有密钥）的简单持有者。
                     </p>
                     <div class="section">
                        <p>它有两种公共方法，一种用于返回私钥，另一种用于返回公钥：</p><pre class="codeblock"><code>
PrivateKey getPrivate()
PublicKey getPublic()
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" name="GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0"></a><h4 id="JSSEC-GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" class="sect4">关键规范接口和类</h4>
                  <div>
                     <p><code class="codeph">Key</code>对象和关键规格（ <code class="codeph">KeySpec</code> s）是密钥数据的两种不同表示形式。 <code class="codeph">Cipher</code>使用<code class="codeph">Key</code>对象初始化其加密算法，但可能需要将密钥转换为更可移植的格式以进行传输或存储。
                     </p>
                     <div class="section">
                        <p>键的<span class="variable" translate="no">transparent</span>表示意味着您可以通过以下方式之一分别访问每个键材料值： <code class="codeph">get</code>相应规范类中定义的方法。例如， <code class="codeph">DSAPrivateKeySpec</code>定义<code class="codeph">getX</code> ， <code class="codeph">getP</code> ， <code class="codeph">getQ</code>和<code class="codeph">getG</code>方法，以访问私钥<code class="codeph">x</code> ，以及用于计算密钥的DSA算法参数：素数<code class="codeph">p</code> ，次贷<code class="codeph">q</code>和基础<code class="codeph">g</code> 。如果密钥存储在硬件设备上，则其规范可能包含有助于识别设备上密钥的信息。
                        </p>
                        <p>此表示与“ <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。">关键接口”</a>界面定义的<span class="variable" translate="no">opaque</span>表示形成对比，在该<span class="variable" translate="no">opaque</span>表示中，您无法直接访问关键材质字段。换句话说，“不透明”表示使您只能有限地访问密钥-只是由<code class="codeph">Key</code>接口： <code class="codeph">getAlgorithm</code> ， <code class="codeph">getFormat</code>和<code class="codeph">getEncoded</code> 。
                        </p>
                        <p>可以以特定于算法的方式或以独立于算法的编码格式（例如ASN.1）来指定密钥。例如，DSA私钥可能由其组件指定<code class="codeph">x</code> ， <code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code> （看到<a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><code class="codeph">DSAPrivateKeySpec</code></a> ），也可以使用其DER编码进行指定（请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><code class="codeph">PKCS8EncodedKeySpec</code></a> ）。
                        </p>
                        <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A">KeyFactory类</a>和<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5E8F4099-779F-4484-9A95-F1CEA167601A">SecretKeyFactory类</a>类可用于在不透明和透明键表示之间进行转换（即，在<code class="codeph">Key</code>和<code class="codeph">KeySpec</code> s，假设可以进行操作。（例如，智能卡上的私钥可能无法离开卡。这样<code class="codeph">Key</code> s是不可转换的。）
                        </p>
                        <p>在以下各节中，我们将讨论关键的规范接口和类。 <code class="codeph">java.security.spec</code>包。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" name="GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF"></a><h5 id="JSSEC-GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" class="sect5">KeySpec界面</h5>
                     <div>
                        <p>该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组并提供类型安全。所有关键规范都必须实现此接口。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E" name="GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E"></a><h5 id="JSSEC-GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E" class="sect5">KeySpec子接口</h5>
                     <div>
                        <p>如<code class="codeph">Key</code>界面，有一套类似的<code class="codeph">KeySpec</code>接口。
                        </p>
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/SecretKeySpec.html" target="_blank"><code class="codeph">SecretKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/EncodedKeySpec.html" target="_blank"><code class="codeph">EncodedKeySpec</code></a> 
                                 <ul style="list-style-type:disc">
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><code class="codeph">PKCS8EncodedKeySpec</code></a></li>
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/X509EncodedKeySpec.html" target="_blank"><code class="codeph">X509EncodedKeySpec</code></a></li>
                                 </ul> 
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DESKeySpec.html" target="_blank"><code class="codeph">DESKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DESedeKeySpec.html" target="_blank"><code class="codeph">DESedeKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/PBEKeySpec.html" target="_blank"><code class="codeph">PBEKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHPrivateKeySpec.html" target="_blank"><code class="codeph">DHPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><code class="codeph">DSAPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECPrivateKeySpec.html" target="_blank"><code class="codeph">ECPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPrivateKeySpec.html" target="_blank"><code class="codeph">RSAPrivateKeySpec</code></a> 
                                 <ul style="list-style-type:disc">
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.html" target="_blank"><code class="codeph">RSAMultiPrimePrivateCrtKeySpec</code></a></li>
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPrivateCrtKeySpec.html" target="_blank"><code class="codeph">RSAPrivateCrtKeySpec</code></a></li>
                                 </ul> 
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHPublicKeySpec.html" target="_blank"><code class="codeph">DHPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPublicKeySpec.html" target="_blank"><code class="codeph">DSAPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECPublicKeySpec.html" target="_blank"><code class="codeph">ECPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPublicKeySpec.html" target="_blank"><code class="codeph">RSAPublicKeySpec</code></a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4" name="GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4"></a><h5 id="JSSEC-GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4" class="sect5">EncodedKeySpec类</h5>
                     <div>
                        <div class="section">
                           <p>此抽象类（实现<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组并提供类型安全。所有关键规范都必须实现此接口。">KeySpec接口</a>接口）以编码格式表示公钥或私钥。它的<span class="apiname">getEncoded</span>方法返回编码的密钥：</p><pre class="codeblock"><code>
abstract byte[] getEncoded();
</code></pre><p>其<span class="apiname">getFormat</span>方法返回编码格式的名称：</p><pre class="codeblock"><code>
abstract String getFormat();
</code></pre><p>具体实现请参见下一部分<code class="codeph">PKCS8EncodedKeySpec</code>和<code class="codeph">X509EncodedKeySpec</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E" name="GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E"></a><h6 id="JSSEC-GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E" class="sect6">PKCS8EncodedKeySpec类</h6>
                        <div>
                           <p>此类，是以下类的子类<code class="codeph">EncodedKeySpec</code>表示根据PKCS8标准中指定的格式的私钥的DER编码。
                           </p>
                           <div class="section">
                              <p>它的<span class="apiname">getEncoded</span>方法返回根据PKCS8标准编码的密钥字节。其<span class="apiname">getFormat</span>方法返回字符串“ PKCS＃8”。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" name="GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC"></a><h6 id="JSSEC-GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" class="sect6">X509EncodedKeySpec类别</h6>
                        <div>
                           <p>此类，是以下类的子类<code class="codeph">EncodedKeySpec</code>表示根据X.509标准指定的格式的公共密钥的DER编码。
                           </p>
                           <div class="section">它的<code class="codeph">getEncoded</code>方法返回根据X.509标准编码的密钥字节。它的<code class="codeph">getFormat</code>方法返回字符串“ X.509”。
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578" name="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578"></a><h4 id="JSSEC-GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578" class="sect4">发电机和工厂</h4>
                  <div>
                     <p>尤其是Java和JCA API的新手有时并不了解生成器和工厂之间的区别。</p>
                     <div class="figure" id="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578__GUID-39757065-9091-43DE-8CEC-C1E00A75DF36">
                        <p class="titleinfigure">图2-10发电机和工厂</p><img src="img/genrator-factory.gif" alt="如下图2-10所示" title="如下图2-10所示" longdesc="img_text/genrator-factory.html"><br><a href="img_text/genrator-factory.html">“图2-10生成器和工厂”的描述</a></div>
                     <!-- class="figure" -->
                     <p>生成器用于<span class="bold">生成全新的对象</span> 。生成器可以以算法相关或算法独立的方式初始化。例如，要创建Diffie-Hellman（DH）密钥对，应用程序可以指定必要的P和G值，或者可以使用适当的密钥长度简单地初始化生成器，然后生成器将选择适当的P和G值。在这两种情况下，生成器都会根据参数生成全新的密钥。
                     </p>
                     <p>另一方面，工厂用于<span class="bold">将数据从一种现有的对象类型转换为另一种</span> 。例如，一个应用程序可能具有DH私钥的组件，并且可以将它们打包为<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组并提供类型安全。所有关键规范都必须实现此接口。">TheKeySpec接口</a> ，但需要将它们转换为可由用户使用的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。">PrivateKey</a>对象。 <code class="codeph">KeyAgreement</code>对象，反之亦然。或者他们可能具有证书的字节数组，但需要使用<code class="codeph">CertificateFactory</code>转换成<code class="codeph">X509Certificate</code>宾语。应用程序使用工厂对象进行转换。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A" name="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A"></a><h5 id="JSSEC-GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A" class="sect5">KeyFactory类</h5>
                     <div>
                        <div class="section">
                           <p>的<code class="codeph">KeyFactory</code> class是<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法，</a>旨在在不透明的加密<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。">密钥接口</a>与<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" title="密钥对象和密钥规范（KeySpecs）是密钥数据的两种不同表示形式。密码使用Key对象初始化其加密算法，但是可能需要将密钥转换为更可移植的格式以进行传输或存储。">密钥规范接口和类</a> （底层密钥材料的透明表示）之间执行转换。
                           </p>
                           <div class="figure" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-A3F628B1-EA36-4F80-9FB3-18565C99D33D">
                              <p class="titleinfigure">图2-11 KeyFactory类</p><img src="img/keyfactory.gif" alt="如下图2-11所示" title="如下图2-11所示" longdesc="img_text/keyfactory.html"><br><a href="img_text/keyfactory.html">“图2-11 KeyFactory类”的描述</a></div>
                           <!-- class="figure" -->
                           <p>关键工厂是双向的。它们使您可以根据给定的密钥规范（密钥材料）构建不透明的密钥对象，或以合适的格式检索密钥对象的基础密钥材料。</p>
                           <p>同一密钥可以存在多个兼容的密钥规范。例如，DSA公钥可以由其组件指定<code class="codeph">y</code> ， <code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code> （看到<code class="codeph">java.security.spec.DSAPublicKeySpec</code> ），也可以根据X.509标准使用其DER编码进行指定（请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" title="此类是EncodedKeySpec的子类，根据X.509标准中指定的格式表示公钥的DER编码。">X509EncodedKeySpec类</a> ）。
                           </p>
                           <p>密钥工厂可用于在兼容的密钥规范之间进行转换。可以通过在兼容的密钥规范之间进行转换来实现密钥解析，例如，当您从<code class="codeph">X509EncodedKeySpec</code>至<code class="codeph">DSAPublicKeySpec</code> ，您基本上将编码后的密钥解析为其组件。有关示例，请参见“ <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="使用密钥规范和KeyFactory生成和验证签名的示例代码。">使用密钥规范和KeyFactory生成/验证签名”</a>部分的末尾。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-6E7550BC-EB9D-4DEA-B0DD-4702CB60B8FB">创建一个KeyFactory对象</p>
                           <p><code class="codeph">KeyFactory</code>通过使用其中之一获得对象<code class="codeph">KeyFactory</code> getInstance（）静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-44809676-3275-4B3B-A0DF-D22B66E32E8F">在密钥规范和密钥对象之间转换</p>
                           <p>如果您具有公开密钥的密钥规范，则可以获得不透明<code class="codeph">PublicKey</code>通过使用<code class="codeph">generatePublic</code>方法：</p><pre class="codeblock"><code>
PublicKey generatePublic(KeySpec keySpec)
</code></pre><p>同样，如果您有私钥的密钥规范，则可以获得不透明<code class="codeph">PrivateKey</code>通过使用<code class="codeph">generatePrivate</code>方法：</p><pre class="codeblock"><code>
PrivateKey generatePrivate(KeySpec keySpec)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-80B6E726-0D4C-4527-BE7C-DBEC57850569">在关键对象和关键规格之间转换</p>
                           <p>如果你有一个<code class="codeph">Key</code>对象，您可以通过调用<code class="codeph">getKeySpec</code>方法：</p><pre class="codeblock"><code>
KeySpec getKeySpec(Key key, Class keySpec)
</code></pre><p><code class="codeph">keySpec</code>标识应返回密钥材料的规范类。例如，它可能是<code class="codeph">DSAPublicKeySpec.class</code> ，以指示应在以下情况下返回密钥材料： <code class="codeph">DSAPublicKeySpec</code>类。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="使用密钥规范和KeyFactory生成和验证签名的示例代码。">使用密钥规范和KeyFactory生成/验证签名</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A" name="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A"></a><h5 id="JSSEC-GUID-5E8F4099-779F-4484-9A95-F1CEA167601A" class="sect5">SecretKeyFactory类</h5>
                     <div>
                        <div class="section">
                           <p>的<code class="codeph">SecretKeyFactory</code>类表示密钥的工厂。与<span class="apiname">KeyFactory</span>类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A">KeyFactory类</a> ）不同， <code class="codeph">javax.crypto.SecretKeyFactory</code>对象仅对秘密（对称）密钥进行操作，而<code class="codeph">java.security.KeyFactory</code>对象处理密钥对的公共和私有密钥组件。
                           </p>
                           <div class="figure" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-B147D33F-7429-4584-82BD-71838EA98DE1">
                              <p class="titleinfigure">图2-12 SecretKeyFactory类</p><img src="img/secretkeyfactory.png" alt="如下图2-12所示" title="如下图2-12所示" longdesc="img_text/secretkeyfactory.html"><br><a href="img_text/secretkeyfactory.html">“图2-12 SecretKeyFactory类”的描述</a></div>
                           <!-- class="figure" -->
                           <p>密钥工厂用于转换<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="java.security。键界面是所有不透明键的顶级界面。它定义了所有不透明键对象共享的功能。">密钥接口</a> （类型为不透明的加密密钥） <code class="codeph">java.security.Key</code> ）添加到<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" title="密钥对象和密钥规范（KeySpecs）是密钥数据的两种不同表示形式。密码使用Key对象初始化其加密算法，但是可能需要将密钥转换为更可移植的格式以进行传输或存储。">密钥规范接口和类</a> （以适当的格式对底层密钥材料进行透明表示），反之亦然。
                           </p>
                           <p>类型的对象<code class="codeph">java.security.Key</code> ， 其中<code class="codeph">java.security.PublicKey</code> ， <code class="codeph">java.security.PrivateKey</code>和<code class="codeph">javax.crypto.SecretKey</code>是子类，是不透明的键对象，因为您无法确定它们是如何实现的。底层实现依赖于提供者，并且可以基于软件或硬件。密钥工厂允许提供者提供自己的加密密钥实现。
                           </p>
                           <p>例如，如果您有一个Diffie-Hellman公钥的密钥规范，其中包含公有值<code class="codeph">y</code> ，素数模<code class="codeph">p</code>和基础<code class="codeph">g</code> ，然后您将相同的规范从不同的提供商提供给Diffie-Hellman关键工厂，结果<code class="codeph">PublicKey</code>对象很可能具有不同的基础实现。
                           </p>
                           <p>提供者应记录其私钥工厂支持的密钥规范。例如， <code class="codeph">SecretKeyFactory</code>用于由<code class="codeph">SunJCE</code>提供者支持<code class="codeph">DESKeySpec</code>作为DES密钥的透明表示， <code class="codeph">SecretKeyFactory</code>用于DES-EDE键支持<code class="codeph">DESedeKeySpec</code>作为DES-EDE密钥的透明表示，并且<code class="codeph">SecretKeyFactory</code>用于PBE支持<code class="codeph">PBEKeySpec</code>作为基础密码的透明表示。
                           </p>
                           <p>以下是如何使用<code class="codeph">SecretKeyFactory</code>将密钥数据转换为<code class="codeph">SecretKey</code>对象，可用于后续<code class="codeph">Cipher</code>操作：</p><pre class="codeblock"><code>    // Note the following bytes are not realistic secret key data
    // bytes but are simply supplied as an illustration of using data
    // bytes (key material) you already have to build a DESedeKeySpec.

    byte[] desEdeKeyData = getKeyData();
    DESedeKeySpec desEdeKeySpec = new DESedeKeySpec(desEdeKeyData);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");
    SecretKey secretKey = keyFactory.generateSecret(desEdeKeySpec);
</code></pre><p>在这种情况下，底层实现<code class="codeph">SecretKey</code>基于提供者<code class="codeph">KeyFactory</code> 。
                           </p>
                           <p>创建功能上等效的另一种独立于提供者的方式<code class="codeph">SecretKey</code>来自相同关键材料的对象是使用<code class="codeph">javax.crypto.spec.SecretKeySpec</code>类，它实现了<code class="codeph">javax.crypto.SecretKey</code>接口：</p><pre class="codeblock"><code>    byte[] aesKeyData = getKeyData();
    SecretKeySpec secretKey = new SecretKeySpec(aesKeyData, "AES");</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-38991B45-AE09-4FF3-AD97-D94141BB6B6D">创建一个SecretKeyFactory对象</p>
                           <p>通过使用<span class="apiname">SecretKeyFactory</span> <span class="apiname">getInstance（）</span>静态工厂方法之一获得<span class="apiname">SecretKeyFactory</span>对象。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-984E30C8-DB95-46BF-AC9C-3300225E5369">在密钥规范和秘密密钥对象之间转换</p>
                           <p>如果您具有密钥的密钥规范，则可以使用<span class="apiname">generateSecret</span>方法从该规范中获得一个不透明的<span class="apiname">SecretKey</span>对象：</p><pre class="pre codeblock"><code>SecretKey generateSecret(KeySpec keySpec)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-AB93CE9F-2B82-451F-ABDF-FB57D6BBE3D1">在密钥对象和密钥规范之间转换</p>
                           <p>如果您有<span class="apiname">SecretKey</span>对象，则可以通过调用<span class="apiname">getKeySpec</span>方法来获取相应的密钥规范对象：</p><pre class="pre codeblock"><code>KeySpec getKeySpec(Key key, Class keySpec)</code></pre><p><span class="apiname">keySpec</span>标识应返回密钥材料的规范类。例如，它可能是<code class="codeph">DESKeySpec.class</code> ，以指示应在<span class="apiname">DESKeySpec</span>类的实例中返回密钥材料。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD" name="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD"></a><h5 id="JSSEC-GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD" class="sect5">KeyPairGenerator类</h5>
                     <div>
                        <div class="section">
                           <p>的<code class="codeph">KeyPairGenerator</code> class是一个引擎类（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> ），用于生成成对的公钥和私钥。
                           </p>
                           <div class="figure" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-3DB89ACB-BF5C-4155-B2BF-E3ED4BEACE8D">
                              <p class="titleinfigure">图2-13 KeyPairGenerator类</p><img src="img/keypairgenerator.gif" alt="如下图2-13所示" title="如下图2-13所示" longdesc="img_text/keypairgenerator.html"><br><a href="img_text/keypairgenerator.html">“图2-13 KeyPairGenerator类”的描述</a></div>
                           <!-- class="figure" -->
                           <p>有两种生成密钥对的方法：以独立于算法的方式和以特定于算法的方式。两者之间的唯一区别是对象的初始化。</p>
                           <p>有关调用以下记录的方法的示例，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="在此示例中，我们将为名为的算法生成一个公钥-私钥对" ds="=" ="">生成密钥</a>对。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-1BBCE846-5B0A-49B6-8EF0-4A61D7933250">创建一个KeyPairGenerator</p>
                           <p>所有密钥对的生成均以<code class="codeph">KeyPairGenerator</code> 。 <code class="codeph">KeyPairGenerator</code>通过使用其中之一获得对象<code class="codeph">KeyPairGenerator</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-671069E3-BACA-4C28-9F68-4B4E0F9C8B1E">初始化KeyPairGenerator</p>
                           <p>用于特定算法的密钥对生成器会创建可与此算法一起使用的公共/私有密钥对。它还将算法特定的参数与每个生成的密钥相关联。</p>
                           <p>密钥对生成器需要先初始化，然后才能生成密钥。在大多数情况下，与算法无关的初始化就足够了。但是在其他情况下，可以使用特定于算法的初始化。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-FC22CAF1-9AD8-4679-A908-D4E426C90F94">独立于算法的初始化</p>
                           <p>所有密钥对生成器都共享密钥大小和随机性源的概念。对于不同的算法，密钥大小的解释不同。例如，在DSA算法的情况下，密钥大小对应于模数的长度。（有关特定算法的密钥大小的信息，请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。）
                           </p>
                           <p>一个<code class="codeph">initialize</code>方法采用两种通用共享的参数类型：</p><pre class="codeblock"><code>void initialize(int keysize, SecureRandom random)
</code></pre><p>另一个<code class="codeph">initialize</code>方法只需要一个<code class="codeph">keysize</code>论点它使用系统提供的随机性来源：</p><pre class="codeblock"><code>void initialize(int keysize)
</code></pre><p>由于在调用上述与算法无关时没有指定其他参数<code class="codeph">initialize</code>方法，取决于提供者如何处理与每个密钥相关联的特定于算法的参数（如果有）。
                           </p>
                           <p>如果该算法是“ DSA”算法，并且模数大小（键大小）为512、768、1024、2048或3072，则<code class="codeph">SUN</code>提供者使用一组预先计算的值<code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code>参数。如果模量大小不是上述值之一，则<code class="codeph">SUN</code>提供者创建一组新的参数。其他提供者可能已经为超过上述三个模量大小的参数进行了预先计算的参数设置。还有一些可能根本没有预先计算的参数列表，而是总是创建新的参数集。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-0A3EC297-448C-4202-A12E-4D236E540D05">特定于算法的初始化</p>
                           <p>对于已经存在一组特定于算法的参数（例如DSA中的“社区参数”）的情况，有两个<code class="codeph">initialize</code>具有<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-190C91B4-991D-416E-A932-C0E37B33A86D" title="AlgorithmParameterSpec是一个透明的加密参数规范的接口。该接口不包含任何方法或常量。其唯一目的是对所有参数规范进行分组（并提供类型安全性）。所有参数规范都必须实现此接口。">The AlgorithmParameterSpec接口</a>参数的方法。一个也有一个<code class="codeph">SecureRandom</code>参数，而随机性的来源是系统为另一个提供的：</p><pre class="codeblock"><code>void initialize(AlgorithmParameterSpec params,
                SecureRandom random)

void initialize(AlgorithmParameterSpec params)
</code></pre><p>请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="在此示例中，我们将为名为的算法生成一个公钥-私钥对" ds="=" ="">生成一对密钥</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-385C2D11-785F-437E-BEA9-A3FAE8259954">生成密钥对</p>
                           <p>不管初始化（和算法）如何，生成密钥对的过程总是相同的。您总是从以下方式调用以下方法<code class="codeph">KeyPairGenerator</code> ：</p><pre class="codeblock"><code>KeyPair generateKeyPair()
</code></pre><p>多次致电<code class="codeph">generateKeyPair</code>将产生不同的密钥对。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" name="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1"></a><h5 id="JSSEC-GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" class="sect5">KeyGenerator类</h5>
                     <div>
                        <p>密钥生成器用于生成对称算法的秘密密钥。</p>
                        <div class="section">
                           <p></p>
                           <div class="figure" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-E128C2F7-1771-4798-AD6F-023E341AE627">
                              <p class="titleinfigure">图2-14 KeyGenerator类</p><img src="img/keygenerator.gif" alt="如下图2-14所示" title="如下图2-14所示" longdesc="img_text/keygenerator.html"><br><a href="img_text/keygenerator.html">“图2-14 KeyGenerator类”的描述</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-740D1207-E50A-4EF4-963D-A2120557B06F">创建一个<code class="codeph">KeyGenerator</code></p>
                           <p> <code class="codeph">KeyGenerator</code>通过使用其中之一获得对象<code class="codeph">KeyGenerator</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-BAF56E68-3D3B-49C4-BB0F-C04C3263C59F">初始化KeyGenerator对象</p>
                           <p>用于特定对称密钥算法的密钥生成器创建可以与该算法一起使用的对称密钥。它还将特定于算法的参数（如果有）与生成的密钥相关联。</p>
                           <p>有两种生成密钥的方法：以独立于算法的方式以及以特定于算法的方式。两者之间的唯一区别是对象的初始化：</p>
                           <ul style="list-style-type:disc">
                              <li><span class="bold">独立于算法的初始化</span> 
                                 <p>所有密钥生成器都共享<span class="variable" translate="no">keysize</span>和<span class="variable" translate="no">source of randomness</span>的概念。有一个<code class="codeph">init</code>接受这两种通用类型的参数的方法。还有一个只需要一个<code class="codeph">keysize</code>参数，并使用系统提供的随机性源，而仅使用随机性源：</p> <pre class="codeblock"><code>

    public void init(SecureRandom random);

    public void init(int keysize);

    public void init(int keysize, SecureRandom random);
</code></pre> <p>由于在调用上述与算法无关时没有指定其他参数<code class="codeph">init</code>方法，取决于提供者如何处理与生成的密钥相关联的特定于算法的参数（如果有）。
                                 </p> 
                              </li>
                              <li><span class="bold">特定于算法的初始化</span> 
                                 <p>对于已经存在一组特定于算法的参数的情况，有两个<code class="codeph">init</code>具有<code class="codeph">AlgorithmParameterSpec</code>论点。一个也有一个<code class="codeph">SecureRandom</code>参数，而随机性的来源是系统为另一个提供的：</p> <pre class="codeblock"><code>
    public void init(AlgorithmParameterSpec params);

    public void init(AlgorithmParameterSpec params, SecureRandom random);
</code></pre></li>
                           </ul>
                           <p>如果客户端未显式初始化KeyGenerator（通过调用<code class="codeph">init</code>方法），每个提供程序必须提供（和记录）默认的初始化。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-86C7A73B-30DE-4CBA-A744-815938F78741">创建密钥</p>
                           <p>以下方法生成一个密钥：</p><pre class="codeblock"><code>
    public SecretKey generateKey();
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" name="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31"></a><h4 id="JSSEC-GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" class="sect4">密钥协议类</h4>
                  <div>
                     <p>密钥协商是一种协议，通过该协议，两个或更多方可以建立相同的加密密钥，而不必交换任何秘密信息。</p>
                     <div class="section">
                        <div class="figure" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-98958A82-0755-47FC-9ABD-EF5482B7C7E7">
                           <p class="titleinfigure">图2-15 KeyAgreement类</p><img src="img/keyagreement.gif" alt="如下图2-15所示" title="如下图2-15所示" longdesc="img_text/keyagreement.html"><br><a href="img_text/keyagreement.html">“图2-15 KeyAgreement类”的描述</a></div>
                        <!-- class="figure" -->
                        <p>各方使用其私钥初始化其密钥协商对象，然后为将参与通信的各方输入公用密钥。在大多数情况下，只有两个参与方，但是Diffie-Hellman之类的算法允许多个参与方（3个或更多）参与。输入所有公共密钥后，每个<code class="codeph">KeyAgreement</code>对象将生成（同意）相同的密钥。
                        </p>
                        <p>KeyAgreement类提供了密钥协商协议的功能。建立共享机密所涉及的密钥是由密钥生成器之一创建的（ <code class="codeph">KeyPairGenerator</code>要么<code class="codeph">KeyGenerator</code> ）， 一种<code class="codeph">KeyFactory</code> ，或者是密钥协商协议的中间阶段的结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-7A60031C-0F65-435C-BABE-CC97DC6E9B1D">创建一个KeyAgreement对象</p>
                        <p>参与密钥协议的每一方都必须创建一个KeyAgreement对象。 <code class="codeph">KeyAgreement</code>通过使用其中之一获得对象<code class="codeph">KeyAgreement</code> <span class="apiname">getInstance（）</span>静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-80712056-629B-48EB-87D7-65AE14AEC64F">初始化KeyAgreement对象</p>
                        <p>您使用您的私人信息初始化KeyAgreement对象。对于Diffie-Hellman，您可以使用Diffie-Hellman私钥对其进行初始化。附加的初始化信息可以包含随机性源和/或一组算法参数。请注意，如果所请求的密钥协商算法要求指定算法参数，并且仅提供一个密钥，但不提供任何参数来初始化KeyAgreement对象，则密钥必须包含所需的算法参数。（例如，Diffie-Hellman算法使用素数模<code class="codeph">p</code>和一个基础发电机<code class="codeph">g</code>作为其参数。）
                        </p>
                        <p>要初始化KeyAgreement对象，请调用其对象之一<code class="codeph">init</code>方法：</p><pre class="codeblock"><code>
    public void init(Key key);

    public void init(Key key, SecureRandom random);

    public void init(Key key, AlgorithmParameterSpec params);

    public void init(Key key, AlgorithmParameterSpec params,
                     SecureRandom random);
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-8E5226BB-CAE3-4CCF-A501-139EB5F1F258">执行密钥协议阶段</p>
                        <p>每个密钥协议协议都包含多个阶段，这些阶段需要由参与密钥协议的各方执行。</p>
                        <p>要执行密钥协议中的下一阶段，请调用<span class="apiname">doPhase</span>方法：</p><pre class="codeblock"><code>
    public Key doPhase(Key key, boolean lastPhase);
</code></pre><p>的<code class="codeph">key</code>参数包含该阶段要处理的密钥。在大多数情况下，这是密钥协议中所涉及的另一方的公钥，或者是上一阶段生成的中间密钥。 <code class="codeph">doPhase</code>可能会返回一个中间密钥，您可能必须将该中间密钥发送给此密钥协议的其他各方，以便他们可以在后续阶段中进行处理。
                        </p>
                        <p>的<code class="codeph">lastPhase</code>参数指定要执行的阶段是否是关键协议中的最后一个阶段：的值<code class="codeph">FALSE</code>表示这不是关键协议的最后阶段（还有更多阶段需要遵循），值为<code class="codeph">TRUE</code>表示这是关键协议的最后阶段，并且关键协议已完成，即<code class="codeph">generateSecret</code>可以称为下一个。
                        </p>
                        <p>在<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" title="The program runs the Diffie-Hellman key agreement protocol between 2 parties.">2方之间</a>的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" title="该程序在两方之间运行Diffie-Hellman密钥协商协议。">Diffie-Hellman密钥交换</a>示例中，您调用<code class="codeph">doPhase</code>一次，与<code class="codeph">lastPhase</code>调成<code class="codeph">TRUE</code> 。在三方之间的Diffie-Hellman的示例中，您称<code class="codeph">doPhase</code>两次：第一次<code class="codeph">lastPhase</code>调成<code class="codeph">FALSE</code> ，第二次<code class="codeph">lastPhase</code>调成<code class="codeph">TRUE</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-A5713E1A-EA50-4F0B-8059-1B355A8D559E">产生共享秘密</p>
                        <p>各方执行完所有必需的密钥协商阶段后，可以通过调用<span class="apiname">generateSecret</span>方法之一来计算共享密钥：</p><pre class="codeblock"><code>
    public byte[] generateSecret();

    public int generateSecret(byte[] sharedSecret, int offset);

    public SecretKey generateSecret(String algorithm);
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" name="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA"></a><h4 id="JSSEC-GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" class="sect4">密钥管理</h4>
                  <div>
                     <p>可以使用称为“密钥库”的数据库来管理密钥和证书的存储库。（ <span class="variable" translate="no">certificate</span>是来自一个实体的经过数字签名的声明，表示其他实体的公钥具有特定的值。）
                     </p>
                     <div class="section" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__KEYSTORELOCATION-86EBB624">
                        <p class="subhead3" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-B8BFF73B-B9BA-4A1E-B465-6C186EA054DD">密钥库位置</p>
                        <p>默认情况下，用户密钥库存储在名为的文件中<code class="codeph">.keystore</code>在用户的主目录中，由<code class="codeph">user.home</code>系统属性，其默认值取决于操作系统：</p>
                        <ul style="list-style-type:disc">
                           <li>Solaris，Linux和MacOS：<code class="codeph">/home/<span class="variable" translate="no">username</span>/</code></li>
                           <li>视窗：<code class="codeph">C:\Users\<span class="variable" translate="no">username</span>\</code></li>
                        </ul>
                        <p>当然，密钥库文件可以根据需要定位。在某些环境中，存在多个密钥库可能很有意义。例如，一个密钥库可能保存用户的私钥，而另一个可能保存用于建立信任关系的证书。</p>
                        <p>除了用户的密钥库之外，JDK还维护一个系统范围的密钥库，该密钥库用于存储来自各种证书颁发机构（CA）的受信任证书。这些CA证书可用于帮助做出信任决策。例如，在SSL / TLS / DTLS中，当<code class="codeph">SunJSSE</code>提供者将获得来自远程对等方的证书，默认的trustmanager将查阅以下文件之一，以确定是否要信任连接：</p>
                        <ul style="list-style-type:disc">
                           <li>Solaris，Linux和MacOS：<code class="codeph"><span class="variable" translate="no"><java-home></span>/lib/security/cacerts</code></li>
                           <li>视窗：<code class="codeph"><span class="variable" translate="no"><java-home></span>\lib\security\cacerts</code></li>
                        </ul>
                        <p>而不是使用系统范围的<code class="codeph">cacerts</code>密钥库，应用程序可以设置和使用自己的密钥库，甚至可以使用上述用户密钥库。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__KEYSTOREIMPLEMENTATION-86EBBA97">
                        <p class="subhead3" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-F8DDBE94-9E8B-410D-B772-3F2188373D58">密钥库实现</p>
                        <p>的<code class="codeph">KeyStore</code>类提供了定义明确的接口来访问和修改密钥库中的信息。可能有多个不同的具体实现，其中每个实现都是针对特定<span class="variable" translate="no">type</span>的密钥库的实现。
                        </p>
                        <p>当前，有两个命令行工具可以利用<code class="codeph">KeyStore</code> ： <span class="bold"><code class="codeph">keytool</code></span>和<span class="bold"><code class="codeph">jarsigner</code></span> ，还有一个基于GUI的工具，名为<span class="bold"><code class="codeph">policytool</code></span> 。它也被<code class="codeph">Policy</code>它在处理策略文件时参考实现，这些策略文件指定了将被授予来自各种来源的代码的权限（允许访问系统资源）。以来<code class="codeph">KeyStore</code>由于是公开可用的，JDK用户可以编写使用它的其他安全应用程序。
                        </p>
                        <p>应用程序可以使用以下选项从不同的提供程序中选择不同<span class="variable" translate="no">types</span>的密钥库实现： <code class="codeph">getInstance</code>工厂方法<code class="codeph">KeyStore</code>类。密钥库类型定义了密钥库信息的存储和数据格式，以及用于保护密钥库中的私钥和密钥库本身完整性的算法。不同类型的密钥库实现不兼容。
                        </p>
                        <p>默认的密钥库实现是“ pkcs12”。这是一个基于RSA PKCS12个人信息交换语法标准的跨平台密钥库。该标准主要用于存储或传输用户的私钥，证书和其他机密信息。可以将任意属性与PKCS12密钥库中的各个条目相关联。</p><pre class="codeblock"><code>    keystore.type=pkcs12
</code></pre><p>要使工具和其他应用程序使用不同的默认密钥库实现，可以更改该行以指定其他类型。</p>
                        <p>一些应用程序，例如<code class="codeph">keytool</code> ，还可以让您覆盖默认的密钥库类型（通过<code class="codeph">-storetype</code>命令行参数）。
                        </p>
                        <div class="infoboxnote" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-AFAA8199-86D1-45F8-B282-F34CAEFAA44A">
                           <p class="notep1">注意：</p>密钥库类型名称不区分大小写。例如，“ jks”将被视为与“ JKS”相同。
                        </div>
                        <p>PKCS12是默认的推荐密钥存储类型。但是，JDK实现附带了其他三种类型的密钥库。</p>
                        <ol>
                           <li><span class="bold">“ jceks”</span>是“ jks”的备用专有密钥库格式，该格式使用基于密码的加密和Triple-DES。<p>“ jceks”实现可以解析“ jks”密钥库文件并将其转换为“ jceks”格式。您可以通过更改密钥库中的私钥条目的密码并指定，将“ jks”类型的密钥库升级为“ jceks”类型的密钥库<code class="codeph">"-storetype jceks"</code>作为密钥库类型。要将提供给默认密钥存储区中名为“ signkey”的私钥的加密强密钥保护，请使用以下命令，该命令将提示您输入新旧密钥密码：</p> <pre class="codeblock"><code>    keytool -keypass -alias signkey -storetype jceks
</code></pre>请参阅《 <span><cite>Java平台标准版工具参考》中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> 。
                           </li>
                           <li><span class="bold">“ jks”</span>是另一种选择。它利用专有密钥库类型（格式）将密钥库实现为文件。它使用自己的密码保护每个私钥，并使用（可能不同的）密码保护整个密钥库的完整性。
                           </li>
                           <li><span class="bold">“ dks”</span>是域密钥库。它是作为单个逻辑密钥库呈现的密钥库的集合。构成给定域的密钥库由配置数据指定，其语法在<a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a> 。
                           </li>
                        </ol>
                        <p>密钥库实现是基于提供程序的。如果要编写自己的KeyStore实现，请参见<a href="howtoimplaprovider.html#GUID-C485394F-08C9-4D35-A245-1B82CDDBC031" title="本文档介绍了将提供程序集成到Java SE时需要执行的操作，以便在Java Security API客户端请求它们时可以找到算法和其他服务。">如何在Java密码体系结构中实现提供者</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-09050137-31F1-468A-A552-B051A4E35876" name="GUID-09050137-31F1-468A-A552-B051A4E35876"></a><h5 id="JSSEC-GUID-09050137-31F1-468A-A552-B051A4E35876" class="sect5">KeyStore类</h5>
                     <div>
                        <p>的<code class="codeph">KeyStore</code>类提供了定义明确的接口来访问和修改密钥库中的信息。
                        </p>
                        <div class="section">
                           <p>的<code class="codeph">KeyStore</code> class是<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。
                           </p>
                           <div class="figure" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-E500AFDF-303F-4F6A-8F30-B78446C385BC">
                              <p class="titleinfigure">图2-16 KeyStore类</p><img src="img/keystore.png" alt="如下图2-16所示" title="如下图2-16所示" longdesc="img_text/keystore.html"><br><a href="img_text/keystore.html">“图2-16 KeyStore类”的描述</a></div>
                           <!-- class="figure" -->
                           <p>此类表示密钥和证书的内存中集合。 <code class="codeph">KeyStore</code>管理两种类型的条目：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="bold">密钥条目</span> ：这种类型的密钥库条目包含非常敏感的加密密钥信息，必须加以保护以防止未经授权的访问。通常，存储在这种类型的条目中的密钥是秘密密钥，或者是带有对相应公钥进行身份验证的证书链的私钥。
                                 </p>
                                 <p>给定实体使用私钥和证书链使用数字签名进行自我认证。例如，作为发行和/或许可软件的一部分，软件分发组织对数字JAR文件进行签名。</p>
                              </li>
                              <li>
                                 <p><span class="bold">可信证书条目</span> ：此类型的条目包含属于另一方的单个公共密钥证书。之所以称为<span class="variable" translate="no">trusted certificate</span> ，是因为密钥库所有者相信证书中的公钥确实属于证书的<span class="variable" translate="no">subject</span> （所有者）所标识的身份。
                                 </p> 
                                 <p>这种类型的条目可用于验证其他方。</p>
                              </li>
                           </ul>
                           <p>密钥库中的每个条目都由“别名”字符串标识。对于私钥及其关联的证书链，这些字符串区分了实体进行身份验证的不同方式。例如，实体可以使用不同的证书颁发机构或使用不同的公钥算法对自己进行身份验证。</p>
                           <p>在此未指定密钥库是否是持久性的，以及密钥库是否是持久性的。该约定允许使用多种技术来保护敏感（例如，私有或秘密）密钥。智能卡或其他集成的加密引擎（SafeKeyper）是一种选择，也可以使用更简单的机制（例如文件）（多种格式）。</p>
                           <p>主要的<code class="codeph">KeyStore</code>方法如下所述。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-10CBBC1C-9B28-406F-868B-905F60CBBB7B">创建密钥库对象</p>
                           <p>通过使用KeyStore getInstance（）方法之一来获取KeyStore对象。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-0D63C81B-715D-42F3-8E1D-035E950EA8A8">将特定的密钥库加载到内存中</p>
                           <p>之前<code class="codeph">KeyStore</code>可以使用对象，实际的密钥库数据必须通过<span class="apiname">load</span>方法加载到内存中：</p><pre class="codeblock"><code>
final void load(InputStream stream, char[] password)
</code></pre><p>可选密码用于检查密钥库数据的完整性。如果未提供密码，则不执行完整性检查。</p>
                           <p>要创建一个空的密钥库，您可以通过<code class="codeph">null</code>作为<code class="codeph">InputStream</code> <span class="apiname">load</span>方法的参数。
                           </p>
                           <p>通过传递一个DKS密钥库来加载<a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a>替代加载方法：</p><pre class="codeblock"><code>
final void load(KeyStore.LoadStoreParameter param)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-C472C461-E71E-43C3-B647-D0E1C1AC6423">获取密钥库别名列表</p>
                           <p>所有密钥库条目均通过唯一<span class="variable" translate="no">aliases</span>访问。的<code class="codeph">aliases</code>方法返回密钥库中别名的枚举：</p><pre class="codeblock"><code>
final Enumeration aliases()
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-C394000F-70E5-47EF-927B-405E6D15E2A9">确定密钥库条目类型</p>
                           <p>如KeyStore类中所述，密钥库中有两种不同类型的条目。下列方法分别确定由给定别名指定的条目是密钥/证书还是受信任的证书条目：</p><pre class="codeblock"><code>
final boolean isKeyEntry(String alias)
final boolean isCertificateEntry(String alias)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-1DEA7EF6-2C1D-4B27-B6D2-254BD157FFE0">添加/设置/删除密钥库条目</p>
                           <p><span class="apiname">setCertificateEntry</span>方法将证书分配给指定的别名：</p><pre class="codeblock"><code>
final void setCertificateEntry(String alias, Certificate cert)
</code></pre><p>如果<code class="codeph">alias</code>不存在，将创建具有该别名的受信任证书条目。如果<code class="codeph">alias</code>存在并标识受信任的证书条目，与之关联的证书将替换为<code class="codeph">cert</code> 。
                           </p>
                           <p><span class="apiname">setKeyEntry</span>方法添加（如果<code class="codeph">alias</code>尚不存在）或设置关键条目：</p><pre class="codeblock"><code>
final void setKeyEntry(String alias,
                       Key key,
                       char[] password,
                       Certificate[] chain)

final void setKeyEntry(String alias,
                       byte[] key,
                       Certificate[] chain)
</code></pre><p>在方法上<code class="codeph">key</code>作为字节数组，是受保护格式的密钥的字节。例如，在由<code class="codeph">SUN</code>提供者<code class="codeph">key</code>字节数组应包含受保护的私钥，编码为<code class="codeph">EncryptedPrivateKeyInfo</code>如PKCS8标准中所定义。在另一种方法中， <code class="codeph">password</code>是用于保护密钥的密码。
                           </p>
                           <p><span class="apiname">deleteEntry</span>方法删除一个条目：</p><pre class="codeblock"><code>
final void deleteEntry(String alias)
</code></pre><p>PKCS＃12密钥库支持包含任意属性的条目。使用<a href="https://docs.oracle.com/javase/10/docs/api/java/security/PKCS12Attribute.html" target="_blank"><code class="codeph">PKCS12Attribute</code></a>类来创建属性。创建新的密钥库条目时，请使用接受属性的构造方法。最后，使用以下方法将条目添加到密钥库：</p><pre class="codeblock"><code>
final void setEntry(String alias, Entry entry, 
                    ProtectionParameter protParam)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-478CD418-9E37-4225-BE10-5465BD82F295">从密钥库获取信息</p>
                           <p>的<code class="codeph">getKey</code>方法返回与给定别名关联的键。使用给定的密码恢复密钥：</p><pre class="codeblock"><code>
final Key getKey(String alias, char[] password)
</code></pre><p>以下方法分别返回与给定别名关联的证书或证书链：</p><pre class="codeblock"><code>
final Certificate getCertificate(String alias)
final Certificate[] getCertificateChain(String alias)
</code></pre><p>您可以确定名称（ <code class="codeph">alias</code>的证书通过以下方式与给定证书匹配的第一个条目）：</p><pre class="codeblock"><code>
final String getCertificateAlias(Certificate cert)
</code></pre><p>PKCS＃12密钥库支持包含任意属性的条目。使用以下方法检索可能包含属性的条目：</p><pre class="codeblock"><code>
final Entry getEntry(String alias, ProtectionParameter protParam)
</code></pre><p>然后使用<a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Entry.html#getAttributes--" target="_blank"><code class="codeph">KeyStore.Entry.getAttributes</code></a>提取此类属性并使用<a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Entry.Attribute.html" target="_blank"><code class="codeph">KeyStore.Entry.Attribute</code></a>界面来检查它们。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-361C2D21-1088-4E98-AC59-C32B9572294A">保存密钥库</p>
                           <p>内存中的密钥库可以通过以下方式保存<code class="codeph">store</code>方法：</p><pre class="codeblock"><code>
final void store(OutputStream stream, char[] password)
</code></pre><p>密码用于计算密钥库数据的完整性校验和，该校验和将附加到密钥库数据中。</p>
                           <p>通过传递一个DKS密钥库来存储<a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a>替代存储方法：</p><pre class="codeblock"><code>
final void store(KeyStore.LoadStoreParameter param)
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" name="GUID-33407B4E-D819-4294-94AB-C6FABF96A93D"></a><h4 id="JSSEC-GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" class="sect4">算法参数类别</h4>
                  <div>
                     <p>喜欢<code class="codeph">Key</code>和<code class="codeph">Keyspec</code> s，算法的初始化参数由<code class="codeph">AlgorithmParameter</code> s或<code class="codeph">AlgorithmParameterSpec</code> s。
                     </p>
                     <p>根据使用情况，算法可以直接使用参数，或者可能需要将参数转换为更可移植的格式以进行传输或存储。</p>
                     <p>一组参数的<span class="variable" translate="no">transparent</span>表示（通过<code class="codeph">AlgorithmParameterSpec</code> ）表示您可以分别访问集合中的每个参数值。您可以通过以下任一方式访问这些值<code class="codeph">get</code>相应规范类中定义的方法（例如， <code class="codeph">DSAParameterSpec</code>定义<code class="codeph">getP</code> ， <code class="codeph">getQ</code>和<code class="codeph">getG</code>方法，访问<code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code> ， 分别）。
                     </p>
                     <p>相反， <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" title="AlgorithmParameters类提供了加密参数的不透明表示形式。">AlgorithmParameters类</a>类提供了<span class="variable" translate="no">opaque</span>表示形式，在该表示形式中您无法直接访问参数字段。您只能获取与参数集关联的算法的名称（通过<code class="codeph">getAlgorithm</code> ）和参数集的某种编码（通过<code class="codeph">getEncoded</code> ）。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-190C91B4-991D-416E-A932-C0E37B33A86D" name="GUID-190C91B4-991D-416E-A932-C0E37B33A86D"></a><h5 id="JSSEC-GUID-190C91B4-991D-416E-A932-C0E37B33A86D" class="sect5">AlgorithmParameterSpec接口</h5>
                     <div>
                        <p><code class="codeph">AlgorithmParameterSpec</code>是透明地指定密码参数的接口。该接口不包含任何方法或常量。其唯一目的是对所有参数规范进行分组（并提供类型安全性）。所有参数规范都必须实现此接口。
                        </p>
                        <div class="section">
                           <p>以下是算法参数规范中的接口和类<code class="codeph">java.security.spec</code>和<code class="codeph">javax.crypto.spec</code>套餐：</p>
                           <ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHParameterSpec.html" target="_blank"><code class="codeph">DHParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHGenParameterSpec.html" target="_blank"><code class="codeph">DHGenParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAParameterSpec.html" target="_blank"><code class="codeph">DSAParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECGenParameterSpec.html" target="_blank"><code class="codeph">ECGenParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECParameterSpec.html" target="_blank"><code class="codeph">ECParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/GCMParameterSpec.html" target="_blank"><code class="codeph">GCMParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/IvParameterSpec.html" target="_blank"><code class="codeph">IvParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/MGF1ParameterSpec.html" target="_blank"><code class="codeph">MGF1ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/OAEPParameterSpec.html" target="_blank"><code class="codeph">OAEPParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/PBEParameterSpec.html" target="_blank"><code class="codeph">PBEParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PSSParameterSpec.html" target="_blank"><code class="codeph">PSSParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/RC2ParameterSpec.html" target="_blank"><code class="codeph">RC2ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/RC5ParameterSpec.html" target="_blank"><code class="codeph">RC5ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAKeyGenParameterSpec.html" target="_blank"><code class="codeph">RSAKeyGenParameterSpec</code></a></li>
                           </ul>
                           <p>以下算法参数规范专门用于XML数字签名。</p>
                           <ul style="list-style-type:disc">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/C14NMethodParameterSpec.html" target="_blank"><code class="codeph">Interface C14NMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/DigestMethodParameterSpec.html" target="_blank"><code class="codeph">Interface DigestMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/SignatureMethodParameterSpec.html" target="_blank"><code class="codeph">Interface SignatureMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/TransformParameterSpec.html" target="_blank"><code class="codeph">Interface TransformParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/ExcC14NParameterSpec.html" target="_blank"><code class="codeph">Interface ExcC14NParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/HMACParameterSpec.html" target="_blank"><code class="codeph">Interface HMACParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XPathFilter2ParameterSpec.html" target="_blank"><code class="codeph">Interface XPathFilter2ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XPathFilterParameterSpec.html" target="_blank"><code class="codeph">Interface XPathFilterParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XSLTTransformParameterSpec.html" target="_blank"><code class="codeph">XSLTTransformParameterSpec</code></a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" name="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0"></a><h5 id="JSSEC-GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" class="sect5">AlgorithmParameters类</h5>
                     <div>
                        <p>的<code class="codeph">AlgorithmParameters</code>类提供了加密参数的不透明表示形式。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-D4D0754B-36F3-4C9E-95F5-9A4C7AE055DA">AlgorithmParameters类</p>
                           <p>的<code class="codeph">AlgorithmParameters</code> class是<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。您可以初始化<code class="codeph">AlgorithmParameters</code>使用特定的类<code class="codeph">AlgorithmParameterSpec</code>对象，或通过以公认的格式对参数进行编码。您可以使用<span class="apiname">getParameterSpec</span>方法检索得到的规范（请参见以下部分）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-93AC8926-8EB7-4B31-9FD2-71D002D6C230">创建一个AlgorithmParameters对象</p>
                           <p><code class="codeph">AlgorithmParameters</code>通过使用其中之一获得对象<code class="codeph">AlgorithmParameters</code> getInstance（）静态工厂方法。有关更多信息，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-9AB97E16-E8EF-456D-9E9F-92C765BF6DD2">初始化AlgorithmParameters对象</p>
                           <p>一次<code class="codeph">AlgorithmParameters</code>对象被实例化，它必须通过调用来初始化<code class="codeph">init</code> ，使用适当的参数规范或参数编码：</p><pre class="codeblock"><code>
void init(AlgorithmParameterSpec paramSpec)
void init(byte[] params)
void init(byte[] params, String format)
</code></pre><p>在这些<code class="codeph">init</code>方法， <code class="codeph">params</code>是一个包含编码参数的数组，并且<code class="codeph">format</code>是解码格式的名称。在里面<code class="codeph">init</code>用的方法<code class="codeph">params</code>论据，但没有<code class="codeph">format</code>参数，使用参数的主要解码格式。如果存在参数的ASN.1规范，则主要解码格式为ASN.1。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-0D673859-E908-4D79-ACBD-08657FB13092">获取编码参数</p>
                           <p>字节编码的参数表示<code class="codeph">AlgorithmParameters</code>对象可以通过调用获得<code class="codeph">getEncoded</code> ：</p><pre class="codeblock"><code>
byte[] getEncoded()
</code></pre><p>此方法以其主要编码格式返回参数。如果存在针对此类参数的ASN.1规范，则参数的主要编码格式为ASN.1。</p>
                           <p>如果要以指定的编码格式返回参数，请使用</p><pre class="codeblock"><code>
byte[] getEncoded(String format)
</code></pre><p>如果<code class="codeph">format</code>如果为null，则使用参数的主要编码格式，就像其他<span class="apiname">getEncoded</span>方法一样。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-1CFCC9C2-CF4B-45C3-A219-10DA07E59161">将AlgorithmParameters对象转换为透明规范</p>
                           <p>可以从<code class="codeph">AlgorithmParameters</code>通过调用对象<code class="codeph">getParameterSpec</code> ：</p><pre class="codeblock"><code>
AlgorithmParameterSpec getParameterSpec(Class paramSpec)
</code></pre><p><code class="codeph">paramSpec</code>标识应在其中返回参数的规范类。规范类可以是例如<code class="codeph">DSAParameterSpec.class</code>指示应在的实例中返回参数<code class="codeph">DSAParameterSpec</code>类。（该课程位于<code class="codeph">java.security.spec</code>包。）
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C" name="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C"></a><h5 id="JSSEC-GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C" class="sect5">AlgorithmParameterGenerator类</h5>
                     <div>
                        <div class="section">
                           <p>的<code class="codeph">AlgorithmParameterGenerator</code> class是一种<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法，</a>用于生成一组适用于某种算法<span class="bold">的全新</span>参数（该算法在<code class="codeph">AlgorithmParameterGenerator</code>实例已创建）。当您没有一组现有的算法参数并且想要从头生成一个算法参数时，将使用此对象。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-1639E5D1-1F84-409B-84F8-D736371E44C2">创建一个AlgorithmParameterGenerator对象</p>
                           <p><code class="codeph">AlgorithmParameterGenerator</code>通过使用其中之一获得对象<code class="codeph">AlgorithmParameterGenerator</code> getInstance（）静态工厂方法。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-7B09D9AD-4B5E-444A-950C-A4D5165A7C61">初始化AlgorithmParameterGenerator对象</p>
                           <p>的<code class="codeph">AlgorithmParameterGenerator</code>可以通过两种不同的方式初始化对象：独立于算法的方式或特定于算法的方式。
                           </p>
                           <p>独立于算法的方法利用了以下事实：所有参数生成器共享“大小”和随机性源的概念。尽管对不同算法的解释不同，但大小度量由所有算法参数普遍共享。例如，在用于DSA算法的参数的情况下，“大小”对应于质数模数的大小（以位为单位）。（请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>以了解有关特定算法大小的更多信息。）使用这种方法时，特定于算法的参数生成值（如果有）默认为某些标准值。一<code class="codeph">init</code>接受以下两种通用类型的参数的方法：</p><pre class="codeblock"><code>
void init(int size, SecureRandom random);
</code></pre><p>另一个<code class="codeph">init</code>方法只需要一个<code class="codeph">size</code>参数并使用系统提供的随机性来源：</p><pre class="codeblock"><code>
void init(int size)
</code></pre><p>第三种方法使用特定于算法的语义来初始化参数生成器对象，该语义由一组特定于算法的参数生成值表示，这些值在<code class="codeph">AlgorithmParameterSpec</code>宾语：</p><pre class="codeblock"><code>
void init(AlgorithmParameterSpec genParamSpec,
                          SecureRandom random)

void init(AlgorithmParameterSpec genParamSpec)
</code></pre><p>例如，要生成Diffie-Hellman系统参数，参数生成值通常由素数模数和随机指数的大小组成，均以位数表示。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-D4CF78C6-CED0-4E4D-A690-B7DB2B05FDC8">生成算法参数</p>
                           <p>创建并初始化AlgorithmParameterGenerator对象后，就可以使用generateParameters方法生成算法参数：</p><code class="codeph">AlgorithmParameters generateParameters()</code></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" name="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA"></a><h4 id="JSSEC-GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" class="sect4">CertificateFactory类</h4>
                  <div>
                     <p>的<code class="codeph">CertificateFactory</code>类定义证书工厂的功能，该功能用于根据其编码生成证书和证书吊销列表（CRL）对象。
                     </p>
                     <div class="section">
                        <p>的<code class="codeph">CertificateFactory</code> class是<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。
                        </p>
                        <p>X.509的证书工厂必须返回作为以下实例的证书： <code class="codeph">java.security.cert.X509Certificate</code> ，以及作为实例的CRL <code class="codeph">java.security.cert.X509CRL</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-8415E441-2028-4476-9A95-DBD09998E407">创建一个CertificateFactory对象</p>
                        <p><code class="codeph">CertificateFactory</code>通过使用其中之一获得对象<code class="codeph">getInstance()</code>静态工厂方法。有关更多信息，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供者实现</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-5379762D-6D25-4ED7-A22C-A72ED8F1AA80">生成证书对象</p>
                        <p>要生成证书对象并使用从输入流中读取的数据对其进行初始化，请使用<code class="codeph">generateCertificate</code>方法：</p><pre class="codeblock"><code>
final Certificate generateCertificate(InputStream inStream)
</code></pre><p>要返回从给定输入流中读取的证书的（可能为空）收集视图，请使用<code class="codeph">generateCertificates</code>方法：</p><pre class="codeblock"><code>
final Collection generateCertificates(InputStream inStream)
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-ED452EA8-B0FA-4C83-A722-194EBF8853DC">生成CRL对象</p>
                        <p>要生成证书吊销列表（CRL）对象并使用从输入流中读取的数据对其进行初始化，请使用<code class="codeph">generateCRL</code>方法：</p><pre class="codeblock"><code>
final CRL generateCRL(InputStream inStream)
</code></pre><p>要返回从给定输入流中读取的CRL的（可能为空）收集视图，请使用<code class="codeph">generateCRLs</code>方法：</p><pre class="codeblock"><code>
final Collection generateCRLs(InputStream inStream)
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-72360D6D-E10F-4091-9DA9-88D86B325A83">生成CertPath对象</p>
                        <p>PKIX的证书路径构建器和验证器由Internet X.509公钥基础结构证书和CRL配置文件<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280定义</a> 。
                        </p>
                        <p>IETF还提供了使用PKIX LDAP V2架构从Collection和LDAP目录中检索证书和CRL的证书存储实现，可作为<a href="http://www.ietf.org/rfc/rfc2587.txt" target="_blank">RFC 2587</a>从IETF获得。
                        </p>
                        <p>产生一个<code class="codeph">CertPath</code>对象并使用从输入流中读取的数据对其进行初始化，请使用以下方法之一<code class="codeph">generateCertPath</code>方法（有或没有指定要用于数据的编码）：</p><pre class="codeblock"><code>
final CertPath generateCertPath(InputStream inStream)

final CertPath generateCertPath(InputStream inStream,
                                String encoding)
</code></pre><p>产生一个<code class="codeph">CertPath</code>对象并使用证书列表对其进行初始化，请使用以下方法：</p><pre class="codeblock"><code>
final CertPath generateCertPath(List certificates)
</code></pre><p>检索列表<code class="codeph">CertPath</code>此证书工厂支持的编码，您可以调用<code class="codeph">getCertPathEncodings</code>方法：</p><pre class="codeblock"><code>
final Iterator getCertPathEncodings()
</code></pre><p>默认编码将首先列出。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229" name="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229"></a><h3 id="JSSEC-GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229" class="sect3">如何在SSL / TLS实现中使用JCA</h3>
               <div>
                  <p>了解了JCA类之后，请考虑如何组合这些类以实现高级网络协议（如SSL / TLS）。</p>
                  <div class="section">
                     <p><a href="java-security-overview1.html#GUID-FCF419A7-B856-46DD-A36F-C6F88F9AF37F">TLS和DTLS协议</a>中的“ SSL / TLS概述”部分从较高级别描述了协议的工作方式。由于非对称（公共密钥）密码操作比对称操作（秘密密钥）要慢得多，因此使用公共密钥密码术来建立秘密密钥，然后再使用这些密钥来保护实际的应用程序数据。SSL / TLS握手大大简化了，它涉及交换初始化数据，执行一些公共密钥操作以获取秘密密钥，然后使用该密钥来加密进一步的流量。
                     </p>
                     <div class="infoboxnote" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-33252E3C-D0BD-4073-9D36-C31CBC961EF5">
                        <p class="notep1">注意：</p>此处提供的详细信息仅显示了如何使用上述某些类。本节将不会提供足够的信息来构建SSL / TLS实现。有关更多信息，请参阅《 <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" title="Java安全套接字扩展（JSSE）支持安全的Internet通信。它为TLS和DTLS协议的Java版本提供了框架和实现，并包括数据加密，服务器身份验证，消息完整性和可选的客户端身份验证的功能。">Java安全套接字扩展（JSSE）参考指南》</a>和<a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC 5246：传输层安全性（TLS）协议版本1.2</a> 。
                     </div>
                     <p>假定此SSL / TLS实现将作为JSSE提供程序提供。具体的实现<code class="codeph">Provider</code>首先编写课程，该课程最终将在<code class="codeph">Security</code>类的提供商列表。该提供程序主要提供从算法名称到实际实现类的映射。 （即：“ SSLContext。TLS“->” com.foo。TLSImpl”），当应用程序请求“ TLS”实例时（通过<code class="codeph">SSLContext.getInstance("TLS")</code> ），请向提供商列表查询所请求的算法，然后创建一个适当的实例。
                     </p>
                     <p>在讨论实际握手的细节之前，需要快速回顾一下JSSE的一些体系结构。JSSE体系结构的核心是<code class="codeph">SSLContext</code> 。上下文最终会创建最终对象（ <code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code> ），实际上实现了SSL / TLS协议。 <code class="codeph">SSLContext</code>使用两个回调类初始化， <code class="codeph">KeyManager</code>和<code class="codeph">TrustManager</code> ，允许应用程序首先选择要发送的身份验证材料，其次可以验证对等方发送的凭据。
                     </p>
                     <p>JSSE <code class="codeph">KeyManager</code>负责选择要呈现给对等方的凭据。可以使用多种算法，但是一种常见的策略是维护RSA或DSA公钥/私钥对以及一个<code class="codeph">X509Certificate</code>在一个<code class="codeph">KeyStore</code>由磁盘文件支持。当一个<code class="codeph">KeyStore</code>对象被初始化并从文件加载，文件的原始字节被转换为<code class="codeph">PublicKey</code>和<code class="codeph">PrivateKey</code>使用一个对象<code class="codeph">KeyFactory</code> ，并且证书链的字节使用<code class="codeph">CertificateFactory</code> 。当需要凭证时， <code class="codeph">KeyManager</code>简单地咨询这个<code class="codeph">KeyStore</code>对象并确定要显示的凭据。
                     </p>
                     <p>一种<code class="codeph">KeyStore</code>的内容最初可能是使用诸如<code class="codeph">keytool</code> 。 <code class="codeph">keytool</code>创建一个RSA或DSA <code class="codeph">KeyPairGenerator</code>并使用适当的密钥大小对其进行初始化。然后，该生成器用于创建一个<code class="codeph">KeyPair</code>哪一个<code class="codeph">keytool</code>将与新创建的证书一起存储在<code class="codeph">KeyStore</code> ，最终将其写入磁盘。
                     </p>
                     <p>JSSE <code class="codeph">TrustManager</code>负责验证从对等方收到的凭据。验证凭据的方法有很多：一种方法是创建一个<code class="codeph">CertPath</code>对象，然后让JDK的内置公钥基础结构（PKI）框架处理验证。在内部，CertPath实现可能会创建一个<code class="codeph">Signature</code>对象，并使用它来验证证书链中的每个签名。
                     </p>
                     <p>通过对体系结构的基本了解，我们可以了解SSL / TLS握手中的一些步骤。客户端首先向服务器发送ClientHello消息。服务器选择要使用的密码套件，然后将其发送回ServerHello消息，然后根据套件选择开始创建JCA对象。在以下示例中，我们将使用仅服务器身份验证。</p>
                     <div class="figure" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-882646E9-0A5E-4ED7-B681-DFFB0FD15668">
                        <p class="titleinfigure">图2-17 SSL / TLS消息</p><img src="img/ssl-client.png" alt="如下图2-17所示" title="如下图2-17所示" longdesc="img_text/ssl-client.html"><br><a href="img_text/ssl-client.html">“图2-17 SSL / TLS消息”的描述</a></div>
                     <!-- class="figure" -->
                     <p>以下示例描述了仅服务器身份验证。这些示例已大大简化，但给出了如何组合JSSE类以创建更高级别协议的想法：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-3C2B038D-8282-4518-9923-9E4598F7200A">
                     <p class="titleinexample">示例2-9 SSL / TLS服务器使用基于RSA的密码套件，例如TLS_RSA_WITH_AES_128_CBC_SHA</p>服务器的<code class="codeph">KeyManager</code>被查询，并返回适当的RSA条目。服务器的证书（即：证书/公钥）在服务器的证书消息中发送。客户的<code class="codeph">TrustManager</code>验证服务器的证书，如果被接受，客户端将使用<code class="codeph">SecureRandom</code>宾语。然后使用加密的非对称RSA对其进行加密<code class="codeph">Cipher</code>已使用初始化的对象<code class="codeph">PublicKey</code>在服务器的证书中找到。此加密数据在客户端密钥交换消息中发送。服务器将使用其对应的<code class="codeph">PrivateKey</code>使用类似的方法恢复字节<code class="codeph">Cipher</code>在解密模式下。这些字节然后用于建立实际的加密密钥。
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-44DAB934-48B2-4359-8E56-57B01B5D5FA0">
                     <p class="titleinexample">示例2-10选择临时Diffie-Hellman密钥协商算法以及DSA签名算法，例如TLS_DHE_DSS_WITH_AES_128_CBC_SHA</p>双方必须使用以下方法建立新的临时DH公共/专用密钥对： <code class="codeph">KeyPairGenerator</code> 。每个生成器都会创建DH键，然后可以使用<code class="codeph">KeyFactory</code>和<code class="codeph">DHPublicKeySpec</code>类。双方然后创建一个<code class="codeph">KeyAgreement</code>对象并使用其各自的DH对其进行初始化<code class="codeph">PrivateKey</code> s。服务器将其公钥片段发送到<code class="codeph">ServerKeyExchange</code>消息（受DSA签名算法保护，并且客户端在ClientKeyExchange消息中发送其公钥。当使用另一个重新组装公钥时<code class="codeph">KeyFactory</code> ，它们被输入到协议对象中。的<code class="codeph">KeyAgreement</code>然后，对象生成商定的字节，然后将其用于建立实际的加密密钥。
                     <p>一旦建立了实际的加密密钥，便使用秘密密钥来初始化对称密钥。 <code class="codeph">Cipher</code>对象，并且此密码用于保护传输中的所有数据。为了帮助确定数据是否已被修改， <code class="codeph">MessageDigest</code>创建并接收发往网络的数据的副本。数据包完成后，摘要（哈希）将附加到数据中，并且整个数据包将由<code class="codeph">Cipher</code> 。如果使用诸如AES之类的分组密码，则必须填充数据以构成完整的分组。在远程方面，这些步骤只需颠倒即可。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1" name="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1"></a><h3 id="JSSEC-GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1" class="sect3">密码强度配置</h3>
               <div>
                  <p></p>
                  <p>您可以使用管辖区策略文件（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F2CF205E-744E-4C16-B504-B6F79781E762">管辖区策略文件格式</a> ）和安全属性文件来配置Java密码学扩展（JCE）体系结构的加密强度。
                  </p>
                  <p>在Oracle Java JDK 9之前，Oracle实现允许的默认加密强度为“强但有限”（例如AES密钥限制为128位）。为了消除此限制，管理员可以下载并安装单独的“无限强度”管辖权策略文件捆绑包。JDK 9的管辖区策略文件机制已重新设计。现在，它允许更加灵活的配置。现在，Oracle JDK附带了默认值“ unlimited”而不是“ limited”。与往常一样，管理员和用户仍必须继续遵循其地理位置的所有导入/导出准则。现在，使用安全属性（通常在<code class="codeph">java.security</code>属性文件），以及在配置目录中找到的管辖区策略文件。
                  </p>
                  <p>JDK捆绑了所有必需的JCE策略文件，这些文件可提供无限的加密强度或强大但有限的加密强度。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-4ACF175C-144C-48E2-818D-263236EDC52D">密码强度设置</p>
                     <p>下的每个目录<code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/policy</code>表示由它们所包含的管辖区策略文件定义的一组策略配置。您可以通过设置目录中的策略文件来激活特定的加密强度设置。 <code class="codeph">crypto.policy</code>安全属性（在文件中配置） <code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/java.security</code> ）指向该目录。
                     </p>
                     <div class="p">JDK捆绑了两个这样的目录， <code class="codeph">limited</code>和<code class="codeph">unlimited</code> ，每个都包含许多策略文件。默认情况下， <code class="codeph">crypto.policy</code>安全属性设置为：<pre class="pre codeblock"><code>crypto.policy = unlimited</code></pre></div>
                     <p>总值是目录中包含的文件的交集。这些策略文件设置在VM范围内，并且会影响此VM上运行的所有应用程序。如果要在应用程序级别覆盖加密强度，请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">如何使应用程序不受加密限制</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-ED64129F-57BF-44D2-8689-AD3378C36F1F">无限目录内容</p>
                     <p>的<code class="codeph">unlimited</code>目录包含以下策略文件：</p>
                     <div class="p">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/unlimited/default_US_export.policy</code></p>
                              <div class="p"><pre class="pre codeblock"><code>// Default US Export policy file.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-5E09236A-26C9-4879-95CB-6E5F2EC1B6C3">
                                    <p class="notep1">注意：</p>由于目前没有从美国出口密码的限制，因此<code>default_US_export.policy</code>文件没有任何限制。
                                 </div>
                              </div>
                           </li>
                           <li>
                              <div class="p"><code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/unlimited/default_local.policy</code><pre class="pre codeblock"><code>// Country specific policy file for countries with no limits on crypto strength.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-44F8E9BD-3982-4E54-8907-05AC7B28453A">
                                    <p class="notep1">注意：</p>根据国家/地区的不同，可能会有本地限制，但是由于此策略文件位于<code class="codeph">unlimited</code>目录，此处没有任何限制。
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p>选择这两个文件集中定义的无限加密强度<code class="codeph">crypto.policy = unlimited</code>在文件中<code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/java.security</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-82032A75-0FAB-4BEF-97E0-862E04C6AE7A">受限目录内容</p>
                     <p>的<code class="codeph">limited</code>目录当前包含以下策略文件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <div class="p"><code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/limited/default_US_export.policy</code><pre class="pre codeblock"><code>// Default US Export policy file.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-297C34B0-18F6-4D2B-802F-B11D6B0FC233">
                                 <p class="notep1">注意：</p>即使这在<code class="codeph">limited</code>目录，因为目前没有从美国出口密码的限制，因此<code>default_US_export.policy</code>文件没有任何限制。
                              </div>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/limited/default_local.policy</code></p><pre class="pre codeblock"><code>// Some countries have import limits on crypto strength. This policy file
// is worldwide importable.

grant {
    permission javax.crypto.CryptoPermission "DES", 64;
    permission javax.crypto.CryptoPermission "DESede", *;
    permission javax.crypto.CryptoPermission "RC2", 128, 
                                     "javax.crypto.spec.RC2ParameterSpec", 128;
    permission javax.crypto.CryptoPermission "RC4", 128;
    permission javax.crypto.CryptoPermission "RC5", 128, 
          "javax.crypto.spec.RC5ParameterSpec", *, 12, *;
    permission javax.crypto.CryptoPermission "RSA", *;
    permission javax.crypto.CryptoPermission *, 128;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-53F6BA3F-7413-4B06-AA40-24359147478D">
                              <p class="notep1">注意：</p>此本地策略文件显示默认限制。任何国家（包括有进口限制的国家）都应允许进口，但请获取法律指导。
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/limited/exempt_local.policy</code></p><pre class="pre codeblock"><code>// Some countries have import limits on crypto strength, but may allow for
// these exemptions if the exemption mechanism is used.

grant {
    // There is no restriction to any algorithms if KeyRecovery is enforced.
    permission javax.crypto.CryptoPermission *, "KeyRecovery"; 

    // There is no restriction to any algorithms if KeyEscrow is enforced.
    permission javax.crypto.CryptoPermission *, "KeyEscrow"; 

    // There is no restriction to any algorithms if KeyWeakening is enforced. 
    permission javax.crypto.CryptoPermission *, "KeyWeakening";
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-9AA5D629-D309-4DF2-9BCE-66BD1DDC8E76">
                              <p class="notep1">注意：</p>有进口限制的国家应使用“限制”，但如果可以采用豁免机制，则可以放宽这些限制。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">如何使应用程序不受密码限制</a> 。请根据您的情况获取法律指导。
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-6273F861-FD0B-4E50-BFFE-116B161FD487">自定义密码强度设置</p>
                     <p>要设置与密码强度不同的限制，该限制与密码策略中的策略文件中的设置不同<code class="codeph">limited</code>要么<code class="codeph">unlimited</code>目录，您可以创建一个新目录，与<code class="codeph">limited</code>和<code class="codeph">unlimited</code> ，然后将策略文件放在此处。例如，您可以创建一个名为<code class="codeph">custom</code> 。在这个<code class="codeph">custom</code>您包含文件的目录<code class="codeph">default_*export.policy</code>和/或<code class="codeph">exempt_*local.policy</code> 。
                     </p>
                     <p>要选择加密强度，请参见<code class="codeph">custom</code>目录，设置<code class="codeph">crypto.policy = custom</code>在文件中<code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/java.security</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-F2CF205E-744E-4C16-B504-B6F79781E762" name="GUID-F2CF205E-744E-4C16-B504-B6F79781E762"></a><h3 id="JSSEC-GUID-F2CF205E-744E-4C16-B504-B6F79781E762" class="sect3">管辖权政策文件格式</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>JCA将其管辖权策略文件表示为具有相应权限声明的Java样式策略文件。如<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">Cryptographic Strength Configuration中所述</a> ，Java策略文件指定允许来自指定代码源的代码具有哪些权限。权限表示对系统资源的访问。在JCA的情况下，“资源”是密码算法，并且不需要指定代码源，因为密码限制适用于所有代码。
                     </p>
                     <p>权限策略文件由一个非常基本的“授予条目”组成，其中包含一个或多个“权限条目”。</p><pre class="codeblock"><code>grant {
    <span class="variable" translate="no">&lt;permission entries&gt;</span>;
};
</code></pre><p>权限策略文件中的权限条目的格式为：</p><pre class="codeblock"><code>permission <span class="variable" translate="no">&lt;crypto permission class name&gt;
</span>    [<span class="variable" translate="no">&lt;alg_name&gt;</span>
        [
            [, <span class="variable" translate="no">&lt;exemption mechanism name&gt;</span>]
            [, <span class="variable" translate="no">&lt;maxKeySize&gt;</span>
                [, <span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span>,
                       <span class="variable" translate="no">&lt;parameters for constructing an AlgorithmParameterSpec object&gt;</span>
                ]
            ]
        ]
    ];
</code></pre><p>包含将AES算法限制为最大密钥大小为128位的示例管辖区策略文件为：</p><pre class="codeblock"><code>    grant {
        permission javax.crypto.CryptoPermission "AES", 128;
        // ...
    };
</code></pre><p>权限条目必须以单词开头<code class="codeph">permission</code> 。权限条目中出现的项目必须以指定的顺序出现。条目以分号终止。标识符的大小写无关紧要（ <code class="codeph">grant</code> ， <code class="codeph">permission</code> ），但对<code class="codeph"><span class="variable" translate="no"><crypto permission class name></span></code>或任何作为值传递的字符串。星号（ <code class="codeph">*</code> ）可以用作任何权限输入选项的通配符。例如，星号为<code class="codeph"><span class="variable" translate="no"><alg_name></span></code>选项表示“所有算法”。</p>
                     <p>下表描述了权限条目的选项：</p>
                     <div class="tblformal" id="GUID-F2CF205E-744E-4C16-B504-B6F79781E762__GUID-4B590C91-3FAE-4242-AE13-89EE1D99FE3B">
                        <p class="titleintable">表2-1权限输入选项</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="权限输入选项" border="1" summary="Permission entry options and their descriptions" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d30788e5998">选项</th>
                                 <th align="left" valign="bottom" id="d30788e6000">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6004" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><crypto permission class name></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6004 d30788e6000 ">
                                    <p>特定的权限类别名称，例如<code class="codeph">javax.crypto.CryptoPermission</code> 。需要。
                                    </p>
                                    <p>加密权限类反映了应用程序在特定环境中使用具有特定密钥大小的特定算法的能力。有两种加密权限类： <code class="codeph">CryptoPermission</code>和<code class="codeph">CryptoAllPermission</code> 。特别的<code class="codeph">CryptoAllPermission</code> class隐含所有与密码学有关的权限，即，它指定没有与密码学有关的限制。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6026" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><alg_name></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6026 d30788e6000 ">
                                    <p>带引号的字符串，指定加密算法的标准名称，例如“ AES”或“ RSA”。可选的。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6035" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><exemption mechanism name></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6035 d30788e6000 ">
                                    <p>带引号的字符串表示一种豁免机制，如果实施该机制，则可以减少密码限制。可选的。</p>
                                    <p>可以使用的豁免机制名称包括“ KeyRecovery”，“ KeyEscrow”和“ KeyWeakening”。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6045" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><maxKeySize></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6045 d30788e6000 ">
                                    <p>整数，指定指定算法允许的最大密钥大小（以位为单位）。可选的。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6053" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><AlgorithmParameterSpec class name></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6053 d30788e6000 ">
                                    <p>类名，指定算法的强度。可选的。</p>
                                    <p>对于某些算法，仅根据密钥大小来指定算法强度可能不够。例如，在“ RC5”算法的情况下，还必须考虑轮数。对于需要将强度表示为大于密钥大小的算法，请使用此选项指定<code class="codeph">AlgorithmParameterSpec</code>执行此操作的类名（例如<code class="codeph">javax.crypto.spec.RC5ParameterSpec</code> （对于“ RC5”算法）。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6069" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no"><parameters for constructing an AlgorithmParameterSpec object></span></code></td>
                                 <td align="left" valign="top" headers="d30788e6069 d30788e6000 ">用于构造指定参数的参数列表<code class="codeph">AlgorithmParameterSpec</code>宾语。如果需要<code class="codeph"><span class="variable" translate="no"><AlgorithmParameterSpec class name></span></code>已指定并需要参数。
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D" name="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D"></a><h3 id="JSSEC-GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D" class="sect3">如何使应用程序不受密码限制</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-CD61A0CD-BB98-4CF9-B958-D75C1DF166A1">
                        <p class="notep1">注意：</p>大多数应用程序开发人员应忽略此部分。如果希望此类应用程序的密码限制少于所要求的密码限制，则仅适用于那些可以将其应用程序输出到政府强制密码限制的少数几个国家/地区的人。
                     </div>
                     <p>默认情况下，应用程序可以使用任何强度的密码算法。但是，由于一些国家/地区政府的进口管制限制，您可能不得不限制这些算法的强度。JCA框架具有强制执行有关在不同权限上下文（位置）中的应用程序可用的密码算法最大强度的限制的功能。您可以在管辖区策略文件中指定这些限制。有关管辖区策略文件以及如何创建和配置它们的更多信息，请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">加密强度配置</a> 。
                     </p>
                     <p>某些或所有此类国家/地区的政府可能允许某些应用不受某些或所有密码限制的约束。例如，他们可能会将某些类型的申请视为“特殊”申请，因此被豁免。或者，他们可以免除使用“免除机制”（例如密钥恢复）的任何应用程序。与此类国家/地区的非豁免应用程序相比，被视为豁免的应用程序可以访问更强大的密码。</p>
                     <p>为了使应用程序在运行时被识别为“豁免”，它必须满足以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>它必须在JAR文件中捆绑有一个权限策略文件。权限策略文件指定应用程序具有哪些与密码相关的权限，以及在什么条件下（如果有）。</li>
                        <li>包含应用程序和权限策略文件的JAR文件必须已使用接受该应用程序的豁免后颁发的代码签名证书进行了签名。</li>
                     </ul>
                     <p>以下是使应用程序免于某些加密限制所需的示例步骤。这是一个基本概述，其中包含有关JCA要求的信息，以便识别和处理被豁免的应用程序。您将需要了解您希望能够在其中运行应用程序但其政府要求密码限制的特定国家或地区的豁免要求。您还需要了解JCA框架供应商的要求，该供应商已经制定了处理豁免应用程序的流程。请咨询此类供应商以获取更多信息。</p>
                     <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-870A208D-FE85-4D1E-A1C1-BA8B9616650D">
                        <p class="notep1">注意：</p>的<code class="codeph">SunJCE</code>提供者不提供<code class="codeph">ExemptionMechanismSpi</code>类</div>
                     <ol>
                        <li>编写和编译您的应用程序代码</li>
                        <li>创建一个权限策略文件，授予适当的密码权限</li>
                        <li>准备测试<ol type="a">
                              <li>从政府授权限制条件中申请政府批准。</li>
                              <li>获取代码签名证书</li>
                              <li>将应用程序和权限策略文件捆绑到一个JAR文件中</li>
                              <li><a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="下一步是请求代码签名证书，以便您可以在测试之前使用它对提供商进行签名。该证书将对测试和生产均有效。有效期为5年。">步骤7.1：获取代码签名证书</a></li>
                              <li>像限制国家/地区中的用户一样设置您的环境</li>
                              <li>（仅适用于使用免除机制的应用程序）安装提供程序，以实现权限策略文件中条目指定的免除机制</li>
                           </ol> 
                        </li>
                        <li>测试您的应用程序</li>
                        <li>必要时申请美国政府出口批准</li>
                        <li>部署您的应用</li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-92A89D36-C09D-4970-8A4B-2912436E0CEC">使用豁免机制的应用程序的特殊代码要求</p>
                     <p>当应用程序具有与其相关联的权限策略文件时（在同一JAR文件中），并且该权限策略文件指定了一种豁免机制，则当<span class="apiname">Cipher</span> <code class="codeph">getInstance</code>调用方法来实例化<span class="apiname">Cipher</span> ，JCA代码在已安装的提供程序中搜索实现指定豁免机制的提供程序。如果找到了这样的提供者，则JCA会实例化一个<code class="codeph">ExemptionMechanism</code>与提供者的实现相关联的API对象，然后将<code class="codeph">ExemptionMechanism</code> <span class="apiname">密码</span>返回的对象<code class="codeph">getInstance</code> 。
                     </p>
                     <p>实例化密码之后，并在初始化之前（通过调用密码） <code class="codeph">init</code>方法），您的代码必须调用以下<span class="apiname">Cipher</span>方法：</p><pre class="codeblock"><code>    public ExemptionMechanism getExemptionMechanism()
</code></pre><p>此调用返回<code class="codeph">ExemptionMechanism</code>与密码相关联的对象。然后，您必须通过对返回的代码调用以下方法来初始化免除机制的实现<code class="codeph">ExemptionMechanism</code> ：</p><pre class="codeblock"><code>    public final void init(Key key)
</code></pre><p>您提供的参数应与随后将提供给密码的相同类型的参数相同<code class="codeph">init</code>方法。
                     </p>
                     <p>初始化后<code class="codeph">ExemptionMechanism</code> ，您可以照常进行初始化和使用密码。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-35BFD164-6C13-4FBA-82C6-1332AC04AA8A">权限策略文件</p>
                     <p>为了使应用程序在运行时被识别为不受某些或所有密码限制的约束，它必须在JAR文件中捆绑有一个权限策略文件。权限策略文件指定应用程序具有哪些与密码相关的权限，以及在什么条件下（如果有）。</p>
                     <p>豁免申请随附的权限策略文件中的权限条目的格式与通过JDK下载的权限策略文件的格式相同，该格式为：</p><pre class="codeblock"><code>permission <span class="variable" translate="no">&lt;crypto permission class name&gt;
</span>    [<span class="variable" translate="no">&lt;alg_name&gt;</span>
        [
            [, <span class="variable" translate="no">&lt;exemption mechanism name&gt;</span>]
            [, <span class="variable" translate="no">&lt;maxKeySize&gt;</span>
                [, <span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span>,
                       <span class="variable" translate="no">&lt;parameters for constructing an AlgorithmParameterSpec object&gt;</span>
                ]
            ]
        ]
    ];
</code></pre><p>请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F2CF205E-744E-4C16-B504-B6F79781E762">管辖策略文件格式</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-15A113AE-5507-4312-A513-1AC8BD2200B7">豁免应用程序的权限策略文件</p>
                     <p>某些应用程序可能完全不受限制。因此，此类应用程序随附的权限策略文件通常只需要包含以下内容：</p><pre class="codeblock"><code>grant {
    // There are no restrictions to any algorithms.
    permission javax.crypto.CryptoAllPermission;
};
</code></pre><p>如果应用程序仅使用一种算法（或几种特定算法），则权限策略文件可以简单地明确提及该算法，而不是授予<span class="apiname">CryptoAllPermission</span> 。
                     </p>
                     <p>例如，如果应用程序仅使用Blowfish算法，则权限策略文件不必将<span class="apiname">CryptoAllPermission</span>授予所有算法。如果使用Blowfish算法，则可以仅指定没有密码限制。为此，权限策略文件如下所示：</p><pre class="codeblock"><code>grant {
    permission javax.crypto.CryptoPermission "Blowfish";
};
</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-3814F089-D790-4662-A51B-DFDD3B21F3DC">由于免除机制而免除的应用程序的权限策略文件</p>
                     <p>如果强制实施了豁免机制，则将某个应用程序视为“豁免”，则该应用程序随附的权限策略文件必须指定一个或多个豁免机制。在运行时，如果强制实施了任何一种豁免机制，则该应用程序将被视为豁免。必须在类似于以下内容的权限条目中指定每种豁免机制：</p><pre class="codeblock"><code>    // No algorithm restrictions if specified
    // exemption mechanism is enforced.
    permission javax.crypto.CryptoPermission *,
        "<span class="variable" translate="no">&lt;ExemptionMechanismName&gt;</span>";
</code></pre><p>哪里<code class="codeph"><span class="variable" translate="no"><ExemptionMechanismName></span></code>指定豁免机制的名称。可能的豁免机制名称列表包括：</p>
                     <ul style="list-style-type:disc">
                        <li><code class="codeph">KeyRecovery</code></li>
                        <li><code class="codeph">KeyEscrow</code></li>
                        <li><code class="codeph">KeyWeakening</code></li>
                     </ul>
                     <p>例如，假设如果强制执行密钥恢复或密钥托管，则您的应用程序是免税的。然后，您的权限策略文件应包含以下内容：</p><pre class="codeblock"><code>grant {
    // No algorithm restrictions if KeyRecovery is enforced.
    permission javax.crypto.CryptoPermission *, "KeyRecovery";

    // No algorithm restrictions if KeyEscrow is enforced.
    permission javax.crypto.CryptoPermission *, "KeyEscrow";
};
</code></pre><div class="p">
                        <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-04F2AC6B-93B0-4124-9B04-99B8D7672EFE">
                           <p class="notep1">注意：</p>指定豁免机制的权限条目<span class="variable" translate="no">not</span>应指定最大密钥大小。允许的密钥大小实际上是从已安装的豁免管辖区策略文件中确定的，如下一节所述。
                        </div>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-5EA84500-8409-491D-B03D-8F922C6EC10C">捆绑的权限策略文件如何影响加密权限</p>
                     <p>在运行时，当应用程序实例化<span class="apiname">密码时</span> （通过对其进行调用<code class="codeph">getInstance</code>方法），并且该应用程序具有关联的权限策略文件，JCA会检查该权限策略文件是否具有适用于<code class="codeph">getInstance</code>呼叫。如果是这样，并且该条目授予<span class="apiname">CryptoAllPermission</span>或未指定必须强制执行豁免机制，则意味着此特定算法没有密码限制。
                     </p>
                     <p>如果权限策略文件中有一个条目适用于<code class="codeph">getInstance</code>调用，并且该条目<span class="variable" translate="no">does</span>指定必须执行豁免机制，然后检查豁免管辖权策略文件。如果豁免许可包括相关算法和豁免机制的条目，并且该条目由与应用程序捆绑在一起的许可权策略文件中的许可权隐含，并且如果指定的豁免机制的实现可从其中一个注册用户获得，提供者，然后从豁免权限条目中确定<span class="apiname">密码</span>的最大密钥大小和算法参数值。
                     </p>
                     <p>如果在与应用程序捆绑在一起的权限策略文件中没有相关条目所隐含的豁免许可条目，或者如果没有任何已注册的提供程序提供的指定豁免机制的实现，则仅允许应用程序使用标准默认设置加密权限。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469" name="GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469"></a><h3 id="JSSEC-GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469" class="sect3">标准名称</h3>
               <div>
                  <p>标准名称文档包含有关算法规范的信息。</p>
                  <div class="section">
                     <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>描述了JDK安全API要求和使用的算法，证书和密钥库类型的标准名称。它还包含有关算法规范的更多信息。具体的提供者信息可以在<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK Providers Documentation中</a>找到。
                     </p>
                     <p>JDK中的加密实现是通过几个不同的提供程序分发的，主要是出于历史原因（ <code class="codeph">Sun</code> ， <code class="codeph">SunJSSE</code> ， <code class="codeph">SunJCE</code> ， <code class="codeph">SunRsaSign</code> ）。注意，这些提供程序可能并非在所有JDK实现上都可用，因此，真正的可移植应用程序应在不指定特定提供程序的情况下调用<span class="apiname">getInstance（）</span> 。指定特定提供程序的应用程序可能无法利用针对基础操作环境（例如PKCS或Microsoft的CAPI）调整的本机提供程序。
                     </p>
                     <p>的<code class="codeph">SunPKCS11</code>提供程序本身不包含任何加密算法，而是将请求定向到基础PKCS11实现中。请参阅<a href="pkcs11-reference-guide1.html#GUID-30E98B63-4910-40A1-A6DD-663EAF466991">《 PKCS＃11参考指南》</a>和基础的PKCS11实现，以确定是否可以通过PKCS11提供程序使用所需的算法。同样，在Windows系统上， <code class="codeph">SunMSCAPI</code>提供程序不提供任何加密功能，而是将请求路由到底层操作系统进行处理。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C" name="GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C"></a><h3 id="JSSEC-GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C" class="sect3">打包您的应用程序</h3>
               <div>
                  <p></p>
                  <p>您可以将应用程序打包为三种不同的模块：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>命名或显式模块：出现在模块路径上的模块，该模块中包含模块配置信息<code>module-info.class</code>文件。
                        </p>
                     </li>
                     <li>
                        <p>自动模块：出现在模块路径上的模块，但在模块路径中不包含模块配置信息<code>module-info.class</code>文件（基本上是“常规” JAR文件）。
                        </p>
                     </li>
                     <li>
                        <p>未命名的模块：出现在类路径上的模块。它可能有也可能没有<code>module-info.class</code>文件;该文件将被忽略。
                        </p>
                     </li>
                  </ul>
                  <p>建议您将应用程序打包在命名模块中，因为它们可以提供更好的性能，更强的封装和更简单的配置。它们还提供了更大的灵活性。您可以通过在模块化JDK的类路径中指定它们，将它们与非模块化JDK甚至作为未命名模块一起使用。</p>
                  <p>有关模块的更多信息，请参见<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank">模块系统的状态</a>和<a href="http://openjdk.java.net/jeps/261" target="_blank">JEP 261：模块系统。</a></p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-871FA938-5110-409E-A4EC-16F2A898093A" name="GUID-871FA938-5110-409E-A4EC-16F2A898093A"></a><h3 id="JSSEC-GUID-871FA938-5110-409E-A4EC-16F2A898093A" class="sect3">其他JCA代码样本</h3>
               <div>
                  <p></p>
                  <p>这些示例说明了几种JCA机制的使用。另请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" title="以下是用于Diffie-Hellman密钥交换，AES / GCM和HMAC-SHA256的示例程序。">Diffie-Hellman密钥交换，AES / GCM和HMAC-SHA256的示例程序</a></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-871FA938-5110-409E-A4EC-16F2A898093A__GUID-08F32763-225D-4D48-BEE3-04D3D93F27BD">话题</p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" title="描述计算MessageDigest对象的过程的示例。">计算一个MessageDigest对象</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="在此示例中，我们将为名为的算法生成一个公钥-私钥对" ds="=" ="">生成一对密钥</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" title="使用生成的密钥生成和验证签名的示例。">使用生成的密钥生成和验证签名</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="使用密钥规范和KeyFactory生成和验证签名的示例代码。">使用密钥规格和KeyFactory生成/验证签名</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" title="确定两个键是否相等的示例代码。">确定两个键是否相等</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8">读取Base64编码的证书</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A">解析证书回复</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" title="本节将引导用户完成以下过程：生成密钥，创建和初始化密码对象，加密文件然后解密。在整个示例中，我们使用高级加密标准（AES）。">使用加密</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4">使用基于密码的加密</a></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" name="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1"></a><h4 id="JSSEC-GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" class="sect4">计算一个MessageDigest对象</h4>
                  <div>
                     <p>描述计算MessageDigest对象的过程的示例。</p>
                     <ol>
                        <li class="stepexpand"><span>创建<code class="codeph">MessageDigest</code>对象，如以下示例所示：</span><div><pre class="codeblock"><code>
   MessageDigest sha = MessageDigest.getInstance("SHA-256");
</code></pre><p>此调用将正确初始化的消息摘要对象分配给<code class="codeph">sha</code>变量。该实现实现了美国国家标准技术研究院（NIST） <a href="http://csrc.nist.gov/publications/fips/index.html" target="_blank">FIPS 180-2文档中</a>定义的安全哈希算法（SHA-256）。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>假设我们有三个字节数组， <code class="codeph">i1</code> ， <code class="codeph">i2</code>和<code class="codeph">i3</code> ，形成我们要计算其消息摘要的总输入。可以通过以下调用来计算此摘要（或“哈希”）：</span><div><pre class="codeblock"><code>
   sha.update(i1);
   sha.update(i2);
   sha.update(i3);
   byte[] hash = sha.digest();
</code></pre></div>
                        </li>
                        <li class="stepexpand"><strong>可选：</strong> <span>一系列等效的替代呼叫将是：</span><div><pre class="codeblock"><code>
   sha.update(i1);
   sha.update(i2);
   byte[] hash = sha.digest(i3);
</code></pre></div>
                           <div>
                              <p>计算完消息摘要后，将自动重置消息摘要对象，并准备接收新数据并计算其摘要。所有以前的状态（即提供给<code class="codeph">update</code>电话）丢失。
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-330AF0AF-315C-4418-8882-6CF8F4C9E551">
                        <p class="titleinexample">示例2-11通过克隆的哈希实现</p>
                        <p>一些哈希实现可能通过克隆支持中间哈希。假设我们要为以下各项计算单独的哈希：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">i1</code></li>
                           <li><code class="codeph">i1 and i2</code></li>
                           <li><code class="codeph">i1, i2, and i3</code></li>
                        </ul>
                        <p>以下是计算这些哈希的一种方法；但是，此代码仅在SHA-256实现可克隆时才有效：</p><pre class="codeblock"><code>/* compute the hash for i1 */
sha.update(i1);
byte[] i1Hash = sha.clone().digest();

/* compute the hash for i1 and i2 */
sha.update(i2);
byte[] i12Hash = sha.clone().digest();

/* compute the hash for i1, i2 and i3 */
sha.update(i3);
byte[] i123hash = sha.digest();
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-B26EFA90-D3F5-4D84-BC21-4463D144473D">
                        <p class="titleinexample">示例2-12确定哈希实现是否可克隆</p>消息摘要的某些实现是可克隆的，而其他则不是。要确定是否可以克隆，请尝试克隆<code class="codeph">MessageDigest</code>反对并捕获潜在的异常，如下所示：<pre class="codeblock"><code>try {
    // try and clone it
    /* compute the hash for i1 */
    sha.update(i1);
    byte[] i1Hash = sha.clone().digest();
    // ...
    byte[] i123hash = sha.digest();
} catch (CloneNotSupportedException cnse) {
    // do something else, such as the code shown below
}
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-27A86AA9-D666-434E-9132-6714C46CF320">
                        <p class="titleinexample">示例2-13如果哈希实现不可克隆，则计算中间摘要</p>如果消息摘要不可克隆，则计算中间摘要的另一种不太优雅的方法是创建多个摘要。在这种情况下，必须预先知道要计算的中间摘要的数量：<pre class="codeblock"><code>   MessageDigest md1 = MessageDigest.getInstance("SHA-256");
   MessageDigest md2 = MessageDigest.getInstance("SHA-256");
   MessageDigest md3 = MessageDigest.getInstance("SHA-256");

   byte[] i1Hash = md1.digest(i1);

   md2.update(i1);
   byte[] i12Hash = md2.digest(i2);

   md3.update(i1);
   md3.update(i2);
   byte[] i123Hash = md3.digest(i3);
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" name="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6"></a><h4 id="JSSEC-GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" class="sect4">生成一对密钥</h4>
                  <div>
                     <p>在此示例中，我们将为名为“ DSA”（数字签名算法）的算法生成一个公钥-私钥对，并在以后的示例中使用此密钥对。我们将生成具有2048位模数的密钥。我们不在乎哪个提供程序提供算法实现。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-E0DA036D-2F50-477A-976A-716A58BAB38E">创建密钥对生成器</p>
                        <p>第一步是获取用于生成DSA算法密钥的密钥对生成器对象：</p><pre class="codeblock"><code>
	KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-F9CB599A-4B78-4EA1-AA7C-9F8886A42D0D">初始化密钥对生成器</p>
                        <p>下一步是初始化密钥对生成器。在大多数情况下，独立于算法的初始化就足够了，但是在某些情况下，使用特定于算法的初始化。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-B61F273F-CE81-434C-BA40-ABA5D951104B">独立于算法的初始化</p>
                        <p>所有密钥对生成器都共享密钥大小和随机性源的概念。的<code class="codeph">KeyPairGenerator</code>类的初始化方法至少需要一个keysize。如果未明确提供随机性来源，则<code class="codeph">SecureRandom</code>将使用最高优先级的已安装提供程序的实现。因此，要生成密钥大小为2048的密钥，只需调用：</p><pre class="codeblock"><code>    keyGen.initialize(2048);
</code></pre><p>以下代码说明了如何使用特定的种子<code class="codeph">SecureRandom</code>宾语：</p><pre class="codeblock"><code>    SecureRandom random = SecureRandom.getInstance("DRBG", "SUN");
    random.setSeed(userSeed);
    keyGen.initialize(2048, random);
</code></pre><p>由于在调用上述独立于算法的<span class="apiname">初始化</span>方法时未指定其他参数，因此由提供者决定如何与每个键关联特定于算法的参数（如果有）。提供者可以使用预先计算的参数值或可以生成新值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-3818AF4B-55DB-4A14-89C9-E26AC60BD770">特定于算法的初始化</p>
                        <p>对于已经存在一组特定于算法的参数（例如DSA中的“社区参数”）的情况，有两个<code class="codeph">initialize</code>具有<code class="codeph">AlgorithmParameterSpec</code>论点。假设您的密钥对生成器用于“ DSA”算法，并且您具有一组特定于DSA的参数， <code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code> ，您想用来生成密钥对。您可以执行以下代码来初始化密钥对生成器（回想一下， <code class="codeph">DSAParameterSpec</code>是一个<code class="codeph">AlgorithmParameterSpec</code> ）：</p><pre class="codeblock"><code>    DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g);
    keyGen.initialize(dsaSpec);
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-3F758987-03FF-45E5-B72D-856E01D3C219">生成密钥对</p>
                        <p>最后一步实际上是生成密钥对。无论使用哪种类型的初始化（与算法无关或算法特定），都使用相同的代码来生成<code class="codeph">KeyPair</code> ：</p><pre class="codeblock"><code>    KeyPair pair = keyGen.generateKeyPair();
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" name="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A"></a><h4 id="JSSEC-GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" class="sect4">使用生成的密钥生成和验证签名</h4>
                  <div>
                     <p>使用生成的密钥生成和验证签名的示例。</p>
                     <div class="section">以下签名生成和验证示例使用<code class="codeph">KeyPair</code>在<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="在此示例中，我们将为名为的算法生成一个公钥-私钥对" ds="=" ="">生成密钥对中产生的</a> 。
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A__GUID-90D8DCA9-8573-4901-AB93-D6D00A0D9CDA">生成签名</p>
                        <p>我们首先创建一个Signature Class对象：</p><pre class="codeblock"><code>
    Signature dsa = Signature.getInstance("SHA256withDSA");
</code></pre><p>接下来，使用在密钥对示例中生成的密钥对，我们使用私钥初始化对象，然后对称为<code class="codeph">data</code> 。
                        </p><pre class="codeblock"><code>
   /* Initializing the object with a private key */
    PrivateKey priv = pair.getPrivate();
    dsa.initSign(priv);

   /* Update and sign the data */
    dsa.update(data);
    byte[] sig = dsa.sign();
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A__GUID-AF402D39-046E-4E3B-878E-498A51ED5378">验证签名</p>
                        <p>验证签名很简单。（请注意，这里我们还使用在密钥对示例中生成的密钥对。）</p><pre class="codeblock"><code>
   /* Initializing the object with the public key */
   PublicKey pub = pair.getPublic();
   dsa.initVerify(pub);

   /* Update and verify the data */
   dsa.update(data);
   boolean verifies = dsa.verify(sig);
   System.out.println("signature verifies: " + verifies);
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" name="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406"></a><h4 id="JSSEC-GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" class="sect4">使用密钥规格和KeyFactory生成/验证签名</h4>
                  <div>
                     <p>示例代码，用于使用密钥规范和<code class="codeph">KeyFactory</code> 。
                     </p>
                     <div class="section">
                        <p>假设您没有DSA私钥的组成部分，而不是拥有公钥/私钥对（例如，例如在上面的“ <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " ds="=" ="">生成密钥对</a> ”中<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="在此示例中，我们将为名为的算法生成一个公钥-私钥对" ds="=" ="">生成的</a> ），而是： <code class="codeph">x</code> （私钥）， <code class="codeph">p</code> （素数）， <code class="codeph">q</code> （次贷），以及<code class="codeph">g</code> （基础）。
                        </p>
                        <p>进一步假设您想使用私钥对某些数据进行数字签名，这些数据位于一个名为<code class="codeph">someData</code> 。您将执行以下步骤，这些步骤还说明了如何创建密钥规格并使用密钥工厂来获取密钥。 <code class="codeph">PrivateKey</code>从关键规范（ <code class="codeph">initSign</code>需要一个<code class="codeph">PrivateKey</code> ）：</p><pre class="codeblock"><code>
    DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec);

    Signature sig = Signature.getInstance("SHA256withDSA");
    sig.initSign(privKey);
    sig.update(someData);
    byte[] signature = sig.sign();
</code></pre><p>假设爱丽丝想使用您签名的数据。为了使她能够这样做并验证您的签名，您需要向她发送以下三件事：</p>
                        <ol>
                           <li>数据</li>
                           <li>签名</li>
                           <li>与用于签署数据的私钥相对应的公钥</li>
                        </ol>
                        <p>您可以存储<code class="codeph">someData</code>一个文件中的字节，然后<code class="codeph">signature</code>个字节，然后将其发送给Alice。
                        </p>
                        <p>对于公共密钥，假设像上面的签名示例一样，您具有与用于签名数据的DSA私有密钥相对应的DSA公共密钥的组件。然后您可以创建一个<code class="codeph">DSAPublicKeySpec</code>从这些组件：</p><pre class="codeblock"><code>
    DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g);
</code></pre><p>您仍然需要提取密钥字节，以便可以将其放入文件中。为此，您可以先致电<code class="codeph">generatePublic</code>上例中已创建的DSA密钥工厂上的方法：</p><pre class="codeblock"><code>  
    PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec);
</code></pre><p>然后，您可以通过以下方式提取（编码的）密钥字节：</p><pre class="codeblock"><code>
    byte[] encKey = pubKey.getEncoded();
</code></pre><p>现在，您可以将这些字节存储在文件中，并将其与包含数据和签名的文件一起发送给Alice。</p>
                        <p>现在，假设爱丽丝已经收到了这些文件，并且她将数据字节从数据文件复制到名为<code class="codeph">data</code> ，从签名文件到名为的字节数组的签名字节<code class="codeph">signature</code> ，以及从公共密钥文件到名为的字节数组的编码公共密钥字节<code class="codeph">encodedPubKey</code> 。
                        </p>
                        <p>爱丽丝现在可以执行以下代码来验证签名。该代码还说明了如何使用密钥工厂以从其编码实例化DSA公共密钥（ <code class="codeph">initVerify</code>需要一个<code class="codeph">PublicKey</code> ）。
                        </p><pre class="codeblock"><code>
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);

    Signature sig = Signature.getInstance("SHA256withDSA");
    sig.initVerify(pubKey);
    sig.update(data);
    sig.verify(signature);
</code></pre><div class="p"> 
                           <div class="infoboxnote" id="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406__GUID-6139C985-28C3-43D0-8F90-5B1DF9F45ABE">
                              <p class="notep1">注意：</p>在上面，爱丽丝需要生成一个<code class="codeph">PublicKey</code>从编码的密钥位开始，因为<code class="codeph">initVerify</code>需要一个<code class="codeph">PublicKey</code> 。一旦她有一个<code class="codeph">PublicKey</code> ，她也可以使用<code class="codeph">KeyFactory</code><code class="codeph">getKeySpec</code>将其转换为<code class="codeph">DSAPublicKeySpec</code>以便她可以根据需要访问组件，例如：</div>
                        </div><pre class="codeblock"><code>
    DSAPublicKeySpec dsaPubKeySpec =
        (DSAPublicKeySpec)keyFactory.getKeySpec(pubKey, DSAPublicKeySpec.class);</code></pre><p>现在，她可以访问DSA公钥组件<code class="codeph">y</code> ， <code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code>通过相应的“获取”方法<code class="codeph">DSAPublicKeySpec</code>类（ <code class="codeph">getY</code> ， <code class="codeph">getP</code> ， <code class="codeph">getQ</code>和<code class="codeph">getG</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-36893ED5-E3CA-496B-BC78-B13EE971C736" name="GUID-36893ED5-E3CA-496B-BC78-B13EE971C736"></a><h4 id="JSSEC-GUID-36893ED5-E3CA-496B-BC78-B13EE971C736" class="sect4">产生随机数</h4>
                  <div>
                     <p>下面的代码示例说明了使用<span class="apiname">SecureRandom</span>类的DRBG实现生成具有不同安全强度的随机数：</p>
                     <div class="section"><pre class="pre codeblock"><code>    SecureRandom drbg;
    byte[] buffer = new byte[32];

    // Any DRBG can be provided 
    drbg = SecureRandom.getInstance("DRBG");
    drbg.nextBytes(buffer);

    SecureRandomParameters params = drbg.getParameters();
    if (params instanceof DrbgParameters.Instantiation) {
        DrbgParameters.Instantiation ins = (DrbgParameters.Instantiation) params;
        if (ins.getCapability().supportsReseeding()) {
            drbg.reseed();
        }
    } 

    // The following call requests a weak DRBG instance. It is only
    // guaranteed to support 112 bits of security strength.
    drbg = SecureRandom.getInstance("DRBG",
        DrbgParameters.instantiation(112, NONE, null));

    // Both the next two calls will likely fail, because drbg could be
    // instantiated with a smaller strength with no prediction resistance
    // support.
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(256, false, "more".getBytes()));
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(112, true, "more".getBytes()));

    // The following call requests a strong DRBG instance, with a
    // personalization string. If it successfully returns an instance,
    // that instance is guaranteed to support 256 bits of security strength
    // with prediction resistance available.
    drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(
        256, PR_AND_RESEED, "hello".getBytes()));

    // Prediction resistance is not requested in this single call,
    // but an additional input is used.
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(-1, false, "more".getBytes()));

    // Same for this call.
    drbg.reseed(DrbgParameters.reseed(false, "extra".getBytes()));</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" name="GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC"></a><h4 id="JSSEC-GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" class="sect4">确定两个键是否相等</h4>
                  <div>
                     <p>确定两个键是否相等的示例代码。</p>
                     <div class="section">
                        <p>在许多情况下，您想知道两个键是否相等。但是，默认方法<code class="codeph">java.lang.Object.equals</code>可能无法提供理想的结果。与提供者最无关的方法是比较编码的密钥。如果此比较不合适（例如，比较<code class="codeph">RSAPrivateKey</code>和<code class="codeph">RSAPrivateCrtKey</code> ），您应该比较每个组件。
                        </p>
                        <p>以下代码演示了此想法：</p><pre class="codeblock"><code>
   static boolean keysEqual(Key key1, Key key2) {
       if (key1.equals(key2)) {
          return true;
       }

       if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) {
          return true;
       }

    // More code for different types of keys here.
    // For example, the following code can check if
    // an RSAPrivateKey and an RSAPrivateCrtKey are equal:
    // if ((key1 instanceof RSAPrivateKey) &amp;&amp;
    //     (key2 instanceof RSAPrivateKey)) {
    //     if ((key1.getModulus().equals(key2.getModulus())) &amp;&amp;
    //         (key1.getPrivateExponent().equals(
    //                                      key2.getPrivateExponent()))) {
    //         return true;
    //     }
    // }

        return false;
    }
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8" name="GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8"></a><h4 id="JSSEC-GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8" class="sect4">读取Base64编码的证书</h4>
                  <div>
                     <div class="section">
                        <p>下面的示例读取带有Base64编码证书的文件，每个证书的开头都以</p><pre class="codeblock"><code>-----BEGIN CERTIFICATE-----
</code></pre><p>最后</p><pre class="codeblock"><code>-----END CERTIFICATE-----
</code></pre><p>我们将<code class="codeph">FileInputStream</code> （不支持<code class="codeph">mark</code>和<code class="codeph">reset</code> ）到<code class="codeph">ByteArrayInputStream</code> （支持这些方法），以便每次调用<code class="codeph">generateCertificate</code>仅使用一个证书，并且输入流的读取位置位于文件中的下一个证书：</p><pre class="codeblock"><code>    try (FileInputStream fis = new FileInputStream(filename);
        BufferedInputStream bis = new BufferedInputStream(fis)) {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        while (bis.available() &gt; 0) {
            Certificate cert = cf.generateCertificate(bis); 
            System.out.println(cert.toString());
        }
   }</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A" name="GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A"></a><h4 id="JSSEC-GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A" class="sect4">解析证书回复</h4>
                  <div>
                     <div class="section">
                        <p>下面的示例解析存储在文件中的PKCS7格式的证书答复，并从中提取所有证书：</p><pre class="codeblock"><code>
   try (FileInputStream fis = new FileInputStream(filename)) {
      CertificateFactory cf = CertificateFactory.getInstance("X.509");

      Collection&lt;? extends Certificate&gt; c = cf.generateCertificates(fis);
      for (Certificate cert : c) {
          System.out.println(cert);
      }

      // Or use the aggregate operations below for the above for-loop
      // c.stream().forEach(e -&gt; System.out.println(e));
   }</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" name="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF"></a><h4 id="JSSEC-GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" class="sect4">使用加密</h4>
                  <div>
                     <p>本节将引导用户完成以下过程：生成密钥，创建和初始化密码对象，加密文件然后解密。在整个示例中，我们使用高级加密标准（AES）。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF__GUID-00354A2E-2E83-4526-8641-493E8355827F">生成密钥</p>
                        <p>要创建AES密钥，我们必须实例化AES的<span class="apiname">KeyGenerator</span> 。我们没有指定提供者，因为我们不在乎特定的AES密钥生成实现。由于我们没有初始化<span class="apiname">KeyGenerator</span> ，因此将使用系统提供的随机性源和默认密钥大小来创建AES密钥：</p><pre class="codeblock"><code>
    KeyGenerator keygen = KeyGenerator.getInstance("AES");
    keygen.init(128);
    SecretKey aesKey = keygen.generateKey();
</code></pre><p>生成密钥后，可以重复使用同一KeyGenerator对象来创建其他密钥。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF__GUID-E7EF09E3-A93B-455B-B8E7-0ACB190996E1">创建密码</p>
                        <p>下一步是创建一个<span class="apiname">Cipher</span>实例。为此，我们使用<code class="codeph">getInstance</code> <span class="apiname">密码</span>类的工厂方法。我们必须指定所请求转换的名称，其中包括以下组件，并用斜杠（/）分隔：</p>
                        <ul style="list-style-type:disc">
                           <li>算法名称</li>
                           <li>模式（可选）</li>
                           <li>填充方案（可选）</li>
                        </ul>
                        <p>在此示例中，我们在密码块链接模式下使用PKCS5样式的填充创建AES密码。我们没有指定提供者，因为我们不在乎请求的转换的特定实现。</p>
                        <p>AES的标准算法名称为“ AES”，密码块链接模式的标准名称为“ CBC”，PKCS5样式填充的标准名称为“ PKCS5Padding”：</p><pre class="codeblock"><code>
    Cipher aesCipher;

    // Create the cipher
    aesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
</code></pre><p>我们使用生成的<code class="codeph">aesKey</code>从上面初始化用于加密的<span class="apiname">Cipher</span>对象：</p><pre class="codeblock"><code>    // Initialize the cipher for encryption
    aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);

    // Our cleartext
    byte[] cleartext = "This is just an example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = aesCipher.doFinal(cleartext);

    // Retrieve the parameters used during encryption to properly  
    // initialize the cipher for decryption
    AlgorithmParameters params = aesCipher.getParameters();

    // Initialize the same cipher for decryption
    aesCipher.init(Cipher.DECRYPT_MODE, aesKey, params);

    // Decrypt the ciphertext
    byte[] cleartext1 = aesCipher.doFinal(ciphertext);</code></pre><p><code class="codeph">cleartext</code>和<code class="codeph">cleartext1</code>都是一样的
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4" name="GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4"></a><h4 id="JSSEC-GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4" class="sect4">使用基于密码的加密</h4>
                  <div>
                     <div class="section">
                        <p>在此示例中，我们提示用户输入密码，以从中获得加密密钥。</p>
                        <p>收集密码并将其存储在类型为的对象中似乎合乎逻辑<code class="codeph">java.lang.String</code> 。但是，以下是警告：类型的对象<code class="codeph">String</code>是不可变的，即没有定义的方法允许您更改（覆盖）或将a的内容清零<code class="codeph">String</code>使用后。此功能使<code class="codeph">String</code>不适合存储安全敏感信息（例如用户密码）的对象。您应该始终将安全敏感信息收集并存储在char数组中。因此， <code class="codeph">javax.crypto.spec.PBEKeySpec</code>类接受（并返回）密码作为char数组。
                        </p>
                        <p>为了使用PKCS5中定义的基于密码的加密（PBE），我们必须指定一个<span class="variable" translate="no">salt</span>和一个<span class="variable" translate="no">iteration count</span> 。用于解密的盐和迭代计数必须相同。较新的PBE算法使用的迭代次数至少为1000。
                        </p><pre class="codeblock"><code>    PBEKeySpec pbeKeySpec;
    PBEParameterSpec pbeParamSpec;
    SecretKeyFactory keyFac;

    // Salt
    byte[] salt = new SecureRandom().nextBytes(salt);

    // Iteration count
    int count = 1000;

    // Create PBE parameter set
    pbeParamSpec = new PBEParameterSpec(salt, count);

    // Prompt user for encryption password.
    // Collect user password as char array, and convert
    // it into a SecretKey object, using a PBE key
    // factory.
    char[] password = System.console.readPassword("Enter encryption password: ");
    pbeKeySpec = new PBEKeySpec(password);
    keyFac = SecretKeyFactory.getInstance("PBEWithHmacSHA256AndAES_256");
    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

    // Create PBE Cipher
    Cipher pbeCipher = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // Initialize PBE Cipher with key and parameters
    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

    // Our cleartext
    byte[] cleartext = "This is another example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = pbeCipher.doFinal(cleartext);

</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" name="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0"></a><h3 id="JSSEC-GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" class="sect3">Diffie-Hellman密钥交换，AES / GCM和HMAC-SHA256的示例程序</h3>
               <div>
                  <p>以下是用于Diffie-Hellman密钥交换，AES / GCM和HMAC-SHA256的示例程序。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0__GUID-FDC020B3-4193-4DD5-88E1-4DA6CBDB346E">话题</p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" title="该程序在两方之间运行Diffie-Hellman密钥协商协议。">两方之间的Diffie-Hellman密钥交换</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" title="该程序在3个参与者之间运行Diffie-Hellman密钥协商协议。">3方之间的Diffie-Hellman密钥交换</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" title="以下是一个示例程序，用于演示AES / GCM加密/解密数据的用法。">AES / GCM示例</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" title="以下是一个示例程序，该示例程序演示了如何为HMAC-SHA256生成密钥对象，并使用该对象初始化HMAC-SHA256对象。">HMAC-SHA256示例</a></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" name="GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4"></a><h4 id="JSSEC-GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" class="sect4">两方之间的Diffie-Hellman密钥交换</h4>
                  <div>
                     <p>该程序在两方之间运行Diffie-Hellman密钥协商协议。</p>
                     <div class="section"><pre class="pre codeblock"><code>/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

public class DHKeyAgreement2 {
    private DHKeyAgreement2() {}
    public static void main(String argv[]) throws Exception {
        
        /*
         * Alice creates her own DH key pair with 2048-bit key size
         */
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(2048);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
        
        // Alice creates and initializes her DH KeyAgreement object
        System.out.println("ALICE: Initialization ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());
        
        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
        
        /*
         * Let's turn over to Bob. Bob has received Alice's public key
         * in encoded format.
         * He instantiates a DH public key from the encoded key material.
         */
        KeyFactory bobKeyFac = KeyFactory.getInstance("DH");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(alicePubKeyEnc);

        PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);

        /*
         * Bob gets the DH parameters associated with Alice's public key.
         * He must use the same parameters when he generates his own key
         * pair.
         */
        DHParameterSpec dhParamFromAlicePubKey = ((DHPublicKey)alicePubKey).getParams();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhParamFromAlicePubKey);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Bob creates and initializes his DH KeyAgreement object
        System.out.println("BOB: Initialization ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Bob encodes his public key, and sends it over to Alice.
        byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instantiate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance("DH");
        x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println("ALICE: Execute PHASE1 ...");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * Bob uses Alice's public key for the first (and only) phase
         * of his version of the DH
         * protocol.
         */
        System.out.println("BOB: Execute PHASE1 ...");
        bobKeyAgree.doPhase(alicePubKey, true);

        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        try {
            byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
            int aliceLen = aliceSharedSecret.length;
            byte[] bobSharedSecret = new byte[aliceLen];
            int bobLen;
        } catch (ShortBufferException e) {
            System.out.println(e.getMessage());
        }        // provide output buffer of required size
        bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);
        System.out.println("Alice secret: " +
                toHexString(aliceSharedSecret));
        System.out.println("Bob secret: " +
                toHexString(bobSharedSecret));
        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Shared secrets differ");
        System.out.println("Shared secrets are the same");

        /*
         * Now let's create a SecretKey object using the shared secret
         * and use it for encryption. First, we generate SecretKeys for the
         * "AES" algorithm (based on the raw shared secret data) and
         * Then we use AES in CBC mode, which requires an initialization
         * vector (IV) parameter. Note that you have to use the same IV
         * for encryption and decryption: If you use a different IV for
         * decryption than you used for encryption, decryption will fail.
         *
         * If you do not specify an IV when you initialize the Cipher
         * object for encryption, the underlying implementation will generate
         * a random one, which you have to retrieve using the
         * javax.crypto.Cipher.getParameters() method, which returns an
         * instance of java.security.AlgorithmParameters. You need to transfer
         * the contents of that object (e.g., in encoded format, obtained via
         * the AlgorithmParameters.getEncoded() method) to the party who will
         * do the decryption. When initializing the Cipher for decryption,
         * the (reinstantiated) AlgorithmParameters object must be explicitly
         * passed to the Cipher.init() method.
         */
        System.out.println("Use shared secret as SecretKey object ...");
        SecretKeySpec bobAesKey = new SecretKeySpec(bobSharedSecret, 0, 16, "AES");
        SecretKeySpec aliceAesKey = new SecretKeySpec(aliceSharedSecret, 0, 16, "AES");

        /*
         * Bob encrypts, using AES in CBC mode
         */
        Cipher bobCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobAesKey);
        byte[] cleartext = "This is just an example".getBytes();
        byte[] ciphertext = bobCipher.doFinal(cleartext);

        // Retrieve the parameter that was used, and transfer it to Alice in
        // encoded format
        byte[] encodedParams = bobCipher.getParameters().getEncoded();

        /*
         * Alice decrypts, using AES in CBC mode
         */

        // Instantiate AlgorithmParameters object from parameter encoding
        // obtained from Bob
        AlgorithmParameters aesParams = AlgorithmParameters.getInstance("AES");
        aesParams.init(encodedParams);
        Cipher aliceCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceAesKey, aesParams);
        byte[] recovered = aliceCipher.doFinal(ciphertext);
        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("AES in CBC mode recovered text is " +
                    "different from cleartext");
        System.out.println("AES in CBC mode recovered text is "
                "same as cleartext");
    }

    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private static void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private static String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();
        int len = block.length;
        for (int i = 0; i &lt; len; i++) {
            byte2hex(block[i], buf);
            if (i &lt; len-1) {
                buf.append(":");
            }
        }
        return buf.toString();
    }
}</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" name="GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E"></a><h4 id="JSSEC-GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" class="sect4">3方之间的Diffie-Hellman密钥交换</h4>
                  <div>
                     <p>该程序在3个参与者之间运行Diffie-Hellman密钥协商协议。</p>
                     <div class="section"><pre class="codeblock"><code>
/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
   /*
    * This program executes the Diffie-Hellman key agreement protocol between
    * 3 parties: Alice, Bob, and Carol using a shared 2048-bit DH parameter.
    */
    public class DHKeyAgreement3 {
        private DHKeyAgreement3() {}
        public static void main(String argv[]) throws Exception {
        // Alice creates her own DH key pair with 2048-bit key size
            System.out.println("ALICE: Generate DH keypair ...");
            KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
            aliceKpairGen.initialize(2048);
            KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
        // This DH parameters can also be constructed by creating a
        // DHParameterSpec object using agreed-upon values
            DHParameterSpec dhParamShared = ((DHPublicKey)aliceKpair.getPublic()).getParams();
        // Bob creates his own DH key pair using the same params
            System.out.println("BOB: Generate DH keypair ...");
            KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
            bobKpairGen.initialize(dhParamShared);
            KeyPair bobKpair = bobKpairGen.generateKeyPair();
        // Carol creates her own DH key pair using the same params
            System.out.println("CAROL: Generate DH keypair ...");
            KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance("DH");
            carolKpairGen.initialize(dhParamShared);
            KeyPair carolKpair = carolKpairGen.generateKeyPair();
        // Alice initialize
            System.out.println("ALICE: Initialize ...");
            KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
            aliceKeyAgree.init(aliceKpair.getPrivate());
        // Bob initialize
            System.out.println("BOB: Initialize ...");
            KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
            bobKeyAgree.init(bobKpair.getPrivate());
        // Carol initialize
            System.out.println("CAROL: Initialize ...");
            KeyAgreement carolKeyAgree = KeyAgreement.getInstance("DH");
            carolKeyAgree.init(carolKpair.getPrivate());
        // Alice uses Carol's public key
            Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);
        // Bob uses Alice's public key
            Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);
        // Carol uses Bob's public key
            Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false);
        // Alice uses Carol's result from above
            aliceKeyAgree.doPhase(cb, true);
        // Bob uses Alice's result from above
            bobKeyAgree.doPhase(ac, true);
        // Carol uses Bob's result from above
            carolKeyAgree.doPhase(ba, true);
        // Alice, Bob and Carol compute their secrets
            byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
            System.out.println("Alice secret: " + toHexString(aliceSharedSecret));
            byte[] bobSharedSecret = bobKeyAgree.generateSecret();
            System.out.println("Bob secret: " + toHexString(bobSharedSecret));
            byte[] carolSharedSecret = carolKeyAgree.generateSecret();
            System.out.println("Carol secret: " + toHexString(carolSharedSecret));
        // Compare Alice and Bob
            if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
                throw new Exception("Alice and Bob differ");
            System.out.println("Alice and Bob are the same");
        // Compare Bob and Carol
            if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))
                throw new Exception("Bob and Carol differ");
            System.out.println("Bob and Carol are the same");
        }
    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
        private static void byte2hex(byte b, StringBuffer buf) {
            char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                                '9', 'A', 'B', 'C', 'D', 'E', 'F' };
            int high = ((b &amp; 0xf0) &gt;&gt; 4);
            int low = (b &amp; 0x0f);
            buf.append(hexChars[high]);
            buf.append(hexChars[low]);
        }
    /*
     * Converts a byte array to hex string
     */
        private static String toHexString(byte[] block) {
            StringBuffer buf = new StringBuffer();
            int len = block.length;
            for (int i = 0; i &lt; len; i++) {
                byte2hex(block[i], buf);
                if (i &lt; len-1) {
                    buf.append(":");
                }
            }
            return buf.toString();
        }
    }
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" name="GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85"></a><h4 id="JSSEC-GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" class="sect4">AES / GCM示例</h4>
                  <div>
                     <p>以下是一个示例程序，用于演示AES / GCM加密/解密数据的用法。</p><pre class="pre codeblock"><code>/*
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.AlgorithmParameters;
import java.util.Arrays;
import javax.crypto.*;

public class AESGCMTest {

    public static void main(String[] args) throws Exception {
        // Slightly longer than 1 AES block (128 bits) to show PADDING
        // is "handled" by GCM.
        byte[] data = {
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
            0x10};

        // Create a 128-bit AES key.
        KeyGenerator kg = KeyGenerator.getInstance("AES");
        kg.init(128);
        SecretKey key = kg.generateKey();

        // Obtain a AES/GCM cipher to do the enciphering. Must obtain
        // and use the Parameters for successful decryption.
        Cipher encCipher = Cipher.getInstance("AES/GCM/NOPADDING");
        encCipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] enc = encCipher.doFinal(data);
        AlgorithmParameters ap = encCipher.getParameters();

        // Obtain a similar cipher, and use the parameters.
        Cipher decCipher = Cipher.getInstance("AES/GCM/NOPADDING");
        decCipher.init(Cipher.DECRYPT_MODE, key, ap);
        byte[] dec = decCipher.doFinal(enc);

        if (Arrays.compare(data, dec) != 0) {
            throw new Exception("Original data != decrypted data");
        }
    }
}</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" name="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A"></a><h4 id="JSSEC-GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" class="sect4">HMAC-SHA256示例</h4>
                  <div>
                     <p>以下是一个示例程序，该示例程序演示了如何为HMAC-SHA256生成密钥对象，并使用该对象初始化HMAC-SHA256对象。</p>
                     <div class="example" id="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A__GUID-4C1C7226-F8A7-4780-8B85-40DFD7702C31">
                        <p class="titleinexample">示例2-14为HMAC-SHA256生成密钥对象</p><pre class="codeblock"><code>/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.*;
import javax.crypto.*;

    /**
     * This program demonstrates how to generate a secret-key object for
     * HMACSHA256, and initialize an HMACSHA256 object with it.
     */

    public class initMac {

        public static void main(String[] args) throws Exception {

            // Generate secret key for HmacSHA256
            KeyGenerator kg = KeyGenerator.getInstance("HmacSHA256");
            SecretKey sk = kg.generateKey();

            // Get instance of Mac object implementing HmacSHA256, and
            // initialize it with the above secret key
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(sk);
            byte[] result = mac.doFinal("Hi There".getBytes());
        }
    }
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>