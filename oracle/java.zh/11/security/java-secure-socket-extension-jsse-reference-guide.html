<html lang="en-us" dir="ltr" xml:lang="en-us"><head></head><body dir="ltr">﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <meta name="description" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <title>Java安全套接字扩展（JSSE）参考指南</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="kerberos-5-gss-api-mechanism.html" title="Previous" type="text/html">
      <link rel="next" href="running-jsse-sample-code1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="kerberos-5-gss-api-mechanism.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="running-jsse-sample-code1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java安全套接字扩展（JSSE）参考指南</li>
            </ol>
            <a id="GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" name="GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345"></a>
            
            <h2 id="JSSEC-GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" class="sect2"><span class="enumeration_chapter">8</span> Java安全套接字扩展（JSSE）参考指南</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='java-secure-socket-extension-jsse-reference-guide'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>Java安全套接字扩展（JSSE）支持安全的Internet通信。它为TLS和DTLS协议的Java版本提供了框架和实现，并包括数据加密，服务器身份验证，消息完整性和可选的客户端身份验证的功能。</p>
            </div>
            <div class="sect2"><a id="GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA" name="GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA"></a><h3 id="JSSEC-GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA" class="sect3">JSSE简介</h3>
               <div>
                  <p>非预期接收者可以轻松访问通过网络传输的数据。当数据包括密码和信用卡号之类的私人信息时，必须采取措施使未经授权的人员无法理解该数据。同样重要的是要确保在传输过程中没有有意或无意地修改数据。传输层安全性（TLS）协议旨在帮助保护数据在网络上传输时的私密性和完整性。</p>
                  <div class="section">
                     <p>Java安全套接字扩展（JSSE）支持安全的Internet通信。它为TLS协议的Java版本提供了框架和实现，并包括数据加密，服务器身份验证，消息完整性和可选的客户端身份验证的功能。使用JSSE，开发人员可以通过TCP / IP在运行任何应用程序协议（例如HTTP，Telnet或FTP）的客户端和服务器之间提供安全的数据传递。</p>
                     <p>通过抽象出复杂的基础安全算法和握手机制，JSSE最大限度地降低了创建细微但危险的安全漏洞的风险。此外，它通过充当开发人员可以直接集成到他们的应用程序中的构建块来简化应用程序开发。</p>
                     <p>JSSE提供了应用程序编程接口（API）框架和该API的实现。 JSSE API补充了由NETWORK定义的核心网络和加密服务。 <code class="codeph">java.security</code>和<code class="codeph">java.net</code>通过提供扩展的网络套接字类，信任管理器，密钥管理器，SSL上下文和用于封装套接字创建行为的套接字工厂框架来打包这些软件包。因为<code class="codeph">SSLSocket</code>类基于阻塞的I / O模型，Java开发工具包（JDK）包含非阻塞<code class="codeph">SSLEngine</code>类，以使实现能够选择自己的I / O方法。
                     </p>
                     <p>JSSE API支持以下安全协议：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>DTLS：版本1.0和1.2</p>
                        </li>
                        <li>
                           <p>TLS：版本1.0、1.1、1.2和1.3</p>
                        </li>
                        <li>
                           <p>SSL（安全套接字层）：3.0版</p>
                        </li>
                     </ul>
                     <p>这些安全协议封装了一个普通的双向流套接字，并且JSSE API添加了对身份验证，加密和完整性保护的透明支持。</p>
                     <p>JSSE是Java SE平台的安全组件，并且基于<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java密码体系结构（JCA）参考指南</a>框架中其他地方的相同设计原则。这种与密码相关的安全组件的框架使它们具有实现独立性，并在可能的情况下具有算法独立性。JSSE使用JCA框架定义的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">加密服务提供程序</a> 。
                     </p>
                     <p>Java SE平台中的其他安全组件包括《 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank">Java身份验证和授权服务（JAAS）参考指南》</a>和《 <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR691" target="_blank">Java安全工具》</a> 。JSSE包含许多与JCA中相同的概念和算法，但会在简单的流套接字API下自动应用它们。</p>
                     <p>JSSE API旨在允许无缝插入其他SSL / TLS / DTLS协议和公钥基础结构（PKI）实现。开发人员还可以提供替代逻辑，以确定是否应信任远程主机或应将哪种身份验证密钥材料发送到远程主机。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A" name="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A"></a><h4 id="JSSEC-GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A" class="sect4">JSSE的功能和优点</h4>
                  <div>
                     <p>JSSE包括以下重要优点和功能：</p>
                     <ul style="list-style-type:disc">
                        <li>作为JDK的标准组件包含</li>
                        <li>基于提供商的可扩展架构</li>
                        <li>用100％纯Java实现</li>
                        <li>提供TLS / DTLS的API支持</li>
                        <li>提供SSL 3.0，TLS（版本1.0、1.1、1.2和1.3）和DTLS（版本1.0和1.2）的实现</li>
                        <li>包括可实例化以创建安全通道的类（ <code class="codeph">SSLSocket</code> ， <code class="codeph">SSLServerSocket</code>和<code class="codeph">SSLEngine</code> ）</li>
                        <li>提供对密码套件协商的支持，这是用于启动或验证安全通信的TLS / DTLS握手的一部分</li>
                        <li>提供对客户端和服务器身份验证的支持，这是常规TLS / DTLS握手的一部分</li>
                        <li>提供对封装在TLS协议中的HTTP的支持，该协议允许使用HTTPS访问数据（例如网页）</li>
                        <li>提供服务器会话管理API，以管理驻留在内存中的SSL会话</li>
                        <li>提供对证书状态请求扩展（OCSP装订）的支持，从而节省了客户端证书验证的往返次数和资源</li>
                        <li>提供对服务器名称指示（SNI）rxtension的支持，该名称扩展了TLS / DTLS协议以指示客户端在握手期间尝试连接到的服务器名称</li>
                        <li>为握手期间的端点标识提供支持，从而防止中间人攻击</li>
                        <li>提供对加密算法约束的支持，从而对JSSE协商的算法提供细粒度的控制</li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0" name="GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0"></a><h4 id="JSSEC-GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0" class="sect4">JSSE标准API</h4>
                  <div>
                     <p>JSSE标准API，可在<code class="codeph">javax.net</code>和<code class="codeph">javax.net.ssl</code>软件包，提供：</p>
                     <ul style="list-style-type:disc">
                        <li>专为客户端和服务器端应用程序定制的安全套接字。</li>
                        <li>一个非阻塞引擎，用于产生和使用TLS / DTLS数据流（ <code class="codeph">SSLEngine</code> ）。
                        </li>
                        <li>用于创建套接字，服务器套接字，SSL套接字和SSL服务器套接字的工厂。通过使用套接字工厂，可以封装套接字的创建和配置行为。</li>
                        <li>表示安全套接字上下文的类，充当安全套接字工厂和引擎的工厂。</li>
                        <li>密钥和信任管理器接口（包括特定于X.509的密钥和信任管理器），以及可用于创建它们的工厂。</li>
                        <li>安全HTTP URL连接（HTTPS）的类。</li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838" name="GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838"></a><h4 id="JSSEC-GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838" class="sect4">SunJSSE提供者</h4>
                  <div>
                     <p>Oracle的Java SE实现包括一个名为<span class="variable" translate="no">SunJSSE</span>的JSSE提供程序，该提供程序<span class="variable" translate="no">SunJSSE</span>预先安装并预先注册了JCA。该提供程序提供以下加密服务：</p>
                     <ul style="list-style-type:disc">
                        <li>SSL 3.0，TLS（版本1.0、1.1、1.2和1.3）和DTLS（版本1.0和1.2）安全协议的实现。</li>
                        <li>最常见的TLS和DTLS密码套件的实现。此实现包含身份验证，密钥协议，加密和完整性保护的组合。</li>
                        <li>一个基于X.509的密钥管理器的实现，该管理器从标准JCA密钥库中选择适当的身份验证密钥。</li>
                        <li>基于X.509的信任管理器的实现，该管理器实现证书链验证的规则。</li>
                     </ul>
                     <p>请参见<a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">SunJSSE提供程序</a> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA" name="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA"></a><h4 id="JSSEC-GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA" class="sect4">JSSE相关文档</h4>
                  <div>
                     <p>以下列表包含在线文档的链接以及有关相关主题的书籍的名称：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-F6CBD4B8-8264-4D13-BA0B-BC3D04F23303">JSSE API文档</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a>包</p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a>包</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-107C6EEB-EE4B-47D2-8F8D-9A6414BE4E36">Java SE安全性</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html" target="_blank">Java SE安全性</a>主页</p>
                           </li>
                           <li>
                              <p>Java教程的<a href="https://docs.oracle.com/javase/tutorial/security/" target="_blank">Java SE中</a>的<a href="https://docs.oracle.com/javase/tutorial/security/" target="_blank">安全功能</a></p>
                           </li>
                           <li>
                              <p><a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="Java认证路径API由用于处理认证路径的类和接口组成，这些类和接口也称为认证链。如果认证路径满足某些验证规则，则可以使用它来安全地建立公共密钥到主题的映射。">Java PKI程序员指南</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.oracle.com/technetwork/java/javaee/gong-135902.html" target="_blank">Inside Java 2 Platform Security，第二版：体系结构，API设计和实现</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-B86C493A-4053-4532-945F-EE2D62C7929F">传输层安全性（TLS）</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="http://www.ietf.org/rfc/rfc2246.txt" target="_blank">TLS协议版本1.0</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.ietf.org/rfc/rfc4346.txt" target="_blank">TLS协议版本1.1</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.ietf.org/rfc/rfc5246.txt" target="_blank">TLS协议版本1.2</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc8446" target="_blank">（TLS）协议版本1.3</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc6066" target="_blank">传输层安全性（TLS）扩展</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">TLS上的HTTP</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-A4325643-AE73-4989-90F4-CB43BE53F298">数据报传输层安全性（DTLS）</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc4347.txt" target="_blank">DTLS协议版本1.0</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc6347.txt" target="_blank">DTLS协议版本1.2</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-9FD2E015-BE86-4ADC-9554-DCCC17A7A5B1">美国加密政策</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="http://www.commerce.gov/" target="_blank">美国商务部</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.techceocouncil.org" target="_blank">技术首席执行官理事会</a></p>
                           </li>
                           <li>
                              <p>当前的出口政策： <a href="https://www.bis.doc.gov/index.php/policy-guidance/encryption" target="_blank">加密和出口管理条例（EAR）</a></p>
                           </li>
                           <li>
                              <p><a href="http://csrc.nist.gov/publications/index.html" target="_blank">NIST计算机安全出版物</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC" name="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC"></a><h3 id="JSSEC-GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC" class="sect3">JSSE类和接口</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>为了安全通信，连接的两端都必须启用SSL。在JSSE API中，连接的端点类为<code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code> 。在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">图8-1中</a> ，主要类用于创建<code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code>按逻辑顺序排列。
                     </p>
                     <div class="figure" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">
                        <p class="titleinfigure">图8-1用于创建SSLSocket和SSLEngine的JSSE类</p><img src="img/jsse-classes-and-interfaces.png" alt="如下图8-1所示" title="如下图8-1所示" longdesc="img_text/jsse-classes-and-interfaces.html"><br><a href="img_text/jsse-classes-and-interfaces.html">“图8-1用于创建SSLSocket和SSLEngine的JSSE类”的描述</a></div>
                     <!-- class="figure" -->
                     <p>一个<code class="codeph">SSLSocket</code>由一个创建<code class="codeph">SSLSocketFactory</code>或通过<code class="codeph">SSLServerSocket</code>接受入站连接。反过来， <code class="codeph">SSLServerSocket</code>由创建<code class="codeph">SSLServerSocketFactory</code> 。都<code class="codeph">SSLSocketFactory</code>和<code class="codeph">SSLServerSocketFactory</code>对象是由<code class="codeph">SSLContext</code> 。一个<code class="codeph">SSLEngine</code>由...直接创建<code class="codeph">SSLContext</code> ，并依靠该应用程序来处理所有I / O。</p>
                     <div class="infoboxnote" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-1C41051F-5CE0-44B3-A0E9-D7FC41D3C6EE">
                        <p class="notep1">注意：</p>使用生料时<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>类，您应该始终在发送任何数据之前检查对等方的凭据。从JDK 7开始，可以在SSL / TLS握手期间处理端点标识/验证过程。请参见<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.setEndpointIdentificationAlgorithm</span></a>方法。
                        <p>例如，URL中的主机名应与对等方凭据中的主机名匹配。如果未验证主机名，则可以通过URL欺骗利用应用程序。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293" name="GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293"></a><h4 id="JSSEC-GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293" class="sect4">JSSE核心类和接口</h4>
                  <div>
                     <p></p>
                     <p>核心JSSE类是<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a>包的一部分。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6AF71CD9-4E87-49E1-B175-89810D54139E" name="GUID-6AF71CD9-4E87-49E1-B175-89810D54139E"></a><h4 id="JSSEC-GUID-6AF71CD9-4E87-49E1-B175-89810D54139E" class="sect4">SocketFactory和ServerSocketFactory类</h4>
                  <div>
                     <p></p>
                     <p>摘要<code class="codeph">javax.net.SocketFactory</code>类用于创建套接字。此类的子类是创建套接字的特定子类的工厂，从而为添加公共套接字级功能提供了通用框架。例如，请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B">SSLSocketFactory和SSLServerSocketFactory类</a> 。
                     </p>
                     <p>摘要<code class="codeph">javax.net.ServerSocketFactory</code>类类似于<code class="codeph">SocketFactory</code>类，但专门用于创建服务器套接字。
                     </p>
                     <p>套接字工厂是捕获与正在构造的套接字相关的各种策略的简单方法，以不需要特殊配置请求套接字的代码的方式来生成此类套接字：</p>
                     <ul style="list-style-type:disc">
                        <li>由于工厂和套接字的多态性，仅通过传递不同类型的工厂，同一应用程序代码就可以使用不同类型的套接字。</li>
                        <li>工厂本身可以使用套接字构造中使用的参数进行自定义。例如，可以定制工厂以返回具有不同网络超时或已经配置的安全参数的套接字。</li>
                        <li>返回给应用程序的套接字可以是的子类。 <code class="codeph">java.net.Socket</code> （要么<code class="codeph">javax.net.ssl.SSLSocket</code> ），以便他们可以直接公开新的API，以实现诸如压缩，安全性，记录标记，统计信息收集或防火墙隧道之类的功能。
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B" name="GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B"></a><h4 id="JSSEC-GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B" class="sect4">SSLSocketFactory和SSLServerSocketFactory类</h4>
                  <div>
                     <p></p>
                     <p>的<code class="codeph">javax.net.ssl.SSLSocketFactory</code>类充当创建安全套接字的工厂。此类是的抽象子类<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/SocketFactory.html" target="_blank"><code class="codeph">javax.net.SocketFactory</code></a> 。
                     </p>
                     <p>安全套接字工厂封装了创建和初始配置安全套接字的详细信息。这包括身份验证密钥，对等证书验证，已启用的密码套件等。</p>
                     <p>的<code class="codeph">javax.net.ssl.SSLServerSocketFactory</code>类类似于<code class="codeph">SSLSocketFactory</code>类，但专门用于创建服务器套接字。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E" name="GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E"></a><h5 id="JSSEC-GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E" class="sect5">获取一个SSLSocketFactory</h5>
                     <div>
                        <p>以下方法可用于获取<code class="codeph">SSLSocketFactory</code> ：</p>
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>通过调用以下命令获取默认工厂<code class="codeph">SSLSocketFactory.getDefault()</code>静态方法。
                              </li>
                              <li>接收工厂作为API参数。也就是说，必须创建套接字但不关心套接字配置细节的代码可以包括带有<code class="codeph">SSLSocketFactory</code>客户端可以调用以指定哪个参数<code class="codeph">SSLSocketFactory</code>在创建套接字时使用（例如， <code class="codeph">javax.net.ssl.HttpsURLConnection</code> ）。
                              </li>
                              <li>构造一个具有特殊配置行为的新工厂。</li>
                           </ul>
                           <p>通常将默认工厂配置为仅支持服务器身份验证，以使默认工厂创建的套接字不会比普通TCP套接字泄漏更多有关客户端的信息。</p>
                           <p>许多创建和使用套接字的类不需要了解套接字创建行为的详细信息。通过作为参数传入的套接字工厂创建套接字是隔离套接字配置细节的一种好方法，并且可以提高创建和使用套接字的类的可重用性。</p>
                           <p>您可以通过实现自己的套接字工厂子类或使用另一个类作为套接字工厂的工厂来创建新的套接字工厂实例。这种类的一个例子是<code class="codeph">SSLContext</code> ，它与JSSE实现一起作为基于提供程序的配置类提供。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB" name="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB"></a><h4 id="JSSEC-GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB" class="sect4">SSLSocket和SSLServerSocket类</h4>
                  <div>
                     <p></p>
                     <p>的<code class="codeph">javax.net.ssl.SSLSocket</code>类是标准Java的子类<code class="codeph">java.net.Socket</code>类。它支持所有标准套接字方法，并添加了专用于安全套接字的方法。此类的实例封装了创建它们的<span class="apiname">SSLContext</span> 。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="javax.net.ssl。SSLContext类是用于实现安全套接字协议的引擎类。此类的实例充当SSLSocket，SSLServerSocket和SSLEngine的工厂。SSLContext对象保存在该上下文下创建的所有对象之间共享的所有状态信息。例如，会话状态由上下文提供的套接字工厂通过握手协议通过握手协议协商时与SSLContext关联。这些缓存的会话可以被在相同上下文下创建的其他套接字重用和共享。">SSLContext类</a> 。有一些API可控制套接字实例的安全套接字会话的创建，但是不会直接公开信任和密钥管理。
                     </p>
                     <p>的<code class="codeph">javax.net.ssl.SSLServerSocket</code>类类似于<code class="codeph">SSLSocket</code>类，但专门用于创建服务器套接字。
                     </p>
                     <p>为防止对等欺骗，您应始终验证提供给<code class="codeph">SSLSocket</code> 。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">密码套件选择和远程实体验证</a> 。
                     </p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB__GUID-1242F7C2-58EE-4389-BD47-8316EBD20B28">
                           <p class="notep1">注意：</p>由于SSL和TLS协议的复杂性，很难预测连接上的传入字节是握手数据还是应用程序数据，以及该数据如何影响当前连接状态（甚至导致进程阻塞）。在Oracle JSSE实现中， <code class="codeph">available()</code>方法获得的对象<code class="codeph">SSLSocket.getInputStream()</code>返回从SSL连接成功解密但尚未被应用程序读取的应用程序数据字节数的计数。
                        </div> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0" name="GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0"></a><h5 id="JSSEC-GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0" class="sect5">获取一个SSLSocket</h5>
                     <div>
                        <p>可以通过以下方式之一获取<span class="apiname">SSLSocket</span>实例：</p>
                        <ul>
                           <li><span>一个<span class="apiname">SSLSocket的</span>可通过的一个实例被创建<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocketFactory.html" target="_blank"><span class="apiname">的SSLSocketFactory</span></a>通过的那类的几个<span class="apiname">的createSocket</span>方法之一。</span></li>
                           <li><span>可以通过<span class="apiname">SSLServerSocket</span>类的<span class="apiname">accept</span>方法创建<span class="apiname">SSLSocket</span> 。</span></li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38" name="GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38"></a><h5 id="JSSEC-GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38" class="sect5">密码套件选择和远程实体验证</h5>
                     <div>
                        <p></p>
                        <p>SSL / TLS协议定义了一系列特定步骤来确保连接<span class="italic">受到保护</span> 。但是，密码套件的选择直接影响连接享有的安全性类型。例如，如果选择了匿名密码套件，则应用程序将无法验证远程对等方的身份。如果选择了不加密的套件，则无法保护数据的隐私。此外，SSL / TLS协议未指定接收到的凭据必须与预期对等方发送的凭据匹配。如果以某种方式将连接重定向到流氓对等方，但是基于当前信任材料，流氓的凭据是可接受的，则该连接将被视为有效。
                        </p>
                        <p>使用生料时<code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code>类，您应该始终在发送任何数据之前检查对等方的凭据。的<code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code>类不会自动验证URL中的主机名是否与对等方凭据中的主机名匹配。如果未验证主机名，则可以通过URL欺骗利用应用程序。从JDK 7开始，可以在SSL / TLS握手期间处理端点标识/验证过程。请参见<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a>方法。
                        </p>
                        <p>诸如HTTPS（ <a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP over TLS</a> ）之类的协议确实需要主机名验证。从JDK 7开始，默认情况下在<span class="apiname">HttpsURLConnection</span>握手期间强制实施HTTPS端点标识。请参见<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a>方法。或者，应用程序可以使用<span class="apiname">HostnameVerifier</span>接口覆盖默认的HTTPS主机名规则。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587">HostnameVerifier接口</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" title="javax.net.ssl。HttpsURLConnection类扩展了java.net。HttpURLConnection类，并添加了对HTTPS特定功能的支持。">HttpsURLConnection类</a> 。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB" name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB"></a><h4 id="JSSEC-GUID-8796681D-06C8-4884-ADE4-782394F6F6FB" class="sect4">SSLEngine类</h4>
                  <div>
                     <p></p>
                     <p>TLS / DTLS变得越来越流行。它被广泛用于各种计算平台和设备中的各种应用程序。随着这种流行，随之而来的是要求将TLS / DTLS与不同的I / O和线程模型一起使用，以满足应用程序的性能，可伸缩性，占用空间和其他要求。要求将TLS / DTLS与阻塞和非阻塞I / O通道，异步I / O，任意输入和输出流以及字节缓冲区一起使用。需要在高度可扩展的，对性能至关重要的环境中使用它，这需要管理数千个网络连接。</p>
                     <p>使用以下命令抽象I / O传输机制<code class="codeph">SSLEngine</code> Java SE中的class允许应用程序以与传输无关的方式使用TLS / DTLS协议，从而使应用程序开发人员可以自由选择最能满足其需求的传输和计算模型。这种抽象不仅允许应用程序使用非阻塞I / O通道和其他I / O模型，而且还可以容纳不同的线程模型。这有效地将I / O和线程决策留给了应用程序开发人员。由于这种灵活性，应用程序开发人员必须管理I / O和线程（本身具有复杂的主题），并且对TLS / DTLS协议有所了解。因此，抽象是高级API：初学者应使用<code class="codeph">SSLSocket</code> 。
                     </p>
                     <p>其他Java编程语言API（例如Java通用安全服务（Java GSS-API）和Java简单身份验证安全层（Java SASL））的用户将注意到相似之处，因为该应用程序还负责传输数据。</p>
                     <p>核心类是<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><span class="apiname">javax.net.ssl。SSLEngine</span></a> 。它封装了TLS / DTLS状态机，并在由用户的用户提供的入站和出站字节缓冲区上进行操作。 <code class="codeph">SSLEngine</code>类。<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">图8-2</a>说明了应用程序中的数据流向<code class="codeph">SSLEngine</code> ，到运输机制，再返回。
                     </p>
                     <div class="figure" id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">
                        <p class="titleinfigure">图8-2通过SSLEngine的数据流</p><img src="img/sslengine_jsse.png" alt="以下文字描述了该图。" title="以下文字描述了该图。"></div>
                     <!-- class="figure" -->
                     <p>左侧显示的应用程序在应用程序缓冲区中提供应用程序（纯文本）数据，并将其传递给<span class="apiname">SSLEngine</span> 。<span class="apiname">SSLEngine</span>对象处理缓冲区中包含的数据或任何握手数据，以生成TLS / DTLS编码的数据并将其放置到应用程序提供的网络缓冲区中。然后，应用程序负责使用适当的传输方式（如右图所示）将网络缓冲区的内容发送到其对等方。在从其对等方（通过传输）接收到TLS / DTLS编码数据后，应用程序将数据放入网络缓冲区，并将其传递给<span class="apiname">SSLEngine</span> 。<span class="apiname">SSLEngine</span>对象处理网络缓冲区的内容以生成握手数据或应用程序数据。
                     </p>
                     <p>的实例<code class="codeph">SSLEngine</code>类可以处于以下状态之一：</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-B02D18CC-ADD5-44A5-805E-25CD2998855B"><!-- --></a>创建</dt>
                        <dd>的<code class="codeph">SSLEngine</code>已创建并初始化，但尚未使用。在此阶段，应用程序可以设置<code class="codeph">SSLEngine</code>特定的设置（启用的密码套件，无论<code class="codeph">SSLEngine</code>应该在客户端或服务器模式下握手，依此类推）。但是，一旦握手开始，所有新设置（客户端/服务器模式除外）将用于下一次握手。
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-0F78430D-0144-4BFE-8E16-6DE2FAD40A64"><!-- --></a>初始握手</dt>
                        <dd>初始握手是两个对等方交换通信参数直到<code class="codeph">SSLSession</code>成立。在此阶段无法发送应用程序数据。
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-4FFB7915-D7CE-49E5-9E71-0C542A09854A"><!-- --></a>申请数据</dt>
                        <dd>建立通信参数并完成握手后，应用程序数据可以流经<code class="codeph">SSLEngine</code> 。出站应用程序消息经过加密和完整性保护，而入站消息则逆转该过程。
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-21E779D2-2FBB-46D2-9275-E742012D20DB"><!-- --></a>重新握手</dt>
                        <dd>在应用程序数据阶段，任何一方都可以随时请求重新协商会话。新的握手数据可以在应用程序数据之间混合。在开始重新握手阶段之前，应用程序可能会重置TLS / DTLS通信参数，例如启用的密码套件列表以及是否使用客户端身份验证，但不能在客户端/服务器模式之间进行更改。和以前一样，握手开始后， <code class="codeph">SSLEngine</code>在下一次握手之前，不会使用配置设置。
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-5FBA1A16-3A76-416F-A4F9-3271D9F2E45D"><!-- --></a>关闭</dt>
                        <dd>当不再需要连接时，应用程序应关闭<code class="codeph">SSLEngine</code>并且应在关闭基础传输机制之前将所有剩余的消息发送/接收给对等方。引擎一旦关闭，便无法重复使用： <code class="codeph">SSLEngine</code>必须创建。
                        </dd>
                     </dl>
                  </div>
                  <div class="sect4"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744"></a><h5 id="JSSEC-GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" class="sect5">了解SSLEngine操作状态</h5>
                     <div>
                        <p>SSLEngine的状态表示为<code class="codeph">SSLEngineResult.Status</code> 。
                        </p>
                        <div class="section">
                           <p>为了表明引擎的状态以及应用程序应采取的措施， <code class="codeph">SSLEngine.wrap()</code>和<code class="codeph">SSLEngine.unwrap()</code>方法返回一个<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngineResult.html" target="_blank"><code class="codeph">SSLEngineResult</code></a>实例，如<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">示例8-5</a>所示。这个<code class="codeph">SSLEngineResult</code>对象包含两条状态信息：引擎的总体状态和握手状态。
                           </p>
                           <p>可能的总体状态由<code class="codeph">SSLEngineResult.Status</code>枚举。以下状态可用：</p>
                           <dl>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-F79D56D5-8F54-4E4E-ACFB-4BEF8B9B9E7D">
                                    <!-- --></a><code class="codeph">OK</code></dt>
                              <dd>没有错误。</dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-55BEDBCE-8E29-45B8-98D1-9E6929540C3D">
                                    <!-- --></a><code class="codeph">CLOSED</code></dt>
                              <dd>该行动关闭了<code class="codeph">SSLEngine</code>或由于已关闭操作而无法完成操作。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C5AE7AA6-7EA1-447A-B443-6895062E1F87">
                                    <!-- --></a><code class="codeph">BUFFER_UNDERFLOW</code></dt>
                              <dd>输入缓冲区的数据不足，表明应用程序必须从对等方获取更多数据（例如，通过从网络读取更多数据）。</dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-B67FEDA3-B9B6-4730-9C49-9D3D60E3255C">
                                    <!-- --></a><code class="codeph">BUFFER_OVERFLOW</code></dt>
                              <dd>输出缓冲区空间不足，无法保存结果，表明应用程序必须清除或扩大目标缓冲区。</dd>
                           </dl>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">例8-1</a>说明了如何处理<code class="codeph">BUFFER_UNDERFLOW</code>和<code class="codeph">BUFFER_OVERFLOW</code>的状态<code class="codeph">SSLEngine.unwrap()</code>方法。它用<code class="codeph">SSLSession.getApplicationBufferSize()</code>和<code class="codeph">SSLSession.getPacketBufferSize()</code>确定要使字节缓冲区多大。
                           </p>
                           <p>可能的握手状态由<code class="codeph">SSLEngineResult.HandshakeStatus</code>枚举。它们表示握手是否已完成，呼叫者是否必须从对等方获取更多的握手数据或向对等方发送更多的握手数据，等等。以下握手状态可用：</p>
                           <dl>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-6738EEFA-1FE5-48B8-9E03-B99B688FD77F">
                                    <!-- --></a><code class="codeph">FINISHED</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>刚刚完成握手。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-29199762-DA07-4595-B35D-A0271A229020">
                                    <!-- --></a><code class="codeph">NEED_TASK</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>在握手可以继续之前，需要一个（或多个）委派任务的结果。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-DEFA0BD8-5FC5-41E8-AEB4-82542DDDF7CA">
                                    <!-- --></a><code class="codeph">NEED_UNWRAP</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>需要从远程端接收数据，然后握手才能继续。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C4CCD4B8-357E-4F8B-95E2-89B2A255D9E3">
                                    <!-- --></a><code class="codeph">NEED_UNWRAP_AGAIN</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>需要先打开包装，然后握手才能继续。该值表示尚未从远端接收尚未解释的数据，不需要再次接收。数据已被引入JSSE框架，但尚未处理。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-2FCB0DC1-F723-4036-B8DA-0A885ECA17E7">
                                    <!-- --></a><code class="codeph">NEED_WRAP</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>必须先将数据发送到远程端，然后才能继续握手，因此应调用<span class="apiname">SSLEngine.wrap（）</span> 。
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-215B8B63-813A-4B80-98DE-3C16A0F2926A">
                                    <!-- --></a><code class="codeph">NOT_HANDSHAKING</code></dt>
                              <dd>的<code class="codeph">SSLEngine</code>目前尚未握手。
                              </dd>
                           </dl>
                           <p>每个结果具有两种状态， <span class="apiname">SSLEngine</span>可以指示应用程序必须采取两项措施：一项响应握手，另一项代表总体状态。 <code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code>方法。例如，引擎可能会由于<code class="codeph">SSLEngine.unwrap()</code>打电话回来<code class="codeph">SSLEngineResult.Status.OK</code>指示输入数据已成功处理，并且<code class="codeph">SSLEngineResult.HandshakeStatus.NEED_UNWRAP</code>指示应用程序应从对等方获取更多TLS / DTLS编码的数据并将其提供给<code class="codeph">SSLEngine.unwrap()</code>再次，以便握手可以继续。如您所见，先前的示例已大大简化；他们将需要大大扩展以正确处理所有这些状态。
                           </p>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">例8-3</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">例8-2</a>说明了如何通过检查握手状态和操作的整体状态来处理握手数据。 <code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">
                           <p class="titleinexample">示例8-1处理BUFFER_UNDERFLOW和BUFFER_OVERFLOW的示例代码</p>
                           <p>以下代码示例说明了如何处理BUFFER_UNDERFLOW和BUFFER_OVERFLOW状态：</p><pre class="codeblock"><code>    SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
    switch (res.getStatus()) {

    case BUFFER_OVERFLOW:
            // Maybe need to enlarge the peer application data buffer.
        if (engine.getSession().getApplicationBufferSize() &gt; peerAppData.capacity()) {
            // enlarge the peer application data buffer
        } else {
            // compact or clear the buffer
        }
        // retry the operation
    break;

    case BUFFER_UNDERFLOW:
        // Maybe need to enlarge the peer network packet buffer
        if (engine.getSession().getPacketBufferSize() &gt; peerNetData.capacity()) {
        // enlarge the peer network packet buffer
        } else {
        // compact or clear the buffer
        }
        // obtain more inbound network data and then retry the operation
       break;

       // Handle other status: CLOSED, OK
       // ...
    }
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">
                           <p class="titleinexample">示例8-2用于检查和处理握手状态和总体状态的示例代码</p>
                           <p>以下代码示例说明了如何通过检查握手状态以及<span class="apiname">wrap（）</span>和<span class="apiname">unwrap（）</span>方法的整体状态来处理握手数据：</p><pre class="codeblock"><code>void doHandshake(SocketChannel socketChannel, SSLEngine engine,
    ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

    // Create byte buffers to use for holding application data
    int appBufferSize = engine.getSession().getApplicationBufferSize();
    ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
    ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

    // Begin handshake
    engine.beginHandshake();
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

    // Process handshaking message
    while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
        hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

        switch (hs) {

        case NEED_UNWRAP:
            // Receive handshaking data from peer
            if (socketChannel.read(peerNetData) &lt; 0) {
                // The channel has reached end-of-stream
            }

            // Process incoming handshaking data
            peerNetData.flip();
            SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                // Handle OK status
                break;

            // Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_WRAP :
            // Empty the local network packet buffer.
            myNetData.clear();

            // Generate handshaking data
            res = engine.wrap(myAppData, myNetData);
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                myNetData.flip();

                // Send the handshaking data to peer
                while (myNetData.hasRemaining()) {
                    socketChannel.write(myNetData);
                }
                break;

            // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_TASK :
            // Handle blocking tasks
            break;

            // Handle other status:  // FINISHED or NOT_HANDSHAKING
            // ...
        }
    }

    // Processes after handshaking
    // ...
}
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">
                           <p class="titleinexample">示例8-3处理DTLS握手状态和总体状态的示例代码</p>
                           <p>下面的代码示例说明了如何处理DTLS握手状态：</p><pre class="pre codeblock"><code>void handshake(SSLEngine engine, DatagramSocket socket,
               SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets =
                        onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // the client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            }   // otherwise, SSLEngineResult.Status.OK:
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            List &lt;DatagramPacket&gt; packets =
                // Call a function to produce handshake packets
                produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange.
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-58F4882A-4BBD-4291-8322-2DC7E300974D" name="GUID-58F4882A-4BBD-4291-8322-2DC7E300974D"></a><h5 id="JSSEC-GUID-58F4882A-4BBD-4291-8322-2DC7E300974D" class="sect5">TLS协议的SSLEngine</h5>
                     <p>本节介绍如何创建<span class="apiname">SSLEngine</span>对象以及如何使用它生成和处理TLS数据。
                     </p>
                     <div class="sect5"><a id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" name="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7"></a><h6 id="JSSEC-GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" class="sect6">创建一个SSLEngine对象</h6>
                        <div>
                           <p>使用<code class="codeph">SSLContext.createSSLEngine()</code>创建一个方法<code class="codeph">SSLEngine</code>宾语。
                           </p>
                           <div class="section">
                              <p>在您创建一个<code class="codeph">SSLEngine</code>对象，您必须将引擎配置为充当客户端或服务器，并设置其他配置参数，例如要使用的密码套件以及是否需要客户端身份验证。的<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#createSSLEngine--" target="_blank"><code class="codeph">SSLContext.createSSLEngine</code></a>方法创建一个<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a>宾语。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">
                              <p class="titleinexample">示例8-4用于为使用JKS作为密钥库的TLS创建SSLEngine客户端的示例代码</p>
                              <p>以下示例代码为使用JKS作为密钥库的TLS创建<span class="apiname">SSLEngine</span>客户端。
                              </p>
                              <div class="infoboxnote" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__GUID-E7142213-957C-4DEB-8C5D-CD8BE3E5A286">
                                 <p class="notep1">注意：</p>在此示例中，服务器名称和端口号未用于与服务器通信（所有传输均由应用程序负责）。它们是JSSE提供程序用于TLS会话缓存的提示。
                              </div><pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("JKS");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("JKS");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for TLS protocols
    sslContext = SSLContext.getInstance("TLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use as client
    engine.setUseClientMode(true);
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" name="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4"></a><h6 id="JSSEC-GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" class="sect6">生成和处理TLS数据</h6>
                        <div>
                           <p>两个主要<code class="codeph">SSLEngine</code>方法是<code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code> 。它们分别负责生成和使用网络数据。取决于状态<code class="codeph">SSLEngine</code>对象，此数据可能是握手数据或应用程序数据。
                           </p>
                           <div class="section">
                              <p>每<code class="codeph">SSLEngine</code>对象在其生命周期中具有多个阶段。在可以发送或接收应用程序数据之前，TLS协议需要握手以建立密码参数。此握手过程需要通过一系列的来回操作<code class="codeph">SSLEngine</code>宾语。
                              </p>
                              <p>在最初的握手过程中， <code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code>方法生成和使用握手数据，并且应用程序负责传输数据。的<code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code>重复此方法序列，直到握手完成为止。每<code class="codeph">SSLEngine</code>操作生成一个实例<code class="codeph">SSLEngineResult</code>类，其中<code class="codeph">SSLEngineResult.HandshakeStatus</code>字段用于确定下一步必须执行什么操作才能移动握手。
                              </p>
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">图8-3</a>显示了典型的TLS握手期间的状态机，以及相应的消息和状态：</p>
                              <div class="figure" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">
                                 <p class="titleinfigure">图8-3 TLS握手期间的状态机</p><img src="img/ssl-tls-handshake.png" alt="如下图8-3所示" title="如下图8-3所示" longdesc="img_text/ssl-tls-handshake.html"><br><a href="img_text/ssl-tls-handshake.html">“图8-3 TLS握手期间的状态机”的描述</a></div>
                              <!-- class="figure" -->
                              <p>握手完成后，请进一步致电<code class="codeph">wrap()</code>将尝试使用应用程序数据并将其打包以进行传输。的<code class="codeph">unwrap()</code>方法将尝试相反的操作。
                              </p>
                              <p>为了将数据发送到对等方，应用程序首先提供它要通过其发送的数据<code class="codeph">SSLEngine.wrap()</code>获得相应的TLS编码数据。然后，应用程序使用其选择的传输机制将编码后的数据发送给对等方。当应用程序通过传输机制从对等方接收到TLS编码的数据时，它会将这些数据提供给<code class="codeph">SSLEngine</code>通过<code class="codeph">SSLEngine.unwrap()</code>获取对端发送的明文数据。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">
                              <p class="titleinexample">示例8-5用于创建无阻塞SocketChannel的示例代码</p>
                              <p>以下示例是使用非阻塞的SSL应用程序<code class="codeph">SocketChannel</code>与同行交流。它将字符串“ hello”发送给对等方，方法是使用<code class="codeph">SSLEngine</code>在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">例8-4中</a>创建。它使用来自<code class="codeph">SSLSession</code>确定要使字节缓冲区多大。
                              </p>
                              <div class="infoboxnote" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-6DE5C28C-B4CD-438F-9A68-33BB5C3E2E94">
                                 <p class="notep1">注意：</p>使用以下命令可以使该示例更健壮和可扩展。 <code class="codeph">Selector</code>与非阻塞<code class="codeph">SocketChannel</code> 。
                              </div><pre class="codeblock"><code>
    // Create a nonblocking socket channel
    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.configureBlocking(false);
    socketChannel.connect(new InetSocketAddress(hostname, port));

    // Complete connection
    while (!socketChannel.finishedConnect()) {
    // do something until connect completed
    }

    //Create byte buffers for holding application and encoded data

    SSLSession session = engine.getSession();
    ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
    ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

    // Do initial handshake
    doHandshake(socketChannel, engine, myNetData, peerNetData);

    myAppData.put("hello".getBytes());
    myAppData.flip();

    while (myAppData.hasRemaining()) {
    // Generate TLS/DTLS encoded data (handshake or application data)
    SSLEngineResult res = engine.wrap(myAppData, myNetData);

    // Process status of call
    if (res.getStatus() == SSLEngineResult.Status.OK) {
        myAppData.compact();

        // Send TLS/DTLS encoded data to peer
        while(myNetData.hasRemaining()) {
            int num = socketChannel.write(myNetData);
            if (num == 0) {
                // no bytes written; try again later
            }
        }
    }

    // Handle other status:  BUFFER_OVERFLOW, CLOSED
    ...
    }</code></pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-FDF2BEE0-D9F4-4653-BD90-4167FEB96C45">
                              <p class="titleinexample">示例8-6用于从无阻塞SocketChannel读取数据的示例代码</p>以下示例代码说明了如何从相同的非阻塞中读取数据<code class="codeph">SocketChannel</code>并通过使用提取明文数据<code class="codeph">SSLEngine</code>在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">例8-4中</a>创建。此代码的每次迭代可能会生成明文数据，也可能不会生成明文数据，具体取决于握手是否正在进行。<pre class="codeblock"><code>
    // Read TLS/DTLS encoded data from peer
    int num = socketChannel.read(peerNetData);
    if (num == -1) {
        // The channel has reached end-of-stream
    } else if (num == 0) {
        // No bytes read; try again ...
    } else {
        // Process incoming data
        peerNetData.flip();
        res = engine.unwrap(peerNetData, peerAppData);

        if (res.getStatus() == SSLEngineResult.Status.OK) {
            peerNetData.compact();

        if (peerAppData.hasRemaining()) {
            // Use peerAppData
        }
    }
    // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
    ...
    }
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9C55936B-376F-4B49-8018-216856F2C695" name="GUID-9C55936B-376F-4B49-8018-216856F2C695"></a><h5 id="JSSEC-GUID-9C55936B-376F-4B49-8018-216856F2C695" class="sect5">用于DTLS协议的SSLEngine</h5>
                     <p>本节说明如何创建<span class="apiname">SSLEngine</span>对象，并使用它来处理DTLS握手，生成和处理DTLS数据以及处理DTLS连接中的重传。
                     </p>
                     <div class="sect5"><a id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF" name="GUID-4D854666-433A-4672-B902-565CC7AEE0BF"></a><h6 id="JSSEC-GUID-4D854666-433A-4672-B902-565CC7AEE0BF" class="sect6">为DTLS创建SSLEngine对象</h6>
                        <div>
                           <p>以下示例说明了如何创建<code class="codeph">SSLEngine</code> DTLS的对象。</p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__GUID-4E9C2C41-E06E-4412-A9C8-20DBFA93CC0B">
                                 <p class="notep1">注意：</p>服务器名称和端口号不用于与服务器通信（所有传输均由应用程序负责）。它们是向JSSE提供程序的提示，用于DTLS会话缓存，以及用于基于Kerberos的密码套件实现的以确定要获取的服务器凭据。
                              </div> 
                           </div>
                           <div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FCB3A">
                              <p class="titleinexample">示例8-7用于使用PKCS12作为密钥库为DTLS创建SSLEngine客户端的示例代码</p>
                              <p>以下示例代码为使用PKCS12作为密钥库的DTLS创建<span class="apiname">SSLEngine</span>客户端：</p><pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for DTLS protocols
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use engine as client
    engine.setUseClientMode(true);
</code></pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FC3CE">
                              <p class="titleinexample">示例8-8用于使用PKCS12作为密钥库为DTLS创建SSLEngine服务器的示例代码</p>以下示例代码为使用PKCS12作为密钥库的DTLS创建<span class="apiname">SSLEngine</span>服务器：<pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an SSLContext for DTLS Protocol without authentication
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(null, null, null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLeEngine(hostname, port);

    // Use the engine as server
    engine.setUseClientMode(false);

    // Require client authentication
    engine.setNeedClientAuth(true);</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45" name="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45"></a><h6 id="JSSEC-GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45" class="sect6">生成和处理DTLS数据</h6>
                        <div>
                           <p></p>
                           <p>DTLS握手和TLS握手类似地生成和处理数据。（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" title="SSLEngine的两个主要方法是wrap（）和unwrap（）。它们分别负责生成和使用网络数据。根据SSLEngine对象的状态，此数据可能是握手数据或应用程序数据。">生成和处理TLS数据</a> 。）它们都使用<span class="apiname">SSLEngine.wrap（）</span>和<span class="apiname">SSLEngine.wrap（）</span>方法分别生成和使用网络数据。
                           </p>
                           <p>下图显示了典型的DTLS握手期间的状态机，以及相应的消息和状态：</p>
                           <div class="figure" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-85F0E791-66C0-479B-855B-86509CE249FE">
                              <p class="titleinfigure">图8-4 DTLS握手期间的状态机</p><img src="img/jsse-handshake-state-machine-new.png" alt="如下图8-4所示" title="如下图8-4所示" longdesc="img_text/jsse-handshake-state-machine-new.html"><br><a href="img_text/jsse-handshake-state-machine-new.html">“图8-4 DTLS握手期间的状态机”的描述</a></div>
                           <!-- class="figure" -->
                           <div class="example" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-E31F4DB7-7133-414A-A7A8-4AECA3A8A5CA">
                              <p class="titleinexample">示例8-9用于处理DTLS握手状态和总体状态的示例代码</p>
                              <p>此示例演示如何处理DTLS握手状态（来自<span class="apiname">SSLEngine.getHandshakeStatus</span>方法）和总体状态（来自<span class="apiname">SSLEngineResult.getStatus</span>方法）。
                              </p><pre class="pre codeblock"><code>void handshake(SSLEngine engine, DatagramSocket socket, SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // Receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // Retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets = onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // The client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // Bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // Otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            } // Otherwise, SSLEngineResult.Status.OK
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            // Call a function to produce handshake packets
            List &lt;DatagramPacket&gt; packets = produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}</code></pre></div>
                           <!-- class="example" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-67A89488-A98D-4B4D-AA48-340CECECC0F5">TLS和DTLS SSLEngine.wrap（）方法之间的区别</p>
                              <div class="p">的<code class="codeph">SSLEngine.wrap()</code> DTLS的方法不同于TLS，如下所示：<ul style="list-style-type:disc">
                                    <li>
                                       <p>在TLS实施中<code class="codeph">SSLEngine</code> ，输出缓冲区<code class="codeph">SSLEngine.wrap()</code>包含一个或多个TLS记录（由于TLSv1 BEAST密码块链接漏洞）。
                                       </p>
                                    </li>
                                    <li>
                                       <p>在DTLS实现中<code class="codeph">SSLEngine</code> ，输出缓冲区<code class="codeph">SSLEngine.wrap()</code>最多包含一个记录，因此每个DTLS记录都可以进行封送处理并分别传递到数据报层。
                                       </p>
                                    </li>
                                 </ul>
                                 <div class="infoboxnote" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-52C4A89B-A524-44E5-9626-136B0C65EB0C">
                                    <p class="notep1">注意：</p>每条记录由<code class="codeph">SSLEngine.wrap()</code>应符合以下规定的最大数据包大小限制<code class="codeph">SSLParameters.getMaximumPacketSize()</code> 。
                                 </div>  
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" name="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7"></a><h6 id="JSSEC-GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" class="sect6">处理DTLS连接中的重传</h6>
                        <div>
                           <p>在通过可靠连接的SSL / TLS中，可以确保数据以正确的顺序到达，并且不需要重新传输。但是，对于经常在不可靠媒体上工作的DTLS，必须重新传输丢失或延迟的握手消息。</p>
                           <div class="section">
                              <p>的<code class="codeph">SSLEngine</code>类以完全与传输无关的方式运行，并且应用程序层执行所有I / O。因为<code class="codeph">SSLEngine</code>类不负责I / O，而是由应用程序负责提供计时器并发信号通知<code class="codeph">SSLEngine</code>需要重传时的class。应用程序层必须确定正确的超时值以及何时触发超时事件。在握手过程中，如果<code class="codeph">SSLEngine</code>对象在<code class="codeph">HandshakeStatus.NEED_UNWRAP</code>状态，对<span class="apiname">SSLEngine.wrap（）</span>的调用意味着先前的数据包丢失了，必须重新传输。在这种情况下，DTLS实现<code class="codeph">SSLEngine</code>类负责在必要时再次包装以前的必要握手消息。
                              </p>
                              <div class="infoboxnote" id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7__GUID-3AC8121B-28CE-4611-8E66-06E9CEC39B5E">
                                 <p class="notep1">注意：</p>在DTLS引擎中，仅握手消息必须正确交换。应用程序数据可以处理数据包丢失，而无需计时器。
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div class="sect6"><a id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3" name="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3"></a><h6 id="JSSEC-GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3" class="sect6">在应用程序中处理重传</h6>
                           <div>
                              <p><code class="codeph">SSLEngine.unwrap()</code>和<code class="codeph">SSLEngine.wrap()</code>可以一起用于处理应用程序中的重传。
                              </p>
                              <div class="section">
                                 <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">图8-5</a>显示了处理DTLS握手重传的典型方案：</p>
                                 <div class="figure" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">
                                    <p class="titleinfigure">图8-5 DTLS握手重传状态流程</p><img src="img/state-flow-need_unwrap_again_new.png" alt="此图像说明了DTLS握手重传状态流。在图像后面的编号步骤中描述了流程。" title="此图像说明了DTLS握手重传状态流。在图像后面的编号步骤中描述了流程。"></div>
                                 <!-- class="figure" -->
                              </div>
                              <!-- class="section" -->
                              <ol>
                                 <li class="stepexpand"><span>创建并初始化DTLS的实例<code class="codeph">SSLEngine</code> 。</span><div>请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="使用SSLContext.createSSLEngine（）方法创建一个SSLEngine对象。">创建SSLEngine对象</a> 。DTLS握手过程开始。
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>如果握手状态为<code class="codeph">HandshakeStatus.NEED_UNWRAP</code> ，等待来自网络的数据。</span></li>
                                 <li class="stepexpand"><span>如果计时器超时，则表明先前传递的握手消息可能已丢失。</span><div>
                                       <div class="infoboxnote" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-39A9DD22-1E2F-4924-8960-9DCAF232DE86">
                                          <p class="notep1">注意：</p>在DTLS握手重传中，确定的握手状态不一定<code class="codeph">HandshakeStatus.NEED_WRAP</code>打电话给<code class="codeph">SSLEngine.wrap()</code> 。
                                       </div>
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>呼叫<code class="codeph">SSLEngine.wrap()</code> 。</span></li>
                                 <li class="stepexpand"><span>包装的数据包已交付。</span></li>
                              </ol>
                           </div>
                        </div>
                        <div class="sect6"><a id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381" name="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381"></a><h6 id="JSSEC-GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381" class="sect6">在应用程序中处理缓冲的握手消息</h6>
                           <div>
                              <p>数据报传输不需要或不提供可靠或有序的数据传递。握手消息可能会丢失或需要重新排序。在DTLS实现中，可能需要先缓冲握手消息以备将来处理，然后再接收所有先前的消息。</p>
                              <div class="section">
                                 <p>DTLS的实现<code class="codeph">SSLEngine</code>负责对握手消息进行重新排序。握手消息的缓冲和重新排序对应用程序是透明的。
                                 </p>
                                 <p>但是，应用程序必须管理<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>状态。此状态表明，对于下一个<span class="apiname">SSLEngine.unwrap（）</span>操作，不需要来自远程端的其他数据。
                                 </p>
                                 <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">图8-6</a>显示了使用<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> 。
                                 </p>
                                 <div class="figure" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">
                                    <p class="titleinfigure">图8-6具有NEED_UNWRAP_AGAIN的DTLS缓冲握手的状态机</p><img src="img/dtls-buffered-handshake-message-new.png" alt="此流程图说明了在DTLS缓冲握手中交换的消息序列。仅在某些情况下发送的消息被标记为可选。该序列在图像后面的编号列表中进行了描述。" title="此流程图说明了在DTLS缓冲握手中交换的消息序列。仅在某些情况下发送的消息被标记为可选。该序列在图像后面的编号列表中进行了描述。"></div>
                                 <!-- class="figure" -->
                              </div>
                              <!-- class="section" -->
                              <ol>
                                 <li class="stepexpand"><span>创建并初始化DTLS的实例<code class="codeph">SSLEngine</code> 。</span><div>请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="使用SSLContext.createSSLEngine（）方法创建一个SSLEngine对象。">创建SSLEngine对象</a> 。
                                    </div>
                                 </li>
                                 <li class="stepexpand"><strong>可选：</strong> <span>如果握手状态为<code class="codeph">HandshakeStatus.NEED_UNWRAP</code> ，等待来自网络的数据。</span></li>
                                 <li class="stepexpand"><strong>可选：</strong> <span>如果收到网络数据，请调用<span class="apiname">SSLEngine.unwrap（）</span> 。</span></li>
                                 <li class="stepexpand"><span>确定握手状态以进行下一步处理。握手状态可以是<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> ， <code class="codeph">HandshakeStatus.NEED_UNWRAP</code> ， 要么<code class="codeph">HandshakeStatus.NEED_WRAP</code> 。</span><ul>
                                       <li>如果握手状态为<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> ，请调用<span class="apiname">SSLEngine.unwrap（）</span> 。
                                       </li>
                                    </ul>
                                    <div>
                                       <div class="infoboxnote" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-4201EFCD-11F7-4175-A530-80F779E79E05">
                                          <p class="notep1">注意：</p>对于<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>状态，对于<span class="apiname">SSLEngine.unwrap（）</span>操作，不需要来自网络的其他数据。
                                       </div>
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>确定握手状态以进行进一步处理。握手状态可以是<code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> ， <code class="codeph">HandshakeStatus.NEED_UNWRAP</code> ， 要么<code class="codeph">HandshakeStatus.NEED_WRAP</code> 。</span></li>
                              </ol>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7ED13982-53B2-455B-9198-3289F19905B6" name="GUID-7ED13982-53B2-455B-9198-3289F19905B6"></a><h5 id="JSSEC-GUID-7ED13982-53B2-455B-9198-3289F19905B6" class="sect5">处理阻止任务</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>在握手期间， <code class="codeph">SSLEngine</code>可能会遇到可能会阻塞或花费很长时间的任务。例如，一个<code class="codeph">TrustManager</code>可能需要连接到远程证书验证服务，或者<code class="codeph">KeyManager</code>可能需要提示用户确定将哪个证书用作客户端身份验证的一部分。保持...的非阻塞性<code class="codeph">SSLEngine</code> ，当引擎遇到此类任务时，它将返回<code class="codeph">SSLEngineResult.HandshakeStatus.NEED_TASK</code> 。收到此状态后，应用程序应调用<code class="codeph">SSLEngine.getDelegatedTask()</code>获取任务，然后使用适合其要求的线程模型来处理任务。例如，应用程序可能从线程池中获取线程来处理任务，而主线程则处理其他I / O。</p>
                           <p>以下代码在新创建的线程中执行每个任务：</p><pre class="codeblock"><code>if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
    Runnable task;
    while ((task = engine.getDelegatedTask()) != null) {
        new Thread(task).start();
    }
}
</code></pre><p>的<code class="codeph">SSLEngine</code>会阻止未来<code class="codeph">wrap()</code>和<code class="codeph">unwrap()</code>调用，直到所有未完成的任务完成。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33" name="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33"></a><h5 id="JSSEC-GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33" class="sect5">关闭TLS / DTLS连接</h5>
                     <div>
                        <div class="section">
                           <p>为了有序地关闭TLS / DTLS连接，TLS / DTLS协议要求传输关闭消息。因此，当应用程序完成TLS / DTLS连接后，应首先从以下位置获取关闭消息： <code class="codeph">SSLEngine</code> ，然后使用其传输机制将其传输给对等方，最后关闭传输机制。<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">例8-10</a>对此进行了说明。
                           </p>
                           <p>除了应用程式明确关闭<code class="codeph">SSLEngine</code> ， <code class="codeph">SSLEngine</code>可能被对等方关闭（通过在处理握手数据时收到关闭消息），或被<code class="codeph">SSLEngine</code>在处理应用程序或握手数据时遇到错误，由抛出<code class="codeph">SSLException</code> 。在这种情况下，应用程序应调用<code class="codeph">SSLEngine.wrap()</code>获取关闭消息并将其发送给对等端，直到<code class="codeph">SSLEngine.isOutboundDone()</code>退货<code class="codeph">true</code> （如<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">示例8-10</a>所示），或直到<code class="codeph">SSLEngineResult.getStatus()</code>退货<code class="codeph">CLOSED</code> 。
                           </p>
                           <p>除了顺序关闭之外，在交换关闭消息之前切断传输链接时，还可能会发生意外关闭。在前面的示例中，应用程序可能会<code class="codeph">-1</code>要么<code class="codeph">IOException</code>尝试从非阻塞读取<code class="codeph">SocketChannel</code> ，或得到<code class="codeph">IOException</code>尝试写入非阻塞时<code class="codeph">SocketChannel</code> 。输入数据结束时，应致电<code class="codeph">engine.closeInbound()</code> ，这将通过<code class="codeph">SSLEngine</code>从TLS / DTLS角度来看，远程对等方已完全关闭。然后，应用程序仍应尝试使用<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">示例8-10中</a>的过程彻底关闭它。显然，不像<code class="codeph">SSLSocket</code> ，应用程序使用<code class="codeph">SSLEngine</code>必须处理更多的状态转换，状态和编程。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">说明使用SSLEngine的示例代码</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">
                           <p class="titleinexample">示例8-10用于关闭SSL / TLS / DTLS连接的示例代码</p>
                           <p>以下代码示例说明了如何关闭TLS / DTLS连接：</p><pre class="codeblock"><code>// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
    // Get close message
    SSLEngineResult res = engine.wrap(empty, myNetData);

    // Check res statuses

    // Send close message to peer
    while(myNetData.hasRemaining()) {
        int num = socketChannel.write(myNetData);
        if (num == 0) {
            // no bytes written; try again later
        }
        myNetData().compact();
    }
}

// Close transport
socketChannel.close();
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" name="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B"></a><h4 id="JSSEC-GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" class="sect4">SSLSession和ExtendedSSLSession</h4>
                  <div>
                     <p>的<code class="codeph">javax.net.ssl.SSLSession</code>接口表示一个服务器的两个对等方之间协商的安全上下文<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>连接。安排会议后，以后可以共享<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>连接在相同两个对等点之间的对象。
                     </p>
                     <div class="section">
                        <p>在某些情况下，握手过程中稍后需要在握手过程中协商的参数来做出有关信任的决策。例如，有效签名算法的列表可能会限制可用于身份验证的证书类型。的<code class="codeph">SSLSession</code>可以<span class="italic">在</span>握手<span class="italic">过程</span>中通过调用<code class="codeph">getHandshakeSession()</code>在<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code> 。的实现<code class="codeph">TrustManager</code>要么<code class="codeph">KeyManager</code>可以使用<code class="codeph">getHandshakeSession()</code>获取有关会话参数的信息的方法，以帮助他们做出决策。
                        </p>
                        <p>完全初始化<code class="codeph">SSLSession</code>包含将用于通过安全套接字进行通信的密码套件，以及有关远程对等方的网络地址的非权威性提示，以及管理信息（例如创建时间和最后使用时间）。会话还包含对等方之间协商的共享主密钥，该共享主密钥用于创建加密密钥，以加密和保证通过网络进行通信的完整性。 <code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>连接。此主密钥的值仅对基础安全套接字实现已知，而不会通过<code class="codeph">SSLSession</code> API。</p>
                        <p><code class="codeph">ExtendedSSLSession</code>扩展<code class="codeph">SSLSession</code>接口以支持其他会话属性。的<code class="codeph">ExtendedSSLSession</code>类添加描述本地实现和对等方支持的签名算法的方法。的<code class="codeph">getRequestedServerNames()</code>调用的方法<code class="codeph">ExtendedSSLSession</code>实例用于获取列表<code class="codeph">SNIServerName</code>所请求的<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）扩展中的对象</a> 。服务器应使用请求的服务器名称来指导其选择适当的身份验证证书和/或安全策略的其他方面。客户端应使用所请求的服务器名称来指导其端点对等身份的标识和/或安全策略的其他方面。
                        </p>
                        <p>呼叫<code class="codeph">getPacketBufferSize()</code>和<code class="codeph">getApplicationBufferSize()</code>方法论<code class="codeph">SSLSession</code>用于确定适当的缓冲区大小<code class="codeph">SSLEngine</code> 。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">
                              <p class="notep1">注意：</p>TLS协议指定实现将产生的数据包最多包含16 KB的纯文本。但是，某些实现违反规范并生成最大32 KB的大记录。如果<code class="codeph">SSLEngine.unwrap()</code>代码检测到较大的入站数据包，然后由返回的缓冲区大小<code class="codeph">SSLSession</code>将动态更新。应用程序应始终检查BUFFER_OVERFLOW和BUFFER_UNDERFLOW状态，并在必要时扩大相应的缓冲区。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="SSLEngine的状态由SSLEngineResult表示。状态。">了解SSLEngine操作状态</a> 。SunJSSE将始终发送符合标准的16 KB记录，并允许传入的32 KB记录。有关解决方法，请参见系统属性。 <code class="codeph">jsse.SSLEngine.acceptLargeFragments</code>在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE包含一个标准实现，可以通过插入不同的实现或指定默认的密钥库等进行自定义。">定制JSSE中</a> 。</div> 
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" name="GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863"></a><h4 id="JSSEC-GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" class="sect4">HttpsURLConnection类别</h4>
                  <div>
                     <p>的<code class="codeph">javax.net.ssl.HttpsURLConnection</code>类扩展了<code class="codeph">java.net.HttpURLConnection</code>类，并增加了对HTTPS特定功能的支持。
                     </p>
                     <div class="section">
                        <p>HTTPS协议类似于HTTP，但是HTTPS首先通过TLS套接字建立安全通道，然后在请求或接收数据之前<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">验证</a>对等方的身份（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">Cipher Suite选择和远程实体验证</a> ）。的<code class="codeph">javax.net.ssl.HttpsURLConnection</code>类扩展了<code class="codeph">java.net.HttpURLConnection</code>类，并增加了对HTTPS特定功能的支持。要了解有关如何构造和使用HTTPS URL的更多信息，请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">java.net。网址</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/java/net/URLConnection.html" target="_blank"><span class="apiname">java.net。URLConnection</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/java/net/HttpURLConnection.html" target="_blank"><span class="apiname">java.net。HttpURLConnection</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">javax.net.ssl。HttpsURLConnection</span></a>类。
                        </p>
                        <p>在获得<code class="codeph">HttpsURLConnection</code>实例中，您可以先配置多个HTTP和HTTPS参数，然后再通过<code class="codeph">URLConnection.connect()</code>方法。特别令人感兴趣的是：</p>
                        <ul style="list-style-type:disc">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA">设置分配的SSLSocketFactory</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573">设置分配的主机名验证程序</a></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA" name="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA"></a><h5 id="JSSEC-GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA" class="sect5">设置分配的SSLSocketFactory</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>在某些情况下，最好指定<code class="codeph">SSLSocketFactory</code>那一个<code class="codeph">HttpsURLConnection</code>实例使用。例如，您可能希望通过默认实现不支持的代理类型进行隧道传输。新的<code class="codeph">SSLSocketFactory</code>可以返回已经执行了所有必要隧道的套接字，从而允许<code class="codeph">HttpsURLConnection</code>使用其他代理。
                           </p>
                           <p>的<code class="codeph">HttpsURLConnection</code>该类具有默认值<code class="codeph">SSLSocketFactory</code>加载类时分配的值（这是<code class="codeph">SSLSocketFactory.getDefault()</code>方法）。的未来实例<code class="codeph">HttpsURLConnection</code>将继承当前的默认值<code class="codeph">SSLSocketFactory</code>直到新的默认值<code class="codeph">SSLSocketFactory</code>通过静态分配给类<code class="codeph">HttpsURLConnection.setDefaultSSLSocketFactory()</code>方法。一旦实例<code class="codeph">HttpsURLConnection</code>已经创建，继承了<code class="codeph">SSLSocketFactory</code>在此实例上，可以通过调用<code class="codeph">setSSLSocketFactory()</code>方法。
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA__GUID-2DF8B087-98E2-490B-89EC-BA0A4E86DC57">
                                 <p class="notep1">注意：</p>更改默认静态<code class="codeph">SSLSocketFactory</code>对的现有实例没有影响<code class="codeph">HttpsURLConnection</code> 。致电<code class="codeph">setSSLSocketFactory()</code>方法是更改现有实例所必需的。
                              </div> 
                           </div>
                           <p>您可以获取每个实例或每个类<code class="codeph">SSLSocketFactory</code>通过拨打电话<code class="codeph">getSSLSocketFactory()</code>要么<code class="codeph">getDefaultSSLSocketFactory()</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573" name="GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573"></a><h5 id="JSSEC-GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573" class="sect5">设置分配的主机名验证程序</h5>
                     <div>
                        <p></p>
                        <p>如果URL的主机名与TLS握手过程中收到的凭据中的主机名不匹配，则可能发生了URL欺骗。如果实现无法确定具有合理确定性的主机名，则TLS实现将对实例的已分配<span class="apiname">HostnameVerifier</span>执行回调，以进行进一步检查。主机名验证者可以采取任何必要的步骤来进行确定，例如执行主机名模式匹配或打开交互式对话框。主机名验证程序验证失败，将关闭连接。有关主机名验证的更多信息，请参阅<a href="http://www.ietf.org/rfc/rfc2818.txt?number=2818" target="_blank">RFC 2818：HTTP over TLS</a> 。</p>
                        <p><span class="apiname">setHostnameVerifier（）</span>和<span class="apiname">setDefaultHostnameVerifier（）</span>方法的运行方式与<span class="apiname">setSSLSocketFactory（）</span>和<span class="apiname">setDefaultSSLSocketFactory（）</span>方法类似，因为<span class="apiname">HostnameVerifier</span>对象是按实例和类分配的，并且可以通过以下方式获取当前值：调用<span class="apiname">getHostnameVerifier（）</span>或<span class="apiname">getDefaultHostnameVerifier（）</span>方法。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B" name="GUID-AD2529FD-8778-4A02-B544-5F58E083774B"></a><h4 id="JSSEC-GUID-AD2529FD-8778-4A02-B544-5F58E083774B" class="sect4">支持类别和接口</h4>
                  <div>
                     <p></p>
                     <p>提供本节中的类和接口以支持创建和初始化<code class="codeph">SSLContext</code>对象，用于创建<code class="codeph">SSLSocketFactory</code> ， <code class="codeph">SSLServerSocketFactory</code>和<code class="codeph">SSLEngine</code>对象。支持类和接口是<code class="codeph">javax.net.ssl</code>包。
                     </p>
                     <p>本节中描述的三个类（ <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="javax.net.ssl。SSLContext类是用于实现安全套接字协议的引擎类。此类的实例充当SSLSocket，SSLServerSocket和SSLEngine的工厂。SSLContext对象保存在该上下文下创建的所有对象之间共享的所有状态信息。例如，会话状态由上下文提供的套接字工厂通过握手协议通过握手协议协商时与SSLContext关联。这些缓存的会话可以被在相同上下文下创建的其他套接字重用和共享。">SSLContext类</a> ， <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" title="javax.net.ssl。KeyManagerFactory类是基于提供程序的服务的引擎类，该类充当一种或多种KeyManager对象的工厂。SunJSSE提供程序实现了一个工厂，该工厂可以返回基本的X.509密钥管理器。因为它是基于提供程序的，所以可以实现并配置其他工厂以提供其他或替代的密钥管理器。">KeyManagerFactory类</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="javax.net.ssl。TrustManagerFactory是基于提供程序的服务的引擎类，该类充当一种或多种类型的TrustManager对象的工厂。因为它是基于提供程序的，所以可以实现并配置其他工厂，以提供其他或替代的信任管理器，这些管理器提供更复杂的服务或实现特定于安装的身份验证策略。">TrustManagerFactory类</a> ）是<span class="italic"><span>引擎类</span></span> 。引擎类是针对特定算法（或协议，如果是<code class="codeph">SSLContext</code> ），可以在一个或多个加密服务提供商（提供程序）包中提供实现。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-71693272-7F57-4155-99F9-A2139271FD6D">JCA设计原理</a>以及<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。
                     </p>
                     <p>JSSE随附的SunJSSE提供程序提供了<code class="codeph">SSLContext</code> ， <code class="codeph">KeyManagerFactory</code>和<code class="codeph">TrustManagerFactory</code>实现，以及标准中引擎类的实现<code class="codeph">java.security</code> API。 <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58" title="下表列出了SunJSSE提供的实现。">表8-1</a>列出了SunJSSE提供的实现。</p>
                     <div class="tblformal" id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58">
                        <p class="titleintable">表8-1 SunJSSE提供的实现</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SunJSSE提供的实现" width="100%" border="1" summary="The following table lists implementations supplied by SunJSSE." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e2123">实施发动机等级</th>
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e2125">算法或协议</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2129" headers="d112429e2123 "><code class="codeph">KeyStore</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2129 d112429e2125 ">PKCS12</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2135" headers="d112429e2123 "><code class="codeph">KeyManagerFactory</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2135 d112429e2125 ">PKIX，SunX509</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2141" headers="d112429e2123 "><code class="codeph">TrustManagerFactory</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2141 d112429e2125 ">PKIX（X509或SunPKIX），SunX509</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2147" headers="d112429e2123 "><code class="codeph">SSLContext</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2147 d112429e2125 ">SSLv3 <a id="fn_1" name="fn_1" href="#fn_1" starting="" with="" jdk="" 8u31,="" the="" sslv3="" protocol="" (secure="" socket="" layer)="" has="" been="" deactivated="" and="" is="" not="" available="" by="" default.="" see="" java.security.security="" property="" jdk.tls.disabledalgorithms="" in=""><java_home="" onclick="footdisplay(1, ">/conf/security/java.security文件。如果绝对需要SSLv3，则可以通过从java.security文件的jdk.tls.disabledAlgorithms属性中删除SSLv3或在初始化JSSE之前动态设置此Security属性来重新激活协议。“）”> <sup>脚1</sup></java_home=""></a> ，TLSv1，TLSv1 .1，TLSv1.2，TLSv1.3，DTLSv1.0，DTLSv1.2</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup>从JDK 8u31开始，SSLv3协议（安全套接字层）已被停用，默认情况下不可用。见<code class="codeph">java.security.Security</code>属性<code class="codeph">jdk.tls.disabledAlgorithms</code>在里面<code class="codeph"><span class="variable" translate="no"><java_home></span>/conf/security/java.security</code>文件。如果绝对需要SSLv3，则可以通过删除协议来重新激活协议<code class="codeph">SSLv3</code>来自<code class="codeph">jdk.tls.disabledAlgorithms</code>物业<code>java.security</code>文件或通过在初始化JSSE之前动态设置此安全性属性。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" name="GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F"></a><h5 id="JSSEC-GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" class="sect5">SSLContext类</h5>
                     <div>
                        <p>的<code class="codeph">javax.net.ssl.SSLContext</code> class是用于实现安全套接字协议的引擎类。此类的实例充当<code class="codeph">SSLSocket</code> ， <code class="codeph">SSLServerSocket</code>和<code class="codeph">SSLEngine</code> 。一个<code class="codeph">SSLContext</code>对象包含在该上下文下创建的所有对象之间共享的所有状态信息。例如，会话状态与<code class="codeph">SSLContext</code>当由上下文提供的套接字工厂通过套接字通过握手协议协商时。这些缓存的会话可以被在相同上下文下创建的其他套接字重用和共享。
                        </p>
                        <p>每个实例都通过其实例进行配置<code class="codeph">init</code>方法，其中包含执行身份验证所需的密钥，证书链和受信任的根CA证书。以密钥和信任管理器的形式提供此配置。这些管理器为上下文支持的密码套件的身份验证和密钥协议方面提供支持。
                        </p>
                        <p>当前，仅支持基于X.509的管理器。</p>
                     </div>
                     <div class="sect5"><a id="GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90" name="GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90"></a><h6 id="JSSEC-GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90" class="sect6">获取并初始化SSLContext类</h6>
                        <div>
                           <p>的<code class="codeph">SSLContext</code>类用于创建<code class="codeph">SSLSocketFactory</code>要么<code class="codeph">SSLServerSocketFactory</code>类。
                           </p>
                           <p>有两种方法可以获取和初始化<code class="codeph">SSLContext</code> ：</p>
                           <ul style="list-style-type:disc">
                              <li>最简单的方法是调用静态<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a>方法之一<code class="codeph">SSLSocketFactory</code>要么<code class="codeph">SSLServerSocketFactory</code>类。此方法创建默认<code class="codeph">SSLContext</code>默认情况下<code class="codeph">KeyManager</code> ， <code class="codeph">TrustManager</code>和<code class="codeph">SecureRandom</code> （安全的随机数生成器）。默认值<code class="codeph">KeyManagerFactory</code>和<code class="codeph">TrustManagerFactory</code>用于创建<code class="codeph">KeyManager</code>和<code class="codeph">TrustManager</code> ， 分别。所使用的密钥材料位于默认密钥库和信任库中，这由<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">定制默认密钥库和信任库，商店类型和商店密码中</a>所述的系统属性确定。
                              </li>
                              <li>使调用者对创建的上下文的行为具有最大控制权的方法是调用静态方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a>在<code class="codeph">SSLContext</code>类，然后通过调用实例的适当属性来初始化上下文<code class="codeph">init()</code>方法。的一种变体<code class="codeph">init()</code>方法采用三个参数： <code class="codeph">KeyManager</code>对象，一组<code class="codeph">TrustManager</code>对象和一个<code class="codeph">SecureRandom</code>宾语。的<code class="codeph">KeyManager</code>和<code class="codeph">TrustManager</code>通过实现适当的接口或使用来创建对象<code class="codeph">KeyManagerFactory</code>和<code class="codeph">TrustManagerFactory</code>类以生成实现。的<code class="codeph">KeyManagerFactory</code>和<code class="codeph">TrustManagerFactory</code>然后可以使用包含在<code class="codeph">KeyStore</code>作为参数传递给<code class="codeph">init()</code>的方法<code class="codeph">TrustManagerFactory</code>要么<code class="codeph">KeyManagerFactory</code>类。最后， <code class="codeph">getTrustManagers()</code>方法（在<code class="codeph">TrustManagerFactory</code> ）和<code class="codeph">getKeyManagers()</code>方法（在<code class="codeph">KeyManagerFactory</code>可以调用以获得一组信任管理器或密钥管理器，每种类型的信任或密钥材料一个。
                              </li>
                           </ul>
                           <p>建立TLS连接后， <code class="codeph">SSLSession</code>创建包含各种信息（例如，已建立的身份和所使用的密码套件）的密码。的<code class="codeph">SSLSession</code>然后用于描述两个实体之间的正在进行的关系和状态信息。每个TLS连接一次涉及一个会话，但是该会话可以同时或顺序用于这些实体之间的许多连接。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7" name="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7"></a><h6 id="JSSEC-GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7" class="sect6">创建一个SSLContext对象</h6>
                        <div>
                           <p>与其他基于JCA提供程序的引擎类一样， <code class="codeph">SSLContext</code>使用创建对象<code class="codeph">getInstance()</code>的工厂方法<code class="codeph">SSLContext</code>类。这些静态方法均返回<span class="italic">至少</span>实现所请求的安全套接字协议的实例。返回的实例也可以实现其他协议。例如， <code class="codeph">getInstance("TLSv1")</code>可能会返回实现TLSv1，TLSv1.1和TLSv1.2的实例。的<code class="codeph">getSupportedProtocols()</code>当一个<code class="codeph">SSLSocket</code> ， <code class="codeph">SSLServerSocket</code> ， 要么<code class="codeph">SSLEngine</code>从此上下文创建。您可以使用来控制为SSL连接实际启用了哪些协议<code class="codeph">setEnabledProtocols(String[] protocols)</code>方法。
                           </p>
                           <div class="section">
                              <div class="infoboxnote" id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7__GUID-AEF580E3-5151-4C8F-A5DE-A21E08BC18A2">
                                 <p class="notep1">注意：</p>一个<code class="codeph">SSLContext</code>对象会自动创建，初始化并静态分配给<code class="codeph">SSLSocketFactory</code>上课时<code class="codeph">SSLSocketFactory.getDefault()</code>方法。因此，您不必直接创建和初始化<span class="apiname">SSLContext</span>对象（除非您想覆盖默认行为）。
                              </div>
                              <p>创建一个<code class="codeph">SSLContext</code>通过调用对象<code class="codeph">getInstance()</code>工厂方法，必须指定协议名称。您还可以指定要提供所请求协议的实现的提供者：</p>
                              <ul style="list-style-type:disc">
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol);</code></li>
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol, String provider);</code></li>
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol, Provider provider);</code></li>
                              </ul>
                              <p>如果仅指定了协议名称，则系统将确定环境中是否可用请求的协议的实现。如果存在多个实现，则它将确定是否存在首选实现。</p>
                              <p>如果同时指定了协议名称和提供者，则系统将确定请求的提供者中是否存在所请求协议的实现。如果没有实现，则将引发异常。</p>
                              <p>协议是一个字符串（例如<code class="codeph">"TLS"</code> ），以描述所需的安全套接字协议。通用协议名称<code class="codeph">SSLContext</code>对象在<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>中定义。
                              </p>
                              <p>一个<code class="codeph">SSLContext</code>可以得到如下：</p><pre class="codeblock"><code>SSLContext sc = SSLContext.getInstance("TLS");
</code></pre><p>新创建的<code class="codeph">SSLContext</code>应该通过调用<code class="codeph">init</code>方法：</p><pre class="codeblock"><code>public void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);
</code></pre><p>如果<code class="codeph">KeyManager[]</code>参数为null，然后为空<code class="codeph">KeyManager</code>将为此上下文定义。如果<code class="codeph">TrustManager[]</code>参数为null，则将搜索安装的安全提供程序以获取<span class="apiname">TrustManagerFactory</span>类的最高优先级实现（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="javax.net.ssl。TrustManagerFactory是基于提供程序的服务的引擎类，该类充当一种或多种类型的TrustManager对象的工厂。因为它是基于提供程序的，所以可以实现并配置其他工厂，以提供其他或替代的信任管理器，这些管理器提供更复杂的服务或实现特定于安装的身份验证策略。">TrustManagerFactory Class</a> ），从该实现中适当<code class="codeph">TrustManager</code>将获得。同样， <code class="codeph">SecureRandom</code>参数可以为null，在这种情况下，将使用默认实现。
                              </p>
                              <p>如果使用内部默认上下文（例如， <code class="codeph">SSLContext</code>由创建<code class="codeph">SSLSocketFactory.getDefault()</code>要么<code class="codeph">SSLServerSocketFactory.getDefault()</code> ），然后创建<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">默认的KeyManager和TrustManager</a> 。默认值<code class="codeph">SecureRandom</code>还选择实现。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" name="GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9"></a><h5 id="JSSEC-GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" class="sect5">TrustManager界面</h5>
                     <div>
                        <p>的主要责任<code class="codeph">TrustManager</code>确定是否应该信任所提供的身份验证凭据。如果凭据不受信任，则连接将终止。要验证安全套接字对等方的远程身份，必须初始化<code class="codeph">SSLContext</code>具有一个或多个对象<code class="codeph">TrustManager</code>对象。你必须通过<code class="codeph">TrustManager</code>支持的每种身份验证机制。如果将null传递给<code class="codeph">SSLContext</code>初始化，然后将为您创建一个信任管理器。通常，单个信任管理器支持基于X.509公钥证书的身份验证（例如， <code class="codeph">X509TrustManager</code> ）。一些安全套接字实现也可能支持基于共享密钥，Kerberos或其他机制的身份验证。
                        </p>
                        <p><code class="codeph">TrustManager</code>对象是由<code class="codeph">TrustManagerFactory</code> ，或者通过提供接口的具体实现。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" name="GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F"></a><h5 id="JSSEC-GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" class="sect5">TrustManagerFactory类</h5>
                     <div>
                        <p>的<code class="codeph">javax.net.ssl.TrustManagerFactory</code>是基于提供程序的服务的引擎类，它充当一种或多种类型的<code class="codeph">TrustManager</code>对象。因为它是基于提供程序的，所以可以实现并配置其他工厂，以提供其他或替代的信任管理器，这些管理器提供更复杂的服务或实现特定于安装的身份验证策略。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B" name="GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B"></a><h6 id="JSSEC-GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B" class="sect6">创建一个TrustManagerFactory</h6>
                        <div>
                           <p>您可以通过类似的方式创建此类的实例<code class="codeph">SSLContext</code> ，除了将算法名称字符串而不是协议名称传递给<code class="codeph">getInstance()</code>方法：</p>
                           <div class="section"><pre class="codeblock"><code>TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, String provider);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, Provider provider);
</code></pre><p>调用示例如下：</p><pre class="codeblock"><code>TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</code></pre><p>前面的调用创建了SunJSSE提供程序的PKIX信任管理器工厂的实例。该工厂可用于创建提供基于X.509 PKIX的认证路径有效性检查的信任管理器。</p>
                              <p>初始化时<code class="codeph">SSLContext</code> ，您可以使用从信任管理器工厂创建的信任管理器，也可以编写自己的信任管理器，例如，使用<a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CertPath.html" target="_blank"><code class="codeph">CertPath</code></a> API。请参阅《 <a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="CertPath类是用于认证路径的抽象类。它定义了所有证书路径对象共享的功能。可以通过对CertPath类进行子类化来实现各种证书路径类型，即使它们可能具有不同的内容和排序方案。">Java PKI程序员指南》</a> 。如果使用以下方法实现信任管理器，则无需使用信任管理器工厂： <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/X509TrustManager.html" target="_blank"><code class="codeph">X509TrustManager</code></a>接口。
                              </p>
                              <p>新创建的工厂应通过调用以下方法之一来初始化<code class="codeph">init()</code>方法：</p><pre class="codeblock"><code>public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</code></pre><p>呼叫任何一个<code class="codeph">init()</code>方法适用于<code class="codeph">TrustManagerFactory</code>您正在使用。如果不确定，请咨询提供商。
                              </p>
                              <p>对于许多工厂，例如SunX509 <code class="codeph">TrustManagerFactory</code>来自SunJSSE提供者， <code class="codeph">KeyStore</code>是初始化所需的唯一信息<code class="codeph">TrustManagerFactory</code>因此第一个<code class="codeph">init</code>方法是合适的一种。的<code class="codeph">TrustManagerFactory</code>将查询<code class="codeph">KeyStore</code>有关在授权检查期间应信任哪些远程证书的信息。
                              </p>
                              <p>有时，初始化参数不是<code class="codeph">KeyStore</code>提供者需要。该提供者的用户应通过适当的实现<code class="codeph">ManagerFactoryParameters</code>由提供商定义。然后，提供者可以在<code class="codeph">ManagerFactoryParameters</code>实施以获得所需的信息。
                              </p>
                              <p>例如，假设<code class="codeph">TrustManagerFactory</code>提供者要求从任何要使用该提供者的应用程序中获取初始化参数B，R和S。像所有需要初始化参数而不是<code class="codeph">KeyStore</code> ，提供程序要求应用程序提供实现特定实例的类的实例<code class="codeph">ManagerFactoryParameters</code>子接口。在该示例中，假设提供者需要调用应用程序来实现并创建一个实例。 <code class="codeph">MyTrustManagerFactoryParams</code>并传递给第二个<code class="codeph">init()</code>方法。以下示例说明了<code class="codeph">MyTrustManagerFactoryParams</code>看起来像：</p><pre class="codeblock"><code>public interface MyTrustManagerFactoryParams extends ManagerFactoryParameters {
  public boolean getBValue();
  public float getRValue();
  public String getSValue();
}
</code></pre><p>一些信任管理器可以做出信任决策，而无需使用<code class="codeph">KeyStore</code>对象或任何其他参数。例如，他们可以通过LDAP从本地目录服务访问信任材料，使用远程在线证书状态检查服务器，或者从标准本地位置访问默认信任材料。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151" name="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151"></a><h6 id="JSSEC-GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151" class="sect6">PKIX TrustManager支持</h6>
                        <div>
                           <p>默认的信任管理器算法是PKIX。可以通过编辑<code class="codeph">ssl.TrustManagerFactory.algorithm</code>物业<code class="codeph">java.security</code>文件。
                           </p>
                           <p>PKIX信任管理器工厂使用来自已安装的安全提供程序的CertPath PKIX实现（请参阅《 <a href="java-pki-programmers-guide.html#GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" title="Java认证路径API定义了用于创建，构建和验证认证路径的接口和抽象类。可以使用基于提供者的接口插入实现。">PKI程序员指南概述》</a> ）。可以使用常规方法初始化信任管理器工厂<code class="codeph">init(KeyStores)</code>方法，或通过使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/CertPathTrustManagerParameters.html" target="_blank"><span class="apiname">CertPathTrustManagerParameters</span></a>类将<span class="apiname">CertPath</span>参数传递给PKIX信任管理器。
                           </p>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">示例8-11</a>说明了如何使信任管理器使用特定的LDAP证书存储并启用吊销检查。
                           </p>
                           <p>如果<code class="codeph">TrustManagerFactory.init(KeyStore)</code>使用方法，然后使用默认的PKIX参数，但禁用了吊销检查。可以通过设置<code class="codeph">com.sun.net.ssl.checkRevocation</code>系统属性<code class="codeph">true</code> 。此设置要求CertPath实现可以自己定位吊销信息。提供程序中的PKIX实现可以在许多情况下执行此操作，但需要系统属性<code class="codeph">com.sun.security.enableCRLDP</code>设置为<code class="codeph">true</code> 。请注意，默认情况下<span class="apiname">TrustManagerFactory.init（ManagerFactoryParameters）</span>方法已启用吊销检查。
                           </p>
                           <p>请参阅<a href="java-pki-programmers-guide.html#GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" title="Java认证路径API包括一组特定于算法的类，这些类经过建模以与PKIX认证路径验证算法一起使用。">PKIX类</a>和<a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="CertPath类是用于认证路径的抽象类。它定义了所有证书路径对象共享的功能。可以通过对CertPath类进行子类化来实现各种证书路径类型，即使它们可能具有不同的内容和排序方案。">CertPath类</a> 。
                           </p>
                           <div class="example" id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">
                              <p class="titleinexample">示例8-11使用LDAP证书启用吊销检查的示例代码</p>
                              <p>以下示例说明了如何使信任管理器使用特定的LDAP证书存储并启用吊销检查：</p><pre class="codeblock"><code>
    import javax.net.ssl.*;
    import java.security.cert.*;
    import java.security.KeyStore;
    import java.io.FileInputStream;
    ...
    
    // Obtain Keystore password
    char[] pass = System.console().readPassword("Password: ");

    // Create PKIX parameters
    KeyStore anchors = KeyStore.getInstance("JKS");
    anchors.load(new FileInputStream(anchorsFile, pass));
    PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(anchors, new X509CertSelector());
    
    // Specify LDAP certificate store to use
    LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
    pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));
    
    // Specify that revocation checking is to be enabled
    pkixParams.setRevocationEnabled(true);
    
    // Wrap PKIX parameters as trust manager parameters
    ManagerFactoryParameters trustParams = new CertPathTrustManagerParameters(pkixParams);
    
    // Create TrustManagerFactory for PKIX-compliant trust managers
    TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");
    
    // Pass parameters to factory to be passed to CertPath implementation
    factory.init(trustParams);
    
    // Use factory
    SSLContext ctx = SSLContext.getInstance("TLS");
    ctx.init(null, factory.getTrustManagers(), null);
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7932AB21-2FED-402E-A806-3088402BAEA6" name="GUID-7932AB21-2FED-402E-A806-3088402BAEA6"></a><h5 id="JSSEC-GUID-7932AB21-2FED-402E-A806-3088402BAEA6" class="sect5">X509TrustManager界面</h5>
                     <div>
                        <p>的<code class="codeph">javax.net.ssl.X509TrustManager</code>接口扩展一般<code class="codeph">TrustManager</code>接口。使用基于X.509的身份验证时，必须由信任管理器实现。
                        </p>
                        <p>要支持通过JSSE对远程套接字对等方进行X.509身份验证，必须将此接口的实例传递给<code class="codeph">init</code>的方法<code class="codeph">SSLContext</code>宾语。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290" name="GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290"></a><h6 id="JSSEC-GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290" class="sect6">创建一个X509TrustManager</h6>
                        <div>
                           <p>您既可以直接自己实现此接口，也可以从基于提供程序的接口获取一个<code class="codeph">TrustManagerFactory</code> （例如SunJSSE提供程序提供的内容）。您还可以实现自己的接口，该接口委托给工厂生成的信任管理器。例如，您可以执行此操作以过滤所得的信任决策并通过图形用户界面查询最终用户。
                           </p>
                           <div class="section">
                              <p>如果将null的KeyStore参数传递给SunJSSE PKIX或SunX509 <code class="codeph">TrustManagerFactory</code> ，然后工厂使用以下过程尝试查找信任物料：</p>
                              <ol>
                                 <li> 
                                    <p>如果<code class="codeph">javax.net.ssl.trustStore</code>属性已定义，则<code class="codeph">TrustManagerFactory</code>尝试使用该系统属性指定的文件名查找文件，并将该文件用作KeyStore参数。如果<code class="codeph">javax.net.ssl.trustStorePassword</code>系统属性也已定义，然后使用其值在打开信任库之前检查其完整性。
                                    </p> 
                                    <p>如果<code class="codeph">javax.net.ssl.trustStore</code>属性已定义，但指定的文件不存在，则使用默认值<code class="codeph">TrustManager</code>使用空密钥库创建。
                                    </p> 
                                 </li>
                                 <li>如果<code class="codeph">javax.net.ssl.trustStore</code>未指定系统属性，则：<ul style="list-style-type:disc">
                                       <li>如果文件<span class="variable" translate="no">java-home</span> <code class="codeph">/lib/security/jssecacerts</code>存在，则使用该文件；</li>
                                       <li>如果文件<span class="variable" translate="no">java-home</span> <code class="codeph">/lib/security/cacerts</code>存在，则使用该文件；</li>
                                       <li>如果这两个文件都不存在，则TLS密码套件是匿名的，不执行任何身份验证，因此不需要信任库。</li>
                                    </ul> 
                                 </li>
                              </ol>
                              <p>要了解有关<span class="variable" translate="no">java-home</span>所指的更多信息，请参见<a href="terms-and-definitions.html" title="以下是常用的密码术术语及其定义。">术语和定义</a> 。
                              </p>
                              <p>工厂寻找通过<code class="codeph">javax.net.ssl.trustStore</code>担保财产或<code>jssecacerts</code>文件之前检查<code class="codeph">cacerts</code>文件。因此，您可以提供特定于JSSE的一组受信任的根证书，与可能存在于其中的证书分开<code>cacerts</code>用于代码签名。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" name="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4"></a><h6 id="JSSEC-GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" class="sect6">创建自己的X509TrustManager</h6>
                        <div>
                           <p>如果提供<code class="codeph">X509TrustManager</code>行为不适合您的情况，那么您可以创建自己的行为<code class="codeph">X509TrustManager</code>通过创建和注册自己的<code class="codeph">TrustManagerFactory</code>或通过实施<code class="codeph">X509TrustManager</code>直接接口。
                           </p>
                           <div class="section">
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">例8-12</a>说明了一个<code class="codeph">MyX509TrustManager</code>增强默认SunJSSE的类<code class="codeph">X509TrustManager</code>通过在默认情况下提供替代身份验证逻辑来实现行为<code class="codeph">X509TrustManager</code>失败。
                              </p>
                              <p>创建此类信任管理器后，请将其分配给<code class="codeph">SSLContext</code>通过<code class="codeph">init()</code>方法，如以下示例所示。未来<code class="codeph">SocketFactories</code>由此创造<code class="codeph">SSLContext</code>将使用您的新<code class="codeph">TrustManager</code>在做出信任决策时。
                              </p><pre class="codeblock"><code>TrustManager[] myTMs = new TrustManager[] { new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTMs, null);
</code></pre></div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">
                              <p class="titleinexample">示例8-12用于创建X509TrustManager的示例代码</p>
                              <p>以下代码示例说明了<code class="codeph">MyX509TrustManager</code>增强默认SunJSSE的类<code class="codeph">X509TrustManager</code>通过在默认情况下提供替代身份验证逻辑来实现行为<code class="codeph">X509TrustManager</code>失败：</p><pre class="codeblock"><code>
class MyX509TrustManager implements X509TrustManager {

     /*
      * The default PKIX X509TrustManager9.  Decisions are delegated
      * to it, and a fall back to the logic in this class is performed
      * if the default X509TrustManager does not trust it.
      */
     X509TrustManager pkixTrustManager;

     MyX509TrustManager() throws Exception {
         // create a "default" JSSE X509TrustManager.

         KeyStore ks = KeyStore.getInstance("JKS");
         ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());

         TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trust managers, looking
          * for an instance of X509TrustManager.  If found,
          * use that as the default trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509TrustManager) {
                 pkixTrustManager = (X509TrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else the
          * constructor fails.
          */
         throw new Exception("Couldn't initialize");
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F" name="GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F"></a><h6 id="JSSEC-GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F" class="sect6">动态更新密钥库</h6>
                        <div>
                           <p>你可以增强<code class="codeph">MyX509TrustManager</code>处理动态密钥库更新。当一个<code class="codeph">checkClientTrusted</code>要么<code class="codeph">checkServerTrusted</code>测试失败并且未建立受信任的证书链，您可以将所需的受信任的证书添加到密钥库中。您必须创建一个新<code class="codeph">pkixTrustManager</code>来自<code class="codeph">TrustManagerFactory</code>使用更新的密钥库初始化。建立新连接时（使用先前初始化的<code class="codeph">SSLContext</code> ），则在做出信任决定时将使用新添加的证书。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3" name="GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3"></a><h5 id="JSSEC-GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3" class="sect5">X509ExtendedTrustManager类别</h5>
                     <div>
                        <p>的<code class="codeph">X509ExtendedTrustManager</code>类是的抽象实现<code class="codeph">X509TrustManager</code>接口。它增加了对连接敏感的信任管理的方法。此外，它还可以在TLS层进行端点验证。
                        </p>
                        <p>在TLS 1.2和更高版本中，客户端和服务器都可以指定它们将接受的哈希和签名算法。要对远程端进行身份验证，身份验证决策必须基于X509证书以及本地接受的哈希和签名算法。本地接受的哈希和签名算法可以使用<code class="codeph">ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code>方法。
                        </p>
                        <p>的<code class="codeph">ExtendedSSLSession</code>可以通过调用<code class="codeph">SSLSocket.getHandshakeSession()</code>方法或<code class="codeph">SSLEngine.getHandshakeSession()</code>方法。
                        </p>
                        <p>的<code class="codeph">X509TrustManager</code>接口对连接不敏感。它无法访问<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>会话属性。
                        </p>
                        <p>除了TLS 1.2和更高版本的支持外， <code class="codeph">X509ExtendedTrustManager</code>该类还支持算法约束和SSL层主机名验证。对于JSSE提供程序和信任管理器实现， <code class="codeph">X509ExtendedTrustManager</code>强烈推荐在旧版上使用该类<code class="codeph">X509TrustManager</code>接口。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D" name="GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D"></a><h6 id="JSSEC-GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D" class="sect6">创建一个X509ExtendedTrustManager</h6>
                        <div>
                           <p>您可以创建一个<code class="codeph">X509ExtendedTrustManager</code>自己子类化（在下一节中概述），或从基于提供者的子类中获取一个子类<code class="codeph">TrustManagerFactory</code> （例如SunJSSE提供程序提供的内容）。在Java SE 7中，PKIX或SunX509 <code class="codeph">TrustManagerFactory</code>返回一个<code class="codeph">X509ExtendedTrustManager</code>实例。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248" name="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248"></a><h6 id="JSSEC-GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248" class="sect6">创建自己的X509ExtendedTrustManager</h6>
                        <div>
                           <p>本节概述了如何创建的子类。 <code class="codeph">X509ExtendedTrustManager</code>几乎与上述相同<code class="codeph">X509TrustManager</code> 。
                           </p>
                           <div class="section">
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">示例8-13</a>说明了如何创建使用PKIX的类<code class="codeph">TrustManagerFactory</code>查找默认值<code class="codeph">X509ExtendedTrustManager</code>将用于做出有关信任的决策。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">
                              <p class="titleinexample">示例8-13用于创建PKIX TrustManagerFactory的示例代码</p>
                              <p>以下代码示例说明了如何创建使用PKIX的类<code class="codeph">TrustManagerFactory</code>查找默认值<code class="codeph">X509ExtendedTrustManager</code>将用于做出有关信任的决策。如果默认信任管理器由于任何原因失败，则子类可以添加其他行为。在示例中，这些位置由注释中的注释指示<code class="codeph">catch</code>条款。
                              </p><pre class="codeblock"><code>import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.*;
import javax.net.ssl.*;
    
public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {

  /*
   * The default PKIX X509ExtendedTrustManager.  Decisions are
   * delegated to it, and a fall back to the logic in this class is
   * performed if the default X509ExtendedTrustManager does not
   * trust it.
   */
  
  X509ExtendedTrustManager pkixTrustManager;
    
  MyX509ExtendedTrustManager() throws Exception {
    // create a "default" JSSE X509ExtendedTrustManager.
    
    KeyStore ks = KeyStore.getInstance("JKS");
    ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ks);
    
    TrustManager tms [] = tmf.getTrustManagers();
    
    /*
     * Iterate over the returned trust managers, looking
     * for an instance of X509ExtendedTrustManager. If found,
     * use that as the default trust manager.
     */
    for (int i = 0; i &lt; tms.length; i++) {
      if (tms[i] instanceof X509ExtendedTrustManager) {
        pkixTrustManager = (X509ExtendedTrustManager) tms[i];
        return;
      }
    }
    
    /*
     * Find some other way to initialize, or else we have to fail the
     * constructor.
     */
    throw new Exception("Couldn't initialize");
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType);
    } catch (CertificateException excep) {
      /*
       * Possibly pop up a dialog box asking whether to trust the
       * cert chain.
       */
    }
  }
    
  /*
   * Connection-sensitive verification.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
         
  /*
   * Merely pass this through.
   */
  public X509Certificate[] getAcceptedIssuers() {
    return pkixTrustManager.getAcceptedIssuers();
  }
}
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702" name="GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702"></a><h5 id="JSSEC-GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702" class="sect5">KeyManager界面</h5>
                     <div>
                        <p></p>
                        <p>的主要责任<code class="codeph">KeyManager</code>选择要最终发送到远程主机的身份验证凭据。要将自己（本地安全套接字对等体）认证为远程对等体，必须初始化<code class="codeph">SSLContext</code>具有一个或多个对象<code class="codeph">KeyManager</code>对象。你必须通过<code class="codeph">KeyManager</code>支持的每种不同的身份验证机制。如果将null传递给<code class="codeph">SSLContext</code>初始化，然后为空<code class="codeph">KeyManager</code>将被创建。如果使用内部默认上下文（例如， <code class="codeph">SSLContext</code>由...制作<code class="codeph">SSLSocketFactory.getDefault()</code>要么<code class="codeph">SSLServerSocketFactory.getDefault()</code> ），然后默认<code class="codeph">KeyManager</code>被建造。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a> 。通常，单个密钥管理器支持基于X.509公共密钥证书的身份验证。一些安全套接字实现也可能支持基于共享密钥，Kerberos或其他机制的身份验证。
                        </p>
                        <p><code class="codeph">KeyManager</code>对象是由<code class="codeph">KeyManagerFactory</code> ，或者通过提供接口的具体实现。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" name="GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F"></a><h5 id="JSSEC-GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" class="sect5">KeyManagerFactory类</h5>
                     <div>
                        <p>的<code class="codeph">javax.net.ssl.KeyManagerFactory</code>类是基于提供程序的服务的引擎类，该类充当一种或多种类型的<code class="codeph">KeyManager</code>对象。SunJSSE提供程序实现了一个工厂，该工厂可以返回基本的X.509密钥管理器。因为它是基于提供程序的，所以可以实现并配置其他工厂以提供其他或替代的密钥管理器。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5" name="GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5"></a><h6 id="JSSEC-GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5" class="sect6">创建一个KeyManagerFactory</h6>
                        <div>
                           <p>您可以通过类似的方式创建此类的实例<code class="codeph">SSLContext</code> ，除了将算法名称字符串而不是协议名称传递给<code class="codeph">getInstance()</code>方法：</p>
                           <div class="section"><pre class="codeblock"><code>KeyManagerFactory kmf = getInstance(String algorithm);
KeyManagerFactory kmf = getInstance(String algorithm, String provider);
KeyManagerFactory kmf = getInstance(String algorithm, Provider provider);
</code></pre><p>调用示例如下：</p><pre class="codeblock"><code>KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</code></pre><p>前面的调用创建了SunJSSE提供程序的默认密钥管理器工厂的实例，该工厂提供了基于X.509的基本身份验证密钥。</p>
                              <p>新创建的工厂应通过调用以下方法之一来初始化<code class="codeph">init</code>方法：</p><pre class="codeblock"><code>public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</code></pre><p>呼叫任何一个<code class="codeph">init</code>方法适用于<code class="codeph">KeyManagerFactory</code>您正在使用。如果不确定，请咨询提供商。
                              </p>
                              <p>对于许多工厂，例如默认的SunX509 <code class="codeph">KeyManagerFactory</code>来自SunJSSE提供者， <code class="codeph">KeyStore</code>和密码是初始化密码的唯一信息<code class="codeph">KeyManagerFactory</code>因此第一个<code class="codeph">init</code>方法是合适的一种。的<code class="codeph">KeyManagerFactory</code>将查询<code class="codeph">KeyStore</code>有关应使用哪个私钥和匹配的公钥证书向远程套接字对等方进行身份验证的信息。password参数指定密码，该密码将与从键盘访问密钥的方法一起使用。 <code class="codeph">KeyStore</code> 。中的所有键<code class="codeph">KeyStore</code>必须使用相同的密码保护。
                              </p>
                              <p>有时初始化参数不是<code class="codeph">KeyStore</code>提供商需要输入密码和密码。该提供者的用户应通过适当的实现<code class="codeph">ManagerFactoryParameters</code>由提供商定义。然后，提供者可以在<code class="codeph">ManagerFactoryParameters</code>实施以获得所需的信息。
                              </p>
                              <p>一些工厂可以提供对身份验证材料的访问，而无需使用<code class="codeph">KeyStore</code>对象或任何其他参数。例如，他们可以作为登录机制（例如基于JAAS，Java身份验证和授权服务的一种）的登录机制的一部分来访问密钥资料。
                              </p>
                              <p>如前所述，SunJSSE提供程序支持必须使用以下命令初始化的SunX509工厂： <code class="codeph">KeyStore</code>参数。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F" name="GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F"></a><h5 id="JSSEC-GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F" class="sect5">X509KeyManager界面</h5>
                     <p>的<code class="codeph">javax.net.ssl.X509KeyManager</code>接口扩展一般<code class="codeph">KeyManager</code>接口。它必须由密钥管理器实现，以用于基于X.509的身份验证。要支持通过JSSE对远程套接字对等方进行X.509身份验证，必须将此接口的实例传递给<code class="codeph">init()</code>的方法<code class="codeph">SSLContext</code>宾语。
                     </p>
                     <div class="sect5"><a id="GUID-FEA439FF-8110-4F2D-82AF-54815002805E" name="GUID-FEA439FF-8110-4F2D-82AF-54815002805E"></a><h6 id="JSSEC-GUID-FEA439FF-8110-4F2D-82AF-54815002805E" class="sect6">创建一个X509KeyManager</h6>
                        <div>
                           <p>您既可以直接自己实现此接口，也可以从基于提供程序的接口获取一个<code class="codeph">KeyManagerFactory</code> （例如SunJSSE提供程序提供的内容）。您还可以实现自己的接口，该接口委托给工厂生成的密钥管理器。例如，您可以执行此操作以过滤结果键并通过图形用户界面查询最终用户。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE" name="GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE"></a><h6 id="JSSEC-GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE" class="sect6">创建自己的X509KeyManager</h6>
                        <div>
                           <p></p>
                           <div class="section">
                              <p>如果默认<code class="codeph">X509KeyManager</code>行为不适合您的情况，那么您可以创建自己的行为<code class="codeph">X509KeyManager</code>类似于<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="如果提供的X509TrustManager行为不适合您的情况，则可以通过创建和注册自己的TrustManagerFactory或直接实现X509TrustManager接口来创建自己的X509TrustManager。">创建自己的X509TrustManager</a>中显示的方式。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41" name="GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41"></a><h5 id="JSSEC-GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41" class="sect5">X509ExtendedKeyManager类别</h5>
                     <div>
                        <p>的<code class="codeph">X509ExtendedKeyManager</code>抽象类是<code class="codeph">X509KeyManager</code>允许选择特定于连接的键的接口。它添加了两种根据密钥类型，允许的发行者和当前密钥为客户端或服务器选择密钥别名的方法。 <code class="codeph">SSLEngine</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">public String chooseEngineClientAlias(String[] keyType, Principal[] issuers, SSLEngine engine)</code></li>
                           <li><code class="codeph">public String chooseEngineServerAlias(String keyType, Principal[] issuers, SSLEngine engine)</code></li>
                        </ul>
                        <p>如果密钥管理器不是<code class="codeph">X509ExtendedKeyManager</code>类，那么它将不适用于<code class="codeph">SSLEngine</code>类。
                        </p>
                        <p>对于JSSE提供程序和关键管理器实施， <code class="codeph">X509ExtendedKeyManager</code>强烈推荐在旧版上使用该类<code class="codeph">X509KeyManager</code>接口。
                        </p>
                        <p>在TLS 1.2和更高版本中，客户端和服务器都可以指定它们将接受的哈希和签名算法。要通过远程方要求的身份验证，本地密钥选择决策必须同时基于X509证书和远程接受的哈希和签名算法。可以使用以下命令检索远程接受的哈希和签名算法<code class="codeph">ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code>方法。
                        </p>
                        <p>您可以创建自己的<code class="codeph">X509ExtendedKeyManager</code>子类，类似于<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="如果提供的X509TrustManager行为不适合您的情况，则可以通过创建和注册自己的TrustManagerFactory或直接实现X509TrustManager接口来创建自己的X509TrustManager。">创建自己的X509TrustManager中显示的方法</a> 。
                        </p>
                        <p>服务器端对<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）扩展</a>的支持使密钥管理器可以检查服务器名称并相应地选择适当的密钥。例如，假设在密钥库中有三个带有证书的密钥条目：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">cn=www.example.com</code></li>
                           <li><code class="codeph">cn=www.example.org</code></li>
                           <li><code class="codeph">cn=www.example.net</code></li>
                        </ul>
                        <p>如果ClientHello消息请求连接到<code class="codeph">www.example.net</code>在SNI扩展中，则服务器应该能够选择带有主题的证书<code class="codeph">cn=www.example.net</code> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9D7375F9-D688-436D-A214-02653F50ED32" name="GUID-9D7375F9-D688-436D-A214-02653F50ED32"></a><h5 id="JSSEC-GUID-9D7375F9-D688-436D-A214-02653F50ED32" class="sect5">TrustManager和KeyManager之间的关系</h5>
                     <div>
                        <p>历史上，关于<code class="codeph">TrustManager</code>和一个<code class="codeph">KeyManager</code> 。
                        </p>
                        <p>一种<code class="codeph">TrustManager</code>确定是否应该信任远程身份验证凭据（以及连接）。
                        </p>
                        <p>一种<code class="codeph">KeyManager</code>确定要发送到远程主机的身份验证凭据。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658" name="GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658"></a><h4 id="JSSEC-GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658" class="sect4">次要支持类别和接口</h4>
                  <div>
                     <p>这些类作为JSSE API的一部分提供，以支持安全套接字的创建，使用和管理。与核心类和支持类相比，安全套接字应用程序不太可能使用它们。辅助支持类和接口是<code class="codeph">javax.net.ssl</code>和<code class="codeph">javax.security.cert</code>包。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D" name="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D"></a><h5 id="JSSEC-GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D" class="sect5">SSLParameters类</h5>
                     <div>
                        <p>的<code class="codeph">SSLParameters</code>类封装了以下影响SSL / TLS / DTLS连接的参数：</p>
                        <ul style="list-style-type:disc">
                           <li>TLS / DTLS握手中接受的密码套件列表</li>
                           <li>允许的协议列表</li>
                           <li>TLS / DTLS握手期间的端点识别算法</li>
                           <li>服务器名称和服务器名称匹配器（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）扩展名</a> ）</li>
                           <li>TLS / DTLS握手中使用的密码套件首选项</li>
                           <li>TLS / DTLS握手期间的算法</li>
                           <li>服务器名称指示（SNI）</li>
                           <li>最大网络数据包大小</li>
                           <li>算法约束以及TLS / DTLS服务器是否应请求或要求客户端身份验证</li>
                        </ul>
                        <p>您可以检索当前<code class="codeph">SSLParameters</code>为<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>通过使用以下方法：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">getSSLParameters()</code>在一个<code class="codeph">SSLSocket</code> ， <code class="codeph">SSLServerSocket</code>和<code class="codeph">SSLEngine</code></li>
                           <li><code class="codeph">getDefaultSSLParameters()</code>和<code class="codeph">getSupportedSSLParamters()</code>在一个<code class="codeph">SSLContext</code></li>
                        </ul>
                        <p>您可以分配<code class="codeph">SSLParameters</code>与<code class="codeph">setSSLParameters()</code>的方法<code class="codeph">SSLSocket</code> ， <code class="codeph">SSLServerSocket</code>和<code class="codeph">SSLEngine</code> 。
                        </p>
                        <p>您可以使用以下命令显式设置服务器名称指示<code class="codeph">SSLParameters.setServerNames()</code>方法。客户端模式下的服务器名称指示也会影响端点标识。在执行中<code class="codeph">X509ExtendedTrustManager</code> ，它使用由服务器检索的服务器名称指示<code class="codeph">ExtendedSSLSession.getRequestedServerNames()</code>方法。参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">示例8-14</a> 。
                        </p>
                        <div class="example" id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">
                           <p class="titleinexample">示例8-14设置服务器名称指示的示例代码</p>
                           <p>本示例在服务器名称指示中使用主机名（ <code class="codeph">www.example.com</code> ），以根据最终实体的X.509证书中显示的对等方身份进行端点标识。
                           </p><pre class="codeblock"><code>    SSLSocketFactory factory = ...
    SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
    // SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

    SNIHostName serverName = new SNIHostName("www.example.com");
    List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
    serverNames.add(serverName);
 
    SSLParameters params = sslSocket.getSSLParameters();
    params.setServerNames(serverNames);
    sslSocket.setSSLParameters(params);
    // sslEngine.setSSLParameters(params);
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div class="sect5"><a id="GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813" name="GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813"></a><h6 id="JSSEC-GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813" class="sect6">密码套件偏好</h6>
                        <div>
                           <p>在TLS握手期间，客户端从其首选项开始，请求从其支持的加密选项列表中协商密码套件。然后，服务器从客户端请求的密码套件列表中选择一个密码套件。通常，选择会尊重客户的偏好。但是，为了减轻使用弱密码套件的风险，服务器可以通过调用该方法，根据自己的偏好而不是客户端的偏好来选择密码套件。 <code class="codeph">SSLParameters.setUseCipherSuitesOrder(true)</code> 。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4E20A067-B139-4754-B4B3-AAF372F76D02" name="GUID-4E20A067-B139-4754-B4B3-AAF372F76D02"></a><h5 id="JSSEC-GUID-4E20A067-B139-4754-B4B3-AAF372F76D02" class="sect5">SSLSessionContext接口</h5>
                     <div>
                        <p></p>
                        <p>的<code class="codeph">javax.net.ssl.SSLSessionContext</code>接口是与单个实体关联的一组<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="javax.net.ssl。SSLSession接口表示SSLSocket或SSLEngine连接的两个对等方之间协商的安全上下文。安排会话后，可以由连接在相同两个对等点之间的将来的SSLSocket或SSLEngine对象共享该会话。">SSLSession</a>对象。例如，它可以与同时参与许多会话的服务器或客户端关联。此接口中的方法启用上下文中所有会话的枚举，并允许通过其会话ID查找特定会话。
                        </p>
                        <p>一个<code class="codeph">SSLSessionContext</code>可以有选择地从<code class="codeph">SSLSession</code>通过调用SSLSession <code class="codeph">getSessionContext()</code>方法。在某些环境中，该上下文可能不可用，在这种情况下， <code class="codeph">getSessionContext()</code>方法返回null。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F2F8AC17-849A-40EE-A385-FD15328999B6" name="GUID-F2F8AC17-849A-40EE-A385-FD15328999B6"></a><h5 id="JSSEC-GUID-F2F8AC17-849A-40EE-A385-FD15328999B6" class="sect5">SSLSessionBindingListener接口</h5>
                     <div>
                        <p></p>
                        <p>的<code class="codeph">javax.net.ssl.SSLSessionBindingListener</code>接口由在绑定到<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession</a>或从<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="javax.net.ssl。SSLSession接口表示SSLSocket或SSLEngine连接的两个对等方之间协商的安全上下文。安排会话后，可以由连接在相同两个对等点之间的将来的SSLSocket或SSLEngine对象共享该会话。">SSLSession取消</a>绑定时通知的对象实现。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730" name="GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730"></a><h5 id="JSSEC-GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730" class="sect5">SSLSessionBindingEvent类</h5>
                     <div>
                        <p></p>
                        <p>的<code class="codeph">javax.net.ssl.SSLSessionBindingEvent</code>类定义（参见传送到一个<span class="apiname">SSLSessionBindingListener</span>事件<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F2F8AC17-849A-40EE-A385-FD15328999B6">SSLSessionBindingListener接口</a> ），当它被结合或从<span class="apiname">的SSLSession</span>未结合（见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="javax.net.ssl。SSLSession接口表示SSLSocket或SSLEngine连接的两个对等方之间协商的安全上下文。安排会话后，可以由连接在相同两个对等点之间的将来的SSLSocket或SSLEngine对象共享该会话。">的SSLSession和ExtendedSSLSession</a> ）。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" name="GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7"></a><h5 id="JSSEC-GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" class="sect5">HandShakeCompletedListener接口</h5>
                     <div>
                        <p>的<code class="codeph">javax.net.ssl.HandShakeCompletedListener</code>接口是由任何类实现的接口，该类在给定的SSL协议握手完成时得到通知<code class="codeph">SSLSocket</code>连接。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F242B876-6932-4B17-A755-1D9AFA25E54B" name="GUID-F242B876-6932-4B17-A755-1D9AFA25E54B"></a><h5 id="JSSEC-GUID-F242B876-6932-4B17-A755-1D9AFA25E54B" class="sect5">HandShakeCompletedEvent类</h5>
                     <div>
                        <p></p>
                        <p>的<code class="codeph">javax.net.ssl.HandShakeCompletedEvent</code>类定义在给定的SSL协议握手完成后传递给<span class="apiname">HandShakeCompletedListener</span> （请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" title="javax.net.ssl。HandShakeCompletedListener接口是由任何类实现的接口，该类在给定SSLSocket连接上收到SSL协议握手完成的通知。">HandShakeCompletedListener接口</a> ）的事件。 <code class="codeph">SSLSocket</code>连接。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587" name="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587"></a><h5 id="JSSEC-GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587" class="sect5">主机名验证器接口</h5>
                     <div>
                        <p></p>
                        <p>如果SSL / TLS实现的标准主机名验证逻辑失败，则实现将调用<code class="codeph">verify()</code>实现此接口并分配给此接口的类的方法<code class="codeph">HttpsURLConnection</code>实例。如果回调类在给定参数的情况下可以确定主机名是可接受的，则它报告应允许连接。不可接受的响应将导致连接终止。参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">示例8-15</a> 。
                        </p>
                        <p>看到<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a>有关如何分配<code class="codeph">HostnameVerifier</code>到<code class="codeph">HttpsURLConnection</code> 。
                        </p>
                        <div class="example" id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">
                           <p class="titleinexample">示例8-15用于实现HostnameVerifier接口的示例代码</p>
                           <p>以下示例说明了一个实现<code class="codeph">HostnameVerifier</code>接口：</p><pre class="codeblock"><code>    public class MyHostnameVerifier implements HostnameVerifier {
    
        public boolean verify(String hostname, SSLSession session) {
            // pop up an interactive dialog box
            // or insert additional matching logic
            if (good_address) {
                return true;
            } else {
                return false;
            }
        }
    }
    
    //...deleted...
    
    HttpsURLConnection urlc = (HttpsURLConnection)
      (new URL("https://www.example.com/")).openConnection();
    urlc.setHostnameVerifier(new MyHostnameVerifier());
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F" name="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F"></a><h5 id="JSSEC-GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F" class="sect5">X509证书类别</h5>
                     <div>
                        <p>许多安全套接字协议使用公钥证书（也称为X.509证书）执行身份验证。这是TLS协议的默认身份验证机制。</p>
                        <p>的<code class="codeph">java.security.cert.X509Certificate</code>抽象类提供了一种访问X.509证书属性的标准方法。
                        </p>
                        <div class="infoboxnote" id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F__GUID-C14C49BA-6583-4041-87ED-DC62E7F52B5F">
                           <p class="notep1">注意：</p>的<code class="codeph">javax.security.cert.X509Certificate</code>仅支持class与旧版本（1.0.x和1.1.x）的JSSE向后兼容。新应用程序应使用<code class="codeph">java.security.cert.X509Certificate</code>类代替。
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F" name="GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F"></a><h5 id="JSSEC-GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F" class="sect5">AlgorithmConstraints接口</h5>
                     <div>
                        <p>的<code class="codeph">java.security.AlgorithmConstraints</code>接口用于控制允许的加密算法。 <code class="codeph">AlgorithmConstraints</code>定义三个<code class="codeph">permits()</code>方法。这些方法告诉某些加密功能是否允许使用算法名称或密钥。密码功能由一组<code class="codeph">CryptoPrimitive</code> ，这是一个包含以下字段的枚举<code class="codeph">STREAM_CIPHER</code> ， <code class="codeph">MESSAGE_DIGEST</code>和<code class="codeph">SIGNATURE</code> 。
                        </p>
                        <p>因此， <code class="codeph">AlgorithmConstraints</code>实现可以回答以下问题：我可以将此密钥与该算法一起用于加密操作吗？
                        </p>
                        <p>一个<code class="codeph">AlgorithmConstraints</code>对象可以与<code class="codeph">SSLParameters</code>通过使用新对象<code class="codeph">setAlgorithmConstraints()</code>方法。目前<code class="codeph">AlgorithmConstraints</code>一个对象<code class="codeph">SSLParameters</code>使用检索对象<code class="codeph">getAlgorithmConstraints()</code>方法。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" name="GUID-651B5070-F586-4504-A6CD-8BEB2D928D47"></a><h5 id="JSSEC-GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" class="sect5">标准常量类</h5>
                     <div>
                        <p>的<code class="codeph">StandardConstants</code>类用于表示JSSE中的标准常量定义。</p>
                        <p><code class="codeph">StandardConstants.SNI_HOST_NAME</code>表示<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）</a>扩展名中的域名服务器（DNS）主机名，可在实例化<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器</a>时使用<code class="codeph">SNIServerName</code>要么<code class="codeph">SNIMatcher</code>宾语。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B" name="GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B"></a><h5 id="JSSEC-GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B" class="sect5">SNIServerName类</h5>
                     <div>
                        <p></p>
                        <p>抽象的实例<code class="codeph">SNIServerName</code>类代表<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）</a>扩展名中的<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称</a> 。它使用指定服务器名称的类型和编码值实例化。
                        </p>
                        <p>您可以使用<code class="codeph">getType()</code>和<code class="codeph">getEncoded()</code>分别返回服务器名称类型和编码的服务器名称值的副本的方法。的<code class="codeph">equals()</code>方法可用于检查某个其他对象是否与此服务器名称“相等”。的<code class="codeph">hashCode()</code>方法返回此服务器名称的哈希码值。要获取服务器名称的字符串表示形式（包括服务器名称类型和编码的服务器名称值），请使用<code class="codeph">toString()</code>方法。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-073F0493-3DB8-4388-818B-83E92021EF45" name="GUID-073F0493-3DB8-4388-818B-83E92021EF45"></a><h5 id="JSSEC-GUID-073F0493-3DB8-4388-818B-83E92021EF45" class="sect5">SNIMatcher类</h5>
                     <div>
                        <p></p>
                        <p>抽象的实例<code class="codeph">SNIMatcher</code>类对<code class="codeph">SNIServerName</code>宾语。服务器可以使用来自<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）</a>扩展名的信息来确定是否特定<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>应该接受连接。例如，当多个“虚拟”或“基于名称”的服务器托管在单个基础网络地址上时，服务器应用程序可以使用SNI信息来确定此服务器是否是客户端要访问的确切服务器。服务器可以使用此类的实例来验证特定类型的可接受服务器名称，例如主机名。
                        </p>
                        <p>的<code class="codeph">SNIMatcher</code>使用指定的服务器名称类型实例化该类，将在其上执行匹配操作。匹配给定<code class="codeph">SNIServerName</code> ， 使用<code class="codeph">matches()</code>方法。返回给定的服务器名称类型<code class="codeph">SNIMatcher</code>对象，使用<code class="codeph">getType()</code>方法。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E10158C4-E808-41B7-9958-A119927743D8" name="GUID-E10158C4-E808-41B7-9958-A119927743D8"></a><h5 id="JSSEC-GUID-E10158C4-E808-41B7-9958-A119927743D8" class="sect5">SNIHostName类别</h5>
                     <div>
                        <p></p>
                        <p>的实例<code class="codeph">SNIHostName</code>类（扩展了<code class="codeph">SNIServerName</code>类）表示<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）扩展</a>中类型为“ host_name”的服务器名称（请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="StandardConstants类用于表示JSSE中的标准常量定义。">StandardConstants类</a> ）。实例化一个<code class="codeph">SNIHostName</code> ，将服务器的全限定DNS主机名（由客户端理解）指定为<code class="codeph">String</code>论点。在以下情况下，该参数是非法的：</p>
                        <ul style="list-style-type:disc">
                           <li>参数为空。</li>
                           <li>参数以尾随句号结尾。</li>
                           <li>该参数不是符合RFC 3490规范的有效国际化域名（IDN）。</li>
                        </ul>
                        <p>您还可以实例化一个<code class="codeph">SNIHostName</code>通过将编码的主机名值指定为字节数组。此方法通常用于解析请求的SNI扩展中的编码名称值。否则，请使用<code class="codeph">SNIHostName(String hostname)</code>构造函数。的<code class="codeph">encoded</code>在以下情况下该参数是非法的：</p>
                        <ul style="list-style-type:disc">
                           <li>参数为空。</li>
                           <li>参数以尾随句号结尾。</li>
                           <li>该参数不是符合RFC 3490规范的有效国际化域名（IDN）。</li>
                           <li>该参数未以UTF-8或US-ASCII编码。</li>
                        </ul>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-E10158C4-E808-41B7-9958-A119927743D8__GUID-7C99C76D-9832-47F9-8FF8-7FD2123DE7EC">
                              <p class="notep1">注意：</p>的<code class="codeph">encoded</code>将克隆作为参数传入的字节数组，以防止后续修改。
                           </div> 
                        </div>
                        <p>返回主机的名称<code class="codeph">SNIHostName</code>使用US-ASCII编码的对象，请使用<code class="codeph">getAsciiName()</code>方法。要将服务器名称与另一个对象进行比较，请使用<code class="codeph">equals()</code>方法（比较<span class="italic">不</span>区分大小写）。返回一个的哈希码值<code class="codeph">SNIHostName</code> ， 使用<code class="codeph">hashCode()</code>方法。返回的字符串表示形式<code class="codeph">SNIHostName</code> ，包括DNS主机名，请使用<code class="codeph">toString()</code>方法。
                        </p>
                        <p>您可以创建一个<code class="codeph">SNIMatcher</code>一个对象<code class="codeph">SNIHostName</code>通过传递代表一个或多个主机名的正则表达式来匹配对象<code class="codeph">createSNIMatcher()</code>方法。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" name="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9"></a><h3 id="JSSEC-GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" class="sect3">定制JSSE</h3>
               <div>
                  <p>JSSE包含一个标准实现，可以通过插入不同的实现或指定默认的密钥库等进行自定义。</p>
                  <div class="section">
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="安全属性和可自定义项目的列表。">表8-2</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="系统属性和自定义项目的列表。">表8-3</a>总结了可以自定义的方面，默认值是什么以及用于提供自定义的机制。
                     </p>
                     <p>通过设置系统属性或“安全性属性”值可以完成某些定制。表格后面的各节说明了如何设置此类属性值。</p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__GUID-6E3ACF45-C569-4DA9-9905-08713A2D064C">
                           <p class="notep1">注意：</p>JSSE实现当前使用此表中显示的许多属性，但不能保证它们将继续具有相同的名称和类型（系统或安全性），甚至不能在将来的版本中完全存在。所有此类属性都用星号（*）标记。为了方便使用，在此处记录了它们，以便与JSSE实现一起使用。
                        </div> 
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="安全属性和可自定义项目的列表。">表8-2</a>显示了通过设置<code class="codeph">java.security.Security</code>属性。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">如何指定java.security。担保财产</a></p>
                     <div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645">
                        <p class="titleintable">表8-2安全属性和自定义项</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="安全属性和自定义项目" width="100%" border="1" summary="List of Security Properties and the customizable items." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d112429e4159">担保财产</th>
                                 <th align="left" valign="bottom" id="d112429e4161">定制物品</th>
                                 <th align="left" valign="bottom" id="d112429e4163">默认值</th>
                                 <th align="left" valign="bottom" id="d112429e4165">笔记</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4169" headers="d112429e4159 d112429e4165 "><code class="codeph">cert.provider.x509v1</code></td>
                                 <td align="left" valign="top" headers="d112429e4169 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" title="默认情况下，由X509Certificate.getInstance（）方法返回的X509Certificate实现是JSSE实现中的实现。">定制X509Certificate实现</a></td>
                                 <td align="left" valign="top" headers="d112429e4169 d112429e4163 ">Oracle的X509证书实现</td>
                                 <td align="left" valign="top" id="d112429e4183" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4187" headers="d112429e4159 d112429e4165 "><code class="codeph">security.provider.<span class="variable" translate="no">n</span></code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4187 d112429e4161 ">密码服务提供商；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" title="JDK带有JSSE加密服务提供程序，简称为SunJSSE。提供程序实质上是为特定密码算法实现一个或多个引擎类的程序包。">自定义提供程序实现</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="SunJSSE提供程序使用SunJCE实现来满足其所有加密需求。尽管建议您保留提供者的常规位置，但是可以通过在SunJCE提供者之前注册来使用其他JCA或JCE提供者的实现。">自定义加密算法提供程序</a></td>
                                 <td align="left" valign="top" headers="d112429e4187 d112429e4163 ">按优先级顺序排列的前五个提供者是：<ol>
                                       <li>太阳</li>
                                       <li>SunRsaSign</li>
                                       <li>SunEC</li>
                                       <li>SunJSSE</li>
                                       <li>SunJCE</li>
                                    </ol>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4225" headers="d112429e4159 d112429e4165 ">在中指定提供商<code class="codeph">security.provider.<span class="variable" translate="no">n</span>=</code>安全属性文件中的行，其中<code class="codeph"><span class="variable" translate="no">n</span></code>是一个等于或大于1的整数。
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4238" headers="d112429e4159 d112429e4165 ">* <code class="codeph">ssl.SocketFactory.provider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4238 d112429e4161 ">默认<code class="codeph">SSLSocketFactory</code>实作</td>
                                 <td align="left" valign="top" headers="d112429e4238 d112429e4163 "><code class="codeph">SSLSocketFactory</code> Oracle实施</td>
                                 <td align="left" valign="top" id="d112429e4252" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4256" headers="d112429e4159 d112429e4165 ">* <code class="codeph">ssl.ServerSocketFactory.provider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4256 d112429e4161 ">默认<code class="codeph">SSLServerSocketFactory</code>实作</td>
                                 <td align="left" valign="top" headers="d112429e4256 d112429e4163 "><code class="codeph">SSLServerSocketFactory</code> Oracle实施</td>
                                 <td align="left" valign="top" id="d112429e4270" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4274" headers="d112429e4159 d112429e4165 "><code class="codeph">ssl.KeyManagerFactory.algorithm</code></td>
                                 <td align="left" valign="top" headers="d112429e4274 d112429e4161 ">默认密钥管理器工厂算法名称（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">自定义默认密钥管理器和信任管理器</a> ）</td>
                                 <td align="left" valign="top" headers="d112429e4274 d112429e4163 ">太阳X509</td>
                                 <td align="left" valign="top" id="d112429e4286" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4290" headers="d112429e4159 d112429e4165 ">* <code class="codeph">jdk.certpath.disabledAlgorithms</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4290 d112429e4161 ">禁用的证书验证加密算法（请参阅“ <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="在某些环境中，使用TLS / DTLS时，某些算法或密钥长度可能不理想。 Oracle JDK使用jdk.certpath.disabledAlgorithms和jdk.tls.disabledAlgorithm安全属性在TLS / DTLS协议协商期间禁用算法，包括版本协商，密码套件选择，对等身份验证和密钥交换机制。注意，这些安全属性不能保证被其他JDK实现使用。有关这些安全属性的语法及其当前活动值的信息，请参见<java-home> /conf/security/java.security文件。">禁用和受限加密算法”</a> ）</td>
                                 <td align="left" valign="top" headers="d112429e4290 d112429e4163 ">
                                    <p>MD2，MD5，SHA1 jdkCA和使用情况TLSServer，RSA keySize <1024，DSA keySize <1024，EC keySize <224 <a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" name="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" href="#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" list="" the="" of="" restricted,="" disabled,="" and="" legacy="" algorithms="" specified="" in="" these="" security="" properties="" may="" change;="" see="" java.security="" file="" your="" jdk="" installation="" for="" latest="" values=")" ="" onclick="footdisplay(2, "><sup>英尺2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4322" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4326" headers="d112429e4159 d112429e4165 "><code class="codeph">ssl.TrustManagerFactory.algorithm</code></td>
                                 <td align="left" valign="top" headers="d112429e4326 d112429e4161 ">默认信任管理器工厂算法名称（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">自定义默认密钥管理器和信任管理器</a> ）</td>
                                 <td align="left" valign="top" headers="d112429e4326 d112429e4163 ">PKIX</td>
                                 <td align="left" valign="top" id="d112429e4338" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4342" headers="d112429e4159 d112429e4165 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="SunJSSE提供程序使用SunJCE实现来满足其所有加密需求。尽管建议您保留提供者的常规位置，但是可以通过在SunJCE提供者之前注册来使用其他JCA或JCE提供者的实现。">SunJSSE提供程序使用的JCE加密算法</a></td>
                                 <td align="left" valign="top" headers="d112429e4342 d112429e4161 ">给替代的JCE算法提供者提供比SunJCE提供者更高的优先顺序</td>
                                 <td align="left" valign="top" headers="d112429e4342 d112429e4163 ">SunJCE实施</td>
                                 <td align="left" valign="top" id="d112429e4356" headers="d112429e4159 d112429e4165 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4360" headers="d112429e4159 d112429e4165 ">
                                    <p></p>* <code class="codeph">jdk.tls.disabledAlgorithms</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4360 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="在某些环境中，使用TLS / DTLS时，某些算法或密钥长度可能不理想。 Oracle JDK使用jdk.certpath.disabledAlgorithms和jdk.tls.disabledAlgorithm安全属性在TLS / DTLS协议协商期间禁用算法，包括版本协商，密码套件选择，对等身份验证和密钥交换机制。注意，这些安全属性不能保证被其他JDK实现使用。有关这些安全属性的语法及其当前活动值的信息，请参见<java-home> /conf/security/java.security文件。">禁用和受限密码算法</a></td>
                                 <td align="left" valign="top" headers="d112429e4360 d112429e4163 ">
                                    <p>SSLv3，RC4，MD5和RSA，DH密钥大小<1024，EC密钥大小<224 <a id="fnsrc_d112429e4386" name="fnsrc_d112429e4386" href="#fnsrc_d112429e4386" list="" the="" of="" restricted,="" disabled,="" and="" legacy="" algorithms="" specified="" in="" these="" security="" properties="" may="" change;="" see="" java.security="" file="" your="" jdk="" installation="" for="" latest="" values=")" ="" onclick="footdisplay(2, "><sup>Footref 2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4388" headers="d112429e4159 d112429e4165 ">禁用不会为TLS / DTLS连接协商的特定算法（协议版本，密码套件，密钥交换机制等），即使已在应用程序中显式启用它们也是如此</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4391" headers="d112429e4159 d112429e4165 ">
                                    <p></p>*<code class="codeph">jdk.tls.legacyAlgorithms</code></td>
                                 <td align="left" valign="top" headers="d112429e4391 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" title="在某些环境中，某种算法可能是不可取的，但由于在旧版应用程序中使用而无法被禁用。仍然可以支持传统算法，但是应用程序不应使用它们，因为传统算法的安全性通常不够强。在TLS / DTLS安全参数协商期间，除非没有其他候选方法，否则不会协商旧式算法。安全属性jdk.tls.legacyAlgorithms指定Oracle JDK将哪些算法视为旧算法。 <java-home> /conf/security/java.security文件，此安全属性的语法。">旧式加密算法</a></td>
                                 <td align="left" valign="top" headers="d112429e4391 d112429e4163 ">
                                    <p>K_NULL，C_NULL，M_NULL，DH_anon，ECDH_anon，RC4_128，RC4_40，DES_CBC，DES40_CBC，3DES_EDE_CBC <a id="fnsrc_d112429e4413" name="fnsrc_d112429e4413" href="#fnsrc_d112429e4413" list="" the="" of="" restricted,="" disabled,="" and="" legacy="" algorithms="" specified="" in="" these="" security="" properties="" may="" change;="" see="" java.security="" file="" your="" jdk="" installation="" for="" latest="" values=")" ="" onclick="footdisplay(2, "><sup>Footref 2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4415" headers="d112429e4159 d112429e4165 ">指定哪些算法被视为旧算法，除非没有其他候选算法，否则不会在TLS / DTLS安全参数协商期间协商哪些算法。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4418" headers="d112429e4159 d112429e4165 "><code class="codeph">jdk.tls.server.defaultDHEParameters</code></td>
                                 <td align="left" valign="top" headers="d112429e4418 d112429e4161 ">Diffie-Hellman团体</td>
                                 <td align="left" valign="top" headers="d112429e4418 d112429e4163 ">OpenJDK TLS / DTLS实施中的安全主要Diffie-Hellman组</td>
                                 <td align="left" valign="top" id="d112429e4425" headers="d112429e4159 d112429e4165 ">为（数据报）传输层安全性（（D）TLS）处理定义默认的有限域Diffie-Hellman临时（DHE）参数</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4429" headers="d112429e4159 d112429e4165 ">*<code class="codeph">jdk.tls.keyLimits</code></td>
                                 <td align="left" valign="top" headers="d112429e4429 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" title="您可以使用jdk.tls.keyLimits安全性属性，指定算法可以使用一组特定的密钥加密的数据量的限制。一旦达到此限制，就会发送KeyUpdate握手后消息，该消息请求更新当前密钥集。此安全属性仅适用于TLS 1.3的对称密码。">数据量限制算法可能会使用一组密钥进行加密</a></td>
                                 <td align="left" valign="top" headers="d112429e4429 d112429e4163 ">AES / GCM /无填充密钥更新2 ^ 37</td>
                                 <td align="left" valign="top" id="d112429e4444" headers="d112429e4159 d112429e4165 ">限制算法可以使用一组特定的密钥加密的数据量；一旦达到此限制，就会发送KeyUpdate握手后消息，该消息请求更新当前密钥集。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4447" headers="d112429e4159 d112429e4165 ">*<code class="codeph">ocsp.enable</code></td>
                                 <td align="left" valign="top" headers="d112429e4447 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="在传输层安全性（TLS）握手期间，使用联机证书状态协议（OCSP）确定X.509证书吊销状态。">客户端驱动的OCSP和OCSP装订</a></td>
                                 <td align="left" valign="top" headers="d112429e4447 d112429e4163 ">假</td>
                                 <td align="left" valign="top" id="d112429e4459" headers="d112429e4159 d112429e4165 ">启用客户端驱动的在线证书状态协议（OCSP）。
                                    <p>您还必须启用吊销检查。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4E3834C7-E741-499E-9646-3557670FD88A" title="通过启用吊销检查并启用OCSP来启用客户端驱动的OCSP。">设置Java客户端以使用客户端驱动的OCSP</a> 。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注2</sup>这些安全属性中指定的受限，禁用和旧算法的列表可能会更改；看到<code>java.security</code> JDK安装中的文件以获取最新值。
                     </p>
                     <p>* <span>此安全性属性当前由JSSE实现使用，但不能保证其他实现会检查和使用它。如果它<span class="variable" translate="no">is</span>另一个实施检查，然后计划的执行应以同样的方式作为JSSE实现做处理。无法保证该属性在将来的发行版中将继续存在或具有相同的类型（系统或安全性）。</span></p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="系统属性和自定义项目的列表。">表8-3</a>显示通过设置自定义的项目<code class="codeph">java.lang.System</code>属性。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">如何指定java.lang。系统属性</a> 。
                     <div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591">
                        <p class="titleintable">表8-3系统属性和自定义项</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="系统属性和自定义项目" width="100%" border="1" summary="List of system properties and customized items." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d112429e4502">系统属性</th>
                                 <th align="left" valign="bottom" id="d112429e4504">定制物品</th>
                                 <th align="left" valign="bottom" id="d112429e4506">默认</th>
                                 <th align="left" valign="bottom" id="d112429e4508">笔记</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4512" headers="d112429e4502 "><code class="codeph">java.protocol.handler.pkgs</code></td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" title="您可以使用java.net的HTTPS URL方案与启用SSL的Web服务器进行安全通信。URL类。JDK提供了默认的HTTPS URL实现。">指定替代的HTTPS协议实现</a></td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4506 ">从Oracle实施</td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4530" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.keyStore</code>  
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4504 ">默认密钥库；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4508 ">价值<code class="codeph">NONE</code>可以指定。如果密钥库不是基于文件的（例如，它位于硬件令牌中），则此设置是适当的</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4550" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.keyStorePassword</code></td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4504 ">默认密钥库密码；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4508 ">
                                    <p>建议不要以其他用户可以发现的方式指定密码。</p>
                                    <p>例如，在命令行上指定密码。为确保密码安全，请在应用程序提示输入密码时，或在受适当保护的选项文件中指定密码</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4569" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.keyStoreProvider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4504 ">默认密钥库提供程序；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4587" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.keyStoreType</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4504 ">默认密钥库类型；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4506 "><code class="codeph">KeyStore.getDefaultType()</code></td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4605" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.trustStore</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4504 ">默认信任库；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4506 "><code class="codeph">jssecacerts</code> （如果存在）。
                                    <p>除此以外，<code class="codeph">cacerts</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4628" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.trustStorePassword</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4504 ">默认信任库密码；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4508 ">
                                    <p>建议不要以其他用户可以发现的方式指定密码。</p>
                                    <p>例如，在命令行上指定密码。为确保密码安全，请在应用程序提示输入密码时，或在受适当保护的选项文件中指定密码</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4648" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.trustStoreProvider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4504 ">默认信任库提供程序；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4666" headers="d112429e4502 ">* <code class="codeph">javax.net.ssl.trustStoreType</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4504 ">默认信任库类型；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4506 "><code class="codeph">KeyStore.getDefaultType()</code></td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4508 ">价值<code class="codeph">NONE</code>可以指定。如果信任库不是基于文件的（例如，它位于硬件令牌中），则此设置是适当的</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4686" headers="d112429e4502 ">*<code class="codeph">https.proxyHost</code></td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4504 ">默认代理主机</td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4699" headers="d112429e4502 ">* <code class="codeph">https.proxyPort</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4504 ">默认代理端口</td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4506 ">80</td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4713" headers="d112429e4502 ">* <code class="codeph">jsse.enableSNIExtension</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4504 ">服务器名称指示选项</td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4506 "><code class="codeph">true</code></td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4508 ">服务器名称指示（SNI）是TLS扩展，在<a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">RFC 6066中</a>定义。它启用了到虚拟服务器的TLS连接，在虚拟服务器中，具有不同网络名称的多个服务器托管在一个基础网络地址上。一些非常老的TLS供应商可能无法处理TLS扩展。在这种情况下，将此属性设置为<code class="codeph">false</code>禁用SNI扩展</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4733" headers="d112429e4502 ">*<code class="codeph">https.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4504 ">HTTPS连接的默认密码套件</td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4506 ">由插座工厂决定。</td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4508 ">
                                    <p>它包含用逗号分隔的密码套件名称列表，该列表指定允许在此密码套件上使用的密码套件<code class="codeph">HttpsURLConnection</code> 。见<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledCipherSuites(String[])</code></a>方法。请注意，此方法直接从传递给它的<span class="apiname">String</span>数组设置ClientHello密码套件的优先顺序。
                                    </p> 
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4757" headers="d112429e4502 ">*<code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY">https.protocols</code></td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4504 ">HTTPS连接的默认握手协议</td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4506 ">由插座工厂决定。</td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4508 ">
                                    <p>这包含逗号分隔的协议套件名称列表，用于指定要在其上启用的协议套件<code class="codeph">HttpsURLConnection</code> 。看到<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols(String[])</code></a></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4776" headers="d112429e4502 ">*通过自定义<code class="codeph">port</code> HTTPS URL中的字段。</td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4504 ">默认的HTTPS端口</td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4506 ">443</td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4789" headers="d112429e4502 ">*<code class="codeph">jsse.SSLEngine.acceptLargeFragments</code></td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4504 ">大型TLS数据包的默认大小调整缓冲区</td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4508 ">
                                    <p>将此系统属性设置为<code class="codeph">true</code> ， <code class="codeph">SSLSession</code>默认情况下将设置缓冲区大小以处理<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">大型数据包</a> 。这可能导致应用程序分配不必要的大数据<code class="codeph">SSLEngine</code>缓冲区。相反，应用程序应<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="SSLEngine的状态由SSLEngineResult表示。状态。">动态检查缓冲区溢出情况，</a>并适当调整缓冲区大小</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4825" headers="d112429e4502 "><code class="codeph">jdk.tls.client.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4504 ">客户端默认启用的密码套件；请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="您可以在应用程序中或使用系统属性jdk.tls.client.cipherSuites和jdk.tls.server.cipherSuites指定默认启用的密码套件。">指定默认启用的密码套件</a></td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4506 "><a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="SunJSSE支持的密码套件列表，默认情况下是启用还是禁用，以及它们引入的版本">表4-11</a> ，SunJSSE支持的密码套件</td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4508 "><span class="bold">警告</span> ：这些系统属性可用于配置弱密码套件，否则将来配置的密码套件可能会很弱。不建议您在不了解风险的情况下使用这些系统属性。
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4852" headers="d112429e4502 "><code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY">jdk.tls.client.protocols</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4504 ">TLS / DTLS客户端的默认握手协议。请参见<a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">SunJSSE提供程序</a></td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4506 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4508 ">
                                    <p>启用特定<code class="codeph">SunJSSE</code>客户端上的协议，请在引号内以逗号分隔的列表中指定它们；客户端上未启用所有其他受支持的协议</p>
                                    <div class="p">例如，<ul style="list-style-type:disc">
                                          <li>
                                             <p>如果<code class="codeph">jdk.tls.client.protocols=</code><code class="codeph">"TLSv1,TLSv1.1"</code> ，则启用了客户端上TLSv1和TLSv1.1的默认协议设置，而未启用SSLv3，TLSv1.2，TLSv1.3和SSLv2Hello</p>
                                          </li>
                                          <li>
                                             <p>如果<code class="codeph">jdk.tls.client.protocols="DTLSv1.2"</code> ，则启用了客户端上DTLS1.2的协议设置，而未启用DTLS1.0</p>
                                          </li>
                                       </ul>
                                    </div>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4887" headers="d112429e4502 "><code class="codeph">jdk.tls.server.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4504 ">服务器端默认启用的密码套件。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="您可以在应用程序中或使用系统属性jdk.tls.client.cipherSuites和jdk.tls.server.cipherSuites指定默认启用的密码套件。">指定默认启用的密码套件</a></td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4506 "><a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="SunJSSE支持的密码套件列表，默认情况下是启用还是禁用，以及它们引入的版本">表4-11</a> ，SunJSSE支持的密码套件</td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4508 "><span class="bold">警告</span> ：这些系统属性可用于配置弱密码套件，否则将来配置的密码套件可能会很弱。不建议您在不了解风险的情况下使用这些系统属性。
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4914" headers="d112429e4502 "><code class="codeph">jdk.tls.server.protocols</code></td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4504 ">TLS / DTLS服务器的默认握手协议。请参见<a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">SunJSSE提供程序</a></td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4506 ">没有</td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4508 ">
                                    <p>要在SunJSSE提供程序的服务器端配置默认启用的协议套件，请在引号内以逗号分隔的列表中指定协议。</p>
                                    <p>此列表中的协议是标准SSL协议名称，如<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称中所述</a> 。
                                    </p>
                                    <p>请注意，此系统属性仅影响默认协议套件（算法SSL，TLS和DTLS的SSLContext）。如果应用程序使用特定于版本的SSLContext（SSLv3，TLSv1，TLSv1.1，TLSv1.2，TLSv1.3，DTLSv1.0或DTLSv1.2），或显式设置启用的协议版本，则此系统属性不会产生影响。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4935" headers="d112429e4502 "><code class="codeph">jdk.tls.ephemeralDHKeySize</code></td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" title="在TLS / DTLS连接中，握手期间可能在内部使用临时Diffie-Hellman（DH）密钥。SunJSSE提供程序提供了一种灵活的方法，可以在TLS / DTLS握手期间自定义临时DH密钥大小的强度。">自定义临时Diffie-Hellman键的大小</a></td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4506 ">1024位</td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4950" headers="d112429e4502 "><code class="codeph">jdk.tls.namedGroups</code></td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4504 ">
                                    <p>自定义支持的命名组以进行TLS / DTLS密钥交换</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4506 ">
                                    <p>如果未定义此系统属性或值为空，则将使用实现默认组和首选项。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4508 ">
                                    <p>它在启用的命名组的引号中按优先顺序包含一个逗号分隔的列表。例如：</p>
                                    <p><code class="codeph">jdk.tls.namedGroups="secp521r1,secp256r1, ffdhe2048"</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4967" headers="d112429e4502 "><code class="codeph">jsse.enableMFLNExtension</code></td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" title="为了协商较小的最大片段长度，客户端可以选择在ClientHello消息中包括类型为max_fragment_length的扩展名。系统属性jsse.enableMFLNExtension可用于为TLS / DTLS启用或禁用MFLN扩展。">自定义最大片段长度协商（MFLN）扩展</a></td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4506 ">假</td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4508 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4988" headers="d112429e4502 "><code class="codeph">jsse.enableFFDHEExtension</code></td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4504 ">
                                    <p>启用或禁用TLS / DTLS密钥交换的有限域Diffie-Hellman临时（FFDHE）参数</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4506 ">真正</td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4508 ">
                                    <p>FFDHE是<a href="https://tools.ietf.org/html/rfc7919" target="_blank">RFC 7919中</a>定义的TLS / DTLS扩展。它使TLS / DTLS连接可以使用已知的有限域Diffie-Hellman组。一些非常老的TLS供应商可能无法处理TLS扩展。在这种情况下，将此属性设置为false可禁用FFDHE扩展。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e5004" headers="d112429e4502 ">*<code class="codeph">com.sun.net.ssl.checkRevocation</code></td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4504 ">吊销检查</td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4506 ">假</td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4508 ">您必须启用吊销检查才能启用客户端驱动的OCSP。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="在传输层安全性（TLS）握手期间，使用联机证书状态协议（OCSP）确定X.509证书吊销状态。">客户端驱动的OCSP和OCSP装订</a> 。
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>* <span>JSSE实现当前使用此系统属性，但不能保证其他实现会检查和使用它。如果它<span class="variable" translate="no">is</span>另一个实施检查，然后计划的执行应以同样的方式作为JSSE实现做处理。无法保证该属性在将来的发行版中将继续存在或具有相同的类型（系统或安全性）。</span></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363" name="GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363"></a><h4 id="JSSEC-GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363" class="sect4">如何指定一个java.lang。系统属性</h4>
                  <div>
                     <p></p>
                     <div class="section">您可以通过设置系统属性来自定义JSSE的某些方面。有几种方法可以设置这些属性：</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>要静态设置系统属性，请使用<code class="codeph">-D</code>的选项<code class="codeph">java</code>命令。例如，要运行名为MyApp的应用程序并设置<code class="codeph">javax.net.ssl.trustStore</code>系统属性，以指定一个名为MyCacertsFile的信任库。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">truststore</a> 。输入以下内容：</span><div><pre class="codeblock"><code>
        java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
                
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>要动态设置系统属性，请调用<code class="codeph">java.lang.System.setProperty()</code>您代码中的方法：</span><div><pre class="codeblock"><code>
        System.setProperty("<span class="variable" translate="no">propertyName</span>", "<span class="variable" translate="no">propertyValue</span>");
                
</code></pre></div>
                           <div>例如，一个<code class="codeph">setProperty()</code>调用与上一个示例相对应的设置<code class="codeph">javax.net.ssl.trustStore</code>系统属性以指定一个名为“ <code class="codeph">MyCacertsFile</code> “ 将会：<pre class="codeblock"><code>
        System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");
                
</code></pre></div>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6" name="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6"></a><h4 id="JSSEC-GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6" class="sect4">如何指定一个java.security。担保财产</h4>
                  <div>
                     <p></p>
                     <div class="section">您可以通过设置“安全性属性”来自定义JSSE的某些方面。您可以静态或动态设置安全属性：</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>要静态设置安全属性，请在安全属性文件中添加一行。安全属性文件位于<code><span class="variable" translate="no">java-home</span>/conf/security/java.security</code></span><div>
                              <dl>
                                 <dt class="dlterm"><a name="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6__GUID-548CD27A-7959-4905-8A44-EA4F9CE36641"><!-- --></a> <span class="variable" translate="no">java-home</span></dt>
                                 <dd>查看<a href="terms-and-definitions.html" title="以下是常用的密码术术语及其定义。">术语和定义</a></dd>
                              </dl>
                              <p>要在安全属性文件中指定安全属性值，请添加以下格式的行：</p> <pre class="codeblock"><code><span class="variable" translate="no">propertyName</span>=<span class="variable" translate="no">propertyValue</span>
</code></pre> </div>
                           <div>
                              <p>例如，假设您要指定与默认SunX509不同的密钥管理器工厂算法名称。通过将算法名称指定为名为“安全性属性”的值来执行此操作<code class="codeph">ssl.KeyManagerFactory.algorithm</code> 。例如，要将值设置为MyX509，请将以下行添加到安全属性文件中：</p> <pre class="codeblock"><code>ssl.KeyManagerFactory.algorithm=MyX509
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>要动态设置安全属性，请调用<code class="codeph">java.security.Security.setProperty</code>代码中的方法：</span><div><pre class="codeblock"><code>Security.setProperty("<span class="variable" translate="no">propertyName</span>," "<span class="variable" translate="no">propertyValue</span>");
</code></pre></div>
                           <div>例如，调用<code class="codeph">setProperty()</code>与前面指定密钥管理器工厂算法名称的示例相对应的方法是：<pre class="codeblock"><code>Security.setProperty("ssl.KeyManagerFactory.algorithm", "MyX509");
</code></pre></div>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" name="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B"></a><h4 id="JSSEC-GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" class="sect4">定制X509Certificate实现</h4>
                  <div>
                     <p>X509Certificate实现由<code class="codeph">X509Certificate.getInstance()</code>方法是默认情况下来自JSSE实现的实现。
                     </p>
                     <div class="section">导致返回不同的实现：</div>
                     <!-- class="section" -->
                     <div class="section">将另一个实现的类的名称（和包）指定为“ <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">如何指定java.security”的值。安全属性</a>命名为<code class="codeph">cert.provider.x509v1</code> 。
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B__GUID-79B9F37D-F567-454A-AD1C-7CEDD90571EE">例如，如果该类被调用<code class="codeph">MyX509CertificateImpl</code>它出现在<code class="codeph">com.cryptox</code>软件包，则应将以下行添加到安全属性文件中：<pre class="codeblock"><code>
    cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" name="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB"></a><h4 id="JSSEC-GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" class="sect4">指定默认启用的密码套件</h4>
                  <div>
                     <p>您可以在应用程序中或通过系统属性指定默认启用的密码套件<code class="codeph">jdk.tls.client.cipherSuites</code>和<code class="codeph">jdk.tls.server.cipherSuites</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-02A9D641-DC20-473E-8C89-6BBC11F59960">
                        <p class="notep1">注意：</p>启用的密码套件的实际使用受到算法约束的限制。
                     </div>
                     <p>默认情况下要启用的密码套件集由以下一种方式按此优先顺序确定：</p>
                     <ol>
                        <li>由应用程序明确设置</li>
                        <li>由系统属性指定</li>
                        <li>由JSSE提供程序默认值指定</li>
                     </ol>
                     <p>例如，在应用程序中显式设置默认启用的密码套件会覆盖在中指定的设置。 <code class="codeph">jdk.tls.client.cipherSuites</code>要么<code class="codeph">jdk.tls.server.cipherSuites</code>以及JSSE提供程序的默认设置。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-C5542CBE-3EEB-4E9B-9772-2BF71110A0FC">通过应用明确设置</p>
                        <p>您可以使用以下方法之一来设置启用哪些密码套件：</p>
                        <ul style="list-style-type:disc">
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLSocket.setEnabledCipherSuites（String []）</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLEngine.setEnabledCipherSuites（String []）</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLServerSocket.setEnabledCipherSuites（String []）</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters（String [] cipherSuites）</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters（String [] cipherSuites，String []协议）</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters.setCipherSuites（String []）</span></a></li>
                           <li><code class="codeph">https.cipherSuites</code> <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">HttpsURLConnection的</span></a>系统属性</li>
                        </ul>    
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-EC7E69C3-7443-409D-B4F0-9B96C08808C9">由系统属性指定</p>
                        <p>系统属性<code class="codeph">jdk.tls.client.cipherSuites</code>在客户端指定默认启用的密码套件； <code class="codeph">jdk.tls.server.cipherSuites</code>指定服务器端的那些。
                        </p>
                        <p>这两个系统属性的值的语法是受支持的密码套件名称的逗号分隔列表。这些属性中指定的无法识别或不受支持的密码套件名称将被忽略。有关标准JSSE密码套件名称的信息，请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法</a> 。
                        </p>
                        <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-7976F3A1-6661-423E-9226-61DCF6E45E1F">
                           <p class="notep1">注意：</p>Oracle JDK和OpenJDK当前支持这些系统属性。不保证其他JDK实现也支持它们。
                        </div>
                        <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-0AD1FE03-21D2-45CF-9E2C-9CC06C8D6F5C">
                           <p class="notep1">警告：</p>这些系统属性可用于配置弱密码套件，否则将来配置的密码套件可能会很弱。不建议您在不了解风险的情况下使用这些系统属性。
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-7B4C4C0A-73C7-46B2-9730-41E68CE9AC30">由JSSE提供程序默认值指定</p>
                        <p>每个JSSE提供程序都有其自己的默认启用的密码套件。有关<a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">SunJSSE提供</a> <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">程序</a>支持的密码套件名称以及默认情况下启用的密码套件名称，请参见<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK提供程序文档</a>中的SunJSSE提供程序。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" name="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77"></a><h4 id="JSSEC-GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" class="sect4">指定替代的HTTPS协议实现</h4>
                  <div>
                     <p>您可以使用HTTPS URL方案与启用SSL的Web服务器安全地通信， <code class="codeph">java.net.URL</code>类。JDK提供了默认的HTTPS URL实现。
                     </p>
                     <p>如果要使用替代HTTPS协议实现，请设置<code class="codeph">java.protocol.handler.pkgs</code> <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">如何指定一个java.lang。系统属性</a>以包括新的类名称。此操作将导致在JDK默认类之前找到并加载指定的类。有关详细信息，请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">URL</span></a>类。
                     </p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77__GUID-E9529FD8-897B-4783-8470-001332442275">
                           <p class="notep1">注意：</p>在过去的JSSE版本中，您必须设置<code class="codeph">java.protocol.handler.pkgs</code> JSSE安装期间的系统属性。除非您要获取以下内容的实例，否则不再需要此步骤<code class="codeph">com.sun.net.ssl.HttpsURLConnection</code> 。
                        </div> 
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" name="GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1"></a><h4 id="JSSEC-GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" class="sect4">定制提供者实施</h4>
                  <div>
                     <p>在JDK配备了JSSE加密服务提供程序，或<span class="variable" translate="no">provider</span>的简称，命名SunJSSE。提供程序实质上是为特定密码算法实现一个或多个引擎类的程序包。
                     </p>
                     <p>JSSE引擎类是<code class="codeph">SSLContext</code> ， <code class="codeph">KeyManagerFactory</code>和<code class="codeph">TrustManagerFactory</code> 。请参阅《 <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java密码体系结构（JCA）参考指南》</a>以了解有关提供程序和引擎类的更多信息。
                     </p>
                     <p>在使用提供者之前，必须以静态或动态方式注册提供者。您不需要注册SunJSSE提供程序，因为它已预先注册。如果要使用其他提供程序，请阅读以下各节以了解如何注册它们。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59723547-D466-44C9-B066-EC5098B508E6" name="GUID-59723547-D466-44C9-B066-EC5098B508E6"></a><h4 id="JSSEC-GUID-59723547-D466-44C9-B066-EC5098B508E6" class="sect4">静态注册密码提供程序</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>通过在安全属性文件中添加以下形式的行来静态注册提供程序： <code class="codeph"><span class="codeinlineitalic"><java-home></span>/conf/security/java.security</code> ：</p><pre class="codeblock"><code>security.provider.<span class="variable" translate="no">n</span>=<span class="variable" translate="no">provName</span>|<span class="variable" translate="no">className</span> 
</code></pre><p>这将声明提供程序，并指定其优先顺序<code class="codeph"><span class="variable" translate="no">n</span></code> 。优先顺序是当没有特定提供者被请求时，在提供者中搜索所请求算法的顺序。订单基于1； 1是最优选的，其次是2，依此类推。
                        </p>
                        <p><code class="codeph"><span class="variable" translate="no">provName</span></code>是提供者的名称， <code class="codeph"><span class="variable" translate="no">className</span></code>是提供者的完全合格的类名称。
                        </p>
                        <p>标准安全提供者会在以下位置自动为您注册<code class="codeph">java.security</code>安全属性文件。
                        </p>
                        <p>要使用其他JSSE提供程序，请添加一条注册该其他提供程序的行，并根据您的喜好给予其优先顺序。</p>
                        <p>您可以同时注册多个JSSE提供程序。注册的提供程序可能包括针对不同引擎类的不同算法的不同实现，或者它们可能支持某些或所有相同类型的算法和引擎类。当搜索针对特定算法的特定引擎类实现时，如果没有为搜索指定特定提供程序，则将按优先顺序搜索这些提供程序，并使用来自提供该指定算法的实现的第一提供程序的实现。</p>
                        <p>请参阅<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">实现和集成提供</a> <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">程序</a>的<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">步骤中的</a> <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置提供</a> <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">程序</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A" name="GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A"></a><h4 id="JSSEC-GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A" class="sect4">动态注册密码服务提供者</h4>
                  <div>
                     <p>您可以通过在<span class="apiname">Security</span>类中调用<span class="apiname">addProvider</span>或<span class="apiname">insertProviderAt</span>方法在运行时动态添加提供程序，而无需静态注册提供程序。请注意，这种类型的注册不是永久性的，只能通过授予<code class="codeph">insertProvider.<span class="variable" translate="no"><provider name></span></code>允许。
                     </p>
                     <div class="section">请参阅<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">实现和集成提供</a> <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">程序</a>的<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">步骤中的</a> <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供程序，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供程序。">步骤8.1：配置提供</a> <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">程序</a> 。
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA" name="GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA"></a><h4 id="JSSEC-GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA" class="sect4">提供商配置</h4>
                  <div>
                     <p></p>
                     <p>一些提供程序可能需要配置。这是通过使用<code class="codeph">configure</code>的方法<code class="codeph">Provider</code>类，然后再调用<code class="codeph">addProvider</code>的方法<code class="codeph">Security</code>类。有关示例，请参见<a href="pkcs11-reference-guide1.html#GUID-C4ABFACB-B2C9-4E71-A313-79F881488BB9">SunPKCS11配置</a> 。的<code class="codeph">Provider.configure()</code>该方法是Java SE 9的新功能。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58" name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58"></a><h4 id="JSSEC-GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58" class="sect4">为特定算法配置首选提供程序</h4>
                  <div>
                     <p>在中指定特定算法的首选提供程序<code class="codeph">jdk.security.provider.preferred</code>安全属性。通过指定首选提供程序，您可以配置提供程序以提高特定算法的性能，但不是其他算法性能最佳的提供程序。使用以下命令指定的有序提供程序列表<code class="codeph">security.provider.n</code>属性不足以订购提供特定算法性能提升的提供商，但不能订购其他算法性能最佳的提供商。配置提供者列表的顺序以实现性能提升需要更大的灵活性。
                     </p>
                     <div class="section">
                        <p>的<code class="codeph">jdk.security.provider.preferred</code>通过“安全性属性”，可以在访问注册的提供程序列表之前，从一组首选的提供程序中选择特定的算法或服务类型。请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">如何指定java.security。担保物</a> 。
                        </p>
                        <p>的<code class="codeph">jdk.security.provider.preferred</code>安全属性不注册提供程序。订购提供者列表必须使用以下命令<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-59723547-D466-44C9-B066-EC5098B508E6">静态注册加密提供者</a> <code class="codeph">security.provider.n</code>属性。任何未注册的提供程序都将被忽略。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-F7D026FC-ED27-4EE6-BC7B-E38147595E77">指定算法的首选提供程序</p>
                        <p>用于在中指定首选提供程序字符串的语法<code class="codeph">jdk.security.provider.preferred</code>安全属性是逗号分隔的列表<code class="codeph">ServiceType.Algorithm:Provider</code></p>
                        <p>使用以下语法：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A708BC0D-1E9B-4CA3-B30A-3765E2E886EA"><!-- --></a>服务类型</dt>
                           <dd>
                              <p>服务类型的名称（例如： <code class="codeph">"MessageDigest"</code> ）。ServiceType是可选的。如果未指定，则该算法适用于所有服务类型。
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-B68E7DD5-A337-4754-9BB7-3D4D406A4AC0"><!-- --></a>算法</dt>
                           <dd>
                              <p>标准算法名称。请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。可以将算法指定为完整标准名称（AES / CBC / PKCS5Padding）或部分指定（AES，AES / CBC，AES // PKCS5Padding）。
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-92F5CD6E-C1BC-44A1-996F-9E00A0EDAC23"><!-- --></a>提供者</dt>
                           <dd>
                              <p>提供者的名称。未在注册列表中列出的任何提供程序都将被忽略。请参见<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK提供程序</a> 。
                              </p>
                           </dd>
                        </dl>包含错误（例如解析错误）的条目将被忽略。使用命令<code class="codeph">java -Djava.security.debug=jca</code>调试错误。
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-B0BE646D-CEBB-4721-95BA-DDA285763F0C">首选提供商和FIPS</p>
                        <p>如果您将FIPS提供程序添加到<code class="codeph">security.provider.n</code>属性，并在中指定首选的提供者顺序<code class="codeph">jdk.security.provider.preferred</code>属性，然后在中指定的首选提供者<code class="codeph">jdk.security.provider.preferred</code>首先选择。
                        </p>
                        <p>因此，建议您不要配置<code class="codeph">jdk.security.provider.preferred</code> FIPS提供程序配置的属性。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-BC021D8E-0B67-4B11-8EDA-295C89132AA4">jdk.security.provider.preferred默认值</p>
                        <p>的<code class="codeph">jdk.security.provider.preferred</code>属性默认情况下未设置，仅用于应用程序性能调整。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A00A625D-2596-41C8-BA38-21C71416A1B2">
                        <p class="titleinexample">示例8-16示例jdk.security.provider.preferred属性</p>
                        <p>用于指定<code class="codeph">jdk.security.provider.preferred</code>属性如下：</p>
                        <p><code class="codeph">jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, MessageDigest.SHA-256:SUN</code></p>
                        <div class="p">使用以下语法：<dl>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-28C00AE0-A9A6-45AE-A743-823716638A8D"><!-- --></a>服务类型</dt>
                              <dd>信息摘要</dd>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-205A4B26-295A-4488-8B2F-5E47C4219023"><!-- --></a>算法</dt>
                              <dd>AES / GCM /无填充，SHA-256</dd>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-05DD7678-1FFD-425E-AE6E-EAFD4619E880"><!-- --></a>提供者</dt>
                              <dd>SunJCE，太阳</dd>
                           </dl>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150" name="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150"></a><h4 id="JSSEC-GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150" class="sect4">自定义默认密钥库和信任库，商店类型和商店密码</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>每当默认<code class="codeph">SSLSocketFactory</code>要么<code class="codeph">SSLServerSocketFactory</code>已创建（通过调用<code class="codeph">SSLSocketFactory.getDefault</code>要么<code class="codeph">SSLServerSocketFactory.getDefault</code> ），以及该默认值<code class="codeph">SSLSocketFactory</code> （要么<code class="codeph">SSLServerSocketFactory</code> ）来自JSSE参考实现（默认<code class="codeph">SSLContext</code>与套接字工厂关联。（默认的套接字工厂将来自JSSE实现。）
                        </p>
                        <p>这个预设<code class="codeph">SSLContext</code>用默认值初始化<code class="codeph">KeyManager</code>和默认<code class="codeph">TrustManager</code> 。如果密钥库由<code class="codeph">javax.net.ssl.keyStore</code>系统属性和适当的<code class="codeph">javax.net.ssl.keyStorePassword</code>系统属性（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">如何指定java.lang。系统属性</a> ），然后<code class="codeph">KeyManager</code>默认创建<code class="codeph">SSLContext</code>将是<code class="codeph">KeyManager</code>用于管理指定密钥库的实现。（实际实现将按照“ <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">自定义默认密钥管理器和信任管理器”中的指定</a> 。）如果未指定此类系统属性，则由<code class="codeph">KeyManager</code>将是一个新的空密钥库。
                        </p>
                        <p>通常，在握手中充当服务器的对等方将为其KeyManager需要一个密钥库，以便获得用于对客户端进行身份验证的凭据。但是，如果选择了一个匿名密码套件，则服务器的<code class="codeph">KeyManager</code>不需要密钥库。并且，除非服务器要求客户端身份验证，否则充当客户端的对等方不需要<code class="codeph">KeyManager</code>密钥库。因此，在这些情况下，如果没有可以<code class="codeph">javax.net.ssl.keyStore</code>系统属性值已定义。
                        </p>
                        <p>同样，如果信任库是由<code class="codeph">javax.net.ssl.trustStore</code>系统属性，然后<code class="codeph">TrustManager</code>默认创建<code class="codeph">SSLContext</code>将是<code class="codeph">TrustManager</code>用于管理指定信任库的实现。在这种情况下，如果存在这样的属性，但指定的文件不存在，则不使用信任库。如果不<code class="codeph">javax.net.ssl.trustStore</code>属性存在，然后搜索默认信任库。如果一个信任库名为<code><span class="variable" translate="no">java-home</span>/lib/security/jssecacerts</code>被发现，它被使用。如果不是，则一个名为<code><span class="variable" translate="no">java-home</span>/lib/security/cacerts</code>搜索并使用（如果存在）。最后，如果仍然找不到信任库，则由<code class="codeph">TrustManager</code>将是一个新的空信任库。
                        </p>
                        <div class="infoboxnote" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-D83B4C21-5CFE-4043-B74A-0AE5D5EF9F1A">
                           <p class="notep1">注意：</p>
                           <p>JDK随附了有限数量的受信任的根证书。 <code>java-home/lib/security/cacerts</code>文件。如<span id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__JSWOR"><cite>Java Platform，Standard Edition Tools Reference</cite></span>中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a>中所述<span id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__JSWOR"><cite>，</cite></span>如果您将此文件用作信任库，则有责任维护（即添加和删除）此文件中包含的证书。
                           </p>
                           <p>根据您联系的服务器的证书配置，您可能需要添加其他根证书。从适当的供应商处获取所需的特定根证书。</p>
                        </div> 
                        <p>如果<code class="codeph">javax.net.ssl.keyStoreType</code>和/或<code class="codeph">javax.net.ssl.keyStorePassword</code>还指定了系统属性，然后将其视为默认属性<code class="codeph">KeyManager</code>密钥库类型和密码。如果未指定任何类型，则默认类型为<code class="codeph">KeyStore.getDefaultType()</code>方法，即<code class="codeph">keystore.type</code>安全属性，如果未指定此类安全属性，则为“ jks”。如果未指定密钥库密码，则将其假定为空白字符串“”。
                        </p>
                        <p>同样，如果<code class="codeph">javax.net.ssl.trustStoreType</code>和/或<code class="codeph">javax.net.ssl.trustStorePassword</code>还指定了系统属性，然后将它们分别视为默认的信任库类型和密码。如果未指定任何类型，则默认类型为<code class="codeph">KeyStore.getDefaultType()</code>方法。如果未指定信任库密码，则假定该密码为空白字符串“”。
                        </p>
                        <div class="infoboxnote" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-C6D20FF5-6487-4F16-8A53-FC954900DDD1">
                           <p class="notep1">注意：</p>本节描述了当前的JSSE参考实现行为。本节中描述的系统属性不能保证继续具有相同的名称和类型（系统或安全性），甚至不能在将来的版本中完全存在。也不能保证它们可以被任何其他JSSE实现检查和使用。如果它们<span class="variable" translate="no">are</span>由实现方式检查，则该实现应该处理它们以相同的方式作为参考JSSE实现确实，如本文所述。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2" name="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2"></a><h4 id="JSSEC-GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2" class="sect4">自定义默认密钥管理器和信任管理器</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>如<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码中所述</a> ，每当默认<code class="codeph">SSLSocketFactory</code>要么<code class="codeph">SSLServerSocketFactory</code>已创建，并且此默认值<code class="codeph">SSLSocketFactory</code> （要么<code class="codeph">SSLServerSocketFactory</code> ）来自JSSE参考实现（默认<code class="codeph">SSLContext</code>与套接字工厂关联。
                        </p>
                        <p>这个预设<code class="codeph">SSLContext</code>用初始化<code class="codeph">KeyManager</code>和一个<code class="codeph">TrustManager</code> 。的<code class="codeph">KeyManager</code>和/或<code class="codeph">TrustManager</code>提供给默认<code class="codeph">SSLContext</code>如前述部分所述，将是用于管理指定的密钥库或信任库的实现。
                        </p>
                        <p>的<code class="codeph">KeyManager</code>选择的实现方式是先检查<code class="codeph">ssl.KeyManagerFactory.algorithm</code> <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">担保物</a> 。如果指定了这样的属性值，则<code class="codeph">KeyManagerFactory</code>搜索指定算法的实现。使用来自第一个提供程序的提供者的实现。它的<code class="codeph">getKeyManagers()</code>调用方法以确定<code class="codeph">KeyManager</code>提供默认值<code class="codeph">SSLContext</code> 。从技术上讲<code class="codeph">getKeyManagers()</code>返回一个数组<code class="codeph">KeyManager</code>对象，一个<code class="codeph">KeyManager</code>每种关键材料。如果未指定此类安全属性值，则使用SunX509的默认值执行搜索。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-D15B5C94-B4CF-4B9F-8C02-998660542B84">
                              <p class="notep1">注意：</p>一种<code class="codeph">KeyManagerFactory</code> SunXSE提供程序提供了SunX509算法的实现。的<code class="codeph">KeyManager</code>它指定的是一个<code class="codeph">javax.net.ssl.X509KeyManager</code>实施。
                           </div> 
                        </div>
                        <p>同样， <code class="codeph">TrustManager</code>选择的实现方式是先检查<code class="codeph">ssl.TrustManagerFactory.algorithm</code>安全属性。如果指定了这样的属性值，则<code class="codeph">TrustManagerFactory</code>搜索指定算法的实现。使用来自第一个提供程序的提供者的实现。它的<code class="codeph">getTrustManagers()</code>调用方法以确定<code class="codeph">TrustManager</code>提供默认值<code class="codeph">SSLContext</code> 。从技术上讲<code class="codeph">getTrustManagers()</code>返回一个数组<code class="codeph">TrustManager</code>对象，一个<code class="codeph">TrustManager</code>每种类型的信托材料。如果未指定此类安全属性值，那么将使用PKIX的默认值执行搜索。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-F1C8A2E0-258D-4164-8DC7-51E303FD09D9">
                              <p class="notep1">注意：</p>一种<code class="codeph">TrustManagerFactory</code> SunJSSE提供程序提供了PKIX算法的实现。的<code class="codeph">TrustManager</code>它指定的是一个<code class="codeph">javax.net.ssl.X509TrustManager</code>实施。
                           </div>
                        </div>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-053952E0-5D14-45BF-897A-9C6A561DE975">
                              <p class="notep1">注意：</p>本节描述了当前的JSSE参考实现行为。本节中描述的系统属性不能保证继续具有相同的名称和类型（系统或安全性），甚至不能在将来的版本中完全存在。也不能保证它们可以被任何其他JSSE实现检查和使用。如果它们<span class="variable" translate="no">are</span>由实现方式检查，则该实现应该处理它们以相同的方式作为参考JSSE实现确实，如本文所述。
                           </div> 
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0A438179-32A7-4900-A81C-29E3073E1E90" name="GUID-0A438179-32A7-4900-A81C-29E3073E1E90"></a><h4 id="JSSEC-GUID-0A438179-32A7-4900-A81C-29E3073E1E90" class="sect4">禁用和受限密码算法</h4>
                  <div>
                     <p>在某些环境中，使用TLS / DTLS时，某些算法或密钥长度可能不理想。Oracle JDK使用<code class="codeph">jdk.certpath.disabledAlgorithms</code>和<code class="codeph">jdk.tls.disabledAlgorithm</code>安全属性，用于在TLS / DTLS协议协商期间禁用算法，包括版本协商，密码套件选择，对等身份验证和密钥交换机制。注意，这些安全属性不能保证被其他JDK实现使用。见<code><span class="variable" translate="no"><java-home></span>/conf/security/java.security</code>文件，以获取有关这些安全属性的语法及其当前活动值的信息。
                     </p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p> <span class="bold"><code class="codeph">jdk.certpath.disabledAlgorithms</code>属性</span> ： <span class="apiname">CertPath</span>代码使用<code class="codeph">jdk.certpath.disabledAlgorithms</code>安全属性，用于确定在<span class="apiname">CertPath</span>检查期间不允许使用的算法。例如，当TLS服务器发送标识证书链时，使用<span class="apiname">CertPath</span>实现来验证接收到的链的客户端<span class="apiname">TrustManager</span>将不允许所述条件。例如，以下行将阻止所有基于MD2的证书以及链接到信任的锚的SHA1 TLSServer证书，这些锚已预先安装在<code>cacaerts</code>密钥库。同样，此行会阻止任何少于1024位的RSA密钥。
                              </p><pre class="pre codeblock"><code>jdk.certpath.disabledAlgorithms=MD2, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024</code></pre></li>
                           <li>
                              <p><span class="bold"><code class="codeph">jdk.tls.disabledAlgorithms</code>属性</span> ： <span class="apiname">SunJSSE</span>代码使用<code class="codeph">jdk.tls.disabledAlgorithms</code>安全属性，用于禁用TLS / DTLS协议，密码套件，密钥等。语法类似于<code class="codeph">jdk.certpath.disabledAlgorithms</code>安全属性。例如，以下行禁用SSLv3算法和所有TLS _ * _ RC4_ *密码套件：</p><pre class="pre codeblock"><code>jdk.tls.disabledAlgorithms=SSLv3, RC4</code></pre></li>
                        </ul>
                        <p>如果需要特定条件，可以通过以下方法重新激活它：删除“安全性”属性中的关联值。 <code>java.security</code>文件或在初始化JSSE之前动态设置适当的安全性属性。
                        </p>
                        <p>请注意，这些安全属性有效地创建了第三组密码套件，即“禁用”。以下列表描述了这三组：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">禁用</span> ：如果密码套件在禁用列表中包含任何组件（例如RC4）（例如，在<code class="codeph">jdk.tls.disabledAlgorithms</code>安全性”），那么该密码套件将被禁用，并且<span class="bold">不会</span>被视为连接握手。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">已启用</span> ：将考虑用于连接的特定密码套件的列表。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">未启用</span> ：将<span class="bold">不</span>被视为连接的非禁用密码套件的列表。要重新启用这些密码套件，请调用适当的<span class="apiname">setEnabledCipherSuites（）</span>或<span class="apiname">setSSLParameters（）</span>方法。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" name="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1"></a><h4 id="JSSEC-GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" class="sect4">旧式加密算法</h4>
                  <div>
                     <p>在某些环境中，某种算法可能是不可取的，但由于在旧版应用程序中使用而无法被禁用。仍然可以支持传统算法，但是应用程序不应使用它们，因为传统算法的安全性通常不够强。在TLS / DTLS安全参数协商期间，除非没有其他候选方法，否则不会协商旧式算法。安全财产<code class="codeph">jdk.tls.legacyAlgorithms</code>指定Oracle JDK将哪些算法视为旧算法。 <code class="codeph"><span class="variable" translate="no"><java-home></span>/conf/security/java.security</code>此安全属性的语法的文件。
                     </p>
                     <div class="infoboxnote" id="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1__GUID-A538AD87-EC24-4BED-8AA1-1FA33AF6F75A">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果传统算法也通过<code class="codeph">jdk.tls.disabledAlgorithms</code>财产或<code class="codeph">java.security.AlgorithmConstraints</code> API（请参见方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setAlgorithmConstraints(java.security.AlgorithmConstraints)" target="_blank"><code class="codeph">javax.net.ssl.SSLParameters.setAlgorithmConstraints</code></a> ），则该算法将被完全禁用，并且无法协商。
                              </p>
                           </li>
                           <li>
                              <p>如果您的应用程序使用“安全性”属性中指定的算法<code class="codeph">jdk.tls.legacyAlgorithms</code> ，尽快使用替代算法；未来的JDK版本可能会将传统算法指定为受限算法。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-316FB978-7588-442E-B829-B4973DB3B584" name="GUID-316FB978-7588-442E-B829-B4973DB3B584"></a><h4 id="JSSEC-GUID-316FB978-7588-442E-B829-B4973DB3B584" class="sect4">自定义加密算法提供程序</h4>
                  <div>
                     <p>SunJSSE提供程序使用SunJCE实现来满足其所有加密需求。尽管建议您保留提供者的常规位置，但是可以通过在SunJCE提供者<span class="italic">之前</span>注册来使用其他JCA或JCE提供者的实现。
                     </p>
                     <div class="section">
                        <p>可通过安全属性文件静态地使用标准JCA机制（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">如何请求和提供提供程序实现</a> ）来配置提供程序。 <code class="codeph"><span class="variable" translate="no"><java-home></span>/conf/security/java.security</code> ，或通过<code class="codeph">addProvider()</code>要么<code class="codeph">insertProviderAt()</code>中的方法<code class="codeph">java.security.Security</code>类。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" name="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D"></a><h4 id="JSSEC-GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" class="sect4">自定义临时Diffie-Hellman键的大小</h4>
                  <div>
                     <p>在TLS / DTLS连接中，握手期间可能在内部使用临时Diffie-Hellman（DH）密钥。SunJSSE提供程序提供了一种灵活的方法，可以在TLS / DTLS握手期间自定义临时DH密钥大小的强度。</p>
                     <div class="section">
                        <p>大小小于1024位的Diffie-Hellman（DH）密钥由于强度不足而被弃用。您可以使用system属性自定义临时DH密钥大小<code class="codeph">jdk.tls.ephemeralDHKeySize</code> 。此系统属性不会影响DH密钥大小<code class="codeph">ServerKeyExchange</code>可导出密码套件的消息。它仅影响JSSE Oracle提供程序中基于DHE_RSA，DHE_DSS和DH_anon的密码套件。
                        </p>
                        <p>您可以为此属性指定以下值之一：</p>
                        <ul style="list-style-type:disc">
                           <li>未定义：大小为1024位的DH密钥将始终用于不可导出的密码套件。这是此属性的默认值。</li>
                           <li><code class="codeph">legacy</code> ：JSSE Oracle提供程序保留了JDK 7和更早版本的旧行为（例如，使用大小为512位和768位的临时DH密钥）。
                           </li>
                           <li><code class="codeph">matched</code>注意：对于不可导出的匿名密码套件，ServerKeyExchange消息中的DH密钥大小为1024位。对于（不可导出密码套件的）基于X.509证书的身份验证，将使用与相应身份验证密钥匹配的DH密钥大小，但该大小必须介于1024位和2048位之间。例如，如果身份验证证书的公共密钥大小为2048位，则临时DH密钥大小应为2048位，除非密码套件可导出。这种密钥大小调整方案可以使认证密钥和密钥交换密钥之间的加密强度保持一致。
                           </li>
                           <li>一个有效的整数，介于1024和2048之间（包括1024和2048）：指定值的固定临时DH密钥大小（以位为单位）将用于不可导出的密码套件。</li>
                        </ul>
                        <p>下表总结了系统属性的每个可能值的最小和最大可接受DH密钥大小<code class="codeph">jdk.tls.ephemeralDHKeySize</code> ：</p>
                        <div class="tblformal" id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D__GUID-16528793-4333-4BC2-928E-787DFD2C1BA2">
                           <p class="titleintable">表8-4系统属性的DH密钥大小<code class="codeph">jdk.tls.ephemeralDHKeySize</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="系统属性的DH密钥大小jdk.tls.ephemeralDHKeySize" width="100%" border="1" summary="The table summaries the minimum and maximum acceptable DH key sizes for each of the possible values for the system property jdk.tls.ephemeralDHKeySize." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6212">jdk.tls.ephemeralDHKeySize的值</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6214">未定义</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6216">遗产</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6218">匹配的</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6220">整数值（固定）</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6224" headers="d112429e6212 ">可导出的DH密钥大小</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6214 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6216 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6218 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6220 ">512</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6235" headers="d112429e6212 ">不可导出的匿名密码套件</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6214 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6216 ">768</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6218 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6220 ">固定密钥的大小由有效的整数属性值指定，该值必须介于1024和2048之间（包括此值）。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6246" headers="d112429e6212 ">认证证书</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6214 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6216 ">768</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6218 ">
                                       <p>密钥大小与身份验证证书相同，但必须在1024位和2048位之间（包括两端）。但是，SunJCE提供程序支持的唯一的DH密钥大小大于1024位是2048位。</p>
                                       <p>因此，您只能使用值1024或2048。</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6220 ">固定密钥的大小由有效的整数属性值指定，该值必须介于1024和2048之间（包括此值）。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" name="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36"></a><h4 id="JSSEC-GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" class="sect4">自定义最大片段长度协商（MFLN）扩展</h4>
                  <div>
                     <p>为了协商较小的最大片段长度，客户端可以选择包括类型扩展名<code>max_fragment_length</code>在ClientHello消息中。系统属性<code class="codeph">jsse.enableMFLNExtension</code> ，可用于为TLS / DTLS启用或禁用MFLN扩展。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-205DC9FA-8FF1-4204-A93B-F98AD1970E8F">最大片段长度协商</p>
                        <p>由于内存限制或带宽限制，受约束的TLS / DTLS客户端可能希望协商较小的最大片段长度。为了协商较小的最大片段长度，客户端可以选择包括类型扩展名<code>max_fragment_length</code>在（扩展的）ClientHello消息中。参见<a href="http://www.rfc-base.org/txt/rfc-6066.txt" target="_blank">RFC 6066</a> 。
                        </p>
                        <p>成功协商最大片段长度后，TLS / DTLS客户端和服务器可以立即开始对消息（包括握手消息）进行片段化，以确保不会发送大于协商长度的片段。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-75708E4F-E271-4F51-8631-8FF8006A8257">系统属性jsse.enableMFLNExtension</p>
                        <p>系统属性<code class="codeph">jsse.enableMFLNExtension</code>定义为启用或禁用MFLN扩展。的<code class="codeph">jsse.enableMFLNExtension</code>默认情况下处于禁用状态。
                        </p>
                        <p>可以如下设置系统属性的值：</p>
                        <div class="tblformal" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-A6CDBCFE-D1FB-4CF8-84A4-C764B31CB09F">
                           <p class="titleintable">表8-5 jsse.enableMFLNExtension系统属性</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="jsse.enableMFLNExtension系统属性" width="100%" border="1" summary="List of possible values provided for the jsse.enableMFLNExtension system property." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d112429e6311">系统属性</th>
                                    <th align="left" valign="bottom" id="d112429e6313">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d112429e6317" headers="d112429e6311 "><code class="codeph">jsse.enableMFLNExtension</code> =真</td>
                                    <td align="left" valign="top" headers="d112429e6317 d112429e6313 ">启用MFLN扩展。如果返回值<code class="codeph">SSLParameters.getMaximumPacketSize()</code>小于（2 <sup>12</sup> +标头大小）的最大片段长度协商扩展将启用。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d112429e6330" headers="d112429e6311 "><code class="codeph">jsse.enableMFLNExtension</code> =假</td>
                                    <td align="left" valign="top" headers="d112429e6330 d112429e6313 ">禁用MFLN扩展名。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3C9ADC85-E82C-421E-808D-F06028838F47" name="GUID-3C9ADC85-E82C-421E-808D-F06028838F47"></a><h4 id="JSSEC-GUID-3C9ADC85-E82C-421E-808D-F06028838F47" class="sect4">配置最大和最小数据包大小</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setMaximumPacketSize-int-" target="_blank"><span class="apiname">SSLParameters.setMaximumPacketSize</span></a>方法设置TLS / DTLS记录的最大预期网络数据包大小（以字节为单位）。
                        </p>
                        <p>建议数据包的大小不小于256个字节，以使较小的握手消息（例如HelloVerifyRequests）不会被分段。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946"></a><h4 id="JSSEC-GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" class="sect4">数据量限制算法可能会使用一组密钥进行加密</h4>
                  <div>
                     <p>您可以使用一组特定的密钥来指定算法可以加密的数据量限制<code class="codeph">jdk.tls.keyLimits</code>安全属性。一旦达到此限制，就会发送KeyUpdate握手后消息，该消息请求更新当前密钥集。此安全属性仅适用于TLS 1.3的对称密码。
                     </p>
                     <p>此属性的语法如下：</p><pre class="pre codeblock"><code>jdk.tls.keyLimits=<span class="variable" translate="no">KeyLimit</span> { , <span class="variable" translate="no">KeyLimit</span> }</code></pre><dl>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-6ABF816F-3121-4CB7-99E7-B8DF02E7EEB4"><!-- --></a>密钥限制</dt>
                        <dd><pre class="pre codeblock"><code><span class="variable" translate="no">AlgorithmName</span> KeyUpdate <span class="variable" translate="no">Length</span></code></pre></dd>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-7921656C-AEC5-4551-81E3-3C75F0970E36"><!-- --></a>算法名称</dt>
                        <dd>完整的算法转换</dd>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-ED46F79E-11D4-4E92-8F61-3402AD26612A"><!-- --></a>长度</dt>
                        <dd>发送KeyUpdate消息之前，会话中的加密数据量。例如，此值可以是字节形式的整数值，也可以是2的幂。 <code class="codeph">2^37</code> 。
                        </dd>
                     </dl>
                     <p>例如，以下指定一旦算法AES / GCM / NoPadding对2 <sup>37</sup>个字节进行加密，就发送KeyUpdate消息：</p><pre class="pre codeblock"><code>jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" name="GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86"></a><h4 id="JSSEC-GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" class="sect4">客户端驱动的OCSP和OCSP装订</h4>
                  <div>
                     <p>在传输层安全性（TLS）握手期间，使用联机证书状态协议（OCSP）确定X.509证书吊销状态。</p>
                     <div class="p">如果有理由认为证书被盗用，则可以通过颁发证书的证书颁发机构（CA）撤销TLS中使用的X.509证书。您可以使用以下方法之一检查TLS握手期间证书的吊销状态。
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">证书吊销列表（CRL）</span> ：CRL是吊销证书的简单列表。接收证书的应用程序从CRL服务器获取CRL，并检查接收到的证书是否在列表中。使用CRL有两个缺点，这意味着可以撤销证书：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>CRL可能会变得非常大，因此网络流量可能会大大增加。</p>
                                 </li>
                                 <li>
                                    <p>创建的许多CRL具有更长的有效期，这增加了证书在该有效期内被撤销并且直到下一次CRL刷新才会显示的可能性。</p>
                                 </li>
                              </ul>
                              <p>请参阅《 <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="Java认证路径API由用于处理认证路径的类和接口组成，这些类和接口也称为认证链。如果认证路径满足某些验证规则，则可以使用它来安全地建立公共密钥到主题的映射。">Java PKI程序员指南》中的</a> <a href="java-pki-programmers-guide.html#GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" title="Java认证路径API包括CertStore类，用于从存储库中检索证书和CRL。">证书/ CRL存储类</a> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">客户端驱动的OCSP</span> ：在客户端驱动的OCSP中，客户端使用OCSP与OCSP响应者联系以检查证书的吊销状态。所需的数据量通常少于CRL，并且OCSP响应者的吊销状态可能比CRL更新。连接到服务器的每个客户端都需要针对每个检查的证书的OCSP响应。如果服务器是一种流行的服务器，并且许多客户端都在使用客户端驱动的OCSP，则这些OCSP请求可能会对OCSP响应程序的性能产生负面影响。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">OCSP装订</span> ：OCSP装订使服务器（而不是客户端）可以向OCSP响应者发出请求。服务器将OCSP响应装订到证书，并在TLS握手期间将其返回给客户端。这种方法使证书的提供者（而不是颁发CA）能够承担提供OCSP响应的资源成本。它还使服务器能够缓存OCSP响应并将其提供给所有客户端。这可以大大减轻OCSP响应程序的负担，因为响应可以由服务器（而不是每个客户端）进行缓存和定期刷新。
                              </p>
                           </li>
                        </ul> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1" name="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1"></a><h5 id="JSSEC-GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1" class="sect5">客户端驱动的OCSP和证书吊销</h5>
                     <div>
                        <p>客户端驱动的在线证书状态协议（OCSP）使客户端可以在传输层安全性（TLS）握手期间连接到OCSP响应程序来检查证书吊销状态。</p>
                        <p>在客户端从服务器接收并验证证书之后，客户端驱动的OCSP请求就会在TLS握手期间发生。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1__GUID-BA910957-12B8-4ABC-B812-8689DA5B68F4">客户端驱动OCSP的TLS握手</p>
                           <p>在客户端和服务器之间的TLS握手期间，使用客户端驱动的OCSP来检查服务器证书吊销状态。客户端收到证书后，它将执行证书验证。如果验证成功，则客户端将验证证书未被发行者吊销。这是通过向OCSP响应者发送OCSP请求来完成的。客户端收到OCSP响应后，将在完成TLS握手之前检查此响应。</p>
                           <p>通常，客户端通过在证书的授权信息访问（AIA）扩展中查找OCSP响应者的URL，但是可以通过使用系统属性将其设置为静态URL。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-4E3834C7-E741-499E-9646-3557670FD88A" name="GUID-4E3834C7-E741-499E-9646-3557670FD88A"></a><h6 id="JSSEC-GUID-4E3834C7-E741-499E-9646-3557670FD88A" class="sect6">设置Java客户端以使用客户端驱动的OCSP</h6>
                        <div>
                           <p>通过启用吊销检查并启用OCSP来启用客户端驱动的OCSP。</p>
                           <div class="p">要将Java客户端配置为使用客户端驱动的OCSP，必须已将Java客户端设置为使用TLS连接到服务器。</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>启用吊销检查。您可以通过两种不同的方式来执行此操作。</span><ul>
                                    <li>设置系统属性<code class="codeph">com.sun.net.ssl.checkRevocation</code>至<code class="codeph">true</code> 。
                                    </li>
                                    <li>使用<code class="codeph">setRevocationEnabled</code>方法开启<code class="codeph">PKIXParameters</code> 。请参见<a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="PKIXParametersClass类指定由PKIX认证路径验证算法定义的输入参数集。它还包括一些其他有用的参数。">PKIXParameters类</a> 。
                                    </li>
                                 </ul>
                              </li>
                              <li class="stepexpand"><span>启用客户端驱动的OCSP：</span><div>
                                    <p>设置安全性属性<code class="codeph">ocsp.enable</code>至<code class="codeph">true</code> 。
                                    </p>
                                 </div>
                              </li>
                           </ol>
                           <div class="section">这两个步骤都是必需的。的<code class="codeph">ocsp.enable</code>除非启用了吊销检查，否则此设置无效。
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-489366D5-635A-4204-8980-3FB126047C45" name="GUID-489366D5-635A-4204-8980-3FB126047C45"></a><h5 id="JSSEC-GUID-489366D5-635A-4204-8980-3FB126047C45" class="sect5">OCSP装订和证书吊销</h5>
                     <div>
                        <p>联机证书状态协议（OCSP）装订使证书的提供者（而不是签发证书颁发机构（CA））承担提供包含证书吊销状态的OCSP响应的资源成本。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-AFCEC2A1-F72C-4598-AF5E-4FD0FA912A15">带OCSP装订的TLS握手</p>
                           <p>客户端和服务器之间的传输层安全性（TLS）握手期间使用OCSP装订，以检查服务器证书吊销状态。服务器向OCSP响应者发出OCSP请求，并将OCSP响应装订到返回给客户端的证书上。通过让服务器向OCSP响应者发出请求，可以缓存响应，然后将其多次用于许多客户端。</p>
                           <p>接收带有订正OCSP响应的证书的客户端验证每个证书，然后在继续握手之前检查OCSP响应。如果从客户端的角度来看，如果缺少服务器对证书的订制OCSP响应，则如果满足以下条件，则客户端将尝试使用客户端驱动的OCSP或证书吊销列表（CRL）获取吊销信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>通过<a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXParameters.html#setRevocationEnabled(boolean)" target="_blank"><span class="apiname">PKIXParameters.setRecovcationEnabled</span></a>方法将RevocationEnabled标志设置为true。
                                 </p>
                              </li>
                              <li>
                                 <p>通过将<span class="apiname">ocsp.enable</span>安全属性设置为true可以启用OCSP检查。
                                 </p>
                              </li>
                           </ul>
                           <p>在吊销检查期间，OCSP检查与CRL结合使用。请参阅<a href="java-pki-programmers-guide.html#GUID-E6E737DB-4000-4005-969E-BCD0238B1566" title="Client-side support for the On-Line Certificate Status Protocol (OCSP) as defined in RFC 2560 is supported.">《</a> <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="Java认证路径API由用于处理认证路径的类和接口组成，这些类和接口也称为认证链。如果认证路径满足某些验证规则，则可以使用它来安全地建立公共密钥到主题的映射。">Java PKI程序员指南》中的</a> <a href="java-pki-programmers-guide.html#GUID-E6E737DB-4000-4005-969E-BCD0238B1566" title="支持RFC 2560中定义的对在线证书状态协议（OCSP）的客户端支持。">附录C：OCSP支持</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-601E4E6D-6F48-4301-BFF2-346BCCB48536">状态请求与多个状态请求</p>
                           <p>OCSP装订功能实现了TLS证书状态请求扩展（ <a href="http://tools.ietf.org/html/rfc6066" target="_blank">RFC 6066的</a>第8部分）和多证书状态请求扩展（ <a href="http://tools.ietf.org/html/rfc6961" target="_blank">RFC 6961</a> ）。
                           </p>
                           <p>TLS证书状态请求扩展名仅请求证书链中服务器证书的吊销信息，而“多个证书状态请求扩展名”请求证书链中所有证书的吊销信息。在仅将服务器证书的吊销信息发送给客户端的情况下，可以使用证书吊销列表（CRL）或客户端驱动的OCSP来验证链中的其他证书（但是需要设置客户端以执行此操作） ）。</p>
                           <p>尽管TLS允许服务器也请求客户端的证书，但是OCSP装订中没有任何规定可以使客户端联系适当的OCSP响应者并将装订响应添加到发送给服务器的证书。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-EF6F03FD-1BFA-4848-AB3D-6A3CA98ED14D">OCSP请求和响应</p>
                           <p>OCSP请求和响应消息通常通过未加密的HTTP发送。该响应由CA签名。</p>
                           <p>如有必要，可以通过调用<code class="codeph">getStatusResponses</code>上的方法<code class="codeph">ExtendedSSLSession</code>宾语。方法签名为：</p><pre class="pre codeblock"><code>public List&lt;byte[]&gt; getStatusResponses();</code></pre><p>OCSP响应使用可分辨编码规则（DER）编码，格式由<a href="http://tools.ietf.org/html/rfc6960" target="_blank">RFC 6960中</a>的ASN.1描述。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-F15D190D-85A1-4012-8FE3-060DBD90E579" name="GUID-F15D190D-85A1-4012-8FE3-060DBD90E579"></a><h6 id="JSSEC-GUID-F15D190D-85A1-4012-8FE3-060DBD90E579" class="sect6">设置Java客户端以使用OCSP装订</h6>
                        <div>
                           <p>通过设置系统属性，可以在客户端启用联机证书状态协议（OCSP）装订<code class="codeph">jdk.tls.client.enableStatusRequestExtension</code>至<code class="codeph">true</code> （其默认值）。
                           </p>
                           <div class="p">要配置Java客户端以使用服务器返回的证书中钉的OCSP响应，必须已将Java客户端设置为使用TLS连接到服务器，并且必须将服务器设置为将OCSP响应装订为证书，它返回TLS握手的一部分。</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>在客户端上启用OCSP装订：</span><div>
                                    <p>如有必要，设置系统属性<code class="codeph">jdk.tls.client.enableStatusRequestExtension</code>至<code class="codeph">true</code> 。
                                    </p>
                                 </div>
                              </li>
                              <li class="stepexpand"><span>启用吊销检查。您可以通过两种不同的方式来执行此操作。</span><ul>
                                    <li>设置系统属性<code class="codeph">com.sun.net.ssl.checkRevocation</code>至<code class="codeph">true</code> 。您可以从命令行或代码中执行此操作。
                                    </li>
                                    <li>使用<code class="codeph">setRevocationEnabled</code>上的方法<code class="codeph">PKIXParameters</code>类。请参见<a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="PKIXParametersClass类指定由PKIX认证路径验证算法定义的输入参数集。它还包括一些其他有用的参数。">PKIXParameters类</a> 。
                                    </li>
                                 </ul>
                                 <div>
                                    <p>为了使客户端在证书验证中包括从服务器接收的装订响应，必须将吊销检查设置为<code class="codeph">true</code> 。如果吊销检查未设置为<code class="codeph">true</code> ，则无论撤销信息的存在或状态如何，都将允许进行连接</p>
                                 </div>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62" name="GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62"></a><h6 id="JSSEC-GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62" class="sect6">设置Java服务器以使用OCSP装订</h6>
                        <div>
                           <p>通过设置系统属性在服务器上启用在线证书状态协议（OCSP）装订<code class="codeph">jdk.tls.server.enableStatusRequestExtension</code>至<code class="codeph">true</code> 。（设置为<code class="codeph">false</code>默认。）
                           </p>
                           <div class="p">以下步骤可用于配置Java服务器以连接到OCSP响应器，并将OCSP响应装订到要返回给客户端的证书。必须已经将Java服务器设置为使用TLS响应客户端。</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>在服务器上启用OCSP装订：</span><div>
                                    <p>设置系统属性<code class="codeph">jdk.tls.server.enableStatusRequestExtension</code>至<code class="codeph">true</code> 。
                                    </p>
                                 </div>
                              </li>
                              <li class="stepexpand"><strong>可选：</strong> <span>根据需要设置其他属性。有关有效属性的列表，请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" title="本主题列出了使用联机证书状态协议（OCSP）时设置各种属性的效果。它显示了客户端驱动的OCSP和OCSP装订中使用的属性。">OCSP装订配置属性</a> 。</span></li>
                           </ol>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" name="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37"></a><h5 id="JSSEC-GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" class="sect5">OCSP装订配置属性</h5>
                     <div>
                        <p>本主题列出了使用联机证书状态协议（OCSP）时设置各种属性的效果。它显示了客户端驱动的OCSP和OCSP装订中使用的属性。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-80804982-7A97-4698-A8C4-79246BD5BFCC">服务器端属性</p>
                           <p>大多数属性在以下位置读取<code class="codeph">SSLContext</code>实例化时间。这意味着，如果您设置属性，则必须获取新的<code class="codeph">SSLContext</code>对象，以便<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>从中获得的对象<code class="codeph">SSLContext</code>对象将反映属性设置。一个例外是<code class="codeph">jdk.tls.stapling.responseTimeout</code>属性。该属性在<code class="codeph">ServerHandshaker</code>对象已创建（基本上是在<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>对象被创建）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="tblformalwide" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-B67B52FB-CD64-48FC-9552-23E929727680">
                              <p class="titleintable">表8-6服务器端OCSP装订属性</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="服务器端OCSP装订属性" width="100%" border="1" summary="This table shows the properties that can be set for the server in OCSP stapling. Only the first property jdk.tls.server.enableStatusRequestExtension, is needed to enable OCSP stapling." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="45%" id="d112429e6787">属性</th>
                                       <th align="left" valign="bottom" width="40%" id="d112429e6789">描述</th>
                                       <th align="left" valign="bottom" width="15%" id="d112429e6791">默认值</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6795" headers="d112429e6787 "><code class="codeph">jdk.tls.server.enableStatusRequestExtension</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6795 d112429e6789 ">为OCSP装订启用服务器端支持。</td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6795 d112429e6791 ">假</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6803" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responseTimeout</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6803 d112429e6789 ">
                                          <p>控制服务器将用于获取OCSP响应的最长时间（无论是从缓存还是通过与OCSP响应者联系）。</p>
                                          <p>已经收到的回复将在<code class="codeph">CertificateStatus</code>消息（如果适用）基于完成的装订类型。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6803 d112429e6791 ">5000（整数值，以毫秒为单位）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6817" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.cacheSize</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6817 d112429e6789 ">
                                          <p>控制条目中的最大高速缓存大小。</p>
                                          <p>如果缓存已满，并且需要缓存新的响应，那么最近使用最少的缓存条目将被新的缓存条目替代。此属性的值为零或更少表示高速缓存在可包含的响应数上没有上限。</p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6817 d112429e6791 ">256个物件</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6828" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.cacheLifetime</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6828 d112429e6789 ">
                                          <p>控制缓存的响应的最大寿命。</p>
                                          <p>如果响应的<span class="bold">nextUpdate</span>字段的过期时间早于缓存的生存期，则响应的生存期可能会比使用此属性设置的值短。此属性的值为零或更少将禁用高速缓存生存期。如果对象没有<span class="bold">nextUpdate</span>值，并且禁用了缓存寿命，那么将不会缓存响应。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6828 d112429e6791 ">3600秒（1小时）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6845" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responderURI</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6845 d112429e6789 ">
                                          <p>如果用于TLS的证书没有颁发机构信息访问（AIA）扩展名，则使管理员能够设置默认URI。</p>
                                          <p>除非<code class="codeph">jdk.tls.stapling.responderOverride</code>属性已设置。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6845 d112429e6791 ">没有设置</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6859" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responderOverride</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6859 d112429e6789 ">
                                          <p>启用通过<code class="codeph">jdk.tls.stapling.responderURI</code>属性以覆盖任何AIA扩展名值。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6859 d112429e6791 ">假</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6871" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.ignoreExtensions</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6871 d112429e6789 ">
                                          <p>禁用转发中指定的OCSP扩展<code class="codeph">status_request</code>要么<code class="codeph">status_request_v2</code> TLS扩展。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6871 d112429e6791 ">假</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-379CDCDD-5E02-4D98-A0D1-0583B903AB50">客户端设置</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="tblformal" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-F7BC7AEB-8918-40C7-AA80-E0CF554FD1F3">
                              <p class="titleintable">表8-7 OCSP装订中使用的客户端设置</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="OCSP装订中使用的客户端设置" border="1" summary="This table shows the effects of different settings of PKIXBuilderParameters and the checkRevocation property (assume OCSP stapling is enabled in both the client and server)." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" id="d112429e6901">PKIXBuilderParameters</th>
                                       <th align="left" valign="bottom" id="d112429e6903">checkRevocation属性</th>
                                       <th align="left" valign="bottom" id="d112429e6905">PKIXRevocationChecker</th>
                                       <th align="left" valign="bottom" id="d112429e6907">结果</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6911" headers="d112429e6901 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6903 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6905 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6907 ">吊销检查已禁用。</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6920" headers="d112429e6901 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6903 ">真正</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6905 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6907 ">吊销检查已启用。 <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6932" headers="d112429e6901 ">实例化</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6903 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6905 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6907 ">吊销检查已启用。 <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6944" headers="d112429e6901 ">实例化</td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6903 ">默认</td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6905 ">实例化，添加到<code class="codeph">PKIXBuilderParameters</code>宾语。
                                       </td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6907 ">启用了吊销检查， <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a>将根据<code class="codeph">PKIXRevocationChecker</code>设置。
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">脚注1请注意，只有当<code class="codeph">ocsp.enable</code>安全属性设置为<code class="codeph">true</code> 。
                           </p>
                           <p>开发人员在如何处理通过OCSP装订提供的响应方面具有一定的灵活性。OCSP装订不会更改证书路径检查和吊销检查中涉及的当前方法。这意味着可以让客户端和服务器都声明<code class="codeph">status_request</code>扩展，通过以下方式获取OCSP响应： <code class="codeph">CertificateStatus</code>消息，并在如何对吊销信息做出响应或缺少吊销信息方面为用户提供了灵活性。
                           </p>
                           <p>如果不<code class="codeph">PKIXBuilderParameters</code>由调用方提供，则禁用吊销检查。如果呼叫者创建了一个<code class="codeph">PKIXBuilderParameters</code>对象并使用<code class="codeph">setRevocationEnabled</code>启用吊销检查的方法，然后将评估装订的OCSP响应。如果<code class="codeph">com.sun.net.ssl.checkRevocation</code>属性设置为<code class="codeph">true</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6" name="GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6"></a><h3 id="JSSEC-GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6" class="sect3">硬件加速和智能卡支持</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>Java密码体系结构（JCA）是一组软件包，它们为加密，密钥生成和密钥协议以及消息认证代码（MAC）算法提供了框架和实现。（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java密码体系结构（JCA）参考指南</a> 。）SunJSSE提供程序仅将JCA用于其所有加密操作，并且可以自动利用JCE功能和增强功能，包括JCA对RSA <a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-11-cryptographic-token-interface-standard.htm" target="_blank">PKCS＃11</a>的支持。此支持使SunJSSE提供程序可以使用硬件加密加速器来显着改善性能，并可以使用智能卡作为密钥存储来在密钥和信任管理中提供更大的灵活性。 。
                     </p>
                     <p>如果已将JCA配置为使用Oracle PKCS＃11提供程序，而该硬件又被配置为使用基础加速器硬件，则硬件加密加速器的使用是自动的。必须在提供程序列表中的任何其他JCA提供程序之前配置该提供程序。有关如何配置Oracle PKCS＃11提供程序的详细信息，请参见《 <a href="pkcs11-reference-guide1.html#GUID-30E98B63-4910-40A1-A6DD-663EAF466991">PKCS＃11参考指南》</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE" name="GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE"></a><h4 id="JSSEC-GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE" class="sect4">配置JSSE以将智能卡用作密钥库和信任库</h4>
                  <div>
                     <p></p>
                     <p>通过JCA中对PKCS＃11的支持，还可以访问智能卡作为密钥库。有关如何配置JSSE使用的密钥库的类型和位置的详细信息，请参见“ <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE包含一个标准实现，可以通过插入不同的实现或指定默认的密钥库等进行自定义。">定制JSSE”</a> 。要将智能卡用作密钥库或信任库，请设置<code class="codeph">javax.net.ssl.keyStoreType</code>和<code class="codeph">javax.net.ssl.trustStoreType</code>系统属性分别为<code class="codeph">pkcs11</code> ，然后设置<code class="codeph">javax.net.ssl.keyStore</code>和<code class="codeph">javax.net.ssl.trustStore</code>系统属性分别为<code class="codeph">NONE</code> 。要指定使用特定提供程序，请使用<code class="codeph">javax.net.ssl.keyStoreProvider</code>和<code class="codeph">javax.net.ssl.trustStoreProvider</code>系统属性（例如，将它们设置为<code class="codeph">SunPKCS11-joe</code> ）。通过使用这些属性，您可以配置以前依赖于这些属性的应用程序来访问基于文件的密钥库以使用智能卡密钥库，而无需对该应用程序进行任何更改。
                     </p>
                     <p>一些应用程序要求以编程方式使用密钥库。这些应用程序可以继续使用现有的API实例化一个<code class="codeph">Keystore</code>并将其传递给其关键经理和信任经理。如果<code class="codeph">Keystore</code>实例引用由智能卡支持的PKCS＃11密钥库，则JSSE应用程序将有权访问智能卡上的密钥。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB" name="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB"></a><h4 id="JSSEC-GUID-C236C41B-54CA-4095-986B-7C62BBC419FB" class="sect4">多个动态密钥库</h4>
                  <div>
                     <p>智能卡（和其他可移动令牌）对<code class="codeph">X509KeyManager</code> 。在Java应用程序的生存期内，智能卡读取器中可以存在不同的智能卡，并且可以使用不同的密码来保护它们。
                     </p>
                     <p>的<a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Builder.html" target="_blank"><code class="codeph">KeyStore.Builder</code></a>类抽象了a的构造和初始化<code class="codeph">KeyStore</code>宾语。它支持使用<code class="codeph">CallbackHandler</code>用于提示密码，其子类可用于支持应用程序所需的其他功能。例如，可以实现<code class="codeph">Builder</code>允许个人<code class="codeph">KeyStore</code>用不同的密码保护的条目。的<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/KeyStoreBuilderParameters.html" target="_blank"><code class="codeph">KeyStoreBuilderParameters</code></a>然后可以使用类来初始化<code class="codeph">KeyManagerFactory</code>使用其中一个或多个<code class="codeph">Builder</code>对象。
                     </p>
                     <p>一种<code class="codeph">X509KeyManager</code> SunJSSE提供程序中名为NewSunX509的实现支持这些参数。如果有多个证书可用，它将尝试选择具有适当密钥用法的证书，并且首选有效证书而不是过期证书。
                     </p>
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">例8-17</a>说明了如何告诉JSSE同时使用PKCS＃11密钥库（可能又使用智能卡）和基于PKCS＃12文件的密钥库。
                     </p>
                     <div class="example" id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">
                        <p class="titleinexample">示例8-17使用基于文件的PKCS＃11和PKCS＃12的示例代码</p><pre class="codeblock"><code>import javax.net.ssl.*;
import java.security.KeyStore.*;
// ...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
    new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
    new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams = new KeyStoreBuilderParameters(
    Arrays.asList(new Builder[] { scBuilder, fsBuilder }) );

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF" name="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF"></a><h3 id="JSSEC-GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF" class="sect3">其他密钥库格式（PKCS12）</h3>
               <div>
                  <p></p>
                  <p><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs12-personal-information-exchange-syntax-standard.htm" target="_blank">PKCS＃12（个人信息交换语法标准）</a>指定了一种便携式格式，用于存储和/或传输用户的私钥，证书，其他机密和其他项目。SunJSSE提供程序提供了PKCS12的完整实现<code class="codeph">java.security.KeyStore</code>用于读取和写入PKCS12文件的格式。其他用于导入和导出密钥和证书的工具箱和应用程序也支持此格式，例如Mozilla Firefox，Microsoft Internet Explorer和OpenSSL。例如，这些实现可以使用.p12文件扩展名将客户端证书和密钥导出到文件中。
                  </p>
                  <p>使用SunJSSE提供程序，您可以通过以下方式访问PKCS12密钥： <code class="codeph">KeyStore</code>密钥库类型为PKCS12的API。此外，您可以使用以下命令列出已安装的密钥和关联的证书<code class="codeph">keytool</code>用命令<code class="codeph">-storetype</code>选项设置为<code class="codeph">pkcs12</code> 。请参阅《 <span id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF__JSWOR"><cite>Java平台标准版工具参考》中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> 。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F" name="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F"></a><h3 id="JSSEC-GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F" class="sect3">服务器名称指示（SNI）扩展</h3>
               <div>
                  <p></p>
                  <p>SNI扩展是一项功能，它扩展了TLS / DTLS协议，以指示客户端在握手过程中尝试连接的服务器名称。服务器可以使用服务器名称指示信息来确定是否特定<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>实例应接受连接。例如，当多个虚拟服务器或基于名称的服务器托管在单个基础网络地址上时，服务器应用程序可以使用SNI信息来确定此服务器是否是客户端要访问的确切服务器。服务器可以使用此类的实例来验证特定类型的可接受服务器名称，例如主机名。请参阅<a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">TLS扩展（RFC 6066）的</a>第3节。
                  </p>
                  <p>客户端应用程序的开发人员可以使用来显式设置服务器名称指示<code class="codeph">SSLParameters.setServerNames(List<SNIServerName> serverNames)</code>方法。参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">示例8-18</a> 。
                  </p>
                  <p>服务器应用程序的开发人员可以使用<code class="codeph">SNIMatcher</code>类来决定如何识别服务器名称指示。<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">例8-19</a>和<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">例8-20</a>说明了此功能：</p>
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">
                     <p class="titleinexample">示例8-18用于设置服务器名称指示的示例代码</p>
                     <p>以下代码示例说明如何使用方法<span class="apiname">SSLParameters.setServerNames（List <sniservername>serverNames）</sniservername></span>设置服务器名称指示：</p><pre class="pre codeblock"><code>SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">
                     <p class="titleinexample">示例8-19使用SSLSocket类识别SNI的示例代码</p>
                     <p>以下代码示例说明了服务器应用程序如何使用<code class="codeph">SNIMatcher</code>决定如何识别服务器名称指示的类：</p><pre class="codeblock"><code>SSLSocket sslSocket = sslServerSocket.accept();

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslSocket.setSSLParameters(params);
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">
                     <p class="titleinexample">示例8-20使用SSLServerSocket类识别SNI的示例代码</p>
                     <p>以下代码示例说明了服务器应用程序如何使用<code class="codeph">SNIMatcher</code>决定如何识别服务器名称指示的类：</p><pre class="codeblock"><code>
 
SSLServerSocket sslServerSocket = ...;

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslServerSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslServerSocket.setSSLParameters(params);

SSLSocket sslSocket = sslServerSocket.accept();
</code></pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>以下列表提供了有关行为的示例<code class="codeph">SNIMatcher</code>在ClientHello消息中收到各种服务器名称指示请求时：</p>
                     <ul style="list-style-type:disc">
                        <li> 
                           <p>匹配器配置为<code class="codeph">www\\.example\\.com</code> ：</p> 
                           <ul style="list-style-type:disc">
                              <li>如果请求的主机名是<code class="codeph">www.example.com</code> ，那么它将被接受并在ServerHello消息中发送确认。
                              </li>
                              <li>如果请求的主机名是<code class="codeph">www.example.org</code> ，那么它将被拒绝<code class="codeph">unrecognized_name</code>致命错误。
                              </li>
                              <li>如果没有请求的主机名或该主机名为空，则将接受该请求，但不会在ServerHello消息中发送确认。</li>
                           </ul> 
                        </li>
                        <li> 
                           <p>匹配器配置为<code class="codeph">www\\.invalid\\.com</code> ：</p> 
                           <ul style="list-style-type:disc">
                              <li>如果请求的主机名是<code class="codeph">www.example.com</code> ，那么它将被拒绝<code class="codeph">unrecognized_name</code>致命错误。
                              </li>
                              <li>如果请求的主机名是<code class="codeph">www.example.org</code> ，那么它将被接受并在ServerHello消息中发送确认。
                              </li>
                              <li>如果没有请求的主机名或该主机名为空，则将接受该请求，但不会在ServerHello消息中发送确认。</li>
                           </ul> 
                        </li>
                        <li> 
                           <p>匹配器未配置：</p> 
                           <p>任何请求的主机名都会被接受，但是ServerHello消息中不会发送任何确认。</p> 
                        </li>
                     </ul>
                     <p>有关实现SNI扩展的新类的说明，请参见：</p>
                     <ul style="list-style-type:disc">
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="StandardConstants类用于表示JSSE中的标准常量定义。">标准常量类</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B">SNIServerName类</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-073F0493-3DB8-4388-818B-83E92021EF45">SNIMatcher类</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E10158C4-E808-41B7-9958-A119927743D8">SNIHostName类别</a></li>
                     </ul>
                     <p>有关示例，请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-63945B45-E909-483F-B3A9-E26586737383">使用服务器名称指示（SNI）扩展</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3" name="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3"></a><h3 id="JSSEC-GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3" class="sect3">TLS应用层协议协商</h3>
               <div>
                  <p>与应用程序层协议协商（ALPN）协商TLS连接的应用程序协议。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3__GUID-6F20B77E-32EA-427D-8B6F-A9E8165CF339">什么是ALPN？</p>
                     <p>某些应用程序可能希望或需要在TLS握手完成之前协商共享的应用程序级别值。例如，HTTP / 2使用应用程序层协议协商机制来帮助确定可以或将在特定的TCP或UDP端口上使用哪个HTTP版本（“ h2”，“ spdy / 3”，“ http / 1.1”）。ALPN（ <a href="https://www.rfc-editor.org/rfc/rfc7301.txt" target="_blank">RFC 7301</a> ）执行此操作时，未在客户端和服务器之间添加网络往返。对于HTTP / 2，必须在协商连接之前建立协议，因为客户端和服务器在开始进行通信之前需要知道要使用的HTTP版本。如果没有ALPN，则不可能在同一端口上具有应用程序协议HTTP / 1和HTTP / 2。
                     </p>
                     <p>客户端在TLS握手开始时使用ALPN扩展，以将受支持的应用程序协议列表发送到服务器，作为客户端的一部分。 <code class="codeph">ClientHello</code> 。服务器读取服务器中支持的应用程序协议列表<code class="codeph">ClientHello</code> ，并确定要使用哪种受支持的协议。然后发送<code class="codeph">ServerHello</code>消息将协商结果返回给客户端。该消息可能包含已选择的协议名称，或者未选择任何协议。
                     </p>
                     <p>因此，可以在TLS握手中完成应用程序协议协商，而无需添加网络往返，并且如果需要的话，还允许服务器将不同的证书与每个应用程序协议相关联。</p>
                     <p>与许多其他TLS扩展不同，此扩展不建立会话的属性，仅建立连接的属性。因此，您会在<code class="codeph">SSLSocket</code> / <code class="codeph">SSLEngine</code> ，而不是<code class="codeph">SSLSession</code> 。使用会话恢复或会话票证时（请参阅“ <a href="http://www.rfc-editor.org/rfc/rfc5077.txt" target="_blank">不带服务器端状态的TLS会话恢复”</a> ），先前协商的值是不相关的，并且仅考虑新握手消息中的值。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" name="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290"></a><h4 id="JSSEC-GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" class="sect4">在客户端上设置ALPN</h4>
                  <div>
                     <p>设置客户端支持的应用程序层协议协商（ALPN）值。与服务器握手期间，服务器将读取客户端的应用程序协议列表，并确定最合适的协议。</p>
                     <div class="section">
                        <p>对于客户端，请使用<code class="codeph">SSLParameters.setApplicationProtocols(String[])</code>方法，然后按<code class="codeph">setSSLParameters</code>任一方法<code class="codeph">SSLSocket</code>要么<code class="codeph">SSLEngine</code>设置要发送到服务器的应用程序协议。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290__GUID-B3161CAE-62B4-48EE-A432-163199F08491">
                        <p class="titleinexample">示例8-21用于在Java客户端中设置和获取ALPN值的示例代码</p>
                        <p>例如，以下是设置ALPN值的步骤<code class="codeph">"three"</code>和<code class="codeph">"two"</code> ，在客户端上。
                        </p>
                        <p>要运行代码的属性<code class="codeph">javax.net.ssl.trustStore</code>必须设置为有效的根证书。（这可以在命令行上完成）。
                        </p><pre class="pre codeblock"><code>import java.io.*; 
import java.util.*;
import javax.net.ssl.*; 
public class SSLClient {
    public static void main(String[] args) throws Exception {

        // Code for creating a client side SSLSocket
        SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
        SSLSocket sslSocket = (SSLSocket) sslsf.createSocket("localhost", 9999);

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // On the client side the order doesn't matter as
        // when connecting to a JDK server, the server's list takes priority
        String[] clientAPs = {"three", "two"};
        sslp.setApplicationProtocols(clientAPs);

        // Populate the SSLSocket object with the SSLParameters object
        // containing the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been negotiated
        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol client side: \"" + ap + "\"");

        // Do simple write/read
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslOS.write(280);
        sslOS.flush();
        sslIS.read();
        sslSocket.close();
    }
}</code></pre><p>当此代码运行并发送一个<code class="codeph">ClientHello</code>到已设置ALPN值的Java服务器<code class="codeph">one</code> ， <code class="codeph">two</code>和<code class="codeph">three</code> ，输出将是：</p><pre class="pre codeblock"><code>Application Protocol client side: two</code></pre><p>还可以在握手期间检查协商结果。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="要确定握手期间已协商的ALPN值，请创建一个自定义KeyManager或TrustManager类，并在此自定义类中包括对getHandshakeApplicationProtocol方法的调用。">确定握手过程中协商的ALPN值</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5" name="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5"></a><h4 id="JSSEC-GUID-59618539-24AD-431E-84E3-585C4C4BF4E5" class="sect4">在服务器上设置默认ALPN</h4>
                  <div>
                     <p>通过在服务器上设置ALPN值，使用默认的ALPN机制来确定合适的应用程序协议。</p>
                     <div class="section">要对服务器上的ALPN使用默认机制，请填充<code class="codeph">SSLParameters</code>具有您要设置的ALPN值的对象，然后使用此对象<code class="codeph">SSLParameters</code>对象以填充<code class="codeph">SSLSocket</code>对象或<code class="codeph">SSLEngine</code>与在客户端上设置ALPN时所做的操作一样，使用带有这些参数的对象（请参见在客户端上<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" title="设置客户端支持的应用程序层协议协商（ALPN）值。与服务器握手期间，服务器将读取客户端的应用程序协议列表，并确定最合适的协议。">设置ALPN</a>一节）。在服务器上设置的ALPN值的第一个值与包含在服务器中的任何ALPN值匹配<code class="codeph">ClientHello</code>将被选择并作为<code class="codeph">ServerHello</code> 。
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
                        <p class="titleinexample">示例8-22服务器上默认ALPN值协商的示例代码</p>
                        <p>这是使用默认方法进行协议协商的Java服务器的代码。要运行代码的属性<code class="codeph">javax.net.ssl.keyStore</code>必须设置为有效的密钥库。（这可以在命令行上完成，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="有关如何使用keytool实用程序来创建适用于JSSE的简单PKCS12密钥库的过程。">创建要与JSSE一起使用的密钥库</a> ）。
                        </p><pre class="pre codeblock"><code>import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf = 
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // As this is server side, put them in order of preference
        String[] serverAPs ={ "one", "two", "three" };
        sslp.setApplicationProtocols(serverAPs);

        // If necessary at any time, get the ALPN values set on the 
        // SSLParameters object with:
        // String serverAPs = sslp.setApplicationProtocols();

        // Populate the SSLSocket object with the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that 
        // has been negotiated

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }
}</code></pre><div class="p">运行此代码并且Java客户端发送一个<code class="codeph">ClientHello</code>具有ALPN值<code class="codeph">three</code>和<code class="codeph">two</code> ，输出为：<pre class="pre codeblock"><code>Application Protocol server side: two</code></pre>还可以在握手期间检查协商结果。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="要确定握手期间已协商的ALPN值，请创建一个自定义KeyManager或TrustManager类，并在此自定义类中包括对getHandshakeApplicationProtocol方法的调用。">确定握手过程中协商的ALPN值</a> 。
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" name="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8"></a><h4 id="JSSEC-GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" class="sect4">在服务器上设置自定义ALPN</h4>
                  <div>
                     <p>使用自定义ALPN机制通过设置回调方法来确定合适的应用程序协议。</p>
                     <div class="section">
                        <p>如果您不想使用服务器的默认协商协议，则可以使用<code class="codeph">setHandshakeApplicationProtocolSelector</code>的方法<code class="codeph">SSLEngine</code>要么<code class="codeph">SSLSocket</code>注册一个<code class="codeph">BiFunction</code> （lambda）回调，它可以检查到目前为止的握手状态，然后根据客户端的应用程序协议列表和任何其他相关信息进行选择。例如，您可以考虑使用建议的密码套件或服务器名称指示（SNI）或在选择时可以获取的任何其他数据。如果使用自定义协商，则由<code class="codeph">setApplicationProtocols</code>方法（默认协商）将被忽略。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
                        <p class="titleinexample">示例8-23服务器上的自定义ALPN值协商的示例代码</p>
                        <p>这是使用定制机制进行协议协商的Java服务器的代码。要运行代码的属性<code class="codeph">javax.net.ssl.keyStore</code>必须设置为有效证书。（这可以在命令行上完成，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="有关如何使用keytool实用程序来创建适用于JSSE的简单PKCS12密钥库的过程。">创建要与JSSE一起使用的密钥库</a> ）。
                        </p><pre class="pre codeblock"><code>import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf =
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Code to set up a callback function
        // Pass in the current&nbsp;SSLSocket&nbsp;to be inspected and client AP values
        sslSocket.setHandshakeApplicationProtocolSelector(
            (serverSocket, clientProtocols) -&gt; {
                SSLSession handshakeSession = serverSocket.getHandshakeSession();
                // callback function called with current SSLSocket and client AP values
                // plus any other useful information to help determine appropriate
                // application protocol. Here the protocol and ciphersuite are also
                // passed to the callback function.
                return chooseApplicationProtocol(
                    serverSocket,
                    clientProtocols,
                    handshakeSession.getProtocol(),
                    handshakeSession.getCipherSuite());
         }); 

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been
        // returned from the callback method.

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }

    // The callback method. Note how the parameters match the call within 
    // the setHandshakeApplicationProtocolSelector method above.
    public static String chooseApplicationProtocol(SSLSocket serverSocket,
            List&lt;String&gt; clientProtocols, String protocol, String cipherSuite ) {
        // For example, check the cipher suite and return an application protocol
        // value based on that.
        if (cipherSuite.equals("&lt;--a_particular_ciphersuite--&gt;")) { 
            return "three";
        } else {
            return "";
        }
    } 
}</code></pre><p>如果运行此代码时密码套件与您在条件语句中指定的密码套件匹配，则该值<code class="codeph">three</code>将被退回。否则将返回一个空字符串。
                        </p>
                        <p>请注意<code class="codeph">BiFunction</code>对象的返回值是<code class="codeph">String</code> ，这将是应用程序协议名称，或者为null，指示所有公布的名称都不可接受。如果返回值为空<code class="codeph">String</code>则将不使用应用协议指示。如果返回值为null（未选择任何值）或不是对等方通告的值，则基础协议将确定要采取的操作。（例如，服务器代码将发送“ no_application_protocol”警报并终止连接。）
                        </p>
                        <p>在客户端和服务器上完成握手之后，您可以通过调用<code class="codeph">getApplicationProtocol</code>方法之一<code class="codeph">SSLSocket</code>对象或<code class="codeph">SSLEngine</code>宾语。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" name="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9"></a><h4 id="JSSEC-GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" class="sect4">在握手期间确定协商的ALPN值</h4>
                  <div>
                     <p>要确定握手期间已协商的ALPN值，请创建一个自定义<code class="codeph">KeyManager</code>要么<code class="codeph">TrustManager</code>类，并在此自定义类中包含对<code class="codeph">getHandshakeApplicationProtocol</code>方法。
                     </p>
                     <div class="section">
                        <p>在某些用例中，所选的ALPN和SNI值会影响由APN做出的选择。 <code class="codeph">KeyManager</code>要么<code class="codeph">TrustManager</code> 。例如，应用程序可能希望根据服务器的属性以及所选的ALPN / SNI /密码套件值来选择不同的证书/专用密钥集。
                        </p>
                        <p>给出的示例代码说明了如何调用<code class="codeph">getHandshakeApplicationProtocol</code>自定义中的方法<code class="codeph">X509ExtendedKeyManager</code>您创建并注册为<code class="codeph">KeyManager</code>宾语。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-57D815A8-4BF8-4F9F-9735-9240C4E6D718">
                        <p class="titleinexample">示例8-24自定义KeyManager的示例代码</p>
                        <p>此示例显示了自定义的完整代码<code class="codeph">KeyManager</code>延伸<code class="codeph">X509ExtendedKeyManager</code> 。大多数方法只是返回从<code class="codeph">KeyManager</code>被这个包装的类<code class="codeph">MyX509ExtendedKeyManager</code>类。然而<code class="codeph">chooseServerAlias</code>方法调用<code class="codeph">getHandshakeApplicationProtocol</code>在<code class="codeph">SSLSocket</code>对象，因此可以确定当前协商的ALPN值。
                        </p><pre class="pre codeblock"><code>

import java.net.Socket;
import java.security.*;
import javax.net.ssl.*;

public class MyX509ExtendedKeyManager extends X509ExtendedKeyManager {

    // X509ExtendedKeyManager is an abstract class so your new class 
    // needs to implement all the abstract methods in this class. 
    // The easiest way to do this is to wrap an existing KeyManager
    // and call its methods for each of the methods you need to implement.   

    X509ExtendedKeyManager akm;
    
    public MyX509ExtendedKeyManager(X509ExtendedKeyManager akm) {
        this.akm = akm;
    }

    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
        return akm.getClientAliases(keyType, issuers);
    }

    @Override
    public String chooseClientAlias(String[] keyType, Principal[] issuers, 
        Socket socket) {
        return akm.chooseClientAlias(keyType, issuers, socket);
    }

    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers, 
        Socket socket) {
        
        // This method has access to a Socket, so it is possible to call the
        // getHandshakeApplicationProtocol method here. Note the cast from 
        // a Socket to an SSLSocket
        String ap = ((SSLSocket) socket).getHandshakeApplicationProtocol();
        System.out.println("In chooseServerAlias, ap is: " + ap);
        return akm.chooseServerAlias(keyType, issuers, socket);
    }

    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
        return akm.getServerAliases(keyType, issuers);
    }

    @Override
    public X509Certificate[] getCertificateChain(String alias) {
        return akm.getCertificateChain(alias);
    }

    @Override
    public PrivateKey getPrivateKey(String alias) {
        return akm.getPrivateKey(alias);
    }
}</code></pre><div class="p">当此代码注册为<code class="codeph">KeyManager</code> Java服务器和Java客户端发送一个<code class="codeph">ClientHello</code>使用ALPN值，输出将是：<pre class="pre codeblock"><code>    In chooseServerAlias, ap is: &lt;negotiated value&gt;</code></pre></div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-264BBD9E-71BA-412C-AA77-EF0EC265D42B">
                        <p class="titleinexample">示例8-25在Java服务器中使用自定义KeyManager的示例代码</p>
                        <p>此示例显示了一个简单的Java服务器，该服务器使用默认的ALPN协商策略和自定义<code class="codeph">KeyManager</code> ， <code class="codeph">MyX509ExtendedKeyManager</code> ，如先前的代码示例所示。
                        </p><pre class="pre codeblock"><code>import java.io.*;
import java.util.*;
import javax.net.ssl.*;
import java.security.KeyStore;

public class SSLServerHandshake {
    
    public static void main(String[] args) throws Exception {
        SSLContext ctx = SSLContext.getInstance("TLS");

        // You need to explicitly create a create a custom KeyManager

        // Keystores
        KeyStore keyKS = KeyStore.getInstance("PKCS12");
        keyKS.load(new FileInputStream("serverCert.p12"), 
            "password".toCharArray());

        // Generate KeyManager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
        kmf.init(keyKS, "password".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        // Code to substitute MyX509ExtendedKeyManager
        if (!(kms[0] instanceof X509ExtendedKeyManager)) {
            throw new Exception("kms[0] not X509ExtendedKeyManager");
        }

        // Create a new KeyManager array and set the first index 
        // of the array to an instance of MyX509ExtendedKeyManager.
        // Notice how creating this object is done by passing in the 
        // existing default X509ExtendedKeyManager 
        kms = new KeyManager[] { 
            new MyX509ExtendedKeyManager((X509ExtendedKeyManager) kms[0])};

        // Initialize SSLContext using the new KeyManager
        ctx.init(kms, null, null);

        // Instead of using SSLServerSocketFactory.getDefault(), 
        // get a SSLServerSocketFactory based on the SSLContext
        SSLServerSocketFactory sslssf = ctx.getServerSocketFactory();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
        SSLParameters sslp = sslSocket.getSSLParameters();
        String[] serverAPs ={"one","two","three"};
        sslp.setApplicationProtocols(serverAPs);
        sslSocket.setSSLParameters(sslp);
        sslSocket.startHandshake();

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();

        sslSocket.close();
        sslServerSocket.close();
    }
}</code></pre><p>与风俗<code class="codeph">X509ExtendedKeyManager</code>到位时<code class="codeph">chooseServerAlias</code>在握手过程中被称为<code class="codeph">KeyManager</code>有机会检查协商的应用程序协议值。在所示示例的情况下，此值输出到控制台。
                        </p>
                        <div class="p">例如，当运行此代码并且Java客户端发送一个<code class="codeph">ClientHello</code>具有ALPN值<code class="codeph">three</code>和<code class="codeph">two</code> ，输出将是：<pre class="pre codeblock"><code>Application Protocol server side: two</code></pre></div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742" name="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742"></a><h4 id="JSSEC-GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742" class="sect4">ALPN相关的类和方法</h4>
                  <div>
                     <p>在使用应用程序层协议协商（ALPN）时，将使用这些类和方法。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742__GUID-E9B3FDB8-8A17-4F18-BE6D-827117066FAF">类和使用方法</p>
                        <p><code class="codeph">SSLEngine</code>和<code class="codeph">SSLSocket</code>包含与ALPN相关的相同方法，并且具有相同的功能。
                        </p>
                        <div class="tblformalwide" id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742__GUID-FE0C995B-14C9-493B-8716-D66B3FDD990A">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="These methods enable the setting and getting of ALPN values." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d112429e7760">类</th>
                                    <th align="left" valign="bottom" width="40%" id="d112429e7762">方法</th>
                                    <th align="left" valign="bottom" width="40%" id="d112429e7764">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7768" headers="d112429e7760 "><code class="codeph">SSLParameters</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7768 d112429e7762 "><code class="codeph">public String[] getApplicationProtocols();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7768 d112429e7764 "><span class="bold">客户端和服务器端</span> ：使用方法返回一个<code class="codeph">String</code>包含每个协议集的数组。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7782" headers="d112429e7760 "><code class="codeph">SSLParameters</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7782 d112429e7762 "><code class="codeph">public void setApplicationProtocols([] protocols);</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7782 d112429e7764 ">
                                       <p><span class="bold">客户端</span> ：使用该方法设置服务器可以选择的协议。
                                       </p>
                                       <p><span class="bold">服务器端</span> ：使用该方法设置服务器可以使用的协议。String数组应按优先顺序包含协议。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7798" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7798 d112429e7762 "><code class="codeph">public String getApplicationProtocol();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7798 d112429e7764 "><span class="bold">客户端和服务器端</span> ： <span class="italic">在</span> TLS协议协商完成<span class="italic">后，</span>使用此方法返回<code class="codeph">String</code>包含已为连接选择的协议。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7818" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7818 d112429e7762 "><code class="codeph">public String getHandshakeApplicationProtocol();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7818 d112429e7764 "><span class="bold">客户端和服务器端</span> ： <span class="italic">在</span>握手<span class="italic">期间</span>使用方法返回一个<code class="codeph">String</code>包含已为连接选择的协议。如果在握手之前或之后调用此方法，则它将返回null。有关如何调用此方法的说明，请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="要确定握手期间已协商的ALPN值，请创建一个自定义KeyManager或TrustManager类，并在此自定义类中包括对getHandshakeApplicationProtocol方法的调用。">握手期间确定协商的ALPN值</a> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7854" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7854 d112429e7762 "><code class="codeph">public void setHandshakeApplicationProtocolSelector(BiFunction,String> selector)</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7854 d112429e7764 "><span class="bold">服务器端</span> ：使用该方法注册回调函数。然后可以基于任何可用信息（例如协议或密码套件）在回调中设置应用程序协议值。有关如何使用此方法的说明，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" title="使用自定义ALPN机制通过设置回调方法来确定合适的应用程序协议。">在服务器上设置自定义ALPN</a> 。
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1" name="GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1"></a><h3 id="JSSEC-GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1" class="sect3">JSSE故障排除</h3>
               <div>
                  <p></p>
                  <p>本节包含有关对JSSE进行故障排除的信息。首先，它提供了一些常见的<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" title="解决一些常见配置问题。">配置问题</a>及其解决方法，然后介绍了有用的<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">调试实用程序</a> 。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" name="GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D"></a><h4 id="JSSEC-GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" class="sect4">配置问题</h4>
                  <div>
                     <p>解决一些常见配置问题。</p>
                  </div>
                  <div class="sect4"><a id="GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521" name="GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521"></a><h5 id="JSSEC-GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521" class="sect5">SSLHandshakeException：没有可用的身份验证方案，握手失败</h5>
                     <div>
                        <p><span class="bold">问题：</span>服务器抛出此异常：</p><pre class="pre codeblock"><code>javax.net.ssl.SSLHandshakeException: No available authentication scheme</code></pre><p>然后，客户端会收到致命警报：</p><pre class="pre codeblock"><code>javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure</code></pre><p><span class="bold">原因：</span>如果TLSv1.3被选为协议版本，只有DSA证书是在服务器的可用的KeyManager服务器抛出这个<span class="apiname">出现SSLHandshakeException。</span>使用keytool命令进行验证；更改<code>testkeys.dsa</code>到密钥库的名称：</p><pre class="pre codeblock"><code><span class="bold">keytool -list -keystore testkeys.dsa -v</span>

Enter keystore password:
Keystore type: PKCS12
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: localhost
Creation date: Sep 19, 2018
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]: Owner: CN=localhost, OU=Widget, O=Ficticious, L=Sunnyvale, ST=CA, C=US Issuer: CN=localhost, OU=Widget, O=Ficticious, L=Sunnyvale, ST=CA, C=US

<span class="italic">...deleted...</span>

Signature algorithm name: SHA256withDSA
Subject Public Key Algorithm: 2048-bit DSA key

<span class="italic">...deleted...</span>
</code></pre><p><span class="bold">解决方案：</span>更新您的证书，使其包含RSA或EC公钥。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908" name="GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908"></a><h5 id="JSSEC-GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908" class="sect5">握手时出现CertificateException</h5>
                     <div>
                        <p></p>
                        <p><span class="bold">问题：</span>在协商TLS / DTLS连接时，客户端或服务器抛出<code class="codeph">CertificateException</code> 。
                        </p>
                        <p><span class="bold">原因1：</span>这通常是由远端发送对本地未知的证书引起的。
                        </p>
                        <p><span class="bold">解决方案1：</span>调试此类问题的最佳方法是打开调试（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a> ），并注意加载证书以及何时通过网络连接接收到证书。很有可能，信任机制不知道收到的证书，因为加载了错误的信任文件。
                        </p>
                        <p>请参阅以下部分：</p>
                        <ul style="list-style-type:disc">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE类和接口</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" title="TrustManager的主要职责是确定是否应该信任提供的身份验证凭据。如果凭据不受信任，则连接将终止。要验证安全套接字对等方的远程身份，必须使用一个或多个TrustManager对象初始化SSLContext对象。您必须为支持的每种身份验证机制传递一个TrustManager。如果将null传递到SSLContext初始化中，则将为您创建一个信任管理器。通常，单个信任管理器支持基于X.509公共密钥证书（例如X509TrustManager）的身份验证。一些安全套接字实现也可能支持基于共享密钥，Kerberos或其他机制的身份验证。">TrustManager界面</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702">KeyManager界面</a></li>
                        </ul>
                        <p><span class="bold">原因2：</span>系统时钟设置不正确。在这种情况下，对于其中一个证书，感知时间可能超出有效期，并且除非可以用信任库中的有效证书替换证书，否则系统必须假定证书无效，因此引发异常。
                        </p>
                        <p><span class="bold">解决方案2：</span>更正系统时钟时间。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F" name="GUID-48170215-4EF1-4653-B58F-81572E9FE23F"></a><h5 id="JSSEC-GUID-48170215-4EF1-4653-B58F-81572E9FE23F" class="sect5">运行时异常：SSL服务不可用</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span>运行使用JSSE的程序时，发生异常，指示SSL服务不可用。例如，抛出类似于以下之一的异常：</p><pre class="codeblock"><code>    Exception in thread "main" java.net.SocketException:
        no SSL Server Sockets
    
    Exception in thread "main":
        SSL implementation not available
</code></pre><p><span class="bold">原因：</span>出现问题<code class="codeph">SSLContext</code>例如，由于密钥库上的密码不正确或密钥库损坏而导致初始化（JDK供应商曾经以未知格式运送密钥库，并导致了这种类型的错误）。
                           </p>
                           <p><span class="bold">解决方案：</span>检查初始化参数。确保指定的任何密钥库均有效，并且指定的密码正确。您可以检查的一种方法是尝试使用<code class="codeph">keytool</code>检查密钥库及其相关内容。请参阅《 <span id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F__JSWOR"><cite>Java平台标准版工具参考》中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-92715704-80F4-431A-BF99-D583EE61C4AB" name="GUID-92715704-80F4-431A-BF99-D583EE61C4AB"></a><h5 id="JSSEC-GUID-92715704-80F4-431A-BF99-D583EE61C4AB" class="sect5">运行时异常：“没有与启用的SSL密码套件相对应的可用证书”</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span>尝试运行简单的SSL服务器程序时，将引发以下异常：</p><pre class="codeblock"><code>    Exception in thread "main" javax.net.ssl.SSLException:
        No available certificate corresponding to the SSL cipher suites which are enabled...
</code></pre><p><span class="bold">原因：</span>各种密码套件都需要某些类型的密钥材料。例如，如果启用了RSA密码套件，则RSA <code class="codeph">keyEntry</code>必须在密钥库中可用。如果没有这样的密钥，则无法使用此密码套件。如果没有为所有启用的密码套件提供可用的密钥条目，则抛出此异常。
                           </p>
                           <p><span class="bold">解决方案：</span>为各种密码套件类型创建密钥条目，或使用匿名套件。匿名密码套件具有固有的危险性，因为它们容易受到MITM（中间人）攻击。请参阅<a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC 5246：传输层安全性（TLS）协议版本1.2</a> 。
                           </p>
                           <p>请参考以下各节，以了解如何传递正确的密钥库和证书：</p>
                           <ul style="list-style-type:disc">
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE类和接口</a></li>
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">自定义默认密钥库和信任库，商店类型和商店密码</a></li>
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF">其他密钥库格式（PKCS12）</a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5" name="GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5"></a><h5 id="JSSEC-GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5" class="sect5">运行时例外：没有通用的密码套件</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题1：</span>握手时，客户端和/或服务器抛出此异常。
                           </p>
                           <p><span class="bold">原因1：</span> TLS连接的两端必须在通用密码套件上达成共识。如果客户端的密码套件集与服务器的密码套件集的交集为空，那么您将看到此异常。
                           </p>
                           <p><span class="bold">解决方案1：</span>将已启用的密码套件配置为包括通用密码套件，并确保提供适当的密码套件。 <code class="codeph">keyEntry</code>用于非对称密码套件。另请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-92715704-80F4-431A-BF99-D583EE61C4AB">运行时异常：本部分中的“没有与启用的SSL密码套件相对应的可用证书”</a> 。
                           </p>
                           <p><span class="bold">问题2：</span>使用Mozilla Firefox或Microsoft Internet Explorer访问仅具有基于DSA证书的服务器上的文件时，会出现运行时异常，指示没有通用的密码套件。
                           </p>
                           <p><span class="bold">原因2：</span>默认情况下， <code class="codeph">keyEntries</code>创建于<code class="codeph">keytool</code>使用DSA公钥。如果只有DSA <code class="codeph">keyEntries</code>存在于密钥库中，则只能使用基于DSA的密码套件。默认情况下，Firefox和Internet Explorer仅发送基于RSA的密码套件。由于客户端和服务器密码套件集的交集为空，因此将引发此异常。
                           </p>
                           <p><span class="bold">解决方案2：</span>要与Firefox或Internet Explorer进行交互，应创建使用基于RSA的密钥的证书。为此，请指定<code class="codeph">-keyalg</code>使用keytool时的RSA选项。例如：</p><pre class="codeblock"><code>keytool -genkeypair -alias duke -keystore testkeys -keyalg rsa
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7" name="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7"></a><h5 id="JSSEC-GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7" class="sect5">发送ClientHello消息后套接字断开连接</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span>套接字尝试连接，发送ClientHello消息，然后立即断开连接。
                           </p>
                           <p><span class="bold">原因：</span>如果以不理解的格式或不支持的协议版本号收到ClientHello消息，则某些TLS服务器将断开连接。
                           </p>
                           <p><span class="bold">解决方案</span> ：尝试在客户端上调整已启用的协议。这涉及修改或调用以下某些系统属性和方法：</p>
                           <ul style="list-style-type:disc">
                              <li>系统属性<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY"><code class="codeph">https.protocols</code></a>为了<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a></code>类</li>
                              <li>系统属性<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY"><span class="apiname">jdk.tls.client.protocols</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getInstance-java.lang.String-" target="_blank"><code class="codeph">SSLContext.getInstance</code></a>方法</li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setEnabledProtocols</code></a>方法</li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols</code></a>方法</li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setSSLParameters</code></a>方法</li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setSSLParameters</code></a>方法</li>
                           </ul>
                           <p>为了向后兼容，某些TLS实现（例如SunJSSE）可以发送封装为SSLv2 ClientHello格式的TLS ClientHello消息。SunJSSE提供程序支持此功能。如果要使用此功能，请在必要的协议列表中添加“ SSLv2Hello”协议。（请参阅<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK提供程序</a>中的协议，其中列出了默认情况下为SunJSSE提供程序启用的协议。）
                           </p>
                           <p>TLS RFC标准要求实现协商双方双方都使用的最新版本，但是如果某些不符合要求的实现出现了他们不理解的版本，则只会挂断。例如，如果请求TLSv1.2，则某些仅使用SSLv3的较旧服务器实现将关闭。在这种情况下，请考虑使用TLS版本回退方案：</p>
                           <ol>
                              <li>如果服务器不了解TLSv1.2，请从TLSv1.2退回到TLSv1.1。</li>
                              <li>如果上一步不起作用，请从TLSv1.1回退到TLSv1.0。</li>
                           </ol>
                           <p>例如，如果客户端上启用的协议列表为TLSv1，TLSv1.1和TLSv1.2，则典型的TLS版本回退方案可能类似于：</p>
                           <ol>
                              <li>尝试连接到服务器。如果服务器立即拒绝TLS连接请求，请转到步骤2。</li>
                              <li>通过删除已启用的协议列表中的最高协议版本（例如，第一个失败的TLSv1.2）来尝试版本回退方案。</li>
                              <li>尝试再次连接到服务器。如果服务器拒绝连接，请转到步骤2，除非没有服务器可以使用的版本。</li>
                              <li>如果连接失败并且SSLv2Hello不在启用的协议列表中，请还原启用协议列表并启用SSLv2Hello。（例如，启用协议列表应为SSLv2Hello，TLSv1，TLSv1.1和TLSv1.2。）从步骤1重新开始。</li>
                           </ol>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-879D0C74-6202-47A4-A56F-1A971ABD230D">
                                 <p class="notep1">注意：</p>回退到以前的版本通常意味着将安全强度降级为较弱的协议。除非确实有必要，否则建议不要使用回退方案，并且您清楚地知道服务器不支持更高的协议版本。
                              </div>
                           </div>
                           <div class="infoboxnote" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-FF293B29-F33E-41EF-909A-6350B9D35E23">
                              <p class="notep1">注意：</p>作为禁用SSLv3的一部分，某些服务器还禁用了SSLv2Hello，这意味着与SSLv2Hello活动客户端（JDK 6u95）的通信将失败。从JDK 7开始，SSLv2Hello默认在客户端禁用，在服务器上启用。
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-85667451-803E-4E07-B366-00E19790595B" name="GUID-85667451-803E-4E07-B366-00E19790595B"></a><h5 id="JSSEC-GUID-85667451-803E-4E07-B366-00E19790595B" class="sect5">SunJSSE找不到支持所需算法并导致NoSuchAlgorithmException的JCA提供程序</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span>尝试握手，但找不到所需的算法时失败。示例可能包括：</p><pre class="codeblock"><code>Exception in thread ...deleted...
    ...deleted...
    Caused by java.security.NoSuchAlgorithmException: Cannot find any
        provider supporting RSA/ECB/PKCS1Padding
</code></pre><p>要么</p><pre class="codeblock"><code>Caused by java.security.NoSuchAlgorithmException: Cannot find any
    provider supporting AES/CBC/NoPadding
</code></pre><p><span class="bold">原因：</span> SunJSSE将JCE用于其所有加密算法。如果已从SunJCE提供者注销了注册<code class="codeph">Provider</code>机制和JCE的替代实现不可用，则将引发此异常。
                           </p>
                           <p><span class="bold">解决方案：</span>通过检查提供商是否已在SunJCE上注册来确保SunJCE可用。 <code class="codeph">Provider</code>接口。尝试在SSL连接的上下文中运行以下代码：</p><pre class="codeblock"><code>import javax.crypto.*;

System.out.println("=====Where did you get AES=====");
Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
System.out.println(c.getProvider());
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA" name="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA"></a><h5 id="JSSEC-GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA" class="sect5">从需要SNI扩展的虚拟主机Web服务器获取应用程序资源时引发异常</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span>如果您收到<code class="codeph">Exception</code>尝试通过TLS从Web服务器获取应用程序资源，并且将Web服务器实现为虚拟主机时，该虚拟主机需要有效的服务器名称指示（SNI）扩展名（例如Apache HTTP Server）以区分虚拟主机，然后将Web服务器可能配置不正确。
                           </p>
                           <p><span class="bold">原因：</span>因为Java SE在JSSE客户端中支持SNI扩展，所以在TLS握手期间从客户端发送到服务器的第一条消息中包括了所请求的虚拟服务器的主机名。如果所请求的主机名（服务器名称指示）与预期的服务器名不匹配，则服务器可以拒绝客户端的连接请求，该服务器名应在虚拟主机的配置中指定。这会触发TLS握手无法识别的名称警报，从而导致<code class="codeph">Exception</code>被抛出。
                           </p>
                           <p><span class="bold">解决方案：</span>如果问题的原因是<code class="codeph">javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name</code> ，则可能是SNI的虚拟主机配置不正确。如果使用的是Apache HTTP Server，请参阅<a href="https://httpd.apache.org/docs/trunk/vhosts/name-based.html" target="_blank">基于名称的虚拟主机支持以</a>了解有关配置虚拟主机的信息。特别要确保<code class="codeph">ServerName</code>指令已在<code class="codeph"><VirtualHost></code>块。
                           </p>
                           <p>请参阅以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li><a href="https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI" target="_blank">使用</a> <a href="https://wiki.apache.org/httpd/FrontPage" target="_blank">Apache HTTP Server Wiki中的</a> <a href="https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI" target="_blank">SNI与虚拟主机一起使用SSL</a></li>
                              <li><a href="https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html" target="_blank">SSL / TLS强加密：</a> <a href="https://httpd.apache.org/docs/" target="_blank">Apache HTTP Server文档中的</a> <a href="https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html" target="_blank">常见问题解答</a></li>
                              <li><a href="https://www.ietf.org/rfc/rfc3546.txt" target="_blank">RFC 3546，传输层安全性（TLS）扩展</a></li>
                              <li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7194590" target="_blank">错误7194590：由虚拟服务器配置错误引起的SSL握手错误</a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-001B7524-87A4-4085-B8EF-929E0503DBEC" name="GUID-001B7524-87A4-4085-B8EF-929E0503DBEC"></a><h5 id="JSSEC-GUID-001B7524-87A4-4085-B8EF-929E0503DBEC" class="sect5">IllegalArgumentException当为DTLS配置RC4密码套件时</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">问题：</span> <code class="codeph">IllegalArgumentException</code>在中指定RC4密码套件算法时会引发异常<code class="codeph">SSLEngine.setEnabledCipherSuites(String[] suites)</code>方法，而<span class="apiname">SSLEngine</span>是DTLS引擎。
                           </p><pre class="codeblock"><code>sslContext = SSLContext.getInstance("DTLS");

// Create the engine
SSLEngine engine = sslContext.createSSLengine(hostname, port);

String enabledSuites[] = { "SSL_RSA_WITH_RC4_128_SHA" };
engine.setEnabledCipherSuites(enabledSuites);</code></pre><p><span class="bold">原因：</span>根据<a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS 1.0版</a>和<a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS 1.2版</a> ，RC4密码套件不得与DTLS一起使用。</p>
                           <p><span class="bold">解决方案：</span>不要将基于RC4的密码套件用于DTLS连接。请参见<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称中的</a> <span class="q">“ JSSE密码套件名称”</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF" name="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF"></a><h4 id="JSSEC-GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF" class="sect4">调试实用程序</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>SunJSSE提供程序支持动态调试跟踪。这类似于调试安全性库问题的机制。通用Java动态调试跟踪支持可通过<code class="codeph">java.security.debug</code>系统属性，而JSSE特定的动态调试跟踪支持可通过<code class="codeph">javax.net.debug</code>系统属性。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-0889B6AB-3EA2-4B6B-844D-652AFF24B968">
                              <p class="notep1">注意：</p>当前，SunJSSE提供程序使用调试实用程序。不能保证其他提供程序使用调试实用程序。如果其他提供程序支持调试实用程序，则实现和输出可能会不同。不能保证调试实用程序在将来的版本中将继续存在或相同（例如，具有相同的选项或输出格式）。
                           </div>
                        </div>
                        <p>要查看JSSE动态调试实用程序的选项，请在<code class="codeph">java</code>命令，在哪里<code class="codeph">MyApp</code>是现有的Java应用程序：</p><pre class="codeblock"><code>java -Djavax.net.debug=help MyApp
</code></pre><div class="infoboxnote" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-E45A25FE-5D18-4728-9014-F977BD07BE7D">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>的<code class="codeph">MyApp</code>打印帮助信息后，应用程序将无法运行，因为帮助代码会导致应用程序退出。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定值<code class="codeph">help</code>在运行不使用该实用程序旨在调试的任何类的程序时，如果使用这两种动态调试实用程序，则不会获得调试选项。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>当前的选项是：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">all</code> ：打开所有调试</li>
                           <li><code class="codeph">ssl</code> ：打开SSL调试</li>
                        </ul>
                        <p>以下可以与<code class="codeph">ssl</code>选择要打印哪种类型的调试信息的选项：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">defaultctx</code> ：打印默认的SSL初始化</li>
                           <li><code class="codeph">handshake</code> ：打印每个握手消息</li>
                           <li><code class="codeph">keygen</code> ：打印密钥生成数据</li>
                           <li><code class="codeph">keymanager</code> ：打印密钥管理器跟踪</li>
                           <li><code class="codeph">pluggability</code> ：打印可插拔性跟踪</li>
                           <li><code class="codeph">record</code> ：启用按记录跟踪</li>
                           <li><code class="codeph">respmgr</code> ：打印状态响应管理器跟踪</li>
                           <li><code class="codeph">session</code> ：打印会话活动</li>
                           <li><code class="codeph">sessioncache</code> ：打印会话高速缓存跟踪</li>
                           <li><code class="codeph">sslctx</code> ：打印<code class="codeph">SSLContext</code>追踪</li>
                           <li><code class="codeph">trustmanager</code> ：打印信任管理器跟踪</li>
                        </ul>
                        <p>从生成的消息<code class="codeph">handshake</code>可以使用以下选项扩展选项：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">data</code> ：每个握手消息的十六进制转储</li>
                           <li><code class="codeph">verbose</code> ：详细握手消息打印</li>
                        </ul>
                        <p>从生成的消息<code class="codeph">record</code>可以使用以下选项扩展选项：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">plaintext</code> ：记录明文的十六进制转储</li>
                           <li><code class="codeph">packet</code> ：打印原始SSL / TLS数据包</li>
                        </ul>
                        <p>要启用特定于JSSE的动态调试跟踪，请设置<code class="codeph">javax.net.debug</code>系统属性（请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">如何指定java.security。安全属性</a> ） <code class="codeph">all</code>要么<code class="codeph">ssl</code> 。为了<code class="codeph">ssl</code>选项，以指定其他选项，请在<code class="codeph">ssl</code>选项。你<span class="variable" translate="no">not</span>必须有选择之间的隔板，虽然隔板，如冒号（ <code class="codeph">:</code> ）或逗号（ <code class="codeph">,</code> ）有助于提高可读性。使用什么分隔符都没有关系，选项关键字的顺序也不重要。
                        </p>
                        <p>有关读取此调试信息的介绍，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6">调试TLS连接</a> 。
                        </p>
                        <p>以下是使用<code class="codeph">javax.net.debug</code>系统属性：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p>要查看所有调试消息：</p> <pre class="codeblock"><code>java -Djavax.net.debug=all MyApp        </code></pre></li>
                           <li> 
                              <p>要查看每个握手消息的十六进制转储（冒号是可选的）：</p> <pre class="codeblock"><code>java -Djavax.net.debug=ssl:handshake:data MyApp
</code></pre></li>
                           <li> 
                              <p>要查看每个握手消息的十六进制转储，并打印信任管理器跟踪（逗号是可选的）：</p> <pre class="codeblock"><code>java -Djavax.net.debug=ssl,handshake,data,trustmanager MyApp
</code></pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" name="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6"></a><h5 id="JSSEC-GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" class="sect5">调试TLS连接</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>有时很难理解TLS连接问题，尤其是在不清楚实际发送和接收哪些消息时。JSSE具有内置的调试工具，并由系统属性激活<code class="codeph">javax.net.debug</code> 。进一步了解<code class="codeph">javax.net.debug</code>系统属性，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">调试实用程序</a> 。
                           </p>
                           <p>本节简要概述了基本TLS 1.3握手的调试输出。要了解有关TLS协议的更多信息，请参阅<a href="https://tools.ietf.org/html/rfc8446" target="_blank">RFC 8446：传输层安全性（TLS）协议版本1.3</a> 。
                           </p>
                           <div class="infoboxnote" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-0F5C19B6-234B-4908-8E1D-C89FD8099480">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关所有可能的TLS握手组合和协议的调试输出信息不在本指南的范围之内。相反，请参考相关的RFC，以获取有关特定版本TLS的更多详细信息。有关受支持的SSL / TLS / DTLS协议及其对应的RFC的链接的列表，请参阅<a href="java-security-overview1.html#GUID-FCF419A7-B856-46DD-A36F-C6F88F9AF37F">TLS和DTLS协议</a> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>输出是非标准的，并且可能因发行版本而异。</p>
                                 </li>
                              </ul>
                           </div>
                           <p>本示例使用默认的JSSE X509KeyManager和X509TrustManager，它们还打印有关在连接期间使用的密钥和受信任证书的调试信息。它使用<code class="codeph">ClassFileServer</code>和<code class="codeph">SSLSocketClientWithClientAuth</code> <span>JDK 8文档中的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的</span>示例应用程序。 <code class="codeph">ClassFileServer</code>是一个简单的HTTPS服务器，可能需要客户端身份验证。 <code class="codeph">SSLSocketClientWithClientAuth</code>演示如何使用<span class="apiname">SSLSocket</span>类作为客户端来发送HTTP请求并从HTTPS服务器获得响应。为简化起见，两者<code class="codeph">ClassFileServer</code>和<code class="codeph">SSLSocketClientWithClientAuth</code>从同一主机运行。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-3E32411C-8496-4158-9E1B-CEEA96196C8D">在本地主机上运行ClassFileServer</p>
                           <p>以下命令运行<code class="codeph">ClassFileServer</code>申请<code class="codeph">localhost</code> ，端口2002：</p><pre class="pre codeblock"><code>java \
  -Djavax.net.ssl.trustStore=/<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts \
  -Djavax.net.ssl.trustStorePassword=changeit \
  ClassFileServer 2002 \
  /<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/ \
  TLS true</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-49CC4971-EF28-4B9D-B85D-22E60900BEB8">在locahost上运行SSLSocketClientWithClientAuth</p>
                           <p>以下命令运行<code class="codeph">SSLSocketClientWithClientAuth</code>申请<code class="codeph">localhost</code> ，端口2002。该应用程序连接到您使用上一个命令启动的HTTPS服务器。它将HTTPS请求发送到服务器并接收答复。请注意，该命令设置系统属性的值<code class="codeph">javax.net.debug</code>至<code class="codeph">all</code> ，这将打开所有调试功能。
                           </p><pre class="pre codeblock"><code>java <span class="bold">-Djavax.net.debug=all</span> -Djavax.net.ssl.trustStore=/<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts SSLSocketClientWithClientAuth localhost 2002 /index.html</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-B00BF1DC-DF9C-456E-A3D1-A5BD823CDF50">调试输出格式</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>调试输出的每一行都包含以下信息；每个字段都由竖线（ <code class="codeph">|</code> ）：</p>
                           <ul style="list-style-type:disc">
                              <li>记录仪名称（ <code class="codeph">System.getLogger("javax.net.ssl")</code> ）</li>
                              <li>调试级别（ <code class="codeph">System.Logger.Level</code> ）</li>
                              <li>线程ID（ <code class="codeph">Thread.currentThread().getId()</code> ）</li>
                              <li>线程名称（ <code class="codeph">Thread.currentThread().getName()</code> ）</li>
                              <li>日期和时间</li>
                              <li>呼叫者（记录呼叫的位置）</li>
                              <li>信息</li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-906070E2-CCDF-4918-B087-BC0C4B53E63E">确定启用客户端和服务器端的密码套件</p>
                           <p>系统属性的值<code class="codeph">jdk.tls.client.cipherSuites</code>和<code class="codeph">jdk.tls.server.cipherSuites</code>检查以确定默认启用的密码套件；有关这些系统属性的更多信息，请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="您可以在应用程序中或使用系统属性jdk.tls.client.cipherSuites和jdk.tls.server.cipherSuites指定默认启用的密码套件。">指定默认启用的密码套件</a> 。
                           </p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:46.990 EDT|SSLContextImpl.java:427|System property jdk.tls.client.cipherSuites is set to 'null'
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.026 EDT|SSLContextImpl.java:427|System property jdk.tls.server.cipherSuites is set to 'null'
...</code></pre><p>这些系统属性的值为null，因此默认启用的密码套件是SunJSSE提供程序默认启用的密码套件。请参见<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK提供程序文档中</a> <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">的SunJSSE提供</a> <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">程序</a> 。
                           </p>
                           <p>的价值<code class="codeph">jdk.tls.keyLimits</code>检查以确定算法可以用一组特定的密钥加密的数据量的限制；请参阅可以<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" title="您可以使用jdk.tls.keyLimits安全性属性，指定算法可以使用一组特定的密钥加密的数据量的限制。一旦达到此限制，就会发送KeyUpdate握手后消息，该消息请求更新当前密钥集。此安全属性仅适用于TLS 1.3的对称密码。">使用一组密钥加密的数据算法的限制数量</a> 。
                           </p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.124 EDT|SSLCipher.java:436|jdk.net.keyLimits:  entry = AES/GCM/NoPadding KeyUpdate 2^37. AES/GCM/NOPADDING:KEYUPDATE = 137438953472
...</code></pre><p>调试输出列出了不支持和禁用的密码套件：</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.150 EDT|SSLContextImpl.java:401|Ignore disabled cipher suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.150 EDT|SSLContextImpl.java:410|Ignore unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.152 EDT|SSLContextImpl.java:401|Ignore disabled cipher suite: TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-092A8241-A891-4245-851C-8E947EFBDA7F">初始化X509KeyManager</p>
                           <p>X509KeyManager被初始化。它发现提供的KeyStore中有一个名为“ duke”的主题的keyEntry。如果此应用程序要进行身份验证，则X509KeyManager会在其keyEntries列表中搜索适当的凭据。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.224 EDT|SunX509KeyManagerImpl.java:164|found key for : duke (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "3B 0A FA 66",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
    "not before"         : "2001-05-22 19:46:46.000 EDT",
    "not  after"         : "2011-05-22 19:46:46.000 EDT",
    "subject"            : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
    "subject public key" : "RSA"}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-5FC24518-15E0-4D7B-9A87-EE8A6CE6A5C8">初始化TrustManager</p>
                           <p>初始化TrustManager，并在信任库中找到来自各个证书颁发机构（CA）的多个证书。它还会找到一个具有专有名称“ localhost”的自签名证书。呈现有效凭证（证书）并链接回信任库中受信任证书的服务器本身将被信任。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.229 EDT|TrustStoreManager.java:112|trustStore is: /<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts
trustStore type is: pkcs12
trustStore provider is: 
the last modified time is: Tue Dec 11 06:43:38 EST 2012
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.229 EDT|TrustStoreManager.java:311|Reload the trust store
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.264 EDT|TrustStoreManager.java:318|Reload trust certs
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.266 EDT|TrustStoreManager.java:323|Reloaded 32 trust certs
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.322 EDT|X509TrustManagerImpl.java:79|adding as trusted certificates (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "00 9B 7E 06 49 A3 3E 62 B9 D5 EE 90 48 71 29 EF 57",
    "signature algorithm": "SHA1withRSA",
    "issuer"             : "CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "not before"         : "1999-09-30 20:00:00.000 EDT",
    "not  after"         : "2036-07-16 19:59:59.000 EDT",
    "subject"            : "CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "subject public key" : "RSA"},
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "61 70 CB 49 8C 5F 98 45 29 E7 B0 A6 D9 50 5B 7A",
    "signature algorithm": "SHA1withRSA",
    "issuer"             : "CN=VeriSign Class 2 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "not before"         : "1999-09-30 20:00:00.000 EDT",
    "not  after"         : "2036-07-16 19:59:59.000 EDT",
    "subject"            : "CN=VeriSign Class 2 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "subject public key" : "RSA"},
...
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "41 00 44 46",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "not before"         : "2004-07-22 18:48:38.000 EDT",
    "not  after"         : "2011-05-22 18:48:38.000 EDT",
    "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "subject public key" : "RSA"},
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-07A51431-1E42-48E3-A511-21A0F97DA4EB">执行其他初始化</p>
                           <p>该示例执行其他初始化代码，然后连接到服务器。</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.326 EDT|SSLContextImpl.java:115|trigger seeding of SecureRandom
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.524 EDT|SSLContextImpl.java:119|done seeding of SecureRandom
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.562 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_128_GCM_SHA256 for TLS12
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.563 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_256_GCM_SHA384 for TLS12
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.577 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_128_GCM_SHA256 for TLS11
...</code></pre><p>调试输出还会通知您禁用，不支持或不可用的扩展和签名算法：</p><pre class="pre codeblock"><code>javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.695 EDT|ServerNameExtension.java:255|Unable to indicate server name
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.695 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: server_name
javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.703 EDT|SignatureScheme.java:282|Signature algorithm, ed25519, is not supported by the underlying providers
javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.704 EDT|SignatureScheme.java:282|Signature algorithm, ed448, is not supported by the underlying providers
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.724 EDT|SignatureScheme.java:358|Ignore disabled signature sheme: rsa_md5
javax.net.ssl|INFO|01|main|2018-08-18 01:04:47.724 EDT|AlpnExtension.java:161|No available application protocols
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.724 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: application_layer_protocol_negotiation
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.725 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: cookie
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: renegotiation_info
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|PreSharedKeyExtension.java:606|No session to resume.
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: pre_shared_key
...
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-7DFE92F5-286D-4D9E-B5AD-BC0B3C978B38">发送ClientHello消息</p>
                           <p>客户端将ClientHello消息发送到服务器。该消息指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>客户端版本：对于TLS 1.3，它具有固定值TLSv1.2； TLS 1.3使用扩展名support_versions而不是此字段来协商协议版本</p>
                              </li>
                              <li>
                                 <p>随机：用于初始化密码算法的随机值</p>
                              </li>
                              <li>
                                 <p>会话ID：早期版本的TLS使用此ID支持会话恢复功能</p>
                              </li>
                              <li>
                                 <p>密码套件：客户端请求的密码套件列表；根据启用的密码套件的不同，可能会存在多种密码套件名称，其中一些仅适用于TLSv1.3，而另一些则适用于TLSv1.2及更早版本。</p>
                              </li>
                              <li>
                                 <p>压缩方法：对于TLS 1.3，此值必须为0</p>
                              </li>
                              <li>
                                 <p>扩充功能：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>status_request：客户端请求OCSP；请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="在传输层安全性（TLS）握手期间，使用联机证书状态协议（OCSP）确定X.509证书吊销状态。">客户端驱动的OCSP和OCSP装订</a></p>
                                    </li>
                                    <li>
                                       <p>supported_groups：列出客户端支持进行密钥交换的命名组。这些命名的组包括椭圆曲线组（ECDHE）和有限域组（DHE）。如果正在使用ECDHE或DHE密钥交换，则ClientHello消息必须包含此消息。</p>
                                    </li>
                                    <li>
                                       <p>ec_point_formats：列出客户端可以解析的椭圆曲线点格式；在此示例中，客户端只能解析未压缩的点格式。其他格式包括压缩和ansiX962_compressed_prime。</p>
                                    </li>
                                    <li>
                                       <p>签名算法：列出可以在CertificateVerify消息中使用的签名算法</p>
                                    </li>
                                    <li>
                                       <p>signature_algorithms_cert：列出可以在数字签名中使用的签名算法</p>
                                    </li>
                                    <li>
                                       <p>status_request_v2：使客户端可以指定和支持多种证书状态方法。请注意，TLS 1.3不推荐使用此扩展。</p>
                                    </li>
                                    <li>
                                       <p>extended_master_secret：在TLS 1.2和更早版本中，此扩展要求双方将握手记录的较大部分都消化成协议原始版本中的主密钥；参见<a href="https://tools.ietf.org/html/rfc7627" target="_blank">RFC 7627</a> 。如果协商了TLS 1.2握手，则该扩展包含在TLS 1.3握手中。
                                       </p>
                                    </li>
                                    <li>
                                       <p>supported_versions：列出客户端支持的TLS版本。特别是，如果客户端请求TLS 1.3，则客户端版本字段的值将为TLSv1.2，并且此扩展名将包含值TLSv1.3。如果客户端请求TLS 1.2，则客户端版本字段的值为TLSv1.2，并且此扩展名不存在或包含值TLSv1.2，但不包含值TLSv1.3。</p>
                                    </li>
                                    <li>
                                       <p>psk_key_exchange_modes：列出可以与预共享密钥（PSK）一起使用的密钥交换模式；在此示例中，客户端通过（EC）DHE密钥建立（psk_dhe_ke）支持PSK。在这种模式下，客户端和服务器必须提供key_share扩展名的值。</p>
                                    </li>
                                    <li>
                                       <p>key_share：列出用于密钥交换的加密参数。它包含一个名为client_shares的字段，其中包含此列表。该列表的每个项目都包含两个字段：group和key_exchange。此示例包含椭圆曲线secp256r1的密钥交换信息。</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.769 EDT|ClientHello.java:633|Produced ClientHello handshake message (
"ClientHello": {
  "client version"      : "TLSv1.2",
  "random"              : "64 CF 68 A1 CF AB B1 6F 43 F6 DE 1B 49 49 DE 5A 42 9A 71 DD CB 9A E3 9F 32 00 E8 87 7A 00 DA C6",
  "session id"          : "02 0D BE 1B A4 5F F2 E8 B6 31 9D A4 EF F3 22 84 C3 58 0B 5C C0 57 0F A5 6D 8A 83 EB DC DA B1 B6",
  "cipher suites"       : "[TLS_AES_128_GCM_SHA256(0x1301), TLS_AES_256_GCM_SHA384(0x1302), TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384(0xC02C), TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256(0xC02B), TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384(0xC030), TLS_RSA_WITH_AES_256_GCM_SHA384(0x009D), TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384(0xC02E), TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384(0xC032), TLS_DHE_RSA_WITH_AES_256_GCM_SHA384(0x009F), TLS_DHE_DSS_WITH_AES_256_GCM_SHA384(0x00A3), TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256(0xC02F), TLS_RSA_WITH_AES_128_GCM_SHA256(0x009C), TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256(0xC02D), TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256(0xC031), TLS_DHE_RSA_WITH_AES_128_GCM_SHA256(0x009E), TLS_DHE_DSS_WITH_AES_128_GCM_SHA256(0x00A2), TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384(0xC024), TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384(0xC028), TLS_RSA_WITH_AES_256_CBC_SHA256(0x003D), TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384(0xC026), TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384(0xC02A), TLS_DHE_RSA_WITH_AES_256_CBC_SHA256(0x006B), TLS_DHE_DSS_WITH_AES_256_CBC_SHA256(0x006A), TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA(0xC00A), TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA(0xC014), TLS_RSA_WITH_AES_256_CBC_SHA(0x0035), TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA(0xC005), TLS_ECDH_RSA_WITH_AES_256_CBC_SHA(0xC00F), TLS_DHE_RSA_WITH_AES_256_CBC_SHA(0x0039), TLS_DHE_DSS_WITH_AES_256_CBC_SHA(0x0038), TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256(0xC023), TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256(0xC027), TLS_RSA_WITH_AES_128_CBC_SHA256(0x003C), TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256(0xC025), TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256(0xC029), TLS_DHE_RSA_WITH_AES_128_CBC_SHA256(0x0067), TLS_DHE_DSS_WITH_AES_128_CBC_SHA256(0x0040), TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA(0xC009), TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA(0xC013), TLS_RSA_WITH_AES_128_CBC_SHA(0x002F), TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA(0xC004), TLS_ECDH_RSA_WITH_AES_128_CBC_SHA(0xC00E), TLS_DHE_RSA_WITH_AES_128_CBC_SHA(0x0033), TLS_DHE_DSS_WITH_AES_128_CBC_SHA(0x0032), TLS_EMPTY_RENEGOTIATION_INFO_SCSV(0x00FF)]",
  "compression methods" : "00",
  "extensions"          : [
    "status_request (5)": {
      "certificate status type": ocsp
      "OCSP status request": {
        "responder_id": &lt;empty&gt;
        "request extensions": {
          &lt;empty&gt;
        }
      }
    },
    "supported_groups (10)": {
      "versions": [secp256r1, secp384r1, secp521r1, sect283k1, sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, secp256k1, ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]
    },
    "ec_point_formats (11)": {
      "formats": [uncompressed]
    },
    "signature_algorithms (13)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "signature_algorithms_cert (50)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "status_request_v2 (17)": {
      "cert status request": {
        "certificate status type": ocsp_multi
        "OCSP status request": {
          "responder_id": &lt;empty&gt;
          "request extensions": {
            &lt;empty&gt;
          }
        }
      }
    },
    "extended_master_secret (23)": {
      &lt;empty&gt;
    },
    "supported_versions (43)": {
      "versions": [TLSv1.3, TLSv1.2, TLSv1.1, TLSv1]
    },
    "psk_key_exchange_modes (45)": {
      "ke_modes": [psk_dhe_ke]
    },
    "key_share (51)": {
      "client_shares": [  
        {
          "named group": secp256r1
          "key_exchange": {
            0000: 04 1F 80 50 D9 C6 03 45   7B 59 0F A7 B6 9E AE 39  ...P...E.Y.....9
            0010: 37 BE B0 5B 09 D8 91 37   72 5D 2B 8E 01 0A 84 56  7..[...7r]+....V
            0020: 99 0D 37 49 8F 92 61 A9   D6 54 E1 3B EE D1 E8 D2  ..7I..a..T.;....
            0030: 92 22 F9 17 CE A7 F8 51   47 C9 1E 5C D6 59 0F 4F  .".....QG..\.Y.O
            0040: 55 
          }
        },
      ]
    }
  ]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-4E2DAA95-0E80-4319-ADD6-49614E4CE119">显示已发送和读取的实际数据</p>
                           <p>调试输出显示发送到原始输出对象（在本例中为OutputStream）的实际数据：</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.770 EDT|SSLSocketOutputRecord.java:217|WRITE: TLS13 handshake, length = 405
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.774 EDT|SSLSocketOutputRecord.java:231|Raw write (
  0000: 16 03 03 01 95 01 00 01   91 03 03 64 CF 68 A1 CF  ...........d.h..
  0010: AB B1 6F 43 F6 DE 1B 49   49 DE 5A 42 9A 71 DD CB  ..oC...II.ZB.q..
  0020: 9A E3 9F 32 00 E8 87 7A   00 DA C6 20 02 0D BE 1B  ...2...z... ....
...
</code></pre><p>然后，调试输出显示在执行任何处理之前从输入设备（InputStream）读取的原始数据：</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.862 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 handshake, length = 155
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.863 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 02 00 00 97 03 03 66 24   0F F6 6D 4A 0C 5A A1 23  ......f$..mJ.Z.#
  0010: F6 5D 4B 87 B1 6E AC 13   BB 4D C1 A4 0F F0 2C EF  .]K..n...M....,.
  0020: D7 4F 03 11 19 B1 20 02   0D BE 1B A4 5F F2 E8 B6  .O.... ....._...
...</code></pre><p>每当客户端发送或读取消息时，调试输出就会显示发送或读取的原始数据以及如何处理任何消息（及其扩展名）。以下各节省略了调试输出的这些部分。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-70D10BBA-9A0A-45C5-A49F-4AC26CA9E5CC">阅读ServerHello消息</p>
                           <p>至此，已经协商了TLS 1.3。服务器选择TLS版本并结合使用服务器版本和supported_versions扩展名进行答复。在这种情况下，将指示TLSv1.3协议。</p>
                           <p>ServerHello消息指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>服务器版本：对于TLS 1.3，该值必须为TLSv1.2； TLS 1.3使用扩展名support_versions而不是此字段来表示协商的协议版本</p>
                              </li>
                              <li>
                                 <p>随机：也用于初始化密码算法</p>
                              </li>
                              <li>
                                 <p>会话ID：对于TLS 1.3，其值与ClientHello消息的相应字段相同</p>
                              </li>
                              <li>
                                 <p>密码套件：所选的密码套件；在此示例中，它是TLS_AES_128_GCM_SHA256</p>
                              </li>
                              <li>
                                 <p>压缩方法：对于TLS 1.3，此值必须为0</p>
                              </li>
                              <li>
                                 <p>扩展名</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>supported_versions：指定服务器使用哪个TLS版本。请注意，对于TLS 1.3，服务器必须使用ClientHello消息的support_versions扩展名的值进行版本协商，而不要使用客户端版本字段的值。</p>
                                    </li>
                                    <li>
                                       <p>key_share：ECDHE密钥交换的命名组和密钥值</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.863 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 handshake, length = 155
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.867 EDT|ServerHello.java:862|Consuming ServerHello handshake message (
"ServerHello": {
  "server version"      : "TLSv1.2",
  "random"              : "66 24 0F F6 6D 4A 0C 5A A1 23 F6 5D 4B 87 B1 6E AC 13 BB 4D C1 A4 0F F0 2C EF D7 4F 03 11 19 B1",
  "session id"          : "02 0D BE 1B A4 5F F2 E8 B6 31 9D A4 EF F3 22 84 C3 58 0B 5C C0 57 0F A5 6D 8A 83 EB DC DA B1 B6",
  "cipher suite"        : "TLS_AES_128_GCM_SHA256(0x1301)",
  "compression methods" : "00",
  "extensions"          : [
    "supported_versions (43)": {
      "selected version": [TLSv1.3]
    },
    "key_share (51)": {
      "server_share": {
        "named group": secp256r1
        "key_exchange": {
          0000: 04 DE 5B 20 0E FD EB 6E   DA 70 C2 D0 FA 0D 4C 53  ..[ ...n.p....LS
          0010: 6D E1 9E 67 77 65 36 AF   B5 EB E6 D2 88 92 9B EE  m..gwe6.........
          0020: E4 97 A3 B3 C1 FB D8 29   3B 92 87 D2 B3 9E 3D AA  .......);.....=.
          0030: 14 99 1E 84 8F C2 E9 E3   E1 AC 9A 12 95 F0 26 B5  ..............&amp;.
          0040: 88 
        }
      },
    }
  ]
}
)
...</code></pre><p>会话已初始化：</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.873 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-F3574858-FC6F-4225-800F-630FC0B2F338">阅读EncryptedExtensions消息</p>
                           <p>在握手的这一点上，已经交换了足够的密码信息，并且握手的其余部分将被加密。</p>
                           <p>EncryptedExtensions消息包含对ClientHello扩展的响应，除了特定于单个证书的响应之外，该响应不需要确定密码参数。在此示例中，它返回客户端支持密钥交换的命名组的列表。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.942 EDT|EncryptedExtensions.java:171|Consuming EncryptedExtensions handshake message (
"EncryptedExtensions": [
  "supported_groups (10)": {
    "versions": [secp256r1, secp384r1, secp521r1, sect283k1, sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, secp256k1, ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]
  }
]
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-2164FC41-F6C2-480B-BCFD-A2260B92588E">读取服务器的CertificateRequest消息</p>
                           <p>如果需要基于证书的客户端身份验证，服务器将发送CertificateRequest消息。此消息包含该证书的所需参数。它指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>certificate_request_context：标识证书申请的字符串；除非用于握手后身份验证，否则该字段的值为零长度</p>
                              </li>
                              <li>
                                 <p>扩展：以下两个扩展指示在数字签名中可以使用哪些签名算法：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>signature_algorithms：最初出现在TLS 1.2中，适用于CertificateVerify消息中的签名</p>
                                    </li>
                                    <li>
                                       <p>signature_algorithms_cert：适用于证书中的签名</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.947 EDT|CertificateRequest.java:864|Consuming CertificateRequest handshake message (
"CertificateRequest": {
  "certificate_request_context": "",
  "extensions": [
    "signature_algorithms (13)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "signature_algorithms_cert (50)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    }
  ]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-3FE3E95C-CD56-4170-ABA4-502151FF69D3">阅读服务器的证书消息</p>
                           <p>证书消息包含认证证书和证书链中的任何其他支持证书。它指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>certificate_request_context：对于服务器身份验证，此字段为空</li>
                              <li>certificate_list：包含由客户端发布的签名算法签名的证书链。但是，在此示例中，收到了自签名证书（主题和发行名称相同的证书）。该相同的自签名证书是在初始化期间较早发现的，因此当实际调用TrustManager来验证收到的证书时，它将被信任。</li>
                           </ul>
                           <p>建立信任的方法有很多，因此，如果默认的X509TrustManager没有执行所需的信任管理类型，则可以向SSLContext提供自己的X509TrustManager。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.964 EDT|CertificateMessage.java:1148|Consuming server Certificate handshake message (
"Certificate": {
  "certificate_request_context": "",
  "certificate_list": [  
  {
    "certificate" : {
      "version"            : "v1",
      "serial number"      : "41 00 44 46",
      "signature algorithm": "MD5withRSA",
      "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
      "not before"         : "2004-07-22 18:48:38.000 EDT",
      "not  after"         : "2011-05-22 18:48:38.000 EDT",
      "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
      "subject public key" : "RSA"}
    "extensions": {
      &lt;no extension&gt;
    }
  },
]
}
)
...</code></pre><p>客户端识别此证书并可以信任它。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.165 EDT|X509TrustManagerImpl.java:242|Found trusted certificate (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "41 00 44 46",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "not before"         : "2004-07-22 18:48:38.000 EDT",
    "not  after"         : "2011-05-22 18:48:38.000 EDT",
    "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "subject public key" : "RSA"}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-AB70F624-B04D-4D2F-9DAB-76A8E19B33AC">阅读服务器的证书验证消息</p>
                           <p>服务器发送的证书通过CertificateVerify消息进行验证。该消息用于提供明确的证明，证明服务器具有与其证书相对应的私钥。该消息指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>签名算法：使用的签名算法；在此示例中，它是rsa_pss_rsae_sha256。</p>
                              </li>
                              <li>
                                 <p>签名：使用与证书消息中的公钥相对应的私钥对整个握手进行签名</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.194 EDT|CertificateVerify.java:1128|Consuming CertificateVerify handshake message (
"CertificateVerify": {
  "signature algorithm": rsa_pss_rsae_sha256
  "signature": {
    0000: 0F 25 DD 62 03 6B 8C 8F   22 C7 8D 46 A2 A6 45 39  .%.b.k.."..F..E9
    0010: 08 8D 51 1E 48 52 66 A4   F8 28 D3 FD 18 93 70 C6  ..Q.HRf..(....p.
    0020: 32 74 C1 CC 0A C4 60 41   50 AF 7C DA 0C DB 92 F9  2t....`AP.......
    0030: 14 CB EF 15 7F 3E 52 16   F7 CC 8A 7C C9 1F 42 CA  .....&gt;R.......B.
    0040: 90 8D FA B7 F2 3A 46 7E   F7 9F 43 CE C6 AA 15 59  .....:F...C....Y
    0050: EE AD 34 10 FF B7 BC FD   A2 F7 F3 1A FA 7F 26 61  ..4...........&amp;a
    0060: 80 2B 50 3A 8A 9E 5C 0E   4C A6 24 DA E6 3D 71 FA  .+P:..\.L.$..=q.
    0070: AE 78 79 D2 DA 36 DE C1   A6 BC 18 46 04 CE 03 4E  .xy..6.....F...N
  }
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-586988CB-FCBF-495C-9651-DBCA787589AE">阅读服务器的完成消息</p>
                           <p>服务器发送完成消息。该消息包含整个握手过程中的消息身份验证代码（MAC）。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-17 01:56:26.764 EDT|Finished.java:860|Consuming server Finished handshake message (
"Finished": {
  "verify data": {
    0000: CA 7B 74 A6 79 36 ED 62   A7 0E 14 9D 9F D0 4A 0F  ..t.y6.b......J.
    0010: 02 4C 78 BB E2 89 A2 C6   E8 BD 28 CA E7 D9 DB 68  .Lx.......(....h
  }'}
)
...
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-9BD61A81-99B4-46CB-97D7-8410C5830206">发送证书消息</p>
                           <p>客户端发送证书消息，因为服务器通过证书请求消息请求了客户端身份验证。证书消息指定与服务器的证书消息类似的信息。客户端需要将凭据发送回服务器，因此请咨询其X509KeyManager。客户端在接受的颁发者列表和KeyStore中的证书之间寻找匹配项。在这种情况下，存在一个匹配项：客户端具有“ duke”的凭据。现在由服务器的X509TrustManager决定是否接受这些凭据。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.222 EDT|CertificateMessage.java:1116|Produced client Certificate message (
"Certificate": {
  "certificate_request_context": "",
  "certificate_list": [  
  {
    "certificate" : {
      "version"            : "v1",
      "serial number"      : "3B 0A FA 66",
      "signature algorithm": "MD5withRSA",
      "issuer"             : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
      "not before"         : "2001-05-22 19:46:46.000 EDT",
      "not  after"         : "2011-05-22 19:46:46.000 EDT",
      "subject"            : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
      "subject public key" : "RSA"}
    "extensions": {
      &lt;no extension&gt;
    }
  },
]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-AC376873-60BB-4C61-9F37-9936860ED312">发送证书验证消息</p>
                           <p>与服务器发送的CertificateVerify消息一样，客户端发送的证书也通过CertificateVerify消息进行验证。该消息用于提供明确的证据，表明客户端具有与其证书相对应的私钥。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.268 EDT|CertificateVerify.java:1097|Produced client CertificateVerify handshake message (
"CertificateVerify": {
  "signature algorithm": rsa_pss_rsae_sha256
  "signature": {
    0000: 91 C2 F7 5D 8D 90 B4 82   E4 BA C6 23 08 E2 B4 DD  ...].......#....
    0010: 8D 95 8F 9F 31 4F 26 F3   97 3B FB 5B 10 4D AE F6  ....1O&amp;..;.[.M..
    0020: 71 78 FB 7B 3A 4F F6 1B   BF D2 E3 FB BE 53 F6 70  qx..:O.......S.p
    0030: 7E 73 83 F4 9A 5E 08 19   63 C1 97 4C 10 B1 C7 3F  .s...^..c..L...?
    0040: 4A 7D EF 4A 30 44 15 9F   D0 F2 8B C4 D1 45 69 B1  J..J0D.......Ei.
    0050: D9 DB 45 83 C4 11 91 B3   81 5E 69 F4 5C 2A CF 69  ..E......^i.\*.i
    0060: D3 A6 7E 75 B4 C9 30 FB   5B AC BA 9F A3 C5 0C FD  ...u..0.[.......
    0070: 9A 62 A4 DA 5A 80 6B 72   CD F5 A5 53 AD 14 74 1C  .b..Z.kr...S..t.
  }
}
)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-23D15A1E-731F-46BD-A55E-80BBBF815B89">发送完成的消息</p>
                           <p>然后，客户端将其Finished消息发送到服务器：</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.271 EDT|Finished.java:658|Produced client Finished handshake message (
"Finished": {
  "verify data": {
    0000: 93 04 B5 23 8F 48 3A CF   4A 85 35 9E 5F E0 1D 4C  ...#.H:.J.5._..L
    0010: 9C 65 06 D4 E8 B4 ED 8F   01 6B 1E A2 DD 18 BD 78  .e.......k.....x
  }'}
)
...</code></pre><p>客户端和服务器已经验证了从对等方收到的Finished消息。双方现在都可以通过连接发送和接收应用程序数据。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-D712952D-0008-420C-B12D-5F8581E4FA11">交换应用程序数据，客户端发送GET命令</p>
                           <p>服务器和客户端已准备好交换应用程序数据。客户端发送“ GET /index.html HTTP1.0”命令。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.375 EDT|SSLCipher.java:2019|Plaintext before ENCRYPTION (
  0000: 47 45 54 20 2F 69 6E 64   65 78 2E 68 74 6D 6C 20  GET /index.html 
  0010: 48 54 54 50 2F 31 2E 30   0D 0A 0D 0A 17 00 00 00  HTTP/1.0........
  0020: 00 00 00 00 00 00 00 00   00 00 00 00 00           .............
)
...</code></pre><p>请注意，网上的数据是加密的：</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.385 EDT|SSLSocketOutputRecord.java:295|Raw write (
  0000: 17 03 03 00 3D 90 BF D1   81 E6 A3 E7 DA 50 A9 8B  ....=........P..
  0010: 18 F5 4B 30 AE 59 41 81   25 C4 9E 3E 70 29 5D C6  ..K0.YA.%..&gt;p)].
  0020: 64 49 0B 4A 0E 93 E3 8F   DC 42 BA B5 21 42 38 88  dI.J.....B..!B8.
  0030: 62 4D 0C 86 FE 9A 8C B9   95 EF 89 93 61 3C 13 69  bM..........a&lt;.i
  0040: 6C 45                                              lE
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-4F657491-E51C-4C8B-8D19-6A23D7B4F3A3">阅读NewSessionTicket消息</p>
                           <p>服务器收到客户端的Finished消息后，可以随时发送NewSessionTicket消息，其中包含一个PSK票证，客户端可以使用它来加快以后的握手速度。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.517 EDT|NewSessionTicket.java:330|Consuming NewSessionTicket message (
"NewSessionTicket": {
  "ticket_lifetime"      : "86,400",
  "ticket_age_add"       : "&lt;omitted&gt;",
  "ticket_nonce"         : "01",
  "ticket"               : "A5 30 8C B6 AD 95 79 E8 2A D1 95 C0 F0 2F 6F AA 9E 97 58 AA 3D 19 82 2D 2C 47 C0 ED BF 64 48 AB",
  "extensions"           : [
    &lt;no extension&gt;
  ]
}
)
</code></pre><p>创建一个重复的SSLSession，并附加新生成的PSK信息。</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.517 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-B52EE7D3-C65E-4961-9807-94DF4D51E2B6">Exchange应用程序数据，服务器发送HTTPS标头和数据</p>
                           <p>客户端从服务器接收应用程序数据，首先是HTTPS标头，然后是实际数据。</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.517 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.617 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 17 03 03 00 63                                     ....c
)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.618 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 application_data, length = 99
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.618 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 65 87 0E 1E 78 F7 AC C4   F7 C6 4D 55 91 6F 72 CC  e...x.....MU.or.
  0010: 18 2D 74 C3 B6 7B 2A F9   EB 2B F4 A8 C7 FD 09 FA  .-t...*..+......
  0020: 7E 36 9D F7 88 E7 44 DD   60 AF EB B0 F8 CF E1 64  .6....D.`......d
  0030: 0D 9B F4 B0 24 C2 BC B1   BF F7 F2 B6 CB E4 2E 39  ....$..........9
  0040: 78 B8 73 09 91 65 7A 0F   4C 49 DE 9A 7F 7B 42 86  x.s..ez.LI....B.
  0050: CA 33 87 DB 0D B2 E5 61   3C 70 6F F9 6A 15 A9 74  .3.....a&lt;po.j..t
  0060: 64 E0 B0                                           d..
)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.619 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 application_data, length = 99
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.621 EDT|SSLCipher.java:1914|Plaintext after DECRYPTION (
  0000: 48 54 54 50 2F 31 2E 30   20 32 30 30 20 4F 4B 0D  HTTP/1.0 200 OK.
  0010: 0A 43 6F 6E 74 65 6E 74   2D 4C 65 6E 67 74 68 3A  .Content-Length:
  0020: 20 32 35 37 37 0D 0A 43   6F 6E 74 65 6E 74 2D 54   2577..Content-T
  0030: 79 70 65 3A 20 74 65 78   74 2F 68 74 6D 6C 0D 0A  ype: text/html..
  0040: 0D 0A                                              ..
)
...
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.626 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 application_data, length = 2610
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.628 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 69 8D F9 A3 E9 25 09 87   F0 E0 A1 63 12 9D 81 DF  i....%.....c....
  0010: 42 FC FA 7A 03 74 FD D5   ED 47 6C 5F 61 F2 BB 39  B..z.t...Gl_a..9
  0020: CF 64 0B B2 10 14 24 99   A3 66 8B D2 13 C9 66 FD  .d....$..f....f.
...
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.642 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 application_data, length = 2610
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.647 EDT|SSLCipher.java:1914|Plaintext after DECRYPTION (
  0000: 3C 21 44 4F 43 54 59 50   45 20 68 74 6D 6C 20 50  &lt;!DOCTYPE html P
  0010: 55 42 4C 49 43 20 22 2D   2F 2F 57 33 43 2F 2F 44  UBLIC "-//W3C//D
  0020: 54 44 20 58 48 54 4D 4C   20 31 2E 30 20 54 72 61  TD XHTML 1.0 Tra
  0030: 6E 73 69 74 69 6F 6E 61   6C 2F 2F 45 4E 22 0A 20  nsitional//EN". 
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-95CFC30C-569C-45DD-8659-8C3ADA3C77B2">阅读服务器的警报消息</p>
                           <p>服务器发送close_notify警报，该警报通知客户端它将不再通过此连接发送消息。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.658 EDT|Alert.java:232|Received alert message (
"Alert": {
  "level"      : "warning",
  "description": "close_notify"
}
)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-487D7D13-FF82-4D6A-895F-817C485E0DAE">关闭连接</p>
                           <p>服务器先关闭套接字，然后再关闭TLS连接。</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:1161|close the underlying socket
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:921|close the ssl connection (passive)
javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:658|Closing input stream
javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:728|Closing output stream</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4" name="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4"></a><h3 id="JSSEC-GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4" class="sect3">兼容性风险和已知问题</h3>
               <div>
                  <p>JSSE的增强可能会引入兼容性问题和其他已知问题，这将在本节中进行介绍。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4__GUID-833724A2-7992-4418-BE39-885C8DC6A93A">TLS 1.3与以前的版本不直接兼容</p>
                     <p>TLS 1.3与以前的版本不直接兼容。尽管可以使用向后兼容模式来实现TLS 1.3，但是在升级到TLS 1.3时仍要考虑一些兼容性风险：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>TLS 1.3使用半关闭策略，而TLS 1.2和更早版本使用双关闭策略。对于依赖于双工关闭策略的应用程序，升级到TLS 1.3时可能存在兼容性问题。</p>
                        </li>
                        <li>
                           <p>signature_algorithms_cert扩展要求将预定义的签名算法用于证书身份验证。但是，实际上，应用程序可能会使用不受支持的签名算法。</p>
                        </li>
                        <li>
                           <p>TLS 1.3不支持DSA签名算法。如果将服务器配置为仅使用DSA证书，则它无法协商TLS 1.3连接。</p>
                        </li>
                        <li>
                           <p>TLS 1.3支持的密码套件与TLS 1.2及更早版本不同。如果应用程序对不再支持的密码套件进行硬编码，则在不修改其代码的情况下可能无法使用TLS 1.3，例如TLS_AES_128_GCM_SHA256（1.3和更高版本）与TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（1.2和更低版本）。</p>
                        </li>
                        <li>
                           <p>TLS 1.3会话恢复和密钥更新行为与TLS 1.2和更早版本不同。兼容性影响应该很小，但是如果应用程序依赖TLS协议的握手详细信息，则可能会有风险。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4" name="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4"></a><h3 id="JSSEC-GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4" class="sect3">程式码范例</h3>
               <div>
                  <p>本节中包含以下代码示例：</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4__GUID-2FFB20C7-211D-4A60-8C79-400C589E83EF">话题</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" title="代码示例说明了如何使用JSSE将不安全的套接字连接转换为安全的套接字连接。该代码示例摘自Marco Pistoia等人撰写的Java SE 6 Network Security一书。等">将不安全的套接字转换为安全套接字</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" title="JSSE示例程序说明了如何使用JSSE。">运行JSSE示例代码</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="有关如何使用keytool实用程序来创建适用于JSSE的简单PKCS12密钥库的过程。">创建用于JSSE的密钥库</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-63945B45-E909-483F-B3A9-E26586737383">使用服务器名称指示（SNI）扩展</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" name="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD"></a><h4 id="JSSEC-GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" class="sect4">将不安全的套接字转换为安全套接字</h4>
                  <div>
                     <p>代码示例说明了如何使用JSSE将不安全的套接字连接转换为安全的套接字连接。该代码示例摘自Marco Pistoia等人撰写的Java SE 6 Network Security一书。等</p>
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">例8-26</a>显示了示例代码，这些代码可用于使用不安全的套接字在客户端和服务器之间建立通信。然后在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">示例8-27中</a>修改此代码，以使用JSSE建立安全的套接字通信。
                     </p>
                     <div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">
                        <p class="titleinexample">示例8-26不带SSL的套接字示例</p>
                        <p>以下示例演示了用于建立不安全套接字连接的服务器端和客户端代码。</p>
                        <p>在充当服务器并使用套接字与客户端进行通信的Java程序中，套接字通信使用类似于以下代码的方式进行设置：</p><pre class="codeblock"><code>
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    
    ServerSocket s;
    
    try {
        s = new ServerSocket(port);
        Socket c = s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    } catch (IOException e) { }
</code></pre><p>用于使用套接字建立与服务器通信的客户端代码类似于以下内容：</p><pre class="codeblock"><code>
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        s = new Socket(host, port);
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    } catch (IOException e) { }
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">
                        <p class="titleinexample">示例8-27使用SSL的套接字示例</p>
                        <p>以下示例演示了用于建立安全套接字连接的服务器端和客户端代码。</p>
                        <p>在充当服务器并使用安全套接字与客户端进行通信的Java程序中，套接字通信使用类似于以下代码的方式进行设置。该程序与使用不安全套接字进行通信的程序之间的差异以粗体突出显示。</p><pre class="codeblock"><code>
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    
    <span class="bold">SSLServerSocket</span> s;
    
    try {
        <span class="bold">SSLServerSocketFactory sslSrvFact =
            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
        s = (SSLServerSocket)sslSrvFact.createServerSocket(port);</span>
    
        <span class="bold">SSLSocket</span> c = <span class="bold">(SSLSocket)</span>s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</code></pre><p>用于使用安全套接字与服务器建立通信的客户端代码类似于以下内容，其中与不安全版本的区别以粗体突出显示：</p><pre class="codeblock"><code>
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        <span class="bold">SSLSocketFactory sslFact =
            (SSLSocketFactory)SSLSocketFactory.getDefault();
        SSLSocket s = (SSLSocket)sslFact.createSocket(host, port);</span>
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" name="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA"></a><h4 id="JSSEC-GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" class="sect4">运行JSSE示例代码</h4>
                  <div>
                     <p>JSSE示例程序说明了如何使用JSSE。</p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">示例代码说明了客户端和服务器之间的安全套接字连接</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">说明HTTPS连接的示例代码</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">说明安全RMI连接的示例代码</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">说明使用SSLEngine的示例代码</a></li>
                        </ul>
                        <p>使用示例代码时，请注意，示例程序旨在说明如何使用JSSE。它们并非设计为可靠的应用程序。</p>
                        <div class="p"> 
                           <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D989BF26-8A0F-46AD-A2E6-83C41C9642B3">
                              <p class="notep1">注意：</p>设置安全通信涉及复杂的算法。示例程序在设置过程中不提供任何反馈。在运行程序时，请耐心等待：您可能会暂时看不到任何输出。如果您使用<code class="codeph">javax.net.debug</code>系统属性设置为<code class="codeph">all</code> ，您将看到更多反馈。有关读取此调试信息的介绍，请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6">调试TLS连接</a> 。
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D24E673C-F5E8-41E1-9DA5-3B642EA482E3">在哪里找到示例代码</p>
                        <p><span>JDK 8文档中的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a></span>列出了所有示例代码文件和文本文件。该页面还提供了一个ZIP文件的链接，您可以下载该ZIP文件以获得所有示例代码文件。
                        </p>
                        <p>以下各节介绍了示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-EB08FD38-4235-478D-952E-543CA50F69A4">示例代码说明了客户端和服务器之间的安全套接字连接</p>
                        <p>中的示例程序<code class="codeph">samples/sockets</code>目录说明了如何在客户端和服务器之间建立安全的套接字连接。
                        </p>
                        <p>在运行示例客户端程序时，您可以与现有服务器（例如Web服务器）进行通信，也可以与示例服务器程序进行通信， <code class="codeph">ClassFileServer</code> 。您可以在连接到同一网络的不同计算机上运行示例客户端和示例服务器程序，也可以在一台计算机上从不同的终端窗口运行它们。
                        </p>
                        <p>所有样品<code class="codeph">SSLSocketClient*</code> samples / sockets / client目录中的程序（和<code class="codeph">URLReader*</code>可以在<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">示例代码示例HTTPS连接中</a>描述的程序）与<code class="codeph">ClassFileServer</code>示例服务器程序。<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">使用ClassFileServer运行SSLSocketClientWithClientAuth中</a>显示了如何执行此操作的示例。您可以进行类似的更改以运行<code class="codeph">URLReader</code> ， <code class="codeph">SSLSocketClient</code> ， 要么<code class="codeph">SSLSocketClientWithTunneling</code>与<code class="codeph">ClassFileServer</code> 。
                        </p>
                        <p>如果客户端和服务器之间的通信过程中发生身份验证错误（无论是使用Web服务器还是<code class="codeph">ClassFileServer</code> ），这很可能是因为必要的密钥不在信任库（信任密钥数据库）中。请参阅<a href="terms-and-definitions.html" title="以下是常用的密码术术语及其定义。">术语和定义</a> 。例如， <code class="codeph">ClassFileServer</code>使用名为<code class="codeph">testkeys</code>包含的私钥<code class="codeph">localhost</code>在SSL握手期间根据需要。的<code class="codeph">testkeys</code>密钥库包含在与密钥库相同的sample / sockets / server目录中<code class="codeph">ClassFileServer</code>资源。如果客户端找不到对应于的公共密钥的证书<code class="codeph">localhost</code>在它查询的信任库中，将发生身份验证错误。请务必使用<code class="codeph">samplecacerts</code>信任库（包含公钥和证书的证书） <code class="codeph">localhost</code> ），如下一节所述。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__CONFIGURATIONREQUIREMENTS-82CE87BD">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-E82A76FE-0D76-4C9C-8850-998385DBC5FC">配置要求</p>
                        <p>运行在客户端和服务器之间创建安全套接字连接的示例程序时，需要使相应的证书文件（信任库）可用。对于客户端程序和服务器程序，都应使用证书文件<code class="codeph">samplecacerts</code>来自<code class="codeph">samples</code>目录。使用此证书文件将允许客户端对服务器进行身份验证。该文件包含JDK随附的所有通用证书颁发机构（CA）证书（在cacerts文件中），以及用于<code class="codeph">localhost</code>客户需要进行身份验证<code class="codeph">localhost</code>与样本服务器通信时<code class="codeph">ClassFileServer</code> 。的<code class="codeph">ClassFileServer</code>使用包含私钥的密钥库<code class="codeph">localhost</code>对应于<code class="codeph">samplecacerts</code> 。
                        </p>
                        <p>为了使<code class="codeph">samplecacerts</code>客户端和服务器均可使用的文件，您可以将其复制到文件中<code>java-home/lib/security/jssecacerts</code> ，将其重命名为cacerts，并用其替换<code>java-home/lib/security/cacerts</code>文件，或在运行以下命令时将以下选项添加到命令行<code class="codeph">java</code>客户端和服务器的命令：</p><pre class="codeblock"><code>-Djavax.net.ssl.trustStore=<span class="variable" translate="no">path_to_samplecacerts_file</span>
</code></pre><p>要了解有关<span class="variable" translate="no">java-home</span>更多信息，请参阅<a href="terms-and-definitions.html" title="以下是常用的密码术术语及其定义。">术语和定义</a> 。
                        </p>
                        <p>的密码<code class="codeph">samplecacerts</code>信任库为<code class="codeph">changeit</code> 。您可以使用<code class="codeph">keytool</code>效用。
                        </p>
                        <p>如果您使用浏览器（例如Mozilla Firefox或Microsoft Internet Explorer）来访问<code class="codeph">ClassFileServer</code>例如，然后可能会弹出一个对话框，提示您无法识别证书。这是正常的，因为与示例程序一起使用的证书是自签名的，并且仅用于测试。您可以接受当前会话的证书。在测试SSL服务器之后，您应该退出浏览器，该浏览器将从浏览器的名称空间中删除测试证书。
                        </p>
                        <p>对于客户端身份验证，单独<code class="codeph">duke</code>证书位于相应的目录中。公钥和证书也存储在<code class="codeph">samplecacerts</code>文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENT-82CE8C59">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-602AB8D6-E941-45E3-87B2-2D94C8E57124">运行SSLSocketClient</p>
                        <p>的<code class="codeph">SSLSocketClient.java</code> <span>JDK 8文档</span>中<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的Java</span>程序演示了如何创建使用<code class="codeph">SSLSocket</code>发送HTTP请求并从HTTPS服务器获得响应。该程序的输出是HTML源代码，用于<code class="codeph">https://www.verisign.com/index.html</code> 。
                        </p>
                        <p>您一定不能在防火墙后面运行该程序。如果从防火墙后面运行它，则会得到一个<code class="codeph">UnknownHostException</code>因为JSSE无法通过防火墙找到通往<code class="codeph">www.verisign.com</code> 。要创建可以从防火墙后面运行的等效客户端，请如示例程序中所示设置代理隧道。 <code class="codeph">SSLSocketClientWithTunneling</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHTUNNELING-82CE8F98">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-64521705-A715-4BC0-B52F-ED2CC2283E3B">运行SSLSocketClientWithTunneling</p>
                        <p>的<code class="codeph">SSLSocketClientWithTunneling.java</code> <span>JDK 8文档</span>中的<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的Java</span>程序演示了如何执行代理隧道以从防火墙后面访问安全的Web服务器。要运行此程序，必须将以下Java系统属性设置为适当的值：</p><pre class="codeblock"><code>java -Dhttps.proxyHost=<span class="variable" translate="no">webproxy</span>
-Dhttps.proxyPort=<span class="variable" translate="no">ProxyPortNumber</span>
SSLSocketClientWithTunneling
</code></pre><div class="p">
                           <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-12EDAEC4-5DE4-4BD8-A68C-E096E92AE49B">
                              <p class="notep1">注意：</p>代理规格<code class="codeph">-D</code>选项是可选的。将<span class="variable" translate="no">webproxy</span>替换为代理主机的名称，并将<span class="variable" translate="no">ProxyPortNumber</span>替换为适当的端口号。
                           </div> 
                        </div>
                        <p>该程序将从以下位置返回HTML源文件<code class="codeph">https://www.verisign.com/index.html</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23C25E">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-AC110522-A3EE-479E-BD16-7946F66F9CD2">运行SSLSocketClientWithClientAuth</p>
                        <p>的<code>SSLSocketClientWithClientAuth.java</code> <span>JDK 8文档</span>中<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的Java</span>程序演示了如何设置密钥管理器以进行服务器身份验证（如果服务器需要）。该程序还假定客户端不在防火墙之外。您可以按照以下示例修改程序以从防火墙内部进行连接<code class="codeph">SSLSocketClientWithTunneling</code> 。
                        </p>
                        <p>要运行该程序，必须指定三个参数：主机，端口和请求的文件路径。为了反映前面的示例，您可以通过将主机设置为来运行此程序而无需客户端身份验证<code class="codeph">www.verisign.com</code> ，前往的港口<code class="codeph">443</code> ，以及请求的文件路径<code class="codeph">https://www.verisign.com/</code> 。使用这些参数时的输出是网站的HTML <code class="codeph">https://www.verisign.com/</code> 。
                        </p>
                        <p>跑步<code class="codeph">SSLSocketClientWithClientAuth</code>要进行客户端身份验证，您必须访问请求客户端身份验证的服务器。您可以使用示例程序<code class="codeph">ClassFileServer</code>作为此服务器。以下各节对此进行了描述。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-7411C2BE-80B1-43A0-A501-CAE5D9A93E86">运行ClassFileServer</p>
                        <p>该程序在本文中称为<code class="codeph">ClassFileServer</code>由两个文件组成： <code>ClassFileServer.java</code>和<code>ClassServer.java</code>在<span>JDK 8文档的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中</span> 。
                        </p>
                        <p>要执行它们，运行<code class="codeph">ClassFileServer.class</code> ，它需要以下参数：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">port</code>可以是任何可用的未使用端口号，例如，您可以使用该端口号<code class="codeph">2001</code> 。
                           </li>
                           <li><code class="codeph">docroot</code>指示服务器上包含您要检索的文件的目录。例如，在Solaris上，可以使用/ home / <span class="variable" translate="no">userid</span> /（其中<span class="variable" translate="no">userid</span>指的是特定的UID），而在Microsoft Windows系统上，可以使用c：\。
                           </li>
                           <li><code class="codeph">TLS</code>是一个可选参数，指示服务器将使用SSL或TLS。</li>
                           <li><code class="codeph">true</code>是一个可选参数，指示需要客户端身份验证。仅当设置了TLS参数时，才查询此参数。
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-4635E921-C2B5-4FD5-9480-6478D6C33FC0">
                           <p class="notep1">注意：</p>的<code class="codeph">TLS</code>和<code class="codeph">true</code>参数是可选的。如果您省略它们，表示应使用普通（非TLS）文件服务器，而无需身份验证，则不会发生任何事情。这是因为一侧（客户端）正尝试与TLS协商，而另一侧（服务器）未与TLS协商，因此它们无法通信。
                        </div> 
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-F17E9E88-69BB-4873-AC14-BA2B42917D05">
                           <p class="notep1">注意：</p>服务器期望GET请求的形式为<code class="codeph">GET /<span class="variable" translate="no">path_to_file</span></code> 。
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-E305855C-9AE0-44F8-A077-6BF06A3C4C4F">使用ClassFileServer运行SSLSocketClientWithClientAuth</p>
                        <p>您可以使用示例程序<code>SSLSocketClientWithClientAuth.java</code>和<code class="codeph">ClassFileServer</code>在<span>JDK 8文档的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中，</span>可以设置经过身份验证的通信，在该通信中，客户端和服务器相互进行了身份验证。您可以在连接到同一网络的不同计算机上运行两个示例程序，也可以在一台计算机上从不同的终端窗口或命令提示符窗口运行它们。要设置客户端和服务器，请执行以下操作：</p>
                        <ol>
                           <li>运行程序<code class="codeph">ClassFileServer</code>从一台机器或终端窗口。
                              <p>请参阅<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">运行ClassFileServer</a> 。
                              </p>
                           </li>
                           <li>运行程序<code class="codeph">SSLSocketClientWithClientAuth</code>在另一台计算机或终端窗口上。 <code class="codeph">SSLSocketClientWithClientAuth</code>需要以下参数：<ul style="list-style-type:disc">
                                 <li><code class="codeph">host</code>是用于运行的计算机的主机名<code class="codeph">ClassFileServer</code> 。
                                 </li>
                                 <li><code class="codeph">port</code>与您指定的端口相同<code class="codeph">ClassFileServer</code> 。
                                 </li>
                                 <li> 
                                    <p><code class="codeph">requestedfilepath</code>表示要从服务器检索的文件的路径。您必须将此参数指定为<code class="codeph">/filepath</code> 。文件路径中需要使用正斜杠，因为它用作GET语句的一部分，无论您运行的是哪种操作系统，该语句都需要正斜杠。该语句的格式如下：</p> <pre class="codeblock"><code>"GET " + requestedfilepath + " HTTP/1.0"
</code></pre></li>
                              </ul> 
                           </li>
                        </ol> 
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-80571B4D-FD52-412D-80AF-BB6FF98147C3">
                           <p class="notep1">注意：</p>您可以修改其他<code class="codeph">SSLClient*</code>应用程序的<code class="codeph">GET</code>命令连接到正在运行的本地计算机<code class="codeph">ClassFileServer</code> 。
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-9CB1D70B-E67B-48AC-A21B-F09E66E24C41">说明HTTPS连接的示例代码</p>
                        <p>有两种主要的API，用于通过JSSE访问安全通信。一种方法是通过套接字级别的API，该API可用于任意安全的通信，如<code class="codeph">SSLSocketClient</code> ， <code class="codeph">SSLSocketClientWithTunneling</code>和<code class="codeph">SSLSocketClientWithClientAuth</code> （有和没有<code class="codeph">ClassFileServer</code> ）示例程序。
                        </p>
                        <p>第二种方法（通常是更简单的方法）是通过标准Java URL API。您可以使用HTTPS URL协议或使用以下协议的方案与启用SSL的Web服务器进行安全通信： <code class="codeph">java.net.URL</code>类。
                        </p>
                        <p>许多常见的浏览器都实现了对HTTPS URL方案的支持，从而无需访问JSSE随附的套接字级API即可访问安全通信。</p>
                        <p>一个示例URL是<code class="codeph">https://www.verisign.com</code> 。
                        </p>
                        <p>HTTPS URL实施的信任和密钥管理是特定于环境的。JSSE实现提供HTTPS URL实现。要使用其他HTTPS协议实现，请设置<code class="codeph">java.protocol.handler.pkgs</code> 。请参见<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">如何指定java.lang。系统属性</a>为程序包名称。见<code class="codeph">java.net.URL</code>类文档以获取详细信息。
                        </p>
                        <p>您可以使用JSSE下载的示例包括两个示例程序，这些示例程序说明了如何创建HTTPS连接。这两个示例程序（ <code>URLReader.java</code>和<code>URLReaderWithOptions.java</code> ）在<code class="codeph">samples/urls</code>目录。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADER-7D238A63">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-C78194C9-255C-4127-B5DA-6E81FC37BF4F">运行URLReader</p>
                        <p>的<code>URLReader.java</code> <span>JDK 8文档</span>中<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的Java</span>程序演示了如何使用URL类访问安全站点。该程序的输出是HTML源代码，用于<code class="codeph">https://www.verisign.com/</code> 。默认情况下，使用JSSE随附的HTTPS协议实现。要使用其他实现，请设置系统属性<code class="codeph">java.protocol.handler.pkgs</code> value为包含实现的包的名称。
                        </p>
                        <p>如果您正在防火墙后运行示例代码，则必须设置<code class="codeph">https.proxyHost</code>和<code class="codeph">https.proxyPort</code>系统属性。例如，要在端口8080上使用代理主机“ webproxy”，可以将以下选项用于<code class="codeph">java</code>命令：</p><pre class="codeblock"><code>-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</code></pre><p>或者，您可以使用以下命令在源代码中设置系统属性： <code class="codeph">java.lang.System</code>方法<code class="codeph">setProperty()</code> 。例如，您可以在程序中包括以下几行，而不使用命令行选项：</p><pre class="codeblock"><code>System.setProperty("java.protocol.handler.pkgs", "com.ABC.myhttpsprotocol");
System.setProperty("https.proxyHost", "webproxy");
System.setProperty("https.proxyPort", "8080");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADERWITHOPTIONS-7D238F45">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-C9D64F26-3785-4D0E-9730-C6F742121933">运行URLReaderWithOptions</p>
                        <p>的<code>URLReaderWithOptions.java</code> <span>JDK 8文档</span>中的<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的</span>程序与<code class="codeph">URLReader.java</code>程序，不同之处在于它允许您在运行程序时有选择地输入以下任何或所有以下系统属性作为程序的参数：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">java.protocol.handler.pkgs</code></li>
                           <li><code class="codeph">https.proxyHost</code></li>
                           <li><code class="codeph">https.proxyPort</code></li>
                           <li><code class="codeph">https.cipherSuites</code></li>
                        </ul>
                        <p>跑步<code class="codeph">URLReaderWithOptions</code> ，输入以下命令：</p><pre class="codeblock"><code>java URLReaderWithOptions [-h <span class="variable" translate="no">proxyhost</span> -p <span class="variable" translate="no">proxyport</span>] [-k <span class="variable" translate="no">protocolhandlerpkgs</span>] [-c <span class="variable" translate="no">ciphersarray</span>]
</code></pre><div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-91B04C04-7256-438A-8976-CFF5EC570A16">
                           <p class="notep1">注意：</p>多个协议处理程序可以包含在<code class="codeph">protocolhandlerpkgs</code>参数为列表，其中各项之间用竖线分隔。多个SSL密码套件名称可以包含在<code class="codeph">ciphersarray</code>参数为列表，其中各项之间用逗号分隔。可能的密码套件名称与密码套件名称返回的密码套件名称相同。 <code class="codeph">SSLSocket.getSupportedCipherSuites()</code>方法。套件名称取自SSL和TLS协议规范。
                        </div>
                        <p>你需要一个<code class="codeph">protocolhandlerpkgs</code>仅当您要使用Oracle提供的默认HTTPS协议处理程序实现以外的其他参数时，才使用此参数。
                        </p>
                        <p>如果要在防火墙后面运行示例代码，则必须包括代理主机和代理端口的参数。此外，您可以包括要启用的密码套件的列表。</p>
                        <p>这是一个跑步的例子<code class="codeph">URLReaderWithOptions</code>并在端口8080上指定代理主机“ webproxy”：</p><pre class="codeblock"><code>java URLReaderWithOptions -h webproxy -p 8080
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-95DD1C8D-09FB-425E-8211-4262B2C00CC2">说明安全RMI连接的示例代码</p>
                        <p>中的示例代码<code>samples/rmi</code>目录说明了如何创建安全的Java远程方法调用（RMI）连接。该示例代码基本上是一个“ Hello World”示例，已修改为安装和使用自定义RMI套接字工厂。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-57A08D48-9BA5-4E30-B6F0-676464818ABC">说明使用SSLEngine的示例代码</p>
                        <p><code class="codeph">SSLEngine</code>在选择I / O和计算策略时为应用程序开发人员提供了灵活性。而不是将SSL / TLS实现绑定到特定的I / O抽象（例如单线程） <code class="codeph">SSLSockets</code> ）， <code class="codeph">SSLEngine</code>从SSL / TLS实现中删除I / O和计算约束。
                        </p>
                        <p>如前面提到的， <code class="codeph">SSLEngine</code>是高级API，不适合随便使用。这里提供了一些介绍性的示例代码，以帮助说明其用法。第一个演示消除了大多数I / O和线程问题，并将重点介绍了许多SSLEngine方法。第二个演示是一个更现实的示例，展示了如何<code class="codeph">SSLEngine</code>可以与Java NIO结合使用以创建基本的HTTP / HTTPS服务器。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLENGINESIMPLEDEMO-7D240794">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-BD9FAB8A-1461-4DC5-B996-8221998F58A9">运行SSLEngineSimpleDemo</p>
                        <p>的<code>SSLEngineSimpleDemo.java</code> <span>JDK 8文档</span>中<span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE示例代码</a>中的Java</span>程序是一个非常简单的应用程序，专注于<code class="codeph">SSLEngine</code>同时简化了I / O和线程问题。此应用程序创建两个<code class="codeph">SSLEngine</code>通过通用交换SSL / TLS消息的对象<code class="codeph">ByteBuffer</code>对象。一个循环依次执行所有引擎操作，并演示如何建立安全连接（握手），如何传输应用程序数据以及如何关闭引擎。
                        </p>
                        <p>的<code class="codeph">SSLEngineResult</code>提供有关当前状态的大量信息<code class="codeph">SSLEngine</code> 。本示例未检查所有状态。它简化了I / O和线程问题，以至于这不是生产环境的好例子。尽管如此，这还是很有用的。 <code class="codeph">SSLEngine</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGTHENIO-BASEDSERVER-7D23AE05">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D6C1E956-4F4B-4EF3-AEAA-74A7F64862E6">运行基于NIO的服务器</p>
                        <p>充分利用<code class="codeph">SSLEngine</code> ，您必须首先了解互补的API，例如I / O和线程模型。
                        </p>
                        <p>NIO是大型应用程序开发人员发现的一种I / O模型<code class="codeph">SocketChannel</code> 。引入NIO的部分原因是为了解决NIO固有的一些缩放问题<code class="codeph">java.net.Socket</code> API。 <code class="codeph">SocketChannel</code>有许多不同的操作模式，包括：</p>
                        <ul style="list-style-type:disc">
                           <li>封锁</li>
                           <li>不阻塞</li>
                           <li>使用选择器不阻塞</li>
                        </ul>
                        <p>提供了用于基本HTTP服务器的示例代码，不仅演示了许多新的NIO API，而且还展示了如何<code class="codeph">SSLEngine</code>可以用来创建安全的HTTPS服务器。该服务器不是生产质量，但确实显示了许多这些新的API的运行情况。
                        </p>
                        <p>样本目录中是一个<code>README.txt</code>引入服务器的文件，解释如何构建和配置服务器，并简要概述代码布局。最感兴趣的文件<code class="codeph">SSLEngine</code>用户是<code>ChannelIO.java</code>和<code>ChannelIOSecure.java</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-EE5A58AA-A4BC-44CE-8ED0-63D0F3B86E0A">
                           <p class="notep1">注意：</p>本节中讨论的服务器示例包含在JDK中。您可以找到捆绑在<code class="codeph"><span class="variable" translate="no">jdk-home</span>/samples/nio/server</code>目录。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" name="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F"></a><h4 id="JSSEC-GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" class="sect4">创建用于JSSE的密钥库</h4>
                  <div>
                     <p>关于如何使用<code class="codeph">keytool</code>实用程序来创建适合与JSSE一起使用的简单PKCS12密钥库。</p>
                     <div class="section">
                        <p>首先你做一个<code class="codeph">keyEntry</code> （使用公钥和私钥）在密钥库中，然后您进行相应的操作<code class="codeph">trustedCertEntry</code> （仅公用密钥）在信任库中。对于客户端身份验证，您对客户端证书遵循类似的过程。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-9D016F06-C132-4185-83B2-B1EB279D05F0">
                              <p class="notep1">注意：</p>自JDK 8起，支持在PKCS12中存储信任锚和秘密密钥。
                           </div>
                        </div>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-5FE9AE11-8CB4-4B6C-8BA9-D17AB01633BC">
                              <p class="notep1">注意：</p>详细解释每个步骤超出了本示例的范围。参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> 。
                           </div> 
                        </div>
                        <p>用户输入以粗体显示。</p>
                        <ol>
                           <li> 
                              <p>创建一个新的密钥库和带有相应公钥和私钥的自签名证书。</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -genkeypair -alias duke -keyalg RSA -validity 7 -keystore keystore </span>
    
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    What is your first and last name?
    [Unknown]:  <span class="bold">Duke</span>
    What is the name of your organizational unit?
    [Unknown]:  <span class="bold">Java Software</span>
    What is the name of your organization?
    [Unknown]:  <span class="bold">Oracle, Inc.</span>
    What is the name of your City or Locality?
    [Unknown]:  <span class="bold">Palo Alto</span>
    What is the name of your State or Province?
    [Unknown]:  <span class="bold">CA</span>
    What is the two-letter country code for this unit?
    [Unknown]:  <span class="bold">US</span>
    Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
    L=Palo Alto, ST=CA, C=US correct?
    [no]:  <span class="bold">yes</span>
</code></pre></li>
                           <li> 
                              <p>检查密钥库。请注意，条目类型为<code class="codeph">PrivatekeyEntry</code> ，这表示该条目具有与其关联的私钥）。
                              </p> <pre class="codeblock"><code>
    % <span class="bold">keytool -list -v -keystore keystore</span>
    
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN

    Your keystore contains 1 entry

    Alias name: duke
    Creation date: Jul 25, 2016
    Entry type: PrivateKeyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

   #1: ObjectId: 2.5.29.14 Criticality=false
   SubjectKeyIdentifier [
   KeyIdentifier [
   0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
   0010: 5F 19 78 43                                        _.xC
   ]
   ]</code></pre></li>
                           <li> 
                              <p>导出并检查自签名证书。</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -export -alias duke -keystore keystore -rfc -file duke.cer</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    Certificate stored in file &lt;duke.cer&gt;
    % <span class="bold">cat duke.cer</span>
    -----BEGIN CERTIFICATE-----
    MIIDdzCCAl+gAwIBAgIEIQzM/DANBgkqhkiG9w0BAQsFADBsMQswCQYDVQQGEwJV
    UzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMT3Jh
    Y2xlLCBJbmMuMRYwFAYDVQQLEw1KYXZhIFNvZnR3YXJlMQ0wCwYDVQQDEwREdWtl
    MB4XDTE2MDcyNTA1MDMyN1oXDTE2MDgwMTA1MDMyN1owbDELMAkGA1UEBhMCVVMx
    CzAJBgNVBAgTAkNBMRIwEAYDVQQHEwlQYWxvIEFsdG8xFTATBgNVBAoTDE9yYWNs
    ZSwgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2FyZTENMAsGA1UEAxMERHVrZTCC
    ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ7+Yeu6HDZgWwkGlG4iKH9w
    vGKrxXVR57FaFyheMevrgj1ovVnQVFhfdMvjPkjWmpqLg6rfTqU4bKbtoMWV6+Rn
    uQrCw2w9xNC93hX9PxRa20UKrSRDKnUSvi1wjlaxfj0KUKuMwbbY9S8x/naYGeTL
    lwbHiiMvkoFkP2kzhVgeqHjIwSz4HRN8vWHCwgIDFWX/ZlS+LbvB4TSZkS0ZcQUV
    vJWTocOd8RB90W3bkibWkWq166XYGE1Nq1L4WIhrVJwbav6ual69yJsEpVcshVkx
    E1WKzJg7dGb03to4agbReb6+aoCUwb2vNUudNWasSrxoEFArVFGD/ZkPT0esfqEC
    AwEAAaMhMB8wHQYDVR0OBBYEFH/JlUhCjWiRuh7mXCxr/3VfGXhDMA0GCSqGSIb3
    DQEBCwUAA4IBAQAmcTm2ahsIJLayajsvm8yPzQsHA7kIwWfPPHCoHmNbynG67oHB
    fleaNvrgm/raTT3TrqQkg0525qI6Cqaoyy8JA2fAp3i+hmyoGHaIlo14bKazaiPS
    RCCqk0J8vwY3CY9nVal1XlHJMEcYV7X1sxKbuAKFoAJ29E/p6ie0JdHtQe31M7X9
    FNLYzt8EpJYUtWo13B9Oufz/Guuex9PQ7aC93rbO32MxtnnCGMxQHlaHLLPygc/x
    cffGz5Xe5s+NEm78CY7thgN+drI7icBYmv4navsnr2OQaD3AfnJ4WYSQyyUUCPxN
    zuk+B0fbLn7PCCcQspmqfgzIpgbEM9M1/yav
    -----END CERTIFICATE-----    
</code></pre> <p>或者，您可以使用以下命令生成证书签名请求（CSR）： <code class="codeph">-certreq</code>并将其发送给证书颁发机构（CA）进行签名，但这超出了本示例的范围。
                              </p> 
                           </li>
                           <li> 
                              <p>将证书导入到新的信任库中。</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -import -alias dukecert -file duke.cer -keystore truststore</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    Re-enter new password:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]

    Trust this certificate? [no]:  yes
    Certificate was added to keystore

    
</code></pre></li>
                           <li> 
                              <p>检查信任库。请注意，输入类型为<code class="codeph">trustedCertEntry</code> ，这意味着私钥不适用于该条目。这也意味着此文件不适合作为<code class="codeph">KeyManager</code> 。
                              </p> <pre class="codeblock"><code>
    % <span class="bold">keytool -list -v -keystore truststore</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN
    
    Your keystore contains 1 entry

    Alias name: dukecert
    Creation date: Jul 25, 2016
    Entry type: trustedCertEntry

    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]



    *******************************************
    *******************************************
</code></pre></li>
                           <li> 
                              <p>现在，使用适当的密钥库运行您的应用程序。因为此示例假定默认<code class="codeph">X509KeyManager</code>和<code class="codeph">X509TrustManager</code>使用时，您可以使用<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE包含一个标准实现，可以通过插入不同的实现或指定默认的密钥库等进行自定义。">Customizing JSSE中</a>描述的系统属性来选择密钥库。</p> <pre class="codeblock"><code>
    % java -Djavax.net.ssl.keyStore=keystore -Djavax.net.ssl.keyStorePassword=password Server
    
    % java -Djavax.net.ssl.trustStore=truststore -Djavax.net.ssl.trustStorePassword=trustword Client
    
</code></pre></li>
                        </ol>
                        <div class="p"> 
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-3E0172AD-F4CF-44DD-BEFF-4EFE7006F0E5">
                              <p class="notep1">注意：</p>本示例仅对服务器进行身份验证。对于客户端身份验证，请为客户端的密钥提供类似的密钥库，并为服务器提供适当的信任库。
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-63945B45-E909-483F-B3A9-E26586737383" name="GUID-63945B45-E909-483F-B3A9-E26586737383"></a><h4 id="JSSEC-GUID-63945B45-E909-483F-B3A9-E26586737383" class="sect4">使用服务器名称指示（SNI）扩展</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>这些示例说明了如何在客户端和服务器端应用程序中使用<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">服务器名称指示（SNI）扩展</a> ，以及如何将其应用于虚拟基础结构。
                        </p>
                        <p>对于本节中的所有示例，要在设置参数后应用参数，请调用<code class="codeph">setSSLParameters(SSLParameters)</code>对应的方法<code class="codeph">SSLSocket</code> ， <code class="codeph">SSLEngine</code> ， 要么<code class="codeph">SSLServerSocket</code>宾语。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0" name="GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0"></a><h5 id="JSSEC-GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0" class="sect5">典型的客户端用法示例</h5>
                     <div>
                        <p></p>
                        <p>以下是一些用例列表，这些用例需要了解SNI扩展才能开发客户端应用程序：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p>情况1。客户端要访问<code class="codeph">www.example.com</code> 。
                              </p> 
                              <p>显式设置主机名：</p> <pre class="codeblock"><code>    SNIHostName serverName = new SNIHostName("www.example.com");
    sslParameters.setServerNames(Collections.singletonList(serverName)); </code></pre> <p>客户端应始终明确指定主机名。</p> 
                           </li>
                           <li> 
                              <p>情况二客户端不想使用SNI，因为服务器不支持它。</p> 
                              <p>使用空服务器名称列表禁用SNI：</p> <pre class="codeblock"><code>    sslParameters.setServerNames(Collections.emptyList());        
</code></pre></li>
                           <li> 
                              <p>情况3。客户端要访问URL <code class="codeph">https://www.example.com</code> 。
                              </p> 
                              <p>Oracle提供程序将默认在SNI扩展名中设置主机名，但是第三方提供程序可能不支持默认服务器名指示。为了使您的应用程序独立于提供程序，请始终明确设置主机名。</p> 
                           </li>
                           <li> 
                              <p>情况4客户端希望将套接字从服务器模式切换到客户端模式。</p> 
                              <p>首先使用以下方法切换模式： <code class="codeph">sslSocket.setUseClientMode(true)</code> 。然后在套接字上重置服务器名称指示参数。
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2" name="GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2"></a><h5 id="JSSEC-GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2" class="sect5">典型的服务器端用法示例</h5>
                     <div>
                        <p></p>
                        <p>以下是一些用例列表，这些用例需要了解SNI扩展才能开发服务器应用程序：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p>情况1。服务器希望接受所有服务器名称指示类型。</p> 
                              <p>如果您没有任何有关SNI扩展的代码，则服务器将忽略所有服务器名称指示类型。</p> 
                           </li>
                           <li> 
                              <p>情况二服务器要拒绝所有类型的服务器名称指示<code class="codeph">host_name</code> 。
                              </p> 
                              <p>为设置无效的服务器名称模式<code class="codeph">host_name</code> ：</p> <pre class="codeblock"><code>    SNIMatcher matcher = SNIHostName.createSNIMatcher("");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</code></pre> <p>另一种方法是创建一个<code class="codeph">SNIMatcher</code>子类<code class="codeph">matches()</code>总是返回的方法<code class="codeph">false</code> ：</p> <pre class="codeblock"><code>    class DenialSNIMatcher extends SNIMatcher {
        DenialSNIMatcher() {
            super(StandardConstants.SNI_HOST_NAME);
        }
    
        @Override
        public boolean matches(SNIServerName serverName) {
            return false;
        }
    }
    
    SNIMatcher matcher = new DenialSNIMatcher();
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</code></pre></li>
                           <li> 
                              <p>情况3。服务器希望接受与主机名中任何主机名的连接<code class="codeph">example.com</code>域。
                              </p> 
                              <p>为设置可识别的服务器名称<code class="codeph">host_name</code>作为包括所有<code class="codeph">*.example.com</code>地址：</p> <pre class="codeblock"><code>    SNIMatcher matcher = SNIHostName.createSNIMatcher("(.*\\.)*example\\.com");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
</code></pre></li>
                           <li> 
                              <p>情况4服务器希望将套接字从客户端模式切换到服务器模式。</p> 
                              <p>首先使用以下方法切换模式： <code class="codeph">sslSocket.setUseClientMode(false)</code> 。然后在套接字上重置服务器名称指示参数。
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445" name="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445"></a><h5 id="JSSEC-GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445" class="sect5">使用虚拟基础架构</h5>
                     <div>
                        <p>本节介绍如何在虚拟基础架构中使用服务器名称指示（SNI）扩展。它说明了如何从套接字为ClientHello消息创建解析器，并提供了使用以下示例的虚拟服务器调度程序<code class="codeph">SSLSocket</code>和<code class="codeph">SSLEngine</code> ，描述了当SNI扩展不可用时会发生什么，并演示了如何创建故障转移<code class="codeph">SSLContext</code> 。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-12355A88-3E49-484D-B8BB-2F9EBA57595F">准备ClientHello解析器</p>
                           <p>应用程序必须实现API才能从套接字解析ClientHello消息。以下示例说明了<code class="codeph">SSLCapabilities</code>和<code class="codeph">SSLExplorer</code>可以执行这些功能的类。
                           </p>
                           <p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java" target="_blank">SSLSocketClient.java</a>在握手过程中封装了TLS / DTLS安全功能（即，TLS / DTLS握手中要接受的密码套件列表，记录版本，hello版本和服务器名称指示）。可以通过以下方式浏览TLS / DTLS连接的网络数据来检索它： <code class="codeph">SSLExplorer.explore()</code>方法。
                           </p>
                           <p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sni/SSLExplorer.java" target="_blank">SSLExplorer.java</a>从TLS客户端浏览初始ClientHello消息，但它不会启动握手或使用网络数据。的<code class="codeph">SSLExplorer.explore()</code>方法解析ClientHello消息，并将安全参数检索到<code class="codeph">SSLCapabilities</code> 。在任何TLS连接上发生握手之前，必须先调用该方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-7F9C795B-475B-4440-A58B-06C192DBD244">基于SSLSocket的虚拟服务器调度程序</p>
                           <p>本节介绍了基于以下功能使用虚拟服务器调度程序的过程： <code class="codeph">SSLSocket</code> 。
                           </p>
                           <ol>
                              <li> 
                                 <p><span class="bold">注册服务器名称处理程序。</span></p> 
                                 <p>在这一步，应用程序可能会创建不同的<code class="codeph">SSLContext</code>用于不同服务器名称指示的对象，或将特定服务器名称指示链接到指定的虚拟机或分布式系统。
                                 </p> 
                                 <p>例如，如果服务器名称是<code class="codeph">www.example.org</code> ，则注册的服务器名称处理程序可能用于本地虚拟主机Web服务。本地虚拟主机Web服务将使用指定的<code class="codeph">SSLContext</code> 。如果服务器名称是<code class="codeph">www.example.com</code> ，则注册的服务器名称处理程序可能适用于托管在<code class="codeph">10.0.0.36</code> 。处理程序可以将此连接映射到虚拟机。
                                 </p> 
                              </li>
                              <li> 
                                 <p><span class="bold">创建一个<code class="codeph">ServerSocket</code>并接受新的连接。</span></p> <pre class="codeblock"><code>ServerSocket serverSocket = new ServerSocket(serverPort);
Socket socket = serverSocket.accept();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">从套接字输入流读取并缓冲字节，然后浏览缓冲的字节。</span></p> <pre class="codeblock"><code>InputStream ins = socket.getInputStream();
byte[] buffer = new byte[0xFF];
int position = 0;
SSLCapabilities capabilities = null;
    
// Read the header of TLS record
while (position &lt; SSLExplorer.RECORD_HEADER_SIZE) {
    int count = SSLExplorer.RECORD_HEADER_SIZE - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Get the required size to explore the SSL capabilities
int recordLength = SSLExplorer.getRequiredSize(buffer, 0, position);
if (buffer.length &lt; recordLength) {
    buffer = Arrays.copyOf(buffer, recordLength);
}
    
while (position &lt; recordLength) {
    int count = recordLength - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Explore
capabilities = SSLExplorer.explore(buffer, 0, recordLength);
if (capabilities != null) {
    System.out.println("Record version: " + capabilities.getRecordVersion());
    System.out.println("Hello version: " + capabilities.getHelloVersion());
}</code></pre></li>
                              <li> 
                                 <p><span class="bold">从探索的功能中获取请求的服务器名称。</span></p> <pre class="codeblock"><code>List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">查找该服务器名称指示的注册服务器名称处理程序。</span></p> 
                                 <p>如果主机名的服务驻留在虚拟机或其他分布式系统中，则应用程序必须将连接转发到目标。该应用程序将需要读取和写入原始Internet数据，而不是套接字流中的SSL应用程序。</p> <pre class="codeblock"><code>Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</code></pre> <p>如果主机名服务驻留在同一进程中，并且主机名服务可以使用<code class="codeph">SSLSocket</code>直接，那么应用程序将需要设置<code class="codeph">SSLSocket</code>实例到服务器：</p> <pre class="codeblock"><code>// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...

SSLSocketFactory serviceSocketFac = serviceContext.getSSLSocketFactory();

// wrap the buffered bytes
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket serviceSocket = (SSLSocket)serviceSocketFac.createSocket(socket, bais, true);

// Now the service can use serviceSocket as usual.
</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-40651F18-8498-4BF4-83A6-E6CE93452E0E">基于SSLEngine的虚拟服务器调度程序</p>
                           <p>本节介绍了基于以下功能使用虚拟服务器调度程序的过程： <code class="codeph">SSLEngine</code> 。
                           </p>
                           <ol>
                              <li> 
                                 <p><span class="bold">注册服务器名称处理程序。</span></p> 
                                 <p>在这一步，应用程序可能会创建不同的<code class="codeph">SSLContext</code>用于不同服务器名称指示的对象，或将特定服务器名称指示链接到指定的虚拟机或分布式系统。
                                 </p> 
                                 <p>例如，如果服务器名称是<code class="codeph">www.example.org</code> ，则注册的服务器名称处理程序可能用于本地虚拟主机Web服务。本地虚拟主机Web服务将使用指定的<code class="codeph">SSLContext</code> 。如果服务器名称是<code class="codeph">www.example.com</code> ，则注册的服务器名称处理程序可能适用于托管在<code class="codeph">10.0.0.36</code> 。处理程序可以将此连接映射到虚拟机。
                                 </p> 
                              </li>
                              <li> 
                                 <p><span class="bold">创建一个<code class="codeph">ServerSocket</code>要么<code class="codeph">ServerSocketChannel</code>并接受新的连接。</span></p> <pre class="codeblock"><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(...);
...
SocketChannel socketChannel = serverSocketChannel.accept();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">从套接字输入流读取并缓冲字节，然后浏览缓冲的字节。</span></p> <pre class="codeblock"><code>ByteBuffer buffer = ByteBuffer.allocate(0xFF);
SSLCapabilities capabilities = null;
while (true) {
    // ensure the capacity
    if (buffer.remaining() == 0) {
        ByteBuffer oldBuffer = buffer;
        buffer = ByteBuffer.allocate(buffer.capacity() + 0xFF);
        buffer.put(oldBuffer);
    }

    int n = sc.read(buffer);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }

    int position = buffer.position();
    buffer.flip();
    capabilities = explorer.explore(buffer);
    buffer.rewind();
    buffer.position(position);
    buffer.limit(buffer.capacity());
    if (capabilities != null) {
        System.out.println("Record version: " +
            capabilities.getRecordVersion());
        System.out.println("Hello version: " +
            capabilities.getHelloVersion());
        break;
    }
}

buffer.flip();  // reset the buffer position and limitation </code></pre></li>
                              <li> 
                                 <p><span class="bold">从探索的功能中获取请求的服务器名称。</span></p> <pre class="codeblock"><code>List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">查找该服务器名称指示的注册服务器名称处理程序。</span></p> 
                                 <p>如果主机名的服务驻留在虚拟机或其他分布式系统中，则应用程序必须将连接转发到目标。该应用程序将需要读取和写入原始Internet数据，而不是套接字流中的SSL应用程序。</p> <pre class="codeblock"><code>Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</code></pre> <p>如果主机名服务驻留在同一进程中，并且主机名服务可以使用<code class="codeph">SSLEngine</code>直接，那么应用程序将简单地将净数据提供给<code class="codeph">SSLEngine</code>实例：</p> <pre class="codeblock"><code>// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...
    
SSLEngine serviceEngine = serviceContext.createSSLEngine();
// Now the service can use the buffered bytes and other byte buffer as usual.
</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-6D6971CD-E025-46F1-A5A3-E21875996EB4">没有可用的SNI扩展</p>
                           <p>如果ClientHello消息中没有服务器名称指示，则无法根据SNI选择正确的服务。在这种情况下，应用程序可能需要指定默认服务，以便在没有服务器名称指示的情况下可以将连接委托给它。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-D66A3C38-9FB2-4292-BAF3-AB9B7F6434E0">故障转移SSLContext</p>
                           <p>的<code class="codeph">SSLExplorer.explore()</code>方法不检查TLS / DTLS内容的有效性。如果记录格式不符合TLS / DTLS规范，或者<code class="codeph">explore()</code>在握手开始后调用方法，然后该方法可能会抛出一个<code class="codeph">IOException</code>并且无法产生网络数据。在这种情况下，请处理由<code class="codeph">SSLExplorer.explore()</code>通过使用故障转移<code class="codeph">SSLContext</code> ，它不是用于协商TLS / DTLS连接，而是用于通过适当的警报消息关闭连接。以下示例说明了故障转移<code class="codeph">SSLContext</code> 。您可以找到一个示例<code class="codeph">DenialSNIMatcher</code> <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2">典型服务器端使用示例</a>中案例2中的类。
                           </p><pre class="codeblock"><code>byte[] buffer = ...       // buffered network data
boolean failed = true;    // SSLExplorer.explore() throws an exception

SSLContext context = SSLContext.getInstance("TLS");
// the failover SSLContext
    
context.init(null, null, null);
SSLSocketFactory sslsf = context.getSocketFactory();
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(socket, bais, true);

SNIMatcher matcher = new DenialSNIMatcher();
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);    // no recognizable server name
sslSocket.setSSLParameters(params);

try {
    InputStream sslIS = sslSocket.getInputStream();
    sslIS.read();
} catch (Exception e) {
    System.out.println("Server exception " + e);
} finally {
    sslSocket.close();
}
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190" name="GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190"></a><h3 id="JSSEC-GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190" class="sect3">标准名称</h3>
               <div>
                  <p></p>
                  <div class="section">JDK安全API要求并为算法，证书和密钥库类型使用一组标准名称。请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>规范。在“ <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK提供者文档”中</a>找到特定的提供者信息。
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-08173142-567C-495C-A48F-32D0FCED466B" name="GUID-08173142-567C-495C-A48F-32D0FCED466B"></a><h3 id="JSSEC-GUID-08173142-567C-495C-A48F-32D0FCED466B" class="sect3">提供商可插拔性</h3>
               <div>
                  <p>JSSE是完全可插拔的，并且不以任何方式限制使用第三方JSSE提供程序。</p>
               </div>
            </div>
         </div>
      </article>
   

</body></html>