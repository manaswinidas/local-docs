<html lang="en-us" dir="ltr" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content>
      <meta name="description" content>
      <title>Accessing Native GSS-API</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="related-documentation1.html" title="Previous" type="text/html">
      <link rel="next" href="single-sign-using-kerberos-java1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="related-documentation1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="single-sign-using-kerberos-java1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="java-generic-security-services-java-gss-api1.html" property="item" typeof="WebPage"><span property="name">Java通用安全服务（Java GSS-API）</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">访问本机GSS-API</li>
            </ol>
            <a id="GUID-88A42A9C-AC8B-426E-A8A7-B30518C2162A" name="GUID-88A42A9C-AC8B-426E-A8A7-B30518C2162A"></a>
            
            <h2 id="JSSEC-GUID-88A42A9C-AC8B-426E-A8A7-B30518C2162A" class="sect2">访问本机GSS-API</h2>
         </header>
         <div class="ind">
            <div>
               <p></p>
               <p>为了帮助Java平台应用程序实现与本机应用程序的无缝集成，JDK增强了Java GSS-API以使用本机GSS-API，而不是配置为使用本机自己的加密机制。使用本机GSS-API及其底层本机加密机制时，将自动获取用户环境中的本机凭据和设置。这与Java GSS-API使用其自己的加密机制实现的默认情况不同。使用Kerberos时，Java应用程序必须使用指定的Kerberos系统属性来提供Kerberos配置信息，Java GSS-API才能运行。<a href="introduction-jaas-and-java-gss-api-tutorials1.html">《 JAAS和Java GSS-API教程简介》</a>详细介绍了默认情况，因此本节将重点介绍如何启用或配置Java GSS-API以使用本机GSS-API。</p>
               <p>在启用Java GSS-API使用本机GSS-API之前，请确保本机GSS-API及其基础加密机制可用并且可以与用户设置一起使用。例如，确保使用适当的配置将本机GSS库安装在适当的目录中，并且Kerberos库和配置也是如此。请注意，本机GSS-API假定在应用程序调用其API之前，它已经获得了本机特定的凭据并将其存储在本机机制实现所知道的位置。因此，当应用程序将本机GSS-API与Kerberos一起使用时，它必须已经通过使用以下命令获得了适当的本机凭证，例如Kerberos票证和密钥。 <code class="codeph">kinit</code>发起方的工具或接受方的密钥表文件。
               </p>
               <p>要使Java GSS-API使用本机GSS-API，Java应用程序必须通过设置以下一个或多个系统属性来显式启用此行为：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><code class="codeph">sun.security.jgss.native</code> （必需）：将其设置为true可以使Java GSS-API使用本机GSS-API。</p>
                  </li>
                  <li>
                     <p><code class="codeph">sun.security.jgss.lib</code> （可选，但对于Windows是必需的）：设置为本地GSS库的完整路径。如果未设置，则Java GSS-API将使用默认Java库路径查找本机GSS库。如果未设置，则Java GSS-API将尝试搜索一些知名的本机GSS库，例如， <code>libgss.so</code>在Solaris上， <code>libgssapi.so</code>要么<code>libgssapi_krb5.so</code>在Linux上<code>libgssapi_krb5.dylib</code>在macOS上。 Windows上没有众所周知的本机GSS-API库，您必须使用此系统属性指定其完整路径名。
                     </p>
                  </li>
               </ul>
               <p>如前所述，本机GSS-API要求应用程序已获取这些凭据并且可以访问它们。Java应用程序可以通过Java GSS-API访问这些本机凭证，并将其用于与对等方建立GSS-API安全上下文。请注意，例如，当存在一个主题时，</p><pre class="oac_no_warn" dir="ltr">javax.security.auth.Subject.getSubject(AccessController.getContext()) != null</pre><p>然后Java GSS-API要求从当前主题的私有或公共凭证集获取凭证，并且如果找不到所需的凭证，则Java GSS-API调用必须失败。因此，在Java平台内部执行Java GSS-API调用的Java平台应用程序<code class="codeph">Subject.doAs/doAsPrivileged(...)</code>调用应使用封装本机凭据的适当Java <span class="apiname">GSSCredential</span>对象填充主题的凭据集，或显式设置系统属性<code class="codeph">javax.security.auth.useSubjectCredsOnly</code>设置为false，以便Java GSS-API可以从其他位置（例如，从主题的凭据集中）获取其他凭据，例如从本地凭据缓存中获取。
               </p>
               <p>当委托他人代表他人建立GSS-API安全上下文时，Java应用程序可以指定委托凭证，如<code class="codeph">GSSContext.getDelegCred()</code> ，在Java GSS-API调用中显式显示或创建一个<code class="codeph">Subject</code>具有此委托凭证的对象，并在内执行Java GSS-API调用<code class="codeph">Subject.doAs/doAsPrivileged(...)</code>电话。
               </p>
               <p>一旦本地GSS-API启用，Java平台的应用程序间接调用Java GSS-API通过机制或协议，如简单身份验证和安全层（SASL）（见<a href="java-sasl-api-programming-and-deployment-guide1.html#GUID-6D78EE33-62E6-4D85-9695-322EED493F72">的Java SASL API编程和部署指南</a> ）也将使用用户的本地设置和证书。
               </p>
               <p>以下是一些示例代码，这些代码有助于演示如何使用Java GSS-API建立GSS-API安全上下文以及如何在第三方之间安全地交换数据： <code class="codeph">SampleClient</code>联络人<code class="codeph">FooServer</code> ，进而联系<code class="codeph">FooServer2</code>代表<code class="codeph">SampleClient</code> 。注意：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>应该在启用本机GSS-API的情况下调用示例代码。校长姓名<code class="codeph">host@foo.sample.com</code>和<code class="codeph">host@foo2.sample.com</code>是占位符，应在Kerberos数据库中用实际的主体名称替换。
                     </p>
                  </li>
                  <li>
                     <p>安装安全管理器后，某些Java GSS-API调用要求授予权限。有关更多详细信息，请查看以下类的Java文档：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/kerberos/ServicePermission.html" target="_blank"><span class="apiname">javax.security.auth.kerberos。服务权限</span></a> 
                           </p>
                        </li>
                        <li>
                           <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/kerberos/DelegationPermission.html" target="_blank"><span class="apiname">javax.security.auth.kerberos。委托权限</span></a>  
                           </p>
                        </li>
                     </ul>
                  </li>
                  <li>
                     <p>为了简化示例，对等点之间的令牌交换由两种伪方法表示： <code class="codeph">SEND_TOKEN(byte[])</code>和<code class="codeph">READ_TOKEN()</code> 。它们的实际实现是特定于应用程序的，因此此处未显示。
                     </p>
                  </li>
                  <li>
                     <p>为了减少代码重复，上下文建立代码由伪方法引用， <code class="codeph">ESTABLISH_CONTEXT(GSSContext)</code> ，在以下代码段中<code class="codeph">SampleClient</code> ， <code class="codeph">FooServer</code>和<code class="codeph">FooServer2</code> 。
                     </p>
                  </li>
               </ul>
               <p>以下是实现<code class="codeph">ESTABLISH_CONTEXT(GSSContext)</code>使用Java GSS-API。</p><pre class="oac_no_warn" dir="ltr">/** 
 * ESTABLISH_CONTEXT(GSSContext ctxt): establishes a context
 * with data confidentiality and mutual authentication.
 */
ctxt.requestConf(true);
ctxt.requestMutualAuth(true);

byte[] inToken = new byte[0];
byte[] outToken = null;

if (ctxt.isInitiator()) {
    while (!ctxt.isEstablished()) {
        // Note: initSecContext(...) always ignores the arguments
        // for the first call because there is no incoming token.
        outToken = ctxt.initSecContext(inToken, 0, inToken.length);

        // Send the output token if generated.
        if (outToken != null) SEND_TOKEN(outToken); // to acceptor

        // Check whether more incoming tokens are expected.
        if (!ctxt.isEstablished()) {
            inToken = READ_TOKEN(); // from acceptor
        }
    }
} else {
    while (!ctxt.isEstablished()) {
        inToken = READ_TOKEN(); // from initiator
        outToken = 
            ctxt.acceptSecContext(inToken, 0, inToken.length);

        // Send the output token if generated.
        if (outToken != null) SEND_TOKEN(outToken); // to initiator
    }
}</pre><p>以下是代码段<code class="codeph">SampleClient</code> ， <code class="codeph">FooServer</code>和<code class="codeph">FooServer2</code> ：</p>
               <p><span class="bold"><code class="codeph">SampleClient</code></span> ：它接触<code class="codeph">FooServer</code>并委派服务器代表其执行操作。如果一切顺利，它应该会返回由<code class="codeph">FooServer2</code> 。
               </p><pre class="oac_no_warn" dir="ltr">GSSManager gssMgr = GSSManager.getInstance();
GSSName serverName = gssMgr.createName(
    "host@foo.sample.com", GSSName.NT_HOSTBASED_SERVICE);
GSSContext context = gssMgr.createContext(
    serverName, null /* default mechanism, which is Kerberos*/,
    null /* default initiator cred */, 
    GSSContext.DEFAULT_LIFETIME);
context.requestCredDelegState(true);

ESTABLISH_CONTEXT(context);

// Make sure credential delegation is available. 
if (!context.getCredDeleg()) {
    context.dispose();
    throw new Exception("credential delegation is denied");
}

byte[] token = READ_TOKEN(); // from "FooServer"
byte[] data = 
   context.unwrap(token, 0, token.length, new MessageProp(true));
context.dispose();

// Should print "Hello from FooServer2 to &lt;client name&gt;" where 
// &lt;client name&gt; is the name of the default initiator.
System.out.println(new String(data));</pre><p><span class="bold"><code class="codeph">FooServer</code></span> ：它接触<code class="codeph">FooServer2</code>如<code class="codeph">SampleClient</code>并将收到的回复转发给<code class="codeph">SampleClient</code> 。
               </p><pre class="oac_no_warn" dir="ltr">GSSManager gssMgr = GSSManager.getInstance();
GSSName myName = gssMgr.createName(
    "host@foo.sample.com", GSSName.NT_HOSTBASED_SERVICE);
GSSCredential myCred = gssMgr.createCredential(
    acceptorName, GSSCredential.INDEFINITE_LIFETIME,
    (Oid[]) null /* default set of mechanisms */, 
    GSSCredential.ACCEPT_ONLY);
GSSContext acontext = gssMgr.createContext(myCred);

ESTABLISH_ACC_CONTEXT(acontext);

GSSCredential delegCred = acontext.getDelegCred();
if (delegCred != null) {
    byte[] data, token;
    // Establish a context on client's behalf using the delegated 
    // credential.
    GSSName serverName = gssMgr.createName(
        "host@foo2.sample.com", GSSName.NT_HOSTBASED_SERVICE); 
    GSSContext icontext = gssMgr.createContext(
        serverName, null /* default mechanism Kerberos */, 
        delegCred /* act on SampleClient's behalf */, 
        GSSContext.DEFAULT_LIFETIME);

    ESTABLISH_CONTEXT(icontext);

    token = READ_TOKEN(); // from "FooServer2"

    MessageProp msgProp = new MessageProp(true);

    // Forward the reply from FooServer2 to SampleClient.
    data = icontext.unwrap(token, 0, token.length, msgProp);
    token = acontext.wrap(data, 0, data.length, msgProp);
    SEND_TOKEN(token); // to "SampleClient"
    icontext.dispose();
}
acontext.dispose();</pre><p><span class="bold"><code class="codeph">FooServer2</code></span> ：始终以个性化已建立上下文发起者名称的hello消息进行回复。
               </p><pre class="oac_no_warn" dir="ltr">GSSManager gssMgr = GSSManager.getInstance();
GSSName myName = gssMgr.createName(
    "host@foo2.sample.com", GSSName.NT_HOSTBASED_SERVICE);
GSSCredential myCred = gssMgr.createCredential(
    myName, GSSCredential.INDEFINITE_LIFETIME,
    (Oid[]) null /* default set of mechanisms */, 
    GSSCredential.ACCEPT_ONLY);
GSSContext context = gssMgr.createContext(myCred);

ESTABLISH_CONTEXT(context);

byte[] data = new String("Hello from FooServer2 to " + 
    context.getSrcName()).getBytes();
byte[] token = 
    context.wrap(data, 0, data.length, new MessageProp(true));

SEND_TOKEN(token); // to "FooServer"

context.dispose();</pre></div>
         </div>
      </article>
   

</body></html>