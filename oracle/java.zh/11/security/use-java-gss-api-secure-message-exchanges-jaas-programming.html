<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Use of Java GSS-API for Secure Message Exchanges Without JAAS Programming</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="when-use-java-gss-api-vs-jsse.html" title="Previous" type="text/html">
      <link rel="next" href="jaas-authentication.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="when-use-java-gss-api-vs-jsse.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="jaas-authentication.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="java-generic-security-services-java-gss-api1.html" property="item" typeof="WebPage"><span property="name">Java通用安全服务（Java GSS-API）</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-jaas-and-java-gss-api-tutorials1.html" property="item" typeof="WebPage"><span property="name">JAAS和Java GSS-API教程简介</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用Java GSS-API进行无需JAAS编程的安全消息交换</li>
            </ol>
            <a id="GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56" name="GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56"></a>
            
            <h2 id="JSSEC-GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56" class="sect2">使用Java GSS-API进行无需JAAS编程的安全消息交换</h2>
         </header>
         <div class="ind">
            <div>
               <p>本教程提供了两个示例应用程序，它们演示了如何使用Java GSS-API在通信应用程序（在本例中为客户端应用程序和服务器应用程序）之间安全地交换消息。</p>
               <p>Java GSS-API使用所谓的“安全机制”来提供这些服务。除了任何其他特定于供应商的选择之外，GSS-API实现还包含对Kerberos V5机制的支持。本教程使用Kerberos V5机制。</p>
               <p>为了在客户端和服务器之间执行身份验证并建立用于安全通信的加密密钥，GSS-API机制需要访问连接两边的本地实体的某些凭据。在我们的示例中，客户端使用的凭据由Kerberos票证组成，而在服务器端，则由长期的Kerberos密钥组成。Kerberos票证可以选择包含主机地址，并且同时支持IPv4和IPv6主机地址。Java GSS-API要求该机制从与线程的访问控制上下文关联的主题获取这些凭证。</p>
               <p>要使用此类凭据填充主题，客户端和服务器应用程序通常将首先使用Kerberos <span class="apiname">LoginModule</span>执行JAAS身份验证。<a href="jaas-authentication.html#GUID-0C6EB04B-D203-4688-A3E2-A7D442334623">JAAS认证</a>教程演示了如何执行此操作。然后， <a href="jaas-authorization.html#GUID-69241059-CCD0-49F6-838F-DDC752F9F19F">JAAS授权</a>教程将演示如何将经过身份验证的主题与线程的访问控制上下文相关联。还编写了实用程序，以方便您代表您自动执行这些操作。“ <a href="use-jaas-login-utility.html#GUID-F41E74DF-EE54-4EB1-8609-49C6D324ADF5">JAAS登录实用程序</a>的<a href="use-jaas-login-utility.html#GUID-F41E74DF-EE54-4EB1-8609-49C6D324ADF5">使用”</a>教程演示了如何使用登录实用程序。
               </p>
               <p>对于本教程，我们不会让客户端和服务器执行JAAS身份验证，也不会让他们使用Login实用程序。相反，我们将依靠设置系统属性<code class="codeph">javax.security.auth.useSubjectCredsOnly</code>至<code class="codeph">false</code> ，这使我们放宽了要求GSS机制从JAAS设置的现有<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">主题</a>获取必要凭据的限制。请参见<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">useSubjectCredsOnly系统属性</a> 。
               </p>
               <div class="infoboxnote" id="GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56__GUID-C1D390A1-E212-48D7-BB3D-B117D67BD365">
                  <p class="notep1">注意：</p>
                  <p>这是一个简化的入门教程。例如，我们不包括任何策略文件，也不使用安全管理器运行示例代码。在现实生活中，使用Java GSS-API的代码应与安全管理器一起运行，以便除非明确授予所需的权限，否则将不允许执行对安全敏感的操作。</p>
               </div>
               <p>还有另一本教程，《 <a href="use-jaas-login-utility-and-java-gss-api-secure-message-exchanges.html#GUID-C1DFED9D-D3A1-4C11-95D8-3543935E87C8">使用JAAS登录实用程序和Java GSS-API进行安全消息交换》</a> ，就像您正在阅读的教程一样，除了它利用了Login实用程序，策略文件和更复杂的登录配置文件。每当完成JAAS身份验证时，都需要一个登录配置文件（请参阅<a href="appendix-b-jaas-login-configuration-file.html#GUID-7EB80FA5-3C16-4016-AED6-0FC619F86F8E">附录B：JAAS登录配置文件</a> ）指定所需的身份验证模块。
               </p>
               <p>与本系列的所有教程一样，本教程中用于支持应用程序的身份验证和安全通信的基础技术是Kerberos V5。请参见<a href="kerberos-requirements.html#GUID-EAA2758B-3071-4CDA-AEF1-D76F5271E998">Kerberos要求</a> 。
               </p>
               <ul style="list-style-type:disc">
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5">客户端和服务器应用程序概述</a></li>
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86">SampleClient和SampleServer代码</a></li>
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos用户和服务主体名称</a></li>
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A">登录配置文件</a></li>
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">useSubjectCredsOnly系统属性</a></li>
                  <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E">运行SampleClient和SampleServer程序</a></li>
               </ul>
               <p>如果要首先查看实际使用的教程代码，则可以直接跳至“ <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E">运行SampleClient和SampleServer程序”</a> ，然后返回其他部分以了解更多信息。
               </p>
            </div>
            <div class="sect2"><a id="GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5" name="GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5"></a><h3 id="JSSEC-GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5" class="sect3">客户端和服务器应用程序概述</h3>
               <div>
                  <p>本教程的应用程序名为<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code> 。
                  </p>
                  <p>这是执行的摘要<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>应用范围：</p>
                  <ol>
                     <li>跑过<code class="codeph">SampleServer</code>应用。 <code class="codeph">SampleServer</code> 
                        <ol type="a">
                           <li>读取其参数，即应侦听客户端连接的端口号。</li>
                           <li>创建一个<span class="apiname">ServerSocket</span>来侦听该端口上的客户端连接。
                           </li>
                           <li>监听连接。</li>
                        </ol>
                     </li>
                     <li>跑过<code class="codeph">SampleClient</code>应用程序（可能在其他计算机上）。 <code class="codeph">SampleClient</code> 
                        <ol type="a">
                           <li>读取其参数：（1）表示以下内容的Kerberos主体的名称<code class="codeph">SampleServer</code> （请参阅<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos用户和服务主体名称</a> ），（2）在其上的主机（计算机）的名称<code class="codeph">SampleServer</code>正在运行，以及（3）其上的端口号<code class="codeph">SampleServer</code>侦听客户端连接。
                           </li>
                           <li>尝试与<code class="codeph">SampleServer</code> ，使用主机和端口将其作为参数传递。
                           </li>
                        </ol>
                     </li>
                     <li>套接字连接被接受<code class="codeph">SampleServer</code>两个应用程序都从套接字输入和输出流初始化<span class="apiname">DataInputStream</span>和<span class="apiname">DataOutputStream</span> ，以用于将来的数据交换。
                     </li>
                     <li><code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>每个实例都实例化<span class="apiname">GSSContext</span>并遵循用于建立共享上下文的协议，该协议将实现后续的安全数据交换。
                     </li>
                     <li><code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>现在可以安全地交换消息。
                     </li>
                     <li>什么时候<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>完成交换消息后，它们执行清理操作。
                     </li>
                  </ol>
                  <p>以下各节介绍了实际的代码和更多详细信息。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86" name="GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86"></a><h3 id="JSSEC-GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86" class="sect3">SampleClient和SampleServer代码</h3>
               <div>
                  <p>两者的完整代码<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLECLIENT.JAVA-338923E1"><code>SampleClient.java</code></a>和<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVER.JAVA-33891DED"><code>SampleServer.java</code></a>程序驻留在<code class="codeph">main</code>方法，可以细分为以下子部分：</p>
                  <ol>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-50F25F90-A350-4A21-A06E-44E33209D542">获取命令行参数</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB">建立用于消息交换的套接字连接</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B">建立安全上下文</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-39585A77-5CF3-4122-B4EC-3D778392370D">安全地交换消息</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-DA54B317-30B2-4666-86B6-B1AD4D627002">清理</a></li>
                  </ol>
                  <div class="infoboxnote" id="GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86__GUID-39A47901-8887-47B3-BDCC-CDA90803FABF">
                     <p class="notep1">注意：</p>
                     <p>这些程序使用的Java GSS-API类（ <span class="apiname">GSSManager</span> ， <span class="apiname">GSSContext</span> ， <span class="apiname">GSSName</span> ， <span class="apiname">GSSCredential</span> ， <span class="apiname">MessageProp</span>和<span class="apiname">Oid</span> ）位于<a href="https://docs.oracle.com/javase/10/docs/api/org/ietf/jgss/package-summary.html" target="_blank"><span class="apiname">org.ietf.jgss</span></a>包中。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-50F25F90-A350-4A21-A06E-44E33209D542" name="GUID-50F25F90-A350-4A21-A06E-44E33209D542"></a><h4 id="JSSEC-GUID-50F25F90-A350-4A21-A06E-44E33209D542" class="sect4">获取命令行参数</h4>
                  <div>
                     <p>客户和服务器的第一件事<code class="codeph">main</code>方法所做的是读取命令行参数。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-E4E494AB-4273-4C46-B172-D0DBBF010903" name="GUID-E4E494AB-4273-4C46-B172-D0DBBF010903"></a><h5 id="JSSEC-GUID-E4E494AB-4273-4C46-B172-D0DBBF010903" class="sect5">SampleClient读取的参数</h5>
                     <div>
                        <p><code class="codeph">SampleClient</code>需要三个参数：</p>
                        <ol>
                           <li>服务主体名称–代表的Kerberos主体的名称<code class="codeph">SampleServer</code> （请参阅<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos用户和服务主体名称</a> ）。
                           </li>
                           <li>主机名–主机所在的计算机<code class="codeph">SampleServer</code>在跑。
                           </li>
                           <li>端口号–其上的端口的端口号<code class="codeph">SampleServer</code>监听连接。
                           </li>
                        </ol>
                        <p>这是用于读取命令行参数的代码：</p><pre class="pre codeblock"><code>if (args.length &lt; 3) {
    System.out.println("Usage: java &lt;options&gt; Login SampleClient "
       + " &lt;servicePrincipal&gt; &lt;hostName&gt; &lt;port&gt;");
    System.exit(-1);
}

String server = args[0];
String hostName = args[1];
int port = Integer.parseInt(args[2]);</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-3E0915A3-9B41-4CA4-90D6-1A039A8B54C0" name="GUID-3E0915A3-9B41-4CA4-90D6-1A039A8B54C0"></a><h5 id="JSSEC-GUID-3E0915A3-9B41-4CA4-90D6-1A039A8B54C0" class="sect5">SampleServer读取的参数</h5>
                     <div>
                        <p><code class="codeph">SampleServer</code>只需要一个参数：</p>
                        <ul style="list-style-type:disc">
                           <li>本地端口号–由以下人员使用的端口号<code class="codeph">SampleServer</code>监听与客户的联系。该数字应与运行Windows Server 2003时指定的端口号相同。 <code class="codeph">SampleClient</code>程序。
                           </li>
                        </ul>
                        <p>以下是读取命令行参数的代码：</p><pre class="pre codeblock"><code>if (args.length != 1) {
    System.out.println(
        "Usage: java &lt;options&gt; Login SampleServer &lt;localPort&gt;");
    System.exit(-1);
}

int localPort = Integer.parseInt(args[0]);</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB" name="GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB"></a><h4 id="JSSEC-GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB" class="sect4">建立用于消息交换的套接字连接</h4>
                  <div>
                     <p>Java GSS-API提供了用于创建和解释令牌（不透明字节数据）的方法。令牌包含要在两个对等方之间安全交换的消息，但是实际令牌传输的方法取决于对等方。为了我们<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>在应用程序中，我们在客户端和服务器之间建立套接字连接，并使用套接字输入和输出流交换数据。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-17E54F39-2231-4271-BBDB-AF72D3D75FF3" name="GUID-17E54F39-2231-4271-BBDB-AF72D3D75FF3"></a><h5 id="JSSEC-GUID-17E54F39-2231-4271-BBDB-AF72D3D75FF3" class="sect5">用于套接字连接的SampleClient代码</h5>
                     <div>
                        <p><code class="codeph">SampleClient</code>作为主机名传递给参数<code class="codeph">SampleServer</code>正在运行以及端口号<code class="codeph">SampleServer</code>会监听连接，所以<code class="codeph">SampleClient</code>具有与之建立套接字连接所需的一切<code class="codeph">SampleServer</code> 。它使用以下代码来建立连接并初始化<span class="apiname">DataInputStream</span>和<span class="apiname">DataOutputStream</span>以用于将来的数据交换：</p><pre class="pre codeblock"><code>Socket socket = new Socket(hostName, port);

DataInputStream inStream = 
  new DataInputStream(socket.getInputStream());
DataOutputStream outStream = 
  new DataOutputStream(socket.getOutputStream());

System.out.println("Connected to server " 
   + socket.getInetAddress());</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-6E59BA99-675F-4937-88BB-89268949B356" name="GUID-6E59BA99-675F-4937-88BB-89268949B356"></a><h5 id="JSSEC-GUID-6E59BA99-675F-4937-88BB-89268949B356" class="sect5">用于套接字连接的SampleServer代码</h5>
                     <div>
                        <p>的<code class="codeph">SampleServer</code>应用程序作为参数传递给端口号，该端口号用于侦听来自客户端的连接。它创建一个<code class="codeph">ServerSocket</code>在该端口上监听：</p><pre class="pre codeblock"><code>ServerSocket ss = new ServerSocket(localPort);</code></pre><p>的<code class="codeph">ServerSocket</code>然后可以等待并接受来自客户端的连接，然后初始化<span class="apiname">DataInputStream</span>和<span class="apiname">DataOutputStream</span>以便与客户端将来进行数据交换：</p><pre class="pre codeblock"><code>Socket socket = ss.accept();

DataInputStream inStream =
    new DataInputStream(socket.getInputStream());
DataOutputStream outStream = 
    new DataOutputStream(socket.getOutputStream());

System.out.println("Got connection from client "
    + socket.getInetAddress());</code></pre><p>的<code class="codeph">accept</code>方法一直等到客户端（在我们的例子中， <code class="codeph">SampleClient</code> ）请求主机和端口上的连接<code class="codeph">SampleServer</code> ， 哪一个<code class="codeph">SampleClient</code>通过</p><pre class="pre codeblock"><code>Socket socket = new Socket(hostName, port);</code></pre><p>请求并建立连接后， <code class="codeph">accept</code>方法返回绑定到新端口的新<span class="apiname">Socket</span>对象。服务器可以通过此新套接字与客户端通信，并继续侦听该客户端上的其他客户端连接请求。 <code class="codeph">ServerSocket</code>绑定到原始端口。因此，服务器程序通常具有可以处理多个连接请求的循环。
                        </p>
                        <p>我们的基本循环结构<code class="codeph">SampleServer</code>是以下内容：</p><pre class="pre codeblock"><code>while (true) {

    Socket socket = ss.accept();

    <span class="italic">&lt;Establish input and output streams for the connection&gt;</span>; 
    <span class="italic">&lt;Establish a context with the client&gt;</span>; 
    <span class="italic">&lt;Exchange messages with the client&gt;</span>;
    <span class="italic">&lt;Clean up&gt;</span>;
}</code></pre><p>客户端连接在原始端口处排队，因此使用<code class="codeph">SampleServer</code> ，必须先完成与第一个建立连接的客户端的交互，然后才能接受下一个连接。服务器实际上可以通过使用线程同时为多个客户端服务-每个客户端连接一个线程，如</p><pre class="pre codeblock"><code>while (true) {
    <span class="italic">&lt;accept a connection&gt;</span>;
    <span class="italic">&lt;create a thread to handle the client&gt;</span>;
}
</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B" name="GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B"></a><h4 id="JSSEC-GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B" class="sect4">建立安全上下文</h4>
                  <div>
                     <p>在两个应用程序可以使用Java GSS-API在它们之间安全地交换消息之前，它们必须使用其凭证建立联合安全上下文。（注意：对于<code class="codeph">SampleClient</code> ，则在Login实用程序代表的用户验证用户身份时建立了凭据<code class="codeph">SampleClient</code>运行了，类似地<code class="codeph">SampleServer</code> ）安全上下文封装了共享状态信息，其中可能包括例如加密密钥。如果请求加密，则此类密钥的一种用法可能是对要交换的消息进行加密。
                     </p>
                     <p>作为安全上下文建立的一部分，上下文发起者（在我们的示例中， <code class="codeph">SampleClient</code> ）已向接受方（ <code class="codeph">SampleServer</code> ），并且可能要求接受方也必须向发起方进行身份验证，在这种情况下，我们说发生了“相互身份验证”。
                     </p>
                     <p>这两个应用程序都创建并使用<span class="apiname">GSSContext</span>对象来建立和维护组成安全上下文的共享信息。
                     </p>
                     <p>上下文对象的实例化由上下文发起者和上下文接受者以不同的方式完成。启动器实例化<span class="apiname">GSSContext之后</span> ，它可以选择设置各种上下文选项，这些选项将确定所需安全上下文的特征，例如，指定是否应该进行相互认证。设置完所有所需的特性后，启动器将调用<code class="codeph">initSecContext</code>方法，产生接受者的令牌所需<code class="codeph">acceptSecContext</code>方法。
                     </p>
                     <p>尽管存在Java GSS-API方法来准备在应用程序之间交换令牌， <span class="variable" translate="no">it is the responsibility of the applications to actually transfer the tokens between them.</span>应用程序<span class="variable" translate="no">it is the responsibility of the applications to actually transfer the tokens between them.</span> 因此，发起方从其调用中收到令牌后<code class="codeph">initSecContext</code> ，它将令牌发送给接受者。接受者呼叫<code class="codeph">acceptSecContext</code> ，将令牌传递给它。的<code class="codeph">acceptSecContext</code>方法可能反过来返回一个令牌。如果是这样，则接受者应将该令牌发送给发起者，发起者随后应调用<code class="codeph">initSecContext</code>再次传递此令牌。每一次<code class="codeph">initSecContext</code>要么<code class="codeph">acceptSecContext</code>返回一个令牌，调用该方法的应用程序应将该令牌发送给其对等方，并且该对等方应将令牌传递给其适当的方法（ <code class="codeph">acceptSecContext</code>要么<code class="codeph">initSecContext</code> ）。一直持续到上下文完全建立为止（这是上下文的<code class="codeph">isEstablished</code>方法返回<code class="codeph">true</code> ）。
                     </p>
                     <p>下面描述了示例应用程序的上下文建立代码：</p>
                     <ul style="list-style-type:disc">
                        <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC">SampleClient建立上下文</a></li>
                        <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-7466BDBC-CB41-4287-802A-C3426B14304A">SampleServer建立上下文</a></li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC" name="GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC"></a><h5 id="JSSEC-GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC" class="sect5">SampleClient建立上下文</h5>
                     <div>
                        <p>在我们的客户端/服务器方案中，SampleClient是上下文发起者。以下是建立安全上下文所需的基本步骤：</p>
                        <ol>
                           <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B">SampleClient GSSContext实例化</a></li>
                           <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-4D05D762-CD29-4A82-B773-5652A4754BF5">SampleClient所需选项的设置</a></li>
                           <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7">SampleClient上下文建立循环</a> ：在尚未建立上下文时循环，每次调用<code class="codeph">initSecContext</code> ，将所有返回的令牌发送到<code class="codeph">SampleServer</code> ，并从接收令牌（如果有） <code class="codeph">SampleServer</code> 。
                           </li>
                        </ol>
                     </div>
                     <div class="sect5"><a id="GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B" name="GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B"></a><h6 id="JSSEC-GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B" class="sect6">SampleClient GSSContext实例化</h6>
                        <div>
                           <p>一个<span class="apiname">GSSContext</span>被实例化一个<span class="apiname">GSSContext，</span>然后调用的一个创造了<code class="codeph">createContext</code>方法。<span class="apiname">GSSManager</span>类用作其他重要GSS API类的工厂。它可以创建实现<span class="apiname">GSSContext</span> ， <span class="apiname">GSSCredential</span>和<span class="apiname">GSSName</span>接口的类的实例。
                           </p>
                           <p><code class="codeph">SampleClient</code>通过调用<span class="apiname">GSSManager</span>静态方法获取默认<span class="apiname">GSSManager</span>子类的实例<code class="codeph">getInstance</code> ：</p><pre class="pre codeblock"><code>GSSManager manager = GSSManager.getInstance();</code></pre><p>默认的<span class="apiname">GSSManager</span>子类是其子类之一<code class="codeph">create*</code>方法 （ <code class="codeph">createContext</code>等）返回其实现支持Kerberos作为基础技术的类。
                           </p>
                           <p>用于在发起方一侧创建上下文的<span class="apiname">GSSManager</span>工厂方法具有以下签名：</p><pre class="pre codeblock"><code>GSSContext createContext(GSSName peer, Oid mech, 
            GSSCredential myCred, int lifetime);</code></pre><p>参数说明如下，随后是对<code class="codeph">createContext</code> 。
                           </p>
                        </div>
                        <div class="sect6"><a id="GUID-4C2BEA87-066F-4910-B09B-CB9C9B65D896" name="GUID-4C2BEA87-066F-4910-B09B-CB9C9B65D896"></a><h6 id="JSSEC-GUID-4C2BEA87-066F-4910-B09B-CB9C9B65D896" class="sect6">GSSName对等参数</h6>
                           <div>
                              <p>客户/服务器范例中的对等方是服务器。为了<code class="codeph">peer</code>参数，我们需要一个<span class="apiname">GSSName</span>作为代表服务器的服务主体。（请参阅<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos用户和服务主体名称</a> 。）服务主体名称的<span class="apiname">字符串</span>作为第一个参数传递给<code class="codeph">SampleClient</code> ，将参数放入名为的本地<span class="apiname">String</span>变量中<code class="codeph">server</code> 。<span class="apiname">GSSManager</span> <code class="codeph">manager</code>用于通过调用<span class="apiname">GSSName</span>之一来实例化<span class="apiname">GSSName</span> <code class="codeph">createName</code>方法。 <code class="codeph">SampleClient</code>称<code class="codeph">createName</code>具有以下签名的方法：</p><pre class="pre codeblock"><code>GSSName createName(String nameStr, Oid nameType);</code></pre><p><code class="codeph">SampleClient</code>通过<code class="codeph">server</code> <span class="apiname">的字符串</span> <code class="codeph">nameStr</code>论点。
                              </p>
                              <p>第二个参数是<span class="apiname">Oid</span> 。<span class="apiname">Oid</span>表示通用对象标识符。Oid是GSS-API框架内使用的可全局全局解释的标识符，用于标识机制和名称类型。Oid的结构和编码在ISOIEC-8824和ISOIEC-8825标准中定义。<span class="apiname">Oid</span>传递给<code class="codeph">createName</code>方法特别是名称类型<span class="apiname">Oid</span> （不是机制Oid）。
                              </p>
                              <p>在GSS-API中，字符串名称通常从独立于机制的格式映射为特定于机制的格式。通常，Oid指定字符串使用的名称格式，以便该机制知道如何进行此映射。传递一个<code class="codeph">null</code> <span class="apiname">Oid</span>表示名称已经采用该机制使用的本机格式。对于这种情况<code class="codeph">server</code>串;对于Kerberos版本5名称，它的格式正确。从而， <code class="codeph">SampleClient</code>通过一个<code class="codeph">null</code>为<span class="apiname">Oid</span> 。这里是电话：</p><pre class="pre codeblock"><code>GSSName serverName = manager.createName(server, null);</code></pre></div>
                        </div>
                        <div class="sect6"><a id="GUID-25214B28-5B08-4173-874B-7A2CEDDE55FB" name="GUID-25214B28-5B08-4173-874B-7A2CEDDE55FB"></a><h6 id="JSSEC-GUID-25214B28-5B08-4173-874B-7A2CEDDE55FB" class="sect6">Oid机制论点</h6>
                           <div>
                              <p><span class="apiname">GSSManager</span>的第二个参数<code class="codeph">createContext</code> method是一个Oid，表示在上下文建立期间用于客户端和服务器之间的身份验证以及它们之间的后续安全通信的机制。
                              </p>
                              <p>我们的教程将使用Kerberos V5作为安全机制。<a href="http://www.ietf.org/rfc/rfc1964.txt" target="_blank">RFC 1964</a>中将Kerberos V5机制的Oid定义为“ 1.2.840.113554.1.2.2”，因此我们创建了这样的<span class="apiname">Oid</span> ：</p><pre class="pre codeblock"><code>Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");</code></pre><p><code class="codeph">SampleClient</code>通过<code class="codeph">krb5Oid</code>作为第二个论点<code class="codeph">createContext</code> 。
                              </p>
                           </div>
                        </div>
                        <div class="sect6"><a id="GUID-AA193F7A-9EAB-4A3B-88DC-104EA28DB05D" name="GUID-AA193F7A-9EAB-4A3B-88DC-104EA28DB05D"></a><h6 id="JSSEC-GUID-AA193F7A-9EAB-4A3B-88DC-104EA28DB05D" class="sect6">GSSCredential myCred参数</h6>
                           <div>
                              <p><span class="apiname">GSSManager</span>的第三个参数<code class="codeph">createContext</code>方法是<span class="apiname">GSSCredential，</span>代表呼叫者的凭据。如果通过<code class="codeph">null</code>对于此参数，如<span class="apiname">SampleClient</span>一样，将使用默认凭据。
                              </p>
                           </div>
                        </div>
                        <div class="sect6"><a id="GUID-8728175F-7265-40E3-A10B-82EC27FDEA84" name="GUID-8728175F-7265-40E3-A10B-82EC27FDEA84"></a><h6 id="JSSEC-GUID-8728175F-7265-40E3-A10B-82EC27FDEA84" class="sect6">int生命周期参数</h6>
                           <div>
                              <p><span class="apiname">GSSManager</span>的最后一个参数<code class="codeph">createContext</code>方法是<code class="codeph">int</code>为创建的上下文指定所需的生存时间（以秒为单位）。 <code class="codeph">SampleClient</code>通过<code class="codeph">GSSContext.DEFAULT_LIFETIME</code>请求默认生存期。
                              </p>
                           </div>
                        </div>
                        <div class="sect6"><a id="GUID-6DA100F6-33D3-479F-AFB2-1DC61EE2F127" name="GUID-6DA100F6-33D3-479F-AFB2-1DC61EE2F127"></a><h6 id="JSSEC-GUID-6DA100F6-33D3-479F-AFB2-1DC61EE2F127" class="sect6">完整的createContext调用</h6>
                           <div>
                              <p>现在我们有了所有必需的参数，这是调用<code class="codeph">SampleClient</code>创建一个<span class="apiname">GSSContext</span> ：</p><pre class="pre codeblock"><code>GSSContext context = 
    manager.createContext(serverName,
                          krb5Oid,
                          null,
                          GSSContext.DEFAULT_LIFETIME);</code></pre></div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-4D05D762-CD29-4A82-B773-5652A4754BF5" name="GUID-4D05D762-CD29-4A82-B773-5652A4754BF5"></a><h6 id="JSSEC-GUID-4D05D762-CD29-4A82-B773-5652A4754BF5" class="sect6">SampleClient所需选项的设置</h6>
                        <div>
                           <p>在实例化上下文之后，并且在与上下文接受者实际建立上下文之前，上下文发起者可以选择设置各种选项，以确定所需的安全上下文特征。每个此类选项均通过调用<code class="codeph">request</code>实例化上下文上的方法。最<code class="codeph">request</code>方法需要一个<code class="codeph">boolean</code>用于指示是否请求功能的参数。并非总是能够满足请求，因此可以在上下文建立之后通过调用以下命令之一来确定是否满足请求： <code class="codeph">get</code>方法。
                           </p>
                           <p><code class="codeph">SampleClient</code>请求以下内容：</p>
                           <ol>
                              <li><span class="bold">相互认证</span> 。上下文发起方始终会向接受方进行身份验证。如果发起方请求相互认证，那么接受方也将向发起方进行认证。
                              </li>
                              <li><span class="bold">机密性</span> 。请求机密性意味着您请求为名为的上下文方法<span class="variable" translate="no">enabling</span>加密<code class="codeph">wrap</code> 。仅当<span class="apiname">MessageProp</span>对象传递给<code class="codeph">wrap</code>方法要求隐私。
                              </li>
                              <li><span class="bold">诚信</span>这要求完整性<code class="codeph">wrap</code>和<code class="codeph">getMIC</code>方法。当要求完整性时，调用这些方法时将生成一个称为消息完整性代码（MIC）的加密标记。什么时候<code class="codeph">getMIC</code>调用时，生成的MIC出现在返回的令牌中。什么时候<code class="codeph">wrap</code>调用MIC时，将MIC与消息（原始消息或对消息进行加密的结果，取决于是否应用机密性）一起打包为一个令牌的一部分。随后，您可以针对消息验证MIC，以确保消息在传输过程中没有被修改。
                              </li>
                           </ol>
                           <p>的<code class="codeph">SampleClient</code>在上发出这些请求的代码<code class="codeph">GSSException</code><code class="codeph">context</code>是以下内容：</p><pre class="pre codeblock"><code>context.requestMutualAuth(true);  // Mutual authentication
context.requestConf(true);  // Will use encryption later
context.requestInteg(true); // Will use integrity later</code></pre><p>建立上下文后，客户端必须通过调用accesor方法（如<span class="apiname">getMutualAuthState</span> ， <span class="apiname">getConfState</span>或<span class="apiname">getIntegState）</span>显式检查上下文状态，并在其中任何一个与所需状态不匹配时销毁安全上下文。
                           </p>
                           <div class="infoboxnote" id="GUID-4D05D762-CD29-4A82-B773-5652A4754BF5__GUID-5D58F826-9EF4-432F-8A87-EA1B00074217">
                              <p class="notep1">注意：</p>
                              <p>使用默认的<span class="apiname">GSSManager</span>实现和Kerberos机制时，将始终授予这些请求。
                              </p>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7" name="GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7"></a><h6 id="JSSEC-GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7" class="sect6">SampleClient上下文建立循环</h6>
                        <div>
                           <p>后<code class="codeph">SampleClient</code>已经实例化了<span class="apiname">GSSContext</span>并指定了所需的上下文选项，它实际上可以使用<code class="codeph">SampleServer</code> 。为此， <code class="codeph">SampleClient</code>有一个循环。每次循环迭代</p>
                           <ol>
                              <li>调用上下文的<code class="codeph">initSecContext</code>方法。如果这是第一次调用，则该方法将传递给<code class="codeph">null</code>令牌。否则，它将最近发送到的令牌传递给<code class="codeph">SampleClient</code>通过<code class="codeph">SampleServer</code> （由<code class="codeph">SampleServer</code>拨电至<code class="codeph">acceptSecContext</code> ）。
                              </li>
                              <li>发送由返回的令牌<code class="codeph">initSecContext</code> （如果有）到<code class="codeph">SampleServer</code> 。首次致电<code class="codeph">initSecContext</code>总是产生一个令牌。最后一次调用可能不会返回令牌。
                              </li>
                              <li>检查是否已建立上下文。如果不， <code class="codeph">SampleClient</code>从接收另一个令牌<code class="codeph">SampleServer</code>然后开始下一个循环迭代。
                              </li>
                           </ol>
                           <p>代币返回<code class="codeph">initSecContext</code>或收到<code class="codeph">SampleServer</code>放在一个字节数组中。令牌应由<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>作为不透明数据在它们之间传递并由Java GSS-API方法解释。
                           </p>
                           <p>的<code class="codeph">initSecContext</code>参数是一个包含令牌的字节数组，令牌起始位置到该数组的起始偏移量以及令牌长度。对于第一个电话， <code class="codeph">SampleClient</code>传递空令牌，因为尚未从接收到令牌<code class="codeph">SampleServer</code> 。
                           </p>
                           <p>与交换令牌<code class="codeph">SampleServer</code> ， <code class="codeph">SampleClient</code>使用<span class="apiname">DataInputStream</span> <code class="codeph">inStream</code>和<span class="apiname">DataOutputStream</span> <code class="codeph">outStream</code>它先前使用输入和输出流进行设置，以实现与<code class="codeph">SampleServer</code> 。请注意，无论何时写入令牌，令牌中的字节数都会首先写入，然后是令牌本身。原因在<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B">“ SampleClient和SampleServer消息交换”</a>部分的简介中进行了讨论。
                           </p>
                           <p>这里是<code class="codeph">SampleClient</code>上下文建立循环，后跟代码显示有关客户端和服务器是谁以及是否真正进行了相互身份验证的信息：</p><pre class="pre codeblock"><code>byte[] token = new byte[0];

while (!context.isEstablished()) {

    // token is ignored on the first call
    token = context.<span class="bold">initSecContext</span>(token, 0, token.length);

    // Send a token to the server if one was generated by
    // initSecContext
    if (token != null) {
        System.out.println("Will send token of size "
                   + token.length + " from initSecContext.");
        outStream.writeInt(token.length);
        outStream.write(token);
        outStream.flush();
    }

    // If the client is done with context establishment
    // then there will be no more tokens to read in this loop
    if (!context.isEstablished()) {
        token = new byte[inStream.readInt()];
        System.out.println("Will read input token of size "
                   + token.length
                   + " for processing by initSecContext");
        inStream.readFully(token);
    }
}

System.out.println("Context Established! ");
System.out.println("Client is " + context.getSrcName());
System.out.println("Server is " + context.getTargName());
if (context.getMutualAuthState())
    System.out.println("Mutual authentication took place!");</code></pre></div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7466BDBC-CB41-4287-802A-C3426B14304A" name="GUID-7466BDBC-CB41-4287-802A-C3426B14304A"></a><h5 id="JSSEC-GUID-7466BDBC-CB41-4287-802A-C3426B14304A" class="sect5">SampleServer建立上下文</h5>
                     <div>
                        <p>在我们的客户端/服务器场景中， <code class="codeph">SampleServer</code>是上下文接受器。以下是建立安全上下文所需的基本步骤：</p>
                        <ol>
                           <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-528478D5-A436-4539-9994-F6F338B02910">SampleServer GSSContext实例化</a></li>
                           <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7">SampleClient上下文建立循环</a> ：在尚未建立上下文时循环，每次从接收令牌<code class="codeph">SampleClient</code> ，打电话<code class="codeph">acceptSecContext</code>并将其传递给令牌，然后将所有返回的令牌发送至<code class="codeph">SampleClient</code> 。
                           </li>
                        </ol>
                     </div>
                     <div class="sect5"><a id="GUID-528478D5-A436-4539-9994-F6F338B02910" name="GUID-528478D5-A436-4539-9994-F6F338B02910"></a><h6 id="JSSEC-GUID-528478D5-A436-4539-9994-F6F338B02910" class="sect6">SampleServer GSSContext实例化</h6>
                        <div>
                           <p>如<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B">SampleClient GSSContext实例化中所述</a> ，通过实例化<span class="apiname">GSSManager</span>然后调用其一个<span class="apiname">GSSContext</span>来创建<span class="apiname">GSSContext</span> 。 <code class="codeph">createContext</code>方法。
                           </p>
                           <p>喜欢<code class="codeph">SampleClient</code> ， <code class="codeph">SampleServer</code>通过调用<span class="apiname">GSSManager</span>静态方法获取默认<span class="apiname">GSSManager</span>子类的实例<code class="codeph">getInstance</code> ：</p><pre class="pre codeblock"><code>GSSManager manager = GSSManager.getInstance();</code></pre><p>用于在接受方一侧创建上下文的<span class="apiname">GSSManager</span>工厂方法具有以下签名：</p><pre class="pre codeblock"><code>GSSContext createContext(GSSCredential myCred);</code></pre><p>如果通过<code class="codeph">null</code>对于<span class="apiname">GSSCredential</span>参数，为<code class="codeph">SampleServer</code>会使用默认凭据。通过以下方式实例化上下文：</p><pre class="pre codeblock"><code>GSSContext context = manager.createContext((GSSCredential)null);</code></pre></div>
                     </div>
                     <div class="sect5"><a id="GUID-0DCD04B3-6461-4F0E-B160-2560909F22CA" name="GUID-0DCD04B3-6461-4F0E-B160-2560909F22CA"></a><h6 id="JSSEC-GUID-0DCD04B3-6461-4F0E-B160-2560909F22CA" class="sect6">SampleServer上下文建立循环</h6>
                        <div>
                           <p>在SampleServer实例化GSSContext之后，它可以与SampleClient建立安全上下文。为此，SampleServer具有一个循环，直到建立上下文为止。每个循环迭代执行以下操作：</p>
                           <ol>
                              <li>从SampleClient接收令牌。此令牌是SampleClient的结果<code class="codeph">initSecContext</code>呼叫。
                              </li>
                              <li>调用上下文的<code class="codeph">acceptSecContext</code>方法，将刚刚收到的令牌传递给它。
                              </li>
                              <li>如果<code class="codeph">acceptSecContext</code>返回一个令牌，然后SampleServer将此令牌发送到SampleClient，然后如果尚未建立上下文，则开始下一个循环迭代。
                              </li>
                           </ol>
                           <p>代币返回<code class="codeph">acceptSecContext</code>或从SampleClient接收到的或放置在字节数组中。
                           </p>
                           <p>的<code class="codeph">acceptSecContext</code>参数是一个包含令牌的字节数组，令牌起始位置到该数组的起始偏移量以及令牌长度。
                           </p>
                           <p>为了与SampleClient交换令牌，SampleServer使用DataInputStream <code class="codeph">inStream</code>和DataOutputStream <code class="codeph">outStream</code>它先前使用输入和输出流来设置与SampleClient进行的套接字连接。
                           </p>
                           <p>这是SampleServer上下文建立循环：</p><pre class="pre codeblock"><code>byte[] token = null;

while (!context.isEstablished()) {

    token = new byte[inStream.readInt()];
    System.out.println("Will read input token of size "
       + token.length
       + " for processing by acceptSecContext");
    inStream.readFully(token);
    
    token = context.<span class="bold">acceptSecContext</span>(token, 0, token.length);
    
    // Send a token to the peer if one was generated by
    // acceptSecContext
    if (token != null) {
        System.out.println("Will send token of size "
           + token.length
           + " from acceptSecContext.");
        outStream.writeInt(token.length);
        outStream.write(token);
        outStream.flush();
    }
}

System.out.print("Context Established! ");
System.out.println("Client is " + context.getSrcName());
System.out.println("Server is " + context.getTargName());
if (context.getMutualAuthState())
    System.out.println("Mutual authentication took place!");</code></pre></div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-39585A77-5CF3-4122-B4EC-3D778392370D" name="GUID-39585A77-5CF3-4122-B4EC-3D778392370D"></a><h4 id="JSSEC-GUID-39585A77-5CF3-4122-B4EC-3D778392370D" class="sect4">安全地交换消息</h4>
                  <div>
                     <p>一旦建立了安全上下文<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code> ，他们可以使用上下文安全地交换消息。
                     </p>
                     <ul style="list-style-type:disc">
                        <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-683071BD-5FAB-4392-BABD-A5A68C145120">用于消息交换的GSSContext方法</a></li>
                        <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B">SampleClient和SampleServer消息交换</a></li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-683071BD-5FAB-4392-BABD-A5A68C145120" name="GUID-683071BD-5FAB-4392-BABD-A5A68C145120"></a><h5 id="JSSEC-GUID-683071BD-5FAB-4392-BABD-A5A68C145120" class="sect5">用于消息交换的GSSContext方法</h5>
                     <div>
                        <p>存在两种用于准备消息以进行安全交换的方法： <code class="codeph">wrap</code>和<code class="codeph">getMIC</code> 。实际上有两个<code class="codeph">wrap</code>方法（和两个<code class="codeph">getMIC</code>方法），两者之间的差异表示输入消息的位置（字节数组或输入流）以及输出应该到达的位置（字节数组返回值或输出流）。
                        </p>
                        <p>这些用于准备交换消息的方法，以及用于由对等方解释所得令牌的相应方法将在下面描述。</p>
                     </div>
                     <div class="sect5"><a id="GUID-F034E83C-1CA8-49E5-8BA7-AD25EFC6A8CD" name="GUID-F034E83C-1CA8-49E5-8BA7-AD25EFC6A8CD"></a><h6 id="JSSEC-GUID-F034E83C-1CA8-49E5-8BA7-AD25EFC6A8CD" class="sect6">包裹</h6>
                        <div>
                           <p>的<code class="codeph">wrap</code> method是消息交换的主要方法。
                           </p>
                           <p>的签名<code class="codeph">wrap</code>调用的方法<code class="codeph">SampleClient</code>是以下内容：</p><pre class="pre codeblock"><code>byte[] wrap (byte[] inBuf, int offset, interface len, 
                MessageProp msgProp)</code></pre><p>你过关了<code class="codeph">wrap</code>一条消息（在<code class="codeph">inBuf</code> ），则偏移为<code class="codeph">inBuf</code>消息开始的位置（ <code class="codeph">offset</code> ），以及消息的长度（ <code class="codeph">len</code> ）。您还传递一个<span class="apiname">MessageProp</span> ，该<span class="apiname">消息</span>用于指示所需的QOP（保护质量）并指定是否需要保密性（加密）。QOP值选择要使用的加密完整性和加密（如果需要）算法。与各种QOP值相对应的算法由基础机制的提供者指定。例如，Kerberos V5的值在<a href="http://www.ietf.org/rfc/rfc1964.txt" target="_blank">RFC 1964</a>中的4.2节中定义。通常将0指定为QOP值以请求默认QOP。</p>
                           <p>的<code class="codeph">wrap</code>方法返回包含该消息的令牌，并在其上返回加密的消息完整性代码（MIC）。如果<span class="apiname">MessageProp</span>指示需要私密性，则放置在令牌中的消息将被加密。您不需要知道返回令牌的格式；应将其视为不透明数据。您将返回的令牌发送到对等应用程序，该应用程序调用<code class="codeph">unwrap</code> “解包”令牌以获取原始消息并验证其完整性的方法。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-A722F5F0-0B1D-43DE-A65B-0830999C89D0" name="GUID-A722F5F0-0B1D-43DE-A65B-0830999C89D0"></a><h6 id="JSSEC-GUID-A722F5F0-0B1D-43DE-A65B-0830999C89D0" class="sect6">getMIC</h6>
                        <div>
                           <p>如果您只是想获取包含所提供消息的加密消息完整性代码（MIC）的令牌，请致电<code class="codeph">getMIC</code> 。您可能要执行此操作的一个示例原因是通过仅为该数据传输MIC来与对等方确认您拥有相同的数据，而不会产生相互传输数据本身的成本。
                           </p>
                           <p>的签名<code class="codeph">getMIC</code>调用的方法<code class="codeph">SampleServer</code>是以下内容：</p><pre class="pre codeblock"><code>
byte[] getMIC (byte[] inMsg, int offset, int len,
            MessageProp msgProp)</code></pre><p>你过关了<code class="codeph">getMIC</code>一条消息（在<code class="codeph">inMsg</code> ），则偏移为<code class="codeph">inMsg</code>消息开始的位置（ <code class="codeph">offset</code> ），以及消息的长度（ <code class="codeph">len</code> ）。您还传递一个<span class="apiname">MessageProp</span> ，该<span class="apiname">消息</span>用于指示所需的QOP（保护质量）。通常将0指定为QOP值以请求默认QOP。</p>
                           <p>如果您创建的令牌是<code class="codeph">getMIC</code>以及用于计算MIC的消息（或声称是计算MIC的消息），您可以调用<code class="codeph">verifyMIC</code>验证消息的MIC的方法。如果验证成功（即，如果未抛出<span class="apiname">GSSException</span> ），则证明该消息与计算MIC时的消息完全相同。从应用程序接收消息的对等方通常也希望获得MIC，以便他们可以验证MIC并确保消息在传输过程中未被修改或损坏。注意：如果您提前知道您想要MIC和消息，那么使用<code class="codeph">wrap</code>和<code class="codeph">unwrap</code>方法。但是在某些情况下，消息和MIC是分别接收的。
                           </p>
                           <p>的签名<code class="codeph">verifyMIC</code>对应于<code class="codeph">getMIC</code>上面显示的内容如下：</p><pre class="pre codeblock"><code>void verifyMIC (byte[] inToken, int tokOffset, int tokLen,
        byte[] inMsg, int msgOffset, int msgLen,
        MessageProp msgProp);</code></pre><p>这将验证包含在<code class="codeph">inToken</code> （长度<code class="codeph">tokLen</code> ，从偏移量开始<code class="codeph">tokOffset</code> ）中包含的消息<code class="codeph">inMsg</code> （长度<code class="codeph">msgLen</code> ，从偏移量开始<code class="codeph">msgOffset</code> ）。底层机制使用<span class="apiname">MessageProp</span>将信息返回给调用方，例如QOP表示已应用到消息的保护强度。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B" name="GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B"></a><h5 id="JSSEC-GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B" class="sect5">SampleClient和SampleServer消息交换</h5>
                     <div>
                        <p>下面总结了SampleClient和SampleServer之间的消息交换，其后是编码详细信息。</p>
                        <p>这些步骤是用于验证GSS-API客户端和服务器的“标准”步骤。麻省理工学院的一个小组编写了一个GSS-API客户端和GSS-API服务器，它们已经成为相当流行的测试程序，用于检查GSS-API库的不同实现之间的互操作性。（可以从MIT的<a href="http://web.mit.edu/kerberos/" target="_blank">http://web.mit.edu/kerberos</a>下载这些GSS-API示例应用程序作为Kerberos发行版的一部分。）MIT的此客户端和服务器遵循以下协议：建立上下文后，客户端发送一条消息，并且希望该消息返回MIC。如果实现了GSS-API库，通常的做法是通过对使用另一种GSS-API库实现的相应对等服务器或客户机运行使用库实现的客户端或服务器来对其进行测试。如果两个库实现均符合标准，则两个对等方将能够成功通信。
                        </p>
                        <p>用C语言编写的客户端（如MIT客户端）测试客户端或服务器的一种含义是令牌交换的方式。GSS-API的C实现不包括基于流的方法。在对等方上没有基于流的方法的情况下，编写令牌时，必须首先写入字节数，然后再写入令牌。同样，在读取令牌时，您首先要读取字节数，然后再读取令牌。这是什么<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>做。
                        </p>
                        <p>这是总结<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>信息交流：</p>
                        <ol>
                           <li><code class="codeph">SampleClient</code>来电<code class="codeph">wrap</code>加密和计算邮件的MIC。
                           </li>
                           <li><code class="codeph">SampleClient</code>发送从返回的令牌<code class="codeph">wrap</code>至<code class="codeph">SampleServer</code> 。
                           </li>
                           <li><code class="codeph">SampleServer</code>来电<code class="codeph">unwrap</code>获取原始消息并验证其完整性。
                           </li>
                           <li><code class="codeph">SampleServer</code>来电<code class="codeph">getMIC</code>计算解密后的消息的MIC。
                           </li>
                           <li><code class="codeph">SampleServer</code>发送由返回的令牌<code class="codeph">getMIC</code> （包含MIC） <code class="codeph">SampleClient</code> 。
                           </li>
                           <li><code class="codeph">SampleClient</code>来电<code class="codeph">verifyMIC</code>验证MIC发送的<code class="codeph">SampleServer</code>是原始邮件的有效MIC。
                           </li>
                        </ol>
                     </div>
                     <div class="sect5"><a id="GUID-BDB7693C-A999-4CDC-BEF1-9D3A207085F9" name="GUID-BDB7693C-A999-4CDC-BEF1-9D3A207085F9"></a><h6 id="JSSEC-GUID-BDB7693C-A999-4CDC-BEF1-9D3A207085F9" class="sect6">SampleClient代码对消息进行加密并发送</h6>
                        <div>
                           <p>的<code class="codeph">SampleClient</code>用于加密消息，为其计算MIC并将结果发送到的代码<code class="codeph">SampleServer</code>是以下内容：</p><pre class="pre codeblock"><code>byte[] messageBytes = "Hello There!\0".getBytes();

/*
 * The first MessageProp argument is 0 to request
 * the default Quality-of-Protection.
 * The second argument is true to request
 * privacy (encryption of the message).
 */
MessageProp prop =  new MessageProp(0, true);

/*
 * Encrypt the data and send it across. Integrity protection
 * is always applied, irrespective of encryption.
 */
token = context.<span class="bold">wrap</span>(messageBytes, 0, messageBytes.length, 
    prop);
System.out.println("Will send wrap token of size " 
    + token.length);
outStream.writeInt(token.length);
outStream.write(token);
outStream.flush();</code></pre></div>
                     </div>
                     <div class="sect5"><a id="GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9" name="GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9"></a><h6 id="JSSEC-GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9" class="sect6">SampleServer代码以解包令牌，计算MIC并将其发送</h6>
                        <div>
                           <p>下列<code class="codeph">SampleServer</code>代码读取由发送的包装令牌<code class="codeph">SampleClient</code>并“解包”它以获取原始消息并验证其完整性。在这种情况下，解包包括解密，因为消息已加密。
                           </p>
                           <div class="infoboxnote" id="GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9__GUID-B372F294-8EDD-481C-A627-E64C7D79147F">
                              <p class="notep1">注意：</p>
                              <p>在这里，完整性检查有望成功。但是请注意，通常，如果完整性检查失败，则表示邮件在传输中已更改。如果<code class="codeph">unwrap</code>方法遇到完整性检查失败，它将引发<span class="apiname">GSSException</span>并带有主要错误代码<span class="apiname">GSSException。BAD_MIC</span> 。</p>
                           </div><pre class="pre codeblock"><code>/*
 * Create a MessageProp which unwrap will use to return 
 * information such as the Quality-of-Protection that was 
 * applied to the wrapped token, whether or not it was 
 * encrypted, etc. Since the initial MessageProp values
 * are ignored, it doesn't matter what they are set to.
 */
MessageProp prop = new MessageProp(0, false);

/* 
 * Read the token. This uses the same token byte array 
 * as that used during context establishment.
 */
token = new byte[inStream.readInt()];
System.out.println("Will read token of size " 
    + token.length);
inStream.readFully(token);

byte[] bytes = context.<span class="bold">unwrap</span>(token, 0, token.length, prop);
String str = new String(bytes);
System.out.println("Received data \""
    + str + "\" of length " + str.length());
System.out.println("Encryption applied: "
    + prop.getPrivacy());</code></pre><p>下一个， <code class="codeph">SampleServer</code>为解密后的消息生成一个MIC并将其发送给<code class="codeph">SampleClient</code> 。这实际上不是必需的，而仅说明了在解密后的消息上生成MIC，该消息应与原始消息完全相同。 <code class="codeph">SampleClient</code>包装并发送到<code class="codeph">SampleServer</code> 。什么时候<code class="codeph">SampleServer</code>生成并发送给<code class="codeph">SampleClient</code>和<code class="codeph">SampleClient</code>验证它，这证明了<code class="codeph">SampleClient</code>解密后的消息<code class="codeph">SampleServer</code>实际上与来自的原始消息完全相同<code class="codeph">SampleClient</code> 。
                           </p><pre class="pre codeblock"><code>/*
 * First reset the QOP of the MessageProp to 0
 * to ensure the default Quality-of-Protection
 * is applied.
 */
prop.setQOP(0);

token = context.<span class="bold">getMIC</span>(bytes, 0, bytes.length, prop);

System.out.println("Will send MIC token of size " 
                   + token.length);
outStream.writeInt(token.length);
outStream.write(token);
outStream.flush();</code></pre></div>
                     </div>
                     <div class="sect5"><a id="GUID-FF93FB73-B91B-489A-807F-577939ACE8A6" name="GUID-FF93FB73-B91B-489A-807F-577939ACE8A6"></a><h6 id="JSSEC-GUID-FF93FB73-B91B-489A-807F-577939ACE8A6" class="sect6">用于验证MIC的SampleClient代码</h6>
                        <div>
                           <p>下列<code class="codeph">SampleClient</code>代码读取由<code class="codeph">SampleServer</code>解密的邮件上，然后验证MIC是原始邮件的MIC，证明解密的邮件<code class="codeph">SampleServer</code>具有与原始消息相同的内容：</p><pre class="pre codeblock"><code>token = new byte[inStream.readInt()];
System.out.println("Will read token of size " + token.length);
inStream.readFully(token);

/* 
 * Recall messageBytes is the byte array containing
 * the original message and prop is the MessageProp 
 * already instantiated by SampleClient.
 */
context.<span class="bold">verifyMIC</span>(token, 0, token.length, 
          messageBytes, 0, messageBytes.length,
          prop);

System.out.println("Verified received MIC for message.");</code></pre></div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DA54B317-30B2-4666-86B6-B1AD4D627002" name="GUID-DA54B317-30B2-4666-86B6-B1AD4D627002"></a><h4 id="JSSEC-GUID-DA54B317-30B2-4666-86B6-B1AD4D627002" class="sect4">清理</h4>
                  <div>
                     <p>什么时候<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>完成消息交换后，他们需要执行清除操作。两者都包含以下代码以</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>关闭插座连接并</p>
                        </li>
                        <li>
                           <p>释放存储在上下文对象中的系统资源和密码信息，然后使上下文无效。</p><pre class="pre codeblock"><code>socket.close();
context.dispose();</code></pre></li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-6D82A7D2-C406-40F4-838A-42ED61194182" name="GUID-6D82A7D2-C406-40F4-838A-42ED61194182"></a><h3 id="JSSEC-GUID-6D82A7D2-C406-40F4-838A-42ED61194182" class="sect3">Kerberos用户和服务主体名称</h3>
               <div>
                  <p>由于本教程使用的基础身份验证和安全通信技术是Kerberos V5，因此无论需要用户或服务的地方，我们都使用Kerberos样式的主体名称（请参阅<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0">Principals</a> ）。
                  </p>
                  <p>例如，当您运行<code class="codeph">SampleClient</code>要求您提供<span class="bold">用户名</span> 。Kerberos风格的用户名就是为Kerberos身份验证分配的用户名。它由基本用户名（例如<code class="codeph">mjones</code> ）后跟一个“ <code class="codeph">@</code>以及您的境界（例如<code class="codeph">mjones@KRBNT-OPERATIONS.EXAMPLE.COM</code> ）。
                  </p>
                  <p>像这样的服务器程序<code class="codeph">SampleServer</code>通常被视为提供“服务”并代表特定的“ <span class="bold">服务主体</span> ” <span class="bold">运行</span> 。的服务主体名称<code class="codeph">SampleServer</code>在几个地方需要：</p>
                  <ul style="list-style-type:disc">
                     <li>当你跑步<code class="codeph">SampleServer</code>和<code class="codeph">SampleClient</code>尝试与其建立连接，则底层Kerberos机制将尝试向Kerberos KDC进行身份验证。它提示您登录。您应该以适当的服务主体登录。
                     </li>
                     <li>当你跑步<code class="codeph">SampleClient</code> ，参数之一是服务主体名称。这是需要的<code class="codeph">SampleClient</code>可以使用适当的服务启动安全上下文的建立。
                     </li>
                     <li>如果<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>程序是使用安全管理器运行的（本教程中没有使用），客户端和服务器策略文件都将需要一个<span class="apiname">ServicePermission</span> ，其名称等于服务主体名称，而操作则等于“启动”或“接受”（用于启动或接受建立安全上下文）。
                     </li>
                  </ul>
                  <p>在本文档中以及随附的登录配置文件中， <code class="codeph">service_principal@your_realm</code>用作占位符，由您的环境中要使用的实际名称替换。实际上， <span class="italic">任何</span> Kerberos主体都可以用作服务主体名称。因此<span class="bold">，出于尝试本教程的目的，您可以将用户名用作客户端用户名和服务主体名。</span></p>
                  <p>在生产环境中，系统管理员通常喜欢将服务器仅作为特定主体运行，并且可以分配要使用的特定名称。分配的Kerberos样式服务主体名称通常为以下形式</p><pre class="pre codeblock"><code>service_name/machine_name@realm;</code></pre><p>例如，一个nfs服务运行在名为<code class="codeph">raven</code>在名为<code class="codeph">KRBNT-OPERATIONS.EXAMPLE.COM</code>可以具有服务主体名称</p><pre class="pre codeblock"><code>nfs/raven@KRBNT-OPERATIONS.EXAMPLE.COM</code></pre><p>但是，不需要这样的多组件名称。可以使用单组件名称，就像用户主体的名称一样。例如，安装可能使用相同的ftp服务主体<code class="codeph">ftp@realm</code>适用于该领域中的所有ftp服务器，而另一个安装可能针对不同的ftp服务器具有不同的ftp主体，例如<code class="codeph">ftp/host1@realm</code>和<code class="codeph">ftp/host2@realm</code>在机器上<code class="codeph">host1</code>和<code class="codeph">host2</code> ， 分别。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-B2F0BDD6-C35F-4B99-8AC3-60F0FCD351DF" name="GUID-B2F0BDD6-C35F-4B99-8AC3-60F0FCD351DF"></a><h4 id="JSSEC-GUID-B2F0BDD6-C35F-4B99-8AC3-60F0FCD351DF" class="sect4">主体名称中需要领域时</h4>
                  <div>
                     <p>如果用户或服务主体名称的领域是默认领域（请参见<a href="kerberos-requirements.html#GUID-EAA2758B-3071-4CDA-AEF1-D76F5271E998">Kerberos要求</a> ），则可以在登录Kerberos（即提示您输入用户名）时离开该领域。因此，例如，如果您的用户名是<code class="codeph">mjones@KRBNT-OPERATIONS.EXAMPLE.COM</code> ，然后您跑步<code class="codeph">SampleClient</code> ，当它要求您的用户名时，您只需指定<code class="codeph">mjones</code> ，离开领域。该名称在作为Kerberos主体名称的上下文中进行解释，并根据需要附加默认领域。
                     </p>
                     <p>如果主体名称将由<span class="apiname">GSSManager</span>转换为<span class="apiname">GSSName</span> ，那么您也可以离开领域<code class="codeph">createName</code>方法。例如，当您运行<code class="codeph">SampleClient</code> ，参数之一是服务器服务主体名称。您可以指定名称而不包含领域，因为<code class="codeph">SampleClient</code>将名称传递给这样的<code class="codeph">createName</code>方法，根据需要追加默认领域。
                     </p>
                     <p>建议在登录配置文件和策略文件中使用主体名称时始终包含领域，因为此类文件的解析器行为可能与实现有关；它们可能会或可能不会在使用此类名称之前附加默认领域，并且如果名称中没有领域，则后续操作可能会失败。</p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A" name="GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A"></a><h3 id="JSSEC-GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A" class="sect3">登录配置文件</h3>
               <div>
                  <p>在本教程中，我们让底层的Kerberos机制获取正在运行的用户的凭据<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>的，而不是直接调用JAAS方法（如在<a href="jaas-authentication.html#GUID-0C6EB04B-D203-4688-A3E2-A7D442334623">JAAS认证</a>和<a href="jaas-authorization.html#GUID-69241059-CCD0-49F6-838F-DDC752F9F19F">JAAS授权</a>教程）或间接（例如，经由登录实用程序中所描述的<a href="use-jaas-login-utility.html#GUID-F41E74DF-EE54-4EB1-8609-49C6D324ADF5">使用JAAS登录实用的</a>教程，并在<a href="use-jaas-login-utility-and-java-gss-api-secure-message-exchanges.html#GUID-C1DFED9D-D3A1-4C11-95D8-3543935E87C8">使用JAAS登录实用程序和Java GSS-API的适用于Secure Message Exchanges</a>教程）。
                  </p>
                  <p>Oracle提供的默认Kerberos机制实现实际上提示输入Kerberos名称和密码，并向Kerberos KDC验证指定的用户（或服务）。该机制依靠JAAS来执行此身份验证。</p>
                  <p>JAAS支持可插入身份验证框架，这意味着可以在调用应用程序下插入任何类型的身份验证模块。登录配置指定用于特定应用程序的登录模块。Oracle的默认JAAS实现要求在文件中指定登录配置信息。（注意：其他一些供应商可能没有基于文件的实现。）有关什么是登录配置文件，包含的内容以及如何指定应使用哪个登录配置文件的信息，请参见<a href="appendix-b-jaas-login-configuration-file.html#GUID-7EB80FA5-3C16-4016-AED6-0FC619F86F8E">附录B：JAAS登录配置文件</a> 。
                  </p>
                  <p>对于本教程，Kerberos登录模块<code class="codeph">com.sun.security.auth.module.Krb5LoginModule</code>在配置文件中指定。此登录模块提示输入Kerberos名称和密码，并尝试通过Kerberos KDC进行身份验证。</p>
                  <p>都<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>可以使用相同的登录配置文件（如果该文件包含两个条目，一个条目用于客户端，一个条目用于服务器）。
                  </p>
                  <p>的<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a>本教程使用的登录配置文件如下：</p><pre class="pre codeblock"><code><span class="bold">com.sun.security.jgss.initiate</span>  {
  com.sun.security.auth.module.Krb5LoginModule required;
};

<span class="bold">com.sun.security.jgss.accept</span>  {
  com.sun.security.auth.module.Krb5LoginModule required storeKey=true 
};</code></pre><p>具有这两个名称的条目（ <code class="codeph">com.sun.security.jgss.initiate</code>和<code class="codeph">com.sun.security.jgss.accept</code>需要新凭证时，由GSS-API机制的Oracle实现使用）。由于本教程中使用的机制是Kerberos V5机制，因此需要调用Kerberos登录模块以获得这些凭据。因此，我们在这些条目<a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/auth/module/Krb5LoginModule.html" target="_blank"><span class="apiname">中将Krb5LoginModule</span></a>列为必需的模块。的<code class="codeph">com.sun.security.jgss.initiate</code>该条目指定客户端的配置，并且<code class="codeph">com.sun.security.jgss.accept</code>服务器端的条目。
                  </p>
                  <p>仅当尝试以指定实体身份登录Kerberos KDC时， <span class="apiname">Krb5LoginModule</span>才会成功。跑步时<code class="codeph">SampleClient</code>要么<code class="codeph">SampleServer</code> ，系统将提示用户输入名称和密码。
                  </p>
                  <p>的<code class="codeph">SampleServer</code>条目<span class="bold"><code class="codeph">storeKey=true</code></span>表示应从登录期间提供的密码中计算出一个密钥，并将其存储在登录后创建的<span class="apiname">主题</span>的专用凭据中。此密钥随后在相互认证期间在以下情况下建立安全上下文时使用： <code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code> 。
                  </p>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/auth/module/Krb5LoginModule.html" target="_blank"><span class="apiname">Krb5LoginModule</span></a> Javadoc API文档描述了<span class="apiname">Krb5LoginModule</span>类支持的配置选项。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-841EB74E-3B52-4421-BC10-FE3C8511E007" name="GUID-841EB74E-3B52-4421-BC10-FE3C8511E007"></a><h3 id="JSSEC-GUID-841EB74E-3B52-4421-BC10-FE3C8511E007" class="sect3">useSubjectCredsOnly系统属性</h3>
               <div>
                  <p>在本教程中，我们设置系统属性<code class="codeph">javax.security.auth.useSubjectCredsOnly</code>至<code class="codeph">false</code> ，这使我们可以放宽通常的限制，即要求GSS机制从JAAS设置的现有<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">主题中</a>获取必要的凭证。放宽此限制后，它将允许该机制从某些特定于供应商的位置获取凭据。例如，某些供应商可能选择使用操作系统的缓存（如果存在），而其他供应商可能选择从磁盘上受保护的文件中读取。
                  </p>
                  <p>放宽此限制后，Oracle的Kerberos机制仍会在与线程的访问控制上下文关联的主题中查找凭据，但是，如果找不到该凭据，它将使用Kerberos模块执行JAAS身份验证以获得新的凭据。Kerberos模块提示您输入Kerberos主体名称和密码。请注意，如果将此属性设置为<code class="codeph">false</code> 。请查阅其文档以确定其实现的行为。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E" name="GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E"></a><h3 id="JSSEC-GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E" class="sect3">运行SampleClient和SampleServer程序</h3>
               <div>
                  <p>执行<code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>程序，请执行以下操作：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6">准备要执行的SampleServer</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B">准备SampleClient执行</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C">执行SampleServer</a></li>
                     <li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59">执行SampleClient</a></li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6" name="GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6"></a><h4 id="JSSEC-GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6" class="sect4">准备要执行的SampleServer</h4>
                  <div>
                     <p>准备<code class="codeph">SampleServer</code>要执行，请执行以下操作：</p>
                     <ol>
                        <li>将以下文件复制到要运行的计算机可访问的目录中<code class="codeph">SampleServer</code> ：<ul style="list-style-type:disc">
                              <li>的<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVER.JAVA-33891DED"><code>SampleServer.java</code></a>源文件。
                              </li>
                              <li>的<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a>登录配置文件。
                              </li>
                           </ul>
                        </li>
                        <li>编译<code class="codeph">SampleServer.java</code> ：<pre class="pre codeblock"><code>javac SampleServer.java</code></pre></li>
                     </ol>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B" name="GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B"></a><h4 id="JSSEC-GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B" class="sect4">准备SampleClient执行</h4>
                  <div>
                     <p>准备<code class="codeph">SampleClient</code>要执行，请执行以下操作：</p>
                     <ol>
                        <li>将以下文件复制到要运行的计算机可访问的目录中<code class="codeph">SampleClient</code> ：<ul style="list-style-type:disc">
                              <li>的<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLECLIENT.JAVA-338923E1"><code>SampleClient.java</code></a>源文件。
                              </li>
                              <li>的<a href="source-code-jaas-and-java-gss-api-tutorials.html#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a>登录配置文件。
                              </li>
                           </ul>
                        </li>
                        <li>编译<code class="codeph">SampleClient.java</code> ：<pre class="pre codeblock"><code>javac SampleClient.java</code></pre></li>
                     </ol>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C" name="GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C"></a><h4 id="JSSEC-GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C" class="sect4">执行SampleServer</h4>
                  <div>
                     <p>重要的是要执行<code class="codeph">SampleServer</code>之前<code class="codeph">SampleClient</code>因为<code class="codeph">SampleClient</code>将尝试建立套接字连接<code class="codeph">SampleServer</code>如果那会失败<code class="codeph">SampleServer</code>尚未运行并接受套接字连接。
                     </p>
                     <p>执行<code class="codeph">SampleServer</code> ，请确保在预期运行的计算机上运行它。该机器名（主机名）被指定为<code class="codeph">SampleClient</code> 。服务主体名称出现在多个位置，包括登录配置文件和策略文件。
                     </p>
                     <p>转到您准备的目录<code class="codeph">SampleServer</code>执行。执行<code class="codeph">SampleServer</code> ，指定</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过<code class="codeph">-Djava.security.krb5.realm=<span class="variable" translate="no"><your_realm></span></code>您的Kerberos领域是指定的领域。
                           </p>
                           <p>例如，如果您的领域是<code class="codeph">KRBNT-OPERATIONS.EXAMPLE.COM</code>你放<code class="codeph">-Djava.security.krb5.realm=KRBNT-OPERATIONS.EXAMPLE.COM</code> 。
                           </p>
                        </li>
                        <li>
                           <p>通过<code class="codeph">-Djava.security.krb5.kdc=<span class="variable" translate="no"><your_kdc></span></code>您的Kerberos KDC是指定的那个。
                           </p>
                           <p>例如，如果您的KDC是<code class="codeph">samplekdc.example.com</code>你放<code class="codeph">-Djava.security.krb5.kdc=samplekdc.example.com</code> 。
                           </p>
                        </li>
                        <li>
                           <p>通过<code class="codeph">-Djavax.security.auth.useSubjectCredsOnly=false</code>底层机制可以决定如何获取凭据。请参见<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">useSubjectCredsOnly系统属性</a> 。
                           </p>
                        </li>
                        <li>
                           <p>通过<code class="codeph">-Djava.security.auth.login.config=bcsLogin.conf</code>要使用的登录配置文件是<code class="codeph">bcsLogin.conf</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>唯一需要的参数<code class="codeph">SampleServer</code>是一个用于指定用于侦听客户端连接的端口号的端口。选择一个高端口号，该端口号不太可能用于其他用途。例如4444。
                     </p>
                     <p>以下是可用于Microsoft Windows和Solaris，Linux和macOS系统的完整命令。</p>
                     <div class="infoboxnote" id="GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C__GUID-ADC9E59B-57DF-47DA-890F-4DCC371D84D1">
                        <p class="notep1">注意：</p>
                        <p><span class="bold">重要说明：在此命令中，您必须替换<code class="codeph"><span class="variable" translate="no"><port_number></span></code>带有适当的端口号， <code class="codeph"><span class="variable" translate="no"><your_realm></span></code>与您的Kerberos领域，以及<code class="codeph"><span class="variable" translate="no"><your_kdc></span></code>与您的Kerberos KDC。</span></p>
                        <p>的<code class="codeph">java.security.krb5.kdc</code>系统属性将“：”符号解释为多个KDC的分隔符。如果KDC不在默认端口（88）上侦听，则必须在默认端口中提供默认领域及其KDC。 <code>krb5.conf</code>文件，然后设置系统属性<code class="codeph">java.security.krb5.kdc.conf</code>带有此文件的名称：</p><pre class="pre codeblock"><code>-Djava.security.krb5.conf=<span class="variable" translate="no">&lt;your_krb5.conf_file&gt;</span></code></pre></div>
                     <p>这是命令：</p><pre class="pre codeblock"><code>java -Djava.security.krb5.realm=<span class="variable" translate="no">&lt;your_realm&gt;</span> 
 -Djava.security.krb5.kdc=<span class="variable" translate="no">&lt;your_kdc&gt;</span> 
 -Djavax.security.auth.useSubjectCredsOnly=false
 -Djava.security.auth.login.config=bcsLogin.conf 
 SampleServer <span class="variable" translate="no">&lt;port_number&gt;</span></code></pre><p>完整命令应显示在一行上（或在Solaris，Linux或macOS上，在多行上显示，但每行除最后一行外均以“ \”结尾，表示还有更多行）。这里使用多行只是为了清楚起见。由于此命令很长，因此您可能需要将其放在.bat文件（对于Windows）或.sh文件（对于Solaris，Linux或macOS）中，然后运行该文件以执行命令。</p>
                     <p>的<code class="codeph"><code class="codeph">SampleServer</code></code>代码将侦听指定端口上的套接字连接。出现提示时，键入服务主体的Kerberos名称和密码。在登录配置文件中指定的底层Kerberos身份验证机制会将服务主体记录到Kerberos中。
                     </p>
                     <p>有关登录故障排除的建议，请参阅<a href="troubleshooting.html#GUID-2087ADBA-6C36-43D5-8841-C79FCB4F5FBE">故障排除</a> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59" name="GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59"></a><h4 id="JSSEC-GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59" class="sect4">执行SampleClient</h4>
                  <div>
                     <p>执行<code class="codeph">SampleClient</code> ，首先转到您准备好的目录<code class="codeph">SampleClient</code>执行。执行<code class="codeph">SampleClient</code> ，指定</p>
                     <ul style="list-style-type:disc">
                        <li>通过<code class="codeph">-Djava.security.krb5.realm=<span class="variable" translate="no"><your_realm></span></code>您的Kerberos领域是指定的领域。
                        </li>
                        <li>通过<code class="codeph">-Djava.security.krb5.kdc=<span class="variable" translate="no"><your_kdc></span></code>您的Kerberos KDC是指定的那个。
                        </li>
                        <li>通过<code class="codeph">-Djavax.security.auth.useSubjectCredsOnly=false</code>底层机制可以决定如何获取凭据。
                        </li>
                        <li>通过<code class="codeph">-Djava.security.auth.login.config=bcsLogin.conf</code>要使用的登录配置文件是<code class="codeph">bcsLogin.conf</code> 。
                        </li>
                     </ul>
                     <p>的<code class="codeph">SampleClient</code>参数是（1）表示服务主体的Kerberos名称<code class="codeph">SampleServer</code> （请参见<a href="use-java-gss-api-secure-message-exchanges-jaas-programming.html#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos用户和服务主体名称</a> ，（2）主机（计算机）的名称<code class="codeph">SampleServer</code>正在运行，以及（3）其上的端口号<code class="codeph">SampleServer</code>正在侦听客户端连接。
                     </p>
                     <p>以下是用于Windows和Solaris，Linux和macOS系统的完整命令。</p>
                     <div class="infoboxnote" id="GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59__GUID-AC5953E8-06A3-4527-97BA-108C746A6B98">
                        <p class="notep1">注意：</p>
                        <p><span class="bold">重要说明：在此命令中，您必须替换<code class="codeph"><span class="variable" translate="no"><service_principal></span></code> ， <code class="codeph"><span class="variable" translate="no"><host></span></code> ， <code class="codeph"><span class="variable" translate="no"><port_number></span></code> ， <code class="codeph"><span class="variable" translate="no"><your_realm></span></code>和<code class="codeph"><span class="variable" translate="no"><your_kdc></span></code>具有适当的值</span> （请注意，端口号必须与作为参数传递给的端口号相同） <code class="codeph">SampleServer</code> ）。这些值不必放在引号中。
                        </p>
                     </div>
                     <p>这是命令：</p><pre class="pre codeblock"><code>java -Djava.security.krb5.realm=<span class="variable" translate="no">&lt;your_realm&gt;</span> 
 -Djava.security.krb5.kdc=<span class="variable" translate="no">&lt;your_kdc&gt;</span> 
 -Djavax.security.auth.useSubjectCredsOnly=false
 -Djava.security.auth.login.config=bcsLogin.conf 
 SampleClient <span class="variable" translate="no">&lt;service_principal&gt;</span> <span class="variable" translate="no">&lt;host&gt;</span> <span class="variable" translate="no">&lt;port_number&gt;</span></code></pre><p>在一行上键入完整的命令。为了清晰起见，此处使用多行。与执行命令一样<code class="codeph">SampleServer</code> ，如果命令太长而无法直接在命令窗口中键入，请将其放在.bat文件（Windows）或.sh文件（Solaris，Linux和macOS）中，然后执行该文件。
                     </p>
                     <p>出现提示时，键入您的Kerberos用户名和密码。登录配置文件中指定的基础Kerberos身份验证机制将使您登录Kerberos。的<code class="codeph">SampleClient</code>代码请求与<code class="codeph">SampleServer</code> 。一旦<code class="codeph">SampleServer</code>接受连接， <code class="codeph">SampleClient</code>和<code class="codeph">SampleServer</code>建立共享上下文，然后按照本教程中的描述交换消息。
                     </p>
                     <p>有关登录故障排除的建议，请参阅<a href="troubleshooting.html#GUID-2087ADBA-6C36-43D5-8841-C79FCB4F5FBE">故障排除</a> 。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>