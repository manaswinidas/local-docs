<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Java Authentication and Authorization Service (JAAS) Reference Guide</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-authentication-and-authorization-service-jaas1.html" title="Previous" type="text/html">
      <link rel="next" href="appendix-b-jaas-login-configuration-file.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-authentication-and-authorization-service-jaas1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="appendix-b-jaas-login-configuration-file.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="java-authentication-and-authorization-service-jaas1.html" property="item" typeof="WebPage"><span property="name">Java身份验证和授权服务（JAAS）</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java身份验证和授权服务（JAAS）参考指南</li>
            </ol>
            <a id="GUID-2A935F5E-0803-411D-B6BC-F8C64D01A25C" name="GUID-2A935F5E-0803-411D-B6BC-F8C64D01A25C"></a>
            
            <h2 id="JSSEC-GUID-2A935F5E-0803-411D-B6BC-F8C64D01A25C" class="sect2">Java身份验证和授权服务（JAAS）参考指南</h2>
         </header>
         <div class="ind">
            <div>
               <p>JAAS可以用于两个目的：</p>
               <ul style="list-style-type:disc">
                  <li>为了对用户进行<span class="variable" translate="no">authentication</span> ，无论代码是作为应用程序，applet，bean还是servlet运行，都可以可靠，安全地确定谁正在执行Java代码。和</li>
                  <li><span class="variable" translate="no">authorization</span>用户以确保他们具有执行所执行操作所需的访问控制权（权限）。
                  </li>
               </ul>
               <p>JAAS实现了标准可插拔身份验证模块（PAM）框架的Java版本。</p>
               <p>传统Java已经提供了基于codesource的访问控制（基于访问控制<span class="variable" translate="no">where</span>代码源自和<span class="variable" translate="no">who signed</span>的代码）。但是，它缺乏根据<span class="variable" translate="no">who runs</span>代码来另外强制执行访问控制的功能。JAAS提供了一个框架，可以通过这种支持来增强Java安全性体系结构。
               </p>
               <p>JAAS认证以<span class="variable" translate="no">pluggable</span>方式执行。这允许应用程序保持独立于基础身份验证技术。可以在应用程序下插入新的或更新的身份验证技术，而无需修改应用程序本身。应用程序通过实例化身份验证来启用身份验证过程<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/login/LoginContext.html" target="_blank"><code class="codeph">LoginContext</code></a>对象，该对象又引用一个<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/login/Configuration.html" target="_blank"><code class="codeph">Configuration</code></a>确定一种或多种认证技术，或<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/spi/LoginModule.html" target="_blank"><code class="codeph">LoginModule</code></a> （s），用于执行身份验证。典型<code class="codeph">LoginModule</code>可能会提示您输入并验证用户名和密码。其他人可能会读取并验证语音或指纹样本。
               </p>
               <p>一旦对执行代码的用户或服务进行了身份验证，JAAS授权组件就会与核心Java SE访问控制模型结合使用，以保护对敏感资源的访问。访问控制决策均基于执行代码的<code class="codeph">CodeSource</code> <span class="variable" translate="no">and</span>对用户或服务运行的代码，谁是一个代表<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/Subject.html" target="_blank"><code class="codeph">Subject</code></a>宾语。的<code class="codeph">Subject</code>由更新<code class="codeph">LoginModule</code>与相关<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Principal.html" target="_blank"><code class="codeph">Principal</code> s</a>和凭据（如果身份验证成功）。
               </p>
            </div>
            <div class="sect2"><a id="GUID-31AC2288-E4E8-42D9-821E-85385F1F2FE8" name="GUID-31AC2288-E4E8-42D9-821E-85385F1F2FE8"></a><h3 id="JSSEC-GUID-31AC2288-E4E8-42D9-821E-85385F1F2FE8" class="sect3">谁应该阅读本文件</h3>
               <div>
                  <p>本文档适用于有经验的开发人员，他们需要能够设计受约束的应用程序。 <code class="codeph">CodeSource</code>基于和<code class="codeph">Subject</code>基于安全的模型。在阅读<a href="java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-CB46C30D-FFF1-466F-B2F5-6DE0BD5DA43A">Java身份验证和授权服务（JAAS）：LoginModule开发人员指南</a>之前， <span class="apiname">LoginModule</span>开发人员（实施身份验证技术的开发人员）还应阅读本<a href="java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-CB46C30D-FFF1-466F-B2F5-6DE0BD5DA43A">指南</a> 。
                  </p>
                  <p>您可能希望先阅读《 <a href="jaas-authentication-tutorial.html#GUID-BFEBDB00-9826-499C-A20F-E9463883DED4">JAAS认证教程》</a>和《 <a href="jaas-authorization-tutorial.html#GUID-D43CF965-8A5F-4A23-A2AF-F41DD5F8B411">JAAS授权教程》，</a>以获得有关如何使用JAAS的概述以及如何查看实际的示例代码，然后返回本文档以获取更多信息。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-11885DA7-0D17-4756-B193-3CC9376B1225" name="GUID-11885DA7-0D17-4756-B193-3CC9376B1225"></a><h3 id="JSSEC-GUID-11885DA7-0D17-4756-B193-3CC9376B1225" class="sect3">相关文件</h3>
               <div>
                  <p>本文档假定您已经阅读以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="java-se-platform-security-architecture.html#GUID-D6C53B30-01F9-49F1-9F61-35815558422B" title="本节说明什么是特权代码及其用途。它还说明了如何使用doPrivileged API。本节介绍了doPrivileged API以及特权功能的使用。如果您使用的是lambda表达式或匿名内部类，则您访问的任何局部变量都必须是final或有效的final。如果在run方法中执行的操作可能引发已检查的异常（必须在方法的throws子句中列出的异常），则需要使用PrivilegedExceptionAction接口而不是PrivilegedAction接口。doPrivileged方法的典型用例是使调用它的方法能够执行一个或多个需要权限检查的动作，而无需当前方法的调用者具有所有必要的权限。在对当前方法进行编码时，您希望临时扩展调用方法的权限以执行操作。将代码标记为特权可使一段受信任的代码临时允许访问比直接调用它的代码更多的资源。可以使用java.lang.reflect反射地调用doPrivileged方法。Method.invoke方法。">Java SE平台安全性架构</a></li>
                     <li><a href="https://docs.oracle.com/javase/tutorial/security/index.html" target="_blank">Java SE安全教程</a></li>
                  </ul>
                  <p>本指南的补充内容是《 <a href="java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-CB46C30D-FFF1-466F-B2F5-6DE0BD5DA43A">JAAS LoginModule开发人员指南》</a> ，适用于需要编写代码的经验丰富的程序员。 <a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/spi/LoginModule.html" target="_blank"><code class="codeph">LoginModule</code></a>实施身份验证技术。
                  </p>
                  <p>每个人都可以运行以下有关JAAS身份验证和授权的<span class="bold">教程</span> ：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="jaas-authentication-tutorial.html#GUID-BFEBDB00-9826-499C-A20F-E9463883DED4">JAAS认证教程</a></li>
                     <li><a href="jaas-authorization-tutorial.html#GUID-D43CF965-8A5F-4A23-A2AF-F41DD5F8B411">JAAS授权教程</a></li>
                  </ul>
                  <p>可以在以下位置找到用于JAAS身份验证和授权的类似教程，但它们演示了Kerberos LoginModule的使用，因此需要安装Kerberos。</p>
                  <ul style="list-style-type:disc">
                     <li><a href="jaas-authentication.html#GUID-0C6EB04B-D203-4688-A3E2-A7D442334623">JAAS认证</a></li>
                     <li><a href="jaas-authorization.html#GUID-69241059-CCD0-49F6-838F-DDC752F9F19F">JAAS授权</a></li>
                  </ul>
                  <p>这两个教程是“ <a href="introduction-jaas-and-java-gss-api-tutorials1.html">JAAS简介”和Java GSS-API教程</a>的一部分，这些教程利用Kerberos作为身份验证和安全通信的基础技术。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-D679A98F-C706-4FE2-9027-39A520BA0FCB" name="GUID-D679A98F-C706-4FE2-9027-39A520BA0FCB"></a><h3 id="JSSEC-GUID-D679A98F-C706-4FE2-9027-39A520BA0FCB" class="sect3">核心类和接口</h3>
               <div>
                  <p>与JAAS相关的核心类和接口可以分为三类：通用，认证和授权。</p>
               </div>
               <div class="sect3"><a id="GUID-2CDC988F-D462-4CEA-9243-CC74B000327F" name="GUID-2CDC988F-D462-4CEA-9243-CC74B000327F"></a><h4 id="JSSEC-GUID-2CDC988F-D462-4CEA-9243-CC74B000327F" class="sect4">普通班</h4>
                  <div>
                     <p>通用类是JAAS认证和授权组件共享的类。</p>
                     <p>JAAS的关键课程是<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/Subject.html" target="_blank"><code class="codeph">javax.security.auth.Subject</code></a> ，代表单个实体（例如人）的相关信息的分组。它包含实体的<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0">Principals</a> ，公共凭据和私有凭据。
                     </p>
                     <p>请注意<code class="codeph">java.security.Principal</code>接口用于表示主体。还请注意，由JAAS定义的凭据可以是任何对象。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3" name="GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3"></a><h5 id="JSSEC-GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3" class="sect5">学科</h5>
                     <div>
                        <p>为了授权对资源的访问，应用程序首先需要对请求的源进行身份验证。 JAAS框架定义了<span class="italic">主题主题</span>来表示请求的来源。主题可以是任何实体，例如人或服务。主题通过身份验证后， <a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/Subject.html" target="_blank"><code class="codeph">javax.security.auth.Subject</code></a>填充有相关的标识或<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0">Principals</a> 。一种<code class="codeph">Subject</code>可能有很多<code class="codeph">Principal</code> s。例如，一个人可能有一个名字<code class="codeph">Principal</code> （“ John Doe”）和SSN <code class="codeph">Principal</code> （“ 123-45-6789”），将其与其他主题区分开来。
                        </p>
                        <p>一种<code class="codeph">Subject</code>也可能拥有与安全相关的属性，这些属性称为<span class="variable" translate="no">credentials</span> ；请参阅“ <a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-9381520E-7A13-4087-BA26-C6CB8BE4A437">凭证</a> ”部分。需要特殊保护的敏感凭据（例如私钥）存储在私钥中<code class="codeph">Set</code> 。打算共享的凭证（例如，公共密钥证书）存储在公共凭证中<code class="codeph">Set</code> 。访问和修改不同的凭据需要不同的权限（如下所述） <code class="codeph">Set</code> s。
                        </p>
                        <p>使用以下构造函数创建主题：</p><pre class="pre codeblock"><code>    public Subject();

    public Subject(boolean readOnly, Set principals,
                   Set pubCredentials, Set privCredentials);
</code></pre><p>第一个构造函数创建一个<code class="codeph">Subject</code>带空（非空） <code class="codeph">Set</code>的<code class="codeph">Principal</code>和凭证。第二个构造函数创建一个<code class="codeph">Subject</code>与指定<code class="codeph">Set</code>的<code class="codeph">Principal</code>和凭证。它还有一个布尔参数，可用于使<code class="codeph">Subject</code>只读。在只读<code class="codeph">Subject</code> ， <code class="codeph">Principal</code>和凭证<code class="codeph">Set</code> s是不可变的。
                        </p>
                        <p>应用程序编写者不必实例化一个<code class="codeph">Subject</code> 。如果应用程序实例化一个<code class="codeph">LoginContext</code>并且没有通过<code class="codeph">Subject</code>到<code class="codeph">LoginContext</code>构造函数<code class="codeph">LoginContext</code>实例化一个新的空<code class="codeph">Subject</code> 。请参阅<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A">LoginContext</a>部分。
                        </p>
                        <p>如果一个<code class="codeph">Subject</code>未实例化为只读状态，可以通过调用以下方法将其设置为只读：</p><pre class="pre codeblock"><code>    public void setReadOnly();
</code></pre><p>一种<code class="codeph">javax.security.auth.AuthPermission</code>必须使用目标为“ setReadOnly”的对象才能调用此方法。一旦处于只读状态，任何添加或删除的尝试<code class="codeph">Principal</code>或凭据将导致<code class="codeph">IllegalStateException</code>被抛出。可以调用以下方法来测试<code class="codeph">Subject</code>的只读状态：</p><pre class="pre codeblock"><code>    public boolean isReadOnly();
</code></pre><p>要检索<code class="codeph">Principal</code>与主题关联的方法有两种：</p><pre class="pre codeblock"><code>    public Set getPrincipals();
    public Set getPrincipals(Class c);
</code></pre><p>第一种方法返回全部<code class="codeph">Principal</code>包含在<code class="codeph">Subject</code> ，而第二种方法仅返回那些<code class="codeph">Principal</code>是指定Class的实例的<code class="codeph">c</code> ，或Class子类的实例<code class="codeph">c</code> 。如果<code class="codeph">Subject</code>没有任何关联<code class="codeph">Principal</code> s。
                        </p>
                        <p>检索与证书关联的公共证书<code class="codeph">Subject</code> ，这些方法可用：</p><pre class="pre codeblock"><code>    public Set getPublicCredentials();
    public Set getPublicCredentials(Class c);
</code></pre><p>这些方法的行为与<code class="codeph">getPrincipals</code>方法，但在这种情况下，将获取公共证书。
                        </p>
                        <p>访问与证书关联的私人证书<code class="codeph">Subject</code> ，可以使用以下方法：</p><pre class="pre codeblock"><code>    public Set getPrivateCredentials();
    public Set getPrivateCredentials(Class c);
</code></pre><p>这些方法的行为与<code class="codeph">getPrincipals</code>和<code class="codeph">getPublicCredentials</code>方法。
                        </p>
                        <p>修改或操作<code class="codeph">Subject</code>的<code class="codeph">Principal</code><code class="codeph">Set</code> ，公共证书<code class="codeph">Set</code> ，或私人证书<code class="codeph">Set</code> ，呼叫者会使用<a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html" target="_blank"><code class="codeph">java.util.Set</code></a>类。下面的示例演示了这一点：</p><pre class="pre codeblock"><code>    Subject subject;
    Principal principal;
    Object credential;

    . . .

    // add a Principal and credential to the Subject
    subject.getPrincipals().add(principal);
    subject.getPublicCredentials().add(credential);
</code></pre><p>注意： <code class="codeph">AuthPermission</code>必须使用目标为“ modifyPrincipals”，“ modifyPublicCredentials”或“ modifyPrivateCredentials”的对象来修改各自<code class="codeph">Set</code> s。另请注意，只有通过<code class="codeph">getPrincipals()</code> ， <code class="codeph">getPublicCredentials()</code>和<code class="codeph">getPrivateCredentials()</code>没有参数的方法由<code class="codeph">Subject</code>的各自内部集合。因此，对返回的集合的任何修改也会影响内部集合。集合通过<code class="codeph">getPrincipals(Class c)</code> ， <code class="codeph">getPublicCredentials(Class c)</code>和<code class="codeph">getPrivateCredentials(Class c)</code>方法不受支持<code class="codeph">Subject</code>的各自内部集合。将为每个这样的方法调用创建并返回一个新集。对这些设置的修改不会影响<code class="codeph">Subject</code>的内部集。
                        </p>
                        <p>为了遍历一组私有凭证，您需要一个<code class="codeph">javax.security.auth.PrivateCredentialPermission</code>访问每个凭证。见<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/PrivateCredentialPermission.html" target="_blank"><code class="codeph">PrivateCredentialPermission</code></a> API文档以获取更多信息。
                        </p>
                        <p>一种<code class="codeph">Subject</code>可能与<code class="codeph">AccessControlContext</code> （请参阅<code class="codeph">doAs</code>和<code class="codeph">doAsPrivileged</code>下面的方法说明）。以下方法返回<code class="codeph">Subject</code>与指定的关联<code class="codeph">AccessControlContext</code> ， 要么<code class="codeph">null</code>如果不<code class="codeph">Subject</code>与指定的关联<code class="codeph">AccessControlContext</code> 。
                        </p><pre class="pre codeblock"><code>    public static Subject getSubject(final AccessControlContext acc);
</code></pre><p>一个<code class="codeph">AuthPermission</code>必须调用目标为“ getSubject”的对象<code class="codeph">Subject.getSubject</code> 。
                        </p>
                        <p>的<code class="codeph">Subject</code>该类还包括以下继承自以下方法的方法<code class="codeph">java.lang.Object</code> 。
                        </p><pre class="pre codeblock"><code>    public boolean equals(Object o);
    public String toString();
    public int hashCode();
</code></pre></div>
                     <div class="sect5"><a id="GUID-FA47090A-D270-4E4E-A5F6-752E1A48DC4C" name="GUID-FA47090A-D270-4E4E-A5F6-752E1A48DC4C"></a><h6 id="JSSEC-GUID-FA47090A-D270-4E4E-A5F6-752E1A48DC4C" class="sect6">作为特定主题执行动作的doAs方法</h6>
                        <div>
                           <p>可以调用以下静态方法来执行特定操作<code class="codeph">Subject</code> ：</p><pre class="pre codeblock"><code>    public static Object
        doAs(final Subject subject,
             final java.security.PrivilegedAction action);

    public static Object
        doAs(final Subject subject,
             final java.security.PrivilegedExceptionAction action)
             throws java.security.PrivilegedActionException;
</code></pre><p>两种方法都首先关联指定的<code class="codeph">subject</code>与当前线程的<code class="codeph">AccessControlContext</code> ，然后执行<code class="codeph">action</code> 。这样可以达到使<code class="codeph">action</code>作为运行<code class="codeph">subject</code> 。第一种方法可以抛出运行时异常，但是正常执行时会从的方法返回一个对象。 <code class="codeph">run</code>其方法<code class="codeph">action</code>论点。第二种方法的行为类似，只是它可以从其方法中抛出一个检查异常。 <code class="codeph">PrivilegedExceptionAction run</code>方法。一个<code class="codeph">AuthPermission</code>目标为“ doAs”的用户需要调用<code class="codeph">doAs</code>方法。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-3BF4EEC2-3953-4331-955B-C34EF2514F36" name="GUID-3BF4EEC2-3953-4331-955B-C34EF2514F36"></a><h6 id="JSSEC-GUID-3BF4EEC2-3953-4331-955B-C34EF2514F36" class="sect6">Subject.doAs示例</h6>
                        <div>
                           <p>这是利用第一个例子<code class="codeph">doAs</code>方法。假设某人名为“鲍勃”已通过身份验证<code class="codeph">LoginContext</code> （请参阅<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A">LoginContext</a> ），结果是<code class="codeph">Subject</code>充满了<code class="codeph">Principal</code>上课<code class="codeph">com.ibm.security.Principal</code> ， 然后<code class="codeph">Principal</code>名称为“ BOB”。还要假设已经安装了<span class="apiname">SecurityManager</span> ，并且访问控制策略中存在以下内容（有关策略文件的更多详细信息，请参阅<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-66990EE6-1213-4BF7-AC43-A4C75AE6746D">策略</a> ）。
                           </p><pre class="pre codeblock"><code>    // grant "BOB" permission to read the file "foo.txt"
    grant Principal com.ibm.security.Principal "BOB" {
        permission java.io.FilePermission "foo.txt", "read";
    };
</code></pre><p>这是示例应用程序代码：</p><pre class="pre codeblock"><code>    class ExampleAction implements java.security.PrivilegedAction {
        public Object run() {
            java.io.File f = new java.io.File("foo.txt");

            // the following call invokes a security check
            if (f.exists()) {
                System.out.println("File foo.txt exists");
            }
            return null;
        }
    }

    public class Example1 {
        public static void main(String[] args) {

            // Authenticate the subject, "BOB".
            // This process is described in the
            // <a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A">LoginContext</a> class.

            Subject bob;
            // Set bob to the Subject created during the
            // authentication process

            // perform "ExampleAction" as "BOB"
            Subject.doAs(bob, new ExampleAction());
        }
    }
</code></pre><p>执行期间， <code class="codeph">ExampleAction</code>拨打电话时会遇到安全检查<code class="codeph">f.exists()</code> 。但是，由于<code class="codeph">ExampleAction</code>作为“ BOB”运行，并且该策略（上述）授予了必要的权限<code class="codeph">FilePermission</code>到“ BOB”， <code class="codeph">ExampleAction</code>将通过安全检查。如果<code class="codeph">grant</code>策略中的声明已更改（添加了不正确的<code class="codeph">CodeBase</code>或更改<code class="codeph">Principal</code>以“ MOE”为例），然后<code class="codeph">SecurityException</code>将被抛出。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-7CBADEEE-D62F-4AA7-BD75-78F79C72067A" name="GUID-7CBADEEE-D62F-4AA7-BD75-78F79C72067A"></a><h6 id="JSSEC-GUID-7CBADEEE-D62F-4AA7-BD75-78F79C72067A" class="sect6">doAsPrivileged方法</h6>
                        <div>
                           <p>以下方法还可以执行特定的操作<code class="codeph">Subject</code> 。
                           </p><pre class="pre codeblock"><code>    public static Object doAsPrivileged(
        final Subject subject,
        final java.security.PrivilegedAction action,
        final java.security.AccessControlContext acc);

    public static Object doAsPrivileged(
        final Subject subject,
        final java.security.PrivilegedExceptionAction action,
        final java.security.AccessControlContext acc)
        throws java.security.PrivilegedActionException;
</code></pre><p>一个<code class="codeph">AuthPermission</code>目标为“ doAsPrivileged”的对象需要调用<code class="codeph">doAsPrivileged</code>方法。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-97198A0C-B488-4D24-A242-CAFA8F70DFA5" name="GUID-97198A0C-B488-4D24-A242-CAFA8F70DFA5"></a><h6 id="JSSEC-GUID-97198A0C-B488-4D24-A242-CAFA8F70DFA5" class="sect6">doAs与doAsPrivileged</h6>
                        <div>
                           <p>的<code class="codeph">doAsPrivileged</code>方法的行为与<code class="codeph">doAs</code>方法，除了代替关联提供的<code class="codeph">Subject</code>与当前线程的<code class="codeph">AccessControlContext</code> ，他们使用提供的<code class="codeph">AccessControlContext</code> 。这样，可以通过以下方式限制操作<code class="codeph">AccessControlContext</code>与当前版本不同。
                           </p>
                           <p>一个<code class="codeph">AccessControlContext</code>包含有关自<code class="codeph">AccessControlContext</code>被实例化，包括代码位置和策略授予的代码权限。为了使访问控制检查成功，该策略必须授予访问权限引用的每个代码项。 <code class="codeph">AccessControlContext</code>所需的权限。
                           </p>
                           <p>如果<code class="codeph">AccessControlContext</code>提供给<code class="codeph">doAsPrivileged</code>是<code class="codeph">null</code> ，则该动作不受单独的限制<code class="codeph">AccessControlContext</code> 。一个可能有用的示例是在服务器环境中。服务器可以验证多个传入请求并执行单独的操作<code class="codeph">doAs</code>每个请求的操作。开始每个<code class="codeph">doAs</code>操作“新鲜”，并且不受当前服务器的限制<code class="codeph">AccessControlContext</code> ，服务器可以调用<code class="codeph">doAsPrivileged</code>并传递一个<code class="codeph">null</code><code class="codeph">AccessControlContext</code> 。
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0" name="GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0"></a><h5 id="JSSEC-GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0" class="sect5">校长</h5>
                     <div>
                        <p>如前所述，一旦对<span class="apiname">Subject</span>进行身份验证，便会在其中填充关联的身份或<span class="apiname">Principal</span> 。一个<span class="apiname">科目</span>可能有许多<span class="apiname">校长</span> 。例如，一个人可能有一个名字<span class="apiname">Principal</span> （“ John Doe”）和一个SSN <span class="apiname">Principal</span> （“ 123-45-6789”），这与其他<span class="apiname">Subject</span>有所区别。<span class="apiname">委托人</span>必须实现<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Principal.html" target="_blank"><span class="apiname">java.security。主体</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html" target="_blank"><span class="apiname">java.io。可序列化的</span></a>接口。请参阅<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">主题</a>有关的方式来更新与<span class="apiname">主题</span>相关的<span class="apiname">的Principal</span>信息。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9381520E-7A13-4087-BA26-C6CB8BE4A437" name="GUID-9381520E-7A13-4087-BA26-C6CB8BE4A437"></a><h5 id="JSSEC-GUID-9381520E-7A13-4087-BA26-C6CB8BE4A437" class="sect5">证书</h5>
                     <div>
                        <p>除了关联的主体外，主题还可以拥有与安全性相关的属性，这些属性称为凭据。凭证可能包含用于对主体进行新服务身份验证的信息。此类凭据包括密码，Kerberos票证和公共密钥证书。凭证可能还包含仅使主体能够执行某些活动的数据。例如，加密密钥代表使主体能够签名或加密数据的凭据。公共和私有凭证类不是核心JAAS类库的一部分。因此，任何类别都可以代表一个凭证。</p>
                        <p>公共和私有凭证类不是核心JAAS类库的一部分。但是，开发人员可以选择让其凭证类实现与凭证相关的两个接口： <code class="codeph">Refreshable</code>和<code class="codeph">Destroyable</code> 。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-9FA5AFF7-92A9-4F26-9266-71B8871C3A86" name="GUID-9FA5AFF7-92A9-4F26-9266-71B8871C3A86"></a><h6 id="JSSEC-GUID-9FA5AFF7-92A9-4F26-9266-71B8871C3A86" class="sect6">可刷新</h6>
                        <div>
                           <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/Refreshable.html" target="_blank"><code class="codeph">javax.security.auth.Refreshable</code></a> <span class="bold">接口</span>提供了凭证刷新自身的功能。例如，具有特定时间限制寿命的凭证可以实现此接口，以允许呼叫者刷新其有效的时间段。该接口有两种抽象方法：</p><pre class="pre codeblock"><code>    boolean isCurrent();
</code></pre><p>此方法确定凭证是当前凭证还是有效凭证。</p><pre class="pre codeblock"><code>    void refresh() throws RefreshFailedException;
</code></pre><p>此方法更新或扩展了凭证的有效性。方法实现应执行</p>
                           <p><code class="codeph">AuthPermission("refreshCredential")</code></p>
                           <p>安全检查，以确保呼叫者有权刷新证书。</p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-B5587785-F349-46FA-8D8C-AB7EA09AC98C" name="GUID-B5587785-F349-46FA-8D8C-AB7EA09AC98C"></a><h6 id="JSSEC-GUID-B5587785-F349-46FA-8D8C-AB7EA09AC98C" class="sect6">可破坏的</h6>
                        <div>
                           <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/Destroyable.html" target="_blank"><code class="codeph">javax.security.auth.Destroyable</code></a> <span class="bold">接口</span>提供了销毁凭证中内容的功能。该接口有两种抽象方法：</p><pre class="pre codeblock"><code>    boolean isDestroyed();
</code></pre><p>确定凭证是否已被销毁。</p><pre class="pre codeblock"><code>    void destroy() throws DestroyFailedException;
</code></pre><p>销毁并清除与此凭证关联的信息。随后调用此凭证上的某些方法将导致<code class="codeph">IllegalStateException</code>被抛出。方法实现应执行<code class="codeph">AuthPermission("destroyCredential")</code>安全检查，以确保呼叫者有权销毁凭据。
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6A19B0FB-39F9-4917-A3B1-72E4387BA021" name="GUID-6A19B0FB-39F9-4917-A3B1-72E4387BA021"></a><h4 id="JSSEC-GUID-6A19B0FB-39F9-4917-A3B1-72E4387BA021" class="sect4">身份验证类和接口</h4>
                  <div>
                     <p>认证表示验证主体身份的过程，必须以安全的方式执行；否则，作恶者可能会冒充他人来访问系统。身份验证通常涉及对象展示某种形式的证据以证明其身份。这样的证据可能只是受试者可能会知道或拥有的信息（例如密码或指纹），也可能只是受试者可能产生的信息（例如使用私钥签名的数据）。</p>
                     <p>要验证主题（用户或服务），请执行以下步骤：</p>
                     <ol>
                        <li>应用程序实例化一个<code class="codeph">LoginContext</code> 。
                        </li>
                        <li>的<code class="codeph">LoginContext</code>咨询一个<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/login/Configuration.html" target="_blank"><code class="codeph">Configuration</code></a>加载所有<code class="codeph">LoginModule</code>为该应用程序配置。
                        </li>
                        <li>该应用程序调用<code class="codeph">LoginContext</code>的<code class="codeph">login</code>方法。
                        </li>
                        <li>的<code class="codeph">login</code>方法调用所有已加载的<code class="codeph">LoginModule</code> s。每<code class="codeph">LoginModule</code>尝试验证主题。成功之后<code class="codeph">LoginModule</code>关联的<code class="codeph">Principal</code>和带有<code class="codeph">Subject</code>代表正在验证的主题的对象。
                        </li>
                        <li>的<code class="codeph">LoginContext</code>将身份验证状态返回给应用程序。
                        </li>
                        <li>如果身份验证成功，则应用程序检索<code class="codeph">Subject</code>来自<code class="codeph">LoginContext</code> 。
                        </li>
                     </ol>
                     <p>认证类别如下所述。</p>
                  </div>
                  <div class="sect4"><a id="GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A" name="GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A"></a><h5 id="JSSEC-GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A" class="sect5">LoginContext</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/login/LoginContext.html" target="_blank"><code class="codeph">javax.security.auth.login.LoginContext</code></a>类提供了用于认证主题的基本方法，并提供了一种独立于基础认证技术开发应用程序的方式。的<code class="codeph">LoginContext</code>咨询一个<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/login/Configuration.html" target="_blank"><code class="codeph">Configuration</code></a>确定身份验证服务，或<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/spi/LoginModule.html" target="_blank"><code class="codeph">LoginModule</code> （s）</a> ，为特定的应用程序配置。因此，不同<code class="codeph">LoginModule</code>可以在应用程序下插入，而无需对应用程序本身进行任何修改。
                        </p>
                        <p><code class="codeph">LoginContext</code>提供了四个构造函数供您选择：</p><pre class="pre codeblock"><code>    public LoginContext(String name) throws LoginException;

    public LoginContext(String name, Subject subject) throws LoginException;

    public LoginContext(String name, CallbackHandler callbackHandler)
           throws LoginException

    public LoginContext(String name, Subject subject,
           CallbackHandler callbackHandler) throws LoginException
</code></pre><p>所有构造函数都共享一个公共参数：name。此参数由<code class="codeph">LoginContext</code>作为登录的索引<code class="codeph">Configuration</code>确定哪个<code class="codeph">LoginModule</code>为应用程序实例化配置了<code class="codeph">LoginContext</code> 。不将Subject作为输入参数的构造函数实例化一个新的<code class="codeph">Subject</code> 。所有构造函数均不允许输入空值。来电者需要<code class="codeph">AuthPermission</code>目标为“ createLoginContext”。 <span class="variable" translate="no"><name></name></span> “实例化一个<code class="codeph">LoginContext</code> 。这里， <span class="variable" translate="no"><name></name></span>引用应用程序在name参数中引用的登录配置条目的名称<code class="codeph">LoginContext</code>实例化。
                        </p>
                        <p>有关什么内容的信息，请参见<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-1018AB86-8912-4C00-8717-2FA2B54A4866">CallbackHandler</a> 。 <code class="codeph">CallbackHandler</code>是，何时您可能需要一个。
                        </p>
                        <p>实际身份验证通过调用以下方法进行：</p><pre class="pre codeblock"><code>
    public void login() throws LoginException;
</code></pre><p>什么时候<code class="codeph">login</code>被调用，所有已配置<code class="codeph">LoginModule</code>调用进行身份验证。如果认证成功，则<code class="codeph">Subject</code> （现在可能会保留<code class="codeph">Principal</code> ，公共凭据和私有凭据）可以使用以下方法检索：</p><pre class="pre codeblock"><code>     public Subject getSubject();
</code></pre><p>登出<code class="codeph">Subject</code>并删除其经过身份验证的<code class="codeph">Principals</code>和凭据，提供了以下方法：</p><pre class="pre codeblock"><code>    public void logout() throws LoginException;
</code></pre><p>下面的代码示例演示了验证和注销主题所必需的调用：</p><pre class="pre codeblock"><code>    // let the LoginContext instantiate a new Subject
    LoginContext lc = new LoginContext("entryFoo");
    try {
        // authenticate the Subject
        lc.login();
        System.out.println("authentication successful");

        // get the authenticated Subject
        Subject subject = lc.getSubject();

        ...

        // all finished -- logout
        lc.logout();
    } catch (LoginException le) {
        System.err.println("authentication unsuccessful: " +
            le.getMessage());
    }
</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-0FDBE77C-01C3-4A98-9925-4F8D2E260118" name="GUID-0FDBE77C-01C3-4A98-9925-4F8D2E260118"></a><h5 id="JSSEC-GUID-0FDBE77C-01C3-4A98-9925-4F8D2E260118" class="sect5">登录模块</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/spi/LoginModule.html" target="_blank"><code class="codeph">LoginModule</code></a> <span class="bold">接口</span>使开发人员能够实施可以插入到应用程序下的各种身份验证技术。例如，一种<code class="codeph">LoginModule</code>可以执行基于用户名/密码的身份验证形式。其他<code class="codeph">LoginModule</code>可以与诸如智能卡或生物识别设备之类的硬件设备接口。
                        </p>
                        <p>注意：如果您是应用程序编写者，则无需了解以下方面的工作原理<code class="codeph">LoginModule</code> s。您所需要知道的就是如何编写应用程序并指定配置信息（例如在登录配置文件中），以便应用程序能够利用配置指定的LoginModule来对用户进行身份验证。
                        </p>
                        <p>另一方面，如果您是希望编写实现身份验证技术的LoginModule的程序员，请参阅<a href="java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-CB46C30D-FFF1-466F-B2F5-6DE0BD5DA43A">Java身份验证和授权服务（JAAS）：LoginModule开发人员指南，</a>以获取详细的分步说明。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1018AB86-8912-4C00-8717-2FA2B54A4866" name="GUID-1018AB86-8912-4C00-8717-2FA2B54A4866"></a><h5 id="JSSEC-GUID-1018AB86-8912-4C00-8717-2FA2B54A4866" class="sect5">回调处理程序</h5>
                     <div>
                        <p>在某些情况下<code class="codeph">LoginModule</code>必须与用户通信以获得身份验证信息。 <code class="codeph">LoginModule</code>使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/callback/CallbackHandler.html" target="_blank"><span class="apiname">javax.security.auth.callback。为此使用CallbackHandler</span></a> 。应用程序实现<code class="codeph">CallbackHandler</code> <span class="bold">接口</span>并将其传递给<code class="codeph">LoginContext</code> ，将其直接转发到基础<code class="codeph">LoginModule</code> s。一种<code class="codeph">LoginModule</code>使用<code class="codeph">CallbackHandler</code>既可以收集用户的输入（例如密码或智能卡密码），也可以向用户提供信息（例如状态信息）。通过允许应用程序指定<code class="codeph">CallbackHandler</code> ，底层<code class="codeph">LoginModules</code>可以独立于应用程序与用户交互的不同方式。例如，执行<code class="codeph">CallbackHandler</code>因为GUI应用程序可能会显示一个窗口来征求用户的输入。另一方面，执行一个<code class="codeph">CallbackHandler</code>对于非GUI工具，可能只是提示用户直接从命令行输入。
                        </p>
                        <p><code class="codeph">CallbackHandler</code></p>
                        <p>是具有一种实现方法的接口：</p><pre class="pre codeblock"><code>     void handle(Callback[] callbacks)
         throws java.io.IOException, UnsupportedCallbackException;
</code></pre><p>的<code class="codeph">LoginModule</code>通过<code class="codeph">CallbackHandler handle</code>方法适当的数组<code class="codeph">Callback</code> s，例如，用于用户名的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/callback/NameCallback.html" target="_blank"><span class="apiname">NameCallback</span></a>和用于<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/callback/PasswordCallback.html" target="_blank"><span class="apiname">密码</span></a>的PasswordCallback，以及<code class="codeph">CallbackHandler</code>执行请求的用户交互，并在<code class="codeph">Callback</code> s。例如，要处理一个<code class="codeph">NameCallback</code> ， <code class="codeph">CallbackHandler</code>可能会提示您输入名称，从用户那里检索值，然后调用<code class="codeph">NameCallback</code>的<code class="codeph">setName</code>存储名称的方法。
                        </p>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/callback/CallbackHandler.html" target="_blank"><code class="codeph">CallbackHandler</code></a>文档中有一个冗长的示例，读者可能不希望查看该文档中未包含的示例。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-A6E64966-EDDC-4519-9E42-1114E5E3DEFC" name="GUID-A6E64966-EDDC-4519-9E42-1114E5E3DEFC"></a><h5 id="JSSEC-GUID-A6E64966-EDDC-4519-9E42-1114E5E3DEFC" class="sect5">打回来</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/callback/package-summary.html" target="_blank"><code class="codeph">javax.security.auth.callback</code></a>程序包包含Callback <span class="bold">接口</span>以及几种实现。的LoginModules可以直接传递回调的阵列到的手柄方法<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-1018AB86-8912-4C00-8717-2FA2B54A4866">的CallbackHandler</a> 。
                        </p>
                        <p>请查阅各种回调API，以获取有关其用法的更多信息。</p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B8891FFA-ACD2-4E42-9488-0551B28F31C8" name="GUID-B8891FFA-ACD2-4E42-9488-0551B28F31C8"></a><h4 id="JSSEC-GUID-B8891FFA-ACD2-4E42-9488-0551B28F31C8" class="sect4">授权等级</h4>
                  <div>
                     <p>要进行JAAS授权，不仅要根据正在运行的代码而且还要根据运行的代码来授予访问控制权限，需要执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>用户必须经过身份验证，如<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-164692CF-6790-488C-BF86-39F7C5CF0F5A">LoginContext</a>部分中所述。
                        </li>
                        <li>如<a href="java-authentication-and-authorization-service-jaas-reference-guide.html#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">主题</a>部分所述，作为身份验证结果的主题必须与访问控制上下文关联。
                        </li>
                        <li>如下所述，必须在安全策略中配置基于主体的条目。</li>
                     </ul>
                     <p>的<code class="codeph">Policy</code>抽象类和特定于授权的类<code class="codeph">AuthPermission</code>和<code class="codeph">PrivateCredentialPermission</code>如下所述。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-66990EE6-1213-4BF7-AC43-A4C75AE6746D" name="GUID-66990EE6-1213-4BF7-AC43-A4C75AE6746D"></a><h5 id="JSSEC-GUID-66990EE6-1213-4BF7-AC43-A4C75AE6746D" class="sect5">政策</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Policy.html" target="_blank"><code class="codeph">java.security.Policy</code></a> class是一个<span class="bold">抽象</span>类，用于表示系统范围的访问控制策略。的<code class="codeph">Policy</code> API支持<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Principal.html" target="_blank"><code class="codeph">Principal</code></a>基于的查询。
                        </p>
                        <p>默认情况下，JDK提供了基于文件的子类实现，该实现已升级为支持<code class="codeph">Principal</code>基于<code class="codeph">grant</code>策略文件中的条目。
                        </p>
                        <p>策略文件及其中条目的结构在“ <a href="permissions-jdk1.html#GUID-789089CA-8557-4017-B8B0-6899AD3BA18D">默认策略实现”和“策略文件语法”中</a>进行了描述。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B7D676A5-E9E6-4FDA-B0F3-8A51B3747138" name="GUID-B7D676A5-E9E6-4FDA-B0F3-8A51B3747138"></a><h5 id="JSSEC-GUID-B7D676A5-E9E6-4FDA-B0F3-8A51B3747138" class="sect5">AuthPermission</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/AuthPermission.html" target="_blank"><code class="codeph">javax.security.auth.AuthPermission</code></a>类封装了JAAS所需的基本权限。一个<code class="codeph">AuthPermission</code>包含名称（也称为“目标名称”），但没有操作列表；您要么具有命名权限，要么没有。
                        </p>
                        <p>除了其继承的方法（来自<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Permission.html" target="_blank"><code class="codeph">java.security.Permission</code></a>类）， <code class="codeph">AuthPermission</code>有两个公共构造函数：</p><pre class="pre codeblock"><code>    public AuthPermission(String name);
    public AuthPermission(String name, String actions);
</code></pre><p>第一个构造函数创建一个新的<code class="codeph">AuthPermission</code>具有指定名称。第二个构造函数还创建了一个新的<code class="codeph">AuthPermission</code>具有指定名称的对象，但具有一个额外的action参数，该参数当前未使用，应为null。此构造函数仅存在于<code class="codeph">Policy</code>实例化新对象<code class="codeph">Permission</code>对象。对于大多数其他代码，第一个构造函数是合适的。
                        </p>
                        <p>目前<code class="codeph">AuthPermission</code>对象用于保护对<code class="codeph">Policy</code> ， <code class="codeph">Subject</code> ， <code class="codeph">LoginContext</code>和<code class="codeph">Configuration</code>对象。请参阅<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/AuthPermission.html" target="_blank"><code class="codeph">AuthPermission</code></a> Javadoc API文档，其中包含受支持的有效名称的列表。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D7D015EE-54C6-4D85-83C2-05742314847D" name="GUID-D7D015EE-54C6-4D85-83C2-05742314847D"></a><h5 id="JSSEC-GUID-D7D015EE-54C6-4D85-83C2-05742314847D" class="sect5">PrivateCredentialPermission</h5>
                     <div>
                        <p>的<a href="https://docs.oracle.com/javase/10/docs/api/javax/security/auth/PrivateCredentialPermission.html" target="_blank"><code class="codeph">javax.security.auth.PrivateCredentialPermission</code></a>类保护对<code class="codeph">Subject</code>的私有凭据，并提供一个公共构造函数：</p><pre class="pre codeblock"><code>     public PrivateCredentialPermission(String name, String actions);
</code></pre></div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-7B9C6511-A221-414A-8A4B-6BCF08172065" name="GUID-7B9C6511-A221-414A-8A4B-6BCF08172065"></a><h3 id="JSSEC-GUID-7B9C6511-A221-414A-8A4B-6BCF08172065" class="sect3">JAAS教程和示例程序</h3>
               <div>
                  <p><a href="jaas-authentication-tutorial.html#GUID-BFEBDB00-9826-499C-A20F-E9463883DED4">JAAS认证</a>和<a href="jaas-authorization-tutorial.html#GUID-D43CF965-8A5F-4A23-A2AF-F41DD5F8B411">JAAS授权</a>教程包含以下样本：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="jaas-authentication-tutorial.html#GUID-E007D5F4-3FA5-417A-B85F-E669839F0101__GUID-1270A0AC-EA51-4A47-B9BC-BDB42F96F5FE"><code>SampleAcn.java</code></a>是演示JAAS认证的示例应用程序。
                     </li>
                     <li><a href="jaas-authorization-tutorial.html#GUID-07EAB926-63EA-48F4-8DF0-4CC4526FA545__GUID-9AE66C05-0850-4AAF-8DD9-7D940069844F"><code>SampleAzn.java</code></a>是授权教程使用的示例应用程序。它演示了身份验证和授权。
                     </li>
                     <li><a href="jaas-authentication-tutorial.html#GUID-A7E0803F-DA0B-42BF-8E25-DA5889BE847F">JAAS认证教程的登录配置文件</a>描述了<code>sample_jaas.config</code> ，这是两个教程都使用的示例登录配置文件。
                     </li>
                     <li><a href="jaas-authentication-tutorial.html#GUID-44F2BF3A-F51D-4F21-8F40-96CB1120396D__SAMPLEACN.POLICY-2FEDE143"><code>sampleacn.policy</code></a>是一个示例策略文件，它授予身份验证教程的代码所需的权限。
                     </li>
                     <li><a href="jaas-authorization-tutorial.html#GUID-3A2FF6CF-3124-4402-B550-D0F4E76B3D4D__GUID-6CA8F774-5E38-437D-8549-9604DEC5C317"><code>sampleazn.policy</code></a>是一个示例策略文件，授予授权教程的代码所需的权限。
                     </li>
                     <li><a href="jaas-authentication-tutorial.html#GUID-03476CCA-11C6-4D51-B170-C8DD7C0D9075__GUID-F9A208EC-3247-4320-8158-82B0E84C6A04"><code>SampleLoginModule.java</code></a>是教程的登录配置文件指定的类（ <code class="codeph">sample_jaas.config</code> ）作为实现所需基础身份验证的类。<span class="apiname">SampleLoginModule</span>的用户身份验证仅包含验证用户指定的名称和密码是否具有特定值。
                     </li>
                     <li><a href="jaas-authentication-tutorial.html#GUID-03476CCA-11C6-4D51-B170-C8DD7C0D9075__GUID-3EA5533B-1284-481E-A35F-C82B17837F2E"><code>SamplePrincipal.java</code></a>是实现<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Principal.html" target="_blank"><code class="codeph">Principal</code></a>接口。由<span class="apiname">SampleLoginModule使用</span> 。
                     </li>
                  </ul>
                  <p>有关应用程序，策略文件和登录配置文件的详细信息，请参见教程。</p>
                  <p>应用程序编写人员无需了解以下代码<code>SampleLoginModule.java</code>要么<code>SamplePrincipal.java</code> ，如教程中所述。希望编写LoginModules的程序员可以通过阅读<a href="java-authentication-and-authorization-service-jaas-loginmodule-developers-guide1.html#GUID-CB46C30D-FFF1-466F-B2F5-6DE0BD5DA43A">Java身份验证和授权服务（JAAS）：LoginModule开发人员指南</a>来学习如何编写。
                  </p>
                  <p></p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-106F4B32-B9A3-4B75-BDBF-29B252BB3F53" name="GUID-106F4B32-B9A3-4B75-BDBF-29B252BB3F53"></a><h3 id="JSSEC-GUID-106F4B32-B9A3-4B75-BDBF-29B252BB3F53" class="sect3">附录A：java.security安全属性文件中的JAAS设置</h3>
               <div>
                  <p>可以在以下选项中配置许多与JAAS相关的设置： <code class="codeph">java.security</code>主安全属性文件，位于<code>conf/security</code> JDK的目录。</p>
                  <p>JAAS向中添加了两个新的安全性属性<code class="codeph">java.security</code> ：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">login.configuration.provider</code></li>
                     <li><code class="codeph">login.config.url.<span class="variable" translate="no">n</span></code></li>
                  </ul>
                  <p>以下预先存在的属性也与JAAS用户相关：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">policy.provider</code></li>
                     <li><code class="codeph">policy.url.<span class="variable" translate="no">n</span></code></li>
                  </ul>
                  <p>下面的示例演示如何配置这些属性。在此示例中，我们保留默认值中提供的值。 <code class="codeph">java.security</code>的档案<code class="codeph">policy.provider</code> ， <code class="codeph">policy.url.<span class="variable" translate="no">n</span></code>和<code class="codeph">login.configuration.provider</code>安全属性。默认值<code class="codeph">java.security</code>文件还列出了<code class="codeph">login.config.url.<span class="variable" translate="no">n</span></code>安全属性，但已将其注释掉。在下面的示例中，未对其进行注释。
                  </p><pre class="pre codeblock"><code>...

#
# Class to instantiate as the javax.security.auth.login.Configuration
# provider.
#
login.configuration.provider=sun.security.provider.ConfigFile

#
# Default login configuration file
#
#login.config.url.1=file:${user.home}/.java.login.config

#
# Class to instantiate as the system Policy. This is the name of the class
# that will be used as the Policy object. The system class loader is used to
# locate this class.
#
policy.provider=sun.security.provider.PolicyFile

# The default is to have a single system-wide policy file,
# and a policy file in the user's home directory.
#
policy.url.1=file:${java.home}/conf/security/java.policy
policy.url.2=file:${user.home}/.java.policy

...
</code></pre><p>注意：对该文件所做的修改可能会被后续的JDK更新覆盖。但是，另一种<code class="codeph">java.security</code>可以通过系统属性从命令行指定属性文件<code class="codeph">java.security.properties=<span class="variable" translate="no"><URL></span></code> 。该属性文件将追加到系统属性文件中。如果两个属性文件都为同一键指定值，那么将从命令行属性文件中选择该值，因为它是最后一个加载的值。
                  </p>
                  <p>另外，指定<code class="codeph">java.security.properties==<span class="variable" translate="no"><URL></span></code> （使用两个等号），则该属性文件将完全覆盖系统属性文件。
                  </p>
                  <p>要禁用从命令行指定其他属性文件的功能，请设置键<code class="codeph">security.overridePropertiesFile</code>至<code class="codeph">false</code>在系统属性文件中。设置为<code class="codeph">true</code>默认。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-75C5BF67-1530-4383-8A0D-6C2C6B378096" name="GUID-75C5BF67-1530-4383-8A0D-6C2C6B378096"></a><h4 id="JSSEC-GUID-75C5BF67-1530-4383-8A0D-6C2C6B378096" class="sect4">登录配置提供程序</h4>
                  <div>
                     <p>Oracle提供的默认JAAS登录配置实现是从文件中获取其配置信息，并希望以教程中显示的特定格式提供该信息。</p>
                     <p>可以通过在以下选项中指定备用提供程序类实现来替换默认的JAAS登录配置实现。 <code class="codeph">login.configuration.provider</code>属性。
                     </p>
                     <p>例如：</p><pre class="pre codeblock"><code>    login.configuration.provider=com.foo.Config
</code></pre><p>如果安全属性<code class="codeph">login.configuration.provider</code>找不到或未指定，则将其设置为默认值：</p><pre class="pre codeblock"><code>    login.configuration.provider=com.sun.security.auth.login.ConfigFile
</code></pre><p>请注意，无法从命令行动态设置登录配置提供程序。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F26A634E-7D9F-41FD-822A-59A2D33E79BB" name="GUID-F26A634E-7D9F-41FD-822A-59A2D33E79BB"></a><h4 id="JSSEC-GUID-F26A634E-7D9F-41FD-822A-59A2D33E79BB" class="sect4">登录配置URL</h4>
                  <div>
                     <p>如果您使用的是登录配置实现，期望在文件中指定配置信息（Oracle的默认实现也是如此），则可以通过在<code class="codeph">login.config.url.<span class="variable" translate="no">n</span></code>属性。 <span class="variable" translate="no">n</span>是从1开始的连续编号的整数。如果指定了多个配置文件（如果<span class="variable" translate="no">n</span> > = 2），则将读取它们并将它们合并为一个配置。
                     </p>
                     <p>例如：</p><pre class="pre codeblock"><code>
  login.config.url.1=file:C:/config/.java.login.config
  login.config.url.2=file:C:/users/foo/.foo.login.config
</code></pre><p>如果未在配置文件中设置配置文件的位置<code class="codeph">java.security</code>属性文件，并且也不能从命令行动态指定（通过<code class="codeph">-Djava.security.auth.login.config</code>选项），JAAS会尝试从中加载默认配置</p><pre class="pre codeblock"><code>
<span class="variable" translate="no">file:${user.home}</span>/.java.login.config
</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-6396FFE2-3877-405C-B40C-8B838A2B69D5" name="GUID-6396FFE2-3877-405C-B40C-8B838A2B69D5"></a><h4 id="JSSEC-GUID-6396FFE2-3877-405C-B40C-8B838A2B69D5" class="sect4">政策提供者</h4>
                  <div>
                     <p>可以通过在以下选项中指定备用提供程序类实现来替换默认策略实现。 <code class="codeph">policy.provider</code>属性。
                     </p>
                     <p>例如：</p><pre class="pre codeblock"><code>policy.provider=com.foo.Policy
</code></pre><p>如果安全属性<code class="codeph">policy.provider</code>找不到或未指定，则<code class="codeph">Policy</code>设置为默认值：</p><pre class="pre codeblock"><code>policy.provider=sun.security.provider.PolicyFile
</code></pre><p>请注意，无法从命令行动态设置策略提供程序。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D6502328-3C68-4E79-816B-599CC503DF73" name="GUID-D6502328-3C68-4E79-816B-599CC503DF73"></a><h4 id="JSSEC-GUID-D6502328-3C68-4E79-816B-599CC503DF73" class="sect4">政策档案网址</h4>
                  <div>
                     <p>可以通过在访问控制策略文件中指定它们各自的URL来静态设置访问控制策略文件的位置。 <code class="codeph">auth.policy.url.<span class="variable" translate="no">n</span></code>属性。 <code class="codeph"><span class="variable" translate="no">n</span></code>是从1开始的连续编号的整数。如果指定了多个策略（如果<code class="codeph"><span class="variable" translate="no">n</span></code> > = 2），它们将被读取并合并为一个单一策略。
                     </p>
                     <p>例如：</p><pre class="pre codeblock"><code>policy.url.1=file:C:/policy/.java.policy
policy.url.2=file:C:/users/foo/.foo.policy
</code></pre><p>如果未在策略文件中设置策略文件的位置<code class="codeph">java.security</code>属性文件，并且不能从命令行动态指定（通过<code class="codeph">-Djava.security.policy</code>选项），访问控制策略默认使用与JDK一起安装的系统策略文件相同的策略。该政策文件</p>
                     <ul style="list-style-type:disc">
                        <li>向标准扩展授予所有权限</li>
                        <li>允许任何人在非特权端口上侦听</li>
                        <li>允许任何代码读取对安全性不敏感的某些“标准”属性，例如<code class="codeph">os.name</code>和<code class="codeph">file.separator</code>属性。
                        </li>
                     </ul>
                     <p></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>