<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="">
      <meta name="description" content="">
      <title>XML Digital Signature API概述和教程</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-sasl-api-programming-and-deployment-guide1.html" title="Previous" type="text/html">
      <link rel="next" href="security-api-specification1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-sasl-api-programming-and-deployment-guide1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="security-api-specification1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XML Digital Signature API概述和教程</li>
            </ol>
            <a id="GUID-DB46A001-6DBD-4571-BDBC-1BBC394BF61E" name="GUID-DB46A001-6DBD-4571-BDBC-1BBC394BF61E"></a>
            
            <h2 id="JSSEC-GUID-DB46A001-6DBD-4571-BDBC-1BBC394BF61E" class="sect2"><span class="enumeration_chapter">12</span> XML Digital Signature API概述和教程</h2>
         </header>
         <div class="ind">
            <div>
               <p></p>
               <p>Java XML数字签名API是用于生成和验证XML签名的标准Java API。该API在Java社区流程下定义为<a href="http://www.jcp.org/en/jsr/detail?id=105" target="_blank">JSR 105</a> 。
               </p>
               <p>XML签名可以应用于任何类型的数据（XML或二进制）（请参阅<a href="http://www.w3.org/TR/xmldsig-core/" target="_blank">XML签名语法和处理</a> ）。结果签名以XML表示。 XML签名可用于保护您的数据并提供数据完整性，消息身份验证和签名者身份验证。
               </p>
               <p>在简要概述了XML签名和XML数字签名API之后，本文档提供了两个示例，这些示例演示了如何使用API来验证和生成XML签名。本文档假定您具有加密和数字签名的基本知识。</p>
               <p>该API旨在支持W3C XML签名语法和处理建议书的所有必需或推荐功能。该API是可扩展和可插入的，并且基于Java密码服务提供程序体系结构。请参阅《 <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java密码学体系结构（JCA）参考指南》</a> 。该API专为两种类型的开发人员设计：</p>
               <ul style="list-style-type:disc">
                  <li>想要使用XML数字签名API生成和验证XML签名的开发人员</li>
                  <li>想要创建XML数字签名API的具体实现并将其注册为JCA提供者的加密服务的开发人员（请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" title="为了使用，必须先安装密码提供程序，然后静态或动态注册。此版本附带有许多Sun提供程序（SUN，SunJCE，SunJSSE，SunRsaSign等）已安装并注册。以下各节描述了如何安装和注册其他提供程序。每个提供程序类实例都有一个（当前区分大小写）名称，版本号以及提供程序及其服务的字符串描述。">Provider类</a> ）。
                  </li>
               </ul>
            </div>
            <div class="sect2"><a id="GUID-BBFA7B90-3EA2-49DE-964B-8A60D4134343" name="GUID-BBFA7B90-3EA2-49DE-964B-8A60D4134343"></a><h3 id="JSSEC-GUID-BBFA7B90-3EA2-49DE-964B-8A60D4134343" class="sect3">包层次结构</h3>
               <div>
                  <p></p>
                  <p>以下六个软件包（包含在<a href="https://docs.oracle.com/javase/10/docs/api/java.xml.crypto-summary.html" target="_blank"><span class="apiname">java.xml.crypto</span></a>模块中）构成了XML数字签名API：</p>
                  <ul style="list-style-type:disc">
                     <li><span class="apiname">javax.xml.crypto</span></li>
                     <li><span class="apiname">javax.xml.crypto.dsig</span></li>
                     <li><span class="apiname">javax.xml.crypto.dsig.keyinfo</span></li>
                     <li><span class="apiname">javax.xml.crypto.dsig.spec</span></li>
                     <li><span class="apiname">javax.xml.crypto.dom</span></li>
                     <li><span class="apiname">javax.xml.crypto.dsig.dom</span></li>
                  </ul>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto</span></a>包包含用于执行XML加密操作（例如生成XML签名或加密XML数据）的通用类。此包中两个值得注意的类是<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/KeySelector.html" target="_blank"><span class="apiname">KeySelector</span></a>类，它允许开发人员提供使用<span class="apiname">KeyInfo</span>对象中包含的信息来定位和可选地验证密钥的实现，以及<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/URIDereferencer.html" target="_blank"><span class="apiname">URIDereferencer</span></a>类，它允许开发人员创建和指定自己的URI解引用实现。
                  </p>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dsig</span></a>软件包包括代表W3C XML数字签名规范中定义的核心元素的接口。<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/XMLSignature.html" target="_blank"><span class="apiname">XMLSignature</span></a>类是最主要的意义，它使您可以签名和验证XML数字签名。大多数XML签名结构或元素由相应的接口表示（KeyInfo结构除外，它们包含在其自己的程序包中，并在下一段中进行讨论）。这些接口包括： <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/SignedInfo.html" target="_blank"><span class="apiname">SignedInfo</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/CanonicalizationMethod.html" target="_blank"><span class="apiname">CanonicalizationMethod</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/SignatureMethod.html" target="_blank"><span class="apiname">SignatureMethod</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/Reference.html" target="_blank"><span class="apiname">Reference</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/Transform.html" target="_blank"><span class="apiname">Transform</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/DigestMethod.html" target="_blank"><span class="apiname">DigestMethod</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/XMLObject.html" target="_blank"><span class="apiname">XMLObject</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/Manifest.html" target="_blank"><span class="apiname">Manifest</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/SignatureProperty.html" target="_blank"><span class="apiname">SignatureProperty</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/SignatureProperties.html" target="_blank"><span class="apiname">SignatureProperty</span></a> 。<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank"><span class="apiname">XMLSignatureFactory</span></a>类是一个抽象工厂，用于创建实现这些接口的对象。
                  </p>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dsig.keyinfo</span></a>包包含代表W3C XML数字签名推荐中定义的大多数<span class="apiname">KeyInfo</span>结构的接口，包括<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyInfo.html" target="_blank"><span class="apiname">KeyInfo</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyName.html" target="_blank"><span class="apiname">KeyName</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyValue.html" target="_blank"><span class="apiname">KeyValue</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/X509Data.html" target="_blank"><span class="apiname">X509Data</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/X509IssuerSerial.html" target="_blank"><span class="apiname">X509IssuerSerial</span></a> ， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/RetrievalMethod.html" target="_blank"><span class="apiname">RetrievalMethod</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/PGPData.html" target="_blank"><span class="apiname">PGPData</span></a> 。<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank"><span class="apiname">KeyInfoFactory</span></a>类是一个抽象工厂，用于创建实现这些接口的对象。
                  </p>
                  <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dsig.spec</span></a>软件包包含表示用于XML签名处理中的摘要，签名，转换或规范化算法的输入参数的接口和类。
                  </p>
                  <p>最后， <a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dom/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dom</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/dom/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dsig.dom</span></a>包包含DOM特定类的<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto中</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/package-summary.html" target="_blank"><span class="apiname">javax.xml.crypto.dsig中的</span></a>包，分别。只有正在创建或使用基于DOM的<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank"><span class="apiname">XMLSignatureFactory</span></a>或<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank"><span class="apiname">KeyInfoFactory</span></a>实现的开发人员和用户才需要直接使用这些包。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-A32C5AC5-08F9-4316-9D63-0CDEAC3A5405" name="GUID-A32C5AC5-08F9-4316-9D63-0CDEAC3A5405"></a><h3 id="JSSEC-GUID-A32C5AC5-08F9-4316-9D63-0CDEAC3A5405" class="sect3">服务供应商</h3>
               <div>
                  <p></p>
                  <p>Java XML签名是抽象<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank"><span class="apiname">XMLSignatureFactory</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank"><span class="apiname">KeyInfoFactory</span></a>类的具体实现，并且负责创建对象和算法，以解析，生成和验证XML签名和<span class="apiname">KeyInfo</span>结构。<span class="apiname">XMLSignatureFactory</span>的具体实现必须为W3C针对XML签名的建议所指定的每种必需算法提供支持。它可以选择支持W3C建议或其他规范定义的其他算法。
                  </p>
                  <p>Java XML数字签名API利用JCA提供程序模型来注册和加载<span class="apiname">XMLSignatureFactory</span>和<span class="apiname">KeyInfoFactory</span>实现。
                  </p>
                  <p>每个具体的<span class="apiname">XMLSignatureFactory</span>或<span class="apiname">KeyInfoFactory</span>实现都支持一种特定的XML机制类型，该类型标识实现内部使用的XML处理机制来解析和生成XML签名和<span class="apiname">KeyInfo</span>结构。此JSR支持一种标准类型DOM。与JDK捆绑在一起的XML Digital Signature提供程序实现支持DOM机制。
                  </p>
                  <p>XML数字签名API实现应使用基础JCA引擎类，例如<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Signature.html" target="_blank"><span class="apiname">java.security。签名</span></a>和<a href="https://docs.oracle.com/javase/10/docs/api/java/security/MessageDigest.html" target="_blank"><span class="apiname">java.security。MessageDigest</span></a> ，以执行加密操作。
                  </p>
                  <p>除了<span class="apiname">XMLSignatureFactory</span>和<span class="apiname">KeyInfoFactory</span>类之外，JSR 105还支持用于转换和规范化算法的服务提供者接口。<a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/TransformService.html" target="_blank"><span class="apiname">TransformService</span></a>类使您可以为特定的XML机制类型开发并插入特定转换或规范化算法的实现。<span class="apiname">TransformService</span>类使用标准的JCA提供程序模型来注册和加载实现。每个JSR 105实现都应该使用<span class="apiname">TransformService</span>类来查找提供程序，该提供程序支持正在生成或验证的XML签名中的转换和规范化算法。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E11E6051-5F30-4DDA-A4EE-5F9C1AB1F7B8" name="GUID-E11E6051-5F30-4DDA-A4EE-5F9C1AB1F7B8"></a><h3 id="JSSEC-GUID-E11E6051-5F30-4DDA-A4EE-5F9C1AB1F7B8" class="sect3">XML签名简介</h3>
               <div>
                  <p></p>
                  <p>您可以使用XML签名来签名任意数据，无论是XML还是二进制数据。通过一个或多个参考元素中的URI标识数据。XML签名以以下三种形式中的一种或多种来描述：分离式，信封式或信封式。分离的签名超出了签名元素本身外部或外部的数据。包络签名是在signature元素内部的数据之上的签名，而封装签名是包含在正在签名的数据内部的签名。</p>
               </div>
               <div class="sect3"><a id="GUID-E5A89234-A67A-4999-8E31-6D6C26B9BAAF" name="GUID-E5A89234-A67A-4999-8E31-6D6C26B9BAAF"></a><h4 id="JSSEC-GUID-E5A89234-A67A-4999-8E31-6D6C26B9BAAF" class="sect4">XML签名示例</h4>
                  <div>
                     <p></p>
                     <p>描述XML签名内容的最简单方法是显示实际示例并更详细地描述每个组件。<a href="java-xml-digital-signature-api-overview-and-tutorial.html#GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0__GUID-4DCD9F0B-02C7-4C00-AB66-096C7F262ACF">示例12-3</a>是在XML文档的内容上生成的封装XML签名。根元素， <code class="codeph">Envelop</code> ，包含一个<code class="codeph">Signature</code>元件：</p><pre class="pre codeblock"><code>&lt;Envelope xmlns="urn:envelope"&gt;
  &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
    &lt;!-- ... --&gt;
  &lt;/Signature&gt;
&lt;/Envelope&gt; </code></pre><p>这个<code class="codeph">Signature</code>元素已插入要签名的内容内，从而使其成为封装的签名。所需<code class="codeph">SignedInfo</code>元素包含实际签名的信息：</p><pre class="pre codeblock"><code>&lt;Envelope xmlns="urn:envelope"&gt;
  &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
    &lt;SignedInfo&gt;
      &lt;CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"/&gt;
      &lt;SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/&gt;
      &lt;Reference URI=""&gt;
        &lt;Transforms&gt;
          &lt;Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/&gt;
        &lt;/Transforms&gt;
        &lt;DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/&gt;
        &lt;DigestValue&gt;/juoQ4bDxElf1M+KJauO20euW+QAvvPP0nDCruCQooM=&lt;/DigestValue&gt;
      &lt;/Reference&gt;
    &lt;/SignedInfo&gt;
    &lt;!-- ... --&gt;
  &lt;/Signature&gt;
&lt;/Envelope&gt; </code></pre><p></p>
                     <p>所需<code class="codeph">CanonicalizationMethod</code>元素定义用于规范化的算法<code class="codeph">SignedInfo</code>元素在签名或验证之前。规范化是将XML内容转换为规范形式的过程，以考虑可能会使该数据签名无效的更改。由于XML的性质以及不同处理器和中介机构对其进行解析的方式，规范化是必要的，因为规范化可以更改数据，使得签名不再有效，但签名后的数据在逻辑上仍然等效。
                     </p>
                     <p>所需<code class="codeph">SignatureMethod</code>元素定义用于生成签名的数字签名算法，在本例中为具有SHA-256的RSA。
                     </p>
                     <p>一个或多个<code class="codeph">Reference</code>元素标识摘要的数据。每<code class="codeph">Reference</code>元素通过URI标识数据。在此示例中，URI的值为空字符串（“”），它表示文档的根目录。可选的<code class="codeph">Transforms</code>元素包含一个或多个列表<code class="codeph">Transform</code>元素，每个元素都描述了一种转换算法，用于在数据摘要之前对其进行转换。在此示例中，有一个用于封装变换算法的Transform元素。信封签名需要信封变换，以便在计算签名值之前删除签名元素本身。所需<code class="codeph">DigestMethod</code>元素定义用于提取数据的算法，在这种情况下为SHA-256。最后要求<code class="codeph">DigestValue</code>元素包含实际的base64编码的摘要值。
                     </p>
                     <p>所需<code class="codeph">SignatureValue</code>元素包含签名的base64编码签名值， <code class="codeph">SignedInfo</code>元件。
                     </p>
                     <p>可选的<code class="codeph">KeyInfo</code>元素包含有关验证签名所需的密钥的信息：</p><pre class="pre codeblock"><code>    &lt;KeyInfo&gt;
      &lt;KeyValue&gt;
        &lt;RSAKeyValue&gt;
          &lt;Modulus&gt;
9hSmAKw/4TTw/1l1u1pYzdFm6lOjRB/5NfdGWl/fB8iAa/tiK0f1u/VWoK6SMtogYgSDKqQThbAu
9dy9rRnOWRGY2He1JtpOvGh0WCmIFUEs2P22HvEf+JGKVEpkoP4hv53ucT69T+7nKGK3/bjxgp+T
C7fbnVj651+jAHuDFlC8Txt1R8ZymfN5cUeHIH96dvNFrtai/uwZDbVMfhV9chL//+Vyhx4O5nHv
jfS+0So9Qi52YAbEyLu6+BLdu8wnMWapC88CfXsRwrpx8b6aCU0e6QSZyOvdgXWz3+9ifVTBDIxE
kjhL5OASx0qjvc+dPUOMvq7fJE05RRZLyb0YJw==
          &lt;/Modulus&gt;
          &lt;Exponent&gt;AQAB&lt;/Exponent&gt;
        &lt;/RSAKeyValue&gt;
      &lt;/KeyValue&gt;
    &lt;/KeyInfo&gt;</code></pre><p>这个<code class="codeph">KeyInfo</code>元素包含一个<code class="codeph">KeyValue</code>元素，其中又包含一个<code class="codeph">RSAKeyValue</code>由验证签名所需的公钥组成的元素。 <code class="codeph">KeyInfo</code>可以包含各种内容，例如X.509证书和PGP密钥标识符。查看<a href="http://www.w3.org/TR/xmldsig-core/#sec-KeyInfo" target="_blank">该<code class="codeph">KeyInfo</code></a> <a href="https://www.w3.org/TR/xmldsig-core/" target="_blank">XML签名语法和处理中的</a> <a href="http://www.w3.org/TR/xmldsig-core/#sec-KeyInfo" target="_blank">元素</a> ，以获取有关不同<a href="https://www.w3.org/TR/xmldsig-core/" target="_blank">签名</a>的更多信息<code class="codeph">KeyInfo</code>类型。
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8618C294-3BFE-45C3-9A1E-C4629E337E68" name="GUID-8618C294-3BFE-45C3-9A1E-C4629E337E68"></a><h3 id="JSSEC-GUID-8618C294-3BFE-45C3-9A1E-C4629E337E68" class="sect3">XML签名安全验证模式</h3>
               <div>
                  <p>XML签名安全验证模式可以保护您免受可能包含可能导致拒绝服务或其他类型的安全问题的潜在敌对构造的XML签名的侵害。</p>
                  <p>使用安全管理器运行应用程序时，默认情况下会启用XML签名安全验证模式。</p>
                  <p>您还可以通过设置以下选项来启用XML签名安全验证模式： <code class="codeph">org.jcp.xml.dsig.secureValidation</code>财产<code class="codeph">TRUE</code> 。您必须将此属性设置为<code class="codeph">TRUE</code>在验证XML签名之前。
                  </p>
                  <p>要在应用程序中设置此属性，请调用<span class="apiname">javax.xml.crypto.dsig.dom。DOMValidateContext.setProperty</span>方法：</p><pre class="pre codeblock"><code>    DOMValidateContext context = new DOMValidateContext(key, element);
    context.setProperty("org.jcp.xml.dsig.secureValidation", Boolean.TRUE);</code></pre><p>启用XML签名安全验证模式后，将更安全地处理XML签名。在各种XML签名结构上设置了限制，以避免出现诸如拒绝服务攻击之类的情况。默认情况下，它强制执行以下限制：</p>
                  <ul style="list-style-type:disc">
                     <li>禁止使用XSLT转换</li>
                     <li>限制数量<code class="codeph">SignedInfo</code>要么<code class="codeph">Manifest</code><code class="codeph">Reference</code>元素不超过30</li>
                     <li>限制数量<code class="codeph">Reference</code>转换为5以下</li>
                     <li>禁止使用与MD5相关的签名或MAC算法</li>
                     <li>确保<code class="codeph">Reference</code> ID是唯一的，有助于防止签名包装攻击</li>
                     <li>禁止<code class="codeph">Reference</code>类型的URI <code class="codeph">http</code> ， <code class="codeph">https</code> ， 要么<code class="codeph">file</code></li>
                     <li>不允许<code class="codeph">RetrievalMethod</code>引用另一个的元素<code class="codeph">RetrievalMethod</code>元件</li>
                     <li>禁止少于1024位的RSA或DSA密钥</li>
                  </ul>
                  <p>此外，您可以使用<code class="codeph">jdk.xml.dsig.secureValidationPolicy</code>安全属性，用于控制和微调之前列出的限制，或添加其他限制。请参阅“安全性”中的定义。 <code>java.security</code>文件以获取更多信息。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E7E9239F-C973-4D05-AC3F-53F714C259DB" name="GUID-E7E9239F-C973-4D05-AC3F-53F714C259DB"></a><h3 id="JSSEC-GUID-E7E9239F-C973-4D05-AC3F-53F714C259DB" class="sect3">XML数字签名API示例</h3>
               <div>
                  <p></p>
                  <p>以下各节描述了两个示例，这些示例显示了如何使用XML Digital Signature API：</p>
               </div>
               <div class="sect3"><a id="GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0" name="GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0"></a><h4 id="JSSEC-GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0" class="sect4">验证示例</h4>
                  <div>
                     <p></p>
                     <p>要编译并运行该示例，请执行以下命令：</p><pre class="pre codeblock"><code>$ javac Validate.java 
$ java Validate signature.xml</code></pre><p>该示例程序将验证文件中的签名<code>signature.xml</code>在当前工作目录中。
                     </p>
                     <div class="example" id="GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0__GUID-CCB8BC57-84D6-4EC2-A81A-A9760B4CD190">
                        <p class="titleinexample">示例12-1 Validate.java</p><pre class="pre codeblock"><code>import javax.xml.crypto.*;
import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dom.*;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.*;
import java.io.FileInputStream;
import java.security.*;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

/**
 * This is a simple example of validating an XML Signature using
 * the XML Signature API. It assumes the key needed to validate
 * the signature is contained in a KeyValue KeyInfo.
 */
public class Validate {

    //
    // Synopsis: java Validate [document]
    //
    //    where "document" is the name of a file containing the XML document
    //    to be validated.
    //
    public static void main(String[] args) throws Exception {

        // Instantiate the document to be validated
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        Document doc = null;
        try (FileInputStream fis = new FileInputStream(args[0])) {
            doc = dbf.newDocumentBuilder().parse(fis);
        }

        // Find Signature element
        NodeList nl =
            doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");
        if (nl.getLength() == 0) {
            throw new Exception("Cannot find Signature element");
        }

        // Create a DOM XMLSignatureFactory that will be used to unmarshal the
        // document containing the XMLSignature
        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");

        // Create a DOMValidateContext and specify a KeyValue KeySelector
        // and document context
        DOMValidateContext valContext = new DOMValidateContext
            (new KeyValueKeySelector(), nl.item(0));

        // unmarshal the XMLSignature
        XMLSignature signature = fac.unmarshalXMLSignature(valContext);

        // Validate the XMLSignature (generated above)
        boolean coreValidity = signature.validate(valContext);

        // Check core validation status
        if (coreValidity == false) {
            System.err.println("Signature failed core validation");
            boolean sv = signature.getSignatureValue().validate(valContext);
            System.out.println("signature validation status: " + sv);
            // check the validation status of each Reference
            Iterator&lt;Reference&gt; i =
                signature.getSignedInfo().getReferences().iterator();
            for (int j=0; i.hasNext(); j++) {
                boolean refValid = i.next().validate(valContext);
                System.out.println("ref["+j+"] validity status: " + refValid);
            }
        } else {
            System.out.println("Signature passed core validation");
        }
    }

    /**
     * KeySelector which retrieves the public key out of the
     * KeyValue element and returns it.
     * NOTE: If the key algorithm doesn't match signature algorithm,
     * then the public key will be ignored.
     */
    private static class KeyValueKeySelector extends KeySelector {
        public KeySelectorResult select(KeyInfo keyInfo,
                                        KeySelector.Purpose purpose,
                                        AlgorithmMethod method,
                                        XMLCryptoContext context)
            throws KeySelectorException {
            if (keyInfo == null) {
                throw new KeySelectorException("Null KeyInfo object!");
            }
            SignatureMethod sm = (SignatureMethod) method;
            List&lt;XMLStructure&gt; list = keyInfo.getContent();

            for (int i = 0; i &lt; list.size(); i++) {
                XMLStructure xmlStructure = list.get(i);
                if (xmlStructure instanceof KeyValue) {
                    PublicKey pk = null;
                    try {
                        pk = ((KeyValue)xmlStructure).getPublicKey();
                    } catch (KeyException ke) {
                        throw new KeySelectorException(ke);
                    }
                    // make sure algorithm is compatible with method
                    if (algEquals(sm.getAlgorithm(), pk.getAlgorithm())) {
                        return new SimpleKeySelectorResult(pk);
                    }
                }
            }
            throw new KeySelectorException("No KeyValue element found!");
        }

        static boolean algEquals(String algURI, String algName) {
            if (algName.equalsIgnoreCase("DSA") &amp;&amp;
                algURI.equalsIgnoreCase("http://www.w3.org/2009/xmldsig11#dsa-sha256")) {
                return true;
            } else if (algName.equalsIgnoreCase("RSA") &amp;&amp;
                       algURI.equalsIgnoreCase("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256")) {
                return true;
            } else {
                return false;
            }
        }
    }

    private static class SimpleKeySelectorResult implements KeySelectorResult {
        private PublicKey pk;
        SimpleKeySelectorResult(PublicKey pk) {
            this.pk = pk;
        }

        public Key getKey() { return pk; }
    }
}
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0__GUID-A82408FF-EC50-46A6-8D22-3B06B85AB588">
                        <p class="titleinexample">示例12-2信封.xml</p><pre class="pre codeblock"><code>&lt;Envelope xmlns="urn:envelope"&gt;
&lt;/Envelope&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-22AB40C4-45EC-4714-91A2-CFB59EC05AA0__GUID-4DCD9F0B-02C7-4C00-AB66-096C7F262ACF">
                        <p class="titleinexample">示例12-3 signature.xml</p>
                        <p>该文件已缩进并格式化以提高可读性。</p><pre class="pre codeblock"><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;Envelope xmlns="urn:envelope"&gt;
  &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
    &lt;SignedInfo&gt;
      &lt;CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"/&gt;
      &lt;SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/&gt;
      &lt;Reference URI=""&gt;
        &lt;Transforms&gt;
          &lt;Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/&gt;
        &lt;/Transforms&gt;
        &lt;DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/&gt;
        &lt;DigestValue&gt;/juoQ4bDxElf1M+KJauO20euW+QAvvPP0nDCruCQooM=&lt;/DigestValue&gt;
      &lt;/Reference&gt;
    &lt;/SignedInfo&gt;
    &lt;SignatureValue&gt;
Vorr4nABCD7eWOjh4jn8pdM5iseGJPt4BmlgjEbxr05TsR9ObHq7WLVOBOtJfb3M6pXv6NnTucpH
e/97zHbuUMaNeGxCs/gN7YDUGOkQE1Gs4HAbGwXuTcif3pw+066ZW4uxyzapwS6lZHmqIm7PRl8I
NIQXVL4dezLe+rx77Kh+rZRheVe4UlTTP+TmIOaBZo93GQ5FudreMhSiuIC0Nx2SP7mAkt6+8kVH
luZouFbqriSvyhzIxDgyOXpm/PHCuuPU2scCokwjEZBtlZXDOl6lIWGllnyrptWntQ6F/ngQObI5
c2+npgCshq1svGuS/xx18MAFHGWi98Vj+07QCg==
    &lt;/SignatureValue&gt;
    &lt;KeyInfo&gt;
      &lt;KeyValue&gt;
        &lt;RSAKeyValue&gt;
          &lt;Modulus&gt;
9hSmAKw/4TTw/1l1u1pYzdFm6lOjRB/5NfdGWl/fB8iAa/tiK0f1u/VWoK6SMtogYgSDKqQThbAu
9dy9rRnOWRGY2He1JtpOvGh0WCmIFUEs2P22HvEf+JGKVEpkoP4hv53ucT69T+7nKGK3/bjxgp+T
C7fbnVj651+jAHuDFlC8Txt1R8ZymfN5cUeHIH96dvNFrtai/uwZDbVMfhV9chL//+Vyhx4O5nHv
jfS+0So9Qi52YAbEyLu6+BLdu8wnMWapC88CfXsRwrpx8b6aCU0e6QSZyOvdgXWz3+9ifVTBDIxE
kjhL5OASx0qjvc+dPUOMvq7fJE05RRZLyb0YJw==
          &lt;/Modulus&gt;
          &lt;Exponent&gt;AQAB&lt;/Exponent&gt;
        &lt;/RSAKeyValue&gt;
      &lt;/KeyValue&gt;
    &lt;/KeyInfo&gt;
  &lt;/Signature&gt;
&lt;/Envelope&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div class="sect4"><a id="GUID-28D86779-8D2A-4741-8D78-49830EFF9473" name="GUID-28D86779-8D2A-4741-8D78-49830EFF9473"></a><h5 id="JSSEC-GUID-28D86779-8D2A-4741-8D78-49830EFF9473" class="sect5">验证XML签名</h5>
                     <div>
                        <p></p>
                        <p>本示例说明如何使用Java XML数字签名API验证XML签名。该示例使用DOM（文档对象模型）来解析包含Signature元素的XML文档和用于验证签名的DOM实现。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B2651FD1-F5CD-49D1-8541-466ABAB7ECA8" name="GUID-B2651FD1-F5CD-49D1-8541-466ABAB7ECA8"></a><h5 id="JSSEC-GUID-B2651FD1-F5CD-49D1-8541-466ABAB7ECA8" class="sect5">实例化包含签名的文档</h5>
                     <div>
                        <p></p>
                        <p>首先，我们使用JAXP <span class="apiname">DocumentBuilderFactory</span>解析包含<span class="apiname">Signature</span>的XML文档。应用程序通过调用以下代码行来获取<span class="apiname">DocumentBuilderFactory</span>的默认实现：</p><pre class="pre codeblock"><code>    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</code></pre><p></p>
                        <p>我们还必须使工厂知道名称空间：</p><pre class="pre codeblock"><code>    dbf.setNamespaceAware(true);</code></pre><p></p>
                        <p>接下来，我们使用工厂获取<span class="apiname">DocumentBuilder</span>的实例，该实例用于解析文档：</p><pre class="pre codeblock"><code>    Document doc = null;
    try (FileInputStream fis = new FileInputStream(args[0])) {
        doc = dbf.newDocumentBuilder().parse(fis);
    }</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-66D2F1B6-2D1E-4721-B70B-4BA32103A79E" name="GUID-66D2F1B6-2D1E-4721-B70B-4BA32103A79E"></a><h5 id="JSSEC-GUID-66D2F1B6-2D1E-4721-B70B-4BA32103A79E" class="sect5">指定要验证的签名元素</h5>
                     <div>
                        <p></p>
                        <p>我们需要指定要验证的<span class="apiname">Signature</span>元素，因为文档中可能有多个。我们使用DOM方法<span class="apiname">Document.getElementsByTagNameNS</span> ，向其传递XML Signature名称空间URI和<span class="apiname">Signature</span>元素的标签名称，如下所示：</p><pre class="pre codeblock"><code>    NodeList nl =
        doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");
    if (nl.getLength() == 0) {
        throw new Exception("Cannot find Signature element");
    } </code></pre><p>这将返回文档中所有<span class="apiname">Signature</span>元素的列表。在此示例中，只有一个<span class="apiname">Signature</span>元素。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FCBFE214-3F87-412D-BC0F-EC4CE1519529" name="GUID-FCBFE214-3F87-412D-BC0F-EC4CE1519529"></a><h5 id="JSSEC-GUID-FCBFE214-3F87-412D-BC0F-EC4CE1519529" class="sect5">创建验证上下文</h5>
                     <div>
                        <p></p>
                        <p>我们创建一个<span class="apiname">XMLValidateContext</span>实例，该实例包含用于验证签名的输入参数。由于我们使用DOM，我们实例化一个<span class="apiname">使用DOMValidateContext</span>实例（ <span class="apiname">的XMLValidateContext</span>的子类），并向其传递两个参数，一个<span class="apiname">KeyValueKeySelector</span>对象和对签名元素的引用进行验证（这是我们先前生成的<span class="apiname">节点列表</span>的第一个条目） ：</p><pre class="pre codeblock"><code>    DOMValidateContext valContext = new DOMValidateContext
        (new KeyValueKeySelector(), nl.item(0));</code></pre><p>在<a href="java-xml-digital-signature-api-overview-and-tutorial.html#GUID-26946ED1-1BBE-4AFD-B1CA-5A6A46FD7354">使用KeySelectors中将对</a> <span class="apiname">KeyValueKeySelector</span>进行更详细的说明。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B5297B69-8989-4D40-994D-C40ED0C71C94" name="GUID-B5297B69-8989-4D40-994D-C40ED0C71C94"></a><h5 id="JSSEC-GUID-B5297B69-8989-4D40-994D-C40ED0C71C94" class="sect5">解组XML签名</h5>
                     <div>
                        <p></p>
                        <p>我们将<span class="apiname">Signature</span>元素的内容提取到<span class="apiname">XMLSignature</span>对象中。此过程称为解组。使用<span class="apiname">XMLSignatureFactory</span>对象可以解组<span class="apiname">Signature</span>元素。应用程序可以通过调用以下代码行来获取<span class="apiname">XMLSignatureFactory</span>的DOM实现：</p><pre class="pre codeblock"><code>    XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");</code></pre><p>然后，我们调用工厂的<span class="apiname">unmarshalXMLSignature</span>方法来解组<span class="apiname">XMLSignature</span>对象，并将其传递给我们之前创建的验证上下文：</p><pre class="pre codeblock"><code>    XMLSignature signature = fac.unmarshalXMLSignature(valContext);</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-CF8C37C4-7360-4833-83FB-6A2948C26818" name="GUID-CF8C37C4-7360-4833-83FB-6A2948C26818"></a><h5 id="JSSEC-GUID-CF8C37C4-7360-4833-83FB-6A2948C26818" class="sect5">验证XML签名</h5>
                     <div>
                        <p></p>
                        <p>现在我们准备验证签名。为此，我们对<span class="apiname">XMLSignature</span>对象调用validate方法，并将验证上下文传递给它，如下所示：</p><pre class="pre codeblock"><code>    boolean coreValidity = signature.validate(valContext);</code></pre><p>如果签名根据W3C XML签名建议中的核心验证规则成功验证，则validate方法返回“ true”，否则返回false。</p>
                     </div>
                     <div class="sect5"><a id="GUID-20CF389E-3F3F-4156-B8A3-CFB411E75274" name="GUID-20CF389E-3F3F-4156-B8A3-CFB411E75274"></a><h6 id="JSSEC-GUID-20CF389E-3F3F-4156-B8A3-CFB411E75274" class="sect6">如果XML签名无法验证怎么办？</h6>
                        <div>
                           <p></p>
                           <p>如果<span class="apiname">XMLSignature.validate</span>方法返回false，我们可以尝试缩小失败原因的范围。核心XML签名验证分为两个阶段：</p>
                           <ul style="list-style-type:disc">
                              <li>签名验证（签名的密码验证）</li>
                              <li>参考验证（签名中每个参考摘要的验证）</li>
                           </ul>
                           <p>每个阶段都必须成功才能使签名有效。要检查签名是否未能通过密码验证，我们可以检查状态，如下所示：</p><pre class="pre codeblock"><code>    boolean sv = signature.getSignatureValue().validate(valContext);
    System.out.println("signature validation status: " + sv);</code></pre><p>我们还可以遍历引用并检查每个引用的验证状态，如下所示：</p><pre class="pre codeblock"><code>    Iterator&lt;Reference&gt; i =
        signature.getSignedInfo().getReferences().iterator();
    for (int j=0; i.hasNext(); j++) {
        boolean refValid = i.next().validate(valContext);
        System.out.println("ref["+j+"] validity status: " + refValid);
    }</code></pre></div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-26946ED1-1BBE-4AFD-B1CA-5A6A46FD7354" name="GUID-26946ED1-1BBE-4AFD-B1CA-5A6A46FD7354"></a><h5 id="JSSEC-GUID-26946ED1-1BBE-4AFD-B1CA-5A6A46FD7354" class="sect5">使用键选择器</h5>
                     <div>
                        <p></p>
                        <p><span class="apiname">KeySelector</span>用于查找和选择验证<span class="apiname">XMLSignature</span>所需的密钥。之前，当我们创建<span class="apiname">DOMValidateContext</span>对象时，我们传递了一个<code class="codeph">KeyValueKeySelector</code>对象作为第一个参数：</p><pre class="pre codeblock"><code>    DOMValidateContext valContext = new DOMValidateContext
        (new KeyValueKeySelector(), nl.item(0));</code></pre><p></p>
                        <p>另外，如果我们已经知道需要什么密钥来验证签名，则可以将<span class="apiname">PublicKey</span>作为第一个参数。但是，我们通常不知道。
                        </p>
                        <p>的<code class="codeph">KeyValueKeySelector</code>类是抽象<span class="apiname">KeySelector</span>类的具体实现。的<code class="codeph">KeyValueKeySelector</code>实现尝试使用<span class="apiname">XMLSignature</span>的<span class="apiname">KeyInfo</span>元素的<span class="apiname">KeyValue</span>元素中包含的数据找到一个合适的验证密钥。它不能确定密钥是否受信任。这是一个非常简单的<span class="apiname">KeySelector</span>实现，旨在用于说明而非实际使用。<span class="apiname">KeySelector的</span>一个更实际的示例是在<span class="apiname">KeyStore</span>中搜索与<span class="apiname">KeyInfo中</span>包含的<span class="apiname">X509Data</span>信息（例如<span class="apiname">X509SubjectName</span> ， <span class="apiname">X509IssuerSerial</span> ， <span class="apiname">X509SKI</span>或<span class="apiname">X509Certificate</span>元素）匹配的可信密钥的示例。</p>
                        <p>实施<code class="codeph">KeyValueKeySelector</code>类如下：</p><pre class="pre codeblock"><code>    private static class KeyValueKeySelector extends KeySelector {
        public KeySelectorResult select(KeyInfo keyInfo,
                                        KeySelector.Purpose purpose,
                                        AlgorithmMethod method,
                                        XMLCryptoContext context)
            throws KeySelectorException {
            if (keyInfo == null) {
                throw new KeySelectorException("Null KeyInfo object!");
            }
            SignatureMethod sm = (SignatureMethod) method;
            List&lt;XMLStructure&gt; list = keyInfo.getContent();

            for (int i = 0; i &lt; list.size(); i++) {
                XMLStructure xmlStructure = list.get(i);
                if (xmlStructure instanceof KeyValue) {
                    PublicKey pk = null;
                    try {
                        pk = ((KeyValue)xmlStructure).getPublicKey();
                    } catch (KeyException ke) {
                        throw new KeySelectorException(ke);
                    }
                    // make sure algorithm is compatible with method
                    if (algEquals(sm.getAlgorithm(), pk.getAlgorithm())) {
                        return new SimpleKeySelectorResult(pk);
                    }
                }
            }
            throw new KeySelectorException("No KeyValue element found!");
        }

        static boolean algEquals(String algURI, String algName) {
            if (algName.equalsIgnoreCase("DSA") &amp;&amp;
                algURI.equalsIgnoreCase("http://www.w3.org/2009/xmldsig11#dsa-sha256")) {
                return true;
            } else if (algName.equalsIgnoreCase("RSA") &amp;&amp;
                       algURI.equalsIgnoreCase("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256")) {
                return true;
            } else {
                return false;
            }
        }
    }

    private static class SimpleKeySelectorResult implements KeySelectorResult {
        private PublicKey pk;
        SimpleKeySelectorResult(PublicKey pk) {
            this.pk = pk;
        }

        public Key getKey() { return pk; }
    }</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1152D2A5-ECBB-4727-9B0F-1941E4171108" name="GUID-1152D2A5-ECBB-4727-9B0F-1941E4171108"></a><h4 id="JSSEC-GUID-1152D2A5-ECBB-4727-9B0F-1941E4171108" class="sect4">GenEnveloped示例</h4>
                  <div>
                     <p></p>
                     <p>要编译并运行此样本，请执行以下命令：</p><pre class="pre codeblock"><code>$ javac GenEnveloped.java
$ java GenEnveloped envelope.xml envelopedSignature.xml</code></pre><p>该示例程序将在文件中生成文档的信封签名<code>envelope.xml</code>并将其存储在文件中<code>envelopedSignature.xml</code>在当前工作目录中。
                     </p>
                     <div class="example" id="GUID-1152D2A5-ECBB-4727-9B0F-1941E4171108__GUID-6CB4162E-30CE-41BF-8767-2C5B88063D8F">
                        <p class="titleinexample">示例12-4 GenEnveloped.java</p><pre class="pre codeblock"><code>import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.*;
import javax.xml.crypto.dsig.spec.*;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.security.*;
import java.util.List;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;

/**
 * This is a simple example of generating an Enveloped XML
 * Signature using the Java XML Digital Signature API. The
 * resulting signature will look like (key and signature
 * values will be different):
 *
 * &lt;pre&gt;&lt;code&gt;
 *&lt;Envelope xmlns="urn:envelope"&gt;
 * &lt;Signature xmlns="http://www.w3.org/2000/09/xmldsig#"&gt;
 *   &lt;SignedInfo&gt;
 *     &lt;CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/&gt;
 *     &lt;SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/&gt;
 *     &lt;Reference URI=""&gt;
 *       &lt;Transforms&gt;
 *         &lt;Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/&gt;
 *       &lt;/Transforms&gt;
 *       &lt;DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/&gt;
 *       &lt;DigestValue&gt;/juoQ4bDxElf1M+KJauO20euW+QAvvPP0nDCruCQooM=&lt;DigestValue&gt;
 *     &lt;/Reference&gt;
 *   &lt;/SignedInfo&gt;
 *   &lt;SignatureValue&gt;
 *     YeS+F0uiYv0h946M69Q9pKFNnD6dxUwLA8QT3GX/0H3cSPKRnNFyZiR4RPgaA1ir/ztb4rt6Lqb8
 *     hgwPERIa5qhoGUJyHDfUTcQ0Xqn1jYCVoC3ho+oUgJPXNVgtMAtpvOgxcWXUPATYdyimO6RrHF8+
 *     JXDkeICI9BPA4NKN1i77CAy6JJbaA87aNIpMJPImwJf8CM7mYsXremZz+RsafNE2cXXRzAoNOynC
 *     pi4oPYpE7CBLzhd23gf7zYRoyT06/bVIj4j3qOlVY1TQofsQ20NtAz6PbqAs7QkNoDzkX1CYlDSJ
 *     U8cGHuwXpul/UIpOiL6MZF8I/YI4ZlJn+O8Mvg==
 *   &lt;/SignatureValue&gt;
 *   &lt;KeyInfo&gt;
 *     &lt;KeyValue&gt;
 *       &lt;RSAKeyValue&gt;
 *         &lt;Modulus&gt;
 *           mH0S/iw2K2tFTFHI75BtB67pzjR52HvQ8K7Xi5UX3NJm0oA+KX2mm0IrVcUuv609vbAAyQoW7CWm
 *           4kswVgStCm68dlw36309cxrEmPhG+PKBmUaGuBmRzwityjXRyRZJ6yaLenE8SJO/DC5ntQvmHqQQ
 *           qeOJYvz2Cbi2bi6x9XwmpqOfZCE5iTvYwioEsrglhP1uLG9fiXyNR2PXUTyLqD91HLhZFj1CEiU7
 *           aE++WfkKaowIx5p8e3F6hQ+VFRNXjtemK5aajuL0gwU+Oujg9ijgbyMh19vBoI8LruJoMOBrYFNN
 *           2boQJ3wP0Ek7CPIqAzQB5MnmvKc9jICKiiZVZw==
 *         &lt;/Modulus&gt;
 *         &lt;Exponent&gt;AQAB&lt;/Exponent&gt;
 *       &lt;/RSAKeyValue&gt;
 *     &lt;/KeyValue&gt;
 *   &lt;/KeyInfo&gt;
 * &lt;/Signature&gt;
 *&lt;/Envelope&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 */
public class GenEnveloped {

    //
    // Synopsis: java GenEnveloped [document] [output]
    //
    //    where "document" is the name of a file containing the XML document
    //    to be signed, and "output" is the name of the file to store the
    //    signed document. The 2nd argument is optional - if not specified,
    //    standard output will be used.
    //
    public static void main(String[] args) throws Exception {
    	
        // Instantiate the document to be signed
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        Document doc = null;
        try (FileInputStream fis = new FileInputStream(args[0])) {
            doc = dbf.newDocumentBuilder().parse(fis);
        }
        
        // Create a RSA KeyPair
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);
        KeyPair kp = kpg.generateKeyPair();
        
        // Create a DOMSignContext and specify the RSA PrivateKey and
        // location of the resulting XMLSignature's parent element
        DOMSignContext dsc = new DOMSignContext
            (kp.getPrivate(), doc.getDocumentElement());
      
        // Create a DOM XMLSignatureFactory that will be used to generate the
        // enveloped signature
        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");

        // Create a Reference to the enveloped document (in this case we are
        // signing the whole document, so a URI of "" signifies that) and
        // also specify the SHA256 digest algorithm and the ENVELOPED Transform.
        Reference ref = fac.newReference
            ("", fac.newDigestMethod(DigestMethod.SHA256, null),
             List.of
              (fac.newTransform
                (Transform.ENVELOPED, (TransformParameterSpec) null)),
             null, null);

        // Create the SignedInfo
        SignedInfo si = fac.newSignedInfo
            (fac.newCanonicalizationMethod
             (CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,
              (C14NMethodParameterSpec) null),
             fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256", null),
             List.of(ref));

        // Create a KeyValue containing the RSA PublicKey that was generated
        KeyInfoFactory kif = fac.getKeyInfoFactory();
        KeyValue kv = kif.newKeyValue(kp.getPublic());

        // Create a KeyInfo and add the KeyValue to it
        KeyInfo ki = kif.newKeyInfo(List.of(kv));

        // Create the XMLSignature (but don't sign it yet)
        XMLSignature signature = fac.newXMLSignature(si, ki);

        // Marshal, generate (and sign) the enveloped signature
        signature.sign(dsc);

        // output the resulting document
        OutputStream os;
        if (args.length &gt; 1) {
           os = new FileOutputStream(args[1]);
        } else {
           os = System.out;
        }

        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer trans = tf.newTransformer();
        trans.transform(new DOMSource(doc), new StreamResult(os));
    }
}</code></pre>
 */
public class GenEnveloped {

    //
    // Synopsis: java GenEnveloped [document] [output]
    //
    //    where "document" is the name of a file containing the XML document
    //    to be signed, and "output" is the name of the file to store the
    //    signed document. The 2nd argument is optional - if not specified,
    //    standard output will be used.
    //
    public static void main(String[] args) throws Exception {
    	
        // Instantiate the document to be signed
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        Document doc = null;
        try (FileInputStream fis = new FileInputStream(args[0])) {
            doc = dbf.newDocumentBuilder().parse(fis);
        }
        
        // Create a RSA KeyPair
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);
        KeyPair kp = kpg.generateKeyPair();
        
        // Create a DOMSignContext and specify the RSA PrivateKey and
        // location of the resulting XMLSignature's parent element
        DOMSignContext dsc = new DOMSignContext
            (kp.getPrivate(), doc.getDocumentElement());
      
        // Create a DOM XMLSignatureFactory that will be used to generate the
        // enveloped signature
        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");

        // Create a Reference to the enveloped document (in this case we are
        // signing the whole document, so a URI of "" signifies that) and
        // also specify the SHA256 digest algorithm and the ENVELOPED Transform.
        Reference ref = fac.newReference
            ("", fac.newDigestMethod(DigestMethod.SHA256, null),
             List.of
              (fac.newTransform
                (Transform.ENVELOPED, (TransformParameterSpec) null)),
             null, null);

        // Create the SignedInfo
        SignedInfo si = fac.newSignedInfo
            (fac.newCanonicalizationMethod
             (CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,
              (C14NMethodParameterSpec) null),
             fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256", null),
             List.of(ref));

        // Create a KeyValue containing the RSA PublicKey that was generated
        KeyInfoFactory kif = fac.getKeyInfoFactory();
        KeyValue kv = kif.newKeyValue(kp.getPublic());

        // Create a KeyInfo and add the KeyValue to it
        KeyInfo ki = kif.newKeyInfo(List.of(kv));

        // Create the XMLSignature (but don't sign it yet)
        XMLSignature signature = fac.newXMLSignature(si, ki);

        // Marshal, generate (and sign) the enveloped signature
        signature.sign(dsc);

        // output the resulting document
        OutputStream os;
        if (args.length > 1) {
           os = new FileOutputStream(args[1]);
        } else {
           os = System.out;
        }

        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer trans = tf.newTransformer();
        trans.transform(new DOMSource(doc), new StreamResult(os));
    }
}</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1152D2A5-ECBB-4727-9B0F-1941E4171108__GUID-EB71567E-2E84-4301-98EC-65664665A996">
                        <p class="titleinexample">示例12-5信封</p><pre class="pre codeblock"><code>&lt;Envelope xmlns="urn:envelope"&gt;
&lt;/Envelope&gt;
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div class="sect4"><a id="GUID-177088CC-2CFD-477D-BB05-E8B9C48AE270" name="GUID-177088CC-2CFD-477D-BB05-E8B9C48AE270"></a><h5 id="JSSEC-GUID-177088CC-2CFD-477D-BB05-E8B9C48AE270" class="sect5">生成XML签名</h5>
                     <div>
                        <p></p>
                        <p>本示例说明如何使用XML数字签名API生成XML签名。更具体地说，该示例生成XML文档的封装XML签名。信封签名是包含在其签名内容内的签名。该示例使用DOM（文档对象模型）来解析要签名的XML文档，并使用DOM实现来生成结果签名。</p>
                        <p>XML签名及其不同组件的基本知识有助于理解本节。有关更多信息，请参见<a href="https://www.w3.org/TR/xmldsig-core/" target="_blank">XML签名语法和处理版本1.1</a> 。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-37E2785A-6ACD-4E09-9A72-4F6AE9A641D9" name="GUID-37E2785A-6ACD-4E09-9A72-4F6AE9A641D9"></a><h5 id="JSSEC-GUID-37E2785A-6ACD-4E09-9A72-4F6AE9A641D9" class="sect5">实例化要签名的文档</h5>
                     <div>
                        <p></p>
                        <p>首先，我们使用JAXP <span class="apiname">DocumentBuilderFactory</span>解析要签名的XML文档。应用程序通过调用以下代码行来获取<span class="apiname">DocumentBuilderFactory</span>的默认实现：</p><pre class="pre codeblock"><code>    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</code></pre><p>我们还必须使工厂知道名称空间：</p><pre class="pre codeblock"><code>    dbf.setNamespaceAware(true);</code></pre><p>接下来，我们使用工厂获取<span class="apiname">DocumentBuilder</span>的实例，该实例用于解析文档：</p><pre class="pre codeblock"><code>    Document doc = null;
    try (FileInputStream fis = new FileInputStream(args[0])) {
        doc = dbf.newDocumentBuilder().parse(fis);
    }</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-A0C0D616-CD13-441C-A1A2-122431692B9F" name="GUID-A0C0D616-CD13-441C-A1A2-122431692B9F"></a><h5 id="JSSEC-GUID-A0C0D616-CD13-441C-A1A2-122431692B9F" class="sect5">创建公钥对</h5>
                     <div>
                        <p></p>
                        <p>我们生成一个公共密钥对。在示例的后面，我们将使用私钥生成签名。我们使用<span class="apiname">KeyPairGenerator</span>创建密钥对。在此示例中，我们将创建一个2048个字节长度的RSA <span class="apiname">KeyPair</span> ：</p><pre class="pre codeblock"><code>    KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
    kpg.initialize(2048);
    KeyPair kp = kpg.generateKeyPair();</code></pre><p>实际上，私钥通常是事先生成的，并与相关的公钥证书一起存储在<span class="apiname">KeyStore</span>文件中。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2FA5FBA6-8DB7-460D-BDEA-2BF38B14BC19" name="GUID-2FA5FBA6-8DB7-460D-BDEA-2BF38B14BC19"></a><h5 id="JSSEC-GUID-2FA5FBA6-8DB7-460D-BDEA-2BF38B14BC19" class="sect5">创建签名上下文</h5>
                     <div>
                        <p></p>
                        <p>我们创建一个<span class="apiname">XMLSignContext，</span>其中包含用于生成签名的输入参数。由于我们正在使用DOM，因此我们实例化了<span class="apiname">DOMSignContext</span> （ <span class="apiname">XMLSignContext</span>的子类），并向其传递两个参数，即用于签名文档的私钥和要签名的文档的根：</p><pre class="pre codeblock"><code>    DOMSignContext dsc = new DOMSignContext
        (kp.getPrivate(), doc.getDocumentElement());</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-3DEB54D1-220A-4140-832D-DD42976057B6" name="GUID-3DEB54D1-220A-4140-832D-DD42976057B6"></a><h5 id="JSSEC-GUID-3DEB54D1-220A-4140-832D-DD42976057B6" class="sect5">组装XML签名</h5>
                     <div>
                        <p></p>
                        <p>我们将Signature元素的不同部分组装到<span class="apiname">XMLSignature</span>对象中。这些对象都是使用<span class="apiname">XMLSignatureFactory</span>对象创建和组装的。应用程序通过调用以下代码行来获取<span class="apiname">XMLSignatureFactory</span>的DOM实现：</p><pre class="pre codeblock"><code>    XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");</code></pre><p>然后，我们调用各种工厂方法来创建<span class="apiname">XMLSignature</span>对象的不同部分，如下所示。我们创建一个<span class="apiname">Reference</span>对象，并将以下内容传递给它：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要签名的对象的URI（我们将URI指定为“”，这表示文档的根。）</p>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="apiname">DigestMethod</span> （我们使用SHA256）</p>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>封装的签名需要一个<span class="apiname">Transform</span> （封装的<span class="apiname">Transform）</span> ，以便在计算签名值之前删除签名本身。</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>    Reference ref = fac.newReference
        ("", fac.newDigestMethod(DigestMethod.SHA256, null),
         List.of
          (fac.newTransform
            (Transform.ENVELOPED, (TransformParameterSpec) null)),
         null, null);</code></pre><p>接下来，我们创建<span class="apiname">SignedInfo</span>对象，该对象是实际签名的对象，如下所示。创建<span class="apiname">SignedInfo时</span> ，我们作为参数传递：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="apiname">CanonicalizationMethod</span> （我们使用包容性并保留注释）</p>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="apiname">SignatureMethod</span> （我们使用RSA）</p>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="apiname">引用</span>列表（在这种情况下，只有一个）</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>    SignedInfo si = fac.newSignedInfo
        (fac.newCanonicalizationMethod
         (CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,
          (C14NMethodParameterSpec) null),
         fac.newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256", null),
         List.of(ref));</code></pre><p>接下来，我们创建可选的<span class="apiname">KeyInfo</span>对象，该对象包含使接收者能够找到验证签名所需的密钥的信息。在此示例中，我们添加了一个包含公钥的<span class="apiname">KeyValue</span>对象。为了创建<span class="apiname">KeyInfo</span>及其各种子类型，我们使用<span class="apiname">KeyInfoFactory</span>对象，可以通过调用<span class="italic">XMLSignatureFactory</span>的<span class="apiname">getKeyInfoFactory</span>方法来获得该对象，如下所示：</p><pre class="pre codeblock"><code>    KeyInfoFactory kif = fac.getKeyInfoFactory();</code></pre><p>然后，我们使用<span class="apiname">KeyInfoFactory</span>创建<span class="apiname">KeyValue</span>对象并将其添加到<span class="apiname">KeyInfo</span>对象中：</p><pre class="pre codeblock"><code>    KeyValue kv = kif.newKeyValue(kp.getPublic());
    KeyInfo ki = kif.newKeyInfo(List.of(kv));</code></pre><p>最后，我们创建<span class="apiname">XMLSignature</span>对象，并将我们之前创建的<span class="apiname">SignedInfo</span>和<span class="apiname">KeyInfo</span>对象作为参数传递：</p><pre class="pre codeblock"><code>    XMLSignature signature = fac.newXMLSignature(si, ki);</code></pre><p>注意，我们实际上还没有生成签名。我们将在下一步中进行。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3B6E8DE8-AC10-46B2-BC89-9E0B2CE8634C" name="GUID-3B6E8DE8-AC10-46B2-BC89-9E0B2CE8634C"></a><h5 id="JSSEC-GUID-3B6E8DE8-AC10-46B2-BC89-9E0B2CE8634C" class="sect5">生成XML签名</h5>
                     <div>
                        <p></p>
                        <p>现在我们准备生成签名，可以通过在<span class="apiname">XMLSignature</span>对象上调用sign方法并将其传递给签名上下文来完成，如下所示：</p><pre class="pre codeblock"><code>    signature.sign(dsc);</code></pre><p></p>
                        <p>现在，生成的文档包含一个签名，该签名已作为根元素的最后一个子元素插入。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1D6C3745-9E04-400A-ADD1-65E5FD3ADB5C" name="GUID-1D6C3745-9E04-400A-ADD1-65E5FD3ADB5C"></a><h5 id="JSSEC-GUID-1D6C3745-9E04-400A-ADD1-65E5FD3ADB5C" class="sect5">打印或显示结果文档</h5>
                     <div>
                        <p></p>
                        <p>您可以使用以下代码将生成的签名文档打印到文件或标准输出中：</p><pre class="pre codeblock"><code>    OutputStream os;
    if (args.length &gt; 1) {
       os = new FileOutputStream(args[1]);
    } else {
       os = System.out;
    }

    TransformerFactory tf = TransformerFactory.newInstance();
    Transformer trans = tf.newTransformer();
    trans.transform(new DOMSource(doc), new StreamResult(os));</code></pre><p></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   

</body></html>