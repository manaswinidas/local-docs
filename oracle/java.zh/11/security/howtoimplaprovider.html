<html lang="en-us"  xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This document describes what you need to do in order to integrate your provider into Java SE so that algorithms and other services can be found when Java Security API clients request them.">
      <meta name="description" content="This document describes what you need to do in order to integrate your provider into Java SE so that algorithms and other services can be found when Java Security API clients request them.">
      <title>How to Implement a Provider in the Java Cryptography Architecture</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="This document describes what you need to do in order to integrate your provider into Java SE so that algorithms and other services can be found when Java Security API clients request them.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-cryptography-architecture-jca-reference-guide.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-providers.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-cryptography-architecture-jca-reference-guide.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="oracle-providers.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">如何在Java密码体系结构中实现提供者</li>
            </ol>
            <a id="GUID-C485394F-08C9-4D35-A245-1B82CDDBC031" name="GUID-C485394F-08C9-4D35-A245-1B82CDDBC031"></a>
            
            <h2 id="JSSEC-GUID-C485394F-08C9-4D35-A245-1B82CDDBC031" class="sect2"><span class="enumeration_chapter">3</span>如何在Java密码体系结构中实现提供者</h2>
         </header>
         <div class="ind">
            <div>
               <p>本文档介绍了将提供程序集成到Java SE时需要执行的操作，以便在Java Security API客户端请求它们时可以找到算法和其他服务。</p>
            </div>
            <div class="sect2"><a id="GUID-75AFEAAB-BDEE-4857-9637-9D72D6C42DED" name="GUID-75AFEAAB-BDEE-4857-9637-9D72D6C42DED"></a><h3 id="JSSEC-GUID-75AFEAAB-BDEE-4857-9637-9D72D6C42DED" class="sect3">谁应该阅读本文件</h3>
               <div>
                  <p></p>
                  <p>只需要使用Java安全API（见程序员<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F" title="以下是JCA中提供的核心类和接口。">核心类和接口</a>的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java加密体系结构（JCA）参考指南</a> ）访问现有的加密算法和其他服务都<span class="variable" translate="no">not</span>需要阅读本文件。
                  </p>
                  <p>本文档适用于希望创建自己的提供加密服务实现的提供程序包的经验丰富的程序员。它记录了将提供程序集成到Java中所需执行的操作，以便在Java Security API客户端请求它们时可以找到您的算法和其他服务。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-2D03228D-7B79-44F8-9D24-A3DCF71B12E4" name="GUID-2D03228D-7B79-44F8-9D24-A3DCF71B12E4"></a><h3 id="JSSEC-GUID-2D03228D-7B79-44F8-9D24-A3DCF71B12E4" class="sect3">术语说明</h3>
               <div>
                  <p>在整个文档中，术语<span class="variable" translate="no">JCA</span>本身是指JCA框架。只要本文记录了特定的JCA提供程序，就会以提供程序名称显式地引用它。
                  </p>
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>在JDK 1.4之前，JCE是非捆绑产品，因此，JCA和JCE通常被称为独立的不同组件。由于JCE现在捆绑在JDK中，因此区别变得不那么明显了。由于JCE使用与JCA相同的体系结构，因此应更恰当地将JCE视为JCA的子集。</li>
                        <li>JDK中的JCA包括两个软件组件：<ul style="list-style-type:disc">
                              <li>定义并支持提供者为其提供实现的加密服务的框架。该框架包括以下软件包： <code class="codeph">java.security</code> ， <code class="codeph">javax.crypto</code> ， <code class="codeph">javax.crypto.spec</code>和<code class="codeph">javax.crypto.interfaces</code> 。
                              </li>
                              <li>包含实际加密实现的实际提供程序，例如<span class="variable" translate="no">Sun</span> ， <span class="variable" translate="no">SunRsaSign</span> ， <span class="variable" translate="no">SunJCE</span> 。
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-42A646A7-E42A-4DA4-A84E-F4862510E3E8" name="GUID-42A646A7-E42A-4DA4-A84E-F4862510E3E8"></a><h3 id="JSSEC-GUID-42A646A7-E42A-4DA4-A84E-F4862510E3E8" class="sect3">实施提供者简介</h3>
               <div>
                  <p></p>
                  <p>Java平台定义了一组跨越主要安全领域的API，包括加密，公共密钥基础结构，身份验证，安全通信和访问控制。这些API使开发人员可以轻松地将安全性集成到其应用程序代码中。它们是按照以下原则设计的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">实现独立性</span> ：应用程序不需要自己实现安全性。相反，他们可以从Java平台请求安全服务。安全服务在提供程序中实现（请参见下文），这些提供程序通过标准接口插入到Java平台中。一个应用程序可能依赖多个独立的提供程序来提供安全功能。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">实现互操作性</span> ：提供程序可跨应用程序互操作。具体而言，应用程序未绑定到特定的提供程序，并且提供程序也未绑定到特定的应用程序。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">算法可扩展性</span> ：Java平台包括许多内置提供程序，这些提供程序实现了当今广泛使用的一组基本安全服务。但是，某些应用程序可能依赖于尚未实施的新兴标准或专有服务。Java平台支持安装实现此类服务的自定义提供程序。
                        </p>
                     </li>
                  </ul>
                  <p>加密服务提供者（提供者）是指一个包（或一组包），它提供JDK安全API的加密方面的子集的具体实现。</p>
                  <p><span class="apiname">java.security。Provider</span>类在Java平台中封装了安全提供程序的概念。它指定了提供者的名称并列出了它实现的安全服务。可以同时配置多个提供程序，并按优先顺序列出。当请求安全服务时，将选择实现该服务的最高优先级提供程序。请参阅“ <a href="java-security-overview1.html#GUID-74E1EFEA-F1DD-466C-B61A-CB5E89FA50DE" title="java.security。Provider类在Java平台中封装了安全提供程序的概念。它指定了提供者的名称并列出了它实现的安全服务。可以同时配置多个提供程序，并按优先顺序列出。当请求安全服务时，将选择实现该服务的最高优先级提供程序。">安全提供程序”</a> ，其中说明了提供程序如何选择请求的安全服务。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B35E3749-0A12-42C3-BA0B-C444D7E140BB" name="GUID-B35E3749-0A12-42C3-BA0B-C444D7E140BB"></a><h3 id="JSSEC-GUID-B35E3749-0A12-42C3-BA0B-C444D7E140BB" class="sect3">引擎类和相应的服务提供者接口类</h3>
               <div>
                  <p>引擎类以抽象方式（没有具体实现）定义加密服务。加密服务始终与特定算法或类型相关联。</p>
                  <p><span class="variable" translate="no">cryptographic service</span>要么提供加密操作（例如用于数字签名或消息摘要，密码或密钥协商协议的操作），要么提供加密操作。生成或提供加密操作所需的加密材料（密钥或参数）；或生成以安全方式封装加密密钥（可以在加密操作中使用）的数据对象（密钥库或证书）。
                  </p>
                  <p>例如，这是四个引擎类：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">Signature</code>类提供对数字签名算法功能的访问。
                     </li>
                     <li>DSA <code class="codeph">KeyFactory</code>类以DSA签名对象的initSign或initVerify方法分别可用的格式提供DSA私钥或公钥（来自其编码或透明规范）。
                     </li>
                     <li><code class="codeph">Cipher</code>类提供对加密算法（例如AES）功能的访问</li>
                     <li><code class="codeph">KeyAgreement</code>类提供对密钥协议协议（例如Diffie-Hellman）功能的访问</li>
                  </ul>
                  <p>Java密码体系结构包含包含与密码学相关的Security包的类，包括引擎类。API的用户请求并利用引擎类的实例来执行相应的操作。JDK定义了以下引擎类：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph">MessageDigest</code> -用于计算指定数据的消息摘要（哈希）。
                     </li>
                     <li><code class="codeph">Signature</code> -用于签名数据和验证数字签名。
                     </li>
                     <li><code class="codeph">KeyPairGenerator</code> -用于生成适用于指定算法的一对公钥和私钥。
                     </li>
                     <li><code class="codeph">KeyFactory</code> -用于转换类型不透明的加密密钥<code class="codeph">Key</code>转换成<span class="variable" translate="no">key specifications</span> （底层关键材料的透明表示），反之亦然。
                     </li>
                     <li><code class="codeph">KeyStore</code> -用于创建和管理<span class="variable" translate="no">keystore</span> 。密钥库是密钥的数据库。密钥库中的私钥具有与其关联的证书链，该证书链对相应的公钥进行身份验证。密钥库还包含来自受信任实体的证书。
                     </li>
                     <li><code class="codeph">CertificateFactory</code> -用于创建公钥证书和证书吊销列表（CRL）。
                     </li>
                     <li><code class="codeph">AlgorithmParameters</code> -用于管理特定算法的参数，包括参数编码和解码。
                     </li>
                     <li><code class="codeph">AlgorithmParameterGenerator</code> -用于生成适用于指定算法的一组参数。
                     </li>
                     <li><code class="codeph">SecureRandom</code> -用于生成随机或伪随机数。
                     </li>
                     <li><code class="codeph">Cipher</code> -用于加密或解密某些指定数据。
                     </li>
                     <li><code class="codeph">KeyAgreement</code> -用于在2个或更多方之间执行密钥协议（密钥交换）协议。
                     </li>
                     <li><code class="codeph">KeyGenerator</code> -用于生成适合于指定算法的秘密（对称）密钥。
                     </li>
                     <li><code class="codeph">Mac</code> ：用于计算某些指定数据的<span class="variable" translate="no">message authentication code</span> 。
                     </li>
                     <li><code class="codeph">SecretKeyFactory</code> -用于转换类型不透明的加密密钥<code class="codeph">SecretKey</code>转换成<span class="variable" translate="no">key specifications</span> （底层关键材料的透明表示），反之亦然。
                     </li>
                     <li><code class="codeph">CertPathBuilder</code> -用于创建公钥证书和证书吊销列表（CRL）。
                     </li>
                     <li><code class="codeph">CertPathValidator</code> -用于验证证书链。
                     </li>
                     <li><code class="codeph">CertStore</code> -用于从存储库中检索证书和CRL。
                     </li>
                     <li><code class="codeph">ExemptionMechanism</code> -用于提供豁免机制的功能，例如<span class="variable" translate="no">key recovery</span> ， <span class="variable" translate="no">key weakening</span> ， <span class="variable" translate="no">key escrow</span>或任何其他（自定义）豁免机制。使用免除机制的应用程序或小应用程序可能比不使用免除机制的应用程序或小应用程序具有更强的加密功能。但是，请注意，大多数国家不再需要密码限制，因此豁免机制仅在政府要求限制的少数国家中有用。
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-B35E3749-0A12-42C3-BA0B-C444D7E140BB__GUID-4ADAF14D-B1E3-451D-9708-F21608DCC42A">
                     <p class="notep1">注意：</p><span class="variable" translate="no">generator</span>创建具有全新内容的对象，而<span class="variable" translate="no">factory</span>使用现有材料（例如，编码）创建对象。
                  </div>
                  <p><span class="variable" translate="no">engine</span>类为特定类型的密码服务（独立于特定的密码算法）的功能提供了接口。它定义了<span class="variable" translate="no">Application Programming Interface</span> （API）方法，该方法允许应用程序访问其提供的特定类型的密码服务。实际的实现（来自一个或多个提供程序）是针对特定算法的实现。例如，签名引擎类提供对数字签名算法功能的访问。实际提供的内容<code class="codeph">SignatureSpi</code>子类（请参阅下一段）将是针对特定种类的签名算法的子类，例如SHA256withDSA或SHA512withRSA。</p>
                  <p>引擎类提供的应用程序接口是根据<span class="bold">服务提供商接口（SPI）来实现的</span> 。也就是说，对于每个引擎类，都有一个对应的抽象SPI类，它定义了密码服务提供者必须实现的服务提供者接口方法。
                  </p>
                  <div class="figure" id="GUID-B35E3749-0A12-42C3-BA0B-C444D7E140BB__GUID-FD9BD684-1D1B-4621-A7A1-4732D79AB756">
                     <p class="titleinfigure">图3-1引擎类</p><img src="img/architecture-service-provider-interface.gif" alt="如下图3-1所示" title="如下图3-1所示" longdesc="img_text/architecture-service-provider-interface.html"><br><a href="img_text/architecture-service-provider-interface.html">“图3-1引擎类”的描述</a></div>
                  <!-- class="figure" -->
                  <p>引擎类的实例“ API对象”封装（作为私有字段）相应的SPI类的实例“ SPI对象”。API对象的所有API方法都声明为“最终”，其实现调用封装的SPI对象的相应SPI方法。通过调用引擎类的<span class="apiname">getInstance</span>工厂方法来创建引擎类（及其对应的SPI类）的实例。
                  </p>
                  <p>每个SPI类的名称与相应引擎类的名称相同，后跟“ Spi”。例如，与签名引擎类相对应的SPI类是<code class="codeph">SignatureSpi</code>类。
                  </p>
                  <p>每个SPI类都是抽象的。为了提供特定类型的服务和特定算法的实现，提供程序必须子类化相应的SPI类，并提供所有抽象方法的实现。</p>
                  <p>引擎类的另一个示例是<code class="codeph">MessageDigest</code>类，提供对消息摘要算法的访问。其实现，在<code class="codeph">MessageDigestSpi</code>子类可能是各种消息摘要算法的子类，例如SHA256或SHA384。
                  </p>
                  <p>最后一个例子是<code class="codeph">KeyFactory</code>引擎类支持从不透明键到透明键规范的转换，反之亦然。请参阅<a href="howtoimplaprovider.html#GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6" title="密钥工厂提供了不透明密钥（类型为Key）和密钥规范之间的双向转换。如果实施密钥工厂，则需要了解和利用密钥规范。在某些情况下，您还需要实现自己的密钥规范。">关键工厂所需的关键规范接口和类</a> 。实际提供的内容<code class="codeph">KeyFactorySpi</code>子类将是特定类型的密钥的子类，例如DSA公共密钥和私有密钥。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-CC161921-EBD2-48C6-B543-A956658B68B6" name="GUID-CC161921-EBD2-48C6-B543-A956658B68B6"></a><h3 id="JSSEC-GUID-CC161921-EBD2-48C6-B543-A956658B68B6" class="sect3">实施和集成提供商的步骤</h3>
               <div>
                  <p>请遵循以下步骤来实现提供程序并将其集成到JCA框架中：</p>
                  <ul style="list-style-type:disc">
                     <li><a href="howtoimplaprovider.html#GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" title="当实例化提供者的Cipher，KeyAgreement，KeyGenerator，MAC或SecretKey工厂的实现（类）时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。">步骤1：编写您的服务实现代码</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE">步骤2：为您的提供商命名</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" title="创建java.security的子类。提供程序类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。">步骤3：编写您的主类，提供者的子类</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。">步骤4：为您的提供商创建模块声明</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-83742677-6E39-4A8D-BF0F-BC743E3AE43C">步骤5：编译代码</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">步骤6：将您的提供者放置在JAR文件中</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-2D4432F9-1C3C-4A91-8612-2B2840188B36">步骤7：如有必要，对您的JAR文件签名</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" title="后续步骤描述了如何安装和配置新的提供程序，以便可以通过JCA使用它。">步骤8：准备测试</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0" title="编写并编译一个或多个测试程序，以测试您的提供商是否已纳入安全性API以及其算法的正确性。创建所需的任何支持文件，例如用于加密测试数据的文件。">步骤9：编写和编译测试程序</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-3FD26072-6982-4DCE-932C-DE152C463992" title="在运行测试应用程序时，所需的java命令选项会因各种因素而异，例如您是否将提供程序打包为命名，自动或未命名模块，以及是否配置了它以便ServiceLoader类可以搜索它。">步骤10：运行测试程序</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E" title="所有其供应商可能会出口到美国以外的美国供应商，都应向美国商务部工业与安全局申请出口批准。">步骤11：如有需要，申请美国政府出口批准</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245">步骤12：记录您的提供商及其支持的服务</a></li>
                     <li><a href="howtoimplaprovider.html#GUID-3521E2A8-93B5-4D0F-AE2D-DC1B5E6857B7" title="在编写，配置，测试，安装和记录提供程序软件之后，请向客户提供文档。">步骤13：使您的类文件和文档对客户端可用</a></li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" name="GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A"></a><h4 id="JSSEC-GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" class="sect4">步骤1：编写您的服务实现代码</h4>
                  <div>
                     <div class="section">
                        <p>您需要做的第一件事是编写代码，以提供要支持的加密服务的特定于算法的实现。您的提供商可能会提供JDK的一个或多个安全组件中已经可用的加密服务的实现。</p>
                        <p>对于JCA中未定义的加密服务（例如，签名和消息摘要），请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和算法</a> 。
                        </p>
                        <p>对于要实现的每个加密服务，请创建适当的SPI类的子类。JCA定义了以下引擎类：</p>
                        <ul style="list-style-type:disc">
                           <li><code class="codeph">SignatureSpi</code></li>
                           <li><code class="codeph">MessageDigestSpi</code></li>
                           <li><code class="codeph">KeyPairGeneratorSpi</code></li>
                           <li><code class="codeph">SecureRandomSpi</code></li>
                           <li><code class="codeph">AlgorithmParameterGeneratorSpi</code></li>
                           <li><code class="codeph">AlgorithmParametersSpi</code></li>
                           <li><code class="codeph">KeyFactorySpi</code></li>
                           <li><code class="codeph">CertificateFactorySpi</code></li>
                           <li><code class="codeph">KeyStoreSpi</code></li>
                           <li><code class="codeph">CipherSpi</code></li>
                           <li><code class="codeph">KeyAgreementSpi</code></li>
                           <li><code class="codeph">KeyGeneratorSpi</code></li>
                           <li><code class="codeph">MacSpi</code></li>
                           <li><code class="codeph">SecretKeyFactorySpi</code></li>
                           <li><code class="codeph">ExemptionMechanismSpi</code></li>
                        </ul>
                        <p>要了解有关JCA和其他加密类的更多信息，请参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="引擎类提供了到特定类型的密码服务的接口，而与特定的密码算法或提供者无关。">引擎类和相应的服务提供者接口类</a> 。
                        </p>
                        <p>在子类中，您需要：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>提供抽象方法的实现，这些抽象方法的名称通常以<code class="codeph">engine</code> 。请参阅<a href="howtoimplaprovider.html#GUID-C8B79D46-6EA9-4E27-8083-7CB967732BB3" title="本节提供有关别名，服务相互依赖性，算法参数生成器和算法参数的其他信息。">进一步的实现细节和要求</a> 。</span></li>
                        <li><span>取决于您编写提供程序和注册其算法的方式（使用<span class="apiname">String</span>对象或<span class="apiname">Provider。服务</span>类），提供者可以：</span><ul>
                              <li>确保有一个没有任何参数的公共构造函数。原因如下：当请求您的一项服务时，Java安全性将根据实现您的“主类”中的属性所指定的服务，来查找实现该服务的子类（请参阅<a href="howtoimplaprovider.html#GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" title="创建java.security的子类。提供程序类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。">步骤3：编写主类，Provider的子类</a> ）。然后，Java Security将创建<code class="codeph">Class</code>与您的子类相关联的对象，并通过调用<code class="codeph">newInstance</code>那个方法<code class="codeph">Class</code>宾语。 <code class="codeph">newInstance</code>要求您的子类具有不带任何参数的公共构造函数。（如果您的子类没有任何构造函数，则会自动生成一个不带参数的默认构造函数。但是，如果您的子类定义了任何构造函数，则必须显式定义不带参数的公共构造函数。）
                              </li>
                              <li>覆盖已注册的<span class="apiname">Provider中的<span class="apiname">newInstance（）</span>方法<span class="apiname">。服务</span> 。这是JDK 9和更高版本中的首选机制。
                              </span></li>
                           </ul>
                        </li>
                     </ol>
                  </div>
                  <div class="sect4"><a id="GUID-AEE5234F-24F1-4899-B490-C79F0C2D8D59" name="GUID-AEE5234F-24F1-4899-B490-C79F0C2D8D59"></a><h5 id="JSSEC-GUID-AEE5234F-24F1-4899-B490-C79F0C2D8D59" class="sect5">步骤1.1：考虑其他JCA Provider要求和加密实施建议</h5>
                     <div>
                        <p>实例化提供者的实现时（类） <code class="codeph">Cipher</code> ， <code class="codeph">KeyAgreement</code> ， <code class="codeph">KeyGenerator</code> ， <code class="codeph">MAC</code> ， 要么<code class="codeph">SecretKey</code>出厂时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。
                        </p>
                        <div class="section">
                           <p>为了使提供程序类在直接由应用程序实例化时变得不可用，绕过JCA，提供程序应实现以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>提供程序包中的所有SPI实现类都应声明为<code class="codeph">final</code> （以便它们不能被子类化），并且应该声明其（SPI）实现方法<code class="codeph">protected</code> 。
                              </li>
                              <li>提供程序包中的所有与加密相关的帮助程序类都应具有程序包私有范围，以便无法从提供程序包外部访问它们。</li>
                           </ul>
                           <p>对于可能出口到美国以外的提供商， <code class="codeph">CipherSpi</code>实现必须包括<code class="codeph">engineGetKeySize</code>给定一个<code class="codeph">Key</code> ，返回密钥大小。如果在权限策略文件中指定了对可用密码强度的限制，则每个<code class="codeph">Cipher</code>初始化方法调用<code class="codeph">engineGetKeySize</code>然后将结果与运行Applet或应用程序的特定位置和环境的最大允许密钥大小进行比较。如果密钥大小太大，则初始化方法将引发异常。
                           </p>
                           <p>提供者可以实现的其他<span class="variable" translate="no">optional</span>功能是：</p>
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li><strong>可选</strong> <span><strong>：</strong> <code class="codeph">engineWrap</code>和<code class="codeph">engineUnwrap</code>方法<code class="codeph">CipherSpi</code> 。包装钥匙可以将钥匙从一个地方安全地转移到另一个地方。有关包装键和展开键的信息，请参见<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/Cipher.html#wrap-java.security.Key-" target="_blank"><code class="codeph">wrap</code></a> 。</span></li>
                           <li><strong>可选：</strong> <span>一种或多种<span class="variable" translate="no">exemption mechanisms</span> 。豁免机制是诸如密钥恢复，密钥托管或密钥弱化之类的机制，如果实施和实施，则可以为使用它的应用程序（或applet）提供减少的密码限制。要了解有关使用豁免机制的应用程序要求的更多信息，请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">如何使应用程序不受密码限制</a> 。</span></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE" name="GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE"></a><h4 id="JSSEC-GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE" class="sect4">步骤2：为您的提供商命名</h4>
                  <div>
                     <p>为您的提供商确定一个唯一的名称。这是客户端应用程序用来引用您的提供程序的名称，并且不得与任何其他提供程序名称冲突。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" name="GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46"></a><h4 id="JSSEC-GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" class="sect4">步骤3：编写您的主类，提供者的子类</h4>
                  <div>
                     <p>创建一个子类<code class="codeph">java.security.Provider</code>类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。
                     </p>
                     <div class="section">
                        <p>您可以使用以下编码样式来对<span class="apiname">Provider</span>类进行子类化：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>创建一个提供程序，将其服务注册到<span class="apiname">String</span>对象，以存储算法名称及其关联的实现类名称。这些存储在<span class="apiname">哈希表中<object,object></object,object></span> <span class="apiname">java.security的超类<span class="apiname">。提供者</span> 。
                              </span></p>
                           </li>
                           <li>
                              <p>创建一个使用<span class="apiname">提供程序的提供程序。服务</span>类，它使用不同的方法来存储算法名称并创建新对象。<span class="apiname">提供者。服务</span>类使您可以自定义JCE框架如何向您的提供程序请求服务，例如，框架如何创建提供程序的服务的新实例。建议使用这种编码样式，尤其是在使用模块时。
                              </p>
                           </li>
                        </ul>
                        <p>提供程序可以使用任何一种样式，甚至可以同时使用两种样式。无论选择哪种样式，您的子类都应该是<code class="codeph">final</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE" name="GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE"></a><h5 id="JSSEC-GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE" class="sect5">步骤3.1：创建使用字符串对象注册其服务的提供程序</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>以下是使用<span class="apiname">String</span>对象存储实现的算法名称的提供程序的示例：</p><pre class="pre codeblock"><code>package p;
public final class MyProvider extends Provider {
    public MyProvider() {
        super("MyProvider", "1.0",
            "Some info about my provider and which algorithms it supports");
        // com.my.crypto.provider.MyCipher extends CipherSPI
        put("Cipher.MyCipher", "com.my.crypto.provider.MyCipher");
    }
}</code></pre><p>要使用这种编码样式创建提供程序，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>呼叫<code class="codeph">super</code> ，指定提供程序名称（请参阅<a href="howtoimplaprovider.html#GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE">步骤2：为您的提供程序提供名称</a> ）版本号，以及有关提供程序及其支持的算法的信息字符串。</span><div><pre class="codeblock"><code>   super("MyProvider", "1.0",
        "Some info about my provider and which algorithms it supports");
</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>设置Java安全性API所需的各种属性的值，以查找提供程序实现的加密服务。</span><div>
                                 <p>对于提供者实现的每个服务，必须有一个属性，其名称是服务的类型，后跟一个句点以及该服务所应用的算法的名称。该属性值必须指定实现服务的类的标准名称。</p>
                                 <p>例如，以下语句设置了一个名为<code class="codeph">Cipher.MyCypher</code>其值是<code class="codeph">com.my.crypto.provider.MyCipher</code> ，扩展了的类<code class="codeph">CipherSPI</code> ：</p><pre class="pre codeblock"><code>        put("Cipher.MyCipher", "com.my.crypto.provider.MyCipher");
</code></pre><p>以下列表显示了各种类型的JCA服务，其中实际的算法名称代替了<code class="codeph"><span class="variable" translate="no">algName</span></code> ：</p>
                                 <ul style="list-style-type:disc">
                                    <li><code class="codeph">Signature.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">MessageDigest.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">KeyPairGenerator.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">SecureRandom.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">AlgorithmParameterGenerator.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">AlgorithmParameters.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">KeyFactory.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">CertificateFactory.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">KeyStore.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">Cipher.<span class="variable" translate="no">algName</span></code> ： <code class="codeph"><span class="variable" translate="no">algName</span></code>可能实际上代表一个<span class="variable" translate="no">transformation</span> ，并且可能由算法名称，特定模式和填充方案组成。请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a></li>
                                    <li><code class="codeph">KeyAgreement.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">KeyGenerator.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">Mac.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">SecretKeyFactory.<span class="variable" translate="no">algName</span></code></li>
                                    <li><code class="codeph">ExemptionMechanism.<span class="variable" translate="no">algName</span></code> ： <code class="codeph"><span class="variable" translate="no">algName</span></code>指免除机制的名称，可以是以下之一： <code class="codeph">KeyRecovery</code> ， <code class="codeph">KeyEscrow</code> ， 要么<code class="codeph">KeyWeakening</code> 。案例也<span class="variable" translate="no">not</span>关系。
                                    </li>
                                 </ul>
                                 <p>在所有这些中，除了<code class="codeph">ExemptionMechanism</code>和<code class="codeph">Cipher</code> ， <code class="codeph">algName</code>是算法，证书类型或密钥库类型的“标准”名称。有关应使用的标准名称，请参见<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。
                                 </p>
                                 <p>每个属性的值必须是实现指定算法，证书类型或密钥库类型的类的标准名称。也就是说，它必须是包名，后跟类名，两者之间用句点分隔。</p>
                                 <p>例如，名为<span class="variable" translate="no">SUN</span>的默认提供程序实现了数字签名算法（其标准名称为<code class="codeph">SHA256withDSA</code> ）在名为<code class="codeph">DSA</code>在里面<code class="codeph">sun.security.provider</code>包。它的子类<code class="codeph">Provider</code> （这是<code class="codeph">sun.security.provider package</code> ）设置<code class="codeph">Signature.SHA256withDSA</code>具有价值的财产<code class="codeph">sun.security.provider.DSA</code>通过以下方式：</p><pre class="codeblock"><code>put("Signature.SHA256withDSA", "sun.security.provider.DSA")
</code></pre><p>下面的列表显示了可以为各种类型的服务定义的更多属性，其中，实际算法名称代替<span class="variable" translate="no">algName</span> ，证书类型代替<span class="variable" translate="no">certType,</span>密钥库类型代替<span class="variable" translate="no">storeType</span> ，属性名称代替<span class="variable" translate="no">attrName</span> ：</p>
                                 <ul style="list-style-type:disc">
                                    <li><code class="codeph">Signature.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">MessageDigest.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">KeyPairGenerator.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">SecureRandom.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">KeyFactory.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">CertificateFactory.certType <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">KeyStore.storeType <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">AlgorithmParameterGenerator.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">AlgorithmParameters.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">Cipher.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">KeyAgreement.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">KeyGenerator.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">Mac.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">SecretKeyFactory.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                    <li><code class="codeph">ExemptionMechanism.algName <span class="variable" translate="no">[one or more spaces]</span> attrName</code></li>
                                 </ul>
                                 <p>在每种情况下， <code class="codeph">attrName</code>是算法，证书类型，密钥库类型或属性的“标准”名称。（有关应使用的标准名称，请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。）
                                 </p>
                                 <p>对于上述格式的属性，该属性的值必须是对应属性的值。（有关每个标准属性的定义，请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全性标准算法名称</a> 。）
                                 </p>
                                 <p>有关其他主类属性设置示例，请参见<a class="new-window" href="http://www.oracle.com/pls/topic/lookup?ctx=javase11&id=sun_security_provider_sun"><span class="apiname">sun.security.provider的JDK源代码</span></a><a class="new-window" href="http://www.oracle.com/pls/topic/lookup?ctx=javase11&id=sun_security_provider_sun"><span class="apiname">。Sun</span></a>和<a class="new-window" href="http://www.oracle.com/pls/topic/lookup?ctx=javase11&id=com_sun_crypto_provider_sunjce"><span class="apiname">com.sun.crypto.provider。SunJCE</span></a>类。它们显示了Sun和SunJCE提供程序如何设置属性。
                                 </p>
                                 <p>举例来说，名为SUN的默认提供程序实现了<code class="codeph">SHA256withDSA</code>软件中的数字签名算法。类<span class="apiname">sun.security.provider。Sun</span>调用方法<span class="apiname">SunEntries.putEntries</span> ，该方法设置SUN提供程序的属性，包括设置属性。 <code class="codeph">Signature.SHA256withDSA ImplementedIn</code>具有价值<code class="codeph">Software</code> ：</p><pre class="codeblock"><code>    put("Signature.SHA256withDSA ImplementedIn", "Software");</code></pre><div class="infoboxnote" id="GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE__GUID-609B98BF-623E-457F-A8A5-EA3B62BCBA5D">
                                    <p class="notep1">注意：</p>有关此编码样式的示例，请参见<span class="apiname">sun.security.provider的源代码<span class="apiname">。Sun</span>和<span class="apiname">sun.security.provider。SunEntries</span>类。
                                 </span></div>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733" name="GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733"></a><h5 id="JSSEC-GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733" class="sect5">步骤3.2：创建使用提供程序的提供程序。服务</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>以下是使用<span class="apiname">提供程序的提供程序的示例<span class="apiname">。服务</span>等级：</span></p><pre class="pre codeblock"><code>package p;
&nbsp;
public final class MyProvider extends Provider {
    &nbsp;
    public MyProvider() {
        super("MyProvider", "1.0",
            "Some info about my provider and which algorithms it supports");
        putService(new ProviderService(this, "Cipher", "MyCipher", "p.MyCipher"));
    }
    &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;private static final class ProviderService extends Provider.Service {
    &nbsp;&nbsp;&nbsp;&nbsp;ProviderService(Provider p, String type, String algo, String cn) {
        &nbsp;&nbsp;&nbsp;&nbsp;super(p, type, algo, cn, null, null);
        }
        &nbsp;
        @Override
        public Object newInstance(Object ctrParamObj)
            throws NoSuchAlgorithmException {
            String type = getType();
            String algo = getAlgorithm();
            try {
                if (type.equals("Cipher")) {
                    if (algo.equals("MyCipher")) {
                        return new MyCipher();
                    }
                }
            } catch (Exception ex) {
                throw new NoSuchAlgorithmException(
                    "Error constructing " + type + " for "
                &nbsp;&nbsp;&nbsp;&nbsp;+ algo + " using SunMSCAPI", ex);
            }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ProviderException("No impl for " + algo + " " + type);
        }
    }
}</code></pre><p>要使用这种编码样式创建提供程序，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>对于提供程序支持的每种算法，请使用<span class="apiname">Provider的实例调用<span class="apiname">putService</span> <span class="apiname">。服务</span> ; <span class="apiname">提供程序的参数<span class="apiname">。服务</span>构造函数表示受支持的算法。</span><div>
                                 <p>以下语句添加了一个名为<code class="codeph">MyCipher</code>类型的<code class="codeph">Cipher</code> ;实现此服务的类的名称是<code class="codeph">p.MyCipher</code> 。的论点<code class="codeph">putService</code>是<span class="apiname">Provider的子类<span class="apiname">。服务内容</span> ：</span></p><pre class="pre codeblock"><code>        putService(new ProviderService(this, "Cipher", "MyCipher", "p.MyCipher"));
</code></pre><p>本示例使用<span class="apiname">Provider的子类<span class="apiname">。服务</span>命名<code class="codeph">ProviderService</code> （而不是<span class="apiname">提供者。服务</span>本身），因为它自定义了JCE框架实例化服务的方式。如果您不需要自定义<span class="apiname">Provider的行为<span class="apiname">。服务</span> ，然后您可以致电<span class="apiname">提供者。直接服务</span>构造函数：</span></span></p><pre class="pre codeblock"><code>public final class MyProvider extends Provider {  &nbsp;
    public MyProvider() {
        super("MyProvider", "1.0",
            "Some info about my provider and which algorithms it supports");
        putService(new Provider.Service(
            this, "Cipher", "MyCipher", "p.MyCipher", null, null));
    }
}</code></pre><p>请注意，此示例与<a href="howtoimplaprovider.html#GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE">步骤3.1：创建使用字符串对象注册其服务的提供程序中</a>描述的示例基本相同。
                                 </p>
                              </div>
                           </span></span></li>
                           <li class="stepexpand"><span>重写<span class="apiname">Provider中的任何方法<span class="apiname">。服务</span> ，例如<span class="apiname">newInstance</span> ，用于定制JCE框架如何处理提供程序中的服务。</span><div>
                                 <p>本节开头的示例覆盖了方法<span class="apiname">Provider。Service.newInstance</span> 。该方法返回一个实例<code class="codeph">MyCipher</code>仅在请求的服务为<code class="codeph">MyCipher</code> 。如果没有，则抛出一个<code class="codeph">NoSuchAlgorithmException</code>和一个<code class="codeph">ProviderException</code> 。
                                 </p>
                                 <p>有关可以覆盖的其他方法的更多信息，请参见<a href="howtoimplaprovider.html#GUID-B1428B09-5542-4D36-9C0D-D78A8B2B3C00" title="提供者。服务类为提供者提供了一种宣传其服务的替代方法，并支持其他功能。">提供程序。服务等级</a> 。
                                 </p>
                                 <div class="infoboxnote" id="GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733__GUID-62864B28-DA3B-492B-8079-F83B7004D2AC">
                                    <p class="notep1">注意：</p>有关此编码样式的示例，请参见<a class="new-window" href="http://www.oracle.com/pls/topic/lookup?ctx=javase11&id=sun_security_mscapi"><span class="apiname">sun.security.mscapi</span></a>软件包中包含的JDK源代码。
                                 </div>
                              </div>
                           </span></li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E1800256-2F1C-471D-96B5-A39ABA751461" name="GUID-E1800256-2F1C-471D-96B5-A39ABA751461"></a><h5 id="JSSEC-GUID-E1800256-2F1C-471D-96B5-A39ABA751461" class="sect5">步骤3.3：为密码实施指定附加信息</h5>
                     <div>
                        <p>如上所述，在<code class="codeph">Cipher</code>属性， <span class="variable" translate="no">algName</span>可能实际上表示一个<span class="variable" translate="no">transformation</span> 。<span class="variable" translate="no">transformation</span>是一个字符串，它描述了一个对象要执行的操作（或一组操作）。 <code class="codeph">Cipher</code>在某些给定输入上的对象。转换始终包括密码算法（例如<span class="variable" translate="no">AES</span> ）的名称，并且可以跟随模式和填充方案。
                        </p>
                        <div class="section">
                           <p>转换的形式为：</p>
                           <ul style="list-style-type:disc">
                              <li><span class="variable" translate="no">algorithm/mode/padding</span> ，或</li>
                              <li><span class="variable" translate="no">算法</span></li>
                           </ul>
                           <p>（在后一种情况下，将使用模式和填充方案的提供程序特定的默认值）。例如，以下是有效的转换：</p><pre class="codeblock"><code>    Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); 
</code></pre>当以流密码模式请求分组密码时（例如， <code class="codeph">AES</code>在<code class="codeph">CFB</code>要么<code class="codeph">OFB</code>模式），客户端可以选择将每次处理的位数附加到模式名称中，以指定一次要处理的位数，如以下示例转换所示：<pre class="codeblock"><code>    Cipher c1 = Cipher.getInstance("AES/CFB8/NoPadding");
    Cipher c2 = Cipher.getInstance("AES/OFB32/PKCS5Padding");
</code></pre><p>如果数字不遵循流密码模式，则使用提供商特定的默认值。（例如， <span class="variable" translate="no">SunJCE</span>提供程序使用默认的128位。）
                           </p>
                           <p>提供者可以为<span class="variable" translate="no">algorithm/mode/padding</span>每种组合提供单独的类。替代地，提供者可以决定提供更多的通用类来表示与<span class="variable" translate="no">algorithm</span>或<span class="variable" translate="no">algorithm/mode</span>或<span class="variable" translate="no">algorithm//padding</span>相对应的子转换（请注意双斜杠）；在这种情况下，请求的模式和/或填充由<code class="codeph">getInstance</code>方法<code class="codeph">Cipher</code> ，该调用<code class="codeph">engineSetMode</code>和<code class="codeph">engineSetPadding</code>提供者的子类的方法<code class="codeph">CipherSpi</code> 。
                           </p>
                           <p>这是一个<code class="codeph">Cipher</code>提供程序主类中的property属性可能具有下表中所示的格式之一。
                           </p>
                           <div class="tblformalwide" id="GUID-E1800256-2F1C-471D-96B5-A39ABA751461__GUID-98373D6F-2FC2-405D-A54E-8D730E6025D5">
                              <p class="titleintable">表3-1密码属性格式</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="密码属性格式" width="100%" border="1" summary="List of Cipher Properties " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e1301"><code class="codeph">Cipher</code>属性格式</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e1305">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e1309" headers="d41150e1301 "><code class="codeph">Cipher.</code><span class="variable" translate="no">algName</span></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e1309 d41150e1305 ">提供者的子类<code class="codeph">CipherSpi</code>用可插入模式和填充实现<span class="variable" translate="no">algName</span></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e1323" headers="d41150e1301 "><code class="codeph">Cipher.</code><span class="variable" translate="no">algName/mode</span></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e1323 d41150e1305 ">提供者的子类<code class="codeph">CipherSpi</code>在指定<span class="variable" translate="no">mode</span>实现<span class="variable" translate="no">algName</span> ，并带有可插入的填充</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e1340" headers="d41150e1301 "><code class="codeph">Cipher.</code><span class="variable" translate="no">algName//padding</span></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e1340 d41150e1305 ">提供者的子类<code class="codeph">CipherSpi</code>使用可插入模式以指定的<span class="variable" translate="no">padding</span>实现<span class="variable" translate="no">algName</span></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e1357" headers="d41150e1301 "> <code class="codeph">Cipher.</code><span class="variable" translate="no">algName/mode/padding</span></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e1357 d41150e1305 ">提供者的子类<code class="codeph">CipherSpi</code>用指定的<span class="variable" translate="no">mode</span>和<span class="variable" translate="no">padding</span>实现<span class="variable" translate="no">algName</span></td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>（有关应使用的标准算法名称，模式和填充方案，请参阅<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。）
                           </p>
                           <p>例如，提供者可以提供以下内容的子类： <code class="codeph">CipherSpi</code>实现<span class="variable" translate="no">AES/ECB/PKCS5Padding</span>一个，实现<span class="variable" translate="no">AES/CBC/PKCS5Padding</span>一个，实现<span class="variable" translate="no">AES/CFB/PKCS5Padding</span> ，以及实现<span class="variable" translate="no">AES/OFB/PKCS5Padding</span> 。该提供者将具有以下内容<code class="codeph">Cipher</code>其主类的属性：</p>
                           <ul style="list-style-type:disc">
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES/ECB/PKCS5Padding</span></code></li>
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES/CBC/PKCS5Padding</span></code></li>
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES/CFB/PKCS5Padding</span></code></li>
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES/OFB/PKCS5Padding</span></code></li>
                           </ul>
                           <p>另一个提供程序可以为上述每种模式实现一个类（即，一个用于<span class="variable" translate="no">ECB</span>类，一个用于<span class="variable" translate="no">CBC</span> ，一个用于<span class="variable" translate="no">CFB</span>和一个用于<span class="variable" translate="no">OFB</span>类），一个用于<span class="variable" translate="no">PKCS5Padding</span>类以及一个从以下子类<span class="variable" translate="no">PKCS5Padding</span>的通用<span class="variable" translate="no">AES</span>类。 <code class="codeph">CipherSpi</code> 。该提供者将具有以下内容<code class="codeph">Cipher</code>其主类的属性：</p>
                           <ul style="list-style-type:disc">
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES</span></code></li>
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES</span> SupportedModes</code><ul style="list-style-type:disc">
                                    <li>
                                       <p>例：<code class="codeph">"ECB|CBC|CFB|OFB"</code></p>
                                    </li>
                                 </ul>
                              </li>
                              <li><code class="codeph">Cipher.<span class="variable" translate="no">AES</span> SupportedPaddings</code><ul style="list-style-type:disc">
                                    <li>
                                       <p>例：<code class="codeph">"NOPADDING|PKCS5Padding"</code></p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>的<code class="codeph">getInstance</code>的工厂方法<code class="codeph">Cipher</code>引擎类遵循以下规则，以实例化提供者的实现<code class="codeph">CipherSpi</code>用于形式“ <span class="variable" translate="no">algorithm</span> ”的转换：</div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>检查提供者是否已注册的子类<code class="codeph">CipherSpi</code>用于指定的“ <span class="variable" translate="no">algorithm</span> ”。</span><ul>
                                 <li>如果答案为是，请实例化此类，为其使用模式和填充方案默认值（由提供程序提供）。</li>
                                 <li>如果答案是否定的，则抛出一个<code class="codeph">NoSuchAlgorithmException</code>例外。
                                 </li>
                              </ul>
                           </li>
                           <li><span>的<code class="codeph">getInstance</code>的工厂方法<code class="codeph">Cipher</code>引擎类遵循以下规则，以实例化提供者的实现<code class="codeph">CipherSpi</code>用于形式“ <span class="variable" translate="no">algorithm/mode/padding</span> ”的转换：</span><ol type="a">
                                 <li class="substepexpand"><span>检查提供者是否已注册的子类<code class="codeph">CipherSpi</code>用于指定的“ <span class="variable" translate="no">algorithm/mode/padding</span> ”转换。</span><div>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果答案为“是”，则将其实例化。</p>
                                          </li>
                                          <li>
                                             <p>如果答案为“否”，请转到下一步。</p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li class="substepexpand"><span>检查提供者是否已注册的子类<code class="codeph">CipherSpi</code>用于子转换“ <span class="variable" translate="no">algorithm/mode</span> ”。</span><div>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果答案为是，请实例化并调用<code class="codeph">engineSetPadding(<span class="variable" translate="no">padding</span>)</code>在新实例上。
                                             </p>
                                          </li>
                                          <li>
                                             <p>如果答案为“否”，请转到下一步。</p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li class="substepexpand"><span>检查提供者是否已注册的子类<code class="codeph">CipherSpi</code>用于子转换“ <span class="variable" translate="no">algorithm//padding</span> ”（请注意双斜杠）</span><div>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果答案为是，请实例化并调用<code class="codeph">engineSetMode(<span class="variable" translate="no">mode</span>)</code>在新实例上。
                                             </p>
                                          </li>
                                          <li>
                                             <p>如果答案为“否”，请转到下一步。</p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li class="substepexpand"><span>检查提供者是否已注册的子类<code class="codeph">CipherSpi</code>用于子转换“ <span class="variable" translate="no">algorithm</span> ”。</span><div>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果答案为是，请实例化并调用<code class="codeph">engineSetMode(<span class="variable" translate="no">mode</span>)</code>和<code class="codeph">engineSetPadding(<span class="variable" translate="no">padding</span>)</code>在新实例上。
                                             </p>
                                          </li>
                                          <li>
                                             <p>如果答案是否定的，则抛出一个<code class="codeph">NoSuchAlgorithmException</code>例外。
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7C304A79-6D0B-438B-A02E-51648C909876" name="GUID-7C304A79-6D0B-438B-A02E-51648C909876"></a><h4 id="JSSEC-GUID-7C304A79-6D0B-438B-A02E-51648C909876" class="sect4">步骤4：为您的提供商创建模块声明</h4>
                  <div>
                     <p>此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。</p>
                     <div class="section"> 
                        <p>为您的提供者创建一个模块声明，并将其保存在一个名为<code>module-info.java</code> 。该模块声明包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>模块的名称。</p>
                           </li>
                           <li>
                              <p>您的提供程序所依赖的任何模块。</p>
                           </li>
                           <li>
                              <p>一种<code class="codeph">provides</code>指令（如果您的模块提供服务实现）。
                              </p>
                           </li>
                        </ul>
                        <p>以下示例模块声明定义了一个名为的模块<code class="codeph">com.foo.MyProvider</code> 。 <code class="codeph">p.MyProvider</code>是服务实现的完全限定的类名。假设在这个例子中， <code class="codeph">p.MyProvider</code>在包<span class="apiname">javax.security.auth.kerberos中</span>使用API，该包位于<span class="apiname">java.security.jgss</span>模块中。因此，该指令<code class="codeph">requires java.security.jgss</code>出现在模块声明中。
                        </p><pre class="pre codeblock"><code>module com.foo.MyProvider {
    provides java.security.Provider with p.MyProvider;
    requires java.security.jgss;
}</code></pre><p>您可以将提供程序打包为三种不同的模块：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>命名或显式模块：出现在模块路径上的模块，该模块中包含模块配置信息<code>module-info.class</code>文件。
                              </p>
                              <p>JCE框架可以使用<a href="https://docs.oracle.com/javase/10/docs/api/java/util/ServiceLoader.html" target="_blank"><span class="apiname">ServiceLoader</span></a>类（简化提供程序配置）在显式模块中搜索提供程序，而无需对该模块进行任何其他更改。请参阅<a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置提供程序</a>和<a href="howtoimplaprovider.html#GUID-3FD26072-6982-4DCE-932C-DE152C463992" title="在运行测试应用程序时，所需的java命令选项会因各种因素而异，例如您是否将提供程序打包为命名，自动或未命名模块，以及是否配置了它以便ServiceLoader类可以搜索它。">步骤10：运行测试程序</a> 。
                              </p>
                           </li>
                           <li>
                              <p>自动模块：出现在模块路径上的模块，但在模块路径中不包含模块配置信息<code>module-info.class</code>文件（基本上是“常规” JAR文件）。
                              </p>
                           </li>
                           <li>
                              <p>未命名的模块：出现在类路径上的模块。它可能有也可能没有<code>module-info.class</code>文件;该文件将被忽略。
                              </p>
                           </li>
                        </ul>
                        <p>建议您将提供程序打包在命名模块中，因为它们可以提供更好的性能，更强的封装，更简单的配置和更大的灵活性。</p>
                        <p>在打包和配置提供程序时，您具有很大的灵活性。但是，这会影响您启动使用它们的应用程序的方式。例如，您可能必须指定其他<code class="codeph">--add-exports</code>要么<code class="codeph">--add-modules</code>选项。通常，命名模块需要较少的这些附加选项。另外，命名模块提供了更大的灵活性。通过在模块化JDK的类路径中指定它们，可以将它们与非模块化JDK一起使用，甚至可以与未命名的模块一起使用。有关模块的更多信息，请参见<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank">模块系统的状态</a>和<a href="http://openjdk.java.net/jeps/261" target="_blank">JEP 261：模块系统</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-83742677-6E39-4A8D-BF0F-BC743E3AE43C" name="GUID-83742677-6E39-4A8D-BF0F-BC743E3AE43C"></a><h4 id="JSSEC-GUID-83742677-6E39-4A8D-BF0F-BC743E3AE43C" class="sect4">步骤5：编译代码</h4>
                  <div>
                     <p>创建实现代码（ <a href="howtoimplaprovider.html#GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" title="当实例化提供者的Cipher，KeyAgreement，KeyGenerator，MAC或SecretKey工厂的实现（类）时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。">第1步：编写服务实现代码</a> ）之后，为提供者命名（ <a href="howtoimplaprovider.html#GUID-7241AB0C-71DC-408C-8726-B8E0225DDBCE">第2步：为您的提供者命名</a> ），然后创建主类（ <a href="howtoimplaprovider.html#GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" title="创建java.security的子类。提供程序类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。">第3步：编写您的主类，该类的子类） Provider</a> ），并创建了模块声明（ <a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。">第4步：为您的Provider创建模块声明</a> ），使用Java编译器来编译文件。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F" name="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F"></a><h4 id="JSSEC-GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F" class="sect4">步骤6：将您的提供者放置在JAR文件中</h4>
                  <div>
                     <p></p>
                     <div class="section" id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__ADDTHEFILEJAVA.SECURITY.PROVIDERTOU-025DFEDB">
                        <p class="subhead3" id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__GUID-BE09E014-A810-4D76-8A09-70F9E5D918E0">添加文件java.security。提供程序以使用ServiceLoader类搜索提供程序</p>
                        <p>如果您的提供程序打包在一个自动或未命名的模块中（您没有按照<a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="This step is optional but recommended; it enables you to package your provider in a named module. A modular JDK can then locate your provider in the module path as opposed to the class path. The module system can more thoroughly check for dependencies in modules in the module path. Note that you can use named modules in a non-modular JDK; the module declaration will be ignored. Also, you can still package your providers in unnamed or automatic modules.">步骤4：为您的提供程序</a>创建模块声明中所述<a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。">创建模块声明</a> ），并且希望使用<span class="apiname">java.util。ServiceLoader</span>搜索您的提供程序，然后添加文件<code>META-INF/services/java.security.Provider</code>到JAR文件，并确保该文件包含您的提供程序实现的完全限定的类名。
                        </p>
                        <p>安全提供程序加载机制使用<a href="https://docs.oracle.com/javase/10/docs/api/java/util/ServiceLoader.html" target="_blank"><span class="apiname">ServiceLoader</span></a>类在咨询类路径之前搜索提供程序。
                        </p>
                        <p>例如，如果您的提供程序的完全限定的类名是<code class="codeph">p.Provider</code>您提供者的所有已编译代码都在目录中<code>classes</code> ，然后创建一个名为<code>classes/META-INF/services/java.security.Provider</code>包含以下行：</p><pre class="pre codeblock"><code>p.MyProvider</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__RUNTHEJARCOMMANDTOCREATEAMODULEJARF-025E01A6">
                        <p class="subhead3" id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__GUID-A548FCA9-2E56-4F93-8352-9B978CDBEAA0">运行jar命令创建一个JAR文件</p>
                        <p>以下命令创建一个名为的JAR文件<code>MyProvider.jar</code> 。模块JAR文件的所有已编译代码都在目录中<code>classes</code> 。另外，模块描述符<code>module-info.class</code> ，在目录中<code>classes</code> ：</p><pre class="pre codeblock"><code>jar --create --file MyProvider.jar --module-version 1.0 -C classes</code></pre><div class="infoboxnote" id="GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__GUID-FC0BD0DE-0B46-47DD-88FD-BBE643CECA04">
                           <p class="notep1">注意：</p>的<code>module-info.class</code>文件和<code class="codeph">--module-version</code>选项是可选的。然而<code>module-info.class</code>如果要创建模块化JAR文件，则必须提供该文件。（模块化JAR文件是具有<code>module-info.class</code>文件放在其顶层目录中。）
                        </div>
                        <p>请参见<span><cite>Java Platform，Standard Edition Tools Reference中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR614" target="_blank">jar</a> 。
                        </p> 
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2D4432F9-1C3C-4A91-8612-2B2840188B36" name="GUID-2D4432F9-1C3C-4A91-8612-2B2840188B36"></a><h4 id="JSSEC-GUID-2D4432F9-1C3C-4A91-8612-2B2840188B36" class="sect4">步骤7：如有必要，对您的JAR文件签名</h4>
                  <div>
                     <p></p>
                     <p>如果您的提供者通过<span class="apiname">Cipher</span> ， <span class="apiname">KeyAgreement</span> ， <span class="apiname">KeyGenerator</span> ， <span class="apiname">Mac</span>或<span class="apiname">SecretKeyFactory</span>类提供加密算法，则必须对JAR文件进行签名，以便JCA可以在运行时对代码进行身份验证；否则，请参阅<a href="howtoimplaprovider.html#GUID-AEE5234F-24F1-4899-B490-C79F0C2D8D59" title="当实例化提供者的Cipher，KeyAgreement，KeyGenerator，MAC或SecretKey工厂的实现（类）时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。">步骤1.1：考虑其他JCA Provider要求和有关加密实现的建议</a> 。如果您不提供这种类型的实现，则可以跳过此步骤。
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" name="GUID-434AACF7-0D2C-494A-B32A-508A6B605F62"></a><h5 id="JSSEC-GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" class="sect5">步骤7.1：获取代码签名证书</h5>
                     <div>
                        <p>下一步是请求代码签名证书，以便您可以在测试之前使用它对提供商进行签名。该证书将对测试和生产均有效。有效期为5年。</p>
                        <div class="section">
                           <p>以下是获取代码签名证书应使用的步骤。请参阅《 <span><cite>Java平台，标准版工具参考》</cite></span>中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand" id="GUID-434AACF7-0D2C-494A-B32A-508A6B605F62__USEKEYTOOLTOGENERATEADSAKEYPAIRUSIN-7569AAA1"><span>使用<span class="bold">keytool</span>生成RSA密钥对，以RSA算法为例：</span><div><pre class="codeblock"><code>keytool -genkeypair -alias <span class="variable" translate="no">&lt;alias&gt;</span> \
        -keyalg RSA -keysize 2048 \
        -dname "cn=<span class="variable" translate="no">&lt;Company Name&gt;</span>, \
        ou=Java Software Code Signing, \
        o=Oracle Corporation" \
        -keystore <span class="variable" translate="no">&lt;keystore file name&gt;</span> \  
        -storepass <span class="variable" translate="no">&lt;keystore password&gt;</span>
</code></pre></div>
                              <div> 
                                 <p>这将生成一个DSA密钥对（一个公共密钥和一个关联的私有密钥），并将其存储在指定密钥库中的条目中。公钥存储在自签名证书中。随后可以使用指定的别名访问密钥库条目。</p>
                                 <p>尖括号中的选项值（“ <”和“>”）表示必须提供的实际值。例如， <code class="codeph"><alias></code>必须用将来希望用于引用新生成的密钥库条目的任何别名替换，并且<code class="codeph"><keystore file name></code>必须替换为要使用的密钥库的名称。
                                 </p>
                                 <div class="infobox-tip" id="GUID-434AACF7-0D2C-494A-B32A-508A6B605F62__GUID-BFAEADA0-1705-445D-9874-DF195A5DF8FB">
                                    <p class="notep1">小费：</p>请勿将实际值用尖括号括起来。例如，如果您希望您的别名是<code class="codeph">myTestAlias</code> ，指定<code class="codeph">-alias</code>选项如下：<pre class="codeblock"><code>    -alias myTestAlias
</code></pre></div>如果您指定了尚不存在的密钥库，则将创建它。
                                 <div class="infoboxnote" id="GUID-434AACF7-0D2C-494A-B32A-508A6B605F62__GUID-AABAAA98-A479-4148-AABB-245A84439DBA">
                                    <p class="notep1">注意：</p>如果您键入的命令行的长度不能超过<code class="codeph">keytool -genkeypair</code>要执行的命令（例如，如果要键入Microsoft Windows DOS提示符），则可以创建并执行包含该命令的纯文本批处理文件。也就是说，创建一个新的文本文件，其中只包含完整的文本文件。 <code class="codeph">keytool -genkeypair</code>命令。（请记住将其全部输入一行。）用.bat扩展名保存文件。然后在DOS窗口中，键入文件名（如果需要，请输入其路径）。这将导致批处理文件中的命令被执行。
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>使用<span class="bold">keytool</span>生成证书签名请求。</span><div><pre class="codeblock"><code>
    keytool -certreq -alias &lt;alias&gt; \
        -file &lt;csr file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt; 
</code></pre>这里， <code class="codeph"><span class="variable" translate="no"><alias></span></code>是上一步中创建的DSA密钥对条目的别名。此命令使用PKCS＃10格式生成证书签名请求（CSR）。它将CSR存储在名称在<code class="codeph"><span class="variable" translate="no"><csr file name></span></code> 。
                              </div>
                           </li>
                           <li class="stepexpand"><span>将CSR，联系信息和其他必需的文档发送到JCA代码签名证书颁发机构。有关联系信息，请参见<a href="http://www.oracle.com/technetwork/java/javase/tech/getcodesigningcertificate-361306.html#jcacodesigning" target="_blank">JCA代码签名证书颁发机构</a> 。</span></li>
                           <li class="stepexpand"><span>JCA代码签名证书颁发机构收到您的电子邮件后，他们将通过电子邮件向您发送请求编号。收到此请求号后，您应该打印，填写并发送CSP认证表。有关联系信息，请参阅<a href="http://www.oracle.com/technetwork/java/javase/tech/getcodesigningcertificate-361306.html#sendingcertificationform" target="_blank">发送CSP认证表</a> 。</span></li>
                           <li class="stepexpand"><span>使用<span class="bold">keytool</span>导入从CA收到的证书。</span><div>从JCA代码签名证书颁发机构收到两个证书后，就可以使用<span class="bold">keytool</span>将其导入到密钥库中。首先将CA的证书导入为“受信任的证书”：<pre class="codeblock"><code>    keytool -import -alias &lt;alias for the CA cert&gt; \
        -file &lt;CA cert file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt;
</code></pre>然后导入代码签名证书：<pre class="codeblock"><code>    keytool -import -alias &lt;alias&gt; \
        -file &lt;code-signing cert file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt;
</code></pre><p><code class="codeph"><span class="variable" translate="no"><alias></span></code>与您在生成DSA密钥对的<a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62__USEKEYTOOLTOGENERATEADSAKEYPAIRUSIN-7569AAA1">步骤1</a>中创建的别名相同。此命令替换由以下项指定的密钥库条目中的自签名证书<code class="codeph"><span class="variable" translate="no"><alias></span></code>由JCA代码签名证书颁发机构签署的签名。
                                 </p>
                              </div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>现在，您在密钥库中拥有来自JCA（JCA代码签名证书颁发机构）信任的实体的证书，您可以将提供程序代码放在JAR文件中（ <a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">步骤6：将提供程序放在JAR文件中</a> ），然后使用签名JAR文件的证书（ <a href="howtoimplaprovider.html#GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF">步骤7.2：对您的提供者进行签名</a> ）。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF" name="GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF"></a><h5 id="JSSEC-GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF" class="sect5">步骤7.2：签署您的提供商</h5>
                     <div>
                        <div class="section">
                           <p>使用在<a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="The next step is to request a code-signing certificate so that you can use it to sign your provider prior to testing. The certificate will be good for both testing and production. It will be valid for 5 years.">步骤7.1：获取代码签名证书中获得的代码签名证书对</a>在<a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">步骤6：将您的提供者放置</a>在JAR文件中创建<a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">的JAR文件</a>进行<a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="下一步是请求代码签名证书，以便您可以在测试之前使用它对提供商进行签名。该证书将对测试和生产均有效。有效期为5年。">签名</a> 。请参见《 <span><cite>Java平台，标准版工具参考》中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-925E7A1B-B3F3-44D2-8B49-0B3FA2C54864" target="_blank">jarsigner</a> 。
                           </p><pre class="codeblock"><code>    jarsigner -keystore <span class="variable" translate="no">&lt;keystore file name&gt;</span> \
        -storepass <span class="variable" translate="no">&lt;keystore password&gt;</span> \
        <span class="variable" translate="no">&lt;JAR file name&gt;</span> <span class="variable" translate="no">&lt;alias&gt;</span>
</code></pre><p>这里， <code class="codeph"><span class="variable" translate="no"><alias></span></code>是包含从JCA代码签名证书颁发机构收到的代码签名证书的条目的密钥库别名（与在<a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="下一步是请求代码签名证书，以便您可以在测试之前使用它对提供商进行签名。该证书将对测试和生产均有效。有效期为5年。">步骤7.1：获取代码签名证书</a>中的命令中指定的别名相同）。
                           </p>
                           <p>您可以通过以下方式测试签名的验证：</p><pre class="codeblock"><code>    jarsigner -verify <span class="variable" translate="no">&lt;JAR file name&gt;</span> </code></pre><p>如果验证成功，将显示文本“ jarjarified”。</p>
                           <div class="infoboxnote" id="GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF__GUID-9AA0BF43-A226-4E46-9B26-5B3B9AD53531">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果您在应用程序中包括签名的JCE提供程序，并且还希望对JAR文件进行签名以实现其他代码签名策略，则需要使用适当的证书/密钥将多个签名应用于JCE提供程序JAR。JCE签名用于通过JCE框架接受提供者JAR，其他签名则可以用于制定策略决策。有关将多个签名应用于JAR文件的信息<span><cite>，</cite></span>请参见<span><cite>Java Platform，Standard Edition Tools Reference中的</cite></span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-925E7A1B-B3F3-44D2-8B49-0B3FA2C54864" target="_blank">jarsigner</a> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>您不能将签名的提供程序打包在JMOD文件中。</p>
                                 </li>
                                 <li>
                                    <p>只有提供Cipher，KeyAgreement，KeyGenerator，Mac或SecretKFactory实例的提供程序必须经过签名。如果您的提供程序仅提供SecureRandom，MessageDigest，Signature，KeyStore等的实例，则不需要对提供程序进行签名。</p>
                                 </li>
                                 <li>
                                    <p>您可以将自定义运行时映像中的提供程序与<code class="codeph">jlink</code>只要没有Cipher，KeyAgreement，KeyGenerator或MAC实现，就可以使用该命令。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" name="GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D"></a><h4 id="JSSEC-GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" class="sect4">步骤8：准备测试</h4>
                  <div>
                     <p>后续步骤描述了如何安装和配置新的提供程序，以便可以通过JCA使用它。</p>
                  </div>
                  <div class="sect4"><a id="GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" name="GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33"></a><h5 id="JSSEC-GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" class="sect5">步骤8.1：配置提供程序</h5>
                     <div>
                        <p>注册您的提供程序，以便JCE框架可以通过<span class="apiname">ServiceLoader</span>类或在类路径或模块路径中找到您的提供程序。
                        </p>
                        <ol>
                           <li class="stepexpand"><span>打开<code>java.security</code>在编辑器中的文件：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>Solaris，Linux或macOS：<code class="codeph"><span class="codeinlineitalic"><java-home></span>/conf/security/java.security</code></p>
                                    </li>
                                    <li>
                                       <p>视窗：<code class="codeph"><span class="codeinlineitalic"><java-home></span>\conf\security\java.security</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="stepexpand"><span>在里面<code>java.security</code>在文件中，找到将标准提供程序（例如SUN，SunRsaSign和SunJCE）配置为静态提供程序的部分；它看起来像如下：</span><div><pre class="codeblock"><code>security.provider.1=SUN
security.provider.2=SunRsaSign
security.provider.3=SunEC
security.provider.4=SunJSSE
security.provider.5=SunJCE
security.provider.6=SunJGSS
security.provider.7=SunSASL
security.provider.8=XMLDSig
security.provider.9=SunPCSC
security.provider.10=JdkLDAP
security.provider.11=JdkSASL
security.provider.12=SunMSCAPI
security.provider.13=SunPKCS11</code></pre><p>本节中的每一行具有以下形式：</p><pre class="codeblock"><code>security.provider.<span class="variable" translate="no">n</span>=<span class="variable" translate="no">provName</span>|<span class="variable" translate="no">className</span> 
</code></pre><p>这将声明提供程序，并指定其优先顺序<code class="codeph"><span class="variable" translate="no">n</span></code> 。优先顺序是当没有特定提供者被请求时，在提供者中搜索所请求算法的顺序。订单基于1； 1是最优选的，其次是2，依此类推。
                                 </p>
                                 <p><code class="codeph"><span class="variable" translate="no">provName</span></code>是提供者的名称， <code class="codeph"><span class="variable" translate="no">className</span></code>是提供者的完全合格的类名称。您可以使用这两个名称中的任何一个。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>通过添加到<code>java.security</code>填写表格<code class="codeph">security.provider.<span class="variable" translate="no">n</span>=<span class="variable" translate="no">provName</span>|<span class="variable" translate="no">className</span></code> 。</span><div>
                                 <p>如果您配置了提供程序，以便<a href="https://docs.oracle.com/javase/10/docs/api/java/util/ServiceLoader.html" target="_blank"><span class="apiname">ServiceLoader</span></a>类可以搜索它（因为您已按照<a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。">步骤4：为提供程序创建模块声明中</a>所述将提供程序打包在命名模块中，或者添加了一个<code>java.security.Provider</code>如<a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F__ADDTHEFILEJAVA.SECURITY.PROVIDERTOU-025DFEDB">添加文件java.security中所述。提供程序以使用ServiceLoader类搜索提供程序</a> ），然后仅指定提供程序的名称。
                                 </p>
                                 <p>如果尚未配置提供程序，以便<span class="apiname">ServiceLoader</span>类可以搜索它，这意味着JCE框架将在类路径或模块路径中搜索它，然后指定提供程序的标准类名。
                                 </p>
                                 <p>例如，突出显示的行注册提供者<code class="codeph">MyProvider</code> （其完全合格的班级名称是<code class="codeph">p.MyProvider</code>并已配置为<span class="apiname">ServiceLoader</span>类可以搜索它）作为第14个首选提供程序：</p><pre class="codeblock"><code># ...
security.provider.11=JdkSASL
security.provider.12=SunMSCAPI
security.provider.13=SunPKCS11
<span class="bold">security.provider.14=MyProvider</span></code></pre><p>如果不确定是否将使用<span class="apiname">ServiceLoader</span>机制，或者不确定是否要在非模块化系统上进行部署，则还可以使用完整的类名再次注册提供程序：</p><pre class="pre codeblock"><code>security.provider.15=p.MyProvider</code></pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>或者，您可以动态注册提供程序。为此，要在<a href="howtoimplaprovider.html#GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0" title="Write and compile one or more test programs that test your provider's incorporation into the Security API as well as the correctness of its algorithm(s). Create any supporting files needed, such as those for test data to be encrypted.">第9步：编写和编译测试程序中</a>编写的程序（例如<a href="howtoimplaprovider.html#GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0" title="编写并编译一个或多个测试程序，以测试您的提供商是否已纳入安全性API以及其算法的正确性。创建所需的任何支持文件，例如用于加密测试数据的文件。">您的测试程序</a> ）将调用<code class="codeph">addProvider</code>要么<code class="codeph">insertProviderAt</code>中的方法<code class="codeph">Security</code>类：</p><pre class="pre codeblock"><code>ServiceLoader&lt;Provider&gt; sl = ServiceLoader.load(java.security.Provider.class);
for (Provider p : sl) {
    System.out.println(p);
    if (p.getName().equals("MyProvider")) {
        Security.addProvider(p);
    }
}</code></pre><p>这种注册不是永久性的，只能通过被授予以下权限的代码来完成：</p><pre class="codeblock"><code>java.security.SecurityPermission "insertProvider.<span class="variable" translate="no">&lt;provider name&gt;</span>"
</code></pre><p>例如，如果提供者名称为MyJCE，并且提供者的代码位于<code class="codeph">myjce_provider.jar</code>文件在<code class="codeph">/localWork</code>目录，那么下面是一个示例策略文件，其中包含一个<code class="codeph">grant</code>授予该权限的语句：</p><pre class="codeblock"><code>    grant codeBase "file:/localWork/myjce_provider.jar" {
        permission java.security.SecurityPermission
            "insertProvider.MyJCE";
    };
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-6E267101-15F4-4E7B-A6EB-64E36AAD1285" name="GUID-6E267101-15F4-4E7B-A6EB-64E36AAD1285"></a><h5 id="JSSEC-GUID-6E267101-15F4-4E7B-A6EB-64E36AAD1285" class="sect5">步骤8.2：设置提供者权限</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>在安装安全管理器时运行应用程序时，必须授予<a href="java-security-overview1.html#GUID-7A49C00B-BEA6-4050-9E32-6168211585F7" title="权限表示对系统资源的访问。为了允许对applet（或使用安全管理器运行的应用程序）进行资源访问，必须将相应的权限显式授予尝试访问的代码。">权限</a> 。可以通过应用程序本身中的代码或通过命令行参数为应用程序安装安全管理器。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>您的提供程序可能需要在客户端环境中授予以下权限：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li><code class="codeph">java.lang.RuntimePermission</code>获取类保护域。提供者在进行自我完整性检查的过程中可能需要获得自己的保护域。
                                    </li>
                                    <li><code class="codeph">java.security.SecurityPermission</code>设置提供程序属性。
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="stepexpand"><span>为了确保您的提供者在安装安全管理器时能够正常工作，您需要测试这样的安装和执行环境。此外，在测试之前，需要向提供者及其使用的任何其他提供者授予适当的权限。</span><div>
                                 <p>例如，一个示例语句向名称为MyJCE且代码位于<code class="codeph">myjce_provider.jar</code>出现在下面。这样的声明可能会出现在策略文件中。在此示例中， <code class="codeph">myjce_provider.jar</code>假定文件位于<code class="codeph">/localWork</code>目录。
                                 </p><pre class="codeblock"><code>    grant codeBase "file:/localWork/myjce_provider.jar" {
        permission java.lang.RuntimePermission "getProtectionDomain";
        permission java.security.SecurityPermission
            "putProviderProperty.MyJCE";
    };
</code></pre></div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0" name="GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0"></a><h4 id="JSSEC-GUID-C6054169-FE6E-4837-B2BD-382DFEB955C0" class="sect4">步骤9：编写和编译测试程序</h4>
                  <div>
                     <p>编写并编译一个或多个测试程序，以测试您的提供商是否已纳入安全性API以及其算法的正确性。创建所需的任何支持文件，例如用于加密测试数据的文件。</p>
                     <ol>
                        <li class="stepexpand"><span>程序应执行的第一个测试是确保找到您的提供程序，并确保其名称，版本号和其他信息符合预期。</span><div>为此，您可以编写如下代码，将您的提供程序名称替换为<code class="codeph">MyPro</code> ：<pre class="codeblock"><code>    import java.security.*;

    Provider p = Security.getProvider("MyPro");

    System.out.println("MyPro provider name is " + p.getName());
    System.out.println("MyPro provider version # is " + p.getVersion());
    System.out.println("MyPro provider info is " + p.getInfo());
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>您应该确保找到您的服务。</span><div>例如，如果实现了AES加密算法，则可以使用以下代码进行检查以确保在请求时找到了该算法（同样，将提供者的名称替换为“ MyPro”）：<pre class="codeblock"><code>
    Cipher c = Cipher.getInstance("AES", "MyPro");

    System.out.println("My Cipher algorithm name is " + c.getAlgorithm());
</code></pre></div>
                        </li>
                        <li class="stepexpand"><strong>可选：</strong> <span>如果您未在以下调用中指定提供商名称： <code class="codeph">getInstance</code> ，将按优先顺序搜索所有注册的提供程序（请参阅<a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置提供程序</a> ），直到找到一个实现该算法的程序。</span></li>
                        <li class="stepexpand"><strong>可选：</strong> <span>如果您的提供者实现了豁免机制，则应编写使用豁免机制的测试小程序或应用程序。这样的小程序/应用程序也需要签名，并且需要捆绑有“权限策略文件”。</span><div>有关创建和测试这样的应用程序的完整信息<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">，请</a>参见<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">如何使应用程序不受密码限制</a> 。
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3FD26072-6982-4DCE-932C-DE152C463992" name="GUID-3FD26072-6982-4DCE-932C-DE152C463992"></a><h4 id="JSSEC-GUID-3FD26072-6982-4DCE-932C-DE152C463992" class="sect4">步骤10：运行测试程序</h4>
                  <div>
                     <p>运行测试应用程序时，需要<code class="codeph">java</code>命令选项将根据各种因素而有所不同，例如您是否将提供程序打包为命名，自动或未命名模块，以及是否配置了它以便<span class="apiname">ServiceLoader</span>类可以搜索它。
                     </p>
                     <div class="section">
                        <p>如果您将提供程序打包为一个命名模块并进行了配置，以便<span class="apiname">ServiceLoader</span>类可以搜索它（通过在其名称中注册它的名称） <code>java.security</code>如<a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置Provider中所述</a> ，然后使用以下命令运行测试程序：</p><pre class="pre codeblock"><code>java --module-path "jars" <span class="variable" translate="no">&lt;other java options&gt;</span></code></pre><p>目录<code>jars</code>包含您的提供者。
                        </p>
                        <p>您可能需要更多选项，具体取决于您的提供程序代码样式（请参阅<a href="howtoimplaprovider.html#GUID-AB9C2460-0CF2-48BA-B9FE-7059071344CE">步骤3.1：创建使用字符串对象注册其服务</a> <a href="howtoimplaprovider.html#GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733">的提供程序和</a><a href="howtoimplaprovider.html#GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733">步骤3.2：创建使用提供程序的提供程序。Service</a> ），如果您将提供程序打包在其他类型的模块中，或者尚未为<span class="apiname">ServiceLoader</span>类配置它。下表描述了这些选项。
                        </p>
                        <p>为了<code class="codeph">java</code>命令，提供程序的名称是<code class="codeph">MyProvider</code> ，其完全合格的类名称为<code class="codeph">p.MyProvider</code> ，并且打包在文件中<code>com.foo.MyProvider.jar</code> ，位于目录中<code>jars</code> 。
                        </p>
                        <div class="tblformalwide" id="GUID-3FD26072-6982-4DCE-932C-DE152C463992__GUID-BC884FEB-0E59-4323-BB7E-5AFEE114EB77">
                           <p class="titleintable">表3-2各种提供程序实现样式的预期Java运行时选项</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="各种提供程序实现样式的预期Java运行时选项" width="100%" border="1" summary="Expected java options depending on module type, provider coding style, and ServiceLoader class configuration" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="8%" id="d41150e2540">模块类型</th>
                                    <th align="left" valign="bottom" width="20%" id="d41150e2542">提供者代码样式</th>
                                    <th align="left" valign="bottom" width="12%" id="d41150e2544">是否配置了ServiceLoader类？</th>
                                    <th align="left" valign="bottom" width="15%" id="d41150e2546">java.security文件中使用的提供者名称</th>
                                    <th align="left" valign="bottom" width="45%" id="d41150e2548">java命令</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2552" headers="d41150e2540 ">未命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2552 d41150e2542 "><span class="apiname">字符串</span>对象或<span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2552 d41150e2544 ">没有</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2552 d41150e2546 ">完全合格的班级名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2552 d41150e2548 "><code class="codeph">java -cp "jars/com.foo.MyProvider.jar" <span class="variable" translate="no"><other java options></span></code></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2570" headers="d41150e2540 ">未命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2570 d41150e2542 "><span class="apiname">字符串</span>对象或<span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2570 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2570 d41150e2546 ">完全合格的类名称或提供程序名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2570 d41150e2548 "><code class="codeph">java -cp "jars/com.foo.MyProvider.jar" <span class="variable" translate="no"><other java options></span></code></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2588" headers="d41150e2540 ">自动</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2588 d41150e2542 "><span class="apiname">字符串</span>对象或<span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2588 d41150e2544 ">没有</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2588 d41150e2546 ">完全合格的班级名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2588 d41150e2548 "><code class="codeph">java --module–path "jars/com.foo.MyProvider.jar" --add–modules=com.foo.MyProvider <span class="variable" translate="no"><other java options></span></code></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2606" headers="d41150e2540 ">自动</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2606 d41150e2542 "><span class="apiname">字符串</span>对象或<span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2606 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2606 d41150e2546 ">完全合格的类名称或提供程序名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2606 d41150e2548 "><code class="codeph">java --module–path "jars/com.foo.MyProvider.jar" <span class="variable" translate="no"><other java options></span></code></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2624" headers="d41150e2540 ">命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2624 d41150e2542 "><span class="apiname">字符串</span>对象或<span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2624 d41150e2544 ">没有</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2624 d41150e2546 ">完全合格的班级名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2624 d41150e2548 "><code class="codeph">java --module–path "jars" --add–modules=com.foo.MyProvider --add–exports=com.foo.MyProvider/p=java.base <span class="variable" translate="no"><other java options></span></code><p>您可以删除<code class="codeph">--add-exports</code>选项，如果您添加<code class="codeph">exports p</code>在模块声明中。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2650" headers="d41150e2540 ">命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2650 d41150e2542 "><span class="apiname">字符串</span>对象</td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2650 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2650 d41150e2546 ">完全合格的班级名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2650 d41150e2548 "><code class="codeph">java --module–path "jars" --add–exports=com.foo.MyProvider/p=java.base <span class="variable" translate="no"><other java options></span></code><p>您可以删除<code class="codeph">--add-exports</code>选项，如果您添加<code class="codeph">exports p</code>在模块声明中。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2674" headers="d41150e2540 ">命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2674 d41150e2542 "><span class="apiname">字符串</span>对象</td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2674 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2674 d41150e2546 ">提供商名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2674 d41150e2548 "><code class="codeph">java --module–path "jars" --add–exports=com.foo.MyProvider/p=java.base <span class="variable" translate="no"><other java options></span></code><p>您可以删除<code class="codeph">--add-exports</code>选项，如果您添加<code class="codeph">exports p</code>在模块声明中。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2698" headers="d41150e2540 ">命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2698 d41150e2542 "><span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2698 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2698 d41150e2546 ">完全合格的班级名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2698 d41150e2548 "><code class="codeph">java --module–path "jars" --add–exports=com.foo.MyProvider/p=java.base<span class="variable" translate="no"><other java options></span></code><p>您可以删除<code class="codeph">--add-exports</code>选项，如果您添加<code class="codeph">exports p</code>在模块声明中。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="8%" id="d41150e2721" headers="d41150e2540 ">命名</td>
                                    <td align="left" valign="top" width="20%" headers="d41150e2721 d41150e2542 "><span class="apiname">提供者。服务</span></td>
                                    <td align="left" valign="top" width="12%" headers="d41150e2721 d41150e2544 ">是</td>
                                    <td align="left" valign="top" width="15%" headers="d41150e2721 d41150e2546 ">提供商名称</td>
                                    <td align="left" valign="top" width="45%" headers="d41150e2721 d41150e2548 "><code class="codeph">java --module–path "jars" <span class="variable" translate="no"><other java options></span></code></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>一旦确定了适当的<code class="codeph">java</code>测试程序的选项，请运行它们。调试您的代码，并根据需要继续测试。如果Java运行时似乎无法找到您的一种算法，请查看前面的步骤并确保它们全部完成。
                        </p>
                        <p>确保使用不同的安装选项（例如，配置为使用<span class="apiname">ServiceLoader</span>类或在类路径或模块路径中找到）和执行环境（在运行或不运行安全管理器的情况下）对程序进行测试。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p"> </div>
                     <!-- class="section" -->
                     <ol>
                        <li id="GUID-3FD26072-6982-4DCE-932C-DE152C463992__IFYOUFINDDURINGTESTINGTHATYOURCODEN-7568E2A4"><strong>可选：</strong> <span>如果在测试期间发现您的代码需要修改，请进行更改并重新编译<a href="howtoimplaprovider.html#GUID-83742677-6E39-4A8D-BF0F-BC743E3AE43C">步骤5：编译代码</a> 。</span></li>
                        <li><span>将更新后的提供程序代码放在JAR文件中（ <a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">步骤6：将您的提供程序放在JAR文件中</a> ）。</span></li>
                        <li><span>签名JAR文件（ <a href="howtoimplaprovider.html#GUID-2D4432F9-1C3C-4A91-8612-2B2840188B36">如果需要，请执行步骤7：签名JAR文件</a> ）。</span></li>
                        <li><span>重新配置提供程序（ <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置提供程序</a> ）。</span></li>
                        <li><strong>可选：</strong> <span>如果需要，请修复或添加权限（ <a href="howtoimplaprovider.html#GUID-6E267101-15F4-4E7B-A6EB-64E36AAD1285">步骤8.2：设置提供者权限</a> ）。</span></li>
                        <li id="GUID-3FD26072-6982-4DCE-932C-DE152C463992__RE-TESTYOURPROGRAMS.-7568E6BE"><span>运行您的程序。</span></li>
                        <li><strong>可选：</strong> <span>如果需要，请重复步骤1至6。</span></li>
                     </ol>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E" name="GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E"></a><h4 id="JSSEC-GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E" class="sect4">步骤11：如有需要，申请美国政府出口批准</h4>
                  <div>
                     <p>所有其供应商可能会出口到美国以外的美国供应商，都应向美国商务部工业与安全局申请出口批准。</p>
                     <div class="section">请咨询您的出口顾问以获取更多信息。
                        <div class="p">
                           <div class="infoboxnote" id="GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E__GUID-1600EB10-8AAE-40E5-8BFB-3CB61D506E4B">
                              <p class="notep1">注意：</p>如果您的提供者打电话<code class="codeph">Cipher.getInstance()</code>和返回<code class="codeph">Cipher</code>无论用户下载的管辖区策略文件允许哪种加密强度，对象都需要执行强加密，您应该包括<code class="codeph">cryptoPerms</code>您打算为提供者捆绑在JAR文件中的权限策略文件，该文件为所需的加密强度指定了适当的权限。此文件的必要性就像要求“免除”密码限制的小程序和应用程序必须包括<code class="codeph">cryptoPerms</code>其JAR文件中的权限策略文件。请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">如何使应用程序不受密码限制</a> 。
                           </div>
                        </div>
                        <p>这是两个可能有用的网址：</p>
                        <ul style="list-style-type:disc">
                           <li><a href="http://www.commerce.gov" target="_blank">美国商务部</a></li>
                           <li><a href="http://www.bis.doc.gov" target="_blank">工业和安全局</a></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245" name="GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245"></a><h4 id="JSSEC-GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245" class="sect4">步骤12：记录您的提供商及其支持的服务</h4>
                  <div>
                     <p></p>
                     <div class="section">下一步是为客户编写文档。至少，您需要指定：</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>程序应使用名称来引用您的提供程序。</span><div>
                              <div class="infoboxnote" id="GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245__GUID-49816D37-1A18-4121-A552-CB368FB6ABA6">
                                 <p class="notep1">注意：</p>在撰写本文时，提供者名称搜索<span class="bold">区分大小写</span> 。也就是说，如果您的主类将您的提供程序名称指定为“ CryptoX”，但是用户请求“ CRYPTOx”，则将找不到您的提供程序。这种行为将来可能会改变，但是现在请务必警告您的客户使用您指定的确切大小写。
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>您的提供商实施的算法和其他服务的类型。</span></li>
                        <li class="stepexpand"><span>安装提供程序的说明与<a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="注册您的提供者，以便JCE框架可以通过ServiceLoader类或在类路径或模块路径中找到您的提供者。">步骤8.1：配置提供程序中的</a>说明类似，不同之处在于信息和示例应特定于您的提供程序。</span></li>
                        <li class="stepexpand"><span>如果运行安全管理器，则提供程序将需要的权限，如<a href="howtoimplaprovider.html#GUID-6E267101-15F4-4E7B-A6EB-64E36AAD1285">步骤8.2：设置提供程序的权限中所述</a> 。</span></li>
                     </ul>
                     <div class="section">此外，您的文档应指定客户端感兴趣的任何其他内容，例如任何默认算法参数。</div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9" name="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9"></a><h5 id="JSSEC-GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9" class="sect5">步骤12.1：指示您的实现对于消息摘要和MAC是否可克隆</h5>
                     <div>
                        <p>对于每个“消息摘要”和“ MAC”算法，请指示您的实现是否可克隆。这在技术上不是必需的，但可以通过告诉客户端是否可以通过克隆来实现中间消息摘要或MAC，从而节省了一些时间和客户端代码。</p>
                        <div class="section">
                           <p>不知道是否<code class="codeph">MessageDigest</code>要么<code class="codeph">Mac</code>可克隆的实现可以通过尝试克隆对象并捕获潜在的异常来找出，如以下示例所示：</p><pre class="codeblock"><code>    try {
        // try and clone it
        /* compute the MAC for i1 */
        mac.update(i1);
        byte[] i1Mac = mac.clone().doFinal();

        /* compute the MAC for i1 and i2 */
        mac.update(i2);
        byte[] i12Mac = mac.clone().doFinal();

        /* compute the MAC for i1, i2 and i3 */
        mac.update(i3);
        byte[] i123Mac = mac.doFinal();
    } catch (CloneNotSupportedException cnse) {
        // have to use an approach not involving cloning
    } 
</code></pre><p>哪里，</p>
                           <dl>
                              <dt class="dlterm"><a name="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-7F81CA19-A39F-4982-BEE5-24482BB92369">
                                    <!-- --></a><code class="codeph">mac</code></dt>
                              <dd>表示当他们通过呼叫请求一个MAC对象时收到的MAC对象<code class="codeph">Mac.getInstance</code></dd>
                              <dt class="dlterm"><a name="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-68D66E9E-92AD-4A6F-B888-6E46A19A0330"><!-- --></a> <code class="codeph">i1</code> ， <code class="codeph">i2</code>和<code class="codeph">i3</code></dt>
                              <dd>指示输入字节数组，并且它们要为以下各项计算单独的哈希：<ul style="list-style-type:disc">
                                    <li><code class="codeph">i1</code></li>
                                    <li><code class="codeph">i1 and i2</code></li>
                                    <li><code class="codeph">i1, i2, and i3</code></li>
                                 </ul>
                              </dd>
                           </dl>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-159B4F88-3142-4A57-A19B-D3EB7A36D437">密钥对生成器</p>
                           <p>对于密钥对生成器算法，如果客户端未显式初始化密钥对生成器（通过调用<code class="codeph">initialize</code>方法），每个提供程序必须提供并记录默认的初始化。
                           </p>
                           <p>例如， <span class="variable" translate="no">SunJCE</span>提供程序提供的Diffie-Hellman密钥对生成器使用默认的质数模量（ <code class="codeph">keysize</code> ）（2048位）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-3FC8D9BE-D65B-4606-823B-9FFDE20AD847">关键工厂</p>
                           <p>提供者应记录其（秘密）密钥工厂支持的所有关键规格。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-339AAE5D-44A6-4BB4-9F9B-92406BB3C2FE">算法参数生成器</p>
                           <p>如果客户端未明确初始化算法参数生成器（通过调用<code class="codeph">init</code>中的方法<code class="codeph">AlgorithmParameterGenerator</code>引擎类），每个提供者必须提供并记录默认的初始化。
                           </p>
                           <p>例如， <span class="variable" translate="no">SunJCE</span>提供程序使用默认的素数模数大小（ <code class="codeph">keysize</code> ）的2048位（用于生成Diffie-Hellman参数）， <span class="variable" translate="no">Sun</span>提供程序的默认模数素数大小为2048位（用于生成DSA参数）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-0F8EDC94-E4EE-4A31-A860-2448C91EE6DF">签名算法</p>
                           <p>如果您实施签名算法，则应记录签名（由其中一个生成的格式）。 <code class="codeph">sign</code>方法）进行编码。
                           </p>
                           <p>例如，“ SUN”提供程序提供的SHA256withDSA签名算法将签名编码为标准<code class="codeph">ASN.1 SEQUENCE</code>两个整数<code class="codeph">r</code>和<code class="codeph">s</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-D07D7305-7910-4466-85CE-229201B60B32">随机数生成（SecureRandom）算法</p>
                           <p>对于随机数生成算法，请提供有关生成的数字有多“随机”以及当随机数生成器是自播种子时种子质量的信息。还要注意当<code class="codeph">SecureRandom</code>对象（及其封装<code class="codeph">SecureRandomSpi</code>实现对象）反序列化：如果后续调用<code class="codeph">nextBytes</code>方法（调用<code class="codeph">engineNextBytes</code>封装方法<code class="codeph">SecureRandomSpi</code>还原对象的对象产生与原始对象完全相同（随机）的字节，然后让用户知道，如果这种行为不受欢迎，则应通过调用其随机对象来播种该还原对象。 <code class="codeph">setSeed</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-79D629C4-F775-4D03-8BE3-1E4D11021491">证书工厂</p>
                           <p>提供者应记录工厂可以创建哪些类型的证书（及其版本号，如果相关）。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CC2277C4-14EA-45A8-BC81-8A0715FDC8E9__GUID-633795DC-5870-4DC0-8070-51E609C26FD1">密钥库</p>
                           <p>提供者应记录有关密钥库实现的任何相关信息，例如其基础数据格式。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3521E2A8-93B5-4D0F-AE2D-DC1B5E6857B7" name="GUID-3521E2A8-93B5-4D0F-AE2D-DC1B5E6857B7"></a><h4 id="JSSEC-GUID-3521E2A8-93B5-4D0F-AE2D-DC1B5E6857B7" class="sect4">步骤13：使您的类文件和文档对客户端可用</h4>
                  <div>
                     <p>在编写，配置，测试，安装和记录提供程序软件之后，请向客户提供文档。</p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-C8B79D46-6EA9-4E27-8083-7CB967732BB3" name="GUID-C8B79D46-6EA9-4E27-8083-7CB967732BB3"></a><h3 id="JSSEC-GUID-C8B79D46-6EA9-4E27-8083-7CB967732BB3" class="sect3">进一步的实施细节和要求</h3>
               <div>
                  <p>本节提供有关别名，服务相互依赖性，算法参数生成器和算法参数的其他信息。</p>
               </div>
               <div class="sect3"><a id="GUID-735A3CD6-0EE5-423C-B5BA-61500BA20854" name="GUID-735A3CD6-0EE5-423C-B5BA-61500BA20854"></a><h4 id="JSSEC-GUID-735A3CD6-0EE5-423C-B5BA-61500BA20854" class="sect4">别名</h4>
                  <div>
                     <p>在JDK中，别名方案使客户端可以在引用算法或类型时使用别名，而不是标准名称。</p>
                     <p>对于许多密码算法和类型，在<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称中</a>定义了一个正式的“标准名称”。
                     </p>
                     <p>例如，“ SHA-256”是RFC 1321中定义的SHA-256消息摘要算法的标准名称。 <code class="codeph">DiffieHellman</code>是PKCS3中定义的Diffie-Hellman密钥协商算法的标准。
                     </p>
                     <p>在JDK中，有一个别名方案，使客户端可以在引用算法或类型时使用别名而不是其标准名称。</p>
                     <p>例如，“ SUN”提供商的主类（ <code class="codeph">Sun.java</code> ）定义别名<code class="codeph">"SHA1/DSA"</code>用于标准名称为<code class="codeph">"SHA1withDSA"</code> 。因此，以下语句是等效的：</p><pre class="codeblock"><code>
    Signature sig = Signature.getInstance("SHA1withDSA", "SUN");

    Signature sig = Signature.getInstance("SHA1/DSA", "SUN");
</code></pre><p>别名可以在您的“主类”中定义（请参阅<a href="howtoimplaprovider.html#GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" title="创建java.security的子类。提供程序类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。">步骤3：编写主类，Provider的子类</a> ）。要定义别名，请创建一个名为</p><pre class="codeblock"><code>
    <code class="codeph">Alg.Alias.</code><span class="variable" translate="no">engineClassName.aliasName</span>
</code></pre><p>其中<span class="variable" translate="no">engineClassName</span>是引擎类的名称（例如， <code class="codeph">Signature</code> ）， <span class="variable" translate="no">aliasName</span>是您的别名。该属性的<span class="variable" translate="no">value</span>必须是被别名的算法（或类型）的标准算法（或类型）名称。
                     </p>
                     <p>例如，“ SUN”提供程序定义别名<code class="codeph">"SHA1/DSA"</code>用于标准名称为的签名算法<code class="codeph">"SHA1withDSA"</code>通过设置一个名为<code class="codeph">Alg.Alias.Signature.SHA1/DSA</code>具有价值<code class="codeph">SHA1withDSA</code>通过以下方式：</p><pre class="codeblock"><code>
    put("Alg.Alias.Signature.SHA1/DSA", "SHA1withDSA");
</code></pre><div class="infoboxnote" id="GUID-735A3CD6-0EE5-423C-B5BA-61500BA20854__GUID-A60FE441-C25A-4F2E-B63D-944121E2B674">
                        <p class="notep1">注意：</p>一个提供程序定义的别名仅可用于该提供程序，而不能用于任何其他提供程序。因此，通过定义的别名<span class="variable" translate="no">SunJCE</span>提供商只提供给<span class="variable" translate="no">SunJCE</span>提供商。
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406" name="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406"></a><h4 id="JSSEC-GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406" class="sect4">服务相互依赖</h4>
                  <div>
                     <p>某些算法需要使用其他类型的算法。例如，PBE算法通常需要使用消息摘要算法才能将密码转换为密钥。</p>
                     <p>如果要实现一种需要另一种的算法，则可以执行以下操作之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>为两者提供您自己的实现。</p>
                        </li>
                        <li>
                           <p>让您的一种算法的实现使用另一种类型的算法的实例，该实例由每个Java SE Platform安装附带的默认<span class="variable" translate="no">Sun</span>提供程序提供。例如，如果您要实现一个需要消息摘要算法的PBE算法，则可以通过调用以下代码获取实现SHA256消息摘要算法的类的实例：</p><pre class="pre codeblock"><code>    MessageDigest.getInstance("SHA256", "SUN")
</code></pre></li>
                        <li>
                           <p>让您的一种算法的实现使用另一种特定提供者提供的另一种算法的实例。仅当您确定所有将使用提供程序的客户端也将安装其他提供程序时，这才是适当的。</p>
                        </li>
                        <li>
                           <p>让您的一种算法的实现使用另一种（未指定）提供程序提供的另一种算法的实例。也就是说，您可以按名称请求算法，但无需指定任何特定的提供程序，例如：</p><pre class="pre codeblock"><code>    MessageDigest.getInstance("SHA256")
</code></pre><p>仅当您确定在将使用提供程序的每个Java平台上至少安装了所请求算法的一种实现（在本例中为SHA256）时，这才是适当的。</p>
                        </li>
                     </ul>
                     <p>以下是一些常见的算法相互依赖性类型：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-BF0865BF-1099-4ED4-AE57-2A701B697FCC">签名和消息摘要算法</p>
                        <p>签名算法通常需要使用消息摘要算法。例如，SHA256withDSA签名算法需要SHA256消息摘要算法。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-9DFFFD0E-FFF1-400E-A664-248C13B07E31">签名和（伪）随机数生成算法</p>
                        <p>签名算法通常需要使用（伪）随机数生成算法。例如，为了生成DSA签名，需要这样的算法。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-44EEC7DD-0BDF-420E-BFC5-D86268BCE3F7">密钥对生成和消息摘要算法</p>
                        <p>密钥对生成算法通常需要使用消息摘要算法。例如，DSA密钥是使用SHA-256消息摘要算法生成的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-017D6037-3458-403F-8AC7-78F3400AD58B">算法参数生成和消息摘要算法</p>
                        <p>算法参数生成器通常需要使用消息摘要算法。例如，DSA参数是使用SHA-256消息摘要算法生成的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-7E836F82-E809-441A-AB3E-982113FA5476">密钥库和消息摘要算法</p>
                        <p>密钥库实现通常会利用消息摘要算法来计算密钥哈希（密钥是用户提供的密码），以检查密钥库的完整性并确保密钥库未被篡改。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-29D07580-4703-4AAE-9B55-2555D969EEDB">密钥对生成算法和算法参数生成器</p>
                        <p>密钥对生成算法有时需要生成一组新的算法参数。它既可以直接生成参数，也可以使用算法参数生成器。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-6E7EB0EF-1CD6-4EFE-9A7E-CDB45C2D01D0">密钥对生成，算法参数生成和（伪）随机数生成算法</p>
                        <p>密钥对生成算法可能需要随机性源，以便生成新的密钥对以及可能与密钥相关联的一组新参数。该随机性源由<span class="apiname">SecureRandom</span>对象表示。密钥对生成算法的实现可以自身生成密钥参数，或者可以使用算法参数生成器生成密钥参数，在这种情况下，密钥对可以或可以不使用随机源来初始化算法参数生成器。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-543705D6-DDEC-4CC6-8C72-5DA888AF50FF">算法参数生成器和算法参数</p>
                        <p>算法参数生成器的<span class="apiname">engineGenerateParameters</span>方法必须返回<span class="apiname">AlgorithmParameters</span>实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-46B5E8BA-E76D-4AA1-8EAC-1207E6ED2EA3">签名和密钥对生成算法或密钥工厂</p>
                        <p>如果要实现签名算法，则实现的<span class="apiname">engineInitSign</span>和<span class="apiname">engineInitVerify</span>方法将需要对基础算法有效的传入密钥（例如，DSS算法的DSA密钥）。您可以执行以下操作之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>还创建自己的类以实现适当的接口（例如，从包<span class="apiname">java.security.interfaces中</span>实现<span class="apiname">DSAPrivateKey</span>和<span class="apiname">DSAPublicKey</span>接口的类），并创建自己的密钥对生成器和/或返回这些类型的密钥的密钥工厂。要求传递给<span class="apiname">engineInitSign</span>和<span class="apiname">engineInitVerify</span>的密钥是已实现的密钥类型，即从密钥对生成器或密钥工厂生成的密钥。或者你可以</p>
                           </li>
                           <li>
                              <p>接受来自其他密钥对生成器或其他密钥工厂的密钥，只要它们是使签名实现能够获取所需信息的适当接口的实例即可（例如，私钥和公钥以及密钥参数）。例如，DSS <span class="apiname">Signature</span>类的<span class="apiname">engineInitSign</span>方法可以接受作为<span class="apiname">java.security.interfaces实例的任何私钥<span class="apiname">。DSAPrivateKey</span> 。
                              </span></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8ED3CE1A-B25A-4E16-B45D-4EB36C9A7406__GUID-814A4711-C96F-4FC1-A433-7C87985BC06C">密钥库以及密钥和证书工厂</p>
                        <p>密钥库实现通常会利用密钥工厂来解析存储在密钥库中的密钥，并使用证书工厂来解析存储在密钥库中的证书。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A46F72E3-DFF4-4864-8BBC-30684ADF78BA" name="GUID-A46F72E3-DFF4-4864-8BBC-30684ADF78BA"></a><h4 id="JSSEC-GUID-A46F72E3-DFF4-4864-8BBC-30684ADF78BA" class="sect4">默认初始化</h4>
                  <div>
                     <p>如果客户端未显式初始化密钥对生成器或算法参数生成器，则此类服务的每个提供程序都必须提供（并记录）默认初始化。</p>
                     <div class="example" id="GUID-A46F72E3-DFF4-4864-8BBC-30684ADF78BA__GUID-9E8C5B1A-BE08-456F-AD70-62B0CFD8764F">例如， <span class="variable" translate="no">Sun</span>提供程序使用1024位的默认模数大小（强度）来生成DSA参数，而“ SunJCE”提供程序使用2048位的默认模数大小（键大小）来生成Diffie-Hellman参数。
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A80C8BAC-AD25-4328-AE62-987F805B6BAF" name="GUID-A80C8BAC-AD25-4328-AE62-987F805B6BAF"></a><h4 id="JSSEC-GUID-A80C8BAC-AD25-4328-AE62-987F805B6BAF" class="sect4">默认密钥对生成器参数要求</h4>
                  <div>
                     <p>如果实现密钥对生成器，则实现应提供在客户端未指定参数时使用的默认参数。</p>
                     <div class="section">
                        <p>您提供的文档（ <a href="howtoimplaprovider.html#GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245">第12步：为您的提供商及其支持的服务进行</a>文档编制）应说明默认参数是什么。
                        </p>
                        <p>例如， <span class="variable" translate="no">Sun</span>提供程序中的DSA密钥对生成器提供了一组预先计算的<code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code>生成512位，768位，1024位和2048位密钥对的默认值。下列<code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code>值用作生成1024位DSA密钥对的默认值：</p><pre class="codeblock"><code>
p = fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
    b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
    801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
    1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
    f3ae2b61 d72aeff2 2203199d d14801c7

q = 9760508f 15230bcc b292b982 a2eb840b f0581cf5

g = f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
    3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
    b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
    0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
    928b665e 807b5525 64014c3b fecf492a
</code></pre><p>（ <code class="codeph">p</code>和<code class="codeph">q</code>此处给出的值是由素数生成标准使用160位生成的</p><pre class="codeblock"><code>
SEED:  8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
</code></pre><p>有了这个种子，算法发现<code class="codeph">p</code>和<code class="codeph">q</code>当计数器位于92时。）
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B1428B09-5542-4D36-9C0D-D78A8B2B3C00" name="GUID-B1428B09-5542-4D36-9C0D-D78A8B2B3C00"></a><h4 id="JSSEC-GUID-B1428B09-5542-4D36-9C0D-D78A8B2B3C00" class="sect4">提供者。服务等级</h4>
                  <div>
                     <p><code class="codeph">Provider.Service</code>类为提供商提供了一种宣传其服务并支持其他功能的替代方法。
                     </p>
                     <div class="section">
                        <p>自从引入以来，安全提供者就通过他们放入其Hashtable条目中的格式正确的键值字符串对来发布其服务信息。尽管此机制既简单又方便，但是它限制了自定义数量。因此，JDK 5.0引入了第二个选项，即<code class="codeph">Provider.Service</code>类。它为提供商提供了一种宣传其服务的替代方法，并支持如下所述的其他功能。请注意，此添加项与使用String值的Hashtable条目的旧方法完全兼容。JDK 5.0上的提供程序可以根据自己的喜好选择一种方法，甚至可以同时使用两种方法。
                        </p>
                        <p>一种<code class="codeph">Provider.Service</code>对象封装有关服务的所有信息。这是提供服务的提供商，其类型（例如<code class="codeph">MessageDigest</code>要么<code class="codeph">Signature</code> ），算法名称以及实现服务的类的名称。（可选）它还包括此服务（别名）和属性的备用算法名称的列表，它们是（名称，值）字符串对的映射。另外，它定义了方法<code class="codeph">newInstance()</code>和<code class="codeph">supportsParameter()</code> 。它们具有默认实现，但是如果需要，可以被提供程序覆盖，例如与硬件安全令牌对接的提供程序可能就是这种情况。
                        </p>
                        <p>的<code class="codeph">newInstance()</code>当安全框架需要构造新的实现实例时，将使用该方法。默认实现使用反射来为相应的服务类型调用标准构造函数。对于所有标准服务，除了<code class="codeph">CertStore</code> ，这是no-args构造函数。的<code class="codeph">constructorParameter</code>在这种情况下，to <span class="apiname">newInstance（）的值</span>必须为null。对于类型的服务<code class="codeph">CertStore</code> ，采用<code class="codeph">CertStoreParameters</code>对象被调用，并且<code class="codeph">constructorParameter</code>必须是的非null实例<code class="codeph">CertStoreParameters.</code>安全提供者可以重写<span class="apiname">newInstance（）</span>方法以实现适合该实现的实例化。它可以使用直接调用或调用构造函数，该构造函数传递特定于Provider实例或令牌的附加信息。例如，如果系统上存在多个智能卡阅读器，则它可能传递有关新创建的服务将与之关联的阅读器的信息。但是，尽管进行了定制，但所有实现都必须遵循以下约定<code class="codeph">constructorParameter</code>如上所述。
                        </p>
                        <p><span class="apiname">supportsParameter（）</span>测试服务是否可以使用指定的参数。如果此服务无法使用参数，则返回false。如果此服务可以使用该参数，无法进行快速测试或状态未知，则返回true。安全框架将其与某些类型的服务一起使用，以快速排除不匹配的实现。当前仅针对以下标准服务进行定义： <code class="codeph">Signature</code> ， <code class="codeph">Cipher</code> ， <code class="codeph">Mac</code>和<code class="codeph">KeyAgreement</code> 。的<code class="codeph">parameter</code>必须是<code class="codeph">Key</code>在这些情况下。例如，对于<code class="codeph">Signature</code>服务，框架在实例化服务之前测试服务是否可以使用提供的Key。默认实现检查属性<code class="codeph">SupportedKeyFormats</code>和<code class="codeph">SupportedKeyClasses</code>如下所述。再次，提供者可以重写此方法以实施其他测试。
                        </p>
                        <p>的<code class="codeph">SupportedKeyFormats</code>属性是编码密钥支持的格式的列表（由<code class="codeph">key.getFormat()</code> ），以“ |”分隔（管道）字符。例如， <code class="codeph">X.509|PKCS#8</code> 。的<code class="codeph">SupportedKeyClasses</code>属性是由“ |”分隔的接口类名称的列表。字符。如果密钥对象可分配给已命名的那些类或接口中的至少一个，则认为该密钥对象是可接受的。换句话说，如果键对象的类是列出的类之一（或类本身）的子类，或者它实现了列出的接口。一个示例值是<code class="codeph">"java.security.interfaces.RSAPrivateKey|java.security.interfaces.RSAPublicKey"</code> 。
                        </p>
                        <p>Provider类中已添加了四个方法，用于添加和查找服务。如前所述，这些方法以及现有Properties方法的实现都是经过专门设计的，以确保与现有Provider子类的兼容性。这可以通过以下方式实现：</p>
                        <p>如果使用旧版Properties方法添加条目，则Provider类确保在通过<span class="apiname">getService（）</span>查找之前，将属性字符串解析为等效的Service对象。同样，如果使用<span class="apiname">putService（）</span>方法，则等效属性字符串将同时放入提供程序的哈希表中。如果提供程序实现重写Provider类中的任何方法，则必须确保其实现不会干扰此转换。为避免出现问题，建议不要在实现中覆盖其中的任何方法。 <code class="codeph">Provider</code>类。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-604DD293-1F38-487D-A2F9-F9E95F5D727C" name="GUID-604DD293-1F38-487D-A2F9-F9E95F5D727C"></a><h4 id="JSSEC-GUID-604DD293-1F38-487D-A2F9-F9E95F5D727C" class="sect4">签名格式</h4>
                  <div>
                     <p>签名算法应指定签名编码的格式。</p>
                     <div class="section">
                        <p>如果您实施签名算法，则您提供的文档（ <a href="howtoimplaprovider.html#GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245">第12步：为提供者及其支持的服务</a>进行文档编制）应指定签名格式（由其中一个生成的）。 <code class="codeph">sign</code>方法）进行编码。
                        </p>
                        <p>例如， <span class="variable" translate="no">Sun</span>提供程序提供的<span class="variable" translate="no">SHA1withDSA</span>签名算法将签名编码为标准ASN.1序列（两个） <code class="codeph">ASN.1 INTEGER</code>值： <code class="codeph">r</code>和<code class="codeph">s</code> ， 以该顺序：</p><pre class="codeblock"><code>
SEQUENCE ::= {
        r INTEGER,
        s INTEGER }
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9" name="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9"></a><h4 id="JSSEC-GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9" class="sect4">DSA接口及其必需的实现</h4>
                  <div>
                     <p>Java安全API包含接口（在<code class="codeph">java.security.interfaces</code>包），以方便程序员实现DSA服务。
                     </p>
                     <div class="section">
                        <p>Java安全性API包含以下接口：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAKey.html" target="_blank"><code class="codeph">Interface DSAKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAKeyPairGenerator.html" target="_blank"><code class="codeph">Interface DSAKeyPairGenerator</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAParams.html" target="_blank"><code class="codeph">Interface DSAParams</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPrivateKey.html" target="_blank"><code class="codeph">Interface DSAPrivateKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPublicKey.html" target="_blank"><code class="codeph">Interface DSAPublicKey</code></a></p>
                           </li>
                        </ul>
                        <p>以下各节讨论了这些接口的实现要求。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__DSAKEYPAIRGENERATOR-7140AF61">
                        <p class="subhead3" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__GUID-6184B702-ABE2-4E9C-BC0B-0DA3FE3AB320">DSAKeyPairGenerator</p>
                        <p>介面<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAKeyPairGenerator.html" target="_blank"><code class="codeph">Interface DSAKeyPairGenerator</code></a>已过时。以前需要它使客户端能够提供要使用的DSA特定参数，而不是实现中提供的默认参数。但是，在Java中，它不再是必需的。一个新的<code class="codeph">KeyPairGenerator</code><code class="codeph">initialize</code>需要一个方法<code class="codeph">AlgorithmParameterSpec</code>参数使客户端可以指示特定于算法的参数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__DSAPARAMSIMPLEMENTATION-7140B38E">
                        <p class="subhead3" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__GUID-7A32C187-6D4C-4A03-85C3-90A45DC7D28C">DSAParams实施</p>
                        <p>如果要实现DSA密钥对生成器，则需要一个类来实现<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAParams.html" target="_blank"><code class="codeph">Interface DSAParams</code></a>用于持有和返回<code class="codeph">p</code> ， <code class="codeph">q</code>和<code class="codeph">g</code>参数。
                        </p>
                        <p>一种<code class="codeph">DSAParams</code>如果您实施了<code class="codeph">DSAPrivateKey</code>和<code class="codeph">DSAPublicKey</code>接口。 <code class="codeph">DSAPublicKey</code>和<code class="codeph">DSAPrivateKey</code>两者都扩展了DSAKey接口，其中包含一个<code class="codeph">getParams</code>必须返回a的方法<code class="codeph">DSAParams</code>宾语。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__GUID-421108DE-1D1A-4A5F-BB41-D64F0B5B8B38">
                              <p class="notep1">注意：</p>有一个<code class="codeph">DSAParams</code> JDK中内置的实现： <code class="codeph">java.security.spec.DSAParameterSpec</code>类。
                           </div> 
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__DSAPRIVATEKEYANDDSAPUBLICKEYIMPLEME-7140B6D2">
                        <p class="subhead3" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__GUID-FCE0D734-D77D-4514-A300-A9260CBADF3D">DSAPrivateKey和DSAPublicKey实现</p>
                        <p>如果您实现DSA密钥对生成器或密钥工厂，则需要创建实现<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPrivateKey.html" target="_blank"><code class="codeph">Interface DSAPrivateKey</code></a>和<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPublicKey.html" target="_blank"><code class="codeph">Interface DSAPublicKey</code></a>接口。
                        </p>
                        <p>如果您实施DSA密钥对生成器，则您的<code class="codeph">generateKeyPair</code>方法（在您的<code class="codeph">KeyPairGeneratorSpi</code>子类）将返回这些接口的实现实例。
                        </p>
                        <p>如果您实施DSA密钥工厂，则您的<code class="codeph">engineGeneratePrivate</code>方法（在您的<code class="codeph">KeyFactorySpi</code>子类）将返回您的实例<code class="codeph">DSAPrivateKey</code>实施，以及您的<code class="codeph">engineGeneratePublic</code>方法将返回您的实例<code class="codeph">DSAPublicKey</code>实施。
                        </p>
                        <p>还有，你的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法将期望传入的键是的实例<code class="codeph">DSAPrivateKey</code>要么<code class="codeph">DSAPublicKey</code>实施。的<code class="codeph">getParams</code>接口实现提供的方法对于从键中获取和提取参数然后使用参数（例如，作为参数的参数）非常有用。 <code class="codeph">DSAParameterSpec</code>调用构造函数以从可用于初始化参数的参数值创建参数规范<code class="codeph">KeyPairGenerator</code> DSA的对象。</p>
                        <p>如果您实施DSA签名算法，则您的<code class="codeph">engineInitSign</code>方法（在您的<code class="codeph">SignatureSpi</code>子类）将通过<code class="codeph">DSAPrivateKey</code>和你的<code class="codeph">engineInitVerify</code>该方法将有望通过<code class="codeph">DSAPublicKey</code> 。
                        </p>
                        <p>请注意： <code class="codeph">DSAPublicKey</code>和<code class="codeph">DSAPrivateKey</code>接口分别定义了一个非常通用的，独立于提供程序的接口，用于DSA公共密钥和私有密钥。的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法（在您的<code class="codeph">KeyFactorySpi</code>子类）还可以检查传入的键是否实际上是其提供者自己的实现的实例<code class="codeph">DSAPrivateKey</code>要么<code class="codeph">DSAPublicKey</code>例如，以利用提供者特定的实施细节。DSA签名算法也是如此<code class="codeph">engineInitSign</code>和<code class="codeph">engineInitVerify</code>方法（在您的<code class="codeph">SignatureSpi</code>子类）。
                        </p>
                        <p>要了解实现该方法的类需要实现哪些方法<code class="codeph">DSAPublicKey</code>和<code class="codeph">DSAPrivateKey</code>接口，首先请注意以下接口签名：</p>
                        <p>在里面<code class="codeph">java.security.interfaces</code>包：</p><pre class="codeblock"><code>
   public interface DSAPrivateKey extends DSAKey,
                java.security.PrivateKey

   public interface DSAPublicKey extends DSAKey,
                java.security.PublicKey

   public interface DSAKey 
</code></pre><p>在里面<code class="codeph">java.security</code>包：</p><pre class="codeblock"><code>
   public interface PrivateKey extends Key

   public interface PublicKey extends Key

   public interface Key extends java.io.Serializable 
</code></pre><p>为了实施<code class="codeph">DSAPrivateKey</code>和<code class="codeph">DSAPublicKey</code>接口，您必须实现它们定义的方法以及由它们直接或间接扩展的接口定义的方法。
                        </p>
                        <p>因此，对于私钥，您需要提供一个实现</p>
                        <ul style="list-style-type:disc">
                           <li>的<code class="codeph">getX</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPrivateKey.html" target="_blank"><code class="codeph">Interface DSAPrivateKey</code></a>接口。
                           </li>
                           <li>的<code class="codeph">getParams</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAKey.html" target="_blank"><code class="codeph">Interface DSAKey</code></a>接口，因为<code class="codeph">DSAPrivateKey</code>延伸<code class="codeph">DSAKey</code> 。注意： <code class="codeph">getParams</code>方法返回一个<code class="codeph">DSAParams</code>对象，因此您还必须有一个<a href="howtoimplaprovider.html#GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__DSAPARAMSIMPLEMENTATION-7140B38E"><code class="codeph">DSAParams</code>实施</a> 。
                           </li>
                           <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a>接口，因为<code class="codeph">DSAPrivateKey</code>延伸<code class="codeph">java.security.PrivateKey</code>和<code class="codeph">PrivateKey</code>延伸<code class="codeph">Key</code> 。
                              <p>同样，对于公共DSA密钥，您需要提供一个实现以下内容的类：</p> 
                              <ul style="list-style-type:disc">
                                 <li>的<code class="codeph">getY</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPublicKey.html" target="_blank"><code class="codeph">Interface DSAPublicKey</code></a>接口。
                                 </li>
                                 <li>的<code class="codeph">getParams</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAKey.html" target="_blank"><code class="codeph">Interface DSAKey</code></a>接口，因为<code class="codeph">DSAPublicKey</code>扩展DSAKey。
                                    <div class="infoboxnote" id="GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__GUID-9A51D01D-705B-4488-976E-73983D4591CF">
                                       <p class="notep1">注意：</p>的<code class="codeph">getParams</code>方法返回一个<code class="codeph">DSAParams</code>对象，因此您还必须具有<a href="howtoimplaprovider.html#GUID-C618C5AF-737E-41AB-8FD3-6F5BB8A319A9__DSAPARAMSIMPLEMENTATION-7140B38E">DSAParams实现</a> 。
                                    </div>
                                 </li>
                                 <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a> ，因为<code class="codeph">DSAPublicKey</code>延伸<code class="codeph">java.security.PublicKey</code>和<code class="codeph">PublicKey</code>延伸<code class="codeph">Key</code> 。
                                 </li>
                              </ul> 
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-353BF021-CABC-4CB4-A019-927D423B4627" name="GUID-353BF021-CABC-4CB4-A019-927D423B4627"></a><h4 id="JSSEC-GUID-353BF021-CABC-4CB4-A019-927D423B4627" class="sect4">RSA接口及其必需的实现</h4>
                  <div>
                     <p>Java安全API包含接口（在<code class="codeph">java.security.interfaces</code>软件包），以方便程序员实现RSA服务。
                     </p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateKey.html" target="_blank"><code class="codeph">Interface RSAPrivateKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateCrtKey.html" target="_blank"><code class="codeph">Interface RSAPrivateCrtKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><code class="codeph">Interface RSAPublicKey</code></a></p>
                           </li>
                        </ul>以下各节讨论了这些接口的实现要求。
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-353BF021-CABC-4CB4-A019-927D423B4627__GUID-6D469E60-0FE0-4C0B-B975-0A1CF57FB454">RSAPrivateKey，RSAPrivateCrtKey和RSAPublicKey实现</p>
                        <p>如果实现RSA密钥对生成器或密钥工厂，则需要创建实现<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><code class="codeph">Interface RSAPublicKey</code></a> （和/或<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateCrtKey.html" target="_blank"><code class="codeph">Interface RSAPrivateCrtKey</code></a> ）和<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><code class="codeph">Interface RSAPublicKey</code></a>接口。 （ <code class="codeph">RSAPrivateCrtKey</code>是使用<span class="variable" translate="no">Chinese Remainder Theorem</span> （CRT）表示法的RSA私钥的接口。）
                        </p>
                        <p>如果您实施RSA密钥对生成器，则您的<code class="codeph">generateKeyPair</code>方法（在您的<code class="codeph">KeyPairGeneratorSpi</code>子类）将返回这些接口的实现实例。
                        </p>
                        <p>如果您实施RSA密钥工厂，则您的<code class="codeph">engineGeneratePrivate</code>方法（在您的<code class="codeph">KeyFactorySpi</code>子类）将返回您的实例<code class="codeph">RSAPrivateKey</code> （要么<code class="codeph">RSAPrivateCrtKey</code> ）实施，以及您的<code class="codeph">engineGeneratePublic</code>方法将返回您的实例<code class="codeph">RSAPublicKey</code>实施。
                        </p>
                        <p>还有，你的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法将期望传入的键是的实例<code class="codeph">RSAPrivateKey</code> ， <code class="codeph">RSAPrivateCrtKey</code> ， 要么<code class="codeph">RSAPublicKey</code>实施。
                        </p>
                        <p>如果您实施RSA签名算法，则您的<code class="codeph">engineInitSign</code>方法（在您的<code class="codeph">SignatureSpi</code>子类）将期望通过<code class="codeph">RSAPrivateKey</code>或<code class="codeph">RSAPrivateCrtKey</code> ， 和你的<code class="codeph">engineInitVerify</code>该方法将有望通过<code class="codeph">RSAPublicKey</code> 。
                        </p>
                        <p>请注意： <code class="codeph">RSAPublicKey</code> ， <code class="codeph">RSAPrivateKey</code>和<code class="codeph">RSAPrivateCrtKey</code>接口为RSA公钥和私钥定义了非常通用的，独立于提供程序的接口。的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法（在您的<code class="codeph">KeyFactorySpi</code>子类）还可以检查传入的键是否实际上是其提供者自己的实现的实例<code class="codeph">RSAPrivateKey</code> ， <code class="codeph">RSAPrivateCrtKey</code> ， 要么<code class="codeph">RSAPublicKey</code>例如，以利用提供者特定的实施细节。RSA签名算法也是如此<code class="codeph">engineInitSign</code>和<code class="codeph">engineInitVerify</code>方法（在您的<code class="codeph">SignatureSpi</code>子类）。
                        </p>
                        <p>要了解实现该方法的类需要实现哪些方法<code class="codeph">RSAPublicKey</code> ， <code class="codeph">RSAPrivateKey</code>和<code class="codeph">RSAPrivateCrtKey</code>接口，首先请注意以下接口签名：</p>
                        <p>在里面<code class="codeph">java.security.interfaces</code>包：</p><pre class="codeblock"><code>
    public interface RSAPrivateKey extends java.security.PrivateKey

    public interface RSAPrivateCrtKey extends RSAPrivateKey

    public interface RSAPublicKey extends java.security.PublicKey

</code></pre><p>在里面<code class="codeph">java.security</code>包：</p><pre class="codeblock"><code>
    public interface PrivateKey extends Key

    public interface PublicKey extends Key

    public interface Key extends java.io.Serializable
</code></pre><p>为了实施<code class="codeph">RSAPrivateKey</code> ， <code class="codeph">RSAPrivateCrtKey</code>和<code class="codeph">RSAPublicKey</code>接口，您必须实现它们定义的方法以及由它们直接或间接扩展的接口定义的方法。
                        </p>
                        <p>因此，对于RSA私钥，您需要提供一个实现以下内容的类：</p>
                        <ul style="list-style-type:disc">
                           <li>的<code class="codeph">getModulus</code>和<code class="codeph">getPrivateExponent</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateKey.html" target="_blank"><code class="codeph">Interface RSAPrivateKey</code></a>接口。
                           </li>
                           <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a>接口，因为<code class="codeph">RSAPrivateKey</code>延伸<code class="codeph">java.security.PrivateKey</code>和<code class="codeph">PrivateKey</code>延伸<code class="codeph">Key</code> 。
                           </li>
                        </ul>
                        <p>同样，对于使用<span class="variable" translate="no">Chinese Remainder Theorem</span> （CRT）表示形式的RSA私钥，您需要提供一个实现以下内容的类：</p>
                        <ul style="list-style-type:disc">
                           <li>上面列出的用于RSA私钥的所有方法，因为<code class="codeph">RSAPrivateCrtKey</code>延伸<code class="codeph">java.security.interfaces.RSAPrivateKey</code> 。
                           </li>
                           <li>的<code class="codeph">getPublicExponent</code> ， <code class="codeph">getPrimeP</code> ， <code class="codeph">getPrimeQ</code> ， <code class="codeph">getPrimeExponentP</code> ， <code class="codeph">getPrimeExponentQ</code>和<code class="codeph">getCrtCoefficient</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateKey.html" target="_blank"><code class="codeph">Interface RSAPrivateKey</code></a>接口。
                           </li>
                        </ul>
                        <p>对于公共RSA密钥，您需要提供一个实现以下内容的类：</p>
                        <ul style="list-style-type:disc">
                           <li>的<code class="codeph">getModulus</code>和<code class="codeph">getPublicExponent</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><code class="codeph">Interface RSAPublicKey</code></a>接口。
                           </li>
                           <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a>接口，因为<code class="codeph">RSAPublicKey</code>延伸<code class="codeph">java.security.PublicKey</code>和<code class="codeph">PublicKey</code>延伸<code class="codeph">Key</code> 。
                           </li>
                        </ul>
                        <p>JCA包含许多<code class="codeph">AlgorithmParameterSpec</code>最常用的密码和密钥协商算法参数的实现。如果您要使用的算法参数应适用于JCA未提供的其他类型的算法，则需要提供自己的算法参数<code class="codeph">AlgorithmParameterSpec</code>适用于该类型算法的实现。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E63F9312-ED15-41D5-8F62-93C6137D5F06" name="GUID-E63F9312-ED15-41D5-8F62-93C6137D5F06"></a><h4 id="JSSEC-GUID-E63F9312-ED15-41D5-8F62-93C6137D5F06" class="sect4">Diffie-Hellman接口及其必需的实现</h4>
                  <div>
                     <p>JCA包含接口（在<code class="codeph">javax.crypto.interfaces</code>软件包），以方便程序员实现Diffie-Hellman服务。
                     </p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPublicKey.html" target="_blank"><code class="codeph">Interface DHPublicKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHKey.html" target="_blank"><code class="codeph">Interface DHKey</code></a></p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPrivateKey.html" target="_blank"><code class="codeph">Interface DHPrivateKey</code></a></p>
                           </li>
                        </ul>
                        <p>以下各节讨论了这些接口的实现要求。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E63F9312-ED15-41D5-8F62-93C6137D5F06__GUID-82CA0637-603D-4E6D-9F2C-9ECC8F327F63">DHPrivateKey和DHPublicKey实现</p>
                        <p>如果您实现Diffie-Hellman密钥对生成器或密钥工厂，则需要创建实现<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPrivateKey.html" target="_blank"><code class="codeph">Interface DHPrivateKey</code></a>和<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPublicKey.html" target="_blank"><code class="codeph">Interface DHPublicKey</code></a>接口。
                        </p>
                        <p>如果实现Diffie-Hellman密钥对生成器，则您的<code class="codeph">generateKeyPair</code>方法（在您的<code class="codeph">KeyPairGeneratorSpi</code>子类）将返回这些接口的实现实例。
                        </p>
                        <p>如果您实现了Diffie-Hellman密钥工厂，则您的<code class="codeph">engineGeneratePrivate</code>方法（在您的<code class="codeph">KeyFactorySpi</code>子类）将返回您的实例<code class="codeph">DHPrivateKey</code>实施，以及您的<code class="codeph">engineGeneratePublic</code>方法将返回您的实例<code class="codeph">DHPublicKey</code>实施。
                        </p>
                        <p>还有，你的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法将期望传入的键是的实例<code class="codeph">DHPrivateKey</code>要么<code class="codeph">DHPublicKey</code>实施。的<code class="codeph">getParams</code>接口实现提供的方法对于从密钥获取和提取参数很有用。然后，您可以使用参数，例如，作为参数<code class="codeph">DHParameterSpec</code>调用构造函数，从用于初始化a的参数值创建参数规范<code class="codeph">KeyPairGenerator</code> Diffie-Hellman的对象。
                        </p>
                        <p>如果您实施Diffie-Hellman密钥协商算法，则您的<code class="codeph">engineInit</code>方法（在您的<code class="codeph">KeyAgreementSpi</code>子类）将通过<code class="codeph">DHPrivateKey</code>和你的<code class="codeph">engineDoPhase</code>该方法将有望通过<code class="codeph">DHPublicKey</code> 。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-E63F9312-ED15-41D5-8F62-93C6137D5F06__GUID-53C9A9A7-1921-4ABC-A1D6-AB8E2714B75B">
                              <p class="notep1">注意：</p>的<code class="codeph">DHPublicKey</code>和<code class="codeph">DHPrivateKey</code>接口分别为Diffie-Hellman公钥和私钥定义了非常通用的，独立于提供程序的接口。的<code class="codeph">engineGetKeySpec</code>和<code class="codeph">engineTranslateKey</code>方法（在<span class="apiname">KeyFactorySpi</span>子类中）还可以检查传入的键是否实际上是其提供程序自己的实现的实例。 <code class="codeph">DHPrivateKey</code>要么<code class="codeph">DHPublicKey</code>例如，以利用提供者特定的实施细节。Diffie-Hellman算法也是如此<code class="codeph">engineInit</code>和<code class="codeph">engineDoPhase</code>方法（在您的<code class="codeph">KeyAgreementSpi</code>子类）。
                           </div> 
                        </div>
                        <p>要了解实现该方法的类需要实现哪些方法<code class="codeph">DHPublicKey</code>和<code class="codeph">DHPrivateKey</code>接口，首先请注意以下接口签名：</p>
                        <p>在里面<code class="codeph">javax.crypto.interfaces</code>包：</p><pre class="codeblock"><code>
    public interface DHPrivateKey extends DHKey, java.security.PrivateKey

    public interface DHPublicKey extends DHKey, java.security.PublicKey

    public interface DHKey 
</code></pre><p>在里面<code class="codeph">java.security</code>包：</p><pre class="codeblock"><code>
    public interface PrivateKey extends Key

    public interface PublicKey extends Key

    public interface Key extends java.io.Serializable 
</code></pre><p>实施<code class="codeph">DHPrivateKey</code>和<code class="codeph">DHPublicKey</code>接口，您必须实现它们定义的方法以及由它们直接或间接扩展的接口定义的方法。
                        </p>
                        <p>因此，对于私钥，您需要提供一个实现以下内容的类：</p>
                        <ul style="list-style-type:disc">
                           <li>的<code class="codeph">getX</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPrivateKey.html" target="_blank"><code class="codeph">Interface DHPrivateKey</code></a>接口。
                           </li>
                           <li>的<code class="codeph">getParams</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHKey.html" target="_blank"><code class="codeph">Interface DHKey</code></a>接口，因为<code class="codeph">DHPrivateKey</code>延伸<code class="codeph">DHKey</code> 。
                           </li>
                           <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a>接口，因为<code class="codeph">DHPrivateKey</code>延伸<code class="codeph">java.security.PrivateKey</code>和<code class="codeph">PrivateKey</code>延伸<code class="codeph">Key</code> 。
                           </li>
                        </ul>
                        <p>同样，对于公共Diffie-Hellman密钥，您需要提供一个实现以下内容的类：</p>
                        <ul style="list-style-type:disc">
                           <li>的<code class="codeph">getY</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPublicKey.html" target="_blank"><code class="codeph">Interface DHPublicKey</code></a>接口。
                           </li>
                           <li>的<code class="codeph">getParams</code>的方法<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHKey.html" target="_blank"><code class="codeph">Interface DHKey</code></a>接口，因为<code class="codeph">DHPublicKey</code>延伸<code class="codeph">DHKey</code> 。
                           </li>
                           <li>的<code class="codeph">getAlgorithm</code> ， <code class="codeph">getEncoded</code>和<code class="codeph">getFormat</code>来自的方法<a href="https://docs.oracle.com/javase/10/docs/api/java/security/Key.html" target="_blank"><code class="codeph">Interface Key</code></a>接口，因为<code class="codeph">DHPublicKey</code>延伸<code class="codeph">java.security.PublicKey</code>和<code class="codeph">PublicKey</code>延伸<code class="codeph">Key</code> 。
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6F87545B-E4EF-4EA7-8EAF-0FEA9DB2495E" name="GUID-6F87545B-E4EF-4EA7-8EAF-0FEA9DB2495E"></a><h4 id="JSSEC-GUID-6F87545B-E4EF-4EA7-8EAF-0FEA9DB2495E" class="sect4">其他算法类型的接口</h4>
                  <div>
                     <p>如上所述，Java安全性API包含接口，以方便程序员实现诸如DSA，RSA和ECC之类的服务。如果有些服务没有API支持，则需要定义自己的API。</p>
                     <div class="section">
                        <p>如果要为另一种算法实现密钥对生成器，则应创建一个或多个接口<code class="codeph">initialize</code>客户端在希望提供要使用的算法特定参数而不是实现提供的默认参数时可以调用的方法。您的子类<code class="codeph">KeyPairGeneratorSpi</code>应该实现此接口。
                        </p>
                        <p>对于没有直接API支持的算法，建议您创建类似的接口并提供实现类。您的公钥界面应扩展<a href="https://docs.oracle.com/javase/10/docs/api/java/security/PublicKey.html" target="_blank"><code class="codeph">Interface PublicKey</code></a>接口。同样，您的私钥接口应扩展<a href="https://docs.oracle.com/javase/10/docs/api/java/security/PrivateKey.html" target="_blank"><code class="codeph">Interface PrivateKey</code></a>接口。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9" name="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9"></a><h4 id="JSSEC-GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9" class="sect4">算法参数规范接口和类</h4>
                  <div>
                     <p>算法参数规范是与算法一起使用的参数集的透明表示。</p>
                     <div class="section">
                        <p>参数的<span class="variable" translate="no">transparent</span>表示意味着您可以通过在相应规范类中定义的<span class="variable" translate="no">get</span>方法之一（例如， <code class="codeph">DSAParameterSpec</code>定义<code class="codeph">getP</code> ， <code class="codeph">getQ</code>和<code class="codeph">getG</code>方法，分别访问p，q和g参数）。
                        </p>
                        <p>这是对比的<span class="variable" translate="no">opaque</span>表示，如由所提供<code class="codeph">AlgorithmParameters</code>引擎类，您无法直接访问关键材料值；您只能获取与参数集关联的算法的名称（通过<code class="codeph">getAlgorithm</code> ）和参数集的某种编码（通过<code class="codeph">getEncoded</code> ）。
                        </p>
                        <p>如果您提供<code class="codeph">AlgorithmParametersSpi</code> ， <code class="codeph">AlgorithmParameterGeneratorSpi</code> ， 要么<code class="codeph">KeyPairGeneratorSpi</code>实施，您必须利用<code class="codeph">AlgorithmParameterSpec</code>接口，因为每个类都包含采用<code class="codeph">AlgorithmParameterSpec</code>参数。此类方法需要确定已传入该接口的实际实现，并采取相应的措施。
                        </p>
                        <p>JCA包含许多<code class="codeph">AlgorithmParameterSpec</code>最常用的签名，密码和密钥协商算法参数的实现。如果您要使用的算法参数应适用于JCA未提供的其他类型的算法，则需要提供自己的算法参数<code class="codeph">AlgorithmParameterSpec</code>适用于该类型算法的实现。
                        </p>
                        <p>Java在中定义了以下算法参数规范接口和类<code class="codeph">java.security.spec</code>和<code class="codeph">javax.crypto.spec</code>套餐：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-63CFC284-0956-449B-A462-67E1CBBCF9DF">AlgorithmParameterSpec接口</p>
                        <p><code class="codeph">AlgorithmParameterSpec</code>是透明地指定密码参数的接口。
                        </p>
                        <p>该接口不包含任何方法或常量。其唯一目的是对所有参数规范进行分组（并提供类型安全性）。所有参数规范都必须实现此接口。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-BD6C1433-2DE1-45A8-9C39-35BB04FF409F">DSAParameterSpec类别</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>和<code class="codeph">DSAParams</code>接口）指定与DSA算法一起使用的参数集。它具有以下方法：</p><pre class="codeblock"><code>
    public BigInteger getP()

    public BigInteger getQ()

    public BigInteger getG()
</code></pre><p>这些方法返回DSA算法参数： <code class="codeph">p</code> ，次贷<code class="codeph">q</code>和基础<code class="codeph">g</code> 。
                        </p>
                        <p>许多类型的DSA服务都可以使用该类，例如，DSA签名，密钥对生成器，算法参数生成器和<span class="variable" translate="no">Sun</span>提供程序实现的算法参数类都可以使用该类。作为一个具体示例，算法参数实现必须包括针对<code class="codeph">getParameterSpec</code>方法，该方法返回一个<code class="codeph">AlgorithmParameterSpec</code> 。<span class="variable" translate="no">Sun</span>提供的DSA算法参数实现会返回的实例<code class="codeph">DSAParameterSpec</code>类。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-C2491F77-4F2A-47BA-9323-C5D07D92F4FE">IvParameterSpec类别</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>接口）指定在反馈模式下与密码一起使用的初始化向量（IV）。
                        </p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-560C045E-D56F-441E-B87B-566DF016C49E">
                           <p class="titleintable">表3-3中的方法<code class="codeph">IvParameterSpec</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="IvParameterSpec中的方法" width="100%" border="1" summary="Methods in the IvParameterSpec class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4744">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4746">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4750" headers="d41150e4744 "><code class="codeph">byte[] getIV()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4750 d41150e4746 ">返回初始化向量（IV）。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-7E4A0563-7A49-40C3-8BEE-5BBC6F0DFA51">OAEPParameterSpec类</p>
                        <p>此类指定与PKCS＃1标准中定义的OAEP填充一起使用的参数集。</p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-651DADDC-41F1-4D6F-BB06-AD0FF59E73B7">
                           <p class="titleintable">表3-4中的方法<code class="codeph">OAEPParameterSpec</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="OAEPParameterSpec中的方法" width="100%" border="1" summary="Methods in the OAEPParameterSpec class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4772">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4774">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4778" headers="d41150e4772 "><code class="codeph">String getDigestAlgorithm()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4778 d41150e4774 ">返回消息摘要算法名称。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4784" headers="d41150e4772 "><code class="codeph">String getMGFAlgorithm()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4784 d41150e4774 ">返回掩码生成函数算法名称。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4790" headers="d41150e4772 "><code class="codeph">AlgorithmParameterSpec getMGFParameters()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4790 d41150e4774 ">返回掩码生成函数的参数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4796" headers="d41150e4772 "><code class="codeph">PSource getPSource()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4796 d41150e4774 ">返回编码输入P的来源。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-6166821C-5737-4D57-A075-9934D8CAE051">PBEParameterSpec类别</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>接口）指定与基于密码的加密（PBE）算法一起使用的参数集。
                        </p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-C45AE15E-8842-4E64-93AA-5CA8BF26BA57">
                           <p class="titleintable">表3-5中的方法<code class="codeph">PBEParameterSpec</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PBEParameterSpec中的方法" width="100%" border="1" summary="Methods in the PBEParameterSpec class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4821">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4823">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4827" headers="d41150e4821 "><code class="codeph">int getIterationCount()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4827 d41150e4823 ">返回迭代计数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4833" headers="d41150e4821 "><code class="codeph">byte[] getSalt()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4833 d41150e4823 ">返回盐。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-609F3223-1A30-4FE4-8109-335D9F5AC2C4">RC2ParameterSpec类别</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>接口）指定用于RC2算法的参数集。
                        </p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-2694D9E7-97F1-4FF7-ADA4-2CA01AD507BD">
                           <p class="titleintable">表3-6中的方法<code class="codeph">RC2ParameterSpec</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RC2ParameterSpec中的方法" width="100%" border="1" summary="Methods in the RC2ParameterSpec class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4858">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4860">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4864" headers="d41150e4858 "><code class="codeph">boolean equals(Object obj)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4864 d41150e4860 ">测试指定对象与此对象之间的相等性。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4870" headers="d41150e4858 "><code class="codeph">int getEffectiveKeyBits()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4870 d41150e4860 ">返回有效密钥大小（以位为单位）。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4876" headers="d41150e4858 "><code class="codeph">byte[] getIV()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4876 d41150e4860 ">返回IV或null（如果此参数集不包含IV）。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4882" headers="d41150e4858 "><code class="codeph">int hashCode()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4882 d41150e4860 ">计算对象的哈希码值。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-73828F82-18C1-4118-B133-5CA2B554D7EA">RC5ParameterSpec类别</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>接口）指定与RC5算法一起使用的参数集。
                        </p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-EA4BD83F-60B2-4A21-AAAE-249AD07DF7C5">
                           <p class="titleintable">表3-7中的方法<code class="codeph">RC5ParameterSpec</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RC5ParameterSpec中的方法" width="100%" border="1" summary="Methods in the RC5ParameterSpec Class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4907">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4909">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4913" headers="d41150e4907 "><code class="codeph">boolean equals(Object obj)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4913 d41150e4909 ">测试指定对象与此对象之间的相等性。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4919" headers="d41150e4907 "><code class="codeph">byte[] getIV()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4919 d41150e4909 ">返回IV或null（如果此参数集不包含IV）。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4925" headers="d41150e4907 "><code class="codeph">int getRounds()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4925 d41150e4909 ">返回轮数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4931" headers="d41150e4907 "><code class="codeph">int getVersion()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4931 d41150e4909 ">返回版本。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4937" headers="d41150e4907 "><code class="codeph">int getWordSize()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4937 d41150e4909 ">返回字的大小（以位为单位）。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4943" headers="d41150e4907 "><code class="codeph">int hashCode()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4943 d41150e4909 ">计算对象的哈希码值。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-CA7717EC-262F-4FF9-B0C0-997AF2504E9B">DHParameterSpec类</p>
                        <p>此类（实现了<code class="codeph">AlgorithmParameterSpec</code>接口）指定与Diffie-Hellman算法一起使用的参数集。
                        </p>
                        <div class="tblformal" id="GUID-4EC9F5A8-8427-40DC-A480-38482B05C8A9__GUID-AD371F63-DD89-44FE-8288-02BD1F92E3E0">
                           <p class="titleintable">表3-8 DHParameterSpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DHParameterSpec中的方法" width="100%" border="1" summary="Methods in the DHParameterSpec class" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4966">方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e4968">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4972" headers="d41150e4966 "><code class="codeph">BigInteger getG()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4972 d41150e4968 ">返回基本生成器<code class="codeph">g</code> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4981" headers="d41150e4966 "><code class="codeph">int getL()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4981 d41150e4968 ">返回以位为单位的大小， <code class="codeph">l</code> ，为随机指数（私有值）。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e4990" headers="d41150e4966 "><code class="codeph">BigInteger getP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e4990 d41150e4968 ">返回素数模量<code class="codeph">p</code> 。
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->许多类型的Diffie-Hellman服务都将对此类有用。例如，它由Diffie-Hellman密钥协议，密钥对生成器，算法参数生成器和由“ SunJCE”提供程序实现的算法参数类使用。作为一个具体示例，算法参数实现必须包括针对<code class="codeph">getParameterSpec</code>方法，该方法返回一个<code class="codeph">AlgorithmParameterSpec</code> 。“ SunJCE”提供的Diffie-Hellman算法参数实现将返回<code class="codeph">DHParameterSpec</code>类。
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6" name="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6"></a><h4 id="JSSEC-GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6" class="sect4">关键工厂所需的关键规范接口和类</h4>
                  <div>
                     <p>密钥工厂提供不透明密钥（类型为）之间的双向转换<code class="codeph">Key</code> ）和关键规格。如果实施密钥工厂，则需要了解和利用密钥规范。在某些情况下，您还需要实现自己的密钥规范。
                     </p>
                     <div class="section">
                        <p></p>
                        <p>密钥规范是构成密钥的密钥材料的透明表示。如果密钥存储在硬件设备上，则其规范可能包含有助于识别设备上密钥的信息。</p>
                        <p>键的<span class="variable" translate="no">transparent</span>表示意味着您可以通过相应规范类中定义的<span class="variable" translate="no">get</span>方法之一来分别访问每个键材料值。例如， <code class="codeph">java.security.spec.DSAPrivateKeySpec</code>定义<code class="codeph">getX</code> ， <code class="codeph">getP</code> ， <code class="codeph">getQ</code>和<code class="codeph">getG</code>方法，以访问私钥<code class="codeph">x</code> ，以及用于计算密钥的DSA算法参数：素数<code class="codeph">p</code> ，次贷<code class="codeph">q</code>和基础<code class="codeph">g</code> 。
                        </p>
                        <p>这与Key接口定义的<span class="variable" translate="no">opaque</span>表示形式形成对比，在该表示形式中，您无法直接访问参数字段。换句话说，“不透明”表示使您只能有限地访问密钥-只是由Key接口定义的三种方法： <code class="codeph">getAlgorithm</code> ， <code class="codeph">getFormat</code>和<code class="codeph">getEncoded</code> 。
                        </p>
                        <p>可以以特定于算法的方式或以独立于算法的编码格式（例如ASN.1）来指定密钥。例如，DSA私钥可能由其组件指定<code class="codeph"><span class="variable" translate="no">x</span></code> ， <code class="codeph"><span class="variable" translate="no">p</span></code> ， <code class="codeph"><span class="variable" translate="no">q</span></code>和<code class="codeph"><span class="variable" translate="no">g</span></code> （看到<a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><code class="codeph">DSAPrivateKeySpec</code></a> ），也可以使用其DER编码进行指定（请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><code class="codeph">PKCS8EncodedKeySpec</code></a> ）。
                        </p>
                        <p>Java在Java中定义了以下关键规范接口和类<code class="codeph">java.security.spec</code>和<code class="codeph">javax.crypto.spec</code>套餐：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__THEKEYSPECINTERFACE-73DA08B1">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-B73EB72B-928A-438F-A7AF-A94DF3D23697">的<code class="codeph">KeySpec</code>接口</p>
                        <p>该接口不包含任何方法或常量。其唯一目的是对所有关键规格进行分组（并提供类型安全性）。所有关键规范都必须实现此接口。</p>
                        <p>Java提供了几个实现<span class="apiname">KeySpec</span>接口的类：</p>
                        <ul style="list-style-type:disc">
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><span class="apiname">DSAPrivateKeySpec</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPublicKeySpec.html" target="_blank"><span class="apiname">DSAPublicKeySpec</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPrivateKeySpec.html" target="_blank"><span class="apiname">RSAPrivateKeySpec</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPublicKeySpec.html" target="_blank"><span class="apiname">RSAPublicKeySpec</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/EncodedKeySpec.html" target="_blank"><span class="apiname">编码键规范</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><span class="apiname">PKCS8EncodedKeySpec</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/X509EncodedKeySpec.html" target="_blank"><span class="apiname">X509EncodedKeySpec</span></a></li>
                        </ul>
                        <p>如果您的提供商使用密钥类型（例如， <code class="codeph">Your_PublicKey_type</code>和<code class="codeph">Your_PrivateKey_type</code> ），而JDK尚未提供相应的<code class="codeph">KeySpec</code>类，有两种可能的情况，其中一种情况要求您实现自己的关键规范：</p>
                        <ol>
                           <li>
                              <p>如果您的用户永远不必访问您的密钥类型的特定密钥材料值，那么您将不必提供任何<code class="codeph">KeySpec</code>您的密钥类型的类。
                              </p>
                              <p>在这种情况下，您的用户将始终创建<code class="codeph">Your_PublicKey_type</code>和<code class="codeph">Your_PrivateKey_type</code>通过适当的键<code class="codeph">KeyPairGenerator</code>由您的提供商提供的该密钥类型。如果他们想存储生成的密钥供以后使用，则可以检索密钥的编码（使用<code class="codeph">getEncoded</code>的方法<code class="codeph">Key</code>接口）。当他们想创建一个<code class="codeph">Your_PublicKey_type</code>要么<code class="codeph">Your_PrivateKey_type</code>编码中的密钥（例如，为了初始化用于签名或验证的Signature对象），它们创建了一个<code class="codeph">X509EncodedKeySpec</code>要么<code class="codeph">PKCS8EncodedKeySpec</code>从编码，并将其提供给适当的<code class="codeph">KeyFactory</code>由您的提供商为该算法提供，其算法<code class="codeph">generatePublic</code>和<code class="codeph">generatePrivate</code>方法将返回请求的<code class="codeph">PublicKey</code> （的一个实例<code class="codeph">Your_PublicKey_type</code> ） 要么<code class="codeph">PrivateKey</code> （的一个实例<code class="codeph">Your_PrivateKey_type</code> ）对象。
                              </p>
                           </li>
                           <li>如果您预期用户需要访问您的密钥类型的特定密钥材料值，或者需要根据密钥材料和关联的参数值而不是根据其编码来构造密钥类型的密钥（如上述情况），指定新的<code class="codeph">KeySpec</code>类（实现<code class="codeph">KeySpec</code>接口），并使用适当的构造函数方法和<span class="variable" translate="no">get</span>方法返回键材料字段和键类型的相关参数值。您将以与<code class="codeph">DSAPrivateKeySpec</code>和<code class="codeph">DSAPublicKeySpec</code>类。您需要将这些类与提供程序类一起提供，例如，作为提供程序JAR文件的一部分。
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-B9C4427E-700A-43A9-A77B-C37E0AC60E5B">DSAPrivateKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定DSA专用密钥及其相关参数。它具有以下方法：</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-1EE9B5E3-B8FD-4DCE-847E-9180552A0296">
                           <p class="titleintable">表3-9 DSAPrivateKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DSAPrivateKeySpec中的方法" width="100%" border="1" summary="List of methods in DSAPrivateKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5266">DSAPrivateKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5268">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5272" headers="d41150e5266 "><code class="codeph">public BigInteger getX()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5272 d41150e5268 ">返回私钥x。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5278" headers="d41150e5266 "><code class="codeph">public BigInteger getP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5278 d41150e5268 ">返回素数p。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5284" headers="d41150e5266 "><code class="codeph">public BigInteger getQ()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5284 d41150e5268 ">返回次级抵押贷款q。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5290" headers="d41150e5266 "><code class="codeph">public BigInteger getG()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5290 d41150e5268 ">返回基数g。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>这些方法返回私钥<code class="codeph">x</code> ，以及用于计算密钥的DSA算法参数：素数<code class="codeph">p</code> ，次贷<code class="codeph">q</code>和基础<code class="codeph">g</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-BE9672C0-2A9E-4938-80AD-2EC7CB79EB99">DSAPublicKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>介面）指定DSA公钥及其相关参数。它具有以下方法：</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-5E1FD16D-0364-485E-A50F-AACEA77F5D68">
                           <p class="titleintable">表3-10 DSAPublicKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DSAPublicKeySpec中的方法" border="1" summary="List of methods in DSAPublicKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5327">DSAPublicKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5329">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5333" headers="d41150e5327 "><code class="codeph">public BigInteger getY()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5333 d41150e5329 ">返回公钥y。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5339" headers="d41150e5327 "><code class="codeph">public BigInteger getP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5339 d41150e5329 ">返回素数p。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5345" headers="d41150e5327 "><code class="codeph">public BigInteger getQ()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5345 d41150e5329 ">返回次级抵押贷款q。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5351" headers="d41150e5327 "><code class="codeph">public BigInteger getG()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5351 d41150e5329 ">返回基数g。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-858883D2-BD57-4AD0-8D5A-C3D563E5367C">RSAPrivateKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定RSA私钥。它具有以下方法：</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-F824E25B-B667-4E68-8327-FCAC9718815E">
                           <p class="titleintable">表3-11 RSAPrivateKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RSAPrivateKeySpec中的方法" border="1" summary="List of methods in RSAPrivateKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5374">RSAPrivateKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5376">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5380" headers="d41150e5374 "><code class="codeph">public BigInteger getModulus()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5380 d41150e5376 ">返回模数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5386" headers="d41150e5374 "><code class="codeph">public BigInteger getPrivateExponent()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5386 d41150e5376 ">返回私有指数。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>这些方法返回RSA模数<code class="codeph">n</code>和私有指数<code class="codeph">d</code>构成RSA私钥的值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-22C44DEF-8ED9-45F3-B02B-9C30364BF4C7">RSAPrivateCrtKeySpec类</p>
                        <p>此类（扩展了<code class="codeph">RSAPrivateKeySpec</code>类）使用<span class="variable" translate="no">Chinese Remainder Theorem</span> （CRT）信息值指定PKCS＃1标准中定义的RSA私钥。它具有以下方法（除了从其超类继承的方法之外） <code class="codeph">RSAPrivateKeySpec</code> ）：</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-BCAE5CFB-F7CA-4C49-B623-2F381316FC3F">
                           <p class="titleintable">表3-12 RSAPrivateCrtKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RSAPrivateCrtKeySpec中的方法" border="1" summary="List of methods in RSAPrivateCrtKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5423">RSAPrivateCrtKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5425">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5429" headers="d41150e5423 "><code class="codeph">public BigInteger getPublicExponent()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5429 d41150e5425 ">返回公共指数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5435" headers="d41150e5423 "><code class="codeph">public BigInteger getPrimeP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5435 d41150e5425 ">返回素数P。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5441" headers="d41150e5423 "><code class="codeph">public BigInteger getPrimeQ()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5441 d41150e5425 ">返回素数Q。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5447" headers="d41150e5423 "><code class="codeph">public BigInteger getPrimeExponentP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5447 d41150e5425 ">返回primeExponentP。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5453" headers="d41150e5423 "><code class="codeph">public BigInteger getPrimeExponentQ()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5453 d41150e5425 ">返回primeExponentQ。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5459" headers="d41150e5423 "><code class="codeph">public BigInteger getCrtCoefficient()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5459 d41150e5425 ">返回crtCoefficient。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>这些方法返回公共指数<code class="codeph">e</code>和CRT信息整数：主要因素<code class="codeph">p</code>模数<code class="codeph">n</code> ，首要因素<code class="codeph">q</code>的<code class="codeph">n</code> ，指数<code class="codeph">d mod (p-1)</code> ，指数<code class="codeph">d mod (q-1)</code>和中国余数定理系数<code class="codeph">(inverse of q) mod p</code> 。
                        </p>
                        <p>RSA私钥在逻辑上仅由模数和私有指数组成。CRT值的存在是为了提高效率。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-6E5BB903-4AE1-42EE-BD7C-2927B9D3952D">RSAPublicKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定RSA公钥。它具有以下方法：</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-E171C644-B094-4DDC-B4EB-08E76AC4543D">
                           <p class="titleintable">表3-13 RSAPublicKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RSAPublicKeySpec中的方法" border="1" summary="List of methods in RSAPublicKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5511">RSAPublicKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5513">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5517" headers="d41150e5511 "><code class="codeph">public BigInteger getModulus()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5517 d41150e5513 ">返回模数。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5523" headers="d41150e5511 "><code class="codeph">public BigInteger getPublicExponent()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5523 d41150e5513 ">返回公共指数。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-F685AFAF-5B0B-470F-829A-A886299D29E2">EncodedKeySpec类</p>
                        <p>这个抽象类（实现了<code class="codeph">KeySpec</code>接口）代表编码格式的公钥或私钥。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-60FAE739-4095-4FC5-94C7-A9B65AC04C85">
                           <p class="titleintable">表3-14 EncodedKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="EncodedKeySpec中的方法" border="1" summary="List of methods in EncodedKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5546">EncodedKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5548">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5552" headers="d41150e5546 "><code class="codeph">public abstract byte[] getEncoded()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5552 d41150e5548 ">返回编码的密钥。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5558" headers="d41150e5546 "><code class="codeph">public abstract String getFormat()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5558 d41150e5548 ">返回编码格式的名称。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>JDK提供了两个类来实现<code class="codeph">EncodedKeySpec</code>接口： <code class="codeph">PKCS8EncodedKeySpec</code>和<code class="codeph">X509EncodedKeySpec</code> 。如果需要，您可以自己提供<code class="codeph">EncodedKeySpec</code>这些或其他类型的键编码的实现。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-5FDB6FA1-A361-4CAA-A0D0-C1489F1C37F1">PKCS8EncodedKeySpec类</p>
                        <p>此类，是以下类的子类<code class="codeph">EncodedKeySpec</code>表示根据PKCS＃8标准中指定的格式的私钥的DER编码。
                        </p>
                        <p>它的<code class="codeph">getEncoded</code>方法返回根据PKCS＃8标准编码的密钥字节。它的<code class="codeph">getFormat</code>方法返回字符串“ PKCS＃8”。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-99E21FFB-6D8F-4DC2-8126-D45C47E562ED">X509EncodedKeySpec类别</p>
                        <p>此类，是以下类的子类<code class="codeph">EncodedKeySpec</code>表示根据X.509标准中指定的格式的公钥或私钥的DER编码。
                        </p>
                        <p>它的<code class="codeph">getEncoded</code>方法返回根据X.509标准编码的密钥字节。它的<code class="codeph">getFormat</code>方法返回字符串“ X.509”。 <code class="codeph">DHPrivateKeySpec</code> ， <code class="codeph">DHPublicKeySpec</code> ， <code class="codeph">DESKeySpec</code> ， <code class="codeph">DESedeKeySpec</code> ， <code class="codeph">PBEKeySpec</code>和<code class="codeph">SecretKeySpec</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-FD188DC8-24F0-4398-A414-399129DEFE6F">DHPrivateKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定Diffie-Hellman私钥及其相关参数。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-18467DAF-8EF1-42DA-B4D5-7CBB4EA96CD5">
                           <p class="titleintable">表3-15 DHPrviateKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DHPrviateKeySpec中的方法" border="1" summary="List of methods in DHPrviateKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5646">DHPrivateKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5648">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5652" headers="d41150e5646 "><code class="codeph">BigInteger getG()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5652 d41150e5648 ">返回基本生成器<code class="codeph">g</code> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5661" headers="d41150e5646 "><code class="codeph">BigInteger getP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5661 d41150e5648 ">返回素数模量<code class="codeph">p</code> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5670" headers="d41150e5646 "><code class="codeph">BigInteger getX()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5670 d41150e5648 ">返回私有值<code class="codeph">x</code> 。
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-EE0F79EC-F03A-4534-A140-D3390B84D0B9">DHPublicKeySpec类</p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-EB5C5B01-8EEC-4D46-BE8F-248BFC0548A3">
                           <p class="titleintable">表3-16 DHPublicKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DHPublicKeySpec中的方法" border="1" summary="List of methods in DHPublicKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5692">DHPublicKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5694">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5698" headers="d41150e5692 "><code class="codeph">BigInteger getG()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5698 d41150e5694 ">返回基本生成器<code class="codeph">g</code> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5707" headers="d41150e5692 "><code class="codeph">BigInteger getP()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5707 d41150e5694 ">返回素数模量<code class="codeph">p</code> 。
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5716" headers="d41150e5692 "><code class="codeph">BigInteger getY()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5716 d41150e5694 ">返回公共值<code class="codeph">y</code> 。
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-2E480283-B201-416E-A166-97DB85D3A22C">DESKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定DES密钥。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-6F7067FE-280E-4C76-B742-9611CF17DB3F">
                           <p class="titleintable">表3-17 DESKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DESKeySpec中的方法" border="1" summary="List of methods in DESKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5742">DESKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5744">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5748" headers="d41150e5742 "><code class="codeph">byte[] getKey()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5748 d41150e5744 ">返回DES密钥字节。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5754" headers="d41150e5742 "><code class="codeph">static boolean isParityAdjusted(byte[] key, int offset)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5754 d41150e5744 ">检查给定的DES密钥材料是否经过奇偶校验调整。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5760" headers="d41150e5742 "><code class="codeph">static boolean isWeak(byte[] key, int offset)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5760 d41150e5744 ">检查给定的DES密钥材料是弱还是半弱。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-9DF7FE1B-6E44-43B6-82B3-FB20A20FB3C0">DESedeKeySpec类</p>
                        <p>此类（实现了<code class="codeph">KeySpec</code>接口）指定DES-EDE（三重DES）密钥。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-6760BDD0-C8AE-4EE6-ADAD-A66B108A0BBF">
                           <p class="titleintable">表3-18 DESedeKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DESedeKeySpec中的方法" border="1" summary="List of methods in DESedeKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5783">DESedeKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5785">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5789" headers="d41150e5783 "><code class="codeph">byte[] getKey()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5789 d41150e5785 ">返回DES-EDE密钥。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5795" headers="d41150e5783 "><code class="codeph">static boolean isParityAdjusted(byte[] key, int offset)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5795 d41150e5785 ">检查给定的DES-EDE密钥是否经过奇偶校验调整。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-19410662-230E-4056-91F5-622C4C270159">PBEKeySpec类别</p>
                        <p>此类实现<code class="codeph">KeySpec</code>接口。用户选择的密码可以与基于密码的加密（PBE）结合使用；密码可以看作是原始密钥材料的一种。使用此类的加密机制可以从原始密钥材料派生加密密钥。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-4DCC8AC8-3BB2-4441-9127-CE623BED2997">
                           <p class="titleintable">表3-19 PBEKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PBEKeySpec中的方法" border="1" summary="List of methods in PBEKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5818">PBEKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5820">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5824" headers="d41150e5818 "><code class="codeph">void clearPassword</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5824 d41150e5820 ">清除密码的内部副本。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5830" headers="d41150e5818 "><code class="codeph">int getIterationCount</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5830 d41150e5820 ">返回迭代计数；如果未指定，则返回0。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5836" headers="d41150e5818 "><code class="codeph">int getKeyLength</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5836 d41150e5820 ">返回要导出的密钥长度；如果未指定，则返回0。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5842" headers="d41150e5818 "><code class="codeph">char[] getPassword</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5842 d41150e5820 ">返回密码的副本。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5848" headers="d41150e5818 "><code class="codeph">byte[] getSalt</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5848 d41150e5820 ">返回盐的副本；如果未指定，则返回null。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-1C280AD1-E9F6-4558-BAE5-12836213C4AD">SecretKeySpec类</p>
                        <p>此类实现<code class="codeph">KeySpec</code>接口。由于它还实现了<code class="codeph">SecretKey</code>接口，可以用来构造一个<code class="codeph">SecretKey</code>对象以与提供者无关的方式，即，无需通过基于提供者的方式<code class="codeph">SecretKeyFactory</code> 。
                        </p>
                        <div class="tblformal" id="GUID-97E2DE2A-5DFD-4A87-AFA7-CDECC3F77FA6__GUID-7DAE6B47-86D9-443B-8353-15A44F2D1A1C">
                           <p class="titleintable">表3-20 SecretKeySpec中的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SecretKeySpec中的方法" border="1" summary="List of methods in SecretKeySpec" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5880">SecretKeySpec中的方法</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d41150e5882">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5886" headers="d41150e5880 "><code class="codeph">boolean equals (Object obj)</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5886 d41150e5882 ">指示其他某个对象是否与此对象“相等”。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5892" headers="d41150e5880 "><code class="codeph">String getAlgorithm()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5892 d41150e5882 ">返回与此秘密密钥关联的算法的名称。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5898" headers="d41150e5880 "><code class="codeph">byte[] getEncoded()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5898 d41150e5882 ">返回此秘密密钥的密钥材料。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5904" headers="d41150e5880 "><code class="codeph">String getFormat()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5904 d41150e5882 ">返回此密钥的编码格式的名称。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d41150e5910" headers="d41150e5880 "><code class="codeph">int hashCode()</code></td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d41150e5910 d41150e5882 ">计算对象的哈希码值。</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-63A770A3-398A-41C4-B2C9-894D76567F5C" name="GUID-63A770A3-398A-41C4-B2C9-894D76567F5C"></a><h4 id="JSSEC-GUID-63A770A3-398A-41C4-B2C9-894D76567F5C" class="sect4">秘钥生成</h4>
                  <div>
                     <p>如果您提供密钥生成器（ <code class="codeph">javax.crypto.KeyGeneratorSpi</code> ）针对特定的密钥算法，您可以返回生成的密钥对象。
                     </p>
                     <div class="section">
                        <p>生成的密钥对象（必须是的实例） <code class="codeph">javax.crypto.SecretKey</code> ，请参见<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/KeyGeneratorSpi.html#engineGenerateKey--" target="_blank">engineGenerateKey</a> ）可以通过以下方式之一返回：</p>
                        <ul style="list-style-type:disc">
                           <li>您实现了一个类，该类的实例表示与密钥生成器关联的算法的秘密密钥。您的密钥生成器实现返回该类的实例。如果密钥生成器生成的密钥具有提供程序特定的属性，则此方法很有用。</li>
                           <li>您的密钥生成器返回的实例<a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/SecretKeySpec.html" target="_blank"><code class="codeph">SecretKeySpec</code></a> ，它已经实现了<code class="codeph">javax.crypto.SecretKey</code>接口。您将（原始）密钥字节和与密钥生成器关联的密钥算法的名称传递给<code class="codeph">SecretKeySpec</code>构造函数。如果基础（原始）密钥字节可以表示为字节数组，并且没有与之关联的密钥参数，则此方法很有用。
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5A41A05A-B8F0-4E24-A61B-347721809A8B" name="GUID-5A41A05A-B8F0-4E24-A61B-347721809A8B"></a><h4 id="JSSEC-GUID-5A41A05A-B8F0-4E24-A61B-347721809A8B" class="sect4">添加新的对象标识符</h4>
                  <div>
                     <p>以下信息适用于提供了未在<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全性标准算法名称中</a>列为标准算法之一的算法的提供<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">程序</a> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5A41A05A-B8F0-4E24-A61B-347721809A8B__GUID-BE5E6BF1-C586-4315-8B28-2590ECA58682">从OID到名称的映射</p>
                        <p>有时，JCA需要从算法标识符（例如，按照证书中的编码）实例化密码算法实现，该标识符根据定义包括算法的对象标识符（OID）。例如，为了验证X.509证书上的签名，JCA根据证书中编码的签名算法标识符确定签名算法，实例化该算法的签名对象，并初始化签名对象以进行验证。</p>
                        <p>为了使JCA能够找到您的算法，您必须在提供者主文件中提供算法的对象标识符作为算法的别名条目。</p><pre class="codeblock"><code>
    put("Alg.Alias.&lt;engine_type&gt;.1.2.3.4.5.6.7.8",
        "&lt;algorithm_alias_name&gt;");
</code></pre><p>请注意，如果在多个对象标识符下已知算法，则需要为每个已知的对象标识符创建一个别名条目。</p>
                        <p>JCA需要执行这种类型映射的一个示例是您的算法（“ <code class="codeph">Foo</code> “）是一种签名算法，用户可以运行<code class="codeph">keytool</code>命令并指定（签名）算法别名。
                        </p><pre class="codeblock"><code>
    % keytool -genkeypair -sigalg 1.2.3.4.5.6.7.8
</code></pre><p>在这种情况下，您的提供程序主文件应包含以下条目：</p><pre class="codeblock"><code>
    put("Signature.Foo", "com.xyz.MyFooSignatureImpl");
    put("Alg.Alias.Signature.1.2.3.4.5.6.7.8", "Foo");
</code></pre><p>执行这种类型的映射的其他示例包括（1）当您的算法是密钥类型算法并且您的程序解析证书（使用SUN提供程序的X.509实现）并从证书中提取公钥时，初始化签名对象以进行验证，以及（2） <code class="codeph">keytool</code>用户在生成相应的密钥对之后，尝试访问您的密钥类型的私钥（例如，执行数字签名）。在这些情况下，提供程序主文件应包含以下条目：</p><pre class="codeblock"><code>
    put("KeyFactory.Foo", "com.xyz.MyFooKeyFactoryImpl");
    put("Alg.Alias.KeyFactory.1.2.3.4.5.6.7.8", "Foo");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5A41A05A-B8F0-4E24-A61B-347721809A8B__GUID-E59AC22F-B23A-4659-A628-A60B9FEAE094">从名称到OID的映射</p>
                        <p>如果JCA需要执行逆映射（即，从算法名称到其关联的OID），则需要为以下一种OID提供以下形式的别名条目，在该别名下应知道您的算法：</p><pre class="codeblock"><code>
    put("Alg.Alias.Signature.OID.1.2.3.4.5.6.7.8", "MySigAlg");
</code></pre><p>如果您的算法在一个以上的对象标识符下是已知的，则在首选的对象标识符前面加上“ OID”。</p>
                        <p>用户运行时，JCA需要执行这种映射的一个示例<code class="codeph">keytool</code>在任何需要<code class="codeph">-sigalg</code>选项。例如，当<code class="codeph">-genkeypair</code>和<code class="codeph">-certreq</code>命令被调用后，用户可以使用来指定您的（签名）算法<code class="codeph">-sigalg</code>选项。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-ECCC1170-B552-4CF9-BD00-64A70DEC2AC6" name="GUID-ECCC1170-B552-4CF9-BD00-64A70DEC2AC6"></a><h4 id="JSSEC-GUID-ECCC1170-B552-4CF9-BD00-64A70DEC2AC6" class="sect4">确保出口</h4>
                  <div>
                     <p>JCA的关键特征是，如果满足某些条件，则JCA框架和提供者密码术实现的可导出性。</p>
                     <p>默认情况下，应用程序可以使用任何强度的密码算法。但是，由于某些国家/地区的进口法规，您可能必须限制这些算法的强度。您可以使用管辖区策略文件来执行此操作；请参阅<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">加密强度配置</a> 。JCA框架将强制执行已安装的管辖权策略文件中指定的限制。
                     </p>
                     <p>如其他地方所述，您只能编写提供程序软件的一个版本，以实现最大强度的加密。由JCA（而不是您的提供商）来决定是否执行有关加密算法和不同位置的applet /应用程序可使用的最大加密强度的任何管辖区策略文件强制性限制。</p>
                     <p>为了使其能够插入JCA，您的提供者必须满足的条件如下：</p>
                     <ul style="list-style-type:disc">
                        <li>提供程序代码的编写方式应使提供程序类在绕过JCA的情况下直接由应用程序实例化时将变得不可用。请参阅<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">实现和集成提供程序的</a> <a href="howtoimplaprovider.html#GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" title="当实例化提供者的Cipher，KeyAgreement，KeyGenerator，MAC或SecretKey工厂的实现（类）时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。">步骤中的步骤1：编写服务实现代码</a> 。
                        </li>
                        <li>提供程序包必须由JCA框架信任的实体签名。（请参阅<a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="The next step is to request a code-signing certificate so that you can use it to sign your provider prior to testing. The certificate will be good for both testing and production. It will be valid for 5 years.">步骤7.1：</a>通过<a href="howtoimplaprovider.html#GUID-CF5F0E7D-BA0E-494C-8A5A-B228FF839AEF">步骤7.2：签署您的提供者</a> <a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="下一步是请求代码签名证书，以便您可以在测试之前使用它对提供商进行签名。该证书将对测试和生产均有效。有效期为5年。">获得代码签名证书</a> 。）供应商可能会出口到美国以外的美国供应商，首先需要申请美国政府的出口许可。（请参阅<a href="howtoimplaprovider.html#GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E" title="All U.S. vendors whose providers may be exported outside the U.S. should apply to the Bureau of Industry and Security in the U.S. Department of Commerce for export approval.">步骤11：如果需要，</a>请<a href="howtoimplaprovider.html#GUID-A62916EE-BE09-4229-9D05-3D6AF303CA4E" title="所有其供应商可能会出口到美国以外的美国供应商，都应向美国商务部工业与安全局申请出口批准。">申请美国政府出口批准</a> 。）
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137" name="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137"></a><h3 id="JSSEC-GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137" class="sect3">MyProvider的示例代码</h3>
               <div>
                  <p>以下是示例提供程序MyProvider的完整源代码。它是便携式提供商；您可以在类或模块路径中指定它。它由两个模块组成：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">com.example.MyProvider</code> ：包含一个提供程序示例，该示例演示了如何使用<span class="apiname">Provider编写提供<span class="apiname">程序。服务</span>机制。您必须编译，打包和签名提供程序，然后<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">按照实现和集成提供程序的步骤中</a>所述在类或模块路径中指定它。
                        </span></p>
                     </li>
                     <li>
                        <p><code class="codeph">com.example.MyApp</code> ：包含使用MyProvider提供程序的示例应用程序。它使用<span class="apiname">ServiceLoader</span>机制查找并加载此提供程序，然后使用<span class="apiname">Security.addProvider（）</span>方法动态注册它。
                        </p>
                     </li>
                  </ul>
                  <p>本示例包含以下文件：</p>
                  <ul style="list-style-type:disc">
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYPROVIDER_MODULE-INFO.JAVA">src/com.example.MyProvider/module-info.java</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYPROVIDER.JAVA">src/com.example.MyProvider/com/example/MyProvider/MyProvider.java</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYCIPHER.JAVA">src/com.example.MyProvider/com/example/MyProvider/MyCipher.java</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_JAVA.SECURITY.PROVIDER">src/com.example.MyProvider/META-INF/services/java.security.Provider</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYAPP_MODULE-INFO">src/com.example.MyApp/module-info.java</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYAPP.JAVA">src/com.example.MyApp/com/example/MyApp/MyApp.java</a></code></li>
                     <li><code class="codeph"><a href="howtoimplaprovider.html#GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_RUNTEST.SH">RunTest.sh</a></code></li>
                  </ul>
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYPROVIDER_MODULE-INFO.JAVA">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-1BEE899E-0CB2-4EB0-A2B4-BF2919189268">src / com.example。MyProvider / module-info.java</p>
                     <p>有关<a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="This step is optional but recommended; it enables you to package your provider in a named module. A modular JDK can then locate your provider in the module path as opposed to the class path. The module system can more thoroughly check for dependencies in modules in the module path. Note that you can use named modules in a non-modular JDK; the module declaration will be ignored. Also, you can still package your providers in unnamed or automatic modules.">模块声明的</a>信息，请参见<a href="howtoimplaprovider.html#GUID-7C304A79-6D0B-438B-A02E-51648C909876" title="此步骤是可选的，但建议执行；它使您可以将提供程序打包到命名模块中。然后，模块化JDK可以在模块路径（而不是类路径）中找到您的提供程序。模块系统可以更彻底地检查模块路径中模块中的依赖关系。注意，您可以在非模块化JDK中使用命名模块。模块声明将被忽略。同样，您仍然可以将提供程序打包在未命名或自动模块中。">步骤4：为您的提供者创建</a>模块声明，该信息在<span class="apiname">module-info.java中</span>指定。
                     </p><pre class="pre codeblock"><code>module com.example.MyProvider {
    provides java.security.Provider with com.example.MyProvider.MyProvider;
}</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYPROVIDER.JAVA">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-563C8F55-9990-407B-A32E-39A24B363CB6">src / com.example。MyProvider / com / example / MyProvider / MyProvider.java</p>
                  </div>
                  <!-- class="section" -->
                  <p><span class="apiname">MyProvider</span>类是使用<span class="apiname">Provider的提供程序的示例<span class="apiname">。服务</span>等级。请参阅<a href="howtoimplaprovider.html#GUID-CB446B7A-CEA2-4F4A-A4AF-4D492CB58733">步骤3.2：创建使用提供程序的提供程序。服务</a> 。
                  </span></p><pre class="pre codeblock"><code>package com.example.MyProvider;

import java.security.*;
import java.util.*;

/**
 * Test JCE provider.
 *
 * Registers services using Provider.Service and overrides newInstance().
 */
public final class MyProvider extends Provider {

    public MyProvider() {
        super("MyProvider", "1.0", "My JCE provider");

        final Provider p = this;

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            putService(new ProviderService(p, "Cipher",
                    "MyCipher", "com.example.MyProvider.MyCipher"));
            return null;
        });
    }

    private static final class ProviderService extends Provider.Service {

        ProviderService(Provider p, String type, String algo, String cn) {
            super(p, type, algo, cn, null, null);
        }

        ProviderService(Provider p, String type, String algo, String cn,
                String[] aliases, HashMap&lt;String, String&gt; attrs) {
            super(p, type, algo, cn,
                    (aliases == null ? null : Arrays.asList(aliases)), attrs);
        }

        @Override
        public Object newInstance(Object ctrParamObj)
                throws NoSuchAlgorithmException {

            String type = getType();
            if (ctrParamObj != null) {
                throw new InvalidParameterException(
                        "constructorParameter not used with " + type
                        + " engines");
            }
            String algo = getAlgorithm();
            try {
                if (type.equals("Cipher")) {
                    if (algo.equals("MyCipher")) {
                        return new MyCipher();
                    }
                }
            } catch (Exception ex) {
                throw new NoSuchAlgorithmException(
                        "Error constructing " + type + " for "
                        + algo + " using SunMSCAPI", ex);
            }
            throw new ProviderException("No impl for " + algo
                    + " " + type);
        }
    }

    @Override
    public String toString() {
        return "MyProvider [getName()=" + getName()
                + ", getVersionStr()=" + getVersionStr() + ", getInfo()="
                + getInfo() + "]";
    }
}
</code></pre><div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYCIPHER.JAVA">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-31AE41CF-22EB-4859-8147-A2DE7DA568C4">src / com.example。MyProvider / com / example / MyProvider / MyCipher.java</p>
                     <p><span class="apiname">MyCipher</span>类扩展了<span class="apiname">CipherSPI</span> ，它是服务器提供程序接口（SPI）。提供者实现的每个加密服务都具有相应SPI的子类。请参阅<a href="howtoimplaprovider.html#GUID-1D2FDA77-743C-47CB-9CCB-2585FEC0607A" title="当实例化提供者的Cipher，KeyAgreement，KeyGenerator，MAC或SecretKey工厂的实现（类）时，框架将确定提供者的代码库（JAR文件）并验证其签名。这样，JCA会对提供程序进行身份验证，并确保仅将由受信任实体签名的提供程序插入到JCA中。因此，对加密提供者的一项要求是必须对它们进行签名，如后面的步骤所述。">步骤1：编写您的服务实现代码</a> 。
                     </p>
                     <div class="infoboxnote" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-53A626BF-DDDB-4135-98C4-B94A602BBBEB">
                        <p class="notep1">注意：</p>这段代码只是一个存根提供程序，它演示了如何编写提供程序。它缺少实际的密码算法实现。的<code class="codeph">MyCipher</code>如果MyProvider是真正的安全提供程序，则该类将包含实际的加密算法实现。
                     </div><pre class="pre codeblock"><code>package com.example.MyProvider;

import java.security.*;
import java.security.spec.*;
import javax.crypto.*;

/**
 * Implementation represents a test Cipher.
 *
 * All are stubs.
 */
public class MyCipher extends CipherSpi {

    @Override
    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)
            throws IllegalBlockSizeException, BadPaddingException {
        return null;
    }

    @Override
    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,
            byte[] output, int outputOffset) throws ShortBufferException,
            IllegalBlockSizeException, BadPaddingException {
        return 0;
    }

    @Override
    protected int engineGetBlockSize() {
        return 0;
    }

    @Override
    protected byte[] engineGetIV() {
        return null;
    }

    @Override
    protected int engineGetOutputSize(int inputLen) {
        return 0;
    }

    @Override
    protected AlgorithmParameters engineGetParameters() {
        return null;
    }

    @Override
    protected void engineInit(int opmode, Key key, SecureRandom random)
            throws InvalidKeyException {
    }

    @Override
    protected void engineInit(int opmode, Key key,
            AlgorithmParameterSpec params, SecureRandom random)
            throws InvalidKeyException, InvalidAlgorithmParameterException {
    }

    @Override
    protected void engineInit(int opmode, Key key, AlgorithmParameters params,
            SecureRandom random) throws InvalidKeyException,
            InvalidAlgorithmParameterException {
    }

    @Override
    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
    }

    @Override
    protected void engineSetPadding(String padding)
            throws NoSuchPaddingException {
    }

    @Override
    protected int engineGetKeySize(Key key)
            throws InvalidKeyException {
        return 0;
    }

    @Override
    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {
        return null;
    }

    @Override
    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,
            byte[] output, int outputOffset) throws ShortBufferException {
        return 0;
    }
}
</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_JAVA.SECURITY.PROVIDER">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-D92A5965-CCCA-4BEB-8A55-4210778C6852">src / com.example。MyProvider / META-INF / services / java.security。提供者</p>
                     <p>的<code>java.security.Provider</code>文件使自动或未命名模块可以使用<span class="apiname">ServiceLoader</span>类搜索您的提供程序。请参阅<a href="howtoimplaprovider.html#GUID-B30F5AA2-6517-4107-9FFF-F6BBE57A7A5F">步骤6：将您的提供者放置在JAR文件中</a> 。
                     </p><pre class="pre codeblock"><code>com.example.MyProvider.MyProvider</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYAPP_MODULE-INFO">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-A1D0DEF8-90A0-431A-94AE-615EAAFD74E5">src / com.example。MyApp / module-info.java</p>
                     <p>该文件包含一个<span class="apiname">uses</span>指令，该指令指定模块所需的服务。该指令可帮助模块系统定位提供程序并确保它们可靠运行。这是对<code class="codeph">provides</code>指令<code class="codeph">MyProvider</code>模块定义。
                     </p><pre class="pre codeblock"><code>module com.example.MyApp {
    uses java.security.Provider;
}
</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_MYAPP.JAVA">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-0ADBCBB8-B7DA-4A5A-BE46-C0ACA36DBD88">src / com.example。MyApp / com / example / MyApp / MyApp.java</p><pre class="pre codeblock"><code>package com.example.MyApp;

import java.util.*;
import java.security.*;
import javax.crypto.*;

/**
 * A simple JCE test client to access a simple test Provider/Cipher
 * implementation in a signed modular jar.
 */
public class MyApp {

    private static final String PROVIDER = "MyProvider";
    private static final String CIPHER = "MyCipher";

    public static void main(String[] args) throws Exception {

        /*
         * Registers MyProvider dynamically.
         *
         * Could do statically by editing the java.security file.
         * Use the first form if using ServiceLoader ("uses" or
         * META-INF/service), the second if using the traditional class
         * lookup method.  Both if provider could be deployed to either.
         *
         * security.provider.14=MyProvider
         * security.provider.15=com.example.MyProvider.MyProvider
         */
        ServiceLoader&lt;Provider&gt; sl =
            ServiceLoader.load(java.security.Provider.class);
        for (Provider p : sl) {
            if (p.getName().equals(PROVIDER)) {
                System.out.println("Registering the Provider");
                Security.addProvider(p);
            }
        }

        /*
         * Get a MyCipher from MyProvider and initialize it.
         */
        Cipher cipher = Cipher.getInstance(CIPHER, PROVIDER);
        cipher.init(Cipher.ENCRYPT_MODE, (Key) null);

        /*
         * What Provider did we get?
         */
        Provider p = cipher.getProvider();
        Class c = p.getClass();
        Module m = c.getModule();
        System.out.println(p.getName() + ": version "
            + p.getVersionStr() + "\n"
            + p.getInfo() + "\n    "
            + ((m.getName() == null) ? "&lt;UNNAMED&gt;" : m.getName())
            + "/" + c.getName());
    }
}
</code></pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__MYPROVIDER_EXAMPLE_RUNTEST.SH">
                     <p class="subhead2" id="GUID-0BB9FD94-C66E-44BC-BE8A-AF7CB376F137__GUID-A269FDB1-ACDC-4787-8E3F-89041F5F2B0A">运行测试</p><pre class="pre codeblock"><code>#!/bin/sh

#
# A simple example to show how a JCE provider could be developed in a
# modular JDK, for deployment as either Named/Unnamed modules.
#

#
# Edit as appropriate
#
JDK_DIR=d:/java/jdk9
KEYSTORE=YourKeyStore
STOREPASS=YourStorePass
SIGNER=YourAlias

echo "-----------"
echo "Clean/Init"
echo "-----------"
rm -rf mods jars
mkdir mods jars

echo "--------------------"
echo "Compiling MyProvider"
echo "--------------------"
${JDK_DIR}/bin/javac.exe \
    --module-source-path src \
    -d mods \
    $(find src/com.example.MyProvider -name '*.java' -print)

echo "------------------------------------"
echo "Packaging com.example.MyProvider.jar"
echo "------------------------------------"
${JDK_DIR}/bin/jar.exe --create \
    --file jars/com.example.MyProvider.jar \
    --verbose \
    --module-version=1.0 \
    -C mods/com.example.MyProvider . \
    -C src/com.example.MyProvider META-INF/services

echo "----------------------------------"
echo "Signing com.example.MyProvider.jar"
echo "----------------------------------"
${JDK_DIR}/bin/jarsigner.exe \
    -keystore ${KEYSTORE} \
    -storepass ${STOREPASS} \
    jars/com.example.MyProvider.jar ${SIGNER}

echo "---------------"
echo "Compiling MyApp"
echo "---------------"
${JDK_DIR}/bin/javac.exe \
    --module-source-path src \
    -d mods \
    $(find src/com.example.MyApp -name '*.java' -print)

echo "-------------------------------"
echo "Packaging com.example.MyApp.jar"
echo "-------------------------------"
${JDK_DIR}/bin/jar.exe --create \
    --file jars/com.example.MyApp.jar \
    --verbose \
    --module-version=1.0 \
    -C mods/com.example.MyApp .

echo "------------------------"
echo "Test1                   "
echo "Named Provider/Named App"
echo "------------------------"
${JDK_DIR}/bin/java.exe \
    --module-path 'jars' \
    -m com.example.MyApp/com.example.MyApp.MyApp

echo "--------------------------"
echo "Test2                     "
echo "Named Provider/Unnamed App"
echo "--------------------------"
${JDK_DIR}/bin/java.exe \
    --module-path 'jars/com.example.MyProvider.jar' \
    --class-path 'jars/com.example.MyApp.jar' \
    com.example.MyApp.MyApp

echo "--------------------------"
echo "Test3                     "
echo "Unnamed Provider/Named App"
echo "--------------------------"
${JDK_DIR}/bin/java.exe \
    --module-path 'jars/com.example.MyApp.jar' \
    --class-path 'jars/com.example.MyProvider.jar' \
    -m com.example.MyApp/com.example.MyApp.MyApp

echo "----------------------------"
echo "Test4                       "
echo "Unnamed Provider/Unnamed App"
echo "----------------------------"
${JDK_DIR}/bin/java.exe \
    --class-path \
        'jars/com.example.MyProvider.jar;jars/com.example.MyApp.jar' \
    com.example.MyApp.MyApp
</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>