<html lang="en-us"  xml:lang="en-us"><head></head><body >﻿
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">
      <meta name="description" content="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">
      <title>Java PKI程序员指南</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="troubleshooting-jsse-sample-code.html" title="Previous" type="text/html">
      <link rel="next" href="java-sasl-api-programming-and-deployment-guide1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script>
   
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="troubleshooting-jsse-sample-code.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一个</a> <a href="java-sasl-api-programming-and-deployment-guide1.html" class="pull-right">下一个<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安全开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java PKI程序员指南</li>
            </ol>
            <a id="GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" name="GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF"></a>
            
            <h2 id="JSSEC-GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" class="sect2"><span class="enumeration_chapter">10</span> Java PKI程序员指南</h2>
         </header>
         <div class="ind">
            <div>
               <p>Java认证路径API由用于处理认证路径的类和接口组成，这些类和接口也称为认证链。如果认证路径满足某些验证规则，则可以使用它来安全地建立公共密钥到主题的映射。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF__GUID-93DCDADC-571F-4DED-897A-BD0FFEAC4236">话题</p>
                  <p><a href="java-pki-programmers-guide.html#GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" title="Java认证路径API定义了用于创建，构建和验证认证路径的接口和抽象类。可以使用基于提供者的接口插入实现。">PKI程序员指南概述</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-271526C4-6095-4233-9F7F-0CD0C62BDA93" title="Java认证路径API的核心类由支持算法和实现独立方式的认证路径功能的接口和类组成。">核心类和接口</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-266DD62E-39A7-435B-90DF-7EB1425D56E1" title="经验丰富的程序员可以创建自己的提供程序包，以提供认证路径服务实施。">实施服务提供商</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-EF1585DC-20BF-4140-B71E-0A8528D4A57D" title="Java认证路径API要求并利用一组标准名称来认证路径验证算法，编码和证书存储类型。">附录A：标准名称</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-EB250086-0AC1-4D60-AE2A-FC7461374746">附录B：SUN Provider中的CertPath实现</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-E6E737DB-4000-4005-969E-BCD0238B1566" title="支持RFC 2560中定义的对在线证书状态协议（OCSP）的客户端支持。">附录C：OCSP支持</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD" title="JdkLDAP提供程序支持CertStore引擎类的LDAP实现。">附录D：JdkLDAP提供程序中的CertPath实现</a></p>
                  <p><a href="java-pki-programmers-guide.html#GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3" title="jdk.certpath.disabledAlgorithms安全属性包含被认为是弱的或损坏的密码算法和密钥大小约束的列表。包含任何这些算法或密钥大小的证书和其他数据（CRL，OCSPResponses）将在认证路径构建和验证期间被阻止。Oracle的PKIX实现使用此属性，其他实现可能不检查和使用它。">附录E：禁用密码算法</a></p>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" name="GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E"></a><h3 id="JSSEC-GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" class="sect3">PKI程序员指南概述</h3>
               <div>
                  <p>Java认证路径API定义了用于创建，构建和验证认证路径的接口和抽象类。可以使用基于提供者的接口插入实现。</p>
                  <div class="section">
                     <p>该API基于《 <cite>Java密码体系结构参考指南》中</cite>描述的“ <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">密码服务提供商”</a>体系结构，并且包括特定于算法的类，用于根据PKIX标准构建和验证X.509认证路径。PKIX标准是由<a href="http://datatracker.ietf.org/wg/pkix/charter/" target="_blank">IETF PKIX工作组开发的</a> 。
                     </p>
                     <p>此API最初使用<a href="http://jcp.org/en/home/index" target="_blank">Java Community Process</a>程序指定为Java Specification Request（JSR）000055。从Java SE开发套件（JDK）1.4开始，该API包含在Java SDK中。请参阅<a href="http://jcp.org/en/jsr/detail?id=55" target="_blank">JSR 55：认证路径API</a> 。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E__GUID-E89AB359-032A-48CA-B599-3C247ECA2ED0">谁应该阅读本文件</p>
                     <p>本文档适用于两种类型的经验丰富的开发人员：</p>
                     <ol>
                        <li> 
                           <p>那些想要设计可构建或验证认证路径的安全应用程序的人。</p> 
                        </li>
                        <li> 
                           <p>那些想要编写用于构建或验证认证路径的服务提供商实现的人。</p> 
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E__GUID-4BEA98CF-CE46-4BB2-B7D0-E7170C4B955C">
                     <p>本文档假定您已经阅读了<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">加密服务提供者</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-2EFB901C-9ED1-4823-9311-B05B49E34AEA" name="GUID-2EFB901C-9ED1-4823-9311-B05B49E34AEA"></a><h4 id="JSSEC-GUID-2EFB901C-9ED1-4823-9311-B05B49E34AEA" class="sect4">公钥证书介绍</h4>
                  <div>
                     <p>公共密钥应用程序和系统的用户必须确信某个主题的公共密钥是真实的，即关联的私有密钥由该主题拥有。公钥证书用于建立这种信任。</p>
                     <p><span class="bold">公钥（或身份）证书</span>是公钥与身份的绑定，身份由另一个实体（通常称为<span class="bold">证书颁发机构</span> （CA））的私钥进行数字签名。在本节的其余部分，术语“ CA”用于表示签署证书的实体。
                     </p>
                     <p>如果用户没有签名对象的公钥证书的CA公钥的受信任副本，则需要另一个用于签名CA的公钥证书。可以递归应用此逻辑，直到从<span class="bold">信任锚</span>或<span class="bold">最受信任的CA发现</span>到目标主题的证书链（或<span class="bold">证明路径</span> ）为止（通常称为<span class="bold">终端实体</span> ）。<span class="bold">最受信任的CA</span>通常由颁发给用户直接信任的CA的证书指定。通常，证书路径是证书的有序列表，通常由终端实体的公钥证书和零个或多个其他证书组成。认证路径通常具有一种或多种编码，从而可以在网络上安全地传输到不同的操作系统体系结构。
                     </p>
                     <p>下图说明了从最受信任的CA的公钥（CA 1）到目标主题（Alice）的认证路径。认证路径通过名为CA2的中间CA建立对Alice公钥的信任。</p>
                     <div class="figure" id="GUID-2EFB901C-9ED1-4823-9311-B05B49E34AEA__GUID-9B683BE7-5148-49FD-A561-A5E6C220F7F7">
                        <p class="titleinfigure">图10-1从CA的公钥（CA 1）到目标主题的认证路径</p><img src="img/publickey_pki.png" alt="如下图10-1所示" title="如下图10-1所示" longdesc="img_text/publickey_pki.html"><br><a href="img_text/publickey_pki.html">“图10-1从CA的公钥（CA 1）到目标主题的认证路径”的描述</a></div>
                     <!-- class="figure" -->
                     <p>必须先验证认证路径，然后才能依靠它来建立对主题的公钥的信任。验证可以包括对证书路径中包含的证书的各种检查，例如，验证签名和检查每个证书是否都已被吊销。PKIX标准定义了一种用于验证由X.509证书组成的认证路径的算法。</p>
                     <p>通常，用户可能没有从最受信任的CA到主题的认证路径。提供构建或发现认证路径的服务是启用公钥的系统的重要功能。<a href="http://www.ietf.org/rfc/rfc2587.txt" target="_blank">RFC 2587</a>定义了LDAP（轻型目录访问协议）架构定义，该架构定义有助于使用LDAP目录服务协议发现X.509认证路径。
                     </p>
                     <p>建立和验证证书路径是许多标准安全协议（例如SSL / TLS / DTLS，S / MIME和IPsec）的重要组成部分。Java认证路径API为需要将该功能集成到其应用程序中的开发人员提供了一组类和接口。该API有益于两种类型的开发人员：需要为特定的认证路径构建或验证算法编写服务提供商实现的开发人员；以及需要访问标准算法以独立于实现的方式创建，构建和验证认证路径的人员。</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23" name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23"></a><h4 id="JSSEC-GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23" class="sect4">X.509证书和证书吊销列表（CRL）</h4>
                  <div>
                     <p>公钥证书是来自一个实体的数字签名声明，该声明表示另一实体的公钥和其他一些信息具有特定的价值。</p>
                     <div class="section">
                        <p>下表定义了一些关键术语：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-AE06C840-0CDB-4B6E-8704-6D4748E6E0F0"><!-- --></a> <span class="variable" translate="no">Public Keys</span></dt>
                           <dd>这些是与特定实体相关联的数字，旨在使所有需要与该实体进行信任交互的人都知道。公钥用于验证签名。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-BD9AF829-3573-4518-B55C-7176F73B1766"><!-- --></a> <span class="variable" translate="no">Digitally Signed</span></dt>
                           <dd>如果某些数据进行了<span class="variable" translate="no">digitally signed</span>则将其与实体的“身份”一起存储，并带有证明该实体知道该数据的签名。通过使用实体的私钥签名使数据不可伪造。
                           </dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-D9C21B0B-3E70-4DC5-AE83-BB794E175306"><!-- --></a> <span class="variable" translate="no">Identity</span></dt>
                           <dd>一种寻址实体的已知方法。在某些系统中，身份是公共密钥，在其他系统中，身份可以是从UNIX UID到电子邮件地址再到X.509专有名称的任何内容。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-02ECE861-7359-4FF7-8A78-EE7F9B412062"><!-- --></a> <span class="variable" translate="no">Signature</span></dt>
                           <dd>使用实体（签名者）的私钥对某些数据计算签名。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-27909E67-E056-4AC0-8BBB-26C32D3D2ACF"><!-- --></a> <span class="variable" translate="no">Private Keys</span></dt>
                           <dd>这些是数字，每个数字只应为拥有其私钥的特定实体知道（也就是说，应将其保密）。私钥和公钥在所有公钥密码系统（也称为“公钥密码系统”）中成对存在。在典型的公共密钥密码系统中，例如DSA，私有密钥恰好对应于一个公共密钥。私钥用于计算签名。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-A64089C4-83C1-4550-9D16-28732ADA7947"><!-- --></a> <span class="variable" translate="no">Entity</span></dt>
                           <dd>实体是个人，组织，程序，计算机，企业，银行或您在某种程度上信任的其他事物。</dd>
                        </dl>
                        <p>基本上，公共密钥加密要求访问用户的公共密钥。在大规模联网环境中，无法保证已建立通信实体之间的先前关系，或者无法保证所有使用的公钥都存在受信任的存储库。发明了证书来解决此公钥分发问题。现在， <span class="variable" translate="no">Certification Authority</span> （CA）可以充当<span class="variable" translate="no">Trusted Third Party</span> 。CA是受信任为其他实体签署（颁发）证书的实体（例如，企业）。假定CA受法律协议约束，只会创建有效且可靠的证书。有许多公共证书颁发机构，例如<a href="http://www.verisign.com" target="_blank">VeriSign</a> ， <a href="http://www.thawte.com" target="_blank">Thawte</a> ， <a href="http://www.entrust.com" target="_blank">Entrust</a>等。您还可以使用诸如Netscape / Microsoft证书服务器或适用于您的组织的Entrust CA产品之类的产品来运行自己的证书颁发机构。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-9E67EE6A-5F24-40B4-B07C-2164E963F0ED">哪些应用程序使用证书？</p>
                        <p>X.509证书当今最广泛可见的应用是在支持TLS协议的Web浏览器（例如Mozilla Firefox和Microsoft Internet Explorer）中。TLS（传输层安全性）是一种安全协议，可为您的网络流量提供隐私和身份验证。这些浏览器只能将此协议用于支持TLS的Web服务器。</p>
                        <p>依赖X.509证书的其他技术包括：</p>
                        <ul style="list-style-type:disc">
                           <li>各种代码签名方案，例如签名的Java ARchives和Microsoft Authenticode。</li>
                           <li>各种安全的电子邮件标准，例如PEM和S / MIME。</li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-1C28CDF4-CC9A-4166-947D-36A7A605ADA3">我如何获得证书？</p>
                        <p>有两种用于获取证书的基本技术：</p>
                        <ul style="list-style-type:disc">
                           <li>您可以自己创建一个（使用正确的工具，例如keytool）。</li>
                           <li>您可以要求证书颁发机构向您颁发证书（直接颁发或使用诸如<span class="bold">keytool之类</span>的工具来生成请求）。
                           </li>
                        </ul>
                        <p>证书创建过程的主要输入是：</p>
                        <ul style="list-style-type:disc">
                           <li>使用某些特殊工具（例如keytool）或浏览器生成的匹配的<span class="variable" translate="no">public and private keys</span> 。<span class="bold">只有公钥才会显示给其他任何人。</span> 私钥用于签名数据；如果有人知道您的私钥，他们可以伪装成您……也许伪造了属于您的法律文件！
                           </li>
                           <li>您需要提供<span class="variable" translate="no">information about the entity being certified</span> （例如您）的信息。通常包括您的姓名和组织地址之类的信息。如果您要求CA为您颁发证书，则通常需要提供证明以证明信息的正确性。
                           </li>
                        </ul>
                        <p>如果您要求CA向您颁发证书，请提供您的公钥和一些有关您的信息。您将使用一种工具（例如keytool或支持生成证书签名请求的浏览器）。对这些信息进行数字签名，然后将其发送到CA。然后，CA将生成证书并将其返回。</p>
                        <p>如果您自己生成证书，则将获得相同的信息，再添加一些信息（证书有效的日期，序列号），然后使用某些工具（例如keytool）创建证书。并非每个人都会接受自签名证书。 CA的部分价值是充当中立且可信赖的介绍服务，部分取决于其验证要求，这些要求已在其认证服务规范（CSP）中公开发布。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-9233A826-76A2-4770-9263-7E866E96E044">X.509证书中包含什么？</p>
                        <p>X.509标准定义了证书中可以包含哪些信息，并描述了如何将其记录下来（数据格式）。除签名外，所有X.509证书还具有以下数据：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-1B3500E7-D036-45DA-BDD4-B6698F4CF5CF"><!-- --></a> <span class="bold">版本</span></dt>
                           <dd>这确定了该证书适用的X.509标准版本，这会影响可以在其中指定哪些信息。到目前为止，已定义了三个版本。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-1A458D8C-2304-4E0F-BEE6-C7BFD204A10B"><!-- --></a> <span class="bold">序列号</span></dt>
                           <dd>创建证书的实体负责为其分配一个序列号，以将其与颁发的其他证书区分开。此信息以多种方式使用，例如，当证书被吊销时，其序列号被放在证书吊销列表（CRL）中。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-0B248269-402E-42E7-A0B3-597ADDE96611"><!-- --></a> <span class="bold">签名算法标识符</span></dt>
                           <dd>这标识了CA用于签署证书的算法。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-1BD8A301-9D9B-411D-A04C-51FE3686E206"><!-- --></a> <span class="bold">发行人名称</span></dt>
                           <dd>签署证书的实体的X.500名称。这通常是一个CA。使用此证书意味着信任签署此证书的实体。（请注意，在某些情况下，例如<span class="variable" translate="no">root or top-level</span> CA证书，颁发者会签署自己的证书。）
                           </dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-D359D40A-D9C6-4212-B15D-CEC95618C378"><!-- --></a> <span class="bold">有效期</span></dt>
                           <dd>每个证书仅在有限的时间内有效。该时间段由开始日期和时间以及结束日期和时间来描述，并且可以短至几秒钟或几乎长达一个世纪。所选的有效期取决于许多因素，例如用于签署证书的私钥的强度或一个人愿意为证书支付的金额。如果关联的私钥没有受到破坏，则这是实体可以依靠公共价值的预期期限。</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-01030D38-927F-4C7E-859A-AF25A09F8992"><!-- --></a> <span class="bold">使用者名称</span></dt>
                           <dd>证书标识其公钥的实体的名称。该名称使用X.500标准，因此在Internet上应该是唯一的。这是实体的专有名称（DN），例如，<pre class="pre codeblock"><code>
    CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</code></pre>（这些是指主题的通用名称，组织单位，组织和国家/地区。）</dd>
                           <dt class="dlterm"><a name="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-36D2585D-476B-44DC-BDB6-6E2AB2FB112A"><!-- --></a> <span class="bold">主题公钥信息</span></dt>
                           <dd>这是被命名实体的公共密钥，以及指定该密钥属于哪个公共密钥密码系统以及任何相关密钥参数的算法标识符。</dd>
                        </dl>
                        <p><span class="variable" translate="no">X.509 Version 1</span>自1988年以来一直可用，已被广泛部署并且是最通用的。
                        </p>
                        <p><span class="variable" translate="no">X.509 Version 2</span>引入了主题和颁发者唯一标识符的概念，以处理随着时间的推移主题和/或颁发者名称重复使用的可能性。大多数证书配置文件强烈建议不要重复使用名称，并且证书不应使用唯一标识符。版本2证书没有广泛使用。
                        </p>
                        <p><span class="variable" translate="no">X.509 Version 3</span>是最新的版本（1996），支持扩展的概念，任何人都可以定义扩展并将其包括在证书中。今天使用的一些常见扩展是： <span class="variable" translate="no">KeyUsage</span> （将密钥的使用限制于特定目的，例如“仅签名”）和<span class="variable" translate="no">AlternativeNames</span> （允许其他身份也与此公钥相关联，例如DNS名称，电子邮件地址，IP地址）。扩展可以标记为<span class="variable" translate="no">critical</span>以指示应检查并强制执行/使用扩展。例如，如果证书的KeyUsage扩展名标记为critical，并将其设置为“ keyCertSign”，则如果在SSL通信期间显示此证书，则应将其拒绝，因为证书扩展名表明关联的私钥仅应用于签名证书。而不是用于SSL。
                        </p>
                        <p>证书中的所有数据均使用称为ASN.1 / DER的两个相关标准进行编码。 <span class="variable" translate="no">Abstract Syntax Notation 1</span>描述了数据。<cite>杰出编码规则</cite>描述了一种存储和传输数据的单一方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-D9894632-4CA4-4FFA-9817-91B17FEA1BF5">可以使用哪种Java API访问和管理证书？</p>
                        <p>证书API，位于<a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/package-summary.html" target="_blank"><code class="codeph">java.security.cert</code></a>软件包，包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li><span class="bold">CertificateFactory</span>类定义证书工厂的功能，该功能用于根据其编码生成证书，证书吊销列表（CRL）和证书路径对象。
                           </li>
                           <li><span class="bold">证书</span>类是用于管理各种证书的抽象类。它是具有不同格式但重要的常用用法的证书的抽象。例如，不同类型的证书（例如X.509和PGP）共享常规证书功能（例如编码和验证）以及某些类型的信息（例如公钥）。
                           </li>
                           <li><span class="bold">CRL</span>类是用于管理各种证书吊销列表（CRL）的抽象类。
                           </li>
                           <li><span class="bold">X509Certificate</span>类是X.509证书的抽象类。它提供了一种访问X.509证书的所有属性的标准方法。
                           </li>
                           <li><span class="bold">X509Extension</span>接口是X.509扩展的接口。为X.509 v3证书和v2 CRL（证书吊销列表）定义的扩展提供了将附加属性与用户或公钥相关联的机制，例如用于管理证书层次结构和用于管理CRL分发的机制。
                           </li>
                           <li><span class="bold">X509CRL</span>类是X.509证书吊销列表（CRL）的抽象类。CRL是带有时间戳的列表，用于标识已撤销的证书。它由证书颁发机构（CA）签名，可以在公共存储库中免费获得。
                           </li>
                           <li><span class="bold">X509CRLEntry</span>类是CRL条目的抽象类。
                           </li>
                        </ul> 
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8DEBED06-13C6-4608-8C74-7C8144EF0D23__GUID-2903E1FC-28C2-425C-BA2A-0B2059DCEAC6">哪些Java工具可以生成，显示，导入和导出X.509证书？</p>
                        <p>有一个名为<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a>的工具，可用于创建公用/专用密钥对和X.509 v3证书，以及管理密钥库。密钥和证书用于对Java应用程序和applet进行数字签名（请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-925E7A1B-B3F3-44D2-8B49-0B3FA2C54864" target="_blank">jarsigner</a> ）。
                        </p>
                        <p><span class="variable" translate="no">keystore</span>是保存密钥和证书的受保护数据库。对密钥库的访问受密码保护（密码在创建密钥库时定义，由创建密钥库的人定义，并且只有在提供当前密码时才可以更改）。此外，密钥库中的每个私钥都可以用自己的密码来保护。
                        </p>
                        <p>使用<span class="bold">keytool</span> ，可以显示，导入和导出存储为文件的X.509 v1，v2和v3证书，并生成新的v3证书。有关示例，请参见《 <span><cite>Java平台标准版工具参考</cite></span> 》中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a>的“示例”部分。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-271526C4-6095-4233-9F7F-0CD0C62BDA93" name="GUID-271526C4-6095-4233-9F7F-0CD0C62BDA93"></a><h3 id="JSSEC-GUID-271526C4-6095-4233-9F7F-0CD0C62BDA93" class="sect3">核心类和接口</h3>
               <div>
                  <p>Java认证路径API的核心类由支持算法和实现独立方式的认证路径功能的接口和类组成。</p>
                  <div class="section">该API建立并扩展了现有的<code class="codeph">java.security.cert</code>用于处理证书的软件包。核心类可以分为4类：基本，验证，构建和存储：<ul style="list-style-type:disc">
                        <li> 
                           <p><a href="java-pki-programmers-guide.html#GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8" title="基本认证路径类提供了用于编码和表示认证路径的基本功能。Java认证路径API中的关键基本类是CertPath，它封装了所有类型的认证路径共享的通用方面。应用程序使用CertificateFactory类的实例来创建CertPath对象。">基本认证路径类别</a></p> 
                           <ul style="list-style-type:disc">
                              <li> 
                                 <p><code class="codeph">CertPath</code> ， <code class="codeph">CertificateFactory</code>和<code class="codeph">CertPathParameters</code></p> 
                              </li>
                           </ul> 
                        </li>
                        <li> 
                           <p><a href="java-pki-programmers-guide.html#GUID-C825028D-5F30-4041-ACC4-466657F59F02" title="Java认证路径API包括用于验证认证路径的类和接口。应用程序使用CertPathValidator类的实例来验证CertPath对象。如果成功，将在实现CertPathValidatorResult接口的对象中返回验证算法的结果。">认证路径验证类别</a></p> 
                           <ul style="list-style-type:disc">
                              <li> 
                                 <p><code class="codeph">CertPathValidator</code> ， <code class="codeph">CertPathValidatorResult</code>和<code class="codeph">CertPathChecker</code></p> 
                              </li>
                           </ul> 
                        </li>
                        <li> 
                           <p><a href="java-pki-programmers-guide.html#GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20" title="Java认证路径API包括用于构建（或发现）认证路径的类。应用程序使用CertPathBuilder类的实例来构建CertPath对象。如果成功，则生成的结果将在实现CertPathBuilderResult接口的对象中返回。">认证路径构建类</a></p> 
                           <ul style="list-style-type:disc">
                              <li> 
                                 <p><code class="codeph">CertPathBuilder</code>和<code class="codeph">CertPathBuilderResult</code></p> 
                              </li>
                           </ul> 
                        </li>
                        <li> 
                           <p><a href="java-pki-programmers-guide.html#GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" title="Java认证路径API包括CertStore类，用于从存储库中检索证书和CRL。">证书/ CRL存储类别</a></p> 
                           <ul style="list-style-type:disc">
                              <li> 
                                 <p><code class="codeph">CertStore</code> ， <code class="codeph">CertStoreParameters</code> ， <code class="codeph">CertSelector</code>和<code class="codeph">CRLSelector</code></p> 
                              </li>
                           </ul> 
                        </li>
                     </ul>
                     <p>Java认证路径API还包括一组特定于算法的类，这些类经过建模，可与<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280中</a>定义的PKIX认证路径验证算法一起使用： <cite>公钥基础结构证书和证书吊销列表（CRL）概要文件</cite> 。<a href="java-pki-programmers-guide.html#GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" title="Java认证路径API包括一组特定于算法的类，这些类经过建模以与PKIX认证路径验证算法一起使用。">PKIX类</a>是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TrustAnchor</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXParameters</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXCertPathValidatorResult</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXBuilderParameters</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXCertPathBuilderResult</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXCertPathChecker</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PKIXRevocationChecker</code></p>
                        </li>
                     </ul>
                     <p>有关认证路径API类的完整参考文档，请参见<a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/package-summary.html" target="_blank"><code class="codeph">java.security.cert</code></a> 。
                     </p>
                     <p><span class="apiname">CertPath</span> API中的大多数类和接口都不是线程安全的。但是，有些例外会在本指南和API规范中指出。需要同时访问一个非线程安全对象的多个线程应在它们之间进行同步并提供必要的锁定。每个操作单独对象的多个线程不需要同步。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-271526C4-6095-4233-9F7F-0CD0C62BDA93__GUID-22A92EA3-26BE-46E0-982F-475702D74971">话题</p>
                     <p><a href="java-pki-programmers-guide.html#GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8" title="基本认证路径类提供了用于编码和表示认证路径的基本功能。Java认证路径API中的关键基本类是CertPath，它封装了所有类型的认证路径共享的通用方面。应用程序使用CertificateFactory类的实例来创建CertPath对象。">基本认证路径类别</a></p>
                     <p><a href="java-pki-programmers-guide.html#GUID-C825028D-5F30-4041-ACC4-466657F59F02" title="Java认证路径API包括用于验证认证路径的类和接口。应用程序使用CertPathValidator类的实例来验证CertPath对象。如果成功，将在实现CertPathValidatorResult接口的对象中返回验证算法的结果。">认证路径验证类别</a></p>
                     <p><a href="java-pki-programmers-guide.html#GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20" title="Java认证路径API包括用于构建（或发现）认证路径的类。应用程序使用CertPathBuilder类的实例来构建CertPath对象。如果成功，则生成的结果将在实现CertPathBuilderResult接口的对象中返回。">认证路径构建类</a></p>
                     <p><a href="java-pki-programmers-guide.html#GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" title="Java认证路径API包括CertStore类，用于从存储库中检索证书和CRL。">证书/ CRL存储类别</a></p>
                     <p><a href="java-pki-programmers-guide.html#GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" title="Java认证路径API包括一组特定于算法的类，这些类经过建模以与PKIX认证路径验证算法一起使用。">PKIX类别</a></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8" name="GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8"></a><h4 id="JSSEC-GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8" class="sect4">基本认证路径类别</h4>
                  <div>
                     <p>基本认证路径类提供了用于编码和表示认证路径的基本功能。Java认证路径API中的关键基本类是<code class="codeph">CertPath</code> ，其中封装了所有类型的认证路径共享的通用方面。应用程序使用<code class="codeph">CertificateFactory</code>类创建一个<code class="codeph">CertPath</code>宾语。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-2D30176C-EE5A-41F8-896B-1A16E7F786B8__GUID-806EEAC8-58FB-41CC-821E-26974A1FB799">话题</p>
                        <p><a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="CertPath类是用于认证路径的抽象类。它定义了所有证书路径对象共享的功能。可以通过对CertPath类进行子类化来实现各种证书路径类型，即使它们可能具有不同的内容和排序方案。">CertPath类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195" title="CertificateFactory类是引擎类，用于定义证书工厂的功能。它用于生成证书，CRL和CertPath对象。">CertificateFactory类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-2AF52C1B-8EE2-4D65-9273-F7AC523AB42F" title="CertPathParameters接口是与特定认证路径构建器或验证算法一起使用的一组参数的透明表示。">CertPathParameters接口</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" name="GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC"></a><h5 id="JSSEC-GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" class="sect5">CertPath类</h5>
                     <div>
                        <p>的<code class="codeph">CertPath</code> class是用于认证路径的抽象类。它定义了所有证书路径对象共享的功能。可以通过将认证子类化来实现各种认证路径类型。 <code class="codeph">CertPath</code>类，即使它们可能具有不同的内容和排序方案。
                        </p>
                        <p>所有<code class="codeph">CertPath</code>对象是可序列化的，不可变的并且是线程安全的，并且具有以下特征：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p>一种</p>
                              <p>这对应于证书路径中证书的类型，例如：X.509。一个的类型<code class="codeph">CertPath</code>使用以下方法获得：</p> <pre class="codeblock"><code>
    public String getType()
</code></pre> <p>有关标准证书类型，请参见<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types" target="_blank">CertificateFactory Types</a> 。
                              </p> 
                           </li>
                           <li> 
                              <p>证书清单</p>
                              <p>的<code class="codeph">getCertificates</code>方法返回证书路径中的证书列表：</p> <pre class="codeblock"><code>
    public abstract List&lt;? extends Certificate&gt; getCertificates()
</code></pre>此方法返回一个<code class="codeph">List</code>零或更多<code class="codeph">java.security.cert.Certificate</code>对象。返回的<code class="codeph">List</code>和<code class="codeph">Certificates</code>其中包含的内容是不可变的，以保护内容<code class="codeph">CertPath</code>宾语。返回的证书的顺序取决于类型。按照惯例， <code class="codeph">CertPath</code> X.509类型的对象从目标证书开始，以信任锚发布的证书结束。即，一张证书的颁发者是下一张证书的主题。代表<code class="codeph">TrustAnchor</code>不应包含在认证路径中。未验证的X.509 <code class="codeph">CertPath</code>可能未遵循此约定。PKIX <code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code> s将检测到与这些约定的任何偏离，这些偏离会导致证书路径无效，并抛出<code class="codeph">CertPathValidatorException</code> 。
                           </li>
                           <li> 
                              <p>一种或多种编码</p>
                              <p>每<code class="codeph">CertPath</code>对象支持一种或多种编码。这些是证书路径的外部编码形式，用于Java虚拟机外部需要路径的标准表示时（例如，通过网络将路径传输给其他方时）。可以使用默认格式编码每个路径，使用以下方法返回其字节：</p> <pre class="codeblock"><code>
    public abstract byte[] getEncoded()
</code></pre>或者， <code class="codeph">getEncoded(String)</code>方法通过将编码格式指定为来返回特定的受支持编码<code class="codeph">String</code> （例如：“ PKCS7”）。有关标准编码格式，请参见<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings" target="_blank">CertPath Encodings</a> 。<pre class="codeblock"><code>
    public abstract byte[] getEncoded(String encoding)
</code></pre>另外， <code class="codeph">getEncodings</code>方法返回支持的编码格式的迭代器<code class="codeph">String</code> s（首先返回默认编码格式）：<pre class="codeblock"><code>
    public abstract Iterator&lt;String&gt; getEncodings()
</code></pre></li>
                        </ul>
                        <p>所有<code class="codeph">CertPath</code>对象也是<code class="codeph">Serializable</code> 。 <code class="codeph">CertPath</code>对象解析为备用<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CertPath.CertPathRep.html" target="_blank">CertPath.CertPathRep</a></code>序列化期间的对象。这允许<code class="codeph">CertPath</code>不论其基础实现如何，都可以将对象序列化为等效表示形式。
                        </p>
                        <p><code class="codeph">CertPath</code>对象是从编码的字节数组或列表中生成的<code class="codeph">Certificate</code>的使用<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195" title="The CertificateFactory class is an engine class that defines the functionality of a certificate factory. It is used to generate Certificate, CRL, and CertPath objects.">CertificateFactory</a></code> 。或者， <code class="codeph">CertPathBuilder</code>可以用来尝试找到一个<code class="codeph">CertPath</code>从最受信任的CA到特定主题。一旦<code class="codeph">CertPath</code>对象已创建，可以通过将其传递给<code class="codeph">validate</code>的方法<code class="codeph">CertPathValidator</code> 。这些概念中的每一个将在后续章节中进行详细说明。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195" name="GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195"></a><h5 id="JSSEC-GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195" class="sect5">CertificateFactory类</h5>
                     <div>
                        <p>的<code class="codeph">CertificateFactory</code> class是定义证书工厂功能的引擎类。它用于生成<code class="codeph">Certificate</code> ， <code class="codeph">CRL</code>和<code class="codeph">CertPath</code>对象。
                        </p>
                        <p>一种<code class="codeph">CertificateFactory</code>不应与<code class="codeph">CertPathBuilder</code> 。一种<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code> （稍后讨论）用于查找或查找证书路径（如果不存在）。相比之下， <code class="codeph">CertificateFactory</code>当已经发现认证路径并且调用者需要实例化一个认证路径时使用<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="The CertPath class is an abstract class for certification paths. It defines the functionality shared by all certification path objects. Various certification path types can be implemented by subclassing the CertPath class, even though they may have different contents and ordering schemes.">CertPath</a></code>对象的内容，它们以不同的形式存在，例如编码的字节数组或<code class="codeph">Certificate</code> s。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195__GUID-27757E23-8A22-4F1E-8E6A-85D19DFA2D6B">创建一个CertificateFactory对象</p>
                           <p>有关创建<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" title="The CertificateFactory class defines the functionality of a certificate factory, which is used to generate certificate and certificate revocation list (CRL) objects from their encoding.">证书</a>的详细信息，请参见《 <cite>Java密码体系结构参考指南》中</cite>的<a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" title="CertificateFactory类定义证书工厂的功能，该功能用于从其编码生成证书和证书吊销列表（CRL）对象。">CertificateFactory</a>部分。 <code class="codeph">CertificateFactory</code>宾语。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-BCABADD4-C0DC-4987-B187-F086B4BCE195__GUID-2B477858-FF29-47C9-8304-CB1196C58E62">生成CertPath对象</p>
                           <p>一种<code class="codeph">CertificateFactory</code>实例生成<code class="codeph">CertPath</code>来自的对象<code class="codeph">List</code>的<code class="codeph">Certificate</code>对象或来自<code class="codeph">InputStream</code>包含a的编码形式<code class="codeph">CertPath</code> 。就像一个<code class="codeph">CertPath</code> ，每个<code class="codeph">CertificateFactory</code>支持证书路径的默认编码格式（例如：PKCS＃7）。产生一个<code class="codeph">CertPath</code>对象，并使用从输入流中读取的数据（默认编码格式）对其进行初始化，请使用<code class="codeph">generateCertPath</code>方法：</p><pre class="pre codeblock"><code>public final CertPath generateCertPath(InputStream inStream)</code></pre><p>或来自特定的编码格式：</p><pre class="pre codeblock"><code>    public final CertPath generateCertPath(InputStream inStream, 
                                           String encoding)</code></pre><p>要了解支持哪些编码格式，请使用<code class="codeph">getCertPathEncodings</code>方法（首先返回默认编码）：</p><pre class="pre codeblock"><code>public final Iterator&lt;String&gt; getCertPathEncodings()</code></pre><p>从一个生成证书路径对象<code class="codeph">List</code>的<code class="codeph">Certificate</code>对象，请使用以下方法：</p><pre class="pre codeblock"><code>public final CertPath generateCertPath(List&lt;? extends Certificate&gt; certificates)</code></pre><p>一种<code class="codeph">CertificateFactory</code>总是回来<code class="codeph">CertPath</code>包含的对象<code class="codeph">Certificates</code>与工厂相同的类型。例如，一个<code class="codeph">CertificateFactory</code> X.509类型的返回<code class="codeph">CertPath</code>由证书组成的对象，这些证书是<code class="codeph">java.security.cert.X509Certificate</code> 。
                           </p>
                           <p>以下代码示例说明了从存储在文件中的PKCS＃7编码的证书答复中生成证书路径：</p><pre class="pre codeblock"><code>    // open an input stream to the file
    FileInputStream fis = new FileInputStream(filename);
    // instantiate a CertificateFactory for X.509
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    // extract the certification path from
    // the PKCS7 SignedData structure
    CertPath cp = cf.generateCertPath(fis, "PKCS7");
    // print each certificate in the path
    List&lt;Certificate&gt; certs = cp.getCertificates();
    for (Certificate cert : certs) {
        System.out.println(cert);
    }</code></pre><p>这是从中获取证书链的另一个代码示例<code class="codeph">KeyStore</code>并将其转换为<code class="codeph">CertPath</code>用一个<code class="codeph">CertificateFactory</code> ：</p><pre class="pre codeblock"><code>    // instantiate a KeyStore with type JKS
    KeyStore ks = KeyStore.getInstance("JKS");
    // load the contents of the KeyStore
    ks.load(new FileInputStream("./keystore"),
        "password".toCharArray());
    // fetch certificate chain stored with alias "sean"
    Certificate[] certArray = ks.getCertificateChain("sean");
    // convert chain to a List
    List certList = Arrays.asList(certArray);
    // instantiate a CertificateFactory for X.509
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    // extract the certification path from
    // the List of Certificates
    CertPath cp = cf.generateCertPath(certList);</code></pre><p>请注意，在<code class="codeph">CertificateFactory</code>命名<code class="codeph">generateCertificates</code>解析一系列<code class="codeph">Certificates</code> 。对于包含多个证书的编码，请使用<code class="codeph">generateCertificates</code>当您想解析可能不相关的证书的集合时。否则，使用<code class="codeph">generateCertPath</code>当您想生成一个<code class="codeph">CertPath</code>然后使用<code class="codeph">CertPathValidator</code> （稍后讨论）。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2AF52C1B-8EE2-4D65-9273-F7AC523AB42F" name="GUID-2AF52C1B-8EE2-4D65-9273-F7AC523AB42F"></a><h5 id="JSSEC-GUID-2AF52C1B-8EE2-4D65-9273-F7AC523AB42F" class="sect5">CertPathParameters接口</h5>
                     <div>
                        <p>的<code class="codeph">CertPathParameters</code>接口是用于特定认证路径构建器或验证算法的一组参数的透明表示。
                        </p>
                        <p>其主要目的是对所有认证路径参数规范进行分组（并提供类型安全性）。的<code class="codeph">CertPathParameters</code>接口扩展了<code class="codeph">Cloneable</code>接口并定义一个<code class="codeph">clone()</code>不会引发异常的方法。此接口的所有具体实现都应实现并覆盖<code class="codeph">Object.clone()</code>方法，如有必要。这允许应用程序克隆任何<code class="codeph">CertPathParameters</code>宾语。
                        </p>
                        <p>实现对象的对象<code class="codeph">CertPathParameters</code>接口作为参数传递给的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code>和<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code>类。通常情况下， <code class="codeph">CertPathParameters</code>接口将保存一组特定于特定认证路径构建或验证算法的输入参数。例如， <code class="codeph">PKIXParameters</code>类是<code class="codeph">CertPathParameters</code>接口，其中包含一组用于PKIX认证路径验证算法的输入参数。一个这样的参数是调用者信任的最受信任的CA集合，用于锚定验证过程。在讨论以下内容的部分中，将更详细地讨论此参数： <code class="codeph"><a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">PKIXParameters</a></code>类。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C825028D-5F30-4041-ACC4-466657F59F02" name="GUID-C825028D-5F30-4041-ACC4-466657F59F02"></a><h4 id="JSSEC-GUID-C825028D-5F30-4041-ACC4-466657F59F02" class="sect4">认证路径验证类别</h4>
                  <div>
                     <p>Java认证路径API包括用于验证认证路径的类和接口。应用程序使用<code class="codeph">CertPathValidator</code>类来验证<code class="codeph">CertPath</code>宾语。如果成功，则将验证算法的结果返回到实现<code class="codeph">CertPathValidatorResult</code>接口。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-C825028D-5F30-4041-ACC4-466657F59F02__GUID-806EEAC8-58FB-41CC-821E-26974A1FB799">话题</p>
                        <p><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="CertPathValidator类是用于验证证书路径的引擎类。">CertPathValidator类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" title="CertPathValidatorResult接口是认证路径验证算法的成功结果或输出的透明表示。">CertPathValidatorResult接口</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" name="GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A"></a><h5 id="JSSEC-GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" class="sect5">CertPathValidator类</h5>
                     <div>
                        <p>的<code class="codeph">CertPathValidator</code> class是用于验证证书路径的引擎类。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A__GUID-27CA0645-A214-4B3D-BC28-A8ACC5FAE9E0">创建一个CertPathValidator对象</p>
                           <p>与所有引擎类一样，获取<code class="codeph">CertPathValidator</code>特定验证算法的对象是调用<code class="codeph">getInstance</code>静态工厂方法<code class="codeph">CertPathValidator</code>类：</p><pre class="codeblock"><code>
        public static CertPathValidator getInstance(String algorithm)
        public static CertPathValidator getInstance(String algorithm, 
                                                    String provider)
        public static CertPathValidator getInstance(String algorithm, 
                                                    Provider provider)
</code></pre><p>的<code class="codeph">algorithm</code>参数是认证路径验证算法的名称（例如，“ PKIX”）。标准<code class="codeph">CertPathValidator</code> <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>中列出了<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">算法名称</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A__GUID-A17E6CF4-1AB1-4AAE-AD14-2DC65C3600E7">验证认证路径</p>
                           <p>一旦<code class="codeph">CertPathValidator</code>对象创建完成后，可以通过调用<code class="codeph">validate</code>方法，向其传递要验证的认证路径和一组特定于算法的参数：</p><pre class="codeblock"><code>
        public final CertPathValidatorResult 
                validate(CertPath certPath, CertPathParameters params)
                throws CertPathValidatorException, 
                       InvalidAlgorithmParameterException
</code></pre><p>如果验证算法成功，则将结果返回到实现<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" title="The CertPathValidatorResult interface is a transparent representation of the successful result or output of a certification path validation algorithm.">CertPathValidatorResult</a></code>接口。否则， <code class="codeph">CertPathValidatorException</code>被抛出。的<code class="codeph">CertPathValidatorException</code>包含返回<code class="codeph">CertPath</code> ，如果有的话，还包括导致算法失败的证书索引以及根本异常或失败原因。
                           </p>
                           <p>请注意<code class="codeph">CertPath</code>和<code class="codeph">CertPathParameters</code>传递给<code class="codeph">validate</code>方法必须是验证算法支持的类型。否则， <code class="codeph">InvalidAlgorithmParameterException</code>被抛出。例如，一个<code class="codeph">CertPathValidator</code>实现PKIX算法的实例进行验证<code class="codeph">CertPath</code> X.509类型的对象和<code class="codeph">CertPathParameters</code>那是...的一个实例<code class="codeph">PKIXParameters</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" name="GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915"></a><h5 id="JSSEC-GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" class="sect5">CertPathValidatorResult接口</h5>
                     <div>
                        <p>的<code class="codeph">CertPathValidatorResult</code>接口是认证路径验证算法的成功结果或输出的透明表示。
                        </p>
                        <p>该接口的主要目的是为所有验证结果分组并提供类型安全。类似于<code class="codeph">CertPathParameters</code>接口， <code class="codeph">CertPathValidatorResult</code>延伸<code class="codeph">Cloneable</code>并定义一个<code class="codeph">clone()</code>不会引发异常的方法。这允许应用程序克隆任何<code class="codeph">CertPathValidatorResult</code>宾语。
                        </p>
                        <p>实现对象的对象<code class="codeph">CertPathValidatorResult</code>接口由返回<code class="codeph">validate</code>的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" title="The CertPathValidatorResult interface is a transparent representation of the successful result or output of a certification path validation algorithm.">CertPathValidatorResult</a></code>界面成功时。如果未成功，则<code class="codeph">CertPathValidatorException</code>并附有故障描述。通常情况下， <code class="codeph">CertPathValidatorResult</code>接口将保存一组特定于特定认证路径验证算法的输出参数。例如， <code class="codeph">PKIXCertPathValidatorResult</code>类是<code class="codeph">CertPathValidatorResult</code>接口，其中包含获取PKIX认证路径验证算法的输出参数的方法。这样的参数之一就是有效的策略树。在讨论以下内容的部分中，将更详细地讨论此参数： <code class="codeph"><a href="java-pki-programmers-guide.html#GUID-DF6CA960-B37A-4EE1-9E43-76561F711A7D" title="The PKIXCertPathValidatorResult class represents the result of the PKIX certification path validation algorithm.">PKIXCertPathValidatorResult</a></code>类。
                        </p>
                        <p>以下代码示例显示了如何创建一个<code class="codeph">CertPathValidator</code>并使用它来验证认证路径。该示例假设<code class="codeph">CertPath</code>和<code class="codeph">CertPathParameters</code>传递给<code class="codeph">validate</code>方法先前已创建；在描述PKIX类的部分中将说明一个更完整的示例。
                        </p><pre class="codeblock"><code>
    // create CertPathValidator that implements the "PKIX" algorithm
    CertPathValidator cpv = null;
    try {
        cpv = CertPathValidator.getInstance("PKIX");
    } catch (NoSuchAlgorithmException nsae) {
        System.err.println(nsae);
        System.exit(1);
    }
    // validate certification path ("cp") with specified parameters ("params")
    try {
        CertPathValidatorResult cpvResult = cpv.validate(cp, params);
    } catch (InvalidAlgorithmParameterException iape) {
        System.err.println("validation failed: " + iape);
        System.exit(1);
    } catch (CertPathValidatorException cpve) {
        System.err.println("validation failed: " + cpve);
        System.err.println("index of certificate that caused exception: "
                + cpve.getIndex());
        System.exit(1);
    }
</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20" name="GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20"></a><h4 id="JSSEC-GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20" class="sect4">认证路径构建类</h4>
                  <div>
                     <p>Java认证路径API包括用于构建（或发现）认证路径的类。应用程序使用<code class="codeph">CertPathBuilder</code>类来建立一个<code class="codeph">CertPath</code>宾语。如果成功，则将生成的结果返回到实现<code class="codeph">CertPathBuilderResult</code>接口。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-CBABC770-E714-4E6C-AD40-EA680BE91C20__GUID-806EEAC8-58FB-41CC-821E-26974A1FB799">话题</p>
                        <p><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="CertPathBuilder类是用于构建认证路径的引擎类。">CertPathBuilder类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919" title="CertPathBuilderResult接口是认证路径生成器算法的结果或输出的透明表示。">CertPathBuilderResult接口</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" name="GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95"></a><h5 id="JSSEC-GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" class="sect5">CertPathBuilder类</h5>
                     <div>
                        <p>的<code class="codeph">CertPathBuilder</code> class是用于构建认证路径的引擎类。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95__GUID-1519C504-4BC9-416A-BF8A-9C08128F4237">创建一个CertPathBuilder对象</p>
                           <p>与所有引擎类一样，获取<code class="codeph">CertPathBuilder</code>特定构建算法的对象是调用<code class="codeph">getInstance</code>静态工厂方法<code class="codeph">CertPathBuilder</code>类：</p><pre class="codeblock"><code>
        public static CertPathBuilder getInstance(String algorithm)
        public static CertPathBuilder getInstance(String algorithm, 
                                                  String provider)
        public static CertPathBuilder getInstance(String algorithm, 
                                                  Provider provider)
</code></pre><p>的<code class="codeph">algorithm</code>参数是认证路径生成器算法的名称（例如，“ PKIX”）。标准<code class="codeph">CertPathBuilder</code> <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>中列出了<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">算法名称</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95__GUID-C97C89AC-BCE4-431B-B4D3-8B747411D6D9">建立认证途径</p>
                           <p>一旦<code class="codeph">CertPathBuilder</code>创建对象后，可以通过调用<code class="codeph">build</code>方法，向其传递特定于算法的参数规范：</p><pre class="codeblock"><code>
        public final CertPathBuilderResult build(CertPathParameters params)
                throws CertPathBuilderException, 
                       InvalidAlgorithmParameterException
</code></pre><p>如果构建算法成功，则将结果返回到实现<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919" title="The CertPathBuilderResult interface is a transparent representation of the result or output of a certification path builder algorithm.">CertPathBuilderResult</a></code>接口。否则， <code class="codeph">CertPathBuilderException</code>引发包含有关失败的信息；例如，基础异常（如果有）和错误消息。
                           </p>
                           <p>请注意<code class="codeph">CertPathParameters</code>传递给<code class="codeph">build</code>方法必须是构建算法支持的类型。否则， <code class="codeph">InvalidAlgorithmParameterException</code>被抛出。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919" name="GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919"></a><h5 id="JSSEC-GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919" class="sect5">CertPathBuilderResult接口</h5>
                     <div>
                        <p>的<code class="codeph">CertPathBuilderResult</code>接口是认证路径构建器算法的结果或输出的透明表示。
                        </p>
                        <p>此接口包含一种用于返回已成功构建的认证路径的方法：</p><pre class="codeblock"><code>
        public CertPath getCertPath()
</code></pre><p>目的<code class="codeph">CertPathBuilderResult</code>界面将对所有构建结果进行分组（并提供类型安全性）。如<code class="codeph">CertPathValidatorResult</code>接口， <code class="codeph">CertPathBuilderResult</code>延伸<code class="codeph">Cloneable</code>并定义一个<code class="codeph">clone()</code>不会引发异常的方法。这允许应用程序克隆任何<code class="codeph">CertPathBuilderResult</code>宾语。
                        </p>
                        <p>实现对象的对象<code class="codeph">CertPathBuilderResult</code>接口由返回<code class="codeph">build</code>的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code> 。
                        </p>
                        <p>以下代码示例显示了如何创建一个<code class="codeph">CertPathBuilder</code>并使用它来建立认证路径。该示例假设<code class="codeph">CertPathParameters</code>传递给<code class="codeph">build</code>方法先前已创建；在描述PKIX类的部分中将说明一个更完整的示例。
                        </p><pre class="codeblock"><code>
    // create CertPathBuilder that implements the "PKIX" algorithm
    CertPathBuilder cpb = null;
    try {
        cpb = CertPathBuilder.getInstance("PKIX");
    } catch (NoSuchAlgorithmException nsae) {
        System.err.println(nsae);
        System.exit(1);
    }
    // build certification path using specified parameters ("params")
    try {
        CertPathBuilderResult cpbResult = cpb.build(params);
        CertPath cp = cpbResult.getCertPath();
        System.out.println("build passed, path contents: " + cp);
    } catch (InvalidAlgorithmParameterException iape) {
        System.err.println("build failed: " + iape);
        System.exit(1);
    } catch (CertPathBuilderException cpbe) {
        System.err.println("build failed: " + cpbe);
        System.exit(1);
    }
</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" name="GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E"></a><h4 id="JSSEC-GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" class="sect4">证书/ CRL存储类别</h4>
                  <div>
                     <p>Java认证路径API包括<code class="codeph">CertStore</code>用于从存储库中检索证书和CRL的类。
                     </p>
                     <p>此类使调用者可以指定存储库<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实现应使用查找证书和CRL。见<code class="codeph">addCertStores</code>的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">PKIXParameters</a></code>类。
                     </p>
                     <p>一种<code class="codeph">CertPathValidator</code>实现可以使用<code class="codeph">CertStore</code>调用者指定作为回调机制的对象，以提取CRL以执行吊销检查。同样， <code class="codeph">CertPathBuilder</code>可以使用<code class="codeph">CertStore</code>作为一种获取证书以及（如果执行吊销检查）CRL的回调机制。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E__GUID-806EEAC8-58FB-41CC-821E-26974A1FB799">话题</p>
                        <p><a href="java-pki-programmers-guide.html#GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" title="CertStore类是引擎类，用于提供证书和证书吊销列表（CRL）存储库的功能。">CertStore类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-BC87018F-F888-4905-8ED4-AE574C646AF2" title="CertStoreParameters接口是与特定CertStore一起使用的一组参数的透明表示。">CertStoreParameters接口</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5" title="CertSelector和CRLSelector接口是用于从一组证书或CRL的大集合中选择证书和CRL的一组标准的规范。">CertSelector和CRLSelector接口</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" name="GUID-5404B79C-3D49-4668-974C-1BACD1A98B73"></a><h5 id="JSSEC-GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" class="sect5">CertStore类</h5>
                     <div>
                        <p>的<code class="codeph">CertStore</code> class是一个引擎类，用于提供证书和证书吊销列表（CRL）存储库的功能。
                        </p>
                        <p>该类可由<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code>和<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code>查找证书和CRL的实现，或者用作通用证书和CRL检索机制。
                        </p>
                        <p>不像<code class="codeph">java.security.KeyStore</code>类，用于访问私钥和可信证书的缓存， <code class="codeph">CertStore</code>旨在提供对可能不受信任的证书和CRL的巨大存储库的访问。例如，LDAP实现<code class="codeph">CertStore</code>使用LDAP协议提供对存储在一个或多个目录中的证书和CRL的访问。
                        </p>
                        <p>的所有公共方法<code class="codeph">CertStore</code>对象是线程安全的。也就是说，多个线程可以在单个线程上同时调用这些方法。 <code class="codeph">CertStore</code>没有不良影响的对象（或多个）。这允许<code class="codeph">CertPathBuilder</code>例如，在搜索CRL的同时搜索其他证书。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-5404B79C-3D49-4668-974C-1BACD1A98B73__GUID-C211FACD-9ACD-4AD0-8E3C-B2E7FC67B88C">创建一个CertStore对象</p>
                           <p>与所有引擎类一样，获取<code class="codeph">CertStore</code>特定存储库类型的对象是调用<code class="codeph">getInstance</code>静态工厂方法<code class="codeph">CertStore</code>类：</p><pre class="codeblock"><code>
        public static CertStore getInstance(String type, 
                CertStoreParameters params)
        public static CertStore getInstance(String type,
                CertStoreParameters params, String provider)
        public static CertStore getInstance(String type,
                CertStoreParameters params, Provider provider)
</code></pre><p>的<code class="codeph">type</code>参数是证书存储库类型的名称（例如，“ LDAP”）。标准<code class="codeph">CertStore</code> <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a>中列出了这些类型。
                           </p>
                           <p>初始化参数（ <code class="codeph">params</code> ）特定于存储库类型。例如，基于服务器的存储库的初始化参数可以包括服务器的主机名和端口。一个<code class="codeph">InvalidAlgorithmParameterException</code>如果参数对此无效，则引发<code class="codeph">CertStore</code>类型。的<code class="codeph">getCertStoreParameters</code>方法返回<code class="codeph">CertStoreParameters</code>用于初始化一个<code class="codeph">CertStore</code> ：</p><pre class="codeblock"><code>
        public final CertStoreParameters getCertStoreParameters()
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5404B79C-3D49-4668-974C-1BACD1A98B73__GUID-A8D1C62A-3A77-43DD-B3A2-4D372A6E4798">取得证书</p>
                           <p>创建完之后<code class="codeph">CertStore</code>对象，您可以使用<code class="codeph">getCertificates</code>方法。此方法需要<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5" title="The CertSelector and CRLSelector interfaces are a specification of the set of criteria for selecting certificates and CRLs from a collection or large group of certificates and CRLs.">CertSelector</a></code> （稍后将详细讨论）object作为参数，它指定一组选择标准来确定应返回哪些证书：</p><pre class="codeblock"><code>
        public final Collection&lt;? extends Certificate&gt; getCertificates(CertSelector selector) 
                throws CertStoreException
</code></pre><p>此方法返回一个<code class="codeph">Collection</code>的<code class="codeph">java.security.cert.Certificate</code>满足选择条件的对象。一个空的<code class="codeph">Collection</code>如果没有匹配项，则返回。一种<code class="codeph">CertStoreException</code>如果遇到意外错误情况（例如与远程存储库的通信失败），通常会抛出该错误。
                           </p>
                           <p>对于一些<code class="codeph">CertStore</code>实施中，在整个存储库中搜索与指定选择标准匹配的证书或CRL可能不可行。在这些情况下， <code class="codeph">CertStore</code>实现可能会使用选择器中指定的信息来查找证书和CRL。例如，一个LDAP <code class="codeph">CertStore</code>可能不会搜索目录中的所有条目。相反，它可能只搜索可能包含其要查找的证书的条目。如果<code class="codeph">CertSelector</code>提供的信息不能为LDAP提供足够的信息<code class="codeph">CertStore</code>确定应该查看的条目，LDAP <code class="codeph">CertStore</code>可能会抛出一个<code class="codeph">CertStoreException</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5404B79C-3D49-4668-974C-1BACD1A98B73__GUID-A8FCE40F-E416-4BDE-AD65-E9E891402E1A">检索CRL</p>
                           <p>您还可以使用以下方法从资源库中检索CRL： <code class="codeph">getCRLs</code>方法。此方法需要<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5" title="The CertSelector and CRLSelector interfaces are a specification of the set of criteria for selecting certificates and CRLs from a collection or large group of certificates and CRLs.">CRLSelector</a></code> （稍后将详细讨论）对象作为参数，它指定一组选择标准来确定应返回哪些CRL：</p><pre class="codeblock"><code>
        public final Collection&lt;? extends CRL&gt; getCRLs(CRLSelector selector) 
                throws CertStoreException
</code></pre><p>此方法返回一个<code class="codeph">Collection</code>的<code class="codeph">java.security.cert.CRL</code>满足选择条件的对象。一个空的<code class="codeph">Collection</code>如果没有匹配项，则返回。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2" name="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2"></a><h5 id="JSSEC-GUID-BC87018F-F888-4905-8ED4-AE574C646AF2" class="sect5">CertStoreParameters接口</h5>
                     <div>
                        <p>的<code class="codeph">CertStoreParameters</code>接口是特定参数使用的一组参数的透明表示<code class="codeph">CertStore</code> 。
                        </p>
                        <p>该接口的主要目的是为所有证书存储参数规范分组并提供类型安全性。的<code class="codeph">CertStoreParameters</code>接口扩展了<code class="codeph">Cloneable</code>接口并定义一个<code class="codeph">clone</code>不会引发异常的方法。此接口的实现应实现并覆盖<code class="codeph">Object.clone()</code>方法，如有必要。这允许应用程序克隆任何<code class="codeph">CertStoreParameters</code>宾语。
                        </p>
                        <p>实现对象的对象<code class="codeph">CertStoreParameters</code>接口作为参数传递给<code class="codeph">getInstance</code>的方法<code class="codeph">CertStore</code>类。两个类实现了<code class="codeph">CertStoreParameters</code>接口在此API中定义： <code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__THELDAPCERTSTOREPARAMETERSCLASS-C0996E42">LDAPCertStoreParameters</a></code>类和<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__THECOLLECTIONCERTSTOREPARAMETERSCLA-C09970DC">CollectionCertStoreParameters</a></code>类。
                        </p>
                        <div class="section" id="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__THELDAPCERTSTOREPARAMETERSCLASS-C0996E42">
                           <p class="subhead3" id="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__GUID-351BA55F-BC4D-4749-BFDD-D80BF79D75BD">LDAPCertStoreParameters类</p>
                           <p>的<code class="codeph">LDAPCertStoreParameters</code>类是<code class="codeph">CertStoreParameters</code>接口，并拥有一组最小的初始化参数（目录服务器的主机和端口号），用于从目录中检索证书和CRL。 <code class="codeph">CertStore</code>类型为<span class="bold">LDAP</span> 。</p>
                           <p>看到<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/LDAPCertStoreParameters.html" target="_blank"><code class="codeph">LDAPCertStoreParameters</code></a></code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__THECOLLECTIONCERTSTOREPARAMETERSCLA-C09970DC">
                           <p class="subhead3" id="GUID-BC87018F-F888-4905-8ED4-AE574C646AF2__GUID-E855C97C-438F-422A-8CCB-BA2E65E8711B">CollectionCertStoreParameters类</p>
                           <p>的<code class="codeph">CollectionCertStoreParameters</code>类是<code class="codeph">CertStoreParameters</code>接口，并拥有一组初始化参数，用于从服务器检索证书和CRL。 <code class="codeph">CertStore</code>的类型为<span class="bold">Collection</span> 。
                           </p>
                           <p>看到<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CollectionCertStoreParameters.html" target="_blank"><code class="codeph">CollectionCertStoreParameters</code></a></code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5" name="GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5"></a><h5 id="JSSEC-GUID-263AAFB6-DC37-4B64-95E7-60D59D7728B5" class="sect5">CertSelector和CRLSelector接口</h5>
                     <div>
                        <p>的<code class="codeph">CertSelector</code>和<code class="codeph">CRLSelector</code>接口是用于从一组证书和CRL或一大组证书和CRL中选择证书和CRL的一组标准的规范。
                        </p>
                        <p>接口对所有选择器规格进行分组并提供类型安全性。每个选择器接口都扩展<code class="codeph">Cloneable</code>并定义一个<code class="codeph">clone()</code>不会引发异常的方法。这允许应用程序克隆任何<code class="codeph">CertSelector</code>要么<code class="codeph">CRLSelector</code>宾语。
                        </p>
                        <p>的<code class="codeph">CertSelector</code>和<code class="codeph">CRLSelector</code>每个接口定义一个名为<code class="codeph">match</code> 。的<code class="codeph">match</code>方法需要<code class="codeph">Certificate</code>要么<code class="codeph">CRL</code>对象作为参数并返回<code class="codeph">true</code>如果对象满足选择标准。否则返回<code class="codeph">false</code> 。的<code class="codeph">match</code>方法<code class="codeph">CertSelector</code>接口定义如下：</p><pre class="codeblock"><code>
        public boolean match(Certificate cert)
</code></pre><p>而对于<code class="codeph">CRLSelector</code>接口：</p><pre class="codeblock"><code>
        public boolean match(CRL crl)
</code></pre><p>通常，实现这些接口的对象会作为参数传递给<code class="codeph">getCertificates</code>和<code class="codeph">getCRLs</code>的方法<code class="codeph">CertStore</code>类。这些方法返回一个<code class="codeph">Collection</code>的<code class="codeph">Certificate</code> s或<code class="codeph">CRL</code>来自的<code class="codeph">CertStore</code>符合指定选择标准的存储库。 <code class="codeph">CertSelector</code>还可用于指定证书路径中目标或最终实体证书的验证约束（例如，参见<code class="codeph">PKIXParameters.setTargetCertConstraints</code>方法。）
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E" name="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E"></a><h6 id="JSSEC-GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E" class="sect6">X509CertSelector类别</h6>
                        <div>
                           <p>的<code class="codeph">X509CertSelector</code>类是<code class="codeph">CertSelector</code>该接口定义了一组用于选择X.509证书的条件。
                           </p>
                           <p>一个<code class="codeph">X509Certificate</code>对象必须匹配<span class="variable" translate="no">all</span>要由被选择的指定的标准<code class="codeph">match</code>方法。选择标准旨在供<code class="codeph">CertPathBuilder</code>在构建X.509认证路径时发现潜在证书的实现。
                           </p>
                           <p>例如， <code class="codeph">setSubject</code>的方法<code class="codeph">X509CertSelector</code>允许PKIX <code class="codeph">CertPathBuilder</code>过滤掉<code class="codeph">X509Certificate</code>与前面的发行者名称不匹配的<code class="codeph">X509Certificate</code>在部分完成的链中。通过在<code class="codeph">X509CertSelector</code>对象，一个<code class="codeph">CertPathBuilder</code>能够丢弃不相关的证书，并且更容易找到满足以下要求的X.509认证路径： <code class="codeph">CertPathParameters</code>宾语。
                           </p>
                           <p>有关本节中提到的X.509证书扩展的定义，请参阅<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280</a> 。
                           </p>
                           <div class="section">
                              <p class="subhead3" id="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E__GUID-E64B3E57-8DA6-4450-B6B6-639AFF56B3B8">创建一个X509CertSelector对象</p>
                              <p>一个<code class="codeph">X509CertSelector</code>通过调用默认构造函数创建对象：</p><pre class="codeblock"><code>
        public X509CertSelector()
</code></pre><p>最初未设置任何标准（任何<code class="codeph">X509Certificate</code>将匹配）。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E__GUID-7F22A883-F6A9-448E-8C0E-F19D51B526D4">设定选择标准</p>
                              <p>选择标准允许呼叫者在X.509证书的不同组件上进行匹配。此处介绍了几种设置选择标准的方法。看到<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/X509CertSelector.html" target="_blank"><code class="codeph">X509CertSelector</code></a></code> 。
                              </p>
                              <p>的<code class="codeph">setIssuer</code>方法设置发行者标准：</p><pre class="codeblock"><code>
        public void setIssuer(X500Principal issuer)
        public void setIssuer(String issuerDN)
        public void setIssuer(byte[] issuerDN)
</code></pre><p>指定的专有名称（以<code class="codeph">X500Principal</code> ， <a href="http://www.ietf.org/rfc/rfc2253.txt" target="_blank">RFC 2253</a>字符串或ASN.1 DER编码形式）必须与证书中的颁发者专有名称匹配。如果为null，则将使用任何发行者专有名称。请注意，使用<code class="codeph">X500Principal</code>最好使用表示可分辨名称，因为它更有效且类型合适。
                              </p>
                              <p>同样， <code class="codeph">setSubject</code>方法设置主题标准：</p><pre class="codeblock"><code>
        public void setSubject(X500Principal subject)
        public void setSubject(String subjectDN)
        public void setSubject(byte[] subjectDN)
</code></pre><p>指定的专有名称（以<code class="codeph">X500Principal</code> ，RFC 2253字符串或ASN.1 DER编码形式）必须与证书中的主题专有名称匹配。如果为null，则将使用任何主题专有名称。
                              </p>
                              <p>的<code class="codeph">setSerialNumber</code>方法设置serialNumber标准：</p><pre class="codeblock"><code>
        public void setSerialNumber(BigInteger serial)
</code></pre><p>指定的序列号必须与证书中的证书序列号匹配。如果为null，则将使用任何证书序列号。</p>
                              <p>的<code class="codeph">setAuthorityKeyIdentifier</code>方法设置AuthorityKeyIdentifier标准：</p><pre class="codeblock"><code>
        public void setAuthorityKeyIdentifier(byte[] authorityKeyID)
</code></pre><p>证书必须包含与指定值匹配的授权密钥标识符扩展。如果为null，则不会对AuthorityKeyIdentifier条件进行检查。</p>
                              <p>的<code class="codeph">setCertificateValid</code>方法设置certificateValid标准：</p><pre class="codeblock"><code>
        public void setCertificateValid(Date certValid)
</code></pre><p>指定的日期必须在证书的证书有效期内。如果为null，则任何日期均有效。</p>
                              <p>的<code class="codeph">setKeyUsage</code>方法设置keyUsage准则：</p><pre class="codeblock"><code>
        public void setKeyUsage(boolean[] keyUsage)
</code></pre><p>证书的“密钥用法扩展”必须允许指定的密钥用法值（设置为true的值）。如果为null，则不会进行keyUsage检查。</p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E__GUID-E860C3B1-5680-44C6-AA72-B3D7D3CE029A">获取选择标准</p>
                              <p>每个选择标准的当前值都可以使用适当的方法来检索<code class="codeph">get</code>方法。看到<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/X509CertSelector.html" target="_blank"><code class="codeph">X509CertSelector</code></a></code> 。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-2229C26E-1196-4E4F-8F23-731CE5CA254E__GUID-222FD599-5D26-4181-B9F5-C319EDD5BBC7">
                              <p>这是从LDAP检索X.509证书的示例<code class="codeph">CertStore</code>与<code class="codeph">X509CertSelector</code>类。
                              </p>
                              <p>首先，我们创建<code class="codeph">LDAPCertStoreParameters</code>我们将用来初始化对象的对象<code class="codeph">CertStore</code> LDAP服务器的主机名和端口的对象：</p><pre class="codeblock"><code>
        LDAPCertStoreParameters lcsp = new 
                LDAPCertStoreParameters("ldap.sun.com", 389);
</code></pre><p>接下来，创建<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" title="The CertStore class is an engine class used to provide the functionality of a certificate and certificate revocation list (CRL) repository.">CertStore</a></code>对象，并将其传递给<code class="codeph">LDAPCertStoreParameters</code>对象，如以下语句所示：</p><pre class="codeblock"><code>
        CertStore cs = CertStore.getInstance("LDAP", lcsp);
</code></pre><p>此调用会创建一个<code class="codeph">CertStore</code>使用RFC 2587中定义的架构从LDAP存储库检索证书和CRL的对象。
                              </p>
                              <p>以下代码块建立了一个<code class="codeph">X509CertSelector</code>检索颁发给特定主题的所有未过期（截至当前日期和时间）的最终实体证书，其中包括：1）允许数字签名的密钥用法，以及2）具有特定电子邮件地址的主题备用名称：</p><pre class="codeblock"><code>
        X509CertSelector xcs = new X509CertSelector();

        // select only unexpired certificates
        xcs.setCertificateValid(new Date());

        // select only certificates issued to
        // 'CN=alice, O=xyz, C=us'
        xcs.setSubject(new X500Principal("CN=alice, O=xyz, C=us"));

        // select only end-entity certificates
        xcs.setBasicConstraints(-2);

        // select only certificates with a digitalSignature
        // keyUsage bit set (set the first entry in the
        // boolean array to true)
        boolean[] keyUsage = {true};
        xcs.setKeyUsage(keyUsage);

        // select only certificates with a subjectAltName of
        // 'alice@xyz.example.com' (1 is the integer value of 
        // an RFC822Name)
        xcs.addSubjectAlternativeName(1, "alice@xyz.example.com");
</code></pre><p>然后我们将选择器传递给<code class="codeph">getCertificates</code>我们的方法<code class="codeph">CertStore</code>我们先前创建的对象：</p><pre class="codeblock"><code>
        Collection&lt;Certificate&gt; certs = cs.getCertificates(xcs);
</code></pre><p>PKIX <code class="codeph">CertPathBuilder</code>可能会使用类似的代码，通过丢弃不符合验证约束或其他条件的证书来帮助发现和分类潜在证书。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8" name="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8"></a><h6 id="JSSEC-GUID-08C0B832-6934-4A28-8932-8CEB87259BA8" class="sect6">X509CRLSelector类别</h6>
                        <div>
                           <p>的<code class="codeph">X509CRLSelector</code>类是<code class="codeph">CRLSelector</code>定义用于选择X.509 CRL的一组标准的接口。
                           </p>
                           <p>一个<code class="codeph">X509CRL</code>对象必须匹配<span class="variable" translate="no">all</span>要由被选择的指定的标准<code class="codeph">match</code>方法。选择标准旨在对<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>必须从存储库中检索CRL以检查X.509认证路径中证书的吊销状态的实现。
                           </p>
                           <p>例如， <code class="codeph">setDateAndTime</code>的方法<code class="codeph">X509CRLSelector</code>允许PKIX <code class="codeph">CertPathValidator</code>过滤掉<code class="codeph">X509CRL</code>在指定时间之后或之前已发出的。通过在<code class="codeph">X509CRLSelector</code>对象，它允许<code class="codeph">CertPathValidator</code>丢弃无关的CRL，更容易检查证书是否已被撤销。
                           </p>
                           <p>请参考<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280</a> ，以获得本节中提到的X.509 CRL字段和扩展的定义。
                           </p>
                           <div class="section">
                              <p class="subhead3" id="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8__GUID-17F00CC6-3326-4342-9F9E-5243CA658856">创建一个X509CRLSelector对象</p>
                              <p>一个<code class="codeph">X509CRLSelector</code>通过调用默认构造函数创建对象：</p><pre class="codeblock"><code>
        public X509CRLSelector()
</code></pre><p>最初未设置任何标准（任何<code class="codeph">X509CRL</code>将匹配）。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8__GUID-6ECBA50A-535C-4A0E-8518-7A0818EA89A6">设定选择标准</p>
                              <p>选择标准允许呼叫者在X.509 CRL的不同组件上进行匹配。此处介绍了大多数设置选择标准的方法。请参考<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/X509CRLSelector.html" target="_blank"><code class="codeph">X509CRLSelector Class</code></a></code> API文档中有关其余方法的详细信息。
                              </p>
                              <p>的<code class="codeph">setIssuers</code>和<code class="codeph">setIssuerNames</code>方法设置issuerNames标准：</p><pre class="codeblock"><code>
        public void setIssuers(Collection&lt;X500Principal&gt; issuers)
        public void setIssuerNames(Collection&lt;?&gt; names)
</code></pre><p>CRL中的发行者专有名称必须至少与指定的专有名称之一匹配。的<code class="codeph">setIssuers</code>方法是首选，因为使用<code class="codeph">X500Principal</code>代表专有名称的s更加有效并且可以正确键入。为了<code class="codeph">setIssuerNames</code>方法， <code class="codeph">names</code>参数是<code class="codeph">String</code>或字节数组（分别以RFC 2253或ASN.1 DER编码形式表示名称）。如果为null，则将使用任何发行者专有名称。
                              </p>
                              <p>的<code class="codeph">setMinCRLNumber</code>和<code class="codeph">setMaxCRLNumber</code>方法设置minCRLNumber和maxCRLNumber标准：</p><pre class="codeblock"><code>
        public void setMinCRLNumber(BigInteger minCRL)
        public void setMaxCRLNumber(BigInteger maxCRL)
</code></pre><p>如果CRL必须具有CRL编号扩展名，且其值大于或等于指定的值， <code class="codeph">setMinCRLNumber</code>会调用方法，并且小于或等于指定值（如果<code class="codeph">setMaxCRLNumber</code>方法被调用。如果传递给这些方法之一的值为null，则不会执行相应的检查。
                              </p>
                              <p>的<code class="codeph">setDateAndTime</code>方法设置dateAndTime条件：</p><pre class="codeblock"><code>
        public void setDateAndTime(Date dateAndTime)
</code></pre><p>指定的日期必须等于或晚于CRL的thisUpdate组件的值，并且早于nextUpdate组件的值。如果为null，将不执行dateAndTime检查。</p>
                              <p>的<code class="codeph">setCertificateChecking</code>方法设置正在检查其吊销状态的证书：</p><pre class="codeblock"><code>
        public void setCertificateChecking(X509Certificate cert)
</code></pre><p>这不是一个标准。相反，它是可选信息，可以帮助<code class="codeph">CertStore</code>查找在检查指定证书的吊销时将相关的CRL。如果指定了null，则不会提供此类可选信息。应用程序在检查特定证书的吊销时应始终调用此方法，因为它可能会提供<code class="codeph">CertStore</code>以及用于查找正确的CRL和过滤掉不相关的CRL的更多信息。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8__GUID-0435DCB0-A5C7-411C-AC6C-7489EBF77489">获取选择标准</p>
                              <p>每个选择标准的当前值都可以使用适当的方法来检索<code class="codeph">get</code>方法。请参考<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/X509CRLSelector.html" target="_blank"><code class="codeph">X509CRLSelector Class</code></a></code> API文档中有关这些方法的更多详细信息。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-08C0B832-6934-4A28-8932-8CEB87259BA8__GUID-D4DD15D1-6345-446B-8B02-0F2C7C1FCBC4">
                              <p>创建一个<code class="codeph">X509CRLSelector</code>从LDAP存储库中检索CRL类似于<code class="codeph">X509CertSelector</code>例。假设我们要检索由特定CA发出且具有最小CRL编号的所有当前（截至当前日期和时间）CRL。首先，我们创建一个<code class="codeph">X509CRLSelector</code>对象并调用适当的方法来设置选择标准：</p><pre class="codeblock"><code>
        X509CRLSelector xcrls = new X509CRLSelector();
        // select CRLs satisfying current date and time
        xcrls.setDateAndTime(new Date());
        // select CRLs issued by 'O=xyz, C=us'
        xcrls.addIssuerName("O=xyz, C=us");
        // select only CRLs with a CRL number at least '2'
        xcrls.setMinCRLNumber(new BigInteger("2"));
</code></pre><p>然后我们将选择器传递给<code class="codeph">getCRLs</code>我们的方法<code class="codeph">CertStore</code>对象（在中创建<code class="codeph">X509CertSelector</code>例）：</p><pre class="codeblock"><code>
        Collection&lt;CRL&gt; crls = cs.getCRLs(xcrls);
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" name="GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5"></a><h4 id="JSSEC-GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" class="sect4">PKIX类别</h4>
                  <div>
                     <p>Java认证路径API包括一组特定于算法的类，这些类经过建模以与PKIX认证路径验证算法一起使用。</p>
                     <p>PKIX认证路径验证算法在<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280</a> ： <cite>Internet X.509公钥基础结构证书和证书吊销列表（CRL）配置文件中定义</cite> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5__GUID-806EEAC8-58FB-41CC-821E-26974A1FB799">话题</p>
                        <p><a href="java-pki-programmers-guide.html#GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9" title="TrustAnchor类代表一个" most-trusted="" c=",=" ="">TrustAnchor类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="PKIXParametersClass类指定由PKIX认证路径验证算法定义的输入参数集。它还包括一些其他有用的参数。">PKIXParameters类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" title="CertPathValidatorResult接口是认证路径验证算法的成功结果或输出的透明表示。">CertPathValidatorResult接口</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-3AD41382-E729-469B-83EE-CB2FE66D71D8" title="PKIX验证算法定义了几个与证书策略处理有关的输出。大多数应用程序将不需要使用这些输出，但是所有实现PKIX验证或构建算法的提供程序都必须支持它们。">PolicyNode接口和PolicyQualifierInfo类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A" title="PKIXBuilderParameters类指定与CertPathBuilder类一起使用的参数集。">PKIXBuilderParameters类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-BF0E3B2B-1DA5-4A95-A8DD-C03C04EA70E7" title="PKIXCertPathBuilderResult类表示PKIX认证路径构造算法的成功结果。">PKIXCertPathBuilderResult类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-D46630F6-939D-4054-A451-3D8206ED4E62" title="PKIXCertPathChecker类允许用户扩展PKIX CertPathValidator或CertPathBuilder实现。这是大多数用户不需要了解的高级功能。但是，任何实现PKIX服务提供商的人都应阅读本节">PKIXCertPathChecker类</a></p>
                        <p><a href="java-pki-programmers-guide.html#GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF" title="使用PKIXCertPathChecker自定义证书路径验证相对简单。">在证书路径验证中使用PKIXCertPathChecker</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9" name="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9"></a><h5 id="JSSEC-GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9" class="sect5">TrustAnchor类</h5>
                     <div>
                        <p>的<code class="codeph">TrustAnchor</code>类表示“最受信任的CA”，用作验证X.509认证路径的信任锚。
                        </p>
                        <p>一种<code class="codeph">TrustAnchor</code>包括CA的公钥，CA的名称以及可以使用此密钥验证的对路径集的任何约束。这些参数可以以受信任的形式指定<code class="codeph">X509Certificate</code>或作为单个参数。
                        </p>
                        <p>所有<code class="codeph">TrustAnchor</code>对象是不可变的并且是线程安全的。也就是说，多个线程可以在单个线程上并发调用此类中定义的方法。 <code class="codeph">TrustAnchor</code>没有不良影响的对象（或多个）。要求<code class="codeph">TrustAnchor</code>对象是不可变的并且是线程安全的，因此可以将它们传递给各种代码，而不必担心协调访问。
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9__GUID-A6811FA1-310C-4285-8B60-CFFE15ADB5EF">
                              <p class="notep1">注意：</p>尽管此类被描述为PKIX类，但它可以与其他X.509认证路径验证算法一起使用。
                           </div>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9__GUID-52EE95E5-E7D5-430B-8FE5-3C638C8A78E8">创建一个TrustAnchor对象</p>
                           <p>实例化一个<code class="codeph">TrustAnchor</code>对象，调用者必须将“最受信任的CA”指定为受信任的<code class="codeph">X509Certificate</code>或公共密钥和专有名称对。调用方还可以选择指定名称约束，该名称约束在初始化期间由验证算法应用于信任锚。请注意，PKIX算法不需要支持信任锚上的名称约束，因此，PKIX <code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>可以选择不支持此参数，而是引发异常。使用以下构造函数之一创建一个<code class="codeph">TrustAnchor</code>宾语：</p><pre class="codeblock"><code>
        public TrustAnchor(X509Certificate trustedCert, 
                byte[] nameConstraints)
        public TrustAnchor(X500Principal caPrincipal, PublicKey pubKey, 
                byte[] nameConstraints)
        public TrustAnchor(String caName, PublicKey pubKey, 
                byte[] nameConstraints)
</code></pre><p>的<code class="codeph">nameConstraints</code>参数被指定为一个字节数组，其中包含NameConstraints扩展名的ASN.1 DER编码。一个<code class="codeph">IllegalArgumentException</code>如果名称约束无法解码（格式不正确），则抛出该异常。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9__GUID-72C9E169-E4D1-41AC-98F0-6846F767D855">获取参数值</p>
                           <p>可以使用相应的get方法来检索每个参数：</p><pre class="codeblock"><code>
        public final X509Certificate getTrustedCert()
        public final X500Principal getCA()
        public final String getCAName()
        public final PublicKey getCAPublicKey()
        public final byte[] getNameConstraints()
</code></pre><div class="infoboxnote" id="GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9__GUID-096C0339-B93D-4C97-8EF4-83EAB4B4F0F0">
                              <p class="notep1">注意：</p>的<code class="codeph">getTrustedCert</code>方法返回<code class="codeph">null</code>如果将信任锚指定为公钥和名称对。同样， <code class="codeph">getCA</code> ， <code class="codeph">getCAName</code>和<code class="codeph">getCAPublicKey</code>方法返回<code class="codeph">null</code>如果信任锚被指定为<code class="codeph">X509Certificate</code> 。
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" name="GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457"></a><h5 id="JSSEC-GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" class="sect5">PKIXParameters类</h5>
                     <div>
                        <p>的<code class="codeph">PKIXParametersClass</code>类指定由PKIX认证路径验证算法定义的一组输入参数。它还包括一些其他有用的参数。
                        </p>
                        <p>此类实现<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-2AF52C1B-8EE2-4D65-9273-F7AC523AB42F" title="The CertPathParameters interface is a transparent representation of the set of parameters used with a particular certification path builder or validation algorithm.">CertPathParameters</a></code>接口。
                        </p>
                        <p>X.509 <code class="codeph">CertPath</code>对象和一个<code class="codeph">PKIXParameters</code>对象作为参数传递给<code class="codeph">validate</code>方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code>实现PKIX算法的实例。的<code class="codeph">CertPathValidator</code>使用这些参数初始化PKIX认证路径验证算法。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457__GUID-82C97FC8-5A66-4760-A86D-A17087AF0688">创建一个PKIXParameters对象</p>
                           <p>实例化一个<code class="codeph">PKIXParameters</code>对象，调用者必须指定PKIX验证算法定义的“最受信任的CA”。可以使用以下两个构造函数之一来指定最受信任的CA：</p><pre class="codeblock"><code>
        public PKIXParameters(Set&lt;TrustAnchor&gt; trustAnchors) 
            throws InvalidAlgorithmParameterException
        public PKIXParameters(KeyStore keystore)
            throws KeyStoreException, InvalidAlgorithmParameterException
</code></pre><p>第一个构造函数允许调用方将最受信任的CA指定为<code class="codeph">Set</code>的<code class="codeph">TrustAnchor</code>对象。另外，调用者可以使用第二个构造函数并指定一个<code class="codeph">KeyStore</code>实例，其中包含受信任的证书条目，每个证书条目将被视为最受信任的CA。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457__GUID-74F7C68B-336C-4582-A787-251B022C3896">设置参数值</p>
                           <p>之后<code class="codeph">PKIXParameters</code>对象已创建，调用者可以设置（或替换当前值）各种参数。这里介绍了几种设置参数的方法。请参考<code class="codeph">PKIXParameters</code> API文档中有关其他方法的详细信息。
                           </p>
                           <p>的<code class="codeph">setInitialPolicies</code>方法设置由PKIX验证算法指定的初始策略标识符。的要素<code class="codeph">Set</code>是对象标识符（OID），表示为<code class="codeph">String</code> 。如果<code class="codeph">initialPolicies</code>参数为null或未设置，可以接受任何策略：</p><pre class="codeblock"><code>
        public void setInitialPolicies(Set&lt;String&gt; initialPolicies)
</code></pre><p>的<code class="codeph">setDate</code>方法设置应确定路径有效性的时间。如果<code class="codeph">date</code>参数未设置或为null，则使用当前日期：</p><pre class="codeblock"><code>
        public void setDate(Date date)
</code></pre><p>的<code class="codeph">setPolicyMappingInhibited</code>方法设置策略映射禁止标志的值。如果未指定，则标志的默认值为false：</p><pre class="codeblock"><code>
        public void setPolicyMappingInhibited(boolean val)
</code></pre><p>的<code class="codeph">setExplicitPolicyRequired</code>方法设置显式策略所需标志的值。如果未指定，则标志的默认值为false：</p><pre class="codeblock"><code>
        public void setExplicitPolicyRequired(boolean val)
</code></pre><p>的<code class="codeph">setAnyPolicyInhibited</code>方法设置任何策略禁止标志的值。如果未指定，则标志的默认值为false：</p><pre class="codeblock"><code>
        public void setAnyPolicyInhibited(boolean val)
</code></pre><p>的<code class="codeph">setTargetCertConstraints</code>方法允许调用者在目标或最终实体证书上设置约束。例如，调用方可以指定目标证书必须包含特定的主题名称。约束指定为<code class="codeph">CertSelector</code>宾语。如果<code class="codeph">selector</code>参数为null或未设置，目标证书上未定义任何约束：</p><pre class="codeblock"><code>
        public void setTargetCertConstraints(CertSelector selector)
</code></pre><p>的<code class="codeph">setCertStores</code>方法允许调用者指定一个<code class="codeph">List</code>的<code class="codeph">CertStore</code>的PKIX实现将使用的对象<code class="codeph">CertPathValidator</code>查找用于路径验证的CRL。这为指定CRL的位置提供了可扩展的机制。的<code class="codeph">setCertStores</code>方法需要<code class="codeph">List</code>的<code class="codeph">CertStore</code>对象作为参数。首先<code class="codeph">CertStore</code>列表中的可能比后面出现的优先。
                           </p><pre class="codeblock"><code>
        public void setCertStores(List&lt;CertStore&gt; stores)
</code></pre><p>的<code class="codeph">setCertPathCheckers</code>该方法允许调用者通过创建特定于实现的认证路径检查器来扩展PKIX验证算法。例如，此机制可用于处理私有证书扩展。的<code class="codeph">setCertPathCheckers</code>方法需要一个列表<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-D46630F6-939D-4054-A451-3D8206ED4E62" title="The PKIXCertPathChecker class allows a user to extend a PKIX CertPathValidator or CertPathBuilder implementation. This is an advanced feature that most users will not need to understand. However, anyone implementing a PKIX service provider should read this section">PKIXCertPathChecker</a></code> （稍后讨论）对象作为参数：</p><pre class="codeblock"><code>
        public void setCertPathCheckers(List&lt;PKIXCertPathChecker&gt; checkers)
</code></pre><p>的<code class="codeph">setRevocationEnabled</code>方法允许调用者禁用吊销检查。默认情况下，吊销检查是启用的，因为它是PKIX验证算法的必需检查。但是，PKIX并未定义应如何检查吊销。例如，实现可以使用CRL或OCSP。如果不合适，此方法允许调用者禁用实现的默认吊销检查机制。然后，可以通过调用以下命令来指定其他撤销检查机制： <code class="codeph">setCertPathCheckers</code>方法，并将其传递给<code class="codeph">PKIXCertPathChecker</code>实现替代机制。
                           </p><pre class="codeblock"><code>
        public void setRevocationEnabled(boolean val)
</code></pre><p>的<code class="codeph">setPolicyQualifiersRejected</code>方法允许调用者启用或禁用策略限定符处理。当一个<code class="codeph">PKIXParameters</code>对象创建后，此标志设置为<code class="codeph">true</code> 。此设置反映了处理策略限定符的最常见（也是最简单）的策略。想要使用更复杂策略的应用程序必须将此标志设置为<code class="codeph">false</code> 。
                           </p><pre class="codeblock"><code>
        public void setPolicyQualifiersRejected(boolean qualifiersRejected)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457__GUID-C41227A2-F4B1-4CBE-84E7-2A530733EA26">获取参数值</p>
                           <p>可以使用适当的参数来检索每个参数的当前值<code class="codeph">get</code>方法。请参考<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXParameters.html" target="_blank"><code class="codeph">Class PKIXParameters</code></a></code> API文档中有关这些方法的更多详细信息。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DF6CA960-B37A-4EE1-9E43-76561F711A7D" name="GUID-DF6CA960-B37A-4EE1-9E43-76561F711A7D"></a><h5 id="JSSEC-GUID-DF6CA960-B37A-4EE1-9E43-76561F711A7D" class="sect5">PKIXCertPathValidatorResult类</h5>
                     <div>
                        <p>的<code class="codeph">PKIXCertPathValidatorResult</code>类表示PKIX认证路径验证算法的结果。
                        </p>
                        <p>此类实现<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-29AC2D33-7518-4DEA-A4CC-544CB174B915" title="The CertPathValidatorResult interface is a transparent representation of the successful result or output of a certification path validation algorithm.">CertPathValidatorResult</a></code>接口。它包含验证算法产生的有效策略树和主题公钥，并包括方法（ <code class="codeph">getPolicyTree()</code>和<code class="codeph">getPublicKey()</code> ）退还给他们。的实例<code class="codeph">PKIXCertPathValidatorResult</code>由返回<code class="codeph">validate</code>的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code>实现PKIX算法的对象。
                        </p>
                        <p>请参考<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXCertPathValidatorResult.html" target="_blank"><code class="codeph">PKIXCertPathValidatorResult</code></a></code> API文档中有关此类的更多详细信息。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3AD41382-E729-469B-83EE-CB2FE66D71D8" name="GUID-3AD41382-E729-469B-83EE-CB2FE66D71D8"></a><h5 id="JSSEC-GUID-3AD41382-E729-469B-83EE-CB2FE66D71D8" class="sect5">PolicyNode接口和PolicyQualifierInfo类</h5>
                     <div>
                        <p>PKIX验证算法定义了几个与证书策略处理有关的输出。大多数应用程序将不需要使用这些输出，但是所有实现PKIX验证或构建算法的提供程序都必须支持它们。</p>
                        <div class="section">
                           <p>的<code class="codeph">PolicyNode</code>接口代表有效执行PKIX认证路径验证所产生的有效策略树的节点。应用程序可以使用以下命令获取有效策略树的根<code class="codeph">getPolicyTree</code>的方法<code class="codeph">PKIXCertPathValidatorResult</code> 。在<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280</a>中将更详细地讨论策略树。
                           </p>
                           <p>的<code class="codeph">getPolicyQualifiers</code>的方法<code class="codeph">PolicyNode</code>返回一个<code class="codeph">Set</code>的<code class="codeph">PolicyQualifierInfo</code>对象，每个对象代表此策略适用的相关证书的“证书策略”扩展中包含的策略限定符。
                           </p>
                           <p>大多数应用程序将不需要检查有效的策略树和策略限定符。他们可以通过在中设置策略相关参数来实现其策略处理目标。 <code class="codeph">PKIXParameters</code> 。但是，有效的策略树可用于更复杂的应用程序，尤其是那些处理策略限定符的应用程序。
                           </p>
                           <p>请参考<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PolicyNode.html" target="_blank"><code class="codeph">Interface PolicyNode</code></a></code>和<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PolicyQualifierInfo.html" target="_blank"><code class="codeph">PolicyQualifierInfo</code></a></code> API文档提供了有关这些类的更多详细信息。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-3AD41382-E729-469B-83EE-CB2FE66D71D8__GUID-C0D7260A-3ACE-449E-A3EE-6C6E42E82B68">
                           <p class="titleinexample">示例10-1使用PKIX算法验证证书路径的示例</p>
                           <p>这是使用PKIX验证算法来验证证书路径的示例。该示例将忽略大多数异常处理，并假定已经创建了信任锚的证明路径和公钥。</p>
                           <p>首先，建立<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path.">CertPathValidator</a></code> ，如以下行所示：</p><pre class="codeblock"><code>
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
</code></pre><p>下一步是创建一个<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-772D31A0-FF9B-4A1E-985B-2100177C74F9" title="The TrustAnchor class represents a "most-trusted CA", which is used as a trust anchor for validating X.509 certification paths.">TrustAnchor</a></code>宾语。这将用作验证认证路径的锚点。在此示例中，最受信任的CA被指定为公钥和名称（名称约束未应用，并且被指定为<code class="codeph">null</code> ）：</p><pre class="codeblock"><code>
    TrustAnchor anchor = new TrustAnchor("O=xyz,C=us", pubkey, null);
</code></pre><p>下一步是创建一个<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">PKIXParameters</a></code>宾语。这将用于填充PKIX算法使用的参数。在这个例子中，我们传递给构造函数a <code class="codeph">Set</code>包含一个元素- <code class="codeph">TrustAnchor</code>我们在上一步中创建的：</p><pre class="codeblock"><code>
    PKIXParameters params = new PKIXParameters(Collections.singleton(anchor));
</code></pre><p>接下来，我们使用约束或验证算法使用的其他参数填充参数对象。在此示例中，我们启用explicitPolicyRequired标志并指定一组初始策略OID（未显示该组的内容）：</p><pre class="codeblock"><code>
    // set other PKIX parameters here
    params.setExplicitPolicyRequired(true);
    params.setInitialPolicies(policyIds);
</code></pre><p>最后一步是使用我们创建的输入参数集来验证认证路径：</p><pre class="codeblock"><code>
    try {
        PKIXCertPathValidatorResult result =
            (PKIXCertPathValidatorResult) cpv.validate(certPath, params);
        PolicyNode policyTree = result.getPolicyTree();
        PublicKey subjectPublicKey = result.getPublicKey();
    } catch (CertPathValidatorException cpve) {
        System.out.println("Validation failure, cert[" 
            + cpve.getIndex() + "] :" + cpve.getMessage());
    }
</code></pre><p>如果验证算法成功，则使用以下命令获得验证算法产生的策略树和主题公钥： <code class="codeph">getPolicyTree</code>和<code class="codeph">getPublicKey</code>方法<code class="codeph">PKIXCertPathValidatorResult</code> 。
                           </p>
                           <p>否则， <code class="codeph">CertPathValidatorException</code>引发，调用者可以捕获异常并打印有关失败的一些详细信息，例如错误消息和导致失败的证书的索引。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A" name="GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A"></a><h5 id="JSSEC-GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A" class="sect5">PKIXBuilderParameters类</h5>
                     <div>
                        <p>的<code class="codeph">PKIXBuilderParameters</code>类指定要与之一起使用的参数集<code class="codeph">CertPathBuilder</code>类。
                        </p>
                        <p>此类（扩展了<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">PKIXParameters</a></code>类）指定要与<a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="CertPathBuilder类是用于构建认证路径的引擎类。">CertPathBuilder</a>类一起使用的参数集，这些参数将构建针对PKIX认证路径验证算法进行了验证的认证路径。
                        </p>
                        <p>一种<code class="codeph">PKIXBuilderParameters</code>对象作为参数传递给<code class="codeph">build</code>方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code>实现PKIX算法的实例。所有PKIX <code class="codeph">CertPathBuilder</code> s <span class="variable" translate="no">must</span>返回已根据PKIX认证路径验证算法进行了验证的认证路径。
                        </p>
                        <p>请注意PKIX的机制<code class="codeph">CertPathBuilder</code>用于验证构造路径的方法是实现细节。例如，一个实现可能会尝试首先使用最小的验证来构建路径，然后使用PKIX的实例对其进行完全验证。 <code class="codeph">CertPathValidator</code> ，而更有效的实现可能会在构建路径时验证更多的路径，如果遇到验证失败或死胡同，则可以回溯到之前的阶段。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A__GUID-9E460F2E-D92C-4928-BE6C-E6EE6DC1949B">创建一个PKIXBuilderParameters对象</p>
                           <p>创建一个<code class="codeph">PKIXBuilderParameters</code>对象类似于创建一个<code class="codeph">PKIXParameters</code>宾语。但是，调用者在创建证书时<span class="variable" translate="no">must</span>在目标或最终实体证书上指定约束<code class="codeph">PKIXBuilderParameters</code>宾语。这些限制应提供<code class="codeph">CertPathBuilder</code>具有足够的信息来找到目标证书。约束指定为<code class="codeph">CertSelector</code>宾语。使用以下构造函数之一创建一个<code class="codeph">PKIXBuilderParameters</code>宾语：</p><pre class="codeblock"><code>
        public PKIXBuilderParameters(Set&lt;TrustAnchor&gt; trustAnchors, 
                CertSelector targetConstraints)
                throws InvalidAlgorithmParameterException
        public PKIXBuilderParameters(KeyStore keystore, 
                CertSelector targetConstraints) 
                throws KeyStoreException, InvalidAlgorithmParameterException
                                                
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A__GUID-071742AD-EC87-46F6-AAAE-A29B4347113B">获取/设置参数值</p>
                           <p>的<code class="codeph">PKIXBuilderParameters</code>类继承了可以在<code class="codeph">PKIXParameters</code>类。除此之外<code class="codeph">setMaxPathLength</code>可以调用方法对证书路径中的最大证书数量进行限制：</p><pre class="codeblock"><code>
        public void setMaxPathLength(int maxPathLength)
</code></pre><p>的<code class="codeph">maxPathLength</code>参数指定证书路径中可能存在的非自行发行的中间证书的最大数量。一种<code class="codeph">CertPathBuilder</code>实现PKIX算法的实例的路径长度不能超过指定的长度。如果值为0，则路径只能包含一个证书。如果值为-1，则路径长度不受限制（即，没有最大值）。如果未指定，则默认最大路径长度为5。此方法有助于防止<code class="codeph">CertPathBuilder</code>从花费资源和时间来构建可能满足或无法满足呼叫者要求的长路径。
                           </p>
                           <p>如果路径中的任何CA证书都包含“基本约束”扩展，则扩展的pathLenConstraint组件的值将覆盖<code class="codeph">maxPathLength</code>只要结果是长度较短的认证路径，就可以使用该参数。还有一个对应的<code class="codeph">getMaxPathLength</code>检索此参数的方法：</p><pre class="codeblock"><code>
        public int getMaxPathLength()
</code></pre><p>另外， <code class="codeph">setCertStores</code>方法（继承自<code class="codeph">PKIXParameters</code>类）通常由的PKIX实现使用<code class="codeph">CertPathBuilder</code>查找用于路径构造的证书以及用于路径验证的CRL。这为指定证书和CRL的位置提供了可扩展的机制。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BF0E3B2B-1DA5-4A95-A8DD-C03C04EA70E7" name="GUID-BF0E3B2B-1DA5-4A95-A8DD-C03C04EA70E7"></a><h5 id="JSSEC-GUID-BF0E3B2B-1DA5-4A95-A8DD-C03C04EA70E7" class="sect5">PKIXCertPathBuilderResult类</h5>
                     <div>
                        <p>的<code class="codeph">PKIXCertPathBuilderResult</code>类表示PKIX认证路径构造算法的成功结果。
                        </p>
                        <p>此类扩展了<code class="codeph">PKIXCertPathValidatorResult</code>类并实现<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-47B1564D-DFC3-4F0F-A006-CB7303EDD919" title="The CertPathBuilderResult interface is a transparent representation of the result or output of a certification path builder algorithm.">CertPathBuilder</a></code>接口。的实例<code class="codeph">PKIXCertPathBuilderResult</code>由返回<code class="codeph">build</code>的方法<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code>实现PKIX算法的对象。
                        </p>
                        <p>的<code class="codeph">getCertPath</code>方法<code class="codeph">PKIXCertPathBuilderResult</code>实例总是返回一个<code class="codeph">CertPath</code>使用PKIX认证路径验证算法验证的对象。返回的<code class="codeph">CertPath</code>对象不包括可能已用于锚定路径的最受信任的CA证书。而是使用<code class="codeph">getTrustAnchor</code>获得方法<code class="codeph">Certificate</code>最受信任的CA。</p>
                        <p>见<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXCertPathBuilderResult.html" target="_blank"><code class="codeph">PKIXCertPathBuilderResult</code></a></code> API文档中有关此类的更多详细信息。
                        </p>
                        <div class="example" id="GUID-BF0E3B2B-1DA5-4A95-A8DD-C03C04EA70E7__GUID-A7BCEA02-89BD-4A73-90B3-B3FA597AB3B3">
                           <p class="titleinexample">示例10-2使用PKIX算法构建认证路径的示例</p>
                           <p>这是构建针对PKIX算法验证的认证路径的示例。遗漏了一些详细信息，例如异常处理，创建用于填充垃圾邮件的信任锚和证书的创建。 <code class="codeph">CertStore</code> 。
                           </p>
                           <p>首先，建立<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path.">CertPathBuilder</a></code> ，如以下示例所示：</p><pre class="codeblock"><code>
    CertPathBuilder cpb = CertPathBuilder.getInstance("PKIX");
</code></pre><p>此调用会创建一个<code class="codeph">CertPathBuilder</code>返回根据PKIX算法验证的路径的对象。
                           </p>
                           <p>下一步是创建一个<code class="codeph"><a href="java-pki-programmers-guide.html#GUID-BB092D65-80CA-457E-A7B4-F1B41A1A674A" title="The PKIXBuilderParameters class specifies the set of parameters to be used with CertPathBuilder class.">PKIXBuilderParameters</a></code>宾语。这将用于填充由<code class="codeph">CertPathBuilder</code> ：</p><pre class="codeblock"><code>
    // Create parameters object, passing it a Set of
    // trust anchors for anchoring the path
    // and a target subject DN.
    X509CertSelector targetConstraints = new X509CertSelector();
    targetConstraints.setSubject("CN=alice,O=xyz,C=us");
    PKIXBuilderParameters params = 
        new PKIXBuilderParameters(trustAnchors, targetConstraints);
</code></pre><p>下一步是指定<code class="codeph">CertStore</code>那<code class="codeph">CertPathBuilder</code>将用于查找证书和CRL。在此示例中，我们将填充一个集合<code class="codeph">CertStore</code>带有证书和CRL：</p><pre class="codeblock"><code>
    CollectionCertStoreParameters ccsp = 
        new CollectionCertStoreParameters(certsAndCrls);
    CertStore store = CertStore.getInstance("Collection", ccsp);
    params.addCertStore(store);
</code></pre><p>下一步是使用我们创建的输入参数集来构建认证路径：</p><pre class="codeblock"><code>
    try {
        PKIXCertPathBuilderResult result = 
            (PKIXCertPathBuilderResult) cpb.build(params);
        CertPath cp = result.getCertPath();
    } catch (CertPathBuilderException cpbe) {
        System.out.println("build failed: " + cpbe.getMessage());
    }
</code></pre><p>如果<code class="codeph">CertPathBuilder</code>无法建立符合所提供参数的路径，它将抛出<code class="codeph">CertPathBuilderException</code> 。否则，可以从<code class="codeph">PKIXCertPathBuilderResult</code>使用<code class="codeph">getCertPath</code>方法。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62" name="GUID-D46630F6-939D-4054-A451-3D8206ED4E62"></a><h5 id="JSSEC-GUID-D46630F6-939D-4054-A451-3D8206ED4E62" class="sect5">PKIXCertPathChecker类</h5>
                     <div>
                        <p>PKIXCertPathChecker类允许用户扩展PKIX <code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实施。这是大多数用户不需要了解的高级功能。但是，任何实现PKIX服务提供商的人都应阅读本节</p>
                        <p>的<code class="codeph">PKIXCertPathChecker</code> class是一个抽象类，它对X.509证书执行一个或多个检查。开发人员应创建<code class="codeph">PKIXCertPathChecker</code>需要动态扩展PKIX时的类<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>在运行时实施。以下是一些<code class="codeph">PKIXCertPathChecker</code>实现很有用：</p>
                        <ul style="list-style-type:disc">
                           <li>     
                              <p>如果撤销机制由PKIX提供<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实施不充分：例如，您可以使用<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXRevocationChecker.html" target="_blank"><code class="codeph">PKIXRevocationChecker</code></a></code> （在JDK 8中引入；请参阅<a href="java-pki-programmers-guide.html#GUID-43A3A247-E165-408C-AD74-88A75BFB4750" title="PKIXRevocationChecker实例使用“在线证书状态协议”（OCSP）或“证书吊销列表”（CRL）检查证书的吊销状态。">使用PKIXRevocationChecker类检查证书的吊销状态</a> ）以更好地控制吊销机制，或者您可以实现自己的吊销机制。 <code class="codeph">PKIXCertPathChecker</code>检查证书是否被吊销。
                              </p> 
                           </li>
                           <li> 
                              <p>用户是否要识别包含关键私人扩展名的证书。由于扩展名是私有的，因此PKIX将无法识别该扩展名<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实施和<code class="codeph">CertPathValidatorException</code>将被抛出。在这种情况下，开发人员可以实施<code class="codeph">PKIXCertPathChecker</code>识别并处理关键的私人分机。
                              </p> 
                           </li>
                           <li> 
                              <p>如果开发人员想要记录有关为调试或显示目的而处理的每个证书的信息。</p> 
                           </li>
                           <li> 
                              <p>如果用户希望使用某些策略限定符拒绝证书。</p> 
                           </li>
                        </ul>
                        <p>的<code class="codeph">setCertPathCheckers</code>的方法<code class="codeph">PKIXParameters</code>类允许用户通过<code class="codeph">List</code>的<code class="codeph">PKIXCertPathChecker</code>反对PKIX <code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实施。每一个<code class="codeph">PKIXCertPathChecker</code>对于PKIX处理的每个证书，将依次调用对象<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实施。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-A080C1B3-DA64-469A-89E5-955129E3322D">创建和使用PKIXCertPathChecker对象</p>
                           <p>的<code class="codeph">PKIXCertPathChecker</code>类没有公共构造函数。这是故意的，因为创建了<code class="codeph">PKIXCertPathChecker</code>是特定于实现的问题。例如， <code class="codeph">PKIXCertPathChecker</code>使用OCSP来检查证书的吊销状态的实施可能需要OCSP服务器的主机名和端口：</p><pre class="codeblock"><code>
        PKIXCertPathChecker checker = new OCSPChecker("ocsp.sun.com", 1321);
</code></pre><p>实例化检查器后，可以使用<code class="codeph">addCertPathChecker</code>的方法<code class="codeph">PKIXParameters</code>类：</p><pre class="codeblock"><code>
        params.addCertPathChecker(checker);
</code></pre><p>或者， <code class="codeph">List</code>可以使用<code class="codeph">setCertPathCheckers</code>的方法<code class="codeph">PKIXParameters</code>类。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-9BBD9439-1598-43E6-BC4D-7C25A44BE16C">实现PKIXCertPathChecker对象</p>
                           <p>的<code class="codeph">PKIXCertPathChecker</code>类是抽象的。它有四种方法（ <code class="codeph">check</code> ， <code class="codeph">getSupportedExtensions</code> ， <code class="codeph">init</code>和<code class="codeph">isForwardCheckingSupported</code> ），所有具体的子类都必须实现。
                           </p>
                           <p>实施<code class="codeph">PKIXCertPathChecker</code>可能是琐碎的或复杂的。一种<code class="codeph">PKIXCertPathChecker</code>实现可以是无状态的，也可以是有状态的。无状态实现不会在两次调用之间保持状态。 <code class="codeph">check</code>方法。例如，一个<code class="codeph">PKIXCertPathChecker</code>用于检查每个证书是否包含特定策略限定符的检查是无状态的。相反，有状态实现的确会在两次调用之间保持状态。 <code class="codeph">check</code>方法。的<code class="codeph">check</code>有状态实现的方法通常取决于证书路径中先前证书的内容。例如，一个<code class="codeph">PKIXCertPathChecker</code>处理NameConstraints扩展的状态是有状态的。
                           </p>
                           <p>同样，将服务提供商实现处理的证书的顺序显示（传递）给<code class="codeph">PKIXCertPathChecker</code>非常重要，尤其是在实现是有状态的情况下。根据服务提供商使用的算法，可以以<span class="variable" translate="no">reverse</span>或<span class="variable" translate="no">forward</span>顺序显示证书。反向排序是指将证书从最受信任的CA（如果存在）向目标主体排序，而正向排序是指将证书从目标受教者向最受信任的CA排序。必须将订单告知<code class="codeph">PKIXCertPathChecker</code>实施，以便它知道如何处理连续的证书。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-FFC1B1A8-E754-4D2F-8175-6DBA80C2150C">初始化PKIXCertPathChecker对象</p>
                           <p>的<code class="codeph">init</code>方法初始化检查器的内部状态：</p><pre class="codeblock"><code>
        public abstract void init(boolean forward)
</code></pre><p>所有有状态的实现应清除或初始化检查器中的任何内部状态。这可以防止服务提供者实现调用处于未初始化状态的检查器。它还允许状态检查器在后续操作中重用，而无需重新实例化它们。的<code class="codeph">forward</code>参数指示提供给证书的证书的顺序<code class="codeph">PKIXCertPathChecker</code> 。如果<code class="codeph">forward</code>是<code class="codeph">true</code> ，将证书从目标提交给信任锚；如果<code class="codeph">false</code> ，从信任锚到目标。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-A847B9BD-CD20-4BEE-9A25-BB8E0BB462A3">前向检查</p>
                           <p>的<code class="codeph">isForwardCheckingSupported</code>方法返回一个<code class="codeph">boolean</code>表示<code class="codeph">PKIXCertPathChecker</code>支持向前检查：</p><pre class="codeblock"><code>
        public abstract boolean isForwardCheckingSupported()
</code></pre><p>所有<code class="codeph">PKIXCertPathChecker</code>实现<span class="variable" translate="no">must</span>支持反向检查。一种<code class="codeph">PKIXCertPathChecker</code>实现<span class="variable" translate="no">may</span>支持向前检查。
                           </p>
                           <p>支持前向检查可以提高效率<code class="codeph">CertPathBuilder</code>向前构建的，因为它允许在构建路径时对其进行检查。但是，有些有状态<code class="codeph">PKIXCertPathChecker</code>可能会发现很难或不可能支持向前检查。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-B8C871A4-BB55-4F51-92EA-50F8E0B1EFF5">支持的扩展</p>
                           <p>的<code class="codeph">getSupportedExtensions</code>方法返回一个不可变的<code class="codeph">Set</code> OID的<code class="codeph">String</code>对于X.509扩展名， <code class="codeph">PKIXCertPathChecker</code>实施支持（即识别，能够处理）：</p><pre class="codeblock"><code>
        public abstract Set&lt;String&gt; getSupportedExtensions()
</code></pre><p>该方法应返回<code class="codeph">null</code>如果未处理任何扩展名。所有实现都应返回<code class="codeph">Set</code> OID的<code class="codeph">String</code>那个<code class="codeph">check</code>方法可能会处理。
                           </p>
                           <p>一种<code class="codeph">CertPathBuilder</code>可以使用此信息来识别具有无法识别的关键扩展名的证书，即使使用<code class="codeph">PKIXCertPathChecker</code>不支持向前检查。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-9104319F-926C-48B0-97DA-F1279C1B9B7B">执行检查</p>
                           <p>以下方法对证书执行检查：</p><pre class="codeblock"><code>
        public abstract void 
                check(Certificate cert, Collection&lt;String&gt; unresolvedCritExts)
                throws CertPathValidatorException
</code></pre><p>的<code class="codeph">unresolvedCritExts</code>参数包含OID的集合，如<code class="codeph">String</code> s。这些OID代表证书中尚未由证书路径验证算法解析的关键扩展集。具体的实现<code class="codeph">check</code>方法应从中删除其处理的所有关键扩展<code class="codeph">unresolvedCritExts</code>参数。
                           </p>
                           <p>如果证书未通过检查，则a <code class="codeph">CertPathValidatorException</code>应该扔。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-AED807F9-739B-4D00-82E0-8DFFFE4735E6">克隆PKIXCertPathChecker</p>
                           <p>的<code class="codeph">PKIXCertPathChecker</code>类实现<code class="codeph">Cloneable</code>接口。全部有状态<code class="codeph">PKIXCertPathChecker</code>实现必须覆盖<code class="codeph">clone</code>必要的方法。的默认实现<code class="codeph">clone</code>方法调用<code class="codeph">Object.clone</code>方法，该方法通过将原始对象的所有字段复制到新对象来执行简单的克隆。无状态实现不应覆盖<code class="codeph">clone</code>方法。但是，所有有状态的实现都必须确保默认<code class="codeph">clone</code>方法是正确的，并在必要时覆盖它。例如，一个<code class="codeph">PKIXCertPathChecker</code>将状态存储在数组中的值必须覆盖<code class="codeph">clone</code>复制数组的方法，而不仅仅是对数组的引用。
                           </p>
                           <p>的原因<code class="codeph">PKIXCertPathChecker</code>对象是<code class="codeph">Cloneable</code>是为了允许PKIX <code class="codeph">CertPathBuilder</code>实施以有效地回溯并在潜在的认证路径到达死胡同或失败点时尝试另一条路径。在这种情况下，该实现能够通过还原克隆的对象来还原先前的路径验证状态。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-44A52013-BF80-49DC-BE95-A0AC981333E7">
                           <p class="titleinexample">示例10-3检查私有扩展的示例代码</p>
                           <p>这是无状态的例子<code class="codeph">PKIXCertPathChecker</code>实施。它检查证书中是否存在私有扩展，并根据一些规则对其进行处理。
                           </p><pre class="codeblock"><code>
        import java.security.cert.Certificate;
        import java.security.cert.X509Certificate;
        import java.util.Collection;
        import java.util.Collections;
        import java.util.Set;
        import java.security.cert.PKIXCertPathChecker;
        import java.security.cert.CertPathValidatorException;

        public class MyChecker extends PKIXCertPathChecker {
            private static Set supportedExtensions =
                Collections.singleton("2.16.840.1.113730.1.1");

            /*
             * Initialize checker
             */
            public void init(boolean forward) 
                throws CertPathValidatorException {
                // nothing to initialize
            }

            public Set getSupportedExtensions() {        
                return supportedExtensions;
            }

            public boolean isForwardCheckingSupported() {
                return true;
            }

            /*
             * Check certificate for presence of Netscape's
             * private extension
             * with OID "2.16.840.1.113730.1.1"
             */
            public void check(Certificate cert, 
                              Collection unresolvedCritExts)
                throws CertPathValidatorException 
            {
                X509Certificate xcert = (X509Certificate) cert;
                byte[] ext = 
                    xcert.getExtensionValue("2.16.840.1.113730.1.1");
                if (ext == null)
                    return;

                //
                // process private extension according to some 
                // rules - if check fails, throw a 
                // CertPathValidatorException ...
                // {insert code here}

                // remove extension from collection of unresolved 
                // extensions (if it exists)
                if (unresolvedCritExts != null)
                    unresolvedCritExts.remove("2.16.840.1.113730.1.1");
            }
        }
</code></pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D46630F6-939D-4054-A451-3D8206ED4E62__GUID-5413E926-46E7-4107-83AB-010F9FFA9F54">PKIX服务提供者实现应如何使用PKIXCertPathChecker</p>
                           <p>每<code class="codeph">PKIXCertPathChecker</code>必须在开始构建或验证算法之前由服务提供者实现初始化对象，例如：</p><pre class="codeblock"><code>
        List&lt;PKIXCertPathChecker&gt; checkers = params.getCertPathCheckers();
        for (PKIXCertPathChecker checker : checkers) {
            checker.init(false);
        }
</code></pre><p>对于其验证的每个证书，服务提供商的实现必须调用<code class="codeph">check</code>每个方法<code class="codeph">PKIXCertPathChecker</code>依次传递对象，证书和所有剩余未解决的关键扩展名：</p><pre class="codeblock"><code>
        for (PKIXCertPathChecker checker : checkers) {
            checker.check(cert, unresolvedCritExts);
        }
</code></pre><p>如果有<code class="codeph">check</code>扔<code class="codeph">CertPathValidatorException</code> ， 一种<code class="codeph">CertPathValidator</code>实施应终止验证程序。但是， <code class="codeph">CertPathBuilder</code>实施可能会简单地记录故障并继续寻找其他可能的路径。如果所有<code class="codeph">check</code>如果成功，则服务提供者实现应检查所有关键扩展是否都已解决，如果未解决，则认为验证失败。例如：</p><pre class="codeblock"><code>
        if (unresolvedCritExts != null &amp;&amp;
            !unresolvedCritExts.isEmpty())
        {
            // note that a CertPathBuilder may have an enclosing
            // try block to catch the exception below and continue on error
            throw new CertPathValidatorException
                ("Unrecognized Critical Extension");
        }
</code></pre><p>如上一节所述， <code class="codeph">CertPathBuilder</code>当潜在的认证路径达到死胡同或失败点时，实施可能需要回溯。在这种情况下，回溯意味着返回路径中的上一个证书并检查其他可能的路径。如果<code class="codeph">CertPathBuilder</code>实现正在构建路径时对其进行验证，因此需要恢复每个路径的先前状态<code class="codeph">PKIXCertPathChecker</code> 。它可以通过制作<code class="codeph">PKIXCertPathChecker</code>每个证书处理<span class="variable" translate="no">before</span>对象，例如：</p><pre class="codeblock"><code>
        /* clone checkers */
        List newList = new ArrayList(checkers);
        ListIterator li = newList.listIterator();
        while (li.hasNext()) {   
            PKIXCertPathChecker checker = (PKIXCertPathChecker) li.next();
            li.set(checker.clone());
        }
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF" name="GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF"></a><h5 id="JSSEC-GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF" class="sect5">在证书路径验证中使用PKIXCertPathChecker</h5>
                     <div>
                        <p>用一个<code class="codeph">PKIXCertPathChecker</code>自定义证书路径验证相对简单。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF__GUID-FDBBF84A-09BF-4E2A-B4DF-301F80CBC82F">基本认证路径验证</p>
                           <p>首先，考虑验证证书路径的代码：</p><pre class="codeblock"><code>
Set&lt;TrustAnchor&gt; trustAnchors = getTrustAnchors();
CertPath cp = getCertPath();

PKIXParameters pkixp = new PKIXParameters(trustAnchors);
pkixp.setRevocationEnabled(false);

CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
PKIXCertPathValidatorResult pcpvr =
    (PKIXCertPathValidatorResult)cpv.validate(cp, pkixp);
</code></pre><p>如果验证失败，则<code class="codeph">validate()</code>方法引发异常。
                           </p>
                           <p>基本步骤如下：</p>
                           <ol>
                              <li>获取CA根证书和要验证的证书路径。</li>
                              <li>创建一个<code class="codeph">PKIXParameters</code>与信任锚。
                              </li>
                              <li>用一个<code class="codeph">CertPathValidator</code>验证证书路径。
                              </li>
                           </ol>
                           <p>在这个例子中<code class="codeph">getTrustAnchors()</code>和<code class="codeph">getCertPath()</code>是获得CA根证书和证书路径的方法。
                           </p>
                           <p>的<code class="codeph">getTrustAnchors()</code>示例中的方法必须返回一个<code class="codeph">Set</code>的<code class="codeph">TrustAnchor</code>代表您希望用于验证的CA根证书。这是一个从文件加载单个CA根证书的简单实现：</p><pre class="codeblock"><code>
public Set&lt;TrustAnchor&gt; getTrustAnchors()
    throws IOException, CertificateException {

  CertificateFactory cf = CertificateFactory.getInstance("X.509");

  X509Certificate c;
  try (InputStream in = new FileInputStream("x509_ca-certificate.cer")) {
    c = (X509Certificate)cf.generateCertificate(in);
  }

  TrustAnchor anchor = new TrustAnchor(c, null);
  return Collections.singleton(anchor);
}
</code></pre><p>同样，这是一个简单的实现<code class="codeph">getCertPath()</code>从文件加载证书路径：</p><pre class="codeblock"><code>
public CertPath getCertPath() throws IOException, CertificateException {
  CertificateFactory cf = CertificateFactory.getInstance("X.509");

  CertPath cp;
  try (InputStream in = new FileInputStream("certpath.pkcs7")) { &nbsp;&nbsp;&nbsp;&nbsp;
    cp = cf.generateCertPath(in, "PKCS7");
  }   
  return cp;
}
</code></pre><p>请注意，PKCS＃7不需要为文件中的证书指定特定的顺序，因此，仅当从要验证的实体开始订购证书并回溯到CA根目录时，此代码才适用于证书路径验证。如果证书顺序不正确，则需要进行其他一些处理。 <code class="codeph">CertificateFactory</code>有个<code class="codeph">generateCertPath()</code>接受一个的方法<code class="codeph">Collection</code> ，这对于这种类型的处理很有用。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F727578E-71D0-4BC5-9B06-47EE13F9CBCF__GUID-A08E7621-A4A4-45FE-94FE-7760C822C211">添加一个<code class="codeph">PKIXCertPathChecker</code></p>
                           <p>要自定义认证路径验证，请添加一个<code class="codeph">PKIXCertPathChecker</code>如下。在这个例子中<code class="codeph">SimpleChecker</code>是一个<code class="codeph">PKIXCertPathChecker</code>子类。新行以<span class="bold">粗体显示</span> 。
                           </p><pre class="codeblock"><code>
Set&lt;TrustAnchor&gt; trustAnchors = getTrustAnchors();
CertPath cp = getCertPath();

PKIXParameters pkixp = new PKIXParameters(trustAnchors);
pkixp.setRevocationEnabled(false);

<span class="bold">SimpleChecker sc = new SimpleChecker();
pkixp.addCertPathChecker(sc);</span>

CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
PKIXCertPathValidatorResult pcpvr =
    (PKIXCertPathValidatorResult)cpv.validate(cp, pkixp);
</code></pre><p><code class="codeph">SimpleChecker</code>是的基本子类<code class="codeph">PKIXCertPathChecker</code> 。它的<code class="codeph">check()</code>对于正在验证的证书路径中的每个证书，都会调用method方法。 <code class="codeph">SimpleChecker</code>使用一个<code class="codeph">AlgorithmConstraints</code>实现以检查每个证书的签名算法和公钥。
                           </p><pre class="codeblock"><code>
import java.security.AlgorithmConstraints;
import java.security.CryptoPrimitive;
import java.security.Key;
import java.security.cert.*;
import java.util.*;

public class SimpleChecker extends PKIXCertPathChecker {
  private final static Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
      EnumSet.of(CryptoPrimitive.SIGNATURE);
  
  public void init(boolean forward) throws CertPathValidatorException {}
  
  public boolean isForwardCheckingSupported() { return true; }
  
  public Set&lt;String&gt; getSupportedExtensions() { return null; }
  
  public void check(Certificate cert,
      Collection&lt;String&gt; unresolvedCritExts)
      throws CertPathValidatorException {
    X509Certificate c = (X509Certificate)cert;
    String sa = c.getSigAlgName();
    Key key = c.getPublicKey();
    
    AlgorithmConstraints constraints = new SimpleConstraints();
    
    if (constraints.permits(SIGNATURE_PRIMITIVE_SET, sa, null) == false)
      throw new CertPathValidatorException("Forbidden algorithm: " + sa);

    if (constraints.permits(SIGNATURE_PRIMITIVE_SET, key) == false)
      throw new CertPathValidatorException("Forbidden key: " + key);
  }
}
</code></pre><p>最后， <code class="codeph">SimpleConstraints</code>是一个<code class="codeph">AlgorithmConstraints</code>需要RSA 2048的实施。
                           </p><pre class="codeblock"><code>
import java.security.AlgorithmConstraints;
import java.security.AlgorithmParameters;
import java.security.CryptoPrimitive;
import java.security.Key;
import java.security.interfaces.RSAKey;
import java.util.Set;

public class SimpleConstraints implements AlgorithmConstraints {
  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
      String algorithm, AlgorithmParameters parameters) {
    return permits(primitives, algorithm, null, parameters);
  }

  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
    return permits(primitives, null, key, null);
  }
  
  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
      String algorithm, Key key, AlgorithmParameters parameters) {
    if (algorithm == null) algorithm = key.getAlgorithm();
    
    if (algorithm.indexOf("RSA") == -1) return false;
    
    if (key != null) {
      RSAKey rsaKey = (RSAKey)key;
      int size = rsaKey.getModulus().bitLength();
      if (size &lt; 2048) return false;
    }

    return true;
  }
}
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-43A3A247-E165-408C-AD74-88A75BFB4750" name="GUID-43A3A247-E165-408C-AD74-88A75BFB4750"></a><h6 id="JSSEC-GUID-43A3A247-E165-408C-AD74-88A75BFB4750" class="sect6">使用PKIXRevocationChecker类检查证书的吊销状态</h6>
                        <div>
                           <p>的实例<code class="codeph">PKIXRevocationChecker</code>使用联机证书状态协议（OCSP）或证书吊销列表（CRL）检查证书的吊销状态。
                           </p>
                           <p>的<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXRevocationChecker.html" target="_blank"><code class="codeph">PKIXRevocationChecker</code></a></code> （在JDK 8中引入），它是<code class="codeph">PKIXCertPathChecker</code> ，使用PKIX算法检查证书的吊销状态。
                           </p>
                           <p>的实例<code class="codeph">PKIXRevocationChecker</code>使用在线证书状态协议（OCSP）或证书吊销列表（CRL）检查证书的吊销状态。OCSP在<a href="http://www.ietf.org/rfc/rfc2560.txt" target="_blank">RFC 2560</a>中进行了描述，它是一种用于确定证书状态的网络协议。CRL是带有时间戳的列表，用于标识已撤销的证书，而RFC 5280描述了一种使用CRL确定证书的撤销状态的算法。
                           </p>
                           <p>每个PKIX <code class="codeph">CertPathValidator</code>和<code class="codeph">CertPathBuilder</code>实例提供默认情况下启用的默认吊销实现。如果您想进一步控制该实现所使用的吊销设置，请使用<code class="codeph">PKIXRevocationChecker</code>类。
                           </p>
                           <p>请按照以下常规步骤，使用以下命令检查证书路径的吊销状态： <code class="codeph">PKIXRevocationChecker</code>类：</p>
                           <ol>
                              <li>
                                 <p>获得一个<code class="codeph">PKIXRevocationChecker</code>通过调用实例<code class="codeph">getRevocationChecker</code> PKIX的方法<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实例。
                                 </p>
                              </li>
                              <li>
                                 <p>使用包含在方法中的方法设置特定于证书吊销的附加参数和选项。 <code class="codeph">PKIXRevocationChecker</code>类。这些方法包括<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXRevocationChecker.html#setOcspResponder-java.net.URI-" target="_blank"><code class="codeph">setOCSPResponder(URI)</code></a></code> ，它会设置用于标识OCSP响应程序位置的URI（尽管通常该URI包含在证书中，而不必设置）和<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXRevocationChecker.html#setOptions-java.util.Set-" target="_blank"><code class="codeph">setOptions(Set<PKIXRevocationChecker.Option>)</code></a></code> ，它设置吊销选项。 <code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXRevocationChecker.Option.html" target="_blank"><code class="codeph">PKIXRevocationChecker.Option</code></a></code>是用于指定以下选项的枚举类型：</p>     
                                 <ul style="list-style-type:disc">
                                    <li><code class="codeph">ONLY_END_ENTITY</code> ：仅检查最终实体证书的吊销状态。
                                    </li>
                                    <li><code class="codeph">PREFER_CRLS</code> ：默认情况下，OCSP是检查吊销状态的首选机制，而CRL是后备机制。使用此选项将此首选项切换为CRL。
                                    </li>
                                    <li><code class="codeph">SOFT_FAIL</code> ：忽略网络故障。
                                    </li>
                                 </ul>      
                              </li>
                              <li>
                                 <p>获得一个实例之后<code class="codeph">PKIXRevocationChecker</code> ，将其添加到<code class="codeph">PKIXParameters</code>要么<code class="codeph">PKIXBuilderParameters</code>与对象<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXParameters.html" target="_blank"><code class="codeph">addCertPathChecker</code></a></code>要么<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXParameters.html" target="_blank"><code class="codeph">setCertPathCheckers</code></a></code>方法。
                                 </p>  
                              </li>
                              <li>
                                 <p>请执行以下步骤之一，具体取决于您是否正在使用PKIX <code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实例：</p>      
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果您使用的是PKIX <code class="codeph">CertPathValidator</code>例如，呼叫<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXCertPathValidatorResult.html" target="_blank"><code class="codeph">validate</code></a></code>方法，将要验证的证书路径和<code class="codeph">PKIXParameters</code>包含吊销检查器的对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果您使用的是PKIX <code class="codeph">CertPathBuilder</code>例如，呼叫<code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CertPathBuilder.html#build-java.security.cert.CertPathParameters-" target="_blank"><code class="codeph">build</code></a></code>使用参数作为方法<code class="codeph">PKIXBuilderParameters</code>包含吊销检查器的对象。
                                       </p>
                                    </li>
                                 </ul>   
                              </li>
                              <li>
                                 <p>致电<code class="codeph">validate</code> PKIX的方法<code class="codeph">CertPathValidator</code>要么<code class="codeph">CertPathBuilder</code>实例使用您要验证的证书路径以及<code class="codeph">PKIXParameters</code>要么<code class="codeph">PKIXBuilderParameters</code>包含吊销检查器的对象。
                                 </p>
                              </li>
                           </ol>
                           <p>以下摘录检查证书路径中包含的证书的吊销状态。的<code class="codeph">CertPath</code>宾语<code class="codeph">path</code>是证书路径，并且<code class="codeph">params</code>是类型的对象<code class="codeph">PKIXParameters</code> ：</p><pre class="codeblock"><code>
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
    PKIXRevocationChecker rc = (PKIXRevocationChecker)cpv.getRevocationChecker();
    rc.setOptions(EnumSet.of(Option.SOFT_FAIL));
    params.addCertPathChecker(rc);
    params.setRevocationEnabled(false);
    CertPathValidatorResult res = cpv.validate(path, params);
</code></pre><p>在此摘录中， <code class="codeph">SOFT_FAIL</code>选项使吊销检查程序在检查吊销状态时忽略任何网络故障（例如无法建立与OCSP服务器的连接）。
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-266DD62E-39A7-435B-90DF-7EB1425D56E1" name="GUID-266DD62E-39A7-435B-90DF-7EB1425D56E1"></a><h3 id="JSSEC-GUID-266DD62E-39A7-435B-90DF-7EB1425D56E1" class="sect3">实施服务提供商</h3>
               <div>
                  <p>经验丰富的程序员可以创建自己的提供程序包，以提供认证路径服务实施。</p>
                  <div class="section">
                     <p>本部分假定您已阅读《 <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title="Java密码体系结构（JCA）是该平台的主要部分，包含一个" name="" provide="=" ="">Java密码体系结构（JCA）参考指南》</a> 。
                     </p>
                     <p>Java认证路径API中定义了以下引擎类：</p>
                     <ul style="list-style-type:disc">
                        <li> 
                           <p><span class="bold"><code class="codeph">CertPathValidator</code></span> -用于验证认证路径</p> 
                        </li>
                        <li> 
                           <p><span class="bold"><code class="codeph">CertPathBuilder</code></span> -用于建立认证路径</p> 
                        </li>
                        <li> 
                           <p><span class="bold"><code class="codeph">CertStore</code></span> -用于从存储库中检索证书和CRL</p> 
                        </li>
                     </ul>
                     <p>此外，预先存在<code class="codeph">CertificateFactory</code>引擎类还支持证书路径的生成。
                     </p>
                     <p>引擎类提供的应用程序接口是根据“服务提供者接口”（SPI）实现的。每个SPI类的名称与相应引擎类的名称相同，后跟“ Spi”。例如，与<code class="codeph">CertPathValidator</code>引擎类是<code class="codeph">CertPathValidatorSpi</code>类。每个SPI类都是抽象的。要为特定的算法或类型提供特定类型的服务的实现，提供程序必须子类化相应的SPI类，并为所有抽象方法提供实现。例如， <code class="codeph">CertStore</code>类提供对从存储库中检索证书和CRL的功能的访问。实际提供的内容<code class="codeph">CertStoreSpi</code>子类将是特定类型的证书存储库的子类，例如LDAP。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F" name="GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F"></a><h4 id="JSSEC-GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F" class="sect4">实施和集成提供商的步骤</h4>
                  <div>
                     <p>在实现和集成证书路径服务的提供程序时，必须确保提供了某些信息。</p>
                     <div class="section">
                        <p>开发人员应遵循<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">实现和集成提供程序</a>的<a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="请遵循以下步骤来实现提供程序并将其集成到JCA框架中：">步骤</a> 。以下是某些步骤要遵循的一些其他规则：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F__GUID-D41C79B8-08E1-461C-B6EF-A8331D596D7D">步骤3：编写您的“ Master Class”（提供商的子类）</p>
                        <p>在“ <a href="howtoimplaprovider.html#GUID-1C82EDB9-96CA-44AB-8590-E299814D6A46" title="创建java.security的子类。提供程序类。这实际上是一个查找表，用于宣传您的提供程序实现的算法。">步骤3：编写您的主类，提供者的子类”中，</a>这些是必须为证书路径服务定义的属性，其中算法名称代替<span class="variable" translate="no">algName</span> ，而certstore类型代替<span class="variable" translate="no">storeType</span> ：</p>
                        <ul style="list-style-type:disc">
                           <li> 
                              <p><code class="codeph">CertPathValidator</code> 。 <span class="variable" translate="no">algName</span></p> 
                           </li>
                           <li> 
                              <p><code class="codeph">CertPathBuilder</code> 。 <span class="variable" translate="no">algName</span></p> 
                           </li>
                           <li> 
                              <p><code class="codeph">CertStore</code> 。 <span class="variable" translate="no">storeType</span></p> 
                           </li>
                        </ul>
                        <p>有关为<span class="variable" translate="no">algName</span>和<span class="variable" translate="no">storeType</span>定义的标准名称，请参见<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称</a> 。每个属性的值必须是实现指定算法或certstore类型的类的标准名称。也就是说，它必须是包名，后跟类名，两者之间用句点分隔。例如，提供商将<code class="codeph">CertPathValidator.PKIX</code>具有价值的财产<code>"sun.security.provider.certpath.PKIXCertPathValidator"</code>如下：</p><pre class="codeblock"><code>
put("CertPathValidator.PKIX", "sun.security.provider.certpath.PKIXCertPathValidator")
</code></pre><p>另外，可以为认证路径服务定义服务属性。这些属性可用作选择服务提供商的筛选器。有关某些标准服务属性的定义，请参见附录A。例如，提供商可以设置<code class="codeph">ValidationAlgorithm</code>服务属性，用于定义PKIX验证算法的RFC或规范的名称：</p><pre class="codeblock"><code>
put("CertPathValidator.PKIX ValidationAlgorithm", "RFC5280");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F__GUID-37433574-5578-471C-8D0A-9293E3E576DD">
                        <p class="subhead3" id="GUID-BFF21E4E-30F9-4D92-BD1E-C530DD33609F__GUID-5DC62ADA-922D-424D-A1D3-18C6837E4BF0">步骤11：记录您的提供商及其支持的服务</p>
                        <p>在“ <a href="howtoimplaprovider.html#GUID-912FAB1D-628A-47EA-A1DD-A216F2DD4245">步骤12：记录您的提供者及其支持的服务”中</a> ，认证路径服务提供者应为每个SPI记录以下信息：</p>
                        <p><span class="bold">证书工厂</span></p>
                        <p>供应商应记录工厂可以创建哪些类型的认证路径（以及相关路径中的证书版本号）。提供者应在认证路径中描述证书的顺序及其内容。</p>
                        <p>提供者应记录支持的编码格式列表。这在技术上不是必需的，因为客户端可以通过调用<span class="apiname">getCertPathEncodings</span>方法来请求它们。但是，文档应更详细地描述每种编码格式，并在适用时引用任何标准。
                        </p>
                        <p><span class="bold">认证路径验证器</span></p>
                        <p>提供者应记录有关以下方面的任何相关信息： <code class="codeph">CertPathValidator</code>实现，包括它验证的认证路径的类型。特别是PKIX <code class="codeph">CertPathValidator</code>实施应记录以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>符合的RFC或规范。</li>
                           <li>它用于检查证书是否已吊销的机制。</li>
                           <li>它识别的任何可选证书或CRL扩展以及如何处理它们。</li>
                        </ul>
                        <p><span class="bold">认证路径建设者</span></p>
                        <p>提供者应记录有关以下方面的任何相关信息： <code class="codeph">CertPathBuilder</code>实现，包括它创建的认证路径的类型以及它们是否经过验证。特别是PKIX <code class="codeph">CertPathBuilder</code>实施应记录以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>符合的RFC或规范。</li>
                           <li>它用于检查证书是否已吊销的机制。</li>
                           <li>它识别的任何可选证书或CRL扩展以及如何处理它们。</li>
                           <li>用于查找认证路径的算法的详细信息。例如：深度优先，宽度优先，前向（即，从目标到信任锚），反向（即，从信任锚到目标）。</li>
                           <li>它用于选择和分类潜在证书的算法。例如，假定有两个证书是路径中下一个证书的潜在候选者，那么使用什么标准先选择一个？使用什么标准拒绝证书？</li>
                           <li>如果适用，该算法用于回溯或构建另一条路径（即，当潜在路径不符合约束条件时）。</li>
                           <li>的类型<code class="codeph">CertStore</code>经过测试的实现。该实现应设计为可与任何<code class="codeph">CertStore</code>类型，但此信息可能仍然有用。
                           </li>
                        </ul>
                        <p>所有<code class="codeph">CertPathBuilder</code>实现应提供其他调试支持，以便分析和纠正潜在的路径构建问题。应记录有关如何访问此调试信息的详细信息。
                        </p>
                        <p><span class="bold">证书/ CRL商店</span></p>
                        <p>提供者应记录由认证机构检索到的证书和CRL类型（以及相关的版本号）。 <code class="codeph">CertStore</code> 。
                        </p>
                        <p>提供者还应记录有关以下方面的任何相关信息： <code class="codeph">CertStore</code>实现（例如使用的协议或支持的格式）。例如，一个LDAP <code class="codeph">CertStore</code>实现应描述支持的LDAP版本，以及用于查找证书和CRL的标准属性。它还应记录实现是否缓存结果以及缓存多长时间（即，在什么条件下刷新它们）。
                        </p>
                        <p>如果实现以特定顺序返回证书和CRL，则它应描述排序算法。实现还应记录任何其他或默认的初始化参数。最后，实施应记录是否以及如何使用<code class="codeph">CertSelector</code>要么<code class="codeph">CRLSelector</code>对象来查找证书和CRL。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-255CC70E-E05E-4109-AA6E-51B83C5A3618" name="GUID-255CC70E-E05E-4109-AA6E-51B83C5A3618"></a><h5 id="JSSEC-GUID-255CC70E-E05E-4109-AA6E-51B83C5A3618" class="sect5">服务相互依赖</h5>
                     <div>
                        <p>认证路径服务实现中常见的算法相互依赖类型。</p>
                        <p>以下是证书路径服务实现中一些常见的算法相互依赖类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>认证路径验证和签名算法</p>
                              <p>一种<code class="codeph">CertPathValidator</code>实施通常需要使用签名算法来验证每个证书的数字签名。<span class="apiname">setSigProvider</span>方法<code class="codeph">PKIXParameters</code>类允许用户指定一个特定的<code class="codeph">Signature</code>提供者。
                              </p>
                           </li>
                           <li>
                              <p>认证路径构建者和证书工厂</p>
                              <p>一种<code class="codeph">CertPathBuilder</code>实施通常会利用<code class="codeph">CertificateFactory</code>从证书列表中生成证书路径。
                              </p>
                           </li>
                           <li>
                              <p>证书库和证书工厂</p>
                              <p>一种<code class="codeph">CertStore</code>实施通常会利用<code class="codeph">CertificateFactory</code>根据其编码生成证书和CRL。例如，一个LDAP <code class="codeph">CertStore</code>实现可能使用X.509 <code class="codeph">CertificateFactory</code>从其ASN.1编码形式生成X.509证书和CRL。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5C8A1966-6636-475F-B533-3D080DB0653A" name="GUID-5C8A1966-6636-475F-B533-3D080DB0653A"></a><h5 id="JSSEC-GUID-5C8A1966-6636-475F-B533-3D080DB0653A" class="sect5">认证路径参数规范接口</h5>
                     <div>
                        <p>认证路径API包含两个接口，分别表示<span class="variable" translate="no">transparent</span>的参数规范， <code class="codeph">CertPathParameters</code>和<code class="codeph">CertStoreParameters</code>接口。
                        </p>
                        <p>的两种实现<code class="codeph">CertPathParameters</code>包括接口， <code class="codeph">PKIXParameters</code>和<code class="codeph">PKIXBuilderParameters</code>类。如果您正在使用PKIX认证路径验证和算法参数，则可以利用这些类。如果您需要其他算法的参数，则需要提供自己的算法<code class="codeph">CertPathParameters</code>该算法的实现。
                        </p>
                        <p>的两种实现<code class="codeph">CertStoreParameters</code>包括接口， <code class="codeph">LDAPCertStoreParameters</code>和<code class="codeph">CollectionCertStoreParameters</code>类。这些类将与LDAP和Collection一起使用<code class="codeph">CertStore</code>实现。如果需要其他存储库类型的参数，则需要提供自己的存储库类型<code class="codeph">CertStoreParameters</code>该类型的实现。
                        </p>
                        <p>的<code class="codeph">CertPathParameters</code>和<code class="codeph">CertStoreParameters</code>每个接口定义一个<code class="codeph">clone</code>实现应重写的方法。典型的实现将执行对象的“深层”副本，以使对该副本的后续更改不会影响原始对象（反之亦然）。但是，这并非实现以下条件的绝对要求<code class="codeph">CertStoreParameters</code> 。的浅表复制实现<code class="codeph">clone</code>更适合需要保留对包含在参数中的参数的引用的应用程序<code class="codeph">CertStoreParameters</code> 。例如，由于<span class="apiname">CertStore.getInstance</span>可以克隆指定的<code class="codeph">CertStoreParameters</code>浅表副本<code class="codeph">clone</code>允许应用程序保留对特定资源的引用，并在以后释放特定资源<code class="codeph">CertStore</code>初始化参数，而不是等待垃圾回收机制。这样做应该格外小心，因为<code class="codeph">CertStore</code>可能仍被其他线程使用。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-67EDE244-431F-4382-9384-B5CBD8163C05" name="GUID-67EDE244-431F-4382-9384-B5CBD8163C05"></a><h5 id="JSSEC-GUID-67EDE244-431F-4382-9384-B5CBD8163C05" class="sect5">认证路径结果规范接口</h5>
                     <div>
                        <p>认证路径API包含两个表示<span class="variable" translate="no">transparent</span>的结果规范的接口， <code class="codeph">CertPathValidatorResult</code>和<code class="codeph">CertPathBuilderResult</code>接口。
                        </p>
                        <p></p>
                        <p>其中包括每个接口的一种实现： <code class="codeph">PKIXCertPathValidatorResult</code>和<code class="codeph">PKIXCertPathBuilderResult</code>类。如果要实现PKIX认证路径服务提供者，则可以利用这些类。如果您需要其他算法的认证路径结果，则需要提供自己的算法<code class="codeph">CertPathValidatorResult</code>要么<code class="codeph">CertPathBuilderResult</code>该算法的实现。
                        </p>
                        <p>一个PKIX实现<code class="codeph">CertPathValidator</code>或<code class="codeph">CertPathBuilder</code>可能会发现将其他信息存储在<code class="codeph">PKIXCertPathValidatorResult</code>要么<code class="codeph">PKIXCertPathBuilderResult</code> ，例如调试跟踪。在这些情况下，实现应使用检索相关信息的方法来实现适当结果类的子类。这些类必须与提供程序类一起提供，例如，作为提供程序JAR文件的一部分。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C6FC73C4-E9CA-45A2-A135-5E81FA345F5F" name="GUID-C6FC73C4-E9CA-45A2-A135-5E81FA345F5F"></a><h5 id="JSSEC-GUID-C6FC73C4-E9CA-45A2-A135-5E81FA345F5F" class="sect5">认证路径异常类</h5>
                     <div>
                        <p>认证路径API包含一组用于处理错误的异常类。 <code class="codeph">CertPathValidatorException, CertPathBuilderException</code>和<code class="codeph">CertStoreException</code>是的子类<code class="codeph">GeneralSecurityException</code> 。
                        </p>
                        <p>您可能需要在服务提供商的实现中扩展这些类。</p>
                        <p>例如，一个<code class="codeph">CertPathBuilder</code>实现可能会提供其他信息，例如调试跟踪<code class="codeph">CertPathBuilderException</code>被抛出。实现可能会抛出一个子类<code class="codeph">CertPathBuilderException</code>包含此信息。同样地， <code class="codeph">CertStore</code>发生故障时，实现可以通过抛出以下内容的子类来提供其他信息： <code class="codeph">CertStoreException</code> 。另外，您可能想实现以下子类<code class="codeph">CertPathValidatorException</code>描述您的特定故障模式<code class="codeph">CertPathValidator</code>实施。
                        </p>
                        <p>在每种情况下，新的异常类都必须与提供程序类一起提供，例如，作为提供程序JAR文件的一部分。每个提供程序都应记录异常子类。</p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-EF1585DC-20BF-4140-B71E-0A8528D4A57D" name="GUID-EF1585DC-20BF-4140-B71E-0A8528D4A57D"></a><h3 id="JSSEC-GUID-EF1585DC-20BF-4140-B71E-0A8528D4A57D" class="sect3">附录A：标准名称</h3>
               <div>
                  <p>Java认证路径API要求并利用一组标准名称来认证路径验证算法，编码和证书存储类型。</p>
                  <div class="section">
                     <p>先前在附录A和其他安全规范（JCA / JSSE / etc。）中找到的<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">标准名称</a>已合并到<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java安全标准算法名称中</a> 。特定的提供程序信息可以在<a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="本文档包含JDK中包含的提供程序的技术细节。假定读者对Java密码体系结构和提供程序体系结构有深入的了解。">JDK Providers中</a>找到。
                     </p>
                     <p>请注意，服务提供商可能会选择为“标准名称”文档中未提及的专有或非标准算法定义新名称。但是，为防止名称冲突，建议在名称前加上提供商组织的反向Internet域名（例如： <code class="codeph">com.sun.MyCertPathValidator</code> ）。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746" name="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746"></a><h3 id="JSSEC-GUID-EB250086-0AC1-4D60-AE2A-FC7461374746" class="sect3">附录B：SUN Provider中的CertPath实现</h3>
               <div>
                  <div class="section">
                     <p>“ SUN”提供程序支持以下标准算法，类型和编码：</p>
                     <ul style="list-style-type:disc">
                        <li><code class="codeph">CertificateFactory</code> ： <span class="bold">X.509</span> <code class="codeph">CertPath</code>使用<span class="bold">PKCS7</span>和<span class="bold">PkiPath</span>编码输入</li>
                        <li><code class="codeph">CertPathValidator</code> ： <span class="bold">PKIX</span>算法</li>
                        <li><code class="codeph">CertPathBuilder</code> ： <span class="bold">PKIX</span>算法</li>
                        <li><code class="codeph">CertStore</code> ： <span class="bold">收藏</span> <code class="codeph">CertStore</code>类型</li>
                     </ul>
                     <p>这些服务提供商接口实现中的每一个将在下面更详细地讨论。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-4FDEC53A-4F0F-41BF-85B8-4FFC6B8A3BB7">证书工厂</p>
                     <p>“ SUN”提供商<code class="codeph">CertificateFactory</code>引擎类支持X.509的生成<code class="codeph">CertPath</code>对象。支持PKCS7和PkiPath编码。PKCS＃7实现支持<a href="http://www.ietf.org/rfc/rfc2315.txt" target="_blank">RFC 2315</a>的子集（仅支持SignedData ContentInfo类型）。证书中的<code class="codeph">CertPath</code>顺序向前（从目标到信任锚）。中的每个证书<code class="codeph">CertPath</code>是类型<code class="codeph">java.security.cert.X509Certificate</code> ，并且支持版本1、2和3。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-69B69C50-2F9D-4044-B2D8-63943646F30E">CertPathValidator</p>
                     <p>“ SUN”提供程序提供了PKIX的实现<code class="codeph">CertPathValidator</code>引擎类。实施验证<code class="codeph">CertPath</code>的类型为X.509，并实现<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280中</a>定义的认证路径验证算法<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">：</a> <cite>PKIX证书和CRL配置文件</cite> 。此实现设置了<code class="codeph">ValidationAlgorithm</code>服务属性为“ RFC5280”。
                     </p>
                     <p>弱密码算法可以在“ SUN”提供程序中使用<code class="codeph">jdk.certpath.disabledAlgorithms</code>安全属性。有关此属性的描述和示例，请参见<a href="java-pki-programmers-guide.html#GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3" title="jdk.certpath.disabledAlgorithms安全属性包含被认为是弱的或损坏的密码算法和密钥大小约束的列表。包含任何这些算法或密钥大小的证书和其他数据（CRL，OCSPResponses）将在认证路径构建和验证期间被阻止。Oracle的PKIX实现使用此属性，其他实现可能不检查和使用它。">附录E：禁用密码算法</a> 。
                     </p>
                     <p>PKIX证书和CRL配置文件具有许多可选功能。“ SUN”提供程序实现对策略映射， <a href="java-pki-programmers-guide.html#GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__SECTION-1310-623E8D62">权限信息访问</a>和<a href="java-pki-programmers-guide.html#GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__SECTION-139-623E860E">CRL分发点证书</a>扩展，发行分发点CRL扩展以及原因码和证书颁发者CRL条目扩展的支持。它不支持最新的CRL或主题信息访问证书扩展。它还不包括对最新的CRL和增量CRL指示器CRL扩展以及无效日期和保留指令代码CRL条目扩展的支持。
                     </p>
                     <p>该实现支持CRL吊销检查机制，该机制符合PKIX证书和CRL配置文件的6.3节。OCSP（ <a href="http://www.ietf.org/rfc/rfc2560.txt" target="_blank">RFC 2560</a> ）当前还作为内置的吊销检查机制而受支持。有关实现和配置以及它如何与CRL结合使用的更多详细信息，请参见<a href="java-pki-programmers-guide.html#GUID-E6E737DB-4000-4005-969E-BCD0238B1566" title="支持RFC 2560中定义的对在线证书状态协议（OCSP）的客户端支持。">附录C：OCSP支持</a> 。
                     </p>
                     <p>该实现不支持<code class="codeph">nameConstraints</code>的参数<code class="codeph">TrustAnchor</code>类和<code class="codeph">validate</code>方法抛出一个<code class="codeph">InvalidAlgorithmParameterException</code>如果已指定。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-BB469A6A-18A4-40FF-BCAE-3320B9E75E01">CertPathBuilder</p>
                     <p>“ SUN”提供程序提供了PKIX的实现<code class="codeph">CertPathBuilder</code>引擎类。实现构建<code class="codeph">CertPath</code> X.509类型的。每<code class="codeph">CertPath</code>根据<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280中</a>定义的PKIX算法进行验证<a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">： <span class="variable" translate="no">PKIX Certificate and CRL Profile</span></a> 。此实现设置了<code class="codeph">ValidationAlgorithm</code>服务属性为“ RFC5280”。
                     </p>
                     <p>实施要求<code class="codeph">targetConstraints</code>一个的参数<code class="codeph">PKIXBuilderParameters</code>对象是的实例<code class="codeph">X509CertSelector</code>主题条件设置为非空值。否则<code class="codeph">build</code>方法抛出一个<code class="codeph">InvalidAlgorithmParameterException</code> 。
                     </p>
                     <p>实现构建<code class="codeph">CertPath</code>使用深度优先算法在向前方向上对物体进行定位。当确定潜在路径无效或超过潜在路径时，它将回溯到先前的状态并尝试使用备用路径<code class="codeph">PKIXBuilderParameters</code><code class="codeph">maxPathLength</code>参数。
                     </p>
                     <p>路径验证的执行方式与<code class="codeph">CertPathValidator</code>实施。该实现会在构建路径时对大多数路径进行验证，以消除流程中较早的无效路径。在构造路径之后（但在将路径返回给应用程序之前），无法对正向订购的证书执行的验证检查将被延迟并在路径上执行。
                     </p>
                     <p>与<code class="codeph">CertPathValidator</code> ， <code class="codeph">jdk.certpath.disabledAlgorithms</code>安全属性可用于排除不安全的加密算法。
                     </p>
                     <p>当发现两个或多个可能导致找到满足指定约束条件的路径的潜在证书时，实现将使用以下条件来对证书进行优先级排序（在下面的示例中，假定<code class="codeph">TrustAnchor</code>指定了“ ou = D，ou = C，o = B，c = A”的专有名称）：</p>
                     <ol>
                        <li>证书的颁发者DN与指定的证书之一的DN匹配<code class="codeph">TrustAnchor</code> s（例如：issuerDN =“ ou = D，ou = C，o = B，c = A”）。
                        </li>
                        <li>证书的颁发者DN是以下证书之一的DN的后代<code class="codeph">TrustAnchor</code> s，按与锚点的接近程度排序（例如：issuerDN =“ ou = E，ou = D，ou = C，o = B，c = A”）。
                        </li>
                        <li>证书的发行者DN是以下任一者的DN的祖先<code class="codeph">TrustAnchor</code> s，按与锚点的接近程度排序（例如：issuerDN =“ ou = C，o = B，c = A”。
                        </li>
                        <li>证书的颁发者DN在以下证书之一的相同名称空间中<code class="codeph">TrustAnchor</code> s，按与锚点的接近程度排序（例如：issuerDN =“ ou = G，ou = C，o = B，c = A”）。
                        </li>
                        <li>证书的发行者DN是证书的主题DN的始祖，按与主题的接近程度排序。</li>
                     </ol>
                     <p>这些证书后面是不符合上述任何标准的证书。</p>
                     <p>此实现已通过LDAP和Collection进行了测试<code class="codeph">CertStore</code>此版本的“ SUN”提供程序中包含的实现。
                     </p>
                     <p>可以通过设置<code class="codeph">java.security.debug</code>财产<code class="codeph">certpath</code> 。例如：</p><pre class="codeblock"><code>
       java -Djava.security.debug=certpath BuildCertPath

</code></pre><p>这会将其他调试信息打印为标准错误。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-430996B3-2A8F-47CD-8F8B-16A78B289E57">集合证书库</p>
                     <p>SUN提供程序支持<code class="codeph">CertStore</code>引擎类。
                     </p>
                     <p>集合<code class="codeph">CertStore</code>实现可以保存作为以下对象实例的任何对象<code class="codeph">java.security.cert.Certificate</code>要么<code class="codeph">java.security.cert.CRL</code> 。
                     </p>
                     <p>证书和CRL不会以任何特定顺序返回，并且不会包含重复项。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__SECTION-139-623E860E">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-38BC3CB0-C574-4E8D-9854-44802339247F">支持CRL分发点扩展</p>
                     <p>支持CRL分发点扩展。为了兼容性，默认情况下禁用它，可以通过设置系统属性来启用它<code class="codeph">com.sun.security.enableCRLDP</code>达到真实值。
                     </p>
                     <p>如果设置为true，则Sun的PKIX实现将使用证书的CRL分发点扩展中的信息（除<code class="codeph">CertStores</code> （如果指定），则可以找到CRL，前提是分发点是X.500专有名称或ldap，http或ftp类型的URI。
                     </p>
                     <div class="infoboxnote" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-04FA26C1-BD2F-49EA-AB41-4CDACEB64B54">
                        <p class="notep1">注意：</p>根据您的网络和防火墙设置，可能还需要配置网络代理服务器。
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__SECTION-1310-623E8D62">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-60E7054D-3704-4401-ABBF-852929BBFE59">对授权机构信息访问（AIA）扩展的支持</p>
                     <p>支持<code class="codeph">caIssuers</code>授权信息访问扩展的访问方法可用。为了兼容性，默认情况下禁用它，可以通过设置系统属性来启用它<code class="codeph">com.sun.security.enableAIAcaIssuers</code>达到真实值。
                     </p>
                     <p>如果设置为true，则Sun的PKIX实现<code class="codeph">CertPathBuilder</code>使用证书的AIA扩展名（指定的CertStore除外）中的信息来查找颁发CA证书，前提是它是ldap，http或ftp类型的URI。
                     </p>
                     <div class="infoboxnote" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-0073BEE2-F442-4AB2-96B8-353D0D92AE36">
                        <p class="notep1">注意：</p>根据您的网络和防火墙设置，可能还需要配置网络代理服务器。
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EB250086-0AC1-4D60-AE2A-FC7461374746__GUID-46480E60-84FA-4B3E-86F0-CD6E0F5EB36F">CRL检索的最大网络连接超时</p>
                     <p>使用系统属性设置CRL检索的最大连接超时（以秒为单位） <code class="codeph">com.sun.security.crl.timeout</code> 。如果尚未设置该属性，或者该属性的值为负，则将其设置为默认值15秒。值为0表示无限超时。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-E6E737DB-4000-4005-969E-BCD0238B1566" name="GUID-E6E737DB-4000-4005-969E-BCD0238B1566"></a><h3 id="JSSEC-GUID-E6E737DB-4000-4005-969E-BCD0238B1566" class="sect3">附录C：OCSP支持</h3>
               <div>
                  <p>支持RFC 2560中定义的对在线证书状态协议（OCSP）的客户端支持。</p>
                  <div class="section">OCSP检查由以下五个安全属性控制：<div class="tblformal" id="GUID-E6E737DB-4000-4005-969E-BCD0238B1566__GUID-E342DEB0-ACE2-44DB-8E21-61EFDDA25D57">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="The five Security Properties control the OCSP checking" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d132107e5178">物业名称</th>
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d132107e5180">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5184" headers="d132107e5178 "><code class="codeph">ocsp.enable</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5184 d132107e5180 ">此属性的值为true或false。如果为true，则在进行证书吊销检查时启用OCSP检查。如果为false或未设置，则禁用OCSP检查。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5190" headers="d132107e5178 "><code class="codeph">ocsp.responderURL</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5190 d132107e5180 ">该属性的值是一个URL，用于标识OCSP响应程序的位置。这是一个例子<pre class="codeblock"><code>
ocsp.responderURL=http://ocsp.example.net:80
</code></pre> <p>默认情况下，OCSP响应程序的位置是根据要验证的证书隐式确定的。当证书中没有颁发机构信息访问扩展名（在RFC 5280中定义）或需要覆盖时，使用该属性。</p> 
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5202" headers="d132107e5178 "><code class="codeph">ocsp.responderCertSubjectName</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5202 d132107e5180 ">该属性的值是OCSP响应者证书的主题名称。这是一个例子<pre class="codeblock"><code>
ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"
</code></pre> <p>默认情况下，OCSP响应者的证书是正在验证的证书的颁发者的证书。当默认值不适用时，此属性标识OCSP响应者的证书。它的值是一个字符串专有名称（在RFC 2253中定义），用于在证书路径验证期间提供的一组证书中标识一个证书。如果仅主题名称不足以唯一地标识证书，则两个<code class="codeph">ocsp.responderCertIssuerName</code>和<code class="codeph">ocsp.responderCertSerialNumber</code>必须使用属性。设置此属性后，将忽略这两个属性。
                                    </p> 
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5220" headers="d132107e5178 "><code class="codeph">ocsp.responderCertIssuerName</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5220 d132107e5180 ">该属性的值是OCSP响应者证书的颁发者名称。这是一个例子<pre class="codeblock"><code>
ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"
</code></pre> <p>默认情况下，OCSP响应者的证书是正在验证的证书的颁发者的证书。当默认值不适用时，此属性标识OCSP响应者的证书。它的值是一个字符串专有名称（在RFC 2253中定义），用于在证书路径验证期间提供的一组证书中标识一个证书。设置此属性后， <code class="codeph">ocsp.responderCertSerialNumber</code>属性也必须设置。请注意，当<code class="codeph">ocsp.responderCertSubjectName</code>属性已设置。
                                    </p> 
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5238" headers="d132107e5178 "><code class="codeph">ocsp.responderCertSerialNumber</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5238 d132107e5180 ">此属性的值是OCSP响应者的证书的序列号。这是一个示例<pre class="codeblock"><code>
ocsp.responderCertSerialNumber=2A:FF:00
</code></pre> <p>默认情况下，OCSP响应者的证书是正在验证的证书的颁发者的证书。当默认值不适用时，此属性标识OCSP响应者的证书。它的值是一个十六进制数字字符串（可能存在冒号或空格），用于在证书路径验证期间提供的一组证书中标识一个证书。设置此属性后， <code class="codeph">ocsp.responderCertIssuerName</code>属性也必须设置。请注意，当<code class="codeph">ocsp.responderCertSubjectName</code>属性已设置。
                                    </p> 
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>这些属性可以在Java运行时的静态设置中进行设置。 <code><java_home>/conf/security/java.security</code>文件，或动态使用<span class="apiname">java.security。Security.setProperty（）</span>方法。
                     </p>
                     <p>默认情况下，不启用OCSP检查。通过设置<code class="codeph">ocsp.enable</code>财产<code class="codeph">"true"</code> 。其余属性的使用是可选的。请注意，仅在还启用了吊销检查的情况下，启用OCSP检查才有效。通过<span class="apiname">PKIXParameters.setRevocationEnabled（）</span>方法启用了吊销检查。
                     </p>
                     <p>在吊销检查期间，OCSP检查与证书吊销列表（CRL）结合使用。以下是OCSP和CRL交互的摘要。仅当遇到OCSP问题时，才会发生到CRL的故障转移。如果OCSP响应者确认证书已被吊销或证书未被吊销，则不会发生故障转移。</p>
                     <div class="tblformal" id="GUID-E6E737DB-4000-4005-969E-BCD0238B1566__GUID-923086ED-0588-4942-882E-B5A4E1809341">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Summary of the interaction of OCSP and CRLs." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d132107e5285">PKIXParameters RevocationEnabled（默认= true）</th>
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d132107e5287"><code class="codeph">ocsp.enable</code> （默认值= false）</th>
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d132107e5291">行为</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5295" headers="d132107e5285 ">真正</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5295 d132107e5287 ">真正</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5295 d132107e5291 ">使用OCSP进行吊销检查，使用CRL进行故障转移</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5302" headers="d132107e5285 ">真正</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5302 d132107e5287 ">假</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5302 d132107e5291 ">仅使用CRL进行吊销检查</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5309" headers="d132107e5285 ">假</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5309 d132107e5287 ">真正</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5309 d132107e5291 ">没有吊销检查</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d132107e5316" headers="d132107e5285 ">假</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5316 d132107e5287 ">假</td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d132107e5316 d132107e5291 ">没有吊销检查</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E6E737DB-4000-4005-969E-BCD0238B1566__GUID-54E50F04-FE0A-4EDA-BF7B-3D509A5CE326">最大允许时钟偏斜</p>
                     <p>您可能会在吊销检查期间遇到连接故障，因为网络速度很慢或系统时钟关闭了一定数量。设置最大允许的时钟偏斜（响应时间与本地时间之间的时差），以秒为单位，用于通过系统属性进行吊销检查<code class="codeph">com.sun.security.ocsp.clockskew</code> 。如果未设置该属性，或者该属性的值为负，则将其设置为默认值900秒（15分钟）。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD" name="GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD"></a><h3 id="JSSEC-GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD" class="sect3">附录D：JdkLDAP提供程序中的CertPath实现</h3>
               <div>
                  <p>JdkLDAP提供程序支持LDAP实现<code class="codeph">CertStore</code>引擎类。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD__GUID-793B32AD-4710-4B61-A24F-BFBC9523B878">LDAP CertStore</p>
                     <p>LDAP <code class="codeph">CertStore</code>实现使用<a href="http://www.ietf.org/rfc/rfc2587.txt" target="_blank">RFC 2587中</a>定义的LDAP模式从LDAP目录中检索证书和CRL。
                     </p>
                     <p>LDAPSchema服务属性设置为“ RFC2587”。</p>
                     <p>该实现会从不同位置获取证书，具体取决于主题，发行者和basicConstraints选择标准中指定的值。 <code class="codeph">X509CertSelector</code> 。它执行以下尽可能多的操作：</p>
                     <ol>
                        <li>主题非空，basicConstraints <= -1<p>在主题DN的“ userCertificate”属性中查找证书。</p> 
                        </li>
                        <li>主题非null，basicConstraints> = -1<p>在主题DN的“ crossCertificatePair”属性的forward元素和主题的“ caCertificate”属性中查找证书。</p> 
                        </li>
                        <li>颁发者非空，basicConstraints> = -1<p>在发行者DN的“ crossCertificatePair”属性的反向元素中以及发行者DN的“ caCertificate”属性中查找证书。</p> 
                        </li>
                     </ol>
                     <p>在每种情况下，在将证书添加到结果集合之前，都使用<span class="apiname">X509CertSelector.match（）</span>检查证书。
                     </p>
                     <p>如果以上指定的条件均不适用，则将引发异常，以表明不可能使用提供的条件来获取证书。请注意，即使满足一个或多个条件，如果目录中没有证书，则返回的Collection可能仍为空。</p>
                     <p>该实现将从在以下代码的<span class="apiname">setCertificateChecking</span> ， <span class="apiname">addIssuerName</span>或<span class="apiname">setIssuerNames</span>方法中指定的发行方DN提取CRL。 <code class="codeph">X509CRLSelector</code>类。如果未使用这些方法之一指定发行方DN，则该实现将引发异常，表明无法使用提供的条件来获取CRL。否则，将按以下方式搜索CRL：</p>
                     <ol>
                        <li>
                           <p>该实现首先创建发行者名称列表。如果在<span class="apiname">setCertificateChecking</span>方法中指定了证书，则它将使用该证书的颁发者。否则，它将使用通过<span class="apiname">addIssuerName</span>或<span class="apiname">setIssuerNames</span>方法指定的发行者名称。
                           </p>
                        </li>
                        <li>
                           <p>接下来，实现对发行者名称列表进行迭代。对于每个发行人名称，它首先在发行人的<code class="codeph">"authorityRevocationList"</code>属性，然后，如果在此处找不到匹配的CRL，则在发行人的<code class="codeph">"certificateRevocationList"</code>属性。上面的一个例外是，如果颁发者名称是从<span class="apiname">setCertificateChecking</span>方法中指定的证书中获得的，则它仅检查颁发者的<code class="codeph">"authorityRevocationList"</code>如果指定的证书是CA证书，则为属性。
                           </p>
                        </li>
                        <li>
                           <p>在将所有CRL添加到结果集合之前，将使用<span class="apiname">X509CRLSelector.match（）</span>检查所有CRL。
                           </p>
                        </li>
                        <li>
                           <p>如果找不到满足选择标准的CRL，则返回一个空的Collection。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FF62B0E3-E57A-4F40-970A-0481AF750CCD__GUID-E2EAC1BE-6771-4212-8FD8-E58E515F13C5">快取</p>
                     <p>默认情况下，每个LDAP CertStore实例最多缓存查询30秒。可以通过设置系统属性来更改缓存寿命<code class="codeph">sun.security.certpath.ldap.cache.lifetime</code>值以秒为单位。值<code class="codeph">0</code>完全禁用缓存。值<code class="codeph">-1</code>意味着无限的生命。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3" name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3"></a><h3 id="JSSEC-GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3" class="sect3">附录E：禁用密码算法</h3>
               <div>
                  <p>的<code class="codeph">jdk.certpath.disabledAlgorithms</code>安全属性包含被认为是弱的或损坏的密码算法和密钥大小约束的列表。包含任何这些算法或密钥大小的证书和其他数据（CRL，OCSPResponses）将在认证路径构建和验证期间被阻止。Oracle的PKIX实现使用此属性，其他实现可能不检查和使用它。
                  </p>
                  <div class="section" id="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__THEEXACTSYNTAXOFTHEJDK.CERTPATH.DIS-E836920C">
                     <div class="p">的确切语法<code class="codeph">jdk.certpath.disabledAlgorithms</code>属性在<code>java.security</code>文件。在Java SE 9中，该属性的默认值为：<pre class="pre codeblock"><code>jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
    RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224</code></pre> </div>
                     <div class="p">使用以下语法：<dl>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-B0501142-4173-4B89-BCAB-258A16642B90"><!-- --></a> MD2</dt>
                           <dd>任何基于MD2的算法都将被阻止。
                              <p>例如，使用MD2withRSA签名算法签名的证书，CRL或OCSPResponse。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-B88364D6-A8F1-4647-89E9-254574E7A6CF"><!-- --></a> MD5</dt>
                           <dd>任何基于MD5的算法都将被阻止。
                              <p>例如，使用MD5withRSA签名算法签名的证书，CRL或OCSPResponse。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-BBF5D821-1F96-4B27-8790-1C16DE97E2A0"><!-- --></a> SHA1 jdkCA和用法TLSServer</dt>
                           <dd>链接到信任锚的所有SHA1证书都预安装在cacerts密钥库中，并且用于TLS服务器的身份验证。参见<a href="http://openjdk.java.net/jeps/288" target="_blank">JEP 288</a> 。
                           </dd>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-0277D5D2-7B44-497A-8326-E03E7308FEF8"><!-- --></a> RSA密钥大小<1024</dt>
                           <dd>任何少于1024位的RSA密钥都会被阻止。
                              <p>例如，带有768位RSA公钥的证书。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-D46E89B2-3499-4AA3-9722-B052D8DCA85E"><!-- --></a> DSA键大小<1024</dt>
                           <dd>任何少于1024位的DSA密钥都将被阻止。
                              <p>例如，具有512位DSA公钥的证书。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-D2A99DE3-62CF-4E4B-BF91-814C4A5C4DD3__GUID-D354B4DE-FA31-45F3-97D4-0B50CE4E7122"><!-- --></a> EC键大小<224</dt>
                           <dd>任何少于224位的EC密钥都将被阻止。
                              <p>例如，带有160位EC公钥的证书。</p>
                           </dd>
                        </dl>
                     </div>
                     <p>管理员或用户可以修改<code class="codeph">jdk.certpath.disabledAlgorithms</code>属性以解决其他安全要求。但是，不建议删除任何当前算法或密钥大小。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   

</body></html>