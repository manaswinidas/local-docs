			<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
  	<title>gRPC 官方文档中文版_V1.0</title>
  	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<style>
		        body {
            color: #666666;
            font-family: 微软雅黑,Verdana,sans-serif,宋体;
            font-size: 14px;
            margin: 0;
            padding: 0;
        }
        a {
            color: #999999;
            text-decoration: none;
        }
        a:hover {
            color: #16B28F;
        }
        .sin_navi ul {
            list-style: none outside none;
            margin: 0;
            padding: 0 0 0 10px;
        }
        .sin_navi ul li {
            line-height: 30px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        li {
            line-height: 24px;
        }
        table {
            border-left: 1px solid #CCCCCC;
            border-top: 1px solid #CCCCCC;
            margin: 5px 10px;
            text-align: left;
            width: 678px;
        }
        table th {
            background-color: #EEEEEE;
            border-bottom: 1px solid #CCCCCC;
            border-right: 1px solid #CCCCCC;
            padding: 10px;
        }
        table td {
            border-bottom: 1px solid #CCCCCC;
            border-right: 1px solid #CCCCCC;
        }
        p {
            line-height: 24px;
            margin: 10px;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #111111;
            font-weight: normal;
            margin: 0;
            padding: 0;
        }
        h1 {
            font-size: 26px;
        }
        h2 {
            border-bottom: 1px dashed #CCCCCC;
            font-size: 24px;
            padding: 10px 0;
        }
        h3 {
            font-size: 20px;
            padding: 8px 0;
        }
        h4 {
            font-size: 18px;
            margin-left: 10px;
            padding: 5px 0;
        }
        h5 {
            font-size: 16px;
            margin-left: 10px;
            padding: 5px 0;
        }
        h6 {
            font-size: 16px;
            margin-left: 10px;
            padding: 5px 0;
        }
        blockquote {
            background: url("../../../img/blockquote.gif") no-repeat scroll left top #F4F5F7;
            margin: 5px 10px;
            padding: 10px 10px 10px 30px;
        }
        pre {
            background: none repeat scroll 0 0 #EEEEEE;
            margin: 5px 10px;
            padding: 10px;
        }
        .sin_callout {
            margin: 5px 10px;
        }
        .sin_header {
            background-color: #F7F7F7;
            border-bottom: 1px solid #CCCCCC;
            height: 80px;
            width: 100%;
        }
        .sin_title {
            margin: 0 auto;
            width: 1000px;
        }
        .sin_title_text {
            color: #000000;
            float: left;
            line-height: 80px;
        }
        .sin_version {
            color: #999999;
            float: left;
            font-size: 14px;
            padding-top: 25px;
            margin-left: 10px;
        }
        .sin_main {
            margin: 0 auto;
            width: 1000px;
        }
        .sin_navi {
            float: left;
            margin-bottom: 20px;
            overflow-y: scroll;
            padding: 0;
            position: relative;
            width: 279px;
            z-index: 1;
        }
        .sin_navi_nomove {
            position: fixed;
            top: 0;
        }
        .sin_navi_ca a {
            color: #333333;
        }
        .sin_navi_ca a:hover {
            color: #16B28F;
        }
        .sin_navi_current {
            border-right: 3px solid #16B28F;
        }
        .sin_navi_current a {
            color: #16B28F;
        }
        .sin_content {
            background-color: #FFFFFF;
            border-left: 1px solid #CCCCCC;
            float: left;
            margin-left: -20px;
            padding: 10px 20px;
            position: relative;
            width: 699px;
            z-index: 2;
        }
        .sin_content_mar {
            margin-left: 259px;
        }
        .sin_footer {
            border-top: 1px solid #CCCCCC;
            color: #999999;
            height: 80px;
            line-height: 80px;
            margin: 0 auto;
            text-align: center;
        }
        .sin_info {
            background: none repeat scroll 0 0 #FFFFCC;
            border: 1px solid #D5D4D4;
            border-radius: 4px 4px 4px 4px;
            color: #999999;
            margin: 10px 0;
            padding: 14px;
        }
        .sin_link_logo {
            color: #16B28F;
            font-size: 12px;
            margin-left: 10px;
        }
        .sin_text {
            margin-bottom: 10px;
        }
        .d_callout {
            margin-bottom: 10px;
        }
        .d_callout_info {
            background: none repeat scroll 0 0 #F4F8FA;
            border-left: 4px solid #5BC0DE;
            padding: 10px;
        }
        .d_callout_warn {
            background: none repeat scroll 0 0 #FCF8F2;
            border-left: 4px solid #F0AD4E;
            padding: 10px;
        }
        .d_callout_danger {
            background: none repeat scroll 0 0 #FDF7F7;
            border-left: 4px solid #D9534F;
            padding: 10px;
        }
        .d_callout_success {
            background: none repeat scroll 0 0 #F3F8F3;
            border-left: 4px solid #50AF51;
            padding: 10px;
        }
        .d_callout input {
            background-color: rgba(0, 0, 0, 0);
            font-size: 15px;
            margin-bottom: 5px;
            padding: 10px 5px 0 10px;
        }
        .d_callout textarea {
            background-color: rgba(0, 0, 0, 0);
        }
        .d_callout_icons a {
            color: #AAAAAA;
            margin-left: 10px;
        }
        a.d_callout_icon_info {
            color: #5BC0DE;
        }
        a.d_callout_icon_warn {
            color: #F0AD4E;
        }
        a.d_callout_icon_danger {
            color: #D9534F;
        }
        a.d_callout_icon_success {
            color: #50AF51;
        }
        .clear {
            clear: both;
        }

	</style>
</head>
<body>
	<div class="sin_header">
		<div class="sin_title">
			<h1 class="sin_title_text">gRPC 官方文档中文版</h1>
			<span class="sin_version">V1.0</span>
			<div class="clear"></div>
		</div>
		<div id="top_end"></div>
	</div>
	<div class="sin_main">
		<div class="sin_navi" id="sin_navi_id">
			<ul style="margin: 20px 0;">
				    																																													<li style="width: 246px;" id="navi_text_56831">
									<a href="#text_56831">
										前言
									</a>	
								</li>
																															<li class="sin_navi_ca" style="width: 246px;" id="navi_category_13407">
								<a href="#category_13407">
									指南
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_58008">
						<a href="#text_58008">
							概览
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_58009">
						<a href="#text_58009">
							gRPC概念
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_58010">
						<a href="#text_58010">
							安全认证
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_58011">
						<a href="#text_58011">
							通讯协议
						</a>	
					</li>
											</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_13408">
								<a href="#category_13408">
									教程
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_57966">
						<a href="#text_57966">
							C++教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60132">
						<a href="#text_60132">
							C# 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60133">
						<a href="#text_60133">
							Go 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60134">
						<a href="#text_60134">
							Java 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60135">
						<a href="#text_60135">
							Node 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60136">
						<a href="#text_60136">
							php 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60138">
						<a href="#text_60138">
							python 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60139">
						<a href="#text_60139">
							ruby 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_60140">
						<a href="#text_60140">
							objective-c 教程
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_61534">
						<a href="#text_61534">
							异步基础: C++
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_61535">
						<a href="#text_61535">
							在 gRPC 上使用 OAuth2: Objective-C
						</a>	
					</li>
											</ul>
																			</ul>
		</div>
		<div class="sin_content" id="sin_content_id">
																													<h2 id="text_56831" class="sin_target">前言</h2>
<div class="sin_text">
    					<h3>简介</h3>
<p><a href="http://www.oschina.net/p/grpc-framework" rel="nofollow">gRPC</a> 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.</p>
<p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p>
<p>《gRPC 官方文档中文版》原文出自《 <a href="http://www.grpc.io/docs/" rel="nofollow">gRPC Docs</a>》，由多位网友在开源中国众包平台协作翻译完成，其中：</p> 
<ul> 
 <li>Guides 部分由 <a href="http://my.oschina.net/altersoft" rel="nofollow">@sofeminer</a> 翻译</li> 
 <li>Tutorials 部分由 <a href="http://my.oschina.net/ivysummer" rel="nofollow">@马博文</a> 翻译</li> 
 <li>全部由 <a href="http://my.oschina.net/u/2350782" rel="nofollow">@jason0916</a> 校对</li> 
</ul>
<h3>反馈</h3>
<p>对《gRPC 官方文档中文版》有任何反馈，欢迎在以下网址评论：<br><a href="http://www.oschina.net/news/70391/grpc-docs-cn" rel="nofollow">http://www.oschina.net/news/70391/grpc-docs-cn</a></p>
<h3>版权</h3>
<p>《gRPC 官方文档中文版》由开源中国组织翻译，转载请注明出处，未经许可不得为其它商业目的使用。</p>
			</div>

																										<h2 id="category_13407">指南</h2>
																								<h3 id="text_58008" class="sin_target">概览</h3>
<div class="sin_text">
    					<h1>开始</h1>
<p>欢迎进入 gRPC 的开发文档，gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。<br>本文档通过快速概述和一个简单的 Hello World 例子来向您介绍 gRPC 。你可以在本站发现更详细的教程和参考文档——文档将会越来越丰富。</p>
<h2>快速开始</h2>
<p>为了直观地着手运行 gRPC，可以从你所选择的语言对应的快速开始入手，里面包含创建这个列子的安装指导、快速上手指南等更多内容。</p> 
<ul> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/cpp" rel="nofollow">C++</a></li> 
 <li><a href="https://github.com/grpc/grpc-java/tree/master/examples" rel="nofollow">Java</a></li> 
 <li><a href="https://github.com/grpc/grpc-go/tree/master/examples" rel="nofollow">Go</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/python" rel="nofollow">Python</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/ruby" rel="nofollow">Ruby</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/node" rel="nofollow">Node.js</a></li> 
 <li><a href="https://github.com/grpc/grpc-java/tree/master/examples/android" rel="nofollow">Android Java</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/csharp/helloworld" rel="nofollow">C#</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/objective-c/helloworld" rel="nofollow">Objective-C</a></li> 
 <li><a href="https://github.com/grpc/grpc/tree/master/examples/php" rel="nofollow">PHP</a></li> 
</ul>
<p>你可以从<a href="https://github.com/grpc/grpc" rel="nofollow">这里</a>找到 gRPC 的源码库。我们大多数例子都在源码库 examples 目录下。</p>
<h2>gRPC 是什么？</h2>
<p>在 gRPC 里*客户端*应用可以像调用本地对象一样直接调用另一台不同的机器上*服务端*应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个*服务*，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个*存根*能够像服务端一样的方法。</p>
<p><img src="http://www.grpc.io/img/grpc_concept_diagram_00.png" alt="图1"></p>
<p>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC <a href="http://www.oschina.net#quickstart" rel="nofollow">支持的语言</a>来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。此外，Google 最新 API 将有 gRPC 版本的接口，使你很容易地将 Google 的功能集成到你的应用里。</p>
<h3>使用 protocol buffers</h3>
<p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 <em>proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://www.oschina.net/https：//developers.google.com/protocol-buffers/docs/overview" rel="nofollow">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。</p>
<h4>Protocol buffers 版本</h4>
<p>尽管 protocol buffers 对于开源用户来说已经存在了一段时间，例子内使用的却一种名叫 proto3 的新风格的 protocol buffers，它拥有轻量简化的语法、一些有用的新功能，并且支持更多新语言。当前针对 Java 和 C++ 发布了 beta 版本，针对 JavaNano（即 Android Java）发布 alpha 版本，在<a href="http://www.oschina.net/https：//github.com/google/protobuf/releases" rel="nofollow">protocol buffers Github 源码库里</a>有 Ruby 支持， 在<a href="http://www.oschina.net/https：//github.com/golang/protobuf" rel="nofollow">golang/protobuf Github 源码库</a>里还有针对 Go 语言的生成器， 对更多语言的支持正在开发中。 你可以在 <a href="http://www.oschina.net/https：//developers.google.com/protocol-buffers/docs/proto3" rel="nofollow">proto3 语言指南</a>里找到更多内容， 在与当前默认版本的<a href="http://www.oschina.net/https：//github.com/google/protobuf/releases" rel="nofollow">发布说明</a>比较，看到两者的主要不同点。更多关于 proto3 的文档很快就会出现。虽然你*可以*使用 proto2 (当前默认的 protocol buffers 版本)， 我们通常建议你在 gRPC 里使用 proto3，因为这样你可以使用 gRPC 支持全部范围的的语言，并且能避免 proto2 客户端与 proto3 服务端交互时出现的兼容性问题，反之亦然。</p>
<h2>你好 gRPC!</h2>
<p>现在你已经对 gRPC 有所了解，了解其工作机制最简单的方法是看一个简单的例子。 Hello World 将带领你创建一个简单的客户端——服务端应用，向你展示：</p> 
<ul> 
 <li>通过一个 protocol buffers 模式，定义一个简单的带有 Hello World 方法的 RPC 服务。</li> 
 <li>用你最喜欢的语言(如果可用的话)来创建一个实现了这个接口的服务端。</li> 
 <li>用你最喜欢的(或者其他你愿意的)语言来访问你的服务端。</li> 
</ul>
<p>这个例子完整的代码在我们 GitHub 源码库的 <code>examples</code> 目录下。<br>我们使用 Git 版本系统来进行源码管理，但是除了如何安装和运行一些 Git 命令外，你没必要知道其他关于 Git 的任何事情。<br>需要注意的是，并不是所有 gRPC 支持的语言都可以编写我们例子的服务端代码，比如 PHP 和 Objective-C 仅支持创建客户端。<br>比起针对于特定语言的复杂教程，这更像是一个介绍性的例子。你可以在本站找到更有深度的教程，gRPC 支持的语言的参考文档很快就会全部开放。</p>
<h3>准备</h3>
<p>本节解释了如何在你本机上准备好例子代码的运行环境。如果你只是想读一下例子，你可以直接到下一步。</p>
<h4>安装 Git</h4>
<p>你可以从<a href="http://git-scm.com/download" rel="nofollow">http://git-scm.com/download</a>下载和安装 Git。安装好 Git 后，你应该能访问 git 命令行工具。你需要的主要命令如下：</p> 
<ul> 
 <li>git clone … ： 从远程代码库克隆一份到本机。</li> 
 <li>git checkout … ： 检出一个特殊分支或一个标签版本的代码来改进。</li> 
</ul>
<h4>安装 gRPC</h4>
<p>针对你选择的语言构建和安装 gRPC 插件和相关工具，可以参照<a href="http://www.oschina.net#quickstart" rel="nofollow">快速开始</a>。 Java gRPC 除了 JDK 外不需要其他工具。</p>
<h4>获得源码</h4> 
<ul> 
 <li>Java</li> 
</ul>
<p>Java 例子代码在 GitHub 源码库里。你可以运行如下命令克隆源码到本地：</p>
<p><code>git clone https：//github.com/grpc/grpc-java.git</code></p>
<p>切换当前目录到<code>grpc-java/examples</code></p>
<p><code>cd grpc-java/examples</code></p> 
<ul> 
 <li>C++</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code> $ git clone https：//github.com/grpc/grpc.git </code></p>
<p>切换当前目录到 <code>examples/cpp/helloworld</code></p>
<p><code> $ cd examples/cpp/helloworld/ </code></p> 
<ul> 
 <li>Python</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code> $ git clone https://github.com/grpc/grpc.git </code></p>
<p>切换当前目录到 <code>examples/python/helloworld</code></p>
<p><code> $ cd examples/python/helloworld/ </code></p> 
<ul> 
 <li>Go</li> 
</ul>
<p>获取例子：</p> 
<pre><code>$ go get -u github.com/grpc/grpc-go/examples/helloworld/greeter_client
$ go get -u github.com/grpc/grpc-go/examples/helloworld/greeter_server
</code></pre>
<p>切换当前目录到 <code>examples/helloworld</code></p> 
<ul> 
 <li>Ruby</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code> $ git clone https：//github.com/grpc/grpc.git </code></p>
<p>切换当前目录到 <code>examples/ruby</code> ，然后使用 bundler 安装例子的包依赖：</p> 
<pre><code>$ gem install bundler # if you don't already have bundler available
$ bundle install
</code></pre> 
<ul> 
 <li>Node.js</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code> $ git clone https：//github.com/grpc/grpc.git </code></p>
<p>切换当前目录到 <code>examples/node</code> ， 接着安装包依赖：</p> 
<pre><code>$ cd examples/node
$ npm install
</code></pre> 
<ul> 
 <li>C#</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code> $ git clone https：//github.com/grpc/grpc。git </code></p>
<p>从 Visual Studio (或 Linux 上的 Monodevelop ) 打开 <code>Greeter.sln</code>。可以从 <a href="http://www.oschina.net/docs/installation/csharp.html" rel="nofollow">C# Quickstart</a> 找到平台特定的设置步骤。</p> 
<ul> 
 <li>Objective-C</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p> 
<pre><code>$ git clone https：//github.com/grpc/grpc.git
$ cd grpc
$ git submodule update --init
</code></pre>
<p>切换当前目录到 <code>examples/objective-c/helloworld</code> 。</p> 
<ul> 
 <li>PHP</li> 
</ul>
<p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p>
<p><code>$ git clone https：//github.com/grpc/grpc.git</code></p>
<p>切换当前目录到 <code>examples/php</code> 。<br>虽然我们大多数例子使用同一个 .proto 文件，但 PHP 的例子有自己的 <code>helloworld.proto</code> 文件，这是因为它依赖 proto2 语法。 PHP暂时没有针对 proto3 的支持。</p>
<h3>定义服务</h3>
<p>创建我们例子的第一步是定义一个*服务*：一个 RPC 服务通过参数和返回类型来指定可以远程调用的方法。就像你在 [概览](#protocol buffers) 里所看到的， gRPC 通过 <a href="http://www.oschina.net/https：//developers.google.com/protocol-buffers/docs/overview" rel="nofollow">protocol buffers</a> 来实现。<br>我们使用 protocol buffers 接口定义语言来定义服务方法，用 protocol buffer 来定义参数和返回类型。客户端和服务端均使用服务定义生成的接口代码。<br>这里有我们服务定义的例子，在 <a href="http://www.oschina.net/https：//github.com/grpc/grpc-java/tree/master/examples/src/main/proto" rel="nofollow">helloworld.proto</a> 里用 protocol buffers IDL 定义的。<code>Greeter</code> 服务有一个方法 <code>SayHello</code> ，可以让服务端从远程客户端接收一个包含用户名的 <code>HelloRequest</code> 消息后，在一个 <code>HelloReply</code> 里发送回一个 <code>Greeter</code>。这是你可以在 gRPC 里指定的最简单的 RPC - 你可以在教程里找到针对你选择的语言更多类型的例子。</p> 
<pre><code>syntax = "proto3";

option java_package = "io.grpc.examples";

package helloworld;

// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

</code></pre>
<h3>生成 gRPC 代码</h3>
<p>一旦定义好服务，我们可以使用 protocol buffer 编译器 <code>protoc</code> 来生成创建应用所需的特定客户端和服务端的代码 - 你可以生成任意 gRPC 支持的语言的代码，当然 PHP 和 Objective-C 仅支持创建客户端代码。生成的代码同时包括客户端的存根和服务端要实现的抽象接口，均包含 <code>Greeter</code> 所定义的方法。</p>
<p>(假如你没有在系统里安装 gRPC 插件和 protoc ，并且仅仅是要看一下这个例子，你可以跳过这一步，直接到下一步来查看生成的代码。)</p> 
<ul> 
 <li><p>Java</p><p>这个例子的构建系统也是 Java gRPC 本身构建的一部分 —— 为了简单起见，我们推荐使用我们事先生成的例子代码。你可以参考 <a href="http://www.oschina.net/https：//github.com/grpc/grpc——java/blob/master/README.md" rel="nofollow">README</a> 来看一下如何从你自己的 .proto 文件生成代码。</p><p>这个例子事先生成的代码在 <a href="http://www.oschina.net/https：//github.com/grpc/grpc——java/tree/master/examples/src/generated/main" rel="nofollow">src/generated/main</a>下。<br>以下类包含所有我们需要创建这个例子所有的代码：</p> 
  <ul> 
   <li>HelloRequest.java， HelloResponse.java和其他文件包含所有 protocol buffer 用来填充、序列化和提取 <code>HelloRequest</code> 和 <code>HelloReply</code> 消息类型的代码。</li> 
   <li>GreeterGrpc.java， 包含 (还有其他有用的代码)：</li> 
  </ul> <pre><code>`Greeter` 服务端需要实现的接口
</code></pre></li> 
</ul> 
<pre><code>		public static interface Greeter {
    	public void sayHello(Helloworld.HelloRequest request,
        StreamObserver&lt;Helloworld.HelloReply&gt; responseObserver);
		}
</code></pre>
<p>客户端用来与 <code>Greeter</code> 服务端进行对话的 <code>存根</code> 类。就像你所看到的，异步存根也实现了 <code>Greeter</code> 接口。</p> 
<pre><code>	public static class GreeterStub extends AbstractStub&lt;GreeterStub&gt;
    implements Greeter {
  	...
	}
</code></pre> 
<ul> 
 <li><p>C++</p><p>生成客户端和服务端接口，运行：</p></li> 
</ul> 
<pre><code>$ make helloworld.grpc.pb.cc helloworld.pb.cc
</code></pre>
<p>这从内部调用 protocol buffer 编译器：</p> 
<pre><code>$ protoc -I ../../protos/ --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin ../../protos/helloworld.proto
$ protoc -I ../../protos/ --cpp_out=. ../../protos/helloworld.proto
</code></pre>
<p>生成：</p>
<p><code>helloworld.pb.h</code> 声明了用于填充、序列化、提取 <code>HelloRequest</code> 和 <code>HelloResponse</code> 消息类型的类，并且还有它的实现 <code>helloworld.pb.cc</code> 。</p>
<p><code>helloworld.grpc.pb.h</code>，声明了我们生成的服务类和它的实现 <code>helloworld.grpc.pb.cc</code> 。</p> 
<ul> 
 <li>Python</li> 
</ul>
<p>可以用如下命令生成客户端和服务端：</p> 
<pre><code>$ ./run_codegen.sh
</code></pre>
<p>这内部调用 protocol buffer 编译器：</p> 
<pre><code>$ protoc -I ../../protos --python_out=. --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_python_plugin` ../../protos/helloworld.proto
</code></pre>
<p>这生成了 <code>helloworld_pb2.py</code> ，包含我们生成的客户端和服务端类，此外还有用于填充、序列化、提取 <code>HelloRequest</code> 和 <code>HelloResponse</code> 消息类型的类。</p> 
<ul> 
 <li>Go</li> 
</ul>
<p>为了生成客户端和服务端接口，运行 protocol buffer 编译器：</p> 
<pre><code>protoc -I ../protos ../protos/helloworld.proto --go_out=plugins=grpc：helloworld
</code></pre>
<p>这生成了 <code>helloworld.pb.go</code> ，包含了我们生成的客户端和服务端类，此外还有用于填充、序列化、提取 <code>HelloRequest</code> 和 <code>HelloResponse</code> 消息类型的类。</p> 
<ul> 
 <li>Ruby</li> 
</ul>
<p>为了生成客户端和服务端接口，运行 protocol buffer 编译器：</p> 
<pre><code>protoc -I ../protos --ruby_out=lib --grpc_out=lib --plugin=protoc-gen-grpc=`which grpc_ruby_plugin` ../protos/helloworld.proto
</code></pre>
<p>在 <code>lib</code> 目录下生成了如下文件：</p> 
<ul> 
 <li><p><code>lib/helloworld.rb</code> 定义了一个 <code>Helloworld</code> 模块， 这个模块提供了用于填充、序列化、提取请求、应答消息类型的所有 protocol buffer 代码。</p></li> 
 <li><p><code>lib/helloworld_services.rb</code> 用生成的客户端和服务端代码继承了 <code>Helloworld</code> 模块。</p></li> 
</ul> 
<ul> 
 <li>Node.js</li> 
</ul>
<p>Node.js库从运行时加载的 .proto 文件动态生成服务描述和客户端存根的定义，所以使用此语言时没必要生成任何特殊代码。而是在例子客户端和服务端里，我们 <code>require</code> gRPC 库，然后用它的 <code>load()</code> 方法：</p> 
<pre><code>var grpc = require('grpc');
var hello_proto = grpc.load(PROTO_PATH).helloworld;
</code></pre> 
<ul> 
 <li><p>C#</p></li> 
 <li><p>为了生成 Windows 上的代码，我们使用来自 <code>Google.Protobuf</code> NuGet 包里的 <code>protoc.exe</code> 和来自 <code>Grpc.Tools</code> NuGet 包里的 <code>Grpc.Tools</code> ，这两个文件都在 <code>tools</code> 目录下。<br>一般你需要自己把 <code>Grpc.Tools</code> 包添加到解决方案，但在这个教程里，这一步已经为你做好了。你应该在 <code>examples/csharp/helloworld</code> 下执行以下命令：</p></li> 
</ul> 
<pre><code>  &gt; packages\Google.Protobuf.3.0.0-alpha4\tools\protoc.exe -I../../protos --csharp_out Greeter --grpc_out Greeter --plugin=protoc-gen-grpc=packages\Grpc.Tools.0.7.0\tools\grpc_csharp_plugin.exe ../../protos/helloworld.proto
</code></pre> 
<ul> 
 <li>在 Linux 或 OS X ，我们依赖通过 Linuxbrew 或者 Homebrew 安装的 <code>protoc</code> 和 <code>grpc_csharp_plugin</code> 。请在 route_guide 目录下运行这个命令：</li> 
</ul> 
<pre><code>  $ protoc -I../../protos --csharp_out Greeter --grpc_out Greeter --plugin=protoc-gen-grpc=`which grpc_csharp_plugin` ../../protos/helloworld.proto
</code></pre>
<p>根据你的 OS 运行合适的命令，在 Greeter 目录重新生成如下文件:</p> 
<ul> 
 <li><code>Greeter/Helloworld.cs</code> 定义了命名空间 <code>Helloworld</code><br> 它包含了所有用来填充、序列化、提取请求和应答消息类型的 protocol buffer 代码。</li> 
 <li><code>Greeter/HelloworldGrpc.cs</code>，提供了存根类和服务类，包括：</li> 
 <li>一个 <code>Greeter.IGreeter</code> 接口，可以在定义 RootGuide 服务实现的时候来继承它。</li> 
 <li>一个 <code>Greeter.GreeterClient</code> 类，可用来访问远程的 RouteGuide 实例。</li> 
 <li><p>Objective-c</p></li> 
</ul>
<p>为了简单，我们提供了一个 <a href="http://www.oschina.net/https：//github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/HelloWorld.podspec" rel="nofollow">Podspec 文件</a>，用来使用适当的插件、输入、输出运行 protoc ，并描述如何编译生成的代码。你仅仅需要在 <code>examples/objective-c/route_guide</code> 下运行：</p> 
<pre><code>	$ pod install
</code></pre>
<p>然后你可以打开由 Cocoapods 创建的 XCode 工作空间，看一下生成的代码。运行命令生成：</p> 
<pre><code>- `Helloworld.pbobjc.h`， 定义生成的消息类的头文件。
- `Helloworld.pbobjc.m`，包含消息类的实现。
- `Helloworld.pbrpc.h`，定义生成的服务类的头文件。
- `Helloworld.pbrpc.m`，包含服务类的实现。
</code></pre> 
<ul> 
 <li><p>PHP</p><p>gRPC PHP 使用 <a href="http://www.oschina.net/https：//github.com/datto/protobuf-php" rel="nofollow">protoc-gen-php</a> 工具来从 .proto 文件生成代码。你可以在 <a href="http://www.oschina.net/https：//github.com/grpc/grpc/blob/master/src/php" rel="nofollow">PHP 快速开始</a>里找到如何安装它。为了生成 Greeter 服务的代码，运行：</p> <pre><code>protoc-gen-php -i . -o . ./helloworld.proto
</code></pre><p>生成 <code>helloworld.php</code> ，包含：</p> 
  <ul> 
   <li>所有用来填充、序列化、提取请求和应答消息类型的 protocol buffer 代码.</li> 
   <li><code>GreeterClient</code> 类，可以让客户端调用在 <code>Greeter</code> 服务里的方法。</li> 
  </ul></li> 
</ul>
<h3>写一个服务器</h3>
<p>现在让我们写点代码！首先我们将创建一个服务应用来实现服务(你会记起来，我们可以是使用除了Objective-C and PHP 外的其他所有语言来实现)。在本节，我们不打算对如何创建一个服务端进行更深入地探讨 —— 更详细的信息可以在你选择语言对应的教程里找到。</p>
<h4>服务实现</h4> 
<ul> 
 <li><p>Java</p><p><a href="http://www.oschina.net/https：//github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java#L51" rel="nofollow">GreeterImpl.java</a> 准确地实现了 <code>Greeter</code> 服务所需要的行为。<br>正如你所见，<code>GreeterImpl</code> 类通过实现 <code>sayHello</code> 方法，实现了从 <a href="http://www.oschina.net/https：//github.com/grpc/grpc-java/tree/master/examples/src/main/proto" rel="nofollow">IDL</a> 生成的<code>GreeterGrpc.Greeter</code> 接口 。</p> <pre><code>@Override
public void sayHello(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) {
  HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();
  responseObserver.onNext(reply);
  responseObserver.onCompleted();
}
</code></pre><p><code>sayHello</code> 有两个参数：</p> 
  <ul> 
   <li><code>HelloRequest</code>，请求。</li> 
   <li><code>StreamObserver&lt;HelloReply&gt;</code>： 应答观察者，一个特殊的接口，服务器用应答来调用它。</li> 
  </ul><p>为了返回给客户端应答并且完成调用：</p> 
  <ol> 
   <li>用我们的激动人心的消息构建并填充一个在我们接口定义的 <code>HelloReply</code> 应答对象。</li> 
   <li>将 <code>HelloReply</code> 返回给客户端，然后表明我们已经完成了对 RPC 的处理。</li> 
  </ol></li> 
</ul> 
<ul> 
 <li><p>C++</p><p><a href="http://www.oschina.net/https：//github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_server.cc" rel="nofollow">greeter_server.cc</a> 实现了 <code>Greeter</code> 服务所需要的行为。<br>正如你所见，<code>GreeterServiceImpl</code> 类通过实现 <code>sayHello</code> 方法，实现了从 proto 服务定义生成的<code>Greeter：：Service</code> 接口 。</p> <pre><code>class GreeterServiceImpl final ： public Greeter：：Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
              HelloReply* reply) override {
std：：string prefix("Hello ");
reply-&gt;set_message(prefix + request-&gt;name());
return Status：：OK;
  }
};
</code></pre><p>在此我们实现同步版本的 <code>Greeter</code>，它提供了默认的 gRPC 服务行为（这里也有一个异步的接口，<code>Greeter：：AsyncService</code>）。</p><p>sayHello 有三个参数：</p> 
  <ul> 
   <li><code>ServerContext</code>： RPC上下文对象。</li> 
   <li><code>HelloRequest</code> ： 请求。</li> 
   <li><code>HelloReply</code> ：应答。</li> 
  </ul><p>为了返回给客户端应答并且完成调用：</p> 
  <ol> 
   <li>用我们的激动人心的消息构建并填充一个在我们接口定义的 <code>HelloReply</code> 应答对象。</li> 
   <li>将 <code>Status::OK</code> 返回给客户端，表明我们已经完成了对 RPC 的处理。</li> 
  </ol></li> 
</ul> 
<ul> 
 <li><p>Python</p><p><a href="http://www.oschina.net/https：//github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_server.py" rel="nofollow">greeter_server.py</a> 实现了 <code>Greeter</code> 服务所需要的行为。<br>正如你所见，<code>Greeter</code> 类通过实现 <code>sayHello</code> 方法，实现了从 proto 服务定义生成的<code>helloworld_pb2.BetaGreeterServicer</code> 接口：</p><p>```<br> class Greeter(helloworld_pb2.BetaGreeterServicer)：</p></li> 
</ul>
<p>def SayHello(self, request, context)：<br> return helloworld_pb2.HelloReply(message=‘Hello, %s!’ % request.name)<br> </p>
<pre><code><br>	为了返回给客户端应答并且完成调用：

	1.  用我们的激动人心的消息构建并填充一个在我们接口定义的 `HelloReply` 应答对象。
	2.  将 `HelloReply` 返回给客户端。

- Go

	[greeter_server/main.go](https：//github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go) 实现了 `Greeter` 服务所需要的行为。
正如你所见，服务器有一个 `server` 结构。它通过实现 `sayHello` 方法，实现了从 proto 服务定义生成的`GreeterServer` 接口：

	</code></pre>
<br>// server is used to implement helloworld.GreeterServer.
<br>type server struct{}
<br>// SayHello implements helloworld.GreeterServer
<br>func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
<br> return &amp;pb.HelloReply{Message： “Hello ” + in.Name}, nil
<br>}
<br> 
<pre><code><br>	为了返回给客户端应答并且完成调用：

	1. 用我们的激动人心的消息构建并填充一个在我们接口定义的 `HelloReply` 应答对象。
	2.	将 `HelloReply` 返回给客户端。

- Ruby

	[greeter_server.rb](https：//github.com/grpc/grpc/blob/master/examples/ruby/greeter_server.rb) 实现了 `Greeter` 服务所需要的行为。
	服务器有一个 `GreeterServer ` 类，它通过实现 `sayHello` 方法，实现了从 proto 服务定义生成的`GreeterServer` 接口：

	</code></pre>
<br>class GreeterServer &lt; Helloworld：：Greeter：：Service
<br> # say_hello implements the SayHello rpc method.
<br> def say_hello(hello_req, 
<em>unused_call)<br> Helloworld：：HelloReply.new(message： “Hello #{hello_req.name}”)<br> end<br> <pre><code><br>为了返回给客户端应答并且完成调用：我们用激动人心的消息构建并填充一个在我们接口定义的 `HelloReply` 应答对象，然后返回它。

- Node.js

	[greeter_server.js](https：//github.com/grpc/grpc/blob/master/examples/node/greeter_server.js) 实现了 `Greeter` 服务所需要的行为。
	服务器通过实现 `SayHello` 方法，实现了服务定义：

	</code></pre><br>function sayHello(call, callback) {<br> callback(null, {message： ‘Hello ’ + call.request.name});<br>}<br> <pre><code><br>为了返回给客户端应答并完成调用，我们填充了应答并将其传递给一个已提供了的回调，用 null 作为第一个参数来表示没有出现错误。

- C#

	[GreeterServer/Program.cs](https：//github.com/grpc/grpc/blob/master/examples/csharp/helloworld/GreeterServer/Program.cs) 实现了 `Greeter` 服务所需要的行为。
	服务器的 `GreeterImpl`类，通过实现 `sayHello` 方法，实现了生成的`IGreeter` 接口：

	</code></pre><br>class GreeterImpl ： Greeter.IGreeter<br>{<br> public Task SayHello(HelloRequest request, ServerCallContext context)<br> {<br> return Task.FromResult(new HelloReply { Message = “Hello ” + request.Name });<br> }<br>}<br> <pre><code><br>为了返回给客户端应答并完成以下调用：

	1. 用我们的激动人心的消息构建并填充一个在我们接口定义的 `HelloReply` 应答对象。
	2. 将 `HelloReply` 返回给客户端。

#### 服务端实现
需要提供一个 gRPC 服务的另一个主要功能是让这个服务实在在网络上可用。

- Java

	[HelloWorldServer.java](https：//github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java) 提供了以下代码作为 Java 的例子。

	</code></pre><br>/* The port on which the server should run <em>/<br>private int port = 50051;<br>private Server server;<br>private void start() throws Exception {<br> server = ServerBuilder.forPort(port)<br> .addService(GreeterGrpc.bindService(new GreeterImpl()))<br> .build()<br> .start();<br> logger.info(“Server started, listening on ” + port);<br> Runtime.getRuntime().addShutdownHook(new Thread() {<br> @Override<br> public void run() {<br> // Use stderr here since the logger may has been reset by its JVM shutdown hook.<br> System.err.println(“<strong>* shutting down gRPC server since JVM is shutting down“);<br> HelloWorldServer.this.stop();<br> System.err.println(”</strong>* server shut down”);<br> }<br> });<br>}<br> <pre><code><br><br>- C++

	[greeter_server.cc](https：//github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_server.cc) 提供了以下代码作为 C++ 的例子。

	</code></pre><br>void RunServer() {<br> std：：string server_address(“0.0.0.0：50051”);<br> GreeterServiceImpl service;<br> ServerBuilder builder;<br> builder.AddListeningPort(server_address, grpc：：InsecureServerCredentials());<br> builder.RegisterService(&amp;service);<br> std：：unique_ptr server(builder.BuildAndStart());<br> std：：cout &lt;&lt; “Server listening on ” &lt;&lt; server_address &lt;&lt; std：：endl;<br> server-&gt;Wait();<br>}<br> <pre><code><br>  
- Python
  
	[greeter_server.py](https：//github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_server.py) 提供了以下代码作为 Python 的例子。

	</code></pre><br> server = helloworld_pb2.beta_create_Greeter_server(Greeter())<br> server.add_insecure_port(‘[：：]：50051’)<br> server.start()<br> try：<br> while True：<br> time.sleep(_ONE_DAY_IN_SECONDS)<br> except KeyboardInterrupt：<br> server.stop()<br> <pre><code><br><br>- Go

	[greeter_server/main.go](https：//github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go) 提供了以下代码作为 Go 的例子。

	</code></pre><br>const (<br> port = “：50051”<br>)<br>…<br>func main() {<br> lis, err ：= net.Listen(“tcp”, port)<br> if err != nil {<br> log.Fatalf(“failed to listen： %v”, err)<br> }<br> s ：= grpc.NewServer()<br> pb.RegisterGreeterServer(s, &amp;server{})<br> s.Serve(lis)<br>}<br> <pre><code><br><br>  
- Ruby

	[greeter_server.rb](https：//github.com/grpc/grpc/blob/master/examples/ruby/greeter_server.rb) 提供了以下代码作为 Ruby 的例子。

	</code></pre><br>def main<br> s = GRPC：：RpcServer.new<br> s.add_http2_port(‘0.0.0.0：50051’)<br> s.handle(GreeterServer)<br> s.run<br>end<br> <pre><code><br><br>  
- Node.js

	[greeter_server.js](https：//github.com/grpc/grpc/blob/maser/examples/node/greeter_server.js) 提供了以下代码作为 Ruby 的例子。

	</code></pre><br>function main() {<br> var server = new Server({<br> “helloworld.Greeter”： {<br> sayHello： sayHello<br> }<br> });<br> server.bind(‘0.0.0.0：50051’);<br> server.listen();<br>}<br> <pre><code><br><br>  
- C#

	[GreeterServer/Program.cs](https：//github.com/grpc/grpc/blob/master/examples/csharp/helloworld/GreeterServer/Program.cs) 提供了以下代码作为 C# 的例子。

	</code></pre><br>Server server = new Server<br>{<br> Services = { Greeter.BindService(new GreeterImpl()) },<br> Ports = { new ServerPort(“localhost”, 50051, ServerCredentials.Insecure) }<br>};<br>server.Start();<br> <pre><code><br>  
在这里我们创建了合理的 gRPC 服务器，将我们实现的 `Greeter` 服务绑定到一个端口。然后我们启动服务器：服务器现在已准备好从 `Greeter` 服务客户端接收请求。我们将在具体语言对应的文档里更深入地了解这所有的工作是怎样进行的。



### 写一个客户端

客户端的 gRPC 非常简单。在这一步，我们将用生成的代码写一个简单的客户程序来访问我们在上一节里创建的 `Greeter` 服务器。
同样，我们也不打算对如何实现一个客户端程序深入更多，我们把这些内容放到教程里。

#### 连接服务

首先我们看一下我们如何连接 `Greeter` 服务器。我们需要创建一个 gRPC 频道，指定我们要连接的主机名和服务器端口。然后我们用这个频道创建存根实例。

- Java

	</code></pre><br>private final ManagedChannel channel;<br>private final GreeterGrpc.GreeterBlockingStub blockingStub;<br>public HelloWorldClient(String host, int port) {<br> channel = ManagedChannelBuilder.forAddress(host, port)<br> .usePlaintext(true)<br> .build();<br> blockingStub = GreeterGrpc.newBlockingStub(channel);<br>}<br> <pre><code><br><br>	在这个例子里，我们创建了一个阻塞的存根。这意味着 RPC 调用要等待服务器应答，将会返回一个应答或抛出一个异常。 gRPC Java 还可以有其他种类的存根，可以向服务器发出非阻塞的调用，这种情况下应答是异步返回的。

- C++

	</code></pre><br>int main(int argc, char</em>* argv) {<br> GreeterClient greeter(<br> grpc：：CreateChannel(“localhost：50051”, grpc：：InsecureCredentials(),<br> ChannelArguments()));<br>…<br>}<br>…<br>class GreeterClient {<br> public：<br> GreeterClient(std：：shared_ptr channel)<br> ： stub</em>(Greeter：：NewStub(channel)) {}
<br>…
<br> private：
<br> std：：unique_ptr&lt;Greeter：：Stub&gt; stub_;
<br>};
<br> 
<pre><code><br><br>  
- Python

	生成的 Python 代码有一个根据频道创建存根的帮助方法。
	</code></pre>
<br>channel = implementations.insecure_channel(‘localhost’, 50051)
<br>stub = helloworld_pb2.beta_create_Greeter_stub(channel)
<br>…
<br> 
<pre><code><br> 
- Go

	</code></pre>
<br>const (
<br> address = “localhost：50051”
<br> defaultName = “world”
<br>)
<br>func main() {
<br> // Set up a connection to the server.
<br> conn, err ：= grpc.Dial(address)
<br> if err != nil {
<br> log.Fatalf(“did not connect： %v”, err)
<br> }
<br> defer conn.Close()
<br> c ：= pb.NewGreeterClient(conn)
<br>…
<br>}
<br> 
<pre><code><br><br>	在 gRPC Go 你是使用一个特殊的 Dial() 方法来创建频道。

- Ruby

	`stub = Helloworld：：Greeter：：Stub.new('localhost：50051')`

	在 Ruby 里，我们可以在一个方法里调用从 .proto 文件里生成的存根类。

- Node.js

	`var client = new hello_proto.Greeter('localhost：50051');`
	
	在 Node.js ，我们可以在一步调用 `Greeter` 存根构造器。

- C#

	</code></pre>
<br>Channel channel = new Channel(“127.0.0.1：50051”, Credentials.Insecure);
<br>var client = Greeter.NewClient(channel);
<br>…
<br> 
<pre><code><br>  
- Objective-C

	在 Objective-C 里，我们可以用生成的 `HLWGreeter` 类指定的初始化方法完成，这个方法需要用`NSString *` 类型表示的服务器和端口作为参数。

	</code></pre>
<p></p>
<h1>import &lt;GRPCClient/GRPCCall+Tests.h&gt;</h1>
<p>…<br>static NSString * const kHostAddress = @“localhost：50051”;<br>…<br>[GRPCCall useInsecureConnectionsForHost：kHostAddress];<br>HLWGreeter *client = [[HLWGreeter alloc] initWithHost：kHostAddress];<br> </p>
<pre><code><br><br>	当用给定的 host：port 对通讯的时候，注意对 `useInsecureConnectionsForHost：` 的调用，要通知 gRPC 库使用明文 (而不是 TLS 加密的连接)。
  
- PHP

	</code></pre>
<br>$client = new helloworld\GreeterClient(
<br> new Grpc\BaseStub(‘localhost：50051’, []));
<br> 
<pre><code><br><br>	在 PHP 里，我们可以使用 `GreeterClient` 类的构造器一步完成。
  



#### 调用 RPC
现在我们可以联系服务并获得一个 greeting ：

1. 我们创建并填充一个 `HelloRequest` 发送给服务。
2. 我们用请求调用存根的 `SayHello()`，如果 RPC 成功，会得到一个填充的 `HelloReply` ，从其中我们可以获得 greeting。


- Java

	</code></pre>
<br>HelloRequest req = HelloRequest.newBuilder().setName(name).build();
<br>HelloReply reply = blockingStub.sayHello(req);
<br> 
<pre><code><br><br>	你可以在 [HelloWorldClient.java](https：//github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldClient.java) 里查看完整的客户端代码。

- C++

	</code></pre>
<br> std：：string SayHello(const std：：string&amp; user) {
<br> HelloRequest request;
<br> request.set_name(user);
<br> HelloReply reply;
<br> ClientContext context;
<br> Status status = stub_-&gt;SayHello(&amp;context, request, &amp;reply);
<br> if (status.ok()) {
<br> return reply.message();
<br> } else {
<br> return “Rpc failed”;
<br> }
<br> }
<br> 
<pre><code><br><br>	你可以在 [greeter_client.cc](https：//github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_client.cc) 里查看完整的客户端代码。

- Python
 
	</code></pre>
<br>response = stub.SayHello(helloworld_pb2.HelloRequest(name=‘you’), _TIMEOUT_SECONDS)
<br>print “Greeter client received： ” + response.message
<br> 
<pre><code><br>	你可以在 [greeter_client.py](https：//github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_client.py) 里查看完整的客户端代码。


- Go

	</code></pre>
<br>r, err ：= c.SayHello(context.Background(), &amp;pb.HelloRequest{Name： name})
<br>if err != nil {
<br> log.Fatalf(“could not greet： %v”, err)
<br>}
<br>log.Printf(“Greeting： %s”, r.Message)
<br> 
<pre><code><br><br>	你可以在 [greeter_client/main.go](https：//github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go) 里查看完整的客户端代码。

- Ruby
</code></pre>
<br> message = stub.say_hello(Helloworld：：HelloRequest.new(name： user)).message
<br> p “Greeting： #{message}”
<br> 
<pre><code><br><br>   你可以在 [greeter_client.rb](https：//github.com/grpc/grpc/blob/master/examples/ruby/greeter_client.rb) 里查看完整的客户端代码。

- Node.js


</code></pre>
<br> client.sayHello({name： user}, function(err, response) {
<br> console.log(‘Greeting：’, response.message);
<br> });
<br> 
<pre><code><br> 
   你可以在 [/examples/node/greeter_client.js](https：//github.com/grpc/grpc/blob/master/examples/node/greeter_client.js) 里查看完整的客户端代码。 


- C#

	</code></pre>
<br>var reply = client.SayHello(new HelloRequest { Name = user });
<br>Console.WriteLine(“Greeting： ” + reply.Message);
<br> 
<pre><code><br><br> 	你可以在 [GreeterClient/Program.cs](https：//github.com/grpc/grpc/blob/master/examples/csharp/helloworld/GreeterClient/Program.cs) 里查看完整的客户端代码。
  
- Objective-C

	</code></pre>
<br>HLWHelloRequest *request = [HLWHelloRequest message];
<br>request.name = @“Objective-C”;
<br>[client sayHelloWithRequest：request handler：^(HLWHelloReply *response, NSError *error) {
<br> NSLog(@“%@”, response.message);
<br>}];
<br> 
<pre><code><br><br>	 你可以在 [examples/objective-c/helloworld](https：//github.com/grpc/grpc/tree/master/examples/objective-c/helloworld) 里查看完整的客户端代码。
 
- PHP

</code></pre>
<br> $request = new helloworld\HelloRequest();
<br> $request-&gt;setName($name);
<br> list($reply, $status) = $client-&gt;SayHello($request)-&gt;wait();
<br> $message = $reply-&gt;getMessage();
<br> 
<pre><code><br><br>   你可以在[greeter_client.php](https：//github.com/grpc/grpc/blob/master/examples/php/greeter_client.php) 里查看完整的客户端代码。


### 试一下!
你可以尝试用同一个语言在客户端和服务端构建并运行例子。或者你可以尝试 gRPC 最有用的一个功能 - 不同的语言间的互操作性，即在不同的语言运行客户端和服务端。每个服务端和客户端使用从同一过 proto 文件生成的接口代码，则意味着任何 `Greeter` 客户端可以与任何 `Greeter` 服务端对话。

- Java
	首先运行服务端：

	你可以从 `examples` 目录构建并运行服务端。首先构建客户端和服务端：

	`
$ ../gradlew -PskipCodegen=true installDist
	`

然后运行服务端，服务端将监听 50051 ：
	`
$ ./build/install/grpc-examples/bin/hello-world-server
	`
	
- C++

	你可以从 `examples/cpp/helloworld` 目录下构建并运行服务端。首先构建客户端和服务端：

	`$ make`

	然后运行服务端，服务端将监听 50051 ：

	`$ ./greeter_server`
  
- Python
	你可以用如下命令到 `examples/python/helloworld` 下运行服务端：

	`$ ./run_server.sh`


- Go

	你可以用如下命令到 `examples/helloworld` 下运行服务端：

	`$ greeter_server &amp;`

  
- Ruby

	你可以用如下命令到 `examples/ruby` 下运行服务端：

	`$ bundle exec ./greeter_server.rb &amp;`

  
- Node.js
	你可以用如下命令到 `examples/node` 下运行服务端：

	`$ node ./greeter_server.js &amp;`

- C#
	构建解决方案，然后到 `examples/csharp` ：


</code></pre>
<p></p> 
<blockquote>
 <p>cd GreeterServer/bin/Debug<br>GreeterServer.exe<br>```</p> 
</blockquote>
<p>一旦服务器在运行，在其他的终端窗口运行客户端并确认它收到一个消息。</p> 
<ul> 
 <li><p>Java</p><p>你可以在 <code>examples</code> 目录下构建并运行客户端。假如你还没有构建客户端，可以使用如下命令：</p><p><code> $ ../gradlew -PskipCodegen=true installDist </code></p></li> 
</ul>
<p>然后运行客户端：<br> <code> $ ./build/install/grpc-examples/bin/hello-world-client </code><br>- C++<br> 你可以在 <code>examples/cpp/helloworld</code> 目录下构建并运行客户端。假如你还没有构建客户端，可以使用如下命令：</p> 
<pre><code>`$ make`
然后运行客户端：
`$ ./greeter_client`
</code></pre> 
<ul> 
 <li><p>Python</p><p>你可以从<code>examples/python/helloworld</code>目录下用如下命令运行客户端：<br><code>$ ./run_client.sh</code></p></li> 
 <li><p>Go</p><p>你可以从<code>examples/helloworld</code>目录下用如下命令运行客户端：</p><p><code>$ greeter_client</code></p></li> 
</ul> 
<ul> 
 <li><p>Ruby</p><p>你可以从<code>examples/node</code>目录下用如下命令运行客户端：<br><code>$ bundle exec ./greeter_client.rb</code></p></li> 
 <li><p>Node.js </p><p>你可以从<code>examples/node</code>目录下用如下命令运行客户端：</p><p><code>$ node ./greeter_client.js</code></p></li> 
 <li><p>C#</p><p>构建解决方案，然后从 <code>examples/csharp</code> 目录：</p> <pre><code>&gt; cd GreeterClient/bin/Debug
&gt; GreeterClient.exe
</code></pre></li> 
 <li><p>Objective-C</p><p>打开由Cocoapods 创建的 XCode 工作空间，运行应用，你可以在 XCode 的控制台日志里看到结果。</p></li> 
 <li><p>PHP</p><p>你可以从 <code>examples/php</code> 目录运行客户端 ：</p> <pre><code>$ ./run_greeter_client.sh
</code></pre></li> 
</ul>
<h2>更多资料!</h2> 
<ul> 
 <li>从<a href="http://www.oschina.net#quickstart" rel="nofollow">快速开始</a>找到如何安装 gRPC 并从每个语言开始 。</li> 
 <li>按照你喜欢的语言对应教程来学习。</li> 
 <li>从<a href="http://www.oschina.net/docs/guides/concepts.html" rel="nofollow"> gRPC 概念</a>发现更多包括 RPC 生命周期，同步、异步调用，过期时间等内容。</li> 
 <li>读一下 <a href="http://www.oschina.net/docs/guides/wire.html" rel="nofollow">HTTP2协议上的 gRPC</a> 里的详细描述</li> 
 <li><a href="http://www.oschina.net/docs/guides/auth.html" rel="nofollow"> gRPC 认证支持</a>里则介绍了 gRPC 对认证支持的机制和例子。</li> 
</ul>
			</div>

																						<h3 id="text_58009" class="sin_target">gRPC概念</h3>
<div class="sin_text">
    					<h1>gRPC 概念</h1>
<p>本文档通过对于 gRPC 的架构和 RPC 生命周期的概览来介绍 gRPC 的主要概念。本文是在假设你已经读过文档部分的前提下展开的。针对具体语言细节请查看对应语言的快速开始、教程和参考文档（很快就会有完整的文档）。</p>
<h2>概览</h2>
<h3>服务定义</h3>
<p>正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 <a href="https://developers.google.com/protocol-buffers/" rel="nofollow">protocol buffers</a> 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案。<br> </p>
<pre><code><br>service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  required string greeting = 1;
}

message HelloResponse {
  required string reply = 1;
}
</code></pre>
<p></p>
<p>gRPC 允许你定义四类服务方法：</p> 
<ul> 
 <li>单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</li> 
</ul> 
<pre><code>rpc SayHello(HelloRequest) returns (HelloResponse){
}
</code></pre> 
<ul> 
 <li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li> 
</ul> 
<pre><code>rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse){
}
</code></pre> 
<ul> 
 <li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li> 
</ul> 
<pre><code>rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) {
}
</code></pre> 
<ul> 
 <li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li> 
</ul> 
<pre><code>rpc BidiHello(stream HelloRequest) returns (stream HelloResponse){
}
</code></pre>
<p>我们将在下面 RPC 生命周期章节里看到各类 RPC 的技术细节。</p>
<h3>使用 API 接口</h3>
<p>gRPC 提供 protocol buffer 编译插件，能够从一个服务定义的 .proto 文件生成客户端和服务端代码。通常 gRPC 用户可以在服务端实现这些API，并从客户端调用它们。</p> 
<ul> 
 <li>在服务侧，服务端实现服务接口，运行一个 gRPC 服务器来处理客户端调用。gRPC 底层架构会解码传入的请求，执行服务方法，编码服务应答。</li> 
 <li>在客户侧，客户端有一个*存根*实现了服务端同样的方法。客户端可以在本地存根调用这些方法，用合适的 protocol buffer 消息类型封装这些参数— gRPC 来负责发送请求给服务端并返回服务端 protocol buffer 响应。</li> 
</ul>
<h3>同步 vs 异步</h3>
<p>同步 RPC 调用一直会阻塞直到从服务端获得一个应答，这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的。</p>
<p>在多数语言里，gRPC 编程接口同时支持同步和异步的特点。你可以从每个语言教程和参考文档里找到更多内容(很快就会有完整文档)。</p>
<h2>RPC 生命周期</h2>
<p>现在让我们来仔细了解一下当 gRPC 客户端调用 gRPC 服务端的方法时到底发生了什么。我们不究其实现细节，关于实现细节的部分，你可以在我们的特定语言页面里找到更为详尽的内容。</p>
<h3>单项 RPC</h3>
<p>首先我们来了解一下最简单的 RPC 形式：客户端发出单个请求，获得单个响应。</p> 
<ul> 
 <li>一旦客户端通过桩调用一个方法，服务端会得到相关通知 ，通知包括客户端的元数据，方法名，允许的响应期限（如果可以的话）</li> 
 <li>服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用。</li> 
 <li>一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端 。</li> 
 <li>假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用。</li> 
</ul>
<h3>服务端流式 RPC</h3>
<p>服务端流式 RPC 除了在得到客户端请求信息后发送回一个应答流之外，与我们的简单例子一样。在发送完所有应答后，服务端的状态详情(状态码和可选的状态信息)和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作。</p>
<h3>客户端流式 RPC</h3>
<p>客户端流式 RPC 也基本与我们的简单例子一样，区别在于客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（但并不必须）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据。</p>
<h3>双向流式 RPC</h3>
<p>双向流式 RPC ，调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间。服务端可以选择发送回它的初始元数据或等待客户端发送请求。<br>下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写 - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像“乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p>
<h3>截止时间</h3>
<p>gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回<code>DEADLINE_EXCEEDED</code>错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法。<br>各语言来指定一个截止时间的方式是不同的 - 比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间。</p>
<h3>RPC 终止</h3>
<p>在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束(“我已经返回了所有应答!”)，到那时在客户端可能是失败的(“应答在最后期限后才来到!”)。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了。</p>
<h3>取消 RPC</h3>
<p>无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它*不是*一个“撤销”， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用。</p>
<h3>元数据集</h3>
<p>元数据是一个特殊 RPC 调用对应的信息(<a href="http://www.oschina.net/docs/guides/auth.html" rel="nofollow">授权详情</a>]) ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串(当然也可以是二进制数据)。元数据对 gRPC 本事来说是不透明的 - 它让客户端提供调用相关的信息给服务端，反之亦然。<br>对于元数据的访问是语言相关的。</p>
<h3>流控制</h3>
<p>TBD</p>
<h3>配置</h3>
<p>TBD</p>
<h3>频道</h3>
<p>在创建客户端存根时，一个 gRPC 频道提供一个特定主机和端口服务端的连接。客户端可以通过指定频道参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个频道具有状态，包含<code>已连接</code>和<code>空闲</code> 。<br>gRPC 如何处理关闭频道是语言相关的。有些语言可允许询问频道状态。</p>
			</div>

																						<h3 id="text_58010" class="sin_target">安全认证</h3>
<div class="sin_text">
    					<h1>认证</h1>
<p>gRPC 被设计成可以利用插件的形式支持多种授权机制。本文档对多种支持的授权机制提供了一个概览，并且用例子来论述对应API，最后就其扩展性作了讨论。<br>马上将会推出更多文档和例子。</p>
<h1>支持的授权机制</h1>
<h2>SSL/TLS</h2>
<p>gRP 集成 SSL/TLS 并对服务端授权所使用的 SSL/TLS 进行了改良，对客户端和服务端交换的所有数据进行了加密。对客户端来讲提供了可选的机制提供凭证来获得共同的授权。</p>
<h2>OAuth 2.0</h2>
<p>gRPC 提供通用的机制（后续进行描述）来对请求和应答附加基于元数据的凭证。当通过 gRPC 访问 Google API 时，会为一定的授权流程提供额外的获取访问令牌的支持，这将通过以下代码例子进行展示。<br><em>警告</em>：Google OAuth2 凭证应该仅用于连接 Google 的服务。把 Google 对应的 OAuth2 令牌发往非 Google 的服务会导致令牌被窃取用作冒充客户端来访问 Google 的服务。</p>
<h2>API</h2>
<p>为了减少复杂性和将混乱最小化， gRPC 以一个统一的凭证对象来进行工作。<br>凭证可以是以下两类：</p> 
<ul> 
 <li><em>频道凭证</em>, 被附加在 <code>频道</code>上， 比如 SSL 凭证。</li> 
 <li><em>调用凭证</em>, 被附加在调用上(或者 C++ 里的 <code>客