			<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
  	<title>Reactor 指南中文版_V2.0</title>
  	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<style>
		        body {
            color: #666666;
            font-family: 微软雅黑,Verdana,sans-serif,宋体;
            font-size: 14px;
            margin: 0;
            padding: 0;
        }
        a {
            color: #999999;
            text-decoration: none;
        }
        a:hover {
            color: #16B28F;
        }
        .sin_navi ul {
            list-style: none outside none;
            margin: 0;
            padding: 0 0 0 10px;
        }
        .sin_navi ul li {
            line-height: 30px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        li {
            line-height: 24px;
        }
        table {
            border-left: 1px solid #CCCCCC;
            border-top: 1px solid #CCCCCC;
            margin: 5px 10px;
            text-align: left;
            width: 678px;
        }
        table th {
            background-color: #EEEEEE;
            border-bottom: 1px solid #CCCCCC;
            border-right: 1px solid #CCCCCC;
            padding: 10px;
        }
        table td {
            border-bottom: 1px solid #CCCCCC;
            border-right: 1px solid #CCCCCC;
        }
        p {
            line-height: 24px;
            margin: 10px;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #111111;
            font-weight: normal;
            margin: 0;
            padding: 0;
        }
        h1 {
            font-size: 26px;
        }
        h2 {
            border-bottom: 1px dashed #CCCCCC;
            font-size: 24px;
            padding: 10px 0;
        }
        h3 {
            font-size: 20px;
            padding: 8px 0;
        }
        h4 {
            font-size: 18px;
            margin-left: 10px;
            padding: 5px 0;
        }
        h5 {
            font-size: 16px;
            margin-left: 10px;
            padding: 5px 0;
        }
        h6 {
            font-size: 16px;
            margin-left: 10px;
            padding: 5px 0;
        }
        blockquote {
            background: url("../../../img/blockquote.gif") no-repeat scroll left top #F4F5F7;
            margin: 5px 10px;
            padding: 10px 10px 10px 30px;
        }
        pre {
            background: none repeat scroll 0 0 #EEEEEE;
            margin: 5px 10px;
            padding: 10px;
        }
        .sin_callout {
            margin: 5px 10px;
        }
        .sin_header {
            background-color: #F7F7F7;
            border-bottom: 1px solid #CCCCCC;
            height: 80px;
            width: 100%;
        }
        .sin_title {
            margin: 0 auto;
            width: 1000px;
        }
        .sin_title_text {
            color: #000000;
            float: left;
            line-height: 80px;
        }
        .sin_version {
            color: #999999;
            float: left;
            font-size: 14px;
            padding-top: 25px;
            margin-left: 10px;
        }
        .sin_main {
            margin: 0 auto;
            width: 1000px;
        }
        .sin_navi {
            float: left;
            margin-bottom: 20px;
            overflow-y: scroll;
            padding: 0;
            position: relative;
            width: 279px;
            z-index: 1;
        }
        .sin_navi_nomove {
            position: fixed;
            top: 0;
        }
        .sin_navi_ca a {
            color: #333333;
        }
        .sin_navi_ca a:hover {
            color: #16B28F;
        }
        .sin_navi_current {
            border-right: 3px solid #16B28F;
        }
        .sin_navi_current a {
            color: #16B28F;
        }
        .sin_content {
            background-color: #FFFFFF;
            border-left: 1px solid #CCCCCC;
            float: left;
            margin-left: -20px;
            padding: 10px 20px;
            position: relative;
            width: 699px;
            z-index: 2;
        }
        .sin_content_mar {
            margin-left: 259px;
        }
        .sin_footer {
            border-top: 1px solid #CCCCCC;
            color: #999999;
            height: 80px;
            line-height: 80px;
            margin: 0 auto;
            text-align: center;
        }
        .sin_info {
            background: none repeat scroll 0 0 #FFFFCC;
            border: 1px solid #D5D4D4;
            border-radius: 4px 4px 4px 4px;
            color: #999999;
            margin: 10px 0;
            padding: 14px;
        }
        .sin_link_logo {
            color: #16B28F;
            font-size: 12px;
            margin-left: 10px;
        }
        .sin_text {
            margin-bottom: 10px;
        }
        .d_callout {
            margin-bottom: 10px;
        }
        .d_callout_info {
            background: none repeat scroll 0 0 #F4F8FA;
            border-left: 4px solid #5BC0DE;
            padding: 10px;
        }
        .d_callout_warn {
            background: none repeat scroll 0 0 #FCF8F2;
            border-left: 4px solid #F0AD4E;
            padding: 10px;
        }
        .d_callout_danger {
            background: none repeat scroll 0 0 #FDF7F7;
            border-left: 4px solid #D9534F;
            padding: 10px;
        }
        .d_callout_success {
            background: none repeat scroll 0 0 #F3F8F3;
            border-left: 4px solid #50AF51;
            padding: 10px;
        }
        .d_callout input {
            background-color: rgba(0, 0, 0, 0);
            font-size: 15px;
            margin-bottom: 5px;
            padding: 10px 5px 0 10px;
        }
        .d_callout textarea {
            background-color: rgba(0, 0, 0, 0);
        }
        .d_callout_icons a {
            color: #AAAAAA;
            margin-left: 10px;
        }
        a.d_callout_icon_info {
            color: #5BC0DE;
        }
        a.d_callout_icon_warn {
            color: #F0AD4E;
        }
        a.d_callout_icon_danger {
            color: #D9534F;
        }
        a.d_callout_icon_success {
            color: #50AF51;
        }
        .clear {
            clear: both;
        }

	</style>
</head>
<body>
	<div class="sin_header">
		<div class="sin_title">
			<h1 class="sin_title_text">Reactor 指南中文版</h1>
			<span class="sin_version">V2.0</span>
			<div class="clear"></div>
		</div>
		<div id="top_end"></div>
	</div>
	<div class="sin_main">
		<div class="sin_navi" id="sin_navi_id">
			<ul style="margin: 20px 0;">
				    																																													<li style="width: 246px;" id="navi_text_47761">
									<a href="#text_47761">
										说明
									</a>	
								</li>
																															<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10770">
								<a href="#category_10770">
									Reactor 介绍
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_44473">
						<a href="#text_44473">
							Reactor 介绍
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44474">
						<a href="#text_44474">
							什么是 Reactor?
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44477">
						<a href="#text_44477">
							关于该项目
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44476">
						<a href="#text_44476">
							使用前提
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44475">
						<a href="#text_44475">
							构架总览
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44478">
						<a href="#text_44478">
							响应式数据流
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44479">
						<a href="#text_44479">
							响应式扩展
						</a>	
					</li>
											</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10771">
								<a href="#category_10771">
									reactor-核心
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_44480">
						<a href="#text_44480">
							reactor-核心
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44481">
						<a href="#text_44481">
							核心概述
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44482">
						<a href="#text_44482">
							函数式功能
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44483">
						<a href="#text_44483">
							 环境与调度者
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44484">
						<a href="#text_44484">
							核心处理者
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44485">
						<a href="#text_44485">
							环形缓冲区处理者
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44486">
						<a href="#text_44486">
							编解码器与缓冲区
						</a>	
					</li>
											</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10772">
								<a href="#category_10772">
									reactor-数据流
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_44487">
						<a href="#text_44487">
							reactor-stream
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44488">
						<a href="#text_44488">
							使用 Stream 和 Promise（约定） 协调任务
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44489">
						<a href="#text_44489">
							Streams 的基础知识
						</a>	
					</li>
																<li class="sin_navi_ca" style="width:236px" id="navi_category_10773">
					<a href="#category_10773">
						创建 Stream 和 Promise
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44500">
						<a href="#text_44500">
							创建 Stream 和 Promise
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44501">
						<a href="#text_44501">
							从冷数据源创建
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44502">
						<a href="#text_44502">
							从现有的 Reactive Publisher 创建
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44503">
						<a href="#text_44503">
							从自定义 Reactive Publisher 处创建
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44504">
						<a href="#text_44504">
							从热数据源创建
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44505">
						<a href="#text_44505">
							绑定一个 Stream
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44506">
						<a href="#text_44506">
							设定容量
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44507">
						<a href="#text_44507">
							函数式组合
						</a>	
					</li>
											</ul>
																							<li style="width:236px" id="navi_text_44490">
						<a href="#text_44490">
							理解线程模型
						</a>	
					</li>
																<li class="sin_navi_ca" style="width:236px" id="navi_category_11107">
					<a href="#category_11107">
						微批处理
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44491">
						<a href="#text_44491">
							 微批处理
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46252">
						<a href="#text_46252">
							使用缓冲区
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46260">
						<a href="#text_46260">
							使用窗口
						</a>	
					</li>
											</ul>
																							<li style="width:236px" id="navi_text_44493">
						<a href="#text_44493">
							背压和溢出
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44496">
						<a href="#text_44496">
							组合操作
						</a>	
					</li>
																<li class="sin_navi_ca" style="width:236px" id="navi_category_10940">
					<a href="#category_10940">
						微服务
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44492">
						<a href="#text_44492">
							微服务
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_45202">
						<a href="#text_45202">
							创建非阻塞服务
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_45203">
						<a href="#text_45203">
							组合多个服务调用
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_45512">
						<a href="#text_45512">
							支持响应式背压
						</a>	
					</li>
											</ul>
																							<li style="width:236px" id="navi_text_44494">
						<a href="#text_44494">
							 错误处理
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44498">
						<a href="#text_44498">
							Stream 数据持久化
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44497">
						<a href="#text_44497">
							分析
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44495">
						<a href="#text_44495">
							 分区
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44499">
						<a href="#text_44499">
							 Rx之外的其它 API 
						</a>	
					</li>
											</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10774">
								<a href="#category_10774">
									reactor-总线
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_44509">
						<a href="#text_44509">
							数据路由
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44510">
						<a href="#text_44510">
							 发布订阅模型
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44511">
						<a href="#text_44511">
							请求应答模式
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44512">
						<a href="#text_44512">
							注册表 
						</a>	
					</li>
											</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10775">
								<a href="#category_10775">
									reactor-网络
								</a>
							</li>
										<ul>
									<li class="sin_navi_ca" style="width:236px" id="navi_category_11104">
					<a href="#category_11104">
						异步 TCP、UDP 及 HTTP
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44514">
						<a href="#text_44514">
							异步 TCP、UDP 及 HTTP
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46224">
						<a href="#text_46224">
							概述
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46225">
						<a href="#text_46225">
							通道
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46226">
						<a href="#text_46226">
							通道处理程序
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46227">
						<a href="#text_46227">
							规范
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46228">
						<a href="#text_46228">
							客户端规范
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46229">
						<a href="#text_46229">
							服务器规范
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46230">
						<a href="#text_46230">
							背压
						</a>	
					</li>
											</ul>
																							<li style="width:236px" id="navi_text_44517">
						<a href="#text_44517">
							最后的最后
						</a>	
					</li>
																<li class="sin_navi_ca" style="width:236px" id="navi_category_11105">
					<a href="#category_11105">
						TCP 101
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44515">
						<a href="#text_44515">
							 TCP 101 
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46231">
						<a href="#text_46231">
							启动和关闭
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46233">
						<a href="#text_46233">
							数据写入
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46235">
						<a href="#text_46235">
							缓冲区刷新策略
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46236">
						<a href="#text_46236">
							消费数据
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46237">
						<a href="#text_46237">
							背压策略
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46238">
						<a href="#text_46238">
							关闭通道
						</a>	
					</li>
											</ul>
													<li class="sin_navi_ca" style="width:236px" id="navi_category_11106">
					<a href="#category_11106">
						HTTP 101
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_44516">
						<a href="#text_44516">
							 HTTP 101 
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46232">
						<a href="#text_46232">
							HTTP 路由解析
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46239">
						<a href="#text_46239">
							数据写入
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46240">
						<a href="#text_46240">
							缓冲区刷新策略
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46241">
						<a href="#text_46241">
							消费数据
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46242">
						<a href="#text_46242">
							背压策略
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46243">
						<a href="#text_46243">
							关闭通道
						</a>	
					</li>
											</ul>
								</ul>
																									<li class="sin_navi_ca" style="width: 246px;" id="navi_category_10776">
								<a href="#category_10776">
									扩展
								</a>
							</li>
										<ul>
																			<li style="width:236px" id="navi_text_44519">
						<a href="#text_44519">
							 Spring 框架支持 
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44521">
						<a href="#text_44521">
							 Groovy 语言扩展 
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44520">
						<a href="#text_44520">
							在 Spring XD 系统中使用 Reactor
						</a>	
					</li>
																										<li style="width:236px" id="navi_text_44522">
						<a href="#text_44522">
							 Clojure 语言支持
						</a>	
					</li>
																<li class="sin_navi_ca" style="width:236px" id="navi_category_11086">
					<a href="#category_11086">
						简明手册
					</a>
				</li>
							<ul>
																			<li style="width:226px" id="navi_text_46166">
						<a href="#text_46166">
							制作一个简单的文件流
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46200">
						<a href="#text_46200">
							制作一个快速断路器
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46201">
						<a href="#text_46201">
							制作一个高效的数据管道
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46202">
						<a href="#text_46202">
							制作一个非阻塞型微服务
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_46203">
						<a href="#text_46203">
							制作一个类 CQRS 应用
						</a>	
					</li>
																										<li style="width:226px" id="navi_text_44523">
						<a href="#text_44523">
							其他示例程序
						</a>	
					</li>
											</ul>
								</ul>
																			</ul>
		</div>
		<div class="sin_content" id="sin_content_id">
																													<h2 id="text_47761" class="sin_target">说明</h2>
<div class="sin_text">
    					<h3>简介</h3>
<p>Reactor 是一个基于 JVM 之上的异步应用基础库。为 Java 、Groovy 和其他 JVM 语言提供了构建基于事件和数据驱动应用的抽象库。Reactor 性能相当高，在最新的硬件平台上，使用无堵塞分发器每秒钟可处理 1500 万事件。</p>
<p>《Reactor 指南中文版》原文出自《<a href="http://projectreactor.io/docs/reference/" rel="nofollow">Reactor Guide</a>》，由多位网友在开源中国众包平台协作翻译完成，其中：<br>《Reactor 介绍》、《reactor 核心》由 <a href="http://my.oschina.net/u/2500465" rel="nofollow">@viemacs</a> 翻译， <a href="http://my.oschina.net/u/2485518" rel="nofollow">@静怡芸香</a> 校对；<br>《reactor-数据流》由 <a href="http://my.oschina.net/xuleo?fromerr=R4dx9orJ" rel="nofollow">@leoxu</a> 、<a href="http://my.oschina.net/Khiyuan" rel="nofollow">@K6F</a> 翻译及校对；<br>《reactor－总线》、《reactor－网络》、《扩展》由<a href="http://my.oschina.net/Khiyuan" rel="nofollow">@K6F</a> 翻译，<a href="http://my.oschina.net/u/2276921" rel="nofollow">@暖冰</a> 校对。 </p>
<h3>反馈</h3>
<p>对《Reactor 指南中文版》有任何反馈，欢迎在以下网址评论：<br><a href="http://www.oschina.net/news/68445" rel="nofollow">http://www.oschina.net/news/68445</a></p>
<h3>特别说明</h3>
<p>《Reactor 指南中文版》由开源中国组织翻译，转载请注明出处，未经许可不得为其它商业目的使用。</p>
			</div>

																										<h2 id="category_10770">Reactor 介绍</h2>
																								<h3 id="text_44473" class="sin_target">Reactor 介绍</h3>
<div class="sin_text">
    					<h1>Reactor 指南</h1>
<p>作者：<br>Stephane Maldini，Jon Brisbin<br>2.0.7.BUILD-SNAPSHOT</p>
<p>翻译：<br>OSC众包翻译社</p>
<h2>Reactor 介绍</h2> 
<blockquote>
 <p>Reactor 是一个基础库，可用它构建时效性**流式数据**应用，或者有**低延迟**和**容错性**要求的微/纳/皮级服务。<br>— 前言Preface<br>TL;DR</p> 
</blockquote>
			</div>

																						<h3 id="text_44474" class="sin_target">什么是 Reactor?</h3>
<div class="sin_text">
    					<p>现在你要了解下 Reactor，不妨在你喜欢的搜索引擎里输入 <em>Reactive，Spring+Reactive，Asynchronous+Java</em> 之类的关键词，或者直接输入 <em>Reactor是什么货？</em>。简单说，Reactor 是一个轻量级 JVM 基础库，帮助你的服务或应用**高效，异步**地传递消息。</p> 
<blockquote>
 <p>“高效”是指什么?</p> 
 <ul> 
  <li>消息从A传递到B时，产生很少的**内存**垃圾，甚至不产生。</li> 
  <li>解决消费者处理消息的效率低于生产者时带来的**溢出**问题。</li> 
  <li>尽可能提供非阻塞**异步流**。</li> 
 </ul> 
</blockquote>
<p>从经验可知(主要是 <em>#rage</em> 和 <em>#drunk</em> 的推特)，异步编程很难，而像 JVM 这类提供众多可选参数的平台则尤其困难。 Reactor 旨在帮助大多数用例真正非阻塞地运行。我们提供的 API 比 JDK 的 <em>java.util.concurrent</em> 库低级原语更高效。Reactor 提供了下列功能的替代函数 (并建议不使用 JDK 原生语句)：</p> 
<ul> 
 <li><p>阻塞等待：如 Future.get()</p></li> 
 <li><p>不安全的数据访问：如 ReentrantLock.lock()</p></li> 
 <li><p>异常冒泡：如 try…​catch…​finally</p></li> 
 <li><p>同步阻塞：如 synchronized{ }</p></li> 
 <li><p>Wrapper分配(GC 压力)：如 new Wrapper(event)</p></li> 
</ul>
<p>当消息传递效率成为系统性能瓶颈的时候(10k msg/s，100k msg/s，1M…)，非阻塞机制就显得尤为重要。<br>虽然这个有理论支持 (参见 <a href="http://en.wikipedia.org/wiki/Amdahl%27s_law" rel="nofollow">Amdahl’s Law</a>)，但读起来太无聊了。我们举例说明，比如你用了个 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html" rel="nofollow">Executor</a> 方法：</p> 
<pre><code>private ExecutorService  threadPool = Executors.newFixedThreadPool(8);

final List&lt;T&gt; batches = new ArrayList&lt;T&gt;();

Callable&lt;T&gt; t = new Callable&lt;T&gt;() { // *1

        public T run() {
                synchronized(batches) { // *2
                        T result = callDatabase(msg); // *3
                        batches.add(result);
                        return result;
                }
        }
};

Future&lt;T&gt; f = threadPool.submit(t); // *4
T result = f.get() // *5
</code></pre> 
<ol> 
 <li>Callable 分配 – 可能导致 GC 压力。</li> 
 <li>同步过程强制每个线程执行停-检查操作。</li> 
 <li>消息的消费可能比生产慢。</li> 
 <li>使用线程池(ThreadPool)将任务传递给目标线程 – 通过 FutureTask 方式肯定会产生 GC 压力。</li> 
 <li>阻塞直至 callDatabase() 回调。</li> 
</ol>
<p>在这个简单的例子中，很容易指出为什么扩容是很有限的： </p> 
<ul> 
 <li><p>分配对象可能产生**GC压力**，特别是当任务运行时间过长。</p></li> 
 <li><p>每次 GC 暂停都会影响全局性能。</p></li> 
 <li><p>默认，队列是**无界**的，任务会因为数据库调用而堆积。</p></li> 
 <li><p>积压虽然不会直接导致内存泄漏，但会带来严重副作用：GC 暂停时要扫描更多的对象；有丢失重要数据位的风险；等等 …</p></li> 
 <li><p>典型链式队列节点分配时会产生大量内存压力。</p></li> 
 <li><p><strong>阻塞回调</strong>容易产生恶性循环。</p></li> 
 <li><p>阻塞回调会降低消息生产者的效率。在实践中，任务提交后需要等待结果返回，此时流式过程几乎演变为**同步**的了。</p></li> 
 <li><p>会话过程抛出的任何带数据存储的异常都会以不受控的方式被传递给生产者，否定了任何通常在线程边界附近可用的容错性。</p></li> 
</ul>
<p>要实现完全非阻塞是很难办到的，尤其是在有着类似**微服务架构**这样时髦绰号的分布式系统的世界里。因此 Reactor 做了部分妥协，尝试利用最优的可用模式，使开发者觉得他们是在写异步纳米服务，而不是什么数学论文。</p>
<p>没有什么传播得比光快(除了绯闻和网红猫的视频)，正如到了某个阶段，延迟是每一个系统到都要面对的实实在在的问题。为此：</p> 
<blockquote>
 <p>Reactor 提供的框架可以帮助减轻应用中由延迟产生的副作用，只需要增加一点点开销：</p> 
 <ul> 
  <li><p>使用了一些聪明的结构，通过启动预分配策略解决运行时**分配问题**；</p></li> 
  <li><p>通过确定信息传递主结构的**边界**，避免任务的无限堆叠；</p></li> 
  <li><p>采用主流的**响应与事件驱动构架**模式，提供包含反馈在内的**非阻塞端对端流**；</p></li> 
  <li><p>引入新的 <a href="http://projectreactor.io/docs/reference/#reactivestreams" rel="nofollow">Reactive Streams</a>标准，拒绝超过当前容量请求，从而保证限制结构的有效性；</p></li> 
  <li><p>在<a href="http://projectreactor.io/docs/reference/#net-overview" rel="nofollow">IPC</a>上也使用了类似理念，提供对流控制友好的**非阻塞 IO 驱动**；</p></li> 
  <li><p>开放了帮助开发者们以**零副作用**方式组织他们代码的函数接口，借助这些函数来处理容错性和线程安全。</p></li> 
 </ul> 
</blockquote>
			</div>

																						<h3 id="text_44477" class="sin_target">关于该项目</h3>
<div class="sin_text">
    					<p>该项目始于 2012 年。 经过长时间的内部孵化，于 2013 年发布 Reactor 1.x 版本。 Reactor 1 在各种架构下都能成功部署，包括开源的(如 Meltdown)和商业的(如 Pivotal RTI)。2014年，我们开始与一些新兴的<a href="http://projectreactor.io/docs/reference/gettingstarted..html#reactivestreams" rel="nofollow">响应式数据流规范</a>合作，重新设计并于 2015年4月发布 Reactor 2.0版本。响应式数据流规范填补了*指派*机制的最后一个缺口：传输过程中，数据设置多大，才不会触发线程边界问题</p>
<p>同时，随着<a href="http://projectreactor.io/docs/reference/gettingstarted..html#rx" rel="nofollow">响应式扩展</a>日益普及，文档逐渐完善，我们也不断调整部分事件驱动和任务协作类 API。</p>
<p><a href="http://pivotal.io/" rel="nofollow">Pivotal</a> 不仅是 Spring 框架发起者，许多员工都曾是各种 Spring 代码核心贡献者；Pivotal 也资助着 Reactor，两名 Reactor 核心开发人员在 Pitoval 工作。我们提供 Reactor 到 Spring 的整合支持，以及部分 Spring 框架重要功能的支持，如 <em>spring-messaging</em> 的 STOMP 中继代理。尽管如此，我们并不强求使用 Reactor 用户必须采用 Spring。我们为“Reactive 大众”保留可嵌入工具箱。实际上，Reactor 仅仅致力于解决异步和函数调用问题。</p>
<p>Reactor 遵循 <a href="http://www.apache.org/licenses/LICENSE-2.0.html" rel="nofollow">Apache 2.0 许可</a>，可在 <a href="https://github.com/reactor/reactor" rel="nofollow">GitHub</a> 上获取。</p>
			</div>

																						<h3 id="text_44476" class="sin_target">使用前提</h3>
<div class="sin_text">
    					<ul> 
 <li><p>使用 Reactor，Java 版本最低需要 Java 7。</p></li> 
 <li><p>若要充分发挥函数组件潜力，需要 Java 8 Lambdas 支持。</p></li> 
 <li>采用 Spring，Clojure 和 Groovy 扩展作为后备。</li> 
 <li>JVM 支持**非安全**访问时 Reactor 可满负荷运行 (比如不是Android的情况)。</li> 
 <li>若没有非安全访问策略，基于**环形缓冲区**的所有特性都不起作用。</li> 
 <li>Reactor 在 Maven Central 中以传统 JAR 格式打包，你可以用你所习惯的构建工具在任何 JVM 工程中安装该依赖。</li> 
</ul>
			</div>

																						<h3 id="text_44475" class="sin_target">构架总览</h3>
<div class="sin_text">
    					<p><img src="http://projectreactor.io/docs/reference/images/modules.png" alt="Figure 1. The main modules present in Reactor 2.0" title="图1. Reactor 2.0 主要模块"><br>图1. Reactor 2.0 主要模块</p>
<p>Reactor 代码库拆分成多个子模块，便于选择所需功能，不受其他功能代码块干扰。</p>
<p>下面举例说明，为实现异步目标，响应式技术和 Reactor 模块该如何搭配：</p> 
<ul> 
 <li><p>Spring XD + Reactor-Net (Core/Stream)： 使用 Reactor 作为 Sink/Source IO 驱动。</p></li> 
 <li><p>Grails | Spring + Reactor-Stream (Core)： 用 Stream 和 Promise 做后台处理。</p></li> 
 <li><p>Spring Data + Reactor-Bus (Core)： 发射数据库事件 (保存/删除/…​)。</p></li> 
 <li><p>Spring Integration Java DSL + Reactor Stream (Core)： Spring 集成的微批量信息通道。</p></li> 
 <li><p>RxJavaReactiveStreams + RxJava + Reactor-Core： 融合富结构与高效异步 IO 处理者</p></li> 
 <li><p>RxJavaReactiveStreams + RxJava + Reactor-Net (Core/Stream)： 用 RxJava 做数据输入，异步 IO 驱动做传输。</p></li> 
</ul>
<p><img src="http://projectreactor.io/docs/reference/images/overview.png" alt="Figure 2. A quick overview of how Reactor modules depend on one another" title="图2. Reactor 模块相互依赖关系快速概览"><br>图2. Reactor 模块相互依赖关系快速概览</p>
			</div>

																								<h3 id="text_44478" class="sin_target">响应式数据流</h3>
<div class="sin_text">
    					<p><a href="http://www.reactive-streams.org/" rel="nofollow">响应式数据流</a> 作为一种新的数据流规范应用于 Java 9 及其后续版本，并被多个供应商和技术企业采纳，包括包括 Netflix，Oracle，Pivotal 或 Typesafe。</p>
<p>这一规范的定位非常清晰，旨在提供同/异步数据序列流式控制机制，并在 JVM 上首先推广。该规范由 4 个 Java 接口，1 个 TCK 和一些样例组成。在实现所需的 4 个接口之外，该规范的实质在于经由 TCK 验证的行为状态。能成功通过 TCK 实现类检测意味着满足 <em>Reactive Streams Ready</em> 状态。</p>
<p><img src="http://projectreactor.io/docs/reference/images/rs.png" alt="Figure 3. The Reactive Streams Contract" title="图3. 响应式数据流约定"><br>图3. 响应式数据流约定<br>, </p> 
<blockquote>
 <p>响应式数据流接口</p> 
 <ul> 
  <li><a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Publisher.java" rel="nofollow">org.reactivestreams.Pubslisher</a>：数据流发布者(信号从 0 到 N，N 可为无穷)。提供两个可选终端事件：错误和完成。</li> 
  <li><a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Subscriber.java" rel="nofollow">org.reactivestreams.Subscriber</a>：数据流消费者(信号从 0 到 N，N 可为无穷)。消费者初始化过程中，会*请求*生产者当前需要订阅多少数据。其他情况，通过接口回调与数据生产方交互: 下一条(新消息)和状态。状态包括：完成/错误，可选。</li> 
  <li><a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Subscription.java" rel="nofollow">org.reactivestreams.Subscription</a>：初始化阶段将一个小追踪器传递给订阅者。它控制着我们准备好来消费多少数据，以及我们想要什么时候停止消费(取消)。</li> 
  <li><a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Processor.java" rel="nofollow">org.reactivestreams.Processor</a>：同时作为发布者和订阅者的组件的标记。</li> 
 </ul> 
</blockquote>
<p><img src="http://projectreactor.io/docs/reference/images/signals.png" alt="Figure 4. The Reactive Streams publishing protocol" title="图4. 响应式数据流发布协议"><br>图4. 响应式数据流发布协议</p> 
<blockquote>
 <p>订阅者有两种方式向发布者请求数据，如下所示：</p> 
 <ul> 
  <li><strong>无界的</strong>：订阅者只需要调用 <em>Subscription#request(Long.MAX_VALUE)</em> 即可。</li> 
  <li><strong>有界的</strong>：订阅者保留数据引用，调用*request(long)* 方法消费。</li> 
  <li>通常订阅者在订阅时会请求一个初始数据集或者一个数据</li> 
  <li>在 onNext 成功后(如 Commit，Flush 等…​ 之后)，请求更多数据</li> 
  <li>建议请求数量呈线性，尽量避免请求叠加， 如每下一个信号请求 10 个数据</li> 
 </ul> 
</blockquote>
<p>表1. 迄今为止，Reactor 可直接使用的接口有：</p>
					    		<table cellpadding="0" cellspacing="0">
		        <thead>
			        <tr>
			        				           		<th>响应式数据流</th>
			            			           		<th>Reactor 模块</th>
			            			           		<th>实现</th>
			            			           		<th>描述</th>
			            			        </tr>
		        </thead>
		        <tbody>
		        					        <tr>
		        							        	<td>
				        		<p>Processor</p>
				        	</td>
				        					        	<td>
				        		<p>reactor-core, reactor-stream</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.core.processor.*, reactor.rx.*</p>
				        	</td>
				        					        	<td>
				        		<p>Reactor-core：提供背压就绪的RingBuffer*Processor 等多种Processor<br>reactor-streeam：提供全套的操作语句和广播机制</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>Publisher</p>
				        	</td>
				        					        	<td>
				        		<p>reactor-core, reactor-bus, reactor-stream, reactor-net</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.core.processor.*, reactor.rx.stream.*, reactor.rx.action.*, reactor.io.net.*</p>
				        	</td>
				        					        	<td>
				        		<p>Reactor-core：Processors里植入Published<br>Reactor-Bus： 提供无界的路由事件的发射发布机制<br>Reactor-stream：Publisher中直接引入数据流扩展<br>Reactor-net：提供2中发布方式：一种是Channel，另一种是flush和闭环回调</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>Subscriber</p>
				        	</td>
				        					        	<td>
				        		<p>reactor-core, reactor-bus, reactor-stream, reactor-net</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.core.processor.*, reactor.bus.EventBus.*, reactor.rx.action.*, reactor.io.net.impl.*</p>
				        	</td>
				        					        	<td>
				        		<p>Reactor-core：Processors植入 Subscriber<br>Reactor-bus：通过无界Publisher/Subcriber机制扩展总线能力<br>Reactor-stream：订阅行为通过计算指定回调实现<br>Reactor-net： IO 层实现处理写入，关闭和 flush</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>Subscription</p>
				        	</td>
				        					        	<td>
				        		<p>reactor-stream, reactor-net</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.subscription.*, reactor.io.net.impl.*</p>
				        	</td>
				        					        	<td>
				        		<p>Reactor-Stream：提供了最优化过 PushSubscriptions 和 缓冲就绪的 ReactiveSubscription；<br>Reactor-net：通过定制Subscription 异步 IO 用户端实现背压</p>
				        	</td>
				        					        </tr>
		        			        </tbody>
    		</table>
								<p>我们从 Reactor 2 开始就严格遵守这个规范直到 <strong>1.0.0</strong> 发布，在 <em>Maven Central</em> 和其他镜像上都可使用。当然它也是 <strong>reactor-core 的传递依赖</strong>。</p>
			</div>

																							<h3 id="text_44479" class="sin_target">响应式扩展</h3>
<div class="sin_text">
    					<p>响应式扩展，就是通常所说的 <a href="https://msdn.microsoft.com/en-gb/data/gg577609.aspx" rel="nofollow">Rx</a>，是一组定义良好的函数式 API，大规模扩展了观察者模式。</p>
<p>Rx 模式支持响应式数据序列处理，主要的设计要点有：</p> 
<ul> 
 <li><p>使用回调链分离时间/延迟：仅当数据可用时才会回调</p></li> 
 <li><p>分离线程模型：用 <em>Observable / Stream</em> 来处理同步或异步</p></li> 
 <li><p>控制错误链/终止：数据载荷信号以及错误与完成信号都传递给回调链</p></li> 
 <li><p>解决各种预定义API中多重分散-聚合和构造问题</p></li> 
</ul>
<p>JVM 中响应式扩展的标准实现是 <a href="https://github.com/ReactiveX/RxJava" rel="nofollow">RxJava</a>。它提供了强大的函数式 API，并将原始微软库中几乎全部的概念移植了过来。</p>
<p>Reactor 2 提供了一个实现了响应式扩展子集的<a href="http://projectreactor.io/docs/reference/#streams" rel="nofollow">特定模块</a>，并在少量场合下调整了名称来匹配我们的特定行为。这种关注以数据为中心的问题(微批处理，构造…​)的方法依赖于 Reactor 函数式单元，指派者和响应式数据流约定. 我们提倡需要各种 响应式扩展的用户尝试使用 <a href="https://github.com/ReactiveX/RxJavaReactiveStreams" rel="nofollow">RxJava</a> 并和我们沟通。最终，用户能受益于 Reactor 以及与 RxJava 生态系统组合所提供的强大的异步和 IO 能力。</p> 
<blockquote>
 <p>¡ 现阶段一些操作，行为和响应式数据流的概念仍然是 Reactor 所特有的。我们将会在<a href="http://projectreactor.io/docs/reference/#streams" rel="nofollow">合适的章节</a>充实这些特性。</p>
 <p>! 因为背压和自动冲洗(flush)选项和原因，<a href="http://projectreactor.io/docs/reference/#net-overview" rel="nofollow">异步 IO</a> 能力仍依赖于*数据流能力*。</p> 
</blockquote>
<p>表2. Rx 与 Reactor 数据流之间的错位</p>
					    		<table cellpadding="0" cellspacing="0">
		        <thead>
			        <tr>
			        				           		<th>rx</th>
			            			           		<th>reactor-数据流</th>
			            			           		<th>注解</th>
			            			        </tr>
		        </thead>
		        <tbody>
		        					        <tr>
		        							        	<td>
				        		<p>观测</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.Stream&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>反映了响应式数据流发布者的实现</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>操作者</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.action.Action&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>反映了响应式数据流处理者的实现</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>带有不多于1个数据的观测&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.Promise&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>给出唯一结果，反映了响应式数据流处理者的实现，并提供可选的异步指派</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>工厂 API (just，from，merge…​.)&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.Streams&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>与核心中以数据为中心的子集对齐，返回数据流</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>函数式 API (map，filter，take…​.)&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.rx.Stream&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>与核心中以数据为中心的子集对齐，返回数据流</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>调度者&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>reactor.core.Dispatcher, org.reactivestreams.Processor&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>Reactor 数据流使用无界共享式调度者或有界处理者来计算操作</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>Observable.observeOn()&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>Stream.dispatchOn()&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>仅对调度者参数调整下名称</p>
				        	</td>
				        					        </tr>
		        			        </tbody>
    		</table>
			</div>

																														<h2 id="category_10771">reactor-核心</h2>
																								<h3 id="text_44480" class="sin_target">reactor-核心</h3>
<div class="sin_text">
    					<blockquote>
 <p>永远别独自展开异步工作。<br>— Jon Brisbin<br><em>在写 Reactor 1 之后</em></p>
 <p>永远别独自展开异步工作。<br>— Stephane Maldini<br><em>在写 Reactor 2 之后</em></p> 
</blockquote>
<p>先来看看，某项目是如何使用 Groovy 的：</p> 
<pre><code>// 初始化上下文，获取默认调度者
Environment.initialize()

// RingBufferDispatcher，默认带 8192 槽容量
def dispatcher = Environment.sharedDispatcher()

// 创建回调
Consumer&lt;Integer&gt; c = { data -&gt;
        println "some data arrived: $data"
    }

// 创建 error 回调

Consumer&lt;Throwable errorHandler = { it.printStackTrace }

// 异步分发数据
dispatcher.dispatch(1234, c, errorHandler)

Environment.terminate()
</code></pre>
<p>然后，再看看响应式数据流例子</p> 
<pre><code>// 独立异步处理者
def processor = RingBufferProcessor.&lt;Integer&gt;create()

// 发送数据，确保数据的安全性，直到订阅成功
processor.onNext(1234)
processor.onNext(5678)

// 消费整型数据
processor.subscribe(new Subscriber&lt;Integer&gt;(){

  void onSubscribe(Subscription s){
      //unbounded subscriber
      s.request Long.MAX
  }

  void onNext(Integer data){
      println data
  }

  void onError(Throwable err){
      err.printStackTrace()
  }

  void onComplete(){
      println 'done!'
  }
}

// 完全关闭内部线程和调用
processor.onComplete()
</code></pre>
			</div>

																						<h3 id="text_44481" class="sin_target">核心概述</h3>
<div class="sin_text">
    					<p><img src="http://projectreactor.io/docs/reference/images/core-overview.png" alt="Figure 5. How Doge can use Reactor-Core" title="图5. 道哥如何使用 Reactor-核心"><br>图5. Doge 如何使用 Reactor-核心</p>
<p><strong>Reactor 核心</strong>含有如下特性：</p> 
<blockquote> 
 <ul> 
  <li><strong>通用 IO &amp; 函数式类型</strong>，一些 Java 8 接口的反向移植</li> 
  <li>函数，提供者，消费者，谓词，双向消费者，双向函数</li> 
  <li>元组</li> 
  <li>资源池、暂停器、定时器</li> 
  <li>缓冲器，编解码和少量预定义的编解码器</li> 
  <li><strong>环境</strong>上下文</li> 
  <li><strong>调度者</strong>约定和几个预定义调度者</li> 
  <li>预定义**响应式数据流处理者**</li> 
 </ul> 
</blockquote>
<p>Reactor-核心自身可替代其它消息传递机制，完成时序任务调度，或者帮你将代码组织为函数块，实现 Java 8 的反向移植接口。这种拆分便于同其他的响应式库配合使用，而没耐心的开发者也不用再去费劲弄懂环形缓冲区了。</p> 
<blockquote>
 <p>¡ Reactor-核心隐含覆盖 LMAX Disruptor，所以它不和已有的 Disruptor 依赖共存或碰撞。</p> 
</blockquote>
			</div>

																						<h3 id="text_44482" class="sin_target">函数式功能</h3>
<div class="sin_text">
    					<p>可重用函数块基本是你一开始使用 Reactor 就需要的核心功能。[1] 那么函数式编程酷在哪里呢? 其核心理念之一将可执行代码当作另一种数据来处理。[2]业务逻辑由原始调用者决定，这与闭包和匿名函数的理念不谋而合。函数式编程还避免了 IF/SWITCH 语句块的包袱，并清晰地分离了功能：每个代码块只负责一个独立功能，而不共享内容。</p> 
<blockquote> 
 <ol> 
  <li><p>除非你只想用核心处理功能，而这些功能在这一阶段是基本独立的。我们打算逐步将调度器与核心调整到一致。</p></li> 
  <li><p>有人也许要说这观点过于简化了，不过我们这里先讲求实用 :)</p></li> 
 </ol> 
</blockquote>
<h4>规划函数块</h4>
<p>每个函数组件有明确的功能：</p> 
<ul> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/Consumer.java" rel="nofollow">消费者</a>：使用回调函数 — 登记后就不用管了</p></li> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/BiConsumer.java" rel="nofollow">双向消费者</a>：带双参数的简单回调 (通常用于序列比较，如前后参数比较)</p></li> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/Function.java" rel="nofollow">函数</a>：转换逻辑 - 请求/回应</p></li> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/Consumer.java" rel="nofollow">双向函数</a>：带双参数的转换逻辑 (通常用于累加器，比较前后参数并返回一个新值)</p></li> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/Supplier.java" rel="nofollow">供给者</a>：工厂逻辑 - 轮询</p></li> 
 <li><p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/java/reactor/fn/Predicate.java" rel="nofollow">谓词</a>：测试逻辑 - 过滤</p></li> 
</ul> 
<blockquote>
 <p>¡ 我们将发布者和订阅者接口也作为**函数块**处理，我们称之为*响应式函数块*。它们是基本的组件，在 Reactor 和 Beyond 中到处都有用到。通常可以直接调用数据流 API 来创建恰当的订阅者，你只需要向 API 传入 <strong>reactor.fn</strong> 参数。</p> 
</blockquote>
<p>好消息是：封装在函数功能中的可执行指令，可以像乐高积木一样重用。</p> 
<pre><code>Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;(){
        @Override
        void accept(String value){
            System.out.println(value);
        }
};

// 为了简约，现在用 Java 8 风格
Function&lt;Integer, String&gt; transformation = integer -&gt; ""+integer;

Supplier&lt;Integer&gt; supplier = () -&gt; 123;

BiConsumer&lt;Consumer&lt;String&gt;, String&gt; biConsumer = (callback, value) -&gt; {
    for(int i = 0; i &lt; 10; i++){
            // 对要运行的最后逻辑运行做惰性求值
            callback.accept(value);
    }
};

// 注意生产者到双向消费者执行过程
biConsumer.accept(
        consumer,
        transformation.apply(
                supplier.get()
        )
);
</code></pre>
<p>乍一看，你可能会觉得这个革新并不特别，但是这种编程理念的变化，对后续我们构建分层可组合代码却尤其重要。调度者通过消费者处理类型化的数据和错误的回调。Reactor Stream 模块也基于该理念实现优雅编码。</p> 
<blockquote>
 <p>♠ 使用 Spring 这样的 IoC 容器的良好实践是利用 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java" rel="nofollow">Java 配置</a>特性返回无状态函数式 Beans。然后就可以从容地将代码块注入数据流管道，或者指派代码块的执行。</p> 
</blockquote>
<h4>元组</h4>
<p>或许你已经注意到：Reactor 提供的接口都是强类型、带有泛型支持和少量确定数目的参数。那如果形参个数大于1或者2呢，又该怎么办呢？此时，需要使用一个类：**元组**。元组像是单对象实例中的带类型 CSV 行，在函数式编程中，就是通过元组保证类型安全呢和可变参数。</p>
<p>让我们用双参数双向消费者代替单参数消费者实现上例的过程：</p> 
<pre><code>Consumer&lt;Tuple2&lt;Consumer&lt;String&gt;, String&gt;&gt; biConsumer = tuple -&gt; {
        for(int i = 0; i &lt; 10; i++){        
                // 类型正确，开启编译器
                tuple.getT1().accept(tuple.getT2());
        }
};

biConsumer.accept(
        Tuple.of(
                consumer,
                transformation.apply(supplier.get())
        )
);
</code></pre> 
<blockquote>
 <p>¡ 元组涉及到更多的资源分配，因此，通常键值对比较和键值信号量更倾向使用 Bi **类型接口。</p> 
</blockquote>
			</div>

																								<h3 id="text_44483" class="sin_target"> 环境与调度者</h3>
<div class="sin_text">
    					<p>函数式功能块到位后，接下来开启异步之旅。第一步我们来看调度者的部分。</p>
<p>使用调度者前，先要确认我们能快速地创建它们。通常创建调度者开销较大，因为它们要预分配一个内存段以确保高度信号，实际上这是序言中所阐述的非常著名的运行时 VS 启动时平衡问题。 Reactor 引入了名为 <strong>环境</strong> 的特定共享上下文来管理各种调度者，来避免不恰当的创建。</p>
<h4>环境</h4>
<p>环境由 Reactor 用户(或可用的扩展库，如 <em>@Spring</em>)来创建和终止。它们自动读取位于 <a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/main/resources/META-INF/reactor/reactor-environment.properties" rel="nofollow">META_INF/reactor/reactor-environment.properties</a> 的配置文件。</p> 
<blockquote>
 <p>♠ 属性文件可在运行时通过 <em>META-INF/reactor</em> 类路径下所需的新属性配置进行调校。</p> 
</blockquote>
<p>运行时替换默认配置的操作可通过传递如下环境变量来实现：*reactor.profiles.active.*</p> 
<pre><code>java - jar reactor-app.jar -Dreactor.profiles.active=turbo
</code></pre>
<p>环境初始化与终止示例</p> 
<pre><code>Environment env = Environment.initialize();

// 判断系统环境与初始化环境是否相同
Assert.isTrue(Environment.get() == env);

// 找到名为"共享"的调度者
Dispatcher d  = Environment.dispatcher("shared");

// 计时器与环境计时器绑定
Timer timer = Environment.timer();

// 关闭可能运行非守护进程的寄存调度者和计时器
Environment.terminate();
// 备选方案：通过注册shutdownHook实现终止自动调用
</code></pre> 
<blockquote>
 <p>♠ 对一个给定的 JVM 应用，最佳实践是：保持单一的运行环境。大多数情况首选 <em>Environment.initializeIfEmpty()</em>。</p> 
</blockquote>
<h4>调度者</h4>
<p>Reactor 1 就提及过调度者，它用类似 Java Executor 的通用约定抽象出信息传递的方法。它实际上扩展了 Executor。</p>
<p>调度者约定提供了一个传递信号的强类型方式，相应的数据及错误消费者可以同(异)步执行。我们用这种方法解决了经典的 Executor 首要面临的问题：错误隔离。调用 Error 消费者比中断已分配资源过程效果更好。如果没有可调用的，调度者将尝试找一个现存的环境并使用其 <em>errorJournalConsumer</em>。</p>
<p>异步调度者提供的第二个特性是使用*尾递归*策略的可重入调度。尾递归的使用情形是，调度检测到 调度者classLoader 已被分配到运行中的线程，此时将当前消费者返回时将要执行的任务入队。</p>
<p>使用同步多线程调度者，比如这个 <a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/test/groovy/reactor/core/dispatch/DispatcherSpec.groovy" rel="nofollow">Groovy Spock 测试</a>：</p> 
<pre><code>import reactor.core.dispatch.*

//...

given:
  def sameThread = new SynchronousDispatcher()
    def diffThread = new ThreadPoolExecutorDispatcher(1, 128)
      def currentThread = Thread.currentThread()
        Thread taskThread = null

  def consumer = { ev -&gt;
      taskThread = Thread.currentThread()
        }

  def errorConsumer = { error -&gt;
      error.printStackTrace()
        }

when: "a task is submitted"
  sameThread.dispatch('test', consumer, errorConsumer)

then: "the task thread should be the current thread"
  currentThread == taskThread

when: "a task is submitted to the thread pool dispatcher"
  def latch = new CountDownLatch(1)
    diffThread.dispatch('test', { ev -&gt; consumer(ev); latch.countDown() }, errorConsumer)

  latch.await(5, TimeUnit.SECONDS) // 等待任务执行

then: "the task thread should be different when the current thread"
  taskThread != currentThread
</code></pre> 
<blockquote>
 <p>! 我们将在随 2.x 发布计划加入 Executor 等没有的特性：响应式数据流协议。它们是 Reactor 没有直接绑定到响应式数据流标准的剩余部分之一。然而，它们可以与 Reactor 数据流结合并快速绑定，正如我们在<a href="http://projectreactor.io/docs/reference/#streams" rel="nofollow">数据流章节</a>中将要探索的一样。本质而言，它意味着用户可以直接使用，直到最终或暂时遇到大部分调度者实现的容量界限。</p> 
</blockquote>
<p>表3. 调度者族介绍</p>
					    		<table cellpadding="0" cellspacing="0">
		        <thead>
			        <tr>
			        				           		<th>调度者	</th>
			            			           		<th>源环境	</th>
			            			           		<th>描述</th>
			            			           		<th>强项	</th>
			            			           		<th>弱项</th>
			            			        </tr>
		        </thead>
		        <tbody>
		        					        <tr>
		        							        	<td>
				        		<p>环形缓冲区&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>sharedDispatcher()&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>An LMAX Disruptor<br>基于环形缓冲区的指派者.&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>较小的容许延迟峰值<br>最快的异步指派者，在商用硬件上 10-15M+ 指派/秒<br>支持预订</p>
				        	</td>
				        					        	<td>
				        		<p>满容量时获取下一槽位会出现’打滑’循环<br>单线程，不能并发指派</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>Mpsc</p>
				        	</td>
				        					        	<td>
				        		<p>sharedDispatcher()<br>如果不安全选项可用</p>
				        	</td>
				        					        	<td>
				        		<p>信息传递结构的另一种优化.</p>
				        	</td>
				        					        	<td>
				        		<p>容许延迟峰值<br>在商用硬件上 5-10M+ 指派/秒<br>支持预订</p>
				        	</td>
				        					        	<td>
				        		<p>无边界，并可能会使用尽可能多的可用内存堆<br>单线程，不能并发指派</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>工作队列&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>workDispatcher()&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>An LMAX Disruptor<br>基于环形缓冲区的指派者.</p>
				        	</td>
				        					        	<td>
				        		<p>有限时间内的容许延迟峰值<br>最快的多线程指派者，在商用硬件上 5-10M+ 指派/秒</p>
				        	</td>
				        					        	<td>
				        		<p>满容量时获取下一槽位会出现’打滑’循环<br>并发指派<br>不支持预定</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>同步&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>dispatcher(“sync”) or SynchronousDispatcher. INSTANCE&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>在当前线程上运行.&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>上游和消费者同位执行<br>对测试支持很有用<br>在当前线程上折返指派时支持预定</p>
				        	</td>
				        					        	<td>
				        		<p>不支持尾递归<br>阻塞</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>尾递归&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>tailRecurse() or TailRecurse Dispatcher. INSTANCE&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>同步折返指派者在正在指派时将指派入队.&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>上游和消费者同位执行<br>减少了执行栈，极大地扩展了函数调用链</p>
				        	</td>
				        					        	<td>
				        		<p>无边界尾递归深度<br>阻塞<br>支持预定 (窃取线程)</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>线程执行者&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>newDispatcher(int, int, DispatcherType. THREAD_POOL_EXECUTOR)&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>使用底层线程池执行者的信息传递&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>多线程<br>阻塞消费者，容许永久延迟<br>在商用硬件上 1-5M+ 指派/秒</p>
				        	</td>
				        					        	<td>
				        		<p>对指定消费者的并发执行两次或以上<br>默认无边界 default<br>不支持预定</p>
				        	</td>
				        					        </tr>
		        					        <tr>
		        							        	<td>
				        		<p>可追踪代理&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>N/A&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>使用追踪级别日志来修饰现在指派者.&nbsp;&nbsp;</p>
				        	</td>
				        					        	<td>
				        		<p>指派窃听<br>比单独的代理指派者运行更慢</p>
				        	</td>
				        					        	<td>
				        		<p>日志开销 (运行时，磁盘)</p>
				        	</td>
				        					        </tr>
		        			        </tbody>
    		</table>
								<p><img src="http://projectreactor.io/docs/reference/images/rbd2.png" alt="Figure 6. RingBufferDispatcher at a given time T" title="图6. 给定时刻 T 的 RingBufferDispatcher"><br>图6. 给定时刻 T 的 RingBufferDispatcher</p>
<h4>调度供给者</h4>
<p>你也许注意到了一些调度者是间线程的，特别是 <strong>RingBufferDispatcher</strong> 和 <strong>MpscDispatcher</strong>。更进一步，根据响应式数据流规范，订阅者/处理者的实现中不应允许并发通知。这特别影响到了 Reactor <strong>数据流</strong>。如果尝试带着调度者使用 <strong>Stream.dispatchOn(Dispatcher)</strong> 会引入并发信号，很明显会失败。</p>
<p>不过，可以用调度者池或**调度供给者**来绕过这个限制。作为**供给者**工厂，**Supplier.get()** 提供的间接取回调度者功能容许了一些有趣的缓冲池策略：循环，最少使用， …​</p>
<p><strong>环境</strong>提供了静态助手来对当前活动的调度者**环境**池进行创建，并最终反寄存：循环所返回的调度者组。一旦就绪，供给者将提供可控数量的调度者。</p>
<p><strong>环境</strong>对调度者通常的一站式管理：</p> 
<pre><code>Environment.initialize();
//....

// 创建有2个调度者的匿名池，采用自动的默认设定(与默认调度者相同的类型，默认的积压大小...)
DispatcherSupplier supplier = Environment.newCachedDispatchers(2);

Dispatcher d1 = supplier.get();
Dispatcher d2 = supplier.get();
Dispatcher d3 = supplier.get();
Dispatcher d4 = supplier.get();

Assert.isTrue( d1 == d3  &amp;&amp; d2 == d4);
supplier.shutdown();

// 创建并注册带3个调度者的新池
DispatcherSupplier supplier1 = Environment.newCachedDispatchers(3，"myPool");
DispatcherSupplier supplier2 = Environment.cachedDispatchers("myPool");

Assert.isTrue( supplier1 == supplier2 );
supplier1.shutdown();
</code></pre>
<h4>计时器</h4>
<p>调度者以尽可能快的速度运算传入的任务，而计时器提供了定期的一次性调度 API。Reactor 核心默认提供了 <strong>HashWheelTimer</strong>，并自动绑定到任一新建的环境上。HashWheelTimer 可以完美处理内存中大量并发任务，是 Java <strong>TaskScheduler</strong> 的强大替代选择。</p> 
<blockquote>
 <p>! 虽然它适用于窗口技术 (分钟级以下的迷你任务)，但因所有任务会随应用关闭而丢失，它并不用于弹性调度。</p>
 <p>♠ 计时器在下次发布时会得到更多关注，比如我们想对 Redis 加入持续/共享调度支持。请在此表达你的意见，或提供一些贡献!</p> 
</blockquote>
<p>在我们的 <a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/test/groovy/reactor/fn/timer/HashWheelTimerYieldingStrategy.groovy" rel="nofollow">Groovy Spock 测试</a> 中创建的一个简单计时器：</p> 
<pre><code>import reactor.fn.timer.Timer

//...

given: "a new timer"
    Environment.initializeIfEmpty()
    Timer timer = Environment.timer()
    def latch = new CountDownLatch(10)

when: "a task is submitted"
    timer.schedule(
        { Long now -&gt; latch.countDown() } as Consumer&lt;Long&gt;,
        period,
        TimeUnit.MILLISECONDS
    )

then: "the latch was counted down"
    latch.await(1, TimeUnit.SECONDS)
    timer.cancel()
    Environment.terminate()
</code></pre>
			</div>

																						<h3 id="text_44484" class="sin_target">核心处理者</h3>
<div class="sin_text">
    					<p>核心处理者的工作比调度者更加专一：计算**支持背压的**异步任务。</p>
<p>同时它直接实现了<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Processor.java" rel="nofollow">org.reactivestreams.Processor</a> 接口，可以良好地与其它响应式数据流提供方合作。比如同时作为订阅者*和*发布者的处理者。你可以将它插入到响应式数据流链中你想要的地方(源，处理过程，槽)。</p> 
<blockquote>
 <p>! 规范并不明确推荐直接使用 <strong>Processor.onNext(d)</strong>。我们技术上支持那种做法，但背压并不会传播，除非最终出现阻塞。你可以明确地用匿名订阅来做传递，先是用 Processor.onSubscribe 传递给处理者，用所实现的请求方式来获取背压反馈。</p>
 <p>! OnNext 必须要序列化，例如每次来自一个单线程(不允许并发的 onXXX 信息)。不过 Reactor 可以支持这种方法，如果使用常规的 <strong>Processor.share()</strong> 方式创建处理者的话，比如 <strong>RingBufferProcessor.share()</strong>。在创建时就要决定用哪种方法，以便在实现中使用正确的协调逻辑，所以要谨慎选择：是要做一个标准发布序列(无并发)，还是要使用多线程。</p>
 <p>Reactor 在处理特定的某某**工作**处理者功能时有一个特例：</p> 
 <ul> 
  <li><p>通常响应式数据流处理者会将相同的数据序列异步调度至所有在给定时刻 T 订阅的订阅者。这与发布/订阅模式类似。</p></li> 
  <li><p>工作处理者以方便的方式来分发数据，尽可能利用所有的订阅者。这意味着在给定时刻 T 的订阅者将一直看到不同的数据。这与工作队模式类似。</p></li> 
 </ul> 
</blockquote>
<p>我们计划随着 2.x 的发布计划增加我们的核心处理者集。</p>
			</div>

																						<h3 id="text_44485" class="sin_target">环形缓冲区处理者</h3>
<div class="sin_text">
    					<p>基于环形缓冲区的响应式数据流处理者有一些很棒的特性：</p> 
<ul> 
 <li><p>高吞吐量</p></li> 
 <li><p>重现最新未消费数据</p></li> 
 <li><p>如果没有订阅者在监听，数据不会丢失（不同于Reactor-数据流的**广播者**）。</p></li> 
 <li><p>如果订阅者在处理过程中取消，信号可以安全重现，该功能用<a href="http://projectreactor.io/docs/reference/#rbwp-note" rel="nofollow">环形缓冲区工作处理者</a> 时也可以良好工作</p></li> 
 <li><p>智能背压，允许任意时刻动态分配大小，方便订阅者负责消费和请求更多数据</p></li> 
 <li><p>传播背压，作为处理者，可被订阅并传递信息</p></li> 
 <li><p>多线程入站/出站处理能力</p></li> 
</ul>
<p>实际上环形缓冲区处理者就是有类型的 <strong>MicroMessageBroker</strong>！</p>
<p>它仅有的缺陷在于运行时创建的成本较高，也不像**环形缓冲区指派者**那样容易共享。因而它适用于高吞吐量预定义数据管线。</p>
<h4>环形缓冲区处理者</h4>
<p>Reactor 中 <a href="http://projectreactor.io/docs/api/index.html?reactor/core/processor/RingBufferProcessor.html" rel="nofollow">RingBufferProcessor</a> 组件本质上是适应响应式数据流 API 的 <a href="https://github.com/LMAX-Exchange/disruptor" rel="nofollow">Disruptor RingBuffer </a>。它的目的在于提供与尽可能接近裸机的效率。它的适用场合是将任务以极低的开销，极高的吞吐量指派到其它线程上，并在你的工作流中管理背压.</p> 
<blockquote>
 <p>我用环形缓冲区处理者来异步计算各种远程产出调用：AMQP，SSD 存储和内存中的储存，处理者完全覆盖了多变的延迟，我们的每秒百万信息的数据源从未阻塞过！</p>
 <p>— Reactor 用户</p>
 <p><em>环形缓冲区处理者用例</em></p> 
</blockquote>
<p>![Figure 7. RingBufferProcessor at a given time T, with 2 Subscribers, all consuming the same sequence, but delta consuming rate is allowed until the ring buffer is full. This will happen when blue cube is colliding with its next clockwise yellow cube.](<a href="http://projectreactor.io/docs/reference/images/RBP.png" rel="nofollow">http://projectreactor.io/docs/reference/images/RBP.png</a> “<br>图7. 给定时刻 T 带2个订阅者的环形缓冲区处理者。订阅者消费相同的序列，但在环形缓冲区满之前可以允许 delta 消费率存在。这在蓝方块与顺时针方向的下一个黄方块发生碰撞时会发生。”)<br>图7. 给定时刻 T 带2个订阅者的环形缓冲区处理者。订阅者消费相同的序列，但在环形缓冲区满之前可以允许 delta 消费率存在。这在蓝方块与顺时针方向的下一个黄方块发生碰撞时会发生。</p>
<p>你需要用静态**创建**帮助者的方法来创建 <strong>环形缓冲区处理者</strong>。</p> 
<pre><code>Processor&lt;Integer, Integer&gt; p = RingBufferProcessor.create("test", 32); //*1
Stream&lt;Integer&gt; s = Streams.wrap(p); //*2

s.consume(i -&gt; System.out.println(Thread.currentThread() + " data=" + i)); //*3
s.consume(i -&gt; System.out.println(Thread.currentThread() + " data=" + i)); //*4
s.consume(i -&gt; System.out.println(Thread.currentThread() + " data=" + i)); //*5

input.subscribe(p); //*6
</code></pre> 
<ol> 
 <li>创建带有 32 个槽容量的内部环形缓冲区的**处理者**。</li> 
 <li>从响应式数据流**处理者**创建 <strong>Reactor 数据流</strong>。</li> 
 <li>每个对**消费**的调用在其自身**线程**上创建一个 <strong>Disruptor</strong>。</li> 
 <li>每个对**消费**的调用在其自身**线程**上创建一个 <strong>Disruptor</strong>。</li> 
 <li>每个对**消费**的调用在其自身**线程**上创建一个 <strong>Disruptor</strong>。</li> 
 <li>将这个**处理者**订阅至一个响应式数据流**发布者**。</li> 
</ol>
<p>每个传递给处理者的 <strong>Subscribe.onNext(Buffer)</strong> 方法的数据元素都会被“广播”给所有消费者。在**处理者**中没有循环指派，因为循环指派位于**环形缓冲区工作处理者**中，在下面会讨论这点。如果向**处理者**传递整数1，2，3，你在控制台看到的输入会像下面这样：</p> 
<pre><code>Thread[test-2,5,main] data=1
Thread[test-1,5,main] data=1
Thread[test-3,5,main] data=1
Thread[test-1,5,main] data=2
Thread[test-2,5,main] data=2
Thread[test-1,5,main] data=3
Thread[test-3,5,main] data=2
Thread[test-2,5,main] data=3
Thread[test-3,5,main] data=3
</code></pre>
<p>每个线程收到传递给**处理者**的所有值，因为内部使用**环形缓冲区**来管理发布值的可用槽，所以每个线程以有序的方式接收值。</p> 
<blockquote>
 <p>! RingBufferProcessor 可以向任何潜在的订阅者重现因无订阅者而丢失的信号。如果满缓冲区未被订阅者耗尽，这会使处理者等待 onNext()。从 subsUp 接收的上一序列，到环形缓冲区的配置大小，都保持就绪以便为每个新的订阅者重现信号，即便事件已发出(分列)也是这样。</p> 
</blockquote>
<h4>环形缓冲区工作处理者(RingBufferWorkProcessor)</h4>
<p>与标准的环形缓冲区处理者向所有消费者广播数值的做法不同，环形缓冲区工作处理者根据消费者数量将传入的数值分区。进入处理者的数值以循环的方式被发送到各种线程(因为每个消费者都有自己的线程)，同时这些数值通过适当地向生产者提供背压来使用内部环形缓冲区有效地管理数值的发布。</p> 
<blockquote>
 <p>我们实现了环形缓冲区工作处理者来对各种 HTTP 微服务调用扩大规模和平衡负载。我说的也许不对，不过看起来它比光还快(！)，而且垃圾回收压力完全得到控制。</p>
 <p>— 开心的 Reactor 用户</p>
 <p><em>环形缓冲区工作处理者用例</em></p> 
</blockquote>
<p><img src="http://projectreactor.io/docs/reference/images/RBWP.png" alt="Figure 8. RingBufferWorkProcessor at a given time T, with 2 Subscribers, each consuming unique sequence (availabilty FIFO), delta consuming rate is allowed until the ring buffer is full. This will happen when blue cube is colliding with its next clockwise yellow cube." title="图8. 在给定时刻 T 的 RingBufferWorkProcessor，带2个订阅者，消费各自独有的序列(可用 FIFO)，但在环形缓冲区满之前可以允许 delta 消费率存在。这在蓝方块与顺时针方向的下一个黄方块发生碰撞时会发生。"><br>图8. 在给定时刻 T 的 RingBufferWorkProcessor，带2个订阅者，消费各自独有的序列(可用 FIFO)，但在环形缓冲区满之前可以允许 delta 消费率存在。这在蓝方块与顺时针方向的下一个黄方块发生碰撞时会发生。</p>
<p>要使用**环形缓冲区工作处理者**，上述例子中你唯一需要修改的是静态**创建**方法的引用，你需要在**环形缓冲区工作处理者**类自身上使用。其余代码都一致。</p> 
<pre><code>Processor&lt;Integer, Integer&gt; p = RingBufferWorkProcessor.create("test", 32); //*1
</code></pre> 
<ol> 
 <li>创建带有32槽容量的内部环形缓冲区**处理者**。</li> 
</ol>
<p>现在当值被发布到**处理者**时，并不会广播给每个消费者，而是根据消费者数量分区。现在当我们运行这个例子时，可以看到像下面这样的输出：</p> 
<pre><code>Thread[test-2,5,main] data=3
Thread[test-3,5,main] data=2
Thread[test-1,5,main] data=1
</code></pre> 
<blockquote>
 <p>! RingBufferWorkProcessor 能够重现被中断的信号，从终止的订阅者那里检测 <strong>CancelException</strong>。当信号最终被其它订阅者实际播放时，这是唯一会出现的情况。**我们可以保证任何事件都至少被交付一次。** 如果你熟悉语义的话，你可能会说 “嗯~，这个环形缓冲区工作处理者用起来像 Message Broker?”，的确是这样。</p> 
</blockquote>
			</div>

																							<h3 id="text_44486" class="sin_target">编解码器与缓冲区</h3>
<div class="sin_text">
    					<p>字节操作是许多数据管线配置中用到的核心概念。从 <a href="http://projectreactor.io/docs/reference/#net-overview" rel="nofollow">reactor-net</a> 到通过 IO 接收发送编组和解组字节中都得到广泛运用。</p>
<p><strong>reactor.io.buffer.Buffer</strong> 是 Java <strong>ByteBuffer</strong> 操作的修饰符，提供了一系列操作，目的是通过调整字节缓冲区大小以及读取或覆盖预分配字节来最小化字节拷贝。在字节缓冲区中追踪定位可以让开发者快速进入脑痛期，至少对我们是这样。因而我们决定向我们的用户推荐这个小工具。</p>
<p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/test/groovy/reactor/io/buffer/BufferSpec.groovy" rel="nofollow"><strong>Groovy Spock 测试</strong></a>中简单的缓冲区操作代码如下所示：</p> 
<pre><code>import reactor.io.buffer.Buffer

//...

given: "an empty Buffer and a full Buffer"
        def buff = new Buffer()
        def fullBuff = Buffer.wrap("Hello World!")

when: "a Buffer is appended"
        buff.append(fullBuff)

then: "the Buffer was added"
        buff.position() == 12
        buff.flip().asString() == "Hello World!"
</code></pre>
<p>一个有效的缓存应用是 <strong>Buffer.View</strong> ，它可由像 <strong>split()</strong> 这样的多路操作返回。它以免拷贝的方式来描述和内观字节缓冲区中的字节。Buffer.View 也是一种缓冲区，开放了相同的操作。</p>
<p>使用定界符和 <strong>Buffer.View</strong> 重用相同的字节来分块读取：</p> 
<pre><code>byte delimiter = (byte) ';';
byte innerDelimiter = (byte) ',';

Buffer buffer = Buffer.wrap("a;b-1,b-2;c;d;");

List&lt;Buffer.View&gt; views = buffer.split(delimiter);

int viewCount = views.size();
Assert.isTrue(viewCount == 4);

for (Buffer.View view : views) {
    System.out.println(view.get().asString()); //prints "a" then "b-1,b-2", then "c" and finally "d"

    if(view.indexOf(innerDelimiter) != -1){
        for(Buffer.View innerView : view.get().split(innerDelimiter)){
            System.out.println(innerView.get().asString()); //prints "b-1" and "b-2"
        }
    }
}
</code></pre>
<p>对通常的编组/解组用例而言调整**缓冲区**有点低层次的感觉。Reactor 带有一系列的预定义转换器，叫做 <strong>Codec</strong>。一些 <strong>Codec</strong> 需要类路径中的适当额外依赖，如 JSON 操作需要 <a href="http://jackson.codehaus.org/" rel="nofollow">Jackson</a>。</p>
<p><strong>Codec</strong> 有两种工作方式，第一种方式中它实现了将任意内容直接编码并返回已编码数据的**函数**，通常以缓冲的形式完成。这种很棒的方式**只适用于无状态编码**。另一种是使用 <strong>Codec.encoder()</strong> 返回的编码函数。</p> 
<blockquote>
 <p>Codec.encoder() vs Codec.apply(Source)</p> 
 <ul> 
  <li><p><strong>Codec.encoder()</strong> 返回唯一编码函数，在不同线程间不能共享。</p></li> 
  <li><p><strong>Codec.apply()</strong> 直接编码(保存分配的编码器)，在此情况下 Codec 需要在线程间共享。</p></li> 
 </ul>
 <p>♠ <a href="http://projectreactor.io/docs/reference/#net-overview" rel="nofollow">Reactor Net</a> 实际上为每个新的连接都调用了 <strong>Codec.encoder</strong> 来处理这种区别。</p> 
</blockquote>
<p><strong>Codec</strong> 也能从源类型解码数据，在大多数 Codec 实现上通常解码至缓冲区。要解码源数据，我们要从 <strong>Codec.decoder()</strong> 检索解码函数。与编码过程不同，解码没有像编码那样已经为编码目的而重载的便捷方法。与编码过程相同的是，解码函数在不同线程间不应共享。</p>
<p><strong>Codec.decoder()</strong> 函数有两种形式，一种是直接返回解码数据，另一种 <strong>Codec.decoder(Consumer)</strong> 为每个解码事件调用已传递消费者。</p> 
<blockquote>
 <p>Codec.decoder() vs Codec.decoder(Consumer)</p> 
 <ul> 
  <li><strong>Codec.decoder()</strong> 是阻塞式解码函数，直接在传入源码数据中返回解码数据。</li> 
  <li><strong>Codec.decoder(Consumer)</strong> 可用于非阻塞解码，它返回 null，仅在解码后调用已传递消费者，可与任意异步方式结合。</li> 
 </ul> 
</blockquote>
<p><a href="https://github.com/reactor/reactor/blob/master/reactor-core/src/test/groovy/reactor/io/codec/json/JsonCodecSpec.groovy" rel="nofollow">Groovy Spock 测试</a> 中使用预定义编/解码器示例代码：</p> 
<pre><code>import reactor.io.json.JsonCodec

//...

given: 'A JSON codec'
    def codec = new JsonCodec&lt;Map&lt;String, Object&gt;, Object&gt;(Map);
    def latch = new CountDownLatch(1)

when: 'The decoder is passed some JSON'
    Map&lt;String, Object&gt; decoded;
    def callbackDecoder = codec.decoder{
        dec