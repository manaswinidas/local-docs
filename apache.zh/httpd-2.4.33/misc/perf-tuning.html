<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>Apache性能调整-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">其他文档</a></div><div id="page-content"><div id="preamble"><h1>Apache性能调优</h1>



    <p>Apache 2.x是一种通用Web服务器，旨在在灵活性，可移植性和性能之间取得平衡。尽管不是专门为设置基准记录而设计的，但Apache 2.x能够在许多实际情况下实现高性能。</p>

    <p>与Apache 1.3相比，版本2.x包含许多其他优化功能，以提高吞吐量和可伸缩性。默认情况下，其中大多数改进都是启用的。但是，有一些编译时和运行时配置选择会严重影响性能。本文档描述了服务器管理员可以配置的选项，以调整Apache 2.x安装的性能。其中一些配置选项使httpd可以更好地利用硬件和OS的功能，而其他选项则允许管理员以速度为代价来交换功能。</p>

  </div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#hardware">硬件和操作系统问题</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#runtime">运行时配置问题</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#compiletime">编译时配置问题</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#trace">附录：跟踪的详细分析</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="hardware" id="hardware">硬件和操作系统问题</a></h2>

    

    <p>影响Web服务器性能的最大硬件问题是RAM。 Web服务器永远都不需要交换，因为交换会增加每个请求的延迟，使之超过用户认为“足够快”的程度。这会导致用户点击停止并重新加载，从而进一步增加了负载。您可以而且应该控制<code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code>设置，以便您的服务器不会产生太多子级以至于开始交换。这样做的过程很简单：通过诸如以下工具查看进程列表，确定平均Apache进程的大小。 <code>top</code> ，并将其划分为总可用内存，为其他进程留出一些空间。</p>

    <p>除此之外，其他一切都很普通：获得足够快的CPU，足够快的网卡和足够快的磁盘，其中“足够快”是需要通过实验确定的东西。</p>

    <p>操作系统的选择很大程度上取决于本地情况。但是一些已被证明通常有用的准则是：</p>

    <ul>
      <li>
        <p>运行所选操作系统的最新稳定版本和补丁程序级别。近年来，许多操作系统供应商都对其TCP堆栈和线程库进行了重大的性能改进。</p>
      </li>

      <li>
        <p>如果您的操作系统支持<code>sendfile(2)</code>系统调用，请确保您安装了启用它所需的版本和/或补丁。（例如，对于Linux，这意味着使用Linux 2.4或更高版本。对于Solaris 8的早期版本，您可能需要应用补丁。）在可用的系统上， <code>sendfile</code>使Apache 2可以更快地交付静态内容并降低CPU利用率。</p>
      </li>
    </ul>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="runtime" id="runtime">运行时配置问题</a></h2>

    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code></li><li><code class="module"><a href="../mod/mpm_common.html">mpm_common</a></code></li><li><code class="module"><a href="../mod/mod_status.html">mod_status</a></code></li></ul></td><td><ul><li><code class="directive"><a href="../mod/core.html#allowoverride">AllowOverride</a></code></li><li><code class="directive"><a href="../mod/mod_dir.html#directoryindex">DirectoryIndex</a></code></li><li><code class="directive"><a href="../mod/core.html#hostnamelookups">HostnameLookups</a></code></li><li><code class="directive"><a href="../mod/core.html#enablemmap">EnableMMAP</a></code></li><li><code class="directive"><a href="../mod/core.html#enablesendfile">EnableSendfile</a></code></li><li><code class="directive"><a href="../mod/core.html#keepalivetimeout">KeepAliveTimeout</a></code></li><li><code class="directive"><a href="../mod/prefork.html#maxspareservers">MaxSpareServers</a></code></li><li><code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code></li><li><code class="directive"><a href="../mod/core.html#options">Options</a></code></li><li><code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code></li></ul></td></tr></tbody></table>

    <h3><a name="dns" id="dns">主机名查找和其他DNS注意事项</a></h3>

      

      <p>在Apache 1.3之前， <code class="directive"><a href="../mod/core.html#hostnamelookups">HostnameLookups</a></code>默认为<code>On</code> 。这会增加每个请求的等待时间，因为它需要在请求完成之前完成DNS查找。在Apache 1.3中，此设置默认为<code>Off</code> 。如果您需要将日志文件中的地址解析为主机名，请使用<code class="program"><a href="../programs/logresolve.html">logresolve</a></code> Apache随附的程序或可用的众多日志报告软件包之一。</p>

      <p>建议您在生产Web服务器计算机以外的其他计算机上对日志文件进行这种后处理，以免此活动对服务器性能产生不利影响。</p>

      <p>如果您使用任何<code><code class="directive"><a href="../mod/mod_access_compat.html#allow">Allow</a></code> from domain</code>要么<code><code class="directive"><a href="../mod/mod_access_compat.html#deny">Deny</a></code> from domain</code>指令（即使用主机名或域名，而不是IP地址），则需要支付两次DNS查找费用（反向查询，然后进行正向查询以确保不欺骗反向查询）。因此，为了获得最佳性能，请尽可能在使用这些指令时使用IP地址而不是名称。</p>

      <p>请注意，可以对指令进行范围调整，例如在<code><Location "/server-status"></code>部分。在这种情况下，仅对符合条件的请求执行DNS查找。这是一个禁用查询的示例，除了<code>.html</code>和<code>.cgi</code>文件：</p>

      <pre class="prettyprint lang-config">HostnameLookups off
&lt;Files ~ "\.(html|cgi)$"&gt;
  HostnameLookups on
&lt;/Files&gt;</pre>


      <p>但即使如此，如果您只需要某些CGI中的DNS名称，则可以考虑进行<code>gethostbyname</code>调用需要它的特定CGI。</p>

    

    <h3><a name="symlinks" id="symlinks">关注SymLinks和SymLinksIfOwnerMatch</a></h3>

      

      <p>无论您在URL空间中的哪个位置，都没有<code>Options FollowSymLinks</code> ，或者您确实有一个<code>Options SymLinksIfOwnerMatch</code> ，Apache将需要发出额外的系统调用以检查符号链接。（每个文件名组件一个额外的调用。）例如，如果您有：</p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  Options SymLinksIfOwnerMatch
&lt;/Directory&gt;</pre>


      <p>并请求URI <code>/index.html</code> ，那么Apache将执行<code>lstat(2)</code>上<code>/www</code> ， <code>/www/htdocs</code>和<code>/www/htdocs/index.html</code> 。这些的结果<code>lstats</code>永远不会被缓存，因此它们将在每个单个请求上发生。如果您确实需要符号链接安全检查，则可以执行以下操作：</p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  Options FollowSymLinks
&lt;/Directory&gt;

&lt;Directory "/www/htdocs"&gt;
  Options -FollowSymLinks +SymLinksIfOwnerMatch
&lt;/Directory&gt;</pre>


      <p>这至少避免了额外的检查<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>路径。请注意，如果有任何部分，则需要添加类似的部分<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code>要么<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>文档根目录之外的路径。为了获得最高性能，并且没有符号链接保护，请进行设置<code>FollowSymLinks</code>到处都是，永远不会<code>SymLinksIfOwnerMatch</code> 。</p>

    

    <h3><a name="htaccess" id="htaccess">AllowOverride</a></h3>

      

      <p>无论您在URL空间中的何处，都允许覆盖（通常是<code>.htaccess</code>文件），Apache将尝试打开<code>.htaccess</code>每个文件名组件。例如，</p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  AllowOverride all
&lt;/Directory&gt;</pre>


      <p>并请求URI <code>/index.html</code> 。然后Apache将尝试打开<code>/.htaccess</code> ， <code>/www/.htaccess</code>和<code>/www/htdocs/.htaccess</code> 。解决方案与之前的情况类似<code>Options FollowSymLinks</code> 。为了达到最佳性能<code>AllowOverride None</code>文件系统中的任何地方。</p>

    

    <h3><a name="negotiation" id="negotiation">谈判</a></h3>

      

      <p>如果您真的对每一盎司的性能都很感兴趣，请尽可能避免进行内容协商。在实践中，谈判的好处胜于性能损失。在一种情况下，您可以加快服务器速度。而不是使用通配符，例如：</p>

      <pre class="prettyprint lang-config">DirectoryIndex index</pre>


      <p>使用完整的选项列表：</p>

      <pre class="prettyprint lang-config">DirectoryIndex index.cgi index.pl index.shtml index.html</pre>


      <p>首先列出最常见的选择。</p>

      <p>另请注意，显式创建一个<code>type-map</code>文件提供了比使用更好的性能<code>MultiViews</code> ，因为可以通过读取单个文件来确定必要的信息，而不必扫描目录中的文件。</p>

    <p>如果您的网站需要进行内容协商，请考虑使用<code>type-map</code>文件，而不是<code>Options MultiViews</code>指令来完成谈判。有关<a href="../content-negotiation.html">协商</a>方法的完整讨论和创建说明，请参阅<a href="../content-negotiation.html">内容协商</a>文档。 <code>type-map</code>文件。</p>

    

    <h3>内存映射</h3>

      

      <p>在Apache 2.x需要查看所交付文件的内容的情况下（例如，在进行服务器端包含处理时），如果操作系统支持某种形式的文件，则通常会对该文件进行内存映射。 <code>mmap(2)</code> 。</p>

      <p>在某些平台上，此内存映射可提高性能。但是，在某些情况下，内存映射可能会损害httpd的性能甚至稳定性：</p>

      <ul>
        <li>
          <p>在某些操作系统上， <code>mmap</code>缩放不及<code>read(2)</code>当CPU数量增加时。例如，在多处理器Solaris服务器上，Apache 2.x有时会在以下情况下更快地交付服务器解析的文件： <code>mmap</code>被禁用。</p>
        </li>

        <li>
          <p>如果您对位于NFS挂载的文件系统上的文件进行内存映射，而另一台NFS客户端计算机上的进程删除或截断了该文件，则下次尝试访问映射的文件内容时，您的进程可能会遇到总线错误。</p>
        </li>
      </ul>

      <p>对于其中两个因素均适用的安装，应使用<code>EnableMMAP off</code>禁用已交付文件的内存映射。（注意：可以根据每个目录覆盖此指令。）</p>

    

    <h3>发送文件</h3>

      

      <p>在Apache 2.x可以忽略要传递的文件内容的情况下（例如，在提供静态文件内容时），如果操作系统支持，则通常使用内核sendfile对文件的支持。 <code>sendfile(2)</code>操作。</p>

      <p>在大多数平台上，使用sendfile通过消除单独的读取和发送机制来提高性能。但是，在某些情况下，使用sendfile可能会损害httpd的稳定性：</p>

      <ul>
        <li>
          <p>某些平台可能破坏了构建系统无法检测到的sendfile支持，尤其是如果这些二进制文件是在另一个盒子上构建的，并且转移到了具有sendfile支持被破坏的机器上的话。</p>
        </li>
        <li>
          <p>使用安装了NFS的文件系统，内核可能无法通过其自己的缓存可靠地为网络文件提供服务。</p>
        </li>
      </ul>

      <p>对于其中两个因素均适用的安装，应使用<code>EnableSendfile off</code>禁用文件内容的sendfile传递。（注意：可以根据每个目录覆盖此指令。）</p>

    

    <h3><a name="process" id="process">流程创建</a></h3>

      

      <p>在Apache 1.3之前<code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code> ， <code class="directive"><a href="../mod/prefork.html#maxspareservers">MaxSpareServers</a></code>和<code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code>设置都对基准结果产生了巨大影响。特别是，Apache需要一个“启动”期才能达到足以满足所施加负载的子级数。最初产卵后<code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code>孩子，每秒只会创建一个孩子来满足<code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code>设置。因此，使用默认设置，可以同时由100个客户端访问一台服务器<code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code>的<code>5</code>大约需要95秒才能产生足够的孩子来处理负载。实际上，这在现实生活中的服务器上效果很好，因为它们不经常重启。但是，在只能运行十分钟的基准测试上，它的性能确实很差。</p>

      <p>实施每秒一秒的规则是为了避免随着新子代的启动而淹没机器。如果机器忙于产生子代，则无法处理请求。但是它对Apache的感知性能产生了巨大的影响，因此必须将其替换。从Apache 1.3开始，代码将放宽每秒规则。它会先生成一个，然后等待一秒钟，然后再生成两个，然后等待一秒钟，再生成四个，然后它会以指数方式继续运行，直到每秒每秒生成32个孩子。只要满足以下条件，它将停止<code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code>设置。</p>

      <p>这似乎足够灵敏，几乎不需要扭动<code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code> ， <code class="directive"><a href="../mod/prefork.html#maxspareservers">MaxSpareServers</a></code>和<code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code>旋钮。每秒产生4个以上的子代时，将向该子代发送一条消息。 <code class="directive"><a href="../mod/core.html#errorlog">ErrorLog</a></code> 。如果您看到很多此类错误，请考虑调整这些设置。使用<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>输出作为指导。</p>

    <p>与流程创建相关的是由<code class="directive"><a href="../mod/mpm_common.html#maxconnectionsperchild">MaxConnectionsPerChild</a></code>设置。默认情况下是<code>0</code> ，这意味着每个孩子处理的连接数没有限制。如果您的配置当前将此值设置为一个非常小的数字，例如<code>30</code> ，您可能希望将其大大提高。如果您运行的是SunOS或旧版本的Solaris，请将其限制为<code>10000</code>大概是因为内存泄漏。</p>

    <p>使用保持活动状态时，孩子将一直忙于不做任何事情，等待已打开的连接上的更多请求。默认值<code class="directive"><a href="../mod/core.html#keepalivetimeout">KeepAliveTimeout</a></code>的<code>5</code>秒尝试最小化此影响。这里的权衡是在网络带宽和服务器资源之间。在任何情况下，您都不应在此方面提出以上问题<code>60</code>秒，因为<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-4.html">大多数收益都丧失了</a> 。</p>

    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="compiletime" id="compiletime">编译时配置问题</a></h2>

    

    <h3>选择一个MPM</h3>

      

      <p>Apache 2.x支持可插入的并发模型，称为<a href="../mpm.html">多处理模块</a> （MPM）。构建Apache时，必须选择要使用的MPM。对于某些平台，存在特定于平台的MPM： <code class="module"><a href="../mod/mpm_netware.html">mpm_netware</a></code> ， <code class="module"><a href="../mod/mpmt_os2.html">mpmt_os2</a></code>和<code class="module"><a href="../mod/mpm_winnt.html">mpm_winnt</a></code> 。对于一般的Unix类型的系统，有几种MPM可供选择。MPM的选择会影响httpd的速度和可伸缩性：</p>

      <ul>

        <li>的<code class="module"><a href="../mod/worker.html">worker</a></code> MPM使用具有多个线程的多个子进程。每个线程一次处理一个连接。通常，对于高流量服务器，Worker是一个不错的选择，因为它的内存占用空间比前叉MPM小。</li>
        
        <li>的<code class="module"><a href="../mod/event.html">event</a></code> MPM的线程类似于Worker MPM，但旨在通过将一些处理工作转交给支持线程来释放更多的主线程以处理新请求，从而允许同时处理更多请求。</li>

        <li>的<code class="module"><a href="../mod/prefork.html">prefork</a></code> MPM使用多个子进程，每个子进程都有一个线程。每个进程一次处理一个连接。在许多系统上，prefork的速度可与worker媲美，但它使用更多的内存。在某些情况下，Prefork的无线程设计比工作线程具有优势：它可以与非线程安全的第三方模块一起使用，并且在具有较差的线程调试支持的平台上调试起来更容易。</li>

      </ul>

      <p>有关这些和其他MPM的更多信息，请参阅MPM <a href="../mpm.html">文档</a> 。</p>

    

    <h3><a name="modules" id="modules">模组</a></h3>

        

        <p>由于内存使用是性能中的重要考虑因素，因此您应尝试消除实际上不使用的模块。如果您已将模块构建为<a href="../dso.html">DSO</a> ，则消除模块是注释掉相关联的简单问题<code class="directive"><a href="../mod/mod_so.html#loadmodule">LoadModule</a></code>该模块的指令。这使您可以尝试删除模块，并查看您的站点在缺少模块的情况下是否仍能正常运行。</p>

        <p>另一方面，如果您有静态链接到Apache二进制文件中的模块，则需要重新编译Apache才能删除不需要的模块。</p>

        <p>当然，这里出现的一个相关问题是，您需要哪些模块，不需要哪些模块。当然，这里的答案会因一个网站而异。但是，您可以使用的<em>最少</em>模块列表通常包括<code class="module"><a href="../mod/mod_mime.html">mod_mime</a></code> ， <code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code>和<code class="module"><a href="../mod/mod_log_config.html">mod_log_config</a></code> 。 <code>mod_log_config</code>当然是可选的，因为您可以运行没有日志文件的网站。但是，不建议这样做。</p>

    

    <h3>原子操作</h3>

      

      <p>一些模块，例如<code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code>最新的工作程序MPM构建使用APR的原子API。该API提供了可用于轻量级线程同步的原子操作。</p>

      <p>默认情况下，APR使用每个目标OS / CPU平台上可用的最有效机制来实现这些操作。例如，许多现代CPU都具有在硬件中执行原子比较和交换（CAS）操作的指令。但是，在某些平台上，APR默认使用原子API的基于互斥体的较慢实现，以确保与缺少此类指令的较旧CPU模型兼容。如果您要为这些平台之一构建Apache，并且计划仅在较新的CPU上运行，则可以通过在Apache上使用以下命令配置Apache，从而在构建时选择更快的原子实现。 <code>--enable-nonportable-atomics</code>选项：</p>

      <div class="example"><p><code>./buildconf<br> ./configure --with-mpm=worker --enable-nonportable-atomics=yes</code></p></div>

      <p>的<code>--enable-nonportable-atomics</code>该选项与以下平台有关：</p>

      <ul>

        <li>SPARC上的Solaris<br>默认情况下，APR在Solaris / SPARC上使用基于互斥锁的原子。如果您配置<code>--enable-nonportable-atomics</code>但是，APR生成的代码使用SPARC v8plus操作码进行快速的硬件比较和交换。如果使用此选项配置Apache，则原子操作将更高效（允许更低的CPU使用率和更高的并发性），但是生成的可执行文件将仅在UltraSPARC芯片上运行。
        </li>

        <li>Linux在x86上<br>默认情况下，APR在Linux上使用基于互斥锁的原子。如果您配置<code>--enable-nonportable-atomics</code>但是，APR生成的代码使用486操作码进行快速的硬件比较和交换。这将导致更有效的原子操作，但是生成的可执行文件将仅在486和更高版本的芯片上运行（而不是386）。
        </li>

      </ul>

    

    <h3>mod_status和ExtendedStatus On</h3>

      

      <p>如果包括<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>你也设定<code>ExtendedStatus On</code>在构建和运行Apache时，Apache会对每个请求执行两次调用<code>gettimeofday(2)</code> （要么<code>times(2)</code>取决于您的操作系统），以及（1.3之前的版本）对<code>time(2)</code> 。这样做是为了使状态报告包含时序指示。为了获得最佳性能，请设置<code>ExtendedStatus off</code> （默认设置）。</p>

    

    <h3>接受序列化-多个套接字</h3>

      

    <div class="warning"><h3>警告：</h3>
      <p>考虑到在Apache HTTP Server 2.x版本中所做的更改，本部分尚未完全更新。一些信息可能仍然有用，但请谨慎使用。</p>
    </div>

      <p>这讨论了Unix套接字API中的一个缺点。假设您的网络服务器使用多个<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>在多个端口或多个地址上侦听的语句。为了测试每个套接字以查看连接是否就绪，Apache使用<code>select(2)</code> 。 <code>select(2)</code>表示套接字上<em>有零个</em>或<em>至少一个</em>连接正在等待。Apache的模型包含多个子级，所有空闲的子级同时测试新连接。一个简单的实现看起来像这样（这些示例与代码不匹配，它们被设计用于教学目的）：</p>

      <pre class="prettyprint lang-c">        for (;;) {
          for (;;) {
            fd_set accept_fds;

            FD_ZERO (&amp;accept_fds);
            for (i = first_socket; i &lt;= last_socket; ++i) {
              FD_SET (i, &amp;accept_fds);
            }
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);
            if (rc &lt; 1) continue;
            new_connection = -1;
            for (i = first_socket; i &lt;= last_socket; ++i) {
              if (FD_ISSET (i, &amp;accept_fds)) {
                new_connection = accept (i, NULL, NULL);
                if (new_connection != -1) break;
              }
            }
            if (new_connection != -1) break;
          }
          process_the(new_connection);
        }</pre>


      <p>但是，这种幼稚的实现存在严重的饥饿问题。回想一下，多个子进程同时执行此循环，因此多个子进程将在<code>select</code>当它们处于两次请求之间时。所有那些被封锁的孩子将醒来并从<code>select</code>当任何请求出现在任何套接字上时。（唤醒的孩子数量根据操作系统和时间问题而有所不同。）然后他们都将陷入循环并尝试<code>accept</code>连接。但是只有一个能够成功（假设仍然只有一个连接可用）。其余的将被<em>阻止</em> <code>accept</code> 。这有效地将那些子级锁定为能够从该一个套接字（而不是其他套接字）提供请求，并且它们将被卡在那里，直到该套接字上出现足够的新请求以将其唤醒为止。此饥饿问题最早在<a href="http://bugs.apache.org/index/full/467">PR＃467中记录</a> 。至少有两种解决方案。</p>

      <p>一种解决方案是使套接字无阻塞。在这种情况下<code>accept</code>不会阻止孩子，他们将被允许立即继续。但这浪费了CPU时间。假设您有十个空闲的孩子<code>select</code> ，并且一个连接到达。然后其中9个孩子会醒来，尝试<code>accept</code>连接失败并循环回<code>select</code> ，什么也没做。同时，这些子级中的任何一个都不会为其他套接字上发生的请求提供服务，直到它们恢复到<code>select</code>再次。总体而言，除非您拥有（在多处理器设备中）闲置的CPU数量与孩子的闲置数量（不太可能的情况）一样，否则该解决方案似乎效果不佳。</p>

      <p>Apache使用的另一种解决方案是将条目序列化到内部循环中。循环如下所示（差异突出显示）：</p>

      <pre class="prettyprint lang-c">        for (;;) {
          <strong>accept_mutex_on ();</strong>
          for (;;) {
            fd_set accept_fds;
            
            FD_ZERO (&amp;accept_fds);
            for (i = first_socket; i &lt;= last_socket; ++i) {
              FD_SET (i, &amp;accept_fds);
            }
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);
            if (rc &lt; 1) continue;
            new_connection = -1;
            for (i = first_socket; i &lt;= last_socket; ++i) {
              if (FD_ISSET (i, &amp;accept_fds)) {
                new_connection = accept (i, NULL, NULL);
                if (new_connection != -1) break;
              }
            }
            if (new_connection != -1) break;
          }
          <strong>accept_mutex_off ();</strong>
          process the new_connection;
        }</pre>


      <p><a id="serialize" name="serialize">功能</a> <code>accept_mutex_on</code>和<code>accept_mutex_off</code>实施互斥信号灯。任何时候只有一个孩子可以使用该互斥锁。实现这些互斥有多种选择。选择定义在<code>src/conf.h</code> （1.3版之前）或<code>src/include/ap_config.h</code> （1.3或更高版本）。有些架构没有任何锁定选择，在这些架构上，使用多个<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>指令。</p>

      <p>的<code class="directive"><a href="../mod/core.html#mutex">Mutex</a></code>指令可用于更改互斥量的实现<code>mpm-accept</code>在运行时互斥。该指令记录了不同互斥量实现的特殊注意事项。</p>

      <p>已经考虑但从未实现的另一种解决方案是部分序列化循环-即，让一定数量的进程进入。仅在多处理器盒可能同时运行多个子代的情况下，这才有意义，而序列化实际上并没有利用全部带宽。这是未来研究的可能领域，但是由于高度并行的Web服务器不是标准，因此优先级仍然很低。</p>

      <p>理想情况下，您应运行多个服务器<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>语句，如果您想要最高的性能。但是请继续阅读。</p>

    

    <h3>接受序列化-单插槽</h3>

      

      <p>上面对于多个套接字服务器来说是不错的选择，但是对于单个套接字服务器呢？从理论上讲，他们不应该遇到任何相同的问题，因为所有孩子都可以阻止<code>accept(2)</code>直到连接到达，并且没有饥饿。在实践中，这几乎隐藏了非阻塞解决方案中上面讨论的“旋转”行为。在大多数TCP堆栈的实现方式中，内核实际上唤醒了所有被阻塞的进程<code>accept</code>当单个连接到达时。这些进程之一获取连接并返回到用户空间。其余的在内核中旋转并在他们发现没有连接时回到睡眠状态。这种旋转从用户区代码中隐藏了，但是仍然存在。这可能会导致与多套接字案例的非阻塞解决方案相同的负载高峰浪费行为。</p>

      <p>由于这个原因，我们发现，即使序列化单个套接字的情况，许多体系结构的表现也都“更好”。因此，几乎在所有情况下，这实际上都是默认设置。在Linux上进行的粗略实验（双奔腾pro 166 w / 128Mb RAM上的2.0.30）表明，与未序列化的单插槽相比，单插槽的序列化导致每秒请求减少不到3％。但是未序列化的单路套接字在每个请求上显示了额外的100毫秒延迟。这种延迟可能是长途运输线路上的麻烦，而只是LAN上的一个问题。如果要覆盖单个套接字序列化，则可以定义<code>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</code> ，然后单路服务器将根本不会序列化。</p>

    

    <h3>徘徊关闭</h3>

      

      <p>如在<a href="http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-connection-00.txt">draft-ietf-http-connection-00.txt</a>部分8中所讨论的，为了使HTTP服务器<strong>可靠地</strong>实现该协议，它需要独立关闭每个通信方向。（回想一下，TCP连接是双向的。每个部分彼此独立。）</p>

      <p>当此功能添加到Apache时，由于目光短浅，在各种版本的Unix上引起了一系列问题。TCP规范未声明<code>FIN_WAIT_2</code>状态有一个超时，但它不禁止超时。在没有超时的系统上，Apache 1.2会导致许多套接字永久卡在<code>FIN_WAIT_2</code>州。在许多情况下，可以通过简单地升级到供应商提供的最新TCP / IP修补程序来避免这种情况。在供应商从来没有发布补丁的情况下（ <em>即</em> SunOS4 -虽然有源码许可人可以修补它自己），我们决定禁用此功能。</p>

      <p>有两种方法可以完成此操作。一种是套接字选项<code>SO_LINGER</code> 。但是，正如命运所愿，这在大多数TCP / IP堆栈中从未得到正确实现。即使在具有适当实现的堆栈（ <em>即</em> Linux 2.0.31）上，该方法也被证明比下一个解决方案更昂贵（cputime）。</p>

      <p>在大多数情况下，Apache通过称为<code>lingering_close</code> （在<code>http_main.c</code> ）。该函数大致如下所示：</p>

      <pre class="prettyprint lang-c">        void lingering_close (int s)
        {
          char junk_buffer[2048];
          
          /* shutdown the sending side */
          shutdown (s, 1);

          signal (SIGALRM, lingering_death);
          alarm (30);

          for (;;) {
            select (s for reading, 2 second timeout);
            if (error) break;
            if (s is ready for reading) {
              if (read (s, junk_buffer, sizeof (junk_buffer)) &lt;= 0) {
                break;
              }
              /* just toss away whatever is here */
            }
          }
          
          close (s);
        }</pre>


      <p>这自然会在连接结束时增加一些开销，但是这是可靠实现所必需的。随着HTTP / 1.1越来越流行，并且所有连接都是持久性的，这笔费用将在更多请求上摊销。如果您想玩火并禁用此功能，则可以定义<code>NO_LINGCLOSE</code> ，但是完全不建议这样做。特别是，随着HTTP / 1.1流水线式持久连接的使用， <code>lingering_close</code>是绝对必要的（ <a href="http://www.w3.org/Protocols/HTTP/Performance/Pipeline.html">流水线连接速度更快</a> ，因此您要支持它们）。</p>

    

    <h3>记分板文件</h3>

      

      <p>Apache的父母和孩子通过称为记分板的方式相互交流。理想情况下，这应该在共享内存中实现。对于那些我们可以访问或已为其提供详细端口的操作系统，通常使用共享内存来实现。其余默认使用磁盘文件。磁盘上的文件不仅速度慢，而且不可靠（功能较少）。仔细阅读<code>src/main/conf.h</code>文件用于您的体系结构，然后查找<code>USE_MMAP_SCOREBOARD</code>要么<code>USE_SHMGET_SCOREBOARD</code> 。定义这两个中的一个（及其同伴） <code>HAVE_MMAP</code>和<code>HAVE_SHMGET</code>分别启用提供的共享内存代码。如果您的系统还有其他类型的共享内存，请编辑文件<code>src/main/http_main.c</code>并添加在Apache中使用它所需的钩子。（也请向我们发送补丁。）</p>

      <div class="note">历史记录：Apache的Linux端口直到Apache 1.2版才开始使用共享内存。这种疏忽导致Linux上早期版本的Apache的行为非常糟糕且不可靠。</div>

    

    <h3>DYNAMIC_MODULE_LIMIT</h3>

      

      <p>如果您不打算使用动态加载的模块（如果您正在阅读本文并针对每一个性能指标调整服务器，则可能不打算这样做），则应添加<code>-DDYNAMIC_MODULE_LIMIT=0</code>在构建服务器时。这将节省仅用于支持动态加载模块的RAM。</p>

    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="trace" id="trace">附录：跟踪的详细分析</a></h2>

    

    <p>这是Solaris 8上具有工作程序MPM的Apache 2.0.38的系统调用跟踪。使用以下方法收集此跟踪：</p>

    <div class="example"><p><code>truss -l -p <var>httpd_child_pid</var>.</code></p></div>

    <p>的<code>-l</code>选项告诉truss记录调用每个系统调用的LWP（轻量级进程– Solaris的内核级线程形式）的ID。</p>

    <p>其他系统可能具有不同的系统调用跟踪实用程序，例如<code>strace</code> ， <code>ktrace</code> ， 要么<code>par</code> 。它们都产生相似的输出。</p>

    <p>在此跟踪中，客户端从httpd请求了10KB静态文件。非静态请求或具有内容协商的请求的痕迹看起来截然不同（在某些情况下非常难看）。</p>

    <div class="example"><pre>/67:    accept(3, 0x00200BEC, 0x00200C0C, 1) (sleeping...)
/67:    accept(3, 0x00200BEC, 0x00200C0C, 1)            = 9</pre></div>

    <p>在此跟踪中，侦听器线程在LWP＃67中运行。</p>

    <div class="note">注意缺乏<code>accept(2)</code>序列化。在此特定平台上，工作程序MPM默认情况下使用非序列化接受，除非它正在多个端口上侦听。</div>

    <div class="example"><pre>/65:    lwp_park(0x00000000, 0)                         = 0
/67:    lwp_unpark(65, 1)                               = 0</pre></div>

    <p>接受连接后，侦听器线程将唤醒工作线程以进行请求处理。在此跟踪中，将处理请求的工作线程映射到LWP＃65。</p>

    <div class="example"><pre>/65:    getsockname(9, 0x00200BA4, 0x00200BC4, 1)       = 0</pre></div>

    <p>为了实现虚拟主机，Apache需要知道用于接受连接的本地套接字地址。在许多情况下（例如没有虚拟主机或<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>使用没有通配符地址的指令）。但是，尚未做出任何优化。</p>

    <div class="example"><pre>/65:    brk(0x002170E8)                                 = 0
/65:    brk(0x002190E8)                                 = 0</pre></div>

    <p>的<code>brk(2)</code>调用从堆中分配内存。在系统调用跟踪中很少看到这些内容，因为httpd使用自定义内存分配器（ <code>apr_pool</code>和<code>apr_bucket_alloc</code> ）进行大多数请求处理。在此跟踪中，httpd刚刚启动，因此必须调用<code>malloc(3)</code>获取用于创建自定义内存分配器的原始内存块。</p>

    <div class="example"><pre>/65:    fcntl(9, F_GETFL, 0x00000000)                   = 2
/65:    fstat64(9, 0xFAF7B818)                          = 0
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B910, 2190656) = 0
/65:    fstat64(9, 0xFAF7B818)                          = 0
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B914, 2190656) = 0
/65:    setsockopt(9, 65535, 8192, 0xFAF7B918, 4, 2190656) = 0
/65:    fcntl(9, F_SETFL, 0x00000082)                   = 0</pre></div>

    <p>接下来，工作线程以非阻塞模式将与客户端的连接（文件描述符9）。的<code>setsockopt(2)</code>和<code>getsockopt(2)</code>调用是Solaris libc处理方式的副作用<code>fcntl(2)</code>在套接字上。</p>

    <div class="example"><pre>/65:    read(9, " G E T   / 1 0 k . h t m".., 8000)     = 97</pre></div>

    <p>工作线程从客户端读取请求。</p>

    <div class="example"><pre>/65:    stat("/var/httpd/apache/httpd-8999/htdocs/10k.html", 0xFAF7B978) = 0
/65:    open("/var/httpd/apache/httpd-8999/htdocs/10k.html", O_RDONLY) = 10</pre></div>

    <p>此httpd已配置为<code>Options FollowSymLinks</code>和<code>AllowOverride None</code> 。因此，它不需要<code>lstat(2)</code>指向请求文件的路径中的每个目录，也不检查<code>.htaccess</code>文件。它只是调用<code>stat(2)</code>验证文件：1）存在，并且2）是常规文件，而不是目录。</p>

    <div class="example"><pre>/65:    sendfilev(0, 9, 0x00200F90, 2, 0xFAF7B53C)      = 10269</pre></div>

    <p>在此示例中，httpd能够通过单个发送HTTP响应标头和请求的文件<code>sendfilev(2)</code>系统调用。Sendfile语义在操作系统之间有所不同。在其他一些系统上，有必要执行<code>write(2)</code>要么<code>writev(2)</code>呼叫前先发送标题<code>sendfile(2)</code> 。</p>

    <div class="example"><pre>/65:    write(4, " 1 2 7 . 0 . 0 . 1   -  ".., 78)      = 78</pre></div>

    <p>这个<code>write(2)</code>调用将请求记录在访问日志中。请注意，此跟踪中缺少的一件事是<code>time(2)</code>呼叫。与Apache 1.3不同，Apache 2.x使用<code>gettimeofday(3)</code>查找时间。在某些操作系统（例如Linux或Solaris）上， <code>gettimeofday</code>具有优化的实现，不需要像典型的系统调用那样大的开销。</p>

    <div class="example"><pre>/65:    shutdown(9, 1, 1)                               = 0
/65:    poll(0xFAF7B980, 1, 2000)                       = 1
/65:    read(9, 0xFAF7BC20, 512)                        = 0
/65:    close(9)                                        = 0</pre></div>

    <p>辅助线程会持续关闭连接。</p>

    <div class="example"><pre>/65:    close(10)                                       = 0
/65:    lwp_park(0x00000000, 0)         (sleeping...)</pre></div>

    <p>最后，工作线程关闭它刚刚传递的文件并阻塞，直到侦听器为它分配另一个连接。</p>

    <div class="example"><pre>/67:    accept(3, 0x001FEB74, 0x001FEB94, 1) (sleeping...)</pre></div>

    <p>同时，侦听器线程将连接分配给工作线程后，便能够接受另一个连接（受工作线程MPM中某些流控制逻辑的约束，如果所有可用工作线程都处于忙碌状态，则会限制侦听器）。尽管从此痕迹中看不出来，但下一个<code>accept(2)</code>可能（通常在高负载条件下也会发生）与工作线程对刚刚接受的连接的处理并行发生。</p>

  </div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>