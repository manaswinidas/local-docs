<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>Apache 1.3 API注释-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">开发人员文档</a></div><div id="page-content"><div id="preamble"><h1>Apache 1.3 API注释</h1>


    <div class="warning"><h3>警告</h3>
      <p>尚未更新本文档，以考虑到Apache HTTP Server 2.0版中所做的更改。一些信息可能仍然有用，但请谨慎使用。</p>
    </div>

    <p>这些是关于Apache API以及您必须处理的数据结构的一些说明<em>。</em>它们尚不完整，但是希望它们能帮助您理解。请记住，随着我们积累经验，API仍可能会发生变化。（有关<em>可能</em>发生的情况，请参见TODO文件）。但是，很容易使模块适应所做的任何更改。（我们比您有更多的模块可以适应）。</p>

    <p>这里有一些关于一般教学风格的注意事项。为了简洁起见，此处的所有结构声明都不完整-实际的声明还有更多我没有告诉您的位置。在大多数情况下，这些保留给服务器核心的一个组件或另一个组件，并且应谨慎使用模块进行更改。但是，在某些情况下，它们确实是我尚未了解的事情。欢迎来到前沿。</p>

    <p>最后，这是一个概述，以使您对即将发生的事情和顺序有一些粗略的了解：</p>

    <ul>
      <li>
        <a href="#basics">基本概念。</a>

        <ul>
          <li><a href="#HMR">处理程序，模块和请求</a></li>

          <li><a href="#moduletour">模块简介</a></li>
        </ul>
      </li>

      <li>
        <a href="#handlers">处理程序的工作方式</a>

        <ul>
          <li><a href="#req_tour">简要浏览<code>request_rec</code></a></li>

          <li><a href="#req_orig">request_rec结构来自哪里</a></li>

          <li><a href="#req_return">处理请求，拒绝并返回错误代码</a></li>

          <li><a href="#resp_handlers">响应处理程序的特殊注意事项</a></li>

          <li><a href="#auth_handlers">身份验证处理程序的特殊注意事项</a></li>

          <li><a href="#log_handlers">日志处理程序的特殊注意事项</a></li>
        </ul>
      </li>

      <li><a href="#pools">资源分配和资源池</a></li>

      <li>
        <a href="#config">配置，命令等</a>

        <ul>
          <li><a href="#per-dir">每目录配置结构</a></li>

          <li><a href="#commands">命令处理</a></li>

          <li><a href="#servconf">旁注---每个服务器的配置，虚拟服务器<em>等</em> 。</a></li>
        </ul>
      </li>
    </ul>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#basics">基本概念</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#handlers">处理程序的工作方式</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#pools">资源分配和资源池</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#config">配置，命令等</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="basics" id="basics">基本概念</a></h2>
    <p>我们首先概述API背后的基本概念，以及它们如何在代码中体现。</p>

    <h3><a name="HMR" id="HMR">处理程序，模块和请求</a></h3>
      <p>Apache将请求处理分解为一系列步骤，大致与Netscape服务器API的方式相同（尽管此API比NetSite的步骤多了一些，因为我认为将来可能有用的东西的钩子）。这些是：</p>

      <ul>
      <li>URI->文件名转换</li>
      <li>Auth ID检查[他们说的是用户吗？]</li>
      <li>身份验证访问检查[用户<em>在这里</em>得到授权吗？]</li>
      <li>验证以外的访问检查</li>
      <li>确定所请求对象的MIME类型</li>
      <li>'Fixups'-目前还没有，但是这个阶段是为了吸引可能的扩展，例如<code class="directive"><a href="../mod/mod_env.html#setenv">SetEnv</a></code> ，但在其他地方不太适合。</li>
      <li>实际上将响应发送回客户端。</li>
      <li>记录请求</li>
      </ul>

      <p>通过查看一系列<em>模块</em>中的每个<em>模块</em> ，查看每个<em>模块</em>是否具有该阶段的处理程序，然后尝试调用它们，来处理这些阶段。处理程序通常可以执行以下三种操作之一：</p>

      <ul>
      <li><em>处理</em>请求，并通过返回魔术常数来表明请求已完成<code>OK</code> 。</li>

      <li><em>拒绝</em>处理请求，方法是返回魔术整数常量<code>DECLINED</code> 。在这种情况下，服务器在所有方面都表现得好像处理程序根本不在那儿。</li>

      <li>通过返回HTTP错误代码之一来发出错误信号。尽管可以调用ErrorDocument尝试清除，但这会终止对请求的正常处理，并且在任何情况下都会记录该错误文档。</li>
      </ul>

      <p>大多数阶段都由处理它们的第一个模块终止。但是，对于日志记录，“修复程序”和非访问身份验证检查，所有处理程序始终运行（除非出现错误）。同样，响应阶段是唯一的，因为模块可以通过键入被请求对象的MIME类型的分派表为其声明多个处理程序。模块可以通过指定密钥来声明一个响应阶段处理程序，该处理程序可以处理<em>任何</em>请求<code>*/*</code> （ <em>即</em>通配符MIME类型规范）。但是，仅当服务器已尝试并且未能为请求的对象的MIME类型找到更具体的响应处理程序（不存在或全部拒绝）时，才调用通配符处理程序。</p>

      <p>处理程序本身是一个参数的功能（a <code>request_rec</code>结构体。 vide infra），它返回一个整数，如上所述。</p>
    

    <h3><a name="moduletour" id="moduletour">模块简介</a></h3>
      <p>在这一点上，我们需要解释一个模块的结构。我们的候选人将是CGI模块中的较差者之一，它可以处理CGI脚本和<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>配置文件命令。实际上，它比大多数模块都要复杂得多，但是如果我们只想举一个例子，那么它可能就是在每个地方都用手指指望的例子。</p>

      <p>让我们从处理程序开始。为了处理CGI脚本，模块为它们声明了一个响应处理程序。因为<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code> ，它还具有名称翻译阶段的处理程序（以识别<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code> ed URIs），类型检查阶段（任何<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code> ed请求被键入为CGI脚本）。</p>

      <p>该模块需要维护一些（虚拟）服务器信息，即<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>有效；因此，模块结构包含指向构建这些结构的功能的指针，以及包含将它们两者结合的另一个功能的指针（如果主服务器和虚拟服务器都具有<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>声明）。</p>

      <p>最后，此模块包含用于处理<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>命令本身。这个特定的模块仅声明一个命令，但是可能会声明更多<em>命令</em> ，因此模块具有<em>命令表</em> ，这些<em>表</em>声明了它们的命令，并描述了允许它们的位置以及如何调用它们。</p>

      <p>关于这些命令中某些参数的声明类型的最后说明： <code>pool</code>是指向<em>资源池</em>结构的指针；服务器使用它们来跟踪已分配的内存，打开的文件<em>等</em> ，以服务特定请求或处理配置自身的过程。这样一来，当请求结束（或者，对于配置池，当服务器重新启动），内存可以被释放，并且文件关闭， <em>集体</em> ，而无需编写明确的代码，任何人都可以跟踪所有这些下来，处理它们。也<code>cmd_parms</code>结构包含有关正在读取的配置文件的各种信息以及其他状态信息，这些信息有时会用于处理config-file命令的功能（例如<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code> ）。事不宜迟，该模块本身：</p>

      <div class="example"><p><code>/* Declarations of handlers. */<br> <br> int translate_scriptalias (request_rec *);<br> int type_scriptalias (request_rec *);<br> int cgi_handler (request_rec *);<br> <br> /* Subsidiary dispatch table for response-phase <br>  * handlers, by MIME type */<br> <br> handler_rec cgi_handlers[] = {<br> <span class="indent"> { "application/x-httpd-cgi", cgi_handler },<br> { NULL }<br> </span> };<br> <br> /* Declarations of routines to manipulate the <br>  * module's configuration info. Note that these are<br>  * returned, and passed in, as void *'s; the server<br>  * core keeps track of them, but it doesn't, and can't,<br>  * know their internal structure.<br>  */<br> <br> void *make_cgi_server_config (pool *);<br> void *merge_cgi_server_config (pool *, void *, void *);<br> <br> /* Declarations of routines to handle config-file commands */<br> <br> extern char *script_alias(cmd_parms *, void *per_dir_config, char *fake, char *real);<br> <br> command_rec cgi_cmds[] = {<br> <span class="indent"> { "ScriptAlias", script_alias, NULL, RSRC_CONF, TAKE2,<br> <span class="indent">"a fakename and a realname"},<br></span> { NULL }<br> </span> };<br> <br> module cgi_module = {</code></p><pre>  STANDARD_MODULE_STUFF,
  NULL,                     /* initializer */
  NULL,                     /* dir config creator */
  NULL,                     /* dir merger */
  make_cgi_server_config,   /* server config */
  merge_cgi_server_config,  /* merge server config */
  cgi_cmds,                 /* command table */
  cgi_handlers,             /* handlers */
  translate_scriptalias,    /* filename translation */
  NULL,                     /* check_user_id */
  NULL,                     /* check auth */
  NULL,                     /* check access */
  type_scriptalias,         /* type_checker */
  NULL,                     /* fixups */
  NULL,                     /* logger */
  NULL                      /* header parser */
};</pre></div>
    
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="handlers" id="handlers">处理程序的工作方式</a></h2>
    <p>处理程序的唯一参数是<code>request_rec</code>结构体。该结构描述了代表客户对服务器的特定请求。在大多数情况下，与客户端的每个连接只会生成一个<code>request_rec</code>结构体。</p>

    <h3><a name="req_tour" id="req_tour">request_rec的简要介绍</a></h3>
      <p>的<code>request_rec</code>包含指向资源池的指针，服务器完成处理请求后将清除该资源池；到包含每个服务器和每个连接信息，最重要的是有关请求本身的信息的结构。</p>

      <p>最重要的此类信息是一小串字符串，描述了所请求对象的属性，包括其URI，文件名，内容类型和内容编码（这些内容由处理请求的翻译和类型检查处理程序填写） ， 分别）。</p>

      <p>其他常用的数据项包括在客户端原始请求上提供MIME标头的表，将与响应一起发送回的MIME标头（模块可以随意添加）以及在运行过程中产生的任何子流程的环境变量。服务请求。这些表格是使用<code>ap_table_get</code>和<code>ap_table_set</code>例行程序。</p>

      <div class="note">
        <p>请注意<code>Content-type</code>标题值<em>不能</em>由模块内容处理程序使用来设置<code>ap_table_*()</code>例行程序。相反，它是通过指向<code>content_type</code>中的字段<code>request_rec</code>结构为适当的字符串。 <em>例如</em></p>
        <div class="example"><p><code>r->content_type = "text/html";</code></p></div>
      </div>

      <p>最后，有两个数据结构的指针，它们依次指向每个模块的配置结构。具体来说，这些保持指向模块所构建的数据结构的指针，以描述其被配置为在给定目录中运行的方式（通过<code>.htaccess</code>文件或<code class="directive"><a href="../mod/core.html#directory"><Directory></a></code>部分），对于私有数据，它是在处理请求的过程中建立的（因此，一个阶段的模块处理程序可以将“注释”传递给其他阶段的处理程序）。在配置文件中还有另一个这样的配置向量<code>server_rec</code>指向的数据结构<code>request_rec</code> ，其中包含每个（虚拟）服务器配置数据。</p>

      <p>这是一个简短的声明，提供最常用的字段：</p>

      <div class="example"><p><code>struct request_rec {<br> <br> pool *pool;<br> conn_rec *connection;<br> server_rec *server;<br> <br> /* What object is being requested */<br> <br> char *uri;<br> char *filename;<br> char *path_info;</code></p><pre>char *args;           /* QUERY_ARGS, if any */
struct stat finfo;    /* Set by server core;
                       * st_mode set to zero if no such file */</pre><p><code>char *content_type;<br> char *content_encoding;<br> <br> /* MIME header environments, in and out. Also, <br>  * an array containing environment variables to<br>  * be passed to subprocesses, so people can write<br>  * modules to add to that environment.<br>  *<br>  * The difference between headers_out and <br>  * err_headers_out is that the latter are printed <br>  * even on error, and persist across internal<br>  * redirects (so the headers printed for <br>  * <code class="directive"><a href="../mod/core.html#errordocument">ErrorDocument</a></code> handlers will have them).<br>  */<br> <br> table *headers_in;<br> table *headers_out;<br> table *err_headers_out;<br> table *subprocess_env;<br> <br> /* Info about the request itself... */<br> <br></code></p><pre>int header_only;     /* HEAD request, as opposed to GET */
char *protocol;      /* Protocol, as given to us, or HTTP/0.9 */
char *method;        /* GET, HEAD, POST, <em>etc.</em> */
int method_number;   /* M_GET, M_POST, <em>etc.</em> */</pre><p><code>/* Info for logging */<br> <br> char *the_request;<br> int bytes_sent;<br> <br> /* A flag which modules can set, to indicate that<br>  * the data being returned is volatile, and clients<br>  * should be told not to cache it.<br>  */<br> <br> int no_cache;<br> <br> /* Various other config info which may change<br>  * with .htaccess files<br>  * These are config vectors, with one void*<br>  * pointer for each module (the thing pointed<br>  * to being the module's business).<br>  */<br> <br></code></p><pre>void *per_dir_config;   /* Options set in config files, <em>etc.</em> */
void *request_config;   /* Notes on *this* request */</pre><p><code>};</code></p></div>
    

    <h3><a name="req_orig" id="req_orig">request_rec结构来自哪里</a></h3>
      <p>最<code>request_rec</code>通过从客户端读取HTTP请求并填充字段来构建结构。但是，有一些例外情况：</p>

      <ul>
      <li>如果要求是图片地图，请输入类型地图（ <em>即</em> <code>*.var</code>文件）或返回本地“ Location：”的CGI脚本，那么用户请求的资源将最终由某个URI定位，而不是客户端最初提供的资源。在这种情况下，服务器执行<em>内部重定向</em> ，构造一个新的<code>request_rec</code>为新URI进行处理，几乎就像客户端直接请求新URI一样对其进行处理。</li>

      <li>如果某个处理程序发出错误信号， <code>ErrorDocument</code>在范围上，相同的内部重定向机制也起作用。</li>

      <li><p>最后，处理程序有时需要调查“如果运行其他请求会发生什么”。例如，目录索引模块需要知道将为每个目录条目的请求分配哪种MIME类型，以便找出要使用的图标。</p>

      <p>此类处理程序可以使用函数构造<em>子请求</em> <code>ap_sub_req_lookup_file</code> ， <code>ap_sub_req_lookup_uri</code>和<code>ap_sub_req_method_uri</code> ;这些构成了一个新的<code>request_rec</code>按照您的期望进行结构和处理，直到但不包括实际发送响应的时间。（如果子请求与原始请求位于同一目录中，则这些功能会跳过访问检查）。</p>

      <p>（服务器端通过建立子请求，然后通过函数实际为它们调用响应处理程序来进行工作。 <code>ap_run_sub_req</code> ）。</p>
      </li>
      </ul>
    

    <h3><a name="req_return" id="req_return">处理请求，拒绝并返回错误代码</a></h3>
      <p>如上所述，每个处理程序在被调用以处理特定的<code>request_rec</code> ，必须返回一个<code>int</code>表明发生了什么。那可以是</p>

      <ul>
      <li><code>OK</code> -请求已成功处理。这可能会也可能不会终止该阶段。</li>

      <li><code>DECLINED</code> -不存在错误情况，但模块拒绝处理该阶段；服务器尝试寻找另一个。</li>

      <li>HTTP错误代码，该代码将中止请求的处理。</li>
      </ul>

      <p>请注意，如果返回的错误代码是<code>REDIRECT</code> ，则模块应将<code>Location</code>在请求的<code>headers_out</code> ，指示客户端应重定向<em>到的位置</em> 。</p>
    

    <h3><a name="resp_handlers" id="resp_handlers">响应处理程序的特殊注意事项</a></h3>
      <p>大部分阶段的处理程序都可以通过简单地在<code>request_rec</code>结构（或者，对于访问检查器，只需返回正确的错误代码）。但是，响应处理程序必须实际将请求发送回客户端。</p>

      <p>他们应该先使用函数发送HTTP响应标头<code>ap_send_http_header</code> 。（您不必执行任何特殊操作就可以跳过发送HTTP / 0.9请求的标头；该函数自行指出它不应执行任何操作）。如果请求被标记<code>header_only</code> ，这就是他们应该做的；他们应该在此之后返回，而不尝试任何进一步的输出。</p>

      <p>否则，他们应产生一个请求主体，以适当地响应客户。为此的原语是<code>ap_rputc</code>和<code>ap_rprintf</code> ，用于内部生成的输出，以及<code>ap_send_fd</code> ，复制一些内容<code>FILE *</code>直接向客户。</p>

      <p>在这一点上，您应该或多或少地理解以下代码，这是处理程序<code>GET</code>没有更多特定处理程序的请求；它也显示了条件<code>GET</code>如果需要在特定的响应处理程序中进行处理，则可以处理- <code>ap_set_last_modified</code>检查<code>If-modified-since</code>客户端提供的值（如果有），并返回适当的代码（如果非零，则为USE_LOCAL_COPY）。没有类似的考虑<code>ap_set_content_length</code> ，但会返回一个用于对称的错误代码。</p>

      <div class="example"><p><code>int default_handler (request_rec *r)<br> {<br> <span class="indent"> int errstatus;<br> FILE *f;<br> <br> if (r->method_number != M_GET) return DECLINED;<br> if (r->finfo.st_mode == 0) return NOT_FOUND;<br> <br> if ((errstatus = ap_set_content_length (r, r->finfo.st_size))<br>     || (errstatus = ap_set_last_modified (r, r->finfo.st_mtime)))<br> return errstatus;<br> <br> f = fopen (r->filename, "r");<br> <br> if (f == NULL) {<br> <span class="indent"> log_reason("file permissions deny server access", r->filename, r);<br> return FORBIDDEN;<br> </span> }<br> <br> register_timeout ("send", r);<br> ap_send_http_header (r);<br> <br> if (!r->header_only) send_fd (f, r);<br> ap_pfclose (r->pool, f);<br> return OK;<br> </span> }</code></p></div>

      <p>最后，如果所有这些挑战太大了，那么有几种方法可以解决。首先，如上所述，尚未生成任何输出的响应处理程序可以简单地返回错误代码，在这种情况下，服务器将自动生成错误响应。其次，它可以通过调用其他处理程序<code>ap_internal_redirect</code> ，这是调用上述内部重定向机制的方式。内部重定向的响应处理程序应始终返回<code>OK</code> 。</p>

      <p>（调用<code>ap_internal_redirect</code>来自<em>非</em>响应处理程序的处理程序会导致严重的混乱）。</p>
    

    <h3><a name="auth_handlers" id="auth_handlers">身份验证处理程序的特殊注意事项</a></h3>
      <p>应该在这里详细讨论的东西：</p>

      <ul>
      <li>除非为目录配置了auth，否则不会调用身份验证阶段处理程序。</li>

      <li>存储在核心每目录配置中的通用身份验证配置；它有访问器<code>ap_auth_type</code> ， <code>ap_auth_name</code>和<code>ap_requires</code> 。</li>

      <li>通用例程，用于处理协议末尾，至少对于HTTP基本认证（ <code>ap_get_basic_auth_pw</code> ，这将<code>connection->user</code>自动构造字段，并且<code>ap_note_basic_auth_failure</code> ，安排适当的<code>WWW-Authenticate:</code>标头发送回来）。</li>
      </ul>
    

    <h3><a name="log_handlers" id="log_handlers">日志处理程序的特殊注意事项</a></h3>
      <p>当一个请求在内部被重定向后，就会出现要记录什么的问题。Apache通过将整个重定向链捆绑到<code>request_rec</code>穿过的结构<code>r->prev</code>和<code>r->next</code>指针。的<code>request_rec</code>在这种情况下传递给日志处理程序的是最初为客户端的初始请求而构建的程序；请注意<code>bytes_sent</code>该字段仅在链中的最后一个请求（实际发送了响应的请求）中是正确的。</p>
    
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="pools" id="pools">资源分配和资源池</a></h2>
    <p>编写和设计服务器池服务器的问题之一是防止泄漏，即分配资源（内存，打开的文件<em>等</em> ），而不随后释放它们。资源池机制旨在通过允许以如下方式分配资源来轻松防止这种情况的发生：服务器完成处理后，资源会<em>自动</em>释放。</p>

    <p>其工作方式如下：为处理特定请求而分配的内存，文件打开<em>等</em> ，与为该请求分配的<em>资源池</em>相关联。池是一个数据结构，它本身跟踪有问题的资源。</p>

    <p>处理完请求后，将<em>清除</em>池。届时，将释放与之关联的所有内存以供重用，并关闭与之关联的所有文件，并运行与该池关联的任何其他清除功能。当结束时，我们可以确信与该池相关联的所有资源都已释放，并且没有一个泄漏。</p>

    <p>服务器重新启动，以及按服务器配置的内存和资源分配以类似的方式处理。有一个<em>配置池</em> ，该<em>池</em>跟踪在读取服务器配置文件并处理其中的命令时分配的资源（例如，为每个服务器模块配置分配的内存，日志文件和其他已打开的文件） ，依此类推）。当服务器重新启动并必须重新读取配置文件时，将清除配置池，因此上次读取它们所占用的内存和文件描述符可供重新使用。</p>

    <p>应该注意的是，除了诸如日志记录处理程序之类的情况外，通常不强制使用池机制，在这种情况下，您确实需要注册清除程序以确保在服务器重启时关闭日志文件（这很容易做到）。使用功能<code><a href="#pool-files">ap_pfopen</a></code> ，它还安排在任何子进程（例如CGI脚本）关闭之前关闭基础文件描述符。 <code>exec</code> ed），或者如果您使用超时机制（此处尚未记录）。但是，使用它有两个好处：分配给池的资源永远不会泄漏（即使您分配了临时字符串，也只是忘记了它）；同样，对于内存分配， <code>ap_palloc</code>通常比<code>malloc</code> 。</p>

    <p>我们从描述内存如何分配到池开始，然后讨论资源池机制如何跟踪其他资源。</p>

    <h3>池中的内存分配</h3>
      <p>通过调用函数将内存分配给池<code>ap_palloc</code> ，它有两个参数，一个是指向资源池结构的指针，另一个是要分配的内存量（以<code>char</code> s）。在用于处理请求的处理程序中，获取资源池结构的最常见方法是查看<code>pool</code>相关的广告位<code>request_rec</code> ;因此，以下成语在模块代码中反复出现：</p>

      <div class="example"><p><code>int my_handler(request_rec *r)<br> {<br> <span class="indent"> struct my_structure *foo;<br> ...<br> <br> foo = (foo *)ap_palloc (r->pool, sizeof(my_structure));<br> </span> }</code></p></div>

      <p>请注意， <em>没有<code>ap_pfree</code></em> - <code>ap_palloc</code>仅当清除关联的资源池时，才会释放ed内存。这意味着<code>ap_palloc</code>不必像<code>malloc()</code> ;在典型情况下，它所做的只是舍入大小，增加指针大小和进行范围检查。</p>

      <p>（这也增加了过度使用<code>ap_palloc</code>可能导致服务器进程过大。有两种处理方法，下面介绍；简单地说，您可以使用<code>malloc</code> ，并尝试确保所有内存都明确获得<code>free</code> d，或者您可以分配主池的子池，在子池中分配内存，并定期清除它。后一种技术在下面有关子池的部分中进行了讨论，并在目录索引代码中使用，以避免在列出包含数千个文件的目录时避免过多的存储分配。</p>
    

    <h3>分配初始化的内存</h3>
      <p>有一些函数分配初始化的内存，并且经常有用。功能<code>ap_pcalloc</code>具有与以下相同的界面<code>ap_palloc</code> ，但在返回内存之前先清除它分配的内存。功能<code>ap_pstrdup</code>需要一个资源池和一个<code>char *</code>作为参数，并为指针所指向的字符串副本分配内存，并返回指向副本的指针。最后<code>ap_pstrcat</code>是varargs样式的函数，它使用一个指向资源池的指针，并且至少有两个<code>char *</code>参数，最后一个必须是<code>NULL</code> 。它以一个单位分配足够的内存来容纳每个字符串的副本。例如：</p>

      <div class="example"><p><code>ap_pstrcat (r->pool, "foo", "/", "bar", NULL);</code></p></div>

      <p>返回一个指向8个字节的内存的指针，初始化为<code>"foo/bar"</code> 。</p>
    

    <h3><a name="pools-used" id="pools-used">Apache Web服务器中的常用池</a></h3>
      <p>实际上，池的生命周期定义比其他任何事情都重要。http_main中有一些静态池，它们会在适当的时候作为参数传递给各种非http_main函数。他们来了：</p>

      <dl>
      <dt><code>permanent_pool</code></dt>
      <dd>从未传给其他任何人，这是所有泳池的始祖</dd>

      <dt><code>pconf</code></dt>
      <dd>
        <ul>
          <li>永久池的子池</li>

          <li>在配置“周期”开始时创建；在服务器终止或重新启动之前一直存在；通过cmd-> pool传递给所有配置时间例程，或者作为不占用池的那些传递给“ pool * p”参数</li>

          <li>传递给模块init（）函数</li>
        </ul>
      </dd>

      <dt><code>ptemp</code></dt>
      <dd>
        <ul>
          <li>不好意思，我在1.3版中目前未将此池称为此池，我在pthreads开发中将其重命名为该池。我指的是在父级中使用ptrans ...与之相比，在子级中使用ptrans的更高定义。</li>

          <li>永久池的子池</li>

          <li>在配置“周期”开始时创建；存在直到配置解析结束； <em>通过</em> cmd-> temp_pool传递给配置时例程。有点像“野孩子”，因为它无处不在。用于某些配置例程可能需要的临时暂存空间，但在配置末尾将其删除。</li>
        </ul>
      </dd>

      <dt><code>pchild</code></dt>
      <dd>
        <ul>
          <li>永久池的子池</li>

          <li>在产生一个孩子（或创建一个线程）时创建；一直活到那个孩子（线程）被破坏为止</li>

          <li>传递给模块child_init函数</li>

          <li>在调用child_exit函数之后立即发生销毁...（这可能解释了为什么我认为child_exit是多余且不需要的）</li>
        </ul>
      </dd>

      <dt><code>ptrans</code></dt>
      <dd>
        <ul>
          <li>应该是pchild的子池，但当前是permanent_pool的子池，请参见上文</li>

          <li>在进入accept（）循环以接收连接之前由孩子清除</li>

          <li>用作连接->池</li>
        </ul>
      </dd>

      <dt><code>r->pool</code></dt>
      <dd>
        <ul>
          <li>对于主要请求，这是connection-> pool的子池；对于子请求，它是父请求池的子池。</li>

          <li>一直存在直到请求结束（ <em>即</em> ap_destroy_sub_req，或者process_request完成后在child_main中）</li>

          <li>注意，r本身是从r-> pool分配的； <em>即</em> ，首先创建r-> pool，然后首先从中创建r palloc（）d</li>
        </ul>
      </dd>
      </dl>

      <p>对于几乎所有人所做的一切， <code>r->pool</code>是要使用的池。但是您可以看到其他生存期（例如pchild）对于某些模块有什么用处……例如需要每个孩子一次打开数据库连接，并希望在孩子死后对其进行清理的模块。</p>

      <p>您还可以查看一些错误是如何表现出来的，例如设置<code>connection->user</code>到一个值<code>r->pool</code> -在这种情况下存在连接<code>ptrans</code> ，比<code>r->pool</code> （特别是如果<code>r->pool</code>是一个子请求！）。所以正确的做法是从<code>connection->pool</code> 。</p>

      <p>还有一个有趣的错误<code class="module"><a href="../mod/mod_include.html">mod_include</a></code> / <code class="module"><a href="../mod/mod_cgi.html">mod_cgi</a></code> 。您会在这些工具中看到他们进行了此测试，以确定是否应该使用<code>r->pool</code>要么<code>r->main->pool</code> 。在这种情况下，他们正在注册用于清除的资源是一个子进程。如果在<code>r->pool</code> ，那么代码将<code>wait()</code>子请求结束时为孩子提供服务。用<code class="module"><a href="../mod/mod_include.html">mod_include</a></code>这可能是任何旧的<code>#include</code> ，并且延迟可能长达3秒...并且经常发生。而是将子流程注册到<code>r->main->pool</code>这会导致在整个请求完成后（ <em>即</em> ，在将输出发送到客户端并进行日志记录之后）将其清除。</p>
    

    <h3><a name="pool-files" id="pool-files">跟踪打开的文件等</a></h3>
      <p>如上所述，资源池还用于跟踪内存以外的其他种类的资源。最常见的是打开的文件。通常用于此的例程是<code>ap_pfopen</code> ，它以资源池和两个字符串为参数；字符串与典型的参数相同<code>fopen</code> ， <em>例如</em></p>

      <div class="example"><p><code>...<br> FILE *f = ap_pfopen (r->pool, r->filename, "r");<br> <br> if (f == NULL) { ... } else { ... }<br></code></p></div>

      <p>还有一个<code>ap_popenf</code>例行程序，与较低层级相似<code>open</code>系统调用。这两个例程都安排在清除相关资源池时关闭文件。</p>

      <p>与内存不同，有<em>一些</em>函数可以关闭分配有<code>ap_pfopen</code>和<code>ap_popenf</code> ，即<code>ap_pfclose</code>和<code>ap_pclosef</code> 。（这是因为在许多系统上，单个进程可以打开的文件数量非常有限）。使用这些功能来关闭分配了文件的文件很重要<code>ap_pfopen</code>和<code>ap_popenf</code> ，因为否则可能会在Linux等系统上导致致命错误，如果相同，则会产生严重错误<code>FILE*</code>关闭不止一次。</p>

      <p>（使用<code>close</code>函数不是强制性的，因为无论如何该文件最终都会关闭，但是在模块正在打开或可能打开很多文件的情况下，您应该考虑使用它。</p>
    

    <h3>其他种类的资源-清理功能</h3>
      <p>更多文字在这里。描述实现文件内容的清理原语；也， <code>spawn_process</code> 。</p>

      <p>泳池清洁活动持续到<code>clear_pool()</code>叫做： <code>clear_pool(a)</code>递归调用<code>destroy_pool()</code>在的所有子池上<code>a</code> ;然后调用所有清理<code>a</code> ;然后释放所有内存<code>a</code> 。
      <code>destroy_pool(a)</code>来电<code>clear_pool(a)</code>然后释放池结构本身。 <em>即</em> <code>clear_pool(a)</code>不删除<code>a</code> ，它只会释放所有资源，您可以立即再次使用它。</p>
    

    <h3>精细控制-创建和处理子池，并带有关于子请求的注释</h3>
      <p>在极少数情况下，过于随意地使用<code>ap_palloc()</code>并且关联的原语可能会导致不希望的挥霍资源分配。您可以通过以下方法处理这种情况：创建一个<em>子池</em> ，在子池中而不是在主池中分配，然后清除或销毁该子池，从而释放与之关联的资源。（这确实<em>是</em>一种罕见的情况；在标准模块集中出现这种情况的唯一情况是列出目录，然后仅列出<em>非常</em>大的目录。不必要地使用此处讨论的原语可能会使您的代码更加繁琐，而收益却很小。</p>

      <p>创建子池的原语是<code>ap_make_sub_pool</code> ，它将另一个池（父池）作为参数。清除主池后，子池将被销毁。通过调用函数，也可以随时清除或销毁子池<code>ap_clear_pool</code>和<code>ap_destroy_pool</code> ， 分别。（不同之处在于<code>ap_clear_pool</code>释放与池关联的资源，而<code>ap_destroy_pool</code>还会取消分配池本身。在前一种情况下，您可以在池中分配新资源，然后再次清除它，依此类推；在后一种情况下，它就消失了）。</p>

      <p>最后一点-子请求有自己的资源池，这些资源池是主请求的资源池的子池。回收与您已分配的子请求关联的资源的礼貌方式（使用<code>ap_sub_req_...</code>功能）是<code>ap_destroy_sub_req</code> ，这将释放资源池。在调用此函数之前，请确保将您关心的所有内容复制到子请求的资源池中可能会分配到不稳定程度较小的位置（例如，其子目录中的文件名） <code>request_rec</code>结构体）。</p>

      <p>（同样，在大多数情况下，您不应该强制调用此函数；典型的子请求仅分配2K左右的内存，并且在清除主请求池后仍将释放该内存。只有在为单个主请求分配许多子请求时，您才应该认真考虑<code>ap_destroy_...</code>功能）。</p>
    
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="config" id="config">配置，命令等</a></h2>
    <p>该服务器的设计目标之一是保持与NCSA 1.3服务器的外部兼容性，即读取相同的配置文件，正确处理其中的所有指令，并且通常是对它们的直接替代。 NCSA。另一方面，另一个设计目标是将尽可能多的服务器功能转移到与单片服务器核心尽可能少的模块中。协调这些目标的唯一方法是将大多数命令的处理从中央服务器移到模块中。</p>

    <p>但是，仅提供模块命令表不足以将它们与服务器核心完全分开。服务器必须记住命令以便以后对它们执行操作。这涉及维护模块专用的数据，这些数据可以是每个服务器或每个目录。大多数事情都是按目录进行的，尤其包括访问控制和授权信息，还包括有关如何根据后缀确定文件类型的信息，这些信息可以通过以下方式进行修改： <code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>和<code class="directive"><a href="../mod/core.html#forcetype">ForceType</a></code>指令等。通常，管理原则是： <em>可以</em>通过目录配置的任何事物<em>都</em>应该是可配置的。每个服务器的信息通常在标准模块集中用于获取类似<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code> es和<code class="directive"><a href="../mod/mod_alias.html#redirect">Redirect</a></code>在请求绑定到基础文件系统中的特定位置之前起作用的。</p>

    <p>模拟NCSA服务器的另一个要求是能够处理每个目录的配置文件，通常称为<code>.htaccess</code>文件，即使在NCSA服务器中，它们也可以包含与访问控制完全无关的指令。因此，在URI->文件名转换之后，但在执行任何其他阶段之前，服务器将沿着转换后的路径名遍历基础文件系统的目录层次结构，以读取任何<code>.htaccess</code>可能存在的文件。然后，读取的信息必须与服务器自己的配置文件中的适用信息<em>合并</em> （从<code class="directive"><a href="../mod/core.html#directory"><Directory></a></code>在部分<code>access.conf</code> ，或者默认为<code>srm.conf</code> ，实际上在大多数情况下的行为几乎与<code><Directory /></code> ）。</p>

    <p>最后，在处理了涉及阅读的请求之后<code>.htaccess</code>文件，我们需要丢弃为处理它们而分配的存储空间。通过将那些结构绑定到每个事务资源池，可以用与解决其他任何类似问题的方法相同的方式解决该问题。</p>

    <h3><a name="per-dir" id="per-dir">每目录配置结构</a></h3>
      <p>让我们看看所有这些如何发挥作用<code>mod_mime.c</code> ，它定义了文件类型处理程序，该处理程序模仿NCSA服务器从后缀确定文件类型的行为。我们将在这里看到的是实现<code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>和<code class="directive"><a href="../mod/mod_mime.html#addencoding">AddEncoding</a></code>命令。这些命令可以出现在<code>.htaccess</code>文件，因此必须在模块的每个目录的私有数据中进行处理，该数据实际上由用于MIME类型和编码信息的两个单独的表组成，声明如下：</p>

      <div class="example"><pre>typedef struct {
    table *forced_types;      /* Additional AddTyped stuff */
    table *encoding_types;    /* Added with AddEncoding... */
} mime_dir_config;</pre></div>

      <p>服务器正在读取配置文件时，或者<code class="directive"><a href="../mod/core.html#directory"><Directory></a></code>部分，其中包括MIME模块的命令之一，它需要创建一个<code>mime_dir_config</code>结构，所以这些命令要起作用。它通过调用在模块的“ create per-dir config slot”中找到的函数来执行此操作，该函数带有两个参数：此配置信息所应用的目录的名称（或<code>NULL</code>对于<code>srm.conf</code> ），以及指向应该在其中进行分配的资源池的指针。</p>

      <p>（如果我们正在阅读<code>.htaccess</code>文件，该资源池是请求的每个请求资源池；否则，它是用于配置数据的资源池，并在重新启动时清除。无论哪种方式，清除池后，要创建的结构都必须消失，这一点很重要，如果有必要，可以在池上注册清除操作。</p>

      <p>对于MIME模块，每目录配置创建功能仅<code>ap_palloc</code> s上面的结构，并创建几个表来填充它。看起来像这样：</p>

      <div class="example"><p><code>void *create_mime_dir_config (pool *p, char *dummy)<br> {<br> <span class="indent"> mime_dir_config *new =<br> <span class="indent"> (mime_dir_config *) ap_palloc (p, sizeof(mime_dir_config));<br> </span> <br> new->forced_types = ap_make_table (p, 4);<br> new->encoding_types = ap_make_table (p, 4);<br> <br> return new;<br> </span> }</code></p></div>

      <p>现在，假设我们已经阅读了<code>.htaccess</code>文件。我们已经有了层次结构中下一个目录的按目录的配置结构。如果<code>.htaccess</code>我们刚刚读的文件没有任何文件<code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>要么<code class="directive"><a href="../mod/mod_mime.html#addencoding">AddEncoding</a></code>命令，其针对MIME模块的每个目录的配置结构仍然有效，我们可以使用它。否则，我们需要以某种方式合并这两个结构。</p>

      <p>为此，服务器调用模块的每目录配置合并功能（如果存在）。该函数带有三个参数：两个要合并的结构，以及在其中分配结果的资源池。对于MIME模块，所有需要做的就是将新的按目录配置结构中的表与父表中的表重叠：</p>

      <div class="example"><p><code>void *merge_mime_dir_configs (pool *p, void *parent_dirv, void *subdirv)<br> {<br> <span class="indent"> mime_dir_config *parent_dir = (mime_dir_config *)parent_dirv;<br> mime_dir_config *subdir = (mime_dir_config *)subdirv;<br> mime_dir_config *new =<br> <span class="indent"> (mime_dir_config *)ap_palloc (p, sizeof(mime_dir_config));<br> </span> <br> new->forced_types = ap_overlay_tables (p, subdir->forced_types,<br> <span class="indent"> parent_dir->forced_types);<br> </span> new->encoding_types = ap_overlay_tables (p, subdir->encoding_types,<br> <span class="indent"> parent_dir->encoding_types);<br> </span> <br> return new;<br> </span> }</code></p></div>

      <p>注意-如果不存在按目录的合并功能，则服务器将仅使用子目录的配置信息，而忽略父目录的配置信息。对于某些模块，它工作得很好（ <em>例如</em> ，对于includes模块，其按目录配置的信息仅包含<code>XBITHACK</code> ），对于这些模块，您不能声明一个，而在模块本身中保留相应的结构槽<code>NULL</code> 。</p>
    

    <h3><a name="commands" id="commands">命令处理</a></h3>
      <p>现在我们有了这些结构，我们需要能够弄清楚如何填充它们。这涉及处理实际<code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>和<code class="directive"><a href="../mod/mod_mime.html#addencoding">AddEncoding</a></code>命令。要查找命令，服务器将在模块的命令表中查找。该表包含有关命令使用多少个参数，以什么格式，允许在哪里等等的信息。该信息足以使服务器使用预解析的参数调用大多数命令处理功能。事不宜迟，让我们看一下<code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>命令处理程序，如下所示（ <code class="directive"><a href="../mod/mod_mime.html#addencoding">AddEncoding</a></code>命令看起来基本相同，此处将不再显示）：</p>

      <div class="example"><p><code>char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct, char *ext)<br> {<br> <span class="indent"> if (*ext == '.') ++ext;<br> ap_table_set (m->forced_types, ext, ct);<br> return NULL;<br> </span> }</code></p></div>

      <p>这个命令处理程序非常简单。如您所见，它包含四个参数，其中两个是预先解析的参数，第三个是有关模块的按目录的配置结构，第四个是指向a的指针。 <code>cmd_parms</code>结构体。该结构包含一堆参数，这些参数经常用于某些（但不是全部）命令，包括资源池（可从中分配内存以及应绑定清理的资源池）以及正在配置的（虚拟）服务器，如果需要，可以从中获取模块的每服务器配置数据。</p>

      <p>该特定命令处理程序异常简单的另一种方式是，它不会遇到任何错误情况。如果存在，则可能返回错误消息，而不是<code>NULL</code> ;这会导致错误输出到服务器的<code>stderr</code> ，然后快速退出（如果它位于主配置文件中）；为一个<code>.htaccess</code>文件中，语法错误记录在服务器错误日志中（连同指示它来自何处），并且请求被退回并带有服务器错误响应（HTTP错误状态，代码500）。</p>

      <p>MIME模块的命令表包含这些命令的条目，如下所示：</p>

      <div class="example"><p><code>command_rec mime_cmds[] = {<br> <span class="indent"> { "AddType", add_type, NULL, OR_FILEINFO, TAKE2,<br> <span class="indent">"a mime type followed by a file extension" },<br></span> { "AddEncoding", add_encoding, NULL, OR_FILEINFO, TAKE2,<br> <span class="indent"> "an encoding (<em>e.g.</em>, gzip), followed by a file extension" },<br> </span> { NULL }<br> </span> };</code></p></div>

      <p>这些表中的条目是：</p>
      <ul>
      <li>命令名称</li>
      <li>处理它的功能</li>
      <li>一种<code>(void *)</code>指针，该指针在<code>cmd_parms</code>命令处理程序的结构---如果同一功能处理了许多相似的命令，这很有用。</li>

      <li>指示命令可能出现位置的位掩码。每个都有对应的掩码位<code>AllowOverride</code>选项和一个额外的掩码位， <code>RSRC_CONF</code> ，表示该命令可能出现在服务器自己的配置文件中，但<em>不会出现</em>在任何<code>.htaccess</code>文件。</li>

      <li>一个标志，指示命令处理程序要预解析多少个参数以及应如何传递它们。
      <code>TAKE2</code>表示两个预先解析的参数。其他选项是<code>TAKE1</code> ，它表示一个预先解析的参数， <code>FLAG</code> ，表示该参数应为<code>On</code>要么<code>Off</code> ，并作为布尔值标志传入， <code>RAW_ARGS</code> ，这会导致服务器为命令提供未解析的原始参数（除了命令名称本身之外的所有内容）。也有<code>ITERATE</code> ，这意味着处理程序看起来与<code>TAKE1</code> ，但是如果存在多个参数，则应多次调用它，最后<code>ITERATE2</code> ，表示命令处理程序看起来像一个<code>TAKE2</code> ，但如果存在更多参数，则应多次调用它，并保持第一个参数不变。</li>

      <li>最后，我们有一个字符串，描述了应该出现的参数。如果实际配置文件中的参数不符合要求，则此字符串将用于帮助提供更具体的错误消息。（您可以放心地离开此<code>NULL</code> ）。</li>
      </ul>

      <p>最后，设置好所有这些之后，我们必须使用它。最终，这是在模块的处理程序中完成的，特别是对于其文件类型处理程序而言，看起来或多或少都是这样。请注意，按目录配置结构是从<code>request_rec</code>的每个目录配置向量，方法是使用<code>ap_get_module_config</code>功能。</p>

      <div class="example"><p><code>int find_ct(request_rec *r)<br> {<br> <span class="indent"> int i;<br> char *fn = ap_pstrdup (r->pool, r->filename);<br> mime_dir_config *conf = (mime_dir_config *)<br> <span class="indent"> ap_get_module_config(r->per_dir_config, &mime_module);<br> </span> char *type;<br> <br> if (S_ISDIR(r->finfo.st_mode)) {<br> <span class="indent"> r->content_type = DIR_MAGIC_TYPE;<br> return OK;<br> </span> }<br> <br> if((i=ap_rind(fn,'.')) < 0) return DECLINED;<br> ++i;<br> <br> if ((type = ap_table_get (conf->encoding_types, &fn[i])))<br> {<br> <span class="indent"> r->content_encoding = type;<br> <br> /* go back to previous extension to try to use it as a type */<br> fn[i-1] = '\0';<br> if((i=ap_rind(fn,'.')) < 0) return OK;<br> ++i;<br> </span> }<br> <br> if ((type = ap_table_get (conf->forced_types, &fn[i])))<br> {<br> <span class="indent"> r->content_type = type;<br> </span> }<br> <br> return OK; </span> }</code></p></div>
    

    <h3><a name="servconf" id="servconf">旁注-每个服务器的配置，虚拟服务器<em>等</em> 。</a></h3>
      <p>每服务器模块配置的基本思想与按目录配置的思想基本相同。有一个创建函数和一个合并函数，在虚拟服务器已部分覆盖基本服务器配置的情况下调用合并函数，并且必须计算一个组合结构。（与按目录配置一样，如果未指定合并功能且在某些虚拟服务器中配置了模块，则默认情况是基本配置将被忽略）。</p>

      <p>唯一的实质区别是，当命令需要配置每个服务器专用模块数据时，它需要转到<code>cmd_parms</code>数据来解决它。这是一个来自alias模块的示例，该示例还指示了如何返回语法错误（请注意，命令处理程序的按目录配置参数声明为虚拟，因为该模块实际上没有按目录配置数据）：</p>

      <div class="example"><p><code>char *add_redirect(cmd_parms *cmd, void *dummy, char *f, char *url)<br> {<br> <span class="indent"> server_rec *s = cmd->server;<br> alias_server_conf *conf = (alias_server_conf *)<br> <span class="indent"> ap_get_module_config(s->module_config,&alias_module);<br> </span> alias_entry *new = ap_push_array (conf->redirects);<br> <br> if (!ap_is_url (url)) return "Redirect to non-URL";<br> <br> new->fake = f; new->real = url;<br> return NULL;<br> </span> }</code></p></div>
    
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>