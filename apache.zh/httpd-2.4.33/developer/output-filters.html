<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>编写输出过滤器的指南-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">开发人员文档</a></div><div id="page-content"><div id="preamble"><h1>编写输出过滤器的指南</h1>


    <p>编写输出滤波器时会遇到许多常见的陷阱；此页面旨在记录针对新过滤器或现有过滤器作者的最佳做法。</p>

    <p>本文档适用于Apache HTTP Server的2.0版和2.2版。它专门针对<code>RESOURCE</code>级或<code>CONTENT_SET</code>级过滤器，尽管有些建议对于所有类型的过滤器都是通用的。</p>
  </div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#basics">过滤器和铲斗旅</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#invocation">过滤器调用</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#brigade">旅团结构</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#buckets">处理桶</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#filtering">过滤旅</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#state">维持状态</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#buffer">缓冲桶</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#nonblock">非阻塞存储桶读取</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rules">输出过滤器的十个规则</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="basics" id="basics">过滤器和铲斗旅</a></h2>
    

    <p>每次调用过滤器时，都会通过一个<em>存储桶旅</em> ，其中包含一系列表示数据内容和元数据的<em>存储桶</em> 。每个桶有<em>桶型</em> ;桶定义和使用了多种存储桶类型<code>httpd</code>核心模块（以及<code>apr-util</code>库，该库提供了bucket brigade接口），但是模块可以自由定义自己的类型。</p>

    <div class="note">必须准备输出过滤器以处理非标准类型的铲斗；除少数例外，过滤器无需关心要过滤的桶的类型。</div>

    <p>过滤器可以使用来判断存储桶是表示数据还是元数据<code>APR_BUCKET_IS_METADATA</code>宏。通常，所有元数据段都应由输出过滤器沿过滤器链向下传递。过滤器可以适当地转换，删除和插入数据桶。</p>

    <p>所有过滤器都必须注意两种元数据存储桶类型： <code>EOS</code>桶类型，以及<code>FLUSH</code>铲斗类型。一个<code>EOS</code> bucket表示已到达响应结束，因此无需再处理其他bucket。一种<code>FLUSH</code> bucket表示过滤器应立即沿过滤器链冲洗所有缓冲的桶（如果适用）。</p>

    <div class="note"><code>FLUSH</code>当内容生成器（或上游过滤器）知道可能有延迟才能发送更多内容时，将发送存储桶。通过传递<code>FLUSH</code>过滤器会立即沿过滤器链下降，确保过滤器不会使客户端等待未决数据的时间超过必要的时间。</div>

    <p>过滤器可以创建<code>FLUSH</code>铲斗，如果需要，将其通过过滤链。产生中<code>FLUSH</code>不必要或太频繁的存储桶会损害网络利用率，因为它可能会强制发送大量的小数据包，而不是发送少量的大数据包。<a href="#nonblock">非阻塞存储桶读取部分</a>介绍了鼓励生成过滤器的情况<code>FLUSH</code>桶。</p>

    <div class="example"><h3>铲斗旅示例</h3><p><code>HEAP FLUSH FILE EOS</code></p></div>

    <p>这显示了可以通过过滤器的铲斗旅。它包含两个元数据存储区（ <code>FLUSH</code>和<code>EOS</code> ）和两个数据段（ <code>HEAP</code>和<code>FILE</code> ）。</p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="invocation" id="invocation">过滤器调用</a></h2>
    

    <p>对于任何给定的请求，一个输出过滤器可能仅被调用一次，并被赋予代表整个响应的单个旅。也有可能针对单个响应调用过滤器的次数与要过滤的内容的大小成正比，每次使过滤器通过一个包含单个存储桶的旅。在任何一种情况下，过滤器都必须正确运行。</p>

    <div class="warning">每次调用时分配一个长寿命内存的输出过滤器可能会消耗与响应大小成比例的内存。需要分配内存的输出过滤器应在每个响应中分配一次；请参阅下面的<a href="#state">维护状态</a> 。</div>

    <p>输出过滤器可以通过存在一个过滤器来区分给定响应的最终调用。 <code>EOS</code>大队。EOS之后，旅中的任何水桶都应忽略。</p>

    <p>输出过滤器绝不能使空的旅通过过滤器链。为了防御起见，过滤器应准备好接受一个空的旅，并且应该返回成功而不必将此旅传递到过滤器链的下方。空旅的处理不应有任何副作用（例如更改过滤器专用的任何状态）。</p>

    <div class="example"><h3>如何处理空旅</h3><pre class="prettyprint lang-c">apr_status_t dummy_filter(ap_filter_t *f, apr_bucket_brigade *bb)
{
    if (APR_BRIGADE_EMPTY(bb)) {
        return APR_SUCCESS;
    }
    ...</pre>
</div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="brigade" id="brigade">旅团结构</a></h2>
    

    <p>桶队是一个双向链接的桶列表。该列表由一个<em>哨兵</em>终止（在两端），该<em>哨兵</em>可以通过将其与由以下方法返回的指针进行比较来区别于常规存储桶<code>APR_BRIGADE_SENTINEL</code> 。哨兵清单实际上不是有效的存储区结构；尝试调用常规存储桶功能（例如<code>apr_bucket_read</code> ）在哨兵上将具有未定义的行为（即会使进程崩溃）。</p>

    <p>遍历和操纵铲斗旅有多种功能和宏。请参阅<a href="http://apr.apache.org/docs/apr-util/trunk/group___a_p_r___util___bucket___brigades.html">apr_buckets.h</a>标头以了解完整的覆盖范围。常用的宏包括：</p>

    <dl>
      <dt><code>APR_BRIGADE_FIRST(bb)</code></dt>
      <dd>返回第bb旅的第一个水桶</dd>

      <dt><code>APR_BRIGADE_LAST(bb)</code></dt>
      <dd>返回bb旅的最后一个水桶</dd>

      <dt><code>APR_BUCKET_NEXT(e)</code></dt>
      <dd>在存储区e之后给出下一个存储区</dd>

      <dt><code>APR_BUCKET_PREV(e)</code></dt>
      <dd>在桶e之前给桶</dd>

    </dl>

    <p>的<code>apr_bucket_brigade</code>结构本身是从池中分配的，因此，如果过滤器创建了一个新的旅，则必须确保正确限制了内存的使用。一个从请求池中分配新旅的过滤器（ <code>r->pool</code> ），例如，每次调用都会违反<a href="#invocation">上述</a>有关内存使用的<a href="#invocation">警告</a> 。此类过滤器应改为在每个请求的第一个调用上创建一个旅，并将该旅存储在其<a href="#state">状态结构中</a> 。</p>

    <div class="warning"><p>通常不建议使用<code>apr_brigade_destroy</code> “摧毁”一个旅，除非您确定该旅将永远不会再使用，即使那样，它也应该很少使用。调用此函数不会释放旅结构使用的内存（因为它来自池），但是关联的池清理未注册。使用<code>apr_brigade_destroy</code>实际上会导致内存泄漏；如果一个“被摧毁”的旅在其收容池被摧毁时也有水桶，那么这些水桶将<em>不会</em>立即被销毁。</p>

    <p>通常，过滤器应使用<code>apr_brigade_cleanup</code>优先于<code>apr_brigade_destroy</code> 。</p></div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="buckets" id="buckets">处理桶</a></h2>

    

    <p>在处理非元数据存储桶时，重要的是要了解“ <code>apr_bucket *</code>对象是数据的抽象<em>表示</em> ：</p>

    <ol>
      <li>存储桶代表的数据量可以具有或可以不具有确定的长度；对于代表不确定长度数据的存储桶， <code>->length</code>字段设置为值<code>(apr_size_t)-1</code> 。例如， <code>PIPE</code>铲斗类型的长度不确定；它们代表管道的输出。</li>

      <li>存储桶代表的数据可能会映射也可能不会映射到内存中。的<code>FILE</code>例如，存储桶类型表示存储在磁盘文件中的数据。</li>
    </ol>

    <p>过滤器使用<code>apr_bucket_read</code>功能。调用此函数时，存储桶可能会<em>变形</em>为其他存储桶类型，也可能会将新存储桶插入存储桶大队。对于表示未映射到内存的数据的存储桶，必须发生这种情况。</p>

    <p>举个例子；考虑一个包含一个<code>FILE</code>代表整个文件的存储桶，大小为24 KB：</p>

    <div class="example"><p><code>FILE(0K-24K)</code></p></div>

    <p>读取此存储桶后，它将从文件中读取一个数据块，然后转换为<code>HEAP</code>存储桶以表示该数据，然后将数据返回给调用方。它还插入一个新的<code>FILE</code>代表文件其余部分的存储桶；之后<code>apr_bucket_read</code>打电话，大队看起来像：</p>

    <div class="example"><p><code>HEAP(8K) FILE(8K-24K)</code></p></div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="filtering" id="filtering">过滤旅</a></h2>
    

    <p>任何输出过滤器的基本功能将是遍历传入的旅并以某种方式转换（或简单地检查）内容。迭代循环的实现对于生成行为良好的输出滤波器至关重要。</p>

    <p>以遍历整个旅的示例为例：</p>

    <div class="example"><h3>输出滤波器错误-不要模仿！</h3><pre class="prettyprint lang-c">apr_bucket *e = APR_BRIGADE_FIRST(bb);
const char *data;
apr_size_t length;

while (e != APR_BRIGADE_SENTINEL(bb)) {
    apr_bucket_read(e, &amp;data, &amp;length, APR_BLOCK_READ);
    e = APR_BUCKET_NEXT(e);
}

return ap_pass_brigade(bb);</pre>
</div>

    <p>上面的实现将消耗与内容大小成比例的内存。如果通过了<code>FILE</code>例如存储桶，整个文件的内容将被读入内存<code>apr_bucket_read</code>呼叫变形<code>FILE</code>斗成一个<code>HEAP</code>桶。</p>

    <p>相反，下面的实现将消耗固定数量的内存来过滤任何旅。需要一个临时旅，每个响应只能分配一次，请参阅“ <a href="#state">维护状态”</a>部分。</p>

    <div class="example"><h3>更好的输出滤波器</h3><pre class="prettyprint lang-c">apr_bucket *e;
const char *data;
apr_size_t length;

while ((e = APR_BRIGADE_FIRST(bb)) != APR_BRIGADE_SENTINEL(bb)) {
    rv = apr_bucket_read(e, &amp;data, &amp;length, APR_BLOCK_READ);
    if (rv) ...;
    /* Remove bucket e from bb. */
    APR_BUCKET_REMOVE(e);
    /* Insert it into  temporary brigade. */
    APR_BRIGADE_INSERT_HEAD(tmpbb, e);
    /* Pass brigade downstream. */
    rv = ap_pass_brigade(f-&gt;next, tmpbb);
    if (rv) ...;
    apr_brigade_cleanup(tmpbb);
}</pre>
</div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="state" id="state">维持状态</a></h2>

    

    <p>需要在每个响应的多个调用上维持状态的过滤器可以使用<code>->ctx</code>其领域<code>ap_filter_t</code>结构体。通常，在这样的结构中存储一个临时旅，以避免每次调用都必须分配一个新的旅，如<a href="#brigade">旅结构</a>一节所述。</p>

    <div class="example"><h3>维护过滤器状态的示例代码</h3><pre class="prettyprint lang-c">struct dummy_state {
    apr_bucket_brigade *tmpbb;
    int filter_state;
    ...
};

apr_status_t dummy_filter(ap_filter_t *f, apr_bucket_brigade *bb)
{
    struct dummy_state *state;
    
    state = f-&gt;ctx;
    if (state == NULL) {
    
        /* First invocation for this response: initialise state structure.
         */
        f-&gt;ctx = state = apr_palloc(f-&gt;r-&gt;pool, sizeof *state);

        state-&gt;tmpbb = apr_brigade_create(f-&gt;r-&gt;pool, f-&gt;c-&gt;bucket_alloc);
        state-&gt;filter_state = ...;
    }
    ...</pre>
</div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="buffer" id="buffer">缓冲桶</a></h2>
    

    <p>如果某个过滤器决定存储存储桶超出单个过滤器函数调用的持续时间（例如，将其存储在<code>->ctx</code>状态结构），则必须将这些存储桶<em>放在一边</em> 。这是必要的，因为某些存储桶类型会提供代表临时资源（例如堆栈内存）的存储桶，这些临时资源在过滤器链完成对旅的处理后将立即超出范围。</p>

    <p>要搁置一个水桶， <code>apr_bucket_setaside</code>函数可以被调用。并非所有存储桶类型都可以保留，但如果成功，存储桶将进行变形以确保其生存期至少与作为参数的池所提供的寿命一样长。 <code>apr_bucket_setaside</code>功能。</p>

    <p>或者， <code>ap_save_brigade</code>可以使用函数，该函数会将所有存储桶移动到一个单独的旅中，该旅中的存储桶的寿命与给定的pool参数一样长。在考虑以下几点时，必须谨慎使用此功能：</p>

    <ol>
      <li>返回时， <code>ap_save_brigade</code>保证返回的旅中的所有存储桶都将代表映射到内存中的数据。如果给定输入旅包含例如<code>PIPE</code>桶， <code>ap_save_brigade</code>将消耗任意数量的内存来存储管道的整个输出。</li>

      <li>什么时候<code>ap_save_brigade</code>从无法保留的存储桶中进行读取，它将始终执行阻塞读取，从而消除了使用<a href="#nonblock">非阻塞存储桶读取</a>的机会。</li>

      <li>如果<code>ap_save_brigade</code>用于不传递非NULL“ <code>saveto</code> （目标）旅参数，该函数将创建一个新的旅，这可能导致内存使用与内容大小成比例，如<a href="#brigade">旅结构</a>部分所述。</li>
    </ol>

    <div class="warning">过滤器必须确保在给定响应（一个包含EOS桶的旅）的最后一次调用期间，处理所有缓冲的数据并将其向下传递到过滤器链中。否则，此类数据将丢失。</div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="nonblock" id="nonblock">非阻塞存储桶读取</a></h2>
    

    <p>的<code>apr_bucket_read</code>功能需要<code>apr_read_type_e</code>参数，确定是否<em>阻塞</em>或<em>非阻塞</em>读取将来自数据源来执行。一个好的过滤器将首先尝试使用非阻塞读取从每个数据桶中读取数据。如果失败了<code>APR_EAGAIN</code> ，然后发送一个<code>FLUSH</code>在过滤器链中进行分类，然后使用阻塞读取重试。</p>

    <p>这种操作模式可确保，如果使用缓慢的内容源，则位于过滤器链下游的所有过滤器都将刷新所有缓冲的存储桶。</p>

    <p>CGI脚本是一个慢速内容源的示例，它被实现为存储桶类型。 <code class="module"><a href="../mod/mod_cgi.html">mod_cgi</a></code>将发送<code>PIPE</code>代表CGI脚本输出的存储桶；在等待CGI脚本产生更多输出时，从此类存储桶读取数据将会阻塞。</p>

    <div class="example"><h3>使用非阻塞存储桶读取的示例代码</h3><pre class="prettyprint lang-c">apr_bucket *e;
apr_read_type_e mode = APR_NONBLOCK_READ;

while ((e = APR_BRIGADE_FIRST(bb)) != APR_BRIGADE_SENTINEL(bb)) {
    apr_status_t rv;

    rv = apr_bucket_read(e, &amp;data, &amp;length, mode);
    if (rv == APR_EAGAIN &amp;&amp; mode == APR_NONBLOCK_READ) {

        /* Pass down a brigade containing a flush bucket: */
        APR_BRIGADE_INSERT_TAIL(tmpbb, apr_bucket_flush_create(...));
        rv = ap_pass_brigade(f-&gt;next, tmpbb);
        apr_brigade_cleanup(tmpbb);
        if (rv != APR_SUCCESS) return rv;

        /* Retry, using a blocking read. */
        mode = APR_BLOCK_READ;
        continue;
    }
    else if (rv != APR_SUCCESS) {
        /* handle errors */
    }

    /* Next time, try a non-blocking read first. */
    mode = APR_NONBLOCK_READ;
    ...
}</pre>
</div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="rules" id="rules">输出过滤器的十个规则</a></h2>
    

    <p>总而言之，这是所有输出过滤器都应遵循的一组规则：</p>

    <ol>
      <li>输出过滤器不应使空的旅通过过滤链，而应容忍通过空的旅。</li>

      <li>输出过滤器必须将所有元数据存储桶传递到过滤器链的下游； <code>FLUSH</code>应通过将所有未决或缓冲的存储桶沿过滤链向下传递来尊重存储桶。</li>

      <li>输出过滤器应忽略在<code>EOS</code>桶。</li>

      <li>输出过滤器必须一次处理固定数量的数据，以确保内存消耗与要过滤的内容的大小不成比例。</li>

      <li>输出过滤器应与存储桶类型无关，并且必须能够处理不熟悉类型的存储桶。</li>

      <li>打电话后<code>ap_pass_brigade</code>为了使一个旅通过过滤器链，输出过滤器应调用<code>apr_brigade_cleanup</code>在重新使用该旅结构之前，确保该旅是空的；输出过滤器永远不要使用<code>apr_brigade_destroy</code>来“摧毁”旅。</li>

      <li>输出过滤器必须<em>搁置</em>超出过滤器功能持续时间保留的所有存储区。</li>

      <li>输出过滤器不得忽略的返回值<code>ap_pass_brigade</code> ，并且必须返回适当的错误以备份过滤器链。</li>

      <li>输出过滤器必须为每个响应仅创建固定数量的存储桶旅，而不是为每次调用创建一个固定数量的存储桶旅。</li>

      <li>输出过滤器应首先尝试从每个数据段中进行非阻塞读取，然后发送<code>FLUSH</code>如果读取阻塞，则在过滤器链中存储桶，然后重试阻塞读取。</li>

    </ol>

  </div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>