<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>为Apache HTTP Server 2.4开发模块-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP服务器</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">开发人员</a></div><div id="page-content"><div id="preamble"><h1>为Apache HTTP Server 2.4开发模块</h1>


<p>本文档说明了如何为Apache HTTP Server 2.4开发模块</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#introduction">介绍</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#basics">定义模块</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#hooking">入门：连接服务器</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#handling">建立一个处理程序</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#configuration">添加配置选项</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#context">上下文感知配置</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#summary">加起来</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#snippets">一些有用的代码片段</a></li>
</ul><h3>也可以看看</h3><ul class="seealso"><li><a href="request.html">Apache 2.4中的请求处理</a></li><li><a href="hooks.html">Apache 2.x挂钩函数</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="introduction" id="introduction">介绍</a></h2>
<h3><a name="what" id="what">我们将在本文档中讨论什么</a></h3>
<p>本文档将通过探索一个名为的示例模块，讨论如何为Apache HTTP Server 2.4创建模块。 <code>mod_example</code> 。在本文档的第一部分中，每当我们访问URL时，本模块的目的就是为您的Web服务器上的现有文件计算并打印出各种摘要值。 <code>http://hostname/filename.sum</code> 。例如，如果我们想知道位于以下位置的文件的MD5摘要值<code>http://www.example.com/index.html</code> ，我们将参观<code>http://www.example.com/index.html.sum</code> 。
</p>

<p>在本文档的第二部分，它涉及配置指令和上下文感知，我们将研究一个简单地将其自己的配置写出给客户端的模块。
</p>


<h3><a name="prerequisites" id="prerequisites">先决条件</a></h3>
<p>首先，最重要的是，您应该具有C编程语言的基本知识。在大多数情况下，我们将尽可能地采用教学方法，并链接到描述示例中使用的功能的文档，但是在许多情况下，有必要要么仅假设“它起作用”，要么进行一些自我探索。各种函数调用的方式和原因。
</p>
<p>最后，您需要基本了解如何在Apache HTTP Server中加载和配置模块，以及如何在尚未拥有Apache头的情况下获取标头，因为这些标头是编译新模块所必需的。
</p>

<h3><a name="compiling" id="compiling">编译模块</a></h3>
<p>要编译本文档中构建的源代码，我们将使用<a href="../programs/apxs.html">APXS</a> 。假设您的源文件名为mod_example.c，则编译，安装和激活模块非常简单：</p>
<div class="example"><pre>apxs -i -a -c mod_example.c</pre></div>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="basics" id="basics">定义模块</a></h2>
<p>
<img src="../images/build_a_mod_3.png" alt="模块名称标签"><br>每个模块都以相同的声明或名称标签（如果需要的话）开头，该声明将模块定义为<em>Apache中的单独实体</em> ：</p>



<pre class="prettyprint lang-c">module AP_MODULE_DECLARE_DATA   example_module =
{ 
    STANDARD20_MODULE_STUFF,
    create_dir_conf, /* Per-directory configuration handler */
    merge_dir_conf,  /* Merge handler for per-directory configurations */
    create_svr_conf, /* Per-server configuration handler */
    merge_svr_conf,  /* Merge handler for per-server configurations */
    directives,      /* Any directives we may have for httpd */
    register_hooks   /* Our hook registering function */
};</pre>



<p>此段代码使服务器知道我们现在已经在系统中注册了一个新模块，并且其名称为<code>example_module</code> 。模块的名称主要用于两件事：<br>
</p>
<ul>
<li>让服务器知道如何使用LoadModule加载模块</li>
<li>为配置中使用的模块设置名称空间</li>
</ul>
<p>现在，我们只关心模块名称的第一个用途，当我们需要加载模块时才起作用：</p>
<pre class="prettyprint lang-config">LoadModule example_module modules/mod_example.so</pre>

<p>本质上，这告诉服务器打开<code>mod_example.so</code>并寻找一个名为<code>example_module</code> 。
</p>
<p>在我们的这个名称标签中，还包含一堆关于我们希望如何处理事情的引用：我们在配置文件或.htaccess中响应哪些指令，如何在特定上下文中操作，以及我们对哪些处理程序感兴趣在Apache HTTP服务中注册。在本文档的后面，我们将返回所有这些元素。
</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="hooking" id="hooking">入门：连接服务器</a></h2>
<h3><a name="hook_intro" id="hook_intro">钩子简介</a></h3>
<p>在Apache HTTP Server 2.4中处理请求时，您需要做的第一件事是在请求处理过程中创建一个钩子。钩子实质上是一条消息，告诉服务器您愿意服务或至少看一眼客户端发出的某些请求。所有处理程序，无论是mod_rewrite，mod_authn _ *，mod_proxy等，都被挂接到请求过程的特定部分。如您所知，模块有不同的用途。一些是身份验证/授权处理程序，其他是文件或脚本处理程序，而其他一些第三模块则重写URI或代理内容。此外，最终，服务器的用户将取决于如何以及何时安装每个模块。因此，服务器本身不假定知道哪个模块负责处理特定请求，而是询问每个模块是否对给定请求感兴趣。然后，由每个模块决定是否像身份验证/授权模块那样轻轻地拒绝服务请求，接受服务请求或拒绝服务请求。<br>
<img src="../images/build_a_mod_2.png" alt="httpd中的钩子处理"><br>为了使诸如mod_example之类的处理程序更容易知道客户端是否在请求我们应处理的内容，服务器具有用于向模块提示是否需要其协助的指令。其中两个是<code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code>和<code class="directive"><a href="../mod/core.html#sethandler">SetHandler</a></code> 。让我们来看一个使用<code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code> 。在我们的示例中，我们希望每个以.sum结尾的请求均由<code>mod_example</code> ，因此我们将添加一个配置指令，该指令指示服务器执行此操作：</p>
<pre class="prettyprint lang-config">AddHandler example-handler .sum</pre>

<p>这告诉服务器的内容如下： <em>每当我们收到以.sum结尾的URI请求时，我们都要让所有模块知道我们正在寻找名称为“ example-handler”的对象</em> 。因此，当服务请求以.sum结尾时，服务器将通知所有模块，该请求应由“ example-handler”服务。稍后您将看到，当我们开始构建mod_example时，我们将检查该处理程序标记是否由<code>AddHandler</code>并根据此标签的值回复服务器。
</p>

<h3><a name="hook_declaration" id="hook_declaration">钩住httpd</a></h3>
<p>首先，我们只想创建一个简单的处理程序，该处理程序在请求特定的URL时便会回复到客户端浏览器，因此，我们现在就无需设置配置处理程序和指令。我们的初始模块定义将如下所示：</p>



<pre class="prettyprint lang-c">module AP_MODULE_DECLARE_DATA   example_module =
{
    STANDARD20_MODULE_STUFF,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    register_hooks   /* Our hook registering function */
};</pre>




<p>这使服务器知道我们对任何花哨的内容都不感兴趣，我们只想挂接到请求并可能处理其中的一些请求。</p> 

<p>我们的示例声明中的参考， <code>register_hooks</code>是我们将创建的用于管理如何连接到请求流程的函数的名称。在此示例模块中，该功能仅具有一个目的。为了创建一个简单的钩子，在所有重写，访问控制等都已处理之后被调用。因此，我们将让服务器知道，我们希望作为最后一个模块之一加入到其进程中：</p>


<pre class="prettyprint lang-c">static void register_hooks(apr_pool_t *pool)
{
    /* Create a hook in the request handler, so we get called when a request arrives */
    ap_hook_handler(example_handler, NULL, NULL, APR_HOOK_LAST);
}</pre>



<p>的<code>example_handler</code> reference是将处理请求的功能。在下一章中，我们将讨论如何创建处理程序。
</p>

<h3><a name="hook_others" id="hook_others">其他有用的钩子</a></h3>
<p>钩入请求处理阶段只是您可以创建的许多钩子之一。其他挂钩方式有：</p>
<ul>
<li><code>ap_hook_child_init</code> ：放置一个在生成子进程时执行的钩子（通常用于在分支服务器后初始化模块）</li>
<li><code>ap_hook_pre_config</code> ：放置一个在读取任何配置数据之前执行的钩子（非常早的钩子）</li>
<li><code>ap_hook_post_config</code> ：放置一个在配置解析后但在服务器分叉之前执行的挂钩</li>
<li><code>ap_hook_translate_name</code> ：在服务器上需要将URI转换为文件名时，放置一个执行钩子（请考虑一下） <code>mod_rewrite</code> ）</li>
<li><code>ap_hook_quick_handler</code> ： 相似<code>ap_hook_handler</code> ，除了它在任何其他请求挂钩（翻译，身份验证，修复程序等）之前运行</li>
<li><code>ap_hook_log_transaction</code> ：放置一个在服务器将要添加当前请求的日志条目时执行的钩子</li>
</ul>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="handling" id="handling">建立一个处理程序</a></h2>
<p>处理程序本质上是一个向服务器发出请求时接收回调的函数。它将当前请求的记录（如何进行，传递了哪些标头和请求，谁发出请求等等）传递给它，并负责告诉服务器对请求不感兴趣或使用提供的工具处理请求。
</p>
<h3><a name="simple_handler" id="simple_handler">一个简单的“你好，世界！”处理程序</a></h3> 
<p>让我们从制作一个简单的请求处理程序开始，该请求处理程序执行以下操作：</p>
<ol>
<li>检查这是“ example-handler”应满足的请求</li>
<li>将输出的内容类型设置为<code>text/html</code></li>
<li>写“你好，世界！回到客户端浏览器</li>
<li>让服务器知道我们已经处理了这个请求，一切正常</li>
</ol>
<p>在C代码中，我们的示例处理程序现在将如下所示：</p>


<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    /* First off, we need to check if this is a call for the "example-handler" handler.
     * If it is, we accept it and do our things, if not, we simply return DECLINED,
     * and the server will try somewhere else.
     */
    if (!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return (DECLINED);
    
    /* Now that we are handling this request, we'll write out "Hello, world!" to the client.
     * To do so, we must first set the appropriate content type, followed by our output.
     */
    ap_set_content_type(r, "text/html");
    ap_rprintf(r, "Hello, world!");
    
    /* Lastly, we must tell the server that we took care of this request and everything went fine.
     * We do so by simply returning the value OK to the server.
     */
    return OK;
}</pre>



<p>现在，我们将所有学到的知识放在一起，最后得到一个类似于<a href="http://people.apache.org/~humbedooh/mods/examples/mod_example_1.c">mod_example_1.c</a>的程序。稍后将在<a href="#functions">“您应该知道的一些有用功能”部分中</a>说明此示例中<a href="#functions">使用的功能</a> 。
</p>
 
<h3><a name="request_rec" id="request_rec">request_rec结构</a></h3> 
<p>任何请求中最重要的部分是<em>请求记录</em> 。在对处理函数的调用中，这由<code>request_rec*</code>每次调用时都会传递的结构。此结构，通常仅称为<code>r</code>在模块中，包含模块完全处理任何HTTP请求并做出相应响应所需的所有信息。</p> <p>的一些关键要素<code>request_rec</code>结构是：</p>
<ul>
<li><code>r->handler (char*):</code>包含服务器当前要求处理此请求的处理程序的名称</li>
<li><code>r->method (char*):</code>包含正在使用的HTTP方法fxGET或POST</li>
<li><code>r->filename (char*):</code>包含客户端请求的翻译文件名</li>
<li><code>r->args (char*):</code>包含请求的查询字符串（如果有）</li>
<li><code>r->headers_in (apr_table_t*):</code>包含客户端发送的所有标头</li>
<li><code>r->connection (conn_rec*):</code>包含有关当前连接信息的记录</li>
<li><code>r->user (char*):</code>如果URI需要身份验证，则将其设置为提供的用户名</li>
<li><code>r->useragent_ip (char*):</code>连接到我们的客户端的IP地址</li>
<li><code>r->pool (apr_pool_t*)</code> ：此请求的内存池。我们将在“ <a href="#memory">内存管理</a> ”一章中对此进行讨论。</li>
</ul>
<p>包含在其中的所有值的完整列表<code>request_rec</code>结构可以在<a href="http://svn.apache.org/repos/asf/httpd/httpd/trunk/include/httpd.h"><code>httpd.h</code></a>头文件或<a href="http://ci.apache.org/projects/httpd/trunk/doxygen/structrequest__rec.html">http://ci.apache.org/projects/httpd/trunk/doxygen/structrequest__rec.html</a> 。</p>


<p>让我们在另一个示例处理程序中尝试其中一些变量：<br>
</p>


<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    /* Set the appropriate content type */
    ap_set_content_type(r, "text/html");

    /* Print out the IP address of the client connecting to us: */
    ap_rprintf(r, "&lt;h2&gt;Hello, %s!&lt;/h2&gt;", r-&gt;useragent_ip);
    
    /* If we were reached through a GET or a POST request, be happy, else sad. */
    if ( !strcmp(r-&gt;method, "POST") || !strcmp(r-&gt;method, "GET") ) {
        ap_rputs("You used a GET or a POST method, that makes us happy!&lt;br/&gt;", r);
    }
    else {
        ap_rputs("You did not use POST or GET, that makes us sad :(&lt;br/&gt;", r);
    }

    /* Lastly, if there was a query string, let's print that too! */
    if (r-&gt;args) {
        ap_rprintf(r, "Your query string was: %s", r-&gt;args);
    }
    return OK;
}</pre>





<h3><a name="return_value" id="return_value">返回值</a></h3>
<p>Apache依赖于处理程序的返回值来表示是否处理了请求，如果是，则表示请求是否正常。如果模块对处理特定请求不感兴趣，则应始终返回该值<code>DECLINED</code> 。如果正在处理请求，则应返回通用值<code>OK</code> ，或特定的HTTP状态代码，例如：</p>


<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    /* Return 404: Not found */
    return HTTP_NOT_FOUND;
}</pre>



<p>归来<code>OK</code>或HTTP状态代码不一定表示请求将结束。服务器可能仍然具有对该请求感兴趣的其他处理程序，例如日志记录模块，在成功请求后，该日志记录模块将记录所请求内容及其进行方式的摘要。要完全停止并防止在模块完成后进行任何进一步处理，可以返回该值<code>DONE</code>让服务器知道它应该停止此请求上的所有活动并继续执行下一个，而不通知其他处理程序。
<br>
<strong>通用响应代码：</strong>
</p>
<ul>
<li><code>DECLINED</code> ：我们未处理此请求</li>
<li><code>OK</code> ：我们处理了此请求，进展顺利</li>
<li><code>DONE</code> ：我们处理了此请求，服务器应关闭该线程，而无需进一步处理</li>
</ul>
<p>
<strong>HTTP特定的返回码（节选）：</strong>
</p>
<ul>
<li><code>HTTP_OK (200)</code> ：请求还可以</li>
<li><code>HTTP_MOVED_PERMANENTLY (301)</code> ：资源已移至新网址</li>
<li><code>HTTP_UNAUTHORIZED (401)</code> ：客户无权访问此页面</li>
<li><code>HTTP_FORBIDDEN (403)</code> ： 没有权限</li>
<li><code>HTTP_NOT_FOUND (404)</code> ： 文件未找到</li>
<li><code>HTTP_INTERNAL_SERVER_ERROR (500)</code> ：内部服务器错误（自我解释）</li>
</ul>


<h3><a name="functions" id="functions">您应该知道的一些有用的功能</a></h3>

<ul>
<li>
    <code>ap_rputs(const char *string, request_rec *r)</code> ：<br>将文本字符串发送到客户端。这是<a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__PROTO.html#gac827cd0537d2b6213a7c06d7c26cc36e">ap_rwrite</a>的简写版本。
    


<pre class="prettyprint lang-c">ap_rputs("Hello, world!", r);</pre>




</li>
<li>
    <code><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__PROTO.html#ga5e91eb6ca777c9a427b2e82bf1eeb81d">ap_rprintf</a></code> ：<br>该功能就像<code>printf</code> ，除了它将结果发送给客户端。
    


<pre class="prettyprint lang-c">ap_rprintf(r, "Hello, %s!", r-&gt;useragent_ip);</pre>



</li>
<li>
    <code><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__PROTO.html#gaa2f8412c400197338ec509f4a45e4579">ap_set_content_type</a>(request_rec *r, const char *type)</code> ：<br>设置要发送的输出的内容类型。
    


<pre class="prettyprint lang-c">ap_set_content_type(r, "text/plain"); /* force a raw text output */</pre>



</li>


</ul>


<h3><a name="memory" id="memory">内存管理</a></h3>
<p>得益于内存池系统，在Apache HTTP Server 2.4中管理资源非常容易。本质上，每个服务器，连接和请求都有其自己的内存池，该内存池在其作用域结束时（例如，请求完成或服务器进程关闭时）会被清理。您模块所需要做的就是将其锁存到该内存池中，而您不必担心必须自己清理一下-非常整洁，是吗？
</p>

<p>在我们的模块中，我们将主要为每个请求分配内存，因此使用<code>r->pool</code>创建新对象时参考。在池中分配内存的一些功能是：</p>
<ul>
<li><code>void* <a href="http://apr.apache.org/docs/apr/1.4/group__apr__pools.html#ga85f1e193c31d109affda72f9a92c6915">apr_palloc</a>( apr_pool_t *p, apr_size_t size)</code> ：分配<code>size</code>池中适合您的字节数</li>
<li><code>void* <a href="http://apr.apache.org/docs/apr/1.4/group__apr__pools.html#gaf61c098ad258069d64cdf8c0a9369f9e">apr_pcalloc</a>( apr_pool_t *p, apr_size_t size)</code> ：分配<code>size</code>池中的字节数，并将所有字节设置为0</li>
<li><code>char* <a href="http://apr.apache.org/docs/apr/1.4/group__apr__strings.html#gabc79e99ff19abbd7cfd18308c5f85d47">apr_pstrdup</a>( apr_pool_t *p, const char *s)</code> ：创建字符串的副本<code>s</code> 。这对于复制常量值很有用，因此您可以对其进行编辑</li>
<li><code>char* <a href="http://apr.apache.org/docs/apr/1.4/group__apr__strings.html#ga3eca76b8d293c5c3f8021e45eda813d8">apr_psprintf</a>( apr_pool_t *p, const char *fmt, ...)</code> ： 相似<code>sprintf</code> ，但服务器会为您提供适当分配的目标变量</li>
</ul>

<p>让我们将这些函数放入示例处理程序中：</p>



<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    const char *original = "You can't edit this!";
    char *copy;
    int *integers;
    
    /* Allocate space for 10 integer values and set them all to zero. */
    integers = apr_pcalloc(r-&gt;pool, sizeof(int)*10); 
    
    /* Create a copy of the 'original' variable that we can edit. */
    copy = apr_pstrdup(r-&gt;pool, original);
    return OK;
}</pre>



<p>这对于我们的模块非常好，因为它不需要任何预先初始化的变量或结构。但是，如果我们想尽早初始化某些内容，则在请求进入之前，我们可以简单地在我们的函数中添加对函数的调用<code>register_hooks</code>整理功能：</p>


<pre class="prettyprint lang-c">static void register_hooks(apr_pool_t *pool)
{
    /* Call a function that initializes some stuff */
    example_init_function(pool);
    /* Create a hook in the request handler, so we get called when a request arrives */
    ap_hook_handler(example_handler, NULL, NULL, APR_HOOK_LAST);
}</pre>



<p>在此请求前初始化函数中，我们不会使用与为基于请求的函数分配资源时使用的池相同的池。取而代之的是，我们将使用服务器给我们的池在基于每个进程的级别上分配内存。
</p>


<h3><a name="parsing" id="parsing">解析请求数据</a></h3>
<p>在示例模块中，我们想添加一个功能，该功能可以检查客户端希望查看的摘要类型，MD5或SHA1。这可以通过向请求添加查询字符串来解决。查询字符串通常由几个键和值组成，例如，一个字符串<code>valueA=yes&valueB=no&valueC=maybe</code> 。由模块本身来解析它们并获取所需的数据。在我们的示例中，我们将寻找一个名为<code>digest</code> ，如果设置为<code>md5</code> ，我们将生成MD5摘要，否则将生成SHA1摘要。</p>
<p>自从Apache HTTP Server 2.4引入以来，从GET和POST请求解析请求数据从未如此简单。我们解析GET和POST数据所需要做的只是四行：</p> 



<pre class="prettyprint lang-c">
<a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *GET; <em>
</em><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/structapr__array__header__t.html">apr_array_header_t</a>*POST; 
<em>
</em>
<a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__SCRIPT.html#gaed25877b529623a4d8f99f819ba1b7bd">
ap_args_to_table</a>(r, &amp;GET); <em>
</em><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#ga9d426b6382b49754d4f87c55f65af202">
ap_parse_form_data</a>(r, NULL, &amp;POST, -1, 8192);</pre>



<p>在特定的示例模块中，我们正在寻找<code>digest</code>查询字符串中的值，该值现在位于名为<code>GET</code> 。要提取此值，我们只需要执行一个简单的操作即可：</p>



<pre class="prettyprint lang-c">/* Get the "digest" key from the query string, if any. */
const char *digestType = apr_table_get(GET, "digest");

/* If no key was returned, we will set a default value instead. */
if (!digestType) digestType = "sha1";</pre>



<p>用于POST和GET数据的结构并不完全相同，因此，如果要从POST数据中获取值而不是查询字符串，我们将不得不再使用几行，如<a href="#get_post">本示例</a>中的本文档的最后一章。
</p>


<h3><a name="advanced_handler" id="advanced_handler">制作高级处理程序</a></h3>
<p>现在，我们已经了解了如何解析表单数据和管理资源，接下来我们可以继续创建模块的高级版本，该高级版本吐出了MD5或SHA1文件摘要：</p>



<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    int rc, exists;
    apr_finfo_t finfo;
    apr_file_t *file;
    char *filename;
    char buffer[256];
    apr_size_t readBytes;
    int n;
    apr_table_t *GET;
    apr_array_header_t *POST;
    const char *digestType;
    
    
    /* Check that the "example-handler" handler is being called. */
    if (!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return (DECLINED);
    
    /* Figure out which file is being requested by removing the .sum from it */
    filename = apr_pstrdup(r-&gt;pool, r-&gt;filename);
    filename[strlen(filename)-4] = 0; /* Cut off the last 4 characters. */
    
    /* Figure out if the file we request a sum on exists and isn't a directory */
    rc = apr_stat(&amp;finfo, filename, APR_FINFO_MIN, r-&gt;pool);
    if (rc == APR_SUCCESS) {
        exists =
        (
            (finfo.filetype != APR_NOFILE)
        &amp;&amp;  !(finfo.filetype &amp; APR_DIR)
        );
        if (!exists) return HTTP_NOT_FOUND; /* Return a 404 if not found. */
    }
    /* If apr_stat failed, we're probably not allowed to check this file. */
    else return HTTP_FORBIDDEN;
    
    /* Parse the GET and, optionally, the POST data sent to us */
    
    ap_args_to_table(r, &amp;GET);
    ap_parse_form_data(r, NULL, &amp;POST, -1, 8192);
    
    /* Set the appropriate content type */
    ap_set_content_type(r, "text/html");
    
    /* Print a title and some general information */
    ap_rprintf(r, "&lt;h2&gt;Information on %s:&lt;/h2&gt;", filename);
    ap_rprintf(r, "&lt;b&gt;Size:&lt;/b&gt; %u bytes&lt;br/&gt;", finfo.size);
    
    /* Get the digest type the client wants to see */
    digestType = apr_table_get(GET, "digest");
    if (!digestType) digestType = "MD5";
    
    
    rc = apr_file_open(&amp;file, filename, APR_READ, APR_OS_DEFAULT, r-&gt;pool);
    if (rc == APR_SUCCESS) {
        
        /* Are we trying to calculate the MD5 or the SHA1 digest? */
        if (!strcasecmp(digestType, "md5")) {
            /* Calculate the MD5 sum of the file */
            union {
                char      chr[16];
                uint32_t  num[4];
            } digest;
            apr_md5_ctx_t md5;
            apr_md5_init(&amp;md5);
            readBytes = 256;
            while ( apr_file_read(file, buffer, &amp;readBytes) == APR_SUCCESS ) {
                apr_md5_update(&amp;md5, buffer, readBytes);
            }
            apr_md5_final(digest.chr, &amp;md5);
            
            /* Print out the MD5 digest */
            ap_rputs("&lt;b&gt;MD5: &lt;/b&gt;&lt;code&gt;", r);
            for (n = 0; n &lt; APR_MD5_DIGESTSIZE/4; n++) {
                ap_rprintf(r, "%08x", digest.num[n]);
            }
            ap_rputs("&lt;/code&gt;", r);
            /* Print a link to the SHA1 version */
            ap_rputs("&lt;br/&gt;&lt;a href='?digest=sha1'&gt;View the SHA1 hash instead&lt;/a&gt;", r);
        }
        else {
            /* Calculate the SHA1 sum of the file */
            union {
                char      chr[20];
                uint32_t  num[5];
            } digest;
            apr_sha1_ctx_t sha1;
            apr_sha1_init(&amp;sha1);
            readBytes = 256;
            while ( apr_file_read(file, buffer, &amp;readBytes) == APR_SUCCESS ) {
                apr_sha1_update(&amp;sha1, buffer, readBytes);
            }
            apr_sha1_final(digest.chr, &amp;sha1);
            
            /* Print out the SHA1 digest */
            ap_rputs("&lt;b&gt;SHA1: &lt;/b&gt;&lt;code&gt;", r);
            for (n = 0; n &lt; APR_SHA1_DIGESTSIZE/4; n++) {
                ap_rprintf(r, "%08x", digest.num[n]);
            }
            ap_rputs("&lt;/code&gt;", r);
            
            /* Print a link to the MD5 version */
            ap_rputs("&lt;br/&gt;&lt;a href='?digest=md5'&gt;View the MD5 hash instead&lt;/a&gt;", r);
        }
        apr_file_close(file);
        
    }    
    /* Let the server know that we responded to this request. */
    return OK;
}</pre>



<p>此版本的完整版本可以在以下位置找到： <a href="http://people.apache.org/~humbedooh/mods/examples/mod_example_2.c">mod_example_2.c</a> 。
</p>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="configuration" id="configuration">添加配置选项</a></h2>
<p>在本文档的下一部分中，我们将把目光从摘要模块上移开，并创建一个新的示例模块，其唯一功能是写出自己的配置。这样做的目的是检查服务器如何与配置一起使用，以及开始为模块编写高级配置时会发生什么。
</p>
<h3><a name="config_intro" id="config_intro">配置指令简介</a></h3>
<p>如果您正在阅读本文，那么您可能已经知道什么是配置指令。简而言之，指令是一种告诉单个模块（或一组模块）如何工作的方式，例如这些指令控制着如何<code>mod_rewrite</code>作品：</p>
<pre class="prettyprint lang-config">RewriteEngine On
RewriteCond "%{REQUEST_URI}" "^/foo/bar"
RewriteRule "^/foo/bar/(.*)$" "/foobar?page=$1"</pre>

<p>每个配置指令均由单独的函数处理，该函数解析给定的参数并相应地设置配置。
</p>

<h3><a name="config_simple" id="config_simple">进行示例配置</a></h3>
<p>首先，我们将在C空间中创建一个基本配置：</p>



<pre class="prettyprint lang-c">typedef struct {
    int         enabled;      /* Enable or disable our module */
    const char *path;         /* Some path to...something */
    int         typeOfAction; /* 1 means action A, 2 means action B and so on */
} example_config;</pre>



<p>现在，让我们通过创建一个很小的模块以打印出硬编码配置的方式来对此进行透视。您会注意到，我们使用<code>register_hooks</code>用于将配置值初始化为其默认值的函数：</p>


<pre class="prettyprint lang-c">typedef struct {
    int         enabled;      /* Enable or disable our module */
    const char *path;         /* Some path to...something */
    int         typeOfAction; /* 1 means action A, 2 means action B and so on */
} example_config;

static example_config config;

static int example_handler(request_rec *r)
{
    if (!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return(DECLINED);
    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "Enabled: %u\n", config.enabled);
    ap_rprintf(r, "Path: %s\n", config.path);
    ap_rprintf(r, "TypeOfAction: %x\n", config.typeOfAction);
    return OK;
}

static void register_hooks(apr_pool_t *pool) 
{
    config.enabled = 1;
    config.path = "/foo/bar";
    config.typeOfAction = 0x00;
    ap_hook_handler(example_handler, NULL, NULL, APR_HOOK_LAST);
}

/* Define our module as an entity and assign a function for registering hooks  */

module AP_MODULE_DECLARE_DATA   example_module =
{
    STANDARD20_MODULE_STUFF,
    NULL,            /* Per-directory configuration handler */
    NULL,            /* Merge handler for per-directory configurations */
    NULL,            /* Per-server configuration handler */
    NULL,            /* Merge handler for per-server configurations */
    NULL,            /* Any directives we may have for httpd */
    register_hooks   /* Our hook registering function */
};</pre>



<p>到目前为止，一切都很好。要访问我们的新处理程序，我们可以在配置中添加以下内容：</p>
<pre class="prettyprint lang-config">&lt;Location "/example"&gt;
    SetHandler example-handler
&lt;/Location&gt;</pre>

<p>当我们访问时，我们将看到我们的模块吐出了当前的配置。
</p>


<h3><a name="register_directive" id="register_directive">在服务器上注册指令</a></h3>
<p>如果要更改配置，而不是通过将新值硬编码到模块中，而是使用httpd.conf文件或可能的.htaccess文件来更改配置，该怎么办？现在是时候让服务器知道我们希望做到这一点了。为此，我们必须首先更改<em>名称标签，</em>以包含对我们要向服务器注册的配置指令的引用：</p>


<pre class="prettyprint lang-c">module AP_MODULE_DECLARE_DATA   example_module =
{
    STANDARD20_MODULE_STUFF,
    NULL,               /* Per-directory configuration handler */
    NULL,               /* Merge handler for per-directory configurations */
    NULL,               /* Per-server configuration handler */
    NULL,               /* Merge handler for per-server configurations */
    example_directives, /* Any directives we may have for httpd */
    register_hooks      /* Our hook registering function */
};</pre>



<p>这将告诉服务器我们现在正在接受配置文件中的指令，并且该结构称为<code>example_directives</code>包含有关我们的指令是什么以及它们如何工作的信息。由于我们的模块配置中有三个不同的变量，因此我们将添加一个结构，该结构具有三个指令，最后是一个NULL：</p>


<pre class="prettyprint lang-c">static const command_rec        example_directives[] =
{
    AP_INIT_TAKE1("exampleEnabled", example_set_enabled, NULL, RSRC_CONF, "Enable or disable mod_example"),
    AP_INIT_TAKE1("examplePath", example_set_path, NULL, RSRC_CONF, "The path to whatever"),
    AP_INIT_TAKE2("exampleAction", example_set_action, NULL, RSRC_CONF, "Special action value!"),
    { NULL }
};</pre>



<p>
<img src="../images/build_a_mod_4.png" alt="指令结构"><br>如您所见，每个指令至少需要设置5个参数：</p>
<ol>
<li><code><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__CONFIG.html#ga07c7d22ae17805e61204463326cf9c34">AP_INIT_TAKE1</a></code> ：这是一个宏，它告诉服务器此指令只接受一个且只有一个参数。如果需要两个参数，则可以使用宏<code><a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__CONFIG.html#gafaec43534fcf200f37d9fecbf9247c21">AP_INIT_TAKE2</a></code>等等（有关更多宏，请参考httpd_conf.h）。</li>
<li><code>exampleEnabled</code> ：这是我们指令的名称。更准确地说，这是用户必须在其配置中放入的内容才能在我们的模块中调用配置更改。</li>
<li><code>example_set_enabled</code> ：这是对C函数的引用，该C函数解析指令并相应地设置配置。我们将在下面的段落中讨论如何做到这一点。</li>
<li><code>RSRC_CONF</code> ：这告诉服务器允许该指令的位置。在后面的章节中，我们将详细介绍此值，但现在， <code>RSRC_CONF</code>表示服务器将仅在服务器上下文中接受这些指令。</li>
<li><code>"Enable or disable...."</code> ：这只是该指令的简要说明。</li>
</ol>
<p>（ <em>在我们的定义中，“ missing”参数通常设置为<code>NULL</code>是一个可选函数，可以在运行初始函数以解析参数后运行。通常将其省略，因为验证参数的函数也可以用于设置参数。</em> ）
</p>

<h3><a name="directive_handler" id="directive_handler">指令处理程序功能</a></h3>
<p>既然我们已经告诉服务器期望模块有一些指令，那么该是时候编写一些函数来处理这些指令了。服务器在配置文件中读取的是文本，因此很自然地，它传递给我们的指令处理程序的是一个或多个字符串，我们自己需要识别它们并对其采取行动。您会注意到，由于我们设置了<code>exampleAction</code>指令接受两个参数，其C函数还具有一个定义的附加参数：</p> 


<pre class="prettyprint lang-c">/* Handler for the "exampleEnabled" directive */
const char *example_set_enabled(cmd_parms *cmd, void *cfg, const char *arg)
{
    if(!strcasecmp(arg, "on")) config.enabled = 1;
    else config.enabled = 0;
    return NULL;
}

/* Handler for the "examplePath" directive */
const char *example_set_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.path = arg;
    return NULL;
}

/* Handler for the "exampleAction" directive */
/* Let's pretend this one takes one argument (file or db), and a second (deny or allow), */
/* and we store it in a bit-wise manner. */
const char *example_set_action(cmd_parms *cmd, void *cfg, const char *arg1, const char *arg2)
{
    if(!strcasecmp(arg1, "file")) config.typeOfAction = 0x01;
    else config.typeOfAction = 0x02;
    
    if(!strcasecmp(arg2, "deny")) config.typeOfAction += 0x10;
    else config.typeOfAction += 0x20;
    return NULL;
}</pre>





<h3><a name="directive_complete" id="directive_complete">放在一起</a></h3>
<p>现在我们已经设置了指令，并为其配置了处理程序，我们可以将模块组装到一个大文件中：</p>


<pre class="prettyprint lang-c">/* mod_example_config_simple.c: */
#include &lt;stdio.h&gt;
#include "apr_hash.h"
#include "ap_config.h"
#include "ap_provider.h"
#include "httpd.h"
#include "http_core.h"
#include "http_config.h"
#include "http_log.h"
#include "http_protocol.h"
#include "http_request.h"

/*
 ==============================================================================
 Our configuration prototype and declaration:
 ==============================================================================
 */
typedef struct {
    int         enabled;      /* Enable or disable our module */
    const char *path;         /* Some path to...something */
    int         typeOfAction; /* 1 means action A, 2 means action B and so on */
} example_config;

static example_config config;

/*
 ==============================================================================
 Our directive handlers:
 ==============================================================================
 */
/* Handler for the "exampleEnabled" directive */
const char *example_set_enabled(cmd_parms *cmd, void *cfg, const char *arg)
{
    if(!strcasecmp(arg, "on")) config.enabled = 1;
    else config.enabled = 0;
    return NULL;
}

/* Handler for the "examplePath" directive */
const char *example_set_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.path = arg;
    return NULL;
}

/* Handler for the "exampleAction" directive */
/* Let's pretend this one takes one argument (file or db), and a second (deny or allow), */
/* and we store it in a bit-wise manner. */
const char *example_set_action(cmd_parms *cmd, void *cfg, const char *arg1, const char *arg2)
{
    if(!strcasecmp(arg1, "file")) config.typeOfAction = 0x01;
    else config.typeOfAction = 0x02;
    
    if(!strcasecmp(arg2, "deny")) config.typeOfAction += 0x10;
    else config.typeOfAction += 0x20;
    return NULL;
}

/*
 ==============================================================================
 The directive structure for our name tag:
 ==============================================================================
 */
static const command_rec        example_directives[] =
{
    AP_INIT_TAKE1("exampleEnabled", example_set_enabled, NULL, RSRC_CONF, "Enable or disable mod_example"),
    AP_INIT_TAKE1("examplePath", example_set_path, NULL, RSRC_CONF, "The path to whatever"),
    AP_INIT_TAKE2("exampleAction", example_set_action, NULL, RSRC_CONF, "Special action value!"),
    { NULL }
};
/*
 ==============================================================================
 Our module handler:
 ==============================================================================
 */
static int example_handler(request_rec *r)
{
    if(!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return(DECLINED);
    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "Enabled: %u\n", config.enabled);
    ap_rprintf(r, "Path: %s\n", config.path);
    ap_rprintf(r, "TypeOfAction: %x\n", config.typeOfAction);
    return OK;
}

/*
 ==============================================================================
 The hook registration function (also initializes the default config values):
 ==============================================================================
 */
static void register_hooks(apr_pool_t *pool) 
{
    config.enabled = 1;
    config.path = "/foo/bar";
    config.typeOfAction = 3;
    ap_hook_handler(example_handler, NULL, NULL, APR_HOOK_LAST);
}
/*
 ==============================================================================
 Our module name tag:
 ==============================================================================
 */
module AP_MODULE_DECLARE_DATA   example_module =
{
    STANDARD20_MODULE_STUFF,
    NULL,               /* Per-directory configuration handler */
    NULL,               /* Merge handler for per-directory configurations */
    NULL,               /* Per-server configuration handler */
    NULL,               /* Merge handler for per-server configurations */
    example_directives, /* Any directives we may have for httpd */
    register_hooks      /* Our hook registering function */
};</pre>




<p>现在，在我们的httpd.conf文件中，可以通过添加几行来更改硬编码配置：</p>
<pre class="prettyprint lang-config">ExampleEnabled On
ExamplePath "/usr/bin/foo"
ExampleAction file allow</pre>

<p>因此，我们应用配置，请访问<code>/example</code>在我们的网站上，我们看到配置已适应我们在配置文件中编写的内容。
</p>



</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="context" id="context">上下文感知配置</a></h2>
<h3><a name="context_intro" id="context_intro">上下文感知配置简介</a></h3>
<p>在Apache HTTP Server 2.4中，不同的URL，虚拟主机，目录等对于服务器用户可能具有非常不同的含义，因此模块必须在不同的上下文中运行。例如，假设您为mod_rewrite设置了以下配置：</p>
<pre class="prettyprint lang-config">&lt;Directory "/var/www"&gt;
    RewriteCond "%{HTTP_HOST}" "^example.com$"
    RewriteRule "(.*)" "http://www.example.com/$1"
&lt;/Directory&gt;
&lt;Directory "/var/www/sub"&gt;
    RewriteRule "^foobar$" "index.php?foobar=true"
&lt;/Directory&gt;</pre>

<p>在此示例中，您将为mod_rewrite设置两个不同的上下文：</p>
<ol>
<li>内<code>/var/www</code> ，所有要求<code>http://example.com</code>必须去<code>http://www.example.com</code></li>
<li>内<code>/var/www/sub</code> ，所有要求<code>foobar</code>必须去<code>index.php?foobar=true</code></li>
</ol>
<p>如果mod_rewrite（或整个服务器）不了解上下文，那么这些重写规则将仅适用于每个请求，无论它们在何处以及如何发出，但是由于模块可以提取特定于上下文的配置直接从服务器开始，它不需要知道自身，在该上下文中哪个指令是有效的，因为服务器会处理这一点。</p>

<p>那么，模块如何获取有关服务器，目录或位置的特定配置？为此，只需进行一个简单的调用即可：</p>


<pre class="prettyprint lang-c">example_config *config = (example_config*) <a href="http://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__CONFIG.html#ga1093a5908a384eacc929b028c79f2a02">ap_get_module_config</a>(r-&gt;per_dir_config, &amp;example_module);</pre>



<p>而已！当然，幕后还有很多事情，我们将在本章中进行讨论，首先是服务器如何知道我们的配置，以及如何在特定的上下文中进行设置。
</p>


<h3><a name="context_base" id="context_base">我们的基本配置设置</a></h3>
<p>在本章中，我们将使用先前上下文结构的稍微修改的版本。我们将设置一个<code>context</code>我们可以使用该变量来跟踪服务器在各个地方使用的上下文配置：</p>

<pre class="prettyprint lang-c">typedef struct {
    char        context[256];
    char        path[256];
    int         typeOfAction;
    int         enabled;
} example_config;</pre>



<p>我们的请求处理程序也将被修改，但仍然非常简单：</p>



<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    if(!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return(DECLINED);
    example_config *config = (example_config*) ap_get_module_config(r-&gt;per_dir_config, &amp;example_module);
    ap_set_content_type(r, "text/plain");
    ap_rprintf("Enabled: %u\n", config-&gt;enabled);
    ap_rprintf("Path: %s\n", config-&gt;path);
    ap_rprintf("TypeOfAction: %x\n", config-&gt;typeOfAction);
    ap_rprintf("Context: %s\n", config-&gt;context);
    return OK;
}</pre>





<h3><a name="context_which" id="context_which">选择背景</a></h3>
<p>在开始使我们的模块上下文意识之前，我们必须首先定义我们将接受的上下文。如上一章所述，定义指令需要设置五个元素：</p>



<pre class="prettyprint lang-c">AP_INIT_TAKE1("exampleEnabled", example_set_enabled, NULL, RSRC_CONF, "Enable or disable mod_example"),</pre>




<p>的<code>RSRC_CONF</code>定义告诉服务器，我们只允许在全局服务器上下文中使用此指令，但是由于我们现在正在尝试模块的上下文感知版本，因此我们应该将其设置为更宽松的名称，即value <code>ACCESS_CONF</code> ，这使我们可以在<directory>和<location>块内使用指令<directory><location>。为了更好地控制指令的位置，可以将以下限制组合在一起以形成特定的规则：</location></directory></location></directory></p>
<ul>
<li><code>RSRC_CONF</code> ：允许在.conf文件（而非.htaccess文件）之外<directory>或<location></location></directory></li>
<li><code>ACCESS_CONF</code> ：允许在.conf文件（而非.htaccess文件）内部<directory>或<location></location></directory></li>
<li><code>OR_OPTIONS</code> ：允许在.conf文件和.htaccess中使用<code>AllowOverride Options</code>被设置</li>
<li><code>OR_FILEINFO</code> ：允许在.conf文件和.htaccess中使用<code>AllowOverride FileInfo</code>被设置</li>
<li><code>OR_AUTHCFG</code> ：允许在.conf文件和.htaccess中使用<code>AllowOverride AuthConfig</code>被设置</li>
<li><code>OR_INDEXES</code> ：允许在.conf文件和.htaccess中使用<code>AllowOverride Indexes</code>被设置</li>
<li><code>OR_ALL</code> ：允许在.conf文件和.htaccess中的任何位置</li>
</ul>


<h3><a name="context_pool" id="context_pool">使用服务器分配配置插槽</a></h3>
<p>管理配置的一种更聪明的方法是让服务器帮助您创建配置。为此，我们必须首先通过更改<em>名称标签</em>让服务器知道，它应该有助于我们创建和管理配置。由于我们为模块配置选择了按目录（或按位置）上下文，因此将在标记中添加按目录创建者和合并功能引用：</p>


<pre class="prettyprint lang-c">module AP_MODULE_DECLARE_DATA   example_module =
{
    STANDARD20_MODULE_STUFF,
    create_dir_conf, /* Per-directory configuration handler */
    merge_dir_conf,  /* Merge handler for per-directory configurations */
    NULL,            /* Per-server configuration handler */
    NULL,            /* Merge handler for per-server configurations */
    directives,      /* Any directives we may have for httpd */
    register_hooks   /* Our hook registering function */
};</pre>







<h3><a name="context_new" id="context_new">创建新的上下文配置</a></h3>
<p>现在，我们已经告诉服务器帮助我们创建和管理配置，我们的第一步是创建一个用于创建新的空白配置的功能。为此，我们创建了刚刚在名称标签中引用的函数，作为每目录配置处理程序：</p>

<pre class="prettyprint lang-c">void *create_dir_conf(apr_pool_t *pool, char *context) {
    context = context ? context : "(undefined context)";
    example_config *cfg = apr_pcalloc(pool, sizeof(example_config));
    if(cfg) {
        /* Set some default values */
        strcpy(cfg-&gt;context, context);
        cfg-&gt;enabled = 0;
        cfg-&gt;path = "/foo/bar";
        cfg-&gt;typeOfAction = 0x11;
    }
    return cfg;
}</pre>






<h3><a name="context_merge" id="context_merge">合并配置</a></h3>
<p>创建上下文感知配置的下一步是合并配置。该过程的这一部分特别适用于具有父配置和子配置的方案，例如：</p>
<pre class="prettyprint lang-config">&lt;Directory "/var/www"&gt;
    ExampleEnabled On
    ExamplePath "/foo/bar"
    ExampleAction file allow
&lt;/Directory&gt;
&lt;Directory "/var/www/subdir"&gt;
    ExampleAction file deny
&lt;/Directory&gt;</pre>

<p>在此示例中，很自然地假定目录<code>/var/www/subdir</code>应该继承为<code>/var/www</code>目录，因为我们没有指定<code>ExampleEnabled</code>也不是<code>ExamplePath</code>该目录。服务器不假定这是真的，但是巧妙地执行以下操作：</p>
<ol>
<li>为创建新配置<code>/var/www</code></li>
<li>根据给定的指令设置配置值<code>/var/www</code></li>
<li>为创建新配置<code>/var/www/subdir</code></li>
<li>根据给定的指令设置配置值<code>/var/www/subdir</code></li>
<li><strong>提议将</strong>两个配置<strong>合并</strong>为一个新配置<code>/var/www/subdir</code></li>
</ol>
<p>该提案由<code>merge_dir_conf</code>我们在名称标签中引用的功能。此功能的目的是评估这两种配置并决定如何合并它们：</p>



<pre class="prettyprint lang-c">void *merge_dir_conf(apr_pool_t *pool, void *BASE, void *ADD) {
    example_config *base = (example_config *) BASE ; /* This is what was set in the parent context */
    example_config *add = (example_config *) ADD ;   /* This is what is set in the new context */
    example_config *conf = (example_config *) create_dir_conf(pool, "Merged configuration"); /* This will be the merged configuration */
    
    /* Merge configurations */
    conf-&gt;enabled = ( add-&gt;enabled == 0 ) ? base-&gt;enabled : add-&gt;enabled ;
    conf-&gt;typeOfAction = add-&gt;typeOfAction ? add-&gt;typeOfAction : base-&gt;typeOfAction;
    strcpy(conf-&gt;path, strlen(add-&gt;path) ? add-&gt;path : base-&gt;path);
    
    return conf ;
}</pre>






<h3><a name="context_example" id="context_example">试用我们新的上下文感知配置</a></h3>
<p>现在，让我们尝试将所有内容放在一起以创建一个具有上下文意识的新模块。首先，我们将创建一个配置，让我们测试模块的工作方式：</p>
<pre class="prettyprint lang-config">&lt;Location "/a"&gt;
    SetHandler example-handler
    ExampleEnabled on
    ExamplePath "/foo/bar"
    ExampleAction file allow
&lt;/Location&gt;

&lt;Location "/a/b"&gt;
    ExampleAction file deny
    ExampleEnabled off
&lt;/Location&gt;

&lt;Location "/a/b/c"&gt;
    ExampleAction db deny
    ExamplePath "/foo/bar/baz"
    ExampleEnabled on
&lt;/Location&gt;</pre>

<p>然后，我们将汇编模块代码。请注意，由于我们现在在处理程序中获取配置时使用名称标签作为参考，因此我添加了一些原型以使编译器满意：</p>


<pre class="prettyprint lang-c">/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * mod_example_config.c
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#include &lt;stdio.h&gt;
#include "apr_hash.h"
#include "ap_config.h"
#include "ap_provider.h"
#include "httpd.h"
#include "http_core.h"
#include "http_config.h"
#include "http_log.h"
#include "http_protocol.h"
#include "http_request.h"

/*$1
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Configuration structure
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

typedef struct
{
    char    context[256];
    char    path[256];
    int     typeOfAction;
    int     enabled;
} example_config;

/*$1
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Prototypes
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

static int    example_handler(request_rec *r);
const char    *example_set_enabled(cmd_parms *cmd, void *cfg, const char *arg);
const char    *example_set_path(cmd_parms *cmd, void *cfg, const char *arg);
const char    *example_set_action(cmd_parms *cmd, void *cfg, const char *arg1, const char *arg2);
void          *create_dir_conf(apr_pool_t *pool, char *context);
void          *merge_dir_conf(apr_pool_t *pool, void *BASE, void *ADD);
static void   register_hooks(apr_pool_t *pool);

/*$1
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Configuration directives
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

static const command_rec    directives[] =
{
    AP_INIT_TAKE1("exampleEnabled", example_set_enabled, NULL, ACCESS_CONF, "Enable or disable mod_example"),
    AP_INIT_TAKE1("examplePath", example_set_path, NULL, ACCESS_CONF, "The path to whatever"),
    AP_INIT_TAKE2("exampleAction", example_set_action, NULL, ACCESS_CONF, "Special action value!"),
    { NULL }
};

/*$1
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Our name tag
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

module AP_MODULE_DECLARE_DATA    example_module =
{
    STANDARD20_MODULE_STUFF,
    create_dir_conf,    /* Per-directory configuration handler */
    merge_dir_conf,     /* Merge handler for per-directory configurations */
    NULL,               /* Per-server configuration handler */
    NULL,               /* Merge handler for per-server configurations */
    directives,         /* Any directives we may have for httpd */
    register_hooks      /* Our hook registering function */
};

/*
 =======================================================================================================================
    Hook registration function
 =======================================================================================================================
 */
static void register_hooks(apr_pool_t *pool)
{
    ap_hook_handler(example_handler, NULL, NULL, APR_HOOK_LAST);
}

/*
 =======================================================================================================================
    Our example web service handler
 =======================================================================================================================
 */
static int example_handler(request_rec *r)
{
    if(!r-&gt;handler || strcmp(r-&gt;handler, "example-handler")) return(DECLINED);

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *config = (example_config *) ap_get_module_config(r-&gt;per_dir_config, &amp;example_module);
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "Enabled: %u\n", config-&gt;enabled);
    ap_rprintf(r, "Path: %s\n", config-&gt;path);
    ap_rprintf(r, "TypeOfAction: %x\n", config-&gt;typeOfAction);
    ap_rprintf(r, "Context: %s\n", config-&gt;context);
    return OK;
}

/*
 =======================================================================================================================
    Handler for the "exampleEnabled" directive
 =======================================================================================================================
 */
const char *example_set_enabled(cmd_parms *cmd, void *cfg, const char *arg)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *conf = (example_config *) cfg;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    if(conf)
    {
        if(!strcasecmp(arg, "on"))
            conf-&gt;enabled = 1;
        else
            conf-&gt;enabled = 0;
    }

    return NULL;
}

/*
 =======================================================================================================================
    Handler for the "examplePath" directive
 =======================================================================================================================
 */
const char *example_set_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *conf = (example_config *) cfg;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    if(conf)
    {
        strcpy(conf-&gt;path, arg);
    }

    return NULL;
}

/*
 =======================================================================================================================
    Handler for the "exampleAction" directive ;
    Let's pretend this one takes one argument (file or db), and a second (deny or allow), ;
    and we store it in a bit-wise manner.
 =======================================================================================================================
 */
const char *example_set_action(cmd_parms *cmd, void *cfg, const char *arg1, const char *arg2)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *conf = (example_config *) cfg;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    if(conf)
    {
        {
            if(!strcasecmp(arg1, "file"))
                conf-&gt;typeOfAction = 0x01;
            else
                conf-&gt;typeOfAction = 0x02;
            if(!strcasecmp(arg2, "deny"))
                conf-&gt;typeOfAction += 0x10;
            else
                conf-&gt;typeOfAction += 0x20;
        }
    }

    return NULL;
}

/*
 =======================================================================================================================
    Function for creating new configurations for per-directory contexts
 =======================================================================================================================
 */
void *create_dir_conf(apr_pool_t *pool, char *context)
{
    context = context ? context : "Newly created configuration";

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *cfg = apr_pcalloc(pool, sizeof(example_config));
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    if(cfg)
    {
        {
            /* Set some default values */
            strcpy(cfg-&gt;context, context);
            cfg-&gt;enabled = 0;
            memset(cfg-&gt;path, 0, 256);
            cfg-&gt;typeOfAction = 0x00;
        }
    }

    return cfg;
}

/*
 =======================================================================================================================
    Merging function for configurations
 =======================================================================================================================
 */
void *merge_dir_conf(apr_pool_t *pool, void *BASE, void *ADD)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    example_config    *base = (example_config *) BASE;
    example_config    *add = (example_config *) ADD;
    example_config    *conf = (example_config *) create_dir_conf(pool, "Merged configuration");
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    conf-&gt;enabled = (add-&gt;enabled == 0) ? base-&gt;enabled : add-&gt;enabled;
    conf-&gt;typeOfAction = add-&gt;typeOfAction ? add-&gt;typeOfAction : base-&gt;typeOfAction;
    strcpy(conf-&gt;path, strlen(add-&gt;path) ? add-&gt;path : base-&gt;path);
    return conf;
}</pre>







</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="summary" id="summary">加起来</a></h2>
<p>现在，我们研究了如何为Apache HTTP Server 2.4创建简单的模块并进行配置。接下来的工作完全由您决定，但是我希望阅读本文档后能得到一些有价值的东西。如果您对如何进一步开发模块有疑问，欢迎加入我们的<a href="http://httpd.apache.org/lists.html">邮件列表，</a>或查看我们的其他文档以获取更多提示。
</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="snippets" id="snippets">一些有用的代码片段</a></h2>

<h3><a name="get_post" id="get_post">从POST表单数据中检索变量</a></h3>



<pre class="prettyprint lang-c">typedef struct {
    const char *key;
    const char *value;
} keyValuePair;

keyValuePair *readPost(request_rec *r) {
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    keyValuePair *kvp;

    res = ap_parse_form_data(r, NULL, &amp;pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL; /* Return NULL if we failed or if there are is no POST data */
    kvp = apr_pcalloc(r-&gt;pool, sizeof(keyValuePair) * (pairs-&gt;nelts + 1));
    while (pairs &amp;&amp; !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair-&gt;value, 1, &amp;len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r-&gt;pool, size + 1);
        apr_brigade_flatten(pair-&gt;value, buffer, &amp;size);
        buffer[len] = 0;
        kvp[i].key = apr_pstrdup(r-&gt;pool, pair-&gt;name);
        kvp[i].value = buffer;
        i++;
    }
    return kvp;
}

static int example_handler(request_rec *r)
{
    /*~~~~~~~~~~~~~~~~~~~~~~*/
    keyValuePair *formData;
    /*~~~~~~~~~~~~~~~~~~~~~~*/

    formData = readPost(r);
    if (formData) {
        int i;
        for (i = 0; &amp;formData[i]; i++) {
            if (formData[i].key &amp;&amp; formData[i].value) {
                ap_rprintf(r, "%s = %s\n", formData[i].key, formData[i].value);
            } else if (formData[i].key) {
                ap_rprintf(r, "%s\n", formData[i].key);
            } else if (formData[i].value) {
                ap_rprintf(r, "= %s\n", formData[i].value);
            } else {
                break;
            }
        }
    }
    return OK;
}</pre>




    

    <h3><a name="headers_out" id="headers_out">打印出收到的每个HTTP标头</a></h3>



<pre class="prettyprint lang-c">static int example_handler(request_rec *r)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    const apr_array_header_t    *fields;
    int                         i;
    apr_table_entry_t           *e = 0;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    fields = apr_table_elts(r-&gt;headers_in);
    e = (apr_table_entry_t *) fields-&gt;elts;
    for(i = 0; i &lt; fields-&gt;nelts; i++) {
        ap_rprintf(r, "%s: %s\n", e[i].key, e[i].val);
    }
    return OK;
}</pre>




    

    <h3><a name="request_body" id="request_body">将请求正文读入内存</a></h3>



<pre class="prettyprint lang-c">static int util_read(request_rec *r, const char **rbuf, apr_off_t *size)
{
    /*~~~~~~~~*/
    int rc = OK;
    /*~~~~~~~~*/

    if((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR))) {
        return(rc);
    }

    if(ap_should_client_block(r)) {

        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        char         argsbuffer[HUGE_STRING_LEN];
        apr_off_t    rsize, len_read, rpos = 0;
        apr_off_t length = r-&gt;remaining;
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

        *rbuf = (const char *) apr_pcalloc(r-&gt;pool, (apr_size_t) (length + 1));
        *size = length;
        while((len_read = ap_get_client_block(r, argsbuffer, sizeof(argsbuffer))) &gt; 0) {
            if((rpos + len_read) &gt; length) {
                rsize = length - rpos;
            }
            else {
                rsize = len_read;
            }

            memcpy((char *) *rbuf + rpos, argsbuffer, (size_t) rsize);
            rpos += rsize;
        }
    }
    return(rc);
}

static int example_handler(request_rec *r) 
{
    /*~~~~~~~~~~~~~~~~*/
    apr_off_t   size;
    const char  *buffer;
    /*~~~~~~~~~~~~~~~~*/

    if(util_read(r, &amp;buffer, &amp;size) == OK) {
        ap_rprintf(r, "We read a request body that was %" APR_OFF_T_FMT " bytes long", size);
    }
    return OK;
}</pre>





    

</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>