<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>Apache HTTP Server 2.x中的挂钩函数-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">开发人员文档</a></div><div id="page-content"><div id="preamble"><h1>Apache HTTP Server 2.x中的挂钩函数</h1>


    <div class="warning"><h3>警告</h3>
      <p>该文档仍在开发中，可能已过时。</p>
    </div>

    <p>通常，挂钩函数是Apache HTTP Server在处理请求期间的某个时刻将调用的函数。模块可以提供被调用的函数，并指定与其他模块相比它们何时被调用。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#corehooks">核心挂钩</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#create">创建一个钩子函数</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#hooking">钩上钩</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="corehooks" id="corehooks">核心挂钩</a></h2>
    <p>httpd的核心模块提供了在标准<a href="./request.html">请求处理</a>阶段使用的挂钩的预定义列表。创建一个新的钩子将公开一个实现它的函数（请参阅下面的部分），但是必须了解您不会扩展httpd的核心钩子，这一点很重要。它们在请求处理中的存在和顺序实际上是如何调用它们的结果<code>server/request.c</code> （请查看<a href="./modguide.html#hooking">本节</a>以获取概述）。核心挂钩在<a href="https://ci.apache.org/projects/httpd/trunk/doxygen/group__hooks.html">doxygen文档</a>中列出。</p>

    <p>强烈建议您阅读<a href="./modguide.html">有关开发模块</a>和在继续操作之前进行<a href="./request.html">请求处理的</a>阅读<a href="./modguide.html">指南</a> 。
    </p> 
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="create" id="create">创建一个钩子函数</a></h2>
    <p>为了创建一个新的钩子，需要完成四件事：</p>

    <h3><a name="create-declare" id="create-declare">声明钩子功能</a></h3>
      <p>使用<code>AP_DECLARE_HOOK</code>宏，需要为其提供钩子函数的返回类型，钩子名称和参数。例如，如果钩子返回一个<code>int</code>并采取<code>request_rec *</code>和<code>int</code>被称为<code>do_something</code> ，然后这样声明：</p>
      <pre class="prettyprint lang-c">AP_DECLARE_HOOK(int, do_something, (request_rec *r, int n))</pre>


      <p>如果模块要使用该钩子，则应将其包含在标题中。</p>
    

    <h3><a name="create-create" id="create-create">创建挂钩结构</a></h3>
      <p>每个导出钩子的源文件都有一个私有结构，用于记录使用该钩子的模块功能。声明如下：</p>

      <pre class="prettyprint lang-c">APR_HOOK_STRUCT(
  APR_HOOK_LINK(do_something)
  ...
)</pre>

    

    <h3><a name="create-implement" id="create-implement">实现挂钩调用者</a></h3>
      <p>导出钩子的源文件必须实现一个将调用该钩子的函数。当前有三种可能的方法可以做到这一点。在所有情况下，调用函数都会被调用<code>ap_run_<var>hookname</var>()</code> 。</p>

      <h4>空钩</h4>
        <p>如果一个钩子的返回值是<code>void</code> ，然后所有的钩子都被调用，并且调用方的实现如下：</p>

        <pre class="prettyprint lang-c">AP_IMPLEMENT_HOOK_VOID(do_something, (request_rec *r, int n), (r, n))</pre>


        <p>第二个和第三个参数是伪参数声明和伪参数，因为它们将在调用该钩子时使用。换句话说，此宏扩展为如下所示：</p>

        <pre class="prettyprint lang-c">void ap_run_do_something(request_rec *r, int n)
{
    ...
    do_something(r, n);
}</pre>

      

      <h4>挂钩返回值</h4>
        <p>如果该钩子返回一个值，那么它可以一直运行到第一个执行某些有趣操作的钩子，如下所示：</p>

        <pre class="prettyprint lang-c">AP_IMPLEMENT_HOOK_RUN_FIRST(int, do_something, (request_rec *r, int n), (r, n), DECLINED)</pre>


        <p>第一个<em>不</em>返回的钩子<code>DECLINED</code>停止循环，并从挂钩调用方返回其返回值。注意<code>DECLINED</code>是传统的钩子返回值，表示“我什么也没做”，但它可以适合您。</p>

        <p>或者，所有钩子都可以运行，直到发生错误。这归结为允许<em>两个</em>返回值，其中一个表示“我做了什么，没关系”，另一个表示“我什么也没做”。返回第一个值而不是这两个值之一的函数将停止循环，并且其返回值是返回值。像这样声明它们：</p>

        <pre class="prettyprint lang-c">AP_IMPLEMENT_HOOK_RUN_ALL(int, do_something, (request_rec *r, int n), (r, n), OK, DECLINED)</pre>


        <p>再次， <code>OK</code>和<code>DECLINED</code>是传统价值观。您可以使用所需的东西。</p>
      
    

    <h3><a name="create-call" id="create-call">呼叫挂机呼叫者</a></h3>
      <p>在代码中的适当时刻，调用钩子调用程序，如下所示：</p>

      <pre class="prettyprint lang-c">int n, ret;
request_rec *r;

ret=ap_run_do_something(r, n);</pre>

    
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="hooking" id="hooking">钩上钩</a></h2>
    <p>想要一个钩子被调用的模块需要做两件事。</p>

    <h3><a name="hooking-implement" id="hooking-implement">实现挂钩功能</a></h3>
      <p>包括适当的标题，并定义正确类型的静态函数：</p>

      <pre class="prettyprint lang-c">static int my_something_doer(request_rec *r, int n)
{
    ...
    return OK;
}</pre>

    

    <h3><a name="hooking-add" id="hooking-add">添加钩子注册功能</a></h3>
      <p>在初始化期间，服务器将调用每个模块的钩子注册函数，该函数包含在模块结构中：</p>

      <pre class="prettyprint lang-c">static void my_register_hooks()
{
    ap_hook_do_something(my_something_doer, NULL, NULL, APR_HOOK_MIDDLE);
}

mode MODULE_VAR_EXPORT my_module =
{
    ...
    my_register_hooks       /* register hooks */
};</pre>

    

    <h3><a name="hooking-order" id="hooking-order">控制挂钩调用顺序</a></h3>
      <p>在上面的示例中，我们没有在钩子注册函数中使用三个参数来控制在钩子中注册的所有函数的调用顺序。有两种执行此操作的机制。第一种方法（不是很简单）允许我们大致指定挂钩相对于其他模块的运行位置。最后一个参数控制这个。有三个可能的值： <code>APR_HOOK_FIRST</code> ， <code>APR_HOOK_MIDDLE</code>和<code>APR_HOOK_LAST</code> 。</p>

      <p>使用任何特定值的所有模块都可以相对于彼此以任何顺序运行，但是，当然，使用<code>APR_HOOK_FIRST</code>将在之前运行<code>APR_HOOK_MIDDLE</code>之前<code>APR_HOOK_LAST</code> 。不在乎何时运行的模块应使用<code>APR_HOOK_MIDDLE</code> 。<em>这些值被隔开，因此位置<code>APR_HOOK_FIRST-2</code>可以比其他功能更早地挂接。</em></p>

      <p>请注意，还有两个值， <code>APR_HOOK_REALLY_FIRST</code>和<code>APR_HOOK_REALLY_LAST</code> 。这些只能由钩子导出器使用。</p>

      <p>另一种方法可以进行更好的控制。当某个模块知道必须在某些其他模块之前（或之后）运行时，可以按名称指定它们。第二个（第三个）参数是一个以NULL终止的字符串数组，其中包含必须在当前模块之前（之后）运行的模块名称。例如，假设我们要先运行“ mod_xyz.c”和“ mod_abc.c”，然后将执行如下操作：</p>

      <pre class="prettyprint lang-c">static void register_hooks()
{
    static const char * const aszPre[] = { "mod_xyz.c", "mod_abc.c", NULL };

    ap_hook_do_something(my_something_doer, aszPre, NULL, APR_HOOK_MIDDLE);
}</pre>


      <p>请注意，用于实现此目的的排序是稳定的，因此排序顺序由<code>APR_HOOK_<var>ORDER</var></code>尽可能保留。</p>

    
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>