<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>过滤器如何在Apache 2.0中工作-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">开发人员文档</a></div><div id="page-content"><div id="preamble"><h1>过滤器如何在Apache 2.0中工作</h1>


    <div class="warning"><h3>警告</h3>
      <p>这是电子邮件中的剪切粘贴作业（<022501c1c529 $ f63a9550 $ 7f00000a @ KOJ>），仅重新格式化以提高可读性。它不是最新的，但可能是进一步研究的良好开端。</p>
    </div>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#types">筛选器类型</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#howinserted">如何插入过滤器？</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#asis">阿西斯</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#conclusion">说明</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="types" id="types">筛选器类型</a></h2>
    <p>共有三种基本过滤器类型（实际上每种类型都分为两类，但稍后介绍）。</p>

    <dl>
    <dt><code>CONNECTION</code></dt>
    <dd>此类型的过滤器在此连接的生存期内有效。（ <code>AP_FTYPE_CONNECTION</code> ， <code>AP_FTYPE_NETWORK</code> ）</dd>

    <dt><code>PROTOCOL</code></dt>
    <dd>从客户端的角度来看，这种类型的过滤器在此请求的生命周期内有效，这意味着该请求从发送请求之时起到接收响应之时才有效。（ <code>AP_FTYPE_PROTOCOL</code> ， <code>AP_FTYPE_TRANSCODE</code> ）</dd>

    <dt><code>RESOURCE</code></dt>
    <dd>此类型的过滤器在此内容用于满足请求时有效。对于简单的请求，这与<code>PROTOCOL</code> ，但内部重定向和子请求可以更改内容而不会结束请求。 （<code>AP_FTYPE_RESOURCE</code> ， <code>AP_FTYPE_CONTENT_SET</code> ）</dd>
    </dl>

    <p>区分协议和资源过滤器很重要。资源过滤器绑定到特定资源，它也可能绑定到标头信息，但是主要绑定是绑定到资源。如果您正在编写过滤器，并且想知道它是资源还是协议，则要问的正确问题是：“如果将请求重定向到其他资源，可以删除此过滤器吗？“如果答案是肯定的，则它是资源过滤器。如果为否，则很可能是协议或连接筛选器。我不会去研究连接过滤器，因为它们似乎很容易理解。使用此定义，一些示例可能会有所帮助：</p>

    <dl>
    <dt>字节范围</dt>
    <dd>我们已将其编码为可插入所有请求，如果未使用，则将其删除。由于此过滤器在所有请求的开始都处于活动状态，因此如果重定向，则无法将其删除，因此这是一个协议过滤器。</dd>

    <dt>http_header</dt>
    <dd>该过滤器实际上将标头写入网络。显然，这是必需的过滤器（特殊情况除外，这将在下文处理），因此它是协议过滤器。</dd>

    <dt>放气</dt>
    <dd>管理员根据请求的文件配置此过滤器。如果我们执行从自动索引页面到index.html页面的内部重定向，则可以基于config添加或删除deflate过滤器，因此这是资源过滤器。</dd>
    </dl>

    <p>严格将每个类别进一步细分为两种过滤器类型是为了订购。我们可以删除它，只允许使用一种过滤器类型，但是顺序往往是错误的，我们需要修改一些东西才能使其工作。目前， <code>RESOURCE</code>过滤器只有一种过滤器类型，但是应该改变。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="howinserted" id="howinserted">如何插入过滤器？</a></h2>
    <p>理论上这实际上很简单，但是代码很复杂。首先，重要的是每个人都必须意识到每个请求都有三个过滤器列表，但是它们都被串联在一起：</p>
    <ul>
        <li><code>r->output_filters</code> （对应于RESOURCE）</li>
        <li><code>r->proto_output_filters</code> （对应于PROTOCOL）</li>
        <li><code>r->connection->output_filters</code> （对应于CONNECTION）</li>
    </ul> 
    
    <p>以前的问题是，我们使用单链表创建了过滤器堆栈，然后从“正确”的位置开始。这意味着如果我有一个<code>RESOURCE</code>过滤器在堆栈上，我添加了一个<code>CONNECTION</code>过滤器<code>CONNECTION</code>过滤器将被忽略。这应该是有道理的，因为我们会将连接过滤器插入到<code>c->output_filters</code>清单，但结尾<code>r->output_filters</code>指向以前位于<code>c->output_filters</code> 。这显然是错误的。新的插入代码使用双向链表。这样的好处是我们永远不会丢失已插入的过滤器。不幸的是，它带来了另一组头痛。</p>

    <p>问题在于，使用子请求时，我们有两种不同的情况。首先是在响应中插入更多数据。第二个是用内部重定向替换现有响应。这是两种不同的情况，需要这样处理。</p>

    <p>在第一种情况下，我们从处理程序或过滤器中创建子请求。这意味着下一个过滤器应该传递给<code>make_sub_request</code>功能，子请求中的最后一个资源过滤器将指向主请求中的下一个过滤器。这是有道理的，因为子请求的数据需要流经与主请求相同的一组过滤器。图形表示可能会帮助：</p>

<div class="example"><pre>Default_handler --&gt; includes_filter --&gt; byterange --&gt; ...</pre></div>

    <p>如果include过滤器创建了一个子请求，则我们不希望该子请求中的数据通过include过滤器，因为它可能不是SSI数据。因此，子请求添加了以下内容：</p>

<div class="example"><pre>Default_handler --&gt; includes_filter -/-&gt; byterange --&gt; ...
                                    /
Default_handler --&gt; sub_request_core</pre></div>

    <p>如果子请求是SSI数据会怎样？好吧，那很容易<code>includes_filter</code>是资源过滤器，因此它将被添加到<code>Default_handler</code>和<code>sub_request_core</code>过滤。</p>

    <p>子请求的第二种情况是一个子请求将成为真实请求。每当在处理程序或过滤器之外创建子请求并将NULL作为下一个过滤器传递给<code>make_sub_request</code>功能。</p>

    <p>在这种情况下，资源过滤器对于新请求不再有意义，因为资源已更改。因此，我们无需从头开始，只需将子请求的资源过滤器的前端指向旧请求的协议过滤器的前端。这意味着我们不会丢失任何协议过滤器，也不会尝试通过不应该看到的过滤器发送此数据。</p>

    <p>问题是我们现在正在为过滤器堆栈使用双向链接列表。但是，您应该注意，此模型中可能有两个列表相交。那么，您处理上一个指针了吗？这是一个很难回答的问题，因为没有“正确”的答案，任何一种方法都同样有效。我研究了为什么我们使用以前的指针。这样做的唯一原因是允许更轻松地添加新服务器。话虽如此，我选择的解决方案是使先前的指针始终停留在原始请求上。</p>

    <p>这会导致一些更复杂的逻辑，但它适用于所有情况。我担心将其移到子请求中是，对于更常见的情况（使用子请求将数据添加到响应中），主过滤器链将是错误的。在我看来，这似乎不是一个好主意。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="asis" id="asis">阿西斯</a></h2>
    <p>最后一个话题。 :-) Mod_Asis有点hack，但是处理程序需要删除除连接过滤器之外的所有过滤器，然后发送数据。如果您正在使用<code class="module"><a href="../mod/mod_asis.html">mod_asis</a></code> ，所有其他投注均关闭。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="conclusion" id="conclusion">说明</a></h2>
    <p>绝对的最后一点是该代码之所以难以正确编写的原因，是因为我们破解了太多代码以迫使其工作。我最初写了大多数hack，所以我要怪很多。但是，既然代码正确，我已经开始删除一些技巧。大多数人应该已经看到<code>reset_filters</code>和<code>add_required_filters</code>功能不见了。那些插入的针对错误条件的协议级过滤器，实际上，两个功能都做同样的事情，一个接一个，真的很奇怪。因为我们不再为错误情况丢失协议过滤器，所以这些黑客消失了。的<code>HTTP_HEADER</code> ， <code>Content-length</code>和<code>Byterange</code>过滤器全部添加到<code>insert_filters</code>阶段，因为如果它们是较早添加的，我们将进行一些有趣的交互。现在，所有这些都可以移动以与<code>HTTP_IN</code> ， <code>CORE</code>和<code>CORE_IN</code>过滤器。这将使代码更易于遵循。</p>
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>