<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>缓存指南-Apache HTTP Server版本2.4</title>
<link href="./style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="./style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="./style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="./style/css/prettify.css">
<script src="./style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="./images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="./images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="./index.html">版本2.4</a></div><div id="page-content"><div id="preamble"><h1>缓存指南</h1>


    <p>本文件是对<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code> ， <code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code> ， <code class="module"><a href="./mod/mod_file_cache.html">mod_file_cache</a></code>和<a href="programs/htcacheclean.html">htcacheclean</a>参考文档。它描述了如何使用Apache HTTP Server的缓存功能来加速Web和代理服务，同时避免常见问题和错误配置。</p>
  </div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="./images/down.gif"> <a href="#introduction">介绍</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#http-caching">三态RFC2616 HTTP缓存</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#examples">缓存设置示例</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#socache-caching">通用两状态键/值共享对象缓存</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#file-caching">专用文件缓存</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#security">安全注意事项</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="introduction" id="introduction">介绍</a></h2>
    
    
    <p>Apache HTTP服务器提供了一系列缓存功能，这些缓存功能旨在以各种方式提高服务器的性能。</p>

    <dl>
        <dt>三态RFC2616 HTTP缓存</dt>
        <dd>
            <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>及其提供者模块<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>提供智能的，支持HTTP的缓存。内容本身存储在缓存中，并且mod_cache旨在遵循<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">RFC2616第13节中</a>所述的所有控制内容可缓存性的各种HTTP标头和选项。
            <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>适用于简单和复杂的缓存配置，在这些配置中，您要处理代理内容，动态本地内容，或者需要加快对可能速度较慢的磁盘上本地文件的访问。
        </dd>

        <dt>两状态键/值共享对象缓存</dt>
        <dd><a href="socache.html">共享库缓存API</a> （socache）及其提供程序模块提供基于服务器范围的键/值的共享库缓存。这些模块旨在缓存低级数据，例如SSL会话和身份验证凭据。后端允许将数据存储在服务器范围内的共享内存中，或数据中心范围内的数据存储在诸如memcache或distcache之类的缓存中。
        </dd>

        <dt>专用文件缓存</dt>
        <dd>
            <code class="module"><a href="./mod/mod_file_cache.html">mod_file_cache</a></code>提供了在服务器启动时将文件预加载到内存中的功能，并且可以缩短访问时间并在经常访问的文件上保存文件句柄，因为不需要每次请求都访问磁盘。</dd>
    </dl>

    <p>为了从本文档中获得最大收益，您应该熟悉HTTP的基础知识，并已阅读了将<a href="urlmapping.html">URL映射到文件系统</a>和<a href="content-negotiation.html">内容协商</a>的用户指南。</p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="http-caching" id="http-caching">三态RFC2616 HTTP缓存</a></h2>

    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code></li><li><code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_cache.html#cacheenable">CacheEnable</a></code></li><li><code class="directive"><a href="./mod/mod_cache.html#cachedisable">CacheDisable</a></code></li><li><code class="directive"><a href="./mod/core.html#usecanonicalname">UseCanonicalName</a></code></li><li><code class="directive"><a href="./mod/mod_negotiation.html#cachenegotiateddocs">CacheNegotiatedDocs</a></code></li></ul></td></tr></tbody></table>

    <p>HTTP协议包含<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">对RFC2616第13节所述</a>的内联缓存机制的内置支持，以及<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>模块可以用来利用这一点。</p>

    <p>与简单的两个状态键/值高速缓存不同，该内容在不再新鲜时会完全消失，HTTP高速缓存包含一种机制，用于保留陈旧的内容，并询问源服务器此陈旧的内容是否已更改，如果未更改，请使其再次新鲜。</p>

    <p>HTTP缓存中的条目存在以下三种状态之一：</p>

    <dl>
    <dt>新鲜</dt>
    <dd>如果内容足够新（未超过其<strong>新鲜度</strong> ），则认为它是<strong>新鲜的</strong> 。HTTP缓存可以免费提供新鲜的内容，而无需对原始服务器进行任何调用。
    </dd>
    <dt>陈旧</dt>
    <dd>
        <p>如果内容太旧（比其<strong>新鲜度寿命长</strong> ），则认为它是<strong>陈旧的</strong> 。HTTP缓存应与原始服务器联系，并在将过时的内容提供给客户端之前检查内容是否仍然新鲜。如果仍然无效，原始服务器将使用替换内容进行响应，或者理想情况下，原始服务器将使用代码进行响应以告诉缓存内容仍然是最新的，而无需再次生成或发送内容。内容再次变得新鲜，并且循环继续。</p>

        <p>HTTP协议确实允许高速缓存在某些情况下为过时的数据提供服务，例如，尝试使用源服务器刷新数据失败并出现5xx错误时，或者当另一个请求已经在刷新给定条目的过程中时。在这些情况下<code>Warning</code>标头已添加到响应中。</p>
    </dd>
    <dt>不存在的</dt>
    <dd>如果缓存已满，它将保留从缓存中删除内容以腾出空间的选项。内容可以随时删除，并且可以是陈旧或新鲜的。<a href="programs/htcacheclean.html">htcacheclean</a>工具可以一次性运行，也可以作为守护程序部署，以将高速缓存的大小保持在给定的大小或inode的数量之内。该工具将尝试删除过时的内容，然后再尝试删除新的内容。
    </dd>
    </dl>

    <p>有关HTTP缓存工作原理的完整详细信息，请参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">RFC2616的第13节</a> 。</p>

    <h3>与服务器的交互</h3>
      

      <p>的<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>模块根据可能的值在两个可能的位置挂接到服务器<code class="directive"><a href="./mod/mod_cache.html#cachequickhandler">CacheQuickHandler</a></code>指示：</p>

      <dl>
        <dt>快速处理程序阶段</dt>
        <dd>
          <p>此阶段发生在请求处理期间的很早，就在解析请求之后。如果在缓存中找到了内容，则将立即提供该内容，并且几乎所有请求处理都将被绕过。</p>

              <p>在这种情况下，缓存的行为就像是已“固定”在服务器的前端。</p>
              
              <p>此模式可提供最佳性能，因为绕过大多数服务器处理。但是，此模式也会绕过服务器处理的身份验证和授权阶段，因此，在此模式很重要时，应谨慎选择此模式。</p>
  
              <p>具有“ Authorization”标头的请求（例如，HTTP基本身份验证）在以下情况下既不可缓存，也无法从缓存中提供服务： <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>正在此阶段运行。</p>
          </dd>
          <dt>正常处理程序阶段</dt>
          <dd>
              <p>在所有请求阶段完成之后，此阶段发生在请求处理的后期。</p>

              <p>在这种情况下，缓存的行为就像是已“固定”在服务器的背面。</p>

              <p>此模式提供了最大的灵活性，因为存在潜在的缓存发生在筛选器链中精确控制的位置的可能性，并且可以在将缓存的内容发送给客户端之前对其进行过滤或个性化。</p>
          </dd>
        </dl>

        <p>如果在缓存中找不到该URL， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>会将一个<a href="filter.html">过滤器</a>添加到过滤器堆栈中，以便记录对缓存的响应，然后放下脚步，从而继续进行正常的请求处理。如果确定内容可缓存，则将内容保存到缓存中以备将来使用，否则将忽略该内容。</p>

        <p>如果在缓存中找到的内容是陈旧的，则<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>模块将请求转换为<strong>条件请求</strong> 。如果原始服务器以正常响应进行响应，则将缓存正常响应，替换已缓存的内容。如果原始服务器使用304 Not Modified响应进行响应，则内容将再次标记为新鲜，并且缓存的内容由过滤器提供，而不是将其保存。</p>
    

    <h3>改善缓存命中</h3>
      

      <p>当虚拟主机被许多不同的服务器别名之一识别时，请确保<code class="directive"><a href="./mod/core.html#usecanonicalname">UseCanonicalName</a></code>被设定为<code>On</code>可以大大提高缓存命中率。这是因为在缓存键中使用了服务内容的虚拟主机的主机名。设置为<code>On</code>具有多个服务器名称或别名的虚拟主机不会产生不同的缓存实体，而是根据规范的主机名缓存内容。</p>

    

    <h3>新鲜寿命</h3>
      

      <p>打算缓存的格式正确的内容应使用<code>Cache-Control</code>标头的<code>max-age</code>要么<code>s-maxage</code>字段，或通过添加<code>Expires</code>标头。</p>
      
      <p>同时，当客户端提出自己的请求时，原始服务器定义的新鲜度生存期可以被客户端覆盖<code>Cache-Control</code>请求中的标头。在这种情况下，将获得请求和响应之间的最低新鲜度生存期。</p>

      <p>当请求或响应中缺少此新鲜度生存期时，将应用默认的新鲜度生存期。缓存实体的默认新鲜度生存期为一小时，但是可以通过使用<code class="directive"><a href="./mod/mod_cache.html#cachedefaultexpire">CacheDefaultExpire</a></code>指示。</p>

      <p>如果响应中不包含<code>Expires</code>标头，但确实包含一个<code>Last-Modified</code>标头<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>可以根据启发式推断出新鲜度寿命，可以通过使用<code class="directive"><a href="./mod/mod_cache.html#cachelastmodifiedfactor">CacheLastModifiedFactor</a></code>指示。</p>

      <p>对于本地内容或未定义自己内容的远程内容<code>Expires</code>标头<code class="module"><a href="./mod/mod_expires.html">mod_expires</a></code>通过添加可用于微调新鲜度<code>max-age</code>和<code>Expires</code> 。</p>

      <p>最大新鲜度寿命也可以通过使用<code class="directive"><a href="./mod/mod_cache.html#cachemaxexpire">CacheMaxExpire</a></code> 。</p>

    

    <h3>条件请求简要指南</h3>
      

      <p>当内容从缓存中过期并变得陈旧，而不是传递原始请求时，httpd将修改该请求以使其成为有条件的。</p>

      <p>当一个<code>ETag</code>标头存在于原始缓存的响应中， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>将添加一个<code>If-None-Match</code>到原始服务器的请求的标头。当一个<code>Last-Modified</code>标头存在于原始缓存的响应中， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>将添加一个<code>If-Modified-Since</code>到原始服务器的请求的标头。执行这两个操作之一会使请求成为<strong>条件</strong>请求。</p>

      <p>当原始服务器收到条件请求时，原始服务器应检查ETag或Last-Modified参数是否已更改，以适合该请求。如果不是，则原点应以简洁的“ 304未修改”响应进行响应。这会向缓存发出信号，表明过时的内容仍然是新鲜的，应将其用于后续请求，直到再次达到内容的新新鲜度生存期为止。</p>

      <p>如果内容已更改，则将内容作为请求的开始条件。</p>

      <p>有条件的请求有两个好处。首先，当向源服务器发出这样的请求时，如果来自源的内容与高速缓存中的内容匹配，则可以轻松地确定这一点，而无需传输整个资源的开销。</p>

      <p>其次，将设计一种设计良好的原始服务器，以使产生条件请求的成本大大低于完整响应。对于静态文件，通常所涉及的只是对<code>stat()</code>或类似的系统调用，以查看文件的大小或修改时间是否已更改。这样，即使本地内容没有更改，它仍然可以从缓存中更快地提供。</p>
      
      <p>原始服务器应尽实际可能支持条件请求，但是，如果不支持条件请求，则原始服务器将以请求不是有条件的方式进行响应，并且缓存将以内容已更改的方式进行响应并保存新内容到缓存。在这种情况下，缓存的行为类似于简单的两个状态缓存，其中内容实际上是新鲜的或已删除。</p>
    

    <h3>可以缓存什么？</h3>
      

      <p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4">RFC2616第13.4节“响应</a>缓存能力”中定义了HTTP缓存可以缓存的响应的完整定义，可以总结如下：</p>

      <ol>
        <li>必须为此URL启用缓存。见<code class="directive"><a href="./mod/mod_cache.html#cacheenable">CacheEnable</a></code>和<code class="directive"><a href="./mod/mod_cache.html#cachedisable">CacheDisable</a></code>指令。</li>

        <li>响应必须具有200、203、300、301或410的HTTP状态代码。</li>

        <li>该请求必须是HTTP GET请求。</li>

        <li>如果响应包含“ Authorization：”标头，则它还必须在“ Cache-Control：”标头中包含“ s-maxage”，“必须重新验证”或“ public”选项，否则将不会被缓存。</li>

        <li>如果URL包含查询字符串（例如，来自HTML表单GET方法的查询字符串），则除非响应通过包含“ Expires：”标头或“缓存”的max-age或s-maxage指令指定了明确的过期时间，否则它将不会被缓存。 -Control：“标头，根据RFC2616第13.9和13.2.1节的规定。</li>

        <li>如果响应的状态为200（OK），则响应还必须包括“ Etag”，“ Last-Modified”或“ Expires”标头中的至少一个，或响应的max-age或s-maxage指令。 “ Cache-Control：”标头，除非<code class="directive"><a href="./mod/mod_cache.html#cacheignorenolastmod">CacheIgnoreNoLastMod</a></code>指令已用于其他要求。</li>

        <li>如果响应在“ Cache-Control：”标头中包含“ private”选项，则除非将其保存，否则将不会存储该响应。 <code class="directive"><a href="./mod/mod_cache.html#cachestoreprivate">CacheStorePrivate</a></code>已被用于其他要求。</li>

        <li>同样，如果响应在“ Cache-Control：”标头中包含“ no-store”选项，则除非将<code class="directive"><a href="./mod/mod_cache.html#cachestorenostore">CacheStoreNoStore</a></code>已经用过。</li>

        <li>如果响应包含包含所有匹配项“ *”的“ Vary：”标头，则不会存储该响应。</li>
      </ol>
    

    <h3>什么不应该被缓存？</h3>
      

      <p>应该由客户端创建请求，或者由原始服务器构造响应，以通过正确设置内容来决定内容是否可缓存。 <code>Cache-Control</code>标头，以及<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>应该留给客户，以适当地满足客户或服务器的意愿。
      </p>

      <p>时间敏感的内容，或根据HTTP协商未涵盖的请求的具体内容而变化的内容，不应被缓存。此内容应使用声明为不可缓存<code>Cache-Control</code>标头。</p>
      
      <p>如果内容经常更改（以分钟或秒的新鲜度表示），则仍然可以缓存该内容，但是非常希望源服务器正确支持<strong>条件请求</strong> ，以确保不必定期生成完整的响应。</p>

      <p>根据客户端提供的请求标头而有所不同的内容可以通过智能使用<code>Vary</code>响应头。</p>

    

    <h3>可变/协商内容</h3>
      

      <p>当原始服务器设计为根据请求中标头的值响应不同的内容（例如，在同一URL上提供多种语言）时，HTTP的缓存机制可以在同一URL上缓存同一页面的多个变体。</p>
      
      <p>这是通过原始服务器添加一个<code>Vary</code>标头，指示在确定两个变体是否彼此不同时，高速缓存必须考虑哪些标头。</p>

      <p>例如，如果接收到带有变化报头的响应，例如；</p>

      <div class="example"><p><code>Vary: negotiate,accept-language,accept-charset</code></p></div>

      <p><code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>只会将缓存的内容提供给请求者，这些请求者的accept-language和accept-charset标头与原始请求的标头匹配。</p>
      
      <p>内容的多种变体可以并排缓存， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>使用<code>Vary</code>标头和列出的请求标头的对应值<code>Vary</code>确定要返回给客户的众多变体中的哪一个。</p>
    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="examples" id="examples">缓存设置示例</a></h2>

    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code></li><li><code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code></li><li><code class="module"><a href="./mod/mod_cache_socache.html">mod_cache_socache</a></code></li><li><code class="module"><a href="./mod/mod_socache_memcache.html">mod_socache_memcache</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_cache.html#cacheenable">CacheEnable</a></code></li><li><code class="directive"><a href="./mod/mod_cache_disk.html#cacheroot">CacheRoot</a></code></li><li><code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlevels">CacheDirLevels</a></code></li><li><code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlength">CacheDirLength</a></code></li><li><code class="directive"><a href="./mod/mod_cache_socache.html#cachesocache">CacheSocache</a></code></li></ul></td></tr></tbody></table>

    <h3><a name="disk" id="disk">缓存到磁盘</a></h3>
      

      <p>的<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>模块依赖于特定的后端存储实现来管理缓存以及缓存到磁盘<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>提供支持这一点。</p>

      <p>通常，模块将被配置为：</p>

      <pre class="prettyprint lang-config">CacheRoot   "/var/cache/apache/"
CacheEnable disk /
CacheDirLevels 2
CacheDirLength 1</pre>


      <p>重要的是，由于缓存文件是本地存储的，因此操作系统内存缓存通常也将应用于其访问。因此，尽管文件存储在磁盘上，但是如果经常访问它们，则操作系统很可能会确保从内存中实际获取文件。</p>

    

    <h3>了解缓存存储</h3>
      

      <p>要将项目存储在缓存中， <code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>创建所请求URL的22个字符的哈希。该哈希值包含URL的主机名，协议，端口，路径和任何CGI参数，以及由Vary标头定义的元素，以确保多个URL不会相互冲突。</p>

      <p>每个字符可以是64个不同字符中的任何一个，这意味着总共有64 ^ 22个可能的散列。例如，URL可能被哈希到<code>xyTGxSMO2b68mBCykqkp1w</code> 。此哈希用作缓存中该URL特定文件的命名的前缀，但是首先，它会根据<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlevels">CacheDirLevels</a></code>和<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlength">CacheDirLength</a></code>指令。</p>

      <p><code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlevels">CacheDirLevels</a></code>指定应该有多少级子目录，以及<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlength">CacheDirLength</a></code>指定每个目录中应包含多少个字符。使用上面给出的示例设置，哈希将转换为文件名前缀，如下所示： <code>/var/cache/apache/x/y/TGxSMO2b68mBCykqkp1w</code> 。</p>

      <p>该技术的总体目标是减少特定目录中可能存在的子目录或文件的数量，因为大多数文件系统会随着该数量的增加而变慢。设置为“ 1”时<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlength">CacheDirLength</a></code>在任何特定级别，最多可以有64个子目录。设置为2时，可以有64 * 64个子目录，依此类推。除非您有充分的理由不这样做，否则将“ 1”设置用于<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlength">CacheDirLength</a></code>被推荐。</p>

      <p>设置<code class="directive"><a href="./mod/mod_cache_disk.html#cachedirlevels">CacheDirLevels</a></code>取决于您预期在缓存中存储多少文件。通过在以上示例中使用的设置“ 2”，最终可以创建总共4096个子目录。缓存了100万个文件，每个目录大约有245个缓存URL。</p>

      <p>每个URL在高速缓存存储区中至少使用两个文件。通常，存在一个“ .header”文件，其中包括有关URL的元信息（例如，何时到期）和一个“ .data”文件，该文件是要提供的内容的逐字记录副本。</p>

      <p>如果通过“ Vary”标头协商内容，则将为所讨论的URL创建“ .vary”目录。该目录将具有多个“ .data”文件，它们对应于不同协商的内容。</p>
    

    <h3>维护磁盘缓存</h3>
      

      <p>的<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>该模块不会尝试调节高速缓存所使用的磁盘空间量，尽管它会优雅地站在任何磁盘错误上，并且表现得好像永远不存在高速缓存一样。</p>

      <p>而是使用<a href="programs/htcacheclean.html">htcacheclean</a>工具与httpd一起提供，该工具可让您定期清理缓存。确定<a href="programs/htcacheclean.html">htcacheclean的</a>运行<a href="programs/htcacheclean.html">频率</a>以及用于高速缓存的目标大小多少有些复杂，并且可能需要反复试验才能选择最佳值。</p>

      <p><a href="programs/htcacheclean.html">htcacheclean</a>具有两种操作模式。它可以作为持久守护程序运行，也可以从cron定期运行。 <a href="programs/htcacheclean.html">htcacheclean</a>可能需要一个小时或更长时间来处理非常大的缓存（数十GB），如果您是从cron运行的，则建议您确定典型运行需要多长时间，以避免一次运行多个实例。</p>
 
      <p>还建议为htcacheclean选择适当的“ nice”级别，以便该工具在服务器运行时不会引起过多的磁盘io。</p>

      <p class="figure">
      <img src="images/caching_fig1.gif" alt="" width="600" height="406"><br>
      <a id="figure1" name="figure1"><dfn>图1</dfn></a> ：典型的高速缓存增长/清理顺序。</p>

      <p>因为<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>本身不注意使用了多少空间，应确保将<a href="programs/htcacheclean.html">htcacheclean</a>配置为<a href="programs/htcacheclean.html">在进行</a>清理后留出足够的“增长空间”。</p>
    

    <h3><a name="memcache" id="memcache">缓存到memcached</a></h3>
      

      <p>使用<code class="module"><a href="./mod/mod_cache_socache.html">mod_cache_socache</a></code>模块， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>可以缓存来自各种实现（也称为“提供者”）的数据。使用<code class="module"><a href="./mod/mod_socache_memcache.html">mod_socache_memcache</a></code>例如，可以指定将<a href="http://memcached.org">memcached</a>用作后端存储机制。</p>

      <p>通常，模块将配置为：</p>

      <pre class="prettyprint lang-config">CacheEnable socache /
CacheSocache memcache:memcd.example.com:11211</pre>


      <p>额外<code>memcached</code>可以通过将服务器附加到末尾来指定服务器<code>CacheSocache memcache:</code>用逗号分隔的行：</p>

      <pre class="prettyprint lang-config">CacheEnable socache /
CacheSocache memcache:mem1.example.com:11211,mem2.example.com:11212</pre>


      <p>此格式还可以与其他各种格式一起使用<code class="module"><a href="./mod/mod_cache_socache.html">mod_cache_socache</a></code>提供者。例如：</p>

      <pre class="prettyprint lang-config">CacheEnable socache /
CacheSocache shmcb:/path/to/datafile(512000)</pre>


      <pre class="prettyprint lang-config">CacheEnable socache /
CacheSocache dbm:/path/to/datafile</pre>


    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="socache-caching" id="socache-caching">通用两状态键/值共享对象缓存</a></h2>

    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_authn_socache.html">mod_authn_socache</a></code></li><li><code class="module"><a href="./mod/mod_socache_dbm.html">mod_socache_dbm</a></code></li><li><code class="module"><a href="./mod/mod_socache_dc.html">mod_socache_dc</a></code></li><li><code class="module"><a href="./mod/mod_socache_memcache.html">mod_socache_memcache</a></code></li><li><code class="module"><a href="./mod/mod_socache_shmcb.html">mod_socache_shmcb</a></code></li><li><code class="module"><a href="./mod/mod_ssl.html">mod_ssl</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_authn_socache.html#authncachesocache">AuthnCacheSOCache</a></code></li><li><code class="directive"><a href="./mod/mod_ssl.html#sslsessioncache">SSLSessionCache</a></code></li><li><code class="directive"><a href="./mod/mod_ssl.html#sslstaplingcache">SSLStaplingCache</a></code></li></ul></td></tr></tbody></table>
    
    <p>Apache HTTP服务器提供了一个低级共享对象缓存，用于在<a href="socache.html">socache</a>界面中缓存诸如SSL会话或身份验证凭据之类的<a href="socache.html">信息</a> 。</p>

    <p>为每个实现提供了附加模块，提供了以下后端：</p>

    <dl>
    <dt><code class="module"><a href="./mod/mod_socache_dbm.html">mod_socache_dbm</a></code></dt>
    <dd>基于DBM的共享库。</dd>
    <dt><code class="module"><a href="./mod/mod_socache_dc.html">mod_socache_dc</a></code></dt>
    <dd>基于Distcache的共享库。</dd>
    <dt><code class="module"><a href="./mod/mod_socache_memcache.html">mod_socache_memcache</a></code></dt>
    <dd>基于Memcache的共享对象缓存。</dd>
    <dt><code class="module"><a href="./mod/mod_socache_shmcb.html">mod_socache_shmcb</a></code></dt>
    <dd>基于共享内存的共享对象缓存。</dd>
    </dl>

    <h3><a name="mod_authn_socache-caching" id="mod_authn_socache-caching">缓存身份验证凭证</a></h3>
      

      <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_authn_socache.html">mod_authn_socache</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_authn_socache.html#authncachesocache">AuthnCacheSOCache</a></code></li></ul></td></tr></tbody></table>

      <p>的<code class="module"><a href="./mod/mod_authn_socache.html">mod_authn_socache</a></code>模块允许身份验证的结果被缓存，从而减轻了身份验证后端的负担。</p>

    

    <h3><a name="mod_ssl-caching" id="mod_ssl-caching">缓存SSL会话</a></h3>
      

      <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_ssl.html">mod_ssl</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_ssl.html#sslsessioncache">SSLSessionCache</a></code></li><li><code class="directive"><a href="./mod/mod_ssl.html#sslstaplingcache">SSLStaplingCache</a></code></li></ul></td></tr></tbody></table>

      <p>的<code class="module"><a href="./mod/mod_ssl.html">mod_ssl</a></code>模块使用<code>socache</code>接口以提供会话缓存和装订缓存。</p>

    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="file-caching" id="file-caching">专用文件缓存</a></h2>

    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_file_cache.html">mod_file_cache</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_file_cache.html#cachefile">CacheFile</a></code></li><li><code class="directive"><a href="./mod/mod_file_cache.html#mmapfile">MMapFile</a></code></li></ul></td></tr></tbody></table>

    <p>在文件系统可能很慢或文件句柄昂贵的平台上，可以选择在启动时将文件预加载到内存中。</p>

    <p>在打开文件的速度较慢的系统上，存在用于在启动时打开文件并缓存文件句柄的选项。这些选项可在访问静态文件较慢的系统上提供帮助。</p>

    <h3><a name="filehandle" id="filehandle">文件句柄缓存</a></h3>
      

      <p>打开文件的行为本身可能会导致延迟，特别是在网络文件系统上。通过维护常用文件的打开文件描述符的缓存，httpd可以避免这种延迟。当前，httpd提供了一种文件句柄缓存的实现。</p>

      <h4>缓存文件</h4>
        

        <p>httpd中存在的最基本的缓存形式是： <code class="module"><a href="./mod/mod_file_cache.html">mod_file_cache</a></code> 。该缓存不维护文件内容，而是维护一个打开文件描述符表。使用以下方式在配置文件中指定以这种方式缓存的文件： <code class="directive"><a href="./mod/mod_file_cache.html#cachefile">CacheFile</a></code>指示。</p>

        <p>的<code class="directive"><a href="./mod/mod_file_cache.html#cachefile">CacheFile</a></code>指令指示httpd在启动时打开文件，并重新使用此文件句柄进行所有后续对该文件的访问。</p>

        <pre class="prettyprint lang-config">CacheFile /usr/local/apache2/htdocs/index.html</pre>


        <p>如果打算以这种方式缓存大量文件，则必须确保适当设置操作系统对打开文件数的限制。</p>

        <p>虽然使用<code class="directive"><a href="./mod/mod_file_cache.html#cachefile">CacheFile</a></code>不会导致文件内容本身被缓存，这确实意味着如果在httpd运行时文件发生更改，这些更改将不会被接收。该文件将与启动httpd时的文件一致。</p>

        <p>如果在httpd运行时删除了文件，它将继续维护一个打开的文件描述符，并像启动httpd时一样提供文件。这通常也意味着，尽管该文件将被删除并且不会显示在文件系统上，但是直到httpd停止并且文件描述符关闭后，额外的可用空间才能恢复。</p>
      

    

    <h3><a name="inmemory" id="inmemory">内存中缓存</a></h3>
      

      <p>通常，直接从系统内存中进行服务是提供内容的最快方法。从磁盘控制器，或更糟的是从远程网络读取文件，速度要慢几个数量级。磁盘控制器通常涉及物理过程，并且网络访问受到可用带宽的限制。另一方面，内存访问仅需几纳秒。</p>

      <p>虽然系统内存并不便宜，但字节到字节是迄今为止最昂贵的存储类型，确保有效使用它很重要。通过在内存中缓存文件，可以减少系统上可用的内存量。正如我们将看到的，在操作系统缓存的情况下，这并不是什么大问题，但是在使用httpd自己的内存缓存时，确保您不要为缓存分配过多的内存非常重要。否则，系统将被迫换出内存，这可能会降低性能。</p>

      <h4>操作系统缓存</h4>
        

        <p>几乎所有现代操作系统都在内核直接管理的内存中缓存文件数据。这是一项强大的功能，并且在大多数情况下，操作系统会使其正确运行。例如，在Linux上，让我们看看第一次和第二次读取文件所花费的时间有所不同。</p>

        <div class="example"><pre>colm@coroebus:~$ time cat testfile &gt; /dev/null
real    0m0.065s
user    0m0.000s
sys     0m0.001s
colm@coroebus:~$ time cat testfile &gt; /dev/null
real    0m0.003s
user    0m0.003s
sys     0m0.000s</pre></div>

        <p>即使对于这个小文件，读取文件所花费的时间也有巨大差异。这是因为内核已将文件内容缓存在内存中。</p>

        <p>通过确保系统上有“备用”内存，可以确保越来越多的文件内容将存储在此高速缓存中。这可能是内存中缓存的一种非常有效的方法，并且完全不需要额外的httpd配置。</p>

        <p>此外，由于操作系统知道何时删除或修改文件，因此它可以在必要时自动从缓存中删除文件内容。与httpd的内存中缓存相比，这是一个很大的优势，后者无法知道文件何时更改。</p>
      

      <p>尽管自动操作系统缓存具有性能和优点，但在某些情况下，httpd可能会更好地执行内存中缓存。</p>

      <h4>MMapFile缓存</h4>
        

        <p><code class="module"><a href="./mod/mod_file_cache.html">mod_file_cache</a></code>提供<code class="directive"><a href="./mod/mod_file_cache.html#mmapfile">MMapFile</a></code>指令，使您可以在启动时使用httpd将静态文件的内容映射到内存中（使用mmap系统调用）。 httpd将使用内存中的内容来进行对该文件的所有后续访问。</p>

        <pre class="prettyprint lang-config">MMapFile /usr/local/apache2/htdocs/index.html</pre>


        <p>与<code class="directive"><a href="./mod/mod_file_cache.html#cachefile">CacheFile</a></code>指令，httpd启动后将不接受这些文件中的任何更改。</p>

        <p>的<code class="directive"><a href="./mod/mod_file_cache.html#mmapfile">MMapFile</a></code>指令不会跟踪它分配了多少内存，因此您必须确保不要过度使用该指令。每个httpd子进程都会复制该内存，因此确保映射的文件不会太大而导致系统交换内存至关重要。</p>
      
    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="security" id="security">安全注意事项</a></h2>
    

    <h3>授权和访问控制</h3>
      

      <p>使用<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>在默认状态下<code class="directive"><a href="./mod/mod_cache.html#cachequickhandler">CacheQuickHandler</a></code>被设定为<code>On</code>非常类似于将缓存的反向代理连接到服务器的前端。除非缓存模块确定应该像外部缓存一样查询原始服务器，否则请求将由缓存模块处理，这将大大改变httpd的安全模型。</p>

      <p>遍历文件系统层次结构以检查潜在的<code>.htaccess</code>文件将是一项非常昂贵的操作，部分破坏了缓存点（以加快请求速度）， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>不对是否授权缓存实体做出决定。换一种说法;如果<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>已缓存了某些内容，只要该内容尚未过期，就会从缓存中提供该内容。</p>

      <p>例如，如果您的配置允许通过IP地址访问资源，则应确保不缓存此内容。您可以使用<code class="directive"><a href="./mod/mod_cache.html#cachedisable">CacheDisable</a></code>指令，或<code class="module"><a href="./mod/mod_expires.html">mod_expires</a></code> 。任其发展， <code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code> -非常像反向代理-会在提供内容时缓存内容，然后将其提供给任何IP地址上的任何客户端。</p>

      <p>当。。。的时候<code class="directive"><a href="./mod/mod_cache.html#cachequickhandler">CacheQuickHandler</a></code>指令设置为<code>Off</code> ，将执行完整的请求处理阶段，并且安全模型保持不变。</p>
    

    <h3>本地漏洞</h3>
      

      <p>由于可以从缓存中满足对最终用户的请求，因此缓存本身可以成为希望破坏或干扰内容的用户的目标。重要的是要记住，缓存必须始终由运行httpd的用户可写。这与通常建议的情况下保持所有Apache用户不可写的内容形成鲜明对比。</p>

      <p>如果Apache用户受到损害（例如，由于CGI进程中的缺陷），则可能会将缓存作为目标。使用时<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code> ，插入或修改缓存的实体相对容易。</p>

      <p>与可能以Apache用户身份进行的其他类型的攻击相比，这带来了较高的风险。如果您正在使用<code class="module"><a href="./mod/mod_cache_disk.html">mod_cache_disk</a></code>您应该牢记这一点-确保在宣布安全升级后升级httpd，并在可能的情况下使用<a href="suexec.html">suEXEC</a>以非Apache用户身份运行CGI进程。</p>

    

    <h3>缓存中毒</h3>
      

      <p>当将httpd作为缓存代理服务器运行时，也有可能发生所谓的缓存中毒。缓存中毒是攻击的广义术语，其中，攻击者使代理服务器从原始服务器检索不正确的（通常是不受欢迎的）内容。</p>

      <p>例如，如果运行httpd的系统使用的DNS服务器容易受到DNS缓存中毒的攻击，则攻击者可以在从源服务器请求内容时控制httpd连接到的位置。另一个例子是所谓的HTTP请求走私攻击。</p>

      <p>本文档不是深入讨论HTTP请求走私的正确位置（相反，请尝试使用您喜欢的搜索引擎），但是请务必注意，可以发出一系列请求并利用以下漏洞进行操作很重要。原始网络服务器，以便攻击者可以完全控制代理检索的内容。</p>
    

    <h3>拒绝服务/ Cachebusting</h3>
      

      <p>Vary机制允许同一个URL的多个变体并排缓存。根据客户端提供的标头值，缓存将选择正确的变体以返回到客户端。当尝试更改已知在正常使用下包含多种可能值的标头时，此机制可能会成为问题。 <code>User-Agent</code>标头。根据特定网站的受欢迎程度，可以为同一URL创建成千上万个重复的缓存条目，从而排挤缓存中的其他条目。</p>
      
      <p>在其他情况下，可能需要在每个请求上更改特定资源的URL，通常是通过在URL上添加“ cachebuster”字符串来实现。如果此内容被服务器声明为可缓存很长时间，则这些条目可能会挤出缓存中的合法条目。而<code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>提供一个<code class="directive"><a href="./mod/mod_cache.html#cacheignoreurlsessionidentifiers">CacheIgnoreURLSessionIdentifiers</a></code>指令，请谨慎使用此指令，以确保下游代理或浏览器缓存不会遭受相同的拒绝服务问题。</p>
    
  </div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>