<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>SSL / TLS强加密：操作方法-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP服务器</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">SSL / TLS</a></div><div id="page-content"><div id="preamble"><h1>SSL / TLS强加密：操作方法</h1>



<p>本文档旨在帮助您入门，并使一些工作正常进行。强烈建议您阅读其余的SSL文档，并在继续学习高级技术之前对材料进行更深入的了解。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#configexample">基本配置示例</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#ciphersuites">密码套件和加强安全性</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#ocspstapling">OCSP装订</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#accesscontrol">客户端身份验证和访问控制</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#logging">记录中</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="configexample" id="configexample">基本配置示例</a></h2>


<p>您的SSL配置至少需要包含以下指令。</p>

<pre class="prettyprint lang-config">LoadModule ssl_module modules/mod_ssl.so

Listen 443
&lt;VirtualHost *:443&gt;
    ServerName www.example.com
    SSLEngine on
    SSLCertificateFile "/path/to/www.example.com.cert"
    SSLCertificateKeyFile "/path/to/www.example.com.key"
&lt;/VirtualHost&gt;</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="ciphersuites" id="ciphersuites">密码套件和加强安全性</a></h2>

<ul>
<li><a href="#onlystrong">如何创建仅接受强加密的SSL服务器？</a></li>
<li><a href="#strongurl">如何创建一个SSL服务器，该服务器通常接受所有类型的密码，但是需要强密码才能访问特定的URL？</a></li>
</ul>

<h3><a name="onlystrong" id="onlystrong">如何创建仅接受强加密的SSL服务器？</a></h3>

    <p>以下仅启用最强的密码：</p>
    <pre class="prettyprint lang-config">SSLCipherSuite HIGH:!aNULL:!MD5</pre>


    <p>在使用以下配置时，您可以为特定的速度优化密码指定首选项（如果客户端支持，它将由mod_ssl选择）：</p>

    <pre class="prettyprint lang-config">SSLCipherSuite RC4-SHA:AES128-SHA:HIGH:!aNULL:!MD5
SSLHonorCipherOrder on</pre>



<h3><a name="strongurl" id="strongurl">如何创建一个SSL服务器，该服务器通常接受所有类型的密码，但是需要强密码才能访问特定的URL？</a></h3>

    <p>显然，在服务器范围内<code class="directive"><a href="../mod/mod_ssl.html#sslciphersuite">SSLCipherSuite</a></code>将密码限制为强大的变体，这不是答案。然而， <code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>可以在内部重新配置<code>Location</code>块，以提供按目录的解决方案，并可以自动强制重新协商SSL参数以满足新配置。可以按照以下步骤进行：</p>
    <pre class="prettyprint lang-config"># be liberal in general
SSLCipherSuite ALL:!aNULL:RC4+RSA:+HIGH:+MEDIUM:+LOW:+EXP:+eNULL

&lt;Location "/strong/area"&gt;
# but https://hostname/strong/area/ and below
# requires strong ciphers
SSLCipherSuite HIGH:!aNULL:!MD5
&lt;/Location&gt;</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="ocspstapling" id="ocspstapling">OCSP装订</a></h2>


<p>联机证书状态协议（OCSP）是一种用于确定服务器证书是否已被吊销的机制，而OCSP装订是一种特殊形式，其中服务器（例如httpd和mod_ssl）维护其证书的当前OCSP响应。并将它们发送给与服务器通信的客户端。大多数证书包含由签发证书颁发机构维护的OCSP响应程序的地址，并且mod_ssl可以与该响应程序进行通信，以获得可以发送给与服务器通信的客户端的签名响应。</p>

<p>因为客户端可以从服务器获取证书吊销状态，而无需从客户端到证书颁发机构的额外连接，所以OCSP装订是获取吊销状态的首选方法。消除客户端与证书颁发机构之间的通信的其他好处是，客户端浏览历史记录不会暴露给证书颁发机构，并且通过不依赖于可能负载较重的证书颁发机构服务器来获取状态更加可靠。</p>

<p>由于服务器获得的响应可以在响应有效期间被使用相同证书的所有客户端重用，因此服务器的开销很小。</p>

<p>正确配置了常规SSL支持后，启用OCSP装订通常只需要对httpd配置进行非常小的修改-这两个指令的附加内容：</p>

    <pre class="prettyprint lang-config">SSLUseStapling On
SSLStaplingCache "shmcb:logs/ssl_stapling(32768)"</pre>


<p>这些指令位于放置其他全局SSL配置指令的任何位置的全局范围（即，不在虚拟主机定义内）。 <code>conf/extra/httpd-ssl.conf</code>对于httpd的常规开源构建， <code>/etc/apache2/mods-enabled/ssl.conf</code>适用于Ubuntu或Debian捆绑的httpd等。</p>

<p>上的路径<code class="directive">SSLStaplingCache</code>指令（例如， <code>logs/</code> ）应该与<code class="directive">SSLSessionCache</code>指示。此路径相对于<code class="directive">ServerRoot</code> 。</p>

<p>这个特别<code class="directive">SSLStaplingCache</code>指令要求<code class="module"><a href="../mod/mod_socache_shmcb.html">mod_socache_shmcb</a></code> （来自<code>shmcb</code>指令参数的前缀）。该模块通常已经启用了<code class="directive">SSLSessionCache</code>或代表除<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code> 。如果您使用以下以外的机制启用了SSL会话缓存<code class="module"><a href="../mod/mod_socache_shmcb.html">mod_socache_shmcb</a></code> ，将替代机制用于<code class="directive">SSLStaplingCache</code>也一样例如：</p>

    <pre class="prettyprint lang-config">SSLSessionCache "dbm:logs/ssl_scache"
SSLStaplingCache "dbm:logs/ssl_stapling"</pre>


<p>您可以使用openssl命令行程序来验证服务器是否发送了OCSP响应：</p>

<pre>$ openssl s_client -connect www.example.com:443 -status -servername www.example.com
...
OCSP response: 
======================================
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
...
    Cert Status: Good
...</pre>

<p>以下各节重点介绍了需要对配置进行进一步修改的最常见情况。另请参阅<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>参考手册。</p>

<h3>如果服务器使用了多个SSL证书</h3>

<p>OCSP响应存储在SSL装订缓存中。尽管响应的大小通常为几百到几千个字节，但mod_ssl支持OCSP响应，最大大小约为1万个字节。如果证书不止几个，则可能需要增加装订缓存大小（以上示例中为32768字节）。如果存储响应时出错，将记录错误消息AH01929。</p>


<h3>如果证书未指向OCSP响应者，或者必须使用其他地址</h3>

<p>请参阅<code class="directive"><a href="../mod/mod_ssl.html#sslstaplingforceurl">SSLStaplingForceURL</a></code>指示。</p>

<p>您可以使用openssl命令行程序确认服务器证书指向OCSP响应者，如下所示：</p>

<pre>$ openssl x509 -in ./www.example.com.crt -text | grep 'OCSP.*http'
OCSP - URI:http://ocsp.example.com</pre>

<p>如果提供了OCSP URI，并且Web服务器无需使用代理即可直接与其通信，则无需进行配置。请注意，控制来自Web服务器的出站连接的防火墙规则可能需要调整。</p>

<p>如果未提供OCSP URI，请与您的证书颁发机构联系以确定是否可用。如果是这样，请使用<code class="directive"><a href="../mod/mod_ssl.html#sslstaplingforceurl">SSLStaplingForceURL</a></code>在使用证书的虚拟主机中。</p>


<h3>如果配置了多个启用SSL的虚拟主机，并且某些主机应禁用OCSP装订</h3>


<p>加<code>SSLUseStapling Off</code>到应禁用OCSP装订的虚拟主机。</p>


<h3>如果OCSP响应程序速度慢或不可靠</h3>

<p>有几种指令可用于处理超时和错误。请参阅文档<code class="directive"><a href="../mod/mod_ssl.html#sslstaplingfaketrylater">SSLStaplingFakeTryLater</a></code> ， <code class="directive"><a href="../mod/mod_ssl.html#sslstaplingrespondertimeout">SSLStaplingResponderTimeout</a></code>和<code class="directive"><a href="../mod/mod_ssl.html#sslstaplingreturnrespondererrors">SSLStaplingReturnResponderErrors</a></code>指令。</p>


<h3>如果mod_ssl记录错误AH02217</h3>

<pre>AH02217: ssl_stapling_init_cert: Can't retrieve issuer certificate!</pre>
<p>为了在使用特定服务器证书时支持OCSP装订，必须配置该证书的证书链。如果未将其配置为启用SSL的一部分，则在启用装订时将发出AH02217错误，并且不会为使用证书的客户端提供OCSP响应。</p>

<p>请参阅<code class="directive"><a href="../mod/mod_ssl.html#sslcertificatechainfile">SSLCertificateChainFile</a></code>和<code class="directive"><a href="../mod/mod_ssl.html#sslcertificatefile">SSLCertificateFile</a></code>有关配置证书链的说明。</p>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="accesscontrol" id="accesscontrol">客户端身份验证和访问控制</a></h2>

<ul>
<li><a href="#allclients">如何强制客户端使用证书进行身份验证？</a></li>
<li><a href="#arbitraryclients">如何强制客户端使用证书中的特定URL进行身份验证，但仍然允许任意客户端访问服务器的其余部分？</a></li>
<li><a href="#certauthenticate">如何仅允许具有证书的客户端访问特定的URL，但允许所有客户端访问服务器的其余部分？</a></li>
<li><a href="#intranet">对于来自Internet的客户端，我如何要求HTTPS具有强密码，基本身份验证或客户端证书才能访问Intranet网站的一部分？</a></li>
</ul>

<h3><a name="allclients" id="allclients">如何强制客户端使用证书进行身份验证？</a></h3>


    <p>当您知道所有用户时（例如，在公司Intranet上通常如此），则可以要求普通证书身份验证。您需要做的就是创建由您自己的CA证书（ <code>ca.crt</code> ），然后对照此证书验证客户端。</p>
    <pre class="prettyprint lang-config"># require a client certificate which has to be directly
# signed by our CA certificate in ca.crt
SSLVerifyClient require
SSLVerifyDepth 1
SSLCACertificateFile "conf/ssl.crt/ca.crt"</pre>



<h3><a name="arbitraryclients" id="arbitraryclients">如何强制客户端使用证书中的特定URL进行身份验证，但仍然允许任意客户端访问服务器的其余部分？</a></h3>


    <p>要强制客户端使用针对特定URL的证书进行身份验证，可以使用以下功能的按目录重新配置功能： <code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code> ：</p>

    <pre class="prettyprint lang-config">SSLVerifyClient none
SSLCACertificateFile "conf/ssl.crt/ca.crt"

&lt;Location "/secure/area"&gt;
SSLVerifyClient require
SSLVerifyDepth 1
&lt;/Location&gt;</pre>



<h3><a name="certauthenticate" id="certauthenticate">如何仅允许具有证书的客户端访问特定的URL，但允许所有客户端访问服务器的其余部分？</a></h3>


    <p>这样做的关键是检查客户端证书的一部分是否符合您的期望。通常，这意味着检查全部或部分专有名称（DN），以查看其是否包含某些已知字符串。有两种方法可以使用两种方法之一<code class="module"><a href="../mod/mod_auth_basic.html">mod_auth_basic</a></code>要么<code class="directive"><a href="../mod/mod_ssl.html#sslrequire">SSLRequire</a></code> 。</p>

    <p>的<code class="module"><a href="../mod/mod_auth_basic.html">mod_auth_basic</a></code>如果证书是完全任意的，或者它们的DN没有公共字段（通常是组织等），通常需要使用此方法。在这种情况下，您应该建立一个密码数据库，其中包含<em>所有</em>允许的客户端，如下所示：</p>

    <pre class="prettyprint lang-config">SSLVerifyClient      none
SSLCACertificateFile "conf/ssl.crt/ca.crt"
SSLCACertificatePath "conf/ssl.crt"

&lt;Directory "/usr/local/apache2/htdocs/secure/area"&gt;
    SSLVerifyClient      require
    SSLVerifyDepth       5
    SSLOptions           +FakeBasicAuth
    SSLRequireSSL
    AuthName             "Snake Oil Authentication"
    AuthType             Basic
    AuthBasicProvider    file
    AuthUserFile         "/usr/local/apache2/conf/httpd.passwd"
    Require              valid-user
&lt;/Directory&gt;</pre>


    <p>在此示例中使用的密码是DES加密字符串“ password”。见<code class="directive"><a href="../mod/mod_ssl.html#ssloptions">SSLOptions</a></code>文档以获取更多信息。</p>

    <div class="example"><h3>httpd.passwd</h3><pre>/C=DE/L=Munich/O=Snake Oil, Ltd./OU=Staff/CN=Foo:xxj31ZMTZzkVA
/C=US/L=S.F./O=Snake Oil, Ltd./OU=CA/CN=Bar:xxj31ZMTZzkVA
/C=US/L=L.A./O=Snake Oil, Ltd./OU=Dev/CN=Quux:xxj31ZMTZzkVA</pre></div>

    <p>当您的客户全部属于编码为DN的通用层次结构的一部分时，您可以使用以下命令更轻松地进行匹配<code class="directive"><a href="../mod/mod_ssl.html#sslrequire">SSLRequire</a></code> ， 如下：</p>


    <pre class="prettyprint lang-config">SSLVerifyClient      none
SSLCACertificateFile "conf/ssl.crt/ca.crt"
SSLCACertificatePath "conf/ssl.crt"

&lt;Directory "/usr/local/apache2/htdocs/secure/area"&gt;
  SSLVerifyClient      require
  SSLVerifyDepth       5
  SSLOptions           +FakeBasicAuth
  SSLRequireSSL
  SSLRequire       %{SSL_CLIENT_S_DN_O}  eq "Snake Oil, Ltd." \
               and %{SSL_CLIENT_S_DN_OU} in {"Staff", "CA", "Dev"}
&lt;/Directory&gt;</pre>



<h3><a name="intranet" id="intranet">对于来自Internet的客户端，我如何要求HTTPS具有强密码，基本身份验证或客户端证书才能访问Intranet网站的一部分？我仍然希望允许Intranet上的客户端进行纯HTTP访问。</a></h3>


   <p>这些示例假定Intranet上的客户端的IP地址在192.168.1.0/24范围内，并且您要允许Internet访问的Intranet网站部分为<code>/usr/local/apache2/htdocs/subarea</code> 。此配置应保留在HTTPS虚拟主机之外，以便它适用于HTTPS和HTTP。</p>

    <pre class="prettyprint lang-config">SSLCACertificateFile "conf/ssl.crt/company-ca.crt"

&lt;Directory "/usr/local/apache2/htdocs"&gt;
    #   Outside the subarea only Intranet access is granted
    Require              ip 192.168.1.0/24
&lt;/Directory&gt;

&lt;Directory "/usr/local/apache2/htdocs/subarea"&gt;
    #   Inside the subarea any Intranet access is allowed
    #   but from the Internet only HTTPS + Strong-Cipher + Password
    #   or the alternative HTTPS + Strong-Cipher + Client-Certificate
    
    #   If HTTPS is used, make sure a strong cipher is used.
    #   Additionally allow client certs as alternative to basic auth.
    SSLVerifyClient      optional
    SSLVerifyDepth       1
    SSLOptions           +FakeBasicAuth +StrictRequire
    SSLRequire           %{SSL_CIPHER_USEKEYSIZE} &gt;= 128
    
    #   Force clients from the Internet to use HTTPS
    RewriteEngine        on
    RewriteCond          "%{REMOTE_ADDR}" "!^192\.168\.1\.[0-9]+$"
    RewriteCond          "%{HTTPS}" "!=on"
    RewriteRule          "." "-" [F]
    
    #   Allow Network Access and/or Basic Auth
    Satisfy              any
    
    #   Network Access Control
    Require              ip 192.168.1.0/24
    
    #   HTTP Basic Authentication
    AuthType             basic
    AuthName             "Protected Intranet Area"
    AuthBasicProvider    file
    AuthUserFile         "conf/protected.passwd"
    Require              valid-user
&lt;/Directory&gt;</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="logging" id="logging">记录中</a></h2>
    

    <p><code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>可以将极其冗长的调试信息记录到错误日志中<code class="directive"><a href="../mod/core.html#loglevel">LogLevel</a></code>设置为较高的跟踪级别。另一方面，在非常繁忙的服务器上，级别<code>info</code>可能已经太多了。请记住，您可以配置<code class="directive"><a href="../mod/core.html#loglevel">LogLevel</a></code>每个模块可满足您的需求。</p>
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>