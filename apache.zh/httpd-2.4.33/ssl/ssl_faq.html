<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>SSL / TLS强加密：常见问题-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP服务器</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">SSL / TLS</a></div><div id="page-content"><div id="preamble"><h1>SSL / TLS强加密：常见问题</h1>


<blockquote>
<p>智者没有给出正确的答案，他提出了正确的问题。</p>
<p class="cite">- <cite>克劳德·列维·斯特劳斯</cite></p>

</blockquote>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#installation">安装</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#aboutconfig">组态</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#aboutcerts">证明书</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#aboutssl">SSL协议</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#support">mod_ssl支持</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="installation" id="installation">安装</a></h2>
<ul>
<li><a href="#mutex">为什么在启动Apache时出现与SSLMutex相关的权限错误？</a></li>
<li><a href="#entropy">当启动Apache时，为什么mod_ssl停止并显示错误“无法生成临时512位RSA专用密钥”？</a></li>
</ul>

<h3><a name="mutex" id="mutex">为什么在启动Apache时出现与SSLMutex相关的权限错误？</a></h3>
    <p>诸如``之类的错误<code>mod_ssl: Child could not open SSLMutex lockfile /opt/apache/logs/ssl_mutex.18332 (System error follows) [...] System: Permission denied (errno: 13)</code> ``''通常是由于<em>父</em>目录上的权限限制过于严格所致。确保所有父目录（此处<code>/opt</code> ， <code>/opt/apache</code>和<code>/opt/apache/logs</code> ）至少为运行Apache子级的UID设置了x位（请参见<code class="directive"><a href="../mod/mod_unixd.html#user">User</a></code>指示）。</p>


<h3><a name="entropy" id="entropy">当启动Apache时，为什么mod_ssl停止并显示错误“无法生成临时512位RSA专用密钥”？</a></h3>
    <p>加密软件需要不可预测的数据源才能正常工作。许多开源操作系统都提供了一个用于此目的的“随机设备”（通常称为<code>/dev/random</code> ）。在其他系统上，应用程序必须在生成密钥或执行公共密钥加密之前，使用适当的数据手动为OpenSSL伪随机数生成器（PRNG）植入种子。从0.9.5版开始，如果PRNG尚未以至少128位随机性作为种子，则需要随机性的OpenSSL函数将报告错误。</p>
    <p>为防止此错误， <code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>必须为PRNG提供足够的熵，以使其正常工作。这可以通过<code class="directive"><a href="../mod/mod_ssl.html#sslrandomseed">SSLRandomSeed</a></code>指示。</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="aboutconfig" id="aboutconfig">组态</a></h2>
<ul>
<li><a href="#parallel">是否可以从同一服务器提供HTTP和HTTPS？</a></li>
<li><a href="#ports">HTTPS使用哪个端口？</a></li>
<li><a href="#httpstest">如何出于测试目的手动说HTTPS？</a></li>
<li><a href="#hang">当我连接到支持SSL的Apache服务器时，为什么连接会挂起？</a></li>
<li><a href="#refused">尝试通过HTTPS访问新安装的Apache + mod_ssl服务器时，为什么会出现``拒绝连接''错误？</a></li>
<li><a href="#envvars">为什么<code>SSL_XXX</code>变量对我的CGI和SSI脚本不可用？</a></li>
<li><a href="#relative">如何在相对超链接的HTTP和HTTPS之间切换？</a></li>
</ul>

<h3><a name="parallel" id="parallel">是否可以从同一服务器提供HTTP和HTTPS？</a></h3>
    <p>是。HTTP和HTTPS使用不同的服务器端口（HTTP绑定到端口80，HTTPS绑定到端口443），因此它们之间没有直接冲突。您可以运行绑定到这些端口的两个单独的服务器实例，也可以使用Apache优雅的虚拟托管工具来创建两个虚拟服务器，这两个虚拟服务器均由同一Apache实例提供服务-一个通过HTTP响应端口80上的请求，另一个通过对端口443上的请求的HTTPS。</p>


<h3><a name="ports" id="ports">HTTPS使用哪个端口？</a></h3>
<p>您可以在任何端口上运行HTTPS，但标准指定端口443，默认情况下，该端口是所有HTTPS兼容浏览器的外观。您可以通过在URL中指定浏览器来强制浏览器使用其他端口。例如，如果您的服务器设置为通过端口8080上的HTTPS提供页面，则可以在以下位置访问它们<code>https://example.com:8080/</code></p>


<h3><a name="httpstest" id="httpstest">如何出于测试目的手动说HTTPS？</a></h3>
 <p>虽然您通常只使用</p>

    <div class="example"><p><code>$ telnet localhost 80<br> GET / HTTP/1.0</code></p></div>

    <p>对于通过HTTP进行Apache的简单测试，由于TCP和HTTP之间的SSL协议，对于HTTPS而言并不是那么容易。借助OpenSSL的<code>s_client</code>命令，但是，您可以通过HTTPS执行类似的检查：</p>

    <div class="example"><p><code>$ openssl s_client -connect localhost:443 -state -debug<br> GET / HTTP/1.0</code></p></div>

    <p>在实际的HTTP响应之前，您将收到有关SSL握手的详细信息。对于直接了解HTTP和HTTPS，可以执行GET和POST操作，可以使用代理，支持字节范围等的更通用的命令行客户端，您应该看看漂亮的<a href="http://curl.haxx.se/">cURL</a>工具。使用此方法，可以检查Apache是否通过HTTP和HTTPS正确响应了请求，如下所示：</p>

    <div class="example"><p><code>$ curl http://localhost/<br> $ curl https://localhost/</code></p></div>


<h3><a name="hang" id="hang">当我连接到支持SSL的Apache服务器时，为什么连接会挂起？</a></h3>

<p>当您尝试通过HTTP连接到HTTPS服务器（或虚拟服务器）时（例如，使用<code>http://example.com/</code>代替<code>https://example.com</code> ）。当尝试通过HTTPS连接到HTTP服务器时（例如，使用<code>https://example.com/</code>在不支持HTTPS或在非标准端口上支持HTTPS的服务器上）。确保您要连接到支持SSL的（虚拟）服务器。</p>

<h3><a name="refused" id="refused">尝试通过HTTPS访问新安装的Apache + mod_ssl服务器时，为什么会收到``拒绝连接''消息？</a></h3>
<p>该错误可能是由于配置错误引起的。请确保您的<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>指令与您的<code class="directive"><a href="../mod/core.html#virtualhost"><VirtualHost></a></code>指令。如果所有其他方法均失败，请使用由提供的默认配置重新开始<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code> 。</p>


<h3><a name="envvars" id="envvars">为什么<code>SSL_XXX</code>变量对我的CGI和SSI脚本不可用？</a></h3>
<p>请确保您有`` <code>SSLOptions +StdEnvVars</code> ''已针对您的CGI / SSI请求的上下文启用。</p>


<h3><a name="relative" id="relative">如何在相对超链接的HTTP和HTTPS之间切换？</a></h3>

<p>通常，要在HTTP和HTTPS之间切换，必须使用完全限定的超链接（因为必须更改URL方案）。使用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>但是，您可以操纵相对超链接，以达到相同的效果。</p>
    <pre class="prettyprint lang-config">RewriteEngine on
RewriteRule   "^/(.*)_SSL$"   "https://%{SERVER_NAME}/$1" [R,L]
RewriteRule   "^/(.*)_NOSSL$" "http://%{SERVER_NAME}/$1"  [R,L]</pre>


    <p>此重写规则集使您可以使用以下形式的超链接<code><a href="document.html_SSL"></code> ，以在相对链接中切换到HTTPS。（用NOSSL替换SSL以切换到HTTP。）</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="aboutcerts" id="aboutcerts">证明书</a></h2>
<ul>
<li><a href="#keyscerts">什么是RSA私钥，CSR和证书？</a></li>
<li><a href="#startup">不支持SSL的Apache和支持SSL的Apache之间在启动方面有区别吗？</a></li>
<li><a href="#selfcert">如何创建用于测试目的的自签名SSL证书？</a></li>
<li><a href="#realcert">如何创建真实的SSL证书？</a></li>
<li><a href="#ownca">如何创建和使用自己的证书颁发机构（CA）？</a></li>
<li><a href="#passphrase">如何更改我的私钥文件上的密码？</a></li>
<li><a href="#removepassphrase">如何在Apache启动时摆脱密码对话框？</a></li>
<li><a href="#verify">如何验证私钥与其证书匹配？</a></li>
<li><a href="#pemder">如何将证书从PEM转换为DER格式？</a></li>
<li><a href="#gid">为什么浏览器抱怨无法验证我的服务器证书？</a></li>
</ul>

<h3><a name="keyscerts" id="keyscerts">什么是RSA私钥，CSR和证书？</a></h3>
<p>RSA私钥文件是一个数字文件，可用于解密发送给您的消息。它具有一个公共组件，您可以通过证书文件分发该组件，该组件允许人们加密发送给您的邮件。</p>
    <p>证书签名请求（CSR）是一个数字文件，其中包含您的公共密钥和名称。您将CSR发送给认证机构（CA），该机构将通过签名将其转换为真实的证书。</p>
    <p>证书包含您的RSA公钥，您的姓名，CA的名称，并由CA进行数字签名。知道CA的浏览器可以验证该证书上的签名，从而获得您的RSA公钥。这样一来，他们就可以发送只有您才能解密的消息。</p>
    <p>有关SSL协议的一般说明，请参见“ <a href="ssl_intro.html">简介”</a>一章。</p>


<h3><a name="startup" id="startup">不支持SSL的Apache和支持SSL的Apache之间在启动方面有区别吗？</a></h3>
<p>是。通常，使用<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>内置就像启动没有它的Apache。但是，如果您的SSL私钥文件上有密码短语，则会弹出一个启动对话框，要求您输入密码短语。</p>

    <p>启动服务器时必须手动输入密码短语可能会出现问题-例如，从系统启动脚本启动服务器时。在这种情况下，您可以按照步骤<a href="#removepassphrase">下面</a>从您的私有密钥才能删除该密码。请记住，这样做会带来额外的安全风险-请谨慎操作！</p>


<h3><a name="selfcert" id="selfcert">如何创建用于测试目的的自签名SSL证书？</a></h3>
    <ol>
    <li>确保已安装OpenSSL，并且在您的<code>PATH</code> 。<br>
    <br>
    </li>
    <li>运行以下命令，创建<code>server.key</code>和<code>server.crt</code>文件：<br>
        <code><strong>$ openssl req -new -x509 -nodes -out server.crt -keyout server.key</strong></code><br>这些可以在您的<code>httpd.conf</code>文件：<pre class="prettyprint lang-config">SSLCertificateFile    "/path/to/this/server.crt"
SSLCertificateKeyFile "/path/to/this/server.key"</pre>

    </li>
    <li>请务必注意<code>server.key</code> <em>没有</em>任何密码。要将密码短语添加到密钥，您应该运行以下命令，并根据要求输入并验证密码短语。<br>
        <p><code><strong>$ openssl rsa -des3 -in server.key -out server.key.new</strong></code><br>
        <code><strong>$ mv server.key.new server.key</strong></code><br></p>请备份<code>server.key</code>文件和您输入的密码在安全的位置。
    </li>
    </ol>


<h3><a name="realcert" id="realcert">如何创建真实的SSL证书？</a></h3>
<p>以下是分步说明：</p>
    <ol>
    <li>确保已安装OpenSSL，并且在您的<code>PATH</code> 。
    <br>
    <br>
    </li>
    <li>为您的Apache服务器创建RSA私钥（将采用Triple-DES加密和PEM格式）：<br>
       <br>
       <code><strong>$ openssl genrsa -des3 -out server.key 2048</strong></code><br>
       <br>请备份这个<code>server.key</code>文件和您在安全位置输入的密码。您可以使用以下命令查看此RSA私钥的详细信息：<br>

       <br>
       <code><strong>$ openssl rsa -noout -text -in server.key</strong></code><br>
       <br>如有必要，您还可以使用以下方法创建此RSA私钥的解密的PEM版本（不推荐）：<br>
       <br>
       <code><strong>$ openssl rsa -in server.key -out server.key.unsecure</strong></code><br>
       <br>

    </li>
    <li>使用服务器RSA私钥创建证书签名请求（CSR）（输出将采用PEM格式）：<br>
       <br>
       <code><strong>$ openssl req -new -key server.key -out server.csr</strong></code><br>
       <br>确保当OpenSSL提示您输入“ CommonName”时（即，当您为网站生成CSR后将通过以下方式访问）输入服务器的FQDN（“完全合格的域名”） <code>https://www.foo.dom/</code> ，在此处输入“ www.foo.dom”。您可以使用来查看此CSR的详细信息<br>

       <br>
       <code><strong>$ openssl req -noout -text -in server.csr</strong></code><br>
       <br>
    </li>
    <li>现在，您必须将此证书签名请求（CSR）发送给证书颁发机构（CA）进行签名。一旦签署了CSR，您将拥有一个真实的证书，可供Apache使用。您可以使CSR由商业CA签名，也可以创建自己的CA对其进行签名。<br>商业CA通常会要求您将CSR发布到Web表单中，支付签名费用，然后发送已签名的证书，您可以将其存储在server.crt文件中。<br>有关如何创建自己的CA并将其用于签署CSR的详细信息，请参见<a href="#ownca">下文</a> 。<br>签署CSR后，您可以看到证书的详细信息，如下所示：<br>
       <br>
       <code><strong>$ openssl x509 -noout -text -in server.crt</strong></code><br>

    </li>
    <li>您现在应该有两个文件： <code>server.key</code>和<code>server.crt</code> 。这些可以在您的<code>httpd.conf</code>文件：<pre class="prettyprint lang-config">SSLCertificateFile    "/path/to/this/server.crt"
SSLCertificateKeyFile "/path/to/this/server.key"</pre>的<code>server.csr</code>文件不再需要。
    </li>

    </ol>


<h3><a name="ownca" id="ownca">如何创建和使用自己的证书颁发机构（CA）？</a></h3>
    <p>简短的答案是使用<code>CA.sh</code>要么<code>CA.pl</code> OpenSSL提供的脚本。除非您有充分的理由不这样做，否则应将其优先使用。如果不能，则可以如下创建自签名证书：</p>

    <ol>
    <li>为您的服务器创建RSA私钥（将采用Triple-DES加密和PEM格式）：<br>
       <br>
       <code><strong>$ openssl genrsa -des3 -out server.key 2048</strong></code><br>
       <br>请备份这个<code>server.key</code>文件和您在安全位置输入的密码。您可以使用以下命令查看此RSA私钥的详细信息：<br>
       <br>
       <code><strong>$ openssl rsa -noout -text -in server.key</strong></code><br>
       <br>如有必要，您还可以使用以下方法创建此RSA私钥的解密的PEM版本（不推荐）：<br>
       <br>
       <code><strong>$ openssl rsa -in server.key -out server.key.unsecure</strong></code><br>
       <br>
    </li>
    <li>使用刚刚创建的RSA密钥创建一个自签名证书（X509结构）（输出将采用PEM格式）：<br>
       <br>
       <code><strong>$ openssl req -new -x509 -nodes -sha1 -days 365 -key server.key -out server.crt -extensions usr_cert</strong></code><br>
       <br>这会签署服务器CSR，并导致<code>server.crt</code>文件。<br>您可以使用以下命令查看此证书的详细信息：<br>
       <br>
       <code><strong>$ openssl x509 -noout -text -in server.crt</strong></code><br>
       <br>
    </li>
    </ol>


<h3><a name="passphrase" id="passphrase">如何更改我的私钥文件上的密码？</a></h3>
<p>您只需要使用旧密码来阅读它，然后指定新的密码就可以再次写它。您可以使用以下命令完成此操作：</p>


    <p><code><strong>$ openssl rsa -des3 -in server.key -out server.key.new</strong></code><br>
    <code><strong>$ mv server.key.new server.key</strong></code><br></p>

    <p>第一次要求输入PEM密码时，应输入旧密码。之后，系统会再次要求您输入密码-这次，请使用新的密码。如果要求您验证密码，则需要再次输入新密码。</p>


<h3><a name="removepassphrase" id="removepassphrase">如何在Apache启动时摆脱密码对话框？</a></h3>
<p>在启动和每次重新启动时都会弹出此对话框的原因是，出于安全原因，server.key文件中的RSA私钥以加密格式存储。需要密码来解密此文件，以便可以读取和解析该文件。删除密码短语会消除服务器的安全性-请谨慎操作！</p>
    <ol>
    <li>从RSA私钥中删除加密（同时保留原始文件的备份副本）：<br>
       <br>
       <code><strong>$ cp server.key server.key.org</strong></code><br>
       <code><strong>$ openssl rsa -in server.key.org -out server.key</strong></code><br>

       <br>
    </li>
    <li>确保server.key文件只能由root用户读取：<br>
       <br>
       <code><strong>$ chmod 400 server.key</strong></code><br>
       <br>
    </li>
    </ol>

    <p>现在<code>server.key</code>包含密钥的未加密副本。如果将服务器指向此文件，它将不会提示您输入密码。但是，如果有人获得了此密钥，他们将可以在网络上模拟您。请确保对该文件的权限使得只有root或Web服务器用户才能读取它（最好让您的Web服务器以root身份启动但以另一个用户身份运行，并且密钥只能由root读取）。</p>

    <p>作为一种替代方法，您可以使用`` <code>SSLPassPhraseDialog exec:/path/to/program</code> ''设施。请记住，这当然既不安全也不安全。</p>


<h3><a name="verify" id="verify">如何验证私钥与其证书匹配？</a></h3>
<p>私钥包含一系列数字。这些数字中的两个构成“公钥”，其他两个则属于“私钥”。生成CSR时会包含“公钥”位，这些位随后构成关联证书的一部分。</p>
    <p>要检查证书中的公钥是否与私钥的公共部分匹配，您只需要比较这些数字即可。要查看证书和密钥，请运行以下命令：</p>

    <p><code><strong>$ openssl x509 -noout -text -in server.crt</strong></code><br>
    <code><strong>$ openssl rsa -noout -text -in server.key</strong></code></p>

    <p>密钥和证书中的“模数”和“公共指数”部分必须匹配。由于公共指数通常为65537，并且很难直观地检查长模数是否相同，因此可以使用以下方法：</p>

    <p><code><strong>$ openssl x509 -noout -modulus -in server.crt | openssl md5</strong></code><br>
    <code><strong>$ openssl rsa -noout -modulus -in server.key | openssl md5</strong></code></p>

    <p>这样就剩下两个比较短的数字来比较。从理论上讲，这些数字可能是相同的，而模数却不相同，但是这种可能性非常小。</p>
    <p>如果您希望检查特定CSR属于哪个密钥或证书，可以对CSR执行相同的计算，如下所示：</p>

    <p><code><strong>$ openssl req -noout -modulus -in server.csr | openssl md5</strong></code></p>


<h3><a name="pemder" id="pemder">如何将证书从PEM转换为DER格式？</a></h3>
<p>OpenSSL的默认证书格式是PEM，它是Base64编码的DER，带有页眉和页脚行。对于某些应用程序（例如Microsoft Internet Explorer），您需要纯DER格式的证书。您可以转换PEM文件<code>cert.pem</code>进入相应的DER文件<code>cert.der</code>使用以下命令：<code><strong>$ openssl x509 -in cert.pem -out cert.der -outform DER</strong></code></p>


<h3><a name="gid" id="gid">为什么浏览器抱怨无法验证我的服务器证书？</a></h3>

    <p>发生这种情况的原因之一是因为您的服务器证书是由中间CA签名的。各种CA，例如Verisign或Thawte，已经开始不使用根证书而是使用中间证书来签署证书。</p>

    <p>中间CA证书位于根CA证书（已安装在浏览器中）和服务器证书（已安装在服务器上）之间。为了使浏览器能够遍历并验证从服务器证书到根证书的信任链，需要为其提供中间证书。CA应该能够为您提供可以安装在服务器上的中间证书包。</p>

    <p>您需要将这些中间证书与<code class="directive"><a href="../mod/mod_ssl.html#sslcertificatechainfile">SSLCertificateChainFile</a></code>指示。</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="aboutssl" id="aboutssl">SSL协议</a></h2>
<ul>
<li><a href="#random">在服务器负载沉重的情况下，为什么会出现很多随机SSL协议错误？</a></li>
<li><a href="#load">现在，我的网络服务器可以提供SSL加密流量，为什么它的负载更高？</a></li>
<li><a href="#establishing">为什么到服务器的HTTPS连接有时需要30秒才能建立连接？</a></li>
<li><a href="#ciphers">mod_ssl支持哪些SSL密码？</a></li>
<li><a href="#adh">尝试使用匿名Diffie-Hellman（ADH）密码时，为什么会出现``无共享密码''错误？</a></li>
<li><a href="#sharedciphers">连接到新安装的服务器时，为什么会出现“无共享密码”错误？</a></li>
<li><a href="#vhosts">为什么不能将SSL与基于名称/基于非IP的虚拟主机一起使用？</a></li>
<li><a href="#vhosts2">是否可以使用基于名称的虚拟主机来标识不同的SSL虚拟主机？</a></li>
<li><a href="#comp">如何使SSL压缩正常工作？</a></li>
<li><a href="#lockicon">当我通过HTTPS使用基本身份验证时，弹出对话框时，Netscape浏览器中的锁定图标保持解锁状态。这是否意味着用户名/密码未加密发送？</a></li>
<li><a href="#msie">在使用Microsoft Internet Explorer（MSIE）通过HTTPS连接到Apache + mod_ssl服务器时，为什么会出现I / O错误？</a></li>
<li><a href="#srp">如何启用TLS-SRP？</a></li>
<li><a href="#javadh">当使用超过1024位的证书时，为什么与基于Java的客户端发生握手失败？</a></li>
</ul>

<h3><a name="random" id="random">在服务器负载沉重的情况下，为什么会出现很多随机SSL协议错误？</a></h3>
<p>造成这种情况的原因可能有多种，但主要的原因是由<code class="directive"><a href="../mod/mod_ssl.html#sslsessioncache">SSLSessionCache</a></code>指示。DBM会话高速缓存是最有可能导致此问题的原因，因此使用SHM会话高速缓存（或完全不使用高速缓存）可能会有所帮助。</p>


<h3><a name="load" id="load">现在，我的网络服务器可以提供SSL加密流量，为什么它的负载更高？</a></h3>
<p>SSL使用强大的加密加密，因此需要进行大量的数字运算。当您通过HTTPS请求网页时，所有内容（甚至图像）在传输之前都已加密。因此，HTTPS流量增加导致负载增加。</p>


<h3><a name="establishing" id="establishing">为什么到服务器的HTTPS连接有时需要30秒才能建立连接？</a></h3>
<p>这通常是由<code>/dev/random</code>装置<code class="directive"><a href="../mod/mod_ssl.html#sslrandomseed">SSLRandomSeed</a></code>这会阻塞read（2）调用，直到有足够的熵来满足请求为止。有关更多信息，请参见参考手册。 <code class="directive"><a href="../mod/mod_ssl.html#sslrandomseed">SSLRandomSeed</a></code>指示。</p>


<h3><a name="ciphers" id="ciphers">mod_ssl支持哪些SSL密码？</a></h3>
<p>通常，使用的OpenSSL版本支持的任何SSL密码也受<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code> 。可用的密码取决于您构建OpenSSL的方式。通常，至少支持以下密码：</p>

    <ol>
    <li>带有SHA1的RC4</li>
    <li>AES与SHA1</li>
    <li>具有SHA1的三重DES</li>
    </ol>

    <p>要确定可用密码的实际列表，应运行以下命令：</p>
    <div class="example"><p><code>$ openssl ciphers -v</code></p></div>


<h3><a name="adh" id="adh">尝试使用匿名Diffie-Hellman（ADH）密码时，为什么会出现``无共享密码''错误？</a></h3>
<p>默认情况下，OpenSSL的<em>不允许</em> ADH密码，出于安全原因。如果选择启用这些密码，请确保您已意识到潜在的副作用。</p>
    <p>为了使用匿名Diffie-Hellman（ADH）密码，您必须使用`` <code>-DSSL_ALLOW_ADH</code> ''，然后添加`` <code>ADH</code> ''进入你的<code class="directive"><a href="../mod/mod_ssl.html#sslciphersuite">SSLCipherSuite</a></code> 。</p>


<h3><a name="sharedciphers" id="sharedciphers">连接到新安装的服务器时，为什么会出现“无共享密码”错误？</a></h3>
<p>您可能是自己弄错了<code class="directive"><a href="../mod/mod_ssl.html#sslciphersuite">SSLCipherSuite</a></code>指令（将其与预先配置的示例进行比较<code>extra/httpd-ssl.conf</code> ），或者在生成私钥并忽略或忽略警告时选择使用DSA / DH算法而不是RSA。如果选择了DSA / DH，则服务器将无法使用基于RSA的SSL密码进行通信（至少在配置其他基于RSA的证书/密钥对之前）。像NS或IE这样的现代浏览器只能使用RSA密码通过SSL进行通信。结果是“没有共享密码”错误。要解决此问题，请使用RSA算法重新生成服务器证书/密钥对。</p>


<h3><a name="vhosts" id="vhosts">为什么不能将SSL与基于名称/基于非IP的虚拟主机一起使用？</a></h3>
<p>原因是非常技术性的，还有一个“鸡和鸡蛋”的问题。SSL协议层位于HTTP协议层之下，并封装HTTP。建立SSL连接（HTTPS）后，Apache / mod_ssl必须与客户端协商SSL协议参数。为此，mod_ssl必须咨询虚拟服务器的配置（例如，它必须寻找密码套件，服务器证书等）。但是为了转到正确的虚拟服务器，Apache必须知道<code>Host</code> HTTP标头字段。为此，必须读取HTTP请求标头。无法在SSL握手完成之前完成此操作，但是需要信息才能完成SSL握手阶段。请参阅下一个问题，以了解如何规避此问题。</p>
    
    <p>请注意，如果您具有通配符SSL证书，或者使用subjectAltName字段在其上具有多个主机名的证书，则可以在基于名称的虚拟主机上使用SSL，而无需其他解决方法。</p>


<h3><a name="vhosts2" id="vhosts2">是否可以使用基于名称的虚拟主机来标识不同的SSL虚拟主机？</a></h3>
    <p>基于名称的虚拟主机是一种识别不同虚拟主机的非常流行的方法。它允许您将相同的IP地址和相同的端口号用于许多不同的站点。当人们继续使用SSL时，很自然地假设可以使用同一方法在同一服务器上具有许多不同的SSL虚拟主机。</p>

    <p>可以，但仅当使用2.2.12或更高版本的Web服务器（使用0.9.8j或更高版本的OpenSSL构建）时才可行。这是因为它要求仅添加SSL规范的最新修订（即服务器名称指示（SNI））的功能。</p>

    <p>请注意，如果您具有通配符SSL证书，或者使用subjectAltName字段在其上具有多个主机名的证书，则可以在基于名称的虚拟主机上使用SSL，而无需其他解决方法。</p>

    <p>原因是SSL协议是封装HTTP协议的单独层。因此，SSL会话是一个单独的事务，发生在HTTP会话开始之前。服务器在IP地址X和端口Y（通常为443）上收到SSL请求。由于SSL请求不包含任何Host：字段，因此服务器无法决定要使用哪个SSL虚拟主机。通常，它只使用找到的第一个与指定的端口和IP地址匹配的地址。</p>

    <p>但是，如果使用的Web服务器和OpenSSL版本支持SNI，并且客户端的浏览器也支持SNI，则主机名将包含在原始SSL请求中，并且Web服务器可以选择正确的SSL虚拟主机。</p>

    <p>当然，您可以使用基于名称的虚拟主机来识别许多非SSL虚拟主机（例如，全部在端口80上），然后拥有一个SSL虚拟主机（在端口443上）。但是，如果这样做，则必须确保将非SSL端口号放在NameVirtualHost指令上，例如</p>

    <pre class="prettyprint lang-config">NameVirtualHost 192.168.1.1:80</pre>


    <p>其他解决方法包括：</p>

    <p>为不同的SSL主机使用单独的IP地址。对不同的SSL主机使用不同的端口号。</p>


<h3><a name="comp" id="comp">如何使SSL压缩正常工作？</a></h3>
<p>尽管SSL压缩协商是在SSLv2和TLS规范中定义的，但直到2004年5月，RFC 3749才将DEFLATE定义为可协商的标准压缩方法。
</p>
<p>使用SSL进行编译时，默认情况下，OpenSSL 0.9.8开始支持此功能<code>zlib</code>选项。如果客户端和服务器均支持压缩，则将使用压缩。但是，大多数客户端仍然尝试最初与SSLv2 Hello连接。由于SSLv2在其握手过程中未包含一系列首选压缩算法，因此无法与这些客户端协商压缩。如果客户端禁用对SSLv2的支持，则取决于所使用的SSL库，可能会发送SSLv3或TLS Hello，并且可能会设置压缩。您可以通过记录以下内容来验证客户端是否使用SSL压缩： <code>%{SSL_COMPRESS_METHOD}x</code>变量。
</p>


<h3><a name="lockicon" id="lockicon">当我通过HTTPS使用基本身份验证时，弹出对话框时，Netscape浏览器中的锁定图标保持解锁状态。这是否意味着用户名/密码未加密发送？</a></h3>
<p>否，用户名/密码以加密方式传输。Netscape浏览器中的图标实际上并未与SSL / TLS层同步。仅当传输实际网页数据的第一部分时，它才会切换到锁定状态，这可能会使人们感到困惑。基本身份验证功能是HTTP层的一部分，它位于HTTPS的SSL / TLS层之上。在HTTPS中进行任何HTTP数据通信之前，SSL / TLS层已完成其握手阶段，并已切换为加密通信。因此，请勿对此图标感到困惑。</p>


<h3><a name="msie" id="msie">通过HTTPS连接到具有较旧版本的Microsoft Internet Explorer（MSIE）的Apache + mod_ssl服务器时，为什么会出现I / O错误？</a></h3>
<p>第一个原因是某些MSIE版本中的SSL实现具有一些与HTTP保持活动功能有关的细微错误，并且套接字连接关闭时SSL关闭通知警报。此外，在某些MSIE版本中，SSL和HTTP / 1.1功能之间的交互存在问题。您可以通过强制Apache不使用HTTP / 1.1，保持活动连接或将SSL关闭通知消息发送给MSIE客户端来解决这些问题。可以通过在支持SSL的虚拟主机部分中使用以下指令来完成此操作：</p>
    <pre class="prettyprint lang-config">SetEnvIf User-Agent "MSIE [2-5]" \
         nokeepalive ssl-unclean-shutdown \
         downgrade-1.0 force-response-1.0</pre>

    <p>此外，某些MSIE版本在特定密码方面存在问题。不幸的是，这不可能实现特定于MSIE的解决方法，因为早在SSL握手阶段就需要密码。因此，特定于MSIE <code class="directive"><a href="../mod/mod_setenvif.html#setenvif">SetEnvIf</a></code>不会解决这些问题。相反，您将不得不对全局参数进行更大幅度的调整。在您决定这样做之前，请确保您的客户确实有问题。如果没有，请不要进行这些更改-它们会影响您的<em>所有</em>客户端（MSIE或其他）。</p>


<h3><a name="srp" id="srp">如何启用TLS-SRP？</a></h3>
    <p>TLS-SRP（RFC 5054中指定的TLS的安全远程密码密钥交换）可以补充或替换认证SSL连接的证书。要使用TLS-SRP，请设置<code class="directive"><a href="../mod/mod_ssl.html#sslsrpverifierfile">SSLSRPVerifierFile</a></code>指令指向OpenSSL SRP验证程序文件。要创建验证程序文件，请使用<code>openssl</code>工具：</p>
    <div class="example"><p><code>openssl srp -srpvfile passwd.srpv -add username</code></p></div>
    <p>创建此文件后，在SSL服务器配置中指定它：</p>
    <div class="example"><p><code>SSLSRPVerifierFile /path/to/passwd.srpv</code></p></div>
    <p>要强制客户端使用非证书的TLS-SRP密码套件，请使用以下指令：</p>
    <div class="example"><p><code>SSLCipherSuite "!DSS:!aRSA:SRP"</code></p></div>


<h3><a name="javadh" id="javadh">当使用超过1024位的证书时，为什么与基于Java的客户端发生握手失败？</a></h3>
    <p>从2.4.7版开始， <code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>将使用DH参数，其中包括长度超过1024位的质数。但是，Java 7和更早版本将其对DH素数大小的支持限制为最大1024位。</p>

    <p>如果您的基于Java的客户端因以下异常而中止： <code>java.lang.RuntimeException: Could not generate DH keypair</code>和<code>java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)</code>和httpd日志<code>tlsv1 alert internal error (SSL alert number 80)</code> （在<code class="directive"><a href="../mod/core.html#loglevel">LogLevel</a></code><code>info</code>或更高版本），您可以使用以下命令重新排列mod_ssl的密码列表<code class="directive"><a href="../mod/mod_ssl.html#sslciphersuite">SSLCipherSuite</a></code> （可能与<code class="directive"><a href="../mod/mod_ssl.html#sslhonorcipherorder">SSLHonorCipherOrder</a></code> ），也可以使用带有1024位素数的自定义DH参数，该参数始终优先于任何内置DH参数。</p>

    <p>要生成自定义的DH参数，请使用<code>openssl dhparam 1024</code>命令。或者，您可以使用<a href="http://www.ietf.org/rfc/rfc2409.txt">RFC 2409</a>第6.2节中的以下标准1024位DH参数：</p>
    <div class="example"><pre>-----BEGIN DH PARAMETERS-----
MIGHAoGBAP//////////yQ/aoiFowjTExmKLgNwc0SkCTgiKZ8x0Agu+pjsTmyJR
Sgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHCReSFtXZiXn7G9ExC6aY37WsL
/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7OZTgf//////////AgEC
-----END DH PARAMETERS-----</pre></div>
    <p>将自定义参数（包括“ BEGIN DH PARAMETERS”和“ END DH PARAMETERS”行）添加到使用以下命令配置的第一个证书文件的末尾<code class="directive"><a href="../mod/mod_ssl.html#sslcertificatefile">SSLCertificateFile</a></code>指示。</p>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="support" id="support">mod_ssl支持</a></h2>
<ul>
<li><a href="#resources">如果有mod_ssl问题，可以使用哪些信息资源？</a></li>
<li><a href="#contact">如果出现mod_ssl问题，可以使用哪些支持联系方式？</a></li>
<li><a href="#reportdetails">编写错误报告时应提供哪些信息？</a></li>
<li><a href="#coredumphelp">我有一个核心转储，您能帮我吗？</a></li>
<li><a href="#backtrace">我如何获得回溯，以帮助查找核心转储的原因？</a></li>
</ul>

<h3><a name="resources" id="resources">如果有mod_ssl问题，可以使用哪些信息资源？</a></h3>
<p>以下信息资源可用。如有问题，请先在这里搜索。</p>

    <dl>
    <dt>用户手册的常见问题解答列表中的答案（此）</dt>
    <dd><a href="http://httpd.apache.org/docs/2.4/ssl/ssl_faq.html">http://httpd.apache.org/docs/2.4/ssl/ssl_faq.html</a><br>首先检查FAQ（此文本）。如果您的问题很常见，则可能已经被回答了几次，并已包含在本文档中。
    </dd>
    </dl>


<h3><a name="contact" id="contact">如果出现mod_ssl问题，可以使用哪些支持联系方式？</a></h3>
 <p>以下按优先顺序列出了对mod_ssl的所有支持可能性。请<em>按此顺序处理</em>这些可能性-不要只选择您喜欢的外观。</p>
    <ol>

    <li><em>将问题报告发送到Apache httpd用户支持邮件列表</em><br>
        <a href="mailto:users@httpd.apache.org">users@httpd.apache.org</a><br>这是提交问题报告的第二种方法。同样，您必须首先订阅该列表，但是随后您可以与整个Apache httpd用户社区轻松讨论您的问题。
    </li>

    <li><em>在错误数据库中编写问题报告</em><br>
        <a href="http://httpd.apache.org/bug_report.html">http://httpd.apache.org/bug_report.html</a><br>这是提交问题报告的最后一种方法。仅当您已经张贴到邮件列表并且没有成功时，才应该这样做。请<em>严格</em>遵守上述网页上的说明。
    </li>
    </ol>


<h3><a name="reportdetails" id="reportdetails">编写错误报告时应提供哪些信息？</a></h3>
<p>您应始终至少提供以下信息：</p>

    <dl>
    <dt>Apache httpd和OpenSSL版本信息</dt>
    <dd>可以通过运行确定Apache版本<code>httpd -v</code> 。可以通过运行确定OpenSSL版本<code>openssl version</code> 。或者，如果已安装Lynx，则可以运行以下命令<code>lynx -mime_header http://localhost/ | grep Server</code>一步收集这些信息。
    </dd>

    <dt>有关如何构建和安装Apache httpd和OpenSSL的详细信息</dt>
    <dd>为此，您可以提供终端会话的日志文件，其中显示了配置和安装步骤。如果无法做到这一点，则至少应提供<code class="program"><a href="../programs/configure.html">configure</a></code>您使用的命令行。
    </dd>

    <dt>如果发生核心转储，请包含回溯</dt>
    <dd>如果您的Apache httpd转储了其核心，请附加一个堆栈框架``回溯''（请参阅<a href="#backtrace">以下</a>有关如何获得此信息的信息）。需要此信息才能找到导致核心转储的原因。
    </dd>

    <dt>您的问题的详细说明</dt>
    <dd>不要笑，我们是真的！许多问题报告并未包含对实际问题的描述。没有这个，任何人都很难帮助您。因此，这符合您的个人利益（您想解决问题，不是吗？）请包括尽可能多的细节。当然，您仍然应该包括上面的所有要点。
    </dd>
    </dl>


<h3><a name="coredumphelp" id="coredumphelp">我有一个核心转储，您能帮我吗？</a></h3>
<p>通常不会，至少不会，除非您提供有关Apache转储内核的代码位置的更多详细信息。为了帮助您，通常总是需要回溯（请参阅下一个问题）。没有这些信息，几乎不可能找到问题并帮助您解决问题。</p>


<h3><a name="backtrace" id="backtrace">我如何获得回溯，以帮助查找核心转储的原因？</a></h3>
<p>以下是完成回溯所需完成的步骤：</p>
    <ol>
    <li>确保至少在Apache中具有可用的调试符号。在使用GCC / GDB的平台上，您将必须使用以下命令构建Apache + mod_ssl： <code>OPTIM="-g -ggdb3"</code> ''得到这个。在其他平台上至少<code>OPTIM="-g"</code> ”是必需的。
    </li>

    <li>启动服务器，然后尝试重现核心转储。为此，您可能需要使用类似`` <code>CoreDumpDirectory /tmp</code> ''以确保可以写入core-dump文件。这应该导致<code>/tmp/core</code>要么<code>/tmp/httpd.core</code>文件。如果您没有其中之一，请尝试在非根UID下运行服务器。许多现代内核不允许进程在完成内核后转储内核。 <code>setuid()</code> （除非<code>exec()</code> ）出于安全原因（可能在内存中保留了特权信息）。如有必要，您可以运行<code>/path/to/httpd -X</code>手动强制Apache不进行分叉。
    </li>

    <li>分析核心转储。为此，运行<code>gdb /path/to/httpd /tmp/httpd.core</code>或类似的命令。在GDB中，您要做的就是输入<code>bt</code> ，瞧，您得到了回溯。对于其他调试器，请查阅本地调试器手册。
    </li>
    </ol>

</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>