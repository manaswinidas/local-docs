<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>日志文件-Apache HTTP Server版本2.4</title>
<link href="./style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="./style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="./style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="./style/css/prettify.css">
<script src="./style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="./images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="./images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="./index.html">版本2.4</a></div><div id="page-content"><div id="preamble"><h1>日志文件</h1>


    <p>为了有效地管理Web服务器，有必要获取有关服务器的活动和性能以及可能发生的任何问题的反馈。Apache HTTP Server提供了非常全面和灵活的日志记录功能。本文档介绍了如何配置其日志记录功能以及如何理解日志包含的内容。</p>
  </div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="./images/down.gif"> <a href="#overview">总览</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#security">安全警告</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#errorlog">错误记录</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#permodule">每个模块的日志记录</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#accesslog">访问日志</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#rotation">日志旋转</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#piped">管道日志</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#virtualhost">虚拟主机</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#other">其他日志文件</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="overview" id="overview">总览</a></h2>
    

  <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_log_config.html">mod_log_config</a></code></li><li><code class="module"><a href="./mod/mod_log_forensic.html">mod_log_forensic</a></code></li><li><code class="module"><a href="./mod/mod_logio.html">mod_logio</a></code></li><li><code class="module"><a href="./mod/mod_cgi.html">mod_cgi</a></code></li></ul></td><td></td></tr></tbody></table>

  <p>Apache HTTP Server提供了多种不同的机制来记录服务器上发生的所有事情，从最初的请求到URL映射过程，再到连接的最终解决，包括过程中可能发生的任何错误。除此之外，第三方模块还可以提供日志记录功能，或将条目注入现有的日志文件中，并且诸如CGI程序，PHP脚本或其他处理程序之类的应用程序可以向服务器错误日志发送消息。
  </p>

  <p>在本文档中，我们讨论作为http服务器标准部分的日志记录模块。
  </p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="security" id="security">安全警告</a></h2>
    

    <p>任何可以写入Apache httpd写入日志文件的目录的人几乎都可以访问服务器启动时所使用的uid（通常是root）。<em>不</em>给人家的日志存储在没有意识到后果的目录的写权限;有关详细信息，请参见<a href="misc/security_tips.html">安全提示</a>文档。</p>

    <p>此外，日志文件可能包含客户端直接提供的信息，而不会转义。因此，恶意客户端有可能在日志文件中插入控制字符，因此在处理原始日志时必须格外小心。</p>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="errorlog" id="errorlog">错误记录</a></h2>
    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/core.html">core</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/core.html#errorlog">ErrorLog</a></code></li><li><code class="directive"><a href="./mod/core.html#errorlogformat">ErrorLogFormat</a></code></li><li><code class="directive"><a href="./mod/core.html#loglevel">LogLevel</a></code></li></ul></td></tr></tbody></table>

    <p>服务器错误日志，其名称和位置由<code class="directive"><a href="./mod/core.html#errorlog">ErrorLog</a></code>指令，是最重要的日志文件。这是Apache httpd发送诊断信息并记录其在处理请求时遇到的任何错误的地方。当启动服务器或服务器操作出现问题时，它是第一个查看的地方，因为它通常包含出现问题的原因以及如何解决的详细信息。</p>

    <p>通常将错误日志写入文件（通常是<code>error_log</code>在Unix系统上<code>error.log</code>在Windows和OS / 2上）。在Unix系统上，也可以让服务器将错误发送到<code>syslog</code>或将<a href="#piped">它们传送到程序</a> 。</p>

    <p>错误日志的格式由<code class="directive"><a href="./mod/core.html#errorlogformat">ErrorLogFormat</a></code>指令，您可以使用该指令自定义要记录的值。如果未指定格式，则默认为格式定义。典型的日志消息如下：</p>

    <div class="example"><p><code>[Fri Sep 09 10:42:29.902022 2011] [core:error] [pid 35708:tid 4328636416] [client 72.15.99.187] File does not exist: /usr/local/apache2/htdocs/favicon.ico</code></p></div>

    <p>日志条目中的第一项是消息的日期和时间。接下来是产生消息的模块（在这种情况下为核心）和该消息的严重性级别。紧随其后的是遇到该条件的进程的进程ID和线程ID（如果适用）。接下来，我们有发出请求的客户地址。最后是详细的错误消息，在这种情况下，该错误消息表示请求的文件不存在。</p>

    <p>错误日志中会出现各种各样的不同消息。大多数看起来类似于上面的示例。错误日志还将包含CGI脚本的调试输出。任何写入的信息<code>stderr</code>由CGI脚本将直接复制到错误日志。</p>

    <p>放一个<code>%L</code>错误日志和访问日志中的令牌将生成一个日志条目ID，您可以使用该ID将错误日志中的条目与访问日志中的条目相关联。如果<code class="module"><a href="./mod/mod_unique_id.html">mod_unique_id</a></code>加载后，其唯一的请求ID也将用作日志条目ID。</p>

    <p>在测试过程中，连续监视错误日志中是否存在任何问题通常很有用。在Unix系统上，可以使用以下方法完成此操作：</p>

    <div class="example"><p><code>tail -f error_log</code></p></div>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="permodule" id="permodule">每个模块的日志记录</a></h2>
    

    <p>的<code class="directive"><a href="./mod/core.html#loglevel">LogLevel</a></code>指令使您可以按模块指定日志严重性级别。这样，如果仅对一个特定模块进行故障排除，则可以调高其日志记录量，而无需获取其他您不感兴趣的模块的详细信息。这对于诸如以下的模块特别有用<code class="module"><a href="./mod/mod_proxy.html">mod_proxy</a></code>要么<code class="module"><a href="./mod/mod_rewrite.html">mod_rewrite</a></code>您想知道有关它要执行的操作的详细信息。</p>

    <p>为此，请在您的计算机上指定模块名称<code class="directive">LogLevel</code>指示：</p>

    <pre class="prettyprint lang-config">LogLevel info rewrite:trace5</pre>


    <p>这设置了主要<code class="directive">LogLevel</code>信息，但将其变成<code>trace5</code>对于<code class="module"><a href="./mod/mod_rewrite.html">mod_rewrite</a></code> 。</p>

    <div class="note">这将替换每个模块的日志记录指令，例如<code>RewriteLog</code> ，在服务器的早期版本中存在。</div>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="accesslog" id="accesslog">访问日志</a></h2>
    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_log_config.html">mod_log_config</a></code></li><li><code class="module"><a href="./mod/mod_setenvif.html">mod_setenvif</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code></li><li><code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code></li><li><code class="directive"><a href="./mod/mod_setenvif.html#setenvif">SetEnvIf</a></code></li></ul></td></tr></tbody></table>

    <p>服务器访问日志记录服务器处理的所有请求。访问日志的位置和内容由<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>指示。的<code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code>指令可用于简化日志内容的选择。本节介绍如何配置服务器以在访问日志中记录信息。</p>

    <p>当然，将信息存储在访问日志中只是日志管理的开始。下一步是分析此信息以生成有用的统计信息。日志分析通常不在本文档的讨论范围之内，并不是Web服务器本身工作的一部分。有关此主题的更多信息以及执行日志分析的应用程序，请检查<a href="http://dmoz.org/Computers/Software/Internet/Site_Management/Log_Analysis/">Open Directory</a> 。
    </p>

    <p>各种版本的Apache httpd使用其他模块和指令来控制访问日志记录，包括mod_log_referer，mod_log_agent和<code>TransferLog</code>指示。的<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>指令现在包含所有较旧指令的功能。</p>

    <p>访问日志的格式是高度可配置的。使用看起来像C样式printf（1）格式字符串的格式字符串指定格式。下一节将介绍一些示例。有关格式字符串可能内容的完整列表，请参见<code class="module"><a href="./mod/mod_log_config.html">mod_log_config</a></code> <a href="mod/mod_log_config.html#formats">格式化字符串</a> 。</p>

    <h3><a name="common" id="common">通用日志格式</a></h3>
      

      <p>访问日志的典型配置如下所示。</p>

      <pre class="prettyprint lang-config">LogFormat "%h %l %u %t \"%r\" %&gt;s %b" common
CustomLog logs/access_log common</pre>


      <p>这定义了<em>昵称</em> <code>common</code>并将其与特定的日志格式字符串关联。格式字符串由百分比指令组成，每个指令均指示服务器记录特定信息。文字字符也可以放在格式字符串中，并将直接复制到日志输出中。引号字符（ <code>"</code> ）必须通过在其前面加上反斜杠来进行转义，以防止将其解释为格式字符串的末尾。格式字符串也可以包含特殊控制字符“ <code>\n</code> “换行”和“ <code>\t</code>标签。</p>

      <p>的<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>指令使用定义的<em>昵称</em>设置新的日志文件。访问日志的文件名是相对于<code class="directive"><a href="./mod/core.html#serverroot">ServerRoot</a></code>除非以斜杠开头。</p>

      <p>上面的配置将以称为通用日志格式（CLF）的格式写入日志条目。这种标准格式可以由许多不同的Web服务器生成，并可以由许多日志分析程序读取。CLF中生成的日志文件条目将如下所示：</p>

      <div class="example"><p><code>127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326</code></p></div>

      <p>下面描述了该日志条目的每个部分。</p>

      <dl>
        <dt><code>127.0.0.1</code> （ <code>%h</code> ）</dt>

        <dd>这是向服务器发出请求的客户端（远程主机）的IP地址。如果<code class="directive"><a href="./mod/core.html#hostnamelookups">HostnameLookups</a></code>被设定为<code>On</code> ，则服务器将尝试确定主机名并将其记录在IP地址的位置。但是，不建议使用此配置，因为它会大大降低服务器的速度。相反，最好使用日志后处理器，例如<code class="program"><a href="./programs/logresolve.html">logresolve</a></code>确定主机名。此处报告的IP地址不一定是用户所坐机器的地址。如果用户和服务器之间存在代理服务器，则该地址将是代理服务器的地址，而不是原始计算机的地址。</dd>

        <dt><code>-</code> （ <code>%l</code> ）</dt>

        <dd>输出中的“连字符”表示请求的信息不可用。在这种情况下，不可用的信息是客户端的RFC 1413身份，由<code>identd</code>在客户端计算机上。该信息高度不可靠，几乎不应使用，除非在受到严格控制的内部网络上使用。Apache httpd甚至不会尝试确定此信息，除非<code class="directive"><a href="./mod/mod_ident.html#identitycheck">IdentityCheck</a></code>被设定为<code>On</code> 。</dd>

        <dt><code>frank</code> （ <code>%u</code> ）</dt>

        <dd>这是由HTTP身份验证确定的请求文档的人的用户ID。通常会将相同的值提供给CGI脚本中的<code>REMOTE_USER</code>环境变量。如果请求的状态代码（请参阅下文）为401，则此值不应被信任，因为用户尚未通过身份验证。如果文档不受密码保护，则此部分将为“ <code>-</code>就像上一个一样。</dd>

        <dt><code>[10/Oct/2000:13:55:36 -0700]</code> （ <code>%t</code> ）</dt>

        <dd>收到请求的时间。格式为：<p class="indent">
            <code>[day/month/year:hour:minute:second zone]<br> day = 2*digit<br> month = 3*letter<br> year = 4*digit<br> hour = 2*digit<br> minute = 2*digit<br> second = 2*digit<br> zone = (`+' | `-') 4*digit</code>
          </p>
          <p>可以通过指定时间以其他格式显示时间<code>%{format}t</code>在日志格式字符串中，其中<code>format</code>与中<code>strftime(3)</code>从C标准库或受支持的特殊标记之一中提取。有关详细信息，请参见<code class="module"><a href="./mod/mod_log_config.html">mod_log_config</a></code> <a href="mod/mod_log_config.html#formats">格式化字符串</a> 。</p>
        </dd>

        <dt><code>"GET /apache_pb.gif HTTP/1.0"</code> （ <code>\"%r\"</code> ）</dt>

        <dd>客户端的请求行以双引号引起来。请求行包含大量有用的信息。首先，客户端使用的方法是<code>GET</code> 。二，客户要求资源<code>/apache_pb.gif</code>第三，客户端使用了协议<code>HTTP/1.0</code> 。也可以独立记录请求行的一个或多个部分。例如，格式字符串“ <code>%m %U%q %H</code> “将记录方法，路径，查询字符串和协议，结果输出与“ <code>%r</code> ”。</dd>

        <dt><code>200</code> （ <code>%>s</code> ）</dt>

        <dd>这是服务器发送回客户端的状态代码。该信息非常有价值，因为它揭示了请求是否导致成功的响应（代码以2开头），重定向（代码以3开头），客户端导致的错误（代码以4结尾）或错误。服务器（以5开头的代码）。可能的状态代码的完整列表可以在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.txt">HTTP规范</a> （RFC2616第10节）中找到。</dd>

        <dt><code>2326</code> （ <code>%b</code> ）</dt>

        <dd>最后一部分表示返回给客户端的对象的大小，不包括响应头。如果没有内容返回给客户端，则此值为“ <code>-</code> ”。记录“ <code>0</code> “对于没有内容，请使用<code>%B</code>代替。</dd>
      </dl>
    

    <h3><a name="combined" id="combined">合并日志格式</a></h3>
      

      <p>另一种常用的格式字符串称为合并日志格式。可以如下使用。</p>

      <pre class="prettyprint lang-config">LogFormat "%h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-agent}i\"" combined
CustomLog log/access_log combined</pre>


      <p>此格式与“通用日志格式”完全相同，但增加了两个字段。每个其他字段都使用百分比指令<code>%{<em>header</em>}i</code> ，其中<em>header</em>可以是任何HTTP请求标头。这种格式的访问日志如下所示：</p>

      <div class="example"><p><code>127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326 "http://www.example.com/start.html" "Mozilla/4.08 [en] (Win98; I ;Nav)"</code></p></div>

      <p>其他字段是：</p>

      <dl>
        <dt><code>"http://www.example.com/start.html"</code> （ <code>\"%{Referer}i\"</code> ）</dt>

        <dd>“引用”（原文如此）HTTP请求标头。这提供了客户端报告已被引用的站点。（这应该是链接到或包含该页面的页面<code>/apache_pb.gif</code> ）。</dd>

        <dt><code>"Mozilla/4.08 [en] (Win98; I ;Nav)"</code> （ <code>\"%{User-agent}i\"</code> ）</dt>

        <dd>用户代理HTTP请求标头。这是客户端浏览器报告的有关其自身的标识信息。</dd>
      </dl>
    

    <h3><a name="multiple" id="multiple">多路访问日志</a></h3>
      

      <p>只需指定多个即可创建多个访问日志<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>配置文件中的指令。例如，以下指令将创建三个访问日志。第一个包含基本CLF信息，第二个和第三个包含引用程序和浏览器信息。最后两个<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>线条显示了如何模仿<code>ReferLog</code>和<code>AgentLog</code>指令。</p>

      <pre class="prettyprint lang-config">LogFormat "%h %l %u %t \"%r\" %&gt;s %b" common
CustomLog logs/access_log common
CustomLog logs/referer_log "%{Referer}i -&gt; %U"
CustomLog logs/agent_log "%{User-agent}i"</pre>


      <p>此示例还表明，不必使用来定义昵称。 <code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code>指示。相反，可以直接在<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>指示。</p>
    

    <h3><a name="conditional" id="conditional">条件日志</a></h3>
      

      <p>有时根据客户端请求的特征方便地从访问日志中排除某些条目。在<a href="env.html">环境变量</a>的帮助下，这很容易实现。首先，必须设置环境变量以指示请求满足某些条件。这通常可以通过<code class="directive"><a href="./mod/mod_setenvif.html#setenvif">SetEnvIf</a></code> 。然后<code>env=</code>的条款<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>伪指令用于包含或排除设置了环境变量的请求。一些例子：</p>

      <pre class="prettyprint lang-config"># Mark requests from the loop-back interface
SetEnvIf Remote_Addr "127\.0\.0\.1" dontlog
# Mark requests for the robots.txt file
SetEnvIf Request_URI "^/robots\.txt$" dontlog
# Log what remains
CustomLog logs/access_log common env=!dontlog</pre>


      <p>再举一个例子，考虑将来自说英语的人的请求记录到一个日志文件，而将不讲英语的人的请求记录到另一个日志文件。</p>

      <pre class="prettyprint lang-config">SetEnvIf Accept-Language "en" english
CustomLog logs/english_log common env=english
CustomLog logs/non_english_log common env=!english</pre>


      <p>在缓存方案中，您可能想知道缓存的效率。一个很简单的发现方法是：</p>

      <pre class="prettyprint lang-config">SetEnv CACHE_MISS 1
LogFormat "%h %l %u %t "%r " %&gt;s %b %{CACHE_MISS}e" common-cache
CustomLog logs/access_log common-cache</pre>


      <p><code class="module"><a href="./mod/mod_cache.html">mod_cache</a></code>将在之前运行<code class="module"><a href="./mod/mod_env.html">mod_env</a></code>并且，如果成功，则将交付没有内容的内容。在这种情况下，缓存命中将记录<code>-</code> ，而缓存未命中将记录日志<code>1</code> 。</p>

      <p>除了<code>env=</code>句法， <code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code>支持以HTTP响应代码为条件的日志记录值：</p>

      <pre class="prettyprint lang-config">LogFormat "%400,501{User-agent}i" browserlog
LogFormat "%!200,304,302{Referer}i" refererlog</pre>


      <p>在第一个示例中， <code>User-agent</code>如果HTTP状态代码为400或501，则将记录日志。在其他情况下，将改为记录文字“-”。同样，在第二个示例中， <code>Referer</code>如果HTTP状态代码<strong>不是</strong> 200、204或302，将记录日志。（请注意“！”之前的状态代码。</p>

      <p>尽管我们刚刚显示了条件日志记录非常强大和灵活，但它不是控制日志内容的唯一方法。日志文件包含服务器活动的完整记录时，它们将更为有用。通常，简单地对日志文件进行后处理以删除您不想考虑的请求通常会更容易。</p>
    
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="rotation" id="rotation">日志旋转</a></h2>
    

    <p>即使在繁忙的服务器上，日志文件中存储的信息量也很大。访问日志文件通常每10,000个请求增长1 MB或更多。因此，有必要通过移动或删除现有日志来定期轮换日志文件。服务器运行时无法完成此操作，因为只要Apache httpd保持打开状态，它将继续写入旧日志文件。而是，在移动或删除日志文件后必须<a href="stopping.html">重新启动</a>服务器，以便它将打开新的日志文件。</p>

    <p>通过使用<em>正常</em>重启，可以指示服务器打开新的日志文件，而不会丢失来自客户端的任何现有连接或挂起的连接。但是，为了完成此操作，服务器必须在完成服务于旧请求的同时继续写入旧日志文件。因此，必须在重新启动后等待一段时间，然后再对日志文件进行任何处理。简单地旋转日志并压缩旧日志以节省空间的典型方案是：</p>

    <div class="example"><p><code>mv access_log access_log.old<br> mv error_log error_log.old<br> apachectl graceful<br> sleep 600<br> gzip access_log.old error_log.old</code></p></div>

    <p>执行日志轮换的另一种方法是使用<a href="#piped">管道日志，</a>如下一节所述。</p>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="piped" id="piped">管道日志</a></h2>
    

    <p>Apache httpd能够写入错误，并通过管道将日志文件访问另一个进程，而不是直接访问文件。此功能极大地增加了日志记录的灵活性，而无需在主服务器中添加代码。要将日志写入管道，只需将文件名替换为管道字符“ <code>|</code> ”，后跟可执行文件的名称，该可执行文件应在其标准输入上接受日志条目。服务器启动时，服务器将启动管道日志进程，如果在服务器运行时崩溃，则将重新启动管道日志进程。（这最后一个功能是为什么我们可以将此技术称为“可靠的管道记录”。）</p>

    <p>父Apache httpd进程产生了管道日志进程，并继承了该进程的用户ID。这意味着管道日志程序通常以root身份运行。因此，使程序保持简单和安全非常重要。</p>

    <p>管道日志的一项重要用途是无需重新启动服务器即可允许日志轮换。Apache HTTP Server包含一个简单的程序，称为<code class="program"><a href="./programs/rotatelogs.html">rotatelogs</a></code>以此目的。例如，要每24小时轮换一次日志，可以使用：</p>

    <pre class="prettyprint lang-config">CustomLog "|/usr/local/apache/bin/rotatelogs /var/log/access_log 86400" common</pre>


    <p>注意，引号用于包围将为管道调用的整个命令。尽管这些示例用于访问日志，但是可以将相同的技术用于错误日志。</p>

    <p>与条件日志记录一样，管道日志记录是一个非常强大的工具，但是在可以使用脱机后处理等更简单的解决方案的地方，不应使用它们。</p>

    <p>默认情况下，在不调用shell的情况下产生了管道日志进程。使用 ” <code>|$</code> “ 代替 ” <code>|</code>使用外壳程序生成（通常使用<code>/bin/sh -c</code> ）：</p>

    <pre class="prettyprint lang-config"># Invoke "rotatelogs" using a shell
CustomLog "|$/usr/local/apache/bin/rotatelogs   /var/log/access_log 86400" common</pre>


    <p>这是Apache 2.2的默认行为。根据外壳的具体情况，这可能会导致在日志记录管道程序的整个生命期内进行额外的外壳过程，并在重新启动期间出现信号处理问题。出于与Apache 2.2兼容的考虑，“ <code>||</code>也支持“”，等效于使用“ <code>|</code> ”。</p>

    <div class="note"><h3>Windows笔记</h3>
    <p>请注意，在Windows上，运行许多管道记录器进程时可能会遇到问题，尤其是当HTTPD作为服务运行时。这是由于桌面堆空间不足而引起的。分配给每个服务的桌面堆空间是由<code>SharedSection</code> HKEY_LOCAL_MACHINE \ System \ CurrentControlSet \ Control \ SessionManager \ SubSystems \ Windows注册表值中的参数。<strong>小心改变这个值</strong> ;更改Windows注册表的一般注意事项适用，但是如果将数字调整得太高，您也可能会耗尽桌面堆池。</p>
    </div>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="virtualhost" id="virtualhost">虚拟主机</a></h2>
    

    <p>当运行具有许多<a href="vhosts/index.html">虚拟主机</a>的服务器时，有几种处理日志文件的选项。首先，可以完全像在单主机服务器中那样使用日志。只需将日志记录指令放在<code class="directive"><a href="./mod/core.html#virtualhost"><VirtualHost></a></code>在主服务器上下文中的“节”中，可以将所有请求记录在同一访问日志和错误日志中。此技术无法轻松收集各个虚拟主机上的统计信息。</p>

    <p>如果<code class="directive"><a href="./mod/mod_log_config.html#customlog">CustomLog</a></code>要么<code class="directive"><a href="./mod/core.html#errorlog">ErrorLog</a></code>指令放置在<code class="directive"><a href="./mod/core.html#virtualhost"><VirtualHost></a></code>部分中，对该虚拟主机的所有请求或错误将仅记录到指定文件中。任何没有日志记录指令的虚拟主机仍会将其请求发送到主服务器日志。该技术对于少量虚拟主机非常有用，但是如果主机数量很大，则管理起来可能会很复杂。另外，它经常会产生<a href="vhosts/fd-limits.html">文件描述符不足的</a>问题。</p>

    <p>对于访问日志，有一个很好的折衷方案。通过将虚拟主机上的信息添加到日志格式字符串中，可以将所有主机记录到同一日志中，然后将日志拆分为单个文件。例如，考虑以下指令。</p>

    <pre class="prettyprint lang-config">LogFormat "%v %l %u %t \"%r\" %&gt;s %b" comonvhost
CustomLog logs/access_log comonvhost</pre>


    <p>的<code>%v</code>用于记录正在处理请求的虚拟主机的名称。然后，可以使用诸如<a href="programs/split-logfile.html">split-logfile之</a>类的程序对访问日志进行后处理，以便将其分为每个虚拟主机一个文件。</p>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="other" id="other">其他日志文件</a></h2>
    

    <table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_logio.html">mod_logio</a></code></li><li><code class="module"><a href="./mod/mod_log_config.html">mod_log_config</a></code></li><li><code class="module"><a href="./mod/mod_log_forensic.html">mod_log_forensic</a></code></li><li><code class="module"><a href="./mod/mod_cgi.html">mod_cgi</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code></li><li><code class="directive"><a href="./mod/mod_log_config.html#bufferedlogs">BufferedLogs</a></code></li><li><code class="directive"><a href="./mod/mod_log_forensic.html#forensiclog">ForensicLog</a></code></li><li><code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code></li><li><code class="directive"><a href="./mod/mod_cgi.html#scriptlog">ScriptLog</a></code></li><li><code class="directive"><a href="./mod/mod_cgi.html#scriptlogbuffer">ScriptLogBuffer</a></code></li><li><code class="directive"><a href="./mod/mod_cgi.html#scriptloglength">ScriptLogLength</a></code></li></ul></td></tr></tbody></table>

    <h3>记录发送和接收的实际字节</h3>
      

      <p><code class="module"><a href="./mod/mod_logio.html">mod_logio</a></code>增加了两个<code class="directive"><a href="./mod/mod_log_config.html#logformat">LogFormat</a></code>字段（％I和％O）记录在网络上接收和发送的实际字节数。</p>
    

    <h3>法医记录</h3>
      

      <p><code class="module"><a href="./mod/mod_log_forensic.html">mod_log_forensic</a></code>提供客户请求的取证日志。记录是在处理请求之前和之后完成的，因此，取证日志包含每个请求的两条日志行。取证记录器非常严格，没有自定义设置。它可能是非常宝贵的调试和安全工具。</p>
    

    <h3><a name="pidfile" id="pidfile">PID文件</a></h3>
      

      <p>启动时，Apache httpd将父httpd进程的进程ID保存到文件中<code>logs/httpd.pid</code> 。可以使用<code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>指示。进程ID供管理员用于通过向父进程发送信号来重新启动和终止守护程序。在Windows上，请改用-k命令行选项。有关更多信息，请参见“ <a href="stopping.html">停止和重新启动”</a>页面。</p>
    

    <h3><a name="scriptlog" id="scriptlog">脚本日志</a></h3>
      

      <p>为了帮助调试， <code class="directive"><a href="./mod/mod_cgi.html#scriptlog">ScriptLog</a></code>指令允许您记录CGI脚本的输入和输出。仅应将其用于测试中，而不应用于实时服务器。有关更多信息，请参见<a href="mod/mod_cgi.html">mod_cgi</a>文档。</p>
    

  </div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>