<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_authnz_fcgi-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_authnz_fcgi</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td>允许FastCGI授权者应用程序处理Apache httpd身份验证和授权</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块�标识符：</a></th><td>authnz_fcgi_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_authnz_fcgi.c</td></tr>
<tr><th><a href="module-dict.html#Compatibility">兼容性：</a></th><td>在版本2.4.10和更高版本中可用</td></tr></table>
<h3>摘要</h3>

    <p>此模块允许FastCGI授权者应用程序对用户进行身份验证并授权对资源的访问。它支持参与单个阶段的身份验证和授权的通用FastCGI授权者，以及参与一个或两个阶段的Apache httpd特定的认证者和授权者。</p>

    <p>FastCGI授权者可以使用用户ID和密码进行身份验证，例如用于基本身份验证，或者可以使用任意机制进行身份验证。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#invocations">调用方式</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#examples">其他例子</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#limitations">局限性</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#logging">记录中</a></li>
</ul><h3 class="directives">指令</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif"> <a href="#authnzfcgicheckauthnprovider">AuthnzFcgiCheckAuthnProvider</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#authnzfcgidefineprovider">AuthnzFcgiDefineProvider</a></li>
</ul>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_authnz_fcgi">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_authnz_fcgi">报告错误</a></li></ul><h3>也可以看看</h3>
<ul class="seealso">
<li><a href="../howto/auth.html">身份验证，授权和访问控制</a></li>
<li><code class="module"><a href="../mod/mod_auth_basic.html">mod_auth_basic</a></code></li>
<li><code class="program"><a href="../programs/fcgistarter.html">fcgistarter</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a></code></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="invocations" id="invocations">调用方式</a></h2>

    <p>该模块支持的FastCGI授权者的调用模式通过两个特性（ <em>类型</em>和认证<em>机制）</em>来区分。</p>

    <p><em>类型</em>仅是用于身份验证的<code>authn</code> ，用于授权的<code>authz</code>或用于身份验证和授权的组合的<code>authnz</code> 。</p>

    <p>Auth <em>机制</em>是指Apache httpd配置机制和处理阶段，可以是<code>AuthBasicProvider</code> ， <code>Require</code>或<code>check_user_id</code> 。其中的前两个对应于用于参与适当处理阶段的指令。</p>

    <p>每种模式的说明：</p>

    <dl>
      <dt><em>键入</em> <code>authn</code> ， <em>机制</em> <code>AuthBasicProvider</code></dt>

      <dd>在这种模式下， <code>FCGI_ROLE</code>设置为<code>AUTHORIZER</code> ， <code>FCGI_APACHE_ROLE</code>设置为<code>AUTHENTICATOR</code> 。应用程序必须被定义为使用提供程序类型<em>authn</em> <code class="directive"><a href="#authnzfcgidefineprovider">AuthnzFcgiDefineProvider</a></code>并启用<code class="directive"><a href="../mod/mod_auth_basic.html#authbasicprovider">AuthBasicProvider</a></code> 。调用时，应用程序应使用提供的用户ID和密码对客户端进行身份验证。示例应用程序：<pre class="prettyprint lang-perl">#!/usr/bin/perl
use FCGI;
my $request = FCGI::Request();
while ($request-&gt;Accept() &gt;= 0) {
    die if $ENV{'FCGI_APACHE_ROLE'} ne "AUTHENTICATOR";
    die if $ENV{'FCGI_ROLE'}        ne "AUTHORIZER";
    die if !$ENV{'REMOTE_PASSWD'};
    die if !$ENV{'REMOTE_USER'};

    print STDERR "This text is written to the web server error log.\n";

    if ( ($ENV{'REMOTE_USER' } eq "foo" || $ENV{'REMOTE_USER'} eq "foo1") &amp;&amp;
        $ENV{'REMOTE_PASSWD'} eq "bar" ) {
        print "Status: 200\n";
        print "Variable-AUTHN_1: authn_01\n";
        print "Variable-AUTHN_2: authn_02\n";
        print "\n";
    }
    else {
        print "Status: 401\n\n";
    }
}</pre>配置示例：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authn FooAuthn fcgi://localhost:10102/
&lt;Location "/protected/"&gt;
  AuthType Basic
  AuthName "Restricted"
  AuthBasicProvider FooAuthn
  Require ...
&lt;/Location&gt;</pre>

      </dd>

      <dt><em>输入</em> <code>authz</code> ， <em>机制</em> <code>Require</code></dt>
      <dd>在这种模式下， <code>FCGI_ROLE</code>设置为<code>AUTHORIZER</code> ， <code>FCGI_APACHE_ROLE</code>设置为<code>AUTHORIZER</code> 。必须使用<code class="directive"><a href="#authnzfcgidefineprovider">AuthnzFcgiDefineProvider</a></code>将应用程序定义为提供程序类型<em>authz</em> 。调用时，应用程序应使用提供的用户ID和其他请求数据来授权客户端。示例应用程序：<pre class="prettyprint lang-perl">#!/usr/bin/perl
use FCGI;
my $request = FCGI::Request();
while ($request-&gt;Accept() &gt;= 0) {
    die if $ENV{'FCGI_APACHE_ROLE'} ne "AUTHORIZER";
    die if $ENV{'FCGI_ROLE'}        ne "AUTHORIZER";
    die if $ENV{'REMOTE_PASSWD'};

    print STDERR "This text is written to the web server error log.\n";

    if ($ENV{'REMOTE_USER'} eq "foo1") {
        print "Status: 200\n";
        print "Variable-AUTHZ_1: authz_01\n";
        print "Variable-AUTHZ_2: authz_02\n";
        print "\n";
    }
    else {
        print "Status: 403\n\n";
    }
}</pre>配置示例：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authz FooAuthz fcgi://localhost:10103/
&lt;Location "/protected/"&gt;
  AuthType ...
  AuthName ...
  AuthBasicProvider ...
  Require FooAuthz
&lt;/Location&gt;</pre>

      </dd>

      <dt><em>键入</em> <code>authnz</code> ， <em>机制</em> <code>AuthBasicProvider</code> <em>+</em> <code>Require</code></dt>

      <dd>在此模式下，该模式支持与Web服务器无关的FastCGI <code>AUTHORIZER</code>协议， <code>FCGI_ROLE</code>设置为<code>AUTHORIZER</code>而<code>FCGI_APACHE_ROLE</code>未设置。应用程序必须使用被定义为提供者类型<em>authnz</em> <code class="directive"><a href="#authnzfcgidefineprovider">AuthnzFcgiDefineProvider</a></code> 。该应用程序应使用用户ID，密码和其他请求数据在同一调用中处理身份验证和授权。调用发生在Apache httpd API身份验证阶段。如果应用程序返回200，并且在授权阶段（通过<code class="directive">Require</code> ）调用了相同的提供程序，则mod_authnz_fcgi将在授权阶段成功返回而不调用应用程序。示例应用程序：<pre class="prettyprint lang-perl">#!/usr/bin/perl
use FCGI;
my $request = FCGI::Request();
while ($request-&gt;Accept() &gt;= 0) {
    die if $ENV{'FCGI_APACHE_ROLE'};
    die if $ENV{'FCGI_ROLE'} ne "AUTHORIZER";
    die if !$ENV{'REMOTE_PASSWD'};
    die if !$ENV{'REMOTE_USER'};

    print STDERR "This text is written to the web server error log.\n";

    if ( ($ENV{'REMOTE_USER' } eq "foo" || $ENV{'REMOTE_USER'} eq "foo1") &amp;&amp;
        $ENV{'REMOTE_PASSWD'} eq "bar" &amp;&amp;
        $ENV{'REQUEST_URI'} =~ m%/bar/.*%) {
        print "Status: 200\n";
        print "Variable-AUTHNZ_1: authnz_01\n";
        print "Variable-AUTHNZ_2: authnz_02\n";
        print "\n";
    }
    else {
        print "Status: 401\n\n";
    }
}</pre>配置示例：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authnz FooAuthnz fcgi://localhost:10103/
&lt;Location "/protected/"&gt;
  AuthType Basic
  AuthName "Restricted"
  AuthBasicProvider FooAuthnz
  Require FooAuthnz
&lt;/Location&gt;</pre>

      </dd>

      <dt><em>输入</em> <code>authn</code> ， <em>机制</em> <code>check_user_id</code></dt>

      <dd>在这种模式下， <code>FCGI_ROLE</code>设置为<code>AUTHORIZER</code> ， <code>FCGI_APACHE_ROLE</code>设置为<code>AUTHENTICATOR</code> 。必须使用<code class="directive"><a href="#authnzfcgidefineprovider">AuthnzFcgiDefineProvider</a></code>将应用程序定义为提供程序类型<em>authn</em> 。<code class="directive"><a href="#authnzfcgicheckauthnprovider">AuthnzFcgiCheckAuthnProvider</a></code>指定何时调用。示例应用程序：<pre class="prettyprint lang-perl">#!/usr/bin/perl
use FCGI;
my $request = FCGI::Request();
while ($request-&gt;Accept() &gt;= 0) {
    die if $ENV{'FCGI_APACHE_ROLE'} ne "AUTHENTICATOR";
    die if $ENV{'FCGI_ROLE'} ne "AUTHORIZER";

    # This authorizer assumes that the RequireBasicAuth option of 
    # AuthnzFcgiCheckAuthnProvider is On:
    die if !$ENV{'REMOTE_PASSWD'};
    die if !$ENV{'REMOTE_USER'};

    print STDERR "This text is written to the web server error log.\n";

    if ( ($ENV{'REMOTE_USER' } eq "foo" || $ENV{'REMOTE_USER'} eq "foo1") &amp;&amp;
        $ENV{'REMOTE_PASSWD'} eq "bar" ) {
        print "Status: 200\n";
        print "Variable-AUTHNZ_1: authnz_01\n";
        print "Variable-AUTHNZ_2: authnz_02\n";
        print "\n";
    }
    else {
        print "Status: 401\n\n";
        # If a response body is written here, it will be returned to
        # the client.
    }
}</pre>配置示例：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authn FooAuthn fcgi://localhost:10103/
&lt;Location "/protected/"&gt;
  AuthType ...
  AuthName ...
  AuthnzFcgiCheckAuthnProvider FooAuthn \
                               Authoritative On \
                               RequireBasicAuth Off \
                               UserExpr "%{reqenv:REMOTE_USER}"
  Require ...
&lt;/Location&gt;</pre>

      </dd>

    </dl>
    
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="examples" id="examples">其他例子</a></h2>

  <ol>
    <li>如果您的应用程序支持单独的身份验证和授权角色（ <code>AUTHENTICATOR</code>和<code>AUTHORIZER</code> ）， <code>AUTHORIZER</code>以下方式定义单独的提供程序，即使它们映射到同一应用程序也是如此：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authn  FooAuthn  fcgi://localhost:10102/
AuthnzFcgiDefineProvider authz  FooAuthz  fcgi://localhost:10102/</pre>在<code class="directive"><a href="../mod/mod_auth_basic.html#authbasicprovider">AuthBasicProvider</a></code>上指定authn提供程序，在<code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code>上指定authz提供程序：<pre class="prettyprint lang-config">AuthType Basic
AuthName "Restricted"
AuthBasicProvider FooAuthn
Require FooAuthz</pre>

    </li>

    <li>如果您的应用程序支持通用<code>AUTHORIZER</code>角色（一次调用中的身份验证和授权者），则按以下方式定义一个提供程序：<pre class="prettyprint lang-config">AuthnzFcgiDefineProvider authnz FooAuthnz fcgi://localhost:10103/</pre>在<code class="directive">AuthBasicProvider</code>和<code class="directive">Require</code>上同时指定authnz提供者：<pre class="prettyprint lang-config">AuthType Basic
AuthName "Restricted"
AuthBasicProvider FooAuthnz
Require FooAuthnz</pre>

    </li>
</ol>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="limitations" id="limitations">局限性</a></h2>

    <p>以下是当前尚未实现的潜在功能：</p>

    <dl>
      <dt>Apache httpd访问检查器</dt>
      <dd>Apache httpd API <em>访问检查</em>阶段是与身份验证和授权分开的阶段。其他一些FastCGI实现也实现了此阶段，这由将<code>FCGI_APACHE_ROLE</code>设置为<code>FCGI_APACHE_ROLE</code>来<code>ACCESS_CHECKER</code> 。</dd>

      <dt>本地（Unix）套接字或管道</dt>
      <dd>当前仅支持TCP套接字。</dd>

      <dt>支持mod_authn_socache</dt>
      <dd>应该为参与Apache httpd样式认证的应用程序实现mod_authn_socache交互。</dd>

      <dt>支持使用AuthDigestProvider进行摘要身份验证</dt>
      <dd>预计这将是一个永久性的限制，因为没有用于检索哈希的授权者流程。</dd>

      <dt>应用程序管理</dt>
      <dd>预期这将永久超出此模块的范围。申请过程必须通过其他方式控制。例如，可以使用<code class="program"><a href="../programs/fcgistarter.html">fcgistarter</a></code>启动它们。</dd>

      <dt>AP_AUTH_INTERNAL_PER_URI</dt>
      <dd>当前，所有提供程序都已注册为AP_AUTH_INTERNAL_PER_CONF，这意味着不会再次对具有与初始请求相同的访问控制配置的内部子请求进行检查。</dd>

      <dt>协议数据字符集转换</dt>
      <dd>如果mod_authnz_fcgi在EBCDIC编译环境中运行，则所有FastCGI协议数据都将写入EBCDIC中，并有望在EBCDIC中接收。</dd>

      <dt>每个连接多个请求</dt>
      <dd>当前，在处理的每个阶段之后都关闭与FastCGI授权者的连接。例如，如果授权者处理单独的<em>authn</em>和<em>authz</em>阶段，则将使用两个连接。</dd>

      <dt>URI映射</dt>
      <dd>无法映射来自客户端的URI，例如与FastCGI响应器一起使用的<code class="directive">ProxyPass</code> 。</dd>

    </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="logging" id="logging">记录中</a></h2>

    <ol>
        <li>处理错误记录在日志级别<code>error</code>或更高级别。</li>
        <li>由应用程序编写的消息以<code>warn</code>级别记录。</li>
        <li>用于调试的常规消息记录在日志级别的<code>debug</code> 。</li>
        <li>传递给应用程序的环境变量记录在日志级别<code>trace2</code> 。<code>REMOTE_PASSWD</code>变量的值将被遮盖，但是<strong>任何其他敏感数据将在log中可见</strong> 。</li>
        <li>模块和FastCGI应用程序之间的所有I / O（包括所有环境变量）都将以可打印和十六进制格式记录在日志级别<code>trace5</code> 。<strong>所有敏感数据将在日志中可见。</strong></li>
    </ol>

    <p><code class="directive"><a href="../mod/core.html#loglevel">LogLevel</a></code>可用于配置特定于mod_authnz_fcgi的日志级别。例如：</p>

<pre class="prettyprint lang-config">LogLevel info authnz_fcgi:trace8</pre>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="AuthnzFcgiCheckAuthnProvider" id="AuthnzFcgiCheckAuthnProvider">AuthnzFcgiCheckAuthnProvider</a> <a name="authnzfcgicheckauthnprovider" id="authnzfcgicheckauthnprovider">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>使FastCGI应用程序能够处理check_authn身份验证挂钩。</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>AuthnzFcgiCheckAuthnProvider <em>提供程序名称</em> | <code>None</code> <em>选择</em> ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>没有</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_authnz_fcgi</td></tr>
</table>
    <p>此伪指令用于使FastCGI授权者处理认证或授权的特定处理阶段。</p>

    <p>FastCGI授权者的某些功能需要使用此指令而不是<code class="directive">AuthBasicProvider</code>来<code class="directive">AuthBasicProvider</code> ：</p>

    <ul>
      <li>非基本认证；通常，确定客户端的用户ID并从授权者处返回。请参阅下面的<code>UserExpr</code>选项</li>
      <li>选择自定义响应代码；对于来自授权者的非200响应，来自授权者的代码将是响应的状态</li>
      <li>设置非200响应的正文；如果授权者为响应正文提供非200的响应，则该正文将返回给客户端；最多支持8192字节的文本</li>
    </ul>

    <dl>
      <dt><em>提供者名称</em></dt>
      <dd>这是使用<code class="directive">AuthnzFcgiDefineProvider</code>定义的提供程序的名称。</dd>

      <dt><code>没有</code></dt>
      <dd>指定<code>None</code>以在外部范围（例如，父目录）中禁用使用此伪指令启用的提供程序。</dd>

      <dt><em>选项</em></dt>
      <dd>支持以下选项：<dl>
         <dt>权威性On | Off（默认为On）</dt>
         <dd>这控制了当该模块配置了FastCGI授权器并且使请求失败时，是否允许其他模块运行。</dd>

         <dt>DefaultUser <em>用户ID</em></dt>
         <dd>当授权者返回成功并且<code>UserExpr</code>被配置并计算为空字符串（例如，授权者未返回变量）时，该值将用作用户ID。当授权者具有来宾或未经身份验证的概念时，通常使用此方法，并且来宾用户和来宾用户被映射到某个特定的用户ID以进行日志记录和其他用途。</dd>

         <dt>RequireBasicAuth On | Off（默认为Off）</dt>
         <dd>这控制在将请求传递给授权者之前是否需要基本身份验证。如果需要，将在没有用户标识和密码的情况下调用授权者。如果没有该请求，将返回401。</dd>

         <dt>UserExpr <em>expr</em> （无默认值）</dt>
         <dd>如果客户端不提供基本身份验证，并且授权者确定用户，则在调用授权者后评估的该表达式将确定用户。该表达式遵循<a href="../expr.html">ap_expr语法，</a>并且必须解析为字符串。典型的用法是使用诸如<code>UserExpr "%{reqenv: <em>XXX</em> }"</code>类的选项来引用授权者返回的<code>Variable- <em>XXX</em></code>设置。如果指定了此选项，并且成功通过身份验证后无法使用表达式检索用户ID，则该请求将被拒绝，并显示500错误。</dd>

       </dl>
      </dd>
     </dl>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="AuthnzFcgiDefineProvider" id="AuthnzFcgiDefineProvider">AuthnzFcgiDefineProvider</a> <a name="authnzfcgidefineprovider" id="authnzfcgidefineprovider">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将FastCGI应用程序定义为身份验证和/或授权的提供者</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>AuthnzFcgiDefineProvider <em>类型</em> <em>提供程序名称</em> <em>后端地址</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>没有</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_authnz_fcgi</td></tr>
</table>
    <p>该指令用于将FastCGI应用程序定义为特定阶段的身份验证或授权的提供程序。</p>

    <dl>
      <dt><em>类型</em></dt>
      <dd>必须将其设置为<em>authn</em>进行身份验证，将<em>authz</em>进行授权，或将<em>authnz设置</em>为执行两种检查的通用FastCGI授权方。</dd>

      <dt><em>提供者名称</em></dt>
      <dd>这用于为提供程序分配名称，该名称用于其他指令中，例如<code class="directive"><a href="../mod/mod_auth_basic.html#authbasicprovider">AuthBasicProvider</a></code>和<code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code> 。</dd>

      <dt><em>后端地址</em></dt>
      <dd>它以<em>fcgi：// hostname：port /</em>的形式指定应用程序的地址。应用程序进程必须独立管理，例如使用<code class="program"><a href="../programs/fcgistarter.html">fcgistarter</a></code> 。</dd>
    </dl>

</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>