<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_rewrite-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_rewrite</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td>提供基于规则的重写引擎来即时重写请求的URL</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块标识符：</a></th><td>rewrite_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_rewrite.c</td></tr></table>
<h3>摘要</h3>

	<p><code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>模块使用基于规则的重写引擎（基于PCRE正则表达式解析器）即时重写请求的URL。默认情况下， <code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>将URL映射到文件系统路径。但是，它也可以用于将一个URL重定向到另一个URL，或调用内部代理获取。</p>
      <p><code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>提供了一种灵活而强大的方法，可以使用无限数量的规则来操作URL。每个规则可以具有无限数量的附加规则条件，以允许您基于服务器变量，环境变量，HTTP标头或时间戳重写URL。</p>
      <p><code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>在完整的URL路径（包括path-info部分）上运行。可以在<code>httpd.conf</code>或<code>.htaccess</code>调用重写规则。重写规则生成的路径可以包含查询字符串，或者可以导致内部子处理，外部请求重定向或内部代理吞吐量。</p>

      <p><a href="../rewrite/index.html">详细的mod_rewrite文档</a>中提供了更多详细信息，讨论和示例。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#logging">记录中</a></li>
</ul><h3 class="directives">指令</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif"> <a href="#rewritebase">RewriteBase</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewritecond">RewriteCond</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewriteengine">重写引擎</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewritemap">重写地图</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewriteoptions">RewriteOptions</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewriterule">重写规则</a></li>
</ul>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_rewrite">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_rewrite">报告错误</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="logging" id="logging">记录中</a></h2>

    <p><code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>在<code>trace1</code>到<code>trace8</code> 。可以使用<code class="directive"><a href="../mod/core.html#loglevel">LogLevel</a></code>指令专门为<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>设置日志级别：直到<code>debug</code>级别，都不会记录任何操作，而<code>trace8</code>表示实际上已记录了所有操作。</p>

    <div class="note">对<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>使用高跟踪日志级别将大大降低Apache HTTP Server的速度！使用比<code>trace2</code>高的日志级别仅用于调试！
    </div>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">LogLevel alert rewrite:trace3</pre>
</div>

    <div class="note"><h3>重写日志</h3>
      <p>那些熟悉<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>早期版本的人无疑会在寻找<code>RewriteLog</code>和<code>RewriteLogLevel</code>指令。上面提到的新的每模块日志记录配置已完全取代了此功能。
      </p>

      <p>要仅获取特定于<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>日志消息，请通过grep传递日志文件：</p>
    <div class="example"><p><code>tail -f error_log | fgrep'[重写：'</code></p></div>
    </div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteBase" id="RewriteBase">RewriteBase</a> <a name="rewritebase" id="rewritebase">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>设置每个目录重写的基本URL</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteBase <em>URL路径</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>没有</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>目录.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>文件信息</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>
      <p><code class="directive">RewriteBase</code>伪指令指定用于替换相对路径的每个目录（htaccess） <code class="directive"><a href="#rewriterule">RewriteRule</a></code>伪指令所使用的URL前缀。</p>
      <p>在每个目录（htaccess）上下文中的替换中使用相对路径时，除非满足以下任一条件，否则此指令是<em>必需的</em> ：</p>
      <ul>
          <li>原始请求和替代请求位于<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code> （与其他方法（例如<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code> ）可访问的对象） <code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code> 。</li>
          <li>包含<code class="directive"><a href="#rewriterule">RewriteRule</a></code>的目录的<em>文件系统</em>路径（相对替换后缀）也有效作为服务器上的URL路径（这种情况很少见）。</li>
          <li>在Apache HTTP Server 2.4.16和更高版本中，当通过<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code>或<code class="module"><a href="../mod/mod_userdir.html">mod_userdir</a></code>映射请求时，可以忽略此伪指令。</li>
      </ul>

<p>在下面的示例中，由于资源不是相对于文档根目录的， <code class="directive">RewriteBase</code>必须使用<code class="directive">RewriteBase</code>以避免重写为http://example.com/opt/myapp-1.2.3/welcome.html。这种配置错误通常会导致服务器在文档根目录下查找“ opt”目录。</p>
<pre class="prettyprint lang-config">DocumentRoot "/var/www/example.com"
AliasMatch "^/myapp" "/opt/myapp-1.2.3"
&lt;Directory "/opt/myapp-1.2.3"&gt;
    RewriteEngine On
    RewriteBase "/myapp/"
    RewriteRule "^index\.html$"  "welcome.html"
&lt;/Directory&gt;</pre>



</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteCond" id="RewriteCond">RewriteCond</a> <a name="rewritecond" id="rewritecond">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>定义重写的条件</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteCond <em>TestString</em> <em>CondPattern</em> [ <em>标志</em> ]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>文件信息</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>
      <p><code class="directive">RewriteCond</code>指令定义规则条件。一个或多个<code class="directive">RewriteCond</code>可以位于<code class="directive"><a href="#rewriterule">RewriteRule</a></code>指令之前。然后，仅当URI的当前状态都与它的模式匹配<strong>并且</strong>满足这些条件时，才使用以下规则。</p>

      <p><em>TestString</em>是一个字符串，除了纯文本之外， <em>它还</em>可以包含以下扩展结构：</p>

      <ul>
        <li>
          <strong>RewriteRule反向引用</strong> ：这些是<strong><code>$N</code></strong>形式的反向引用（0 &lt;= N &lt;= 9）。 $ 1到$ 9可从<code>RewriteRule</code>访问模式的分组部分（在括号中），该条件取决于当前的<code>RewriteCond</code>条件集。 $ 0提供对该模式匹配的整个字符串的访问。
        </li>
        <li>
          <strong>RewriteCond反向引用</strong> ：这些是<strong><code>%N</code></strong>形式的反向引用（0 &lt;= N &lt;= 9）。从％1到％9，可以从当前条件集中最后匹配的<code>RewriteCond</code>访问模式的分组部分（再次用括号括起来）。 ％0提供对该模式匹配的整个字符串的访问。
        </li>
        <li>
          <strong>RewriteMap扩展</strong> ：这些是<strong><code>${mapname:key|default}</code></strong>形式的扩展。有关更多详细信息，请参见<a href="#mapfunc">RewriteMap文档</a> 。
        </li>
        <li>
          <strong>服务器变量</strong> ：这些变量的格式为<strong><code>%{</code> <em>NAME_OF_VARIABLE</em> <code>}</code></strong> ，其中<em>NAME_OF_VARIABLE</em>可以是选自以下列表的字符串：<table>
          
            <tr>
              <th>HTTP标头：</th> <th>连接和请求：</th> <th></th>
            </tr>

            <tr>
              <td>HTTP_ACCEPT<br>HTTP_COOKIE<br>HTTP_FORWARDED<br>HTTP_HOST<br>HTTP_PROXY_CONNECTION<br>HTTP_REFERER<br>HTTP_USER_AGENT<br>
              </td>

              <td>AUTH_TYPE<br>CONN_REMOTE_ADDR<br>CONTEXT_PREFIX<br>CONTEXT_DOCUMENT_ROOT<br>IPV6<br>PATH_INFO<br>请求参数<br>REMOTE_ADDR<br>远程主机<br>REMOTE_IDENT<br>REMOTE_PORT<br>REMOTE_USER<br>REQUEST_METHOD<br>SCRIPT_FILENAME<br>
              </td>

              <td></td>
            </tr>

            <tr>
              <th>服务器内部：</th> <th>日期和时间：</th> <th>特价：</th>
            </tr>

            <tr>
              <td>DOCUMENT_ROOT<br>SCRIPT_GROUP<br>SCRIPT_USER<br>SERVER_ADDR<br>SERVER_ADMIN<br>服务器名称<br>服务器端口<br>SERVER_PROTOCOL<br>SERVER_SOFTWARE<br>
              </td>

              <td>TIME_YEAR<br>TIME_MON<br>TIME_DAY<br>TIME_HOUR<br>TIME_MIN<br>TIME_SEC<br>TIME_WDAY<br>时间<br>
              </td>

              <td>API_VERSION<br>CONN_REMOTE_ADDR<br>HTTPS<br>IS_SUBREQ<br>REMOTE_ADDR<br>REQUEST_FILENAME<br>REQUEST_SCHEME<br>REQUEST_URI<br>THE_REQUEST<br>
              </td>
            </tr>
          </table>

                <p>这些变量都对应于类似命名的HTTP MIME标头，Apache HTTP Server的C变量或Unix系统的<code>struct tm</code>字段。大多数文档<a href="../expr.html#vars">在此处</a>或《手册》或CGI规范的其他地方都有记录。</p>

                <p>SERVER_NAME和SERVER_PORT分别取决于<code class="directive"><a href="../mod/core.html#usecanonicalname">UseCanonicalName</a></code>和<code class="directive"><a href="../mod/core.html#usecanonicalphysicalport">UseCanonicalPhysicalPort</a></code>的值。</p>

                <p>mod_rewrite的特殊功能包括以下内容。</p>
                <dl>
                  <dt><code>API_VERSION</code></dt>

                  <dd>这是当前httpd构建中Apache httpd模块API（服务器和模块之间的内部接口）的版本，如include / ap_mmn.h中所定义。模块API版本与使用中的Apache httpd版本相对应（例如，在Apache httpd 1.3.14的发行版本中，它是19990320：10），但是模块作者主要感兴趣。</dd>

                  <dt><code>CONN_REMOTE_ADDR</code></dt>

                  <dd>从2.4.8开始：连接的对等IP地址（请参见<code class="module"><a href="../mod/mod_remoteip.html">mod_remoteip</a></code>模块）。</dd>

                  <dt><code>HTTPS</code></dt>

                  <dd>如果连接使用的是SSL / TLS，则将包含文本“ on”，否则将包含“ off”。（无论是否加载了<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code> ，都可以安全地使用此变量）。</dd>

                  <dt><code>IS_SUBREQ</code></dt>

                  <dd>如果当前正在处理的请求是子请求，则将包含文本“ true”，否则将包含“ false”。子请求可能由需要解析其他文件或URI才能完成其任务的模块生成。</dd>

                  <dt><code>REMOTE_ADDR</code></dt>

                  <dd>远程主机的IP地址（请参见<code class="module"><a href="../mod/mod_remoteip.html">mod_remoteip</a></code>模块）。</dd>

                  <dt><code>REQUEST_FILENAME</code></dt>

                  <dd>如果在引用<code>REQUEST_FILENAME</code>服务器已经确定了与请求匹配的文件或脚本的本地文件系统的完整路径。否则，例如在虚拟主机上下文中使用时，该值与<code>REQUEST_URI</code>相同。根据<code class="directive"><a href="../mod/core.html#acceptpathinfo">AcceptPathInfo</a></code>的值，服务器可能只使用了<code>REQUEST_URI</code>某些前导组件将请求映射到文件。
                  </dd>

                  <dt><code>REQUEST_SCHEME</code></dt>

                  <dd>将包含请求的方案（通常为“ http”或“ https”）。可以使用<code class="directive"><a href="../mod/core.html#servername">ServerName</a></code>来影响此值。</dd>

                  <dt><code>REQUEST_URI</code></dt>

                  <dd>所请求URI的路径部分，例如“ /index.html”。这特别排除了查询字符串，该查询字符串可以作为其自己的名为<code>QUERY_STRING</code>的变量使用。</dd>

                  <dt><code>THE_REQUEST</code></dt>

                  <dd>浏览器发送到服务器的完整HTTP请求行（例如“ <code>GET /index.html HTTP/1.1</code> ”）。这不包括浏览器发送的任何其他标头。与以下大多数其他变量不同，该值尚未被转义（解码）。</dd>

                </dl>
        </li>
      </ul>

      <p>如果<em>TestString</em>具有特殊值<code>expr</code> ，则<em>CondPattern</em>将被视为<a href="../expr.html">ap_expr</a> 。如果未指定<code>novary</code>标志，则表达式中引用的HTTP标头将添加到Vary标头中。</p>

      <p>您应该注意的其他事项：</p>

      <ol>
        <li>
        <p>变量SCRIPT_FILENAME和REQUEST_FILENAME包含相同的值<code>request_rec</code> HTTP Server的内部<code>request_rec</code>结构的<code>filename</code>段的值。第一个名称是众所周知的CGI变量名称，第二个名称是REQUEST_URI的对应名称（其中包含<code>request_rec</code>的<code>uri</code>字段的值）。</p>
        <p>如果发生替换并且重写继续，则两个变量的值将相应更新。</p>
        <p>如果在每个服务器的上下文中使用（ <em>即</em> ，在将请求映射到文件系统之前），则SCRIPT_FILENAME和REQUEST_FILENAME不能包含完整的本地文件系统路径，因为在此处理阶段该路径未知。在这种情况下，两个变量最初都将包含REQUEST_URI的值。为了在每个服务器上下文中获取请求的完整本地文件系统路径，请使用基于URL的超前<code>%{LA-U:REQUEST_FILENAME}</code>来确定<code>%{LA-U:REQUEST_FILENAME}</code>的最终值。</p></li>

        <li>
        <code>%{ENV:variable}</code> （其中<em>variable</em>可以是任何环境变量）。这是通过内部Apache httpd结构查找的（如果未在其中找到），可以通过Apache httpd服务器进程的<code>getenv()</code>查找。</li>

        <li>
        <code>%{SSL:variable}</code> （ <em>变量</em>是<a href="mod_ssl.html#envvars">SSL环境变量</a>的名称），无论是否加载<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>均可使用，但如果未加载，则始终扩展为空字符串。示例： <code>%{SSL:SSL_CIPHER_USEKEYSIZE}</code>可能扩展为<code>128</code> 。即使不设置<code class="directive"><a href="../mod/mod_ssl.html#ssloptions">SSLOptions</a></code>指令的<code>StdEnvVars</code>选项，这些变量也可用。</li>

        <li>
        <code>%{HTTP:header}</code> （ <em>标头</em>可以是任何HTTP MIME标头名称）始终可以用于获取HTTP请求中发送的标头的值。示例： <code>%{HTTP:Proxy-Connection}</code>是HTTP标头`` <code>Proxy-Connection:</code> ''的值。
        <p>如果在条件中使用了HTTP标头，则该标头会添加到响应的Vary标头中，以防条件对请求的评估为true。如果条件对请求的评估结果为false， <strong>则不</strong>添加该属性。为了适当地缓存，需要将HTTP标头添加到响应的Vary标头中。</p>
        <p>必须记住，在“ <strong><code>ornext|OR</code></strong> ”标志的情况下，条件遵循短路逻辑，以便根本无法评估某些条件。</p></li>

        <li>
        <a id="LA-U" name="LA-U"><code>%{LA-U:variable}</code></a>可用于执行内部（基于URL）子请求以确定<em>variable</em>最终值的<em>前瞻</em> 。这可以用于访问变量以进行重写，该变量在当前阶段尚不可用，但将在以后的阶段中进行设置。
        <p>例如，要根据重写<code>REMOTE_USER</code>从单个服务器中（中变量<code>httpd.conf</code>文件），则必须使用<code>%{LA-U:REMOTE_USER}</code> -这个变量是由授权阶段，哪来的URL转换<em>后</em>设置阶段（在mod_rewrite操作期间）。</p>
        <p>另一方面，由于mod_rewrite通过API的Fixup阶段实现了其每个目录的上下文（ <code>.htaccess</code>文件），并且由于授权阶段<em>早于</em>该阶段，因此您只能在该上下文中使用<code>%{REMOTE_USER}</code> 。</p></li>

        <li>
        <code>%{LA-F:variable}</code>可用于执行内部（基于文件名的）子请求，以确定<em>variable</em>的最终值。在大多数情况下，这与上面的LA-U相同。</li>
      </ol>

      <p><em>CondPattern</em>是条件模式，它是一个正则表达式，适用于<em>TestString</em>的当前实例。
      首先对<em>TestString</em>进行评估，然后再与<em>CondPattern</em>进行匹配。</p>

      <p><em>CondPattern</em>通常是与<em>perl兼容的正则表达式</em> ，但是还有其他语法可用于对<em>Teststring</em>执行其他有用的测试：</p>

      <ol>
        <li>您可以在模式字符串前面加上' <code>!</code>无论使用哪种<em>CondPattern</em> ，字符（感叹号）都将否定条件的结果。
        </li>

        <li>您可以执行字典字符串比较：<dl>
            <dt><strong>&lt;CondPattern</strong></dt>
            <dd>词典上的先行<br>将<em>CondPattern</em>视为纯字符串，并按字典顺序将其与<em>TestString</em>进行比较。如果<em>TestString在</em>字典上位于<em>CondPattern</em>之前，则为true。</dd>

            <dt><strong>&gt; CondPattern</strong></dt>
            <dd>按词典顺序<br>将<em>CondPattern</em>视为纯字符串，并按字典顺序将其与<em>TestString</em>进行比较。如果<em>TestString在</em>字典上遵循<em>CondPattern，</em>则为true。</dd>

            <dt><strong>= CondPattern</strong></dt>
            <dd>词典上相等<br>将<em>CondPattern</em>视为纯字符串，并按字典顺序将其与<em>TestString</em>进行比较。如果<em>TestString</em>在字典上等于<em>CondPattern</em> （两个字符串完全相同，一个字符一个字符），则为true。如果<em>CondPattern</em>为<code>""</code> （两个引号），则会将<em>TestString</em>与空字符串进行比较。</dd>

            <dt><strong>&lt;= CondPattern</strong></dt>
            <dd>从词法上小于或等于<br>将<em>CondPattern</em>视为纯字符串，并按字典顺序将其与<em>TestString</em>进行比较。如果<em>TestString在</em>字典上在<em>CondPattern</em>之前或等于<em>CondPattern</em> （两个字符串相等，一个字符一个字符），则为True。</dd>

            <dt><strong>&gt; = CondPattern</strong></dt>
            <dd>词典上大于或等于<br>将<em>CondPattern</em>视为纯字符串，并按字典顺序将其与<em>TestString</em>进行比较。如果<em>TestString在</em>字典上遵循<em>CondPattern</em>或等于<em>CondPattern</em> （两个字符串相等，一个字符一个字符），则为true。</dd>
        </dl>
        </li>

        <li>您可以执行整数比较：<dl>

            <dt><strong>-eq</strong></dt>
            <dd>在数值<strong>EQ</strong> UAL到<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果两者在数值上相等，则为true。</dd>

            <dt><strong>-ge</strong></dt>
            <dd>在数值<strong>摹</strong> reater比或<strong>电子邮件</strong>向资格赛<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果<em>TestString</em>在数值上大于或等于<em>CondPattern，</em>则为true。</dd>

            <dt><strong>-gt</strong></dt>
            <dd>在数值上<strong>摹</strong> reater <strong>牛逼</strong>汉<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果<em>TestString</em>在数值上大于<em>CondPattern，</em>则为true。</dd>

            <dt><strong>-le</strong></dt>
            <dd>在数值<strong>升</strong> ESS比或<strong>电子邮件</strong>向资格赛<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果<em>TestString</em>在数值上小于或等于<em>CondPattern，</em>则为true。通过使用<strong>-L</strong>或<strong>-h</strong>变体，避免与<strong>-l</strong>混淆。</dd>

            <dt><strong>-lt</strong></dt>
            <dd>在数值<strong>升</strong> ESS <strong>牛逼</strong>汉<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果<em>TestString</em>在数值上小于<em>CondPattern，</em>则为True。通过使用<strong>-L</strong>或<strong>-h</strong>变体，避免与<strong>-l</strong>混淆。</dd>

            <dt><strong>-ne</strong></dt>
            <dd>在数值<strong><strong>ñË</strong></strong>加时赛以资格赛<br><em>TestString</em>被视为整数，并与<em>CondPattern进行</em>数值比较。如果两者在数值上不同，则为true。这等效于<code>!-eq</code> 。</dd>

           </dl>
        </li>

        <li>您可以执行各种文件属性测试：<dl>

          <dt><strong>-d</strong></dt>

          <dd>是<strong>d</strong> 。<br>将<em>TestString</em>视为路径名，并测试它是否存在，并且是目录。
          </dd>

          <dt><strong>-F</strong></dt>

          <dd>是有规律的<strong>˚FILE。</strong><br>将<em>TestString</em>视为路径名，并测试它是否存在，并且是常规文件。
        </dd>

           <dt><strong>-F</strong></dt>

           <dd>是现有文件，通过子请求。<br>检查<em>TestString</em>是否为有效文件，可通过该路径的所有服务器当前配置的访问控件进行访问。这使用内部子请求进行检查，因此请谨慎使用-可能会影响服务器的性能！
           </dd>

            <dt><strong>-H</strong></dt>
            <dd>是符号链接，bash约定。<br>参见<strong>-l</strong> 。
            </dd>

            <dt><strong>-l</strong></dt>

            <dd>是象征性的<strong>l</strong>墨水。<br>将<em>TestString</em>视为路径名，并测试它是否存在，并且是符号链接。如果有混淆的可能，例如使用<strong>-lt</strong>或<strong>-le</strong>测试时，也可以使用<strong>-L</strong>或<strong>-h</strong>的bash约定。
            </dd>

            <dt><strong>-L</strong></dt>
            <dd>是符号链接，bash约定。<br>参见<strong>-l</strong> 。</dd>

            <dt><strong>-s</strong></dt>
            <dd>是普通文件，其中<strong>s</strong> IZE。<br>将<em>TestString</em>视为路径名并测试它是否存在，并且是大小大于零的常规文件。</dd>

            <dt><strong>-U</strong></dt>
            <dd><p>是现有的URL，通过子请求。<br>检查<em>TestString</em>是否是有效的URL，可通过该路径的所有服务器当前配置的访问控件进行访问。这使用内部子请求进行检查，因此请谨慎使用-可能会影响服务器的性能！</p>
            <p>该标志<em>仅</em>返回有关访问控制，身份验证和授权之类的信息。该标志<em>不</em>返回有关配置的处理程序（静态文件，CGI，代理等）将返回的状态代码的信息。</p> </dd>

            <dt><strong>-X</strong></dt>
            <dd>具有<strong>x</strong>可执行权限。<br>将<em>TestString</em>视为路径名，并测试它是否存在，并具有可执行权限。这些权限是根据基础操作系统确定的。</dd>

          </dl>例如：<pre class="prettyprint lang-config">RewriteCond /var/www/%{REQUEST_URI} !-f
RewriteRule ^(.+) /other/archive/$1 [R]</pre>


        </li>

        <li>
           <p>如果<em>TestString</em>具有特殊值<code>expr</code> ，则<em>CondPattern</em>将被视为<a href="../expr.html">ap_expr</a> 。</p>

           <p>在下面的示例中， <code>-strmatch</code>用于将<code>REFERER</code>与站点主机名进行比较，以阻止不需要的热链接。
           </p>

           <pre class="prettyprint lang-config">RewriteCond expr "! %{HTTP_REFERER} -strmatch '*://%{HTTP_HOST}/*'"
RewriteRule "^/images" "-" [F]</pre>

        </li>
     </ol>

     <p>您还可以通过将<strong><code>[</code> <em>标志</em> <code>]</code></strong>作为<code>RewriteCond</code>指令的第三个参数附加<strong><code>[</code></strong> <em>CondPattern</em> <strong><code>]</code></strong>来设置特殊标志，其中<em>标志</em>是以下任意<em>标志</em>的逗号分隔列表：</p>
      
      <ul>
        <li>' <strong><code>nocase|NC</code></strong> <strong>'（N</strong> <strong>摄氏度</strong> ASE）<br>这使得测试用例不敏感-在扩展的<em>TestString</em>和<em>CondPattern中</em> ，“ AZ”和“ az”之间的差异都将被忽略。该标志仅对<em>TestString</em>和<em>CondPattern</em>之间的比较有效。它对文件系统和子请求检查没有影响。</li>

        <li>' <strong><code>ornext|OR</code></strong> '（ <strong>或</strong>下一个条件）<br>使用它可以将规则条件与局部OR（而不是隐式AND）组合。典型示例：<pre class="prettyprint lang-config">RewriteCond "%{REMOTE_HOST}"  "^host1"  [OR]
RewriteCond "%{REMOTE_HOST}"  "^host2"  [OR]
RewriteCond "%{REMOTE_HOST}"  "^host3"
RewriteRule ...some special stuff for any of these hosts...</pre>没有此标志，您将必须写入条件/规则对三遍。
        </li>

        <li>' <strong><code>novary|NV</code></strong> <strong>'（N</strong> 0 <strong>伏</strong>进制）<br>如果在这种情况下使用HTTP标头，则此标志阻止将此标头添加到响应的Vary标头中。<br>如果此响应的表示形式随此标头的值而变化，则使用此标志可能会中断对响应的正确缓存。因此，仅在了解Vary标头的含义的情况下，才应使用此标志。
        </li>
      </ul>

      <p><strong>例：</strong></p>

       <p>要根据请求的`` <code>User-Agent:</code> ''标头重写站点的主页，可以使用以下命令：</p>

<pre class="prettyprint lang-config">RewriteCond  "%{HTTP_USER_AGENT}"  "(iPhone|Blackberry|Android)"
RewriteRule  "^/$"                 "/homepage.mobile.html"  [L]

RewriteRule  "^/$"                 "/homepage.std.html"     [L]</pre>


        <p>说明：如果使用将自身标识为移动浏览器的浏览器（请注意，示例不完整，因为还有许多其他移动平台），则将提供主页的移动版本。否则，将提供标准页面。
        </p>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteEngine" id="RewriteEngine">RewriteEngine</a> <a name="rewriteengine" id="rewriteengine">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>启用或禁用运行时重写引擎</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteEngine开|关</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>RewriteEngine关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>文件信息</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>

      <p><code class="directive">RewriteEngine</code>指令启用或禁用运行时重写引擎。如果将其设置为<code>off</code>此模块完全不执行任何运行时处理。它甚至不更新<code>SCRIPT_URx</code>环境变量。</p>

      <p>使用此伪指令可以在特定上下文中禁用规则，而不是注释掉所有<code class="directive"><a href="#rewriterule">RewriteRule</a></code>伪指令。</p>

      <p>请注意，重写配置不会被虚拟主机继承。这意味着您需要为每个要在其中使用重写规则的虚拟主机使用<code>RewriteEngine on</code>指令。</p>

      <p>如果在未将<code class="directive">RewriteEngine</code>设置为<code>on</code>的上下文中定义了<code>prg</code>类型的<code class="directive"><a href="#rewritemap">RewriteMap</a></code>伪指令，则不会在服务器初始化期间启动</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteMap" id="RewriteMap">RewriteMap</a> <a name="rewritemap" id="rewritemap">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>定义用于键查找的映射功能</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteMap <em>MapName</em> <em>MapType</em> ： <em>MapSource</em>
</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>
      <p><code class="directive">RewriteMap</code>指令定义了一个<em>重写映射</em> ，映射函数可在规则替换字符串中使用它来通过键查找插入/替换字段。查找的来源可以有多种类型。</p>

      <p><a id="mapfunc" name="mapfunc"><em>MapName</em></a>是地图的名称，将用于通过以下结构之一为重写规则的替换字符串指定映射功能：</p>

      <p class="indent">
        <strong><code>${</code> <em>MapName</em> <code>:</code> <em>LookupKey</em> <code>}</code><br>
         <code>${</code> <em>MapName</em> <code>:</code> <em>LookupKey</em> <code>|</code> <em>DefaultValue</em> <code>}</code></strong>
      </p>

      <p>当发生这种构造时，将查询映射<em>MapName</em>并查找键<em>LookupKey</em> 。如果找到了键，则将map-function构造替换为<em>SubstValue</em> 。如果没有找到关键则其由<em>默认值</em>或由空字符串如果没有指定<em>默认值</em>取代。空值的行为就像缺少键一样，因此无法区分空值键和不存在键。</p>

      <p>例如，您可以将<code class="directive">RewriteMap</code>定义为：</p>

      <pre class="prettyprint lang-config">RewriteMap examplemap "txt:/path/to/file/map.txt"</pre>


      <p>然后，您将可以在<code class="directive">RewriteRule</code>使用此映射，如下所示：</p>

      <pre class="prettyprint lang-config">RewriteRule "^/ex/(.*)" "${examplemap:$1}"</pre>


      <p>可以使用<em>MapType</em>和<em>MapSource</em>的以下组合：</p>

    <dl>

    <dt>文本</dt>
        <dd>一个纯文本文件，包含用空格分隔的键/值对，每行一对。（ <a href="../rewrite/rewritemap.html#txt">详细...</a> ）</dd>

    <dt>rnd</dt>
        <dd>从纯文本文件中随机选择一个条目（ <a href="../rewrite/rewritemap.html#rnd">详细信息...</a> ）</dd>

    <dt>数据库</dt>
        <dd>在dbm文件中查找包含名称，值对的条目。哈希是使用<code><a href="../programs/httxt2dbm.html">httxt2dbm</a></code>实用程序从纯文本文件格式构建的。（ <a href="../rewrite/rewritemap.html#dbm">详细...</a> ）</dd>

    <dt>整型</dt>
        <dd><code>RewriteMap</code>提供的四个可用内部功能之一：toupper，tolower，escape或unescape。（ <a href="../rewrite/rewritemap.html#int">详细...</a> ）</dd>

    <dt>prg</dt>
        <dd>调用外部程序或脚本以处理重写。（ <a href="../rewrite/rewritemap.html#prg">详细...</a> ）</dd>

    <dt>dbd或fastdbd</dt>
        <dd>要执行的SQL SELECT语句以查找重写目标。（ <a href="../rewrite/rewritemap.html#dbd">详细...</a> ）</dd>
    </dl>

    <p>可以在<a href="../rewrite/rewritemap.html">RewriteMap HowTo中</a>找到更多详细信息和大量示例。</p>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteOptions" id="RewriteOptions">RewriteOptions</a> <a name="rewriteoptions" id="rewriteoptions">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为重写引擎设置一些特殊选项</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteOptions <var>选项</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>文件信息</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>

      <p><code class="directive">RewriteOptions</code>指令为当前的每服务器或每目录配置设置一些特殊选项。<em>Option</em>字符串当前只能是以下之一：</p>

      <dl>
      <dt><code>继承</code></dt>
      <dd>

      <p>这将强制当前配置继承父项的配置。在每个虚拟服务器上下文中，这意味着继承了主服务器的映射，条件和规则。在每个目录的上下文中，这意味着父目录的<code>.htaccess</code>配置或<code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>节的条件和规则将被继承。继承的规则实际上被复制到使用此伪指令的部分。如果与本地规则结合使用，则继承的规则将被复制到本地规则之后。该指令的位置-低于或高于本地规则-对此行为没有影响。如果本地规则强制停止重写，则继承的规则将不被处理。</p>

      <div class="warning">从父范围继承的规则将在子范围中指定的规则<strong>之后</strong>应用。
      </div>
      </dd>

      <dt><code>继承之前</code></dt>
      <dd>
      <p>与上面的“ <code>Inherit</code>类似，但来自父作用域的规则在子作用域中指定的规则<strong>之前</strong>应用。<br>在Apache HTTP Server 2.3.10和更高版本中可用。</p>
      </dd>

      <dt><code>继承向下</code></dt>
      <dd>

      <p>如果启用此选项，则所有子配置将继承当前配置的配置。等效于在所有子配置中指定<code>RewriteOptions Inherit</code> 。有关如何处理父子关系的更多详细信息，请参见“ <code>Inherit</code>选项。<br>在Apache HTTP Server 2.4.8和更高版本中可用。</p>
      </dd>

      <dt><code>InheritDownBefore</code></dt>
      <dd>

      <p>像上面的<code>InheritDown</code>一样，但是当前作用域中的规则在子作用域中指定的规则<strong>之前</strong>应用。<br>在Apache HTTP Server 2.4.8和更高版本中可用。</p>
      </dd>

      <dt><code>忽略继承</code></dt>
      <dd>

      <p>此选项强制当前配置和子配置忽略所有将从父级继承的指定<code>InheritDown</code>或<code>InheritDownBefore</code> 。<br>在Apache HTTP Server 2.4.8和更高版本中可用。</p>
      </dd>

      <dt><code>AllowNoSlash</code></dt>
      <dd>
      <p>默认情况下， <code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>将忽略映射到磁盘上的目录但没有尾部斜杠的URL，以期望<code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code>模块将向客户端发出带有尾部斜杠的规范URL重定向。</p>

      <p>将<code class="directive"><a href="../mod/mod_dir.html#directoryslash">DirectorySlash</a></code>指令设置为off时，可以启用<code>AllowNoSlash</code>选项以确保不再忽略重写规则。如果需要，可以使用此选项在与目录匹配的.htaccess文件中应用重写规则，而不用斜杠。<br>在Apache HTTP Server 2.4.0和更高版本中可用。</p>
      </dd>

      <dt><code>AllowAnyURI</code></dt>
      <dd>

      <p>如果在<code>VirtualHost</code>或httpd 2.2.22或更高版本的服务器上下文中使用<code class="directive"><a href="#rewriterule">RewriteRule</a></code> ，则仅当请求URI为<a href="directive-dict.html#Syntax">URL路径时</a> ， <code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>才会处理重写规则。这避免了某些安全问题，在这些安全问题中，特定规则可能允许“令人惊讶的”模式扩展（请参阅<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3368">CVE-2011-3368</a>和<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4317">CVE-2011-4317</a> ）。为了解除对匹配URL路径的限制，可以启用<code>AllowAnyURI</code>选项，并且<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>会将规则集应用于任何请求URI字符串，而不管该字符串是否与HTTP规范要求的URL路径语法匹配。<br>在Apache HTTP Server 2.4.3和更高版本中可用。</p>

      <div class="warning">
      <h3>安全警告</h3>

      <p>如果与未经仔细编写的重写规则一起使用，启用此选项将使服务器容易受到安全性问题的影响。<strong>强烈建议</strong>不要使用此选项。尤其要提防包含' <code>@</code> '字符的输入字符串，这些字符串可能会根据上述CVE名称更改转换后的URI的解释。</p>
      </div>
      </dd>

      <dt><code>合并库</code></dt>
      <dd>

      <p>使用此选项， <code class="directive"><a href="#rewritebase">RewriteBase</a></code>的值从显式定义的位置复制到未定义自己的<code class="directive"><a href="#rewritebase">RewriteBase</a></code>任何子目录或子位置。这是2.4.0到2.4.3中的默认行为，并且可以使用Apache HTTP Server 2.4.4和更高版本来恢复该标志。</p>
      </dd>

      <dt><code>IgnoreContextInfo</code></dt>
      <dd>

      <p>在目录（htaccess）上下文中进行相对替换并且未设置<code class="directive"><a href="#rewritebase">RewriteBase</a></code> ，此模块将使用一些扩展的URL和文件系统上下文信息将相对替换更改回URL。诸如<code class="module"><a href="../mod/mod_userdir.html">mod_userdir</a></code>和<code class="module"><a href="../mod/mod_alias.html">mod_alias</a></code>模块可提供此扩展上下文信息。在2.4.16及更高版本中可用。</p>
      </dd>


      <dt><code>LegacyPrefixDocRoot</code></dt>
      <dd>

      <p>在2.4.26之前，如果替换是与当前虚拟主机匹配的绝对URL，则该URL可能首先被还原为URL路径，然后又被还原为本地路径。由于可以将URL简化为本地路径，因此该路径应以文档根作为前缀。当使用以下<code class="directive"><a href="#rewriterule">RewriteRule</a></code>向http：// host / file / myfile发出请求时，这可以防止访问/ tmp / myfile之类的文件。</p>
      <pre class="prettyprint lang-config">RewriteRule /file/(.*) http://localhost/tmp/$1</pre>

      <p>此选项允许使用旧的行为，即文档根目录不以从URL简化的本地路径作为前缀。在2.4.26及更高版本中可用。</p>
      </dd>

      </dl>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="RewriteRule" id="RewriteRule">RewriteRule</a> <a name="rewriterule" id="rewriterule">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>定义重写引擎的规则</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>RewriteRule <em>模式</em> <em>替换</em> [ <em>标志</em> ]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>文件信息</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_rewrite</td></tr>
</table>
      <p><code class="directive">RewriteRule</code>指令是真正的重写主力。该指令可以多次出现，每个实例定义一个重写规则。定义这些规则的顺序很重要-这是它们在运行时应用的顺序。</p>

      <p><a id="patterns" name="patterns"><em>模式</em></a>是与Perl兼容的<a id="regexp" name="regexp">正则表达式</a> 。根据定义<code class="directive">RewriteRule</code>指令的位置，比较此模式的内容会有所不同。</p>

<div class="note"><h3><a id="what_is_matched" name="what_is_matched">匹配什么？</a></h3>

<ul>
      <li><p>在<code class="directive"><a href="../mod/core.html#virtualhost">VirtualHost</a></code>上下文中， <em>模式</em>将首先与主机名和端口之后，查询字符串（例如“ /app1/index.html”）之前的URL部分匹配。这是（％解码） <a href="directive-dict.html#Syntax">URL路径</a> 。</p></li>

      <li><p>在每个目录上下文（ <code class="directive"><a href="../mod/core.html#directory">Directory</a></code>和.htaccess）中， <em>模式</em>仅与部分路径匹配，例如，对“ /app1/index.html”的请求可能与“ app1 / index.html”或“ index”进行比较.html”，具体取决于<code class="directive">RewriteRule</code>的定义位置。</p>

      <p>在比较之前，将定义规则的目录路径从当前映射的文件系统路径中剥离（直到并包括尾斜杠）。此按目录前缀剥离的最终结果是，此上下文中的规则仅与定义该规则的当前映射文件系统路径“以下”部分匹配。</p>

      <p>诸如<code class="directive">DocumentRoot</code>和<code class="directive">Alias</code>指令，甚至是先前<code class="directive">RewriteRule</code>替换的结果，都将确定当前映射的文件系统路径。
      </p>
      </li>

      <li><p>如果要与主机名，端口或查询字符串匹配，请分别使用<code class="directive"><a href="#rewritecond">RewriteCond</a></code>和<code>%{HTTP_HOST}</code> ， <code>%{SERVER_PORT}</code>或<code>%{QUERY_STRING}</code>变量。</p></li>
</ul>
</div>

<div class="note"><h3>每目录重写</h3>
<ul>
<li>重写引擎可能会在<a href="../howto/htaccess.html">.htaccess</a>文件和<code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>部分中使用，但会带来一些额外的复杂性。</li>

<li>要在这种情况下启用重写引擎，您需要设置“ <code>RewriteEngine On</code> ”， <strong>并且</strong>必须启用“ <code>Options FollowSymLinks</code> ”。如果您的管理员已禁用对用户目录的<code>FollowSymLinks</code>覆盖，则您将无法使用重写引擎。出于安全原因，此限制是必需的。</li>

<li>有关将哪些前缀添加回相对替换的更多信息，请参见<code class="directive"><a href="#rewritebase">RewriteBase</a></code>指令。</li>

<li>如果希望与每个目录（htaccess）RewriteRule中的完整URL路径匹配，请在<code class="directive"><a href="#rewritecond">RewriteCond</a></code>使用<code>%{REQUEST_URI}</code>变量。</li>

<li>删除的前缀始终以斜杠结尾，这意味着匹配是针对<em>从未</em>有前导斜杠的字符串进行的。因此，带有<code>^/</code>的<em>模式</em>在每个目录上下文中都不会匹配。</li>

<li>尽管<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>和<code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>部分（包括它们的正则表达式对等部分）在语法上允许重写规则，但这永远是不必要的，不受支持。在这些情况下可能打破的特征是相对替换。</li>
</ul>
</div>

      <p>有关<a class="glossarylink" href="../glossary.html#regex" title="见词汇">正则表达式的</a>一些提示，请参见<a href="../rewrite/intro.html#regex">mod_rewrite简介</a> 。</p>

      <p>在mod_rewrite中，NOT字符（' <code>!</code>'）也可用作可能的模式前缀。这使您可以否定模式。例如：`` <em>如果当前URL与该模式<strong>不</strong>匹配</em> ''。这可以用于例外情况，在这种情况下更容易匹配否定模式，或者用作最后的默认规则。</p>

<div class="note"><h3>注意</h3>使用NOT字符取反模式时，不能在该模式中包括分组的通配符部分。这是因为，如果模式不匹配（即，否定匹配），则组中没有内容。因此，如果使用取反的模式，则不能在替换字符串中使用<code>$N</code> ！
</div>

      <p>该<a id="rhs" name="rhs"><em>替换</em></a>重写规则的是，取代了通过<em>模式</em>匹配原始URL路径的字符串。<em>替代</em>可以是：</p>

      <dl>

        <dt>文件系统路径</dt>

        <dd>指定要传递给客户端的资源在文件系统上的位置。仅当在服务器（虚拟主机）上下文中配置规则并且替换路径中的第一个组件存在于文件系统中时，替换才会被视为文件系统路径</dd>

        <dt>网址路径</dt>

        <dd>与要提供资源的<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>相对的路径。请注意， <code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>尝试通过检查路径的第一段是否存在于文件系统的根目录中来猜测是指定了文件系统路径还是URL路径。例如，如果您指定<code>/www/file.html</code>的<em>Substitution</em>字符串，那么<em>除非</em>根目录或文件系统中存在名为<code>www</code>的目录（或者，在使用重写的情况下）， <em>否则</em>它将被视为URL路径。 <code>.htaccess</code>文件（相对于您的文档根目录）中，在这种情况下，它将被视为文件系统路径。如果希望将其他URL映射指令（例如<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code> ）应用于结果URL路径，请使用<code>[PT]</code>标志，如下所述。</dd>

        <dt>绝对网址</dt>

        <dd>如果指定了绝对URL，则<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>检查主机名是否与当前主机匹配。如果是这样，则将方案和主机名删除，并将得到的路径视为URL路径。否则，将对给定URL执行外部重定向。要强制外部重定向回到当前主机，请参见下面的<code>[R]</code>标志。</dd>

        <dt><code>-</code> （破折号）</dt>

        <dd>破折号表示不应执行任何替换（现有路径未经修改地传递）。当需要在不更改路径的情况下应用标志（请参阅下文）时，将使用此方法。</dd>

      </dl>

      <p>除纯文本外， <em>替换</em>字符串还可以包括</p>

      <ol>
        <li>向后引用（ <code>$N</code> ）到RewriteRule模式</li>

        <li>向后引用（ <code>%N</code> ）到最后匹配的RewriteCond模式</li>

        <li>规则条件测试字符串（ <code>%{VARNAME}</code> ）中的服务器变量</li>

        <li><a href="#mapfunc">映射函数</a>调用（ <code>${mapname:key|default}</code> ）</li>
      </ol>

      <p>反向引用是形式<code>$</code> <strong>N</strong> （ <strong>N</strong> = 0..9）的标识符，该标识符将由匹配<em>Pattern</em>的第<strong>N</strong>组内容替换。服务器变量与<code class="directive"><a href="#rewritecond">RewriteCond</a></code>指令的<em>TestString</em>相同。映射功能来自<code class="directive"><a href="#rewritemap">RewriteMap</a></code>指令，并在此处进行了说明。这三种类型的变量按上述顺序扩展。</p>

      <p>重写规则按照在配置文件中定义的顺序应用于以前的重写规则的结果。URL路径或文件系统路径（请参阅<a href="#what_is_matched">“匹配的内容是什么？“</a> ，见上文） <strong>完全</strong>由<strong>替换</strong> <em>替换</em>和重写过程继续，直到所有的规则已经应用，或者有明确由终止<a href="../rewrite/flags.html#flag_l"><code><strong>L</strong></code>标志</a> ，或其他标记，这意味着立即终止，如<code><strong>END</strong></code>或<code><strong>F</strong></code> 。</p>

     <div class="note"><h3>修改查询字符串</h3>
      <p>默认情况下，查询字符串不变。但是，您可以在包含查询字符串部分的替换字符串中创建URL。只需在替换字符串中使用问号来表示应将以下文本重新插入到查询字符串中。当您要删除现有的查询字符串时，只需用问号结束替换字符串。要组合新旧查询字符串，请使用<code>[QSA]</code>标志。</p>
     </div>

      <p>另外，您可以通过将<strong><code>[</code> <em>标志</em> <code>]</code></strong>作为第三个参数附加到<code class="directive">RewriteRule</code>指令来设置要执行的特殊<a name="rewriteflags" id="rewriteflags">操作</a> 。<em>标志</em>是下表中任何<em>标志</em>的逗号分隔列表，并用方括号括起来。有关每个标志的更多详细信息和示例，请参见“ <a href="../rewrite/flags.html">重写标志”文档</a> 。</p>

    <table class="bordered"><tr class="header"><th>标志和语法</th>
        <th>功能</th>
    </tr>
<tr>
        <td>乙</td>
        <td>应用转换<em>之前，请</em>在反向引用中转义非字母数字字符。 <em><a href="../rewrite/flags.html#flag_b">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>backrefnoplus | BNP</td>
        <td>如果要对反向引用进行转义，则应将空格转义为％20而不是+。在路径组件而不是查询字符串中使用反向引用时很有用。 <em><a href="../rewrite/flags.html#flag_bnp">细节 ...</a></em></td>
    </tr>
<tr>
        <td>链| C</td>
        <td>规则链接到以下规则。如果规则失败，则链接到该规则的规则将被跳过。 <em><a href="../rewrite/flags.html#flag_c">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>cookie | CO = <em>NAME</em> ： <em>VAL</em></td>
        <td>在客户端浏览器中设置cookie。完整语法为：CO = <em>名称</em> ： <em>VAL</em> ： <em>域</em> [： <em>生存期</em> [： <em>路径</em> [： <em>安全</em> [： <em>httponly</em> ]]]]] <em><a href="../rewrite/flags.html#flag_co">详细信息...</a></em>
        </td>
    </tr>
<tr>
        <td>丢弃路径| DPI</td>
        <td>导致重写的URI的PATH_INFO部分被丢弃。 <em><a href="../rewrite/flags.html#flag_dpi">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>结束</td>
        <td>立即停止重写过程，不要再应用任何规则。还可以防止在每个目录和.htaccess上下文中进一步执行重写规则。（在2.3.9及更高版本中可用） <em><a href="../rewrite/flags.html#flag_end">详细信息...</a></em></td>
    </tr>
<tr>
        <td>env | E = [！]<em>VAR</em> [： <em>VAL</em> ]</td>
        <td>导致设置环境变量<em>VAR</em> （如果提供，则设置为<em>VAL</em>值）。表格 ！<em>VAR</em>导致未设置环境变量<em>VAR</em> 。
        <em><a href="../rewrite/flags.html#flag_e">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>禁止| F</td>
        <td>向客户端浏览器返回403 FORBIDDEN响应。
        <em><a href="../rewrite/flags.html#flag_f">细节 ...</a></em></td>
    </tr>
<tr>
        <td>走了| G</td>
        <td>向客户端浏览器返回410 GONE响应。 <em><a href="../rewrite/flags.html#flag_g">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>处理程序| H = <em>内容处理程序</em></td>
        <td>导致将结果URI发送到指定的<em>Content-handler</em>进行处理。 <em><a href="../rewrite/flags.html#flag_h">细节 ...</a></em></td>
    </tr>
<tr>
        <td>最后| L</td>
        <td>立即停止重写过程，不要再应用任何规则。特别要注意每个目录和.htaccess上下文的注意事项（另请参阅END标志）。 <em><a href="../rewrite/flags.html#flag_l">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>下一个| N</td>
        <td>以规则集的结果为起点，从第一条规则开始重新运行重写过程。 <em><a href="../rewrite/flags.html#flag_n">细节 ...</a></em></td>
    </tr>
<tr>
        <td>nocase | NC</td>
        <td>使模式比较不区分大小写。
        <em><a href="../rewrite/flags.html#flag_nc">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>noescape | NE</td>
        <td>防止mod_rewrite在重写结果中应用特殊字符的十六进制转义。 <em><a href="../rewrite/flags.html#flag_ne">细节 ...</a></em></td>
    </tr>
<tr>
        <td>nosubreq | NS</td>
        <td>如果当前请求是内部子请求，则导致规则被跳过。 <em><a href="../rewrite/flags.html#flag_ns">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>代理| P</td>
        <td>强制将替代URL作为代理请求在内部发送。 <em><a href="../rewrite/flags.html#flag_p">细节 ...</a></em></td>
    </tr>
<tr>
        <td>直通| PT</td>
        <td>强制将结果URI传递回URL映射引擎，以处理其他URI到文件名的转换器，例如<code>Alias</code>或<code>Redirect</code> 。 <em><a href="../rewrite/flags.html#flag_pt">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>qsappend | QSA</td>
        <td>将来自原始请求URL的任何查询字符串追加到在重写目标中创建的任何查询字符串。 <em><a href="../rewrite/flags.html#flag_qsa">细节 ...</a></em></td>
    </tr>
<tr>
        <td>qsdiscard | QSD</td>
        <td>丢弃所有附加到传入URI的查询字符串。 <em><a href="../rewrite/flags.html#flag_qsd">细节 ...</a></em></td>
    </tr>
<tr class="odd">
        <td>qslast | QSL</td>
        <td>将最后一个（最右边）问号解释为查询字符串定界符，而不是通常使用的第一个（最左边）问号。在2.4.19及更高版本中可用。
        <em><a href="../rewrite/flags.html#flag_qsl">细节 ...</a></em></td>
    </tr>
<tr>
        <td>redirect | R [= <em>代码</em> ]</td>
        <td>强制进行外部重定向，可以选择使用指定的HTTP状态代码。 <em><a href="../rewrite/flags.html#flag_r">细节 ...</a></em>
        </td>
    </tr>
<tr class="odd">
        <td>skip | S = <em>num</em></td>
        <td>如果当前规则匹配，则告诉重写引擎跳过下一个<em>num</em>规则。 <em><a href="../rewrite/flags.html#flag_s">细节 ...</a></em></td>
    </tr>
<tr>
        <td>type | T = <em>MIME类型</em></td>
        <td>强制目标文件的<a class="glossarylink" href="../glossary.html#mime-type" title="见词汇">MIME类型</a>为指定的类型。 <em><a href="../rewrite/flags.html#flag_t">细节 ...</a></em></td>
    </tr>
</table>

<div class="note"><h3>主目录扩展</h3>
<p>当替换字符串以类似于“ /〜user”的字符串开头（通过显式文本或反向引用）时，mod_rewrite将执行主目录扩展，而与<code class="module"><a href="../mod/mod_userdir.html">mod_userdir</a></code>的存在或配置无关。</p>

<p>当在<code class="directive"><a href="#rewriterule">RewriteRule</a></code>指令上使用<em>PT</em>标志时，不会发生这种扩展。</p>
</div>


     <p>以下是所有可能的替换组合及其含义：</p>

      <p><strong>内部每服务器配置（ <code>httpd.conf</code> ）<br>对于请求`` <code>GET /somepath/pathinfo</code> ''：</strong><br>
      </p>

<table class="bordered"><tr class="header">
<th>给定规则</th>
<th>结果替代</th>
</tr>
<tr>
<td>^ / somepath（。*）otherpath $ 1</td>
<td>无效，不支持</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）otherpath $ 1 [R]</td>
<td>无效，不支持</td>
</tr>
<tr>
<td>^ / somepath（。*）otherpath $ 1 [P]</td>
<td>无效，不支持</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）/ otherpath $ 1</td>
<td>/ otherpath / pathinfo</td>
</tr>
<tr>
<td>^ / somepath（。*）/ otherpath $ 1 [R]</td>
<td>通过外部重定向http：// thishost / otherpath / pathinfo</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）/ otherpath $ 1 [P]</td>
<td>没有意义，不受支持</td>
</tr>
<tr>
<td>^ / somepath（。*）http：// thishost / otherpath $ 1</td>
<td>/ otherpath / pathinfo</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）http：// thishost / otherpath $ 1 [R]</td>
<td>通过外部重定向http：// thishost / otherpath / pathinfo</td>
</tr>
<tr>
<td>^ / somepath（。*）http：// thishost / otherpath $ 1 [P]</td>
<td>没有意义，不受支持</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）http：// otherhost / otherpath $ 1</td>
<td>通过外部重定向http：// otherhost / otherpath / pathinfo</td>
</tr>
<tr>
<td>^ / somepath（。*）http：// otherhost / otherpath $ 1 [R]</td>
<td>通过外部重定向http：// otherhost / otherpath / pathinfo（[R]标志是多余的）</td>
</tr>
<tr class="odd">
<td>^ / somepath（。*）http：// otherhost / otherpath $ 1 [P]</td>
<td>通过内部代理http：// otherhost / otherpath / pathinfo</td>
</tr>
</table>

      <p><strong><code>/somepath</code>每个目录内部配置<br>（ <code>/physical/path/to/somepath/.htaccess</code> ，带有<code>RewriteBase "/somepath"</code> ）<br>对于请求`` <code>GET /somepath/localpath/pathinfo</code> ''：</strong><br>
     </p>

<table class="bordered"><tr class="header">
<th>给定规则</th>
<th>结果替代</th>
</tr>
<tr>
<td>^ localpath（。*）otherpath $ 1</td>
<td>/ somepath / otherpath / pathinfo</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）otherpath $ 1 [R]</td>
<td>通过外部重定向http：// thishost / somepath / otherpath / pathinfo</td>
</tr>
<tr>
<td>^ localpath（。*）otherpath $ 1 [P]</td>
<td>没有意义，不受支持</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）/ otherpath $ 1</td>
<td>/ otherpath / pathinfo</td>
</tr>
<tr>
<td>^ localpath（。*）/ otherpath $ 1 [R]</td>
<td>通过外部重定向http：// thishost / otherpath / pathinfo</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）/ otherpath $ 1 [P]</td>
<td>没有意义，不受支持</td>
</tr>
<tr>
<td>^ localpath（。*）http：// thishost / otherpath $ 1</td>
<td>/ otherpath / pathinfo</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）http：// thishost / otherpath $ 1 [R]</td>
<td>通过外部重定向http：// thishost / otherpath / pathinfo</td>
</tr>
<tr>
<td>^ localpath（。*）http：// thishost / otherpath $ 1 [P]</td>
<td>没有意义，不受支持</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）http：// otherhost / otherpath $ 1</td>
<td>通过外部重定向http：// otherhost / otherpath / pathinfo</td>
</tr>
<tr>
<td>^ localpath（。*）http：// otherhost / otherpath $ 1 [R]</td>
<td>通过外部重定向http：// otherhost / otherpath / pathinfo（[R]标志是多余的）</td>
</tr>
<tr class="odd">
<td>^ localpath（。*）http：// otherhost / otherpath $ 1 [P]</td>
<td>通过内部代理http：// otherhost / otherpath / pathinfo</td>
</tr>
</table>

  
</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>