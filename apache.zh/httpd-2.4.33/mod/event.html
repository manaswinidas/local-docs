<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>事件-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache MPM事件</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td><code class="module"><a href="../mod/worker.html">worker</a></code> MPM的一种变体，其目标是仅消耗具有活动处理能力的连接的线程</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>MPM</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块�标识符：</a></th><td>mpm_event_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>event.c</td></tr></table>
<h3>摘要</h3>

    <p><code class="module"><a href="../mod/event.html">event</a></code>多处理模块（MPM）旨在通过将一些处理工作传递给侦听器线程，从而释放工作线程来处理新请求，从而允许同时处理更多请求。</p>

    <p>要使用<code class="module"><a href="../mod/event.html">event</a></code> MPM，在构建<code class="program"><a href="../programs/httpd.html">httpd</a></code>时，将<code>--with-mpm=event</code>添加到<code class="program"><a href="../programs/configure.html">configure</a></code>脚本的参数中。</p>

</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#event-worker-relationship">与工人MPM的关系</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#how-it-works">怎么运行的</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#requirements">要求</a></li>
</ul><h3 class="directives">指令</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif"> <a href="#asyncrequestworkerfactor">AsyncRequestWorkerFactor</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#coredumpdirectory">CoreDumpDirectory</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#enableexceptionhook">EnableExceptionHook</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mod_unixd.html#group">组</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#listen">听</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#listenbacklog">聆听积压</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#maxconnectionsperchild">MaxConnectionsPerChild</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#maxmemfree">MaxMemFree</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#maxsparethreads">MaxSpareThreads</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#minsparethreads">MinSpare线程</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#pidfile">PidFile</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#scoreboardfile">计分板文件</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#sendbuffersize">SendBufferSize</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#serverlimit">服务器限制</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#startservers">启动服务器</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#threadlimit">线程限制</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#threadsperchild">每个孩子的线程数</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mpm_common.html#threadstacksize">线程堆栈大小</a></li>
<li><img alt="" src="../images/right.gif"> <a href="mod_unixd.html#user">用户</a></li>
</ul>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mpm_event">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mpm_event">报告错误</a></li></ul><h3>也可以看看</h3>
<ul class="seealso">
<li><a href="worker.html">工人MPM</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="event-worker-relationship" id="event-worker-relationship">与工人MPM的关系</a></h2>
<p><code class="module"><a href="../mod/event.html">event</a></code>基于<code class="module"><a href="../mod/worker.html">worker</a></code> MPM，该工作程序实现了混合多进程多线程服务器。单个控制进程（父进程）负责启动子进程。每个子进程都会创建固定数量的服务器线程（如<code class="directive"><a href="../mod/mpm_common.html#threadsperchild">ThreadsPerChild</a></code>指令中所指定），以及一个侦听器线程，该线程侦听连接并将连接到达时将其传递给工作线程进行处理。</p>

<p>运行时配置指令与<code class="module"><a href="../mod/worker.html">worker</a></code>提供的指令相同，只不过增加了<code class="directive">AsyncRequestWorkerFactor</code> 。</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="how-it-works" id="how-it-works">怎么运行的</a></h2>
    <p>该MPM尝试修复HTTP中的“保持活动状态”。客户端完成第一个请求后，它可以保持连接打开，使用同一套接字发送其他请求，并节省创建TCP连接的大量开销。但是，Apache HTTP Server传统上会保留整个子进程/线程来等待来自客户端的数据，这有其自身的缺点。为了解决此问题，该MPM为每个进程使用专用的侦听器线程来处理侦听套接字，处于保持活动状态的所有套接字，处理程序和协议过滤器已完成工作的套接字以及仅剩余的套接字要做的就是将数据发送到客户端。
    </p>

    <p>这种新架构利用非阻塞套接字和<a class="glossarylink" href="../glossary.html#apr" title="见词汇">APR</a>公开的现代内核功能（例如Linux的epoll），不再需要将<code>mpm-accept</code> <code class="directive"><a href="../mod/core.html#mutex">Mutex</a></code>配置为避免雷声群发问题。</p>

    <p>单个进程/线程块可以处理的连接总数由<code class="directive">AsyncRequestWorkerFactor</code>指令控制。</p>

    <h3><a name="async-connections" id="async-connections">异步连接</a></h3>
        <p>异步连接将需要一个固定的专用工作线程与先前的MPM，但不需要事件。<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>的状态页在“异步连接”部分下显示新列：</p>
        <dl>
            <dt>写作</dt>
            <dd>在将响应发送到客户端时，由于连接速度太慢，TCP写缓冲区可能已满。通常在这种情况下，对套接字的<code>write()</code>返回<code>EWOULDBLOCK</code>或<code>EAGAIN</code> ，以在空闲时间之后再次变为可写状态。持有套接字的工作程序可能能够将等待的任务卸载到侦听器线程，这样，一旦为套接字引发事件（例如，“套接字已现在可写”）。请检查“限制”部分以获取更多信息。
            </dd>

            <dt>活着</dt>
            <dd>“保持活动”处理是工作人员MPM的最基本改进。一旦工作线程完成将响应刷新到客户端的操作，便可以将套接字处理工作转移给侦听器线程，从而依次等待来自OS的任何事件，例如“套接字可读”。如果客户端有任何新请求，则侦听器会将其转发到可用的第一个工作线程。相反，如果发生<code class="directive"><a href="../mod/core.html#keepalivetimeout">KeepAliveTimeout</a></code> ，则侦听器将关闭套接字。通过这种方式，工作线程不负责空闲套接字，并且可以将它们重新用于服务其他请求。</dd>

            <dt>闭幕</dt>
            <dd>有时，MPM需要执行持久的关闭操作，即在仍将数据传输到httpd的同时，将早期错误发送回客户端。发送响应然后立即关闭连接不是正确的操作，因为客户端（仍然尝试发送其余请求）将重置连接，并且无法读取httpd的响应。延迟关闭是有时间限制的，但是可能会花费相对较长的时间，因此将其卸载到工作线程（包括关闭挂钩和实际套接字关闭）。从2.4.28开始，连接最终超时时也是如此（侦听器线程除了等待和调度其事件外，从不处理连接）。
            </dd>
        </dl>

        <p>这些改进对HTTP / HTTPS连接均有效。</p>

    

    <h3><a name="graceful-close" id="graceful-close">流畅地终止流程和使用记分板</a></h3>
        <p>该MPM过去显示了一些可伸缩性瓶颈，导致出现以下错误：“ <strong>记分板已满，而不是在MaxRequestWorkers处</strong> ”。
        <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code>限制了在任何给定时间将服务的并发请求数，以及允许的进程数（ <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code> / <code class="directive"><a href="../mod/mpm_common.html#threadsperchild">ThreadsPerChild</a></code> ），同时，记分板表示所有正在运行的进程及其工作线程的状态。如果计分板已满（因此所有线程的状态都为非空闲），但服务的活动请求数不是<code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code> ，则意味着其中一些正在阻止可服务但正在排队的新请求（向上到<code class="directive"><a href="../mod/mpm_common.html#listenbacklog">ListenBacklog</a></code>施加的限制）。大多数情况下，线程处于“优美”状态，即它们等待通过TCP连接完成其工作，以安全地终止并释放记分板插槽（例如，处理长时间运行的请求，运行缓慢的客户端或使用keep-alive的连接）启用）。两种情况很常见：</p>
        <ul>
            <li>在<a href="../stopping.html#graceful">正常重启</a>期间。父进程发信号通知其所有子进程完成其工作并终止，同时它重新加载配置并派生新进程。如果大一点的孩子在停下来之前持续跑步一段时间，记分板将被部分占用，直到他们的插槽被释放。
            </li>
            <li>当服务器负载下降导致httpd停止某些进程时（例如，由于<code class="directive"><a href="../mod/mpm_common.html#maxsparethreads">MaxSpareThreads</a></code>导致）。这特别有问题，因为当负载再次增加时，httpd将尝试启动新进程。如果重复这种模式，则进程的数量可能会增加很多，最终导致尝试停止的旧进程和尝试执行某些工作的新进程混合在一起。
            </li>
        </ul>
        <p>从2.4.24开始，mpm-event变得更智能，并且能够以更好的方式处理正常终止。一些改进是：</p>
        <ul>
            <li>允许使用直到<code class="directive"><a href="../mod/mpm_common.html#serverlimit">ServerLimit</a></code>的所有记分板插槽。
            <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code>和<code class="directive"><a href="../mod/mpm_common.html#threadsperchild">ThreadsPerChild</a></code>用于限制活动进程的数量，同时<code class="directive"><a href="../mod/mpm_common.html#serverlimit">ServerLimit</a></code>还考虑了进行正常关闭的进程，以在需要时允许额外的插槽。这个想法是使用<code class="directive"><a href="../mod/mpm_common.html#serverlimit">ServerLimit</a></code>来指示httpd在影响系统资源之前允许多少个总体过程。
            </li>
            <li>强制优雅地完成进程以使其保持活动状态以关闭其连接。</li>
            <li>在正常关闭期间，如果给定进程的运行中的工作线程多于打开的连接，请终止这些线程以更快地释放资源（新进程可能需要）。</li>
            <li>如果记分板已满，请防止由于负载减少而导致更多进程正常完成，直到旧进程终止（否则，一旦负载再次增加，情况将变得更糟）。</li>
        </ul>
        <p>最后一点中描述的行为可以通过连接摘要表中的<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>通过两个新列“ Slot”和“ Stopping”来完全观察到。前者指示PID，后者指示过程是否停止；多余的状态“是（旧生成）”表示正常重启后进程仍在运行。</p>
    

    <h3><a name="limitations" id="limitations">局限性</a></h3>
        <p>对于已声明自己与事件不兼容的某些连接过滤器，改进的连接处理可能不起作用。在这些情况下，此MPM将退回到<code class="module"><a href="../mod/worker.html">worker</a></code> MPM的行为，并为每个连接保留一个工作程序线程。服务器随附的所有模块均与事件MPM兼容。</p>

        <p>当前，对于涉及需要读取和/或修改整个响应主体的输出过滤器的请求，存在类似的限制。如果在过滤器处理数据时阻塞了与客户端的连接，并且过滤器产生的数据量太大而无法在内存中进行缓冲，则在httpd等待挂起的数据被释放之前，不会释放用于请求的线程。发送给客户。<br>为了说明这一点，我们可以考虑以下两种情况：提供静态资产（如CSS文件）与提供从FCGI / CGI或代理服务器检索的内容的服务。前者是可以预见的，即事件MPM在内容末尾具有完全可见性，并且可以使用事件：提供响应内容的工作线程可以刷新第一个字节，直到返回<code>EWOULDBLOCK</code>或<code>EAGAIN</code>为止，然后将其余部分委托给侦听器。这依次等待套接字上的一个事件，然后委派工作将其余的内容刷新到第一个空闲的工作线程。同时，在后一个示例（FCGI / CGI /代理内容）中，MPM无法预测响应的结束，并且辅助线程必须先完成其工作，然后才能将控件返回给侦听器。唯一的选择是将响应缓冲在内存中，但是出于服务器稳定性和内存占用的考虑，这不是最安全的选择。
        </p>

    

    <h3><a name="background" id="background">背景材料</a></h3>
        <p>通过在支持的操作系统中引入新的API，使事件模型成为可能：</p>
        <ul>
            <li>epoll（Linux）</li>
            <li>kqueue（BSD）</li>
            <li>事件端口（Solaris）</li>
        </ul>
        <p>在提供这些新API之前，必须使用传统的<code>select</code>和<code>poll</code> API。如果用于处理许多连接或连接变化率很高，则这些API会变慢。新的API允许监视更多的连接，并且在一组监视频繁变化的连接时，它们的性能更好。因此，这些API使得编写事件MPM成为可能，该事件可通过许多空闲连接的典型HTTP模式进行更好地扩展。</p>

        <p>MPM假定基础<code>apr_pollset</code>实现是合理的线程安全的。这使MPM可以避免过多的高级锁定，也不必唤醒侦听器线程才能向其发送保持活动套接字。当前仅与KQueue和EPoll兼容。</p>

    

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="requirements" id="requirements">要求</a></h2>
    <p>该MPM依赖于<a class="glossarylink" href="../glossary.html#apr" title="见词汇">APR</a>的原子比较和交换操作来进行线程同步。如果要针对x86目标进行编译并且不需要支持386，或者您要针对SPARC进行编译并且不需要在UltraSPARC之前的芯片上运行，请在<code>--enable-nonportable-atomics=yes</code>上添加<code class="program"><a href="../programs/configure.html">configure</a></code>脚本的参数。这将导致APR使用旧式CPU中不可用的有效操作码来实现原子操作。</p>

    <p>该MPM在缺少良好线程的较旧平台上的性能不佳，但是对EPoll或KQueue的要求使得此问题无济于事。</p>

    <ul>

      <li>要在FreeBSD上使用此MPM，建议使用FreeBSD 5.3或更高版本。但是，如果您使用<code>libkse</code> ，则可以在FreeBSD 5.2.1上运行此MPM（请参见<code>man libmap.conf</code> ）。</li>

      <li>对于NetBSD，建议至少使用2.0版。</li>

      <li>对于Linux，建议使用2.6内核。还必须确保您的<code>glibc</code>版本已编译为支持EPoll。</li>

    </ul>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="AsyncRequestWorkerFactor" id="AsyncRequestWorkerFactor">AsyncRequestWorkerFactor</a> <a name="asyncrequestworkerfactor" id="asyncrequestworkerfactor">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>限制每个进程的并发连接</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>AsyncRequestWorkerFactor <var>因子</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>2</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>MPM</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>事件</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在2.3.13版和更高版本中可用</td></tr>
</table>
    <p>事件MPM以异步方式处理某些连接，其中请求工作线程仅根据需要分配很短的时间，而其他连接每个连接保留一个请求工作线程。这可能导致所有工作人员都被捆绑在一起，并且没有工作线程可用于处理已建立的异步连接上的新工作的情况。</p>

    <p>为了缓解此问题，事件MPM做两件事：</p>
    <ul>
        <li>它限制每个进程接受的连接数，具体取决于空闲请求工作程序的数量；</li>
        <li>如果所有工作人员都忙，即使保持活动超时没有到期，它也会以保持活动状态关闭连接。这允许各个客户端重新连接到可能仍具有工作线程可用的其他进程。</li>
    </ul>

    <p>此伪指令可用于微调每个进程的连接限制。仅当当前连接数（不计算处于“关闭”状态的连接数）低于以下条件时， <strong>进程</strong>才会接受新连接：</p>

    <p class="indent"><strong>
        <code class="directive"><a href="../mod/mpm_common.html#threadsperchild">ThreadsPerChild</a></code> +（ <code class="directive">AsyncRequestWorkerFactor</code> * <var>空闲工作者数</var> ）</strong></p>

    <p>给定空闲工作线程的平均值，可以估算所有进程之间的最大并发连接数，其估算公式如下：</p>


    <p class="indent"><strong>（ <code class="directive"><a href="../mod/mpm_common.html#threadsperchild">ThreadsPerChild</a></code> +（ <code class="directive">AsyncRequestWorkerFactor</code> * <var>空闲工作者的数量</var> ））* <code class="directive"><a href="../mod/mpm_common.html#serverlimit">ServerLimit</a></code>
    </strong></p>

    <div class="note"><h3>例</h3>
    <pre class="prettyprint lang-config">ThreadsPerChild = 10
ServerLimit = 4
AsyncRequestWorkerFactor = 2
MaxRequestWorkers = 40

idle_workers = 4 (average for all the processes to keep it simple)

max_connections = (ThreadsPerChild + (AsyncRequestWorkerFactor * idle_workers)) * ServerLimit
                = (10 + (2 * 4)) * 4 = 72</pre>

    </div>

    <p>当所有工作线程都处于空闲状态时，可以通过一种更简单的方式计算并发连接的绝对最大数量：</p>

    <p class="indent"><strong>（ <code class="directive">AsyncRequestWorkerFactor</code> +1）* <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code>
    </strong></p>


    <div class="note"><h3>例</h3>
    <pre class="prettyprint lang-config">ThreadsPerChild = 10
ServerLimit = 4
MaxRequestWorkers = 40
AsyncRequestWorkerFactor = 2</pre>


    <p>如果所有进程的所有线程都空闲，则：</p>

    <pre class="prettyprint lang-config">idle_workers = 10</pre>


    <p>我们可以通过两种方式计算并发连接的绝对最大数量：</p>

    <pre class="prettyprint lang-config">max_connections = (ThreadsPerChild + (AsyncRequestWorkerFactor * idle_workers)) * ServerLimit
                = (10 + (2 * 10)) * 4 = 120

max_connections = (AsyncRequestWorkerFactor + 1) * MaxRequestWorkers
                = (2 + 1) * 40 = 120</pre>

    </div>

    <p>调整<code class="directive">AsyncRequestWorkerFactor</code>要求了解每个特定用例中httpd处理的流量，因此更改默认值需要进行广泛的测试以及从<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>收集数据。</p>

    <p>在版本2.3.13之前， <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code>被称为<code class="directive">MaxClients</code> 。上面的值表明，旧名称不能准确描述事件MPM的含义。</p>

    <p><code class="directive">AsyncRequestWorkerFactor</code>可以采用非整数参数，例如“ 1.5”。</p>


</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>