<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_proxy_ajp-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_proxy_ajp</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td>用于<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code> AJP支持模块</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块�标识符：</a></th><td>proxy_ajp_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_proxy_ajp.c</td></tr>
<tr><th><a href="module-dict.html#Compatibility">兼容性：</a></th><td>在2.1版及更高版本中可用</td></tr></table>
<h3>摘要</h3>

    <p>该模块<em>需要</em> <code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>服务。它提供对<code>Apache JServ Protocol version 1.3</code> （以下称为<em>AJP13</em> ）的支持。</p>

    <p>因此，为了获得处理<code>AJP13</code>协议的能力，服务器中必须存在<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>和<code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code> 。</p>

    <div class="warning"><h3>警告</h3>
      <p>在<a href="mod_proxy.html#access">确保服务器安全</a>之前，请勿启用代理。开放式代理服务器对您的网络和整个Internet都是危险的。</p>
    </div>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#usage">用法</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#env">环境变量</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#overviewprotocol">协议概述</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#basppacketstruct">基本封包结构</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rpacetstruct">请求报文结构</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#resppacketstruct">响应包结构</a></li>
</ul><h3 class="directives">指令</h3>
<p>该模块不提供指令。</p>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_proxy_ajp">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_proxy_ajp">报告错误</a></li></ul><h3>也可以看看</h3>
<ul class="seealso">
<li><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code></li>
<li><a href="../env.html">环境变量文档</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="usage" id="usage">用法</a></h2>
    <p>该模块用于使用AJP13协议将代理反向代理到后端应用程序服务器（例如Apache Tomcat）。用法类似于HTTP反向代理，但使用<code>ajp://</code>前缀：</p>

    <div class="example"><h3>简单反向代理</h3><pre class="prettyprint lang-config">ProxyPass "/app" "ajp://backend.example.com:8009/app"</pre>
</div>

    <p>还可以使用平衡器：</p>
    <div class="example"><h3>平衡器反向代理</h3><pre class="prettyprint lang-config">&lt;Proxy "balancer://cluster"&gt;
    BalancerMember "ajp://app1.example.com:8009" loadfactor=1
    BalancerMember "ajp://app2.example.com:8009" loadfactor=2
    ProxySet lbmethod=bytraffic
&lt;/Proxy&gt;
ProxyPass "/app" "balancer://cluster/app"</pre>
</div>

    <p>请注意，通常不需要<code class="directive"><a href="../mod/mod_proxy.html#proxypassreverse">ProxyPassReverse</a></code>指令。AJP请求包括提供给代理的原始主机标头，并且可以期望应用程序服务器生成相对于该主机的自引用标头，因此无需重写。</p>
    
    <p>主要的例外是代理上的URL路径与后端上的URL路径不同。在这种情况下，可以相对于原始主机URL（不是后端<code>ajp://</code> URL）重写重定向标头，例如：</p>
    <div class="example"><h3>重写代理路径</h3><pre class="prettyprint lang-config">ProxyPass "/apps/foo" "ajp://backend.example.com:8009/foo"
ProxyPassReverse "/apps/foo" "http://www.example.com/foo"</pre>
</div>
    <p>但是，通常最好将应用程序以与代理相同的路径部署在后端服务器上，而不是采用这种方法。
    </p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="env" id="env">环境变量</a></h2>
    <p>名称具有前缀<code>AJP_</code>环境变量将作为AJP请求属性转发到原始服务器（从密钥名称中删除了AJP_前缀）。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="overviewprotocol" id="overviewprotocol">协议概述</a></h2>
    <p><code>AJP13</code>协议是面向数据包的。出于性能考虑，大概选择了更具可读性的纯文本格式的二进制格式。Web服务器通过TCP连接与Servlet容器进行通信。为了减少套接字创建的昂贵过程，Web服务器将尝试维护与Servlet容器的持久TCP连接，并在多个请求/响应周期中重用连接。</p>
    <p>将连接分配给特定请求后，在请求处理周期终止之前，该连接将不再用于其他任何请求。换句话说，请求不会通过连接进行多路复用。尽管这样做确实会导致同时打开更多连接，但是这会使连接两端的代码更加简单。</p>
    <p>Web服务器打开与servlet容器的连接后，该连接可以处于以下状态之一：</p>
    <ul>
    <li>闲<br>该连接未处理任何请求。</li>
    <li>已分配<br>连接正在处理特定请求。</li>
    </ul>
    <p>一旦分配了连接以处理特定请求，基本请求信息（例如HTTP标头等）就会以高度压缩的形式（例如，通用字符串编码为整数）通过连接发送。该格式的详细信息在下面的“请求数据包结构”中。如果请求有正文<code>(content-length &gt; 0)</code> ，则在紧随其后的单独数据包中发送该正文。</p>
    <p>至此，servlet容器可能已准备就绪，可以开始处理请求了。这样，它可以将以下消息发送回Web服务器：</p>
    <ul>
    <li>SEND_HEADERS<br>将一组标题发送回浏览器。</li>
    <li>SEND_BODY_CHUNK<br>将大量的身体数据发送回浏览器。
    </li>
    <li>GET_BODY_CHUNK<br>如果请求尚未全部传输，请从请求中获取更多数据。这是必要的，因为数据包具有固定的最大大小，并且请求的主体中可以包含任意数量的数据（例如，对于上载的文件）。（注意：这与HTTP分块传输无关）。</li>
    <li>END_RESPONSE<br>完成请求处理周期。</li>
    </ul>
    <p>每个消息都带有不同格式的数据包。有关详细信息，请参见下面的响应数据包结构。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="basppacketstruct" id="basppacketstruct">基本封包结构</a></h2>
    <p>该协议有一些XDR传统，但是在很多方面都存在差异（例如，没有4字节对齐）。</p>
    <p>AJP13对所有数据类型使用网络字节顺序。</p>
    <p>协议中有四种数据类型：字节，布尔值，整数和字符串。</p>
    <dl>
    <dt><strong>字节</strong></dt><dd>一个字节。</dd>
    <dt><strong>布尔型</strong></dt>
      <dd>一个字节， <code>1 = true</code> ， <code>0 = false</code> 。在某些地方使用其他非零值作为true（即C样式）可能会起作用，但在其他地方则不会。</dd>
    <dt><strong>整数</strong></dt>
      <dd><code>0 to 2^16 (32768)</code>范围内的数字。存储在2个字节中，高位在前。</dd>
    <dt><strong>串</strong></dt>
      <dd>可变大小的字符串（长度以2 ^ 16为界）。编码时先将长度打包成两个字节，然后是字符串（包括终止符'\ 0'）。注意，编码长度<strong>不</strong>包括尾部“\ 0” -它像<code>strlen</code> 。在Java方面，这有点令人困惑，它散落着奇数的自动增量语句，以跳过这些终止符。我相信这样做的原因是，使C代码在读取servlet容器发送回的字符串时更加高效-以\ 0字符结尾，C代码可以将引用传递到单个缓冲区中，而无需复制。如果缺少\ 0，则C代码必须将内容复制出来才能获得其字符串概念。</dd>
    </dl>

  <h3>封包大小</h3>
    <p>根据大部分代码，最大数据包大小为<code>8 * 1024 bytes (8K)</code> 。数据包的实际长度在标头中编码。</p>
  
  <h3>包头</h3>
    <p>从服务器发送到容器的数据包以<code>0x1234</code>开头。从容器发送到服务器的数据包以<code>AB</code>开头（这是A的ASCII码，后跟B的ASCII码）。在前两个字节之后，有一个有效载荷长度的整数（按上面的编码）。尽管这可能表明最大有效载荷可能高达2 ^ 16，但实际上，代码将最大有效载荷设置为8K。</p>
    <table>
       
      <tr>
        <th colspan="6"><em>数据包格式（服务器-&gt;容器）</em></th>
      </tr>
      <tr>
        <th>字节</th>
        <td>0</td>
        <td>1个</td>
        <td>2</td>
        <td>3</td>
        <td>4 ...（n + 3）</td>
      </tr>
      <tr>
        <th>内容</th>
        <td>0x12</td>
        <td>0x34</td>
        <td colspan="2">资料长度（n）</td>
        <td>数据</td>
      </tr>
    </table>
    <table>
       
      <tr>
        <th colspan="6"><em>数据包格式（容器-&gt;服务器）</em></th>
      </tr>
      <tr>
        <th>字节</th>
        <td>0</td>
        <td>1个</td>
        <td>2</td>
        <td>3</td>
        <td>4 ...（n + 3）</td>
      </tr>
      <tr>
        <th>内容</th>
        <td>一种</td>
        <td>乙</td>
        <td colspan="2">资料长度（n）</td>
        <td>数据</td>
      </tr>
    </table>
    <p>对于大多数数据包，有效载荷的第一个字节对消息的类型进行编码。从服务器发送到容器的请求主体数据包是一个例外-它们以标准数据包标头（ <code>0x1234</code> ，然后是数据包的长度）发送，但之后没有任何前缀代码。</p>
     <p>Web服务器可以将以下消息发送到Servlet容器：</p>
    <table>
       
      <tr>
        <td>码</td>
        <td>包类型</td>
        <td>含义</td>
      </tr>
      <tr>
        <td>2</td>
        <td>转发请求</td>
        <td>使用以下数据开始请求处理周期</td>
      </tr>
      <tr>
        <td>7</td>
        <td>关掉</td>
        <td>Web服务器要求容器关闭自身。</td>
      </tr>
      <tr>
        <td>8</td>
        <td>平</td>
        <td>Web服务器要求容器进行控制（安全登录阶段）。</td>
      </tr>
      <tr>
        <td>10</td>
        <td>ing</td>
        <td>Web服务器要求容器用CPong快速响应。
        </td>
      </tr>
      <tr>
        <td>没有</td>
        <td>数据</td>
        <td>大小（2个字节）和相应的正文数据。</td>
      </tr>
    </table>
    <p>为了确保一些基本的安全性，只有在请求来自与其托管在同一台计算机上的情况下，容器才会真正执行<code>Shutdown</code> 。</p>
    <p>Web服务器在<code>Forward Request</code>之后立即发送第一个<code>Data</code>包。</p>
    <p>Servlet容器可以将以下类型的消息发送到Web服务器：</p>
    <table>
       
      <tr>
        <td>码</td>
        <td>包类型</td>
        <td>含义</td>
      </tr>
      <tr>
        <td>3</td>
        <td>发送身体块</td>
        <td>将主体的一部分从Servlet容器发送到Web服务器（大概发送到浏览器）。</td>
      </tr>
      <tr>
        <td>4</td>
        <td>发送标题</td>
        <td>将响应标头从servlet容器发送到Web服务器（大概发送到浏览器）。</td>
      </tr>
      <tr>
        <td>5</td>
        <td>结束回应</td>
        <td>标记响应的结束（并因此标记请求处理周期）。
        </td>
      </tr>
      <tr>
        <td>6</td>
        <td>得到身体块</td>
        <td>如果请求尚未全部传输，请从请求中获取更多数据。</td>
      </tr>
      <tr>
        <td>9</td>
        <td>CPong回复</td>
        <td>对CPing请求的回复</td>
      </tr>
    </table>
    <p>以上每个消息都有一个不同的内部结构，下面将详细介绍。</p>
  
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="rpacetstruct" id="rpacetstruct">请求报文结构</a></h2>
    <p>对于从服务器到类型为<em>Forward Request</em>的容器的消息：</p>
    <div class="example"><pre>AJP13_FORWARD_REQUEST :=
    prefix_code      (byte) 0x02 = JK_AJP13_FORWARD_REQUEST
    method           (byte)
    protocol         (string)
    req_uri          (string)
    remote_addr      (string)
    remote_host      (string)
    server_name      (string)
    server_port      (integer)
    is_ssl           (boolean)
    num_headers      (integer)
    request_headers *(req_header_name req_header_value)
    attributes      *(attribut_name attribute_value)
    request_terminator (byte) OxFF</pre></div>
    <p><code>request_headers</code>具有以下结构：</p><div class="example"><pre>req_header_name :=
    sc_req_header_name | (string)  [see below for how this is parsed]

sc_req_header_name := 0xA0xx (integer)

req_header_value := (string)</pre></div>
    <p>这些<code>attributes</code>是可选的，并具有以下结构：</p>
    <div class="example"><pre>attribute_name := sc_a_name | (sc_a_req_attribute string)

attribute_value := (string)</pre></div>
    <p>并不是所有重要的标头都是<code>content-length</code> ，因为它确定容器是否立即寻找另一个数据包。</p>
  <h3>转发请求要素的详细说明</h3>
  <h3>请求前缀</h3>
    <p>对于所有请求，该值为2。有关其他前缀代码的详细信息，请参见上文。</p>
  
  <h3>方法</h3>
    <p>HTTP方法，编码为一个字节：</p>
    <table>
      <tr><td>指令名称</td><td>码</td></tr>
      <tr><td>选件</td><td>1个</td></tr>
      <tr><td>得到</td><td>2</td></tr>
      <tr><td>头</td><td>3</td></tr>
      <tr><td>开机自检</td><td>4</td></tr>
      <tr><td>放</td><td>5</td></tr>
      <tr><td>删除</td><td>6</td></tr>
      <tr><td>跟踪</td><td>7</td></tr>
      <tr><td>PROPFIND</td><td>8</td></tr>
      <tr><td>道具</td><td>9</td></tr>
      <tr><td>MKCOL</td><td>10</td></tr>
      <tr><td>复制</td><td>11</td></tr>
      <tr><td>移动</td><td>12</td></tr>
      <tr><td>锁</td><td>13</td></tr>
      <tr><td>开锁</td><td>14</td></tr>
      <tr><td>访问控制列表</td><td>15</td></tr>
      <tr><td>报告</td><td>16</td></tr>
      <tr><td>版本控制</td><td>17</td></tr>
      <tr><td>报到</td><td>18岁</td></tr>
      <tr><td>查看</td><td>19</td></tr>
      <tr><td>取消结帐</td><td>20</td></tr>
      <tr><td>搜索</td><td>21</td></tr>
      <tr><td>麦考克空间</td><td>22</td></tr>
      <tr><td>更新</td><td>23</td></tr>
      <tr><td>标签</td><td>24</td></tr>
      <tr><td>合并</td><td>25</td></tr>
      <tr><td>BASELINE_CONTROL</td><td>26</td></tr>
      <tr><td>活动能力</td><td>27</td></tr>
    </table>
    <p>更高版本的ajp13，将传输其他方法，即使它们不在此列表中也是如此。</p>
  
  <h3>协议，req_uri，remote_addr，remote_host，server_name，server_port，is_ssl</h3>
    <p>这些都是不言自明的。这些都是必需的，并将针对每个请求发送。</p>
  
  <h3>标头</h3>
    <p><code>request_headers</code>的结构如下：首先， <code>num_headers</code>数<code>num_headers</code>进行编码。然后，随后是一系列标题名称<code>req_header_name</code> /值<code>req_header_value</code>对。通用标头名称编码为整数，以节省空间。如果标头名称不在基本标头列表中，则它会正常编码（作为字符串，带有前缀长度）。常见标头<code>sc_req_header_name</code>及其代码的列表如下（均区分大小写）：</p>
    <table>
      <tr><td>名称</td><td>代码值</td><td>代码名称</td></tr>
      <tr><td>接受</td><td>0xA001</td><td>SC_REQ_ACCEPT</td></tr>
      <tr><td>接受字符集</td><td>0xA002</td><td>SC_REQ_ACCEPT_CHARSET</td></tr>
      <tr><td>接受编码</td><td>0xA003</td><td>SC_REQ_ACCEPT_ENCODING</td></tr>
      <tr><td>接受语言</td><td>0xA004</td><td>SC_REQ_ACCEPT_LANGUAGE</td></tr>
      <tr><td>授权书</td><td>0xA005</td><td>SC_REQ_AUTHORIZATION</td>
      </tr>
      <tr><td>连接</td><td>0xA006</td><td>SC_REQ_CONNECTION</td></tr>
      <tr><td>内容类型</td><td>0xA007</td><td>SC_REQ_CONTENT_TYPE</td>
      </tr>
      <tr><td>内容长度</td><td>0xA008</td><td>SC_REQ_CONTENT_LENGTH</td>
      </tr>
      <tr><td>曲奇饼</td><td>0xA009</td><td>SC_REQ_COOKIE</td></tr>
      <tr><td>cookie2</td><td>0xA00A</td><td>SC_REQ_COOKIE2</td></tr>
      <tr><td>主办</td><td>0xA00B</td><td>SC_REQ_HOST</td></tr>
      <tr><td>语用</td><td>0xA00C</td><td>SC_REQ_PRAGMA</td></tr>
      <tr><td>推荐人</td><td>0xA00D</td><td>SC_REQ_REFERER</td></tr>
      <tr><td>用户代理</td><td>0xA00E</td><td>SC_REQ_USER_AGENT</td></tr>
    </table>
    <p>读取此内容的Java代码将获取第一个两个字节的整数，并且如果在最高有效字节中看到一个<code>'0xA0'</code> ，它将使用第二个字节中的整数作为标头名称数组的索引。如果第一个字节不是<code>0xA0</code> ，则假定两个字节的整数是字符串的长度，然后将其读入。</p>
    <p>这是基于这样的假设，即没有头名称的长度应大于<code>0x9FFF (==0xA000 - 1)</code> ，这是完全合理的，尽管有些武断。</p>
    <div class="note"><h3>注意：</h3><code>content-length</code>标头非常重要。如果存在且不为零，则容器假定该请求具有主体（例如POST请求），并立即从输入流中读取单独的数据包以获取该主体。
    </div>
  
  <h3>属性</h3>
    <p>以<code>?</code>为前缀的属性（例如<code>?context</code> ）都是可选的。对于每个属性，只有一个字节码来指示属性的类型，然后是其值（字符串或整数）。它们可以以任何顺序发送（尽管C代码始终按下面列出的顺序发送它们）。发送一个特殊的终止代码来表示可选属性列表的结尾。字节码列表为：</p>
    <table>
      <tr><td>信息</td><td>代码值</td><td>价值类型</td><td>注意</td></tr>
      <tr><td>？语境</td><td>0x01</td><td>--</td><td>目前尚未实施</td></tr>
      <tr><td>？servlet_path</td><td>0x02</td><td>--</td><td>目前尚未实施</td></tr>
      <tr><td>？remote_user</td><td>0x03</td><td>串</td><td></td></tr>
      <tr><td>？auth_type</td><td>0x04</td><td>串</td><td></td></tr>
      <tr><td>？请求参数</td><td>0x05</td><td>串</td><td></td></tr>
      <tr><td>？jvm_route</td><td>0x06</td><td>串</td><td></td></tr>
      <tr><td>？ssl_cert</td><td>0x07</td><td>串</td><td></td></tr>
      <tr><td>？ssl_cipher</td><td>0x08</td><td>串</td><td></td></tr>
      <tr><td>？ssl_session</td><td>0x09</td><td>串</td><td></td></tr>
      <tr><td>？req_attribute</td><td>0x0A</td><td>串</td><td>名称（属性名称如下）</td></tr>
      <tr><td>？ssl_key_size</td><td>0x0B</td><td>整数</td><td></td></tr>
      <tr><td>完成</td><td>0xFF</td><td>--</td><td>request_terminator</td></tr>
    </table>
    <p>C语言当前未设置<code>context</code>和<code>servlet_path</code> ，大多数Java代码完全忽略了为这些字段发送的任何内容（如果其中一个代码之后发送了字符串，则其中的一些实际上会中断）。我不知道这是错误还是未实现的功能，或者仅仅是残留代码，但连接的两边都没有。</p>
    <p><code>remote_user</code>和<code>auth_type</code>大概是指HTTP级别的身份验证，并传达远程用户的用户名和用于建立其身份的身份验证类型（例如，Basic，Digest）。</p>
    <p>该<code>query_string</code> ， <code>ssl_cert</code> ， <code>ssl_cipher</code>和<code>ssl_session</code>指HTTP和HTTPS的对应件。</p>
    <p><code>jvm_route</code>用于支持粘性会话-在存在多个负载平衡服务器的情况下，将用户的sesson与特定的Tomcat实例相关联。</p>
    <p>除了基本属性列表之外，还可以通过<code>req_attribute</code>代码<code>0x0A</code>发送任意数量的其他属性。在该代码的每个实例之后立即发送一对代表属性名称和值的字符串。环境值通过此方法传递。</p>
    <p>最后，在发送完所有属性之后，发送属性终止符<code>0xFF</code> 。这不仅向属性列表的末尾发出信号，而且还向请求数据包的结束发出信号。</p>
  
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="resppacketstruct" id="resppacketstruct">响应包结构</a></h2>
    <p>容器可以发送回服务器的消息。</p>
    <div class="example"><pre>AJP13_SEND_BODY_CHUNK :=
  prefix_code   3
  chunk_length  (integer)
  chunk        *(byte)
  chunk_terminator (byte) Ox00


AJP13_SEND_HEADERS :=
  prefix_code       4
  http_status_code  (integer)
  http_status_msg   (string)
  num_headers       (integer)
  response_headers *(res_header_name header_value)

res_header_name :=
    sc_res_header_name | (string)   [see below for how this is parsed]

sc_res_header_name := 0xA0 (byte)

header_value := (string)

AJP13_END_RESPONSE :=
  prefix_code       5
  reuse             (boolean)


AJP13_GET_BODY_CHUNK :=
  prefix_code       6
  requested_length  (integer)</pre></div>
  <h3>细节：</h3>
  <h3>发送身体块</h3>
    <p>块基本上是二进制数据，并直接发送回浏览器。</p>
  
  <h3>发送标题</h3>
    <p>状态代码和消息是通常的HTTP内容（例如<code>200</code>和<code>OK</code> ）。响应头名称的编码方式与请求头名称的编码方式相同。有关如何将代码与字符串区分开的详细信息，请参见上面的header_encoding。<br>常见标头的代码为：</p>
    <table>
      <tr><td>名称</td><td>代码值</td></tr>
      <tr><td>内容类型</td><td>0xA001</td></tr>
      <tr><td>内容语言</td><td>0xA002</td></tr>
      <tr><td>内容长度</td><td>0xA003</td></tr>
      <tr><td>日期</td><td>0xA004</td></tr>
      <tr><td>上一次更改</td><td>0xA005</td></tr>
      <tr><td>地点</td><td>0xA006</td></tr>
      <tr><td>Set-Cookie</td><td>0xA007</td></tr>
      <tr><td>Set-Cookie2</td><td>0xA008</td></tr>
      <tr><td>Servlet引擎</td><td>0xA009</td></tr>
      <tr><td>状态</td><td>0xA00A</td></tr>
      <tr><td>WWW认证</td><td>0xA00B</td></tr>
    </table>
    <p>在代码或字符串标题名称之后，标题值立即被编码。</p>
  
  <h3>结束回应</h3>
    <p>发出此请求处理周期结束的信号。如果<code>reuse</code>标志为true <code>(anything other than 0 in the actual C code)</code> ，则此TCP连接现在可用于处理新的传入请求。如果<code>reuse</code>为假（== 0），则应关闭连接。</p>
  
  <h3>得到身体块</h3>
    <p>容器从请求中请求更多数据（如果主体太大而无法容纳发送过来的第一个数据包，或者请求被分块时）。服务器将发送回带有一个数据量的主体数据包，该数据量是<code>request_length</code>的最小值，最大发送主体大小<code>(8186 (8 Kbytes - 6))</code>以及从请求主体实际剩余发送的字节数。<br>如果主体中没有更多数据（即servlet容器试图读取主体的末尾），则服务器将发回一个<em>空</em>数据包，该数据包是有效载荷长度为0的主体数据包。
    <code>（0x12,0x34,0x00,0x00）</code></p>
  
</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>