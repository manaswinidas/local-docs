<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_proxy_balancer-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_proxy_balancer</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>扩展以实现负载平衡</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块�标识符：</a></th><td>proxy_balancer_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_proxy_balancer.c</td></tr>
<tr><th><a href="module-dict.html#Compatibility">兼容性：</a></th><td>在2.1版及更高版本中可用</td></tr></table>
<h3>摘要</h3>

    <p>该模块<em>需要</em> <code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>服务，并且为所有受支持的协议提供负载平衡。最重要的是：</p>
    <ul>
        <li>HTTP，使用<code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code></li>
        <li>FTP，使用<code class="module"><a href="../mod/mod_proxy_ftp.html">mod_proxy_ftp</a></code></li>
        <li>AJP13，使用<code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code></li>
        <li>WebSocket，使用<code class="module"><a href="../mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel</a></code></li>
    </ul>
    
    <p>此模块未提供负载均衡调度程序算法，而是由其他算法提供，例如：</p>
    <ul>
        <li><code class="module"><a href="../mod/mod_lbmethod_byrequests.html">mod_lbmethod_byrequests</a></code></li>
        <li><code class="module"><a href="../mod/mod_lbmethod_bytraffic.html">mod_lbmethod_bytraffic</a></code></li>
        <li><code class="module"><a href="../mod/mod_lbmethod_bybusyness.html">mod_lbmethod_bybusyness</a></code></li>
        <li><code class="module"><a href="../mod/mod_lbmethod_heartbeat.html">mod_lbmethod_heartbeat</a></code></li>
    </ul>

    <p>因此，为了获得负载平衡的能力，服务器中必须存在<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code> ， <code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code>和至少一个负载平衡调度程序算法模块。</p>

    <div class="warning"><h3>警告</h3>
      <p>在<a href="mod_proxy.html#access">确保服务器安全</a>之前，请勿启用代理。开放式代理服务器对您的网络和整个Internet都是危险的。</p>
    </div>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#scheduler">负载均衡器调度程序算法</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#stickyness">负载均衡器粘性</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#example">平衡器配置示例</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#environment">导出的环境变量</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#balancer_manager">启用Balancer Manager支持</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#stickyness_implementation">负载均衡器粘性的详细信息</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#stickyness_troubleshooting">解决负载均衡器粘性</a></li>
</ul><h3 class="directives">指令</h3>
<p>该模块不提供指令。</p>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_proxy_balancer">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_proxy_balancer">报告错误</a></li></ul><h3>也可以看看</h3>
<ul class="seealso">
<li><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code></li>
<li><code class="directive"><a href="../mod/mod_proxy.html#balancermember">平衡器成员</a></code></li>
<li><code class="directive"><a href="../mod/mod_proxy.html#balancergrowth">平衡器增长</a></code></li>
<li><code class="directive"><a href="../mod/mod_proxy.html#balancerpersist">保持平衡</a></code></li>
<li><code class="directive"><a href="../mod/mod_proxy.html#balancerinherit">平衡器继承</a></code></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="scheduler" id="scheduler">负载均衡器调度程序算法</a></h2>
    
    <p>当前，有3种负载均衡器调度程序算法可供使用：请求计数，加权流量计数和待处理的请求计数。这些是通过Balancer定义的<code>lbmethod</code>值控制的。有关更多信息，请参见<code class="directive"><a href="../mod/mod_proxy.html#proxypass">ProxyPass</a></code>指令，尤其是有关如何配置Balancer和BalancerMembers的信息。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="stickyness" id="stickyness">负载均衡器粘性</a></h2>
    
    <p>平衡器支持粘性。当请求被代理到某个后端时，则来自同一用户的所有后续请求都应被代理到同一后端。许多负载均衡器通过将客户端IP地址映射到后端的表来实现此功能。这种方法对客户端和后端透明，但存在一些问题：如果客户端自身隐藏在代理之后，负载分配将不相等；当客户端使用在会话期间发生变化的动态IP地址时，会发生粘性错误；如果发生故障，则会失去粘性。映射表溢出。</p>
    <p><code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code>模块在两种替代方式之上实现了粘性：cookie和URL编码。提供cookie既可以由后端完成，也可以由Apache Web服务器本身完成。URL编码通常在后端进行。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="example" id="example">平衡器配置示例</a></h2>
    
    <p>在深入探讨技术细节之前，这里有一个示例，说明如何使用<code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code>在两个后端服务器之间提供负载平衡：</p>

    <pre class="prettyprint lang-config">&lt;Proxy "balancer://mycluster"&gt;
    BalancerMember "http://192.168.1.50:80"
    BalancerMember "http://192.168.1.51:80"
&lt;/Proxy&gt;
ProxyPass "/test" "balancer://mycluster"
ProxyPassReverse "/test" "balancer://mycluster"</pre>


    <p>另一个示例，说明如何使用<code class="module"><a href="../mod/mod_headers.html">mod_headers</a></code>提供具有粘性的负载平衡，即使后端服务器未设置合适的会话cookie，也是如此：</p>

    <pre class="prettyprint lang-config">Header add Set-Cookie "ROUTEID=.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED
&lt;Proxy "balancer://mycluster"&gt;
    BalancerMember "http://192.168.1.50:80" route=1
    BalancerMember "http://192.168.1.51:80" route=2
    ProxySet stickysession=ROUTEID
&lt;/Proxy&gt;
ProxyPass "/test" "balancer://mycluster"
ProxyPassReverse "/test" "balancer://mycluster"</pre>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="environment" id="environment">导出的环境变量</a></h2>
    
    <p>目前，导出了6个环境变量：</p>

    <dl>
    
    <dt><var><a name="balancer_session_sticky" id="balancer_session_sticky">BALANCER_SESSION_STICKY</a></var></dt>
    <dd>
    <p><var>为该</var>请求分配用于当前请求的<var>stickysession</var>值。它是用于粘性会话的cookie或请求参数的名称</p>
    </dd>

    
    <dt><var><a name="balancer_session_route" id="balancer_session_route">BALANCER_SESSION_ROUTE</a></var></dt>
    <dd>
    <p>分配了从当前请求中解析出的<var>路由</var> 。</p>
    </dd>

    
    <dt><var><a name="balancer_name" id="balancer_name">BALANCER_NAME</a></var></dt>
    <dd>
    <p>为当前请求分配了平衡器的名称。该值类似于<code>balancer://foo</code> 。</p>
    </dd>

    
    <dt><var><a name="balancer_worker_name" id="balancer_worker_name">BALANCER_WORKER_NAME</a></var></dt>
    <dd>
    <p>为该请求分配用于当前请求的工作程序的名称。该值类似于<code>http://hostA:1234</code> 。</p>
    </dd>

    
    <dt><var><a name="balancer_worker_route" id="balancer_worker_route">BALANCER_WORKER_ROUTE</a></var></dt>
    <dd>
    <p>这分配了将用于当前请求的工作程序的<var>路由</var> 。</p>
    </dd>

    
    <dt><var><a name="balancer_route_changed" id="balancer_route_changed">BALANCER_ROUTE_CHANGED</a></var></dt>
    <dd>
    <p>如果会话路由与辅助路由不匹配（BALANCER_SESSION_ROUTE！= BALANCER_WORKER_ROUTE）或会话尚未建立路由。这可用于确定使用粘性会话时何时/是否需要向客户端发送更新的路由。</p>
    </dd>
    </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="balancer_manager" id="balancer_manager">启用Balancer Manager支持</a></h2>
    
    <p>该模块<em>需要</em> <code class="module"><a href="../mod/mod_status.html">mod_status</a></code>服务。平衡器管理器可实现平衡器成员的动态更新。您可以使用Balancer Manager更改特定成员的平衡因子，或将其置于离线模式。
    </p>

    <p>因此，为了获得负载平衡器管理的能力，服务器中必须存在<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>和<code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code> 。</p>

    <p>要为来自example.com域的浏览器启用负载均衡器管理，请将此代码添加到您的<code>httpd.conf</code>配置文件中</p>
<pre class="prettyprint lang-config">&lt;Location "/balancer-manager"&gt;
    SetHandler balancer-manager
    Require host example.com
&lt;/Location&gt;</pre>


    <p>现在，您可以使用Web浏览器访问页面<code>http://your.server.name/balancer-manager</code>来访问负载均衡器管理器。请注意，Manager只能动态控制<code>&lt;Location ...&gt;</code>容器之外定义的平衡器。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="stickyness_implementation" id="stickyness_implementation">负载均衡器粘性的详细信息</a></h2>
    
    <p>使用基于cookie的粘性时，您需要配置cookie的名称，其中包含有关使用哪个后端的信息。这可以通过添加到<code class="directive"><a href="../mod/mod_proxy.html#proxypass">ProxyPass</a></code>或<code class="directive"><a href="../mod/mod_proxy.html#proxyset">ProxySet</a></code>的<var>stickysession</var>属性来<code class="directive"><a href="../mod/mod_proxy.html#proxyset">ProxySet</a></code> 。Cookie的名称区分大小写。平衡器提取cookie的值，并查找<var>路由</var>等于该值的成员worker。这<var>条路线</var>也必须在任一设定<code class="directive"><a href="../mod/mod_proxy.html#proxypass">ProxyPass</a></code>或<code class="directive"><a href="../mod/mod_proxy.html#proxyset">ProxySet</a></code> 。Cookie可以由后端设置，也可以由Apache Web服务器本身在上<a href="#example">例中</a>显示。</p>
    <p>某些后端使用粘性Cookie的形式略有不同，例如Apache Tomcat。Tomcat将Tomcat实例的名称添加到其会话ID cookie的末尾，并用点（ <code>.</code> ）分隔<code>.</code>从会话ID。因此，如果Apache Web服务器在粘性cookie的值中找到一个点，则它仅使用该点后面的部分来搜索路由。为了让Tomcat知道其实例名称，您需要将Tomcat配置文件<code>conf/server.xml</code>中的<code>jvmRoute</code>属性设置为连接到相应Tomcat的辅助服务器的<var>路由</var>值。Tomcat（更<code>JSESSIONID</code>是基于servlet的Java Web应用程序）使用的会话cookie的名称是<code>JSESSIONID</code> （大写），但可以配置为其他名称。</p>
    <p>实现粘性的第二种方法是URL编码。Web服务器在请求的URL中搜索查询参数。使用<var>stickysession</var>再次指定参数的名称。该参数的值用于查找<var>路由</var>等于该值的成员worker。由于提取和处理响应中包含的所有URL链接并不容易，因此通常将参数添加到每个链接的工作是由生成内容的后端完成的。在某些情况下，使用<code class="module"><a href="../mod/mod_substitute.html">mod_substitute</a></code>或<code class="module"><a href="../mod/mod_sed.html">mod_sed</a></code>通过Web服务器执行此操作可能是可行的。但是，这可能会对性能产生负面影响。</p>
    <p>Java标准实现的URL编码略有不同。他们使用以分号（ <code>;</code> ）作为分隔符的URL路径信息，并在其后添加会话ID。与cookie一样，Apache Tomcat可以在此路径信息中包含配置的<code>jvmRoute</code> 。为了让Apache的发现，这一类路径信息，你要啃老族一套<code>scolonpathdelim</code>到<code>On</code>中<code class="directive"><a href="../mod/mod_proxy.html#proxypass">ProxyPass</a></code>或<code class="directive"><a href="../mod/mod_proxy.html#proxyset">ProxySet</a></code> 。</p>
    <p>最后，通过配置cookie的名称和用竖线（ <code>|</code> ）分隔的URL参数的名称，可以同时支持cookie和URL编码，如以下示例所示：</p>
    <pre class="prettyprint lang-config">ProxyPass "/test" "balancer://mycluster" stickysession=JSESSIONID|jsessionid scolonpathdelim=On
&lt;Proxy "balancer://mycluster"&gt;
    BalancerMember "http://192.168.1.50:80" route=node1
    BalancerMember "http://192.168.1.51:80" route=node2
&lt;/Proxy&gt;</pre>

    <p>如果cookie和request参数都提供同一请求的路由信息，则使用来自request参数的信息。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="stickyness_troubleshooting" id="stickyness_troubleshooting">解决负载均衡器粘性</a></h2>
    
    <p>如果您遇到粘性错误，例如用户丢失了应用程序会话并需要再次登录，则首先要检查这是因为后端有时不可用还是您的配置错误。要了解后端可能存在的稳定性问题，请检查Apache错误日志中是否存在代理错误消息。</p>
    <p>要验证您的配置，请首先检查粘性是基于Cookie还是基于URL编码。下一步将使用增强的<code class="directive"><a href="../mod/mod_log_config.html#logformat">LogFormat</a></code>在访问日志中记录适当的数据。以下字段很有用：</p>
    <dl>
    <dt><code>％{MYCOOKIE} C</code></dt>
    <dd>Cookie中名称为<code>MYCOOKIE</code> 。名称应与<var>stickysession</var>属性中提供的名称相同。</dd>
    <dt><code>％{Set-Cookie} o</code></dt>
    <dd>这将记录后端设置的所有cookie。您可以跟踪后端是否设置了您期望的会话cookie，以及将其设置为哪个值。</dd>
    <dt><code>％{BALANCER_SESSION_STICKY} e</code></dt>
    <dd>用于查找路由信息的cookie或请求参数的名称。</dd>
    <dt><code>％{BALANCER_SESSION_ROUTE} e</code></dt>
    <dd>在请求中找到的路线信息。</dd>
    <dt><code>％{BALANCER_WORKER_ROUTE} e</code></dt>
    <dd>选择的工人的路线。</dd>
    <dt><code>％{BALANCER_ROUTE_CHANGED} e</code></dt>
    <dd>如果请求中的路由与工作方的路由不同，则设置为<code>1</code> ，即无法将请求粘性处理。</dd>
    </dl>
    <p>会话丢失的常见原因是会话超时，通常可以在后端服务器上对其进行配置。</p>
    <p>如果日志级别设置为<code>debug</code>或更高，则平衡器还将有关处理粘性的详细信息记录到错误日志中。这是解决粘性问题的简便方法，但是对于高负载下的生产服务器，日志量可能很高。</p>
</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>