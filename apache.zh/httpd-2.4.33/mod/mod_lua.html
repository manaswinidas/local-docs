<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_lua-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_lua</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td>提供Lua钩子到httpd请求处理的各个部分</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块标识符：</a></th><td>lua_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_lua.c</td></tr>
<tr><th><a href="module-dict.html#Compatibility">兼容性：</a></th><td>2.3及更高版本</td></tr></table>
<h3>摘要</h3>

<p>这个模块允许用Lua编程语言编写的脚本扩展服务器。<code class="module"><a href="../mod/mod_lua.html">mod_lua</a></code>可用的扩展点（挂钩）包括许多可用于本机编译的Apache HTTP Server模块的挂钩，例如将请求映射到文件，生成动态响应，访问控制，身份验证和授权</p>

<p>可以<a href="http://www.lua.org/">在Lua网站上</a>找到有关Lua编程语言的更多信息。</p>

<div class="note"><code>mod_lua</code>仍处于实验状态。在声明稳定之前，使用和行为可能随时更改，即使在2.4.x系列的稳定版本之间也是如此。升级之前，请务必检查CHANGES文件。</div>

<div class="warning"><h3>警告</h3>
<p>此模块具有对httpd的强大控制权，这既有优势又有潜在的安全风险。<strong>不</strong>建议您在与不信任的用户共享的服务器上使用此模块，因为它可能会被用来更改httpd的内部工作方式。</p>
</div>

</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#basicconf">基本配置</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#writinghandlers">编写处理程序</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#writingauthzproviders">编写授权提供者</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#writinghooks">书写钩</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#datastructures">数据结构</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#functions">内置功能</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#logging">记录功能</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#apache2">apache2软件包</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#modifying_buckets">用Lua过滤器修改内容</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#databases">数据库连接</a></li>
</ul><h3 class="directives">指令</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif"> <a href="#luaauthzprovider">LuaAuthzProvider</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luacodecache">LuaCodeCache</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookaccesschecker">LuaHookAccessChecker</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookauthchecker">LuaHookAuthChecker</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookcheckuserid">LuaHookCheckUserID</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookfixups">LuaHookFixups</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookinsertfilter">LuaHookInsertFilter</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahooklog">LuaHookLog</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahookmaptostorage">LuaHookMapToStorage</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahooktranslatename">LuaHookTranslateName</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luahooktypechecker">LuaHookTypeChecker</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luainherit">LuaInherit</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luainputfilter">LuaInputFilter</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luamaphandler">LuaMapHandler</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luaoutputfilter">LuaOutputFilter</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luapackagecpath">LuaPackageCPath</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luapackagepath">LuaPackagePath</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luaquickhandler">LuaQuickHandler</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luaroot">LuaRoot</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#luascope">LuaScope</a></li>
</ul>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_lua">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_lua">报告错误</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="basicconf" id="basicconf">基本配置</a></h2>

<p>基本的模块加载指令是</p>

<pre class="prettyprint lang-config">LoadModule lua_module modules/mod_lua.so</pre>


<p>
<code>mod_lua</code>提供了一个名为<code>lua-script</code>的处理程序，可以与<code class="directive"><a href="../mod/core.html#sethandler">SetHandler</a></code>或<code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code>指令一起使用：</p>

<pre class="prettyprint lang-config">&lt;Files "*.lua"&gt;
    SetHandler lua-script
&lt;/Files&gt;</pre>


<p>这将导致<code>mod_lua</code>通过调用该文件的<code>handle</code>函数来处理对以<code>.lua</code>结尾的文件的请求。
</p>

<p>要获得更大的灵活性，请参见<code class="directive">LuaMapHandler</code> 。
</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="writinghandlers" id="writinghandlers">编写处理程序</a></h2>
<p>在Apache HTTP Server API中，处理程序是一种特定的挂钩，负责生成响应。包含处理程序的模块示例为<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code> ， <code class="module"><a href="../mod/mod_cgi.html">mod_cgi</a></code>和<code class="module"><a href="../mod/mod_status.html">mod_status</a></code> 。</p>

<p><code>mod_lua</code>总是希望为处理程序调用Lua函数，而不仅仅是评估脚本主体CGI样式。处理程序函数如下所示：</p>


<pre class="prettyprint lang-lua">
<strong>example.lua</strong><br />
-- example handler

require "string"

--[[
     This is the default method name for Lua handlers, see the optional
     function-name in the LuaMapHandler directive to choose a different
     entry point.
--]]
function handle(r)
    r.content_type = "text/plain"

    if r.method == 'GET' then
        r:puts("Hello Lua World!\n")
        for k, v in pairs( r:parseargs() ) do
            r:puts( string.format("%s: %s\n", k, v) )
        end
    elseif r.method == 'POST' then
        r:puts("Hello Lua World!\n")
        for k, v in pairs( r:parsebody() ) do
            r:puts( string.format("%s: %s\n", k, v) )
        end
    elseif r.method == 'PUT' then
-- use our own Error contents
        r:puts("Unsupported HTTP method " .. r.method)
        r.status = 405
        return apache2.OK
    else
-- use the ErrorDocument
        return 501
    end
    return apache2.OK
end</pre>


<p>该处理程序函数仅将uri或表单编码的参数输出到纯文本页面。
</p>

<p>这意味着（实际上是鼓励）您可以在同一脚本中拥有多个处理程序（或挂钩或过滤器）。
</p>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="writingauthzproviders" id="writingauthzproviders">编写授权提供者</a></h2>


<p><code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code>提供了高级的授权接口，比直接使用相关的挂钩要容易得多。<code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code>指令的第一个参数给出负责的授权提供者的名称。对于任何<code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code>行， <code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code>将调用给定名称的授权提供程序，并将其余行作为参数传递。然后，提供程序将检查授权并将结果作为返回值传递。</p>

<p>通常在身份验证之前调用authz提供程序。如果需要知道经过身份验证的用户名（或者完全要对用户进行身份验证），则提供程序必须返回<code>apache2.AUTHZ_DENIED_NO_USER</code> 。这将导致身份验证继续进行，并再次调用authz提供程序。</p>

<p>以下authz提供程序功能使用两个参数，一个IP地址和一个用户名。它将允许从给定的ip地址进行访问而无需身份验证，或者通过身份验证的用户与第二个参数匹配：</p>

<pre class="prettyprint lang-lua">
<strong>authz_provider.lua</strong><br />

require 'apache2'

function authz_check_foo(r, ip, user)
    if r.useragent_ip == ip then
        return apache2.AUTHZ_GRANTED
    elseif r.user == nil then
        return apache2.AUTHZ_DENIED_NO_USER
    elseif r.user == user then
        return apache2.AUTHZ_GRANTED
    else
        return apache2.AUTHZ_DENIED
    end
end</pre>


<p>以下配置将此功能注册为提供者<code>foo</code>并将其配置为URL <code>/</code> ：</p>
<pre class="prettyprint lang-config">LuaAuthzProvider foo authz_provider.lua authz_check_foo
&lt;Location "/"&gt;
  Require foo 10.1.2.3 john_doe
&lt;/Location&gt;</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="writinghooks" id="writinghooks">书写钩</a></h2>

<p>挂钩函数是模块（和Lua脚本）如何参与请求的处理。服务器公开的每种挂钩类型都有特定的用途，例如将请求映射到文件系统，执行访问控制或设置mime类型：</p>

<table class="bordered"><tr class="header">
        <th>钩相</th>
        <th>mod_lua指令</th>
        <th>描述</th>
    </tr>
<tr>
        <td>快速处理程序</td>
        <td><code class="directive"><a href="#luaquickhandler">LuaQuickHandler</a></code></td>
        <td>这是将请求映射到主机或虚拟主机后将调用的第一个钩子</td>
    </tr>
<tr class="odd">
        <td>翻译名称</td>
        <td><code class="directive"><a href="#luahooktranslatename">LuaHookTranslateName</a></code></td>
        <td>此阶段将请求的URI转换为系统上的文件名。诸如<code class="module"><a href="../mod/mod_alias.html">mod_alias</a></code>和<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>模块在此阶段运行。</td>
    </tr>
<tr>
        <td>映射到存储</td>
        <td><code class="directive"><a href="#luahookmaptostorage">LuaHookMapToStorage</a></code></td>
        <td>此阶段将文件映射到其物理，缓存或外部/代理存储。可以由代理或缓存模块使用</td>
    </tr>
<tr class="odd">
        <td>检查访问</td>
        <td><code class="directive"><a href="#luahookaccesschecker">LuaHookAccessChecker</a></code></td>
        <td>此阶段检查客户端是否有权访问资源。请在验证用户身份之前运行此阶段。
        </td>
    </tr>
<tr>
        <td>检查用户ID</td>
        <td><code class="directive"><a href="#luahookcheckuserid">LuaHookCheckUserID</a></code></td>
        <td>此阶段用于检查协商的用户标识</td>
    </tr>
<tr class="odd">
        <td>检查授权</td>
        <td><code class="directive"><a href="#luahookauthchecker">LuaHookAuthChecker</a></code>或<code class="directive"><a href="#luaauthzprovider">LuaAuthzProvider</a></code></td>
        <td>此阶段根据协商的凭证（例如用户ID，客户端证书等）授权用户。</td>
    </tr>
<tr>
        <td>检查类型</td>
        <td><code class="directive"><a href="#luahooktypechecker">LuaHookTypeChecker</a></code></td>
        <td>此阶段检查请求的文件，并为其分配内容类型和处理程序</td>
    </tr>
<tr class="odd">
        <td>修正</td>
        <td><code class="directive"><a href="#luahookfixups">LuaHookFixups</a></code></td>
        <td>这是内容处理程序运行之前的最后一个“修复所有内容”阶段。对请求的任何最新更改都应在此处进行。</td>
    </tr>
<tr>
        <td>内容处理程序</td>
        <td>fx。 <code>.lua</code>文件或通过<code class="directive"><a href="#luamaphandler">LuaMapHandler</a></code></td>
        <td>这是处理内容的地方。读取，解析文件，运行某些文件，并将结果发送到客户端</td>
    </tr>
<tr class="odd">
        <td>记录中</td>
        <td><code class="directive"><a href="#luahooklog">LuaHookLog</a></code></td>
        <td>处理完请求后，它将进入几个日志记录阶段，将请求记录在错误或访问日志中。Mod_lua可以加入该程序的开头并控制日志记录输出。</td>
    </tr>
</table>

<p>挂钩函数作为唯一的参数传递给请求对象（LuaAuthzProvider除外，该函数也从Require指令传递参数）。它们可以返回任何值，具体取决于钩子，但是最常见的是，它们将返回OK，DONE或DECLINED，您可以在Lua中将其编写为<code>apache2.OK</code> ， <code>apache2.DONE</code>或<code>apache2.DECLINED</code> ，否则为HTTP状态代码。</p>


<pre class="prettyprint lang-lua">
<strong>translate_name.lua</strong><br />
-- example hook that rewrites the URI to a filesystem path.

require 'apache2'

function translate_name(r)
    if r.uri == "/translate-name" then
        r.filename = r.document_root .. "/find_me.txt"
        return apache2.OK
    end
    -- we don't care about this URL, give another module a chance
    return apache2.DECLINED
end</pre>



<pre class="prettyprint lang-lua">
<strong>translate_name2.lua</strong><br />
--[[ example hook that rewrites one URI to another URI. It returns a
     apache2.DECLINED to give other URL mappers a chance to work on the
     substitution, including the core translate_name hook which maps based
     on the DocumentRoot.

     Note: Use the early/late flags in the directive to make it run before
           or after mod_alias.
--]]

require 'apache2'

function translate_name(r)
    if r.uri == "/translate-name" then
        r.uri = "/find_me.txt"
        return apache2.DECLINED
    end
    return apache2.DECLINED
end</pre>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="datastructures" id="datastructures">数据结构</a></h2>

<dl>
<dt>request_rec</dt>
        <dd>
        <p>request_rec作为用户数据映射。它具有一个元表，可让您使用它做有用的事情。在大多数情况下，它具有与request_rec结构相同的字段，其中许多字段可写且可读。（表字段的内容可以更改，但是字段本身不能设置为其他表。）</p>

        <table class="bordered"><tr class="header">
          <th><strong>名称</strong></th>
          <th><strong>a型</strong></th>
          <th><strong>可写</strong></th>
          <th><strong>描述</strong></th>
        </tr>
<tr>
          <td><code>允许覆盖</code></td>
          <td>串</td>
          <td>没有</td>
          <td>AllowOverride选项应用于当前请求。</td>
        </tr>
<tr class="odd">
          <td><code>ap_auth_type</code></td>
          <td>串</td>
          <td>没有</td>
          <td>如果进行了身份验证检查，则将其设置为身份验证类型（fx <code>basic</code> ）</td>
        </tr>
<tr>
          <td><code>args</code></td>
          <td>串</td>
          <td>是</td>
          <td>从请求中提取的查询字符串参数（fx <code>foo=bar&amp;name=johnsmith</code> ）</td>
        </tr>
<tr class="odd">
          <td><code>s</code></td>
          <td>布尔值</td>
          <td>没有</td>
          <td>如果这是HTTP / 0.9样式的请求，则设置为true（例如<code>GET /foo</code> （不包含标头））</td>
        </tr>
<tr>
          <td><code>auth_name</code></td>
          <td>串</td>
          <td>没有</td>
          <td>用于授权的领域名称（如果适用）。</td>
        </tr>
<tr class="odd">
          <td><code>旗帜</code></td>
          <td>串</td>
          <td>没有</td>
          <td>服务器横幅fx<code>Apache HTTP服务器/2.4.3 openssl / 0.9.8c</code></td>
        </tr>
<tr>
          <td><code>basic_auth_pw</code></td>
          <td>串</td>
          <td>没有</td>
          <td>与此请求一起发送的基本身份验证密码（如果有）</td>
        </tr>
<tr class="odd">
          <td><code>规范文件名</code></td>
          <td>串</td>
          <td>没有</td>
          <td>请求的规范文件名</td>
        </tr>
<tr>
          <td><code>content_encoding</code></td>
          <td>串</td>
          <td>没有</td>
          <td>当前请求的内容编码</td>
        </tr>
<tr class="odd">
          <td><code>内容类型</code></td>
          <td>串</td>
          <td>是</td>
          <td>在type_check阶段确定的当前请求的内容类型（fx <code>image/gif</code>或<code>text/html</code> ）</td>
        </tr>
<tr>
          <td><code>context_prefix</code></td>
          <td>串</td>
          <td>没有</td>
          <td></td>
        </tr>
<tr class="odd">
          <td><code>context_document_root</code></td>
          <td>串</td>
          <td>没有</td>
          <td></td>
        </tr>
<tr>
          <td><code>document_root</code></td>
          <td>串</td>
          <td>没有</td>
          <td>主机的文档根目录</td>
        </tr>
<tr class="odd">
          <td><code>err_headers_out</code></td>
          <td>表</td>
          <td>没有</td>
          <td>响应的MIME标头环境，即使在错误时也可以打印，并且在内部重定向中仍然存在</td>
        </tr>
<tr>
          <td><code>文档名称</code></td>
          <td>串</td>
          <td>是</td>
          <td>请求映射到的文件名，fx /www/example.com/foo.txt。可以在请求的翻译名称或映射到存储阶段更改此设置，以允许默认处理程序（或脚本处理程序）为请求的文件提供不同的文件。</td>
        </tr>
<tr class="odd">
          <td><code>处理程序</code></td>
          <td>串</td>
          <td>是</td>
          <td>应该为该请求提供服务的<a href="../handler.html">处理程序</a>的名称，fx
            <code>lua-script</code>如果要由mod_lua提供）。这通常由<code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code>或<code class="directive"><a href="../mod/core.html#sethandler">SetHandler</a></code>指令设置，但也可以通过mod_lua设置，以允许另一个处理程序处理特定的请求，否则该请求将无法处理。
            </td>
        </tr>
<tr>
          <td><code>headers_in</code></td>
          <td>表</td>
          <td>是</td>
          <td>来自请求的MIME标头环境。其中包含标头，例如<code>Host, User-Agent, Referer</code>等。</td>
        </tr>
<tr class="odd">
          <td><code>headers_out</code></td>
          <td>表</td>
          <td>是</td>
          <td>响应的MIME标头环境。</td>
        </tr>
<tr>
          <td><code>主机名</code></td>
          <td>串</td>
          <td>没有</td>
          <td>主机名，由<code>Host:</code>标头或完整URI设置。</td>
        </tr>
<tr class="odd">
          <td><code>是_https</code></td>
          <td>布尔值</td>
          <td>没有</td>
          <td>此请求是否通过HTTPS完成</td>
        </tr>
<tr>
          <td><code>is_initial_req</code></td>
          <td>布尔值</td>
          <td>没有</td>
          <td>该请求是初始请求还是子请求</td>
        </tr>
<tr class="odd">
          <td><code>limit_req_body</code></td>
          <td>数</td>
          <td>没有</td>
          <td>此请求的请求主体的大小限制；如果没有限制，则为0。</td>
        </tr>
<tr>
          <td><code>log_id</code></td>
          <td>串</td>
          <td>没有</td>
          <td>标识访问和错误日志中的请求的ID。</td>
        </tr>
<tr class="odd">
          <td><code>方法</code></td>
          <td>串</td>
          <td>没有</td>
          <td>请求方法，fx<code>GET</code>或<code>POST</code> 。</td>
        </tr>
<tr>
          <td><code>笔记</code></td>
          <td>表</td>
          <td>是</td>
          <td>可以从一个模块传递到另一个模块的注释列表。</td>
        </tr>
<tr class="odd">
          <td><code>选项</code></td>
          <td>串</td>
          <td>没有</td>
          <td>选项指令应用于当前请求。</td>
        </tr>
<tr>
          <td><code>path_info</code></td>
          <td>串</td>
          <td>没有</td>
          <td>从此请求中提取的PATH_INFO。</td>
        </tr>
<tr class="odd">
          <td><code>港口</code></td>
          <td>数</td>
          <td>没有</td>
          <td>请求使用的服务器端口。</td>
        </tr>
<tr>
          <td><code>协议</code></td>
          <td>串</td>
          <td>没有</td>
          <td>使用的协议，fx<code>HTTP / 1.1</code></td>
        </tr>
<tr class="odd">
          <td><code>proxyreq</code></td>
          <td>串</td>
          <td>是</td>
          <td>表示这是否是代理请求。通常在请求的post_read_request / translate_name阶段中设置此值。</td>
        </tr>
<tr>
          <td><code>范围</code></td>
          <td>串</td>
          <td>没有</td>
          <td><code>Range:</code>标头的内容。</td>
        </tr>
<tr class="odd">
          <td><code>剩余的</code></td>
          <td>数</td>
          <td>没有</td>
          <td>要从请求主体读取的剩余字节数。</td>
        </tr>
<tr>
          <td><code>server_built</code></td>
          <td>串</td>
          <td>没有</td>
          <td>服务器可执行文件的构建时间。</td>
        </tr>
<tr class="odd">
          <td><code>服务器名称</code></td>
          <td>串</td>
          <td>没有</td>
          <td>此请求的服务器名称。</td>
        </tr>
<tr>
          <td><code>some_auth_required</code></td>
          <td>布尔值</td>
          <td>没有</td>
          <td>此请求是否需要某种授权。</td>
        </tr>
<tr class="odd">
          <td><code>subprocess_env</code></td>
          <td>表</td>
          <td>是</td>
          <td>为此请求设置的环境变量。</td>
        </tr>
<tr>
          <td><code>开始了</code></td>
          <td>数</td>
          <td>没有</td>
          <td>从该时期（1970年1月1日）开始（重新）启动服务器的时间（以秒为单位）</td>
        </tr>
<tr class="odd">
          <td><code>状态</code></td>
          <td>数</td>
          <td>是</td>
          <td>此请求的（当前）HTTP返回代码，fx <code>200</code>或<code>404</code> 。</td>
        </tr>
<tr>
          <td><code>the_request</code></td>
          <td>串</td>
          <td>没有</td>
          <td>客户端发送的请求字符串fx<code>GET /foo/bar HTTP/1.1</code> 。</td>
        </tr>
<tr class="odd">
          <td><code>unparsed_uri</code></td>
          <td>串</td>
          <td>没有</td>
          <td>请求的未解析的URI</td>
        </tr>
<tr>
          <td><code>乌里</code></td>
          <td>串</td>
          <td>是</td>
          <td>httpd解析后的URI</td>
        </tr>
<tr class="odd">
          <td><code>用户</code></td>
          <td>串</td>
          <td>是</td>
          <td>如果进行了身份验证检查，则将其设置为已验证用户的名称。</td>
        </tr>
<tr>
          <td><code>useragent_ip</code></td>
          <td>串</td>
          <td>没有</td>
          <td>发出请求的用户代理的IP</td>
        </tr>
</table>
           </dd>
    </dl>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="functions" id="functions">内置功能</a></h2>

<p>request_rec对象具有（至少）以下方法：</p>

<pre class="prettyprint lang-lua">r:flush()   -- flushes the output buffer.
            -- Returns true if the flush was successful, false otherwise.

while we_have_stuff_to_send do
    r:puts("Bla bla bla\n") -- print something to client
    r:flush() -- flush the buffer (send to client)
    r.usleep(500000) -- fake processing time for 0.5 sec. and repeat
end</pre>


<pre class="prettyprint lang-lua">r:addoutputfilter(name|function) -- add an output filter:

r:addoutputfilter("fooFilter") -- add the fooFilter to the output stream</pre>


<pre class="prettyprint lang-lua">r:sendfile(filename) -- sends an entire file to the client, using sendfile if supported by the current platform:

if use_sendfile_thing then
    r:sendfile("/var/www/large_file.img")
end</pre>


<pre class="prettyprint lang-lua">r:parseargs() -- returns two tables; one standard key/value table for regular GET data, 
              -- and one for multi-value data (fx. foo=1&amp;foo=2&amp;foo=3):

local GET, GETMULTI = r:parseargs()
r:puts("Your name is: " .. GET['name'] or "Unknown")</pre>


<pre class="prettyprint lang-lua">r:parsebody([sizeLimit]) -- parse the request body as a POST and return two lua tables,
                         -- just like r:parseargs().
                         -- An optional number may be passed to specify the maximum number 
                         -- of bytes to parse. Default is 8192 bytes:
                 
local POST, POSTMULTI = r:parsebody(1024*1024)
r:puts("Your name is: " .. POST['name'] or "Unknown")</pre>


<pre class="prettyprint lang-lua">r:puts("hello", " world", "!") -- print to response body, self explanatory</pre>


<pre class="prettyprint lang-lua">r:write("a single string") -- print to response body, self explanatory</pre>


<pre class="prettyprint lang-lua">r:escape_html("&lt;html&gt;test&lt;/html&gt;") -- Escapes HTML code and returns the escaped result</pre>


<pre class="prettyprint lang-lua">r:base64_encode(string) -- Encodes a string using the Base64 encoding standard:

local encoded = r:base64_encode("This is a test") -- returns VGhpcyBpcyBhIHRlc3Q=</pre>


<pre class="prettyprint lang-lua">r:base64_decode(string) -- Decodes a Base64-encoded string:

local decoded = r:base64_decode("VGhpcyBpcyBhIHRlc3Q=") -- returns 'This is a test'</pre>


<pre class="prettyprint lang-lua">r:md5(string) -- Calculates and returns the MD5 digest of a string (binary safe):

local hash = r:md5("This is a test") -- returns ce114e4501d2f4e2dcea3e17b546f339</pre>


<pre class="prettyprint lang-lua">r:sha1(string) -- Calculates and returns the SHA1 digest of a string (binary safe):

local hash = r:sha1("This is a test") -- returns a54d88e06612d820bc3be72877c74f257b561b19</pre>


<pre class="prettyprint lang-lua">r:escape(string) -- URL-Escapes a string:

local url = "http://foo.bar/1 2 3 &amp; 4 + 5"
local escaped = r:escape(url) -- returns 'http%3a%2f%2ffoo.bar%2f1+2+3+%26+4+%2b+5'</pre>


<pre class="prettyprint lang-lua">r:unescape(string) -- Unescapes an URL-escaped string:

local url = "http%3a%2f%2ffoo.bar%2f1+2+3+%26+4+%2b+5"
local unescaped = r:unescape(url) -- returns 'http://foo.bar/1 2 3 &amp; 4 + 5'</pre>


<pre class="prettyprint lang-lua">r:construct_url(string) -- Constructs an URL from an URI

local url = r:construct_url(r.uri)</pre>


<pre class="prettyprint lang-lua">r.mpm_query(number) -- Queries the server for MPM information using ap_mpm_query:

local mpm = r.mpm_query(14)
if mpm == 1 then
    r:puts("This server uses the Event MPM")
end</pre>


<pre class="prettyprint lang-lua">r:expr(string) -- Evaluates an <a href="../expr.html">expr</a> string.

if r:expr("%{HTTP_HOST} =~ /^www/") then
    r:puts("This host name starts with www")
end</pre>


<pre class="prettyprint lang-lua">r:scoreboard_process(a) -- Queries the server for information about the process at position <code>a</code>:

local process = r:scoreboard_process(1)
r:puts("Server 1 has PID " .. process.pid)</pre>


<pre class="prettyprint lang-lua">r:scoreboard_worker(a, b) -- Queries for information about the worker thread, <code>b</code>, in process <code>a</code>:

local thread = r:scoreboard_worker(1, 1)
r:puts("Server 1's thread 1 has thread ID " .. thread.tid .. " and is in " .. thread.status .. " status")</pre>



<pre class="prettyprint lang-lua">r:clock() -- Returns the current time with microsecond precision</pre>


<pre class="prettyprint lang-lua">r:requestbody(filename) -- Reads and returns the request body of a request.
                -- If 'filename' is specified, it instead saves the
                -- contents to that file:
                
local input = r:requestbody()
r:puts("You sent the following request body to me:\n")
r:puts(input)</pre>


<pre class="prettyprint lang-lua">r:add_input_filter(filter_name) -- Adds 'filter_name' as an input filter</pre>


<pre class="prettyprint lang-lua">r.module_info(module_name) -- Queries the server for information about a module

local mod = r.module_info("mod_lua.c")
if mod then
    for k, v in pairs(mod.commands) do
       r:puts( ("%s: %s\n"):format(k,v)) -- print out all directives accepted by this module
    end
end</pre>


<pre class="prettyprint lang-lua">r:loaded_modules() -- Returns a list of modules loaded by httpd:

for k, module in pairs(r:loaded_modules()) do
    r:puts("I have loaded module " .. module .. "\n")
end</pre>


<pre class="prettyprint lang-lua">r:runtime_dir_relative(filename) -- Compute the name of a run-time file (e.g., shared memory "file") 
                         -- relative to the appropriate run-time directory.</pre>


<pre class="prettyprint lang-lua">r:server_info() -- Returns a table containing server information, such as 
                -- the name of the httpd executable file, mpm used etc.</pre>


<pre class="prettyprint lang-lua">r:set_document_root(file_path) -- Sets the document root for the request to file_path</pre>




<pre class="prettyprint lang-lua">r:set_context_info(prefix, docroot) -- Sets the context prefix and context document root for a request</pre>


<pre class="prettyprint lang-lua">r:os_escape_path(file_path) -- Converts an OS path to a URL in an OS dependent way</pre>


<pre class="prettyprint lang-lua">r:escape_logitem(string) -- Escapes a string for logging</pre>


<pre class="prettyprint lang-lua">r.strcmp_match(string, pattern) -- Checks if 'string' matches 'pattern' using strcmp_match (globs).
                        -- fx. whether 'www.example.com' matches '*.example.com':
                        
local match = r.strcmp_match("foobar.com", "foo*.com")
if match then 
    r:puts("foobar.com matches foo*.com")
end</pre>


<pre class="prettyprint lang-lua">r:set_keepalive() -- Sets the keepalive status for a request. Returns true if possible, false otherwise.</pre>


<pre class="prettyprint lang-lua">r:make_etag() -- Constructs and returns the etag for the current request.</pre>


<pre class="prettyprint lang-lua">r:send_interim_response(clear) -- Sends an interim (1xx) response to the client.
                       -- if 'clear' is true, available headers will be sent and cleared.</pre>


<pre class="prettyprint lang-lua">r:custom_response(status_code, string) -- Construct and set a custom response for a given status code.
                               -- This works much like the ErrorDocument directive:
                               
r:custom_response(404, "Baleted!")</pre>


<pre class="prettyprint lang-lua">r.exists_config_define(string) -- Checks whether a configuration definition exists or not:

if r.exists_config_define("FOO") then
    r:puts("httpd was probably run with -DFOO, or it was defined in the configuration")
end</pre>


<pre class="prettyprint lang-lua">r:state_query(string) -- Queries the server for state information</pre>


<pre class="prettyprint lang-lua">r:stat(filename [,wanted]) -- Runs stat() on a file, and returns a table with file information:

local info = r:stat("/var/www/foo.txt")
if info then
    r:puts("This file exists and was last modified at: " .. info.modified)
end</pre>


<pre class="prettyprint lang-lua">r:regex(string, pattern [,flags]) -- Runs a regular expression match on a string, returning captures if matched:

local matches = r:regex("foo bar baz", [[foo (\w+) (\S*)]])
if matches then
    r:puts("The regex matched, and the last word captured ($2) was: " .. matches[2])
end

-- Example ignoring case sensitivity:
local matches = r:regex("FOO bar BAz", [[(foo) bar]], 1)

-- Flags can be a bitwise combination of:
-- 0x01: Ignore case
-- 0x02: Multiline search</pre>


<pre class="prettyprint lang-lua">r.usleep(number_of_microseconds) -- Puts the script to sleep for a given number of microseconds.</pre>


<pre class="prettyprint lang-lua">r:dbacquire(dbType[, dbParams]) -- Acquires a connection to a database and returns a database class.
                        -- See '<a href="#databases">Database connectivity</a>' for details.</pre>


<pre class="prettyprint lang-lua">r:ivm_set("key", value) -- Set an Inter-VM variable to hold a specific value.
                        -- These values persist even though the VM is gone or not being used,
                        -- and so should only be used if MaxConnectionsPerChild is &gt; 0
                        -- Values can be numbers, strings and booleans, and are stored on a 
                        -- per process basis (so they won't do much good with a prefork mpm)
                        
r:ivm_get("key")        -- Fetches a variable set by ivm_set. Returns the contents of the variable
                        -- if it exists or nil if no such variable exists.
                        
-- An example getter/setter that saves a global variable outside the VM:
function handle(r)
    -- First VM to call this will get no value, and will have to create it
    local foo = r:ivm_get("cached_data")
    if not foo then
        foo = do_some_calcs() -- fake some return value
        r:ivm_set("cached_data", foo) -- set it globally
    end
    r:puts("Cached data is: ", foo)
end</pre>


<pre class="prettyprint lang-lua">r:htpassword(string [,algorithm [,cost]]) -- Creates a password hash from a string.
                                          -- algorithm: 0 = APMD5 (default), 1 = SHA, 2 = BCRYPT, 3 = CRYPT.
                                          -- cost: only valid with BCRYPT algorithm (default = 5).</pre>


<pre class="prettyprint lang-lua">r:mkdir(dir [,mode]) -- Creates a directory and sets mode to optional mode parameter.</pre>


<pre class="prettyprint lang-lua">r:mkrdir(dir [,mode]) -- Creates directories recursive and sets mode to optional mode parameter.</pre>


<pre class="prettyprint lang-lua">r:rmdir(dir) -- Removes a directory.</pre>


<pre class="prettyprint lang-lua">r:touch(file [,mtime]) -- Sets the file modification time to current time or to optional mtime msec value.</pre>


<pre class="prettyprint lang-lua">r:get_direntries(dir) -- Returns a table with all directory entries.

function handle(r)
  local dir = r.context_document_root
  for _, f in ipairs(r:get_direntries(dir)) do
    local info = r:stat(dir .. "/" .. f)
    if info then
      local mtime = os.date(fmt, info.mtime / 1000000)
      local ftype = (info.filetype == 2) and "[dir] " or "[file]"
      r:puts( ("%s %s %10i %s\n"):format(ftype, mtime, info.size, f) )
    end
  end
end</pre>


<pre class="prettyprint lang-lua">r.date_parse_rfc(string) -- Parses a date/time string and returns seconds since epoche.</pre>


<pre class="prettyprint lang-lua">r:getcookie(key) -- Gets a HTTP cookie</pre>


<pre class="prettyprint lang-lua">r:setcookie{
  key = [key],
  value = [value],
  expires = [expiry],
  secure = [boolean],
  httponly = [boolean],
  path = [path],
  domain = [domain]
} -- Sets a HTTP cookie, for instance:

r:setcookie{
  key = "cookie1",
  value = "HDHfa9eyffh396rt",
  expires = os.time() + 86400,
  secure = true
}</pre>


<pre class="prettyprint lang-lua">r:wsupgrade() -- Upgrades a connection to WebSockets if possible (and requested):
if r:wsupgrade() then -- if we can upgrade:
    r:wswrite("Welcome to websockets!") -- write something to the client
    r:wsclose()  -- goodbye!
end</pre>


<pre class="prettyprint lang-lua">r:wsread() -- Reads a WebSocket frame from a WebSocket upgraded connection (see above):

local line, isFinal = r:wsread() -- isFinal denotes whether this is the final frame.
                                 -- If it isn't, then more frames can be read
r:wswrite("You wrote: " .. line)</pre>


<pre class="prettyprint lang-lua">r:wswrite(line) -- Writes a frame to a WebSocket client:
r:wswrite("Hello, world!")</pre>


<pre class="prettyprint lang-lua">r:wsclose() -- Closes a WebSocket request and terminates it for httpd:

if r:wsupgrade() then
    r:wswrite("Write something: ")
    local line = r:wsread() or "nothing"
    r:wswrite("You wrote: " .. line);
    r:wswrite("Goodbye!")
    r:wsclose()
end</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="logging" id="logging">记录功能</a></h2>

<pre class="prettyprint lang-lua">-- examples of logging messages
r:trace1("This is a trace log message") -- trace1 through trace8 can be used
r:debug("This is a debug log message")
r:info("This is an info log message")
r:notice("This is a notice log message")
r:warn("This is a warn log message")
r:err("This is an err log message")
r:alert("This is an alert log message")
r:crit("This is a crit log message")
r:emerg("This is an emerg log message")</pre>


</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="apache2" id="apache2">apache2软件包</a></h2>
<p>提供了一个名为<code>apache2</code>的软件包，其中包含（至少）以下内容。</p>
<dl>
  <dt>apache2。好</dt>
  <dd>内部常量确定。如果处理程序处理了请求，则应返回此值。</dd>
  <dt>apache2。拒绝</dt>
  <dd>内部常量DECLINED。如果处理程序不打算处理请求，则应返回此值。</dd>
  <dt>apache2。完成</dt>
  <dd>内部常量DONE。</dd>
  <dt>apache2.version</dt>
  <dd>Apache HTTP服务器版本字符串</dd>
  <dt>apache2。HTTP_MOVED_TEMPORARILY</dt>
  <dd>HTTP状态码</dd>
  <dt>apache2。PROXYREQ_NONE，apache2。PROXYREQ_PROXY，apache2。PROXYREQ_REVERSE，apache2。PROXYREQ_RESPONSE</dt>
  <dd><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>使用的内部常量</dd>
  <dt>apache2。AUTHZ_DENIED，apache2。AUTHZ_GRANTED，apache2。AUTHZ_NEUTRAL，apache2。AUTHZ_GENERAL_ERROR，apache2。AUTHZ_DENIED_NO_USER</dt>
  <dd><code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code>使用的内部常量</dd>

</dl>
<p>（其他HTTP状态代码尚未实现。）</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="modifying_buckets" id="modifying_buckets">用Lua过滤器修改内容</a></h2>
    
    <p>通过<code class="directive"><a href="#luainputfilter">LuaInputFilter</a></code>或<code class="directive"><a href="#luaoutputfilter">LuaOutputFilter</a></code>实现的过滤器函数被设计为三级非阻塞函数，使用协程在存储桶沿着过滤器链发送时暂停和恢复该函数。该功能的核心结构是：</p>
    <pre class="prettyprint lang-lua">function filter(r)
    -- Our first yield is to signal that we are ready to receive buckets.
    -- Before this yield, we can set up our environment, check for conditions,
    -- and, if we deem it necessary, decline filtering a request alltogether:
    if something_bad then
        return -- This would skip this filter.
    end
    -- Regardless of whether we have data to prepend, a yield MUST be called here.
    -- Note that only output filters can prepend data. Input filters must use the 
    -- final stage to append data to the content.
    coroutine.yield([optional header to be prepended to the content])
    
    -- After we have yielded, buckets will be sent to us, one by one, and we can 
    -- do whatever we want with them and then pass on the result.
    -- Buckets are stored in the global variable 'bucket', so we create a loop
    -- that checks if 'bucket' is not nil:
    while bucket ~= nil do
        local output = mangle(bucket) -- Do some stuff to the content
        coroutine.yield(output) -- Return our new content to the filter chain
    end

    -- Once the buckets are gone, 'bucket' is set to nil, which will exit the 
    -- loop and land us here. Anything extra we want to append to the content
    -- can be done by doing a final yield here. Both input and output filters 
    -- can append data to the content in this phase.
    coroutine.yield([optional footer to be appended to the content])
end</pre>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="databases" id="databases">数据库连接</a></h2>
    
    <p>Mod_lua实现了一种简单的数据库功能，用于在最流行的数据库引擎（mySQL，PostgreSQL，FreeTDS，ODBC，SQLite，Oracle）以及mod_dbd上查询和运行命令。
    </p>
    <p>下面的示例显示如何获取数据库句柄并从表返回信息：</p>
    <pre class="prettyprint lang-lua">function handle(r)
    -- Acquire a database handle
    local database, err = r:dbacquire("mysql", "server=localhost,user=someuser,pass=somepass,dbname=mydb")
    if not err then
        -- Select some information from it
        local results, err = database:select(r, "SELECT `name`, `age` FROM `people` WHERE 1")
        if not err then
            local rows = results(0) -- fetch all rows synchronously
            for k, row in pairs(rows) do
                r:puts( string.format("Name: %s, Age: %s&lt;br/&gt;", row[1], row[2]) )
            end
        else
            r:puts("Database query error: " .. err)
        end
        database:close()
    else
        r:puts("Could not connect to the database: " .. err)
    end
end</pre>

    <p>要使用<code class="module"><a href="../mod/mod_dbd.html">mod_dbd</a></code> ，请将<code>mod_dbd</code>指定为数据库类型，或将字段保留为空白：</p>
    <pre class="prettyprint lang-lua">local database = r:dbacquire("mod_dbd")</pre>

    <h3><a name="database_object" id="database_object">数据库对象和包含的功能</a></h3>
        
        <p><code>dbacquire</code>返回的数据库对象具有以下方法：</p>
        <p><strong>从数据库正常选择和查询：</strong></p>
    <pre class="prettyprint lang-lua">-- Run a statement and return the number of rows affected:
local affected, errmsg = database:query(r, "DELETE FROM `tbl` WHERE 1")

-- Run a statement and return a result set that can be used synchronously or async:
local result, errmsg = database:select(r, "SELECT * FROM `people` WHERE 1")</pre>

        <p><strong>使用准备好的语句（推荐）：</strong></p>
    <pre class="prettyprint lang-lua">-- Create and run a prepared statement:
local statement, errmsg = database:prepare(r, "DELETE FROM `tbl` WHERE `age` &gt; %u")
if not errmsg then
    local result, errmsg = statement:query(20) -- run the statement with age &gt; 20
end

-- Fetch a prepared statement from a DBDPrepareSQL directive:
local statement, errmsg = database:prepared(r, "someTag")
if not errmsg then
    local result, errmsg = statement:select("John Doe", 123) -- inject the values "John Doe" and 123 into the statement
end</pre>

        <p><strong>转义值，关闭数据库等：</strong></p>
    <pre class="prettyprint lang-lua">-- Escape a value for use in a statement:
local escaped = database:escape(r, [["'|blabla]])

-- Close a database connection and free up handles:
database:close()

-- Check whether a database connection is up and running:
local connected = database:active()</pre>

    
    <h3><a name="result_sets" id="result_sets">处理结果集</a></h3>
    
    <p><code>db:select</code>或通过<code>db:prepare</code>创建的prepared语句函数返回的结果集可用于同步或异步获取行，具体取决于指定的行号：<br>
    <code>result(0)</code>以同步方式获取所有行，并返回一个行表。<br>
    <code>result(-1)</code>异步获取集合中的下一个可用行。<br>
    <code>result(N)</code>异步获取行号<code>N</code> ：</p>
    <pre class="prettyprint lang-lua">-- fetch a result set using a regular query:
local result, err = db:select(r, "SELECT * FROM `tbl` WHERE 1")

local rows = result(0) -- Fetch ALL rows synchronously
local row = result(-1) -- Fetch the next available row, asynchronously
local row = result(1234) -- Fetch row number 1234, asynchronously
local row = result(-1, true) -- Fetch the next available row, using row names as key indexes.</pre>

    <p>可以构造一个函数，该函数返回一个迭代函数，以异步或异步方式对所有行进行迭代，具体取决于async参数：</p>
    <pre class="prettyprint lang-lua">function rows(resultset, async)
    local a = 0
    local function getnext()
        a = a + 1
        local row = resultset(-1)
        return row and a or nil, row
    end
    if not async then
        return pairs(resultset(0))
    else
        return getnext, self
    end
end

local statement, err = db:prepare(r, "SELECT * FROM `tbl` WHERE `age` &gt; %u")
if not err then
     -- fetch rows asynchronously:
    local result, err = statement:select(20)
    if not err then
        for index, row in rows(result, true) do
            ....
        end
    end

     -- fetch rows synchronously:
    local result, err = statement:select(20)
    if not err then
        for index, row in rows(result, false) do
            ....
        end
    end
end</pre>

    
    <h3><a name="closing_databases" id="closing_databases">关闭数据库连接</a></h3>
        

    <p>当不再需要数据库句柄时，应使用<code>database:close()</code>它们。如果不手动关闭它们，它们最终将被垃圾回收并由mod_lua关闭，但是如果您将关闭保留为mod_lua，则最终可能与数据库的连接数过多。本质上，以下两个度量是相同的：</p>
    <pre class="prettyprint lang-lua">-- Method 1: Manually close a handle
local database = r:dbacquire("mod_dbd")
database:close() -- All done

-- Method 2: Letting the garbage collector close it
local database = r:dbacquire("mod_dbd")
database = nil -- throw away the reference
collectgarbage() -- close the handle via GC</pre>

    
    <h3><a name="database_caveat" id="database_caveat">使用数据库时的注意事项</a></h3>
    
    <p>尽管可以免费使用标准<code>query</code>和<code>run</code>功能，但是建议您尽可能使用准备好的语句，以优化性能（如果您的数据库句柄长期存在）并最大程度地降低SQL注入攻击的风险。仅当在语句（静态语句）中未插入任何变量时，才应使用<code>run</code>和<code>query</code> 。使用动态语句时，请使用<code>db:prepare</code>或<code>db:prepared</code> 。
    </p>
    

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaAuthzProvider" id="LuaAuthzProvider">LuaAuthzProvider</a> <a name="luaauthzprovider" id="luaauthzprovider">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将授权提供程序功能插入<code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code>
</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaAuthzProvider provider_name /path/to/lua/script.lua函数名</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.4.3及更高版本</td></tr>
</table>
<p>lua函数注册为授权提供程序后，可以与<code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code>指令一起使用：</p>

<pre class="prettyprint lang-config">LuaRoot "/usr/local/apache2/lua"
LuaAuthzProvider foo authz.lua authz_check_foo
&lt;Location "/"&gt;
  Require foo johndoe
&lt;/Location&gt;</pre>

<pre class="prettyprint lang-lua">require "apache2"
function authz_check_foo(r, who)
    if r.user ~= who then return apache2.AUTHZ_DENIED
    return apache2.AUTHZ_GRANTED
end</pre>




</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaCodeCache" id="LuaCodeCache">LuaCodeCache</a> <a name="luacodecache" id="luacodecache">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>配置编译后的代码缓存。</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaCodeCache统计信息|永远|永远</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>LuaCodeCache统计</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table><p>指定内存中代码缓存的行为。默认值为stat，它在每次需要该文件时统计顶级脚本（不包含任何脚本），如果修改后的时间表明该文件比已加载的脚本新，则重新加载该脚本。其他值导致它永久保留文件缓存（不统计和替换）或从不缓存文件。</p>

    <p>一般而言，统计数据或永远对生产有利，而统计数据或永不对发展有利。</p>

    <div class="example"><h3>例子：</h3><pre class="prettyprint lang-config">LuaCodeCache stat
LuaCodeCache forever
LuaCodeCache never</pre>
</div>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookAccessChecker" id="LuaHookAccessChecker">LuaHookAccessChecker</a> <a name="luahookaccesschecker" id="luahookaccesschecker">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的access_checker阶段提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookAccessChecker /path/to/lua/script.lua hook_function_name [early | late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.3.15和更高版本支持可选的第三个参数</td></tr>
</table>
<p>将您的钩子添加到access_checker阶段。访问检查器挂钩函数通常返回OK，DECLINED或HTTP_FORBIDDEN。</p>
   <div class="note"><h3>定购</h3><p>可选参数“ early”或“ late”控制此脚本相对于其他模块运行的时间。</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookAuthChecker" id="LuaHookAuthChecker">LuaHookAuthChecker</a> <a name="luahookauthchecker" id="luahookauthchecker">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的auth_checker阶段提供一个钩子</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookAuthChecker /path/to/lua/script.lua hook_function_name [early | late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.3.15和更高版本支持可选的第三个参数</td></tr>
</table>
<p>在处理请求的auth_checker阶段调用lua函数。这可用于实现任意身份验证和授权检查。一个非常简单的例子：</p>
<pre class="prettyprint lang-lua">require 'apache2'

-- fake authcheck hook
-- If request has no auth info, set the response header and
-- return a 401 to ask the browser for basic auth info.
-- If request has auth info, don't actually look at it, just
-- pretend we got userid 'foo' and validated it.
-- Then check if the userid is 'foo' and accept the request.
function authcheck_hook(r)

   -- look for auth info
   auth = r.headers_in['Authorization']
   if auth ~= nil then
     -- fake the user
     r.user = 'foo'
   end

   if r.user == nil then
      r:debug("authcheck: user is nil, returning 401")
      r.err_headers_out['WWW-Authenticate'] = 'Basic realm="WallyWorld"'
      return 401
   elseif r.user == "foo" then
      r:debug('user foo: OK')
   else
      r:debug("authcheck: user='" .. r.user .. "'")
      r.err_headers_out['WWW-Authenticate'] = 'Basic realm="WallyWorld"'
      return 401
   end
   return apache2.OK
end</pre>

   <div class="note"><h3>定购</h3><p>可选参数“ early”或“ late”控制此脚本相对于其他模块运行的时间。</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookCheckUserID" id="LuaHookCheckUserID">LuaHookCheckUserID</a> <a name="luahookcheckuserid" id="luahookcheckuserid">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的check_user_id阶段提供一个钩子</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookCheckUserID /path/to/lua/script.lua hook_function_name [early | late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.3.15和更高版本支持可选的第三个参数</td></tr>
</table><p>...</p>
   <div class="note"><h3>定购</h3><p>可选参数“ early”或“ late”控制此脚本相对于其他模块运行的时间。</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookFixups" id="LuaHookFixups">LuaHookFixups</a> <a name="luahookfixups" id="luahookfixups">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的修正阶段提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookFixups /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
<p>就像LuaHookTranslateName一样，但是在修正阶段执行</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookInsertFilter" id="LuaHookInsertFilter">LuaHookInsertFilter</a> <a name="luahookinsertfilter" id="luahookinsertfilter">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的insert_filter阶段提供一个钩子</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookInsertFilter /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table><p>尚未实现</p>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookLog" id="LuaHookLog">LuaHookLog</a> <a name="luahooklog" id="luahooklog">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的访问日志阶段提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookLog /path/to/lua/script.lua log_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
<p>这个简单的日志挂钩可让您在httpd进入请求的日志记录阶段时运行功能。使用它，您可以将数据追加到自己的日志中，可以在写入常规日志之前处理数据，或者阻止创建日志条目。为了防止发生通常的日志记录，只需返回<code>apache2.DONE</code>在你的日志处理程序，否则返回<code>apache2.OK</code>以告知httpd正常登录。
</p>
<p>例：</p>
<pre class="prettyprint lang-config">LuaHookLog "/path/to/script.lua" logger</pre>

<pre class="prettyprint lang-lua">-- /path/to/script.lua --
function logger(r)
    -- flip a coin:
    -- If 1, then we write to our own Lua log and tell httpd not to log
    -- in the main log.
    -- If 2, then we just sanitize the output a bit and tell httpd to 
    -- log the sanitized bits.

    if math.random(1,2) == 1 then
        -- Log stuff ourselves and don't log in the regular log
        local f = io.open("/foo/secret.log", "a")
        if f then
            f:write("Something secret happened at " .. r.uri .. "\n")
            f:close()
        end
        return apache2.DONE -- Tell httpd not to use the regular logging functions
    else
        r.uri = r.uri:gsub("somesecretstuff", "") -- sanitize the URI
        return apache2.OK -- tell httpd to log it.
    end
end</pre>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookMapToStorage" id="LuaHookMapToStorage">LuaHookMapToStorage</a> <a name="luahookmaptostorage" id="luahookmaptostorage">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的map_to_storage阶段提供一个钩子</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookMapToStorage /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>与<code class="directive">LuaHookTranslateName</code>但在请求的映射到存储阶段执行。诸如mod_cache之类的模块在此阶段运行，这为此处的操作提供了一个有趣的示例：</p>
    <pre class="prettyprint lang-config">LuaHookMapToStorage "/path/to/lua/script.lua" check_cache</pre>

    <pre class="prettyprint lang-lua">require"apache2"
cached_files = {}

function read_file(filename) 
    local input = io.open(filename, "r")
    if input then
        local data = input:read("*a")
        cached_files[filename] = data
        file = cached_files[filename]
        input:close()
    end
    return cached_files[filename]
end

function check_cache(r)
    if r.filename:match("%.png$") then -- Only match PNG files
        local file = cached_files[r.filename] -- Check cache entries
        if not file then
            file = read_file(r.filename)  -- Read file into cache
        end
        if file then -- If file exists, write it out
            r.status = 200
            r:write(file)
            r:info(("Sent %s to client from cache"):format(r.filename))
            return apache2.DONE -- skip default handler for PNG files
        end
    end
    return apache2.DECLINED -- If we had nothing to do, let others serve this.
end</pre>


    
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookTranslateName" id="LuaHookTranslateName">LuaHookTranslateName</a> <a name="luahooktranslatename" id="luahooktranslatename">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的翻译名称阶段提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookTranslateName /path/to/lua/script.lua hook_function_name [early | late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.3.15和更高版本支持可选的第三个参数</td></tr>
</table><p>在请求处理的翻译名称阶段添加一个挂钩（位于APR_HOOK_MIDDLE）。hook函数接收单个参数request_rec，并应返回状态代码，该状态代码可以是HTTP错误代码，也可以是apache2模块中定义的常数：apache2。好的，apache2。拒绝，或apache2。完成。</p>

    <p>对于那些新的钩子，基本上每个钩子都会被调用，直到其中一个返回apache2为止。好。如果您的钩子不想执行翻译，则应仅返回apache2。拒绝。如果请求应停止处理，则返回apache2。完成。</p>

    <p>例：</p>

<pre class="prettyprint lang-config"># httpd.conf
LuaHookTranslateName "/scripts/conf/hooks.lua" silly_mapper</pre>


<pre class="prettyprint lang-lua">-- /scripts/conf/hooks.lua --
require "apache2"
function silly_mapper(r)
    if r.uri == "/" then
        r.filename = "/var/www/home.lua"
        return apache2.OK
    else
        return apache2.DECLINED
    end
end</pre>


   <div class="note"><h3>语境</h3><p>该指令在<code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code> ， <code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>或htaccess上下文中无效。</p></div>

   <div class="note"><h3>定购</h3><p>可选参数“ early”或“ late”控制此脚本相对于其他模块运行的时间。</p></div>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaHookTypeChecker" id="LuaHookTypeChecker">LuaHookTypeChecker</a> <a name="luahooktypechecker" id="luahooktypechecker">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的type_checker阶段提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaHookTypeChecker /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table><p>该指令为请求处理的type_checker阶段提供了一个挂钩。在此阶段，为请求分配了内容类型和处理程序，因此可用于根据输入来修改类型和处理程序：</p>
    <pre class="prettyprint lang-config">LuaHookTypeChecker "/path/to/lua/script.lua" type_checker</pre>

    <pre class="prettyprint lang-lua">    function type_checker(r)
        if r.uri:match("%.to_gif$") then -- match foo.png.to_gif
            r.content_type = "image/gif" -- assign it the image/gif type
            r.handler = "gifWizard"      -- tell the gifWizard module to handle this
            r.filename = r.uri:gsub("%.to_gif$", "") -- fix the filename requested
            return apache2.OK
        end

        return apache2.DECLINED
    end</pre>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaInherit" id="LuaInherit">LuaInherit</a> <a name="luainherit" id="luainherit">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>控制父配置节如何合并到子级中</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaInherit none | parent-first | parent-last</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>LuaInherit父母优先</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.4.0及更高版本</td></tr>
</table><p>默认情况下，如果在重叠的“目录”或“位置”配置节中使用LuaHook *伪指令，则在更具体的节中定义的脚本将在更通用的节（LuaInherit parent-first）中定义的脚本<em>之后</em>运行。您可以颠倒此顺序，或使父上下文根本不适用。</p>
    
    <p>在以前的2.3.x版本中，默认设置实际上是忽略父配置节中的LuaHook *指令。</p>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaInputFilter" id="LuaInputFilter">LuaInputFilter</a> <a name="luainputfilter" id="luainputfilter">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>提供用于内容输入过滤的Lua功能</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaInputFilter filter_name /path/to/lua/script.lua函数名</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.4.5及更高版本</td></tr>
</table>
<p>提供一种添加Lua函数作为输入过滤器的方法。与输出过滤器一样，输入过滤器用作协程，首先在发送缓冲区之前产生，然后在需要将存储桶沿链向下传递时产生，最后（可选）产生需要附加到输入数据的任何内容。全局变量<code>bucket</code>在将存储桶传递到Lua脚本时将其保存：</p>

<pre class="prettyprint lang-config">LuaInputFilter myInputFilter "/www/filter.lua" input_filter
&lt;Files "*.lua"&gt;
  SetInputFilter myInputFilter
&lt;/Files&gt;</pre>

<pre class="prettyprint lang-lua">--[[
    Example input filter that converts all POST data to uppercase.
]]--
function input_filter(r)
    print("luaInputFilter called") -- debug print
    coroutine.yield() -- Yield and wait for buckets
    while bucket do -- For each bucket, do...
        local output = string.upper(bucket) -- Convert all POST data to uppercase
        coroutine.yield(output) -- Send converted data down the chain
    end
    -- No more buckets available.
    coroutine.yield("&amp;filterSignature=1234") -- Append signature at the end
end</pre>

<p>如果认为不需要过滤器，输入过滤器支持拒绝/跳过过滤器：</p>
<pre class="prettyprint lang-lua">function input_filter(r)
    if not good then
        return -- Simply deny filtering, passing on the original content instead
    end
    coroutine.yield() -- wait for buckets
    ... -- insert filter stuff here
end</pre>

<p>有关更多信息，请参见“ <a href="#modifying_buckets">使用Lua过滤器修改内容</a> ”。
</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaMapHandler" id="LuaMapHandler">LuaMapHandler</a> <a name="luamaphandler" id="luamaphandler">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将路径映射到lua处理程序</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaMapHandler uri模式/path/to/lua/script.lua [函数名]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>该指令与uri模式匹配，以调用特定文件中的特定处理函数。它使用PCRE正则表达式来匹配uri，并支持将匹配组内插到文件路径和函数名称中。小心编写正则表达式，以避免安全问题。</p>
   <div class="example"><h3>例子：</h3><pre class="prettyprint lang-config">LuaMapHandler "/(\w+)/(\w+)" "/scripts/$1.lua" "handle_$2"</pre>
</div>
        <p>这会匹配uri的/ photos / show吗？id = 9到文件/scripts/photos.lua并在加载该文件后在lua vm上调用处理程序函数handle_show。</p>

<pre class="prettyprint lang-config">LuaMapHandler "/bingo" "/scripts/wombat.lua"</pre>

        <p>这将调用“句柄”函数，如果未提供特定的函数名，则为默认值。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaOutputFilter" id="LuaOutputFilter">LuaOutputFilter</a> <a name="luaoutputfilter" id="luaoutputfilter">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>提供Lua功能以进行内容输出过滤</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaOutputFilter filter_name /path/to/lua/script.lua函数名</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.4.5及更高版本</td></tr>
</table>
<p>提供一种添加Lua函数作为输出过滤器的方法。与输入过滤器一样，输出过滤器充当协程，首先在发送缓冲区之前屈服，然后在需要将存储桶沿链向下传递时屈服，最后（可选）产生需要附加到输入数据的任何内容。全局变量<code>bucket</code>在将存储桶传递到Lua脚本时将其保存：</p>

<pre class="prettyprint lang-config">LuaOutputFilter myOutputFilter "/www/filter.lua" output_filter
&lt;Files "*.lua"&gt;
  SetOutputFilter myOutputFilter
&lt;/Files&gt;</pre>

<pre class="prettyprint lang-lua">--[[
    Example output filter that escapes all HTML entities in the output
]]--
function output_filter(r)
    coroutine.yield("(Handled by myOutputFilter)&lt;br/&gt;\n") -- Prepend some data to the output,
                                                          -- yield and wait for buckets.
    while bucket do -- For each bucket, do...
        local output = r:escape_html(bucket) -- Escape all output
        coroutine.yield(output) -- Send converted data down the chain
    end
    -- No more buckets available.
end</pre>

<p>与输入过滤器一样，如果认为不希望使用，则输出过滤器支持拒绝/跳过过滤器：</p>
<pre class="prettyprint lang-lua">function output_filter(r)
    if not r.content_type:match("text/html") then
        return -- Simply deny filtering, passing on the original content instead
    end
    coroutine.yield() -- wait for buckets
    ... -- insert filter stuff here
end</pre>

<div class="note"><h3>带有<code class="module"><a href="../mod/mod_filter.html">mod_filter</a></code> Lua过滤器</h3>
<p>当通过<code class="directive"><a href="../mod/mod_filter.html#filterprovider">FilterProvider</a></code>指令将Lua过滤器用作基础提供程序时，仅在<var>filter-name</var>与<var>provider-name</var>相同时才进行<var>过滤</var> 。
</p> </div>

<p>有关更多信息，请参见“ <a href="#modifying_buckets">使用Lua过滤器修改内容</a> ”。
</p>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaPackageCPath" id="LuaPackageCPath">LuaPackageCPath</a> <a name="luapackagecpath" id="luapackagecpath">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>在lua的package.cpath中添加一个目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaPackageCPath /路径/到/包含/?.soa</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>将路径添加到lua的共享库搜索路径。遵循与lua相同的约定。这只是在lua vms中修改了package.cpath。</p>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaPackagePath" id="LuaPackagePath">LuaPackagePath</a> <a name="luapackagepath" id="luapackagepath">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>在lua的package.path中添加目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaPackagePath /路径/到/包含/?.lua</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table><p>将路径添加到lua的模块搜索路径。遵循与lua相同的约定。这只是在lua vms中修改了package.path。</p>

    <div class="example"><h3>例子：</h3><pre class="prettyprint lang-config">LuaPackagePath "/scripts/lib/?.lua"
LuaPackagePath "/scripts/lib/?/init.lua"</pre>
</div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaQuickHandler" id="LuaQuickHandler">LuaQuickHandler</a> <a name="luaquickhandler" id="luaquickhandler">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>为请求处理的快速处理程序提供一个挂钩</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaQuickHandler /path/to/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>该阶段在将请求映射到病毒宿主后立即运行，可用于在其他阶段启动之前执行一些请求处理，或用于无需转换而将请求映射到存储等。由于此阶段先于其他任何阶段运行，因此像<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>或<code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>这样的指令在此阶段中是无效的，就像尚未正确解析URI一样。
    </p>
   <div class="note"><h3>语境</h3><p>该指令在<code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code> ， <code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>或htaccess上下文中无效。</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaRoot" id="LuaRoot">LuaRoot</a> <a name="luaroot" id="luaroot">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>指定用于解析mod_lua指令的相对路径的基本路径</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaRoot /路径/到/一个/目录</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>指定将用于评估mod_lua中所有相对路径的基本路径。如果未指定，它们将相对于当前工作目录进行解析，这对于服务器而言可能并不总是能正常工作。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="LuaScope" id="LuaScope">LuaScope</a> <a name="luascope" id="luascope">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>一次，request，conn，thread之一-默认为一次</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>LuaScope一次|请求| conn |线程|服务器[最小] [最大]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>LuaScope一次</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录，.htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆写：</a></th><td>所有</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>实验性</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_lua</td></tr>
</table>
    <p>在此“目录”中，指定处理程序将使用的Lua解释器的生命周期范围。默认值为“一次”</p>

   <dl>
    <dt>一旦：</dt> <dd>一次使用解释器，将其丢弃。</dd>

    <dt>请求：</dt> <dd>使用解释器来处理基于此请求中相同文件的任何内容，该文件也属于请求范围。</dd>

    <dt>conn：</dt> <dd>与请求相同，但附加到connection_rec</dd>

    <dt>线：</dt> <dd>在处理请求的线程的生存期内使用解释器（仅适用于线程MPM）。</dd>

    <dt>服务器：</dt>  <dd>此服务器与其他服务器有所不同，因为服务器范围的寿命很长，并且多个线程将具有相同的server_rec。为了适应这种情况，服务器范围的Lua状态存储在apr资源列表中。<code>min</code>和<code>max</code>参数指定要保留在池中的Lua状态的最小和最大数目。</dd>
   </dl>
    <p>一般而言， <code>thread</code>和<code>server</code>范围的执行速度大约比其余范围快2-3倍，因为它们不必在每个请求上都产生新的Lua状态（尤其是在事件MPM时，因为即使keepalive请求也将使用新线程来执行）每个请求）。如果您对脚本在重用状态时不会遇到问题感到满意，则应使用<code>thread</code>或<code>server</code>作用域来获得最佳性能。尽管<code>thread</code>作用域将提供最快的响应，但是<code>server</code>池作用域将被合并，因此<code>server</code>作用域将使用较少的内存，从而使fx 1000个线程仅共享100个Lua状态，因此仅使用<code>thread</code>作用域所需的10％的内存。
    </p>

</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>