<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>mod_proxy-Apache HTTP服务器版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body >
<div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP服务器</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.4</a> &gt; <a href="./index.html">模块</a></div>
<div id="page-content">
<div id="preamble"><h1>Apache模块mod_proxy</h1>

<table class="module"><tr><th><a href="module-dict.html#Description">描述：</a></th><td>多协议代理/网关服务器</td></tr>
<tr><th><a href="module-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块标识符：</a></th><td>proxy_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件：</a></th><td>mod_proxy.c</td></tr></table>
<h3>摘要</h3>

    <div class="warning"><h3>警告</h3>
      <p>在<a href="#access">确保服务器安全</a>之前，请勿使用<code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>启用代理。开放式代理服务器对您的网络和整个Internet都是危险的。</p>
    </div>

    <p><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>和相关模块为Apache HTTP Server实现代理/网关，支持许多流行的协议以及几种不同的负载平衡算法。第三方模块可以添加对其他协议和负载平衡算法的支持。</p>

    <p>必须将一组模块加载到服务器中以提供必要的功能。这些模块可以在构建时静态包含，也可以通过<code class="directive"><a href="../mod/mod_so.html#loadmodule">LoadModule</a></code>指令动态包含。该集合必须包括：</p>

    <ul>
      <li><code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code> ，提供基本的代理功能</li>

      <li>如果需要负载平衡，则为<code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code>和一个或多个平衡器模块。（有关更多信息，请参见<code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code> 。）</li>

      <li>一个或多个代理方案或协议模块：<table class="bordered">
        <tr><th>协议</th><th>模组</th></tr>
        <tr><td>AJP13（Apache JServe协议版本1.3）</td><td><code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code></td></tr>
        <tr><td>CONNECT（用于SSL）</td><td><code class="module"><a href="../mod/mod_proxy_connect.html">mod_proxy_connect</a></code></td></tr>
        <tr><td>快速CGI</td><td><code class="module"><a href="../mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a></code></td></tr>
        <tr><td>ftp</td><td><code class="module"><a href="../mod/mod_proxy_ftp.html">mod_proxy_ftp</a></code></td></tr>
        <tr><td>HTTP / 0.9，HTTP / 1.0和HTTP / 1.1</td><td><code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code></td></tr>
        <tr><td>地理信息系统</td><td><code class="module"><a href="../mod/mod_proxy_scgi.html">mod_proxy_scgi</a></code></td></tr>
        <tr><td>WS和WSS（Web套接字）</td><td><code class="module"><a href="../mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel</a></code></td></tr>
        </table>
      </li>
    </ul>

    <p>另外，其他模块提供了扩展功能。缓存由<code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code>和相关模块提供。<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>的<code>SSLProxy*</code>伪指令提供了使用SSL / TLS协议联系远程服务器的能力。这些附加模块将需要加载和配置以利用这些功能。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><h3>话题</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif"> <a href="#forwardreverse">正向代理和反向代理/网关</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#examples">基本范例</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#handler">通过处理程序访问</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#workers">工作人员</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#access">控制对代理的访问</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#startup">启动缓慢</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#intranet">内网代理</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#envsettings">协议调整</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#request-bodies">要求机构</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#x-headers">反向代理请求标头</a></li>
</ul><h3 class="directives">指令</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif"> <a href="#balancergrowth">平衡器增长</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#balancerinherit">平衡器继承</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#balancermember">平衡器成员</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#balancerpersist">保持平衡</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#noproxy">无代理</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxy">&lt;代理&gt;</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyaddheaders">ProxyAddHeaders</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxybadheader">ProxyBadHeader</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyblock">代理块</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxydomain">代理域</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyerroroverride">ProxyErrorOverride</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyiobuffersize">ProxyIOBufferSize</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxymatch">&lt;ProxyMatch&gt;</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxymaxforwards">ProxyMaxForwards</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypass">代理通行证</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassinherit">ProxyPassInherit</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassinterpolateenv">ProxyPassInterpolateEnv</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassmatch">ProxyPassMatch</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassreverse">ProxyPassReverse</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassreversecookiedomain">ProxyPassReverseCookieDomain</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypassreversecookiepath">ProxyPassReverseCookiePath</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxypreservehost">ProxyPreserveHost</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyreceivebuffersize">ProxyReceiveBufferSize</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyremote">代理远程</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyremotematch">ProxyRemoteMatch</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyrequests">代理请求</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyset">代理集</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxysourceaddress">ProxySourceAddress</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxystatus">代理状态</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxytimeout">代理超时</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxyvia">代理人</a></li>
</ul>
<h3>错误修正清单</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">httpd更新日志</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache httpd-2&amp;query_format=specific&amp;order=changeddate DESC%2Cpriority%2Cbug_severity&amp;component=mod_proxy">已知的问题</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache httpd-2&amp;component=mod_proxy">报告错误</a></li></ul><h3>也可以看看</h3>
<ul class="seealso">
<li><code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_connect.html">mod_proxy_connect</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_ftp.html">mod_proxy_ftp</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_scgi.html">mod_proxy_scgi</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel</a></code></li>
<li><code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code></li>
<li><code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="forwardreverse" id="forwardreverse">正向代理和反向代理/网关</a></h2>
      <p>可以在<dfn>正向</dfn>和<dfn>反向</dfn>代理（也称为<dfn>网关</dfn> ）模式下配置Apache HTTP Server。</p>

      <p>普通<dfn>转发代理</dfn>是位于客户端和<em>原始服务器</em>之间的中间<em>服务器</em> 。为了从原始服务器获取内容，客户端向代理发送请求，将原始服务器命名为目标。然后，代理从源服务器请求内容，并将其返回给客户端。必须将客户端特别配置为使用转发代理访问其他站点。</p>

      <p>转发代理的典型用法是为内部客户端提供Internet访问，否则这些客户端会受到防火墙的限制。转发代理还可以使用缓存（由<code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code>提供）来减少网络使用量。</p>

      <p>使用<code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>指令激活转发代理。由于转发代理允许客户端通过您的服务器访问任意站点并隐藏其真实来源，因此必须<a href="#access">保护服务器的安全，</a>以便只有授权的客户端才能访问代理，然后再激活转发代理。</p>

      <p><dfn>相反，反向代理</dfn> （或<dfn>网关</dfn> ）对客户端来说就像普通的Web服务器一样。客户端上不需要特殊配置。客户端在反向代理的名称空间中对内容进行普通请求。然后，反向代理决定将这些请求发送到哪里，并像返回内容本身一样返回内容。</p>

      <p>反向代理的典型用法是为Internet用户提供对位于防火墙后面的服务器的访问。反向代理还可以用于平衡多个后端服务器之间的负载或为较慢的后端服务器提供缓存。此外，反向代理可以简单地用于将多个服务器带入相同的URL空间。</p>

      <p>使用<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令或<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>指令的<code>[P]</code>标志来激活反向代理。这是<strong>没有</strong>必要把<code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>以配置反向代理服务器上。</p>
    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="examples" id="examples">基本范例</a></h2>

    <p>下面的示例只是一个非常基本的想法，可以帮助您入门。请阅读有关各个指令的文档。</p>

    <p>另外，如果您希望启用缓存，请查阅<code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code>的文档。</p>

    <div class="example"><h3>反向代理</h3><pre class="prettyprint lang-config">ProxyPass "/foo" "http://foo.example.com/bar"
ProxyPassReverse "/foo" "http://foo.example.com/bar"</pre>
</div>

    <div class="example"><h3>转发代理</h3><pre class="prettyprint lang-config">ProxyRequests On
ProxyVia On

&lt;Proxy "*"&gt;
  Require host internal.example.com
&lt;/Proxy&gt;</pre>
</div>
    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="handler" id="handler">通过处理程序访问</a></h2>

      <p>您还可以通过创建合适的处理程序传递来强制将请求作为反向代理请求进行处理。下面的示例配置将使用反向代理将对PHP脚本的所有请求传递到指定的FastCGI服务器：</p>

      <div class="example"><h3>反向代理PHP脚本</h3><pre class="prettyprint lang-config">&lt;FilesMatch "\.php$"&gt;
    # Unix sockets require 2.4.7 or later
    SetHandler  "proxy:unix:/path/to/app.sock|fcgi://localhost/"
&lt;/FilesMatch&gt;</pre>
</div>

      <p>Apache HTTP Server 2.4.10和更高版本中提供了此功能。</p>

    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="workers" id="workers">工作人员</a></h2>
      <p>代理在称为<dfn>worker的</dfn>对象中管理原始服务器的配置及其通信参数。有两个内置工作器：默认的正向代理工作器和默认的反向代理工作器。可以明确配置其他工作程序。</p>

      <p>这两个默认工作程序具有固定的配置，如果没有其他工作程序匹配该请求，则将使用它们。他们不使用HTTP Keep-Alive或连接重用。相反，将针对每个请求打开和关闭与原始服务器的TCP连接。</p>

      <p>明确配置的工作程序由其URL标识。当用于反向代理时，通常使用<code class="directive"><a href="#proxypass">ProxyPass</a></code>或<code class="directive"><a href="#proxypassmatch">ProxyPassMatch</a></code>创建和配置它们：</p>

      <pre class="prettyprint lang-config">ProxyPass "/example" "http://backend.example.com" connectiontimeout=5 timeout=30</pre>


      <p>这将创建与原始服务器URL <code>http://backend.example.com</code>相关联的工作程序，该工作程序将使用给定的超时值。在正向代理中使用时，通常通过<code class="directive"><a href="#proxyset">ProxySet</a></code>指令定义<code class="directive"><a href="#proxyset">ProxySet</a></code>程序：</p>

      <pre class="prettyprint lang-config">ProxySet "http://backend.example.com" connectiontimeout=5 timeout=30</pre>


      <p>或使用<code class="directive"><a href="#proxy">Proxy</a></code>和<code class="directive"><a href="#proxyset">ProxySet</a></code> ：</p>

      <pre class="prettyprint lang-config">&lt;Proxy "http://backend.example.com"&gt;
  ProxySet connectiontimeout=5 timeout=30
&lt;/Proxy&gt;</pre>


      <p>在转发模式下使用显式配置的工作程序不是很常见，因为转发代理通常与许多不同的原始服务器通信。如果某些原始服务器经常使用，则为它们创建显式工作器仍然很有用。明确配置的工作人员本身没有正向或反向代理的概念。它们封装了与原始服务器通信的通用概念。每当原始服务器的URL与工作程序URL匹配时，由<code class="directive"><a href="#proxypass">ProxyPass</a></code>创建的用于反向代理的工作程序也将用于正向代理服务器请求，反之亦然。</p>

      <p>标识直接工作者的URL是其原始服务器的URL，包括给定的任何路径组件：</p>

     <pre class="prettyprint lang-config">ProxyPass "/examples" "http://backend.example.com/examples"
ProxyPass "/docs" "http://backend.example.com/docs"</pre>


      <p>本示例定义了两个不同的工作程序，每个工作程序都使用单独的连接池和配置。</p>

      <div class="warning"><h3>工人分享</h3>
        <p>如果工作程序URL重叠，则会发生工作程序共享，这是当某个工作程序的URL是稍后在配置文件中定义的另一个工作程序的URL的前导子串时发生的。在下面的例子中</p>

        <pre class="prettyprint lang-config">ProxyPass "/apps" "http://backend.example.com/" timeout=60
ProxyPass "/examples" "http://backend.example.com/examples" timeout=10</pre>


        <p>实际上没有创建第二个工作程序。而是使用第一个工作程序。好处是，只有一个连接池，因此连接经常被重用。请注意，将为以后的工作程序显式提供的所有配置属性都将被忽略。这将被记录为警告。在上面的示例中，URL <code>/examples</code>的最终超时值为<code>60</code>而不是<code>10</code> ！</p>

        <p>如果要避免共享工作程序，请按最长的工作程序URL开头的URL长度对工作程序定义进行排序。如果要最大程度地共享工作人员，请使用相反的排序顺序。另请参阅有关订购<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令的相关警告。</p>

      </div> 

      <p>明确配置的工作程序分为两种： <dfn>直接工作程序</dfn>和<dfn>（负载）平衡程序工作程序</dfn> 。它们支持许多重要的配置属性，下面在<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令中对其进行了描述。也可以使用<code class="directive"><a href="#proxyset">ProxySet</a></code>设置相同的属性。</p>

      <p>直接工作者可用的选项集取决于原始服务器URL中指定的协议。可用的协议包括<code>ajp</code> ， <code>fcgi</code> ， <code>ftp</code> ， <code>http</code>和<code>scgi</code> 。</p>

      <p>平衡器工人是虚拟工人，他们使用直接工人（称为成员）来实际处理请求。每个平衡器可以有多个成员。处理请求时，它将根据配置的负载平衡算法选择一个成员。</p>

      <p>如果均衡器工作程序的URL使用<code>balancer</code>作为协议方案，则将创建一个均衡器工作程序。平衡器URL唯一标识平衡器工作程序。使用<code class="directive"><a href="#balancermember">BalancerMember</a></code>将成员添加到<code class="directive"><a href="#balancermember">BalancerMember</a></code> 。</p>

      <div class="note"><h3>原始域的DNS解析</h3>
      <p>首次创建到原始域的套接字时，会发生DNS解析。启用连接重用后，每个后端域在每个子进程中仅解析一次，并为所有其他连接进行缓存，直到子级被回收为止。在计划涉及后端域的DNS维护任务时，应考虑此信息。另请检查<code class="directive"><a href="#proxypass">ProxyPass</a></code>参数以获取有关连接重用的更多详细信息。
        </p>
      </div>

    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="access" id="access">控制对代理的访问</a></h2>
      <p>您可以控制谁可以通过<code class="directive"><a href="#proxy">&lt;Proxy&gt;</a></code>控制块访问代理，如以下示例所示：</p>

      <pre class="prettyprint lang-config">&lt;Proxy "*"&gt;
  Require ip 192.168.0
&lt;/Proxy&gt;</pre>


      <p>有关访问控制指令的更多信息，请参见<code class="module"><a href="../mod/mod_authz_host.html">mod_authz_host</a></code> 。</p>

      <p>如果您使用转发代理（使用<code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>指令），则严格限制访问权限至关重要。否则，任何客户端都可以使用您的服务器来访问任意主机，同时隐藏其真实身份。这对于您的网络和整个Internet都是危险的。使用反向代理时（将<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令与<code>ProxyRequests Off</code> ），访问控制的<code>ProxyRequests Off</code>不那么严格，因为客户端只能与您专门配置的主机联系。</p>

      <p><strong>另请参见</strong> <a href="mod_proxy_http.html#env">Proxy-Chain-Auth</a>环境变量。</p>

    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="startup" id="startup">启动缓慢</a></h2>
      <p>如果使用的是<code class="directive"><a href="#proxyblock">ProxyBlock</a></code>指令，则在启动过程中查找并缓存主机名的IP地址，以供以后进行匹配测试。这可能需要几秒钟（或更长时间），具体取决于主机名查找发生的速度。</p>
    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="intranet" id="intranet">内网代理</a></h2>
      <p>位于内部网中的Apache httpd代理服务器需要通过公司的防火墙转发外部请求（为此，配置<code class="directive"><a href="#proxyremote">ProxyRemote</a></code>指令以将相应的<var>方案</var>转发到防火墙代理）。但是，当它必须访问Intranet中的资源时，可以在访问主机时绕过防火墙。<code class="directive"><a href="#noproxy">NoProxy</a></code>指令对于指定哪些主机属于Intranet有用，应直接访问。</p>

      <p>内联网中的用户倾向于从其WWW请求中省略本地域名，从而请求使用“ http：// somehost /”而不是<code>http://somehost.example.com/</code> 。一些商业代理服务器允许他们摆脱这种情况，而只是处理请求，这意味着已配置的本地域。使用<code class="directive"><a href="#proxydomain">ProxyDomain</a></code>指令并将服务器<a href="#proxyrequests">配置为使用代理服务时</a> ，Apache httpd可以返回重定向响应，并将客户端发送到正确的标准服务器地址。这是首选方法，因为用户的书签文件将包含完全合格的主机。</p>
    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="envsettings" id="envsettings">协议调整</a></h2>
      <p>对于<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>将请求发送到无法正确实现keepalive或HTTP / 1.1的原始服务器的情况，有两个<a href="../env.html">环境变量</a>可以强制请求使用不具有keepalive的HTTP / 1.0。这些是通过<code class="directive"><a href="../mod/mod_env.html#setenv">SetEnv</a></code>指令设置的。</p>

      <p>这些是<code>force-proxy-request-1.0</code>和<code>proxy-nokeepalive</code>注释。</p>

      <pre class="prettyprint lang-config">&lt;Location "/buggyappserver/"&gt;
  ProxyPass "http://buggyappserver:7001/foo/"
  SetEnv force-proxy-request-1.0 1
  SetEnv proxy-nokeepalive 1
&lt;/Location&gt;</pre>


      <p>在2.4.26及更高版本中，可以将“ no-proxy”环境变量设置为禁用<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>处理当前请求。应该使用<code class="directive"><a href="../mod/mod_setenvif.html#setenvif">SetEnvIf</a></code>设置此变量，因为<code class="directive"><a href="../mod/mod_env.html#setenv">SetEnv</a></code>的评估还不够早。</p>

    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="request-bodies" id="request-bodies">要求机构</a></h2>

    <p>一些请求方法（例如POST）包括请求正文。HTTP协议要求包含正文的请求使用分块传输编码或发送<code>Content-Length</code>请求标头。将这些请求传递到原始服务器时， <code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code>将始终尝试发送<code>Content-Length</code> 。但是，如果主体很大，并且原始请求使用了分块编码，那么分块编码也可以在上游请求中使用。您可以使用<a href="../env.html">环境变量</a>控制此选择。设置<code>proxy-sendcl</code>可通过始终发送<code>Content-Length</code> <code>proxy-sendcl</code>确保与上游服务器的最大兼容性，而设置<code>proxy-sendchunked</code>通过使用分块编码来最大程度地减少资源使用。</p>

    <p>在某些情况下，服务器必须将请求正文后台处理到磁盘上，以满足请求的请求正文处理。例如，如果原始正文是通过分块编码发送的（并且很大），但是管理员已要求使用Content-Length或HTTP / 1.0发送后端请求，则将发生假脱机。如果请求正文已具有Content-Length标头，但服务器已配置为过滤传入的请求正文，则也可能发生假脱机。</p>

    <p><code class="directive"><a href="../mod/core.html#limitrequestbody">LimitRequestBody</a></code>仅适用于服务器将后台处理到磁盘的请求正文</p>

    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="x-headers" id="x-headers">反向代理请求标头</a></h2>

    <p>当在反向代理模式下工作时（例如，使用<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令）， <code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code>添加多个请求标头，以便将信息传递到原始服务器。这些标题是：</p>

    <dl>
      <dt><code>X转发</code></dt>
      <dd>客户端的IP地址。</dd>
      <dt><code>X转发主机</code></dt>
      <dd>客户端在<code>Host</code> HTTP请求标头中请求的原始主机。</dd>
      <dt><code>X转发服务器</code></dt>
      <dd>代理服务器的主机名。</dd>
    </dl>

    <p>在原始服务器上使用这些标头时要小心，因为如果原始请求中已经包含这些标头之一，则它们将包含多个（逗号分隔）值。例如，您可以在原始服务器的日志格式字符串中使用<code>%{X-Forwarded-For}i</code>来记录原始客户端IP地址，但是如果请求通过多个代理，则可能会获得多个地址。</p>

    <p>另请参见<code class="directive"><a href="#proxypreservehost">ProxyPreserveHost</a></code>和<code class="directive"><a href="#proxyvia">ProxyVia</a></code>指令，它们控制其他请求标头。</p>

    <p>注意：如果需要指定要添加到转发的请求中的自定义请求标头，请使用<code class="directive"><a href="../mod/mod_headers.html#requestheader">RequestHeader</a></code>指令。</p>

   </div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="BalancerGrowth" id="BalancerGrowth">平衡器增长</a> <a name="balancergrowth" id="balancergrowth">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>配置后可以添加的其他均衡器数量</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>平衡器增长<var>＃</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>平衡器增长5</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>BalancerGrowth仅在Apache HTTP Server 2.3.13和更高版本中可用。</td></tr>
</table>
    <p>除了预配置的数量外，该指令还可以增加虚拟主机可用的均衡器数量的增长潜力。仅在至少有一个预配置的Balancer时才生效。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="BalancerInherit" id="BalancerInherit">平衡器继承</a> <a name="balancerinherit" id="balancerinherit">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>从主服务器继承ProxyPassed Balancer / Workers</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>BalancerInherit On | Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>平衡器继承</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>BalancerInherit仅在Apache HTTP Server 2.4.5和更高版本中可用。</td></tr>
</table>
        <p>该指令将导致当前服务器/虚拟主机“继承”主服务器中定义的ProxyPass平衡器和工作器。如果使用Balancer Manager，这可能会导致问题和不一致的行为，因此，如果使用该功能，应将其禁用。</p>
        <p>全局服务器中的设置定义了所有虚拟主机的默认设置。</p>
    
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="BalancerMember" id="BalancerMember">平衡器成员</a> <a name="balancermember" id="balancermember">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将成员添加到负载均衡组</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>BalancerMember [ <var>balancerurl</var> ] <var>url</var> [ <var>键=值[键=值...]]</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>BalancerMember仅在Apache HTTP Server 2.2和更高版本中可用。</td></tr>
</table>
        <p>该指令将成员添加到负载平衡组。它可以在<code>&lt;Proxy <var>balancer://</var> ...&gt;</code>容器指令中使用，并且可以采用<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令可用的任何键值对参数。</p>
        <p>另外一个参数仅可用于<code class="directive">BalancerMember</code>指令： <var>loadfactor</var> 。这是成员负载系数-十进制数字，介于1.0（默认值）和100.0之间，它定义了要施加到所讨论成员的加权负载。</p>
        <p>时，才需要在<var>balancerurl</var>时不是一个内<code>&lt;Proxy <var>balancer://</var> ...&gt;</code>容器指令。它对应于<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令中定义的平衡器的url。</p>
        <p>任何<code>&lt;Proxy <var>balancer://</var> ...&gt;</code>容器指令中的平衡器URL的路径部分都将被忽略。</p>
        <p>通常应从<code class="directive">BalancerMember</code>的URL中删除斜杠。</p>
    
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="BalancerPersist" id="BalancerPersist">平衡器持久性</a> <a name="balancerpersist" id="balancerpersist">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>尝试在重新启动期间持久保存Balancer Manager所做的更改。</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>平衡器持续开启|关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>平衡器关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>BalancerPersist仅在Apache HTTP Server 2.4.4和更高版本中可用。</td></tr>
</table>
        <p>该指令将导致与平衡器和平衡器成员相关联的共享内存存储在重新启动后得以保留。这样，在正常的重新启动/正常状态转换期间，这些本地更改不会丢失。</p>
    
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="NoProxy" id="NoProxy">NoProxy</a> <a name="noproxy" id="noproxy">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将直接连接的主机，域或网络</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>NoProxy <var>主机</var> [ <var>主机</var> ] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>该指令仅对内部网中的Apache httpd代理服务器有用。<code class="directive">NoProxy</code>指令指定子网，IP地址，主机和/或域的列表，以空格分隔。与主机中的一个或多个主机匹配的请求始终直接得到服务，而不会转发到已配置的<code class="directive"><a href="#proxyremote">ProxyRemote</a></code>代理服务器。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyRemote  "*"  "http://firewall.example.com:81"
NoProxy         ".example.com" "192.168.112.0/21"</pre>
</div>

    <p><code class="directive">NoProxy</code>指令的<var>主机</var>参数是以下类型列表之一：</p>

    <dl>
    
    <dt><var><a name="domain" id="domain">域</a></var></dt>
    <dd>
    <p><dfn>域</dfn>是部分合格的DNS域名，后跟一个句点。它表示逻辑上属于同一DNS域或区域的主机的列表（ <em>即</em> ，主机名的后缀均以<var>Domain</var>结尾）。</p>

    <div class="example"><h3>例子</h3><p><code>.com .example.org。
    </code></p></div>

    <p>为了区分<var>Domain</var>和<var><a href="#hostname">Hostname</a></var> （在语法和语义上； DNS域也可以有DNS A记录！）， <var>Domain</var>始终以前置句号编写。</p>

    <div class="note"><h3>注意</h3>
      <p>进行域名比较时不考虑大小写，并且始终假定<var>Domain</var>锚定在DNS树的根中。因此，这两个域<code>.ExAmple.com</code>和<code>.example.com.</code> （请注意尾随时间段）被视为相等。由于域比较不涉及DNS查找，因此它比子网比较有效得多。</p>
    </div></dd>

    
    <dt><var><a name="subnet" id="subnet">子网</a></var></dt>
    <dd>
    <p><dfn>子网</dfn>是数字（点分四边形）形式的部分合格的互联网地址，可以选择在其后跟斜杠和网络掩码，指定为<var>子网中</var>的有效位数。它用于表示可以通过通用网络接口访问的主机的子网。在没有显式网络掩码的情况下，假定省略（或零值）尾随数字指定掩码。（在这种情况下，网络掩码只能是8位宽的倍数。）例子：</p>

    <dl>
    <dt><code>192.168</code>或<code>192.168.0.0</code></dt>
    <dd>子网192.168.0.0具有16个有效位的隐式网络掩码（有时以<code>255.255.0.0</code>的网络掩码形式使用）</dd>
    <dt><code>192.168.112.0/21</code></dt>
    <dd>子网<code>192.168.112.0/21</code> ，其网络掩码为21个有效位（也以<code>255.255.248.0</code>的形式使用）</dd>
    </dl>

    <p>作为简并情况下， <em>子网</em> 32的有效位是相当于一个<var><a href="#ipaddr">IPADDR</a></var> ，而<var>子网</var>具有零个有效位（ <em>例如</em> ，0.0.0.0/0）是一样的恒定<var>_Default_，</var>匹配的任何IP地址。</p></dd>

    
    <dt><var><a name="ipaddr" id="ipaddr">IP地址</a></var></dt>
    <dd>
    <p><dfn>IPAddr</dfn>以数字（点分四边形）形式表示完全合格的Internet地址。通常，此地址代表一台主机，但不一定需要将DNS域名与该地址连接。</p>
    <div class="example"><h3>例</h3><p><code>192.168.123.7</code></p></div>

    <div class="note"><h3>注意</h3>
      <p><var>IPAddr</var>不需要由DNS系统解析，因此它可以导致更有效的Apache性能。</p>
    </div></dd>

    
    <dt><var><a name="hostname" id="hostname">主机名</a></var></dt>
    <dd>
    <p><dfn>主机名</dfn>是完全合格的DNS域名，可以通过DNS域名服务将其解析为一个或多个<var><a href="#ipaddr">IPAddrs</a></var> 。它代表一个逻辑主机（与<var><a href="#domain">Domain</a></var>相比，请参见上文），并且必须至少可解析为一个<var><a href="#ipaddr">IPAddr</a></var> （或通常可解析为具有不同<var><a href="#ipaddr">IPAddr</a></var>的主机列表）。</p>

    <div class="example"><h3>例子</h3><p><code>prep.ai.example.edu<br>www.example.org</code></p></div>

    <div class="note"><h3>注意</h3>
      <p>在许多情况下，指定<var><a href="#ipaddr">IPAddr</a></var>代替<var>主机名</var>更为有效，因为可以避免DNS查找。当与名称服务器的连接使用慢速PPP链接时，Apache httpd中的名称解析可能会花费大量时间。</p>
      <p><var>主机名</var>比较是在不考虑大小写的情况下进行的，并且始终假定<var>主机名</var>锚定在DNS树的根中。因此，这两个主机是<code>WWW.ExAmple.com</code>和<code>www.example.com.</code> （请注意尾随时间段）被视为相等。</p>
     </div></dd>
    </dl>

<h3>也可以看看</h3>
<ul>
<li><a href="../dns-caveats.html">DNS问题</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="Proxy" id="Proxy">&lt;Proxy&gt;</a> <a name="proxy" id="proxy">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>适用于代理资源的指令的容器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>&lt;代理<var>通配符URL</var> &gt; ... &lt;/代理&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">&lt;Proxy&gt;</code>部分中放置的指令仅适用于匹配的代理内容。允许使用壳式通配符。</p>

    <p>例如，以下内容将仅允许<code>yournetwork.example.com</code>主机通过代理服务器访问内容：</p>

    <pre class="prettyprint lang-config">&lt;Proxy "*"&gt;
  Require host yournetwork.example.com
&lt;/Proxy&gt;</pre>


    <p>以下示例将在通过代理服务器发送文件时通过<code>INCLUDES</code>过滤器处理<code>example.com</code>的<code>foo</code>目录中的所有文件：</p>

   <pre class="prettyprint lang-config">&lt;Proxy "http://example.com/foo/*"&gt;
  SetOutputFilter INCLUDES
&lt;/Proxy&gt;</pre>


    <div class="note"><h3>与“位置配置”部分的不同</h3>
      <p>如果后端URL以<var>通配符URL</var>字符串开头，则它与配置节匹配，即使指令中的最后一个路径段仅匹配后端URL的前缀也是如此。例如，&lt;Proxy“ http://example.com/foo”&gt;匹配所有http://example.com/foo，http://example.com/foo/bar和http://example.com / foobar。最终URL的匹配与<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>部分的行为不同，在本注释中， <code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>部分的行为将最终路径组件视为以斜杠结尾。</p>
      <p>有关对匹配的更多控制，请参见<code class="directive">&lt;ProxyMatch&gt;</code> 。</p>
    </div>


<h3>也可以看看</h3>
<ul>
<li><code class="directive"><a href="#proxymatch">&lt;ProxyMatch&gt;</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyAddHeaders" id="ProxyAddHeaders">ProxyAddHeaders</a> <a name="proxyaddheaders" id="proxyaddheaders">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>在X-Forwarded- *标头中添加代理信息</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyAddHeaders关闭|打开</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyAddHeaders开启</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在2.3.10版和更高版本中可用</td></tr>
</table>
    <p>该指令确定是否应通过X-Forwarded-For，X-Forwarded-Host和X-Forwarded-Server HTTP标头将与代理相关的信息传递给后端服务器。</p>
    <div class="note"><h3>实效</h3>
     <p>该选项仅用于由<code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code>处理的HTTP代理。</p>
    </div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyBadHeader" id="ProxyBadHeader">ProxyBadHeader</a> <a name="proxybadheader" id="proxybadheader">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>确定如何处理响应中的错误标题行</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyBadHeader IsError |忽略| StartBody</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyBadHeader IsError</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>如果<code class="directive">ProxyBadHeader</code>指令从源服务器接收到语法上无效的响应头行（ <em>即</em> ，不包含冒号），则确定<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>的行为。以下参数是可能的：</p>

    <dl>
    <dt><code>IsError</code></dt>
    <dd>中止该请求并以502（错误网关）响应结束。这是默认行为。</dd>

    <dt><code>忽视</code></dt>
    <dd>将错误的标题行视为未发送。</dd>

    <dt><code>StartBody</code></dt>
    <dd>当收到第一行错误的标题行时，请完成读取标题并将其余部分视为正文。这有助于解决有问题的后端服务器，这些服务器忘记在标头和正文之间插入空行。</dd>
    </dl>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyBlock" id="ProxyBlock">ProxyBlock</a> <a name="proxyblock" id="proxyblock">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>禁止代理的单词，主机或域</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyBlock * | <var>字</var> | <var>主机</var> | <var>域</var> [ <var>单词</var> | <var>主机</var> | <var>域</var> ] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyBlock</code>指令指定由空格分隔的单词，主机和/或域的列表。对名称包含匹配的单词，主机或域的站点的HTTP，HTTPS和FTP文档请求<em>被</em>代理服务器<em>阻止</em> 。代理模块还将尝试确定启动时可能是主机名的列表项的IP地址，并将其缓存以进行匹配测试。这可能会减慢服务器的启动时间。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyBlock "news.example.com" "auctions.example.com" "friends.example.com"</pre>
</div>

    <p>请注意，该<code>example</code>也足以匹配任何这些站点。</p>

    <p>如果IP地址引用了主机，主机也将匹配。</p>

    <p>另请注意</p>

    <pre class="prettyprint lang-config">ProxyBlock "*"</pre>


    <p>阻止与所有站点的连接。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyDomain" id="ProxyDomain">ProxyDomain</a> <a name="proxydomain" id="proxydomain">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>代理请求的默认域名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyDomain <var>域</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>该指令仅对内部网中的Apache httpd代理服务器有用。<code class="directive">ProxyDomain</code>指令指定apache代理服务器将属于的默认域。如果遇到对没有域名的主机的请求，将生成对附加了配置的<var>域</var>的同一主机的重定向响应。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyRemote  "*"  "http://firewall.example.com:81"
NoProxy         ".example.com" "192.168.112.0/21"
ProxyDomain     ".example.com"</pre>
</div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyErrorOverride" id="ProxyErrorOverride">ProxyErrorOverride</a> <a name="proxyerroroverride" id="proxyerroroverride">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>覆盖代理内容的错误页面</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyErrorOverride开|关</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyErrorOverride关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令对于要在最终用户看到的错误页面上具有通用外观的反向代理设置很有用。这也允许包含的文件（通过<code class="module"><a href="../mod/mod_include.html">mod_include</a></code>的SSI）获取错误代码并采取相应措施。（默认行为将显示代理服务器的错误页面。启用它会显示SSI错误消息。）</p>

    <p>该指令不影响信息性（1xx），正常成功（2xx）或重定向（3xx）响应的处理。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyIOBufferSize" id="ProxyIOBufferSize">ProxyIOBufferSize</a> <a name="proxyiobuffersize" id="proxyiobuffersize">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>确定内部数据吞吐量缓冲区的大小</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyIOBufferSize <var>字节</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyIOBufferSize 8192</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyIOBufferSize</code>指令调整内部缓冲区的大小，该缓冲区用作输入和输出之间数据的暂存器。大小必须至少为<code>512</code> 。</p>

    <p>在几乎每种情况下，都没有理由更改该值。</p>

    <p>如果与AJP一起使用，则此伪指令设置最大AJP数据包大小（以字节为单位）。大于65536的值设置为65536。如果将其更改为默认值，则还必须在Tomcat端更改AJP连接器的<code>packetSize</code>属性！属性<code>packetSize</code>仅在Tomcat <code>5.5.20+</code>和<code>6.0.2+</code></p>

    <p>通常，没有必要更改最大数据包大小。发送证书或证书链时，已报告默认值问题。</p>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyMatch" id="ProxyMatch">&lt;ProxyMatch&gt;</a> <a name="proxymatch" id="proxymatch">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>适用于正则表达式匹配的代理资源的指令的容器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>&lt;ProxyMatch <var>正则表达式</var> &gt; ... &lt;/ ProxyMatch&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">&lt;ProxyMatch&gt;</code>指令与<code class="directive"><a href="#proxy">&lt;Proxy&gt;</a></code>指令相同， <code class="directive">&lt;ProxyMatch&gt;</code>在于它使用<a class="glossarylink" href="../glossary.html#regex" title="见词汇">正则表达式</a>匹配URL。</p>

    <p>从2.4.8开始，将捕获命名的组和反向引用，并将其以大写的前缀“ MATCH_”的相应名称写入环境。这允许从<a href="../expr.html">表达式</a>和模块（例如<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>引用URL的元素。为了避免混淆，将忽略编号（未命名）的反向引用。请改用命名组。</p>

<pre class="prettyprint lang-config">&lt;ProxyMatch "^http://(?&lt;sitename&gt;[^/]+)"&gt;
    Require ldap-group cn=%{env:MATCH_SITENAME},ou=combined,o=Example
&lt;/ProxyMatch&gt;</pre>


<h3>也可以看看</h3>
<ul>
<li><code class="directive"><a href="#proxy">&lt;代理&gt;</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyMaxForwards" id="ProxyMaxForwards">ProxyMaxForwards</a> <a name="proxymaxforwards" id="proxymaxforwards">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>可以转发请求的最大代理数量</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyMaxForwards <var>号码</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyMaxForwards -1</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>默认行为已在2.2.7中更改</td></tr>
</table>
    <p><code class="directive">ProxyMaxForwards</code>指令指定如果请求不提供<code>Max-Forwards</code>标头，则请求可以通过的最大代理数。可以设置此项以防止无限代理循环或DoS攻击。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyMaxForwards 15</pre>
</div>

    <p>请注意，设置<code class="directive">ProxyMaxForwards</code>违反了HTTP / 1.1协议（RFC2616），如果客户端未进行设置，则该设置将禁止Proxy设置<code>Max-Forwards</code> 。早期的Apache httpd版本将始终对其进行设置。负的<code class="directive">ProxyMaxForwards</code>值（包括默认值-1）为您提供了符合协议的行为，但可能使您<code class="directive">ProxyMaxForwards</code>循环。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPass" id="ProxyPass">ProxyPass</a> <a name="proxypass" id="proxypass">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>将远程服务器映射到本地服务器URL空间</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPass [ <var>路径</var> ]！| <var>url</var> [ <var>键=值</var> <var>[键=值</var> ...]] [nocanon] [插值] [noquery]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>2.4.7中添加了Unix域套接字（UDS）支持</td></tr>
</table>
    <p>该指令允许将远程服务器映射到本地服务器的空间。本地服务器在常规意义上不充当代理，而似乎是远程服务器的镜像。本地服务器通常称为<dfn>反向代理</dfn>或<dfn>网关</dfn> 。<var>路径</var>是本地虚拟路径的名称； <var>url</var>是远程服务器的部分URL，不能包含查询字符串。</p>

    <div class="note">强烈建议在继续执行本节之前，先回顾一下“ <a href="#workers">工人”</a>的概念。</div>

    <div class="note"><code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>和<code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>容器不支持此指令。</div>

    <div class="warning">使用<code class="directive">ProxyPass</code>时，通常应<strong>关闭</strong> <code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>指令。</div>

    <p>在2.4.7及更高版本中，可以通过使用在<code>unix:/path/lis.sock|</code>前面加上一个目标来支持使用Unix域套接字<code>unix:/path/lis.sock|</code> 。例如，要代理HTTP并将UDS定位于/ home / www / socket，则可以使用<code>unix:/home/www.socket|http://localhost/whatever/</code> 。</p>

    <div class="note"><strong>注意：</strong>与<code>unix:</code> URL关联的路径支持<code class="directive">DefaultRuntimeDir</code> 。</div>

    <p>在<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>节中使用时，将省略第一个参数，并从<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>获取本地目录。在<code class="directive"><a href="../mod/core.html#locationmatch">&lt;LocationMatch&gt;</a></code>部分中也会发生同样的情况；但是，ProxyPass不会这样解释正则表达式，因此有必要在这种情况下使用<code class="directive">ProxyPassMatch</code> 。</p>

    <p>假设本地服务器的地址为<code>http://example.com/</code> ;然后</p>

    <pre class="prettyprint lang-config">&lt;Location "/mirror/foo/"&gt;
    ProxyPass "http://backend.example.com/"
&lt;/Location&gt;</pre>


    <p>会导致对<code>http://example.com/mirror/foo/bar</code>的本地请求在内部转换为对<code>http://backend.example.com/bar</code>的代理请求。</p>

    <p>如果您需要更灵活的反向代理配置，请参阅带有<code>[P]</code>标志的<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>指令。</p>

    <p>以下替代语法是可能的；但是，当数量很大时，它可能会降低性能。以下语法的优点是它允许通过<a href="mod_proxy_balancer.html#balancer_manager">Balancer Manager</a>界面进行动态控制：</p>

    <pre class="prettyprint lang-config">ProxyPass "/mirror/foo/" "http://backend.example.com/"</pre>


    <div class="warning">
    <p>如果第一个参数以<strong>/</strong>结尾，则第二个参数也应以<strong>/</strong>结尾，反之亦然。否则，对后端的最终请求可能会错过一些所需的斜杠，并且不会传递预期的结果。
    </p>
    </div>

    <p><code>!</code> 伪指令在您不想反向代理子目录的情况下很有用， <em>例如</em></p>

    <pre class="prettyprint lang-config">&lt;Location "/mirror/foo/"&gt;
    ProxyPass "http://backend.example.com/"
&lt;/Location&gt;
&lt;Location "/mirror/foo/i"&gt;
    ProxyPass "!"
&lt;/Location&gt;</pre>


    <pre class="prettyprint lang-config">ProxyPass "/mirror/foo/i" "!"
ProxyPass "/mirror/foo" "http://backend.example.com"</pre>


    <p>会将对<code>/mirror/foo</code>所有请求代理到<code>backend.example.com</code> ，对<code>/mirror/foo/i</code>请求<em>除外</em> 。</p>

    <div class="warning"><h3>订购ProxyPass指令</h3>
      <p>按照配置顺序检查已配置的<code class="directive"><a href="#proxypass">ProxyPass</a></code>和<code class="directive"><a href="#proxypassmatch">ProxyPassMatch</a></code>规则。匹配的第一个规则获胜。因此，通常您应该首先从最长的URL开始对有冲突的<code class="directive"><a href="#proxypass">ProxyPass</a></code>规则进行排序。否则，任何使用URL前导子串的早期规则将隐藏更长URL的以后规则。请注意，与工人共享有一些关系。相反，在<code class="directive"><a href="../mod/core.html#location">Location</a></code>块中只能放置一个<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令，并且最特定的位置优先。</p>

      <p>出于相同的原因，排除项必须位于常规<code class="directive">ProxyPass</code>指令<em>之前</em> 。在2.4.26及更高版本中，“ no-proxy”环境变量是排除的替代方法，并且是在<code class="directive"><a href="../mod/core.html#location">Location</a></code>上下文中配置<code class="directive">ProxyPass</code>指令的排除的唯一方法。应该使用<code class="directive"><a href="../mod/mod_setenvif.html#setenvif">SetEnvIf</a></code>设置此变量，因为<code class="directive"><a href="../mod/mod_env.html#setenv">SetEnv</a></code>的评估还不够早。
      </p>

    </div> 

    <p><strong>ProxyPass <code>key=value</code>参数</strong></p>

    <p>在Apache HTTP Server 2.1和更高版本中，mod_proxy支持与后端服务器的池化连接。可将按需创建的连接保留在池中以备将来使用。可以使用<code>key=value</code>参数在<code class="directive">ProxyPass</code>指令上对池大小和其他设置的限制进行编码，如下表所述。</p>

    <div class="warning"><h3>与后端的最大连接数</h3>
    <p>默认情况下，mod_proxy将允许并保留该Web服务器子进程可以同时使用的最大连接数。使用<code>max</code>参数可以减少默认值。每个Web服务器子进程都会维护连接池，除非在配置或MPM设计中只允许一个子进程时，否则所有子进程之间都无法协调<code>max</code>和其他设置。</p>
    </div>

    <p>使用<code>ttl</code>参数设置可选的生存时间。至少<code>ttl</code>秒内未使用的连接将被关闭。 <code>ttl</code>可用于避免使用由于后端服务器的保持活动超时而可能关闭的连接。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyPass "/example" "http://backend.example.com" max=20 ttl=120 retry=300</pre>
</div>

    <table class="bordered"><tr><th>Worker | BalancerMember参数</th></tr></table>
    <table>
    <tr><th>参数</th>
        <th>默认</th>
        <th>描述</th></tr>
    <tr><td>分</td>
        <td>0</td>
        <td>连接池条目的最小数量，与实际的连接数量无关。仅在特殊情况下才需要将其修改为默认值，在特殊情况下，应预先分配或保留与后端连接关联的堆内存。</td></tr>
    <tr><td>最高</td>
        <td>1 ... n</td>
        <td>后端服务器允许的最大连接数。此限制的默认值为活动MPM中每个进程的线程数。在Prefork MPM中，该值始终为1，而对于其他MPM，则由<code class="directive">ThreadsPerChild</code>指令控制。</td></tr>
    <tr><td>最大</td>
        <td>最高</td>
        <td>如果保留连接池条目的使用时间超过生存时间（由<code>ttl</code>参数控制），则超过此限制的保留连接池条目将在某些操作期间释放。如果连接池条目具有关联的连接，它将被关闭。仅在特殊情况下才需要将其修改为默认值，在特殊情况下，需要更积极地释放或关闭超过生存时间的连接池条目和任何关联的连接。</td></tr>
    <tr><td>获得</td>
        <td>--</td>
        <td>如果设置，这将是等待连接池中的空闲连接的最长时间，以毫秒为单位。如果池中没有可用的连接，则Apache httpd将向客户端返回<code>SERVER_BUSY</code>状态。
    </td></tr>
    <tr><td>连接超时</td>
        <td>超时</td>
        <td>连接超时（以秒为单位）。Apache httpd等待建立与后端的连接完成的秒数。通过添加ms的后缀，还可以以毫秒为单位设置超时。
    </td></tr>
    <tr><td>禁用重用</td>
        <td>关</td>
        <td>如果要在使用后强制mod_proxy立即关闭与后端的连接，从而禁用该后端的持久连接和池，则应使用此参数。这在各种情况下有帮助，在这种情况下，Apache httpd和后端服务器之间的防火墙（无论协议如何）倾向于无声地丢弃连接，或者后端本身可能处于循环DNS下。启用连接重用后，每个后端域（每个子进程）仅解析一次（使用DNS查询），并为所有进一步的连接进行缓存，直到子级被回收为止。要禁用连接重用，请将此属性值设置为<code>On</code> 。
    </td></tr>
    <tr><td>启用重用</td>
        <td>上</td>
        <td>这与上面的“ disablereuse”相反，它为需要选择加入连接重用的方案处理程序（例如<code class="module"><a href="../mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a></code> ）提供了便利。仅2.4.11及更高版本。
    </td></tr>
    <tr><td>冲洗包装</td>
        <td>关</td>
        <td>确定在每个“大块”数据之后，代理模块是否将自动刷新输出旅。 “ off”表示仅在需要时才冲洗； “打开”是指在发送每个块之后； “自动”表示轮询/等待一段时间，如果“ flushwait”毫秒未收到任何输入，则刷新。当前，这仅对mod_proxy_ajp和mod_proxy_fcgi有效。
    </td></tr>
    <tr><td>冲洗等待</td>
        <td>10</td>
        <td>如果“ flushpackets”为“ auto”，则在刷新输出旅之前等待额外输入的时间（以毫秒为单位）。
    </td></tr>
    <tr><td>iobuffersize</td>
        <td>8192</td>
        <td>调整内部暂存器IO缓冲区的大小。这使您可以覆盖特定工作程序的<code class="directive">ProxyIOBufferSize</code> 。对于系统默认值8192，此值必须至少为512或设置为0。
    </td></tr>
    <tr><td>活着</td>
        <td>关</td>
        <td><p>当您的Apache httpd和后端服务器之间有防火墙时，通常会丢弃不活动的连接，请使用此参数。该标志将告诉操作系统在不活动的连接上发送<code>KEEP_ALIVE</code>消息，从而防止防火墙断开连接。要启用keepalive，请将此属性值设置为<code>On</code> 。</p>
    <p>初始和后续TCP Keepalive探测的频率取决于全局OS设置，并且可能高达2小时。为了有用，操作系统中配置的频率必须小于防火墙使用的阈值。</p>
    </td></tr>
    <tr><td>磅</td>
        <td>0</td>
        <td>设置工作程序所属的负载均衡器集群集。负载平衡器将尝试使用编号较小的lbset的所有成员，然后再尝试编号较大的lbset的所有成员。
    </td></tr>
    <tr><td>ping</td>
        <td>0</td>
        <td>Ping属性告诉Web服务器在转发请求之前“测试”与后端的连接。对于AJP，它会导致<code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code>在ajp13连接上发送<code>CPING</code>请求（在Tomcat 3.3.2 +，4.1.28 +和5.0.13+上实现）。对于HTTP，它将导致<code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code>向后端发送<code>100-Continue</code> （仅对HTTP / 1.1有效-对于非HTTP / 1.1后端，此属性无效）。在这两种情况下，该参数都是等待答复的延迟（以秒为单位）。已添加此功能以避免后端挂起和繁忙。这将在正常操作期间增加网络流量，这可能是一个问题，但是在某些群集节点出现故障或繁忙的情况下，它将降低流量。通过添加ms的后缀，也可以以毫秒为单位设置延迟。
    </td></tr>
    <tr><td>接收缓冲区大小</td>
        <td>0</td>
        <td>调整代理连接的显式（TCP / IP）网络缓冲区大小。这使您可以覆盖特定工作程序的<code class="directive">ProxyReceiveBufferSize</code> 。对于系统默认值，该值必须至少为512或设置为0。
    </td></tr>
    <tr><td>重新导向</td>
        <td>--</td>
        <td>工作者的重定向路由。通常动态设置此值以启用从群集中安全删除节点的功能。如果设置，则所有没有会话ID的请求都将重定向到路由参数等于此值的BalancerMember。
    </td></tr>
    <tr><td>重试</td>
        <td>60</td>
        <td>连接池工作者重试超时（以秒为单位）。如果到后端服务器的连接池工作程序处于错误状态，则在超时到期之前，Apache httpd不会将任何请求转发到该服务器。这样可以关闭后端服务器以进行维护，并在以后使其重新联机。值0表示始终在没有超时的错误状态下重试工作线程。
    </td></tr>
    <tr><td>路线</td>
        <td>--</td>
        <td>在负载平衡器内部使用时的工作人员路线。路由是附加到会话ID的值。
    </td></tr>
    <tr><td>状态</td>
        <td>--</td>
        <td>单个字母值，定义此工作人员的初始状态。
        <table>
         <tr><td>D：工作者被禁用，将不接受任何请求。</td></tr>
         <tr><td>S：工人在管理上被停止。</td></tr>
         <tr><td>I：工作者处于忽略错误模式，将始终被视为可用。</td></tr>
         <tr><td>H：工作者处于热备用模式，仅在没有其他可行的工作者可用时才使用。</td></tr>
         <tr><td>E：工人处于错误状态。</td></tr>
         <tr><td>N：Worker处于耗尽模式，将仅接受发往其自身的现有粘性会话，而忽略所有其他请求。</td></tr>
        </table>可以通过在前面加上“ +”来设置状态（这是默认设置），也可以通过在前面加上“-”来清除状态。因此，设置为“ SE”将此工作程序设置为“已停止”，并清除错误中标志。
    </td></tr>
    <tr><td>超时</td>
        <td><code class="directive"><a href="#proxytimeout">代理超时</a></code></td>
        <td>连接超时（以秒为单位）。Apache httpd等待/发送到后端的数据的秒数。
    </td></tr>
    <tr><td>ttl</td>
        <td>--</td>
        <td>非活动连接和关联的连接池条目的生存时间（以秒为单位）。一旦达到此限制，将不再使用连接。它将在以后关闭。
    </td></tr>
    <tr><td>冲水器</td>
        <td>齐平</td>
        <td><p><code class="module"><a href="../mod/mod_proxy_fdpass.html">mod_proxy_fdpass</a></code>使用的提供程序的名称。有关更多详细信息，请参见此模块的文档。</p>
    </td></tr>
    <tr><td>秘密</td>
        <td>--</td>
        <td><p><code class="module"><a href="../mod/mod_proxy_ajp.html">mod_proxy_ajp</a></code>使用的秘密值。有关更多详细信息，请参见此模块的文档。</p>
    </td></tr>
    <tr><td>升级</td>
        <td>WebSocket</td>
        <td><p>升级头中的协议由<code class="module"><a href="../mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel</a></code>接受。有关更多详细信息，请参见此模块的文档。</p>
    </td></tr>

    </table>

    <p>如果Proxy指令方案以<code>balancer://</code>开头（例如， <code>balancer://cluster</code> ，则忽略任何路径信息），那么将创建一个实际上不与后端服务器通信的虚拟工作程序。相反，它负责管理多个“实际”工人。在这种情况下，可以将特殊的参数集添加到该虚拟工作程序。有关平衡器如何工作的更多信息，请参见<code class="module"><a href="../mod/mod_proxy_balancer.html">mod_proxy_balancer</a></code> 。
    </p>
    <table class="bordered"><tr><th>平衡器参数</th></tr></table>
    <table>
    <tr><th>参数</th>
        <th>默认</th>
        <th>描述</th></tr>
    <tr><td>磅法</td>
        <td>副要求</td>
        <td>平衡器负载平衡方法。选择要使用的负载平衡调度程序方法。要么<code>byrequests</code> ，执行加权请求计数； <code>bytraffic</code> ，执行加权的流量字节计数平衡；或<code>bybusyness</code> ，以执行待处理的请求平衡。默认值为<code>byrequests</code> 。
    </td></tr>
    <tr><td>最大尝试</td>
        <td>少于工人人数一个，或一个工人少于一个。</td>
        <td>放弃之前的最大故障转移尝试次数。
    </td></tr>
    <tr><td>无故障转移</td>
        <td>关</td>
        <td>如果设置为<code>On</code> ，则当工作程序处于错误状态或被禁用时，会话将中断。如果后端服务器不支持会话复制，则将此值设置为<code>On</code> 。
    </td></tr>
    <tr><td>粘性会话</td>
        <td>--</td>
        <td>平衡器粘性会话名称。该值通常设置为<code>JSESSIONID</code>或<code>PHPSESSIONID</code> ，它取决于支持会话的后端应用程序服务器。如果后端应用程序服务器对Cookie和URL编码的ID使用不同的名称（例如Servlet容器），请使用|分开他们。第一部分是cookie，第二部分是路径。<br>在Apache HTTP Server 2.4.4和更高版本中可用。
    </td></tr>
    <tr><td>粘性会话</td>
        <td>“。”</td>
        <td>在会话cookie中设置分隔符号。某些后端应用程序服务器不使用“。”作为符号。例如，Oracle Weblogic服务器使用'!！'。可以使用此选项设置正确的符号。设置为“关”表示不使用任何符号。
    </td></tr>
    <tr><td>scolonpathdelim</td>
        <td>关</td>
        <td>如果设置为<code>On</code> ，则分号字符“;”将用作附加的粘性会话路径定界符/分隔符。主要用于模拟处理诸如<code>JSESSIONID=6736bcf34;foo=aabfa</code>路径时mod_jk的行为
    </td></tr>
    <tr><td>超时</td>
        <td>0</td>
        <td>平衡器超时（以秒为单位）。如果设置，这将是等待自由工作者的最长时间。默认为不等待。
    </td></tr>
    <tr><td>故障状态</td>
        <td>--</td>
        <td>单个或逗号分隔的HTTP状态代码列表。如果设置，则当后端返回列表中的任何状态代码时，这将强制工作器进入错误状态。工作者恢复的行为与其他工作者错误相同。
    </td></tr>
    <tr><td>故障超时</td>
        <td>关</td>
        <td>如果设置，在将请求发送到后端后，IO读取超时将强制工作器进入错误状态。工作者恢复的行为与其他工作者错误相同。<br>在Apache HTTP Server 2.4.5和更高版本中可用。
    </td></tr>
    <tr><td>随机数</td>
        <td>&lt;自动&gt;</td>
        <td><code>balancer-manager</code>应用程序页面中使用的保护性随机数。默认设置是使用自动确定的基于UUID的随机数，以提供对该页面的进一步保护。如果已设置，则现时设置为该值。设置为<code>None</code>将禁用所有随机数检查。
    <div class="note"><h3>注意</h3>
      <p>除随机数外，还应通过ACL保护<code>balancer-manager</code>页面。</p>
    </div>
     </td></tr>
    <tr><td>成长</td>
        <td>0</td>
        <td>除了在配置中定义的平衡器之外，还可以添加到此平衡器的其他BalancerMember数量。
    </td></tr>
    <tr><td>强制恢复</td>
        <td>上</td>
        <td>如果平衡器的所有工人都处于错误状态，则在不考虑工人的重试参数的情况下强制所有工人立即恢复。如果在不考虑每个工作人员的重试参数的情况下强制执行所有工作人员的恢复，则在某些情况下，已经过载的后端可能会陷入更深的麻烦。在这种情况下，设置为<code>Off</code> 。<br>在Apache HTTP Server 2.4.2和更高版本中可用。
    </td></tr>

    </table>
    <p>样品平衡器设置：</p>
    <pre class="prettyprint lang-config">ProxyPass "/special-area" "http://special.example.com" smax=5 max=10
ProxyPass "/" "balancer://mycluster/" stickysession=JSESSIONID|jsessionid nofailover=On
&lt;Proxy "balancer://mycluster"&gt;
    BalancerMember "ajp://1.2.3.4:8009"
    BalancerMember "ajp://1.2.3.5:8009" loadfactor=20
    # Less powerful server, don't send as many requests there,
    BalancerMember "ajp://1.2.3.6:8009" loadfactor=5
&lt;/Proxy&gt;</pre>


    <p>设置仅在没有其他成员可用时才使用的热备用：</p>
    <pre class="prettyprint lang-config">ProxyPass "/" "balancer://hotcluster/"
&lt;Proxy "balancer://hotcluster"&gt;
    BalancerMember "ajp://1.2.3.4:8009" loadfactor=1
    BalancerMember "ajp://1.2.3.5:8009" loadfactor=2.25
    # The server below is on hot standby
    BalancerMember "ajp://1.2.3.6:8009" status=+H
    ProxySet lbmethod=bytraffic
&lt;/Proxy&gt;</pre>


    <p><strong>其他ProxyPass关键字</strong></p>

    <p>通常，mod_proxy将规范ProxyPassed URL。但这可能与某些后端（特别是那些使用<var>PATH_INFO的</var>后端）不兼容。可选的<var>nocanon</var>关键字抑制了这种情况，并将URL路径“原始”传递给后端。请注意，此关键字可能会影响后端的安全性，因为它取消了针对代理提供的基于URL的攻击的常规有限保护。</p>

    <p>通常，在生成<var>SCRIPT_FILENAME</var>环境变量时，mod_proxy将包括查询字符串。可选的<var>noquery</var>关键字（在httpd 2.4.1和更高版本中可用）可防止此情况。</p>

    <p>可选的<var>interpolate</var>关键字与<code class="directive">ProxyPassInterpolateEnv</code>结合使用，可以使ProxyPass使用语法<var>$ {VARNAME}</var>对环境变量进行插值。请注意，插值发生时，许多标准的CGI派生环境变量将不存在，因此对于复杂的规则，您可能仍必须诉诸于<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code> 。另请注意，URL的方案部分不支持插值。可以通过<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>完成动态确定方案，如以下示例所示。</p>

    <pre class="prettyprint lang-config">RewriteEngine On

RewriteCond "%{HTTPS}" =off
RewriteRule "." "-" [E=protocol:http]
RewriteCond "%{HTTPS}" =on
RewriteRule "." "-" [E=protocol:https]

RewriteRule "^/mirror/foo/(.*)" "%{ENV:protocol}://backend.example.com/$1" [P]
ProxyPassReverse  "/mirror/foo/" "http://backend.example.com/"
ProxyPassReverse  "/mirror/foo/" "https://backend.example.com/"</pre>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassInherit" id="ProxyPassInherit">ProxyPassInherit</a> <a name="proxypassinherit" id="proxypassinherit">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>继承从主服务器定义的ProxyPass指令</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassInherit开启|关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyPassInherit开启</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>ProxyPassInherit仅在Apache HTTP Server 2.4.5和更高版本中可用。
        </td></tr>
</table>
        <p>该指令将导致当前服务器/虚拟主机“继承”主服务器中定义的<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令。如果使用Balancer Manager进行动态更改，则可能导致问题和行为不一致，因此，如果使用该功能，则应将其禁用。</p>
        <p>全局服务器中的设置定义了所有虚拟主机的默认设置。</p>
        <p>禁用ProxyPassInherit也将禁用<code class="directive"><a href="#balancerinherit">BalancerInherit</a></code> 。</p>
    
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassInterpolateEnv" id="ProxyPassInterpolateEnv">ProxyPassInterpolateEnv</a> <a name="proxypassinterpolateenv" id="proxypassinterpolateenv">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>在反向代理配置中启用环境变量插值</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassInterpolateEnv开|关</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyPassInterpolateEnv关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在httpd 2.2.9和更高版本中可用</td></tr>
</table>
    <p>该指令与<code class="directive">ProxyPass</code> ， <code class="directive">ProxyPassReverse</code> ， <code class="directive">ProxyPassReverseCookieDomain</code>和<code class="directive">ProxyPassReverseCookiePath</code>的<var>插值</var>参数一起使用，可以使用环境变量来动态配置反向代理，这些环境变量可以由其他模块（例如<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code> 。如果设置了<var>插值</var>选项，它将影响<code class="directive">ProxyPass</code> ， <code class="directive">ProxyPassReverse</code> ， <code class="directive">ProxyPassReverseCookieDomain</code>和<code class="directive">ProxyPassReverseCookiePath</code>指令，并使它们在配置指令中将环境变量<code>varname</code>的值替换为字符串<code>${varname}</code> 。</p>
    <p>除非需要，请将其关闭（以提高服务器性能）！</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassMatch" id="ProxyPassMatch">ProxyPassMatch</a> <a name="proxypassmatch" id="proxypassmatch">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>使用正则表达式将远程服务器映射到本地服务器URL空间</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassMatch [ <var>正则表达式</var> ]！| <var>url</var> [ <var>键=值</var> <var>[键=值</var> ...]]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>此伪指令等效于<code class="directive"><a href="#proxypass">ProxyPass</a></code>但是使用正则表达式而不是简单的前缀匹配。提供的正则表达式与<var>url</var>匹配，如果匹配，则服务器会将所有带括号的匹配替换为给定的字符串，并将其用作新的<var>url</var> 。</p>

    <div class="note"><strong>注意：</strong>此伪指令不能在<code>&lt;Directory&gt;</code>上下文中使用。</div>
    
    <p>假设本地服务器的地址为<code>http://example.com/</code> ;然后</p>

    <pre class="prettyprint lang-config">ProxyPassMatch "^/(.*\.gif)$" "http://backend.example.com/$1"</pre>


    <p>会导致对<code>http://example.com/foo/bar.gif</code>的本地请求在内部转换为对<code>http://backend.example.com/foo/bar.gif</code>的代理请求。</p>
    <div class="note"><h3>注意</h3>
      <p><em>在进行正则</em>表达式替换<em>之前</em> （以及之后），URL参数必须可解析为URL。这限制了您可以使用的匹配项。例如，如果我们曾经使用</p>
      <pre class="prettyprint lang-config">ProxyPassMatch "^(/.*\.gif)$" "http://backend.example.com:8000$1"</pre>

      <p>在我们之前的示例中，它将在服务器启动时失败，并出现语法错误。这是一个错误（ASF bugzilla中的PR 46665），解决方法是重新构建匹配项：</p>
      <pre class="prettyprint lang-config">ProxyPassMatch "^/(.*\.gif)$" "http://backend.example.com:8000/$1"</pre>

    </div>
    <p><code>!</code> 伪指令在您不想反向代理子目录的情况下很有用。</p>

    <p>在<code class="directive"><a href="../mod/core.html#locationmatch">&lt;LocationMatch&gt;</a></code>部分中使用时，将省略第一个参数，并从<code class="directive"><a href="../mod/core.html#locationmatch">&lt;LocationMatch&gt;</a></code>获得regexp。</p>

    <p>如果您需要更灵活的反向代理配置，请参阅带有<code>[P]</code>标志的<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>指令。</p>

    <div class="note">
      <h3>默认替换</h3>
      <p>当URL参数在正则表达式中不使用任何反向引用时，原始URL将附加到URL参数中。
      </p>
    </div>

    <div class="warning">
      <h3>安全警告</h3>
      <p>在构造规则的目标URL时，请注意考虑到允许客户端影响服务器将用作代理的URL集对安全性的影响。确保URL的方案和主机名部分是固定的，或者不允许客户端产生不适当的影响。</p>
    </div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverse" id="ProxyPassReverse">ProxyPassReverse</a> <a name="proxypassreverse" id="proxypassreverse">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>调整从反向代理服务器发送的HTTP响应标头中的URL</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassReverse [ <var>路径</var> ] <var>url</var> [ <var>插值</var> ]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>该指令使Apache httpd可以调整HTTP重定向响应中<code>Location</code> ， <code>Content-Location</code>和<code>URI</code>标头中的URL。当Apache httpd用作反向代理（或网关）以避免由于反向服务器上的HTTP重定向位于反向代理之后而绕过反向代理时，这是必不可少的。</p>

    <p>仅上面特别提到的HTTP响应标头将被重写。Apache httpd不会重写其他响应标头，默认情况下也不会重写HTML页面内的URL引用。这意味着，如果代理内容包含绝对URL引用，则它们将绕过代理。要重写HTML内容以匹配代理，必须加载并启用<code class="module"><a href="../mod/mod_proxy_html.html">mod_proxy_html</a></code> 。
    </p>

    <p><var>path</var>是本地虚拟路径的名称； <var>url</var>是远程服务器的部分URL。这些参数的用法与<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令的用法相同。</p>

    <p>例如，假设本地服务器的地址为<code>http://example.com/</code> ；然后</p>

    <pre class="prettyprint lang-config">ProxyPass         "/mirror/foo/" "http://backend.example.com/"
ProxyPassReverse  "/mirror/foo/" "http://backend.example.com/"
ProxyPassReverseCookieDomain  "backend.example.com"  "public.example.com"
ProxyPassReverseCookiePath  "/"  "/mirror/foo/"</pre>


    <p>不仅会导致对<code>http://example.com/mirror/foo/bar</code>的本地请求在内部转换为对<code>http://backend.example.com/bar</code>的代理请求（ <code>ProxyPass</code>在此处提供的功能） 。当将<code>http://backend.example.com/bar</code>重定向到<code>http://backend.example.com/quux</code>时，它还会处理服务器<code>backend.example.com</code>发送的重定向。在将HTTP重定向响应转发到客户端之前，Apache httpd将其调整为<code>http://example.com/mirror/foo/quux</code> 。请注意，用于构造URL的主机名是根据<code class="directive"><a href="../mod/core.html#usecanonicalname">UseCanonicalName</a></code>伪指令的设置选择的。</p>

    <p>请注意，此<code class="directive">ProxyPassReverse</code>指令也可以与代理功能（ <code>RewriteRule ...[P]</code>从<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code> ，因为它不依赖于一个对应<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令。</p>

    <p>可选的<var>interpolate</var>关键字与<code class="directive">ProxyPassInterpolateEnv</code>一起使用，可以插入使用<var>$ {VARNAME}</var>格式指定的环境变量。请注意，URL的方案部分不支持插值。</p>

    <p>在<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>节中使用时，将省略第一个参数，并从<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>获取本地目录。在<code class="directive"><a href="../mod/core.html#locationmatch">&lt;LocationMatch&gt;</a></code>部分中也会发生同样的情况，但可能不会按预期方式工作，因为ProxyPassReverse会将正则表达式从字面上解释为路径。如果在这种情况下需要，请在此部分外部或在单独的<code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code>部分中指定ProxyPassReverse。</p>

    <p><code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>或<code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>部分不支持此伪指令。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverseCookieDomain" id="ProxyPassReverseCookieDomain">ProxyPassReverseCookieDomain</a> <a name="proxypassreversecookiedomain" id="proxypassreversecookiedomain">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>调整来自反向代理服务器的Set-Cookie标头中的域字符串</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassReverseCookieDomain <var>内部域</var> <var>公共域</var> [ <var>插值</var> ]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
<p>用法基本上类似于<code class="directive"><a href="#proxypassreverse">ProxyPassReverse</a></code> ，但不是重写URL头，而是重写<code>Set-Cookie</code>头中的<code>domain</code>字符串。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverseCookiePath" id="ProxyPassReverseCookiePath">ProxyPassReverseCookiePath</a> <a name="proxypassreversecookiepath" id="proxypassreversecookiepath">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>调整来自反向代理服务器的Set-Cookie标头中的Path字符串</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPassReverseCookiePath <var>内部路径</var> <var>public-path</var> [ <var>interpolate</var> ]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
<p>在后端URL路径映射到反向代理上的公共路径的情况下，与<code class="directive"><a href="#proxypassreverse">ProxyPassReverse</a></code>结合使用时非常有用。此伪指令重写<code>Set-Cookie</code>标头中的<code>path</code>字符串。如果cookie路径的开头与<var>internal-</var> path匹配，则cookie路径将被<var>public-path</var>替换。
</p><p>在<code class="directive"><a href="#proxypassreverse">ProxyPassReverse</a></code>给出的示例中，伪指令：</p>
    <pre class="prettyprint lang-config">ProxyPassReverseCookiePath  "/"  "/mirror/foo/"</pre>

<p>会将后端路径为<code>/</code> （或<code>/example</code>或实际上为任何内容）的cookie重写为<code>/mirror/foo/</code> 。
</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyPreserveHost" id="ProxyPreserveHost">ProxyPreserveHost</a> <a name="proxypreservehost" id="proxypreservehost">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>使用传入的主机HTTP请求标头进行代理请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyPreserveHost开|关</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyPreserveHost关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机，目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在2.3.3及更高版本中的目录上下文中可用。</td></tr>
</table>
    <p>启用后，此选项会将Host：行从传入请求传递到代理主机，而不是<code class="directive"><a href="#proxypass">ProxyPass</a></code>行中指定的主机名。</p>

    <p>通常应<code>Off</code>此选项。它在特殊的配置（例如基于质量的代理虚拟主机）中非常有用，其中原始Host标头需要后端服务器进行评估。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyReceiveBufferSize" id="ProxyReceiveBufferSize">ProxyReceiveBufferSize</a> <a name="proxyreceivebuffersize" id="proxyreceivebuffersize">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>代理HTTP和FTP连接的网络缓冲区大小</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyReceiveBufferSize <var>字节</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyReceiveBufferSize 0</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyReceiveBufferSize</code>指令为代理的HTTP和FTP连接指定显式（TCP / IP）网络缓冲区大小，以提高吞吐量。它必须大于<code>512</code>或设置为<code>0</code>以指示应使用系统的默认缓冲区大小。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyReceiveBufferSize 2048</pre>
</div>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyRemote" id="ProxyRemote">ProxyRemote</a> <a name="proxyremote" id="proxyremote">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>用于处理某些请求的远程代理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyRemote <var>匹配</var> <var>远程服务器</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>这定义了此代理的远程代理。 <var>match</var>是远程服务器支持的URL方案的名称，或者是应使用远程服务器的部分URL，或者<code>*</code>表示应为所有请求联系该服务器。 <var>remote-server</var>是<var>远程服务器</var>的部分URL。句法：</p>

    <div class="example"><p><code>
      <dfn>远程服务器</dfn> = <var>方案</var> ：// <var>主机名</var> [： <var>端口</var> ]</code></p></div>

    <p><var>方案</var>实际上是应该用于与远程服务器通信的协议；此模块仅支持<code>http</code>和<code>https</code> 。使用<code>https</code> ，使用HTTP CONNECT方法通过远程代理转发请求。</p>

    <div class="example"><h3>例</h3><pre class="prettyprint lang-config">ProxyRemote "http://goodguys.example.com/" "http://mirrorguys.example.com:8000"
ProxyRemote "*" "http://cleverproxy.localdomain"
ProxyRemote "ftp" "http://ftpproxy.mydomain:8080"</pre>
</div>

    <p>在最后一个示例中，代理将转发封装为另一个HTTP代理请求的FTP请求到另一个可以处理它们的代理。</p>

    <p>此选项还支持反向代理配置。可以将后端Web服务器嵌入到虚拟主机URL空间中，即使该服务器被另一个正向代理隐藏了。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyRemoteMatch" id="ProxyRemoteMatch">ProxyRemoteMatch</a> <a name="proxyremotematch" id="proxyremotematch">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>用于处理正则表达式匹配的请求的远程代理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyRemoteMatch <var>正则表达式</var> <var>远程服务器</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyRemoteMatch</code>与<code class="directive"><a href="#proxyremote">ProxyRemote</a></code>指令相同，除了第一个参数是与请求的URL匹配的<a class="glossarylink" href="../glossary.html#regex" title="见词汇">正则表达式</a> 。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyRequests" id="ProxyRequests">ProxyRequests</a> <a name="proxyrequests" id="proxyrequests">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>启用转发（标准）代理请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyRequests开|关</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>代理请求关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>这允许或阻止Apache httpd充当正向代理服务器。（将ProxyRequests设置为<code>Off</code>不会禁用<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令的使用。）</p>

    <p>在典型的反向代理或网关配置中，此选项应设置为<code>Off</code> 。</p>

    <p>为了获得代理HTTP或FTP站点的功能，您还需要服务器中存在<code class="module"><a href="../mod/mod_proxy_http.html">mod_proxy_http</a></code>或<code class="module"><a href="../mod/mod_proxy_ftp.html">mod_proxy_ftp</a></code> （或两者）。</p>

    <p>为了获得（转发）代理HTTPS站点的功能，您需要在服务器中启用<code class="module"><a href="../mod/mod_proxy_connect.html">mod_proxy_connect</a></code> 。</p>

    <div class="warning"><h3>警告</h3>
      <p>在<a href="#access">确保服务器安全</a>之前，请勿使用<code class="directive"><a href="#proxyrequests">ProxyRequests</a></code>启用代理。开放式代理服务器对您的网络和整个Internet都是危险的。</p>
    </div>

<h3>也可以看看</h3>
<ul>
<li><a href="#forwardreverse">正向和反向代理/网关</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxySet" id="ProxySet">ProxySet</a> <a name="proxyset" id="proxyset">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>设置各种代理平衡器或成员参数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxySet <var>网址</var> <var>key = value [key = value ...]</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>目录</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>ProxySet仅在Apache HTTP Server 2.2和更高版本中可用。</td></tr>
</table>
    <p>此伪指令用作设置通常可通过<code class="directive"><a href="#proxypass">ProxyPass</a></code>伪指令完成的对代理平衡器和工作者可用的任何参数的替代方法。如果在<code>&lt;Proxy <var>balancer url|worker url</var> &gt;</code>容器指令中使用，则不需要<var>url</var>参数。作为副作用，创建了各个平衡器或工人。通过<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>而不是<code class="directive"><a href="#proxypass">ProxyPass</a></code>指令进行反向代理时，这很有用。</p>

    <div class="example"><pre class="prettyprint lang-config">&lt;Proxy "balancer://hotcluster"&gt;
    BalancerMember "http://www2.example.com:8080" loadfactor=1
    BalancerMember "http://www3.example.com:8080" loadfactor=2
    ProxySet lbmethod=bytraffic
&lt;/Proxy&gt;</pre>
</div>

    <pre class="prettyprint lang-config">&lt;Proxy "http://backend"&gt;
    ProxySet keepalive=On
&lt;/Proxy&gt;</pre>


    <pre class="prettyprint lang-config">ProxySet "balancer://foo" lbmethod=bytraffic timeout=15</pre>


    <pre class="prettyprint lang-config">ProxySet "ajp://backend:7001" timeout=15</pre>


   <div class="warning"><h3>警告</h3>
      <p>请记住，相同的参数键可能具有不同的含义，具体取决于将其应用于平衡器还是工人，如上面有关超时的两个示例所示。</p>
   </div>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxySourceAddress" id="ProxySourceAddress">ProxySourceAddress</a> <a name="proxysourceaddress" id="proxysourceaddress">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>设置传出代理连接的本地IP地址</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxySourceAddress <var>地址</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在2.3.9版和更高版本中可用</td></tr>
</table>
    <p>此指令允许设置连接到后端服务器时要绑定到的特定本地地址。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyStatus" id="ProxyStatus">ProxyStatus</a> <a name="proxystatus" id="proxystatus">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>在mod_status中显示代理LoadBalancer状态</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyStatus关|开|满</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>ProxyStatus关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性：</a></th><td>在2.2版和更高版本中可用</td></tr>
</table>
    <p>该指令确定是否通过<code class="module"><a href="../mod/mod_status.html">mod_status</a></code>服务器状态页面显示代理负载均衡器状态数据。</p>
    <div class="note"><h3>注意</h3>
      <p><strong>满</strong>是<strong>On的</strong>同义词</p>
    </div>


</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyTimeout" id="ProxyTimeout">ProxyTimeout</a> <a name="proxytimeout" id="proxytimeout">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td>代理请求的网络超时</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyTimeout <var>秒</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code><code class="directive"><a href="../mod/core.html#timeout">Timeout</a></code>值</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>该指令允许用户指定代理请求的超时时间。当您的应用服务器缓慢/挂起时，这很有用，您宁愿返回超时并正常地失败，而不是等待服务器返回所花费的时间。</p>

</div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="directive-section"><h2><a name="ProxyVia" id="ProxyVia">ProxyVia</a> <a name="proxyvia" id="proxyvia">指令</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">描述：</a></th><td><code>Via</code> HTTP响应标头提供的有关代理请求的信息</td></tr>
<tr><th><a href="directive-dict.html#Syntax">句法：</a></th><td><code>ProxyVia开启|关闭|完整|阻止</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认：</a></th><td><code>代理关闭</code></td></tr>
<tr><th><a href="directive-dict.html#Context">内容：</a></th><td>服务器配置，虚拟主机</td></tr>
<tr><th><a href="directive-dict.html#Status">状态：</a></th><td>延期</td></tr>
<tr><th><a href="directive-dict.html#Module">模块：</a></th><td>mod_proxy</td></tr>
</table>
    <p>此伪指令控制代理对<code>Via:</code> HTTP标头的使用。它的预期用途是控制沿着代理服务器链的代理请求的流。有关<code>Via:</code>标头行的说明，请参阅<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a> （HTTP / 1.1）的第14.45节。</p>

    <ul>
    <li>如果设置为<code>Off</code> （默认值），则不执行任何特殊处理。如果请求或回复包含<code>Via:</code>标头，则将原样传递。</li>

    <li>如果设置为<code>On</code> ，则每个请求和答复都将为当前主机添加<code>Via:</code>标头行。</li>

    <li>如果设置为<code>Full</code> ，则每个生成的<code>Via:</code>标题行还将具有显示为<code>Via:</code>注释字段的Apache httpd服务器版本。</li>

    <li>如果设置为<code>Block</code> ，则每个代理请求都将删除其所有<code>Via:</code>标头行。不会生成新的<code>Via:</code>标头。</li>
    </ul>

</div>
</div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>