<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>VirtualHost示例-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP服务器</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">虚拟主机</a></div><div id="page-content"><div id="preamble"><h1>VirtualHost示例</h1>



    <p>本文档尝试回答有关设置<a href="index.html">虚拟主机</a>的常见问题。这些方案涉及通过<a href="name-based.html">基于名称</a>或<a href="name-based.html">基于</a> <a href="ip-based.html">IP的</a>虚拟主机在单个服务器上运行的多个网站。
    </p>

</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#purename">在单个IP地址上运行多个基于名称的网站。</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#twoips">基于名称的主机位于多个IP地址上。</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#intraextra">在不同的IP地址（例如内部和外部地址）上提供相同的内容。</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#port">在不同的端口上运行不同的站点。</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#ip">基于IP的虚拟主机</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#ipport">基于端口和基于IP的混合虚拟主机</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#mixed">基于名称和基于IP的混合虚拟主机</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#proxy">使用<code>Virtual_host</code>和mod_proxy在一起</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#default">使用<code>_default_</code>虚拟主机</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#migrate">将基于名称的虚拟主机迁移到基于IP的虚拟主机</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#serverpath">使用<code>ServerPath</code>指示</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="purename" id="purename">在单个IP地址上运行多个基于名称的网站。</a></h2>

    <p>您的服务器具有多个解析为单个地址的主机名，并且您希望以不同的方式响应<code>www.example.com</code>和<code>www.example.org</code> 。</p>

    <div class="note"><h3>注意</h3><p>在Apache服务器上创建虚拟主机配置不会神奇地导致为那些主机名创建DNS条目。您<em>必须</em>在DNS中输入名称，解析为IP地址，否则其他人将无法看到您的网站。您可以将条目放入<code>hosts</code>文件进行本地测试，但仅在具有这些文件的计算机上有效<code>hosts</code>条目。</p>
    </div>

    <pre class="prettyprint lang-config"># Ensure that Apache listens on port 80
Listen 80
&lt;VirtualHost *:80&gt;
    DocumentRoot "/www/example1"
    ServerName www.example.com

    # Other directives here
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
    DocumentRoot "/www/example2"
    ServerName www.example.org

    # Other directives here
&lt;/VirtualHost&gt;</pre>


    <p>星号匹配所有地址，因此主服务器不处理任何请求。由于虚拟主机具有<code>ServerName www.example.com</code>是配置文件中的第一个，它具有最高的优先级，可以被视为<cite>默认</cite>服务器或<cite>主</cite>服务器。这意味着如果收到的请求与指定的请求之一不匹配<code class="directive"><a href="../mod/core.html#servername">ServerName</a></code>指令，这将首先由<code class="directive"><a href="../mod/core.html#virtualhost"><VirtualHost></a></code> 。</p>

    <p>上面的配置是您几乎希望在所有基于名称的虚拟主机情况下使用的配置。实际上，此配置唯一不起作用的是基于不同的IP地址或端口提供不同的内容时。</p>

    <div class="note">
            <h3>注意</h3>

           <p>您可以更换<code>*</code>使用系统上的特定IP地址。此类虚拟主机仅用于连接到指定IP地址时收到的HTTP请求。</p>

           <p>但是，使用还很有用<code>*</code>在IP地址不可预测的系统上-例如，如果您的ISP具有动态IP地址，并且您正在使用各种动态DNS解决方案。以来<code>*</code>匹配任何IP地址，只要您的IP地址发生更改，此配置就不会更改。</p>
    </div>
  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="twoips" id="twoips">基于名称的主机位于多个IP地址上。</a></h2>

    <div class="note">
      <h3>注意</h3>
      <p>此处讨论的任何技术都可以扩展到任意数量的IP地址。</p>
    </div>

    <p>该服务器有两个IP地址。在一个 （ <code>172.20.30.40</code> ），我们将为“主”服务器提供服务， <code>server.example.com</code>另一方面<code>172.20.30.50</code> ），我们将为两个或多个虚拟主机提供服务。</p>

    <pre class="prettyprint lang-config">Listen 80

# This is the "main" server running on 172.20.30.40
ServerName server.example.com
DocumentRoot "/www/mainserver"

&lt;VirtualHost 172.20.30.50&gt;
    DocumentRoot "/www/example1"
    ServerName www.example.com

    # Other directives here ...
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.50&gt;
    DocumentRoot "/www/example2"
    ServerName www.example.org

    # Other directives here ...
&lt;/VirtualHost&gt;</pre>


    <p>除地址以外的任何其他请求<code>172.20.30.50</code>将由主服务器提供。要求<code>172.20.30.50</code>主机名未知或否<code>Host:</code>标头，将从<code>www.example.com</code> 。</p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="intraextra" id="intraextra">在不同的IP地址（例如内部和外部地址）上提供相同的内容。</a></h2>

    <p>服务器计算机有两个IP地址（ <code>192.168.1.1</code>和<code>172.20.30.40</code> ）。机器位于内部（内部网）网络和外部（内部网）网络之间。网络外部，名称<code>server.example.com</code>解析为外部地址（ <code>172.20.30.40</code> ），但在网络内部，该名称解析为内部地址（ <code>192.168.1.1</code> ）。</p>

    <p>可以使服务器以相同的内容响应内部和外部请求，而只需一个<code class="directive"><a href="../mod/core.html#virtualhost"><VirtualHost></a></code>部分。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost 192.168.1.1 172.20.30.40&gt;
    DocumentRoot "/www/server1"
    ServerName server.example.com
    ServerAlias server
&lt;/VirtualHost&gt;</pre>


    <p>现在，来自两个网络的请求将通过相同的服务<code class="directive"><a href="../mod/core.html#virtualhost"><VirtualHost></a></code> 。</p>

    <div class="note">
          <h3>注意：</h3><p>在内部网络上，可以只使用名称<code>server</code>而不是标准主机名<code>server.example.com</code> 。</p>

          <p>还要注意，在上面的示例中，您可以将IP地址列表替换为<code>*</code> ，这将导致服务器在所有地址上做出相同的响应。</p>
    </div>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="port" id="port">在不同的端口上运行不同的站点。</a></h2>

    <p>您有多个要使用相同IP的域，并且还想为多个端口提供服务。下面的示例说明了名称匹配是在确定最佳匹配的IP地址和端口组合之后进行的。</p>

    <pre class="prettyprint lang-config">Listen 80
Listen 8080

&lt;VirtualHost 172.20.30.40:80&gt;
    ServerName www.example.com
    DocumentRoot "/www/domain-80"
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40:8080&gt;
    ServerName www.example.com
    DocumentRoot "/www/domain-8080"
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40:80&gt;
    ServerName www.example.org
    DocumentRoot "/www/otherdomain-80"
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40:8080&gt;
    ServerName www.example.org
    DocumentRoot "/www/otherdomain-8080"
&lt;/VirtualHost&gt;</pre>


  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="ip" id="ip">基于IP的虚拟主机</a></h2>

    <p>服务器有两个IP地址（ <code>172.20.30.40</code>和<code>172.20.30.50</code> ）解析为名称<code>www.example.com</code>和<code>www.example.org</code>分别。</p>

    <pre class="prettyprint lang-config">Listen 80

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/example1"
    ServerName www.example.com
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.50&gt;
    DocumentRoot "/www/example2"
    ServerName www.example.org
&lt;/VirtualHost&gt;</pre>


    <p>请求未在以下任一地址中指定的地址<code><VirtualHost></code>指令（例如<code>localhost</code> （例如））将转到主服务器（如果有）。</p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="ipport" id="ipport">基于端口和基于IP的混合虚拟主机</a></h2>

    <p>服务器计算机有两个IP地址（ <code>172.20.30.40</code>和<code>172.20.30.50</code> ）解析为名称<code>www.example.com</code>和<code>www.example.org</code>分别。在每种情况下，我们都希望在端口80和8080上运行主机。</p>

    <pre class="prettyprint lang-config">Listen 172.20.30.40:80
Listen 172.20.30.40:8080
Listen 172.20.30.50:80
Listen 172.20.30.50:8080

&lt;VirtualHost 172.20.30.40:80&gt;
    DocumentRoot "/www/example1-80"
    ServerName www.example.com
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40:8080&gt;
    DocumentRoot "/www/example1-8080"
    ServerName www.example.com
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.50:80&gt;
    DocumentRoot "/www/example2-80"
    ServerName www.example.org
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.50:8080&gt;
    DocumentRoot "/www/example2-8080"
    ServerName www.example.org
&lt;/VirtualHost&gt;</pre>


  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="mixed" id="mixed">基于名称和基于IP的混合虚拟主机</a></h2>

    <p>在虚拟主机的参数中提到的任何地址都永远不会出现在其他虚拟主机中，这是严格基于IP的虚拟主机。</p>

    <pre class="prettyprint lang-config">Listen 80
&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/example1"
    ServerName www.example.com
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/example2"
    ServerName www.example.org
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/example3"
    ServerName www.example.net
&lt;/VirtualHost&gt;

# IP-based
&lt;VirtualHost 172.20.30.50&gt;
    DocumentRoot "/www/example4"
    ServerName www.example.edu
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.60&gt;
    DocumentRoot "/www/example5"
    ServerName www.example.gov
&lt;/VirtualHost&gt;</pre>


  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="proxy" id="proxy">使用<code>Virtual_host</code>和mod_proxy在一起</a></h2>

    <p>以下示例允许前端计算机将虚拟主机代理到另一台计算机上运行的服务器。在此示例中，在以下计算机上配置了相同名称的虚拟主机： <code>192.168.111.2</code> 。的<code class="directive"><a href="../mod/mod_proxy.html#proxypreservehost">ProxyPreserveHost On</a></code>如果我们将多个主机名代理到一台计算机，则使用伪指令来传递所需的主机名。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost *:*&gt;
    ProxyPreserveHost On
    ProxyPass        "/" "http://192.168.111.2/"
    ProxyPassReverse "/" "http://192.168.111.2/"
    ServerName hostname.example.com
&lt;/VirtualHost&gt;</pre>


    </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="default" id="default">使用<code>_default_</code>虚拟主机</a></h2>

    <h3><a name="defaultallports" id="defaultallports"><code>_default_</code>所有端口的虚拟主机</a></h3>

    <p>将<em>每个</em>请求捕获到任何未指定的IP地址和端口， <em>即</em>未用于任何其他虚拟主机的地址/端口组合。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost _default_:*&gt;
    DocumentRoot "/www/default"
&lt;/VirtualHost&gt;</pre>


    <p>将这样的默认虚拟主机与通配符端口一起使用可有效防止任何请求发送到主服务器。</p>

    <p>默认虚拟主机从不处理已发送到用于基于名称的虚拟主机的地址/端口的请求。如果请求中包含未知或否<code>Host:</code>标头始终由基于主名称的虚拟主机（该地址/端口的虚拟主机首先出现在配置文件中）提供。</p>

    <p>您可以使用<code class="directive"><a href="../mod/mod_alias.html#aliasmatch">AliasMatch</a></code>要么<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>将任何请求重写到单个信息页（或脚本）。</p>
    

    <h3><a name="defaultdifferentports" id="defaultdifferentports"><code>_default_</code>不同端口的虚拟主机</a></h3>

    <p>与设置1相同，但是服务器监听多个端口，我们想使用第二个<code>_default_</code>端口80的虚拟主机。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost _default_:80&gt;
    DocumentRoot "/www/default80"
    # ...
&lt;/VirtualHost&gt;

&lt;VirtualHost _default_:*&gt;
    DocumentRoot "/www/default"
    # ...
&lt;/VirtualHost&gt;</pre>


    <p>端口80的默认虚拟主机（ <em>必须</em>出现在具有通配符端口的任何默认虚拟主机之前）必须捕获所有发送到未指定IP地址的请求。主服务器从不用于服务请求。</p>
    

    <h3><a name="defaultoneport" id="defaultoneport"><code>_default_</code>一个端口的虚拟主机</a></h3>

    <p>我们希望为端口80提供一个默认虚拟主机，但没有其他默认虚拟主机。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost _default_:80&gt;
    DocumentRoot "/www/default"
...
&lt;/VirtualHost&gt;</pre>


    <p>默认虚拟主机将请求对端口80上未指定地址的请求。主服务器会处理对未指定地址和端口的任何其他请求。</p>

    <p>任何使用<code>*</code>虚拟主机声明中的优先级高于<code>_default_</code> 。</p>

    

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="migrate" id="migrate">将基于名称的虚拟主机迁移到基于IP的虚拟主机</a></h2>

    <p>具有主机名的基于名称的虚拟主机<code>www.example.org</code> （根据我们<a href="#name">基于名称的</a>示例，设置2）应该获得其自己的IP地址。为避免名称服务器或为基于名称的虚拟主机缓存旧IP地址的代理服务器出现问题，我们希望在迁移阶段提供两种变体。</p>

    <p>解决方案很简单，因为我们只需添加新的IP地址（ <code>172.20.30.50</code> ）到<code>VirtualHost</code>指示。</p>

    <pre class="prettyprint lang-config">Listen 80
ServerName www.example.com
DocumentRoot "/www/example1"

&lt;VirtualHost 172.20.30.40 172.20.30.50&gt;
    DocumentRoot "/www/example2"
    ServerName www.example.org
    # ...
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/example3"
    ServerName www.example.net
    ServerAlias *.example.net
    # ...
&lt;/VirtualHost&gt;</pre>


    <p>现在，可以通过新地址（作为基于IP的虚拟主机）和旧地址（作为基于名称的虚拟主机）访问该虚拟主机。</p>

  </div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="serverpath" id="serverpath">使用<code>ServerPath</code>指示</a></h2>

    <p>我们有一台带有两个基于名称的虚拟主机的服务器。为了匹配正确的虚拟主机，客户端必须发送正确的虚拟主机<code>Host:</code>标头。旧的HTTP / 1.0客户端不会发送这样的标头，并且Apache不知道客户端试图到达哪个虚拟主机（并服务于来自主要虚拟主机的请求）。为了提供尽可能多的向后兼容性，我们创建了一个主虚拟主机，该主机返回一个页面，该页面包含指向基于名称的虚拟主机的URL前缀的链接。</p>

    <pre class="prettyprint lang-config">&lt;VirtualHost 172.20.30.40&gt;
    # primary vhost
    DocumentRoot "/www/subdomain"
    RewriteEngine On
    RewriteRule "." "/www/subdomain/index.html"
    # ...
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/subdomain/sub1"
    ServerName www.sub1.domain.tld
    ServerPath "/sub1/"
    RewriteEngine On
    RewriteRule "^(/sub1/.*)" "/www/subdomain$1"
    # ...
&lt;/VirtualHost&gt;

&lt;VirtualHost 172.20.30.40&gt;
    DocumentRoot "/www/subdomain/sub2"
    ServerName www.sub2.domain.tld
    ServerPath "/sub2/"
    RewriteEngine On
    RewriteRule "^(/sub2/.*)" "/www/subdomain$1"
    # ...
&lt;/VirtualHost&gt;</pre>


    <p>因为<code class="directive"><a href="../mod/core.html#serverpath">ServerPath</a></code>指示URL请求<code>http://www.sub1.domain.tld/sub1/</code> <em>始终</em>从sub1-vhost提供。<br>网址请求<code>http://www.sub1.domain.tld/</code>仅当客户端发送正确的邮件时，才从sub1-vhost提供服务<code>Host:</code>标头。如果不<code>Host:</code>头发送给客户端，客户端从主主机获取信息页面。</p>

    <p>请注意，有一个奇怪的地方： <code>http://www.sub2.domain.tld/sub1/</code>如果客户端未发送，则sub1-vhost也提供服务<code>Host:</code>标头。</p>

    <p>的<code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>指令用于确保发送正确消息的客户端<code>Host:</code>标头可以使用两种URL变体， <em>即</em> ，带有或不带有URL前缀。</p>

  </div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>