<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>停止和重新启动Apache HTTP Server-Apache HTTP Server版本2.4</title>
<link href="./style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="./style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="./style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="./style/css/prettify.css">
<script src="./style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="./images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="./images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="./index.html">版本2.4</a></div><div id="page-content"><div id="preamble"><h1>停止并重新启动Apache HTTP Server</h1>


    <p>本文档介绍了在类似Unix的系统上停止和重新启动Apache HTTP Server。Windows NT，2000和XP用户应看到将<a href="platform/windows.html#winsvc">httpd作为服务运行，</a>而Windows 9x和ME用户应看到将<a href="platform/windows.html#wincons">httpd作为控制台应用程序</a>获取有关如何在这些平台上控制httpd的信息。</p>
</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="./images/down.gif"> <a href="#introduction">介绍</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#term">立即停止</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#graceful">优雅重启</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#hup">现在重启</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#gracefulstop">优雅的停止</a></li>
</ul><h3>也可以看看</h3><ul class="seealso"><li><code class="program"><a href="./programs/httpd.html">httpd</a></code></li><li><code class="program"><a href="./programs/apachectl.html">apachectl</a></code></li><li><a href="invoking.html">开始</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="introduction" id="introduction">介绍</a></h2>

    <p>为了停止或重新启动Apache HTTP Server，必须向正在运行的服务器发送信号<code class="program"><a href="./programs/httpd.html">httpd</a></code>流程。有两种发送信号的方法。首先，您可以使用Unix <code>kill</code>命令直接将信号发送到进程。您会注意到很多<code class="program"><a href="./programs/httpd.html">httpd</a></code>可执行文件在您的系统上运行，但是除了父对象（其pid位于<code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code> 。也就是说，除了父进程外，您根本不需要向其他进程发送信号。您可以发送四个信号来发送父母： <code><a href="#term">TERM</a></code> ， <code><a href="#graceful">USR1</a></code> ， <code><a href="#hup">HUP</a></code>和<code><a href="#gracefulstop">WINCH</a></code> ，稍后将进行描述。</p>

    <p>要将信号发送给父母，您应该发出以下命令：</p>

<div class="example"><p><code>kill -TERM `cat /usr/local/apache2/logs/httpd.pid`</code></p></div>

    <p>发出信号的第二种方法<code class="program"><a href="./programs/httpd.html">httpd</a></code>流程是使用<code>-k</code>命令行选项： <code>stop</code> ， <code>restart</code> ， <code>graceful</code>和<code>graceful-stop</code> ，如下所述。这些是<code class="program"><a href="./programs/httpd.html">httpd</a></code>二进制文件，但我们建议您使用<code class="program"><a href="./programs/apachectl.html">apachectl</a></code>控制脚本，它将通过它们传递给<code class="program"><a href="./programs/httpd.html">httpd</a></code> 。</p>

    <p>发出信号后<code class="program"><a href="./programs/httpd.html">httpd</a></code> ，您可以通过发出以下内容了解其进度：</p>

<div class="example"><p><code>tail -f /usr/local/apache2/logs/error_log</code></p></div>

    <p>修改这些示例以匹配您的<code class="directive"><a href="./mod/core.html#serverroot">ServerRoot</a></code>和<code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>设置。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="term" id="term">立即停止</a></h2>

<dl><dt>信号：TERM</dt>
<dd><code>apachectl -k stop</code></dd>
</dl>

    <p>发送<code>TERM</code>要么<code>stop</code>给父母的信号使它立即试图杀死所有孩子。杀死所有孩子可能要花几秒钟。然后父母本身退出。正在进行的所有请求都将终止，并且不再处理其他请求。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="graceful" id="graceful">优雅重启</a></h2>

<dl><dt>信号：USR1</dt>
<dd><code>apachectl -k graceful</code></dd>
</dl>

    <p>的<code>USR1</code>要么<code>graceful</code>信号会导致父进程<em>建议</em>子进程在其当前请求之后退出（如果他们没有提供任何服务，则立即退出）。父级重新读取其配置文件并重新打开其日志文件。随着每个孩子的死亡，父级将其替换为<em>新一代</em>配置中的一个孩子，该配置立即开始处理新请求。</p>

    <p>此代码旨在始终遵循MPM的流程控制指令，因此在重新启动过程中，可为客户使用的流程和线程数将保持在适当的值。此外，它尊重<code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code>以下列方式：如果至少一秒钟后<code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code>尚未创建新的子代，然后创建足够的子代以吸收松弛。因此，代码会尝试维护适合当前服务器负载的子代数，并通过<code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code>参数。</p>

    <p>的用户<code class="module"><a href="./mod/mod_status.html">mod_status</a></code>会注意到当以下情况时，服务器统计信息<strong>未</strong>设置为零<code>USR1</code>已发送。编写代码既可以最大程度地减少服务器无法处理新请求的时间（它们将由操作系统排队，因此无论如何它们都不会丢失），并且可以尊重您的调整参数。为了做到这一点，它必须保持<em>记分板</em>用于跟踪几代人的所有孩子。</p>

    <p>状态模块还将使用<code>G</code>指示那些仍在处理请求的子级在正常重启之前启动。</p>

    <p>目前没有办法使用<code>USR1</code>确定所有编写重新启动前日志的孩子都已完成。我们建议您在发送<code>USR1</code>在对旧日志执行任何操作之前先发出信号。例如，如果对于低带宽链接的用户而言，大多数匹配仅花费不到10分钟即可完成，那么您可以等待15分钟，然后再对旧日志执行任何操作。</p>

    <div class="note">
    <p>发出重新启动时，将首先运行语法检查，以确保配置文件中没有错误。如果您的配置文件中有错误，您将收到有关该语法错误的错误消息，并且服务器将拒绝重新启动。这样可以避免服务器停止然后无法重新启动的情况，从而使服务器无法运行。</p>

    <p>这仍然不能保证服务器将正确重启。要检查配置文件的语义以及语法，可以尝试启动<code class="program"><a href="./programs/httpd.html">httpd</a></code>作为非root用户。如果没有错误，它将尝试打开其套接字和日志并失败，因为它不是root用户（或者因为当前正在运行） <code class="program"><a href="./programs/httpd.html">httpd</a></code>已经绑定了这些端口）。如果由于任何其他原因而失败，则可能是配置文件错误，应该在发出正常重启之前修复该错误。</p></div>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="hup" id="hup">现在重启</a></h2>

<dl><dt>信号：HUP</dt>
<dd><code>apachectl -k restart</code></dd>
</dl>

    <p>发送<code>HUP</code>要么<code>restart</code>给父母的信号导致它杀死孩子，就像<code>TERM</code> ，但父级不会退出。它重新读取其配置文件，并重新打开所有日志文件。然后，它会产生一组新的孩子，并继续提供热门歌曲。</p>

    <p>的用户<code class="module"><a href="./mod/mod_status.html">mod_status</a></code>将注意到当<code>HUP</code>已发送。</p>

<div class="note">与正常重启一样，在尝试重启之前运行语法检查。如果您的配置文件中有错误，将不会尝试重新启动，并且您将收到有关语法错误的通知。</div>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="gracefulstop" id="gracefulstop">优雅的停止</a></h2>

<dl><dt>信号：绞盘</dt>
<dd><code>apachectl -k graceful-stop</code></dd>
</dl>

    <p>的<code>WINCH</code>要么<code>graceful-stop</code>信号会导致父进程<em>建议</em>子进程在其当前请求之后退出（如果他们没有提供任何服务，则立即退出）。家长然后将其删除<code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>并停止监听所有端口。父级将继续运行，并监视正在处理请求的子级。一旦所有子项都已完成并退出或超时<code class="directive"><a href="./mod/mpm_common.html#gracefulshutdowntimeout">GracefulShutdownTimeout</a></code>到达后，父级也会退出。如果达到超时时间，则将向剩余的所有孩子发送<code>TERM</code>迫使他们退出的信号。</p>

    <p>一种<code>TERM</code>当处于“正常”状态时，信号将立即终止父进程和所有子进程。但是作为<code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>将被删除，您将无法使用<code>apachectl</code>要么<code>httpd</code>发送此信号。</p>

    <div class="note"><p>的<code>graceful-stop</code> signal允许您运行多个相同配置的实例<code class="program"><a href="./programs/httpd.html">httpd</a></code>同时。在执行httpd的正常升级时，这是一项强大的功能，但是在某些配置下，它也可能导致死锁和竞争情况。</p>

    <p>请注意确保磁盘文件（例如锁定文件）（ <code class="directive"><a href="./mod/core.html#mutex">Mutex</a></code> ）和Unix套接字文件（ <code class="directive"><a href="./mod/mod_cgid.html#scriptsock">ScriptSock</a></code> ）包含服务器PID，并且应共存而不会出现问题。但是，如果配置指令，第三方模块或持久性CGI使用任何其他磁盘上的锁或状态文件，则应确保确保多个正在运行的实例。 <code class="program"><a href="./programs/httpd.html">httpd</a></code>不要破坏彼此的文件。</p>

    <p>您还应该警惕其他潜在的比赛条件，例如使用<code class="program"><a href="./programs/rotatelogs.html">rotatelogs</a></code>样式管道记录。多个正在运行的实例<code class="program"><a href="./programs/rotatelogs.html">rotatelogs</a></code>尝试同时旋转相同的日志文件可能会破坏彼此的日志文件。</p></div>
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>