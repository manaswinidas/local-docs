<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>将URL映射到文件系统位置-Apache HTTP Server版本2.4</title>
<link href="./style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="./style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="./style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="./style/css/prettify.css">
<script src="./style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="./images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="./images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP Server</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="./index.html">版本2.4</a></div><div id="page-content"><div id="preamble"><h1>将URL映射到文件系统位置</h1>


    <p>本文档说明了Apache HTTP Server如何使用请求的URL来确定用于提供文件的文件系统位置。</p>
  </div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="./images/down.gif"> <a href="#related">相关模块和指令</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#documentroot">文档根</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#outside">DocumentRoot外部的文件</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#user">用户目录</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#redirect">URL重定向</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#proxy">反向代理</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#rewrite">改写引擎</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#notfound">文件未找到</a></li>
<li><img alt="" src="./images/down.gif"> <a href="#other">其他URL映射模块</a></li>
</ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="related" id="related">相关模块和指令</a></h2>

<table class="related"><tbody><tr><th>相关模块</th><th>相关指令</th></tr><tr><td><ul><li><code class="module"><a href="./mod/mod_actions.html">mod_actions</a></code></li><li><code class="module"><a href="./mod/mod_alias.html">mod_alias</a></code></li><li><code class="module"><a href="./mod/mod_autoindex.html">mod_autoindex</a></code></li><li><code class="module"><a href="./mod/mod_dir.html">mod_dir</a></code></li><li><code class="module"><a href="./mod/mod_imagemap.html">mod_imagemap</a></code></li><li><code class="module"><a href="./mod/mod_negotiation.html">mod_negotiation</a></code></li><li><code class="module"><a href="./mod/mod_proxy.html">mod_proxy</a></code></li><li><code class="module"><a href="./mod/mod_rewrite.html">mod_rewrite</a></code></li><li><code class="module"><a href="./mod/mod_speling.html">mod_speling</a></code></li><li><code class="module"><a href="./mod/mod_userdir.html">mod_userdir</a></code></li><li><code class="module"><a href="./mod/mod_vhost_alias.html">mod_vhost_alias</a></code></li></ul></td><td><ul><li><code class="directive"><a href="./mod/mod_alias.html#alias">Alias</a></code></li><li><code class="directive"><a href="./mod/mod_alias.html#aliasmatch">AliasMatch</a></code></li><li><code class="directive"><a href="./mod/mod_speling.html#checkspelling">CheckSpelling</a></code></li><li><code class="directive"><a href="./mod/mod_dir.html#directoryindex">DirectoryIndex</a></code></li><li><code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code></li><li><code class="directive"><a href="./mod/core.html#errordocument">ErrorDocument</a></code></li><li><code class="directive"><a href="./mod/core.html#options">Options</a></code></li><li><code class="directive"><a href="./mod/mod_proxy.html#proxypass">ProxyPass</a></code></li><li><code class="directive"><a href="./mod/mod_proxy.html#proxypassreverse">ProxyPassReverse</a></code></li><li><code class="directive"><a href="./mod/mod_proxy.html#proxypassreversecookiedomain">ProxyPassReverseCookieDomain</a></code></li><li><code class="directive"><a href="./mod/mod_proxy.html#proxypassreversecookiepath">ProxyPassReverseCookiePath</a></code></li><li><code class="directive"><a href="./mod/mod_alias.html#redirect">Redirect</a></code></li><li><code class="directive"><a href="./mod/mod_alias.html#redirectmatch">RedirectMatch</a></code></li><li><code class="directive"><a href="./mod/mod_rewrite.html#rewritecond">RewriteCond</a></code></li><li><code class="directive"><a href="./mod/mod_rewrite.html#rewriterule">RewriteRule</a></code></li><li><code class="directive"><a href="./mod/mod_alias.html#scriptalias">ScriptAlias</a></code></li><li><code class="directive"><a href="./mod/mod_alias.html#scriptaliasmatch">ScriptAliasMatch</a></code></li><li><code class="directive"><a href="./mod/mod_userdir.html#userdir">UserDir</a></code></li></ul></td></tr></tbody></table>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="documentroot" id="documentroot">文档根</a></h2>

    <p>在确定要为给定请求提供服务的文件时，httpd的默认行为是获取请求的URL路径（URL的名称和端口后面的部分）并将其添加到<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>在配置文件中指定。因此，下面的文件和目录<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>组成基本的文档树，这些树将从Web上可见。</p>

    <p>例如，如果<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>被设置为<code>/var/www/html</code>然后要求<code>http://www.example.com/fish/guppies.html</code>会导致文件<code>/var/www/html/fish/guppies.html</code>被提供给请求客户。</p>

    <p>如果请求目录（即，以结尾的路径<code>/</code> ），则该目录提供的文件由<code class="directive"><a href="./mod/mod_dir.html#directoryindex">DirectoryIndex</a></code>指示。例如，如果<code>DocumentRoot</code>设置如上，您将设置：</p>

    <div class="example"><p><code>DirectoryIndex index.html index.php</code></p></div>

    <p>然后要求<code>http://www.example.com/fish/</code>将导致httpd尝试提供文件<code>/var/www/html/fish/index.html</code> 。如果该文件不存在，则下一次将尝试为该文件提供服务<code>/var/www/html/fish/index.php</code> 。</p>

    <p>如果这些文件都不存在，那么下一步是尝试提供目录索引，如果<code class="module"><a href="./mod/mod_autoindex.html">mod_autoindex</a></code>已加载并配置为允许这样做。</p>

    <p>httpd还具有<a href="vhosts/index.html">Virtual Hosting功能</a> ，该服务器在其中接收多个主机的请求。在这种情况下， <code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>可以为每个虚拟主机指定，也可以为模块提供的指令指定<code class="module"><a href="./mod/mod_vhost_alias.html">mod_vhost_alias</a></code>可用于根据请求的IP地址或主机名动态确定从何处提供内容。</p>

    <p>的<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>指令在您的主服务器配置文件中设置（ <code>httpd.conf</code> ），并且可能会为您创建的每个其他<a href="vhosts/index.html">虚拟主机</a>一次。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="outside" id="outside">DocumentRoot外部的文件</a></h2>

    <p>在许多情况下，有必要允许通过Web访问文件系统中严格不在其下面的部分<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code> 。 httpd提供了几种不同的方法来实现此目的。在Unix系统上，符号链接可以将文件系统的其他部分置于<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code> 。出于安全原因，只有在以下情况下，httpd才会使用符号链接： <code class="directive"><a href="./mod/core.html#options">Options</a></code>相关目录的设置包括<code>FollowSymLinks</code>要么<code>SymLinksIfOwnerMatch</code> 。</p>

    <p>或者， <code class="directive"><a href="./mod/mod_alias.html#alias">Alias</a></code>指令会将文件系统的任何部分映射到Web空间。例如，</p>

<pre class="prettyprint lang-config">Alias "/docs" "/var/web"</pre>


    <p>网址<code>http://www.example.com/docs/dir/file.html</code>将从<code>/var/web/dir/file.html</code> 。的<code class="directive"><a href="./mod/mod_alias.html#scriptalias">ScriptAlias</a></code>指令以相同的方式工作，其附加效果是将位于目标路径上的所有内容都视为<a class="glossarylink" href="./glossary.html#cgi" title="见词汇">CGI</a>脚本。</p>

    <p>如果您需要更多的灵活性，可以使用<code class="directive"><a href="./mod/mod_alias.html#aliasmatch">AliasMatch</a></code>和<code class="directive"><a href="./mod/mod_alias.html#scriptaliasmatch">ScriptAliasMatch</a></code>指令执行强大的基于<a class="glossarylink" href="./glossary.html#regex" title="见词汇">正则表达式</a>的匹配和替换。例如，</p>

    <pre class="prettyprint lang-config">ScriptAliasMatch "^/~([a-zA-Z0-9]+)/cgi-bin/(.+)"   "/home/$1/cgi-bin/$2"</pre>


    <p>会将请求映射到<code>http://example.com/~user/cgi-bin/script.cgi</code>到这条路<code>/home/user/cgi-bin/script.cgi</code>并将生成的文件视为CGI脚本。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="user" id="user">用户目录</a></h2>

    <p>传统上，在Unix系统上，特定<em>用户</em>的主目录可以称为<code>~user/</code> 。模块<code class="module"><a href="./mod/mod_userdir.html">mod_userdir</a></code>通过允许使用以下URL来访问每个用户主目录下的文件，将这一思想扩展到了网络。</p>

<div class="example"><p><code>http://www.example.com/~user/file.html</code></p></div>

    <p>出于安全原因，从Web直接访问用户的主目录是不合适的。因此， <code class="directive"><a href="./mod/mod_userdir.html#userdir">UserDir</a></code>伪指令指定Web文件所在的用户主目录下的目录。使用默认设置<code>Userdir public_html</code> ，上面的URL映射到目录类似的文件<code>/home/user/public_html/file.html</code>哪里<code>/home/user/</code>是在中指定的用户主目录<code>/etc/passwd</code> 。</p>

    <p>还有其他几种形式的<code>Userdir</code>您可以在以下系统上使用的指令<code>/etc/passwd</code>不包含主目录的位置。</p>

    <p>有人发现“〜”符号（通常在网络上以“ <code>%7e</code> ），很尴尬，并且喜欢使用替代字符串来表示用户目录。mod_userdir不支持此功能。但是，如果用户的主目录是按常规方式构建的，则可以使用<code class="directive"><a href="./mod/mod_alias.html#aliasmatch">AliasMatch</a></code>指令以达到预期的效果。例如，使<code>http://www.example.com/upages/user/file.html</code>映射到<code>/home/user/public_html/file.html</code> ，请使用以下<code>AliasMatch</code>指示：</p>

    <pre class="prettyprint lang-config">AliasMatch "^/upages/([a-zA-Z0-9]+)(/(.*))?$"   "/home/$1/public_html/$3"</pre>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="redirect" id="redirect">URL重定向</a></h2>

    <p>上一节中讨论的配置指令告诉httpd从文件系统中的特定位置获取内容，并将其返回给客户端。有时，最好改为通知客户端所请求的内容位于其他URL，并指示客户端使用新URL发出新请求。这称为<em>重定向</em> ，由<code class="directive"><a href="./mod/mod_alias.html#redirect">Redirect</a></code>指示。例如，如果目录的内容<code>/foo/</code>在下面<code class="directive"><a href="./mod/core.html#documentroot">DocumentRoot</a></code>移到新目录<code>/bar/</code> ，您可以指示客户在新位置请求内容，如下所示：</p>

    <pre class="prettyprint lang-config">Redirect permanent "/foo/"   "http://www.example.com/bar/"</pre>


    <p>这将重定向从<code>/foo/</code>到相同的网址路径<code>www.example.com</code>服务器与<code>/bar/</code>替代<code>/foo/</code> 。您可以将客户端重定向到任何服务器，而不仅仅是原始服务器。</p>

    <p>httpd还提供了一个<code class="directive"><a href="./mod/mod_alias.html#redirectmatch">RedirectMatch</a></code>指令，用于更复杂的重写问题。例如，要将网站首页的请求重定向到其他站点，而又不理会所有其他请求，请使用以下配置：</p>

    <pre class="prettyprint lang-config">RedirectMatch permanent "^/$"    "http://www.example.com/startpage.html"</pre>


    <p>或者，要将一个站点上的所有页面临时重定向到另一站点上的特定页面，请使用以下命令：</p>

    <pre class="prettyprint lang-config">RedirectMatch temp ".*"  "http://othersite.example.com/startpage.html"</pre>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="proxy" id="proxy">反向代理</a></h2>

<p>httpd还允许您将远程文档带入本地服务器的URL空间。这种技术称为<em>反向代理，</em>因为Web服务器通过从远程服务器中获取文档并将其返回给客户端来充当代理服务器。它与常规（正向）代理不同，因为对于客户端来说，文档似乎来自反向代理服务器。</p>

<p>在以下示例中，当客户根据<code>/foo/</code>目录中，服务器会从<code>/bar/</code>目录在<code>internal.example.com</code>并将它们返回给客户端，就好像它们来自本地服务器一样。</p>

<pre class="prettyprint lang-config">ProxyPass "/foo/" "http://internal.example.com/bar/"
ProxyPassReverse "/foo/" "http://internal.example.com/bar/"
ProxyPassReverseCookieDomain internal.example.com public.example.com
ProxyPassReverseCookiePath "/foo/" "/bar/"</pre>


<p>的<code class="directive"><a href="./mod/mod_proxy.html#proxypass">ProxyPass</a></code>配置服务器以获取适当的文档，而<code class="directive"><a href="./mod/mod_proxy.html#proxypassreverse">ProxyPassReverse</a></code>指令重写源自的重定向<code>internal.example.com</code>这样它们就可以定位到本地服务器上的相应目录。同样， <code class="directive"><a href="./mod/mod_proxy.html#proxypassreversecookiedomain">ProxyPassReverseCookieDomain</a></code>和<code class="directive"><a href="./mod/mod_proxy.html#proxypassreversecookiepath">ProxyPassReverseCookiePath</a></code>重写后端服务器设置的cookie。</p>
<p>重要的是要注意，但是，文档内部的链接不会被重写。因此，任何绝对链接<code>internal.example.com</code>将导致客户端脱离代理服务器并直接向<code>internal.example.com</code> 。您可以使用以下方式修改页面中的这些链接（和其他内容）： <code class="module"><a href="./mod/mod_substitute.html">mod_substitute</a></code> 。</p>

<pre class="prettyprint lang-config">Substitute "s/internal\.example\.com/www.example.com/i"</pre>


<p>要更复杂地重写HTML和XHTML中的链接， <code class="module"><a href="./mod/mod_proxy_html.html">mod_proxy_html</a></code>模块也可用。它允许您创建需要重写的URL映射，以便可以处理复杂的代理方案。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="rewrite" id="rewrite">改写引擎</a></h2>

    <p>如果需要更强大的替换功能，则由<code class="module"><a href="./mod/mod_rewrite.html">mod_rewrite</a></code>可能会有用。该模块提供的指令可以使用请求的特征（例如浏览器类型或源IP地址）来决定从何处提供内容。另外，mod_rewrite可以使用外部数据库文件或程序来确定如何处理请求。重写引擎能够执行上述所有三种类型的映射：内部重定向（别名），外部重定向和代理。<a href="rewrite/index.html">详细的mod_rewrite文档</a>中讨论了许多使用mod_rewrite的实际示例。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="notfound" id="notfound">文件未找到</a></h2>

    <p>不可避免地，将请求在文件系统中找不到匹配文件的URL。发生这种情况有几个原因。在某些情况下，可能是由于将文档从一个位置移动到另一位置的结果。在这种情况下，最好使用<a href="#redirect">URL重定向</a>来通知客户端资源的新位置。这样，即使资源位于新位置，您也可以确保旧书签和链接将继续起作用。</p>

    <p>导致“找不到文件”错误的另一个常见原因是直接在浏览器中或在HTML链接中意外误入URL。 httpd提供模块<code class="module"><a href="./mod/mod_speling.html">mod_speling</a></code> （原文如此）以帮助解决此问题。激活此模块后，它将拦截“找不到文件”错误，并寻找具有相似文件名的资源。如果找到一个这样的文件，则mod_speling将向客户端发送HTTP重定向，以通知其正确的位置。如果找到几个“关闭”文件，则将向客户端显示可用替代项的列表。</p>

    <p>mod_speling的一个特别有用的功能是，它将比较文件名而不考虑大小写。这可以帮助用户不了解URL和unix文件系统区分大小写的系统。但是，除了偶尔进行URL校正外，将mod_speling用于其他任何事情都可能给服务器带来额外的负担，因为每个“不正确”的请求都将跟随URL重定向和来自客户端的新请求。</p>

    <p><code class="module"><a href="./mod/mod_dir.html">mod_dir</a></code>提供<code class="directive"><a href="./mod/mod_dir.html#fallbackresource">FallbackResource</a></code> ，可用于将虚拟URI映射到真实资源，然后为它们提供服务。这是一个非常有用的替代品<code class="module"><a href="./mod/mod_rewrite.html">mod_rewrite</a></code>实施“前端控制器”时</p>

    <p>如果所有查找内容的尝试均失败，则httpd将返回带有HTTP状态代码404（找不到文件）的错误页面。此页面的外观由<code class="directive"><a href="./mod/core.html#errordocument">ErrorDocument</a></code>指令，并且可以按照“ <a href="custom-error.html">自定义错误响应”</a>文档中讨论的灵活方式<a href="custom-error.html">自定义</a> 。</p>
</div><div class="top"><a href="#page-header"><img alt="最佳" src="./images/up.gif"></a></div>
<div class="section">
<h2><a name="other" id="other">其他URL映射模块</a></h2>



    <p>可用于URL映射的其他模块包括：</p>

    <ul>
    <li><code class="module"><a href="./mod/mod_actions.html">mod_actions</a></code> -根据请求方法或资源MIME类型将请求映射到CGI脚本。</li>
    <li><code class="module"><a href="./mod/mod_dir.html">mod_dir</a></code> -提供斜杠到索引文件（例如）的基本映射<code>index.html</code> 。</li>
    <li><code class="module"><a href="./mod/mod_imagemap.html">mod_imagemap</a></code> -根据用户单击HTML文档中嵌入的图像的位置，将请求映射到URL。</li>
    <li><code class="module"><a href="./mod/mod_negotiation.html">mod_negotiation</a></code> -根据客户的偏好（例如语言或内容压缩）选择合适的文档。</li>
    </ul>

</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="./mod/index.html">模块</a> | <a href="./mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="./glossary.html">词汇表</a> | <a href="./sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>