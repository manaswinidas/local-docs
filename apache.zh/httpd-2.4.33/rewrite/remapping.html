<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>使用mod_rewrite重定向和重新映射-Apache HTTP Server版本2.4</title>
<link href="../style/css/manual-zip.css" rel="stylesheet" type="text/css" title="Main stylesheet" media="all">
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" type="text/css" title="No Sidebar - Default font size" media="all">
<link href="../style/css/manual-print.css" rel="stylesheet" type="text/css" media="print"><link rel="stylesheet" type="text/css" href="../style/css/prettify.css">
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>
</head>
<body id="manual-page" ><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p>
<p class="apache">Apache HTTP服务器版本2.4</p>
<img alt="" src="../images/feather.png"></div>
<div class="up"><a href="./index.html"><img title="<-" alt="<-" src="../images/left.gif"></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> > <a href="http://httpd.apache.org/">HTTP服务器</a> > <a href="http://httpd.apache.org/docs/">文档</a> > <a href="../index.html">版本2.4</a> > <a href="./index.html">重写</a></div><div id="page-content"><div id="preamble"><h1>使用mod_rewrite重定向和重新映射</h1>



<p>本文件是对<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code> <a href="../mod/mod_rewrite.html">参考文档</a> 。它描述了如何使用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>重定向和重新映射请求。这包括mod_rewrite常用用法的许多示例，包括每种用法的详细说明。</p>

<div class="warning">请注意，这些示例中的许多示例在您的特定服务器配置中都不会起作用，因此，理解它们，而不只是将示例剪切并粘贴到您的配置中，这一点很重要。</div>

</div>
<div id="quickview"><a href="https://www.apache.org/foundation/contributing.html" class="badge"><img src="https://www.apache.org/images/SupportApache-small.png" alt="支持Apache！"></a><ul id="toc"><li><img alt="" src="../images/down.gif"> <a href="#old-to-new">从旧到新（内部）</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#old-to-new-extern">从旧到新的重写（外部）</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#movehomedirs">资源已移至另一台服务器</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#static-to-dynamic">从静态到动态</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#backward-compatibility">向后兼容文件扩展名更改</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#canonicalhost">规范主机名</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#multipledirs">在多个目录中搜索页面</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#archive-access-multiplexer">重定向到地理位置分布式服务器</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#browser-dependent-content">浏览器相关内容</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#canonicalurl">规范网址</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#moveddocroot">感动<code>DocumentRoot</code></a></li>
<li><img alt="" src="../images/down.gif"> <a href="#fallback-resource">后备资源</a></li>
<li><img alt="" src="../images/down.gif"> <a href="#rewrite-query">重写查询字符串</a></li>
</ul><h3>也可以看看</h3><ul class="seealso"><li><a href="../mod/mod_rewrite.html">模块文件</a></li><li><a href="intro.html">mod_rewrite简介</a></li><li><a href="access.html">控制访问</a></li><li><a href="vhosts.html">虚拟主机</a></li><li><a href="proxy.html">代理</a></li><li><a href="rewritemap.html">使用RewriteMap</a></li><li><a href="advanced.html">先进技术</a></li><li><a href="avoid.html">何时不使用mod_rewrite</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="old-to-new" id="old-to-new">从旧到新（内部）</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>假设我们最近已将页面重命名<code>foo.html</code>至<code>bar.html</code>并且现在想提供旧的URL以实现向后兼容。但是，我们希望旧URL的用户甚至无法识别页面已被重命名-也就是说，我们不希望在其浏览器中更改地址。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>我们通过以下规则在内部将旧网址重写为新网址：</p>

<pre class="prettyprint lang-config">RewriteEngine  on
RewriteRule    "^<strong>/foo</strong>\.html$"  "<strong>/bar</strong>.html" [PT]</pre>

    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="old-to-new-extern" id="old-to-new-extern">从旧到新的重写（外部）</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>再次假设我们最近已重命名页面<code>foo.html</code>至<code>bar.html</code>并且现在想提供旧的URL以实现向后兼容。但是这一次，我们希望旧URL的用户得到新的提示，即他们的浏览器的“位置”字段也应更改。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>我们强制将HTTP重定向到新URL，从而导致浏览器发生更改，因此用户可以查看：</p>

<pre class="prettyprint lang-config">RewriteEngine  on
RewriteRule    "^<strong>/foo</strong>\.html$"  "<strong>bar</strong>.html"  [<strong>R</strong>]</pre>

</dd>

<dt>讨论区</dt>

    <dd>
    <p>与上面的<a href="#old-to-new-intern">内部</a>示例相比，在此示例中，我们可以简单地使用Redirect指令。在较早的示例中使用了mod_rewrite，以便从客户端隐藏重定向：</p>

    <pre class="prettyprint lang-config">Redirect "/foo.html" "/bar.html"</pre>


    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="movehomedirs" id="movehomedirs">资源已移至另一台服务器</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>如果资源已移至另一台服务器，则您可能希望在人们更新其书签的同时，URL在旧服务器上继续工作一段时间。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>您可以使用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>将这些URL重定向到新服务器，但是您也可以考虑使用Redirect或RedirectMatch指令。</p>

<pre class="prettyprint lang-config">#With mod_rewrite
RewriteEngine on
RewriteRule   "^/docs/(.+)"  "http://new.example.com/docs/$1"  [R,L]</pre>


<pre class="prettyprint lang-config">#With RedirectMatch
RedirectMatch "^/docs/(.*)" "http://new.example.com/docs/$1"</pre>


<pre class="prettyprint lang-config">#With Redirect
Redirect "/docs/" "http://new.example.com/docs/"</pre>

    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="static-to-dynamic" id="static-to-dynamic">从静态到动态</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>我们如何转换静态页面<code>foo.html</code>变成动态变体<code>foo.cgi</code>以无缝的方式，即在浏览器/用户未通知的情况下。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>我们只是将URL重写为CGI脚本，然后将处理程序强制为<strong>cgi-script，</strong>以便将其作为CGI程序执行。这样一来<code>/~quux/foo.html</code>在内部导致对<code>/~quux/foo.cgi</code> 。</p>

<pre class="prettyprint lang-config">RewriteEngine  on
RewriteBase    "/~quux/"
RewriteRule    "^foo\.html$"  "foo.cgi"  [H=<strong>cgi-script</strong>]</pre>

    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="backward-compatibility" id="backward-compatibility">向后兼容文件扩展名更改</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>迁移后如何使URL向后兼容（实际上仍然存在） <code>document.YYYY</code>至<code>document.XXXX</code> ，例如翻译一堆<code>.html</code>文件到<code>.php</code> ？</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>我们将该名称重写为其基名称，并测试是否存在新扩展名。如果存在，则使用该名称，否则将URL重写为其原始状态。</p>

<pre class="prettyprint lang-config">#   backward compatibility ruleset for
#   rewriting document.html to document.php
#   when and only when document.php exists
&lt;Directory "/var/www/htdocs"&gt;
    RewriteEngine on
    RewriteBase "/var/www/htdocs"

    RewriteCond "$1.php" -f
    RewriteCond "$1.html" !-f
    RewriteRule "^(.*).html$" "$1.php"
&lt;/Directory&gt;</pre>

    </dd>

    <dt>讨论区</dt>
    <dd>
    <p>本示例通过利用规则集的执行顺序，使用了mod_rewrite经常被忽略的功能。特别是，mod_rewrite在评估RewriteCond指令之前先评估RewriteRule的左侧。因此，在评估RewriteCond指令时已经定义了$ 1。这使我们可以测试原始文件的存在（ <code>document.html</code> ）和目标（ <code>document.php</code> ）文件使用相同的基本文件名。</p>

    <p>此规则集旨在在每个目录的上下文中使用（在<directory>块中或在.htaccess文件中），以便<code>-f</code>检查正在寻找正确的目录路径。您可能需要设置一个<code class="directive"><a href="../mod/mod_rewrite.html#rewritebase">RewriteBase</a></code>指令以指定您正在使用的目录库。</directory></p>
    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="canonicalhost" id="canonicalhost">规范主机名</a></h2>



      <dl>
        <dt>描述：</dt>

        <dd>该规则的目标是强制使用特定主机名，而不是可能用于访问同一站点的其他主机名。例如，如果您希望强制使用<strong>www.example.com</strong>而不是<strong>example.com</strong> ，则可以使用以下配方的变体。</dd>

        <dt>解：</dt>

        <dd>

<p>解决此问题的最佳方法根本不涉及mod_rewrite，而是使用<code class="directive"><a href="../mod/mod_alias.html#redirect">Redirect</a></code>放置在虚拟主机中的非规范主机名的指令。</p>

<pre class="prettyprint lang-config">&lt;VirtualHost *:80&gt;
  ServerName undesired.example.com
  ServerAlias example.com notthis.example.com

  Redirect "/" "http://www.example.com/"
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
  ServerName www.example.com
&lt;/VirtualHost&gt;</pre>


<p>您也可以使用<code class="directive"><a href="../mod/core.html#if"><If></a></code>指示：</p>

<pre class="prettyprint lang-config">&lt;If "%{HTTP_HOST} != 'www.example.com'"&gt;
    Redirect "/" "http://www.example.com/"
&lt;/If&gt;</pre>


<p>或者，例如，要将您的网站的一部分重定向到HTTPS，您可以执行以下操作：</p>

<pre class="prettyprint lang-config">&lt;If "%{SERVER_PROTOCOL} != 'HTTPS'"&gt;
    Redirect "/admin/" "https://www.example.com/admin/"
&lt;/If&gt;</pre>


<p>如果出于某种原因您仍然想要使用<code>mod_rewrite</code> -例如，如果您需要使用它来处理更多的RewriteRules，则可以使用以下配方之一。</p>

<p>对于运行在80以外的端口上的站点：</p>
<pre class="prettyprint lang-config">RewriteCond "%{HTTP_HOST}"   "!^www\.example\.com" [NC]
RewriteCond "%{HTTP_HOST}"   "!^$"
RewriteCond "%{SERVER_PORT}" "!^80$"
RewriteRule "^/?(.*)"        "http://www.example.com:%{SERVER_PORT}/$1" [L,R,NE]</pre>


<p>对于在端口80上运行的站点</p>
<pre class="prettyprint lang-config">RewriteCond "%{HTTP_HOST}"   "!^www\.example\.com" [NC]
RewriteCond "%{HTTP_HOST}"   "!^$"
RewriteRule "^/?(.*)"        "http://www.example.com/$1" [L,R,NE]</pre>


        <p>如果您想为所有域名一般做到这一点-那就是，如果你想重定向<strong>的example.com</strong> <strong>www.example.com</strong>的<strong>example.com</strong>的所有可能的值，可以使用下面的方法：</p>

<pre class="prettyprint lang-config">RewriteCond "%{HTTP_HOST}" "!^www\." [NC]
RewriteCond "%{HTTP_HOST}" "!^$"
RewriteRule "^/?(.*)"      "http://www.%{HTTP_HOST}/$1" [L,R,NE]</pre>


    <p>这些规则集将在您的主服务器配置文件中或在<code>.htaccess</code>文件放在<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>服务器。</p>
        </dd>
      </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="multipledirs" id="multipledirs">在多个目录中搜索页面</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>特定资源可能存在于多个位置之一，我们希望在请求资源时在这些位置中查找该资源。也许我们最近已经重新排列了目录结构，将内容分为几个位置。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>以下规则集在两个目录中搜索以找到资源，并且，如果在两个位置均未找到资源，则将尝试仅在请求的位置之外提供资源。</p>

<pre class="prettyprint lang-config">RewriteEngine on

#   first try to find it in dir1/...
#   ...and if found stop and be happy:
RewriteCond         "%{DOCUMENT_ROOT}/<strong>dir1</strong>/%{REQUEST_URI}"  -f
RewriteRule "^(.+)" "%{DOCUMENT_ROOT}/<strong>dir1</strong>/$1"  [L]

#   second try to find it in dir2/...
#   ...and if found stop and be happy:
RewriteCond         "%{DOCUMENT_ROOT}/<strong>dir2</strong>/%{REQUEST_URI}"  -f
RewriteRule "^(.+)" "%{DOCUMENT_ROOT}/<strong>dir2</strong>/$1"  [L]

#   else go on for other Alias or ScriptAlias directives,
#   etc.
RewriteRule   "^"  "-"  [PT]</pre>

    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="archive-access-multiplexer" id="archive-access-multiplexer">重定向到地理位置分布式服务器</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
    <p>我们的网站有很多镜像，并希望将人们重定向到他们所所在的国家/地区。</p>
    </dd>

    <dt>解：</dt>

    <dd>
    <p>查看发出请求的客户的主机名，我们确定他们来自哪个国家。如果我们无法在其IP地址上进行查找，我们将退回到默认服务器。</p>
    <p>我们将使用<code class="directive"><a href="../mod/mod_rewrite.html#rewritemap">RewriteMap</a></code>指令来构建我们希望使用的服务器列表。</p>

<pre class="prettyprint lang-config">HostnameLookups on
RewriteEngine on
RewriteMap    multiplex         "txt:/path/to/map.mirrors"
RewriteCond   "%{REMOTE_HOST}"  "([a-z]+)$" [NC]
RewriteRule   "^/(.*)$"  "${multiplex:<strong>%1</strong>|http://www.example.com/}$1"  [R,L]</pre>


<div class="example"><p><code>## map.mirrors -- Multiplexing Map<br> <br> de http://www.example.de/<br> uk http://www.example.uk/<br> com http://www.example.com/<br> ##EOF##</code></p></div>
    </dd>

    <dt>讨论区</dt>
    <dd>
    <div class="warning">该规则集依赖<code class="directive"><a href="../mod/core.html#hostnamelookups">HostNameLookups</a></code>被设置<code>on</code> ，这可能会严重影响性能。</div>

    <p>的<code class="directive"><a href="../mod/mod_rewrite.html#rewritecond">RewriteCond</a></code>指令捕获请求客户端的主机名的最后一部分-国家/地区代码-并且以下RewriteRule使用该值在映射文件中查找适当的镜像主机。</p>
    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="browser-dependent-content" id="browser-dependent-content">浏览器相关内容</a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
      <p>我们希望基于请求内容的浏览器或用户代理提供不同的内容。</p>
    </dd>

    <dt>解：</dt>

    <dd>
      <p>我们必须根据HTTP标头“ User-Agent”确定要提供的内容。以下配置执行以下操作：如果HTTP标头“ User-Agent”包含“ Mozilla / 3”，则页面<code>foo.html</code>被重写为<code>foo.NS.html</code>并且重写停止。如果浏览器是版本1或2的“ Lynx”或“ Mozilla”，则URL变为<code>foo.20.html</code> 。所有其他浏览器都接收页面<code>foo.32.html</code> 。这是通过以下规则集完成的：</p>

<pre class="prettyprint lang-config">RewriteCond "%{HTTP_USER_AGENT}"  "^<strong>Mozilla/3</strong>.*"
RewriteRule "^foo\.html$"         "foo.<strong>NS</strong>.html"          [<strong>L</strong>]

RewriteCond "%{HTTP_USER_AGENT}"  "^Lynx/" [OR]
RewriteCond "%{HTTP_USER_AGENT}"  "^Mozilla/[12]"
RewriteRule "^foo\.html$"         "foo.<strong>20</strong>.html"          [<strong>L</strong>]

RewriteRule "^foo\.html$"         "foo.<strong>32</strong>.html"          [<strong>L</strong>]</pre>

    </dd>
  </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="canonicalurl" id="canonicalurl">规范网址</a></h2>



<dl>
 <dt>描述：</dt>

   <dd>
     <p>在某些Web服务器上，一个资源有多个URL。通常，存在规范的URL（实际使用和分发的URL）以及仅仅是快捷方式，内部的URL等等。无论用户随请求提供了哪个URL，最终他们都应该在浏览器地址栏中看到规范的URL。</p>
   </dd>

   <dt>解：</dt>

     <dd>
       <p>我们对所有非规范URL进行外部HTTP重定向，以在浏览器的位置视图以及所有后续请求中修复它们。在下面的示例规则集中，我们将替换<code>/puppies</code>和<code>/canines</code>通过规范<code>/dogs</code> 。</p>

<pre class="prettyprint lang-config">RewriteRule   "^/(puppies|canines)/(.*)"    "/dogs/$2"  [R]</pre>

        </dd>

     <dt>讨论：</dt>
     <dd>这实际上应该使用Redirect或RedirectMatch指令完成：<pre class="prettyprint lang-config">RedirectMatch "^/(puppies|canines)/(.*)" "/dogs/$2"</pre>

     </dd>
      </dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="moveddocroot" id="moveddocroot">感动<code>DocumentRoot</code></a></h2>

  

  <dl>
    <dt>描述：</dt>

    <dd>
<p>通常情况下<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>网络服务器的地址直接与“ <code>/</code> ”。但是通常这些数据并不是真正的最高优先级。例如，您可能希望访问者在首次进入网站时进入特定的子目录<code>/about/</code> 。这可以使用以下规则集来完成：</p>
</dd>

    <dt>解：</dt>

    <dd>
      <p>我们重定向URL <code>/</code>至<code>/about/</code> ：</p>

<pre class="prettyprint lang-config">RewriteEngine on
RewriteRule   "^/$"  "/about/"  [<strong>R</strong>]</pre>


<p>请注意，这也可以使用<code class="directive"><a href="../mod/mod_alias.html#redirectmatch">RedirectMatch</a></code>指示：</p>

<pre class="prettyprint lang-config">RedirectMatch "^/$" "http://example.com/about/"</pre>


<p>另请注意，该示例仅重写根URL。也就是说，它重写了<code>http://example.com/</code> ，但不要求<code>http://example.com/page.html</code> 。如果实际上已经更改了文档根目录-也就是说，如果<strong>所有</strong>内容实际上都在该子目录中，那么最好简单地更改您的文档根目录<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>指令，或将所有内容移动到一个目录中，而不是重写URL。</p>
</dd>
</dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="fallback-resource" id="fallback-resource">后备资源</a></h2>


<dl>
<dt>描述：</dt>
<dd>您希望一个资源（例如，某个文件，例如index.php）来处理到达特定目录的所有请求，但那些应该进入现有资源（例如图像或css文件）的请求除外。</dd>

<dt>解：</dt>
<dd>
<p>从2.2.16版开始，您应该使用<code class="directive"><a href="../mod/mod_dir.html#fallbackresource">FallbackResource</a></code>为此的指令：</p>

<pre class="prettyprint lang-config">&lt;Directory "/var/www/my_blog"&gt;
  FallbackResource "index.php"
&lt;/Directory&gt;</pre>


<p>但是，在Apache的早期版本中，或者如果您的需求比这更复杂，则可以使用以下重写集的变体来完成同一件事：</p>

<pre class="prettyprint lang-config">&lt;Directory "/var/www/my_blog"&gt;
  RewriteBase "/my_blog"

  RewriteCond "/var/www/my_blog/%{REQUEST_FILENAME}" !-f
  RewriteCond "/var/www/my_blog/%{REQUEST_FILENAME}" !-d
  RewriteRule "^" "index.php" [PT]
&lt;/Directory&gt;</pre>


<p>另一方面，如果您希望将请求的URI作为查询字符串参数传递给index.php，则可以将该RewriteRule替换为：</p>

<pre class="prettyprint lang-config">RewriteRule "(.*)" "index.php?$1" [PT,QSA]</pre>


<p>请注意，这些规则集可以在<code>.htaccess</code>文件，以及成<directory>块。</directory></p>

</dd>

</dl>

</div><div class="top"><a href="#page-header"><img alt="最佳" src="../images/up.gif"></a></div>
<div class="section">
<h2><a name="rewrite-query" id="rewrite-query">重写查询字符串</a></h2>


<dl>
<dt>描述：</dt>
<dd>您想从查询字符串中捕获特定值，然后替换它或将其合并到URL的另一个组件中。</dd>

<dt>解决方案：</dt>
<dd>
<p>本节中的许多解决方案都将使用相同的条件，这会将匹配的值保留在％2反向引用中。 ％1是查询字符串的开头（取决于兴趣关键字），而％3是其余部分。对于灵活性和避免替换中使用双'&&'而言，此条件有点复杂。</p>
<ul>
  <li>此解决方案删除匹配的键和值：<pre class="prettyprint lang-config"># Remove mykey=???
RewriteCond "%{QUERY_STRING}" "(.*(?:^|&amp;))mykey=([^&amp;]*)&amp;?(.*)&amp;?$"
RewriteRule "(.*)" "$1?%1%3"</pre>

  </li>

  <li>此解决方案使用URL替换中的捕获值，并通过附加'？来丢弃其余的原始查询。'：<pre class="prettyprint lang-config"># Copy from query string to PATH_INFO
RewriteCond "%{QUERY_STRING}" "(.*(?:^|&amp;))mykey=([^&amp;]*)&amp;?(.*)&amp;?$"
RewriteRule "(.*)" "$1/products/%2/?" [PT]</pre>

  </li>

  <li>此解决方案在随后的条件下检查捕获的值：<pre class="prettyprint lang-config"># Capture the value of mykey in the query string
RewriteCond "%{QUERY_STRING}" "(.*(?:^|&amp;))mykey=([^&amp;]*)&amp;?(.*)&amp;?$"
RewriteCond "%2" !=not-so-secret-value 
RewriteRule "(.*)" - [F]</pre>

  </li>

  <li>此解决方案与前面的解决方案相反，将路径部分（也许是PATH_INFO）从URL复制到查询字符串中。
<pre class="prettyprint lang-config"># The desired URL might be /products/kitchen-sink, and the script expects
# /path?products=kitchen-sink.
RewriteRule "^/?path/([^/]+)/([^/]+)" "/path?$1=$2" [PT]</pre>

  </li>
</ul>

</dd>

</dl>
</div></div>
<div id="footer">
<p class="apache">版权所有2018 The Apache Software Foundation。<br>根据<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache许可，版本2.0许可</a> 。</p>
<p class="menu"><a href="../mod/index.html">模块</a> | <a href="../mod/directives.html">指令</a> | <a href="http://wiki.apache.org/httpd/FAQ">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">网站地图</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>

</body></html>