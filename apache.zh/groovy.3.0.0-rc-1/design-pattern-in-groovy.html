<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Groovy中的设计模式</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>Groovy中的设计模式</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_patterns">1。模式</a>
<ul class="sectlevel2">
<li><a href="#_abstract_factory_pattern">1.1。抽象工厂模式</a>
<ul class="sectlevel3">
<li><a href="#_example">1.1.1。例</a></li>
</ul>
</li>
<li><a href="#_adapter_pattern">1.2。适配器图案</a>
<ul class="sectlevel3">
<li><a href="#_delegation_example">1.2.1。委托示例</a></li>
<li><a href="#_inheritance_example">1.2.2。继承实例</a></li>
<li><a href="#_adapting_using_closures">1.2.3。使用闭包进行适应</a></li>
<li><a href="#_adapting_using_the_expandometaclass">1.2.4。使用ExpandoMetaClass进行适应</a></li>
</ul>
</li>
<li><a href="#_bouncer_pattern">1.3。弹跳器模式</a>
<ul class="sectlevel3">
<li><a href="#_null_checking_example">1.3.1。空检查示例</a></li>
<li><a href="#_validation_example">1.3.2。验证范例</a></li>
</ul>
</li>
<li><a href="#_chain_of_responsibility_pattern">1.4。责任链模式</a>
<ul class="sectlevel3">
<li><a href="#_example_2">1.4.1。例</a></li>
</ul>
</li>
<li><a href="#_composite_pattern">1.5。复合图案</a>
<ul class="sectlevel3">
<li><a href="#_example_3">1.5.1。例</a></li>
</ul>
</li>
<li><a href="#_decorator_pattern">1.6。装饰图案</a>
<ul class="sectlevel3">
<li><a href="#_traditional_example">1.6.1。传统例子</a></li>
<li><a href="#_a_touch_of_dynamic_behaviour">1.6.2。一点动感的行为</a></li>
<li><a href="#_runtime_behaviour_embellishment">1.6.3。运行时行为修饰</a></li>
<li><a href="#_more_dynamic_decorating">1.6.4。更动感的装饰</a></li>
<li><a href="#_decorating_with_an_interceptor">1.6.5。用拦截器装饰</a></li>
<li><a href="#_decorating_with_java_lang_reflect_proxy">1.6.6。用java.lang.reflect装饰。代理</a></li>
<li><a href="#_decorating_with_spring">1.6.7。用春天装饰</a></li>
<li><a href="#_asynchronous_decorators_using_gpars">1.6.8。使用GPar的异步装饰器</a></li>
</ul>
</li>
<li><a href="#_delegation_pattern">1.7。委托模式</a>
<ul class="sectlevel3">
<li><a href="#_implement_delegation_pattern_using_expandometaclass">1.7.1。使用ExpandoMetaClass实现委托模式</a></li>
<li><a href="#_implement_delegation_pattern_using_delegate_annotation">1.7.2。使用@Delegate注释实现委派模式</a></li>
</ul>
</li>
<li><a href="#_flyweight_pattern">1.8。跳线模式</a>
<ul class="sectlevel3">
<li><a href="#_example_4">1.8.1。例</a></li>
</ul>
</li>
<li><a href="#_iterator_pattern">1.9。迭代器模式</a></li>
<li><a href="#_loan_my_resource_pattern">1.10。贷款我的资源模式</a>
<ul class="sectlevel3">
<li><a href="#_example_5">1.10.1。例</a></li>
</ul>
</li>
<li><a href="#_null_object_pattern">1.11。空对象模式</a>
<ul class="sectlevel3">
<li><a href="#_simple_example">1.11.1。简单的例子</a></li>
<li><a href="#_tree_example">1.11.2。树例</a></li>
</ul>
</li>
<li><a href="#_pimp_my_library_pattern">1.12。皮条客我的图书馆模式</a>
<ul class="sectlevel3">
<li><a href="#_example_6">1.12.1。例</a></li>
</ul>
</li>
<li><a href="#_proxy_pattern">1.13。代理模式</a>
<ul class="sectlevel3">
<li><a href="#_example_7">1.13.1。例</a></li>
</ul>
</li>
<li><a href="#_singleton_pattern">1.14。单例模式</a>
<ul class="sectlevel3">
<li><a href="#_example_the_classic_java_singleton">1.14.1。示例：经典Java单例</a></li>
<li><a href="#_example_singleton_via_metaprogramming">1.14.2。示例：通过元编程的单例</a></li>
<li><a href="#_guice_example">1.14.3。吉斯例子</a></li>
<li><a href="#_spring_example">1.14.4。春天的例子</a></li>
<li><a href="#_further_information">1.14.5。更多信息</a></li>
</ul>
</li>
<li><a href="#_state_pattern">1.15。状态模式</a>
<ul class="sectlevel3">
<li><a href="#_example_8">1.15.1。例</a></li>
<li><a href="#_variation_1_leveraging_interface_oriented_design">1.15.2。变体1：利用面向接口的设计</a></li>
<li><a href="#_variation_2_extract_state_pattern_logic">1.15.3。方案2：提取状态模式逻辑</a></li>
<li><a href="#_variation_3_bring_on_the_dsl">1.15.4。变体3：启用DSL</a></li>
</ul>
</li>
<li><a href="#_strategy_pattern">1.16。策略模式</a>
<ul class="sectlevel3">
<li><a href="#_example_9">1.16.1。例</a></li>
</ul>
</li>
<li><a href="#_template_method_pattern">1.17。模板方法模式</a>
<ul class="sectlevel3">
<li><a href="#_example_10">1.17.1。例</a></li>
</ul>
</li>
<li><a href="#_visitor_pattern">1.18。访客模式</a>
<ul class="sectlevel3">
<li><a href="#_simple_example_2">1.18.1。简单的例子</a></li>
<li><a href="#_advanced_example">1.18.2。进阶范例</a>
<ul class="sectlevel4">
<li><a href="#_why_to_use_this">为什么要使用这个</a></li>
<li><a href="#_what_happens_if_we_add_a_new_type">如果添加新类型会怎样？</a></li>
<li><a href="#_what_if_we_want_to_have_different_iteration_patterns">如果我们想拥有不同的迭代模式怎么办？</a></li>
<li><a href="#_make_it_groovy">使其时髦</a></li>
<li><a href="#_summary">摘要</a></li>
</ul>
</li>
<li><a href="#_further_information_2">1.18.3。更多信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_references">2。参考文献</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>在Java中使用<a href="http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29">设计模式</a>是一个公认的话题。设计模式也适用于Groovy：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一些模式可以直接继承（并且可以利用常规的Groovy语法改进来提高可读性）</p>
</li>
<li>
<p>不再需要某些模式，因为它们是语言中内置的，或者因为Groovy支持更好的方式来实现模式的意图</p>
</li>
<li>
<p>一些必须在设计级别用其他语言表达的模式可以直接在Groovy中实现（由于Groovy可以模糊设计与实现之间的区别）</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_patterns"><a class="anchor" href="#_patterns"></a> 1。模式</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_abstract_factory_pattern"><a class="anchor" href="#_abstract_factory_pattern"></a> 1.1。抽象工厂模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">抽象工厂模式</a>提供了一种封装一组具有共同主题的单个工厂的方法。它体现了普通工厂的意图，即使用接口消除了对代码的需要，从而知道了该接口背后的具体实现，但适用于一组接口并选择了实现这些接口的整个具体类家族。</p>
</div>
<div class="paragraph">
<p>例如，我可能具有Button，TextField和Scrollbar接口。我可能将WindowsButton，MacButton，FlashButton作为Button的具体类。我可能将WindowsScrollBar，MacScrollBar和FlashScrollBar作为ScrollBar的具体实现。使用Abstract Factory Pattern应该允许我选择要使用的窗口系统（即Windows，Mac，Flash），从那时起应该能够编写引用接口的代码，但始终使用适当的具体类（所有从一个窗口系统）。</p>
</div>
<div class="sect3">
<h4 id="_example"><a class="anchor" href="#_example"></a> 1.1.1。例</h4>
<div class="paragraph">
<p>假设我们要编写一个游戏系统。我们可能会注意到，许多游戏具有非常相似的功能和控制。</p>
</div>
<div class="paragraph">
<p>我们决定尝试将常见的和特定于游戏的代码分成单独的类。</p>
</div>
<div class="paragraph">
<p>首先，让我们看一下<a href="http://en.wikipedia.org/wiki/Two-Up">两人制</a>游戏的特定于游戏的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TwoupMessages {
    def welcome = 'Welcome to the twoup game, you start with $1000'
    def done = 'Sorry, you have no money left, goodbye'
}

class TwoupInputConverter {
    def convert(input) { input.toInteger() }
}

class TwoupControl {
    private money = 1000
    private random = new Random()
    private tossWasHead() {
        def next = random.nextInt()
        return next % 2 == 0
    }
    def moreTurns() {
        if (money &gt; 0) {
            println "You have $money, how much would you like to bet?"
            return true
        }

        false
    }
    def play(amount) {
        def coin1 = tossWasHead()
        def coin2 = tossWasHead()
        if (coin1 &amp;&amp; coin2) {
            money += amount
            println 'You win'
        } else if (!coin1 &amp;&amp; !coin2) {
            money -= amount
            println 'You lose'
        } else {
            println 'Draw'
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们看一下猜数字游戏的特定游戏代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GuessGameMessages {
    def welcome = 'Welcome to the guessing game, my secret number is between 1 and 100'
    def done = 'Correct'
}

class GuessGameInputConverter {
    def convert(input) { input.toInteger() }
}

class GuessGameControl {
    private lower = 1
    private upper = 100
    private guess = new Random().nextInt(upper - lower) + lower
    def moreTurns() {
        def done = (lower == guess || upper == guess)
        if (!done) {
            println "Enter a number between $lower and $upper"
        }

        !done
    }
    def play(nextGuess) {
        if (nextGuess &lt;= guess) {
            lower = [lower, nextGuess].max()
        }
        if (nextGuess &gt;= guess) {
            upper = [upper, nextGuess].min()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们编写我们的工厂代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def guessFactory = [messages: GuessGameMessages, control: GuessGameControl, converter: GuessGameInputConverter]
def twoupFactory = [messages: TwoupMessages, control: TwoupControl, converter: TwoupInputConverter]

class GameFactory {
    def static factory
    def static getMessages() { return factory.messages.newInstance() }
    def static getControl() { return factory.control.newInstance() }
    def static getConverter() { return factory.converter.newInstance() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该工厂的重要方面是它允许选择整个系列的具体课程。</p>
</div>
<div class="paragraph">
<p>这是我们将如何使用工厂的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">GameFactory.factory = twoupFactory
def messages = GameFactory.messages
def control = GameFactory.control
def converter = GameFactory.converter
println messages.welcome
def reader = new BufferedReader(new InputStreamReader(System.in))
while (control.moreTurns()) {
    def input = reader.readLine().trim()
    control.play(converter.convert(input))
}
println messages.done</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，第一行配置了我们将使用的具体游戏类系列。如第一行所示，通过使用factory属性选择要使用的家庭并不重要。其他方式将是该模式的同样有效的示例。例如，我们可能已经询问用户他们想玩哪个游戏，或者从环境设置中确定了哪个游戏。</p>
</div>
<div class="paragraph">
<p>使用如下所示的代码，游戏在运行时可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Welcome to the twoup game, you start with $1000
You have 1000, how much would you like to bet?
300
Draw
You have 1000, how much would you like to bet?
700
You win
You have 1700, how much would you like to bet?
1700
You lose
Sorry, you have no money left, goodbye</pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将脚本的第一行更改为GameFactory.factory = guessFactory，则示例运行可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Welcome to the guessing game, my secret number is between 1 and 100
Enter a number between 1 and 100
75
Enter a number between 1 and 75
35
Enter a number between 1 and 35
15
Enter a number between 1 and 15
5
Enter a number between 5 and 15
10
Correct</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adapter_pattern"><a class="anchor" href="#_adapter_pattern"></a> 1.2。适配器图案</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式</a> （有时称为包装器模式）允许在满足另一种类型的接口的情况下使用满足一个接口的对象。模式有两种典型的味道： <em>委托</em>味道和<em>继承</em>味道。</p>
</div>
<div class="sect3">
<h4 id="_delegation_example"><a class="anchor" href="#_delegation_example"></a> 1.2.1。委托示例</h4>
<div class="paragraph">
<p>假设我们有以下类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius &lt;= radius
    }
    String toString() { "RoundHole with radius $radius" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以问<code>RoundHole</code>如果一个类<code>RoundPeg</code>适合，但如果我们问一个相同的问题<code>SquarePeg</code> ，那么它将失败，因为<code>SquarePeg</code>全班没有<code>radius</code>属性（即不满足所需的接口）。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我们可以创建一个适配器以使其看起来具有正确的接口。它看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SquarePegAdapter {
    def peg
    def getRadius() {
        Math.sqrt(((peg.width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with peg width $peg.width (and notional radius $radius)"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以像这样使用适配器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def hole = new RoundHole(radius: 4.0)
(4..7).each { w -&gt;
    def peg = new SquarePegAdapter(peg: new SquarePeg(width: w))
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>peg SquarePegAdapter with peg width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inheritance_example"><a class="anchor" href="#_inheritance_example"></a> 1.2.2。继承实例</h4>
<div class="paragraph">
<p>让我们再次使用继承来考虑相同的示例。首先，这是原始类（不变）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius &lt;= radius
    }
    String toString() { "RoundHole with radius $radius" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用继承的适配器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SquarePegAdapter extends SquarePeg {
    def getRadius() {
        Math.sqrt(((width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with width $width (and notional radius $radius)"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用适配器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def hole = new RoundHole(radius: 4.0)
(4..7).each { w -&gt;
    def peg = new SquarePegAdapter(width: w)
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>peg SquarePegAdapter with width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adapting_using_closures"><a class="anchor" href="#_adapting_using_closures"></a> 1.2.3。使用闭包进行适应</h4>
<div class="paragraph">
<p>作为前面的示例的变体，我们可以定义以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface RoundThing {
    def getRadius()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以将适配器定义为闭包，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def adapter = {
    p -&gt; [getRadius: { Math.sqrt(((p.width / 2) ** 2) * 2) }] as RoundThing
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并像这样使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def peg = new SquarePeg(width: 4)
if (hole.pegFits(adapter(peg))) {
    // ... as before
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adapting_using_the_expandometaclass"><a class="anchor" href="#_adapting_using_the_expandometaclass"></a> 1.2.4。使用ExpandoMetaClass进行适应</h4>
<div class="paragraph">
<p>从Groovy 1.1开始，有一个内置的MetaClass，可以自动动态添加属性和方法。</p>
</div>
<div class="paragraph">
<p>示例是使用该功能的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def peg = new SquarePeg(width: 4)
peg.metaClass.radius = Math.sqrt(((peg.width / 2) ** 2) * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建钉对象后，您可以简单地向其动态添加属性。无需更改原始类，也不需要适配器类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bouncer_pattern"><a class="anchor" href="#_bouncer_pattern"></a> 1.3。弹跳器模式</h3>
<div class="paragraph">
<p><a href="http://www.c2.com/cgi/wiki?BouncerPattern">Bouncer模式</a>描述了一种方法的用法，其唯一目的是引发异常（当特定条件成立时）或什么都不做。此类方法通常用于防御性地保护方法的前提条件。</p>
</div>
<div class="paragraph">
<p>编写实用程序方法时，应始终防止错误的输入参数。在编写内部方法时，您可以通过进行足够的单元测试来确保始终满足某些前提条件。在这种情况下，您可能会降低对方法进行保护的意愿。</p>
</div>
<div class="paragraph">
<p>Groovy与其他语言的不同之处在于，您经常使用<code>assert</code>方法中的方法，而不是拥有大量的工具检查器方法或类。</p>
</div>
<div class="sect3">
<h4 id="_null_checking_example"><a class="anchor" href="#_null_checking_example"></a> 1.3.1。空检查示例</h4>
<div class="paragraph">
<p>我们可能有一个实用程序方法，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class NullChecker {
    static check(name, arg) {
        if (arg == null) {
            throw new IllegalArgumentException(name + ' is null')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将这样使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void doStuff(String name, Object value) {
    NullChecker.check('name', name)
    NullChecker.check('value', value)
    // do stuff
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是执行此操作的更时髦的方法将是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void doStuff(String name, Object value) {
    assert name != null, 'name should not be null'
    assert value != null, 'value should not be null'
    // do stuff
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_validation_example"><a class="anchor" href="#_validation_example"></a> 1.3.2。验证范例</h4>
<div class="paragraph">
<p>作为替代示例，我们可能具有以下实用程序方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class NumberChecker {
    static final String NUMBER_PATTERN = "\\\\d+(\\\\.\\\\d+(E-?\\\\d+)?)?"
    static isNumber(str) {
        if (!str ==~ NUMBER_PATTERN) {
            throw new IllegalArgumentException("Argument '$str' must be a number")
        }
    }
    static isNotZero(number) {
        if (number == 0) {
            throw new IllegalArgumentException('Argument must not be 0')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将这样使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def stringDivide(String dividendStr, String divisorStr) {
    NumberChecker.isNumber(dividendStr)
    NumberChecker.isNumber(divisorStr)
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    NumberChecker.isNotZero(divisor)
    dividend / divisor
}

println stringDivide('1.2E2', '3.0')
// =&gt; 40.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是使用Groovy，我们可以轻松地使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def stringDivide(String dividendStr, String divisorStr) {
    assert dividendStr =~ NumberChecker.NUMBER_PATTERN
    assert divisorStr =~ NumberChecker.NUMBER_PATTERN
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    assert divisor != 0, 'Divisor must not be 0'
    dividend / divisor
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chain_of_responsibility_pattern"><a class="anchor" href="#_chain_of_responsibility_pattern"></a> 1.4。责任链模式</h3>
<div class="paragraph">
<p>在责任链模式中，使用和实现接口（一种或多种方法）的对象是有意地松散耦合的。一组<em>实现</em>接口的对象被组织在一个列表中（在极少数情况下是一棵树）。使用该接口的对象从第一个<em>实现者</em>对象发出请求。它将决定是否自行执行任何操作以及是否将请求进一步传递到列表（或树）中的下一行。如果某些实现者均未响应该请求，则有时会将某些请求的默认实现也编码到该模式中。</p>
</div>
<div class="sect3">
<h4 id="_example_2"><a class="anchor" href="#_example_2"></a> 1.4.1。例</h4>
<div class="paragraph">
<p>在此示例中，脚本将请求发送到<code>lister</code>宾语。的<code>lister</code>指向一个<code>UnixLister</code>宾语。如果无法处理请求，则会将请求发送到<code>WindowsLister</code> 。如果无法处理请求，则会将请求发送到<code>DefaultLister</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class UnixLister {
    private nextInLine
    UnixLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Linux') {
            println "ls $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class WindowsLister {
    private nextInLine
    WindowsLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Windows XP') {
            println "cmd.exe /c dir $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class DefaultLister {
    def listFiles(dir) {
        new File(dir).eachFile { f -&gt; println f }
    }
}

def lister = new UnixLister(new WindowsLister(new DefaultLister()))

lister.listFiles('Downloads')</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出将是文件列表（格式略有不同，具体取决于操作系统）。</p>
</div>
<div class="paragraph">
<p>这是UML表示形式：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/ChainOfResponsibilityClasses.gif" alt="责任链类">
</div>
</div>
<div class="paragraph">
<p>此模式的变化形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们可以有一个明确的接口，例如<code>Lister</code> ，以静态键入实现，但是由于使用<em>鸭式输入，</em>因此这是可选的</p>
</li>
<li>
<p>我们可以使用链树代替列表，例如<code>if (animal.hasBackbone())</code>委托给<code>VertebrateHandler</code>否则委托给<code>InvertebrateHandler</code></p>
</li>
<li>
<p>即使我们处理了一个请求，我们也总是可以顺其自然</p>
</li>
<li>
<p>我们可以在某个时候决定不回应，也不要顺其自然</p>
</li>
<li>
<p>我们可以使用Groovy的元编程功能将未知的方法传递给链下</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composite_pattern"><a class="anchor" href="#_composite_pattern"></a> 1.5。复合图案</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Composite_pattern">复合模式</a>使您可以像对待一组对象一样对待一个对象的单个实例。模式通常与对象的层次结构一起使用。通常，对于层次结构中的<em>叶</em>节点或<em>复合</em>节点，应以相同的方式调用一个或多个方法。在这种情况下，复合节点通常会为其每个子节点调用相同的命名方法。</p>
</div>
<div class="sect3">
<h4 id="_example_3"><a class="anchor" href="#_example_3"></a> 1.5.1。例</h4>
<div class="paragraph">
<p>考虑我们要调用的复合模式的这种用法<code>toString()</code>在任一<code>Leaf</code>要么<code>Composite</code>对象。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/CompositeClasses.gif" alt="复合类">
</div>
</div>
<div class="paragraph">
<p>在Java中， <code>Component</code> class是必不可少的，因为它提供了用于叶节点和复合节点的类型。在Groovy中，由于使用鸭式输入法，因此我们不需要它，但是，它仍然可以用作在叶子节点和复合节点之间放置常见行为的有用位置。</p>
</div>
<div class="paragraph">
<p>为了我们的目的，我们将组装以下组件层次结构。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/CompositeComponents.gif" alt="复合组件">
</div>
</div>
<div class="paragraph">
<p>这是代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Component {
    def name
    def toString(indent) {
        ("-" * indent) + name
    }
}

class Composite extends Component {
    private children = []
    def toString(indent) {
        def s = super.toString(indent)
        children.each { child -&gt;
            s += "\\n" + child.toString(indent + 1)
        }
        s
    }
    def leftShift(component) {
        children &lt;&lt; component
    }
}

class Leaf extends Component { }

def root = new Composite(name: "root")
root &lt;&lt; new Leaf(name: "leaf A")
def comp = new Composite(name: "comp B")
root &lt;&lt; comp
root &lt;&lt; new Leaf(name: "leaf C")
comp &lt;&lt; new Leaf(name: "leaf B1")
comp &lt;&lt; new Leaf(name: "leaf B2")
println root.toString(0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是结果输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>root
-leaf A
-comp B
--leaf B1
--leaf B2
-leaf C</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_decorator_pattern"><a class="anchor" href="#_decorator_pattern"></a> 1.6。装饰图案</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Decorator_pattern">装饰器模式</a>提供了一种在不更改对象基本界面的情况下修饰其行为的机制。装饰对象应该能够在期望原始（未装饰）对象的任何地方进行替换。装饰通常不涉及修改原始对象的源代码，并且装饰者应该能够以灵活的方式组合在一起，以产生具有多个装饰的对象。</p>
</div>
<div class="sect3">
<h4 id="_traditional_example"><a class="anchor" href="#_traditional_example"></a> 1.6.1。传统例子</h4>
<div class="paragraph">
<p>假设我们有以下内容<code>Logger</code>类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Logger {
    def log(String message) {
        println message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，对日志消息进行时间戳记很有用，或者有时我们可能希望更改消息的大小写。我们可以尝试将所有这些功能构建到我们的<code>Logger</code>类。如果我们这样做， <code>Logger</code>课开始会很复杂。而且，即使他们可能不想要功能的一小部分，每个人都将获得所有功能。最后，特征交互将变得非常难以控制。</p>
</div>
<div class="paragraph">
<p>为了克服这些缺点，我们改为定义两个装饰器类。的用途<code>Logger</code>类可以随意按零或更多装饰器类的顺序装饰基础记录器。这些类如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TimeStampingLogger extends Logger {
    private Logger logger
    TimeStampingLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        def now = Calendar.instance
        logger.log("$now.time: $message")
    }
}

class UpperLogger extends Logger {
    private Logger logger
    UpperLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        logger.log(message.toUpperCase())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以像这样使用装饰器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def logger = new UpperLogger(new TimeStampingLogger(new Logger()))
logger.log("G'day Mate")
// =&gt; Tue May 22 07:13:50 EST 2007: G'DAY MATE</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到我们用两个装饰器修饰了记录器的行为。由于我们选择了应用装饰器的顺序，因此我们的日志消息大写，并且时间戳是正常情况下的。如果我们交换订单，让我们看看会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">logger = new TimeStampingLogger(new UpperLogger(new Logger()))
logger.log('Hi There')
// =&gt; TUE MAY 22 07:13:50 EST 2007: HI THERE</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，时间戳本身也已更改为大写。</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_touch_of_dynamic_behaviour"><a class="anchor" href="#_a_touch_of_dynamic_behaviour"></a> 1.6.2。一点动感的行为</h4>
<div class="paragraph">
<p>我们以前的装饰师专门针对<code>Logger</code>对象。我们可以使用Groovy的元对象编程功能来创建装饰器，该装饰器实际上是通用的。考虑此类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GenericLowerDecorator {
    private delegate
    GenericLowerDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        def newargs = args.collect { arg -&gt;
            if (arg instanceof String) {
                return arg.toLowerCase()
            } else {
                return arg
            }
        }
        delegate.invokeMethod(name, newargs)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它需要任何类并进行装饰，以便任何<code>String</code>方法参数将自动更改为小写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">logger = new GenericLowerDecorator(new TimeStampingLogger(new Logger()))
logger.log('IMPORTANT Message')
// =&gt; Tue May 22 07:27:18 EST 2007: important message</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意在这里订购。原始装饰者仅限于装饰<code>Logger</code>对象。该装饰器可与任何对象类型一起使用，因此我们无法交换顺序，即这将不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Can't mix and match Interface-Oriented and Generic decorators
// logger = new TimeStampingLogger(new GenericLowerDecorator(new Logger()))</pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在运行时生成适当的Proxy类型来克服此限制，但在此不会使示例复杂化。</p>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_behaviour_embellishment"><a class="anchor" href="#_runtime_behaviour_embellishment"></a> 1.6.3。运行时行为修饰</h4>
<div class="paragraph">
<p>您也可以考虑使用<code>ExpandoMetaClass</code>从Groovy 1.1开始，以动态修饰类的行为。这不是装饰器模式的正常使用样式（它肯定不那么灵活），但是在某些情况下可以帮助您获得类似的结果而无需创建新类。</p>
</div>
<div class="paragraph">
<p>代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// current mechanism to enable ExpandoMetaClass
GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()

def logger = new Logger()
logger.metaClass.log = { String m -&gt; println 'message: ' + m.toUpperCase() }
logger.log('x')
// =&gt; message: X</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以达到与应用单个装饰器相似的结果，但是我们无法轻松地即时应用和删除装饰。</p>
</div>
</div>
<div class="sect3">
<h4 id="_more_dynamic_decorating"><a class="anchor" href="#_more_dynamic_decorating"></a> 1.6.4。更动感的装饰</h4>
<div class="paragraph">
<p>假设我们有一个计算器类（实际上任何类都可以）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可能会对观察类的使用情况感兴趣。如果将其深埋在我们的代码库中，则可能很难确定何时调用它以及使用什么参数。另外，可能很难知道它是否运行良好。我们可以轻松地创建一个通用的跟踪装饰器，该装饰器会在每当<code>Calc</code>类将被调用，并提供有关执行所需时间的时间信息。这是跟踪装饰器的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TracingDecorator {
    private delegate
    TracingDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        println "Calling $name$args"
        def before = System.currentTimeMillis()
        def result = delegate.invokeMethod(name, args)
        println "Got $result in ${System.currentTimeMillis()-before} ms"
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是在脚本中使用类的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def tracedCalc = new TracingDecorator(new Calc())
assert 15 == tracedCalc.add(3, 12)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运行此脚本后将看到的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Calling add{3, 12}
Got 15 in 31 ms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_decorating_with_an_interceptor"><a class="anchor" href="#_decorating_with_an_interceptor"></a> 1.6.5。用拦截器装饰</h4>
<div class="paragraph">
<p>上面的时序示例与Groovy对象的生命周期挂钩（通过<code>invokeMethod</code> ）。这是执行元编程的重要样式，因此Groovy对使用<em>拦截器</em>进行的这种装饰样式有特殊的支持。</p>
</div>
<div class="paragraph">
<p>Groovy甚至内置了<code>TracingInterceptor</code> 。我们可以像这样扩展内置类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TimingInterceptor extends TracingInterceptor {
    private beforeTime
    def beforeInvoke(object, String methodName, Object[] arguments) {
        super.beforeInvoke(object, methodName, arguments)
        beforeTime = System.currentTimeMillis()
    }
    Object afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
        super.afterInvoke(object, methodName, arguments, result)
        def duration = System.currentTimeMillis() - beforeTime
        writer.write("Duration: $duration ms\\n")
        writer.flush()
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是使用此新类的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def proxy = ProxyMetaClass.getInstance(Calc)
proxy.interceptor = new TimingInterceptor()
proxy.use {
    assert 7 == new Calc().add(1, 6)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>before Calc.ctor()
after  Calc.ctor()
Duration: 0 ms
before Calc.add(java.lang.Integer, java.lang.Integer)
after  Calc.add(java.lang.Integer, java.lang.Integer)
Duration: 2 ms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_decorating_with_java_lang_reflect_proxy"><a class="anchor" href="#_decorating_with_java_lang_reflect_proxy"></a> 1.6.6。用java.lang.reflect装饰。代理</h4>
<div class="paragraph">
<p>如果您尝试装饰一个对象（即，只是类的特定实例，而不是通常的类），则可以使用Java的<code>java.lang.reflect.Proxy</code> 。Groovy使使用此工具比仅使用Java更容易。以下是从grails项目中提取的代码示例，该项目包装了<code>java.sql.Connection</code>所以它的关闭方法是不操作的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">protected Sql getGroovySql() {
    final Connection con = session.connection()
    def invoker = { object, method, args -&gt;
        if (method.name == "close") {
            log.debug("ignoring call to Connection.close() for use by groovy.sql.Sql")
        } else {
            log.trace("delegating $method")
            return con.invokeMethod(method.name, args)
        }
    } as InvocationHandler;
    def proxy = Proxy.newProxyInstance( getClass().getClassLoader(), [Connection] as Class[], invoker )
    return new Sql(proxy)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有许多方法可以拦截，则可以修改此方法以通过方法名称在映射中查找闭包并调用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_decorating_with_spring"><a class="anchor" href="#_decorating_with_spring"></a> 1.6.7。用春天装饰</h4>
<div class="paragraph">
<p><a href="http://www.springframework.org">Spring Framework</a>允许将装饰器与<em>拦截</em>器一起使用（您可能已经听说过<em>advice</em>或<em>Aspect</em>术语）。您也可以从Groovy利用这种机制。</p>
</div>
<div class="paragraph">
<p>首先定义一个您要装饰的类（我们还将像正常的Spring惯例一样使用一个接口）：</p>
</div>
<div class="paragraph">
<p>这是界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Calc {
    def add(a, b)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是课程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CalcImpl implements Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们在一个名为<code>beans.xml</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;bean id="performanceInterceptor" autowire="no"
          class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"&gt;
        &lt;property name="loggerName" value="performance"/&gt;
    &lt;/bean&gt;
    &lt;bean id="calc" class="util.CalcImpl"/&gt;
    &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
        &lt;property name="beanNames" value="calc"/&gt;
        &lt;property name="interceptorNames" value="performanceInterceptor"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们的脚本如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.springframework:spring-context:3.2.2.RELEASE')
import org.springframework.context.support.ClassPathXmlApplicationContext

def ctx = new ClassPathXmlApplicationContext('beans.xml')
def calc = ctx.getBean('calc')
println calc.add(3, 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们运行它时，我们看到的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>21/05/2007 23:02:35 org.springframework.aop.interceptor.PerformanceMonitorInterceptor invokeUnderTrace
FINEST: StopWatch 'util.Calc.add': running time (millis) = 16</pre>
</div>
</div>
<div class="paragraph">
<p>您可能需要调整您的<code>logging.properties</code>日志级别的消息文件<code>FINEST</code>显示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_decorators_using_gpars"><a class="anchor" href="#_asynchronous_decorators_using_gpars"></a> 1.6.8。使用GPar的异步装饰器</h4>
<div class="paragraph">
<p>使用<a href="http://www.cs.iastate.edu/~design/projects/panini/docs/starting.shtml">Panini中</a>的示例代码获取灵感。这是一个Groovy版本，避免使用<code>@AddedBehavior</code>注释以不具有通常选择装饰方法的算法为代价。这不是对所选择的特定方法的限制，仅是出于说明目的的简化（但不要假设以下内容完全相同）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.codehaus.gpars:gpars:0.10')
import static groovyx.gpars.GParsPool.withPool

interface Document {
    void print()
    String getText()
}

class DocumentImpl implements Document {
    def document
    void print() { println document }
    String getText() { document }
}

def words(String text) {
    text.replaceAll('[^a-zA-Z]', ' ').trim().split("\\\\s+")*.toLowerCase()
}

def avgWordLength = {
    def words = words(it.text)
    sprintf "Avg Word Length: %4.2f", words*.size().sum() / words.size()
}
def modeWord = {
    def wordGroups = words(it.text).groupBy {it}.collectEntries { k, v -&gt; [k, v.size()] }
    def maxSize = wordGroups*.value.max()
    def maxWords = wordGroups.findAll { it.value == maxSize }
    "Mode Word(s): ${maxWords*.key.join(', ')} ($maxSize occurrences)"
}
def wordCount = { d -&gt; "Word Count: " + words(d.text).size() }

def asyncDecorator(Document d, Closure c) {
    ProxyGenerator.INSTANCE.instantiateDelegate([print: {
        withPool {
            def result = c.callAsync(d)
            d.print()
            println result.get()
        }
    }], [Document], d)
}

Document d = asyncDecorator(asyncDecorator(asyncDecorator(
        new DocumentImpl(document:"This is the file with the words in it\\n\\t\\nDo you see the words?\\n"),
//        new DocumentImpl(document: new File('AsyncDecorator.groovy').text),
        wordCount), modeWord), avgWordLength)
d.print()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegation_pattern"><a class="anchor" href="#_delegation_pattern"></a> 1.7。委托模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Delegation_pattern">委托模式</a>是一种通过将责任委托给一个或多个关联对象来实现对象行为（公共方法）的技术。</p>
</div>
<div class="paragraph">
<p>Groovy允许应用委托模式的传统样式，例如，参见<a href="#_replace_inheritance_with_delegation">使用</a>代理<a href="#_replace_inheritance_with_delegation">替换继承</a> 。</p>
</div>
<div class="sect3">
<h4 id="_implement_delegation_pattern_using_expandometaclass"><a class="anchor" href="#_implement_delegation_pattern_using_expandometaclass"></a> 1.7.1。使用ExpandoMetaClass实现委托模式</h4>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/ExpandoMetaClass.html">groovy.lang。ExpandoMetaClass</a>允许将此模式的使用封装在库中。这使Groovy可以仿真可用于Ruby语言的类似库。</p>
</div>
<div class="paragraph">
<p>考虑以下库类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Delegator {
    private targetClass
    private delegate
    Delegator(targetClass, delegate) {
        this.targetClass = targetClass
        this.delegate = delegate
    }
    def delegate(String methodName) {
        delegate(methodName, methodName)
    }
    def delegate(String methodName, String asMethodName) {
        targetClass.metaClass."$asMethodName" = delegate.&amp;"$methodName"
    }
    def delegateAll(String[] names) {
        names.each { delegate(it) }
    }
    def delegateAll(Map names) {
        names.each { k, v -&gt; delegate(k, v) }
    }
    def delegateAll() {
        delegate.class.methods*.name.each { delegate(it) }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在类路径中使用它，您现在可以动态应用委托模式，如以下示例所示。首先，考虑一下我们有以下几类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy \\$thing"
    }
}

def lender = new MortgageLender()

def delegator = new Delegator(Person, lender)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以使用<em>委托</em>者从<em>借出</em>对象自动借用方法来扩展<em>Person</em>类。我们可以按原样借用方法，也可以重命名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegate 'borrowFor'
delegator.delegate 'borrowAmount', 'getMoney'

def p = new Person()

println p.borrowFor('present')   // =&gt; buy present
println p.getMoney(50)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的第一行通过委派给<em>贷方</em>对象，将<em>peerFor</em>方法添加到<em>Person</em>类。第二行通过委派给<em>贷方</em>对象的<em>borowAmount</em>方法，将<em>getMoney</em>方法添加到<em>Person</em>类。</p>
</div>
<div class="paragraph">
<p>另外，我们可以借用这样的多种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll 'borrowFor', 'borrowAmount'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将这两个方法添加到<em>Person</em>类。</p>
</div>
<div class="paragraph">
<p>或者，如果我们需要所有方法，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使<em>Person</em>类中的委托对象中的所有方法可用。</p>
</div>
<div class="paragraph">
<p>另外，我们可以使用地图符号重命名多个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll borrowAmount:'getMoney', borrowFor:'getThing'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implement_delegation_pattern_using_delegate_annotation"><a class="anchor" href="#_implement_delegation_pattern_using_delegate_annotation"></a> 1.7.2。使用@Delegate注释实现委派模式</h4>
<div class="paragraph">
<p>从1.6版开始，您可以使用基于AST转换的内置委派机制。</p>
</div>
<div class="paragraph">
<p>这使委派更加容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    def name
    @Delegate MortgageLender mortgageLender = new MortgageLender()
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy $thing"
    }
}

def p = new Person()

assert "buy present" == p.borrowFor('present')
assert "borrow \\$50" == p.borrowAmount(50)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flyweight_pattern"><a class="anchor" href="#_flyweight_pattern"></a> 1.8。跳线模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Flyweight_pattern">轻量级模式</a>是一种通过在处理包含许多相同内容的系统时不需要大量创建重量级对象来大大减少内存需求的模式。例如，如果使用熟悉Unicode，字体，位置等的复杂字符类对文档进行建模，则如果文档中的每个物理字符都需要自己的字符类实例，则对于大型文档，内存需求可能会非常大。取而代之的是，字符本身可能保留在Strings中，并且我们可能有一个字符类（或少量，例如每种字体类型一个字符类）知道如何处理字符的细节。</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们称之为与许多其他的事情（例如字符类型） <em>禀</em>状态共享的状态。它是重量级的类中捕获的。区分物理字符的状态（可能只是其ASCII码或Unicode）称为<em>外部</em>状态。</p>
</div>
<div class="sect3">
<h4 id="_example_4"><a class="anchor" href="#_example_4"></a> 1.8.1。例</h4>
<div class="paragraph">
<p>首先，我们将为一些复杂的飞机建模（第一个是第二个的骗局竞争对手-与示例无关）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Boeing797 {
    def wingspan = '80.8 m'
    def capacity = 1000
    def speed = '1046 km/h'
    def range = '14400 km'
    // ...
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/b797-hoax.jpg" alt="b797骗局">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Airbus380 {
    def wingspan = '79.8 m'
    def capacity = 555
    def speed = '912 km/h'
    def range = '10370 km'
    // ...
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/a380.jpg" alt="a380">
</div>
</div>
<div class="paragraph">
<p>如果我们要为舰队建模，我们的第一个尝试可能涉及使用这些重量级对象的许多实例。事实证明，每架飞机只有几个小状态（我们的外部状态）发生变化，因此我们将为重物设置单例，并分别捕获外部状态（以下代码中的购买日期和资产编号） 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class FlyweightFactory {
    static instances = [797: new Boeing797(), 380: new Airbus380()]
}

class Aircraft {
    private type         // instrinsic state
    private assetNumber  // extrinsic state
    private bought       // extrinsic state
    Aircraft(typeCode, assetNumber, bought) {
        type = FlyweightFactory.instances[typeCode]
        this.assetNumber = assetNumber
        this.bought = bought
    }
    def describe() {
        println """
        Asset Number: $assetNumber
        Capacity: $type.capacity people
        Speed: $type.speed
        Range: $type.range
        Bought: $bought
        """
    }
}

def fleet = [
    new Aircraft(380, 1001, '10-May-2007'),
    new Aircraft(380, 1002, '10-Nov-2007'),
    new Aircraft(797, 1003, '10-May-2008'),
    new Aircraft(797, 1004, '10-Nov-2008')
]

fleet.each { p -&gt; p.describe() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此在这里，即使我们的机队包含数百架飞机，每种类型的飞机也只有一个重物。</p>
</div>
<div class="paragraph">
<p>作为进一步的效率衡量标准，我们可以使用惰性创建flyweight对象，而不是像上面的示例一样预先创建初始映射。</p>
</div>
<div class="paragraph">
<p>运行此脚本将导致：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Asset Number: 1001
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-May-2007

Asset Number: 1002
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-Nov-2007

Asset Number: 1003
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-May-2008

Asset Number: 1004
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-Nov-2008</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iterator_pattern"><a class="anchor" href="#_iterator_pattern"></a> 1.9。迭代器模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Iterator_pattern">迭代器模式</a>允许在不暴露其基础表示的情况下顺序访问聚合对象的元素。</p>
</div>
<div class="paragraph">
<p>Groovy在其许多闭包运算符中内置了迭代器模式，例如<code>each</code>和<code>eachWithIndex</code>以及<code>for .. in</code>环。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def printAll(container) {
    for (item in container) { println item }
}

def numbers = [ 1,2,3,4 ]
def months = [ Mar:31, Apr:30, May:31 ]
def colors = [ java.awt.Color.BLACK, java.awt.Color.WHITE ]
printAll numbers
printAll months
printAll colors</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3
4
May=31
Mar=31
Apr=30
java.awt.Color[r=0,g=0,b=0]
java.awt.Color[r=255,g=255,b=255]</pre>
</div>
</div>
<div class="paragraph">
<p>另一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">colors.eachWithIndex { item, pos -&gt;
    println "Position $pos contains '$item'"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Position 0 contains 'java.awt.Color[r=0,g=0,b=0]'
Position 1 contains 'java.awt.Color[r=255,g=255,b=255]'</pre>
</div>
</div>
<div class="paragraph">
<p>迭代器模式还内置于其他特殊运算符中，例如<code>eachByte</code> ， <code>eachFile</code> ， <code>eachDir</code> ， <code>eachLine</code> ， <code>eachObject</code> ， <code>eachMatch</code>用于处理流，URL，文件，目录和正则表达式的运算符匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_loan_my_resource_pattern"><a class="anchor" href="#_loan_my_resource_pattern"></a> 1.10。贷款我的资源模式</h3>
<div class="paragraph">
<p><a href="https://wiki.scala-lang.org/display/SYGN/Loan">贷款我的资源</a>模式可确保一旦超出范围，就可以确定性地处置资源。</p>
</div>
<div class="paragraph">
<p>该模式内置于许多Groovy帮助器方法中。如果您需要使用Groovy支持的以外的方式来处理资源，则应该考虑自己使用它。</p>
</div>
<div class="sect3">
<h4 id="_example_5"><a class="anchor" href="#_example_5"></a> 1.10.1。例</h4>
<div class="paragraph">
<p>考虑以下适用于文件的代码。首先，我们可以在文件中写一些行，然后打印其大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def f = new File('junk.txt')
f.withPrintWriter { pw -&gt;
    pw.println(new Date())
    pw.println(this.class.name)
}
println f.size()
// =&gt; 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以一次读回一行文件的内容，并打印出每一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">f.eachLine { line -&gt;
    println line
}
// =&gt;
// Mon Jun 18 22:38:17 EST 2007
// RunPattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意普通的Java <code>Reader</code>和<code>PrintWriter</code> Groovy在后台使用了对象，但是代码编写者不必担心显式创建或关闭这些资源。内置的Groovy方法将各自的读取器或写入器借给结束代码，然后自行整理。因此，您无需任何工作即可使用此模式。</p>
</div>
<div class="paragraph">
<p>但是，有时候您希望做的事情与使用Groovy的内置机制免费获得的东西有所不同。您应该考虑在自己的资源处理操作中利用此模式。</p>
</div>
<div class="paragraph">
<p>考虑如何处理文件中每一行的单词列表。实际上，我们也可以使用Groovy的内置函数来执行此操作，但是请忍受并假设我们必须自己做一些资源处理。这是不使用此模式就可以编写代码的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def reader = f.newReader()
reader.splitEachLine(' ') { wordList -&gt;
    println wordList
}
reader.close()
// =&gt;
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们现在有一个明确的调用<code>close()</code>在我们的代码中。如果我们没有编写正确的代码（这里我们没有将代码包含在<code>try …​ finally</code>块，我们冒着打开文件句柄的风险。</p>
</div>
<div class="paragraph">
<p>现在让我们应用贷款模式。首先，我们将编写一个辅助方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def withListOfWordsForEachLine(File f, Closure c) {
    def r = f.newReader()
    try {
        r.splitEachLine(' ', c)
    } finally {
        r?.close()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以重新编写我们的代码，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withListOfWordsForEachLine(f) { wordList -&gt;
    println wordList
}
// =&gt;
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这要简单得多，并且删除了显式<code>close()</code> 。现在可以一站式解决这个问题，因此我们可以在一个地方进行适当级别的测试或审查，以确保我们没有问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_null_object_pattern"><a class="anchor" href="#_null_object_pattern"></a> 1.11。空对象模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Null_Object_pattern">空对象模式</a>涉及使用表示空的特殊对象位置标记对象。通常，如果您引用了null，则无法调用<code>reference.field</code>要么<code>reference.method()</code>您会收到可怕的消息<code>NullPointerException</code> 。空对象模式使用代表空的特殊对象，而不是实际的<code>null</code> 。这使您可以在空对象上调用字段和方法引用。使用null对象的结果在语义上应等效于不<em>执行任何操作</em> 。</p>
</div>
<div class="sect3">
<h4 id="_simple_example"><a class="anchor" href="#_simple_example"></a> 1.11.1。简单的例子</h4>
<div class="paragraph">
<p>假设我们有以下系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Job {
    def salary
}

class Person {
    def name
    def Job job
}

def people = [
    new Person(name: 'Tom', job: new Job(salary: 1000)),
    new Person(name: 'Dick', job: new Job(salary: 1200)),
]

def biggestSalary = people.collect { p -&gt; p.job.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行时，将打印出<code>1200</code> 。现在假设我们现在调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">people &lt;&lt; new Person(name: 'Harry')</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们现在尝试计算<code>biggestSalary</code>再次，我们收到一个空指针异常。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我们可以引入<code>NullJob</code>类并将上面的语句更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class NullJob extends Job { def salary = 0 }

people &lt;&lt; new Person(name: 'Harry', job: new NullJob())
biggestSalary = people.collect { p -&gt; p.job.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以按照我们的要求工作，但它并非始终是使用Groovy做到这一点的最佳方法。Groovy的安全引用运算符（ <code>?.</code> ）运算符和null感知闭包通常使Groovy避免需要创建特殊的null对象或null类。通过研究编写上面示例的更简单的方式可以说明这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">people &lt;&lt; new Person(name:'Harry')
biggestSalary = people.collect { p -&gt; p.job?.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使此工作正常进行，有两件事在进行。首先， <code>max()</code>是<em>“空感知”的，</em>因此[300，null，400] .max（）== 400。其次， <code>?.</code>运算符，类似<code>p?.job?.salary</code>如果等于，则等于null <code>salary</code>等于null，或者<code>job</code>等于`null或<code>p</code>等于null。如果...那么...则不需要编写复杂的嵌套代码，否则可以避免<code>NullPointerException</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_tree_example"><a class="anchor" href="#_tree_example"></a> 1.11.2。树例</h4>
<div class="paragraph">
<p>考虑下面的示例，在该示例中我们要计算树结构中所有值的大小，累积总和和累积乘积。</p>
</div>
<div class="paragraph">
<p>我们的首次尝试在计算方法内具有特殊的逻辑以处理空值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class NullHandlingTree {
    def left, right, value

    def size() {
        1 + (left ? left.size() : 0) + (right ? right.size() : 0)
    }

    def sum() {
       value + (left ? left.sum() : 0) + (right ? right.sum() : 0)
    }

    def product() {
       value * (left ? left.product() : 1) * (right ? right.product() : 1)
    }
}

def root = new NullHandlingTree(
    value: 2,
    left: new NullHandlingTree(
        value: 3,
        right: new NullHandlingTree(value: 4),
        left: new NullHandlingTree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们引入空对象模式（此处通过定义<code>NullTree</code>类），我们现在可以简化逻辑<code>size()</code> ， <code>sum()</code>和`product（）`方法。现在，这些方法可以更清楚地表示正常（现在是通用）情况的逻辑。内的每种方法<code>NullTree</code>返回一个表示什么都不做的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Tree {
    def left = new NullTree(), right = new NullTree(), value

    def size() {
        1 + left.size() + right.size()
    }

    def sum() {
       value + left.sum() + right.sum()
    }

    def product() {
       value * left.product() * right.product()
    }
}

class NullTree {
    def size() { 0 }
    def sum() { 0 }
    def product() { 1 }
}

def root = new Tree(
    value: 2,
    left: new Tree(
        value: 3,
        right: new Tree(value: 4),
        left: new Tree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行以下两个示例之一的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>4
14
120</pre>
</div>
</div>
<div class="paragraph">
<p>注意：null对象模式的微小变化是将其与单例模式组合。因此，如上所述，我们在需要空对象的地方都不会编写新的NullTree（）。相反，我们将有一个空对象实例，可以根据需要将其放置在数据结构中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pimp_my_library_pattern"><a class="anchor" href="#_pimp_my_library_pattern"></a> 1.12。皮条客我的图书馆模式</h3>
<div class="paragraph">
<p><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=179766">皮条客我的图书馆</a>模式提出了一种扩展图书馆的方法，该图书馆几乎可以完成您需要的所有工作，但只需要更多。它假定您没有所需库的源代码。</p>
</div>
<div class="sect3">
<h4 id="_example_6"><a class="anchor" href="#_example_6"></a> 1.12.1。例</h4>
<div class="paragraph">
<p>假设我们要使用Groovy中的内置Integer设施（该设施基于Java中已经存在的功能）。这些库几乎具有我们想要的所有功能，但不是全部。我们可能没有Groovy和Java库的所有源代码，因此我们不能只更改该库。相反，我们增加了图书馆。Groovy有很多方法可以做到这一点。一种方法是使用类别。</p>
</div>
<div class="paragraph">
<p>首先，我们将定义一个合适的类别。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class EnhancedInteger {
    static boolean greaterThanAll(Integer self, Object[] others) {
        greaterThanAll(self, others)
    }
    static boolean greaterThanAll(Integer self, others) {
        others.every { self &gt; it }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们添加了两种方法，通过提供以下方法来增强Integer方法： <code>greaterThanAll</code>方法。类别遵循约定，在这些约定中它们被定义为静态方法，并带有一个特殊的第一个参数来表示我们希望扩展的类。GreaterThanAll（Integer self，others）静态方法成为<code>greaterThanAll(other)</code>实例方法。</p>
</div>
<div class="paragraph">
<p>我们定义了两个版本<code>greaterThanAll</code> 。一个适用于集合，范围等。另一个适用于可变数量的<code>Integer</code>论点。</p>
</div>
<div class="paragraph">
<p>这是您使用类别的方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">use(EnhancedInteger) {
    assert 4.greaterThanAll(1, 2, 3)
    assert !5.greaterThanAll(2, 4, 6)
    assert 5.greaterThanAll(-4..4)
    assert 5.greaterThanAll([])
    assert !5.greaterThanAll([4, 5])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，使用这种技术，您可以有效地丰富原始类，而无需访问其源代码。此外，您可以在系统的不同部分应用不同的扩充功能，也可以根据需要使用未扩充的对象。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proxy_pattern"><a class="anchor" href="#_proxy_pattern"></a> 1.13。代理模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Proxy_pattern">代理模式</a>允许一个对象充当其他对象的伪装。通常，无论谁在使用代理，都不会意识到他们没有使用真实的东西。当难以创建或使用真实对象时，该模式很有用：它可以通过网络连接存在，或者是内存中的大对象，或者可以是文件，数据库或其他昂贵或无法复制的资源。</p>
</div>
<div class="sect3">
<h4 id="_example_7"><a class="anchor" href="#_example_7"></a> 1.13.1。例</h4>
<div class="paragraph">
<p>代理模式的一种常见用法是在与其他JVM中的远程对象通信时使用。这是用于创建代理的客户端代码，该代理通过套接字与服务器对象进行通信以及示例用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AccumulatorProxy {
    def accumulate(args) {
        def result
        def s = new Socket("localhost", 54321)
        s.withObjectStreams { ois, oos -&gt;
            oos &lt;&lt; args
            result = ois.readObject()
        }
        s.close()
        return result
    }
}

println new AccumulatorProxy().accumulate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
// =&gt; 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是您的服务器代码可能看起来的样子（首先开始）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Accumulator {
    def accumulate(args) {
        args.inject(0) { total, arg -&gt; total += arg }
    }
}

def port = 54321
def accumulator = new Accumulator()
def server = new ServerSocket(port)
println "Starting server on port $port"
while(true) {
    server.accept() { socket -&gt;
        socket.withObjectStreams { ois, oos -&gt;
            def args = ois.readObject()
            oos &lt;&lt; accumulator.accumulate(args)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_singleton_pattern"><a class="anchor" href="#_singleton_pattern"></a> 1.14。单例模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a>用于确保仅创建特定类的一个对象。当恰好需要一个对象来协调整个系统中的动作时，这很有用。可能出于效率的考虑，创建大量相同的对象会很浪费，或者可能是因为需要一种需要单点控制的特定算法，或者可能是因为使用了一个对象与不可共享的资源进行交互。</p>
</div>
<div class="paragraph">
<p>Singleton模式的缺点包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它可以减少重用。例如，如果您想对Singletons使用继承，则会出现问题。如果<code>SingletonB</code>延伸<code>SingletonA</code> ，如果每个对象都有（最多）一个实例，或者从其中一个类创建对象，则应禁止从另一个类创建对象。另外，如果您确定两个类都可以有一个实例，则如何覆盖<code>getInstance()</code>方法是静态的？</p>
</li>
<li>
<p>由于静态方法，通常也很难测试单例，但是如果需要，Groovy可以支持。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_example_the_classic_java_singleton"><a class="anchor" href="#_example_the_classic_java_singleton"></a> 1.14.1。示例：经典Java单例</h4>
<div class="paragraph">
<p>假设我们希望创建一个收集选票的类。因为获得正确的投票数可能非常重要，所以我们决定使用单例模式。永远只有一个<code>VoteCollector</code>对象，因此它使我们更容易推理出对象的创建和使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class VoteCollector {
    def votes = 0
    private static final INSTANCE = new VoteCollector()
    static getInstance() { return INSTANCE }
    private VoteCollector() { }
    def display() { println "Collector:${hashCode()}, Votes:$votes" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关此代码的一些兴趣点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它有一个私有的构造函数，所以没有<code>VoteCollector</code>可以在我们的系统中创建对象（ <code>INSTANCE</code>我们创建）</p>
</li>
<li>
<p>的<code>INSTANCE</code>也是私有的，因此一旦设置便无法更改</p>
</li>
<li>
<p>我们目前尚未使投票的更新成为线程安全的（此示例未添加）</p>
</li>
<li>
<p>投票收集器实例并非是懒惰地创建的（如果我们从不引用该类，则不会创建该实例；但是，一旦引用该类，即使最初不需要该实例也将被创建）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以在某些脚本代码中使用此单例类，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def collector = VoteCollector.instance
collector.display()
collector.votes++
collector = null

Thread.start{
    def collector2 = VoteCollector.instance
    collector2.display()
    collector2.votes++
    collector2 = null
}.join()

def collector3 = VoteCollector.instance
collector3.display()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用实例3次。第二种用法甚至是在不同的线程中使用（但不要在使用新类加载器的情况下尝试使用此方法）。</p>
</div>
<div class="paragraph">
<p>运行此脚本将产生结果（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Collector:15959960, Votes:0
Collector:15959960, Votes:1
Collector:15959960, Votes:2</pre>
</div>
</div>
<div class="paragraph">
<p>此模式的变化形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了支持延迟加载和多线程，我们可以使用<code>synchronized</code>带有的关键字<code>getInstance()</code>方法。这会降低性能，但可以使用。</p>
</li>
<li>
<p>我们可以考虑涉及双重检查锁定和<code>volatile</code>关键字，但请在<a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">此处</a>查看此方法的局限性。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_example_singleton_via_metaprogramming"><a class="anchor" href="#_example_singleton_via_metaprogramming"></a> 1.14.2。示例：通过元编程的单例</h4>
<div class="paragraph">
<p>Groovy的元编程功能允许以更基本的方式来实现单例模式之类的概念。此示例说明了使用Groovy的元编程功能来实现单例模式的简单方法，但不一定是最有效的方法。</p>
</div>
<div class="paragraph">
<p>假设我们要跟踪计算器执行的计算总数。一种方法是对计算器类使用单例，并在类中保留带有计数的变量。</p>
</div>
<div class="paragraph">
<p>首先，我们定义一些基类。一种<code>Calculator</code>执行计算并记录执行多少次此类的类<code>Client</code>充当计算器外观的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    def calc = new Calculator()
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以定义并注册一个<em>MetaClass</em> ，它拦截所有尝试创建一个<code>Calculator</code>对象，并且始终提供一个预先创建的实例。我们还在Groovy系统中注册了此MetaClass：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CalculatorMetaClass extends MetaClassImpl {
    private static final INSTANCE = new Calculator()
    CalculatorMetaClass() { super(Calculator) }
    def invokeConstructor(Object[] arguments) { return INSTANCE }
}

def registry = GroovySystem.metaClassRegistry
registry.setMetaClass(Calculator, new CalculatorMetaClass())</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们使用我们的实例<code>Client</code>脚本中的类。客户端类将尝试创建计算器的新实例，但将始终获得单例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = new Client()
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = new Client()
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运行此脚本的结果（您的哈希码值可能会有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 7306473, Calc: 24230857, Total Calculations: 1
Client: 31436753, Calc: 24230857, Total Calculations: 2</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_guice_example"><a class="anchor" href="#_guice_example"></a> 1.14.3。吉斯例子</h4>
<div class="paragraph">
<p>我们还可以使用<a href="https://github.com/google/guice">Guice</a>实现Singleton模式。</p>
</div>
<div class="paragraph">
<p>再次考虑“计算器”示例。</p>
</div>
<div class="paragraph">
<p>Guice是一个面向Java的框架，支持面向接口的设计。因此，我们创建了一个<code>Calculator</code>界面优先。然后我们可以创建我们的<code>CalculatorImpl</code>实施和<code>Client</code>我们的脚本将与之交互的对象。的<code>Client</code>此示例中并不一定需要class类，但可以让我们证明非单实例是默认实例。这是代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    @Inject Calculator calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

def injector = Guice.createInjector (
    [configure: { binding -&gt;
        binding.bind(Calculator)
               .to(CalculatorImpl)
               .asEagerSingleton() } ] as Module
)

def client = injector.getInstance(Client)
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = injector.getInstance(Client)
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>@Inject</code>中的注释<code>Client</code>类。我们总是可以在源代码中正确指出将要注入的字段。</p>
</div>
<div class="paragraph">
<p>在此示例中，我们选择使用<em>显式</em>绑定。在绑定中配置了我们所有的依赖项（好的，此例中只有一个）。向导注入器了解绑定，并在创建对象时根据需要注入依赖项。为了保持单例模式，您必须始终使用Guice创建实例。到目前为止，没有任何显示阻止您使用新的CalculatorImpl（）手动创建计算器的另一个实例，这当然会违反所需的单例行为。</p>
</div>
<div class="paragraph">
<p>在其他情况下（尽管可能不在大型系统中），我们可以选择使用批注来表示依赖关系，例如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

@ImplementedBy(CalculatorImpl)
interface Calculator {
    // as before ...
}

@Singleton
class CalculatorImpl implements Calculator {
    // as before ...
}

class Client {
    // as before ...
}

def injector = Guice.createInjector()

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>@Singleton</code>上的注释<code>CalculatorImpl</code>类和<code>@ImplementedBy</code>中的注释<code>Calculator</code>接口。</p>
</div>
<div class="paragraph">
<p>运行时，上面的示例（使用任何一种方法）都会产生（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 8897128, Calc: 17431955, Total Calculations: 1
Client: 21145613, Calc: 17431955, Total Calculations: 2</pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到，每当我们请求一个实例时，我们都获得了一个新的客户端对象，但是该实例被注入了相同的计算器对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring_example"><a class="anchor" href="#_spring_example"></a> 1.14.4。春天的例子</h4>
<div class="paragraph">
<p>我们可以再次使用Spring来做计算器示例，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('org.springframework:spring-core:3.2.2.RELEASE'), @Grab('org.springframework:spring-beans:3.2.2.RELEASE')])
import org.springframework.beans.factory.support.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    Client(Calculator calc) { this.calc = calc }
    def calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

// Here we 'wire' up our dependencies through the API. Alternatively,
// we could use XML-based configuration or the Grails Bean Builder DSL.
def factory = new DefaultListableBeanFactory()
factory.registerBeanDefinition('calc', new RootBeanDefinition(CalculatorImpl))
def beanDef = new RootBeanDefinition(Client, false)
beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_AUTODETECT)
factory.registerBeanDefinition('client', beanDef)

def client = factory.getBean('client')
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = factory.getBean('client')
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 29418586, Calc: 10580099, Total Calculations: 1
Client: 14800362, Calc: 10580099, Total Calculations: 2</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_further_information"><a class="anchor" href="#_further_information"></a> 1.14.5。更多信息</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html?page=1">只是辛格尔顿</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/webservices/library/co-single/index.html">明智地使用单身人士</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">双重检查锁定和单例模式</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20160807234810/http://blog.crazybob.org/2007/01/lazy-loading-singletons.html">延迟加载单例</a></p>
</li>
<li>
<p><a href="https://csharpindepth.com/Articles/Singleton">在C＃中实现单例模式</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_state_pattern"><a class="anchor" href="#_state_pattern"></a> 1.15。状态模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/State_pattern">状态模式</a>提供了一种在复杂系统中划分行为的结构化方法。系统的整体行为分为良好定义的状态。通常，每个状态由一个类实现。首先可以通过了解系统的<em>当前状态</em>来确定整个系统的行为；其次，通过了解在该状态下可能的行为（体现在与该状态相对应的类的方法中）。</p>
</div>
<div class="sect3">
<h4 id="_example_8"><a class="anchor" href="#_example_8"></a> 1.15.1。例</h4>
<div class="paragraph">
<p>这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client {
    def context = new Context()
    def connect() {
        context.state.connect()
    }
    def disconnect() {
        context.state.disconnect()
    }
    def send_message(message) {
        context.state.send_message(message)
    }
    def receive_message() {
        context.state.receive_message()
    }
}

class Context {
    def state = new Offline(this)
}

class ClientState {
    def context
    ClientState(context) {
        this.context = context
        inform()
    }
}

class Offline extends ClientState {
    Offline(context) {
        super(context)
    }
    def inform() {
        println "offline"
    }
    def connect() {
        context.state = new Online(context)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends ClientState {
    Online(context) {
        super(context)
    }
    def inform() {
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        context.state = new Offline(context)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>offline
error: not connected
connected
"Hello" sent
error: already connected
message received
offline</pre>
</div>
</div>
<div class="paragraph">
<p>但是，对于像Groovy这样的动态语言来说，很棒的事情之一就是我们可以举这个例子，并根据我们的特殊需求以多种不同的方式来表达它。该示例的一些潜在变化如下所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_variation_1_leveraging_interface_oriented_design"><a class="anchor" href="#_variation_1_leveraging_interface_oriented_design"></a> 1.15.2。变体1：利用面向接口的设计</h4>
<div class="paragraph">
<p>我们可以采用的一种方法是利用<a href="http://www.pragmaticprogrammer.com/titles/kpiod/index.html">面向接口的设计</a> 。为此，我们可以引入以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface State {
    def connect()
    def disconnect()
    def send_message(message)
    def receive_message()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们的<code>Client</code> ， <code>Online</code>和“离线”类可以进行修改以实现该接口，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client implements State {
  // ... as before ...
}

class Online implements State {
  // ... as before ...
}

class Offline implements State {
  // ... as before ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会问：我们是否刚刚引入了其他样板代码？我们不能依靠鸭子打字吗？答案是“是”和“否”。我们可以避免使用鸭式输入法，但是状态模式的主要目的之一是划分复杂度。如果我们知道<em>客户</em>类和每个<em>状态</em>类都满足一个接口，那么我们就在复杂性上设置了一些关键界限。我们可以孤立地查看任何状态类，并且知道该状态可能的行为范围。</p>
</div>
<div class="paragraph">
<p>我们不必为此使用接口，但是它有助于表达这种特定分区样式的意图，并且有助于减小单元测试的大小（我们将不得不使用其他测试来以这种语言表达这种意图。对面向接口设计的支持较少）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_variation_2_extract_state_pattern_logic"><a class="anchor" href="#_variation_2_extract_state_pattern_logic"></a> 1.15.3。方案2：提取状态模式逻辑</h4>
<div class="paragraph">
<p>或者，或者与其他变体结合，我们可能决定将某些状态模式逻辑提取到帮助程序类中。例如，我们可以在状态模式package / jar / script中定义以下类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class InstanceProvider {
    static def registry = GroovySystem.metaClassRegistry
    static def create(objectClass, param) {
        registry.getMetaClass(objectClass).invokeConstructor([param] as Object[])
    }
}

abstract class Context {
    private context
    protected setContext(context) {
        this.context = context
    }
    def invokeMethod(String name, Object arg) {
        context.invokeMethod(name, arg)
    }
    def startFrom(initialState) {
        setContext(InstanceProvider.create(initialState, this))
    }
}

abstract class State {
    private client

    State(client) { this.client = client }

    def transitionTo(nextState) {
        client.setContext(InstanceProvider.create(nextState, client))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这都是非常通用的，可以在我们要引入状态模式的任何地方使用。这是我们的代码现在的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client extends Context {
    Client() {
        startFrom(Offline)
    }
}

class Offline extends State {
    Offline(client) {
        super(client)
        println "offline"
    }
    def connect() {
        transitionTo(Online)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends State {
    Online(client) {
        super(client)
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        transitionTo(Offline)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在这里看到<code>startFrom</code>和<code>transitionTo</code>方法开始使我们的示例代码具有DSL的感觉。</p>
</div>
</div>
<div class="sect3">
<h4 id="_variation_3_bring_on_the_dsl"><a class="anchor" href="#_variation_3_bring_on_the_dsl"></a> 1.15.4。变体3：启用DSL</h4>
<div class="paragraph">
<p>替代地，或与其他变体结合，我们可能决定完全采用针对该示例的领域特定语言（DSL）方法。</p>
</div>
<div class="paragraph">
<p>我们可以定义以下通用辅助函数（在<a href="http://www.bytemycode.com/snippets/snippet/640/">此</a>首先讨论）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Grammar {
    def fsm

    def event
    def fromState
    def toState

    Grammar(a_fsm) {
        fsm = a_fsm
    }

    def on(a_event) {
        event = a_event
        this
    }

    def on(a_event, a_transitioner) {
        on(a_event)
        a_transitioner.delegate = this
        a_transitioner.call()
        this
    }

    def from(a_fromState) {
        fromState = a_fromState
        this
    }

    def to(a_toState) {
        assert a_toState, "Invalid toState: $a_toState"
        toState = a_toState
        fsm.registerTransition(this)
        this
    }

    def isValid() {
        event &amp;&amp; fromState &amp;&amp; toState
    }

    public String toString() {
        "$event: $fromState=&gt;$toState"
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class FiniteStateMachine {
    def transitions = [:]

    def initialState
    def currentState

    FiniteStateMachine(a_initialState) {
        assert a_initialState, "You need to provide an initial state"
        initialState = a_initialState
        currentState = a_initialState
    }

    def record() {
        Grammar.newInstance(this)
    }

    def reset() {
        currentState = initialState
    }

    def isState(a_state) {
        currentState == a_state
    }

    def registerTransition(a_grammar) {
        assert a_grammar.isValid(), "Invalid transition ($a_grammar)"
        def transition
        def event = a_grammar.event
        def fromState = a_grammar.fromState
        def toState = a_grammar.toState

        if (!transitions[event]) {
            transitions[event] = [:]
        }

        transition = transitions[event]
        assert !transition[fromState], "Duplicate fromState $fromState for transition $a_grammar"
        transition[fromState] = toState
    }

    def fire(a_event) {
        assert currentState, "Invalid current state '$currentState': passed into constructor"
        assert transitions.containsKey(a_event), "Invalid event '$a_event', should be one of ${transitions.keySet()}"
        def transition = transitions[a_event]
        def nextState = transition[currentState]
        assert nextState, "There is no transition from '$currentState' to any other state"
        currentState = nextState
        currentState
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以像这样定义和测试状态机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class StatePatternDslTest extends GroovyTestCase {
    private fsm

    protected void setUp() {
        fsm = FiniteStateMachine.newInstance('offline')
        def recorder = fsm.record()
        recorder.on('connect').from('offline').to('online')
        recorder.on('disconnect').from('online').to('offline')
        recorder.on('send_message').from('online').to('online')
        recorder.on('receive_message').from('online').to('online')
    }

    void testInitialState() {
        assert fsm.isState('offline')
    }

    void testOfflineState() {
        shouldFail{
            fsm.fire('send_message')
        }
        shouldFail{
            fsm.fire('receive_message')
        }
        shouldFail{
            fsm.fire('disconnect')
        }
        assert 'online' == fsm.fire('connect')
    }

    void testOnlineState() {
        fsm.fire('connect')
        fsm.fire('send_message')
        fsm.fire('receive_message')
        shouldFail{
            fsm.fire('connect')
        }
        assert 'offline' == fsm.fire('disconnect')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例与其他示例不完全相同。它不使用预定义<code>Online</code>和<code>Offline</code>类。而是根据需要动态定义整个状态机。有关此样式的更多详细示例，请参见<a href="http://www.bytemycode.com/snippets/snippet/640/">前面的参考</a> 。</p>
</div>
<div class="paragraph">
<p>另请参阅： <a href="#_model_based_testing_using_modeljunit">使用ModelJUnit进行基于模型的测试</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_strategy_pattern"><a class="anchor" href="#_strategy_pattern"></a> 1.16。策略模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>允许您从特定算法的使用中抽象出来。这使您可以轻松交换正在使用的算法，而不必更改调用代码。模式的一般形式是：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/StrategyClasses.gif" alt="策略类">
</div>
</div>
<div class="paragraph">
<p>在Groovy中，由于它具有使用匿名方法将代码视为一流对象的能力（我们将其宽松地称为<em>Closures</em> ），因此大大减少了对策略模式的需求。您可以简单地将算法放入Closures中。</p>
</div>
<div class="sect3">
<h4 id="_example_9"><a class="anchor" href="#_example_9"></a> 1.16.1。例</h4>
<div class="paragraph">
<p>首先，让我们看一下封装策略模式的传统方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Calc {
    def execute(n, m)
}

class CalcByMult implements Calc {
    def execute(n, m) { n * m }
}

class CalcByManyAdds implements Calc {
    def execute(n, m) {
        def result = 0
        n.times{
            result += m
        }

        result
    }
}

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

Calc[] multiplicationStrategies = [
    new CalcByMult(),
    new CalcByManyAdds()
]

sampleData.each{ data -&gt;
    multiplicationStrategies.each { calc -&gt;
        assert data[2] == calc.execute(data[0], data[1])
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里我们定义了一个接口<code>Calc</code>具体策略类将要实现的代码（我们也可以使用抽象类）。然后，我们定义了两种用于进行简单乘法的算法： <code>CalcByMult</code>正常方式，而CalcByManyAdds仅使用加法（请勿尝试使用负数进行此操作-是的，我们可以解决此问题，但这只会使示例更长）。然后，我们使用普通的<a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming">多态性</a>来调用算法。</p>
</div>
<div class="paragraph">
<p>这是使用Closures实现相同功能的Groovier方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def multiplicationStrategies = [
    { n, m -&gt; n * m },
    { n, m -&gt; def result = 0; n.times{ result += m }; result }
]

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

sampleData.each{ data -&gt;
    multiplicationStrategies.each { calc -&gt;
        assert data[2] == calc(data[0], data[1])
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_template_method_pattern"><a class="anchor" href="#_template_method_pattern"></a> 1.17。模板方法模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Template_method_pattern">模板方法模式</a>抽象了几种算法的细节。算法的通用部分包含在基类中。具体的实现细节在基类中捕获。涉及的类的通用模式如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/TemplateMethodClasses.gif" alt="TemplateMethodClasses">
</div>
</div>
<div class="sect3">
<h4 id="_example_10"><a class="anchor" href="#_example_10"></a> 1.17.1。例</h4>
<div class="paragraph">
<p>在这个例子中<code>Accumulator</code>抓住了累积算法的精髓。基类<code>Sum</code>和<code>Product</code>提供使用通用累积算法的特定定制方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Accumulator {
    protected initial
    abstract doAccumulate(total, v)
    def accumulate(values) {
        def total = initial
        values.each { v -&gt; total = doAccumulate(total, v) }
        total
    }
}

class Sum extends Accumulator {
    def Sum() { initial = 0 }
    def doAccumulate(total, v) { total + v }
}

class Product extends Accumulator {
    def Product() { initial = 1 }
    def doAccumulate(total, v) { total * v }
}

println new Sum().accumulate([1,2,3,4])
println new Product().accumulate([1,2,3,4])</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果输出为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>10
24</pre>
</div>
</div>
<div class="paragraph">
<p>在这种特殊情况下，可以使用Groovy的inject方法通过Closures获得类似的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Closure addAll = { total, item -&gt; total += item }
def accumulated = [1, 2, 3, 4].inject(0, addAll)
println accumulated    // =&gt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>多亏了鸭式输入，这也可以与其他支持add（Groovy中的plus（））方法的对象一起使用，例如：</p>
</div>
<div class="paragraph">
<p>在这种特殊情况下，可以使用Groovy的inject方法通过Closures获得类似的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">accumulated = [ "1", "2", "3", "4" ].inject("", addAll)
println accumulated    // =&gt; "1234"</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以按以下方式进行乘法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Closure multAll = { total, item -&gt; total *= item }
accumulated = [1, 2, 3, 4].inject(1, multAll)
println accumulated    // =&gt; 24</code></pre>
</div>
</div>
<div class="paragraph">
<p>以这种方式使用闭包看起来更像是<a href="#_strategy_pattern">策略模式，</a>但是如果我们意识到内置的注入方法是模板方法算法的通用部分，那么闭包将成为模板方法模式的自定义部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_visitor_pattern"><a class="anchor" href="#_visitor_pattern"></a> 1.18。访客模式</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Visitor_pattern">访客模式</a>是那些众所周知但不经常使用的模式之一。我认为这很奇怪，因为这确实是一件好事。</p>
</div>
<div class="paragraph">
<p>模式的目标是将算法与对象结构分离。这种分离的实际结果是能够在不修改那些对象结构的情况下向现有对象结构添加新操作。</p>
</div>
<div class="sect3">
<h4 id="_simple_example_2"><a class="anchor" href="#_simple_example_2"></a> 1.18.1。简单的例子</h4>
<div class="paragraph">
<p>本示例考虑如何计算形状（或形状集合）的边界。我们的首次尝试使用传统的访客模式。不久我们将看到更多的Groovy方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Shape { }

class Rectangle extends Shape {
    def x, y, width, height

    Rectangle(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height
    }

    def union(rect) {
        if (!rect) return this
        def minx = [rect.x, x].min()
        def maxx = [rect.x + width, x + width].max()
        def miny = [rect.y, y].min()
        def maxy = [rect.y + height, y + height].max()
        new Rectangle(minx, miny, maxx - minx, maxy - miny)
    }

    def accept(visitor) {
        visitor.visit_rectangle(this)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2

    Line(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2
    }

    def accept(visitor){
        visitor.visit_line(this)
    }
}

class Group extends Shape {
    def shapes = []
    def add(shape) { shapes += shape }
    def remove(shape) { shapes -= shape }
    def accept(visitor) {
        visitor.visit_group(this)
    }
}

class BoundingRectangleVisitor {
    def bounds

    def visit_rectangle(rectangle) {
        if (bounds)
            bounds = bounds.union(rectangle)
        else
            bounds = rectangle
    }

    def visit_line(line) {
        def line_bounds = new Rectangle(line.x1, line.y1, line.x2-line.y1, line.x2-line.y2)
        if (bounds)
            bounds = bounds.union(line_bounds)
        else
            bounds = line_bounds
    }

    def visit_group(group) {
        group.shapes.each { shape -&gt; shape.accept(this) }
    }
}

def group = new Group()
group.add(new Rectangle(100, 40, 10, 5))
group.add(new Rectangle(100, 70, 10, 5))
group.add(new Line(90, 30, 60, 5))
def visitor = new BoundingRectangleVisitor()
group.accept(visitor)
bounding_box = visitor.bounds
println bounding_box.dump()</code></pre>
</div>
</div>
<div class="paragraph">
<p>那花了很多代码。</p>
</div>
<div class="paragraph">
<p>我们可以通过以下方式使用Groovy闭包来提高代码的清晰度（并将其大小减小一半）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Shape {
    def accept(Closure yield) { yield(this) }
}

class Rectangle extends Shape {
    def x, y, w, h
    def bounds() { this }
    def union(rect) {
        if (!rect) return this
        def minx = [ rect.x, x ].min()
        def maxx = [ rect.x + w, x + w ].max()
        def miny = [ rect.y, y ].min()
        def maxy = [ rect.y + h, y + h ].max()
        new Rectangle(x:minx, y:miny, w:maxx - minx, h:maxy - miny)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2
    def bounds() {
        new Rectangle(x:[x1, x2].min(), y:[y1, y2].min(), w:(x2 - x1).abs(), h:(y2 - y1).abs())
    }
}

class Group {
    def shapes = []
    def leftShift(shape) { shapes += shape }
    def accept(Closure yield) { shapes.each{it.accept(yield)} }
}

def group = new Group()
group &lt;&lt; new Rectangle(x:100, y:40, w:10, h:5)
group &lt;&lt; new Rectangle(x:100, y:70, w:10, h:5)
group &lt;&lt; new Line(x1:90, y1:30, x2:60, y2:5)
def bounds
group.accept{ bounds = it.bounds().union(bounds) }
println bounds.dump()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_example"><a class="anchor" href="#_advanced_example"></a> 1.18.2。进阶范例</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType1Counter implements Visitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
    }
    void visit(NodeType2 n2){}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们现在使用<code>NodeType1Counter</code>在这样的树上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">NodeType1 root = new NodeType1()
root.children = new Visitable[2]
root.children[0] = new NodeType1()
root.children[1] = new NodeType2()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们有一个<code>NodeType1</code>对象作为根，其中一个孩子也是<code>NodeType1</code>实例。另一个孩子是<code>NodeType2</code>实例。这意味着使用<code>NodeType1Counter</code>这里应该数2 <code>NodeType1</code>对象。</p>
</div>
<div class="sect4">
<h5 id="_why_to_use_this"><a class="anchor" href="#_why_to_use_this"></a>为什么要使用这个</h5>
<div class="paragraph">
<p>如您在这里看到的非常好，我们有一个访客，该访客的状态没有更改对象树。这在不同区域非常有用，例如，您可以让访问者计算所有节点类型，或者使用多少个不同类型，或者您可以使用该节点专用的方法来收集有关树的信息等等。</p>
</div>
</div>
<div class="sect4">
<h5 id="_what_happens_if_we_add_a_new_type"><a class="anchor" href="#_what_happens_if_we_add_a_new_type"></a>如果添加新类型会怎样？</h5>
<div class="paragraph">
<p>在这种情况下，我们必须做很多工作。.我们必须更改Visitor以接受新类型，我们当然必须编写新类型本身，并且我们必须更改已经实现的每个Visitor。进行很少的更改后，您将修改所有的访问者以扩展访问者的默认实现，因此您无需在每次添加新类型时都更改每个访问者。</p>
</div>
</div>
<div class="sect4">
<h5 id="_what_if_we_want_to_have_different_iteration_patterns"><a class="anchor" href="#_what_if_we_want_to_have_different_iteration_patterns"></a>如果我们想拥有不同的迭代模式怎么办？</h5>
<div class="paragraph">
<p>那你有问题。由于节点描述了如何进行迭代，因此您没有任何影响，可以立即停止迭代或更改顺序。因此，也许我们应该对此进行一些更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

class DefaultVisitor implements Visitor{
    void visit(NodeType1 n1) {
        for(int i = 0; i &lt; n1.children.length; ++i) {
            n1.children[i].accept(this)
        }
    }
    void visit(NodeType2 n2) {
        for(int i = 0; i &lt; n2.children.length; ++i) {
            n2.children[i].accept(this)
        }
    }
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0];
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行一些小的更改但会产生很大的效果...访问者现在可以递归并告诉我如何进行迭代。节点中的实现被最小化以<code>visitor.visit(this)</code> ， <code>DefaultVisitor</code>现在可以捕获新类型了，我们可以通过不委托给super来停止迭代。当然，现在最大的缺点是它不再是迭代的，但是您不能获得所有的好处。</p>
</div>
</div>
<div class="sect4">
<h5 id="_make_it_groovy"><a class="anchor" href="#_make_it_groovy"></a>使其时髦</h5>
<div class="paragraph">
<p>现在的问题是如何使它更具Groovy。你没找到这个吗<code>visitor.visit(this)</code>奇怪？为什么在那儿？答案是模拟双重调度。在Java中，使用了编译时类型，所以当我<code>visitor.visit(children[i])</code>那么编译器将无法找到正确的方法，因为<code>Visitor</code>不包含方法<code>visit(Visitable)</code> 。即使可以，我们也想使用<code>NodeType1</code>要么<code>NodeType2</code> 。</p>
</div>
<div class="paragraph">
<p>现在，Groovy不使用静态类型，Groovy使用运行时类型。这意味着我可以做<code>visitor.visit(children[i])</code>直。嗯..因为我们最小化了accept方法，只做双重调度部分，并且因为Groovy的运行时类型系统已经涵盖了这一点..我们需要accept方法吗？我想你可以猜到我会回答不。但是我们可以做更多。我们的缺点是不知道如何处理未知的树元素。我们必须扩展接口<code>Visitor</code>为此，导致<code>DefaultVisitor</code>然后我们的任务是提供有用的默认值，例如迭代节点或什么都不做。现在，借助Groovy，我们可以通过添加一个<code>visit(Visitable)</code>什么都不做的方法。Java btw中也是如此。</p>
</div>
<div class="paragraph">
<p>但是不要让我们停在这里...我们需要<code>Visitor</code>接口？如果我们没有accept方法，那么我们就不需要<code>Visitor</code>界面。因此，新代码将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultVisitor {
    void visit(NodeType1 n1) {
        n1.children.each { visit(it) }
    }
    void visit(NodeType2 n2) {
        n2.children.each { visit(it) }
    }
    void visit(Visitable v) { }
}

interface Visitable { }

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来我们在这里保存了几行代码。但是我们做了更多。的<code>Visitable</code>节点现在不引用任何<code>Visitor</code>类或接口。对我来说，这是您可以达到的最佳分离水平。但是我们真的需要在这里停下来吗？不，让我们更改<code>Visitable</code>界面，让它返回我们接下来要访问的孩子。这允许我们使用通用的迭代方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultVisitor {
    void visit(Visitable v) {
        doIteraton(v)
    }
    void doIteraton(Visitable v) {
        v.children.each {
            visit(it)
        }
    }
}

interface Visitable {
    Visitable[] getChildren()
}

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultVisitor</code>现在看起来有点不同。我加了一个<code>doIteration</code>方法，它将获取要迭代的子项，然后在每个元素上调用visit。默认情况下，它将调用<code>visit(Visitable)</code>然后遍历这个孩子的孩子。我变了<code>Visitable</code>以确保任何节点都能够返回子代（即使为空）。我不必更改<code>NodeType1</code>和<code>NodeType2</code>类，因为定义子项的方式已经使它们成为属性，这意味着Groovy非常高兴为我们生成get方法。没有真正有趣的部分是<code>NodeType1Counter</code> ，这很有趣，因为我们没有更改它。 <code>super.visit(n1)</code>现在会打电话<code>visit(Visitable)</code>它将调用<code>doIteration</code>这将开始下一阶段的迭代。所以没有变化。但<code>visit(it)</code>将会通知<code>visit(NodeType1)</code>如果是类型<code>NodeType1</code> 。实际上，我们不需要<code>doIteration</code>方法，我们可以这样做<code>visit(Visitable)</code>也可以，但是我认为这个变体更好，因为它允许我们编写新的<code>Visitor</code>覆盖访问（ <code>Visitable</code> ）对于错误情况，这当然意味着我们绝对不能这样做<code>super.visit(n1)</code>但<code>doIteration(n1)</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_summary"><a class="anchor" href="#_summary"></a>摘要</h5>
<div class="paragraph">
<p>最终，我们的代码减少了约40％，一个健壮且稳定的体系结构，并且将Visiter从Visitable中完全删除了。我听说了基于Reflection的访问者实现以获得更通用的版本。好吧，有了这个，您看到确实不需要这样做。如果添加新类型，则无需更改任何内容。据说访问者模式不太适合极端的编程技术，因为您需要一直更改很多类。我想我证明这是因为Java而不是因为模式不好或什么原因。</p>
</div>
<div class="paragraph">
<p>访客模式有多种变体，例如非循环访客模式，试图解决添加带有特殊访客的新节点类型的问题。我不太喜欢，它可以与演员一起使用， <code>ClassCastException</code>和其他讨厌的东西。最后，它试图解决一些Groovy版本甚至无法解决的问题。</p>
</div>
<div class="paragraph">
<p>还有一件事。 <code>NodeType1Counter</code>也可以用Java实现。Groovy将识别访问方法并根据需要调用它们，因为<code>DefaultVisitor</code>仍然是Groovy并尽其所能。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_further_information_2"><a class="anchor" href="#_further_information_2"></a> 1.18.3。更多信息</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://se.ethz.ch/~meyer/publications/computer/visitor.pdf">组件化：Visitor示例</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references"><a class="anchor" href="#_references"></a> 2。参考文献</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Erich Gamma，Richard Helm，Ralph Johnson，John Vlissides（1995）。<em>设计模式：可重用的面向对象软件的元素</em> 。艾迪生-韦斯利。书号0-201-63361-2。</p>
<div class="ulist">
<ul>
<li>
<p><em>设计模式的规范参考。</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>马丁·福勒（Martin Fowler）（1999）。<em>重构：改进现有代码的设计</em> 。艾迪生-韦斯利。ISBN 0-201-48567-2。</p>
</li>
<li>
<p>约书亚·科列夫斯基（Joshua Kerievsky）（2004）。<em>重构为模式</em> 。艾迪生-韦斯利。书号0-321-21335-1。</p>
</li>
<li>
<p>埃里克·弗里曼，伊丽莎白·弗里曼，凯西·塞拉，贝特·贝茨（2004）。<em>头先设计模式</em> 。奥赖利。ISBN 0-596-00712-4。* <em>一本很棒的书，内容丰富而有趣。</em></p>
</li>
<li>
<p>Dierk Koenig与Andrew Glover，Paul King，Guillaume Laforge和Jon Skeet（2007）。<em>行动中的Groovy</em> 。曼宁。ISBN 1-932394-84-2。</p>
<div class="ulist">
<ul>
<li>
<p><em>讨论访问者，构建者和其他模式。</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>布拉德·阿普尔顿（1999）。<a href="http://www.bradapp.com/docs/pizza-inv.html">披萨倒装-一种有效消耗资源的模式</a> 。</p>
<div class="ulist">
<ul>
<li>
<p><em>许多软件工程师最常用的模式之一！</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>尼尔·福特（Neil Ford）的<em>动态语言设计模式</em> 。休斯顿Java用户组。Groovy和Ruby中的示例。 <a href="http://www.oracle.com/technetwork/server-storage/ts-4961-159222.pdf" class="bare">http://www.oracle.com/technetwork/server-storage/ts-4961-159222.pdf</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:01 AEST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>