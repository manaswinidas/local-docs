<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>处理JSON</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=8">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>处理JSON</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#json_jsonslurper">1。杰森·斯珀珀</a>
<ul class="sectlevel2">
<li><a href="#_parser_variants">1.1。解析器变体</a></li>
</ul>
</li>
<li><a href="#_jsonoutput">2。杰森输出</a>
<ul class="sectlevel2">
<li><a href="#_customizing_output">2.1。自定义输出</a>
<ul class="sectlevel3">
<li><a href="#_formatted_output">2.1.1。格式化输出</a></li>
</ul>
</li>
<li><a href="#_builders">2.2。建筑商</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Groovy带有集成支持，可在Groovy对象和JSON之间进行转换。专用于JSON序列化和解析的类可在<code>groovy.json</code>包。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="json_jsonslurper"><a class="anchor" href="#json_jsonslurper"></a> 1。杰森·斯珀珀</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>JsonSlurper</code>是一个将JSON文本或阅读器内容解析为Groovy数据结构（对象）（例如地图，列表和原始类型，例如<code>Integer</code> ， <code>Double</code> ， <code>Boolean</code>和<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>该类带有一堆重载<code>parse</code>方法以及一些特殊方法，例如<code>parseText</code> ， <code>parseFile</code>和别的。在下一个示例中，我们将使用<code>parseText</code>方法。它解析一个JSON <code>String</code>并将其递归转换为对象列表或地图。另一个<code>parse*</code>方法类似，因为它们返回JSON <code>String</code>但是对于不同的参数类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText('{ "name": "John Doe" } /* some comment */')

assert object instanceof Map
assert object.name == 'John Doe'</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，结果是一个普通地图，可以像普通的Groovy对象实例一样进行处理。 <code>JsonSlurper</code>解析由<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404 JSON交换标准</a>定义的给定JSON，以及对JavaScript注释和日期的支持。</p>
</div>
<div class="paragraph">
<p>除了地图<code>JsonSlurper</code>支持将JSON数组转换为列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText('{ "myList": [4, 8, 15, 16, 23, 42] }')

assert object instanceof Map
assert object.myList instanceof List
assert object.myList == [4, 8, 15, 16, 23, 42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON标准支持以下原始数据类型：字符串，数字，对象， <code>true</code> ， <code>false</code>和<code>null</code> 。<code>JsonSlurper</code>将这些JSON类型转换为相应的Groovy类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText '''
    { "simple": 123,
      "fraction": 123.66,
      "exponential": 123e12
    }'''

assert object instanceof Map
assert object.simple.class == Integer
assert object.fraction.class == BigDecimal
assert object.exponential.class == BigDecimal</code></pre>
</div>
</div>
<div class="paragraph">
<p>如<code>JsonSlurper</code>返回的纯Groovy对象实例在后面没有任何特殊的JSON类，其用法是透明的。事实上， <code>JsonSlurper</code>结果符合GPath表达式。GPath是一种功能强大的表达语言，它支持多种不同的数据格式（例如： <code>XmlSlurper</code>以XML为例）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关更多详细信息，请参阅有关<a href="core-semantics.html#gpath_expressions">GPath表达式</a>的部分。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下表概述了JSON类型和相应的Groovy数据类型：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">JSON格式</th>
<th class="tableblock halign-left valign-top">Groovy</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.BigDecimal</code>要么<code>java.lang.Integer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.LinkedHashMap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.ArrayList</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Date</code>基于<code>yyyy-MM-dd’T’HH:mm:ssZ</code>日期格式</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">每当JSON中的值是<code>null</code> ， <code>JsonSlurper</code>用Groovy补充它<code>null</code>值。这与其他代表JSON解析器的JSON解析器形成对比<code>null</code>库提供的单例对象的值。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="_parser_variants"><a class="anchor" href="#_parser_variants"></a> 1.1。解析器变体</h3>
<div class="paragraph">
<p><code>JsonSlurper</code>带有一些解析器实现。每个解析器都适合不同的要求，很可能是在某些情况下<code>JsonSlurper</code>默认解析器并不是在所有情况下的最佳选择。这是附带的解析器实现的概述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>JsonParserCharArray</code>解析器基本上采用JSON字符串，并在基础字符数组上进行操作。在值转换期间，它将复制字符子数组（一种称为“斩波”的机制）并对其进行操作。</p>
</li>
<li>
<p>的<code>JsonFastParser</code>是<code>JsonParserCharArray</code>并且是最快的解析器。但是，由于某种原因，它不是默认解析器。 <code>JsonFastParser</code>是所谓的索引覆盖解析器。在解析给定的JSON期间<code>String</code>它会尽力避免创建新的char数组，或者<code>String</code>实例。它仅保留指向基础原始字符数组的指针。此外，它推迟了对象创建的时间。如果将已解析的映射放入长期缓存中，则必须小心，因为可能不会创建映射对象，并且映射对象仍仅包含指向原始char缓冲区的指针。然而， <code>JsonFastParser</code>带有特殊的斩波模式，该模式会尽早将char缓冲区切成小块，以保留原始缓冲区的一小部分副本。建议是使用<code>JsonFastParser</code> 2MB以下的JSON缓冲区，并牢记长期缓存限制。</p>
</li>
<li>
<p>的<code>JsonParserLax</code>是<code>JsonParserCharArray</code>解析器。具有类似的性能特征<code>JsonFastParser</code>但不同之处在于，它并不完全依赖ECMA-404 JSON语法。例如，它允许注释，没有引号字符串等。</p>
</li>
<li>
<p>的<code>JsonParserUsingCharacterSource</code>是用于超大文件的特殊解析器。它使用一种称为“字符窗口”的技术来解析具有恒定性能特征的大型JSON文件（在这种情况下，大型文件意味着大于2MB的文件）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认解析器实现<code>JsonSlurper</code>是<code>JsonParserCharArray</code> 。的<code>JsonParserType</code>枚举包含上述解析器实现的常量：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">实作</th>
<th class="tableblock halign-left valign-top">不变</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserCharArray</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserType#CHAR_BUFFER</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonFastParser</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserType#INDEX_OVERLAY</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserLax</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserType#LAX</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserUsingCharacterSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JsonParserType#CHARACTER_SOURCE</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>更改解析器实现就像设置<code>JsonParserType</code>致电<code>JsonSlurper#setType()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jsonSlurper = new JsonSlurper(type: JsonParserType.INDEX_OVERLAY)
def object = jsonSlurper.parseText('{ "myList": [4, 8, 15, 16, 23, 42] }')

assert object instanceof Map
assert object.myList instanceof List
assert object.myList == [4, 8, 15, 16, 23, 42]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jsonoutput"><a class="anchor" href="#_jsonoutput"></a> 2。杰森输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>JsonOutput</code>负责将Groovy对象序列化为JSON字符串。可以将其视为<a href="#json_jsonslurper">JsonSlurper的</a>伴随对象，它是一个JSON解析器。</p>
</div>
<div class="paragraph">
<p><code>JsonOutput</code>带有超载，静态<code>toJson</code>方法。每<code>toJson</code>实现采用不同的参数类型。静态方法可以直接使用，也可以通过使用静态import语句导入方法来使用。</p>
</div>
<div class="paragraph">
<p>一个的结果<code>toJson</code>打电话是<code>String</code>包含JSON代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def json = JsonOutput.toJson([name: 'John Doe', age: 42])

assert json == '{"name":"John Doe","age":42}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>JsonOutput</code>不仅支持将要序列化为JSON的原始，映射或列表数据类型，而且甚至支持序列化POGO（即普通的Groovy对象）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person { String name }

def json = JsonOutput.toJson([ new Person(name: 'John'), new Person(name: 'Max') ])

assert json == '[{"name":"John"},{"name":"Max"}]'</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_output"><a class="anchor" href="#_customizing_output"></a> 2.1。自定义输出</h3>
<div class="paragraph">
<p>如果您需要控制序列化输出，则可以使用<code>JsonGenerator</code> 。的<code>JsonGenerator.Options</code> builder可用于创建定制的生成器。可以在此构建器上设置一个或多个选项，以更改结果输出。完成设置选项后，只需调用<code>build()</code>为了获得完全配置的实例，该实例将根据所选选项生成输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    String title
    int age
    String password
    Date dob
    URL favoriteUrl
}

Person person = new Person(name: 'John', title: null, age: 21, password: 'secret',
                            dob: Date.parse('yyyy-MM-dd', '1984-12-15'),
                            favoriteUrl: new URL('http://groovy-lang.org/'))

def generator = new JsonGenerator.Options()
    .excludeNulls()
    .dateFormat('yyyy@MM')
    .excludeFieldsByName('age', 'password')
    .excludeFieldsByType(URL)
    .build()

assert generator.toJson(person) == '{"dob":"1984@12","name":"John"}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>闭包可用于转换类型。这些闭包转换器针对给定类型进行注册，并且在遇到该类型或子类型时会被调用。闭包的第一个参数是与注册转换器的类型匹配的对象，并且此参数是必需的。关闭可能需要一秒钟<code>String</code>参数，如果有的话，它将被设置为键名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    URL favoriteUrl
}

Person person = new Person(name: 'John', favoriteUrl: new URL('http://groovy-lang.org/json.html#_jsonoutput'))

def generator = new JsonGenerator.Options()
    .addConverter(URL) { URL u, String key -&gt;
        if (key == 'favoriteUrl') {
            u.getHost()
        } else {
            u
        }
    }
    .build()

assert generator.toJson(person) == '{"favoriteUrl":"groovy-lang.org","name":"John"}'

// No key available when generating a JSON Array
def list = [new URL('http://groovy-lang.org/json.html#_jsonoutput')]
assert generator.toJson(list) == '["http://groovy-lang.org/json.html#_jsonoutput"]'

// First parameter to the converter must match the type for which it is registered
shouldFail(IllegalArgumentException) {
    new JsonGenerator.Options()
        .addConverter(Date) { Calendar cal -&gt; }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_formatted_output"><a class="anchor" href="#_formatted_output"></a> 2.1.1。格式化输出</h4>
<div class="paragraph">
<p>正如我们在前面的示例中看到的那样，默认情况下JSON输出并不是很漂亮。然而<code>prettyPrint</code>方法中<code>JsonOutput</code>来营救这个任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def json = JsonOutput.toJson([name: 'John Doe', age: 42])

assert json == '{"name":"John Doe","age":42}'

assert JsonOutput.prettyPrint(json) == '''\
{
    "name": "John Doe",
    "age": 42
}'''.stripIndent()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>prettyPrint</code>需要一个<code>String</code>作为单个参数；因此，它可以应用于任意JSON <code>String</code>实例，不仅是<code>JsonOutput.toJson</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_builders"><a class="anchor" href="#_builders"></a> 2.2。建筑商</h3>
<div class="paragraph">
<p>从Groovy创建JSON的另一种方法是使用<code>JsonBuilder</code>要么<code>StreamingJsonBuilder</code> 。两个构建器都提供DSL，该DSL允许制定对象图，然后将其转换为JSON。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关构建器的更多详细信息，请参阅涵盖<a href="core-domain-specific-languages.html#_jsonbuilder">JsonBuilder</a>和<a href="core-domain-specific-languages.html#_streamingjsonbuilder">StreamingJsonBuilder</a>的构建器章节。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:02 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=9">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>