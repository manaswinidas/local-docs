<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>单例模式</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=5">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>单例模式</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_example_the_classic_java_singleton">1。示例：经典Java单例</a></li>
<li><a href="#_example_singleton_via_metaprogramming">2。示例：通过元编程的单例</a></li>
<li><a href="#_guice_example">3。吉斯例子</a></li>
<li><a href="#_spring_example">4。春天的例子</a></li>
<li><a href="#_further_information">5，更多信息</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a>用于确保仅创建特定类的一个对象。当恰好需要一个对象来协调整个系统中的动作时，这很有用。可能出于效率的考虑，创建大量相同的对象会很浪费，或者可能是因为需要一种需要单点控制的特定算法，或者可能是因为使用了一个对象与不可共享的资源进行交互。</p>
</div>
<div class="paragraph">
<p>Singleton模式的缺点包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它可以减少重用。例如，如果您想对Singletons使用继承，则会出现问题。如果<code>SingletonB</code>延伸<code>SingletonA</code> ，如果每个对象都有（最多）一个实例，或者从其中一个类创建对象，则应禁止从另一个类创建对象。另外，如果您确定两个类都可以有一个实例，则如何覆盖<code>getInstance()</code>方法是静态的？</p>
</li>
<li>
<p>由于静态方法，通常也很难测试单例，但是如果需要，Groovy可以支持。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_the_classic_java_singleton"><a class="anchor" href="#_example_the_classic_java_singleton"></a> 1。示例：经典Java单例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>假设我们希望创建一个收集选票的类。因为获得正确的投票数可能非常重要，所以我们决定使用单例模式。永远只有一个<code>VoteCollector</code>对象，因此它使我们更容易推理出对象的创建和使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class VoteCollector {
    def votes = 0
    private static final INSTANCE = new VoteCollector()
    static getInstance() { return INSTANCE }
    private VoteCollector() { }
    def display() { println "Collector:${hashCode()}, Votes:$votes" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关此代码的一些兴趣点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它有一个私有的构造函数，所以没有<code>VoteCollector</code>可以在我们的系统中创建对象（ <code>INSTANCE</code>我们创建）</p>
</li>
<li>
<p>的<code>INSTANCE</code>也是私有的，因此一旦设置便无法更改</p>
</li>
<li>
<p>我们目前尚未使投票的更新成为线程安全的（此示例未添加）</p>
</li>
<li>
<p>投票收集器实例并非是懒惰地创建的（如果我们从不引用该类，则不会创建该实例；但是，一旦引用该类，即使最初不需要该实例也将被创建）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以在某些脚本代码中使用此单例类，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def collector = VoteCollector.instance
collector.display()
collector.votes++
collector = null

Thread.start{
    def collector2 = VoteCollector.instance
    collector2.display()
    collector2.votes++
    collector2 = null
}.join()

def collector3 = VoteCollector.instance
collector3.display()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用实例3次。第二种用法甚至是在不同的线程中使用（但不要在使用新类加载器的情况下尝试使用此方法）。</p>
</div>
<div class="paragraph">
<p>运行此脚本将产生结果（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Collector:15959960, Votes:0
Collector:15959960, Votes:1
Collector:15959960, Votes:2</pre>
</div>
</div>
<div class="paragraph">
<p>此模式的变化形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了支持延迟加载和多线程，我们可以使用<code>synchronized</code>带有的关键字<code>getInstance()</code>方法。这会降低性能，但可以使用。</p>
</li>
<li>
<p>我们可以考虑涉及双重检查锁定和<code>volatile</code>关键字，但请在<a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">此处</a>查看此方法的局限性。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_singleton_via_metaprogramming"><a class="anchor" href="#_example_singleton_via_metaprogramming"></a> 2。示例：通过元编程的单例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy的元编程功能允许以更基本的方式来实现单例模式之类的概念。此示例说明了使用Groovy的元编程功能来实现单例模式的简单方法，但不一定是最有效的方法。</p>
</div>
<div class="paragraph">
<p>假设我们要跟踪计算器执行的计算总数。一种方法是对计算器类使用单例，并在类中保留带有计数的变量。</p>
</div>
<div class="paragraph">
<p>首先，我们定义一些基类。一种<code>Calculator</code>执行计算并记录执行多少次此类的类<code>Client</code>充当计算器外观的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    def calc = new Calculator()
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以定义并注册一个<em>MetaClass</em> ，它拦截所有尝试创建一个<code>Calculator</code>对象，并且始终提供一个预先创建的实例。我们还在Groovy系统中注册了此MetaClass：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CalculatorMetaClass extends MetaClassImpl {
    private static final INSTANCE = new Calculator()
    CalculatorMetaClass() { super(Calculator) }
    def invokeConstructor(Object[] arguments) { return INSTANCE }
}

def registry = GroovySystem.metaClassRegistry
registry.setMetaClass(Calculator, new CalculatorMetaClass())</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们使用我们的实例<code>Client</code>脚本中的类。客户端类将尝试创建计算器的新实例，但将始终获得单例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = new Client()
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = new Client()
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运行此脚本的结果（您的哈希码值可能会有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 7306473, Calc: 24230857, Total Calculations: 1
Client: 31436753, Calc: 24230857, Total Calculations: 2</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_guice_example"><a class="anchor" href="#_guice_example"></a> 3。吉斯例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们还可以使用<a href="https://github.com/google/guice">Guice</a>实现Singleton模式。</p>
</div>
<div class="paragraph">
<p>再次考虑“计算器”示例。</p>
</div>
<div class="paragraph">
<p>Guice是一个面向Java的框架，支持面向接口的设计。因此，我们创建了一个<code>Calculator</code>界面优先。然后我们可以创建我们的<code>CalculatorImpl</code>实施和<code>Client</code>我们的脚本将与之交互的对象。的<code>Client</code>此示例中并不一定需要class类，但可以让我们证明非单实例是默认实例。这是代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    @Inject Calculator calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

def injector = Guice.createInjector (
    [configure: { binding -&gt;
        binding.bind(Calculator)
               .to(CalculatorImpl)
               .asEagerSingleton() } ] as Module
)

def client = injector.getInstance(Client)
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = injector.getInstance(Client)
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>@Inject</code>中的注释<code>Client</code>类。我们总是可以在源代码中正确指出将要注入的字段。</p>
</div>
<div class="paragraph">
<p>在此示例中，我们选择使用<em>显式</em>绑定。在绑定中配置了我们所有的依赖项（好的，此例中只有一个）。向导注入器了解绑定，并在创建对象时根据需要注入依赖项。为了保持单例模式，您必须始终使用Guice创建实例。到目前为止，没有任何显示阻止您使用新的CalculatorImpl（）手动创建计算器的另一个实例，这当然会违反所需的单例行为。</p>
</div>
<div class="paragraph">
<p>在其他情况下（尽管可能不在大型系统中），我们可以选择使用批注来表示依赖关系，例如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

@ImplementedBy(CalculatorImpl)
interface Calculator {
    // as before ...
}

@Singleton
class CalculatorImpl implements Calculator {
    // as before ...
}

class Client {
    // as before ...
}

def injector = Guice.createInjector()

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>@Singleton</code>上的注释<code>CalculatorImpl</code>类和<code>@ImplementedBy</code>中的注释<code>Calculator</code>接口。</p>
</div>
<div class="paragraph">
<p>运行时，上面的示例（使用任何一种方法）都会产生（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 8897128, Calc: 17431955, Total Calculations: 1
Client: 21145613, Calc: 17431955, Total Calculations: 2</pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到，每当我们请求一个实例时，我们都获得了一个新的客户端对象，但是该实例被注入了相同的计算器对象。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_example"><a class="anchor" href="#_spring_example"></a> 4。春天的例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们可以再次使用Spring来做计算器示例，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grapes([@Grab('org.springframework:spring-core:3.2.2.RELEASE'), @Grab('org.springframework:spring-beans:3.2.2.RELEASE')])
import org.springframework.beans.factory.support.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    Client(Calculator calc) { this.calc = calc }
    def calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

// Here we 'wire' up our dependencies through the API. Alternatively,
// we could use XML-based configuration or the Grails Bean Builder DSL.
def factory = new DefaultListableBeanFactory()
factory.registerBeanDefinition('calc', new RootBeanDefinition(CalculatorImpl))
def beanDef = new RootBeanDefinition(Client, false)
beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_AUTODETECT)
factory.registerBeanDefinition('client', beanDef)

def client = factory.getBean('client')
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = factory.getBean('client')
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下（您的哈希码值将有所不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 29418586, Calc: 10580099, Total Calculations: 1
Client: 14800362, Calc: 10580099, Total Calculations: 2</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_information"><a class="anchor" href="#_further_information"></a> 5，更多信息</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html?page=1">只是辛格尔顿</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/webservices/library/co-single/index.html">明智地使用单身人士</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">双重检查锁定和单例模式</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20160807234810/http://blog.crazybob.org/2007/01/lazy-loading-singletons.html">延迟加载单例</a></p>
</li>
<li>
<p><a href="https://csharpindepth.com/Articles/Singleton">在C＃中实现单例模式</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:03 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=6">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>