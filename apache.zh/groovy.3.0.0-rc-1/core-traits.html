<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>特质</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>特质</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_methods">1。方法</a>
<ul class="sectlevel2">
<li><a href="#_public_methods">1.1。公开方法</a></li>
<li><a href="#_abstract_methods">1.2。抽象方法</a></li>
<li><a href="#_private_methods">1.3。私人方法</a></li>
<li><a href="#_final_methods">1.4。最终方法</a></li>
</ul>
</li>
<li><a href="#_the_meaning_of_this">2。这个的意思</a></li>
<li><a href="#_interfaces">3。介面</a></li>
<li><a href="#_properties">4。性质</a></li>
<li><a href="#_fields">5，领域</a>
<ul class="sectlevel2">
<li><a href="#_private_fields">5.1。私人领域</a></li>
<li><a href="#_public_fields">5.2。公共领域</a></li>
</ul>
</li>
<li><a href="#_composition_of_behaviors">6。行为组成</a></li>
<li><a href="#_overriding_default_methods">7。覆盖默认方法</a></li>
<li><a href="#_extending_traits">8。扩展特征</a>
<ul class="sectlevel2">
<li><a href="#_simple_inheritance">8.1。简单继承</a></li>
<li><a href="#_multiple_inheritance">8.2。多重继承</a></li>
</ul>
</li>
<li><a href="#_duck_typing_and_traits">9。鸭的打字和特征</a>
<ul class="sectlevel2">
<li><a href="#_dynamic_code">9.1。动态代码</a></li>
<li><a href="#_dynamic_methods_in_a_trait">9.2。特征中的动态方法</a></li>
</ul>
</li>
<li><a href="#_multiple_inheritance_conflicts">10。多重继承冲突</a>
<ul class="sectlevel2">
<li><a href="#_default_conflict_resolution">10.1。默认冲突解决</a></li>
<li><a href="#_user_conflict_resolution">10.2。解决用户冲突</a></li>
</ul>
</li>
<li><a href="#_runtime_implementation_of_traits">11。特征的运行时实现</a>
<ul class="sectlevel2">
<li><a href="#_implementing_a_trait_at_runtime">11.1。在运行时实现特征</a></li>
<li><a href="#_implementing_multiple_traits_at_once">11.2。一次实现多个特征</a></li>
</ul>
</li>
<li><a href="#_chaining_behavior">12链接行为</a>
<ul class="sectlevel2">
<li><a href="#_semantics_of_super_inside_a_trait">12.1。特征特质的超语义</a></li>
</ul>
</li>
<li><a href="#_advanced_features">13高级功能</a>
<ul class="sectlevel2">
<li><a href="#_sam_type_coercion">13.1。SAM型强制</a></li>
<li><a href="#_differences_with_java_8_default_methods">13.2。Java 8默认方法的差异</a></li>
</ul>
</li>
<li><a href="#_differences_with_mixins">14。mixins的差异</a></li>
<li><a href="#_static_methods_properties_and_fields">15静态方法，属性和字段</a></li>
<li><a href="#_inheritance_of_state_gotchas">16。状态陷阱的继承</a></li>
<li><a href="#_self_types">17。自我类型</a>
<ul class="sectlevel2">
<li><a href="#_type_constraints_on_traits">17.1。特征的类型约束</a></li>
<li><a href="#traits-selftype">17.2。@SelfType批注</a></li>
</ul>
</li>
<li><a href="#_limitations">18岁局限性</a>
<ul class="sectlevel2">
<li><a href="#_compatibility_with_ast_transformations">18.1。与AST转换的兼容性</a></li>
<li><a href="#_prefix_and_postfix_operations">18.2。前缀和后缀操作</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>特质是该语言的结构结构，它可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>行为组成</p>
</li>
<li>
<p>接口的运行时实现</p>
</li>
<li>
<p>行为重载</p>
</li>
<li>
<p>与静态类型检查/编译的兼容性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将它们视为既包含<strong>默认实现</strong>又包含<strong>state的</strong> <strong>接口</strong> 。使用<code>trait</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后就可以像普通界面一样使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bird implements FlyingAbility {}          <i class="conum" data-value="1"></i><b>(1)</b>
def b = new Bird()                              <i class="conum" data-value="2"></i><b>(2)</b>
assert b.fly() == "I'm flying!"                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加特质<code>FlyingAbility</code>到<code>Bird</code>班级能力</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>实例化一个新的<code>Bird</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Bird</code>类自动获取<code>FlyingAbility</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从本构图到测试，这些特性具有广泛的功能，本节对此进行了详细介绍。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_methods"><a class="anchor" href="#_methods"></a> 1。方法</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_public_methods"><a class="anchor" href="#_public_methods"></a> 1.1。公开方法</h3>
<div class="paragraph">
<p>可以使用trait中的任何常规方法来声明特征中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_abstract_methods"><a class="anchor" href="#_abstract_methods"></a> 1.2。抽象方法</h3>
<div class="paragraph">
<p>另外，特征也可以声明<em>抽象</em>方法，因此需要在实现特征的类中实现<em>抽象</em>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greetable {
    abstract String name()                              <i class="conum" data-value="1"></i><b>(1)</b>
    String greeting() { "Hello, ${name()}!" }           <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实现类将必须声明<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以与具体方法混合</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以使用如下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person implements Greetable {                     <i class="conum" data-value="1"></i><b>(1)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实施特质<code>Greetable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>以来<code>name</code>是抽象的，需要实现它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>greeting</code>可以叫</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_private_methods"><a class="anchor" href="#_private_methods"></a> 1.3。私人方法</h3>
<div class="paragraph">
<p>特性还可以定义私有方法。这些方法将不会出现在特征合同界面中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    private String greetingMessage() {                      <i class="conum" data-value="1"></i><b>(1)</b>
        'Hello from a private method!'
    }
    String greet() {
        def m = greetingMessage()                           <i class="conum" data-value="2"></i><b>(2)</b>
        println m
        m
    }
}
class GreetingMachine implements Greeter {}                 <i class="conum" data-value="3"></i><b>(3)</b>
def g = new GreetingMachine()
assert g.greet() == "Hello from a private method!"          <i class="conum" data-value="4"></i><b>(4)</b>
try {
    assert g.greetingMessage()                              <i class="conum" data-value="5"></i><b>(5)</b>
} catch (MissingMethodException e) {
    println "greetingMessage is private in trait"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个私有方法<code>greetingMessage</code>特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>公众<code>greet</code>留言电话<code>greetingMessage</code>默认</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>greet</code>可以叫</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但不是<code>greetingMessage</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">仅支持性状<code>public</code>和<code>private</code>方法。都没有<code>protected</code>也不<code>package private</code>支持范围。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_final_methods"><a class="anchor" href="#_final_methods"></a> 1.4。最终方法</h3>
<div class="paragraph">
<p>如果我们有一个实现特征的类，则从概念上讲，特征方法的实现将“继承”到该类中。但是，实际上，没有包含此类实现的基类。而是将它们直接编织到班级中。方法上的最终修饰符仅表示织造方法的修饰符。尽管用相同的签名但混合了最终变量和非最终变量来继承和重写或乘以继承方法可能被认为是不好的样式，但是Groovy并不禁止这种情况。将应用常规方法选择，并且所使用的修饰符将从结果方法中确定。如果您想要无法覆盖的特征实现方法，则可以考虑创建一个实现所需特征的基类。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_meaning_of_this"><a class="anchor" href="#_the_meaning_of_this"></a> 2。这个的意思</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>this</code>表示实现实例。将特征视为超类。这意味着当您编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Introspector {
    def whoAmI() { this }
}
class Foo implements Introspector {}
def foo = new Foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后致电：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">foo.whoAmI()</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回相同的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert foo.whoAmI().is(foo)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaces"><a class="anchor" href="#_interfaces"></a> 3。介面</h2>
<div class="sectionbody">
<div class="paragraph">
<p>特性可以实现接口，在这种情况下，可以使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Named {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    String name()
}
trait Greetable implements Named {                      <i class="conum" data-value="2"></i><b>(2)</b>
    String greeting() { "Hello, ${name()}!" }
}
class Person implements Greetable {                     <i class="conum" data-value="3"></i><b>(3)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="4"></i><b>(4)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="5"></i><b>(5)</b>
assert p instanceof Named                               <i class="conum" data-value="6"></i><b>(6)</b>
assert p instanceof Greetable                           <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>普通接口的声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>加<code>Named</code>到已实现接口的列表</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Greetable</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>实现失踪<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的<code>greeting</code>实现来自特质</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>确保<code>Person</code>实现<code>Named</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>确保<code>Person</code>实现<code>Greetable</code>特征</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_properties"><a class="anchor" href="#_properties"></a> 4。性质</h2>
<div class="sectionbody">
<div class="paragraph">
<p>特征可以定义属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person(name: 'Bob')             <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Bob'                      <i class="conum" data-value="4"></i><b>(4)</b>
assert p.getName() == 'Bob'                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>申报财产<code>name</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>该属性自动显示</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>可以使用常规属性访问器进行访问</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>或使用常规的getter语法</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fields"><a class="anchor" href="#_fields"></a> 5，领域</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_private_fields"><a class="anchor" href="#_private_fields"></a> 5.1。私人领域</h3>
<div class="paragraph">
<p>由于特征允许使用私有方法，因此使用私有字段存储状态也可能很有趣。特性将使您做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counter {
    private int count = 0                   <i class="conum" data-value="1"></i><b>(1)</b>
    int count() { count += 1; count }       <i class="conum" data-value="2"></i><b>(2)</b>
}
class Foo implements Counter {}             <i class="conum" data-value="3"></i><b>(3)</b>
def f = new Foo()
assert f.count() == 1                       <i class="conum" data-value="4"></i><b>(4)</b>
assert f.count() == 2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个私有领域<code>count</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个公共方法<code>count</code>递增计数器并返回它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Counter</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>count</code>方法可以使用私有字段来保持状态</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这是与<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8虚拟扩展方法</a>的主要区别。尽管虚拟扩展方法不携带状态，但特征可以携带。而且，从Java 6开始就支持Groovy中的特征，因为它们的实现不依赖于虚拟扩展方法。这意味着，即使可以从Java类中将特征视为常规接口，该接口也将<strong>没有</strong>默认方法，而只有抽象方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_public_fields"><a class="anchor" href="#_public_fields"></a> 5.2。公共领域</h3>
<div class="paragraph">
<p>公共字段的工作方式与私有字段相同，但是为了避免<a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形问题</a> ，在实现类中将字段名称重新映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    public String name                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person()                        <i class="conum" data-value="3"></i><b>(3)</b>
p.Named__name = 'Bob'                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在特征内声明一个公共<strong>领域</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明实现该特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建该类的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>公共字段可用，但已重命名</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>字段的名称取决于特征的完全限定名称。所有点（ <code>.</code>包中的）替换为下划线（ <code>_</code> ），并且最终名称包含双下划线。因此，如果字段的类型是<code>String</code> ，包装名称为<code>my.package</code> ，特征的名称是<code>Foo</code>并且该字段的名称是<code>bar</code> ，在实施类中，公共字段将显示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String my_package_Foo__bar</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">虽然特质支持公共领域，但不建议使用它们，这被认为是不好的做法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_composition_of_behaviors"><a class="anchor" href="#_composition_of_behaviors"></a> 6。行为组成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>特性可以用于以受控方式实现多重继承。例如，我们可以具有以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个实现了这两个特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {} <i class="conum" data-value="1"></i><b>(1)</b>

def d = new Duck()                                      <i class="conum" data-value="2"></i><b>(2)</b>
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.speak() == "I'm speaking!"                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Duck</code>该类同时实现<code>FlyingAbility</code>和<code>SpeakingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个新的实例<code>Duck</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以调用该方法<code>fly</code>从<code>FlyingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>还有方法<code>speak</code>从<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>特性鼓励在对象之间重用功能，并通过现有行为的组合来创建新的类。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overriding_default_methods"><a class="anchor" href="#_overriding_default_methods"></a> 7。覆盖默认方法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>特性提供方法的默认实现，但可以在实现类中覆盖它们。例如，我们可以稍微改变一下上面的例子，通过鸭子来嘎嘎叫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         <i class="conum" data-value="1"></i><b>(1)</b>
    String speak() { quack() }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def d = new Duck()
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.quack() == "Quack!"                            <i class="conum" data-value="4"></i><b>(4)</b>
assert d.speak() == "Quack!"                            <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义特定于<code>Duck</code> ，命名<code>quack</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖默认的实现<code>speak</code>这样我们使用<code>quack</code>代替</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>鸭子仍在飞行，从默认实现</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>quack</code>来自<code>Duck</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>speak</code>不再使用来自的默认实现<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_traits"><a class="anchor" href="#_extending_traits"></a> 8。扩展特征</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_simple_inheritance"><a class="anchor" href="#_simple_inheritance"></a> 8.1。简单继承</h3>
<div class="paragraph">
<p>性状可能会扩展另一个特征，在这种情况下，您必须使用<code>extends</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                                     <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Polite extends Named {                        <i class="conum" data-value="2"></i><b>(2)</b>
    String introduce() { "Hello, I am $name" }      <i class="conum" data-value="3"></i><b>(3)</b>
}
class Person implements Polite {}
def p = new Person(name: 'Alice')                   <i class="conum" data-value="4"></i><b>(4)</b>
assert p.introduce() == 'Hello, I am Alice'         <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Named</code>特质定义一个<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Polite</code>特质<strong>扩展</strong>了<code>Named</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Polite</code>添加了可以访问<code>name</code>超特性的性质</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>name</code>该属性从<code>Person</code>课堂实施<code>Polite</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>就像<code>introduce</code>方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_inheritance"><a class="anchor" href="#_multiple_inheritance"></a> 8.2。多重继承</h3>
<div class="paragraph">
<p>或者，一个特征可以扩展多个特征。在这种情况下，必须在<code>implements</code>条款：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait WithId {                                      <i class="conum" data-value="1"></i><b>(1)</b>
    Long id
}
trait WithName {                                    <i class="conum" data-value="2"></i><b>(2)</b>
    String name
}
trait Identified implements WithId, WithName {}     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>WithId</code>特质定义了<code>id</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>WithName</code>特质定义了<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Identified</code>是一个既继承了<code>WithId</code>和<code>WithName</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_duck_typing_and_traits"><a class="anchor" href="#_duck_typing_and_traits"></a> 9。鸭的打字和特征</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dynamic_code"><a class="anchor" href="#_dynamic_code"></a> 9.1。动态代码</h3>
<div class="paragraph">
<p>特性可以调用任何动态代码，例如普通的Groovy类。这意味着您可以在方法的主体中调用应该在实现类中存在的方法，而不必在接口中显式声明它们。这意味着特质与鸭子类型完全兼容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SpeakingDuck {
    String speak() { quack() }                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def d = new Duck()
assert d.speak() == 'Quack!'                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>SpeakingDuck</code>期望<code>quack</code>要定义的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Duck</code>类确实使用<em>methodMissing</em>实现方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>称呼<code>speak</code>方法触发对<code>quack</code>由处理<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_methods_in_a_trait"><a class="anchor" href="#_dynamic_methods_in_a_trait"></a> 9.2。特征中的动态方法</h3>
<div class="paragraph">
<p>特征也可以实现MOP方法，例如<code>methodMissing</code>要么<code>propertyMissing</code> ，在这种情况下，实现类将从trait继承行为，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DynamicObject {                               <i class="conum" data-value="1"></i><b>(1)</b>
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String prop) {
        props[prop]
    }
    void setProperty(String prop, Object value) {
        props[prop] = value
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  <i class="conum" data-value="2"></i><b>(2)</b>
    String existingMethod() { 'ok' }                <i class="conum" data-value="3"></i><b>(3)</b>
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert d.foo == null                                <i class="conum" data-value="5"></i><b>(5)</b>
d.foo = 'bar'                                       <i class="conum" data-value="6"></i><b>(6)</b>
assert d.foo == 'bar'                               <i class="conum" data-value="7"></i><b>(7)</b>
assert d.existingMethod() == 'ok'                   <i class="conum" data-value="8"></i><b>(8)</b>
assert d.someMethod() == 'SOMEMETHOD'               <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建实现几种MOP方法的特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Dynamic</code>类定义一个属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Dynamic</code>类定义方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>调用现有属性将从中调用方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>调用不存在的属性会从特征中调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>将会通知<code>setProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>将会通知<code>getProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>调用现有方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>但由于特质而调用了不存在的方法<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_inheritance_conflicts"><a class="anchor" href="#_multiple_inheritance_conflicts"></a> 10。多重继承冲突</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_default_conflict_resolution"><a class="anchor" href="#_default_conflict_resolution"></a> 10.1。默认冲突解决</h3>
<div class="paragraph">
<p>一个类可以实现多个特征。如果某个特征定义的方法与另一个特征中的方法具有相同的签名，则我们将发生冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A {
    String exec() { 'A' }               <i class="conum" data-value="1"></i><b>(1)</b>
}
trait B {
    String exec() { 'B' }               <i class="conum" data-value="2"></i><b>(2)</b>
}
class C implements A,B {}               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特征<code>A</code>定义一个名为<code>exec</code>返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征<code>B</code>定义完全相同的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>C</code>实现两个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，默认行为是： <strong>最后一个声明的特征</strong>中的方法<code>implements</code>条款胜出。这里， <code>B</code>在之后声明<code>A</code>所以从<code>B</code>将被收取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def c = new C()
assert c.exec() == 'B'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_user_conflict_resolution"><a class="anchor" href="#_user_conflict_resolution"></a> 10.2。解决用户冲突</h3>
<div class="paragraph">
<p>如果此行为不是您想要的行为，则可以使用<code>Trait.super.foo</code>句法。在上面的示例中，我们可以通过编写以下代码来确保调用特征A中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class C implements A,B {
    String exec() { A.super.exec() }    <i class="conum" data-value="1"></i><b>(1)</b>
}
def c = new C()
assert c.exec() == 'A'                  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确要求<code>exec</code>从特质<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>从调用版本<code>A</code>而不是使用默认分辨率，这将是<code>B</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_runtime_implementation_of_traits"><a class="anchor" href="#_runtime_implementation_of_traits"></a> 11。特征的运行时实现</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_implementing_a_trait_at_runtime"><a class="anchor" href="#_implementing_a_trait_at_runtime"></a> 11.1。在运行时实现特征</h3>
<div class="paragraph">
<p>Groovy还支持在运行时动态地实现特征。它允许您使用特征“装饰”现有对象。作为示例，让我们从此特征和以下类开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Extra {
    String extra() { "I'm an extra method" }            <i class="conum" data-value="1"></i><b>(1)</b>
}
class Something {                                       <i class="conum" data-value="2"></i><b>(2)</b>
    String doSomething() { 'Something' }                <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Extra</code>特质定义了<code>extra</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Something</code>类<strong>未</strong>实现<code>Extra</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Something</code>只定义一个方法<code>doSomething</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，如果这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something()
s.extra()</code></pre>
</div>
</div>
<div class="paragraph">
<p>额外通话将失败，因为<code>Something</code>没有实施<code>Extra</code> 。可以使用以下语法在运行时执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something() as Extra                        <i class="conum" data-value="1"></i><b>(1)</b>
s.extra()                                               <i class="conum" data-value="2"></i><b>(2)</b>
s.doSomething()                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><strong>在运行时</strong>使用<strong>as</strong>关键字将对象强制为特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后<code>extra</code>可以在对象上调用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>和<code>doSomething</code>仍然可以通话</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将对象强制为特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象实现的特征<strong>和</strong>接口，但结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_multiple_traits_at_once"><a class="anchor" href="#_implementing_multiple_traits_at_once"></a> 11.2。一次实现多个特征</h3>
<div class="paragraph">
<p>如果您需要一次实现多个特征，则可以使用<code>withTraits</code>方法而不是<code>as</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     <i class="conum" data-value="1"></i><b>(1)</b>
c.methodFromB()                     <i class="conum" data-value="2"></i><b>(2)</b>
def d = c.withTraits A, B           <i class="conum" data-value="3"></i><b>(3)</b>
d.methodFromA()                     <i class="conum" data-value="4"></i><b>(4)</b>
d.methodFromB()                     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>拨电至<code>methodFromA</code>将会失败，因为<code>C</code>没有实现<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>拨电至<code>methodFromB</code>将会失败，因为<code>C</code>没有实现<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>withTrait</code>将包裹<code>c</code>变成可以实现的东西<code>A</code>和<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>methodFromA</code>现在将通过，因为<code>d</code>贯彻<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>methodFromB</code>现在将通过，因为<code>d</code>也实现<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将一个对象强制为多个特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象所实现的特征<strong>和</strong>接口，但是结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_chaining_behavior"><a class="anchor" href="#_chaining_behavior"></a> 12链接行为</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy支持<em>可堆叠特征</em>的概念。如果当前特征无法处理消息，则想法是将一个特征委托给另一个特征。为了说明这一点，让我们想象一个消息处理程序接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface MessageHandler {
    void on(String message, Map payload)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以通过应用小的行为来组成消息处理程序。例如，让我们以特征形式定义默认处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，任何类都可以通过实现trait来继承默认处理程序的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandler implements DefaultHandler {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果要记录除默认处理程序之外的所有消息，该怎么办？一种选择是编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandlerWithLogging implements DefaultHandler {
    void on(String message, Map payload) {                                  <i class="conum" data-value="1"></i><b>(1)</b>
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        DefaultHandler.super.on(message, payload)                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确实施<code>on</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行记录</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通过委派给<code>DefaultHandler</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这可行，但是这种方法有缺点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>日志记录逻辑绑定到“具体”处理程序</p>
</li>
<li>
<p>我们有一个明确的参考<code>DefaultHandler</code>在里面<code>on</code>方法，这意味着如果我们碰巧更改了类实现的特征，则代码将被破坏</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>作为替代，我们可以编写另一个特征，即仅限于日志记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait LoggingHandler implements MessageHandler {                            <i class="conum" data-value="1"></i><b>(1)</b>
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        super.on(message, payload)                                          <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>日志处理程序本身就是一个处理程序</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打印收到的消息</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>super</code>使其将调用委托给链中的下一个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的班级可以这样重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing test logging with payload [:]
Received test logging with payload [:]</pre>
</div>
</div>
<div class="paragraph">
<p>正如优先规则所暗示的那样<code>LoggerHandler</code>获胜，因为它被声明为最后一个，然后调用<code>on</code>将使用来自<code>LoggingHandler</code> 。但后者呼吁<code>super</code> ，这意味着链中的下一个特征。在这里，下一个特征是<code>DefaultHandler</code>所以<strong>两者都</strong>将被称为：</p>
</div>
<div class="paragraph">
<p>如果我们添加第三个处理程序，该处理程序负责处理以<code>say</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SayHandler implements MessageHandler {
    void on(String message, Map payload) {
        if (message.startsWith("say")) {                                    <i class="conum" data-value="1"></i><b>(1)</b>
            println "I say ${message - 'say'}!"
        } else {
            super.on(message, payload)                                      <i class="conum" data-value="2"></i><b>(2)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理程序特定的前提</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不满足前提条件，则将消息传递给链中的下一个处理程序</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的最终处理程序如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
def h = new Handler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>意思是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息将首先通过日志记录处理程序</p>
</li>
<li>
<p>日志处理程序调用<code>super</code>它将委派给下一个处理程序，即<code>SayHandler</code></p>
</li>
<li>
<p>如果消息以<code>say</code> ，然后处理程序将使用消息</p>
</li>
<li>
<p>如果没有， <code>say</code>处理程序委托给链中的下一个处理程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法非常强大，因为它允许您编写彼此不认识的处理程序，但仍可以按所需顺序将它们组合在一起。例如，如果我们执行代码，它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果我们将日志记录处理程序移动到链中的第二个处理程序，则输出将不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
h = new AlternateHandler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>印刷品：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>原因是现在，因为<code>SayHandler</code>无需呼叫即可使用消息<code>super</code> ，不再调用日志记录处理程序。</p>
</div>
<div class="sect2">
<h3 id="_semantics_of_super_inside_a_trait"><a class="anchor" href="#_semantics_of_super_inside_a_trait"></a> 12.1。特征特质的超语义</h3>
<div class="paragraph">
<p>如果一个类实现了多个特征并调用了不合格<code>super</code>找到，然后：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果该类实现了另一个特征，则调用将委托给链中的下一个特征</p>
</li>
<li>
<p>如果连锁店没有任何特征， <code>super</code>指实现类的超类（ <em>this</em> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，由于以下行为，可以修饰最终类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Filtering {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    StringBuilder append(String str) {                  <i class="conum" data-value="2"></i><b>(2)</b>
        def subst = str.replace('o','')                 <i class="conum" data-value="3"></i><b>(3)</b>
        super.append(subst)                             <i class="conum" data-value="4"></i><b>(4)</b>
    }
    String toString() { super.toString() }              <i class="conum" data-value="5"></i><b>(5)</b>
}
def sb = new StringBuilder().withTraits Filtering       <i class="conum" data-value="6"></i><b>(6)</b>
sb.append('Groovy')
assert sb.toString() == 'Grvy'                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个名为<code>Filtering</code> ，应该应用于<code>StringBuilder</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>重新定义<code>append</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>从字符串中删除所有“ o”</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后委托给<code>super</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果<code>toString</code>被称为，委托给<code>super.toString</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>的运行时实现<code>Filtering</code>特质<code>StringBuilder</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>附加的字符串不再包含字母<code>o</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这个例子中，当<code>super.append</code>遇到时，目标对象没有实现其他任何特征，因此被称为原始方法<code>append</code>方法，也就是说从<code>StringBuilder</code> 。相同的技巧用于<code>toString</code> ，以便所生成的代理对象的字符串表示形式委托给<code>toString</code>的<code>StringBuilder</code>实例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_features"><a class="anchor" href="#_advanced_features"></a> 13高级功能</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_sam_type_coercion"><a class="anchor" href="#_sam_type_coercion"></a> 13.1。SAM型强制</h3>
<div class="paragraph">
<p>如果一个特征定义了一个抽象方法，则它是SAM（单一抽象方法）类型强制的候选者。例如，想象一下以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    String greet() { "Hello $name" }        <i class="conum" data-value="1"></i><b>(1)</b>
    abstract String getName()               <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>greet</code>方法不是抽象的，而是调用抽象方法<code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>getName</code>是一种抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以来<code>getName</code>是在所述<em>单个抽象方法</em> <code>Greeter</code>特质，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Greeter greeter = { 'Alice' }               <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>关闭“成为”实施<code>getName</code>单一抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>甚至：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void greet(Greeter g) { println g.greet() } <i class="conum" data-value="1"></i><b>(1)</b>
greet { 'Alice' }                           <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>greet方法接受SAM类型Greeter作为参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以直接用闭包调用它</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_differences_with_java_8_default_methods"><a class="anchor" href="#_differences_with_java_8_default_methods"></a> 13.2。Java 8默认方法的差异</h3>
<div class="paragraph">
<p>在Java 8中，接口可以具有方法的默认实现。如果一个类实现一个接口并且不提供默认方法的实现，则从该接口中选择实现。特性的行为相同，但有一个主要区别：如果类在其接口列表中声明了该特性， <strong>并且</strong> <strong>即使</strong>超类也没有提供实现，则<strong>始终</strong>使用trait的实现。</p>
</div>
<div class="paragraph">
<p>如果您想覆盖已经实现的方法的行为，可以使用此功能以非常精确的方式来构成行为。</p>
</div>
<div class="paragraph">
<p>为了说明这个概念，让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.test.GroovyTestCase
import groovy.transform.CompileStatic
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

class SomeTest extends GroovyTestCase {
    def config
    def shell

    void setup() {
        config = new CompilerConfiguration()
        shell = new GroovyShell(config)
    }
    void testSomething() {
        assert shell.evaluate('1+1') == 2
    }
    void otherTest() { /* ... */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们创建一个简单的测试用例，该用例使用两个属性（ <em>config</em>和<em>shell</em> ），并在多种测试方法中使用它们。现在，假设您要进行相同的测试，但是要使用另一种不同的编译器配置。一种选择是创建一个子类<code>SomeTest</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以工作，但是如果您实际上有多个测试类，并且想要为所有这些测试类测试新配置怎么办？然后，您将必须为每个测试类创建一个不同的子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class YetAnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您会看到<code>setup</code>两种测试的方法是相同的。然后，该想法是创建一个特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait MyTestSupport {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在子类中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest implements MyTestSupport {}
class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使我们能够大大减少样板代码，并减少在我们决定更改设置代码时忘记更改设置代码的风险。即使<code>setup</code>已在超级类中实现，因为测试类在其接口列表中声明了特征，所以该行为将从特征实现中借用！</p>
</div>
<div class="paragraph">
<p>当您无法访问超类源代码时，此功能特别有用。它可用于模拟方法或在子类中强制方法的特定实现。它使您可以重构代码，以将重写的逻辑保留为单个特征，并仅通过实现它即可继承新行为。当然，另一种选择是在将要使用新代码的<strong>每个</strong>位置覆盖该方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">值得注意的是，如果您使用运行时特征，则特征中的方法<strong>始终</strong>比被代理对象更优选：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                                         <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Bob {
    String getName() { 'Bob' }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Alice')
assert p.name == 'Alice'                                <i class="conum" data-value="3"></i><b>(3)</b>
def p2 = p as Bob                                       <i class="conum" data-value="4"></i><b>(4)</b>
assert p2.name == 'Bob'                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>类定义一个<code>name</code>属性导致<code>getName</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>Bob</code>是定义<code>getName</code>作为返回<code>Bob</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认对象将返回<em>Alice</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>p2</code>胁迫<code>p</code>进入<code>Bob</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>getName</code>返回<em>鲍勃，</em>因为<code>getName</code>取自<strong>特质</strong></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">同样，不要忘记动态特质强制返回一个唯一的对象，该对象仅实现原始接口以及特质。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_differences_with_mixins"><a class="anchor" href="#_differences_with_mixins"></a> 14。mixins的差异</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mixin在概念上存在一些差异，因为Groovy中提供了它们。请注意，我们在谈论的是运行时混入，而不是@Mixin注释，后者已不赞成使用traits。</p>
</div>
<div class="paragraph">
<p>首先，特征中定义的方法在字节码中可见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在内部，特征表示为一个接口（没有默认或静态方法）和几个帮助程序类</p>
</li>
<li>
<p>这意味着实现特征的对象可以有效地实现<em>接口</em></p>
</li>
<li>
<p>这些方法从Java可见</p>
</li>
<li>
<p>它们与类型检查和静态编译兼容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相反，通过mixin添加的方法仅在运行时可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A { String methodFromA() { 'A' } }        <i class="conum" data-value="1"></i><b>(1)</b>
class B { String methodFromB() { 'B' } }        <i class="conum" data-value="2"></i><b>(2)</b>
A.metaClass.mixin B                             <i class="conum" data-value="3"></i><b>(3)</b>
def o = new A()
assert o.methodFromA() == 'A'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert o.methodFromB() == 'B'                   <i class="conum" data-value="5"></i><b>(5)</b>
assert o instanceof A                           <i class="conum" data-value="6"></i><b>(6)</b>
assert !(o instanceof B)                        <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>A</code>定义<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>B</code>定义<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>混合B到A</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>我们可以打电话<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们也可以打电话<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>该对象是的实例<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>但这<strong>不是</strong>实例<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后一点实际上是非常重要的，它说明了混合环境优于特征的地方： <strong>不</strong>修改实例，因此，如果将某个类别混入另一个类别，则不会生成第三类，并且方法会响应A即使混入，也会继续响应A。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_static_methods_properties_and_fields"><a class="anchor" href="#_static_methods_properties_and_fields"></a> 15静态方法，属性和字段</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">以下说明请注意。静态成员支持正在进行中，仍处于试验阶段。以下信息仅对3.0.0-rc-1有效。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在特征中定义静态方法，但这有很多限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有静态方法的特性不能静态编译或进行类型检查。动态地访问所有静态方法，属性和字段（这是JVM的限制）。</p>
</li>
<li>
<p>静态方法不会出现在每个特征的生成接口中。</p>
</li>
<li>
<p>特质被解释为实现类的<em>模板</em> ，这意味着每个实现类将获得自己的静态方法，属性和字段。因此，在特征上声明的静态成员不属于<code>Trait</code> ，但要实现类。</p>
</li>
<li>
<p>通常，您不应混合使用具有相同签名的静态方法和实例方法。适用特征的常规规则适用（包括多重继承冲突解决）。如果选择的方法是静态的，但是某些实现的特征具有实例变量，则将发生编译错误。如果选择的方法是实例变量，则将忽略静态变量（在这种情况下，其行为类似于Java接口中的静态方法）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait TestHelper {
    public static boolean CALLED = false        <i class="conum" data-value="1"></i><b>(1)</b>
    static void init() {                        <i class="conum" data-value="2"></i><b>(2)</b>
        CALLED = true                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
class Foo implements TestHelper {}
Foo.init()                                      <i class="conum" data-value="4"></i><b>(4)</b>
assert Foo.TestHelper__CALLED                   <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态字段在特征中声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征中也声明了一个静态方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>静态字段<em>在</em>特征中更新</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态方法<em>初始化</em>可供实现类使用</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><em>重新映射</em>了静电场以避免钻石问题</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与往常一样，不建议使用公共字段。无论如何，如果您要这样做，必须了解以下代码将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Foo.CALLED = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为在特征本身上<em>没有</em>定义静态字段<em>CALLED</em> 。同样，如果您有两个不同的实现类，则每个类都有一个不同的静态字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bar implements TestHelper {}              <i class="conum" data-value="1"></i><b>(1)</b>
class Baz implements TestHelper {}              <i class="conum" data-value="2"></i><b>(2)</b>
Bar.init()                                      <i class="conum" data-value="3"></i><b>(3)</b>
assert Bar.TestHelper__CALLED                   <i class="conum" data-value="4"></i><b>(4)</b>
assert !Baz.TestHelper__CALLED                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>Bar</code>实现特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>Baz</code>也实现了特质</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>init</code>仅被调用<code>Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态场<code>CALLED</code>上<code>Bar</code>已更新</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但是静态场<code>CALLED</code>上<code>Baz</code>不是，因为它<strong>与众不同</strong></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inheritance_of_state_gotchas"><a class="anchor" href="#_inheritance_of_state_gotchas"></a> 16。状态陷阱的继承</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们已经看到，特质是有状态的。特征可以定义字段或属性，但是当类实现特征时，它将基于每个特征获取这些字段/属性。因此，请考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特质定义两个属性， <code>x</code>和<code>y</code> ， 以及ASA <code>sum</code>方法。现在让我们创建一个实现特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BaseElem implements IntCouple {
    int f() { sum() }
}
def base = new BaseElem()
assert base.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>通话结果<code>f</code>是<code>3</code> ，因为<code>f</code>代表参加<code>sum</code>在特质中，具有状态。但是，如果我们改写这个怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Elem implements IntCouple {
    int x = 3                                       <i class="conum" data-value="1"></i><b>(1)</b>
    int y = 4                                       <i class="conum" data-value="2"></i><b>(2)</b>
    int f() { sum() }                               <i class="conum" data-value="3"></i><b>(3)</b>
}
def elem = new Elem()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>覆盖属性<code>x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖属性<code>y</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼叫<code>sum</code>从特质</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你打电话<code>elem.f()</code> ， 什么是预期的输出？实际上是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert elem.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>原因是<code>sum</code>方法访问特征的<em>字段</em> 。所以它正在使用<code>x</code>和<code>y</code>特征中定义的值。如果要使用实现类中的值，则需要使用getter和setter取消引用字段，如最后一个示例中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_self_types"><a class="anchor" href="#_self_types"></a> 17。自我类型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_type_constraints_on_traits"><a class="anchor" href="#_type_constraints_on_traits"></a> 17.1。特征的类型约束</h3>
<div class="paragraph">
<p>有时您会想编写只能应用于某种类型的特征。例如，您可能想要在扩展了您无法控制的另一个类的类上应用特征，并且仍然能够调用这些方法。为了说明这一点，让我们从以下示例开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CommunicationService {
    static void sendMessage(String from, String to, String message) {       <i class="conum" data-value="1"></i><b>(1)</b>
        println "$from sent [$message] to $to"
    }
}

class Device { String id }                                                  <i class="conum" data-value="2"></i><b>(2)</b>

trait Communicating {
    void sendMessage(Device to, String message) {
        CommunicationService.sendMessage(id, to.id, message)                <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

class MyDevice extends Device implements Communicating {}                   <i class="conum" data-value="4"></i><b>(4)</b>

def bob = new MyDevice(id:'Bob')
def alice = new MyDevice(id:'Alice')
bob.sendMessage(alice,'secret')                                             <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一种<code>Service</code>类，超出您的控制范围（在库中，…）定义了一个<code>sendMessage</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>Device</code>类，超出您的控制范围（在图书馆中，...）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>为可以调用服务的设备定义通信特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>定义<code>MyDevice</code>作为通讯设备</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>从特征中调用方法，然后<code>id</code>解决了</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>很明显，在这里<code>Communicating</code>特质只能适用于<code>Device</code> 。但是，由于特质无法扩展类，因此没有明确的约定来表明这一点。但是，代码可以编译并运行得很好，因为<code>id</code>在trait方法中将动态解决。问题是没有什么可以阻止将特征应用于任何<strong>非</strong> <code>Device</code> 。任何具有<code>id</code>会工作，而任何没有<code>id</code>属性将导致运行时错误。</p>
</div>
<div class="paragraph">
<p>如果要启用类型检查或应用，则问题甚至更加复杂<code>@CompileStatic</code>关于特质：因为特质对自己是一个人一无所知<code>Device</code> ，类型检查器会抱怨说找不到<code>id</code>属性。</p>
</div>
<div class="paragraph">
<p>一种可能性是显式添加一个<code>getId</code>特征中的方法，但不能解决所有问题。如果方法需要怎么办<code>this</code>作为参数，实际上要求它是一个<code>Device</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SecurityService {
    static void check(Device d) { if (d.id==null) throw new SecurityException() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想打电话<code>this</code>在特征中，那么您将需要明确地投射<code>this</code>变成一个<code>Device</code> 。显式强制转换为<code>this</code>到处。</p>
</div>
</div>
<div class="sect2">
<h3 id="traits-selftype"><a class="anchor" href="#traits-selftype"></a> 17.2。@SelfType批注</h3>
<div class="paragraph">
<p>为了使该合同明确，并使类型检查器知道其<em>自身</em>的<em>类型</em> ，Groovy提供了一个<code>@SelfType</code>注释将：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>让您声明实现此特征的类必须继承或实现的类型</p>
</li>
<li>
<p>如果不满足这些类型约束，则抛出编译时错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，在前面的示例中，我们可以使用<code>@groovy.transform.SelfType</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您尝试在<strong>不是</strong>设备的类上实现此特征，则将发生编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyDevice implements Communicating {} // forgot to extend Device</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'</pre>
</div>
</div>
<div class="paragraph">
<p>总之，自我类型是一种声明对特征的约束的有效方法，而不必直接在特征中声明契约或不必在所有地方使用强制转换，从而将关注点分离保持应有的严格程度。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations"><a class="anchor" href="#_limitations"></a> 18岁局限性</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_compatibility_with_ast_transformations"><a class="anchor" href="#_compatibility_with_ast_transformations"></a> 18.1。与AST转换的兼容性</h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">性状与AST转换未正式兼容。其中一些，例如<code>@CompileStatic</code>将应用于特性本身（而不是实现类），而其他特性将同时应用于实现类和特性。绝对不能保证AST转换会像在常规类上一样在特征上运行，因此使用该风险自担！
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_prefix_and_postfix_operations"><a class="anchor" href="#_prefix_and_postfix_operations"></a> 18.2。前缀和后缀操作</h3>
<div class="paragraph">
<p>在特征中，如果前缀和后缀操作更新了特征的字段，则不允许它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counting {
    int x
    void inc() {
        x++                             <i class="conum" data-value="1"></i><b>(1)</b>
    }
    void dec() {
        --x                             <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
class Counter implements Counting {}
def c = new Counter()
c.inc()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>x</code>在特征中定义，不允许后缀增量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>x</code>在特征中定义，不允许前缀减少</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>解决方法是使用<code>+=</code>运算符。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:01 AEST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>