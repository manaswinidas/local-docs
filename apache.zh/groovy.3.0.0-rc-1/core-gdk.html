<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Groovy开发套件</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>Groovy开发套件</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_working_with_io">1。使用IO</a>
<ul class="sectlevel2">
<li><a href="#_reading_files">1.1。读取文件</a></li>
<li><a href="#_writing_files">1.2。写文件</a></li>
<li><a href="#_traversing_file_trees">1.3。遍历文件树</a></li>
<li><a href="#_data_and_objects">1.4。数据与对象</a></li>
<li><a href="#process-management">1.5。执行外部流程</a></li>
</ul>
</li>
<li><a href="#_working_with_collections">2。使用收藏</a>
<ul class="sectlevel2">
<li><a href="#Collections-Lists">2.1。清单</a>
<ul class="sectlevel3">
<li><a href="#_list_literals">2.1.1。列出文字</a></li>
<li><a href="#_list_as_a_boolean_expression">2.1.2。以布尔表达式形式列出</a></li>
<li><a href="#_iterating_on_a_list">2.1.3。迭代列表</a></li>
<li><a href="#_manipulating_lists">2.1.4。操作清单</a>
<ul class="sectlevel4">
<li><a href="#List-Filtering">筛选和搜索</a></li>
<li><a href="#_adding_or_removing_elements">添加或删除元素</a></li>
<li><a href="#_set_operations">设定操作</a></li>
<li><a href="#_sorting">排序</a></li>
<li><a href="#_duplicating_elements">复制元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Collections-Maps">2.2。地图</a>
<ul class="sectlevel3">
<li><a href="#_map_literals">2.2.1。地图文字</a></li>
<li><a href="#_map_property_notation">2.2.2。地图属性符号</a></li>
<li><a href="#_iterating_on_maps">2.2.3。在地图上迭代</a></li>
<li><a href="#_manipulating_maps">2.2.4。操纵地图</a>
<ul class="sectlevel4">
<li><a href="#_adding_or_removing_elements_2">添加或删除元素</a></li>
<li><a href="#JN1035-Maps-Collectionviewsofamap">键，值和条目</a></li>
<li><a href="#_filtering_and_searching">筛选和搜索</a></li>
<li><a href="#Maps-Grouping">分组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Collections-Ranges">2.3。范围</a></li>
<li><a href="#_syntax_enhancements_for_collections">2.4。集合的语法增强</a>
<ul class="sectlevel3">
<li><a href="#_gpath_support">2.4.1。GPath支持</a></li>
<li><a href="#_spread_operator">2.4.2。点差运算符</a></li>
<li><a href="#Collections-Gettingefficientwiththestar-dotoperator">2.4.3。星点“ *”。算子</a></li>
<li><a href="#Collections-Slicingwiththesubscriptoperator">2.4.4。下标运算符切片</a></li>
</ul>
</li>
<li><a href="#Collections-EnhancedCollectionMethods">2.5。增强的收集方法</a></li>
</ul>
</li>
<li><a href="#_working_with_legacy_date_calendar_types">3。使用旧的日期/日历类型</a></li>
<li><a href="#_working_with_date_time_types">4。处理日期/时间类型</a>
<ul class="sectlevel2">
<li><a href="#_formatting_and_parsing">4.1。格式化和解析</a></li>
<li><a href="#_manipulating_date_time">4.2。处理日期/时间</a>
<ul class="sectlevel3">
<li><a href="#_addition_and_subtraction">4.2.1。加减</a></li>
<li><a href="#_multiplication_and_division">4.2.2。乘法与除法</a></li>
<li><a href="#_incrementing_and_decrementing">4.2.3。递增和递减</a></li>
<li><a href="#_negation">4.2.4。否定</a></li>
</ul>
</li>
<li><a href="#_interacting_with_date_time_values">4.3。与日期/时间值交互</a>
<ul class="sectlevel3">
<li><a href="#_property_notation">4.3.1。属性符号</a></li>
<li><a href="#_ranges_code_upto_code_and_code_downto_code">4.3.2。范围<code>upto</code>和<code>downto</code></a></li>
<li><a href="#_combining_date_time_values">4.3.3。合并日期/时间值</a></li>
<li><a href="#_creating_periods_and_durations">4.3.4。创建期间和持续时间</a></li>
</ul>
</li>
<li><a href="#_converting_between_legacy_and_jsr_310_types">4.4。在旧版和JSR 310类型之间转换</a></li>
</ul>
</li>
<li><a href="#_handy_utilities">5，方便的实用程序</a>
<ul class="sectlevel2">
<li><a href="#_configslurper">5.1。ConfigSlurper</a></li>
<li><a href="#_expando">5.2。Expando</a></li>
<li><a href="#_observable_list_map_and_set">5.3。可观察的列表，地图和集合</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_working_with_io"><a class="anchor" href="#_working_with_io"></a> 1。使用IO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy提供了许多用于I / O的<a href="gdk.html">辅助方法</a> 。尽管您可以在Groovy中使用标准Java代码来处理这些代码，但Groovy提供了更便捷的方式来处理文件，流，读取器，...</p>
</div>
<div class="paragraph">
<p>特别是，您应该查看添加到以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>java.io.File</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></p>
</li>
<li>
<p>的<code>java.io.InputStream</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
</li>
<li>
<p>的<code>java.io.OutputStream</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></p>
</li>
<li>
<p>的<code>java.io.Reader</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></p>
</li>
<li>
<p>的<code>java.io.Writer</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></p>
</li>
<li>
<p>的<code>java.nio.file.Path</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分重点介绍使用上述可用辅助方法的示例惯用构造，但这并不意味着对所有可用方法都有完整的描述。为此，请阅读<a href="gdk.html">GDK API</a> 。</p>
</div>
<div class="sect2">
<h3 id="_reading_files"><a class="anchor" href="#_reading_files"></a> 1.1。读取文件</h3>
<div class="paragraph">
<p>作为第一个示例，让我们看看如何在Groovy中打印文本文件的所有行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir, 'haiku.txt').eachLine { line -&gt;
    println line
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>eachLine</code>方法是添加到<code>File</code> Groovy自动创建class并具有许多变体，例如，如果您需要知道行号，则可以使用以下变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir, 'haiku.txt').eachLine { line, nb -&gt;
    println "Line $nb: $line"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果出于某种原因在抛出异常<code>eachLine</code>主体，该方法可确保资源已正确关闭。对于Groovy添加的所有I / O资源方法，都是如此。</p>
</div>
<div class="paragraph">
<p>例如，在某些情况下，您将更喜欢使用<code>Reader</code> ，但是仍然可以从Groovy的自动资源管理中受益。在下一个示例中，即使发生异常，阅读器<strong>也会</strong>关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def count = 0, MAXSIZE = 3
new File(baseDir,"haiku.txt").withReader { reader -&gt;
    while (reader.readLine()) {
        if (++count &gt; MAXSIZE) {
            throw new RuntimeException('Haiku should only have 3 verses')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要将文本文件的行收集到列表中，则可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = new File(baseDir, 'haiku.txt').collect {it}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您甚至可以利用<code>as</code>运算符，将文件的内容放入行数组中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def array = new File(baseDir, 'haiku.txt') as String[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您必须将文件内容放入文件中多少次了<code>byte[]</code>它需要多少代码？Groovy实际上非常容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">byte[] contents = file.bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用I / O不仅限于处理文件。实际上，很多操作都依赖于输入/输出流，因此，正如您在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html">文档中</a>可以看到的那样，为什么Groovy为此添加了很多支持方法。</p>
</div>
<div class="paragraph">
<p>例如，您可以获得<code>InputStream</code>从一个<code>File</code>非常简单地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def is = new File(baseDir,'haiku.txt').newInputStream()
// do something ...
is.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您可以看到它需要您关闭输入流。在Groovy中，通常最好使用<code>withInputStream</code>可以为您解决的成语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt').withInputStream { stream -&gt;
    // do something ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_files"><a class="anchor" href="#_writing_files"></a> 1.2。写文件</h3>
<div class="paragraph">
<p>当然，在某些情况下，您将不希望读取而是写入文件。一种选择是使用<code>Writer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt').withWriter('utf-8') { writer -&gt;
    writer.writeLine 'Into the ancient pond'
    writer.writeLine 'A frog jumps'
    writer.writeLine 'Water’s sound!'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但对于这样一个简单的示例，使用<code><<</code>运算符就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt') &lt;&lt; '''Into the ancient pond
A frog jumps
Water’s sound!'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，我们并不总是处理文本内容，因此您可以使用<code>Writer</code>或直接写入字节，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">file.bytes = [66,22,11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，您也可以直接处理输出流。例如，以下是创建输出流以写入文件的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def os = new File(baseDir,'data.bin').newOutputStream()
// do something ...
os.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您会看到它需要您关闭输出流。再次强调，使用<code>withOutputStream</code>在任何情况下都会处理异常并关闭流的惯用语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'data.bin').withOutputStream { stream -&gt;
    // do something ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_traversing_file_trees"><a class="anchor" href="#_traversing_file_trees"></a> 1.3。遍历文件树</h3>
<div class="paragraph">
<p>在脚本编写上下文中，遍历文件树以查找某些特定文件并对其进行处理是一项常见的任务。Groovy提供了多种方法来执行此操作。例如，您可以对目录的所有文件执行某些操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.eachFile { file -&gt;                      <i class="conum" data-value="1"></i><b>(1)</b>
    println file.name
}
dir.eachFileMatch(~/.*\.txt/) { file -&gt;     <i class="conum" data-value="2"></i><b>(2)</b>
    println file.name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>对目录中找到的每个文件执行关闭代码</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对目录中与指定模式匹配的文件执行关闭代码</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，您将不得不处理更深层次的文件层次结构，在这种情况下，您可以使用<code>eachFileRecurse</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.eachFileRecurse { file -&gt;                      <i class="conum" data-value="1"></i><b>(1)</b>
    println file.name
}

dir.eachFileRecurse(FileType.FILES) { file -&gt;      <i class="conum" data-value="2"></i><b>(2)</b>
    println file.name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>递归地对目录中找到的每个文件或目录执行关闭代码</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>仅对文件执行关闭代码，但递归执行</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于更复杂的遍历技术，您可以使用<code>traverse</code>方法，要求您设置一个特殊标志来指示如何处理遍历：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.traverse { file -&gt;
    if (file.directory &amp;&amp; file.name=='bin') {
        FileVisitResult.TERMINATE                   <i class="conum" data-value="1"></i><b>(1)</b>
    } else {
        println file.name
        FileVisitResult.CONTINUE                    <i class="conum" data-value="2"></i><b>(2)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果当前文件是目录，并且名称是<code>bin</code> ，停止遍历</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>否则，打印文件名并继续</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_data_and_objects"><a class="anchor" href="#_data_and_objects"></a> 1.4。数据与对象</h3>
<div class="paragraph">
<p>在Java中，通常使用来对数据进行序列化和反序列化<code>java.io.DataOutputStream</code>和<code>java.io.DataInputStream</code>类。Groovy将使处理它们变得更加容易。例如，您可以使用以下代码将数据序列化为文件并反序列化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean b = true
String message = 'Hello from Groovy'
// Serialize data into a file
file.withDataOutputStream { out -&gt;
    out.writeBoolean(b)
    out.writeUTF(message)
}
// ...
// Then read it back
file.withDataInputStream { input -&gt;
    assert input.readBoolean() == b
    assert input.readUTF() == message
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，如果您要序列化的数据实现了<code>Serializable</code>界面，您可以继续执行对象输出流，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person p = new Person(name:'Bob', age:76)
// Serialize data into a file
file.withObjectOutputStream { out -&gt;
    out.writeObject(p)
}
// ...
// Then read it back
file.withObjectInputStream { input -&gt;
    def p2 = input.readObject()
    assert p2.name == p.name
    assert p2.age == p.age
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="process-management"><a class="anchor" href="#process-management"></a> 1.5。执行外部流程</h3>
<div class="paragraph">
<p>上一节描述了在Groovy中处理文件，读取器或流有多么容易。但是，在诸如系统管理或开发人员之类的领域中，通常需要与外部流程进行通信。</p>
</div>
<div class="paragraph">
<p>Groovy提供了一种执行命令行过程的简单方法。只需将命令行写为字符串并调用<code>execute()</code>方法。例如，在* nix机器（或装有适当* nix命令的Windows机器）上，您可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "ls -l".execute()             <i class="conum" data-value="1"></i><b>(1)</b>
println "Found text ${process.text}"        <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>执行<code>ls</code>外部过程中的命令</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用命令的输出并检索文本</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>execute()</code>方法返回一个<code>java.lang.Process</code>实例，随后将允许处理输入/输出/错误流，并检查进程的退出值等。</p>
</div>
<div class="paragraph">
<p>例如，这里是与上面相同的命令，但是我们现在一次处理一行结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "ls -l".execute()             <i class="conum" data-value="1"></i><b>(1)</b>
process.in.eachLine { line -&gt;               <i class="conum" data-value="2"></i><b>(2)</b>
    println line                            <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>执行<code>ls</code>外部过程中的命令</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对于流程的输入流的每一行</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>打印线</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得一提的是<code>in</code>对应于命令标准输出的输入流。 <code>out</code>将指向一个流，您可以在其中将数据发送到流程（其标准输入）。</p>
</div>
<div class="paragraph">
<p>请记住，许多命令是Shell内置的，需要特殊处理。因此，如果要在Windows计算机上的目录中列出文件列表，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "dir".execute()
println "${process.text}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会收到一个<code>IOException</code>说<em>无法运行程序“目录”：CreateProcess错误= 2，系统找不到指定的文件。</em></p>
</div>
<div class="paragraph">
<p>这是因为<code>dir</code>内置于Windows Shell（ <code>cmd.exe</code> ），并且不能作为简单的可执行文件运行。相反，您将需要编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "cmd /c dir".execute()
println "${process.text}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，因为此功能当前使用<code>java.lang.Process</code>卧底，必须考虑该类的不足。特别是，此类的javadoc说：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>由于某些本机平台仅为标准输入和输出流提供了有限的缓冲区大小，因此未能及时写入子进程的输入流或读取子进程的输出流可能导致子进程阻塞，甚至死锁</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因此，Groovy提供了一些附加的辅助方法，这些方法使处理流程的流变得更加容易。</p>
</div>
<div class="paragraph">
<p>这是如何吞噬过程中的所有输出（包括错误流输出）的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = "rm -f foo.tmp".execute([], tmpDir)
p.consumeProcessOutput()
p.waitFor()</code></pre>
</div>
</div>
<div class="paragraph">
<p>也有变化<code>consumeProcessOutput</code>利用<code>StringBuffer</code> ， <code>InputStream</code> ， <code>OutputStream</code>等等...有关完整列表，请阅读<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html">java.lang的</a><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html">GDK API。处理</a></p>
</div>
<div class="paragraph">
<p>另外，这些是<code>pipeTo</code>命令（映射到<code>|</code>以允许重载），这允许将一个进程的输出流馈送到另一个进程的输入流。</p>
</div>
<div class="paragraph">
<p>以下是一些使用示例：</p>
</div>
<div class="listingblock">
<div class="title">管道在行动</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">proc1 = 'ls'.execute()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc1 | proc2 | proc3 | proc4
proc4.waitFor()
if (proc4.exitValue()) {
    println proc4.err.text
} else {
    println proc4.text
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费错误</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sout = new StringBuilder()
def serr = new StringBuilder()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc4.consumeProcessOutput(sout, serr)
proc2 | proc3 | proc4
[proc2, proc3].each { it.consumeProcessErrorStream(serr) }
proc2.withWriter { writer -&gt;
    writer &lt;&lt; 'testfile.groovy'
}
proc4.waitForOrKill(1000)
println "Standard output: $sout"
println "Standard error: $serr"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_collections"><a class="anchor" href="#_working_with_collections"></a> 2。使用收藏</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy为各种集合类型提供本地支持，包括<a href="#Collections-Lists">列表</a> ， <a href="#Collections-Maps">地图</a>或<a href="#Collections-Ranges">范围</a> 。其中大多数基于Java集合类型，并以<a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>中的其他方法修饰。</p>
</div>
<div class="sect2">
<h3 id="Collections-Lists"><a class="anchor" href="#Collections-Lists"></a> 2.1。清单</h3>
<div class="sect3">
<h4 id="_list_literals"><a class="anchor" href="#_list_literals"></a> 2.1.1。列出文字</h4>
<div class="paragraph">
<p>您可以如下创建列表。注意<code>[]</code>是空列表表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [5, 6, 7, 8]
assert list.get(2) == 7
assert list[2] == 7
assert list instanceof java.util.List

def emptyList = []
assert emptyList.size() == 0
emptyList.add(5)
assert emptyList.size() == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个列表表达式都会创建<a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">java.util的实现</a><a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">。清单</a> 。</p>
</div>
<div class="paragraph">
<p>当然，列表可以用作构建另一个列表的源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list1 = ['a', 'b', 'c']
//construct a new list, seeded with the same items as in list1
def list2 = new ArrayList&lt;String&gt;(list1)

assert list2 == list1 // == checks that each corresponding element is the same

// clone() can also be called
def list3 = list1.clone()
assert list3 == list1</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表是对象的有序集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [5, 6, 7, 8]
assert list.size() == 4
assert list.getClass() == ArrayList     // the specific kind of list being used

assert list[2] == 7                     // indexing starts at 0
assert list.getAt(2) == 7               // equivalent method to subscript operator []
assert list.get(2) == 7                 // alternative method

list[2] = 9
assert list == [5, 6, 9, 8,]           // trailing comma OK

list.putAt(2, 10)                       // equivalent method to [] when value being changed
assert list == [5, 6, 10, 8]
assert list.set(2, 11) == 10            // alternative method that returns old value
assert list == [5, 6, 11, 8]

assert ['a', 1, 'a', 'a', 2.5, 2.5f, 2.5d, 'hello', 7g, null, 9 as byte]
//objects can be of different types; duplicates allowed

assert [1, 2, 3, 4, 5][-1] == 5             // use negative indices to count from the end
assert [1, 2, 3, 4, 5][-2] == 4
assert [1, 2, 3, 4, 5].getAt(-2) == 4       // getAt() available with negative index...
try {
    [1, 2, 3, 4, 5].get(-2)                 // but negative index not allowed with get()
    assert false
} catch (e) {
    assert e instanceof IndexOutOfBoundsException
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_list_as_a_boolean_expression"><a class="anchor" href="#_list_as_a_boolean_expression"></a> 2.1.2。以布尔表达式形式列出</h4>
<div class="paragraph">
<p>列表可以评估为<code>boolean</code>值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ![]             // an empty list evaluates as false

//all other lists, irrespective of contents, evaluate as true
assert [1] &amp;&amp; ['a'] &amp;&amp; [0] &amp;&amp; [0.0] &amp;&amp; [false] &amp;&amp; [null]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_iterating_on_a_list"><a class="anchor" href="#_iterating_on_a_list"></a> 2.1.3。迭代列表</h4>
<div class="paragraph">
<p>迭代列表中的元素通常是通过调用<code>each</code>和<code>eachWithIndex</code>方法，对列表的每个项目执行代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">[1, 2, 3].each {
    println "Item: $it" // `it` is an implicit parameter corresponding to the current element
}
['a', 'b', 'c'].eachWithIndex { it, i -&gt; // `it` is the current element, while `i` is the index
    println "$i: $it"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了迭代之外，通过将其每个元素转换为其他元素来创建新列表通常也很有用。该操作（通常称为映射）是在Groovy中完成的，这要归功于<code>collect</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]

// shortcut syntax instead of collect
assert [1, 2, 3]*.multiply(2) == [1, 2, 3].collect { it.multiply(2) }

def list = [0]
// it is possible to give `collect` the list which collects the elements
assert [1, 2, 3].collect(list) { it * 2 } == [0, 2, 4, 6]
assert list == [0, 2, 4, 6]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_manipulating_lists"><a class="anchor" href="#_manipulating_lists"></a> 2.1.4。操作清单</h4>
<div class="sect4">
<h5 id="List-Filtering"><a class="anchor" href="#List-Filtering"></a>筛选和搜索</h5>
<div class="paragraph">
<p><a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>包含许多关于集合的方法，这些方法通过实用的方法增强了标准集合，其中一些示例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2, 3].find { it &gt; 1 } == 2           // find 1st element matching criteria
assert [1, 2, 3].findAll { it &gt; 1 } == [2, 3]   // find all elements matching critieria
assert ['a', 'b', 'c', 'd', 'e'].findIndexOf {      // find index of 1st element matching criteria
    it in ['c', 'e', 'g']
} == 2

assert ['a', 'b', 'c', 'd', 'c'].indexOf('c') == 2  // index returned
assert ['a', 'b', 'c', 'd', 'c'].indexOf('z') == -1 // index -1 means value not in list
assert ['a', 'b', 'c', 'd', 'c'].lastIndexOf('c') == 4

assert [1, 2, 3].every { it &lt; 5 }               // returns true if all elements match the predicate
assert ![1, 2, 3].every { it &lt; 3 }
assert [1, 2, 3].any { it &gt; 2 }                 // returns true if any element matches the predicate
assert ![1, 2, 3].any { it &gt; 3 }

assert [1, 2, 3, 4, 5, 6].sum() == 21                // sum anything with a plus() method
assert ['a', 'b', 'c', 'd', 'e'].sum {
    it == 'a' ? 1 : it == 'b' ? 2 : it == 'c' ? 3 : it == 'd' ? 4 : it == 'e' ? 5 : 0
    // custom value to use in sum
} == 15
assert ['a', 'b', 'c', 'd', 'e'].sum { ((char) it) - ((char) 'a') } == 10
assert ['a', 'b', 'c', 'd', 'e'].sum() == 'abcde'
assert [['a', 'b'], ['c', 'd']].sum() == ['a', 'b', 'c', 'd']

// an initial value can be provided
assert [].sum(1000) == 1000
assert [1, 2, 3].sum(1000) == 1006

assert [1, 2, 3].join('-') == '1-2-3'           // String joining
assert [1, 2, 3].inject('counting: ') {
    str, item -&gt; str + item                     // reduce operation
} == 'counting: 123'
assert [1, 2, 3].inject(0) { count, item -&gt;
    count + item
} == 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是惯用的Groovy代码，用于查找集合中的最大值和最小值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [9, 4, 2, 10, 5]
assert list.max() == 10
assert list.min() == 2

// we can also compare single characters, as anything comparable
assert ['x', 'y', 'a', 'z'].min() == 'a'

// we can use a closure to specify the sorting behaviour
def list2 = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list2.max { it.size() } == 'xyzuvw'
assert list2.min { it.size() } == 'z'</code></pre>
</div>
</div>
<div class="paragraph">
<p>除闭包外，您还可以使用<code>Comparator</code>定义比较标准：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Comparator mc = { a, b -&gt; a == b ? 0 : (a &lt; b ? -1 : 1) }

def list = [7, 4, 9, -6, -1, 11, 2, 3, -9, 5, -13]
assert list.max(mc) == 11
assert list.min(mc) == -13

Comparator mc2 = { a, b -&gt; a == b ? 0 : (Math.abs(a) &lt; Math.abs(b)) ? -1 : 1 }


assert list.max(mc2) == -13
assert list.min(mc2) == -1

assert list.max { a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } == -13
assert list.min { a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } == -1</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adding_or_removing_elements"><a class="anchor" href="#_adding_or_removing_elements"></a>添加或删除元素</h5>
<div class="paragraph">
<p>我们可以用<code>[]</code>分配一个新的空列表，并<code><<</code>附加项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = []
assert list.empty

list &lt;&lt; 5
assert list.size() == 1

list &lt;&lt; 7 &lt;&lt; 'i' &lt;&lt; 11
assert list == [5, 7, 'i', 11]

list &lt;&lt; ['m', 'o']
assert list == [5, 7, 'i', 11, ['m', 'o']]

//first item in chain of &lt;&lt; is target list
assert ([1, 2] &lt;&lt; 3 &lt;&lt; [4, 5] &lt;&lt; 6) == [1, 2, 3, [4, 5], 6]

//using leftShift is equivalent to using &lt;&lt;
assert ([1, 2, 3] &lt;&lt; 4) == ([1, 2, 3].leftShift(4))</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过多种方式添加到列表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2] + 3 + [4, 5] + 6 == [1, 2, 3, 4, 5, 6]
// equivalent to calling the `plus` method
assert [1, 2].plus(3).plus([4, 5]).plus(6) == [1, 2, 3, 4, 5, 6]

def a = [1, 2, 3]
a += 4      // creates a new list and assigns it to `a`
a += [5, 6]
assert a == [1, 2, 3, 4, 5, 6]

assert [1, *[222, 333], 456] == [1, 222, 333, 456]
assert [*[1, 2, 3]] == [1, 2, 3]
assert [1, [2, 3, [4, 5], 6], 7, [8, 9]].flatten() == [1, 2, 3, 4, 5, 6, 7, 8, 9]

def list = [1, 2]
list.add(3)
list.addAll([5, 4])
assert list == [1, 2, 3, 5, 4]

list = [1, 2]
list.add(1, 3) // add 3 just before index 1
assert list == [1, 3, 2]

list.addAll(2, [5, 4]) //add [5,4] just before index 2
assert list == [1, 3, 5, 4, 2]

list = ['a', 'b', 'z', 'e', 'u', 'v', 'g']
list[8] = 'x' // the [] operator is growing the list as needed
// nulls inserted if required
assert list == ['a', 'b', 'z', 'e', 'u', 'v', 'g', null, 'x']</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是重要的是<code>+</code>列表中的运算符<strong>未更改</strong> 。相比<code><<</code> ，它将创建一个新列表，这通常不是您想要的，并且可能导致性能问题。</p>
</div>
<div class="paragraph">
<p><a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>还包含一些方法，使您可以轻松地按值从列表中删除元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['a','b','c','b','b'] - 'c' == ['a','b','b','b']
assert ['a','b','c','b','b'] - 'b' == ['a','c']
assert ['a','b','c','b','b'] - ['b','c'] == ['a']

def list = [1,2,3,4,3,2,1]
list -= 3           // creates a new list by removing `3` from the original one
assert list == [1,2,4,2,1]
assert ( list -= [2,4] ) == [1,1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以通过将元素的索引传递给<code>remove</code>方法，在这种情况下，列表会发生突变：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ['a','b','c','d','e','f','b','b','a']
assert list.remove(2) == 'c'        // remove the third element, and return it
assert list == ['a','b','d','e','f','b','b','a']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您只想删除列表中具有相同值的第一个元素，而不是删除所有元素，则可以调用<code>remove</code>传递值的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list= ['a','b','c','b','b']
assert list.remove('c')             // remove 'c', and return true because element removed
assert list.remove('b')             // remove first 'b', and return true because element removed

assert ! list.remove('z')           // return false because no elements removed
assert list == ['a','b','b']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，有两个<code>remove</code>可用方法。一个使用整数并通过其索引删除元素，另一个将删除与传递的值匹配的第一个元素。那么，当我们有一个整数列表时该怎么办？在这种情况下，您可能希望使用<code>removeAt</code>通过其索引删除元素，以及<code>removeElement</code>删除与值匹配的第一个元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [1,2,3,4,5,6,2,2,1]

assert list.remove(2) == 3          // this removes the element at index 2, and returns it
assert list == [1,2,4,5,6,2,2,1]

assert list.removeElement(2)        // remove first 2 and return true
assert list == [1,4,5,6,2,2,1]

assert ! list.removeElement(8)      // return false because 8 is not in the list
assert list == [1,4,5,6,2,2,1]

assert list.removeAt(1) == 4        // remove element at index 1, and return it
assert list == [1,5,6,2,2,1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然， <code>removeAt</code>和<code>removeElement</code>适用于任何类型的列表。</p>
</div>
<div class="paragraph">
<p>此外，删除列表中的所有元素都可以通过调用<code>clear</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list= ['a',2,'c',4]
list.clear()
assert list == []</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_set_operations"><a class="anchor" href="#_set_operations"></a>设定操作</h5>
<div class="paragraph">
<p><a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>还包括一些使推理更容易的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'a' in ['a','b','c']             // returns true if an element belongs to the list
assert ['a','b','c'].contains('a')      // equivalent to the `contains` method in Java
assert [1,3,4].containsAll([1,4])       // `containsAll` will check that all elements are found

assert [1,2,3,3,3,3,4,5].count(3) == 4  // count the number of elements which have some value
assert [1,2,3,3,3,3,4,5].count {
    it%2==0                             // count the number of elements which match the predicate
} == 2

assert [1,2,4,6,8,10,12].intersect([1,3,6,9,12]) == [1,6,12]

assert [1,2,3].disjoint( [4,6,9] )
assert ![1,2,3].disjoint( [2,4,6] )</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_sorting"><a class="anchor" href="#_sorting"></a>排序</h5>
<div class="paragraph">
<p>使用集合通常意味着排序。Groovy提供了各种选项来对列表进行排序，从使用闭包到比较器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [6, 3, 9, 2, 7, 1, 5].sort() == [1, 2, 3, 5, 6, 7, 9]

def list = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list.sort {
    it.size()
} == ['z', 'abc', '321', 'Hello', 'xyzuvw']

def list2 = [7, 4, -6, -1, 11, 2, 3, -9, 5, -13]
assert list2.sort { a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } ==
        [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

Comparator mc = { a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 }

// JDK 8+ only
// list2.sort(mc)
// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

def list3 = [6, -3, 9, 2, -7, 1, 5]

Collections.sort(list3)
assert list3 == [-7, -3, 1, 2, 5, 6, 9]

Collections.sort(list3, mc)
assert list3 == [1, 2, -3, 5, 6, -7, 9]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_duplicating_elements"><a class="anchor" href="#_duplicating_elements"></a>复制元素</h5>
<div class="paragraph">
<p><a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>还利用运算符重载来提供允许复制列表元素的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2, 3] * 3 == [1, 2, 3, 1, 2, 3, 1, 2, 3]
assert [1, 2, 3].multiply(2) == [1, 2, 3, 1, 2, 3]
assert Collections.nCopies(3, 'b') == ['b', 'b', 'b']

// nCopies from the JDK has different semantics than multiply for lists
assert Collections.nCopies(2, [1, 2]) == [[1, 2], [1, 2]] //not [1,2,1,2]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Collections-Maps"><a class="anchor" href="#Collections-Maps"></a> 2.2。地图</h3>
<div class="sect3">
<h4 id="_map_literals"><a class="anchor" href="#_map_literals"></a> 2.2.1。地图文字</h4>
<div class="paragraph">
<p>在Groovy中，可以使用地图文字语法创建地图（也称为关联数组）： <code>[:]</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.get('name') == 'Gromit'
assert map.get('id') == 1234
assert map['name'] == 'Gromit'
assert map['id'] == 1234
assert map instanceof java.util.Map

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.put("foo", 5)
assert emptyMap.size() == 1
assert emptyMap.get("foo") == 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>映射键默认为字符串： <code>[a:1]</code>相当于<code>['a':1]</code> 。如果您定义一个名为<code>a</code>而你想要的<strong>价值</strong> <code>a</code>成为地图中的关键。如果是这种情况，则<strong>必须</strong>通过添加括号对键进行转义，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def a = 'Bob'
def ages = [a: 43]
assert ages['Bob'] == null // `Bob` is not found
assert ages['a'] == 43     // because `a` is a literal!

ages = [(a): 43]            // now we escape `a` by using parenthesis
assert ages['Bob'] == 43   // and the value is found!</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了地图文字外，还可以获取地图的新副本，以进行克隆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [
        simple : 123,
        complex: [a: 1, b: 2]
]
def map2 = map.clone()
assert map2.get('simple') == map.get('simple')
assert map2.get('complex') == map.get('complex')
map2.get('complex').put('c', 3)
assert map.get('complex').get('c') == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上一个示例所示，生成的地图是原始地图的<strong>浅表</strong>副本。</p>
</div>
</div>
<div class="sect3">
<h4 id="_map_property_notation"><a class="anchor" href="#_map_property_notation"></a> 2.2.2。地图属性符号</h4>
<div class="paragraph">
<p>地图的作用也类似于bean，因此您可以使用属性符号来获取/设置<code>Map</code>只要键是有效的Groovy标识符的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.name == 'Gromit'     // can be used instead of map.get('name')
assert map.id == 1234

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.foo = 5
assert emptyMap.size() == 1
assert emptyMap.foo == 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：经设计<code>map.foo</code>会一直寻找钥匙<code>foo</code>在地图上。这意味着<code>foo.class</code>将返回<code>null</code>在不包含<code>class</code>键。如果您真的想了解课程，则必须使用<code>getClass()</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.class == null
assert map.get('class') == null
assert map.getClass() == LinkedHashMap // this is probably what you want

map = [1      : 'a',
       (true) : 'p',
       (false): 'q',
       (null) : 'x',
       'null' : 'z']
assert map.containsKey(1) // 1 is not an identifier so used as is
assert map.true == null
assert map.false == null
assert map.get(true) == 'p'
assert map.get(false) == 'q'
assert map.null == 'z'
assert map.get(null) == 'x'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_iterating_on_maps"><a class="anchor" href="#_iterating_on_maps"></a> 2.2.3。在地图上迭代</h4>
<div class="paragraph">
<p>与<a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包一样</a> ，地图上的惯用迭代利用了<code>each</code>和<code>eachWithIndex</code>方法。值得注意的是，使用地图文字表示法创建的地图是<strong>有序的</strong> ，也就是说，如果您对地图条目进行迭代，则可以确保返回的条目将与添加到地图中的顺序相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [
        Bob  : 42,
        Alice: 54,
        Max  : 33
]

// `entry` is a map entry
map.each { entry -&gt;
    println "Name: $entry.key Age: $entry.value"
}

// `entry` is a map entry, `i` the index in the map
map.eachWithIndex { entry, i -&gt;
    println "$i - Name: $entry.key Age: $entry.value"
}

// Alternatively you can use key and value directly
map.each { key, value -&gt;
    println "Name: $key Age: $value"
}

// Key, value and i as the index in the map
map.eachWithIndex { key, value, i -&gt;
    println "$i - Name: $key Age: $value"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_manipulating_maps"><a class="anchor" href="#_manipulating_maps"></a> 2.2.4。操纵地图</h4>
<div class="sect4">
<h5 id="_adding_or_removing_elements_2"><a class="anchor" href="#_adding_or_removing_elements_2"></a>添加或删除元素</h5>
<div class="paragraph">
<p>可以使用来完成将元素添加到地图的操作<code>put</code>方法，下标运算符或使用<code>putAll</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def defaults = [1: 'a', 2: 'b', 3: 'c', 4: 'd']
def overrides = [2: 'z', 5: 'x', 13: 'x']

def result = new LinkedHashMap(defaults)
result.put(15, 't')
result[17] = 'u'
result.putAll(overrides)
assert result == [1: 'a', 2: 'z', 3: 'c', 4: 'd', 5: 'x', 13: 'x', 15: 't', 17: 'u']</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除地图的所有元素可以通过调用<code>clear</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def m = [1:'a', 2:'b']
assert m.get(1) == 'a'
m.clear()
assert m == [:]</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用地图文字语法生成的地图正在使用对象<code>equals</code>和<code>hashcode</code>方法。这意味着您<strong>永远不要</strong>使用哈希代码随时间变化的对象，否则您将无法找回关联的值。</p>
</div>
<div class="paragraph">
<p>还值得注意的是，您<strong>永远不要</strong>使用<code>GString</code>作为地图的键，因为a的哈希码<code>GString</code>与等效项的哈希码不同<code>String</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def key = 'some key'
def map = [:]
def gstringKey = "${key.toUpperCase()}"
map.put(gstringKey,'value')
assert map.get('SOME KEY') == null</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="JN1035-Maps-Collectionviewsofamap"><a class="anchor" href="#JN1035-Maps-Collectionviewsofamap"></a>键，值和条目</h5>
<div class="paragraph">
<p>我们可以检查视图中的键，值和条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [1:'a', 2:'b', 3:'c']

def entries = map.entrySet()
entries.each { entry -&gt;
  assert entry.key in [1,2,3]
  assert entry.value in ['a','b','c']
}

def keys = map.keySet()
assert keys == [1,2,3] as Set</code></pre>
</div>
</div>
<div class="paragraph">
<p>不建议更改视图返回的值（无论是映射条目，键还是值），因为操作的成功直接取决于所操纵的映射的类型。特别是，Groovy依赖于JDK的集合，这些集合通常不能保证可以安全地通过<code>keySet</code> ， <code>entrySet</code> ， 要么<code>values</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_and_searching"><a class="anchor" href="#_filtering_and_searching"></a>筛选和搜索</h5>
<div class="paragraph">
<p><a href="http://www.groovy-lang.org/gdk.html">Groovy开发工具包</a>包含与<a href="#List-Filtering">列表</a>类似的过滤，搜索和收集方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def people = [
    1: [name:'Bob', age: 32, gender: 'M'],
    2: [name:'Johnny', age: 36, gender: 'M'],
    3: [name:'Claire', age: 21, gender: 'F'],
    4: [name:'Amy', age: 54, gender:'F']
]

def bob = people.find { it.value.name == 'Bob' } // find a single entry
def females = people.findAll { it.value.gender == 'F' }

// both return entries, but you can use collect to retrieve the ages for example
def ageOfBob = bob.value.age
def agesOfFemales = females.collect {
    it.value.age
}

assert ageOfBob == 32
assert agesOfFemales == [21,54]

// but you could also use a key/pair value as the parameters of the closures
def agesOfMales = people.findAll { id, person -&gt;
    person.gender == 'M'
}.collect { id, person -&gt;
    person.age
}
assert agesOfMales == [32, 36]

// `every` returns true if all entries match the predicate
assert people.every { id, person -&gt;
    person.age &gt; 18
}

// `any` returns true if any entry matches the predicate

assert people.any { id, person -&gt;
    person.age == 54
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Maps-Grouping"><a class="anchor" href="#Maps-Grouping"></a>分组</h5>
<div class="paragraph">
<p>我们可以使用一些条件将列表分组到地图中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['a', 7, 'b', [2, 3]].groupBy {
    it.class
} == [(String)   : ['a', 'b'],
      (Integer)  : [7],
      (ArrayList): [[2, 3]]
]

assert [
        [name: 'Clark', city: 'London'], [name: 'Sharma', city: 'London'],
        [name: 'Maradona', city: 'LA'], [name: 'Zhang', city: 'HK'],
        [name: 'Ali', city: 'HK'], [name: 'Liu', city: 'HK'],
].groupBy { it.city } == [
        London: [[name: 'Clark', city: 'London'],
                 [name: 'Sharma', city: 'London']],
        LA    : [[name: 'Maradona', city: 'LA']],
        HK    : [[name: 'Zhang', city: 'HK'],
                 [name: 'Ali', city: 'HK'],
                 [name: 'Liu', city: 'HK']],
]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Collections-Ranges"><a class="anchor" href="#Collections-Ranges"></a> 2.3。范围</h3>
<div class="paragraph">
<p>范围允许您创建顺序值列表。这些可以用作<code>List</code>因为<a href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Range.html">Range</a>扩展了<a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">java.util。清单</a> 。</p>
</div>
<div class="paragraph">
<p>用定义的范围<code>..</code>表示法包含在内（即列表包含from和to值）。</p>
</div>
<div class="paragraph">
<p>用定义的范围<code>..<</code>表示法是半开的，它们包括第一个值，但不包括最后一个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// an inclusive range
def range = 5..8
assert range.size() == 4
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert range.contains(8)

// lets use a half-open range
range = 5..&lt;8
assert range.size() == 3
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert !range.contains(8)

//get the end points of the range without using indexes
range = 1..10
assert range.from == 1
assert range.to == 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，有效地实现了int范围，创建了一个包含from和to值的轻量级Java对象。</p>
</div>
<div class="paragraph">
<p>范围可用于实现java.lang的任何Java对象。可比较，也有方法<code>next()</code>和<code>previous()</code>返回范围中的下一个/上一个项目。例如，您可以创建一系列<code>String</code>元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// an inclusive range
def range = 'a'..'d'
assert range.size() == 4
assert range.get(2) == 'c'
assert range[2] == 'c'
assert range instanceof java.util.List
assert range.contains('a')
assert range.contains('d')
assert !range.contains('e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用经典迭代范围<code>for</code>环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">for (i in 1..10) {
    println "Hello ${i}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是您也可以通过迭代范围来以更Groovy惯用的风格实现相同的效果<code>each</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">(1..10).each { i -&gt;
    println "Hello ${i}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围也可以用在<code>switch</code>声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">switch (years) {
    case 1..10: interestRate = 0.076; break;
    case 11..25: interestRate = 0.052; break;
    default: interestRate = 0.037;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_enhancements_for_collections"><a class="anchor" href="#_syntax_enhancements_for_collections"></a> 2.4。集合的语法增强</h3>
<div class="sect3">
<h4 id="_gpath_support"><a class="anchor" href="#_gpath_support"></a> 2.4.1。GPath支持</h4>
<div class="paragraph">
<p>由于列表和地图的属性符号均受支持，Groovy提供了语法糖，使得处理嵌套集合非常容易，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22]]
assert listOfMaps.a == [11, 21] //GPath notation
assert listOfMaps*.a == [11, 21] //spread dot notation

listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22], null]
assert listOfMaps*.a == [11, 21, null] // caters for null values
assert listOfMaps*.a == listOfMaps.collect { it?.a } //equivalent notation
// But this will only collect non-null values
assert listOfMaps.a == [11,21]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spread_operator"><a class="anchor" href="#_spread_operator"></a> 2.4.2。点差运算符</h4>
<div class="paragraph">
<p>传播运算符可用于将一个集合“内联”到另一个集合中。它是语法糖，通常避免调用<code>putAll</code>并促进单线的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [ 'z': 900,
         *: ['a': 100, 'b': 200], 'a': 300] == ['a': 300, 'b': 200, 'z': 900]
//spread map notation in map definition
assert [*: [3: 3, *: [5: 5]], 7: 7] == [3: 3, 5: 5, 7: 7]

def f = { [1: 'u', 2: 'v', 3: 'w'] }
assert [*: f(), 10: 'zz'] == [1: 'u', 10: 'zz', 2: 'v', 3: 'w']
//spread map notation in function arguments
f = { map -&gt; map.c }
assert f(*: ['a': 10, 'b': 20, 'c': 30], 'e': 50) == 30

f = { m, i, j, k -&gt; [m, i, j, k] }
//using spread map notation with mixed unnamed and named arguments
assert f('e': 100, *[4, 5], *: ['a': 10, 'b': 20, 'c': 30], 6) ==
        [["e": 100, "b": 20, "c": 30, "a": 10], 4, 5, 6]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Collections-Gettingefficientwiththestar-dotoperator"><a class="anchor" href="#Collections-Gettingefficientwiththestar-dotoperator"></a> 2.4.3。星点“ *”。算子</h4>
<div class="paragraph">
<p>“星点”运算符是一种快捷方式运算符，它允许您在集合的所有元素上调用方法或属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 3, 5] == ['a', 'few', 'words']*.size()

class Person {
    String name
    int age
}
def persons = [new Person(name:'Hugo', age:17), new Person(name:'Sandra',age:19)]
assert [17, 19] == persons*.age</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Collections-Slicingwiththesubscriptoperator"><a class="anchor" href="#Collections-Slicingwiththesubscriptoperator"></a> 2.4.4。下标运算符切片</h4>
<div class="paragraph">
<p>您可以使用下标表达式索引到列表，数组，地图中。有趣的是，在这种情况下，字符串被视为特殊的集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = 'nice cheese gromit!'
def x = text[2]

assert x == 'c'
assert x.class == String

def sub = text[5..10]
assert sub == 'cheese'

def list = [10, 11, 12, 13]
def answer = list[2,3]
assert answer == [12,13]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您可以使用范围来提取集合的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">list = 100..200
sub = list[1, 3, 20..25, 33]
assert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]</code></pre>
</div>
</div>
<div class="paragraph">
<p>下标运算符可用于更新现有集合（对于不可变的集合类型）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">list = ['a','x','x','d']
list[1..2] = ['b','c']
assert list == ['a','b','c','d']</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，允许使用负索引从集合的末尾更轻松地提取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">text = "nice cheese gromit!"
x = text[-1]
assert x == "!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用负索引从列表，数组，字符串等的末尾开始计数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def name = text[-7..-2]
assert name == "gromit"</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终，如果使用向后范围（起始索引大于终止索引），则答案将相反。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">text = "nice cheese gromit!"
name = text[3..1]
assert name == "eci"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Collections-EnhancedCollectionMethods"><a class="anchor" href="#Collections-EnhancedCollectionMethods"></a> 2.5。增强的收集方法</h3>
<div class="paragraph">
<p>除了<a href="#Collections-Lists">列表</a> ， <a href="#Collections-Maps">地图</a>或<a href="#Collections-Ranges">范围外</a> ，Groovy还提供了许多其他过滤，收集，分组，计数等方法，这些方法可以直接在集合上或更容易迭代的对象上使用。</p>
</div>
<div class="paragraph">
<p>特别是，我们邀请您阅读<a href="http://www.groovy-lang.org/gdk.html">Groovy开发套件</a> API文档，尤其是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法添加到<code>Iterable</code>可以在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html">这里</a>找到</p>
</li>
<li>
<p>方法添加到<code>Iterator</code>可以在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Iterator.html">这里</a>找到</p>
</li>
<li>
<p>方法添加到<code>Collection</code>可以在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Collection.html">这里</a>找到</p>
</li>
<li>
<p>方法添加到<code>List</code>可以在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/List.html">这里</a>找到</p>
</li>
<li>
<p>方法添加到<code>Map</code>可以在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html">这里</a>找到</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_legacy_date_calendar_types"><a class="anchor" href="#_working_with_legacy_date_calendar_types"></a> 3。使用旧的日期/日历类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>groovy-dateutil</code>模块支持使用Java经典版本的众多扩展<code>Date</code>和<code>Calendar</code>类。</p>
</div>
<div class="paragraph">
<p>您可以访问<code>Date</code>要么<code>Calendar</code>使用普通数组索引符号和来自<code>Calendar</code>类如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.util.Calendar.*    <i class="conum" data-value="1"></i><b>(1)</b>

def cal = Calendar.instance
cal[YEAR] = 2000                      <i class="conum" data-value="2"></i><b>(2)</b>
cal[MONTH] = JANUARY                  <i class="conum" data-value="2"></i><b>(2)</b>
cal[DAY_OF_MONTH] = 1                 <i class="conum" data-value="2"></i><b>(2)</b>
assert cal[DAY_OF_WEEK] == SATURDAY   <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>导入常量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置日历的年，月和日</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>访问日历的星期几</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy支持算术运算和之间的迭代<code>Date</code>和<code>Calendar</code>实例如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def utc = TimeZone.getTimeZone('UTC')
Date date = Date.parse("yyyy-MM-dd HH:mm", "2010-05-23 09:01", utc)

def prev = date - 1
def next = date + 1

def diffInDays = next - prev
assert diffInDays == 2

int count = 0
prev.upto(next) { count++ }
assert count == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以将字符串解析为日期，然后将日期输出为格式化的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def orig = '2000-01-01'
def newYear = Date.parse('yyyy-MM-dd', orig)
assert newYear[DAY_OF_WEEK] == SATURDAY
assert newYear.format('yyyy-MM-dd') == orig
assert newYear.format('dd/MM/yyyy') == '01/01/2000'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以基于现有的日期或日历创建一个新的日期或日历：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def newYear = Date.parse('yyyy-MM-dd', '2000-01-01')
def newYearsEve = newYear.copyWith(
    year: 1999,
    month: DECEMBER,
    dayOfMonth: 31
)
assert newYearsEve[DAY_OF_WEEK] == FRIDAY</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_date_time_types"><a class="anchor" href="#_working_with_date_time_types"></a> 4。处理日期/时间类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>groovy-datetime</code>模块支持使用Java 8中引入的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html">Date / Time API的</a>众多扩展。本文档将此API定义的数据类型称为“ JSR 310类型”。</p>
</div>
<div class="sect2">
<h3 id="_formatting_and_parsing"><a class="anchor" href="#_formatting_and_parsing"></a> 4.1。格式化和解析</h3>
<div class="paragraph">
<p>使用日期/时间类型的一个常见用例是将它们转换为字符串（格式）和从字符串（解析）。Groovy提供了以下其他格式化方法：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getDateString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDate</code>和<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>DateTimeFormatter.ISO_LOCAL_DATE</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE"><code>DateTimeFormatter.ISO_OFFSET_DATE</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>DateTimeFormatter.ISO_LOCAL_DATE</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getDateTimeString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>DateTimeFormatter.ISO_LOCAL_DATE_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME"><code>DateTimeFormatter.ISO_OFFSET_DATE_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>DateTimeFormatter.ISO_LOCAL_DATE_TIME</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getTimeString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalTime</code>和<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>DateTimeFormatter.ISO_LOCAL_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetTime</code>和<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME"><code>DateTimeFormatter.ISO_OFFSET_TIME</code></a>格式化程序</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>DateTimeFormatter.ISO_LOCAL_TIME</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>format(FormatStyle style)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalTime</code>和<code>OffsetTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedTime(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>4:30 AM</code> （带有样式<code>FormatStyle.SHORT</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDate</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedDate(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Saturday, March 10, 2018</code> （带有样式<code>FormatStyle.FULL</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDateTime</code> ， <code>OffsetDateTime</code>和<code>ZonedDateTime</code>格式与<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedDateTime(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mar 10, 2019 4:30:45 AM</code> （带有样式<code>FormatStyle.MEDIUM</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>format(String pattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">格式与<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-"><code>DateTimeFormatter.ofPattern(pattern)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>03/10/2018</code> （例如，使用模式“ MM / dd / yyyy”）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对于解析，Groovy添加了一个静态<code>parse</code>许多JSR 310类型的方法。该方法有两个参数：要格式化的值和要使用的模式。该模式由<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"><code>java.time.format.DateTimeFormatter</code> API</a> 。举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def date = LocalDate.parse('Jun 3, 04', 'MMM d, yy')
assert date == LocalDate.of(2004, Month.JUNE, 3)

def time = LocalTime.parse('4:45', 'H:mm')
assert time == LocalTime.of(4, 45, 0)

def offsetTime = OffsetTime.parse('09:47:51-1234', 'HH:mm:ssZ')
assert offsetTime == OffsetTime.of(9, 47, 51, 0, ZoneOffset.ofHoursMinutes(-12, -34))

def dateTime = ZonedDateTime.parse('2017/07/11 9:47PM Pacific Standard Time', 'yyyy/MM/dd h:mma zzzz')
assert dateTime == ZonedDateTime.of(
        LocalDate.of(2017, 7, 11),
        LocalTime.of(21, 47, 0),
        ZoneId.of('America/Los_Angeles')
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这些<code>parse</code>方法的参数顺序与静态参数的顺序不同<code>parse</code> Groovy添加到的方法<code>java.util.Date</code> 。这样做是为了与现有<code>parse</code>日期/时间API的方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_manipulating_date_time"><a class="anchor" href="#_manipulating_date_time"></a> 4.2。处理日期/时间</h3>
<div class="sect3">
<h4 id="_addition_and_subtraction"><a class="anchor" href="#_addition_and_subtraction"></a> 4.2.1。加减</h4>
<div class="paragraph">
<p><code>Temporal</code>类型有<code>plus</code>和<code>minus</code>添加或减去提供的方法<code>java.time.temporal.TemporalAmount</code>论点。因为Groovy映射了<code>+</code>和<code>-</code>对于这些名称的单参数方法的运算符，可以使用更自然的表达式语法进行加减。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def nextAprilFools = aprilFools + Period.ofDays(365) // add 365 days
assert nextAprilFools.year == 2019

def idesOfMarch = aprilFools - Period.ofDays(17) // subtract 17 days
assert idesOfMarch.dayOfMonth == 15
assert idesOfMarch.month == Month.MARCH</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy提供了其他功能<code>plus</code>和<code>minus</code>接受整数参数的方法，使以上内容可以更简洁地重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nextAprilFools = aprilFools + 365 // add 365 days
def idesOfMarch = aprilFools - 17 // subtract 17 days</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些整数的单位取决于JSR 310类型的操作数。如上所示，用于<code>ChronoLocalDate</code>像<code>LocalDate</code>有一个<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYShttp://days">天</a>的单位。用于的整数<code>Year</code>和<code>YearMonth</code>分别以<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#YEARS">年</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS">月</a>为单位。所有其他类型的单位均为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS">秒</a> ，例如<code>LocalTime</code> ， 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def mars = LocalTime.of(12, 34, 56) // 12:34:56 pm

def thirtySecondsToMars = mars - 30 // go back 30 seconds
assert thirtySecondsToMars.second == 26</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiplication_and_division"><a class="anchor" href="#_multiplication_and_division"></a> 4.2.2。乘法与除法</h4>
<div class="paragraph">
<p>的<code>*</code>运算符可用于相乘<code>Period</code>和<code>Duration</code>实例以整数值表示；的<code>/</code>运算符可用于除法<code>Duration</code>实例以整数值表示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def period = Period.ofMonths(1) * 2 // a 1-month period times 2
assert period.months == 2

def duration = Duration.ofSeconds(10) / 5// a 10-second duration divided by 5
assert duration.seconds == 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_incrementing_and_decrementing"><a class="anchor" href="#_incrementing_and_decrementing"></a> 4.2.3。递增和递减</h4>
<div class="paragraph">
<p>的<code>++</code>和<code>--</code>运算符可用于将日期/时间值递增和递减一个单位。由于JSR 310类型是不可变的，因此该操作将创建一个具有递增/递减值的新实例，并将其重新分配给引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def year = Year.of(2000)
--year // decrement by one year
assert year.value == 1999

def offsetTime = OffsetTime.of(0, 0, 0, 0, ZoneOffset.UTC) // 00:00:00.000 UTC
offsetTime++ // increment by one second
assert offsetTime.second == 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_negation"><a class="anchor" href="#_negation"></a> 4.2.4。否定</h4>
<div class="paragraph">
<p>的<code>Duration</code>和<code>Period</code>类型代表时间的正负。这些可以与一元否定<code>-</code>操作员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def duration = Duration.ofSeconds(-15)
def negated = -duration
assert negated.seconds == 15</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interacting_with_date_time_values"><a class="anchor" href="#_interacting_with_date_time_values"></a> 4.3。与日期/时间值交互</h3>
<div class="sect3">
<h4 id="_property_notation"><a class="anchor" href="#_property_notation"></a> 4.3.1。属性符号</h4>
<div class="paragraph">
<p>的<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong-java.time.temporal.TemporalField-"><code>getLong(TemporalField)</code></a>的方法<code>TemporalAccessor</code>类型（例如<code>LocalDate</code> ， <code>LocalTime</code> ， <code>ZonedDateTime</code>等）和<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get-java.time.temporal.TemporalUnit-"><code>get(TemporalUnit)</code></a>的方法<code>TemporalAmount</code>类型（即<code>Period</code>和<code>Duration</code> ），可以用Groovy的属性符号来调用。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def date = LocalDate.of(2018, Month.MARCH, 12)
assert date[ChronoField.YEAR] == 2018
assert date[ChronoField.MONTH_OF_YEAR] == Month.MARCH.value
assert date[ChronoField.DAY_OF_MONTH] == 12
assert date[ChronoField.DAY_OF_WEEK] == DayOfWeek.MONDAY.value

def period = Period.ofYears(2).withMonths(4).withDays(6)
assert period[ChronoUnit.YEARS] == 2
assert period[ChronoUnit.MONTHS] == 4
assert period[ChronoUnit.DAYS] == 6</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ranges_code_upto_code_and_code_downto_code"><a class="anchor" href="#_ranges_code_upto_code_and_code_downto_code"></a> 4.3.2。范围<code>upto</code>和<code>downto</code></h4>
<div class="paragraph">
<p>JSR 310类型可以与<a href="core-operators.html#_range_operator">范围运算符</a>一起使用。以下示例在今天与<code>LocalDate</code>从现在开始六天，打印出每个迭代的星期几。由于这两个范围都包含在内，因此将打印一周的所有七天。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
(start..end).each { date -&gt;
    println date.dayOfWeek
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>upto</code>方法将完成与上面示例中的范围相同的操作。的<code>upto</code>方法从早期迭代<code>start</code>以后的价值（含） <code>end</code>值（也包括在内），以增量形式调用闭包<code>next</code>每次迭代一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
start.upto(end) { next -&gt;
    println next.dayOfWeek
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>downto</code>从后面的方法向相反的方向迭代<code>start</code>较早的价值<code>end</code>值。</p>
</div>
<div class="paragraph">
<p>的迭代单位<code>upto</code> ， <code>downto</code> ，范围与加减法的单位相同： <code>LocalDate</code>一次迭代一天， <code>YearMonth</code>迭代一个月， <code>Year</code>一年，其他一切都减少一秒钟。两种方法都支持可选的<code>TemporalUnit</code>更改迭代单位的参数。</p>
</div>
<div class="paragraph">
<p>考虑以下示例，其中使用<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS">个月</a>的迭代单位将2018年3月1日迭代到2018年3月2日。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.of(2018, Month.MARCH, 1)
def end = start + 1 // 1 day later

int iterationCount = 0
start.upto(end, ChronoUnit.MONTHS) { next -&gt;
    println next
    ++iterationCount
}

assert iterationCount == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>自从<code>start</code>日期是包容性的，闭包用<code>next</code>日期值为3月1日。的<code>upto</code>然后将日期增加一个月，得出日期为4月1日。因为此日期<em>晚</em>于指定的日期<code>end</code>从3月2日开始，迭代只停止了一次，立即停止。这种行为对于<code>downto</code>方法，除了迭代将在<code>next</code>变得比目标更早<code>end</code>日期。</p>
</div>
<div class="paragraph">
<p>简而言之，当与<code>upto</code>要么<code>downto</code>使用自定义迭代单位的方法，当前迭代值将永远不会超过最终值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_combining_date_time_values"><a class="anchor" href="#_combining_date_time_values"></a> 4.3.3。合并日期/时间值</h4>
<div class="paragraph">
<p>左移运算符（ <code><<</code> ）可用于将两种JSR 310类型组合为一个聚合类型。例如，一个<code>LocalDate</code>可以左移到<code>LocalTime</code>生产复合材料<code>LocalDateTime</code>实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">MonthDay monthDay = Month.JUNE &lt;&lt; 3 // June 3rd
LocalDate date = monthDay &lt;&lt; Year.of(2015) // 3-Jun-2015
LocalDateTime dateTime = date &lt;&lt; LocalTime.NOON // 3-Jun-2015 @ 12pm
OffsetDateTime offsetDateTime = dateTime &lt;&lt; ZoneOffset.ofHours(-5) // 3-Jun-2015 @ 12pm UTC-5</code></pre>
</div>
</div>
<div class="paragraph">
<p>左移运算符是反身的；反之亦然。操作数的顺序无关紧要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def year = Year.of(2000)
def month = Month.DECEMBER

YearMonth a = year &lt;&lt; month
YearMonth b = month &lt;&lt; year
assert a == b</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creating_periods_and_durations"><a class="anchor" href="#_creating_periods_and_durations"></a> 4.3.4。创建期间和持续时间</h4>
<div class="paragraph">
<p>右移运算符（ <code>>></code> ）产生代表操作数之间周期或持续时间的值。对于<code>ChronoLocalDate</code> ， <code>YearMonth</code>和<code>Year</code> ，运算符产生一个<code>Period</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def newYears = LocalDate.of(2018, Month.JANUARY, 1)
def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def period = newYears &gt;&gt; aprilFools
assert period instanceof Period
assert period.months == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>操作员产生一个<code>Duration</code>对于具有时间意识的JSR类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def duration = LocalTime.NOON &gt;&gt; (LocalTime.NOON + 30)
assert duration instanceof Duration
assert duration.seconds == 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果运算符左侧的值早于右侧的值，则结果为正。如果左侧晚于右侧，则结果为负：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def decade = Year.of(2010) &gt;&gt; Year.of(2000)
assert decade.years == -10</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_converting_between_legacy_and_jsr_310_types"><a class="anchor" href="#_converting_between_legacy_and_jsr_310_types"></a> 4.4。在旧版和JSR 310类型之间转换</h3>
<div class="paragraph">
<p>尽管有缺点<code>Date</code> ， <code>Calendar</code>和<code>TimeZone</code>输入<code>java.util</code>包，它们在Java API（至少在Java 8之前的版本）中很常见。为了适应此类API的使用，Groovy提供了在JSR 310类型和旧式类型之间进行转换的方法。</p>
</div>
<div class="paragraph">
<p>大多数JSR类型都已配备<code>toDate()</code>和<code>toCalendar()</code>转换为相对等价的方法<code>java.util.Date</code>和<code>java.util.Calendar</code>价值观。都<code>ZoneId</code>和<code>ZoneOffset</code>已经给了<code>toTimeZone()</code>转换成<code>java.util.TimeZone</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// LocalDate to java.util.Date
def valentines = LocalDate.of(2018, Month.FEBRUARY, 14)
assert valentines.toDate().format('MMMM dd, yyyy') == 'February 14, 2018'

// LocalTime to java.util.Date
def noon = LocalTime.of(12, 0, 0)
assert noon.toDate().format('HH:mm:ss') == '12:00:00'

// ZoneId to java.util.TimeZone
def newYork = ZoneId.of('America/New_York')
assert newYork.toTimeZone() == TimeZone.getTimeZone('America/New_York')

// ZonedDateTime to java.util.Calendar
def valAtNoonInNY = ZonedDateTime.of(valentines, noon, newYork)
assert valAtNoonInNY.toCalendar().getTimeZone().toZoneId() == newYork</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，转换为旧式时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纳秒级的值被截断为毫秒。一种<code>LocalTime</code> ，例如<code>ChronoUnit.NANOS</code>值999,999,999纳秒转换为999毫秒。</p>
</li>
<li>
<p>转换“本地”类型时（ <code>LocalDate</code> ， <code>LocalTime</code>和<code>LocalDateTime</code> ），返回的时区<code>Date</code>要么<code>Calendar</code>将是系统默认值。</p>
</li>
<li>
<p>转换仅时间类型时（ <code>LocalTime</code>要么<code>OffsetTime</code> ），则是<code>Date</code>要么<code>Calendar</code>设置为当前日期。</p>
</li>
<li>
<p>转换仅日期类型时（ <code>LocalDate</code> ），时间值<code>Date</code>要么<code>Calendar</code>将被清除，即<code>00:00:00.000</code> 。</p>
</li>
<li>
<p>转换时<code>OffsetDateTime</code>到一个<code>Calendar</code> ，只有小时和分钟<code>ZoneOffset</code>传达到相应的<code>TimeZone</code> 。幸运的是，具有非零秒的区域偏移很少见。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy在其中添加了许多方法<code>Date</code>和<code>Calendar</code>用于转换为各种JSR 310类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Date legacy = Date.parse('yyyy-MM-dd HH:mm:ss.SSS', '2010-04-03 10:30:58.999')

assert legacy.toLocalDate() == LocalDate.of(2010, 4, 3)
assert legacy.toLocalTime() == LocalTime.of(10, 30, 58, 999_000_000) // 999M ns = 999ms
assert legacy.toOffsetTime().hour == 10
assert legacy.toYear() == Year.of(2010)
assert legacy.toMonth() == Month.APRIL
assert legacy.toDayOfWeek() == DayOfWeek.SATURDAY
assert legacy.toMonthDay() == MonthDay.of(Month.APRIL, 3)
assert legacy.toYearMonth() == YearMonth.of(2010, Month.APRIL)
assert legacy.toLocalDateTime().year == 2010
assert legacy.toOffsetDateTime().dayOfMonth == 3
assert legacy.toZonedDateTime().zone == ZoneId.systemDefault()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handy_utilities"><a class="anchor" href="#_handy_utilities"></a> 5，方便的实用程序</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_configslurper"><a class="anchor" href="#_configslurper"></a> 5.1。ConfigSlurper</h3>
<div class="paragraph">
<p><code>ConfigSlurper</code>是一个实用程序类，用于读取以Groovy脚本形式定义的配置文件。就像Java一样<code>*.properties</code>文件， <code>ConfigSlurper</code>允许点符号。但除此之外，它还允许Closure作用域配置值和任意对象类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new ConfigSlurper().parse('''
    app.date = new Date()  <i class="conum" data-value="1"></i><b>(1)</b>
    app.age  = 42
    app {                  <i class="conum" data-value="2"></i><b>(2)</b>
        name = "Test${42}"
    }
''')

assert config.app.date instanceof Date
assert config.app.age == 42
assert config.app.name == 'Test42'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>点符号的用法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用闭包范围代替点表示法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如上例所示， <code>parse</code>方法可用于检索<code>groovy.util.ConfigObject</code>实例。的<code>ConfigObject</code>是专业的<code>java.util.Map</code>返回配置值或新值的实现<code>ConfigObject</code>实例但从来没有<code>null</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app.name = "Test${42}"
''')

assert config.test != null   <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>config.test</code>尚未指定，但会传回<code>ConfigObject</code>被调用时。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果点是配置变量名称的一部分，则可以使用单引号或双引号将其转义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new ConfigSlurper().parse('''
    app."person.age"  = 42
''')

assert config.app."person.age" == 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外， <code>ConfigSlurper</code>附带对<code>environments</code> 。的<code>environments</code>方法可以用于移交本身可能由几个部分组成的Closure实例。假设我们要为开发环境创建一个特定的配置值。创建时<code>ConfigSlurper</code>实例，我们可以使用<code>ConfigSlurper(String)</code>构造函数以指定目标环境。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new ConfigSlurper('development').parse('''
  environments {
       development {
           app.port = 8080
       }

       test {
           app.port = 8082
       }

       production {
           app.port = 80
       }
  }
''')

assert config.app.port == 8080</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>ConfigSlurper</code>环境不限于任何特定的环境名称。它完全取决于<code>ConfigSlurper</code>客户端代码支持并相应解释什么值。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>environments</code>方法是内置的，但是<code>registerConditionalBlock</code>方法可以用来注册除<code>environments</code>名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def slurper = new ConfigSlurper()
slurper.registerConditionalBlock('myProject', 'developers')   <i class="conum" data-value="1"></i><b>(1)</b>

def config = slurper.parse('''
  sendMail = true

  myProject {
       developers {
           sendMail = false
       }
  }
''')

assert !config.sendMail</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一旦注册了新块<code>ConfigSlurper</code>可以解析它。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了实现Java集成， <code>toProperties</code>方法可以用来转换<code>ConfigObject</code>到一个<code>java.util.Properties</code>可能存储到一个对象<code>*.properties</code>文本文件。请注意，尽管配置值已转换为<code>String</code>实例添加到新创建的实例<code>Properties</code>实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app {
        name = "Test${42}"
    }
''')

def properties = config.toProperties()

assert properties."app.date" instanceof String
assert properties."app.age" == '42'
assert properties."app.name" == 'Test42'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expando"><a class="anchor" href="#_expando"></a> 5.2。Expando</h3>
<div class="paragraph">
<p>的<code>Expando</code>类可用于创建可动态扩展的对象。尽管其名称不使用<code>ExpandoMetaClass</code>下。每<code>Expando</code> object表示一个独立的，动态制作的实例，可以在运行时使用属性（或方法）对其进行扩展。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def expando = new Expando()
expando.name = 'John'

assert expando.name == 'John'</code></pre>
</div>
</div>
<div class="paragraph">
<p>当动态属性注册一个特殊情况时， <code>Closure</code>代码块。一旦注册，就可以像调用方法一样调用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def expando = new Expando()
expando.toString = { -&gt; 'John' }
expando.say = { String s -&gt; "John says: ${s}" }

assert expando as String == 'John'
assert expando.say('Hi') == 'John says: Hi'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_observable_list_map_and_set"><a class="anchor" href="#_observable_list_map_and_set"></a> 5.3。可观察的列表，地图和集合</h3>
<div class="paragraph">
<p>Groovy带有可观察的列表，地图和集合。这些集合中的每一个都会触发<code>java.beans.PropertyChangeEvent</code>添加，删除或更改元素时发生的事件。请注意<code>PropertyChangeEvent</code>不仅表示已发生某个事件，而且还包含有关属性名称和某个属性已更改为的旧/新值的信息。</p>
</div>
<div class="paragraph">
<p>根据发生的更改的类型，可观察的集合可能会触发更专业的操作<code>PropertyChangeEvent</code>类型。例如，将元素添加到可观察列表会触发<code>ObservableList.ElementAddedEvent</code>事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def event                                       <i class="conum" data-value="1"></i><b>(1)</b>
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {  <i class="conum" data-value="2"></i><b>(2)</b>
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList    <i class="conum" data-value="3"></i><b>(3)</b>
observable.addPropertyChangeListener(listener)  <i class="conum" data-value="4"></i><b>(4)</b>

observable.add 42                               <i class="conum" data-value="5"></i><b>(5)</b>

assert event instanceof ObservableList.ElementAddedEvent

def elementAddedEvent = event as ObservableList.ElementAddedEvent
assert elementAddedEvent.changeType == ObservableList.ChangeType.ADDED
assert elementAddedEvent.index == 3
assert elementAddedEvent.oldValue == null
assert elementAddedEvent.newValue == 42</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个<code>PropertyChangeEventListener</code>正在捕获触发的事件</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>ObservableList.ElementEvent</code>及其后代类型与此侦听器有关</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>注册监听器</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>创建一个<code>ObservableList</code>从给定的列表</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>触发<code>ObservableList.ElementAddedEvent</code>事件</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，实际上添加一个元素会导致触发两个事件。第一个是类型<code>ObservableList.ElementAddedEvent</code> ，第二个是平原<code>PropertyChangeEvent</code>告知听众财产的变化<code>size</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>ObservableList.ElementClearedEvent</code>事件类型是另一个有趣的类型。每当删除多个元素时，例如在调用时<code>clear()</code> ，它包含从列表中删除的元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def event
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList
observable.addPropertyChangeListener(listener)

observable.clear()

assert event instanceof ObservableList.ElementClearedEvent

def elementClearedEvent = event as ObservableList.ElementClearedEvent
assert elementClearedEvent.values == [1, 2, 3]
assert observable.size() == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了大致了解所有受支持的事件类型，建议读者阅读JavaDoc文档或所使用的可观察集合的源代码。</p>
</div>
<div class="paragraph">
<p><code>ObservableMap</code>和<code>ObservableSet</code>带有与我们所见相同的概念<code>ObservableList</code>在这个部分。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:03 AEST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>