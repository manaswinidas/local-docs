<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>面向对象</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>面向对象</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_types">1。种类</a>
<ul class="sectlevel2">
<li><a href="#_primitive_types">1.1。原始类型</a></li>
<li><a href="#_class">1.2。类</a>
<ul class="sectlevel3">
<li><a href="#_normal_class">1.2.1。普通班</a></li>
<li><a href="#_inner_class">1.2.2。内部阶层</a>
<ul class="sectlevel4">
<li><a href="#_anonymous_inner_class">匿名内部阶级</a></li>
</ul>
</li>
<li><a href="#_abstract_class">1.2.3。抽象类</a></li>
</ul>
</li>
<li><a href="#_interface">1.3。接口</a></li>
<li><a href="#_constructors">1.4。建设者</a>
<ul class="sectlevel3">
<li><a href="#_positional_parameters">1.4.1。位置参数</a></li>
<li><a href="#_named_parameters">1.4.2。命名参数</a></li>
</ul>
</li>
<li><a href="#_methods">1.5。方法</a>
<ul class="sectlevel3">
<li><a href="#_method_definition">1.5.1。方法定义</a></li>
<li><a href="#_named_parameters_2">1.5.2。命名参数</a>
<ul class="sectlevel4">
<li><a href="#_mixing_named_and_positional_parameters">混合命名和位置参数</a></li>
</ul>
</li>
<li><a href="#_default_arguments">1.5.3。默认参数</a></li>
<li><a href="#_varargs">1.5.4。瓦拉格斯</a></li>
<li><a href="#_method_selection_algorithm">1.5.5。方法选择算法</a></li>
<li><a href="#_exception_declaration">1.5.6。异常声明</a></li>
</ul>
</li>
<li><a href="#_fields_and_properties">1.6。字段和属性</a>
<ul class="sectlevel3">
<li><a href="#fields">1.6.1。领域</a></li>
<li><a href="#properties">1.6.2。性质</a></li>
</ul>
</li>
<li><a href="#_annotation">1.7。注解</a>
<ul class="sectlevel3">
<li><a href="#ann-definition">1.7.1。注释定义</a></li>
<li><a href="#ann-placement">1.7.2。注解位置</a></li>
<li><a href="#_annotation_member_values">1.7.3。注释成员值</a></li>
<li><a href="#_retention_policy">1.7.4。保留政策</a></li>
<li><a href="#_closure_annotation_parameters">1.7.5。闭包注释参数</a></li>
<li><a href="#_meta_annotations">1.7.6。元注释</a>
<ul class="sectlevel4">
<li><a href="#_declaring_meta_annotations">声明元注释</a></li>
<li><a href="#meta-ann-behavior">元注释的行为</a></li>
<li><a href="#meta-ann-members">元注释参数</a></li>
<li><a href="#handling_duplicate_annotations">处理重复的注释</a></li>
<li><a href="#meta-ann-processor">自定义注释处理器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_inheritance">1.8。遗产</a></li>
<li><a href="#generics">1.9。泛型</a></li>
</ul>
</li>
<li><a href="#_traits">2。特质</a>
<ul class="sectlevel2">
<li><a href="#_methods_2">2.1。方法</a>
<ul class="sectlevel3">
<li><a href="#_public_methods">2.1.1。公开方法</a></li>
<li><a href="#_abstract_methods">2.1.2。抽象方法</a></li>
<li><a href="#_private_methods">2.1.3。私人方法</a></li>
<li><a href="#_final_methods">2.1.4。最终方法</a></li>
</ul>
</li>
<li><a href="#_the_meaning_of_this">2.2。这个的意思</a></li>
<li><a href="#_interfaces">2.3。介面</a></li>
<li><a href="#_properties">2.4。性质</a></li>
<li><a href="#_fields">2.5。领域</a>
<ul class="sectlevel3">
<li><a href="#_private_fields">2.5.1。私人领域</a></li>
<li><a href="#_public_fields">2.5.2。公共领域</a></li>
</ul>
</li>
<li><a href="#_composition_of_behaviors">2.6。行为组成</a></li>
<li><a href="#_overriding_default_methods">2.7。覆盖默认方法</a></li>
<li><a href="#_extending_traits">2.8。扩展特征</a>
<ul class="sectlevel3">
<li><a href="#_simple_inheritance">2.8.1。简单继承</a></li>
<li><a href="#_multiple_inheritance">2.8.2。多重继承</a></li>
</ul>
</li>
<li><a href="#_duck_typing_and_traits">2.9。鸭的打字和特征</a>
<ul class="sectlevel3">
<li><a href="#_dynamic_code">2.9.1。动态代码</a></li>
<li><a href="#_dynamic_methods_in_a_trait">2.9.2。特征中的动态方法</a></li>
</ul>
</li>
<li><a href="#_multiple_inheritance_conflicts">2.10。多重继承冲突</a>
<ul class="sectlevel3">
<li><a href="#_default_conflict_resolution">2.10.1。默认冲突解决</a></li>
<li><a href="#_user_conflict_resolution">2.10.2。解决用户冲突</a></li>
</ul>
</li>
<li><a href="#_runtime_implementation_of_traits">2.11。特征的运行时实现</a>
<ul class="sectlevel3">
<li><a href="#_implementing_a_trait_at_runtime">2.11.1。在运行时实现特征</a></li>
<li><a href="#_implementing_multiple_traits_at_once">2.11.2。一次实现多个特征</a></li>
</ul>
</li>
<li><a href="#_chaining_behavior">2.12。链接行为</a>
<ul class="sectlevel3">
<li><a href="#_semantics_of_super_inside_a_trait">2.12.1。特征特质的超语义</a></li>
</ul>
</li>
<li><a href="#_advanced_features">2.13。高级功能</a>
<ul class="sectlevel3">
<li><a href="#_sam_type_coercion">2.13.1。SAM型强制</a></li>
<li><a href="#_differences_with_java_8_default_methods">2.13.2。Java 8默认方法的差异</a></li>
</ul>
</li>
<li><a href="#_differences_with_mixins">2.14。mixins的差异</a></li>
<li><a href="#_static_methods_properties_and_fields">2.15。静态方法，属性和字段</a></li>
<li><a href="#_inheritance_of_state_gotchas">2.16。状态陷阱的继承</a></li>
<li><a href="#_self_types">2.17。自我类型</a>
<ul class="sectlevel3">
<li><a href="#_type_constraints_on_traits">2.17.1。特征的类型约束</a></li>
<li><a href="#traits-selftype">2.17.2。@SelfType批注</a></li>
</ul>
</li>
<li><a href="#_limitations">2.18。局限性</a>
<ul class="sectlevel3">
<li><a href="#_compatibility_with_ast_transformations">2.18.1。与AST转换的兼容性</a></li>
<li><a href="#_prefix_and_postfix_operations">2.18.2。前缀和后缀操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Groovy编程语言的面向对象。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types"><a class="anchor" href="#_types"></a> 1。种类</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_primitive_types"><a class="anchor" href="#_primitive_types"></a> 1.1。原始类型</h3>
<div class="paragraph">
<p>Groovy支持与<a href="http://docs.oracle.com/javase/specs/jls/se8/html/">Java语言规范</a>定义的原始类型相同的原始类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整数类型： <code>byte</code> （8位）， <code>short</code> （16位）， <code>int</code> （32位）和<code>long</code> （64位）</p>
</li>
<li>
<p>浮点类型： <code>float</code> （32位）和<code>double</code> （64位）</p>
</li>
<li>
<p><code>boolean</code>类型（恰好<code>true</code>要么<code>false</code> ）</p>
</li>
<li>
<p><code>char</code>类型（16位，可用作数字类型，表示UTF-16代码）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy将原始字段和变量声明并存储为原始数据时，由于它对所有内容都使用对象，因此会自动包装对原始数据的引用。就像Java一样，它使用的包装是</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表1.基本包装器</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">原始类型</th>
<th class="tableblock halign-left valign-top">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">烧焦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这是一个使用示例<code>int</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
  static int i
}

assert Foo.class.getDeclaredField('i').type == int.class
assert Foo.i.class != int.class &amp;&amp; Foo.i.class == Integer.class</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您可能会担心，这意味着每次您对原始图元使用数学运算符时，都会产生将原始图元拆箱和重新装箱的费用。但是事实并非如此，因为Groovy会将您的运算符编译为<a href="core-operators.html#_operator-overloading">等效</a>的<a href="core-operators.html#_operator-overloading">方法，</a>并改用<a href="core-operators.html#_operator-overloading">等效</a>的<a href="core-operators.html#_operator-overloading">方法</a> 。此外，当调用采用基本参数的Java方法并自动将基本方法的返回值从Java装箱时，Groovy将自动取消对基本的装箱。但是，请注意，与Java的方法解析有所<a href="core-differences-java.html#_primitives_and_wrappers">不同</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_class"><a class="anchor" href="#_class"></a> 1.2。类</h3>
<div class="paragraph">
<p>Groovy类与Java类非常相似，并且在JVM级别与Java类兼容。它们可能具有方法，字段和属性（以JavaBean属性为例，但样板较少）。类和类成员可以具有与Java中相同的修饰符（公共的，受保护的，私有的，静态的等），但在源代码级别上有一些细微的差异，稍后将对此进行说明。</p>
</div>
<div class="paragraph">
<p>Groovy类及其对应的Java类之间的主要区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有可见性修饰符的类或方法会自动公开（可以使用特殊注释来实现程序包私有可见性）。</p>
</li>
<li>
<p>由于不需要显式的getter和setter方法，没有可见性修饰符的字段会自动变成属性，从而减少了冗长的代码。关于这方面的更多内容将在“ <a href="#fields">字段和属性”部分中介绍</a> 。</p>
</li>
<li>
<p>类不需要与它们的源文件定义具有相同的基本名称，但是在大多数情况下，强烈建议使用它们（请参见有关脚本的下一点）。</p>
</li>
<li>
<p>一个源文件可能包含一个或多个类（但是，如果文件包含不在类中的任何代码，则将其视为脚本）。脚本只是具有某些特殊约定的类，并且将具有与其源文件相同的名称（因此，请勿在脚本中包含与脚本源文件同名的类定义）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码提供了一个示例类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {                       <i class="conum" data-value="1"></i><b>(1)</b>

    String name                      <i class="conum" data-value="2"></i><b>(2)</b>
    Integer age

    def increaseAge(Integer years) { <i class="conum" data-value="3"></i><b>(3)</b>
        this.age += years
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>以名字开头的类<code>Person</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>字符串字段和命名的属性<code>name</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>方法定义</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_normal_class"><a class="anchor" href="#_normal_class"></a> 1.2.1。普通班</h4>
<div class="paragraph">
<p>普通类是指顶级和具体的类。这意味着可以实例化它们，而不受任何其他类或脚本的限制。这样，它们只能是公开的（即使<code>public</code>关键字可能会被删除）。通过使用类调用其构造函数来实例化类<code>new</code>关键字，如以下代码段所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inner_class"><a class="anchor" href="#_inner_class"></a> 1.2.2。内部阶层</h4>
<div class="paragraph">
<p>内部类在另一个类中定义。封闭类可以照常使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的也是如此。除封闭类之外的其他类均不允许访问内部类。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer {
    private String privateStr

    def callInnerMethod() {
        new Inner().methodA()       <i class="conum" data-value="1"></i><b>(1)</b>
    }

    class Inner {                   <i class="conum" data-value="2"></i><b>(2)</b>
        def methodA() {
            println "${privateStr}." <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>内部类被实例化，其方法被调用</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>内部类定义，在其封闭类内部</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>即使是私有的，内部类也可以访问封闭类的字段</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用内部类有一些原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它们通过将内部类对其他类隐藏而增加了封装，而其他类则无需了解。这也导致包装和工作空间更整洁。</p>
</li>
<li>
<p>通过对仅一个类使用的类进行分组，它们提供了良好的组织。</p>
</li>
<li>
<p>它们导致更易于维护的代码，因为内部类靠近使用它们的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在某些情况下，内部类是接口的实现，这些接口的方法是外部类所需要的。下面的代码通过非常常见的线程用法说明了这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer2 {
    private String privateStr = 'some string'

    def startThread() {
       new Thread(new Inner2()).start()
    }

    class Inner2 implements Runnable {
        void run() {
            println "${privateStr}."
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意该类<code>Inner2</code>仅定义为提供方法的实现<code>run</code>上课<code>Outer2</code> 。在这种情况下，匿名内部类有助于消除冗长性。</p>
</div>
<div class="sect4">
<h5 id="_anonymous_inner_class"><a class="anchor" href="#_anonymous_inner_class"></a>匿名内部阶级</h5>
<div class="paragraph">
<p>内部类的最后一个示例可以使用匿名内部类简化。使用以下代码可以实现相同的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer3 {
    private String privateStr = 'some string'

    def startThread() {
        new Thread(new Runnable() {      <i class="conum" data-value="1"></i><b>(1)</b>
            void run() {
                println "${privateStr}."
            }
        }).start()                       <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>与上一节的最后一个示例相比， <code>new Inner2()</code>被替换为<code>new Runnable()</code>及其所有实施</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>方法<code>start</code>正常调用</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，不需要定义一个新类仅使用一次。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_abstract_class"><a class="anchor" href="#_abstract_class"></a> 1.2.3。抽象类</h4>
<div class="paragraph">
<p>抽象类代表通用概念，因此，它们无法实例化，无法创建为子类。其成员包括字段/属性以及抽象或具体方法。抽象方法没有实现，必须由具体的子类实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Abstract {         <i class="conum" data-value="1"></i><b>(1)</b>
    String name

    abstract def abstractMethod() <i class="conum" data-value="2"></i><b>(2)</b>

    def concreteMethod() {
        println 'concrete'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>抽象类必须用<code>abstract</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>抽象方法也必须声明为<code>abstract</code>关键词</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常将抽象类与接口进行比较。但是选择一个或另一个至少有两个重要的区别。首先，虽然抽象类可能包含字段/属性和具体方法，但接口可能仅包含抽象方法（方法签名）。而且，一个类可以实现多个接口，而它只能扩展一个类（无论是否抽象）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface"><a class="anchor" href="#_interface"></a> 1.3。接口</h3>
<div class="paragraph">
<p>接口定义了类需要遵循的协定。接口仅定义需要实现的方法列表，而没有定义方法的实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {                                         <i class="conum" data-value="1"></i><b>(1)</b>
    void greet(String name)                                 <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>接口需要使用<code>interface</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>接口仅定义方法签名</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接口的方法始终是<strong>公共的</strong> 。使用是错误的<code>protected</code>要么<code>private</code>接口中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {
    protected void greet(String name)           <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>protected</code>是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果类在其类中定义了接口，则它将<em>实现</em>一个接口<code>implements</code>列表或其任何超类是否：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SystemGreeter implements Greeter {                    <i class="conum" data-value="1"></i><b>(1)</b>
    void greet(String name) {                               <i class="conum" data-value="2"></i><b>(2)</b>
        println "Hello $name"
    }
}

def greeter = new SystemGreeter()
assert greeter instanceof Greeter                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>SystemGreeter</code>宣布<code>Greeter</code>界面使用<code>implements</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后实施所需<code>greet</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的任何实例<code>SystemGreeter</code>也是<code>Greeter</code>接口</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个接口可以扩展另一个接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface ExtendedGreeter extends Greeter {                 <i class="conum" data-value="1"></i><b>(1)</b>
    void sayBye(String name)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>ExtendedGreeter</code>接口扩展了<code>Greeter</code>界面使用<code>extends</code>关键词</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得注意的是，要使一个类成为接口的实例，必须明确。例如，以下类定义了<code>greet</code>在中声明的方法<code>Greeter</code>接口，但不声明<code>Greeter</code>在其界面中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultGreeter {
    void greet(String name) { println "Hello" }
}

greeter = new DefaultGreeter()
assert !(greeter instanceof Greeter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，Groovy没有定义结构类型。但是，可以使用运行时对象的实例在运行时实现接口。 <code>as</code>强制运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = new DefaultGreeter()                              <i class="conum" data-value="1"></i><b>(1)</b>
coerced = greeter as Greeter                                <i class="conum" data-value="2"></i><b>(2)</b>
assert coerced instanceof Greeter                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个实例<code>DefaultGreeter</code>没有实现接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将实例强制<code>Greeter</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>强制实例实现<code>Greeter</code>接口</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您会看到有两个不同的对象：一个是源对象，一个是<code>DefaultGreeter</code>实例，它没有实现该接口。另一个是<code>Greeter</code>委托给强制对象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Groovy接口不支持Java 8接口之类的默认实现。如果您正在寻找类似（但不相等）的东西， <a href="#_traits">特征就很</a>接近接口，但是允许默认实现以及本手册中描述的其他重要功能。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_constructors"><a class="anchor" href="#_constructors"></a> 1.4。建设者</h3>
<div class="paragraph">
<p>构造函数是用于初始化具有特定状态的对象的特殊方法。与普通方法一样，一个类可以声明多个构造函数，只要每个构造函数具有唯一的类型签名即可。如果对象在构造过程中不需要任何参数，则可以使用<em>no-arg</em>构造函数。如果没有提供构造函数，那么Groovy编译器将提供一个空的无参数构造函数。</p>
</div>
<div class="paragraph">
<p>Groovy支持两种调用样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>使用位置参数的</em>方式类似于使用Java构造函数的方式</p>
</li>
<li>
<p><em>命名参数</em>允许您在调用构造函数时指定参数名称。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_positional_parameters"><a class="anchor" href="#_positional_parameters"></a> 1.4.1。位置参数</h4>
<div class="paragraph">
<p>要使用位置参数创建对象，相应的类需要声明一个或多个构造函数。对于多个构造函数，每个构造函数必须具有唯一的类型签名。构造函数也可以使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/TupleConstructor.html">groovy.transform添加到类中</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/TupleConstructor.html">。TupleConstructor</a>批注。</p>
</div>
<div class="paragraph">
<p>通常，一旦声明了至少一个构造函数，则只能通过调用其构造函数之一来实例化该类。值得注意的是，在这种情况下，您通常无法使用命名参数创建类。Groovy确实支持命名参数，只要该类包含一个无参数的构造函数或提供一个采用<code>Map</code>参数作为第一个（也是唯一可能的）参数-有关详细信息，请参见下一部分。</p>
</div>
<div class="paragraph">
<p>使用声明的构造函数有三种形式。第一种是普通的Java方式， <code>new</code>关键词。其他依赖于将列表强制转换成所需的类型。在这种情况下，可以强制<code>as</code>关键字并通过静态键入变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PersonConstructor {
    String name
    Integer age

    PersonConstructor(name, age) {          <i class="conum" data-value="1"></i><b>(1)</b>
        this.name = name
        this.age = age
    }
}

def person1 = new PersonConstructor('Marie', 1)  <i class="conum" data-value="2"></i><b>(2)</b>
def person2 = ['Marie', 2] as PersonConstructor  <i class="conum" data-value="3"></i><b>(3)</b>
PersonConstructor person3 = ['Marie', 3]         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>构造函数声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>构造函数调用，经典的Java方式</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>构造函数用法，与<code>as</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>构造函数用法，在分配中使用强制</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_named_parameters"><a class="anchor" href="#_named_parameters"></a> 1.4.2。命名参数</h4>
<div class="paragraph">
<p>如果未声明（或无参数）构造函数，则可以通过以映射形式（属性/值对）传递参数来创建对象。如果要允许多个参数组合，这可能会派上用场。否则，通过使用传统的位置参数，必须声明所有可能的构造函数。有一个构造函数，其中第一个（也许也是唯一一个）参数是<code>Map</code>参数也受支持-也可以使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/MapConstructor.html">groovy.transform添加此类构造</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/MapConstructor.html">函数。MapConstructor</a>批注。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PersonWOConstructor {                                  <i class="conum" data-value="1"></i><b>(1)</b>
    String name
    Integer age
}

def person4 = new PersonWOConstructor()                      <i class="conum" data-value="2"></i><b>(2)</b>
def person5 = new PersonWOConstructor(name: 'Marie')         <i class="conum" data-value="3"></i><b>(3)</b>
def person6 = new PersonWOConstructor(age: 1)                <i class="conum" data-value="4"></i><b>(4)</b>
def person7 = new PersonWOConstructor(name: 'Marie', age: 2) <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>没有声明构造函数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>实例中未提供任何参数</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>name</code>实例化中给出的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>age</code>实例化中给出的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>name</code>和<code>age</code>实例中给出的参数</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，重要的是要强调一点，这种方法为构造函数调用者提供了更多功能，同时对调用者增加了使名称和值类型正确的责任。因此，如果需要更大的控制权，则最好使用位置参数声明构造函数。</p>
</div>
<div class="paragraph">
<p>笔记：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>尽管上面的示例没有提供构造函数，但是您也可以提供no-arg构造函数或第一个参数为<code>Map</code> ，最通常是唯一的论点。</p>
</li>
<li>
<p>当没有（或无参数）构造函数被声明时，对于每个提供的命名属性，Groovy会先通过调用no-arg构造函数，再调用setter来替换命名的构造函数调用。</p>
</li>
<li>
<p>当第一个参数是Map时，Groovy将所有命名参数组合到Map中（不考虑顺序），并将地图作为第一个参数。如果您的属性声明为<code>final</code> （因为它们将在构造函数中设置，而不是在使用setter的事实之后设置）。</p>
</li>
<li>
<p>通过提供位置构造函数以及无参数或Map构造函数，可以支持命名构造和位置构造。</p>
</li>
<li>
<p>您可以通过具有第一个参数是Map的构造函数来支持混合构造，但是还需要其他位置参数。请谨慎使用此样式。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_methods"><a class="anchor" href="#_methods"></a> 1.5。方法</h3>
<div class="paragraph">
<p>Groovy方法与其他语言非常相似。下一部分将显示一些特性。</p>
</div>
<div class="sect3">
<h4 id="_method_definition"><a class="anchor" href="#_method_definition"></a> 1.5.1。方法定义</h4>
<div class="paragraph">
<p>用返回类型或方法定义方法<code>def</code>关键字，以使返回类型为无类型。方法也可以接收任意数量的参数，这些参数可能没有明确声明其类型。Java修饰符可以正常使用，并且如果未提供可见性修饰符，则该方法是公共的。</p>
</div>
<div class="paragraph">
<p>Groovy中的方法总是返回一些值。如果不<code>return</code>提供语句，将返回在最后执行的行中评估的值。例如，请注意，以下方法均不使用<code>return</code>关键词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def someMethod() { 'method called' }                           <i class="conum" data-value="1"></i><b>(1)</b>
String anotherMethod() { 'another method called' }             <i class="conum" data-value="2"></i><b>(2)</b>
def thirdMethod(param1) { "$param1 passed" }                   <i class="conum" data-value="3"></i><b>(3)</b>
static String fourthMethod(String param1) { "$param1 passed" } <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>没有声明返回类型且没有参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有显式返回类型且无参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>具有未定义类型的参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>带有String参数的静态方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_named_parameters_2"><a class="anchor" href="#_named_parameters_2"></a> 1.5.2。命名参数</h4>
<div class="paragraph">
<p>像构造函数一样，普通方法也可以使用命名参数来调用。为了支持这种表示法，使用了约定，其中方法的第一个参数是<code>Map</code> 。在方法主体中，可以像在普通映射中一样访问参数值（ <code>map.key</code> ）。如果该方法只有一个Map参数，则必须命名所有提供的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Map args) { "${args.name}: ${args.age}" }
foo(name: 'Marie', age: 1)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_mixing_named_and_positional_parameters"><a class="anchor" href="#_mixing_named_and_positional_parameters"></a>混合命名和位置参数</h5>
<div class="paragraph">
<p>命名参数可以与位置参数混合。在这种情况下，除了<code>Map</code>参数作为第一个参数，所讨论的方法将根据需要具有其他位置参数。调用方法时提供的位置参数必须正确。命名参数可以在任何位置。它们被分组到地图中，并自动作为第一个参数提供。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Map args, Integer number) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  <i class="conum" data-value="1"></i><b>(1)</b>
foo(23, name: 'Marie', age: 1)  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>附加方法调用<code>number</code>的论点<code>Integer</code>类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有参数顺序更改的方法调用</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们没有Map作为第一个参数，则必须为该参数提供Map而不是命名参数。否则将导致<code>groovy.lang.MissingMethodException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>方法调用抛出<code>groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23]</code> ，因为命名参数<code>Map</code>参数未定义为第一个参数</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们用显式替换命名参数，可以避免上述异常<code>Map</code>参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(23, [name: 'Marie', age: 1])  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确的<code>Map</code>参数代替命名参数使调用有效</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">尽管Groovy允许您混合使用命名参数和位置参数，但这可能导致不必要的混乱。请谨慎混合命名和位置参数。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_default_arguments"><a class="anchor" href="#_default_arguments"></a> 1.5.3。默认参数</h4>
<div class="paragraph">
<p>默认参数使参数可选。如果未提供参数，则该方法采用默认值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(String par1, Integer par2 = 1) { [name: par1, age: par2] }
assert foo('Marie').age == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在存在默认参数之后，无法定义任何强制性参数，只能定义其他默认参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_varargs"><a class="anchor" href="#_varargs"></a> 1.5.4。瓦拉格斯</h4>
<div class="paragraph">
<p>Groovy支持参数数量可变的方法。它们的定义如下： <code>def foo(p1, …​, pn, T…​ args)</code> 。这里<code>foo</code>支持<code>n</code>默认情况下的参数，但未指定数量的其他参数超出<code>n</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子定义了一个方法<code>foo</code> ，它可以接受任意数量的参数，包括完全没有参数。
<code>args.length</code>将返回给定的参数数量。Groovy允许<code>T[]</code>作为替代符号<code>T…​</code> 。这意味着Groovy将任何以数组作为最后一个参数的方法视为可以接受可变数量参数的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object[] args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用varargs的方法被调用<code>null</code>作为vararg参数，则参数将为<code>null</code>而不是长度为<code>null</code>作为唯一元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args }
assert foo(null) == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用数组作为参数调用varargs方法，则参数将是该数组，而不是包含给定数组作为唯一元素的长度为1的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args }
Integer[] ints = [1, 2]
assert foo(ints) == [1, 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个要点是varargs与方法重载相结合。如果方法过载，Groovy将选择最具体的方法。例如，如果一个方法<code>foo</code>接受类型为varargs的参数<code>T</code>和另一种方法<code>foo</code>也接受一个类型的参数<code>T</code> ，第二种方法是首选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { 1 }
def foo(Object x) { 2 }
assert foo() == 1
assert foo(1) == 2
assert foo(1, 2) == 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_method_selection_algorithm"><a class="anchor" href="#_method_selection_algorithm"></a> 1.5.5。方法选择算法</h4>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_declaration"><a class="anchor" href="#_exception_declaration"></a> 1.5.6。异常声明</h4>
<div class="paragraph">
<p>Groovy自动允许您将已检查的异常视为未检查的异常。这意味着您不需要声明方法可能抛出的任何检查的异常，如下面的示例所示，该示例可以抛出一个<code>FileNotFoundException</code>如果找不到文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def badRead() {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也不需要围绕电话<code>badRead</code>上一个示例中的try / catch块中的方法-尽管您可以随意这样做。</p>
</div>
<div class="paragraph">
<p>如果您希望声明代码可能抛出（检查或以其他方式抛出）的任何异常，则可以这样做。添加异常不会改变其他Groovy代码中代码的使用方式，但是可以看作是代码的人工阅读者的文档。异常将成为字节码中方法声明的一部分，因此，如果您的代码可能是从Java调用的，则将它们包括在内可能会很有用。以下示例说明了如何使用显式检查异常声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def badRead() throws FileNotFoundException {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fields_and_properties"><a class="anchor" href="#_fields_and_properties"></a> 1.6。字段和属性</h3>
<div class="sect3">
<h4 id="fields"><a class="anchor" href="#fields"></a> 1.6.1。领域</h4>
<div class="paragraph">
<p>字段是具有以下内容的类或特征的成员：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>强制<em>访问修饰符</em> （ <code>public</code> ， <code>protected</code> ， 要么<code>private</code> ）</p>
</li>
<li>
<p>一个或多个可选<em>修饰符</em> （ <code>static</code> ， <code>final</code> ， <code>synchronized</code> ）</p>
</li>
<li>
<p>可选<em>类型</em></p>
</li>
<li>
<p>强制性<em>名称</em></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Data {
    private int id                                  <i class="conum" data-value="1"></i><b>(1)</b>
    protected String description                    <i class="conum" data-value="2"></i><b>(2)</b>
    public static final boolean DEBUG = false       <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一种<code>private</code>字段命名<code>id</code> ，类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>protected</code>字段命名<code>description</code> ，类型<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>一种<code>public static final</code>类型为<em>DEBUG</em>的字段<code>boolean</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>字段可以在声明时直接初始化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Data {
    private String id = IDGenerator.next() <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>私人领域<code>id</code>初始化为<code>IDGenerator.next()</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以省略字段的类型声明。但是，这被认为是不好的做法，总的来说，对字段使用强类型是一个好主意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BadPractice {
    private mapping                         <i class="conum" data-value="1"></i><b>(1)</b>
}
class GoodPractice {
    private Map&lt;String,String&gt; mapping      <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>场<code>mapping</code>没有声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>场<code>mapping</code>有很强的类型</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果以后要使用可选的类型检查，则两者之间的区别很重要。这对于文档编制也很重要。但是，在某些情况下（例如脚本编写）或如果您想依赖鸭子输入，则可能会忽略该类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="properties"><a class="anchor" href="#properties"></a> 1.6.2。性质</h4>
<div class="paragraph">
<p>属性是类的外部可见功能。Java中的典型约定不仅是使用公共字段来表示此类功能（它提供了更有限的抽象，而且会限制重构的可能性），而是遵循JavaBean约定，即使用私有支持字段和getter的组合来表示属性。 /设置者。Groovy遵循这些相同的约定，但是提供了一种更简单的方法来定义属性。您可以使用以下方法定义属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>缺少</strong>访问修饰符（否<code>public</code> ， <code>protected</code>要么<code>private</code> ）</p>
</li>
<li>
<p>一个或多个可选<em>修饰符</em> （ <code>static</code> ， <code>final</code> ， <code>synchronized</code> ）</p>
</li>
<li>
<p>可选<em>类型</em></p>
</li>
<li>
<p>强制性<em>名称</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy随后将适当地生成吸气剂/吸气剂。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
    int age                                 <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建后盾<code>private String name</code>场<code>getName</code>和一个<code>setName</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建后盾<code>private int age</code>场<code>getAge</code>和一个<code>setAge</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果声明了属性<code>final</code> ，不会生成设置器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    final String name                   <i class="conum" data-value="1"></i><b>(1)</b>
    final int age                       <i class="conum" data-value="2"></i><b>(2)</b>
    Person(String name, int age) {
        this.name = name                <i class="conum" data-value="3"></i><b>(3)</b>
        this.age = age                  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义类型的只读属性<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义类型的只读属性<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>分配<code>name</code>的参数<code>name</code>领域</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>分配<code>age</code>的参数<code>age</code>领域</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>属性是通过名称访问的，并且将透明地调用getter或setter，除非代码在定义属性的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    void name(String name) {
        this.name = "Wonder$name"       <i class="conum" data-value="1"></i><b>(1)</b>
    }
    String wonder() {
        this.name                       <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def p = new Person()
p.name = 'Marge'                        <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Marge'                <i class="conum" data-value="4"></i><b>(4)</b>
p.name('Marge')                         <i class="conum" data-value="5"></i><b>(5)</b>
assert p.wonder() == 'WonderMarge'      <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>this.name</code>将直接访问该字段，因为该属性是从定义它的类中访问的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类似地，直接在<code>name</code>领域</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>对属性的写访问权限是在<code>Person</code>类，因此它将隐式调用<code>setName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>对属性的读取访问是在<code>Person</code>类，因此它将隐式调用<code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>这将称为<code>name</code>方法开启<code>Person</code>直接执行该字段</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>这将称为<code>wonder</code>方法开启<code>Person</code>对字段执行直接读取访问</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得注意的是，这样做是为了防止在定义属性的类中使用属性访问语法时发生堆栈溢出，从而防止堆栈溢出。</p>
</div>
<div class="paragraph">
<p>通过meta可以列出类的属性<code>properties</code>实例的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
}
def p = new Person()
assert p.properties.keySet().containsAll(['name','age'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>按照约定，即使没有支持字段，只要有遵循Java Beans规范的getter或setter，Groovy都将识别属性。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PseudoProperties {
    // a pseudo property "name"
    void setName(String name) {}
    String getName() {}

    // a pseudo read-only property "age"
    int getAge() { 42 }

    // a pseudo write-only property "groovy"
    void setGroovy(boolean groovy) {  }
}
def p = new PseudoProperties()
p.name = 'Foo'                      <i class="conum" data-value="1"></i><b>(1)</b>
assert p.age == 42                  <i class="conum" data-value="2"></i><b>(2)</b>
p.groovy = true                     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>写作<code>p.name</code>因为存在伪属性而被允许<code>name</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>阅读<code>p.age</code>允许，因为有一个伪只读属性<code>age</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>写作<code>p.groovy</code>允许，因为有一个伪只写属性<code>groovy</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这种语法糖是用Groovy编写的许多DSL的核心。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_annotation"><a class="anchor" href="#_annotation"></a> 1.7。注解</h3>
<div class="sect3">
<h4 id="ann-definition"><a class="anchor" href="#ann-definition"></a> 1.7.1。注释定义</h4>
<div class="paragraph">
<p>注释是一种专用于对代码元素进行注释的特殊接口。注释是一种类型，其中超级接口是<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html">注释</a>接口。使用接口以与接口非常相似的方式声明注释。 <code>@interface</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface SomeAnnotation {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>批注可以以没有主体和可选默认值的方法的形式定义成员。可能的成员类型限于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基本类型</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/String.html">弦乐</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Class.html">班级</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Enum.html">枚举</a></p>
</li>
<li>
<p>另一种<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html">注释类型</a></p>
</li>
<li>
<p>或以上任何数组</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface SomeAnnotation {
    String value()                          <i class="conum" data-value="1"></i><b>(1)</b>
}
@interface SomeAnnotation {
    String value() default 'something'      <i class="conum" data-value="2"></i><b>(2)</b>
}
@interface SomeAnnotation {
    int step()                              <i class="conum" data-value="3"></i><b>(3)</b>
}
@interface SomeAnnotation {
    Class appliesTo()                       <i class="conum" data-value="4"></i><b>(4)</b>
}
@interface SomeAnnotation {}
@interface SomeAnnotations {
    SomeAnnotation[] value()                <i class="conum" data-value="5"></i><b>(5)</b>
}
enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
@interface Scheduled {
    DayOfWeek dayOfWeek()                   <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义<code>value</code>类型成员<code>String</code>默认值为<code>something</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>定义<code>step</code>类型的成员原始类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>定义<code>appliesTo</code>类型成员<code>Class</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>定义<code>value</code>成员，该类型是另一个注释类型的数组</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>定义<code>dayOfWeek</code>成员是枚举类型<code>DayOfWeek</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与Java语言不同，在Groovy中，可以使用注释来更改语言的语义。AST转换尤其如此，它将基于注释生成代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="ann-placement"><a class="anchor" href="#ann-placement"></a> 1.7.2。注解位置</h4>
<div class="paragraph">
<p>注释可以应用于代码的各个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SomeAnnotation                 <i class="conum" data-value="1"></i><b>(1)</b>
void someMethod() {
    // ...
}

@SomeAnnotation                 <i class="conum" data-value="2"></i><b>(2)</b>
class SomeClass {}

@SomeAnnotation String var      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>@SomeAnnotation</code>适用于<code>someMethod</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>@SomeAnnotation</code>适用于<code>SomeClass</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>@SomeAnnotation</code>适用于<code>var</code>变量</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了限制可以应用注释的范围，必须使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Target.html">Target</a>注释在注释定义上声明它。例如，这是您声明可以将注释应用于类或方法的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.annotation.ElementType
import java.lang.annotation.Target

@Target([ElementType.METHOD, ElementType.TYPE])     <i class="conum" data-value="1"></i><b>(1)</b>
@interface SomeAnnotation {}                        <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Target</code>注解旨在用范围对注解进行注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>@SomeAnnotation</code>因此只会被允许<code>TYPE</code>要么<code>METHOD</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可能的目标列表在<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html">ElementType枚举中</a>可用。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">Groovy不支持Java 8中引入的<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER">TYPE_PARAMETER</a>和<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER">TYPE_USE</a>元素类型。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_annotation_member_values"><a class="anchor" href="#_annotation_member_values"></a> 1.7.3。注释成员值</h4>
<div class="paragraph">
<p>使用注释时，需要至少设置所有没有默认值的成员。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface Page {
    int statusCode()
}

@Page(statusCode=404)
void notFound() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是可以省略<code>value=</code>在注释的值的声明中，如果成员<code>value</code>是唯一设置的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface Page {
    String value()
    int statusCode() default 200
}

@Page(value='/home')                    <i class="conum" data-value="1"></i><b>(1)</b>
void home() {
    // ...
}

@Page('/users')                         <i class="conum" data-value="2"></i><b>(2)</b>
void userList() {
    // ...
}

@Page(value='error',statusCode=404)     <i class="conum" data-value="3"></i><b>(3)</b>
void notFound() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们可以省略<code>statusCode</code>因为它具有默认值，但是<code>value</code>需要设置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>以来<code>value</code>是唯一没有默认值的强制成员，我们可以省略<code>value=</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果两者<code>value</code>和<code>statusCode</code>需要设置，需要使用<code>value=</code>为默认<code>value</code>会员</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_retention_policy"><a class="anchor" href="#_retention_policy"></a> 1.7.4。保留政策</h4>
<div class="paragraph">
<p>注释的可见性取决于其保留策略。注释的保留策略是使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Retention.html">Retention</a>注释设置的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.SOURCE)                   <i class="conum" data-value="1"></i><b>(1)</b>
@interface SomeAnnotation {}                         <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Retention</code>批注为<code>@SomeAnnotation</code>注解</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以<code>@SomeAnnotation</code>将有一个<code>SOURCE</code>保留</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/RetentionPolicy.html">RetentionPolicy</a>枚举中提供了可能的保留目标和说明列表。选择通常取决于您是要在编译时还是运行时看到注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="_closure_annotation_parameters"><a class="anchor" href="#_closure_annotation_parameters"></a> 1.7.5。闭包注释参数</h4>
<div class="paragraph">
<p>Groovy中注释的一个有趣的功能是可以将闭包用作注释值。因此，注释可用于多种表达式，并且仍具有IDE支持。例如，设想一个框架，您希望根据环境约束（例如JDK版本或OS）执行某些方法。可以编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Tasks {
    Set result = []
    void alwaysExecuted() {
        result &lt;&lt; 1
    }
    @OnlyIf({ jdk&gt;=6 })
    void supportedOnlyInJDK6() {
        result &lt;&lt; 'JDK 6'
    }
    @OnlyIf({ jdk&gt;=7 &amp;&amp; windows })
    void requiresJDK7AndWindows() {
        result &lt;&lt; 'JDK 7 Windows'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了<code>@OnlyIf</code>注释接受<code>Closure</code>作为参数，您只需要声明<code>value</code>作为一个<code>Class</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@interface OnlyIf {
    Class value()                    <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了完成该示例，让我们编写一个使用该信息的样本运行器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Runner {
    static &lt;T&gt; T run(Class&lt;T&gt; taskClass) {
        def tasks = taskClass.newInstance()                                         <i class="conum" data-value="1"></i><b>(1)</b>
        def params = [jdk:6, windows: false]                                        <i class="conum" data-value="2"></i><b>(2)</b>
        tasks.class.declaredMethods.each { m -&gt;                                     <i class="conum" data-value="3"></i><b>(3)</b>
            if (Modifier.isPublic(m.modifiers) &amp;&amp; m.parameterTypes.length == 0) {   <i class="conum" data-value="4"></i><b>(4)</b>
                def onlyIf = m.getAnnotation(OnlyIf)                                <i class="conum" data-value="5"></i><b>(5)</b>
                if (onlyIf) {
                    Closure cl = onlyIf.value().newInstance(tasks,tasks)            <i class="conum" data-value="6"></i><b>(6)</b>
                    cl.delegate = params                                            <i class="conum" data-value="7"></i><b>(7)</b>
                    if (cl()) {                                                     <i class="conum" data-value="8"></i><b>(8)</b>
                        m.invoke(tasks)                                             <i class="conum" data-value="9"></i><b>(9)</b>
                    }
                } else {
                    m.invoke(tasks)                                                 <i class="conum" data-value="10"></i><b>(10)</b>
                }
            }
        }
        tasks                                                                       <i class="conum" data-value="11"></i><b>(11)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建作为参数传递的类的新实例（任务类）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>模拟一个不是Windows的JDK 6环境</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>迭代任务类的所有已声明方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>如果该方法是公开的并且不带参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>尝试找到<code>@OnlyIf</code>注解</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>如果找到了<code>value</code>并创建一个新的<code>Closure</code>从中</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>设置<code>delegate</code>对我们的环境变量的关闭</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>称为闭包，即注解闭包。它将返回一个<code>boolean</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>如果是<code>true</code> ，调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>如果该方法未使用注释<code>@OnlyIf</code> ，仍然执行方法</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>之后，返回任务对象</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以通过以下方式使用跑步者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def tasks = Runner.run(Tasks)
assert tasks.result == [1, 'JDK 6'] as Set</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_meta_annotations"><a class="anchor" href="#_meta_annotations"></a> 1.7.6。元注释</h4>
<div class="sect4">
<h5 id="_declaring_meta_annotations"><a class="anchor" href="#_declaring_meta_annotations"></a>声明元注释</h5>
<div class="paragraph">
<p>元注释（也称为注释别名）是在编译时由其他注释替换的注释（一个元注释是一个或多个注释的别名）。元注释可用于减少涉及多个注释的代码的大小。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始。想象你有<code>@Service</code>和<code>@Transactional</code>批注，并且您想同时使用这两种方式来注释类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Service
@Transactional
class MyTransactionalService {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定您可以添加到同一类的批注的倍数，元批注可以通过使用语义完全相同的单个批注减少两个批注来提供帮助。例如，我们可能想写成这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TransactionalService                           <i class="conum" data-value="1"></i><b>(1)</b>
class MyTransactionalService {}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>@TransactionalService</code>是一个元注释</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>元注释被声明为常规注释，但带有<code>@AnnotationCollector</code>以及它正在收集的注释列表。就我们而言， <code>@TransactionalService</code>注释可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AnnotationCollector

@Service                                        <i class="conum" data-value="1"></i><b>(1)</b>
@Transactional                                  <i class="conum" data-value="2"></i><b>(2)</b>
@AnnotationCollector                            <i class="conum" data-value="3"></i><b>(3)</b>
@interface TransactionalService {
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用以下命令注释元注释<code>@Service</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用以下命令注释元注释<code>@Transactional</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>用以下命令注释元注释<code>@AnnotationCollector</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="meta-ann-behavior"><a class="anchor" href="#meta-ann-behavior"></a>元注释的行为</h5>
<div class="paragraph">
<p>Groovy支持<em>预编译</em>和<em>源形式的</em>元注释。这意味着您的元注释<em>可以</em>预先编译，也可以与当前正在编译的源树放在同一源代码树中。</p>
</div>
<div class="paragraph">
<p>信息：元注释是仅Groovy的功能。您没有机会用元注释来注释Java类，并希望它能与Groovy一样。同样，您不能用Java编写元注释：元注释定义<strong>和</strong>用法都必须是Groovy代码。但是，您可以在元注释中愉快地收集Java注释和Groovy注释。</p>
</div>
<div class="paragraph">
<p>当Groovy编译器遇到带有元注释的类时，它将<strong>替换</strong>为收集的注释。因此，在我们之前的示例中，它将替换<code>@TransactionalService</code>与<code>@Transactional</code>和<code>@Service</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def annotations = MyTransactionalService.annotations*.annotationType()
assert (Service in annotations)
assert (Transactional in annotations)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<em>语义分析</em>编译阶段执行从元注释到收集的注释的转换。</p>
</div>
<div class="paragraph">
<p>除了使用收集的注释替换别名之外，元注释还能够处理它们，包括参数。</p>
</div>
</div>
<div class="sect4">
<h5 id="meta-ann-members"><a class="anchor" href="#meta-ann-members"></a>元注释参数</h5>
<div class="paragraph">
<p>元注释可以收集具有参数的注释。为了说明这一点，我们将想象两个注释，每个注释接受一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Timeout(after=3600)
@Dangerous(type='explosive')</code></pre>
</div>
</div>
<div class="paragraph">
<p>并假设您要创建一个名为<code>@Explosive</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Timeout(after=3600)
@Dangerous(type='explosive')
@AnnotationCollector
public @interface Explosive {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，替换注释时，它们将获得<strong>在alias中定义</strong>的注释参数值。更有趣的是，元注释支持覆盖特定值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Explosive(after=0)                 <i class="conum" data-value="1"></i><b>(1)</b>
class Bomb {}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>after</code>作为参数提供的值<code>@Explosive</code>覆盖在<code>@Timeout</code>注解</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果两个注释定义了相同的参数名称，则默认处理器会将注释值复制到接受此参数的所有注释中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
   String value()                                   <i class="conum" data-value="1"></i><b>(1)</b>
}
@Retention(RetentionPolicy.RUNTIME)
public @interface Bar {
    String value()                                  <i class="conum" data-value="2"></i><b>(2)</b>
}

@Foo
@Bar
@AnnotationCollector
public @interface FooBar {}                         <i class="conum" data-value="3"></i><b>(3)</b>

@Foo('a')
@Bar('b')
class Bob {}                                        <i class="conum" data-value="4"></i><b>(4)</b>

assert Bob.getAnnotation(Foo).value() == 'a'        <i class="conum" data-value="5"></i><b>(5)</b>
println Bob.getAnnotation(Bar).value() == 'b'       <i class="conum" data-value="6"></i><b>(6)</b>

@FooBar('a')
class Joe {}                                        <i class="conum" data-value="7"></i><b>(7)</b>
assert Joe.getAnnotation(Foo).value() == 'a'        <i class="conum" data-value="8"></i><b>(8)</b>
println Joe.getAnnotation(Bar).value() == 'a'       <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Foo</code>注释定义了<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>@Bar</code>注释还定义了<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>@FooBar</code>元注释聚合<code>@Foo</code>和<code>@Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>类<code>Bob</code>带有注释<code>@Foo</code>和<code>@Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的价值<code>@Foo</code>上的注释<code>Bob</code>是<code>a</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>而价值<code>@Bar</code>上的注释<code>Bob</code>是<code>b</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>类<code>Joe</code>带有注释<code>@FooBar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后的价值<code>@Foo</code>上的注释<code>Joe</code>是<code>a</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>和的价值<code>@Bar</code>上的注释<code>Joe</code>也是<code>a</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在第二种情况下，将元注释值复制到两个<code>@Foo</code>和<code>@Bar</code>注释。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果收集的批注定义了具有不兼容类型的相同成员，则会产生编译时错误。例如，如果在前面的示例中<code>@Foo</code>定义类型的值<code>String</code>但<code>@Bar</code>定义类型的值<code>int</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，可以自定义元注释的行为并描述如何扩展收集的注释。我们将很快讨论如何做，但首先要介绍一个高级处理选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="handling_duplicate_annotations"><a class="anchor" href="#handling_duplicate_annotations"></a>处理重复的注释</h5>
<div class="paragraph">
<p>的<code>@AnnotationCollector</code>注释支持<code>mode</code>该参数可用于在存在重复注释的情况下更改默认处理器如何处理注释替换。</p>
</div>
<div class="paragraph">
<p>INFO：定制处理器（下面讨论）可能支持也可能不支持此参数。</p>
</div>
<div class="paragraph">
<p>举例来说，假设您创建了一个包含<code>@ToString</code>注释，然后将您的元注释放在已经有显式的类上<code>@ToString</code>注解。这应该是一个错误吗？是否应同时使用两个注释？一个优先于另一个吗？没有正确的答案。在某些情况下，使这些答案中的任何一个正确都是很合适的。因此，与尝试抢占一种解决重复标注问题的正确方法不同，Groovy让您编写自己的自定义元注释处理器（接下来介绍），并让您编写自己喜欢的AST转换中的任何检查逻辑-这是常见的目标进行汇总。话虽如此，只需设置<code>mode</code> ，您可以在任何额外的编码内自动为您处理许多普遍预期的情况。的行为<code>mode</code>参数由<code>AnnotationCollectorMode</code>选择的枚举值，并在下表中进行了汇总。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">重复</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释集合中的注释将始终被插入。运行完所有转换后，如果存在多个注释（不包括具有SOURCE保留的注释），将是一个错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自收集器的注释将被添加，所有具有相同名称的现有注释将被删除。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自收集器的注释将被添加，任何具有相同名称的现有注释将被删除，但是在现有注释中找到的任何新参数将被合并到添加的注释中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果找到任何现有的具有相同名称的注释，则将忽略来自收集器的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果找到任何具有相同名称的现有注释，但是收集器注释上的任何新参数都将添加到现有注释中，则将忽略来自收集器的注释。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="meta-ann-processor"><a class="anchor" href="#meta-ann-processor"></a>自定义注释处理器</h5>
<div class="paragraph">
<p>自定义注释处理器将让您选择如何将元注释扩展为收集的注释。在这种情况下，元注释的行为完全取决于您。为此，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个元注释处理器，扩展<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html">AnnotationCollectorTransform</a></p>
</li>
<li>
<p>声明要在元注释声明中使用的处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明这一点，我们将探索元注释<code>@CompileDynamic</code>被实施。</p>
</div>
<div class="paragraph">
<p><code>@CompileDynamic</code>是一个扩展为<code>@CompileStatic(TypeCheckingMode.SKIP)</code> 。问题是默认的元注释处理器不支持枚举和注释值<code>TypeCheckingMode.SKIP</code>是一个。</p>
</div>
<div class="paragraph">
<p>天真的实现在这里行不通：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic(TypeCheckingMode.SKIP)
@AnnotationCollector
public @interface CompileDynamic {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，我们将如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AnnotationCollector(processor = "org.codehaus.groovy.transform.CompileDynamicProcessor")
public @interface CompileDynamic {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到的第一件事是我们的界面不再带有注释<code>@CompileStatic</code> 。原因是我们依靠<code>processor</code>参数，而是引用一个将<strong>生成</strong>注释的类。</p>
</div>
<div class="paragraph">
<p>这是定制处理器的实现方式：</p>
</div>
<div class="listingblock">
<div class="title">CompileDynamicProcessor.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
class CompileDynamicProcessor extends AnnotationCollectorTransform {            <i class="conum" data-value="2"></i><b>(2)</b>
    private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic)    <i class="conum" data-value="3"></i><b>(3)</b>
    private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) <i class="conum" data-value="4"></i><b>(4)</b>

    List&lt;AnnotationNode&gt; visit(AnnotationNode collector,                        <i class="conum" data-value="5"></i><b>(5)</b>
                               AnnotationNode aliasAnnotationUsage,             <i class="conum" data-value="6"></i><b>(6)</b>
                               AnnotatedNode aliasAnnotated,                    <i class="conum" data-value="7"></i><b>(7)</b>
                               SourceUnit source) {                             <i class="conum" data-value="8"></i><b>(8)</b>
        def node = new AnnotationNode(CS_NODE)                                  <i class="conum" data-value="9"></i><b>(9)</b>
        def enumRef = new PropertyExpression(
            new ClassExpression(TC_NODE), "SKIP")                               <i class="conum" data-value="10"></i><b>(10)</b>
        node.addMember("value", enumRef)                                        <i class="conum" data-value="11"></i><b>(11)</b>
        Collections.singletonList(node)                                         <i class="conum" data-value="12"></i><b>(12)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们的定制处理器是用Groovy编写的，为了获得更好的编译性能，我们使用静态编译</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>自定义处理器必须扩展<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html">AnnotationCollectorTransform</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个代表<code>@CompileStatic</code>注释类型</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>创建一个代表<code>TypeCheckingMode</code>枚举类型</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>collector</code>是个<code>@AnnotationCollector</code>在元注释中找到的节点。通常不使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>aliasAnnotationUsage</code>是扩展的元注释，在这里<code>@CompileDynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td><code>aliasAnnotated</code>是使用元注释进行注释的节点</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td><code>sourceUnit</code>是个<code>SourceUnit</code>正在编译</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>我们为创建一个新的注释节点<code>@CompileStatic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>我们创建一个等价于<code>TypeCheckingMode.SKIP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>我们将该表达式添加到注释节点，现在<code>@CompileStatic(TypeCheckingMode.SKIP)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i> <b>12</b></td>
<td>返回生成的注释</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在示例中， <code>visit</code>方法是唯一必须重写的方法。它的目的是返回注释节点列表，该列表将添加到使用元注释进行注释的节点上。在此示例中，我们返回一个对应于<code>@CompileStatic(TypeCheckingMode.SKIP)</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inheritance"><a class="anchor" href="#_inheritance"></a> 1.8。遗产</h3>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
<div class="sect2">
<h3 id="generics"><a class="anchor" href="#generics"></a> 1.9。泛型</h3>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traits"><a class="anchor" href="#_traits"></a> 2。特质</h2>
<div class="sectionbody">
<div class="paragraph">
<p>特质是该语言的结构结构，它可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>行为组成</p>
</li>
<li>
<p>接口的运行时实现</p>
</li>
<li>
<p>行为重载</p>
</li>
<li>
<p>与静态类型检查/编译的兼容性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将它们视为既包含<strong>默认实现</strong>又包含<strong>state的</strong> <strong>接口</strong> 。使用<code>trait</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后就可以像普通界面一样使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bird implements FlyingAbility {}          <i class="conum" data-value="1"></i><b>(1)</b>
def b = new Bird()                              <i class="conum" data-value="2"></i><b>(2)</b>
assert b.fly() == "I'm flying!"                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加特质<code>FlyingAbility</code>到<code>Bird</code>班级能力</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>实例化一个新的<code>Bird</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Bird</code>类自动获取<code>FlyingAbility</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从本构图到测试，这些特性具有广泛的功能，本节对此进行了详细介绍。</p>
</div>
<div class="sect2">
<h3 id="_methods_2"><a class="anchor" href="#_methods_2"></a> 2.1。方法</h3>
<div class="sect3">
<h4 id="_public_methods"><a class="anchor" href="#_public_methods"></a> 2.1.1。公开方法</h4>
<div class="paragraph">
<p>可以使用trait中的任何常规方法来声明特征中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_abstract_methods"><a class="anchor" href="#_abstract_methods"></a> 2.1.2。抽象方法</h4>
<div class="paragraph">
<p>另外，特征也可以声明<em>抽象</em>方法，因此需要在实现特征的类中实现<em>抽象</em>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greetable {
    abstract String name()                              <i class="conum" data-value="1"></i><b>(1)</b>
    String greeting() { "Hello, ${name()}!" }           <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实现类将必须声明<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以与具体方法混合</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以使用如下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person implements Greetable {                     <i class="conum" data-value="1"></i><b>(1)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实施特质<code>Greetable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>以来<code>name</code>是抽象的，需要实现它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>greeting</code>可以叫</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_private_methods"><a class="anchor" href="#_private_methods"></a> 2.1.3。私人方法</h4>
<div class="paragraph">
<p>特性还可以定义私有方法。这些方法将不会出现在特征合同界面中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    private String greetingMessage() {                      <i class="conum" data-value="1"></i><b>(1)</b>
        'Hello from a private method!'
    }
    String greet() {
        def m = greetingMessage()                           <i class="conum" data-value="2"></i><b>(2)</b>
        println m
        m
    }
}
class GreetingMachine implements Greeter {}                 <i class="conum" data-value="3"></i><b>(3)</b>
def g = new GreetingMachine()
assert g.greet() == "Hello from a private method!"          <i class="conum" data-value="4"></i><b>(4)</b>
try {
    assert g.greetingMessage()                              <i class="conum" data-value="5"></i><b>(5)</b>
} catch (MissingMethodException e) {
    println "greetingMessage is private in trait"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个私有方法<code>greetingMessage</code>特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>公众<code>greet</code>留言电话<code>greetingMessage</code>默认</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>greet</code>可以叫</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但不是<code>greetingMessage</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">仅支持性状<code>public</code>和<code>private</code>方法。都没有<code>protected</code>也不<code>package private</code>支持范围。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_final_methods"><a class="anchor" href="#_final_methods"></a> 2.1.4。最终方法</h4>
<div class="paragraph">
<p>如果我们有一个实现特征的类，则从概念上讲，特征方法的实现将“继承”到该类中。但是，实际上，没有包含此类实现的基类。而是将它们直接编织到班级中。方法上的最终修饰符仅表示织造方法的修饰符。尽管用相同的签名但混合了最终变量和非最终变量来继承和重写或乘以继承方法可能被认为是不好的样式，但是Groovy并不禁止这种情况。将应用常规方法选择，并且所使用的修饰符将从结果方法中确定。如果您想要无法覆盖的特征实现方法，则可以考虑创建一个实现所需特征的基类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_meaning_of_this"><a class="anchor" href="#_the_meaning_of_this"></a> 2.2。这个的意思</h3>
<div class="paragraph">
<p><code>this</code>表示实现实例。将特征视为超类。这意味着当您编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Introspector {
    def whoAmI() { this }
}
class Foo implements Introspector {}
def foo = new Foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后致电：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">foo.whoAmI()</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回相同的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert foo.whoAmI().is(foo)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaces"><a class="anchor" href="#_interfaces"></a> 2.3。介面</h3>
<div class="paragraph">
<p>特性可以实现接口，在这种情况下，可以使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Named {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    String name()
}
trait Greetable implements Named {                      <i class="conum" data-value="2"></i><b>(2)</b>
    String greeting() { "Hello, ${name()}!" }
}
class Person implements Greetable {                     <i class="conum" data-value="3"></i><b>(3)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="4"></i><b>(4)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="5"></i><b>(5)</b>
assert p instanceof Named                               <i class="conum" data-value="6"></i><b>(6)</b>
assert p instanceof Greetable                           <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>普通接口的声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>加<code>Named</code>到已实现接口的列表</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Greetable</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>实现失踪<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的<code>greeting</code>实现来自特质</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>确保<code>Person</code>实现<code>Named</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>确保<code>Person</code>实现<code>Greetable</code>特征</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_properties"><a class="anchor" href="#_properties"></a> 2.4。性质</h3>
<div class="paragraph">
<p>特征可以定义属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person(name: 'Bob')             <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Bob'                      <i class="conum" data-value="4"></i><b>(4)</b>
assert p.getName() == 'Bob'                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>申报财产<code>name</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>该属性自动显示</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>可以使用常规属性访问器进行访问</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>或使用常规的getter语法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_fields"><a class="anchor" href="#_fields"></a> 2.5。领域</h3>
<div class="sect3">
<h4 id="_private_fields"><a class="anchor" href="#_private_fields"></a> 2.5.1。私人领域</h4>
<div class="paragraph">
<p>由于特征允许使用私有方法，因此使用私有字段存储状态也可能很有趣。特性将使您做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counter {
    private int count = 0                   <i class="conum" data-value="1"></i><b>(1)</b>
    int count() { count += 1; count }       <i class="conum" data-value="2"></i><b>(2)</b>
}
class Foo implements Counter {}             <i class="conum" data-value="3"></i><b>(3)</b>
def f = new Foo()
assert f.count() == 1                       <i class="conum" data-value="4"></i><b>(4)</b>
assert f.count() == 2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个私有领域<code>count</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个公共方法<code>count</code>递增计数器并返回它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Counter</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>count</code>方法可以使用私有字段来保持状态</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这是与<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8虚拟扩展方法</a>的主要区别。尽管虚拟扩展方法不携带状态，但特征可以携带。而且，从Java 6开始就支持Groovy中的特征，因为它们的实现不依赖于虚拟扩展方法。这意味着，即使可以从Java类中将特征视为常规接口，该接口也将<strong>没有</strong>默认方法，而只有抽象方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_public_fields"><a class="anchor" href="#_public_fields"></a> 2.5.2。公共领域</h4>
<div class="paragraph">
<p>公共字段的工作方式与私有字段相同，但是为了避免<a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形问题</a> ，在实现类中将字段名称重新映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    public String name                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person()                        <i class="conum" data-value="3"></i><b>(3)</b>
p.Named__name = 'Bob'                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在特征内声明一个公共<strong>领域</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明实现该特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建该类的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>公共字段可用，但已重命名</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>字段的名称取决于特征的完全限定名称。所有点（ <code>.</code>包中的）替换为下划线（ <code>_</code> ），并且最终名称包含双下划线。因此，如果字段的类型是<code>String</code> ，包装名称为<code>my.package</code> ，特征的名称是<code>Foo</code>并且该字段的名称是<code>bar</code> ，在实施类中，公共字段将显示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String my_package_Foo__bar</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">虽然特质支持公共领域，但不建议使用它们，这被认为是不好的做法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composition_of_behaviors"><a class="anchor" href="#_composition_of_behaviors"></a> 2.6。行为组成</h3>
<div class="paragraph">
<p>特性可以用于以受控方式实现多重继承。例如，我们可以具有以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个实现了这两个特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {} <i class="conum" data-value="1"></i><b>(1)</b>

def d = new Duck()                                      <i class="conum" data-value="2"></i><b>(2)</b>
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.speak() == "I'm speaking!"                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Duck</code>该类同时实现<code>FlyingAbility</code>和<code>SpeakingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个新的实例<code>Duck</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以调用该方法<code>fly</code>从<code>FlyingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>还有方法<code>speak</code>从<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>特性鼓励在对象之间重用功能，并通过现有行为的组合来创建新的类。</p>
</div>
</div>
<div class="sect2">
<h3 id="_overriding_default_methods"><a class="anchor" href="#_overriding_default_methods"></a> 2.7。覆盖默认方法</h3>
<div class="paragraph">
<p>特性提供方法的默认实现，但可以在实现类中覆盖它们。例如，我们可以稍微改变一下上面的例子，通过鸭子来嘎嘎叫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         <i class="conum" data-value="1"></i><b>(1)</b>
    String speak() { quack() }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def d = new Duck()
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.quack() == "Quack!"                            <i class="conum" data-value="4"></i><b>(4)</b>
assert d.speak() == "Quack!"                            <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义特定于<code>Duck</code> ，命名<code>quack</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖默认的实现<code>speak</code>这样我们使用<code>quack</code>代替</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>鸭子仍在飞行，从默认实现</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>quack</code>来自<code>Duck</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>speak</code>不再使用来自的默认实现<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_extending_traits"><a class="anchor" href="#_extending_traits"></a> 2.8。扩展特征</h3>
<div class="sect3">
<h4 id="_simple_inheritance"><a class="anchor" href="#_simple_inheritance"></a> 2.8.1。简单继承</h4>
<div class="paragraph">
<p>性状可能会扩展另一个特征，在这种情况下，您必须使用<code>extends</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                                     <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Polite extends Named {                        <i class="conum" data-value="2"></i><b>(2)</b>
    String introduce() { "Hello, I am $name" }      <i class="conum" data-value="3"></i><b>(3)</b>
}
class Person implements Polite {}
def p = new Person(name: 'Alice')                   <i class="conum" data-value="4"></i><b>(4)</b>
assert p.introduce() == 'Hello, I am Alice'         <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Named</code>特质定义一个<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Polite</code>特质<strong>扩展</strong>了<code>Named</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Polite</code>添加了可以访问<code>name</code>超特性的性质</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>name</code>该属性从<code>Person</code>课堂实施<code>Polite</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>就像<code>introduce</code>方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_inheritance"><a class="anchor" href="#_multiple_inheritance"></a> 2.8.2。多重继承</h4>
<div class="paragraph">
<p>或者，一个特征可以扩展多个特征。在这种情况下，必须在<code>implements</code>条款：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait WithId {                                      <i class="conum" data-value="1"></i><b>(1)</b>
    Long id
}
trait WithName {                                    <i class="conum" data-value="2"></i><b>(2)</b>
    String name
}
trait Identified implements WithId, WithName {}     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>WithId</code>特质定义了<code>id</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>WithName</code>特质定义了<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Identified</code>是一个既继承了<code>WithId</code>和<code>WithName</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_duck_typing_and_traits"><a class="anchor" href="#_duck_typing_and_traits"></a> 2.9。鸭的打字和特征</h3>
<div class="sect3">
<h4 id="_dynamic_code"><a class="anchor" href="#_dynamic_code"></a> 2.9.1。动态代码</h4>
<div class="paragraph">
<p>特性可以调用任何动态代码，例如普通的Groovy类。这意味着您可以在方法的主体中调用应该在实现类中存在的方法，而不必在接口中显式声明它们。这意味着特质与鸭子类型完全兼容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SpeakingDuck {
    String speak() { quack() }                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def d = new Duck()
assert d.speak() == 'Quack!'                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>SpeakingDuck</code>期望<code>quack</code>要定义的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Duck</code>类确实使用<em>methodMissing</em>实现方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>称呼<code>speak</code>方法触发对<code>quack</code>由处理<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_methods_in_a_trait"><a class="anchor" href="#_dynamic_methods_in_a_trait"></a> 2.9.2。特征中的动态方法</h4>
<div class="paragraph">
<p>特征也可以实现MOP方法，例如<code>methodMissing</code>要么<code>propertyMissing</code> ，在这种情况下，实现类将从trait继承行为，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DynamicObject {                               <i class="conum" data-value="1"></i><b>(1)</b>
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String prop) {
        props[prop]
    }
    void setProperty(String prop, Object value) {
        props[prop] = value
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  <i class="conum" data-value="2"></i><b>(2)</b>
    String existingMethod() { 'ok' }                <i class="conum" data-value="3"></i><b>(3)</b>
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert d.foo == null                                <i class="conum" data-value="5"></i><b>(5)</b>
d.foo = 'bar'                                       <i class="conum" data-value="6"></i><b>(6)</b>
assert d.foo == 'bar'                               <i class="conum" data-value="7"></i><b>(7)</b>
assert d.existingMethod() == 'ok'                   <i class="conum" data-value="8"></i><b>(8)</b>
assert d.someMethod() == 'SOMEMETHOD'               <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建实现几种MOP方法的特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Dynamic</code>类定义一个属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Dynamic</code>类定义方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>调用现有属性将从中调用方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>调用不存在的属性会从特征中调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>将会通知<code>setProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>将会通知<code>getProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>调用现有方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>但由于特质而调用了不存在的方法<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_inheritance_conflicts"><a class="anchor" href="#_multiple_inheritance_conflicts"></a> 2.10。多重继承冲突</h3>
<div class="sect3">
<h4 id="_default_conflict_resolution"><a class="anchor" href="#_default_conflict_resolution"></a> 2.10.1。默认冲突解决</h4>
<div class="paragraph">
<p>一个类可以实现多个特征。如果某个特征定义的方法与另一个特征中的方法具有相同的签名，则我们将发生冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A {
    String exec() { 'A' }               <i class="conum" data-value="1"></i><b>(1)</b>
}
trait B {
    String exec() { 'B' }               <i class="conum" data-value="2"></i><b>(2)</b>
}
class C implements A,B {}               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特征<code>A</code>定义一个名为<code>exec</code>返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征<code>B</code>定义完全相同的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>C</code>实现两个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，默认行为是： <strong>最后一个声明的特征</strong>中的方法<code>implements</code>条款胜出。这里， <code>B</code>在之后声明<code>A</code>所以从<code>B</code>将被收取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def c = new C()
assert c.exec() == 'B'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_user_conflict_resolution"><a class="anchor" href="#_user_conflict_resolution"></a> 2.10.2。解决用户冲突</h4>
<div class="paragraph">
<p>如果此行为不是您想要的行为，则可以使用<code>Trait.super.foo</code>句法。在上面的示例中，我们可以通过编写以下代码来确保调用特征A中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class C implements A,B {
    String exec() { A.super.exec() }    <i class="conum" data-value="1"></i><b>(1)</b>
}
def c = new C()
assert c.exec() == 'A'                  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确要求<code>exec</code>从特质<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>从调用版本<code>A</code>而不是使用默认分辨率，这将是<code>B</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_runtime_implementation_of_traits"><a class="anchor" href="#_runtime_implementation_of_traits"></a> 2.11。特征的运行时实现</h3>
<div class="sect3">
<h4 id="_implementing_a_trait_at_runtime"><a class="anchor" href="#_implementing_a_trait_at_runtime"></a> 2.11.1。在运行时实现特征</h4>
<div class="paragraph">
<p>Groovy还支持在运行时动态地实现特征。它允许您使用特征“装饰”现有对象。作为示例，让我们从此特征和以下类开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Extra {
    String extra() { "I'm an extra method" }            <i class="conum" data-value="1"></i><b>(1)</b>
}
class Something {                                       <i class="conum" data-value="2"></i><b>(2)</b>
    String doSomething() { 'Something' }                <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Extra</code>特质定义了<code>extra</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Something</code>类<strong>未</strong>实现<code>Extra</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Something</code>只定义一个方法<code>doSomething</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，如果这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something()
s.extra()</code></pre>
</div>
</div>
<div class="paragraph">
<p>额外通话将失败，因为<code>Something</code>没有实施<code>Extra</code> 。可以使用以下语法在运行时执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something() as Extra                        <i class="conum" data-value="1"></i><b>(1)</b>
s.extra()                                               <i class="conum" data-value="2"></i><b>(2)</b>
s.doSomething()                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><strong>在运行时</strong>使用<strong>as</strong>关键字将对象强制为特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后<code>extra</code>可以在对象上调用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>和<code>doSomething</code>仍然可以通话</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将对象强制为特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象实现的特征<strong>和</strong>接口，但结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_multiple_traits_at_once"><a class="anchor" href="#_implementing_multiple_traits_at_once"></a> 2.11.2。一次实现多个特征</h4>
<div class="paragraph">
<p>如果您需要一次实现多个特征，则可以使用<code>withTraits</code>方法而不是<code>as</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     <i class="conum" data-value="1"></i><b>(1)</b>
c.methodFromB()                     <i class="conum" data-value="2"></i><b>(2)</b>
def d = c.withTraits A, B           <i class="conum" data-value="3"></i><b>(3)</b>
d.methodFromA()                     <i class="conum" data-value="4"></i><b>(4)</b>
d.methodFromB()                     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>拨电至<code>methodFromA</code>将会失败，因为<code>C</code>没有实现<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>拨电至<code>methodFromB</code>将会失败，因为<code>C</code>没有实现<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>withTrait</code>将包裹<code>c</code>变成可以实现的东西<code>A</code>和<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>methodFromA</code>现在将通过，因为<code>d</code>贯彻<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>methodFromB</code>现在将通过，因为<code>d</code>也实现<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将一个对象强制为多个特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象所实现的特征<strong>和</strong>接口，但是结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chaining_behavior"><a class="anchor" href="#_chaining_behavior"></a> 2.12。链接行为</h3>
<div class="paragraph">
<p>Groovy支持<em>可堆叠特征</em>的概念。如果当前特征无法处理消息，则想法是将一个特征委托给另一个特征。为了说明这一点，让我们想象一个消息处理程序接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface MessageHandler {
    void on(String message, Map payload)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以通过应用小的行为来组成消息处理程序。例如，让我们以特征形式定义默认处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，任何类都可以通过实现trait来继承默认处理程序的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandler implements DefaultHandler {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果要记录除默认处理程序之外的所有消息，该怎么办？一种选择是编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandlerWithLogging implements DefaultHandler {
    void on(String message, Map payload) {                                  <i class="conum" data-value="1"></i><b>(1)</b>
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        DefaultHandler.super.on(message, payload)                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确实施<code>on</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行记录</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通过委派给<code>DefaultHandler</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这可行，但是这种方法有缺点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>日志记录逻辑绑定到“具体”处理程序</p>
</li>
<li>
<p>我们有一个明确的参考<code>DefaultHandler</code>在里面<code>on</code>方法，这意味着如果我们碰巧更改了类实现的特征，则代码将被破坏</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>作为替代，我们可以编写另一个特征，即仅限于日志记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait LoggingHandler implements MessageHandler {                            <i class="conum" data-value="1"></i><b>(1)</b>
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        super.on(message, payload)                                          <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>日志处理程序本身就是一个处理程序</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打印收到的消息</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>super</code>使其将调用委托给链中的下一个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的班级可以这样重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing test logging with payload [:]
Received test logging with payload [:]</pre>
</div>
</div>
<div class="paragraph">
<p>正如优先规则所暗示的那样<code>LoggerHandler</code>获胜，因为它被声明为最后一个，然后调用<code>on</code>将使用来自<code>LoggingHandler</code> 。但后者呼吁<code>super</code> ，这意味着链中的下一个特征。在这里，下一个特征是<code>DefaultHandler</code>所以<strong>两者都</strong>将被称为：</p>
</div>
<div class="paragraph">
<p>如果我们添加第三个处理程序，该处理程序负责处理以<code>say</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SayHandler implements MessageHandler {
    void on(String message, Map payload) {
        if (message.startsWith("say")) {                                    <i class="conum" data-value="1"></i><b>(1)</b>
            println "I say ${message - 'say'}!"
        } else {
            super.on(message, payload)                                      <i class="conum" data-value="2"></i><b>(2)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理程序特定的前提</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不满足前提条件，则将消息传递给链中的下一个处理程序</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的最终处理程序如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
def h = new Handler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>意思是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息将首先通过日志记录处理程序</p>
</li>
<li>
<p>日志处理程序调用<code>super</code>它将委派给下一个处理程序，即<code>SayHandler</code></p>
</li>
<li>
<p>如果消息以<code>say</code> ，然后处理程序将使用消息</p>
</li>
<li>
<p>如果没有， <code>say</code>处理程序委托给链中的下一个处理程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法非常强大，因为它允许您编写彼此不认识的处理程序，但仍可以按所需顺序将它们组合在一起。例如，如果我们执行代码，它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果我们将日志记录处理程序移动到链中的第二个处理程序，则输出将不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
h = new AlternateHandler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>印刷品：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>原因是现在，因为<code>SayHandler</code>无需呼叫即可使用消息<code>super</code> ，不再调用日志记录处理程序。</p>
</div>
<div class="sect3">
<h4 id="_semantics_of_super_inside_a_trait"><a class="anchor" href="#_semantics_of_super_inside_a_trait"></a> 2.12.1。特征特质的超语义</h4>
<div class="paragraph">
<p>如果一个类实现了多个特征并调用了不合格<code>super</code>找到，然后：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果该类实现了另一个特征，则调用将委托给链中的下一个特征</p>
</li>
<li>
<p>如果连锁店没有任何特征， <code>super</code>指实现类的超类（ <em>this</em> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，由于以下行为，可以修饰最终类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Filtering {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    StringBuilder append(String str) {                  <i class="conum" data-value="2"></i><b>(2)</b>
        def subst = str.replace('o','')                 <i class="conum" data-value="3"></i><b>(3)</b>
        super.append(subst)                             <i class="conum" data-value="4"></i><b>(4)</b>
    }
    String toString() { super.toString() }              <i class="conum" data-value="5"></i><b>(5)</b>
}
def sb = new StringBuilder().withTraits Filtering       <i class="conum" data-value="6"></i><b>(6)</b>
sb.append('Groovy')
assert sb.toString() == 'Grvy'                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个名为<code>Filtering</code> ，应该应用于<code>StringBuilder</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>重新定义<code>append</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>从字符串中删除所有“ o”</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后委托给<code>super</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果<code>toString</code>被称为，委托给<code>super.toString</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>的运行时实现<code>Filtering</code>特质<code>StringBuilder</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>附加的字符串不再包含字母<code>o</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这个例子中，当<code>super.append</code>遇到时，目标对象没有实现其他任何特征，因此被称为原始方法<code>append</code>方法，也就是说从<code>StringBuilder</code> 。相同的技巧用于<code>toString</code> ，以便所生成的代理对象的字符串表示形式委托给<code>toString</code>的<code>StringBuilder</code>实例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_features"><a class="anchor" href="#_advanced_features"></a> 2.13。高级功能</h3>
<div class="sect3">
<h4 id="_sam_type_coercion"><a class="anchor" href="#_sam_type_coercion"></a> 2.13.1。SAM型强制</h4>
<div class="paragraph">
<p>如果一个特征定义了一个抽象方法，则它是SAM（单一抽象方法）类型强制的候选者。例如，想象一下以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    String greet() { "Hello $name" }        <i class="conum" data-value="1"></i><b>(1)</b>
    abstract String getName()               <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>greet</code>方法不是抽象的，而是调用抽象方法<code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>getName</code>是一种抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以来<code>getName</code>是在所述<em>单个抽象方法</em> <code>Greeter</code>特质，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Greeter greeter = { 'Alice' }               <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>关闭“成为”实施<code>getName</code>单一抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>甚至：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void greet(Greeter g) { println g.greet() } <i class="conum" data-value="1"></i><b>(1)</b>
greet { 'Alice' }                           <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>greet方法接受SAM类型Greeter作为参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以直接用闭包调用它</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_differences_with_java_8_default_methods"><a class="anchor" href="#_differences_with_java_8_default_methods"></a> 2.13.2。Java 8默认方法的差异</h4>
<div class="paragraph">
<p>在Java 8中，接口可以具有方法的默认实现。如果一个类实现一个接口并且不提供默认方法的实现，则从该接口中选择实现。特性的行为相同，但有一个主要区别：如果类在其接口列表中声明了该特性， <strong>并且</strong> <strong>即使</strong>超类也没有提供实现，则<strong>始终</strong>使用trait的实现。</p>
</div>
<div class="paragraph">
<p>如果您想覆盖已经实现的方法的行为，可以使用此功能以非常精确的方式来构成行为。</p>
</div>
<div class="paragraph">
<p>为了说明这个概念，让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.test.GroovyTestCase
import groovy.transform.CompileStatic
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

class SomeTest extends GroovyTestCase {
    def config
    def shell

    void setup() {
        config = new CompilerConfiguration()
        shell = new GroovyShell(config)
    }
    void testSomething() {
        assert shell.evaluate('1+1') == 2
    }
    void otherTest() { /* ... */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们创建一个简单的测试用例，该用例使用两个属性（ <em>config</em>和<em>shell</em> ），并在多种测试方法中使用它们。现在，假设您要进行相同的测试，但是要使用另一种不同的编译器配置。一种选择是创建一个子类<code>SomeTest</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以工作，但是如果您实际上有多个测试类，并且想要为所有这些测试类测试新配置怎么办？然后，您将必须为每个测试类创建一个不同的子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class YetAnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您会看到<code>setup</code>两种测试的方法是相同的。然后，该想法是创建一个特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait MyTestSupport {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在子类中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest implements MyTestSupport {}
class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使我们能够大大减少样板代码，并减少在我们决定更改设置代码时忘记更改设置代码的风险。即使<code>setup</code>已在超级类中实现，因为测试类在其接口列表中声明了特征，所以该行为将从特征实现中借用！</p>
</div>
<div class="paragraph">
<p>当您无法访问超类源代码时，此功能特别有用。它可用于模拟方法或在子类中强制方法的特定实现。它使您可以重构代码，以将重写的逻辑保留为单个特征，并仅通过实现它即可继承新行为。当然，另一种选择是在将要使用新代码的<strong>每个</strong>位置覆盖该方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">值得注意的是，如果您使用运行时特征，则特征中的方法<strong>始终</strong>比被代理对象更优选：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                                         <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Bob {
    String getName() { 'Bob' }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Alice')
assert p.name == 'Alice'                                <i class="conum" data-value="3"></i><b>(3)</b>
def p2 = p as Bob                                       <i class="conum" data-value="4"></i><b>(4)</b>
assert p2.name == 'Bob'                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>类定义一个<code>name</code>属性导致<code>getName</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>Bob</code>是定义<code>getName</code>作为返回<code>Bob</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认对象将返回<em>Alice</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>p2</code>胁迫<code>p</code>进入<code>Bob</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>getName</code>返回<em>鲍勃，</em>因为<code>getName</code>取自<strong>特质</strong></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">同样，不要忘记动态特质强制返回一个唯一的对象，该对象仅实现原始接口以及特质。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_differences_with_mixins"><a class="anchor" href="#_differences_with_mixins"></a> 2.14。mixins的差异</h3>
<div class="paragraph">
<p>Mixin在概念上存在一些差异，因为Groovy中提供了它们。请注意，我们在谈论的是运行时混入，而不是@Mixin注释，后者已不赞成使用traits。</p>
</div>
<div class="paragraph">
<p>首先，特征中定义的方法在字节码中可见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在内部，特征表示为一个接口（没有默认或静态方法）和几个帮助程序类</p>
</li>
<li>
<p>这意味着实现特征的对象可以有效地实现<em>接口</em></p>
</li>
<li>
<p>这些方法从Java可见</p>
</li>
<li>
<p>它们与类型检查和静态编译兼容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相反，通过mixin添加的方法仅在运行时可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A { String methodFromA() { 'A' } }        <i class="conum" data-value="1"></i><b>(1)</b>
class B { String methodFromB() { 'B' } }        <i class="conum" data-value="2"></i><b>(2)</b>
A.metaClass.mixin B                             <i class="conum" data-value="3"></i><b>(3)</b>
def o = new A()
assert o.methodFromA() == 'A'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert o.methodFromB() == 'B'                   <i class="conum" data-value="5"></i><b>(5)</b>
assert o instanceof A                           <i class="conum" data-value="6"></i><b>(6)</b>
assert !(o instanceof B)                        <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>A</code>定义<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>B</code>定义<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>混合B到A</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>我们可以打电话<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们也可以打电话<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>该对象是的实例<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>但这<strong>不是</strong>实例<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后一点实际上是非常重要的，它说明了混合环境优于特征的地方： <strong>不</strong>修改实例，因此，如果将某个类别混入另一个类别，则不会生成第三类，并且方法会响应A即使混入，也会继续响应A。</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_methods_properties_and_fields"><a class="anchor" href="#_static_methods_properties_and_fields"></a> 2.15。静态方法，属性和字段</h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">以下说明请注意。静态成员支持正在进行中，仍处于试验阶段。以下信息仅对3.0.0-rc-1有效。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在特征中定义静态方法，但这有很多限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有静态方法的特性不能静态编译或进行类型检查。动态地访问所有静态方法，属性和字段（这是JVM的限制）。</p>
</li>
<li>
<p>静态方法不会出现在每个特征的生成接口中。</p>
</li>
<li>
<p>特质被解释为实现类的<em>模板</em> ，这意味着每个实现类将获得自己的静态方法，属性和字段。因此，在特征上声明的静态成员不属于<code>Trait</code> ，但要实现类。</p>
</li>
<li>
<p>通常，您不应混合使用具有相同签名的静态方法和实例方法。适用特征的常规规则适用（包括多重继承冲突解决）。如果选择的方法是静态的，但是某些实现的特征具有实例变量，则将发生编译错误。如果选择的方法是实例变量，则将忽略静态变量（在这种情况下，其行为类似于Java接口中的静态方法）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait TestHelper {
    public static boolean CALLED = false        <i class="conum" data-value="1"></i><b>(1)</b>
    static void init() {                        <i class="conum" data-value="2"></i><b>(2)</b>
        CALLED = true                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
class Foo implements TestHelper {}
Foo.init()                                      <i class="conum" data-value="4"></i><b>(4)</b>
assert Foo.TestHelper__CALLED                   <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态字段在特征中声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征中也声明了一个静态方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>静态字段<em>在</em>特征中更新</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态方法<em>初始化</em>可供实现类使用</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><em>重新映射</em>了静电场以避免钻石问题</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与往常一样，不建议使用公共字段。无论如何，如果您要这样做，必须了解以下代码将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Foo.CALLED = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为在特征本身上<em>没有</em>定义静态字段<em>CALLED</em> 。同样，如果您有两个不同的实现类，则每个类都有一个不同的静态字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bar implements TestHelper {}              <i class="conum" data-value="1"></i><b>(1)</b>
class Baz implements TestHelper {}              <i class="conum" data-value="2"></i><b>(2)</b>
Bar.init()                                      <i class="conum" data-value="3"></i><b>(3)</b>
assert Bar.TestHelper__CALLED                   <i class="conum" data-value="4"></i><b>(4)</b>
assert !Baz.TestHelper__CALLED                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>Bar</code>实现特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>Baz</code>也实现了特质</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>init</code>仅被调用<code>Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态场<code>CALLED</code>上<code>Bar</code>已更新</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但是静态场<code>CALLED</code>上<code>Baz</code>不是，因为它<strong>与众不同</strong></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_inheritance_of_state_gotchas"><a class="anchor" href="#_inheritance_of_state_gotchas"></a> 2.16。状态陷阱的继承</h3>
<div class="paragraph">
<p>我们已经看到，特质是有状态的。特征可以定义字段或属性，但是当类实现特征时，它将基于每个特征获取这些字段/属性。因此，请考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特质定义两个属性， <code>x</code>和<code>y</code> ， 以及ASA <code>sum</code>方法。现在让我们创建一个实现特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BaseElem implements IntCouple {
    int f() { sum() }
}
def base = new BaseElem()
assert base.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>通话结果<code>f</code>是<code>3</code> ，因为<code>f</code>代表参加<code>sum</code>在特质中，具有状态。但是，如果我们改写这个怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Elem implements IntCouple {
    int x = 3                                       <i class="conum" data-value="1"></i><b>(1)</b>
    int y = 4                                       <i class="conum" data-value="2"></i><b>(2)</b>
    int f() { sum() }                               <i class="conum" data-value="3"></i><b>(3)</b>
}
def elem = new Elem()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>覆盖属性<code>x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖属性<code>y</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼叫<code>sum</code>从特质</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你打电话<code>elem.f()</code> ， 什么是预期的输出？实际上是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert elem.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>原因是<code>sum</code>方法访问特征的<em>字段</em> 。所以它正在使用<code>x</code>和<code>y</code>特征中定义的值。如果要使用实现类中的值，则需要使用getter和setter取消引用字段，如最后一个示例中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_self_types"><a class="anchor" href="#_self_types"></a> 2.17。自我类型</h3>
<div class="sect3">
<h4 id="_type_constraints_on_traits"><a class="anchor" href="#_type_constraints_on_traits"></a> 2.17.1。特征的类型约束</h4>
<div class="paragraph">
<p>有时您会想编写只能应用于某种类型的特征。例如，您可能想要在扩展了您无法控制的另一个类的类上应用特征，并且仍然能够调用这些方法。为了说明这一点，让我们从以下示例开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CommunicationService {
    static void sendMessage(String from, String to, String message) {       <i class="conum" data-value="1"></i><b>(1)</b>
        println "$from sent [$message] to $to"
    }
}

class Device { String id }                                                  <i class="conum" data-value="2"></i><b>(2)</b>

trait Communicating {
    void sendMessage(Device to, String message) {
        CommunicationService.sendMessage(id, to.id, message)                <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

class MyDevice extends Device implements Communicating {}                   <i class="conum" data-value="4"></i><b>(4)</b>

def bob = new MyDevice(id:'Bob')
def alice = new MyDevice(id:'Alice')
bob.sendMessage(alice,'secret')                                             <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一种<code>Service</code>类，超出您的控制范围（在库中，…）定义了一个<code>sendMessage</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>Device</code>类，超出您的控制范围（在图书馆中，...）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>为可以调用服务的设备定义通信特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>定义<code>MyDevice</code>作为通讯设备</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>从特征中调用方法，然后<code>id</code>解决了</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>很明显，在这里<code>Communicating</code>特质只能适用于<code>Device</code> 。但是，由于特质无法扩展类，因此没有明确的约定来表明这一点。但是，代码可以编译并运行得很好，因为<code>id</code>在trait方法中将动态解决。问题是没有什么可以阻止将特征应用于任何<strong>非</strong> <code>Device</code> 。任何具有<code>id</code>会工作，而任何没有<code>id</code>属性将导致运行时错误。</p>
</div>
<div class="paragraph">
<p>如果要启用类型检查或应用，则问题甚至更加复杂<code>@CompileStatic</code>关于特质：因为特质对自己是一个人一无所知<code>Device</code> ，类型检查器会抱怨说找不到<code>id</code>属性。</p>
</div>
<div class="paragraph">
<p>一种可能性是显式添加一个<code>getId</code>特征中的方法，但不能解决所有问题。如果方法需要怎么办<code>this</code>作为参数，实际上要求它是一个<code>Device</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SecurityService {
    static void check(Device d) { if (d.id==null) throw new SecurityException() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想打电话<code>this</code>在特征中，那么您将需要明确地投射<code>this</code>变成一个<code>Device</code> 。显式强制转换为<code>this</code>到处。</p>
</div>
</div>
<div class="sect3">
<h4 id="traits-selftype"><a class="anchor" href="#traits-selftype"></a> 2.17.2。@SelfType批注</h4>
<div class="paragraph">
<p>为了使该合同明确，并使类型检查器知道其<em>自身</em>的<em>类型</em> ，Groovy提供了一个<code>@SelfType</code>注释将：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>让您声明实现此特征的类必须继承或实现的类型</p>
</li>
<li>
<p>如果不满足这些类型约束，则抛出编译时错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，在前面的示例中，我们可以使用<code>@groovy.transform.SelfType</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您尝试在<strong>不是</strong>设备的类上实现此特征，则将发生编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyDevice implements Communicating {} // forgot to extend Device</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'</pre>
</div>
</div>
<div class="paragraph">
<p>总之，自我类型是一种声明对特征的约束的有效方法，而不必直接在特征中声明契约或不必在所有地方使用强制转换，从而将关注点分离保持应有的严格程度。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_limitations"><a class="anchor" href="#_limitations"></a> 2.18。局限性</h3>
<div class="sect3">
<h4 id="_compatibility_with_ast_transformations"><a class="anchor" href="#_compatibility_with_ast_transformations"></a> 2.18.1。与AST转换的兼容性</h4>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">性状与AST转换未正式兼容。其中一些，例如<code>@CompileStatic</code>将应用于特性本身（而不是实现类），而其他特性将同时应用于实现类和特性。绝对不能保证AST转换会像在常规类上一样在特征上运行，因此使用该风险自担！
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_and_postfix_operations"><a class="anchor" href="#_prefix_and_postfix_operations"></a> 2.18.2。前缀和后缀操作</h4>
<div class="paragraph">
<p>在特征中，如果前缀和后缀操作更新了特征的字段，则不允许它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counting {
    int x
    void inc() {
        x++                             <i class="conum" data-value="1"></i><b>(1)</b>
    }
    void dec() {
        --x                             <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
class Counter implements Counting {}
def c = new Counter()
c.inc()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>x</code>在特征中定义，不允许后缀增量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>x</code>在特征中定义，不允许前缀减少</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>解决方法是使用<code>+=</code>运算符。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:03 AEST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>