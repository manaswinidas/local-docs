<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>访客模式</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=5">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>访客模式</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_simple_example">1。简单的例子</a></li>
<li><a href="#_advanced_example">2。进阶范例</a>
<ul class="sectlevel2">
<li><a href="#_why_to_use_this">2.1。为什么要使用这个</a></li>
<li><a href="#_what_happens_if_we_add_a_new_type">2.2。如果添加新类型会怎样？</a></li>
<li><a href="#_what_if_we_want_to_have_different_iteration_patterns">2.3。如果我们想拥有不同的迭代模式怎么办？</a></li>
<li><a href="#_make_it_groovy">2.4。使其时髦</a></li>
<li><a href="#_summary">2.5。摘要</a></li>
</ul>
</li>
<li><a href="#_further_information">3。更多信息</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Visitor_pattern">访客模式</a>是那些众所周知但不经常使用的模式之一。我认为这很奇怪，因为这确实是一件好事。</p>
</div>
<div class="paragraph">
<p>模式的目标是将算法与对象结构分离。这种分离的实际结果是能够在不修改那些对象结构的情况下向现有对象结构添加新操作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_simple_example"><a class="anchor" href="#_simple_example"></a> 1。简单的例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本示例考虑如何计算形状（或形状集合）的边界。我们的首次尝试使用传统的访客模式。不久我们将看到更多的Groovy方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Shape { }

class Rectangle extends Shape {
    def x, y, width, height

    Rectangle(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height
    }

    def union(rect) {
        if (!rect) return this
        def minx = [rect.x, x].min()
        def maxx = [rect.x + width, x + width].max()
        def miny = [rect.y, y].min()
        def maxy = [rect.y + height, y + height].max()
        new Rectangle(minx, miny, maxx - minx, maxy - miny)
    }

    def accept(visitor) {
        visitor.visit_rectangle(this)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2

    Line(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2
    }

    def accept(visitor){
        visitor.visit_line(this)
    }
}

class Group extends Shape {
    def shapes = []
    def add(shape) { shapes += shape }
    def remove(shape) { shapes -= shape }
    def accept(visitor) {
        visitor.visit_group(this)
    }
}

class BoundingRectangleVisitor {
    def bounds

    def visit_rectangle(rectangle) {
        if (bounds)
            bounds = bounds.union(rectangle)
        else
            bounds = rectangle
    }

    def visit_line(line) {
        def line_bounds = new Rectangle(line.x1, line.y1, line.x2-line.y1, line.x2-line.y2)
        if (bounds)
            bounds = bounds.union(line_bounds)
        else
            bounds = line_bounds
    }

    def visit_group(group) {
        group.shapes.each { shape -&gt; shape.accept(this) }
    }
}

def group = new Group()
group.add(new Rectangle(100, 40, 10, 5))
group.add(new Rectangle(100, 70, 10, 5))
group.add(new Line(90, 30, 60, 5))
def visitor = new BoundingRectangleVisitor()
group.accept(visitor)
bounding_box = visitor.bounds
println bounding_box.dump()</code></pre>
</div>
</div>
<div class="paragraph">
<p>那花了很多代码。</p>
</div>
<div class="paragraph">
<p>我们可以通过以下方式使用Groovy闭包来提高代码的清晰度（并将其大小减小一半）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Shape {
    def accept(Closure yield) { yield(this) }
}

class Rectangle extends Shape {
    def x, y, w, h
    def bounds() { this }
    def union(rect) {
        if (!rect) return this
        def minx = [ rect.x, x ].min()
        def maxx = [ rect.x + w, x + w ].max()
        def miny = [ rect.y, y ].min()
        def maxy = [ rect.y + h, y + h ].max()
        new Rectangle(x:minx, y:miny, w:maxx - minx, h:maxy - miny)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2
    def bounds() {
        new Rectangle(x:[x1, x2].min(), y:[y1, y2].min(), w:(x2 - x1).abs(), h:(y2 - y1).abs())
    }
}

class Group {
    def shapes = []
    def leftShift(shape) { shapes += shape }
    def accept(Closure yield) { shapes.each{it.accept(yield)} }
}

def group = new Group()
group &lt;&lt; new Rectangle(x:100, y:40, w:10, h:5)
group &lt;&lt; new Rectangle(x:100, y:70, w:10, h:5)
group &lt;&lt; new Line(x1:90, y1:30, x2:60, y2:5)
def bounds
group.accept{ bounds = it.bounds().union(bounds) }
println bounds.dump()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_example"><a class="anchor" href="#_advanced_example"></a> 2。进阶范例</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType1Counter implements Visitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
    }
    void visit(NodeType2 n2){}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们现在使用<code>NodeType1Counter</code>在这样的树上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">NodeType1 root = new NodeType1()
root.children = new Visitable[2]
root.children[0] = new NodeType1()
root.children[1] = new NodeType2()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们有一个<code>NodeType1</code>对象作为根，其中一个孩子也是<code>NodeType1</code>实例。另一个孩子是<code>NodeType2</code>实例。这意味着使用<code>NodeType1Counter</code>这里应该数2 <code>NodeType1</code>对象。</p>
</div>
<div class="sect2">
<h3 id="_why_to_use_this"><a class="anchor" href="#_why_to_use_this"></a> 2.1。为什么要使用这个</h3>
<div class="paragraph">
<p>如您在这里看到的非常好，我们有一个访客，该访客的状态没有更改对象树。这在不同区域非常有用，例如，您可以让访问者计算所有节点类型，或者使用多少个不同类型，或者您可以使用该节点专用的方法来收集有关树的信息等等。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_happens_if_we_add_a_new_type"><a class="anchor" href="#_what_happens_if_we_add_a_new_type"></a> 2.2。如果添加新类型会怎样？</h3>
<div class="paragraph">
<p>在这种情况下，我们必须做很多工作。.我们必须更改Visitor以接受新类型，我们当然必须编写新类型本身，并且我们必须更改已经实现的每个Visitor。进行很少的更改后，您将修改所有的访问者以扩展访问者的默认实现，因此您无需在每次添加新类型时都更改每个访问者。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_if_we_want_to_have_different_iteration_patterns"><a class="anchor" href="#_what_if_we_want_to_have_different_iteration_patterns"></a> 2.3。如果我们想拥有不同的迭代模式怎么办？</h3>
<div class="paragraph">
<p>那你有问题。由于节点描述了如何进行迭代，因此您没有任何影响，可以立即停止迭代或更改顺序。因此，也许我们应该对此进行一些更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

class DefaultVisitor implements Visitor{
    void visit(NodeType1 n1) {
        for(int i = 0; i &lt; n1.children.length; ++i) {
            n1.children[i].accept(this)
        }
    }
    void visit(NodeType2 n2) {
        for(int i = 0; i &lt; n2.children.length; ++i) {
            n2.children[i].accept(this)
        }
    }
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0];
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行一些小的更改但会产生很大的效果...访问者现在可以递归并告诉我如何进行迭代。节点中的实现被最小化以<code>visitor.visit(this)</code> ， <code>DefaultVisitor</code>现在可以捕获新类型了，我们可以通过不委托给super来停止迭代。当然，现在最大的缺点是它不再是迭代的，但是您不能获得所有的好处。</p>
</div>
</div>
<div class="sect2">
<h3 id="_make_it_groovy"><a class="anchor" href="#_make_it_groovy"></a> 2.4。使其时髦</h3>
<div class="paragraph">
<p>现在的问题是如何使它更具Groovy。你没找到这个吗<code>visitor.visit(this)</code>奇怪？为什么在那儿？答案是模拟双重调度。在Java中，使用了编译时类型，所以当我<code>visitor.visit(children[i])</code>那么编译器将无法找到正确的方法，因为<code>Visitor</code>不包含方法<code>visit(Visitable)</code> 。即使可以，我们也想使用<code>NodeType1</code>要么<code>NodeType2</code> 。</p>
</div>
<div class="paragraph">
<p>现在，Groovy不使用静态类型，Groovy使用运行时类型。这意味着我可以做<code>visitor.visit(children[i])</code>直。嗯..因为我们最小化了accept方法，只做双重调度部分，并且因为Groovy的运行时类型系统已经涵盖了这一点..我们需要accept方法吗？我想你可以猜到我会回答不。但是我们可以做更多。我们的缺点是不知道如何处理未知的树元素。我们必须扩展接口<code>Visitor</code>为此，导致<code>DefaultVisitor</code>然后我们的任务是提供有用的默认值，例如迭代节点或什么都不做。现在，借助Groovy，我们可以通过添加一个<code>visit(Visitable)</code>什么都不做的方法。Java btw中也是如此。</p>
</div>
<div class="paragraph">
<p>但是不要让我们停在这里...我们需要<code>Visitor</code>接口？如果我们没有accept方法，那么我们就不需要<code>Visitor</code>界面。因此，新代码将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultVisitor {
    void visit(NodeType1 n1) {
        n1.children.each { visit(it) }
    }
    void visit(NodeType2 n2) {
        n2.children.each { visit(it) }
    }
    void visit(Visitable v) { }
}

interface Visitable { }

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来我们在这里保存了几行代码。但是我们做了更多。的<code>Visitable</code>节点现在不引用任何<code>Visitor</code>类或接口。对我来说，这是您可以达到的最佳分离水平。但是我们真的需要在这里停下来吗？不，让我们更改<code>Visitable</code>界面，让它返回我们接下来要访问的孩子。这允许我们使用通用的迭代方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultVisitor {
    void visit(Visitable v) {
        doIteraton(v)
    }
    void doIteraton(Visitable v) {
        v.children.each {
            visit(it)
        }
    }
}

interface Visitable {
    Visitable[] getChildren()
}

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultVisitor</code>现在看起来有点不同。我加了一个<code>doIteration</code>方法，它将获取要迭代的子项，然后在每个元素上调用visit。默认情况下，它将调用<code>visit(Visitable)</code>然后遍历这个孩子的孩子。我变了<code>Visitable</code>以确保任何节点都能够返回子代（即使为空）。我不必更改<code>NodeType1</code>和<code>NodeType2</code>类，因为定义子项的方式已经使它们成为属性，这意味着Groovy非常高兴为我们生成get方法。没有真正有趣的部分是<code>NodeType1Counter</code> ，这很有趣，因为我们没有更改它。 <code>super.visit(n1)</code>现在会打电话<code>visit(Visitable)</code>它将调用<code>doIteration</code>这将开始下一阶段的迭代。所以没有变化。但<code>visit(it)</code>将会通知<code>visit(NodeType1)</code>如果是类型<code>NodeType1</code> 。实际上，我们不需要<code>doIteration</code>方法，我们可以这样做<code>visit(Visitable)</code>也可以，但是我认为这个变体更好，因为它允许我们编写新的<code>Visitor</code>覆盖访问（ <code>Visitable</code> ）对于错误情况，这当然意味着我们绝对不能这样做<code>super.visit(n1)</code>但<code>doIteration(n1)</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary"><a class="anchor" href="#_summary"></a> 2.5。摘要</h3>
<div class="paragraph">
<p>最终，我们的代码减少了约40％，一个健壮且稳定的体系结构，并且将Visiter从Visitable中完全删除了。我听说了基于Reflection的访问者实现以获得更通用的版本。好吧，有了这个，您看到确实不需要这样做。如果添加新类型，则无需更改任何内容。据说访问者模式不太适合极端的编程技术，因为您需要一直更改很多类。我想我证明这是因为Java而不是因为模式不好或什么原因。</p>
</div>
<div class="paragraph">
<p>访客模式有多种变体，例如非循环访客模式，试图解决添加带有特殊访客的新节点类型的问题。我不太喜欢，它可以与演员一起使用， <code>ClassCastException</code>和其他讨厌的东西。最后，它试图解决一些Groovy版本甚至无法解决的问题。</p>
</div>
<div class="paragraph">
<p>还有一件事。 <code>NodeType1Counter</code>也可以用Java实现。Groovy将识别访问方法并根据需要调用它们，因为<code>DefaultVisitor</code>仍然是Groovy并尽其所能。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_information"><a class="anchor" href="#_further_information"></a> 3。更多信息</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="http://se.ethz.ch/~meyer/publications/computer/visitor.pdf">组件化：Visitor示例</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:02 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=6">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>