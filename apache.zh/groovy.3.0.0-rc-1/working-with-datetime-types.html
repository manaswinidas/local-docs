<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>处理日期/时间类型</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=2">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>处理日期/时间类型</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_formatting_and_parsing">1。格式化和解析</a></li>
<li><a href="#_manipulating_date_time">2。处理日期/时间</a>
<ul class="sectlevel2">
<li><a href="#_addition_and_subtraction">2.1。加减</a></li>
<li><a href="#_multiplication_and_division">2.2。乘法与除法</a></li>
<li><a href="#_incrementing_and_decrementing">2.3。递增和递减</a></li>
<li><a href="#_negation">2.4。否定</a></li>
</ul>
</li>
<li><a href="#_interacting_with_date_time_values">3。与日期/时间值交互</a>
<ul class="sectlevel2">
<li><a href="#_property_notation">3.1。属性符号</a></li>
<li><a href="#_ranges_code_upto_code_and_code_downto_code">3.2。范围<code>upto</code>和<code>downto</code></a></li>
<li><a href="#_combining_date_time_values">3.3。合并日期/时间值</a></li>
<li><a href="#_creating_periods_and_durations">3.4。创建期间和持续时间</a></li>
</ul>
</li>
<li><a href="#_converting_between_legacy_and_jsr_310_types">4。在旧版和JSR 310类型之间转换</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>的<code>groovy-datetime</code>模块支持使用Java 8中引入的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html">Date / Time API的</a>众多扩展。本文档将此API定义的数据类型称为“ JSR 310类型”。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formatting_and_parsing"><a class="anchor" href="#_formatting_and_parsing"></a> 1。格式化和解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用日期/时间类型的一个常见用例是将它们转换为字符串（格式）和从字符串（解析）。Groovy提供了以下其他格式化方法：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getDateString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDate</code>和<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>DateTimeFormatter.ISO_LOCAL_DATE</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE"><code>DateTimeFormatter.ISO_OFFSET_DATE</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>DateTimeFormatter.ISO_LOCAL_DATE</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getDateTimeString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>DateTimeFormatter.ISO_LOCAL_DATE_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME"><code>DateTimeFormatter.ISO_OFFSET_DATE_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>DateTimeFormatter.ISO_LOCAL_DATE_TIME</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-03-10T20:30:45EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getTimeString()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalTime</code>和<code>LocalDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>DateTimeFormatter.ISO_LOCAL_TIME</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>OffsetTime</code>和<code>OffsetDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME"><code>DateTimeFormatter.ISO_OFFSET_TIME</code></a>格式化程序</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45+04:00</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>ZonedDateTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>DateTimeFormatter.ISO_LOCAL_TIME</code></a>并附加<code>ZoneId</code>简称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20:30:45EST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>format(FormatStyle style)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalTime</code>和<code>OffsetTime</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedTime(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>4:30 AM</code> （带有样式<code>FormatStyle.SHORT</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDate</code> ，格式为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedDate(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Saturday, March 10, 2018</code> （带有样式<code>FormatStyle.FULL</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于<code>LocalDateTime</code> ， <code>OffsetDateTime</code>和<code>ZonedDateTime</code>格式与<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-"><code>DateTimeFormatter.ofLocalizedDateTime(style)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mar 10, 2019 4:30:45 AM</code> （带有样式<code>FormatStyle.MEDIUM</code> ，例如）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>format(String pattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">格式与<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-"><code>DateTimeFormatter.ofPattern(pattern)</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>03/10/2018</code> （例如，使用模式“ MM / dd / yyyy”）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对于解析，Groovy添加了一个静态<code>parse</code>许多JSR 310类型的方法。该方法有两个参数：要格式化的值和要使用的模式。该模式由<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"><code>java.time.format.DateTimeFormatter</code> API</a> 。举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def date = LocalDate.parse('Jun 3, 04', 'MMM d, yy')
assert date == LocalDate.of(2004, Month.JUNE, 3)

def time = LocalTime.parse('4:45', 'H:mm')
assert time == LocalTime.of(4, 45, 0)

def offsetTime = OffsetTime.parse('09:47:51-1234', 'HH:mm:ssZ')
assert offsetTime == OffsetTime.of(9, 47, 51, 0, ZoneOffset.ofHoursMinutes(-12, -34))

def dateTime = ZonedDateTime.parse('2017/07/11 9:47PM Pacific Standard Time', 'yyyy/MM/dd h:mma zzzz')
assert dateTime == ZonedDateTime.of(
        LocalDate.of(2017, 7, 11),
        LocalTime.of(21, 47, 0),
        ZoneId.of('America/Los_Angeles')
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这些<code>parse</code>方法的参数顺序与静态参数的顺序不同<code>parse</code> Groovy添加到的方法<code>java.util.Date</code> 。这样做是为了与现有<code>parse</code>日期/时间API的方法。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_manipulating_date_time"><a class="anchor" href="#_manipulating_date_time"></a> 2。处理日期/时间</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_addition_and_subtraction"><a class="anchor" href="#_addition_and_subtraction"></a> 2.1。加减</h3>
<div class="paragraph">
<p><code>Temporal</code>类型有<code>plus</code>和<code>minus</code>添加或减去提供的方法<code>java.time.temporal.TemporalAmount</code>论点。因为Groovy映射了<code>+</code>和<code>-</code>对于这些名称的单参数方法的运算符，可以使用更自然的表达式语法进行加减。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def nextAprilFools = aprilFools + Period.ofDays(365) // add 365 days
assert nextAprilFools.year == 2019

def idesOfMarch = aprilFools - Period.ofDays(17) // subtract 17 days
assert idesOfMarch.dayOfMonth == 15
assert idesOfMarch.month == Month.MARCH</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy提供了其他功能<code>plus</code>和<code>minus</code>接受整数参数的方法，使以上内容可以更简洁地重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nextAprilFools = aprilFools + 365 // add 365 days
def idesOfMarch = aprilFools - 17 // subtract 17 days</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些整数的单位取决于JSR 310类型的操作数。如上所示，用于<code>ChronoLocalDate</code>像<code>LocalDate</code>有一个<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYShttp://days">天</a>的单位。用于的整数<code>Year</code>和<code>YearMonth</code>分别以<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#YEARS">年</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS">月</a>为单位。所有其他类型的单位均为<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS">秒</a> ，例如<code>LocalTime</code> ， 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def mars = LocalTime.of(12, 34, 56) // 12:34:56 pm

def thirtySecondsToMars = mars - 30 // go back 30 seconds
assert thirtySecondsToMars.second == 26</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiplication_and_division"><a class="anchor" href="#_multiplication_and_division"></a> 2.2。乘法与除法</h3>
<div class="paragraph">
<p>的<code>*</code>运算符可用于相乘<code>Period</code>和<code>Duration</code>实例以整数值表示；的<code>/</code>运算符可用于除法<code>Duration</code>实例以整数值表示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def period = Period.ofMonths(1) * 2 // a 1-month period times 2
assert period.months == 2

def duration = Duration.ofSeconds(10) / 5// a 10-second duration divided by 5
assert duration.seconds == 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_incrementing_and_decrementing"><a class="anchor" href="#_incrementing_and_decrementing"></a> 2.3。递增和递减</h3>
<div class="paragraph">
<p>的<code>++</code>和<code>--</code>运算符可用于将日期/时间值递增和递减一个单位。由于JSR 310类型是不可变的，因此该操作将创建一个具有递增/递减值的新实例，并将其重新分配给引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def year = Year.of(2000)
--year // decrement by one year
assert year.value == 1999

def offsetTime = OffsetTime.of(0, 0, 0, 0, ZoneOffset.UTC) // 00:00:00.000 UTC
offsetTime++ // increment by one second
assert offsetTime.second == 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_negation"><a class="anchor" href="#_negation"></a> 2.4。否定</h3>
<div class="paragraph">
<p>的<code>Duration</code>和<code>Period</code>类型代表时间的正负。这些可以与一元否定<code>-</code>操作员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def duration = Duration.ofSeconds(-15)
def negated = -duration
assert negated.seconds == 15</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interacting_with_date_time_values"><a class="anchor" href="#_interacting_with_date_time_values"></a> 3。与日期/时间值交互</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_property_notation"><a class="anchor" href="#_property_notation"></a> 3.1。属性符号</h3>
<div class="paragraph">
<p>的<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong-java.time.temporal.TemporalField-"><code>getLong(TemporalField)</code></a>的方法<code>TemporalAccessor</code>类型（例如<code>LocalDate</code> ， <code>LocalTime</code> ， <code>ZonedDateTime</code>等）和<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get-java.time.temporal.TemporalUnit-"><code>get(TemporalUnit)</code></a>的方法<code>TemporalAmount</code>类型（即<code>Period</code>和<code>Duration</code> ），可以用Groovy的属性符号来调用。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def date = LocalDate.of(2018, Month.MARCH, 12)
assert date[ChronoField.YEAR] == 2018
assert date[ChronoField.MONTH_OF_YEAR] == Month.MARCH.value
assert date[ChronoField.DAY_OF_MONTH] == 12
assert date[ChronoField.DAY_OF_WEEK] == DayOfWeek.MONDAY.value

def period = Period.ofYears(2).withMonths(4).withDays(6)
assert period[ChronoUnit.YEARS] == 2
assert period[ChronoUnit.MONTHS] == 4
assert period[ChronoUnit.DAYS] == 6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ranges_code_upto_code_and_code_downto_code"><a class="anchor" href="#_ranges_code_upto_code_and_code_downto_code"></a> 3.2。范围<code>upto</code>和<code>downto</code></h3>
<div class="paragraph">
<p>JSR 310类型可以与<a href="core-operators.html#_range_operator">范围运算符</a>一起使用。以下示例在今天与<code>LocalDate</code>从现在开始六天，打印出每个迭代的星期几。由于这两个范围都包含在内，因此将打印一周的所有七天。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
(start..end).each { date -&gt;
    println date.dayOfWeek
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>upto</code>方法将完成与上面示例中的范围相同的操作。的<code>upto</code>方法从早期迭代<code>start</code>以后的价值（含） <code>end</code>值（也包括在内），以增量形式调用闭包<code>next</code>每次迭代一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
start.upto(end) { next -&gt;
    println next.dayOfWeek
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>downto</code>从后面的方法向相反的方向迭代<code>start</code>较早的价值<code>end</code>值。</p>
</div>
<div class="paragraph">
<p>的迭代单位<code>upto</code> ， <code>downto</code> ，范围与加减法的单位相同： <code>LocalDate</code>一次迭代一天， <code>YearMonth</code>迭代一个月， <code>Year</code>一年，其他一切都减少一秒钟。两种方法都支持可选的<code>TemporalUnit</code>更改迭代单位的参数。</p>
</div>
<div class="paragraph">
<p>考虑以下示例，其中使用<a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS">个月</a>的迭代单位将2018年3月1日迭代到2018年3月2日。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def start = LocalDate.of(2018, Month.MARCH, 1)
def end = start + 1 // 1 day later

int iterationCount = 0
start.upto(end, ChronoUnit.MONTHS) { next -&gt;
    println next
    ++iterationCount
}

assert iterationCount == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>自从<code>start</code>日期是包容性的，闭包用<code>next</code>日期值为3月1日。的<code>upto</code>然后将日期增加一个月，得出日期为4月1日。因为此日期<em>晚</em>于指定的日期<code>end</code>从3月2日开始，迭代只停止了一次，立即停止。这种行为对于<code>downto</code>方法，除了迭代将在<code>next</code>变得比目标更早<code>end</code>日期。</p>
</div>
<div class="paragraph">
<p>简而言之，当与<code>upto</code>要么<code>downto</code>使用自定义迭代单位的方法，当前迭代值将永远不会超过最终值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_combining_date_time_values"><a class="anchor" href="#_combining_date_time_values"></a> 3.3。合并日期/时间值</h3>
<div class="paragraph">
<p>左移运算符（ <code><<</code> ）可用于将两种JSR 310类型组合为一个聚合类型。例如，一个<code>LocalDate</code>可以左移到<code>LocalTime</code>生产复合材料<code>LocalDateTime</code>实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">MonthDay monthDay = Month.JUNE &lt;&lt; 3 // June 3rd
LocalDate date = monthDay &lt;&lt; Year.of(2015) // 3-Jun-2015
LocalDateTime dateTime = date &lt;&lt; LocalTime.NOON // 3-Jun-2015 @ 12pm
OffsetDateTime offsetDateTime = dateTime &lt;&lt; ZoneOffset.ofHours(-5) // 3-Jun-2015 @ 12pm UTC-5</code></pre>
</div>
</div>
<div class="paragraph">
<p>左移运算符是反身的；反之亦然。操作数的顺序无关紧要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def year = Year.of(2000)
def month = Month.DECEMBER

YearMonth a = year &lt;&lt; month
YearMonth b = month &lt;&lt; year
assert a == b</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_periods_and_durations"><a class="anchor" href="#_creating_periods_and_durations"></a> 3.4。创建期间和持续时间</h3>
<div class="paragraph">
<p>右移运算符（ <code>>></code> ）产生代表操作数之间周期或持续时间的值。对于<code>ChronoLocalDate</code> ， <code>YearMonth</code>和<code>Year</code> ，运算符产生一个<code>Period</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def newYears = LocalDate.of(2018, Month.JANUARY, 1)
def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def period = newYears &gt;&gt; aprilFools
assert period instanceof Period
assert period.months == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>操作员产生一个<code>Duration</code>对于具有时间意识的JSR类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def duration = LocalTime.NOON &gt;&gt; (LocalTime.NOON + 30)
assert duration instanceof Duration
assert duration.seconds == 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果运算符左侧的值早于右侧的值，则结果为正。如果左侧晚于右侧，则结果为负：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def decade = Year.of(2010) &gt;&gt; Year.of(2000)
assert decade.years == -10</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_converting_between_legacy_and_jsr_310_types"><a class="anchor" href="#_converting_between_legacy_and_jsr_310_types"></a> 4。在旧版和JSR 310类型之间转换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管有缺点<code>Date</code> ， <code>Calendar</code>和<code>TimeZone</code>输入<code>java.util</code>包，它们在Java API（至少在Java 8之前的版本）中很常见。为了适应此类API的使用，Groovy提供了在JSR 310类型和旧式类型之间进行转换的方法。</p>
</div>
<div class="paragraph">
<p>大多数JSR类型都已配备<code>toDate()</code>和<code>toCalendar()</code>转换为相对等价的方法<code>java.util.Date</code>和<code>java.util.Calendar</code>价值观。都<code>ZoneId</code>和<code>ZoneOffset</code>已经给了<code>toTimeZone()</code>转换成<code>java.util.TimeZone</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// LocalDate to java.util.Date
def valentines = LocalDate.of(2018, Month.FEBRUARY, 14)
assert valentines.toDate().format('MMMM dd, yyyy') == 'February 14, 2018'

// LocalTime to java.util.Date
def noon = LocalTime.of(12, 0, 0)
assert noon.toDate().format('HH:mm:ss') == '12:00:00'

// ZoneId to java.util.TimeZone
def newYork = ZoneId.of('America/New_York')
assert newYork.toTimeZone() == TimeZone.getTimeZone('America/New_York')

// ZonedDateTime to java.util.Calendar
def valAtNoonInNY = ZonedDateTime.of(valentines, noon, newYork)
assert valAtNoonInNY.toCalendar().getTimeZone().toZoneId() == newYork</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，转换为旧式时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纳秒级的值被截断为毫秒。一种<code>LocalTime</code> ，例如<code>ChronoUnit.NANOS</code>值999,999,999纳秒转换为999毫秒。</p>
</li>
<li>
<p>转换“本地”类型时（ <code>LocalDate</code> ， <code>LocalTime</code>和<code>LocalDateTime</code> ），返回的时区<code>Date</code>要么<code>Calendar</code>将是系统默认值。</p>
</li>
<li>
<p>转换仅时间类型时（ <code>LocalTime</code>要么<code>OffsetTime</code> ），则是<code>Date</code>要么<code>Calendar</code>设置为当前日期。</p>
</li>
<li>
<p>转换仅日期类型时（ <code>LocalDate</code> ），时间值<code>Date</code>要么<code>Calendar</code>将被清除，即<code>00:00:00.000</code> 。</p>
</li>
<li>
<p>转换时<code>OffsetDateTime</code>到一个<code>Calendar</code> ，只有小时和分钟<code>ZoneOffset</code>传达到相应的<code>TimeZone</code> 。幸运的是，具有非零秒的区域偏移很少见。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy在其中添加了许多方法<code>Date</code>和<code>Calendar</code>用于转换为各种JSR 310类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Date legacy = Date.parse('yyyy-MM-dd HH:mm:ss.SSS', '2010-04-03 10:30:58.999')

assert legacy.toLocalDate() == LocalDate.of(2010, 4, 3)
assert legacy.toLocalTime() == LocalTime.of(10, 30, 58, 999_000_000) // 999M ns = 999ms
assert legacy.toOffsetTime().hour == 10
assert legacy.toYear() == Year.of(2010)
assert legacy.toMonth() == Month.APRIL
assert legacy.toDayOfWeek() == DayOfWeek.SATURDAY
assert legacy.toMonthDay() == MonthDay.of(Month.APRIL, 3)
assert legacy.toYearMonth() == YearMonth.of(2010, Month.APRIL)
assert legacy.toLocalDateTime().year == 2010
assert legacy.toOffsetDateTime().dayOfMonth == 3
assert legacy.toZonedDateTime().zone == ZoneId.systemDefault()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:04 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=3">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>