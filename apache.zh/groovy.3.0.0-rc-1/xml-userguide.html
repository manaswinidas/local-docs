<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>处理XML</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=1">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>处理XML</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_parsing_xml">1。解析XML</a>
<ul class="sectlevel2">
<li><a href="#_xmlparser_and_xmlslurper">1.1。XmlParser和XmlSlurper</a></li>
<li><a href="#_domcategory">1.2。DOMC类别</a></li>
</ul>
</li>
<li><a href="#_gpath">2。GPath</a>
<ul class="sectlevel2">
<li><a href="#_simply_traversing_the_tree">2.1。只需遍历树</a></li>
<li><a href="#_flexible_navigation_with_children_depthfirst_and_breadthfirst">2.2。带有孩子（*），depthFirst（**）和广度优先的灵活导航</a></li>
</ul>
</li>
<li><a href="#_creating_xml">3。创建XML</a>
<ul class="sectlevel2">
<li><a href="#_markupbuilder">3.1。标记生成器</a></li>
<li><a href="#_streamingmarkupbuilder">3.2。StreamingMarkupBuilder</a></li>
<li><a href="#_markupbuilderhelper">3.3。MarkupBuilderHelper</a></li>
<li><a href="#_domtogroovy">3.4。DOMToGroovy</a></li>
</ul>
</li>
<li><a href="#_manipulating_xml">4。处理XML</a>
<ul class="sectlevel2">
<li><a href="#_adding_nodes">4.1。添加节点</a></li>
<li><a href="#_modifying_removing_nodes">4.2。修改/删除节点</a></li>
<li><a href="#_printing_xml">4.3。打印XML</a>
<ul class="sectlevel3">
<li><a href="#_xmlutil">4.3.1。XmlUtil</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_parsing_xml"><a class="anchor" href="#_parsing_xml"></a> 1。解析XML</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_xmlparser_and_xmlslurper"><a class="anchor" href="#_xmlparser_and_xmlslurper"></a> 1.1。XmlParser和XmlSlurper</h3>
<div class="paragraph">
<p>使用Groovy解析XML的最常用方法是使用以下方法之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>groovy.xml.XmlParser</code></p>
</li>
<li>
<p><code>groovy.xml.XmlSlurper</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两者都具有解析XML的相同方法。两者都带有一堆重载的解析方法以及一些特殊方法，例如<code>parseText</code> ，parseFile等。在下一个示例中，我们将使用<code>parseText</code>方法。它解析一个XML <code>String</code>并将其递归转换为对象列表或地图。</p>
</div>
<div class="listingblock">
<div class="title">XmlSlurper</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = '''
    &lt;list&gt;
        &lt;technology&gt;
            &lt;name&gt;Groovy&lt;/name&gt;
        &lt;/technology&gt;
    &lt;/list&gt;
'''

def list = new XmlSlurper().parseText(text) <i class="conum" data-value="1"></i><b>(1)</b>

assert list instanceof groovy.xml.slurpersupport.GPathResult <i class="conum" data-value="2"></i><b>(2)</b>
assert list.technology.name == 'Groovy' <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>解析XML并将根节点作为GPathResult返回</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>检查我们是否使用了GPathResult</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>以GPath样式遍历树</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">XmlParser</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = '''
    &lt;list&gt;
        &lt;technology&gt;
            &lt;name&gt;Groovy&lt;/name&gt;
        &lt;/technology&gt;
    &lt;/list&gt;
'''

def list = new XmlParser().parseText(text) <i class="conum" data-value="1"></i><b>(1)</b>

assert list instanceof groovy.util.Node <i class="conum" data-value="2"></i><b>(2)</b>
assert list.technology.name.text() == 'Groovy' <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>解析XML并将根节点作为节点返回</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>检查我们是否正在使用节点</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>以GPath样式遍历树</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>让我们看看<strong>两者</strong>之间的<strong>相似之处</strong> <code>XMLParser</code>和<code>XMLSlurper</code>第一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>两者都是基于<code>SAX</code>所以它们都是低内存占用</p>
</li>
<li>
<p>两者都可以更新/转换XML</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是它们有关键的<strong>区别</strong> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>XmlSlurper</code>懒惰地评估结构。因此，如果更新xml，则必须再次评估整个树。</p>
</li>
<li>
<p><code>XmlSlurper</code>退货<code>GPathResult</code>解析XML时的实例</p>
</li>
<li>
<p><code>XmlParser</code>退货<code>Node</code>解析XML时的对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>什么时候使用一个或另一个？</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><a href="http://stackoverflow.com/questions/7558019/groovy-xmlslurper-vs-xmlparser">StackOverflow上</a>有一个讨论。此处写的结论部分基于此条目。
</td>
</tr>
</tbody></table>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>如果要将现有文档转换为另一个文档，</strong>则<code>XmlSlurper</code>将是选择</p>
</li>
<li>
<p><strong>如果您想同时更新和阅读，</strong>则<code>XmlParser</code>是选择。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其基本原理是每次您创建带有<code>XmlSlurper</code>在您再次与另一个文档一起解析文档之前，它将不可用<code>XmlSlurper</code>实例。只需要阅读几个节点，XmlSlurper就适合您。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>如果您只需要阅读几个节点</strong> <code>XmlSlurper</code>应该选择，因为它不必在内存中创建完整的结构”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，两个类的执行方式相似。甚至将GPath表达式与它们一起使用的方式都是相同的（两种用法<code>breadthFirst()</code>和<code>depthFirst()</code>表达式）。所以我想这取决于写/读频率。</p>
</div>
</div>
<div class="sect2">
<h3 id="_domcategory"><a class="anchor" href="#_domcategory"></a> 1.2。DOMC类别</h3>
<div class="paragraph">
<p>使用Groovy解析XML文档的另一种方法是使用<code>groovy.xml.dom.DOMCategory</code>这是一个类别类，它将GPath样式操作添加到Java的DOM类中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Java使用代表XML文档各个部分的类对XML的DOM处理提供了内置支持，例如<code>Document</code> ， <code>Element</code> ， <code>NodeList</code> ， <code>Attr</code>有关这些类的更多信息，请参见相应的JavaDocs。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>具有如下所示的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">static def CAR_RECORDS = '''
&lt;records&gt;
  &lt;car name='HSV Maloo' make='Holden' year='2006'&gt;
    &lt;country&gt;Australia&lt;/country&gt;
    &lt;record type='speed'&gt;Production Pickup Truck with speed of 271kph&lt;/record&gt;
  &lt;/car&gt;
  &lt;car name='P50' make='Peel' year='1962'&gt;
    &lt;country&gt;Isle of Man&lt;/country&gt;
    &lt;record type='size'&gt;Smallest Street-Legal Car at 99cm wide and 59 kg in weight&lt;/record&gt;
  &lt;/car&gt;
  &lt;car name='Royale' make='Bugatti' year='1931'&gt;
    &lt;country&gt;France&lt;/country&gt;
    &lt;record type='price'&gt;Most Valuable Car at $15 million&lt;/record&gt;
  &lt;/car&gt;
&lt;/records&gt;
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用解析<code>groovy.xml.DOMBuilder</code>和<code>groovy.xml.dom.DOMCategory</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def reader = new StringReader(CAR_RECORDS)
def doc = DOMBuilder.parse(reader) <i class="conum" data-value="1"></i><b>(1)</b>
def records = doc.documentElement

use(DOMCategory) { <i class="conum" data-value="2"></i><b>(2)</b>
    assert records.car.size() == 3
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>解析XML</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创造<code>DOMCategory</code>范围能够使用辅助方法调用</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpath"><a class="anchor" href="#_gpath"></a> 2。GPath</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Groovy中查询XML的最常见方法是使用<code>GPath</code> ：</p>
</div>
<div class="paragraph">
<p><em>GPath是一种集成到Groovy中的路径表达语言，它可以识别嵌套的结构化数据的一部分。从这个意义上讲，它具有与XPath用于XML相似的目标和范围。使用GPath表达式的两个主要地方是处理嵌套POJO或XML时</em></p>
</div>
<div class="paragraph">
<p>它类似于<a href="http://en.wikipedia.org/wiki/XPath">XPath</a>表达式，不仅可以用于XML，而且可以与POJO类一起使用。例如，您可以指定目标对象或元素的路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a.b.c</code> →对于XML，产生所有<code><c></code>里面的元素<code><b></code>内<code><a></code></p>
</li>
<li>
<p><code>a.b.c</code> →所有POJO，产生<code><c></code>所有的属性<code><b></code>的性质<code><a></code> （类似于JavaBeans中的a.getB（）。getC（））</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于XML，您还可以指定属性，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a["@href"]</code> →所有a元素的href属性</p>
</li>
<li>
<p><code>a.'@href'</code> →表达这一点的另一种方式</p>
</li>
<li>
<p><code>a.@href</code> →使用XmlSlurper时表达它的另一种方式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用一个例子来说明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">static final String books = '''
    &lt;response version-api="2.0"&gt;
        &lt;value&gt;
            &lt;books&gt;
                &lt;book available="20" id="1"&gt;
                    &lt;title&gt;Don Quixote&lt;/title&gt;
                    &lt;author id="1"&gt;Miguel de Cervantes&lt;/author&gt;
                &lt;/book&gt;
                &lt;book available="14" id="2"&gt;
                    &lt;title&gt;Catcher in the Rye&lt;/title&gt;
                   &lt;author id="2"&gt;JD Salinger&lt;/author&gt;
               &lt;/book&gt;
               &lt;book available="13" id="3"&gt;
                   &lt;title&gt;Alice in Wonderland&lt;/title&gt;
                   &lt;author id="3"&gt;Lewis Carroll&lt;/author&gt;
               &lt;/book&gt;
               &lt;book available="5" id="4"&gt;
                   &lt;title&gt;Don Quixote&lt;/title&gt;
                   &lt;author id="4"&gt;Miguel de Cervantes&lt;/author&gt;
               &lt;/book&gt;
           &lt;/books&gt;
       &lt;/value&gt;
    &lt;/response&gt;
'''</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_simply_traversing_the_tree"><a class="anchor" href="#_simply_traversing_the_tree"></a> 2.1。只需遍历树</h3>
<div class="paragraph">
<p>我们可以做的第一件事是使用POJO的表示法获取值。让我们得到第一本书作者的名字</p>
</div>
<div class="listingblock">
<div class="title">获取节点值</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)
def authorResult = response.value.books.book[0].author

assert authorResult.text() == 'Miguel de Cervantes'</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们用<code>XmlSlurper</code>并且我们必须将返回值视为XML文档的根，因此在这种情况下为“响应”。</p>
</div>
<div class="paragraph">
<p>这就是为什么我们从响应开始遍历文档，然后<code>value.books.book[0].author</code> 。注意在<code>XPath</code>节点数组从[1]而不是[0]开始，但是因为<code>GPath</code>是基于Java的，它从索引0开始。</p>
</div>
<div class="paragraph">
<p>最后，我们将获得<code>author</code>节点，因为我们想要该节点内的文本，所以我们应该调用<code>text()</code>方法。的<code>author</code>节点是的实例<code>GPathResult</code>类型和<code>text()</code>一种将字符串的内容提供给我们的方法。</p>
</div>
<div class="paragraph">
<p>使用时<code>GPath</code>与解析的XML <code>XmlSlurper</code>结果是<code>GPathResult</code>宾语。 <code>GPathResult</code>还有许多其他方便的方法可以将节点内的文本转换为任何其他类型，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>toInteger()</code></p>
</li>
<li>
<p><code>toFloat()</code></p>
</li>
<li>
<p><code>toBigInteger()</code></p>
</li>
<li>
<p>......</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有这些方法都尝试将<code>String</code>适当的类型。</p>
</div>
<div class="paragraph">
<p>如果我们使用的是XML <code>XmlParser</code>我们可能正在处理类型的实例<code>Node</code> 。但是所有动作仍然适用于<code>GPathResult</code>在这些示例中，也可以应用于节点。两个解析器的创建者都考虑了<code>GPath</code>兼容性。</p>
</div>
<div class="paragraph">
<p>下一步是从给定节点的属性中获取一些值。在下面的示例中，我们希望获取第一本书的作者ID。我们将使用两种不同的方法。我们先来看一下代码：</p>
</div>
<div class="listingblock">
<div class="title">获取属性的值</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

def book = response.value.books.book[0] <i class="conum" data-value="1"></i><b>(1)</b>
def bookAuthorId1 = book.@id <i class="conum" data-value="2"></i><b>(2)</b>
def bookAuthorId2 = book['@id'] <i class="conum" data-value="3"></i><b>(3)</b>

assert bookAuthorId1 == '1' <i class="conum" data-value="4"></i><b>(4)</b>
assert bookAuthorId1.toInteger() == 1 <i class="conum" data-value="5"></i><b>(5)</b>
assert bookAuthorId1 == bookAuthorId2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获取第一本书节点</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获取书籍的id属性<code>@id</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用获取书的id属性<code>map notation</code> <code>['@id']</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>以字符串形式获取值</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>获取属性的值作为<code>Integer</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，有两种获取属性的符号，</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>直接表示法</em><code>@nameoftheattribute</code></p>
</li>
<li>
<p><em>地图符号</em>使用<code>['@nameoftheattribute']</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>他们两个都同样有效。</p>
</div>
</div>
<div class="sect2">
<h3 id="_flexible_navigation_with_children_depthfirst_and_breadthfirst"><a class="anchor" href="#_flexible_navigation_with_children_depthfirst_and_breadthfirst"></a> 2.2。带有孩子（*），depthFirst（**）和广度优先的灵活导航</h3>
<div class="paragraph">
<p>如果您曾经使用过XPath，则可能使用过以下表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/following-sibling::othernode</code> ：在同一级别中查找节点“ othernode”</p>
</li>
<li>
<p><code>//</code> ：随处可见</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或多或少，我们在GPath中都有对应的快捷方式<code>*</code> （又名<code>children()</code> ）和<code>**</code> （又名<code>depthFirst()</code> ）。</p>
</div>
<div class="paragraph">
<p>第一个示例显示了一个简单的用法<code>*</code> ，仅迭代节点的直接子级。</p>
</div>
<div class="listingblock">
<div class="title">使用*</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

// .'*' could be replaced by .children()
def catcherInTheRye = response.value.books.'*'.find { node -&gt;
    // node.@id == 2 could be expressed as node['@id'] == 2
    node.name() == 'book' &amp;&amp; node.@id == '2'
}

assert catcherInTheRye.title.text() == 'Catcher in the Rye'</code></pre>
</div>
</div>
<div class="paragraph">
<p>该测试搜索与给定条件匹配的“ books”节点的任何子节点。更详细地讲，该表达式表示： <em>在“ books”节点的正下方查找标签名称等于“ book”且ID值为“ 2”的任何节点</em> 。</p>
</div>
<div class="paragraph">
<p>此操作大致对应于<code>breadthFirst()</code>方法，只是它只停止在<strong>一个级别</strong>而不是继续到内部级别。</p>
</div>
<div class="paragraph">
<p>如果我们想寻找给定值而又不必确切知道它在哪里，该怎么办。假设我们只知道作者“ Lewis Carroll”的ID。我们如何才能找到那本书？使用<code>**</code>是解决方案：</p>
</div>
<div class="listingblock">
<div class="title">使用**</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

// .'**' could be replaced by .depthFirst()
def bookId = response.'**'.find { book -&gt;
    book.author.text() == 'Lewis Carroll'
}.@id

assert bookId == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>**</code> <em>从此刻起，</em>就像<em>在树上到处</em>寻找东西一样。在这种情况下，我们使用了<code>find(Closure cl)</code>查找只是第一次出现。</p>
</div>
<div class="paragraph">
<p>如果我们想收集所有书名怎么办？很简单，只需使用<code>findAll</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

def titles = response.'**'.findAll { node -&gt; node.name() == 'title' }*.text()

assert titles.size() == 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>在最后两个示例中， <code>**</code>用作快捷方式<code>depthFirst()</code>方法。从给定节点向下浏览树时，它会沿着树尽可能远地走下去。的<code>breadthFirst()</code>方法将遍历给定级别上的所有节点，然后再遍历到下一个级别。</p>
</div>
<div class="paragraph">
<p>以下示例显示了这两种方法之间的区别：</p>
</div>
<div class="listingblock">
<div class="title">depthFirst（）与.breadthFirst</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)
def nodeName = { node -&gt; node.name() }
def withId2or3 = { node -&gt; node.@id in [2, 3] }

assert ['book', 'author', 'book', 'author'] ==
        response.value.books.depthFirst().findAll(withId2or3).collect(nodeName)
assert ['book', 'book', 'author', 'author'] ==
        response.value.books.breadthFirst().findAll(withId2or3).collect(nodeName)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们搜索id属性值为2或3的任何节点。都有<code>book</code>和<code>author</code>符合该条件的节点。在每种情况下，不同的遍历顺序将找到相同的节点，但以与遍历树的方式相对应的不同顺序查找。</p>
</div>
<div class="paragraph">
<p>再次值得一提的是，有一些有用的方法将节点的值转换为整数，浮点数等。在进行如下比较时，这些方法可能会很方便：</p>
</div>
<div class="listingblock">
<div class="title">帮手</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

def titles = response.value.books.book.findAll { book -&gt;
    /* You can use toInteger() over the GPathResult object */
    book.@id.toInteger() &gt; 2
}*.title

assert titles.size() == 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，数字2已经过硬编码，但可以想象该值可能来自其他任何来源（数据库等）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_xml"><a class="anchor" href="#_creating_xml"></a> 3。创建XML</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用Groovy创建XML的最常用方法是使用构建器，即以下一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>groovy.xml.MarkupBuilder</code></p>
</li>
<li>
<p><code>groovy.xml.StreamingMarkupBuilder</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_markupbuilder"><a class="anchor" href="#_markupbuilder"></a> 3.1。标记生成器</h3>
<div class="paragraph">
<p>这是使用Groovy的MarkupBuilder创建新XML文件的示例：</p>
</div>
<div class="listingblock">
<div class="title">使用MarkupBuilder创建Xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def writer = new StringWriter()
def xml = new MarkupBuilder(writer) <i class="conum" data-value="1"></i><b>(1)</b>

xml.records() { <i class="conum" data-value="2"></i><b>(2)</b>
    car(name: 'HSV Maloo', make: 'Holden', year: 2006) {
        country('Australia')
        record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
    }
    car(name: 'Royale', make: 'Bugatti', year: 1931) {
        country('France')
        record(type: 'price', 'Most Valuable Car at $15 million')
    }
}

def records = new XmlSlurper().parseText(writer.toString()) <i class="conum" data-value="3"></i><b>(3)</b>

assert records.car.first().name.text() == 'HSV Maloo'
assert records.car.last().name.text() == 'Royale'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个实例<code>MarkupBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>开始创建XML树</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个实例<code>XmlSlurper</code>遍历和测试生成的XML</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>让我们再仔细看看：</p>
</div>
<div class="listingblock">
<div class="title">创建XML元素</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlString = "&lt;movie&gt;the godfather&lt;/movie&gt;" <i class="conum" data-value="1"></i><b>(1)</b>

def xmlWriter = new StringWriter() <i class="conum" data-value="2"></i><b>(2)</b>
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie("the godfather") <i class="conum" data-value="3"></i><b>(3)</b>

assert xmlString == xmlWriter.toString() <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们正在创建一个参考字符串以进行比较</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>xmlWriter</code>实例由<code>MarkupBuilder</code>最终将xml表示形式转换为String实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>xmlMarkup.movie(…​)</code>调用将创建一个带有名为的标签的XML节点<code>movie</code>和内容<code>the godfather</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">使用属性创建XML元素</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlString = "&lt;movie id='2'&gt;the godfather&lt;/movie&gt;"

def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie(id: "2", "the godfather") <i class="conum" data-value="1"></i><b>(1)</b>

assert xmlString == xmlWriter.toString()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这次，为了同时创建属性和节点内容，您可以创建任意数量的地图条目，最后添加一个值来设置节点的内容</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该值可以是任何<code>Object</code> ，该值将序列化为其<code>String</code>表示。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">创建XML嵌套元素</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie(id: 2) { <i class="conum" data-value="1"></i><b>(1)</b>
    name("the godfather")
}

def movie = new XmlSlurper().parseText(xmlWriter.toString())

assert movie.@id == 2
assert movie.name.text() == 'the godfather'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>闭包代表给定节点的子元素。请注意，这次我们没有使用String作为属性，而是使用了数字。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有时，您可能想在xml文档中使用特定的名称空间：</p>
</div>
<div class="listingblock">
<div class="title">知道命名空间</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup
        .'x:movies'('xmlns:x': 'http://www.groovy-lang.org') { <i class="conum" data-value="1"></i><b>(1)</b>
    'x:movie'(id: 1, 'the godfather')
    'x:movie'(id: 2, 'ronin')
}

def movies =
        new XmlSlurper() <i class="conum" data-value="2"></i><b>(2)</b>
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.last().@id == 2
assert movies.'x:movie'.last().text() == 'ronin'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建具有给定名称空间的节点<code>xmlns:x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个<code>XmlSlurper</code>注册名称空间以能够测试我们刚刚创建的XML</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>那有一些更有意义的例子呢？我们可能想要生成更多的元素，以在创建XML时具有一些逻辑：</p>
</div>
<div class="listingblock">
<div class="title">混合码</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup
        .'x:movies'('xmlns:x': 'http://www.groovy-lang.org') {
    (1..3).each { n -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        'x:movie'(id: n, "the godfather $n")
        if (n % 2 == 0) { <i class="conum" data-value="2"></i><b>(2)</b>
            'x:movie'(id: n, "the godfather $n (Extended)")
        }
    }
}

def movies =
        new XmlSlurper()
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.size() == 4
assert movies.'x:movie'*.text().every { name -&gt; name.startsWith('the') }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>生成一系列元素</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用条件创建给定元素</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然，可以将构建器的实例作为参数传递来重构/模块化代码：</p>
</div>
<div class="listingblock">
<div class="title">混合码</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

<i class="conum" data-value="1"></i><b>(1)</b>
Closure&lt;MarkupBuilder&gt; buildMovieList = { MarkupBuilder builder -&gt;
    (1..3).each { n -&gt;
        builder.'x:movie'(id: n, "the godfather $n")
        if (n % 2 == 0) {
            builder.'x:movie'(id: n, "the godfather $n (Extended)")
        }
    }

    return builder
}

xmlMarkup.'x:movies'('xmlns:x': 'http://www.groovy-lang.org') {
    buildMovieList(xmlMarkup) <i class="conum" data-value="2"></i><b>(2)</b>
}

def movies =
        new XmlSlurper()
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.size() == 4
assert movies.'x:movie'*.text().every { name -&gt; name.startsWith('the') }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在这种情况下，我们创建了一个Closure来处理电影列表的创建</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>只是使用<code>buildMovieList</code>必要时起作用</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_streamingmarkupbuilder"><a class="anchor" href="#_streamingmarkupbuilder"></a> 3.2。StreamingMarkupBuilder</h3>
<div class="paragraph">
<p>班级<code>groovy.xml.StreamingMarkupBuilder</code>是用于创建XML标记的构建器类。此实现使用<code>groovy.xml.streamingmarkupsupport.StreamingMarkupWriter</code>处理输出。</p>
</div>
<div class="listingblock">
<div class="title">使用StreamingMarkupBuilder</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xml = new StreamingMarkupBuilder().bind { <i class="conum" data-value="1"></i><b>(1)</b>
    records {
        car(name: 'HSV Maloo', make: 'Holden', year: 2006) { <i class="conum" data-value="2"></i><b>(2)</b>
            country('Australia')
            record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
        }
        car(name: 'P50', make: 'Peel', year: 1962) {
            country('Isle of Man')
            record(type: 'size', 'Smallest Street-Legal Car at 99cm wide and 59 kg in weight')
        }
        car(name: 'Royale', make: 'Bugatti', year: 1931) {
            country('France')
            record(type: 'price', 'Most Valuable Car at $15 million')
        }
    }
}

def records = new XmlSlurper().parseText(xml.toString()) <i class="conum" data-value="3"></i><b>(3)</b>

assert records.car.size() == 3
assert records.car.find { it.@name == 'P50' }.country.text() == 'Isle of Man'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意<code>StreamingMarkupBuilder.bind</code>返回一个<code>Writable</code>可用于将标记流式传输到Writer的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们正在捕获一个字符串中的输出，以再次解析它，以检查生成的XML的结构<code>XmlSlurper</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_markupbuilderhelper"><a class="anchor" href="#_markupbuilderhelper"></a> 3.3。MarkupBuilderHelper</h3>
<div class="paragraph">
<p>的<code>groovy.xml.MarkupBuilderHelper</code>顾名思义，它是<code>groovy.xml.MarkupBuilder</code> 。</p>
</div>
<div class="paragraph">
<p>通常可以从类的实例中访问该帮助器<code>groovy.xml.MarkupBuilder</code>或<code>groovy.xml.StreamingMarkupBuilder</code> 。</p>
</div>
<div class="paragraph">
<p>在以下情况下，该帮助程序可能会很方便：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在输出中产生评论</p>
</li>
<li>
<p>在输出中产生XML处理指令</p>
</li>
<li>
<p>在输出中产生XML声明</p>
</li>
<li>
<p>在当前标签的正文中打印数据，以转义XML实体</p>
</li>
<li>
<p>在当前标签的正文中打印数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同时<code>MarkupBuilder</code>和<code>StreamingMarkupBuilder</code>该助手可以通过属性访问<code>mkp</code> ：</p>
</div>
<div class="listingblock">
<div class="title">使用MarkupBuilder的“ mkp”</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter).rules {
    mkp.comment('THIS IS THE MAIN RULE') <i class="conum" data-value="1"></i><b>(1)</b>
    rule(sentence: mkp.yield('3 &gt; n')) <i class="conum" data-value="2"></i><b>(2)</b>
}

<i class="conum" data-value="3"></i><b>(3)</b>
assert xmlWriter.toString().contains('3 &amp;gt; n')
assert xmlWriter.toString().contains('&lt;!-- THIS IS THE MAIN RULE --&gt;')</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>mkp</code>在XML中创建注释</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>mkp</code>产生转义值</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>检查两个假设是否正确</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是另一个示例来说明<code>mkp</code>可从<code>bind</code>使用时的方法范围<code>StreamingMarkupBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="title">使用StreamingMarkupBuilder的“ mkp”</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xml = new StreamingMarkupBuilder().bind {
    records {
        car(name: mkp.yield('3 &lt; 5')) <i class="conum" data-value="1"></i><b>(1)</b>
        car(name: mkp.yieldUnescaped('1 &lt; 3')) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

assert xml.toString().contains('3 &amp;lt; 5')
assert xml.toString().contains('1 &lt; 3')</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果我们想为name属性生成一个转义的值<code>mkp.yield</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>稍后使用检查值<code>XmlSlurper</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_domtogroovy"><a class="anchor" href="#_domtogroovy"></a> 3.4。DOMToGroovy</h3>
<div class="paragraph">
<p>假设我们有一个现有的XML文档，并且想自动生成标记而不必全部输入？我们只需要使用<code>org.codehaus.groovy.tools.xml.DOMToGroovy</code>如下例所示：</p>
</div>
<div class="listingblock">
<div class="title">从DOMToGroovy构建MarkupBuilder</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def songs = """
    &lt;songs&gt;
      &lt;song&gt;
        &lt;title&gt;Here I go&lt;/title&gt;
        &lt;band&gt;Whitesnake&lt;/band&gt;
      &lt;/song&gt;
    &lt;/songs&gt;
"""

def builder =
        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder()

def inputStream = new ByteArrayInputStream(songs.bytes)
def document = builder.parse(inputStream)
def output = new StringWriter()
def converter = new DomToGroovy(new PrintWriter(output)) <i class="conum" data-value="1"></i><b>(1)</b>

converter.print(document) <i class="conum" data-value="2"></i><b>(2)</b>

String xmlRecovered =
        new GroovyShell()
                .evaluate("""
           def writer = new StringWriter()
           def builder = new groovy.xml.MarkupBuilder(writer)
           builder.${output}

           return writer.toString()
        """) <i class="conum" data-value="3"></i><b>(3)</b>

assert new XmlSlurper().parseText(xmlRecovered).song.title.text() == 'Here I go' <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创造<code>DOMToGroovy</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将XML转换为<code>MarkupBuilder</code>输出中可用的呼叫<code>StringWriter</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用<code>output</code>变量来创建整个MarkupBuilder</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>返回XML字串</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_manipulating_xml"><a class="anchor" href="#_manipulating_xml"></a> 4。处理XML</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，您将看到使用以下方法添加/修改/删除节点的不同方法<code>XmlSlurper</code>要么<code>XmlParser</code> 。我们将要处理的xml如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xml = """
&lt;response version-api="2.0"&gt;
    &lt;value&gt;
        &lt;books&gt;
            &lt;book id="2"&gt;
                &lt;title&gt;Don Quixote&lt;/title&gt;
                &lt;author id="1"&gt;Miguel de Cervantes&lt;/author&gt;
            &lt;/book&gt;
        &lt;/books&gt;
    &lt;/value&gt;
&lt;/response&gt;
"""</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_adding_nodes"><a class="anchor" href="#_adding_nodes"></a> 4.1。添加节点</h3>
<div class="paragraph">
<p>之间的主要区别<code>XmlSlurper</code>和<code>XmlParser</code>是，当前者创建节点时，它们将不可用，直到再次对文档进行评估，因此您应该再次解析转换后的文档，以便能够看到新的节点。因此，在选择两种方法中的任何一种时，请记住这一点。</p>
</div>
<div class="paragraph">
<p>如果您需要在创建节点后立即查看它，那么<code>XmlParser</code>应该是您的选择，但是如果您打算对XML进行许多更改并将结果发送到另一个进程，则可能<code>XmlSlurper</code>会更有效率。</p>
</div>
<div class="paragraph">
<p>您不能直接使用<code>XmlSlurper</code>实例，但是你可以<code>XmlParser</code> 。从XmlParser创建新节点的方法是通过其方法<code>createNode(..)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def parser = new XmlParser()
def response = parser.parseText(xml)
def numberOfResults = parser.createNode(
        response,
        new QName("numberOfResults"),
        [:]
)

numberOfResults.value = "1"
assert response.numberOfResults.text() == "1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>createNode()</code>方法接收以下参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>父节点（可以为null）</p>
</li>
<li>
<p>标签的限定名称（在这种情况下，我们仅使用本地部分，而没有任何名称空间）。我们使用的是<code>groovy.namespace.QName</code></p>
</li>
<li>
<p>带有标签属性的地图（在这种情况下，无）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论如何，您通常不会从解析器实例中创建节点，而是从已解析的XML实例中创建节点。那是从<code>Node</code>或一个<code>GPathResult</code>实例。</p>
</div>
<div class="paragraph">
<p>看下一个例子。我们正在解析xml <code>XmlParser</code>然后从解析后的文档实例创建一个新节点（请注意，这里的方法在接收参数方面略有不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def parser = new XmlParser()
def response = parser.parseText(xml)

response.appendNode(
        new QName("numberOfResults"),
        [:],
        "1"
)

response.numberOfResults.text() == "1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用时<code>XmlSlurper</code> ， <code>GPathResult</code>实例没有<code>createNode()</code>方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_modifying_removing_nodes"><a class="anchor" href="#_modifying_removing_nodes"></a> 4.2。修改/删除节点</h3>
<div class="paragraph">
<p>我们知道如何解析文档，添加新节点，现在我想更改给定节点的内容。让我们开始使用<code>XmlParser</code>和<code>Node</code> 。本示例将第一本书的信息更改为另一本书。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlParser().parseText(xml)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode { <i class="conum" data-value="1"></i><b>(1)</b>
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

def newNode = response.value.books.book[0]

assert newNode.name() == "book"
assert newNode.@id == "3"
assert newNode.title.text() == "To Kill a Mockingbird"
assert newNode.author.text() == "Harper Lee"
assert newNode.author.@id.first() == "3"</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用时<code>replaceNode()</code>我们作为参数传递的闭包应该遵循与使用相同的规则<code>groovy.xml.MarkupBuilder</code> ：</p>
</div>
<div class="paragraph">
<p>这是使用相同的示例<code>XmlSlurper</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode {
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

assert response.value.books.book[0].title.text() == "Don Quixote"

/* That mkp is a special namespace used to escape away from the normal building mode
   of the builder and get access to helper markup methods
   'yield', 'pi', 'comment', 'out', 'namespaces', 'xmlDeclaration' and
   'yieldUnescaped' */
def result = new StreamingMarkupBuilder().bind { mkp.yield response }.toString()
def changedResponse = new XmlSlurper().parseText(result)

assert changedResponse.value.books.book[0].title.text() == "To Kill a Mockingbird"</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意如何使用<code>XmlSlurper</code>我们必须再次解析转换后的文档才能找到创建的节点。在这个特定示例中，可能会有些烦人，不是吗？</p>
</div>
<div class="paragraph">
<p>最后，两个解析器还使用相同的方法将新属性添加到给定属性。这次的区别再次是您是否希望新节点立即可用。第一<code>XmlParser</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def parser = new XmlParser()
def response = parser.parseText(xml)

response.@numberOfResults = "1"

assert response.@numberOfResults == "1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>和<code>XmlSlurper</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlSlurper().parseText(books)
response.@numberOfResults = "2"

assert response.@numberOfResults == "2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用时<code>XmlSlurper</code> ，增加一个新的属性<strong>并不</strong>需要执行一个新的评价。</p>
</div>
</div>
<div class="sect2">
<h3 id="_printing_xml"><a class="anchor" href="#_printing_xml"></a> 4.3。打印XML</h3>
<div class="sect3">
<h4 id="_xmlutil"><a class="anchor" href="#_xmlutil"></a> 4.3.1。XmlUtil</h4>
<div class="paragraph">
<p>有时不仅获取给定节点的值，而且获取节点本身也是很有用的（例如，将该节点添加到另一个XML）。</p>
</div>
<div class="paragraph">
<p>为此，您可以使用<code>groovy.xml.XmlUtil</code>类。它有几种静态方法可以从几种类型的源（Node，GPathResult，String ...）序列化xml片段。</p>
</div>
<div class="listingblock">
<div class="title">将节点作为字符串获取</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = new XmlParser().parseText(xml)
def nodeToSerialize = response.'**'.find { it.name() == 'author' }
def nodeAsText = XmlUtil.serialize(nodeToSerialize)

assert nodeAsText ==
        XmlUtil.serialize('&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;author id="1"&gt;Miguel de Cervantes&lt;/author&gt;')</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:00 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=2">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>